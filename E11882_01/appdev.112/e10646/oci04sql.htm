<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using SQL Statements in OCI</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:22Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci03typ.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci05bnd.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/79</span> <!-- End Header -->
<div id="LNOCI040" class="chapter"><a id="g454129"></a> <a id="i443030"></a>
<h1 class="chapter"><span class="secnum">4</span> Using SQL Statements in OCI</h1>
<p>This chapter discusses the concepts and steps involved in processing SQL statements with Oracle Call Interface.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i441651">Overview of SQL Statement Processing</a></p>
</li>
<li>
<p><a href="#i429200">Preparing Statements</a></p>
</li>
<li>
<p><a href="#i420655">Binding Placeholders in OCI</a></p>
</li>
<li>
<p><a href="#i441668">Executing Statements</a></p>
</li>
<li>
<p><a href="#i441217">Describing Select-List Items</a></p>
</li>
<li>
<p><a href="#i448834">Defining Output Variables in OCI</a></p>
</li>
<li>
<p><a href="#i433473">Fetching Results</a></p>
</li>
<li>
<p><a href="#i444930">Using Scrollable Cursors in OCI</a></p>
</li>
</ul>
<a id="i441651"></a>
<div id="LNOCI16337" class="sect1">
<h2 class="sect1">Overview of SQL Statement Processing</h2>
<p><a href="oci02bas.htm#g478150">Chapter 2</a> discussed the basic steps involved in any OCI application. This chapter presents a more detailed look at the specific tasks involved in processing SQL statements in an OCI program.</p>
<p><a id="sthref659"></a>One of the most common tasks of an OCI program is to accept and process SQL statements. This section outlines the specific steps involved in this processing.</p>
<p>Once you have allocated the necessary handles and connected to an Oracle database, follow the steps illustrated in <a href="#i448548">Figure 4-1</a>.</p>
<div id="LNOCI16338" class="figure">
<p class="titleinfigure"><a id="i448548"></a>Figure 4-1 Steps in Processing SQL Statements</p>
<img width="395" height="353" src="img/lnoci020.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref660" href="img_text/lnoci020.htm">Description of "Figure 4-1 Steps in Processing SQL Statements"</a><br />
<br /></div>
<!-- class="figure" -->
<ol>
<li>
<p>Prepare the statement. Define an application request using <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> or <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a>. <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> is an enhanced version of <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> that was introduced to support statement caching.</p>
</li>
<li>
<p>Bind placeholders, if necessary. For DML statements and queries with input variables, perform one or more of the following bind calls to bind the address of each input variable (or PL/SQL output variable) or array to each placeholder in the statement.</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i456224">OCIBindByPos()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i444090">OCIBindObject()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i444015">OCIBindDynamic()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a></p>
</li>
</ul>
</li>
<li>
<p>Execute the statement by calling <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>. For DDL statements, no further steps are necessary.</p>
</li>
<li>
<p>Describe the select-list items, if necessary, using <a href="oci16rel002.htm#i540956">OCIParamGet()</a> and <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a>. This is optional step is not required if the number of select-list items and the attributes of each item (such as its length and data type) are known at compile time.</p>
</li>
<li>
<p>Define output variables, if necessary. For queries, perform one or more define calls to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>, <a href="oci16rel003.htm#i555538">OCIDefineObject()</a>, <a href="oci16rel003.htm#i444226">OCIDefineDynamic()</a>, or <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a> to define an output variable for each select-list item in the SQL statement. Note that you do not use a define call to define the output variables in an anonymous PL/SQL block. You did this when you bound the data.</p>
</li>
<li>
<p>Fetch the results of the query, if necessary, by calling <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a>.</p>
</li>
</ol>
<p>After these steps have been completed, the application can free allocated handles and then detach from the server, or it may process additional statements.</p>
<div class="infobox-note">
<p class="notep1">7.x Upgrade Note:</p>
OCI programs no longer require an explicit parse step. If a statement must be parsed, that step occurs upon execution, meaning that release 8.0 or later applications must issue an execute command for both DML and DDL statements.</div>
<p>The following sections describe each step in detail.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Some variation in the order of steps is possible. For example, it is possible to do the define step before the execute step if the data types and lengths of returned values are known at compile time.</div>
<p>Additional steps beyond those listed earlier may be required if your application must do any of the following:</p>
<ul>
<li>
<p>Initiate and manage multiple transactions</p>
</li>
<li>
<p>Manage multiple threads of execution</p>
</li>
<li>
<p>Perform piecewise inserts, updates, or fetches</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci09adv.htm#i471377">"Statement Caching in OCI"</a></div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i429200"></a>
<div id="LNOCI16339" class="sect1">
<h2 class="sect1">Preparing Statements<a id="sthref661"></a><a id="sthref662"></a></h2>
<p>SQL and PL/SQL statements are prepared for execution by using the statement prepare call and any necessary bind calls. In this phase, the application specifies a SQL or PL/SQL statement and binds associated placeholders in the statement to data for execution. The client-side library allocates storage to maintain the statement prepared for execution.</p>
<p>An application requests a SQL or PL/SQL statement to be prepared for execution using the <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> or <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> call and passes to this call a previously allocated statement handle. This is a completely local call, requiring no round-trip to the server. No association is made between the statement and a particular server at this point.</p>
<p><a id="sthref663"></a>Following the request call, an application can call <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> on the statement handle, passing <code>OCI_ATTR_STMT_TYPE</code> to the <code>attrtype</code> parameter, to determine what type of SQL statement was prepared. The possible attribute values and corresponding statement types are listed in <a href="#CIHEHCEJ">Table 4-1</a>.</p>
<div id="LNOCI16340" class="tblformal">
<p class="titleintable"><a id="sthref664"></a><a id="CIHEHCEJ"></a>Table 4-1 OCI_ATTR_STMT_TYPE Values and Statement Types</p>
<table class="cellalignment1016" title="OCI_ATTR_STMT_TYPE Values and Statement Types" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t5">Attribute Value</th>
<th class="cellalignment1012" id="r1c2-t5">Statement Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_SELECT</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t5 r1c2-t5">
<p><code>SELECT</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_UPDATE</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t5 r1c2-t5">
<p><code>UPDATE</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_DELETE</code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t5 r1c2-t5">
<p><code>DELETE</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_INSERT</code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t5 r1c2-t5">
<p><code>INSERT</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_CREATE</code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t5 r1c2-t5">
<p><code>CREATE</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_DROP</code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t5 r1c2-t5">
<p><code>DROP</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_ALTER</code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t5 r1c2-t5">
<p><code>ALTER</code> statement</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_BEGIN</code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t5 r1c2-t5">
<p><code>BEGIN</code>... (PL/SQL)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t5" headers="r1c1-t5">
<p><code>OCI_STMT_DECLARE</code></p>
</td>
<td class="cellalignment1013" headers="r10c1-t5 r1c2-t5">
<p><code>DECLARE</code>... (PL/SQL)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci02bas.htm#i462916">"Using PL/SQL in an OCI Program"</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#i575217">"OCIStmtPrepare2()"</a> or <a href="oci17msc001.htm#i575144">"OCIStmtPrepare()"</a></p>
</li>
</ul>
</div>
<div id="LNOCI16341" class="sect2"><a id="sthref665"></a>
<h3 class="sect2">Using Prepared Statements on Multiple Servers<a id="sthref666"></a><a id="sthref667"></a></h3>
<p>A prepared application request can be executed on multiple servers at run time by reassociating the statement handle with the respective service context handles for the servers. All information about the current service context and statement handle association is lost when a new association is made.</p>
<p>For example, consider an application such as a network manager, which manages multiple servers. In many cases, it is likely that the same <code>SELECT</code> statement must be executed against multiple servers to retrieve information for display. OCI allows the network manager application to prepare a <code>SELECT</code> statement once and execute it against multiple servers. It must fetch all of the required rows from each server before reassociating the prepared statement with the next server.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a prepared statement must be reexecuted frequently on the same server, it is more efficient to prepare a new statement for another service context.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i420655"></a>
<div id="LNOCI16342" class="sect1">
<h2 class="sect1">Binding Placeholders in OCI<a id="sthref668"></a><a id="sthref669"></a></h2>
<p>Most DML statements, and some queries (such as those with a <code>WHERE</code> clause), require a program to pass data to Oracle Database as part of a SQL or PL/SQL statement. This data can be constant or literal, known when your program is compiled. For example, the following SQL statement, which adds an employee to a database, contains several literals, such as 'BESTRY' and 2365:</p>
<pre>
INSERT INTO emp VALUES
    (2365, 'BESTRY', 'PROGRAMMER', 2000, 20)
</pre>
<p>Coding a statement like this into an application would severely limit its usefulness. You must change the statement and recompile the program each time you add a new employee to the database. To make the program more flexible, you can write the program so that a user can supply input data at run time.</p>
<p>When you prepare a SQL statement or PL/SQL block that contains input data to be supplied at run time, placeholders in the SQL statement or PL/SQL block mark where data must be supplied. For example, the following SQL statement contains five placeholders, indicated by the leading colons (<code>:ename</code>), that show where input data must be supplied by the program.</p>
<pre>
INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno)
</pre>
<p>You can use placeholders for input variables in any <code>DELETE</code>, <code>INSERT</code>, <code>SELECT</code>, or <code>UPDATE</code> statement, or in a PL/SQL block, in any position in the statement where you can use an expression or a literal value. In PL/SQL, placeholders can also be used for output variables.</p>
<p>Placeholders cannot be used to represent other Oracle objects such as tables. For example, the following is <span class="italic">not</span> a valid use of the <code>emp</code> placeholder:</p>
<pre>
INSERT INTO :emp VALUES
    (12345, 'OERTEL', 'WRITER', 50000, 30)
</pre>
<p>For each placeholder in a SQL statement or PL/SQL block, you must call an OCI routine that binds the address of a variable in your program to that placeholder. When the statement executes, the database gets the data that your program placed in the input variables or bind variables and passes it to the server with the SQL statement.</p>
<p>Binding is used for both input and output variables in nonquery operations. In <a href="#CIHHHEFJ">Example 4-1</a>, the variables <code>empno_out</code>, <code>ename_out</code>, <code>job_out</code>, <code>sal_out</code>, and <code>deptno_out</code> should be bound. These are outbinds (as opposed to regular inbinds).</p>
<div id="LNOCI18134" class="example">
<p class="titleinexample"><a id="CIHHHEFJ"></a>Example 4-1 Binding Both Input and Output Variables in Nonquery Operations</p>
<pre>
INSERT INTO emp VALUES
         (:empno, :ename, :job, :sal, :deptno)
      RETURNING
         (empno, ename, job, sal, deptno)
      INTO
         (:empno_out, :ename_out, :job_out, :sal_out, :deptno_out)
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#g453183">Chapter 5</a> for detailed information about implementing bind operations</div>
<div id="LNOCI16343" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref670"></a>
<h3 class="sect2"><a id="sthref671"></a><a id="sthref672"></a>Rules for Placeholders</h3>
<p>The rules for forming placeholders are as follows:</p>
<ul>
<li>
<p>The first character is a colon (":").</p>
</li>
<li>
<p>The colon is followed by a combination of underscore ("_"), A to Z, a to z, or 0 to 9. However, the first character following the colon cannot be an underscore.</p>
</li>
<li>
<p>The letters must be only from the English alphabet, and only the first 30 characters after the colon are significant. The name is case-insensitive.</p>
</li>
<li>
<p>The placeholder can consist of only digits after the colon. If it is only digits, the placeholder must be less than 65536. If the name starts with a digit, then only digits are allowed.</p>
</li>
<li>
<p>The hyphen ("-") is not allowed.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i441668"></a>
<div id="LNOCI16344" class="sect1">
<h2 class="sect1">Executing Statements<a id="sthref673"></a><a id="sthref674"></a></h2>
<p>An OCI application executes prepared statements individually using <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>.</p>
<p>When an OCI application executes a query, it receives from the Oracle database data that matches the query specifications. Within the database, the data is stored in Oracle-defined formats. When the results are returned, the OCI application can request that data be converted to a particular host language format, and stored in a particular output variable or buffer.</p>
<p>For each item in the select list of a query, the OCI application must define an output variable to receive the results of the query. The define step indicates the address of the buffer and the type of the data to be retrieved.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If output variables are defined for a <code>SELECT</code> statement before a call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>, the number of rows specified by the <code>iters</code> parameter are fetched directly into the defined output buffers and additional rows equivalent to the prefetch count are prefetched. If there are no additional rows, then the fetch is complete without calling <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a>.</div>
<p><span class="bold"><a id="sthref675"></a><a id="sthref676"></a><a id="sthref677"></a></span>For nonqueries, the number of times the statement is executed during array operations equals <code>iters - rowoff</code>, where <code>rowoff</code> is the offset in the bound array, and is also a parameter of the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call.</p>
<p>For example, if an array of 10 items is bound to a placeholder for an <code>INSERT</code> statement, and <code>iters</code> is set to 10, all 10 items are inserted in a single execute call when <code>rowoff</code> is zero. If <code>rowoff</code> is set to 2, only 8 items are inserted.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i448834">"Defining Output Variables in OCI"</a></div>
<a id="i430413"></a>
<div id="LNOCI16345" class="sect2">
<h3 class="sect2">Execution Snapshots<a id="sthref678"></a><a id="sthref679"></a></h3>
<p>The <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call provides the ability to ensure that multiple service contexts operate on the same consistent snapshot of the database's committed data. This is achieved by taking the contents of the <code>snap_out</code> parameter of one <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call and passing that value as the <code>snap_in</code> parameter of the next <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Uncommitted data in one service context is <span class="italic">not</span> visible to another context, even when both calls are using the same snapshot.</div>
<p>The data type of both the <code>snap_out</code> and <code>snap_in</code> parameter is <code>OCISnapshot</code>. OCISnapshot is an OCI snapshot descriptor that is allocated with the <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a> function.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#i463442">"OCI Descriptors"</a></div>
<p>It is not necessary to specify a <span class="italic">snapshot</span> when calling <code>OCIStmtExecute()</code>. The following sample code shows a basic execution in which the <code>snapsho</code>t parameters are passed as <code>NULL</code>.</p>
<pre>
checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
          (OCISnapshot *)NULL, (OCISnapshot *) NULL, OCI_DEFAULT));
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>checkerr()</code> function, which is user-developed, evaluates the return code from an OCI application.</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16346" class="sect2"><a id="sthref680"></a>
<h3 class="sect2">Execution Modes of OCIStmtExecute()<a id="sthref681"></a></h3>
<p>You can specify a number of modes for the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call. This section describes the OCIStmtExecute() call. See <a href="oci17msc001.htm#i574897">"OCIStmtExecute()"</a> for other values of the parameter <code>mode</code>.</p>
<a id="i444385"></a>
<div id="LNOCI16347" class="sect3">
<h4 class="sect3">Batch Error Mode<a id="sthref682"></a><a id="sthref683"></a></h4>
<p>OCI provides the ability to perform array DML operations. For example, an application can process an array of <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements with a single statement execution. If one of the operations fails due to an error from the server, such as a unique constraint violation, the array operation terminates, and OCI returns an error. Any rows remaining in the array are ignored. The application must then reexecute the remainder of the array, and go through the whole process again if it encounters more errors, which causes additional round-trips.</p>
<p>To facilitate processing of array DML operations, OCI provides the <span class="italic"><a id="sthref684"></a>batch error mode</span> (also called the <span class="italic"><a id="sthref685"></a>enhanced DML array</span> feature). This mode, which is specified in the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call, simplifies DML array processing if there are one or more errors. In this mode, OCI attempts to insert, update, or delete all rows, and collects information about any errors that occurred. The application can then retrieve error information and reexecute any DML operations that failed during the first call. In this way, all DML operations in the array are attempted in the first call, and any failed operations can be reissued in a second call.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This feature is only available to applications linked with release 8.1 or later OCI libraries running against a release 8.1 or later server. Applications must also be recoded to account for the new program logic described in this section.</div>
<p>This mode is used as follows:</p>
<ol>
<li>
<p>The user specifies <code>OCI_BATCH_ERRORS</code> as the <span class="italic">mode</span> parameter of the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call.</p>
</li>
<li>
<p>After performing an array DML operation with <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>, the application can retrieve the number of errors encountered during the operation by calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> on the statement handle to retrieve the <code>OCI_ATTR_NUM_DML_ERRORS</code> attribute, as shown in <a href="#CIHJJIEJ">Example 4-2</a>.</p>
<div id="LNOCI18135" class="example">
<p class="titleinexample"><a id="CIHJJIEJ"></a>Example 4-2 Calling OCIAttrGet() to Retrieve the Number of Errors Encountered During an Array DML Operation</p>
<pre>
ub4   num_errs;
OCIAttrGet(stmtp, OCI_HTYPE_STMT, &amp;num_errs, 0, OCI_ATTR_NUM_DML_ERRORS,
           errhp);
</pre></div>
<!-- class="example" --></li>
<li>
<p>The application extracts each error using <a href="oci16rel002.htm#i540956">OCIParamGet()</a>, along with its row information, from the error handle that was passed to the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call. To retrieve the information, the application must allocate an additional new error handle for the <a href="oci16rel002.htm#i540956">OCIParamGet()</a> call, populating the new error handle with batched error information. The application obtains the syntax of each error with <a href="oci17msc007.htm#i540516">OCIErrorGet()</a>, and the row offset into the DML array at which the error occurred, by calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> on the new error handle.</p>
<p>For example, after the <code>num_errs</code> amount has been retrieved, the application can issue the following calls shown in <a href="#CIHBABGA">Example 4-3</a>.</p>
<div id="LNOCI18136" class="example">
<p class="titleinexample"><a id="CIHBABGA"></a>Example 4-3 Retrieving Information About Each Error Following an Array DML Operation</p>
<pre>
OCIError errhndl, errhp2;
for (i=0; i&lt;num_errs; i++)
{
   OCIParamGet(errhp, OCI_HTYPE_ERROR, errhp2, (void **)&amp;errhndl, i);
   OCIAttrGet(errhndl, OCI_HTYPE_ERROR, &amp;row_offset, 0,
       OCI_ATTR_DML_ROW_OFFSET, errhp2);
   OCIErrorGet(..., errhndl, ...);
</pre></div>
<!-- class="example" -->
<p>Following this operation, the application can correct the bind information for the appropriate entry in the array using the diagnostic information retrieved from the batched error. Once the appropriate bind buffers are corrected or updated, the application can reexecute the associated DML statements.</p>
<p>Because it cannot be determined at compile time which rows in the first execution may cause errors, the binds for the subsequent DML should be done dynamically by passing in the appropriate buffers at run time. The bind buffers used in the array binds done on the first DML operation can be reused.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="LNOCI16348" class="sect3"><a id="sthref686"></a>
<h4 class="sect3">Example of Batch Error Mode</h4>
<p><a href="#CIHGDAIE">Example 4-4</a> shows an example of how the batch error execution mode might be used. In this example, assume that you have an application that inserts five rows (with two columns, of types <code>NUMBER</code> and <code>CHAR</code>) into a table. Furthermore, assume that only two rows (1 and 3) are successfully inserted in the initial DML operation. The user then proceeds to correct the data (wrong data was being inserted the first time) and to issue an update with the corrected data. The user uses statement handles <code>stmtp1</code> and <code>stmtp2</code> to issue the <code>INSERT</code> and <code>UPDATE</code> statements, respectively.</p>
<div id="LNOCI18137" class="example">
<p class="titleinexample"><a id="CIHGDAIE"></a>Example 4-4 Using Batch Error Execution Mode</p>
<pre>
OCIBind *bindp1[2], *bindp2[2];
ub4 num_errs, row_off[MAXROWS], number[MAXROWS] = {1,2,3,4,5};
char grade[MAXROWS] = {'A','B','C','D','E'};
OCIError *errhp2;
OCIError *errhndl[MAXROWS];
...
/* Array bind all the positions */
OCIBindByPos (stmtp1,&amp;bindp1[0],errhp,1,(void *)&amp;number[0],
     sizeof(number[0]),SQLT_INT,(void *)0, (ub2 *)0,(ub2 *)0,
            0,(ub4 *)0,OCI_DEFAULT);
OCIBindByPos (stmtp1,&amp;bindp1[1],errhp,2,(void *)&amp;grade[0],
     sizeof(grade[0]),SQLT_CHR,(void *)0, (ub2 *)0,(ub2 *)0,0,
            (ub4 *)0,OCI_DEFAULT);
/* execute the array INSERT */
OCIStmtExecute (svchp,stmtp1,errhp,5,0,0,0,OCI_BATCH_ERRORS);
/* get the number of errors. A different error handler errhp2 is used so that
 * the state of errhp is not changed */
OCIAttrGet (stmtp1, OCI_HTYPE_STMT, &amp;num_errs, 0,
            OCI_ATTR_NUM_DML_ERRORS, errhp2);
if (num_errs) {
   /* The user can do one of two things: 1) Allocate as many  */
   /* error handles as number of errors and free all handles  */
   /* at a later time; or 2) Allocate one err handle and reuse */
   /* the same handle for all the errors */
   for (i = 0; i &lt; num_errs; i++) {
      OCIHandleAlloc( (void *)envhp, (void **)&amp;errhndl[i],
      (ub4) OCI_HTYPE_ERROR, 0, (void *) 0);
      OCIParamGet(errhp, OCI_HTYPE_ERROR, errhp2, &amp;errhndl[i], i);
      OCIAttrGet (errhndl[i], OCI_HTYPE_ERROR, &amp;row_off[i], 0,
                  OCI_ATTR_DML_ROW_OFFSET, errhp2);
      /* get server diagnostics */
      OCIErrorGet (..., errhndl[i], ...);
      }
   }
/* make corrections to bind data */
OCIBindByPos (stmtp2,&amp;bindp2[0],errhp,1,(void *)0,sizeof(grade[0]),SQLT_INT,
     (void *)0, (ub2 *)0,(ub2 *)0,0,(ub4 *)0,OCI_DATA_AT_EXEC);
OCIBindByPos (stmtp2,&amp;bindp2[1],errhp,2,(void *)0,sizeof(number[0]),SQLT_DAT,
     (void *)0, (ub2 *)0,(ub2 *)0,0,(ub4 *)0,OCI_DATA_AT_EXEC);
/* register the callback for each bind handle, row_off and position
 * information can be passed to the callback function by means of context
 * pointers.
 */
OCIBindDynamic (bindp2[0],errhp,ctxp1,my_callback,0,0);
OCIBindDynamic (bindp2[1],errhp,ctxp2,my_callback,0,0);
/* execute the UPDATE statement */
OCIStmtExecute (svchp,stmtp2,errhp,num_errs,0,0,0,OCI_BATCH_ERRORS);
...
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHGDAIE">Example 4-4</a>, <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> is used with a callback because the user does not know at compile time what rows may return with errors. With a callback, you can simply pass the erroneous row numbers, stored in <code>row_off</code>, through the callback context and send only those rows that must be updated or corrected. The same bind buffers can be shared between the <code>INSERT</code> and the <code>UPDATE</code> statement executions.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i441217"></a>
<div id="LNOCI16349" class="sect1">
<h2 class="sect1">Describing Select-List Items<a id="sthref687"></a><a id="sthref688"></a></h2>
<p>If your OCI application is processing a query, you may need to obtain more information about the items in the select list. This is particularly true for dynamic queries whose contents are not known until run time. In this case, the program may need to obtain information about the data types and column lengths of the select-list items. This information is necessary to define output variables that may receive query results.</p>
<p>For example, consider a query where the program has no prior information about the columns in the <code>employees</code> table:</p>
<pre>
SELECT * FROM employees
</pre>
<p>There are two types of describes available: implicit and explicit.</p>
<p>An <a id="sthref689"></a><a id="sthref690"></a><span class="italic">implicit describe</span> does not require any special calls to retrieve describe information from the server, although special calls <span class="italic">are</span> necessary to access the information. An implicit describe allows an application to obtain select-list information as an attribute of the statement handle <span class="italic">after a statement has been executed</span> without making a specific describe call. It is called <span class="italic">implicit</span> because no describe call is required. The describe information comes <span class="italic">free</span> with the statement execution.</p>
<p>An <a id="sthref691"></a><a id="sthref692"></a><span class="italic">explicit describe</span> requires the application to call a particular function to bring the describe information from the server. An application may describe a select list (query) either implicitly or explicitly. Other schema elements must be described explicitly.</p>
<p>You can describe a query explicitly before execution by specifying <code>OCI_DESCRIBE_ONLY</code> as the mode of <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>, which does not execute the statement, but returns the select-list description. For performance reasons, Oracle recommends that applications use the implicit describe, which comes <span class="italic">free</span> with a standard statement execution.</p>
<p>An explicit describe with the <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> call obtains information about schema objects rather than select lists.</p>
<p>In all cases, the specific information about columns and data types is retrieved by reading handle attributes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci06des.htm#g464132">Chapter 6</a> for information about using <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> to obtain metadata pertaining to schema objects</div>
<div id="LNOCI16350" class="sect2"><a id="sthref693"></a>
<h3 class="sect2">Implicit Describe<a id="sthref694"></a><a id="sthref695"></a><a id="sthref696"></a></h3>
<p>After a SQL statement is executed, information about the select list is available as an attribute of the statement handle. No explicit describe call is needed.</p>
<p>To retrieve information about multiple select-list items, an application can call <a href="oci16rel002.htm#i540956">OCIParamGet()</a> with the <span class="italic">pos</span> parameter set to 1 the first time, and then iterate the value of <span class="italic">pos</span> and repeat the <a href="oci16rel002.htm#i540956">OCIParamGet()</a> call until <code>OCI_ERROR</code> with <code>ORA-24334</code> is returned. An application could also specify any position <span class="italic">n</span> to get a column at random.</p>
<p>Once a parameter descriptor has been allocated for a position in the select list, the application can retrieve specific information by calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> on the parameter descriptor. Information available from the parameter descriptor includes the data type and maximum size of the parameter.</p>
<p>The sample code in <a href="#CIHHFJJE">Example 4-5</a><a href="#CIHHFJJE">Implicit Describe - Select List Is Available as an Attribute of the Statement Handle</a> shows a loop that retrieves the column names and data types corresponding to a query following query execution. The query was associated with the statement handle by a prior call to <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> or <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a>.</p>
<div id="LNOCI18138" class="example">
<p class="titleinexample"><a id="CIHHFJJE"></a>Example 4-5 Implicit Describe - Select List Is Available as an Attribute of the Statement Handle</p>
<pre>
...
OCIParam     *mypard = (OCIParam *) 0;
ub2          dtype;
text         *col_name;
ub4          counter, col_name_len, char_semantics;
ub2          col_width;
sb4          parm_status;

text *sqlstmt = (text *)"SELECT * FROM employees WHERE employee_id = 100";

checkerr(errhp, OCIStmtPrepare(stmthp, errhp, (OraText *)sqlstmt,
                    (ub4)strlen((char *)sqlstmt),
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));

checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, 0, 0, (OCISnapshot *)0, (OCISnapshot *)0, OCI_DEFAULT));

/* Request a parameter descriptor for position 1 in the select list */
counter = 1;
parm_status = OCIParamGet((void *)stmthp, OCI_HTYPE_STMT, errhp,
               (void **)&amp;mypard, (ub4) counter);

/* Loop only if a descriptor was successfully retrieved for
   current position, starting at 1 */

while (parm_status == OCI_SUCCESS) {
   /* Retrieve the data type attribute */
   checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
           (void*) &amp;dtype,(ub4 *) 0, (ub4) OCI_ATTR_DATA_TYPE,
           (OCIError *) errhp  ));

   /* Retrieve the column name attribute */
   col_name_len = 0;
   checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
           (void**) &amp;col_name, (ub4 *) &amp;col_name_len, (ub4) OCI_ATTR_NAME,
           (OCIError *) errhp ));

   /* Retrieve the length semantics for the column */
   char_semantics = 0;
   checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
           (void*) &amp;char_semantics,(ub4 *) 0, (ub4) OCI_ATTR_CHAR_USED,
           (OCIError *) errhp  ));
   col_width = 0;
   if (char_semantics)
       /* Retrieve the column width in characters */
       checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
               (void*) &amp;col_width, (ub4 *) 0, (ub4) OCI_ATTR_CHAR_SIZE,
               (OCIError *) errhp  ));
   else
       /* Retrieve the column width in bytes */
       checkerr(errhp, OCIAttrGet((void*) mypard, (ub4) OCI_DTYPE_PARAM,
               (void*) &amp;col_width,(ub4 *) 0, (ub4) OCI_ATTR_DATA_SIZE,
               (OCIError *) errhp  ));

   /* increment counter and get next descriptor, if there is one */
   counter++;
   parm_status = OCIParamGet((void *)stmthp, OCI_HTYPE_STMT, errhp,
          (void **)&amp;mypard, (ub4) counter);
} /* while */
...
</pre></div>
<!-- class="example" -->
<p>The <code>checkerr()</code> function in <a href="#CIHHFJJE">Example 4-5</a> is used for error handling. The complete listing can be found in the first sample application in <a href="ociabdem.htm#g462659">Appendix B</a>.</p>
<p>The calls to <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> and <a href="oci16rel002.htm#i540956">OCIParamGet()</a> are local calls that do not require a network round-trip, because all of the select-list information is cached on the client side after the statement is executed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel002.htm#i540956">"OCIParamGet()"</a></p>
</li>
<li>
<p><a href="oci16rel002.htm#i493114">"OCIArrayDescriptorAlloc()"</a></p>
</li>
<li>
<p><a href="oci06des.htm#i440535">"Parameter Attributes"</a> for a list of the specific attributes of the parameter descriptor that may be read by <a href="oci16rel002.htm#i493114">OCIArrayDescriptorAlloc()</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16351" class="sect2"><a id="sthref697"></a>
<h3 class="sect2">Explicit Describe of Queries<a id="sthref698"></a><a id="sthref699"></a></h3>
<p>You can describe a query explicitly before execution by specifying <code>OCI_DESCRIBE_ONLY</code> as the mode of <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>; this does not execute the statement, but returns the select-list description.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To maximize performance, Oracle recommends that applications execute the statement in default mode and use the implicit describe that accompanies the execution.</div>
<p>The code in <a href="#CIHCGFEE">Example 4-6</a> demonstrates the use of explicit describe in a select list to return information about columns.</p>
<div id="LNOCI18139" class="example">
<p class="titleinexample"><a id="CIHCGFEE"></a>Example 4-6 Explicit Describe - Returning the Select-List Description for Each Column</p>
<pre>
...
int i = 0;
ub4 numcols = 0;
ub2 type = 0;
OCIParam *colhd = (OCIParam *) 0;   /* column handle */

text *sqlstmt = (text *)"SELECT * FROM employees WHERE employee_id = 100";

checkerr(errhp, OCIStmtPrepare(stmthp, errhp, (OraText *)sqlstmt,
                    (ub4)strlen((char *)sqlstmt),
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));

/* initialize svchp, stmhp, errhp, rowoff, iters, snap_in, snap_out */
/* set the execution mode to OCI_DESCRIBE_ONLY. Note that setting the mode to
OCI_DEFAULT does an implicit describe of the statement in addition to executing
the statement */

checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, 0, 0,
        (OCISnapshot *) 0, (OCISnapshot *) 0, OCI_DESCRIBE_ONLY));

/* Get the number of columns in the query */
checkerr(errhp, OCIAttrGet((void *)stmthp, OCI_HTYPE_STMT, (void *)&amp;numcols,
                      (ub4 *)0, OCI_ATTR_PARAM_COUNT, errhp));

/* go through the column list and retrieve the data type of each column.
Start from pos = 1 */
for (i = 1; i &lt;= numcols; i++)
{
  /* get parameter for column i */
  checkerr(errhp, OCIParamGet((void *)stmthp, OCI_HTYPE_STMT, errhp, (void **)&amp;colhd, i));

  /* get data-type of column i */
  type = 0;
  checkerr(errhp, OCIAttrGet((void *)colhd, OCI_DTYPE_PARAM,
          (void *)&amp;type, (ub4 *)0, OCI_ATTR_DATA_TYPE, errhp));
}
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i448834"></a>
<div id="LNOCI16352" class="sect1">
<h2 class="sect1">Defining Output Variables in OCI<a id="sthref700"></a><a id="sthref701"></a></h2>
<p>Query statements return data from the database to your application. When processing a query, you must define an output variable or an array of output variables for each item in the select list from which to retrieve data. The define step creates an association that determines where returned results are stored, and in what format.</p>
<p>For example, to process the following statement you would normally define two output variables: one to receive the value returned from the <code>name</code> column, and one to receive the value returned from the <code>ssn</code> column:</p>
<pre>
SELECT name, ssn FROM employees
    WHERE empno = :empnum
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#g453183">Chapter 5, "Binding and Defining in OCI"</a></div>
</div>
<!-- class="sect1" -->
<a id="i433473"></a>
<div id="LNOCI16353" class="sect1">
<h2 class="sect1">Fetching Results<a id="sthref702"></a><a id="sthref703"></a></h2>
<p>If an OCI application has processed a query, it is typically necessary to fetch the results with <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> after the statement has completed execution. The <code>OCIStmtFetch2()</code> function supports <span class="italic">scrollable cursors</span>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i444930">"Using Scrollable Cursors in OCI"</a></div>
<p>Fetched data is retrieved into output variables that have been specified by define operations.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If output variables are defined for a <code>SELECT</code> statement before a call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>, the number of rows specified by the <code>iters</code> parameter is fetched directly into the defined output buffers</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>These statements mentioned previously fetch data associated with the sample code in <a href="oci05bnd.htm#i423689">"Steps Used in OCI Defining"</a>. See that example for more information.</p>
</li>
<li>
<p><a href="oci05bnd.htm#i421494">"Overview of Defining in OCI"</a> for information about defining output variables</p>
</li>
</ul>
</div>
<div id="LNOCI16354" class="sect2"><a id="sthref704"></a>
<h3 class="sect2">Fetching LOB Data<a id="sthref705"></a><a id="sthref706"></a></h3>
<p>If LOB columns or attributes are part of a select list, they can be returned as LOB locators or actual LOB values, depending on how you define them. If LOB locators are fetched, then the application can perform further operations on these locators through the <code>OCILobXXX</code> functions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci07lob.htm#g452677">Chapter 7</a> for more information about working with LOB locators in OCI</p>
</li>
<li>
<p><a href="oci05bnd.htm#i435612">"Defining LOB Output Variables"</a> for usage and examples of selecting LOB data without the use of locators</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i429698"></a>
<div id="LNOCI16355" class="sect2">
<h3 class="sect2">Setting Prefetch Count<a id="sthref707"></a><a id="sthref708"></a><a id="sthref709"></a></h3>
<p>To minimize server round-trips and optimize performance, OCI can prefetch result set rows when executing a query. You can customize this prefetching by setting either the <code>OCI_ATTR_PREFETCH_ROWS</code> or <code>OCI_ATTR_PREFETCH_MEMORY</code> attribute of the statement handle using the <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> function. These attributes are used as follows:</p>
<ul>
<li>
<p><code><a id="sthref710"></a>OCI_ATTR_PREFETCH_ROWS</code> sets the number of rows to be prefetched. If it is not set, then the default value is 1. If the <code>iters</code> parameter of <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> is 0 and prefetching is enabled, the rows are buffered during calls to <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a>. The prefetch value can be altered after execution and between fetches.</p>
</li>
<li>
<p><code><a id="sthref711"></a>OCI_ATTR_PREFETCH_MEMORY</code> sets the memory allocated for rows to be prefetched. The application then fetches as many rows as can fit into that much memory.</p>
</li>
</ul>
<p>When both of these attributes are set, OCI prefetches rows up to the <code>OCI_ATTR_PREFETCH_ROWS</code> limit unless the <code>OCI_ATTR_PREFETCH_MEMORY</code> limit is reached, in which case OCI returns as many rows as can fit in a buffer of size <code>OCI_ATTR_PREFETCH_MEMORY</code>.</p>
<p>By default, prefetching is turned on, and OCI fetches one extra row, except when prefetching cannot be supported for a query (see the note that follows). To turn prefetching off, set both the <code>OCI_ATTR_PREFETCH_ROWS</code> and <code>OCI_ATTR_PREFETCH_MEMORY</code> attributes to zero.</p>
<p>If both <code>OCI_ATTR_PREFETCH_ROWS</code> and <code>OCI_ATTR_PREFETCH_MEMORY</code> attributes are explicitly set, OCI uses the tighter of the two constraints to determine the number of rows to prefetch.</p>
<p>To prefetch exclusively based on the memory constraint, set the <code>OCI_ATTR_PREFETCH_MEMORY</code> attribute and be sure to disable the <code>OCI_ATTR_PREFETCH_ROWS</code> attribute by setting it to zero (to override the default setting of 1 row).</p>
<p>To prefetch exclusively based on the number of rows constraint, set the <code>OCI_ATTR_PREFETCH_ROWS</code> attribute and disable the <code>OCI_ATTR_PREFETCH_MEMORY</code> attribute by setting it to zero (if it was ever explicitly set to a non-zero value).</p>
<p>Prefetching is possible for <code>REF CURSOR</code>s and nested cursor columns. By default, prefetching is not turned on for <code>REF CURSOR</code>s. To turn on prefetching for <code>REF CURSOR</code>s, set the <code>OCI_ATTR_PREFETCH_ROWS</code> or <code>OCI_ATTR_PREFETCH_MEMORY</code> attribute before fetching rows from the <code>REF CURSOR</code>. When a <code>REF CURSOR</code> is passed multiple times between an OCI application and PL/SQL and fetches on the <code>REF CURSOR</code> are done in OCI and in PL/SQL, the rows prefetched by OCI (if enabled) cause the application to behave as if out-of-order rows are being fetched in PL/SQL. In such situations, OCI prefetch should not be enabled on <code>REF CURSOR</code>s.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prefetching is not in effect if <code>LONG</code>, LOB or Opaque Type columns (such as <code>XMLType</code>) are part of the query.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428664">"Statement Handle Attributes"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i444930"></a>
<div id="LNOCI16356" class="sect1">
<h2 class="sect1"><a id="sthref712"></a>Using Scrollable Cursors in OCI</h2>
<p>A cursor is a current position in a <a id="sthref713"></a><span class="italic">result set</span>. Execution of a cursor puts the results of the query into a set of rows called the result set that can be fetched either sequentially or nonsequentially. In the latter case, the cursor is known as a <span class="italic">scrollable cursor.</span></p>
<p>A scrollable cursor supports forward and backward access into the result set from a given position, by using either absolute or relative row number offsets into the result set.</p>
<p>Rows are numbered starting at one. For a scrollable cursor, you can fetch previously fetched rows, the nth row in the result set, or the nth row from the current position. Client-side caching of either the partial or entire result set improves performance by limiting calls to the server.</p>
<p>Oracle Database does not support DML operations on scrollable cursors. A cursor cannot be made scrollable if the <code>LONG</code> data type is part of the select list.</p>
<p>Moreover, fetches from a scrollable statement handle are based on the snapshot at execution time. OCI client prefetching works with OCI scrollable cursors. The size of the client prefetch cache can be controlled by the existing OCI attributes <code>OCI_ATTR_PREFETCH_ROWS</code> and <code>OCI_ATTR_PREFETCH_MEMORY</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use scrollable cursors unless you require their functionality, because they use more server resources and can have greater response times than nonscrollable cursors.</div>
<p>The <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call has an execution mode for scrollable cursors, <code><a id="sthref714"></a>OCI_STMT_SCROLLABLE_READONLY</code>. The default for statement handles is nonscrollable, forward sequential access only, where the mode is <code>OCI_FETCH_NEXT</code>. You must set this execution mode each time the statement handle is executed.</p>
<p>The statement handle attribute <a id="sthref715"></a><code>OCI_ATTR_CURRENT_POSITION</code> can be retrieved only by using <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a>. This attribute cannot be set by the application; it indicates the current position in the result set.</p>
<p>For nonscrollable cursors, <a id="sthref716"></a><code>OCI_ATTR_ROW_COUNT</code> is the total number of rows fetched into the user buffers with the <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> calls since this statement handle was executed. Because nonscrollable cursors are forward sequential only, <code>OCI_ATTR_ROW_COUNT</code> also represents the highest row number detected by the application.</p>
<p>For scrollable cursors, <a id="sthref717"></a><code>OCI_ATTR_ROW_COUNT</code> represents the maximum (absolute) row number fetched into the user buffers. Because the application can arbitrarily position the fetches, this does not have to be the total number of rows fetched into the user's buffers since the (scrollable) statement was executed.</p>
<p>The attribute <a id="sthref718"></a><code>OCI_ATTR_ROWS_FETCHED</code> on the statement handle represents the number of rows that were successfully fetched into the user's buffers in the last fetch call or execute. It works for both scrollable and nonscrollable cursors.</p>
<p>Use the <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> call, instead of the <code>OCIStmtFetch()</code> call, which is retained for backward compatibility. You are encouraged to use <code><a id="sthref719"></a></code><a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> for all new applications, even those not using scrollable cursors. This call also works for nonscrollable cursors, but can raise an error if any other orientation besides <code>OCI_DEFAULT</code> or <code>OCI_FETCH_NEXT</code> is passed.</p>
<p>Scrollable cursors are supported for remote mapped queries. Transparent application failover (TAF) is supported for scrollable cursors.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you call <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> with the <code>nrows</code> parameter set to 0, the cursor is canceled.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc001.htm#i575019">"OCIStmtFetch2()"</a></p>
</li>
<li>
<p><a href="#i429698">"Setting Prefetch Count"</a></p>
</li>
</ul>
</div>
<div id="LNOCI16357" class="sect2"><a id="sthref720"></a>
<h3 class="sect2">Increasing Scrollable Cursor Performance<a id="sthref721"></a></h3>
<p>Response time is improved if you use OCI client-side prefetch buffers. After calling <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> for a scrollable cursor, call <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> using <code>OCI_FETCH_LAST</code> to obtain the size of the result set. Then set <code>OCI_ATTR_PREFETCH_ROWS</code> to about 20% of that size, and set <code>OCI_PREFETCH_MEMORY</code> if the result set uses a large amount of memory.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16358" class="sect2"><a id="sthref722"></a>
<h3 class="sect2"><a id="sthref723"></a>Example of Access on a Scrollable Cursor</h3>
<p>Assume that a result set is returned by the following SQL query, and that the table <code>EMP</code> has 14 rows:</p>
<pre>
SELECT empno, ename FROM emp
</pre>
<p>One use of scrollable cursors is shown in <a href="#CIHBFFEB">Example 4-7</a>.</p>
<div id="LNOCI18140" class="example">
<p class="titleinexample"><a id="CIHBFFEB"></a>Example 4-7 Access on a Scrollable Cursor</p>
<pre>
...
/* execute the scrollable cursor in the scrollable mode */
OCIStmtExecute(svchp, stmthp, errhp, (ub4)0, (ub4)0, (CONST OCISnapshot *)NULL,
               (OCISnapshot *) NULL, OCI_STMT_SCROLLABLE_READONLY ); 
                                  
/* Fetches rows with absolute row numbers 6, 7, 8. After this call,
 OCI_ATTR_CURRENT_POSITION = 8, OCI_ATTR_ROW_COUNT = 8 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 3, 
                               OCI_FETCH_ABSOLUTE, (sb4) 6, OCI_DEFAULT);
                               
/* Fetches rows with absolute row numbers 6, 7, 8. After this call,
 OCI_ATTR_CURRENT_POSITION = 8, OCI_ATTR_ROW_COUNT = 8 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 3, 
                               OCI_FETCH_RELATIVE, (sb4) -2, OCI_DEFAULT);
                               
/* Fetches rows with absolute row numbers 14. After this call,
 OCI_ATTR_CURRENT_POSITION = 14, OCI_ATTR_ROW_COUNT = 14 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 1, 
                               OCI_FETCH_LAST, (sb4) 0, OCI_DEFAULT);

/* Fetches rows with absolute row number 1. After this call,
 OCI_ATTR_CURRENT_POSITION = 1, OCI_ATTR_ROW_COUNT = 14 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 1, 
                               OCI_FETCH_FIRST, (sb4) 0, OCI_DEFAULT);

/* Fetches rows with absolute row numbers 2, 3, 4. After this call,
 OCI_ATTR_CURRENT_POSITION = 4, OCI_ATTR_ROW_COUNT = 14 */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 3, 
                               OCI_FETCH_NEXT, (sb4) 0, OCI_DEFAULT);

/* Fetches rows with absolute row numbers 3,4,5,6,7. After this call,
 OCI_ATTR_CURRENT_POSITION = 7, OCI_ATTR_ROW_COUNT = 14. It is assumed 
the user's define memory is allocated. */
checkprint(errhp, OCIStmtFetch2(stmthp, errhp, (ub4) 5, 
                               OCI_FETCH_PRIOR, (sb4) 0, OCI_DEFAULT);
...
}
checkprint (errhp, status)
{
 ub4 rows_fetched;
/* This checks for any OCI errors before printing the results of the fetch call
   in the define buffers */
 checkerr (errhp, status);
 checkerr(errhp, OCIAttrGet((CONST void *) stmthp, OCI_HTYPE_STMT,
         (void *) &amp;rows_fetched, (uint *) 0, OCI_ATTR_ROWS_FETCHED, errhp));
}
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci03typ.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci05bnd.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
