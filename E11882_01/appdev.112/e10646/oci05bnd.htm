<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Binding and Defining in OCI</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:22Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci04sql.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci06des.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/79</span> <!-- End Header -->
<div id="LNOCI050" class="chapter"><a id="g453183"></a> <a id="i427075"></a>
<h1 class="chapter"><span class="secnum">5</span> Binding and Defining in OCI</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i436225">Overview of Binding in OCI</a></p>
</li>
<li>
<p><a href="#i421489">Advanced Bind Operations in OCI</a></p>
</li>
<li>
<p><a href="#i421494">Overview of Defining in OCI</a></p>
</li>
<li>
<p><a href="#i421090">Advanced Define Operations in OCI</a></p>
</li>
<li>
<p><a href="#i421503">Binding and Defining Arrays of Structures in OCI</a></p>
</li>
<li>
<p><a href="#BABGDJDD">Binding and Defining Multiple Buffers</a></p>
</li>
<li>
<p><a href="#i423484">DML with a RETURNING Clause in OCI</a></p>
</li>
<li>
<p><a href="#i422770">Character Conversion in OCI Binding and Defining</a></p>
</li>
<li>
<p><a href="#i423493">PL/SQL REF CURSORs and Nested Tables in OCI</a></p>
</li>
<li>
<p><a href="#i427753">Runtime Data Allocation and Piecewise Operations in OCI</a></p>
</li>
</ul>
<a id="i436225"></a>
<div id="LNOCI16359" class="sect1">
<h2 class="sect1">Overview of Binding in OCI<a id="sthref724"></a><a id="sthref725"></a></h2>
<p>This chapter expands on the basic concepts of binding and defining, and provides more detailed information about the different types of binds and defines you can use in OCI applications. Additionally, this chapter discusses the use of arrays of structures, and other issues involved in binding, defining, and character conversions.</p>
<p>For example, given the <code>INSERT</code> statement:</p>
<pre>
INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno)
</pre>
<p>Then given the following variable declarations:</p>
<pre>
text     *ename, *job;
sword    empno, sal, deptno;
</pre>
<p><a id="sthref726"></a>the bind step makes an association between the placeholder name and the address of the program variables. The bind also indicates the data type and length of the program variables, as illustrated in <a href="#i423597">Figure 5-1</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i421804">"Steps Used in OCI Binding"</a> for the code that implements this example</div>
<div id="LNOCI16360" class="figure">
<p class="titleinfigure"><a id="i423597"></a>Figure 5-1 Using OCIBindByName() to Associate Placeholders with Program Variables</p>
<img width="652" height="206" src="img/lnoci021.gif" alt="Description of Figure 5-1 follows" /><br />
<a id="sthref727" href="img_text/lnoci021.htm">Description of "Figure 5-1 Using OCIBindByName() to Associate Placeholders with Program Variables"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If you change only the value of a bind variable, it is not necessary to rebind it to execute the statement again. Because the bind is by reference, as long as the address of the variable and handle remain valid, you can reexecute a statement that references the variable without rebinding.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
At the interface level, all bind variables are considered at least <code>IN</code> and must be properly initialized. If the variable is a pure <code>OUT</code> bind variable, you can set the variable to 0. You can also provide a <code>NULL</code> indicator and set that indicator to -1 (<code>NULL</code>).<a id="sthref728"></a></div>
<p>In the Oracle database, data types have been implemented for named data types, <code>REF</code>s and LOBs, and they can be bound as placeholders in a SQL statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For opaque data types (descriptors or locators) whose sizes are not known, pass the address of the descriptor or locator pointer. Set the size parameter to the size of the appropriate data structure, (<code>sizeof(structure)</code>).</div>
<a id="i421775"></a>
<div id="LNOCI16361" class="sect2">
<h3 class="sect2">Named Binds and Positional Binds<a id="sthref729"></a><a id="sthref730"></a></h3>
<p>The SQL statement in <a href="#i423597">Figure 5-1</a> is an example of a <span class="italic">named bind</span>. Each placeholder in the statement has a name associated with it, such as 'ename' or 'sal'. When this statement is prepared and the placeholders are associated with values in the application, the association is made by the name of the placeholder using the <a href="oci16rel003.htm#i456223">OCIBindByName()</a> call with the name of the placeholder passed in the <span class="italic">placeholder</span> parameter.</p>
<p>A second type of bind is known as a <span class="italic">positional bind</span>. In a positional bind, the placeholders are referred to by their position in the statement rather than by their names. For binding purposes, an association is made between an input value and the position of the placeholder, using the <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> call.</p>
<p>To use the previous example for a positional bind:</p>
<pre>
INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno)
</pre>
<p>The five placeholders are then each bound by calling <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> and passing the position number of the placeholder in the <code>position</code> parameter. For example, the <code>:empno</code> placeholder would be bound by calling <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> with a position of 1, <code>:ename</code> with a position of 2, and so on.</p>
<p>In a duplicate bind, only a single bind call may be necessary. Consider the following SQL statement, which queries the database for employees whose commission and salary are both greater than a given amount:</p>
<pre>
SELECT empno FROM emp
    WHERE sal &gt; :some_value
    AND comm &gt; :some_value
</pre>
<p>An OCI application could complete the binds for this statement with a single call to <a href="oci16rel003.htm#i456223">OCIBindByName()</a> to bind the <code>:some_value</code> placeholder by name. In this case, all bind placeholders for <code>:some_value</code> get assigned the same value as provided by the <a href="oci16rel003.htm#i456223">OCIBindByName()</a> call.</p>
<p>Now consider the case where a 6th placeholder is added that is a duplicate. For example, add <code>:ename</code> as the 6th placeholder in the first previous example:</p>
<pre>
INSERT INTO emp VALUES
    (:empno, :ename, :job, :sal, :deptno, :ename)
</pre>
<p>If you are using the <a href="oci16rel003.htm#i456223">OCIBindByName()</a> call, just one bind call suffices to bind both occurrences of the <code>:ename</code> placeholder. All occurrences of <code>:ename</code> in the statement will get bound to the same value. Moreover, if new bind placeholders get added as a result of which bind positions for existing bind placeholders change, you do not need to change your existing bind calls in order to update bind positions. This is a distinct advantage in using the <a href="oci16rel003.htm#i456223">OCIBindByName()</a> call if your program evolves to add more bind variables in your statement text.</p>
<p>If you are using the <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> call, however, you have increased flexibility in terms of binding duplicate bind-parameters separately, if you need it. You have the option of binding any of the duplicate occurrences of a bind parameter separately. Any unbound duplicate occurrences of a parameter inherit the value from the first occurrence of the bind parameter with the same name. The first occurrence must be explicitly bound.</p>
<p>In the context of SQL statements, the position <span class="italic">n</span> indicates the bind parameter at the <span class="italic">n</span>th position. However, in the context of PL/SQL statements, <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> has a different interpretation for the position parameter: the position <span class="italic">n</span> in the bind call indicates a binding for the <span class="italic">n</span>th unique parameter name in the statement when scanned left to right.</p>
<p>Using the previous example again and the same SQL statement text, if you want to bind the 6th position separately, the <code>:ename</code> placeholder would be bound by calling <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> with a position of 6. Otherwise, if left unbound, <code>:ename</code> would inherit the value from the first occurrence of the bind parameter with the same name, in this case, from <code>:ename</code> in position 2.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16362" class="sect2"><a id="sthref731"></a>
<h3 class="sect2">OCI Array Interface<a id="sthref732"></a></h3>
<p>You can pass data to the Oracle database in various ways.</p>
<p>You can execute a SQL statement repeatedly using the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> routine and supply different input values on each iteration.</p>
<p>You can use the Oracle array interface and input many values with a single statement and a single call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>. In this case, you bind an array to an input placeholder, and the entire array can be passed at the same time, under the control of the <span class="italic">iters</span> parameter.</p>
<p>The array interface significantly reduces round-trips to the database when you are updating or inserting a large volume of data. This reduction can lead to considerable performance gains in a busy client/server environment. For example, consider an application that inserts 10 rows into the database. Calling <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> 10 times with single values results in 10 network round-trips to insert all the data. The same result is possible with a single call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> using an input array, which involves only one network round-trip.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use the OCI array interface to perform inserts, row triggers in the database are fired as each row is inserted.
<p><a id="sthref733"></a>The maximum number of rows allowed in an array DML statement is 4 billion -1 (3,999,999,999).</p>
</div>
</div>
<!-- class="sect2" -->
<a id="i421871"></a>
<div id="LNOCI16363" class="sect2">
<h3 class="sect2">Binding Placeholders in PL/SQL<a id="sthref734"></a></h3>
<p>You process a PL/SQL block by placing the block in a string variable, binding any variables, and then executing the statement containing the block, just as you would with a single SQL statement.</p>
<p>When you bind placeholders in a PL/SQL block to program variables, you must use <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> to perform the basic binds for host variables that are either scalars or arrays.</p>
<p>The following short PL/SQL block contains two placeholders, which represent <code>IN</code> parameters to a procedure that updates an employee's salary, when given the employee number and the new salary amount:</p>
<pre>
char plsql_statement[] = "BEGIN\
                          RAISE_SALARY(:emp_number, :new_sal);\
                          END;" ;
</pre>
<p>These placeholders can be bound to input variables in the same way as placeholders in a SQL statement.</p>
<p>When processing PL/SQL statements, output variables are also associated with program variables by using bind calls.</p>
<p>For example, consider the following PL/SQL block:</p>
<pre>
BEGIN
    SELECT ename,sal,comm INTO :emp_name, :salary, :commission
    FROM emp
    WHERE empno = :emp_number;
END;
</pre>
<p>In this block, you would use <a href="oci16rel003.htm#i456223">OCIBindByName()</a> to bind variables in place of the <code>:emp_name</code>, <code>:salary</code>, and <code>:commission</code> output placeholders, and in place of the input placeholder <code>:emp_number</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
All <a id="sthref735"></a>buffers, even pure <code>OUT</code> buffers, must be initialized by setting the buffer length to zero in the bind call, or by setting the corresponding indicator to -1.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci12oty.htm#i437227">"Information for Named Data Type and REF Binds"</a> for more information about binding PL/SQL placeholders</div>
</div>
<!-- class="sect2" -->
<a id="i421804"></a>
<div id="LNOCI16364" class="sect2">
<h3 class="sect2">Steps Used in OCI Binding<a id="sthref736"></a></h3>
<p>Placeholders are bound in several steps. For a simple scalar or array bind, it is only necessary to specify an association between the placeholder and the data, by using <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>.</p>
<p>Once the bind is complete, the OCI library detects where to find the input data or where to put the PL/SQL output data when the SQL statement is executed. Program input data does not need to be in the program variable when it is bound to the placeholder, but the data must be there when the statement is executed.</p>
<p><a id="sthref737"></a>The following code example in <a href="#CIHEIIBF">Example 5-1</a> shows handle allocation and binding for each placeholder in a SQL statement.</p>
<div id="LNOCI18141" class="example">
<p class="titleinexample"><a id="CIHEIIBF"></a>Example 5-1 Handle Allocation and Binding for Each Placeholder in a SQL Statement</p>
<pre>
...
/* The SQL statement, associated with stmthp (the statement handle)
by calling OCIStmtPrepare() */
text *insert = (text *) "INSERT INTO emp(empno, ename, job, sal, deptno)\
    VALUES (:empno, :ename, :job, :sal, :deptno)";
...

/*  Bind the placeholders in the SQL statement, one per bind handle. */
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd1p, errhp, (text *) ":ENAME",
    strlen(":ENAME"), (ub1 *) ename, enamelen+1, SQLT_STR, (void *) 0,
    (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd2p, errhp, (text *) ":JOB",
    strlen(":JOB"), (ub1 *) job, joblen+1, SQLT_STR, (void *)
    &amp;job_ind, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd3p, errhp, (text *) ":SAL",
    strlen(":SAL"), (ub1 *) &amp;sal, (sword) sizeof(sal), SQLT_INT,
    (void *) &amp;sal_ind, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0,
    OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd4p, errhp, (text *) ":DEPTNO",
    strlen(":DEPTNO"), (ub1 *) &amp;deptno,(sword) sizeof(deptno), SQLT_INT,
    (void *) 0, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));
checkerr(errhp, OCIBindByName(stmthp, &amp;bnd5p, errhp, (text *) ":EMPNO",
    strlen(":EMPNO"), (ub1 *) &amp;empno, (sword) sizeof(empno), SQLT_INT,
    (void *) 0, (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0,OCI_DEFAULT));
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>checkerr()</code> function evaluates the return code from an OCI application. The code for the function is in the Example for <a href="oci17msc007.htm#i540516">"OCIErrorGet()"</a>.</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16365" class="sect2"><a id="sthref738"></a>
<h3 class="sect2">PL/SQL Block in an OCI Program<a id="sthref739"></a></h3>
<p>Perhaps the most common use for PL/SQL blocks in OCI is to call stored procedures or stored functions. Assume that there is a procedure named <code>RAISE_SALARY</code> stored in the database, and you embed a call to that procedure in an anonymous PL/SQL block, and then process the PL/SQL block.</p>
<p>The following program fragment shows how to embed a stored procedure call in an OCI application. The program passes an employee number and a salary increase as inputs to a stored procedure called <code>raise_salary</code>:</p>
<pre>
raise_salary (employee_num IN, sal_increase IN, new_salary OUT);
</pre>
<p>This procedure raises a given employee's salary by a given amount. The increased salary that results is returned in the stored procedure's variable, <code>new_salary</code>, and the program displays this value.</p>
<p>Note that the PL/SQL procedure argument, <code>new_salary</code>, although a PL/SQL OUT variable, must be bound, not defined. This is explained in <a href="#CIHEIHBE">Defining PL/SQL Output Variables</a> and in <a href="oci12oty.htm#i437290">Information for Named Data Type and REF Defines, and PL/SQL OUT Binds</a>.</p>
<p><a href="#CIHEBECF">Example 5-2</a> demonstrates how to perform a simple scalar bind where only a single bind call is necessary. In some cases, additional bind calls are needed to define attributes for specific bind data types or execution modes.</p>
<div id="LNOCI18142" class="example">
<p class="titleinexample"><a id="CIHEBECF"></a>Example 5-2 Defining a PL/SQL Statement to Be Used in OCI</p>
<pre>
/* Define PL/SQL statement to be used in program. */
text *give_raise = (text *) "BEGIN\
                  RAISE_SALARY(:emp_number,:sal_increase, :new_salary);\
                     END;";
OCIBind  *bnd1p = NULL;                      /* the first bind handle */
OCIBind  *bnd2p = NULL;                     /* the second bind handle */
OCIBind  *bnd3p = NULL;                      /* the third bind handle */

static void checkerr();
sb4 status;

main()
{
  sword    empno, raise, new_sal;
  void     *tmp;
  OCISession *usrhp = (OCISession *)NULL; 
...
/* attach to Oracle database, and perform necessary initializations
and authorizations */
...
      /* allocate a statement handle */
  checkerr(errhp, OCIHandleAlloc( (void *) envhp, (void **) &amp;stmthp,
           OCI_HTYPE_STMT, 100, (void **) &amp;tmp));

      /* prepare the statement request, passing the PL/SQL text
        block as the statement to be prepared */
checkerr(errhp, OCIStmtPrepare(stmthp, errhp, (text *) give_raise, (ub4) 
      strlen(give_raise), OCI_NTV_SYNTAX, OCI_DEFAULT));

      /* bind each of the placeholders to a program variable */
 checkerr( errhp, OCIBindByName(stmthp, &amp;bnd1p, errhp, (text *) ":emp_number",
             -1, (ub1 *) &amp;empno,
            (sword) sizeof(empno), SQLT_INT, (void *) 0,
             (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));

 checkerr( errhp, OCIBindByName(stmthp, &amp;bnd2p, errhp, (text *) ":sal_increase",
             -1, (ub1 *) &amp;raise,
             (sword) sizeof(raise), SQLT_INT, (void *) 0,
             (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));

      /* remember that PL/SQL OUT variables are bound, not defined */

checkerr( errhp, OCIBindByName(stmthp, &amp;bnd3p, errhp, (text *) ":new_salary",
             -1, (ub1 *) &amp;new_sal,
             (sword) sizeof(new_sal), SQLT_INT, (void *) 0,
             (ub2 *) 0, (ub2) 0, (ub4) 0, (ub4 *) 0, OCI_DEFAULT));

      /* prompt the user for input values */
printf("Enter the employee number: ");
scanf("%d", &amp;empno); 
      /* flush the input buffer */
myfflush();

printf("Enter employee's raise: ");
scanf("%d", &amp;raise);
      /* flush the input buffer */
myfflush();

  /* execute PL/SQL block*/
  checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0, 
      (OCISnapshot *) NULL, (OCISnapshot *) NULL, OCI_DEFAULT));

  /* display the new salary, following the raise */
printf("The new salary is %d\n", new_sal);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421489"></a>
<div id="LNOCI16366" class="sect1">
<h2 class="sect1">Advanced Bind Operations in OCI</h2>
<p><a href="oci04sql.htm#i420655">"Binding Placeholders in OCI"</a> discussed how a basic bind operation is performed to create an association between a placeholder in a SQL statement and a program variable by using <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>. This section covers more advanced bind operations, including multistep binds, and binds of named data types and <code>REFs</code>.</p>
<p>In some cases, additional bind calls are necessary to define specific attributes for certain bind data types or certain execution modes.</p>
<p>The following sections describe these special cases, and the information about binding is summarized in <a href="#CIHJBEEH">Table 5-1</a>.<span class="bold"><a id="sthref740"></a></span></p>
<div id="LNOCI16367" class="tblformalwide">
<p class="titleintable"><a id="sthref741"></a><a id="CIHJBEEH"></a>Table 5-1 Information Summary for Bind Types</p>
<table class="cellalignment1011" title="Information Summary for Bind Types" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t10">Type of Bind</th>
<th class="cellalignment1012" id="r1c2-t10">Bind Data Type</th>
<th class="cellalignment1012" id="r1c3-t10">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t10" headers="r1c1-t10">
<p>Scalar</p>
</td>
<td class="cellalignment1013" headers="r2c1-t10 r1c2-t10">
<p>Any scalar data type</p>
</td>
<td class="cellalignment1013" headers="r2c1-t10 r1c3-t10">
<p>Bind a single scalar using <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a><span class="italic">.</span></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t10" headers="r1c1-t10">
<p>Array of scalars</p>
</td>
<td class="cellalignment1013" headers="r3c1-t10 r1c2-t10">
<p>Any scalar data type</p>
</td>
<td class="cellalignment1013" headers="r3c1-t10 r1c3-t10">
<p>Bind an array of scalars using <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a><span class="italic">.</span></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t10" headers="r1c1-t10">
<p>Named data type</p>
</td>
<td class="cellalignment1013" headers="r4c1-t10 r1c2-t10">
<p><code>SQLT_NTY</code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t10 r1c3-t10">
<p>Two bind calls are required:</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i444090">OCIBindObject()</a></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t10" headers="r1c1-t10">
<p><code>REF</code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t10 r1c2-t10">
<p><code>SQLT_REF</code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t10 r1c3-t10">
<p>Two bind calls are required:</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i444090">OCIBindObject()</a></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t10" headers="r1c1-t10">
<p>LOB</p>
<p><code>BFILE</code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t10 r1c2-t10">
<p><code>SQLT_BLOB</code></p>
<p><code>SQLT_CLOB</code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t10 r1c3-t10">
<p>Allocate the LOB locator using <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a>, and then bind its address, <code>OCILobLocator</code> <code>**</code>, with <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>, by using one of the LOB data types.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t10" headers="r1c1-t10">
<p>Array of structures or static arrays</p>
</td>
<td class="cellalignment1013" headers="r7c1-t10 r1c2-t10">
<p>Varies</p>
</td>
<td class="cellalignment1013" headers="r7c1-t10 r1c3-t10">
<p>Two bind calls are required:</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a></p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t10" headers="r1c1-t10">
<p>Piecewise insert</p>
</td>
<td class="cellalignment1013" headers="r8c1-t10 r1c2-t10">
<p>Varies</p>
</td>
<td class="cellalignment1013" headers="r8c1-t10 r1c3-t10">
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> is required. The application may also need to call <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> to register piecewise callbacks.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t10" headers="r1c1-t10">
<p><code>REF CURSOR</code> variables</p>
</td>
<td class="cellalignment1013" headers="r9c1-t10 r1c2-t10">
<p><code>SQLT_RSET</code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t10 r1c3-t10">
<p>Allocate a statement handle, <code>OCIStmt</code>, and then bind its address, <code>OCIStmt **</code>, using the <code>SQLT_RSET</code> data type.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci12oty.htm#i437161">"Named Data Type Binds"</a> for information about binding named data types (objects)</p>
</li>
<li>
<p><a href="oci12oty.htm#i437201">"Binding REFs"</a></p>
</li>
</ul>
</div>
<a id="i420964"></a>
<div id="LNOCI16368" class="sect2">
<h3 class="sect2">Binding LOBs<a id="sthref742"></a><a id="sthref743"></a></h3>
<p>There are two ways of binding LOBs:</p>
<ul>
<li>
<p>Bind the LOB locator, rather than the actual LOB values. In this case the LOB value is written or read by passing a LOB locator to the OCI LOB functions.</p>
</li>
<li>
<p>Bind the LOB value directly, without using the LOB locator.</p>
</li>
</ul>
<div id="LNOCI16369" class="sect3"><a id="sthref744"></a>
<h4 class="sect3">Binding LOB Locators</h4>
<p>Either a single locator or an array of locators can be bound in a single bind call. In each case, the application must pass the <span class="italic">address of a LOB locator</span> and not the locator itself. For example, suppose that an application has prepared this SQL statement where <code>one_lob</code> is a bind variable corresponding to a LOB column:</p>
<pre>
INSERT INTO some_table VALUES (:one_lob)
</pre>
<p>Then your application makes the following declaration:</p>
<pre>
OCILobLocator * one_lob;
</pre>
<p>Then the calls in <a href="#CIHEEHEF">Example 5-3</a> would be used to bind the placeholder and execute the statement:</p>
<div id="LNOCI18143" class="example">
<p class="titleinexample"><a id="CIHEEHEF"></a>Example 5-3 Binding the Placeholder and Executing the Statement to Insert a Single Locator</p>
<pre>
/* initialize single locator */
one_lob = OCIDescriptorAlloc(...OCI_DTYPE_LOB...);
...
/* pass the address of the locator */
OCIBindByName(...,(void *) &amp;one_lob,... SQLT_CLOB, ...);
OCIStmtExecute(...,1,...)                /* 1 is the iters parameter */
</pre></div>
<!-- class="example" -->
<p>You can also insert an array using the same SQL <code>INSERT</code> statement. In this case, the application would include the code shown in <a href="#CIHDCCJD">Example 5-4</a>.</p>
<div id="LNOCI18144" class="example">
<p class="titleinexample"><a id="CIHDCCJD"></a>Example 5-4 Binding the Placeholder and Executing the Statement to Insert an Array of Locators</p>
<pre>
OCILobLocator * lob_array[10];
...
for (i=0; i&lt;10, i++)
    lob_array[i] = OCIDescriptorAlloc(...OCI_DTYPE_LOB...);
                                     /* initialize array of locators */
...
OCIBindByName(...,(void *) lob_array,...);
OCIStmtExecute(...,10,...);               /* 10 is the iters parameter */
</pre></div>
<!-- class="example" -->
<p>You must allocate descriptors with the <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a> function before they can be used. In an array of locators, you must initialize each array element using <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a>. Use <code>OCI_DTYPE_LOB</code> as the <code>type</code> parameter when allocating <code>BLOB</code>s, <code>CLOB</code>s, and <code>NCLOB</code>s. Use <code>OCI_DTYPE_FILE</code> when allocating <code>BFILE</code>s.</p>
<div id="LNOCI16370" class="sect4"><a id="sthref745"></a>
<h5 class="sect4">Restrictions on Binding LOB Locators</h5>
<p>Observe the following restrictions when you bind LOB locators:</p>
<ul>
<li>
<p>Piecewise and callback <code>INSERT</code> or <code>UPDATE</code> operations are not supported.</p>
</li>
<li>
<p>When using a FILE locator as a bind variable for an <code>INSERT</code> or <code>UPDATE</code> statement, you must first initialize the locator with a directory object and file name, by using <a href="oci17msc002.htm#i450493">OCILobFileSetName()</a> before issuing the <code>INSERT</code> or <code>UPDATE</code> statement.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci07lob.htm#g452677">Chapter 7</a> for more information about the OCI LOB functions</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i440236"></a>
<div id="LNOCI16371" class="sect3">
<h4 class="sect3">Binding LOB Data</h4>
<p>Oracle Database allows nonzero binds for <code>INSERT</code>s and <code>UPDATE</code>s of any size LOB. So you can bind data into a LOB column using <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>, <a href="oci16rel003.htm#i456223">OCIBindByName()</a>, and PL/SQL binds.</p>
<p>The bind of more than 4 kilobytes of data to a LOB column uses space from the temporary tablespace. Ensure that your temporary tablespace is big enough to hold at least the amount of data equal to the sum of all the bind lengths for LOBs. If your temporary tablespace is extendable, it is extended automatically after the existing space is fully consumed. Use the following command to create an extendable temporary tablespace:</p>
<pre>
CREATE TABLESPACE ... AUTOEXTEND ON ... TEMPORARY ...;
</pre>
<div id="LNOCI16372" class="sect4"><a id="sthref746"></a>
<h5 class="sect4">Restrictions on Binding LOB Data</h5>
<p>Observe the following restrictions when you bind LOB data:</p>
<ul>
<li>
<p><a id="sthref747"></a>If a table has both <code>LONG</code> and LOB columns, then you can have binds of greater than 4 kilobytes for either the <code>LONG</code> column or the LOB columns, but not both in the same statement.</p>
</li>
<li>
<p>In an <code>INSERT</code> <code>AS</code> <code>SELECT</code> operation, Oracle Database does not allow binding of any length data to LOB columns.</p>
</li>
<li>
<p>A special consideration applies on the maximum size of bind variables that are neither LONG or LOB, but that appear after any LOB or LONG bind variable in the SQL statement. You receive an <code>ORA-24816</code> error from Oracle Database if the maximum size for such bind variables exceeds 4000 bytes. To avoid this error, you must set <code>OCI_ATTR_MAXDATA_SIZE</code> to 4000 bytes for any such binds whose maximum size may exceed 4000 bytes on the server side after character set conversion. Alternatively, reorder the binds so that such binds are placed before any LONG or LOBs in the bind list.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i436480">"Using the OCI_ATTR_MAXDATA_SIZE Attribute"</a></div>
</li>
<li>
<p>Oracle Database does not do implicit conversions, such as <code>HEX</code> to <code>RAW</code> or <code>RAW</code> to <code>HEX</code>, for data of size more than 4000 bytes. The PL/SQL code in <a href="#CIHGGFFI">Example 5-5</a> illustrates this:</p>
<div id="LNOCI18145" class="example">
<p class="titleinexample"><a id="CIHGGFFI"></a>Example 5-5 Demonstrating Some Implicit Conversions That Cannot Be Done</p>
<pre>
create table t (c1 clob, c2 blob);
declare
  text   varchar(32767);
  binbuf raw(32767);
begin
  text := lpad ('a', 12000, 'a');
  binbuf := utl_raw.cast_to_raw(text);

  -- The following works:
  insert into t values (text, binbuf);

  -- The following does not work because Oracle dpes not do implicit 
  -- hex to raw conversion.
  insert into t (c2) values (text);  

  -- The following does not work because Oracle does not do implicit 
  -- raw to hex conversion.
  insert into t (c1) values (binbuf);  

  -- The following does not work because you cannot combine the
  -- utl_raw.cast_to_raw() operator with the &gt;4k bind.
  insert into t (c2) values (utl_raw.cast_to_raw(text));

end;
/
</pre></div>
<!-- class="example" --></li>
<li>
<p>If you bind more than 4000 bytes of data to a <code>BLOB</code> or a <code>CLOB</code>, and the data is filtered by a SQL operator, then Oracle Database limits the size of the result to at most 4000 bytes.</p>
<p>For example:</p>
<pre>
create table t (c1 clob, c2 blob);
-- The following command inserts only 4000 bytes because the result of
-- LPAD is limited to 4000 bytes
insert into t(c1) values (lpad('a', 5000, 'a')); 

-- The following command inserts only 2000 bytes because the result of
-- LPAD is limited to 4000 bytes, and the implicit hex to raw conversion
-- converts it to 2000 bytes of RAW data.
insert into t(c2) values (lpad('a', 5000, 'a')); 
</pre></li>
</ul>
</div>
<!-- class="sect4" -->
<div id="LNOCI16373" class="sect4"><a id="sthref748"></a>
<h5 class="sect4">Examples of Binding LOB Data</h5>
<p>The following SQL statements are used in <a href="#CIHBCIAD">Example 5-6</a> through <a href="#CIHGHACA">Example 5-13</a>:</p>
<pre>
CREATE TABLE foo (a INTEGER );
CREATE TYPE lob_typ AS OBJECT (A1 CLOB );
CREATE TABLE lob_long_tab (C1 CLOB, C2 CLOB, CT3 lob_typ, L LONG);
</pre>
<div id="LNOCI18146" class="example">
<p class="titleinexample"><a id="CIHBCIAD"></a>Example 5-6 Allowed: Inserting into C1, C2, and L Columns Up to 8000, 8000, and 2000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre>
void insert()                 /* A function in an OCI program */
{
   /* The following is allowed */
   ub1 buffer[8000];
   text *insert_sql = (text *) "INSERT INTO lob_long_tab (C1, C2, L) \
                       VALUES (:1, :2, :3)";
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[2], errhp, 3, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18147" class="example">
<p class="titleinexample"><a id="sthref749"></a>Example 5-7 Allowed: Inserting into C1 and L Columns up to 2000 and 8000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre>
void insert()
{
   /* The following is allowed */
   ub1 buffer[8000];
   text *insert_sql = (text *) "INSERT INTO lob_long_tab (C1, L) \
                      VALUES (:1, :2)";
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18148" class="example">
<p class="titleinexample"><a id="sthref750"></a>Example 5-8 Allowed: Updating C1, C2, and L Columns up to 8000, 8000, and 2000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre>
void update()
{
   /* The following is allowed, no matter how many rows it updates */
   ub1 buffer[8000];
   text *update_sql = (text *)"UPDATE lob_long_tab SET \
                              C1 = :1, C2=:2, L=:3";
   OCIStmtPrepare(stmthp, errhp, update_sql, strlen((char*)update_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[2], errhp, 3, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18149" class="example">
<p class="titleinexample"><a id="sthref751"></a>Example 5-9 Allowed: Updating C1, C2, and L Columns up to 2000, 2000, and 8000 Byte-Sized Bind Variable Data Values, Respectively</p>
<pre>
void update()
{
   /* The following is allowed, no matter how many rows it updates */
   ub1 buffer[8000];
   text *update_sql = (text *)"UPDATE lob_long_tab SET \
                               C1 = :1, C2=:2, L=:3";
   OCIStmtPrepare(stmthp, errhp, update_sql, strlen((char*)update_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[2], errhp, 3, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                               (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18150" class="example">
<p class="titleinexample"><a id="sthref752"></a>Example 5-10 Allowed: Piecewise, Callback, and Array Insert or Update Operations</p>
<pre>
void insert()
{
   /* Piecewise, callback and array insert/update operations similar to 
    * the allowed regular insert/update operations are also allowed */
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18151" class="example">
<p class="titleinexample"><a id="sthref753"></a>Example 5-11 Not Allowed: Inserting More Than 4000 Bytes into Both LOB and LONG Columns Using the Same INSERT Statement</p>
<pre>
void insert()
{
   /* The following is NOT allowed because you cannot insert &gt;4000 bytes
    * into both LOB and LONG columns */
   ub1 buffer[8000];
   text *insert_sql = (text *)"INSERT INTO lob_long_tab (C1, L) \
                               VALUES (:1, :2)";
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[1], errhp, 2, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18152" class="example">
<p class="titleinexample"><a id="sthref754"></a>Example 5-12 Allowed: Inserting into the CT3 LOB Column up to 2000 Byte-Sized Bind Variable Data Values</p>
<pre>
void insert()
{
   /* Insert of data into LOB attributes is allowed */
   ub1 buffer[8000];
   text *insert_sql = (text *)"INSERT INTO lob_long_tab (CT3) \
                               VALUES (lob_typ(:1))";
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 2000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18153" class="example">
<p class="titleinexample"><a id="CIHGHACA"></a>Example 5-13 Not Allowed: Binding Any Length Data to a LOB Column in an Insert As Select Operation</p>
<pre>
void insert()
{
   /* The following is NOT allowed because you cannot do insert as
    * select character data into LOB column */
   ub1 buffer[8000];
   text *insert_sql = (text *)"INSERT INTO lob_long_tab (C1) SELECT \
                               :1 from FOO";
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (void *)buffer, 8000,
                SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *) NULL,
                              (OCISnapshot *) NULL, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16382" class="sect2"><a id="sthref755"></a>
<h3 class="sect2">Binding in OCI_DATA_AT_EXEC Mode<a id="sthref756"></a></h3>
<p>If the <code>mode</code> parameter in a call to <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> is set to <code>OCI_DATA_AT_EXEC</code>, an additional call to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> is necessary if the application uses the callback method for providing data at run time. The call to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> sets up the callback routines, if necessary, for indicating the data or piece provided. If the <code>OCI_DATA_AT_EXEC</code> mode is chosen, but the standard OCI piecewise polling method is used instead of callbacks, the call to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> is not necessary.</p>
<p>When binding <code>RETURN</code> clause variables, an application must use <code>OCI_DATA_AT_EXEC</code> mode, and it must provide callbacks.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about piecewise operations</div>
</div>
<!-- class="sect2" -->
<a id="i422187"></a>
<div id="LNOCI16383" class="sect2">
<h3 class="sect2">Binding REF CURSOR Variables<a id="sthref757"></a><a id="sthref758"></a></h3>
<p><code>REF CURSOR</code>s are bound to a statement handle with a bind data type of <code>SQLT_RSET</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i423493">"PL/SQL REF CURSORs and Nested Tables in OCI"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421494"></a>
<div id="LNOCI16384" class="sect1">
<h2 class="sect1">Overview of Defining in OCI<a id="sthref759"></a><a id="sthref760"></a></h2>
<p>Query statements return data from the database to your application. When processing a query, you must define an output variable or an array of output variables for each item in the select list for retrieving data. The define step creates an association that determines where returned results are stored, and in what format.</p>
<p>For example, if your program processes the following statement then you would normally define two output variables: one to receive the value returned from the <code>name</code> column, and one to receive the value returned from the <code>ssn</code> column:</p>
<pre>
SELECT name, ssn FROM employees
    WHERE empno = :empnum
</pre>
<p>If you were only interested in retrieving values from the <code>name</code> column, you would not need to define an output variable for <code>ssn</code>. If the <code>SELECT</code> statement being processed returns more than a single row for a query, the output variables that you define can be arrays instead of scalar values.</p>
<p>Depending on the application, the define step can occur before or after an execute operation. If you know the data types of select-list items at compile time, the define can occur before the statement is executed. If your application is processing dynamic SQL statements entered by you at run time or statements that do not have a clearly defined select list, the application must execute the statement to retrieve describe information. After the describe information is retrieved, the type information for each select-list item is available for use in defining output variables.</p>
<p>OCI processes the define call locally on the client side. In addition to indicating the location of buffers where results should be stored, the define step determines what data conversions must occur when data is returned to the application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Output buffers must be 2-byte aligned.</div>
<p>The <code>dty</code> parameter of the <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> call specifies the data type of the output variable. OCI can perform a wide range of data conversions when data is fetched into the output variable. For example, internal data in Oracle <code>DATE</code> format can be automatically converted to a <code>String</code> data type on output.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci03typ.htm#g467721">Chapter 3</a> for more information about data types and conversions</p>
</li>
<li>
<p><a href="oci04sql.htm#i441217">"Describing Select-List Items"</a></p>
</li>
</ul>
</div>
<a id="i423689"></a>
<div id="LNOCI16385" class="sect2">
<h3 class="sect2">Steps Used in OCI Defining<a id="sthref761"></a></h3>
<p>A basic define is done with a position call, <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>. This step creates an association between a select-list item and an output variable. Additional define calls may be necessary for certain data types or fetch modes. Once the define step is complete, the OCI library determines where to put retrieved data. You can make your define calls again to redefine the output variables without having to reprepare or reexecute the SQL statement.</p>
<p><a id="sthref762"></a><a href="#CIHBDHGI">Example 5-14</a> shows a scalar output variable being defined following an execute and describe operation.</p>
<div id="LNOCI18154" class="example">
<p class="titleinexample"><a id="CIHBDHGI"></a>Example 5-14 Defining a Scalar Output Variable Following an Execute and Describe Operation</p>
<pre>
SELECT department_name FROM departments WHERE department_id = :dept_input

   /* The input placeholder was bound earlier, and the data comes from the
   user input below */

  printf("Enter employee dept: ");
  scanf("%d", &amp;deptno);

 /* Execute the statement. If OCIStmtExecute() returns OCI_NO_DATA, meaning that
    no data matches the query, then the department number is invalid. */

  if ((status = OCIStmtExecute(svchp, stmthp, errhp, 0, 0, (OCISnapshot *) 0, (OCISnapshot *) 0,
       OCI_DEFAULT))
      &amp;&amp; (status != OCI_NO_DATA))
  {
    checkerr(errhp, status);
    return OCI_ERROR;
  }
  if (status == OCI_NO_DATA) {
    printf("The dept you entered does not exist.\n");
    return 0;
  }

   /* The next two statements describe the select-list item, dname, and
   return its length */
  checkerr(errhp, OCIParamGet((void *)stmthp, (ub4) OCI_HTYPE_STMT, errhp, (void **)&amp;parmdp, (ub4) 1));
  checkerr(errhp, OCIAttrGet((void*) parmdp, (ub4) OCI_DTYPE_PARAM,
        (void*) &amp;deptlen, (ub4 *) &amp;sizelen, (ub4) OCI_ATTR_DATA_SIZE,
        (OCIError *) errhp  ));

  /* Use the retrieved length of dname to allocate an output buffer, and
   then define the output variable. If the define call returns an error,
   exit the application */
  dept = (text *) malloc((int) deptlen + 1);
  if (status = OCIDefineByPos(stmthp, &amp;defnp, errhp,
             1, (void *) dept, (sb4) deptlen+1,
             SQLT_STR, (void *) 0, (ub2 *) 0,
             (ub2 *) 0, OCI_DEFAULT))
  {
    checkerr(errhp, status);
    return OCI_ERROR;
  }
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci04sql.htm#i441217">"Describing Select-List Items"</a> for an explanation of the describe step</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421090"></a>
<div id="LNOCI16387" class="sect1">
<h2 class="sect1">Advanced Define Operations in OCI</h2>
<p>This section covers advanced define operations, including multistep defines and defines of named data types and <code>REF</code>s.</p>
<p>In some cases, the define step requires additional calls than just a call to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>; for example, that define the attributes of an array fetch, <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a>, or a named data type fetch, <a href="oci16rel003.htm#i555538">OCIDefineObject()</a>. For example, to fetch multiple rows with a column of named data types, all the three calls must be invoked for the column. To fetch multiple rows of scalar columns only, <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a> and <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> are sufficient.</p>
<p>Oracle Database also provides predefined C data types that map object type attributes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci12oty.htm#g453655">Chapter 12, "Object-Relational Data Types in OCI"</a></p>
</li>
<li>
<p><a href="#i421090">"Advanced Define Operations in OCI"</a></p>
</li>
</ul>
</div>
<a id="i435612"></a>
<div id="LNOCI16388" class="sect2">
<h3 class="sect2">Defining LOB Output Variables<a id="sthref763"></a><a id="sthref764"></a></h3>
<p>There are two ways of defining LOBs:</p>
<ul>
<li>
<p>Define a LOB locator, rather than the actual LOB values. In this case, the LOB value is written or read by passing a LOB locator to the OCI LOB functions.</p>
</li>
<li>
<p>Define a LOB value directly, without using the LOB locator.</p>
</li>
</ul>
<div id="LNOCI16389" class="sect3"><a id="sthref765"></a>
<h4 class="sect3">Defining LOB Locators</h4>
<p>Either a single locator or an array of locators can be defined in a single define call. In each case, the application must pass the address of a LOB locator and not the locator itself. For example, suppose that an application has prepared the following SQL statement:</p>
<pre>
SELECT lob1 FROM some_table;
</pre>
<p>In this statement, <code>lob1</code> is the LOB column, and <code>one_lob</code> is a define variable corresponding to a LOB column with the following declaration:</p>
<pre>
OCILobLocator * one_lob;
</pre>
<p>Then the following calls would be used to bind the placeholder and execute the statement:</p>
<pre>
/* initialize single locator */
OCIDescriptorAlloc(...&amp;one_lob, OCI_DTYPE_LOB...);
...
/* pass the address of the locator */
OCIBindByName(...,(void *) &amp;one_lob,... SQLT_CLOB, ...);
OCIStmtExecute(...,1,...);                /* 1 is the iters parameter */
</pre>
<p>You can also insert an array using this same SQL <code>SELECT</code> statement. In this case, the application would include the following code:</p>
<pre>
OCILobLocator * lob_array[10];
...
for (i=0; i&lt;10, i++)
   OCIDescriptorAlloc(...&amp;lob_array[i], OCI_DTYPE_LOB...);
                                         /* initialize array of locators */
...
OCIBindByName(...,(void *) lob_array,...);
OCIStmtExecute(...,10,...);               /* 10 is the iters parameter */
</pre>
<p>Note that you must allocate descriptors with the <code>OCIDescriptorAlloc()</code> function before they can be used. In an array of locators, you must initialize each array element using <code>OCIDescriptorAlloc()</code>. Use <code>OCI_DTYPE_LOB</code> as the <code>type</code> parameter when allocating <code>BLOB</code>s, <code>CLOB</code>s, and <code>NCLOB</code>s. Use <code>OCI_DTYPE_FILE</code> when allocating <code>BFILE</code>s.</p>
</div>
<!-- class="sect3" -->
<a id="i440237"></a>
<div id="LNOCI16390" class="sect3">
<h4 class="sect3">Defining LOB Data</h4>
<p>Oracle Database allows nonzero defines for <code>SELECT</code>s of any size LOB. So you can select up to the maximum allowed size of data from a LOB column using <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> and PL/SQL defines. Because there can be multiple LOBs in a row, you can select the maximum size of data from each one of those LOBs in the same <code>SELECT</code> statement.</p>
<p>The following SQL statement is the basis for <a href="#CIHCFDCF">Example 5-15</a> and <a href="#CIHCGDAE">Example 5-16</a>:</p>
<pre>
CREATE TABLE lob_tab (C1 CLOB, C2 CLOB);
</pre>
<div id="LNOCI18155" class="example">
<p class="titleinexample"><a id="CIHCFDCF"></a>Example 5-15 Defining LOBs Before Execution</p>
<pre>
void select_define_before_execute()      /* A function in an OCI program */
{
  /* The following is allowed */
   ub1 buffer1[8000];
   ub1 buffer2[8000];
   text *select_sql = (text *)"SELECT c1, c2 FROM lob_tab";

   OCIStmtPrepare(stmthp, errhp, select_sql, (ub4)strlen((char*)select_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[0], errhp, 1, (void *)buffer1, 8000,
                SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[1], errhp, 2, (void *)buffer2, 8000,
                SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (OCISnapshot *)0, 
                 (OCISnapshot *)0, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18156" class="example">
<p class="titleinexample"><a id="CIHCGDAE"></a>Example 5-16 Defining LOBs After Execution</p>
<pre>
void select_execute_before_define()
{
  /* The following is allowed */
   ub1 buffer1[8000];
   ub1 buffer2[8000];
   text *select_sql = (text *)"SELECT c1, c2 FROM lob_tab";

   OCIStmtPrepare(stmthp, errhp, select_sql, (ub4)strlen((char*)select_sql),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   OCIStmtExecute(svchp, stmthp, errhp, 0, 0, (OCISnapshot *)0,
                 (OCISnapshot *)0, OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[0], errhp, 1, (void *)buffer1, 8000,
                 SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIDefineByPos(stmthp, &amp;defhp[1], errhp, 2, (void *)buffer2, 8000,
                 SQLT_LNG, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT);
   OCIStmtFetch(stmthp, errhp, 1, OCI_FETCH_NEXT, OCI_DEFAULT);
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHEIHBE"></a>
<div id="LNOCI16393" class="sect2">
<h3 class="sect2">Defining PL/SQL Output Variables<a id="sthref766"></a><a id="sthref767"></a></h3>
<p>Do not use the define calls to define output variables for select-list items in a SQL <code>SELECT</code> statement inside a PL/SQL block. Use OCI bind calls instead.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci12oty.htm#i437290">"Information for Named Data Type and REF Defines, and PL/SQL OUT Binds"</a> for more information about defining PL/SQL output variables</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16394" class="sect2"><a id="sthref768"></a>
<h3 class="sect2">Defining for a Piecewise Fetch<a id="sthref769"></a></h3>
<p>A piecewise fetch requires an initial call to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>. An additional call to <a href="oci16rel003.htm#i444226">OCIDefineDynamic()</a> is necessary if the application uses callbacks rather than the standard polling mechanism.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421503"></a>
<div id="LNOCI16395" class="sect1">
<h2 class="sect1">Binding and Defining Arrays of Structures in OCI<a id="sthref770"></a><a id="sthref771"></a></h2>
<p>Defining arrays of structures requires an initial call to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>. An additional call to <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a> is necessary to set up each additional parameter, including the <code>skip</code> parameter necessary for arrays of structures operations.</p>
<p>Using arrays of structures can simplify the processing of multirow, multicolumn operations. You can create a structure of related scalar data items, and then fetch values from the database into an array of these structures, or insert values into the database from an array of these structures.</p>
<p>For example, an application may need to fetch multiple rows of data from columns <code>NAME</code>, <code>AGE</code>, and <code>SALARY</code>. The application can include the definition of a structure containing separate fields to hold the <code>NAME</code>, <code>AGE</code>, and <code>SALARY</code> data from one row in the database table. The application would then fetch data into an array of these structures.</p>
<p>To perform a multirow, multicolumn operation using an array of structures, associate each column involved in the operation with a field in a structure. This association, which is part of <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a> and <a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a> calls, specifies where data is stored.</p>
<a id="i421388"></a>
<div id="LNOCI16396" class="sect2">
<h3 class="sect2">Skip Parameters<a id="sthref772"></a><a id="sthref773"></a></h3>
<p>When you split column data across an array of structures, it is no longer stored contiguously in the database. The single array of structures stores data as though it were composed of several arrays of scalars. For this reason, you must specify a skip parameter for each field that you are binding or defining. This skip parameter is the number of bytes that must be skipped in the array of structures before the same field is encountered again. In general, this is equivalent to the byte size of one structure.</p>
<p><a href="#i421954">Figure 5-2</a> shows how a skip parameter is determined. In this case, the skip parameter is the sum of the sizes of the fields <code>field1</code> (2 bytes), <code>field2</code> (4 bytes), and <code>field3</code> (2 bytes), which is 8 bytes. This equals the size of one structure.</p>
<div id="LNOCI16397" class="figure">
<p class="titleinfigure"><a id="i421954"></a>Figure 5-2 Determining Skip Parameters</p>
<img width="668" height="136" src="img/lnoci002.gif" alt="Description of Figure 5-2 follows" /><br />
<a id="sthref774" href="img_text/lnoci002.htm">Description of "Figure 5-2 Determining Skip Parameters"</a><br />
<br /></div>
<!-- class="figure" -->
<p>On some operating systems it may be necessary to set the skip parameter to <code>sizeof</code>(<code>one_array_element</code>) rather than <code>sizeof</code>(<code>struct</code>), because some compilers insert extra bytes into a structure.</p>
<p>Consider an array of C structures consisting of two fields, a <code>ub4</code> and a <code>ub1</code>:</p>
<pre>
struct demo {
    ub4 field1;
    ub1 field2;
};
struct demo demo_array[MAXSIZE];
</pre>
<p>Some compilers insert 3 bytes of padding after the <code>ub1</code> so that the <code>ub4</code> that begins the next structure in the array is properly aligned. In this case, the following statement may return an incorrect value:</p>
<pre>
skip_parameter = sizeof(struct demo);
</pre>
<p>On some operating systems this produces a proper skip parameter of 8. On other systems, <code>skip_parameter</code> is set to 5 bytes by this statement. In the latter case, use the following statement to get the correct value for the skip parameter:</p>
<pre>
skip_parameter = sizeof(demo_array[0]);
</pre>
<div id="LNOCI16398" class="sect3"><a id="sthref775"></a>
<h4 class="sect3">Skip Parameters for Standard Arrays<a id="sthref776"></a><a id="sthref777"></a></h4>
<p>Arrays of structures are an extension of binding and defining arrays of single variables. When you specify a single-variable array operation, the related skip equals the size of the data type of the array under consideration. For example, consider an array declared as follows:</p>
<pre>
text emp_names[4][20];
</pre>
<p>The skip parameter for the bind or define operation is 20. Each data element in the array is then recognized as a separate unit, rather than being part of a structure.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16399" class="sect2"><a id="sthref778"></a>
<h3 class="sect2">OCI Calls Used with Arrays of Structures<a id="sthref779"></a></h3>
<p>Two OCI calls must be used when you perform operations involving arrays of structures:</p>
<ul>
<li>
<p>Use <a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a> for binding fields in arrays of structures for input variables</p>
</li>
<li>
<p>Use <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a> for defining arrays of structures for output variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Binding or defining for arrays of structures requires multiple calls. A call to <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> must precede a call to <a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a>, and a call to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> must precede a call to <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a>.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNOCI16400" class="sect2"><a id="sthref780"></a>
<h3 class="sect2">Arrays of Structures and Indicator Variables<a id="sthref781"></a><a id="sthref782"></a></h3>
<p>The implementation of arrays of structures in addition supports the use of indicator variables and return codes. You can declare parallel arrays of column-level indicator variables and return codes that correspond to the arrays of information being fetched, inserted, or updated. These arrays can have their own skip parameters, which are specified during <a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a> or <a href="oci16rel003.htm#i498627">OCIDefineArrayOfStruct()</a> calls.</p>
<p>You can set up arrays of structures of program values and indicator variables in many ways. Consider an application that fetches data from three database columns into an array of structures containing three fields. You can set up a corresponding array of indicator variable structures of three fields, each of which is a column-level indicator variable for one of the columns being fetched from the database. A one-to-one relationship between the fields in an indicator struct and the number of select-list items is not necessary.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#i462559">"Indicator Variables"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGDJDD"></a>
<div id="LNOCI05100" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Binding<a id="sthref783"></a><a id="sthref784"></a><a id="sthref785"></a><a id="sthref786"></a><a id="sthref787"></a> and Defining Multiple Buffers</h2>
<p><a id="sthref788"></a>You can specify multiple buffers for use with a single bind or define call. Performance is improved because the number of round-trips is decreased when data stored at different noncontiguous addresses is not copied to one contiguous location. CPU time spent and memory used are thus reduced.</p>
<p>The data type <code>OCIIOV</code> is defined as:</p>
<pre>
typedef struct OCIIOV
{
  void *bfp;  /* The pointer to a buffer for the data    */
  ub4  bfl;   /* The size of the buffer                  */
}OCIIOV;
</pre>
<p>The value <code>OCI_IOV</code> for the <code>mode</code> parameter is used in the <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> and <a href="oci16rel003.htm#i456223">OCIBindByName()</a> functions for binding multiple buffers. If this value of <code>mode</code> is specified, the address of <code>OCIIOV</code> must be passed in parameter <code>valuep</code>. The size of the data type must be passed in the parameter <code>valuesz</code>. For example:</p>
<pre>
OCIIOV vecarr[NumBuffers];
...
/* For bind at position 1 with data type int     */
OCIBindByPos(stmthp, bindp, errhp, 1, (void *)&amp;vecarr[0],
             sizeof(int), ... OCI_IOV);
...
</pre>
<p>The value <code>OCI_IOV</code> for the mode parameter is used in the <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> function for defining multiple buffers. If this value of <code>mode</code> is specified, the address of <code>OCIIOV</code> is passed in parameter <code>valuep</code>. The size of the data type must be passed in the parameter <code>valuesz</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i456223">"OCIBindByName()"</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456224">"OCIBindByPos()"</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i459315">"OCIDefineByPos()"</a></p>
</li>
</ul>
</div>
<p><a href="#CIHHIAJF">Example 5-17</a> illustrates the use of the structure <code>OCIIOV</code> and its <code>mode</code> values.</p>
<div id="LNOCI18157" class="example">
<p class="titleinexample"><a id="CIHHIAJF"></a>Example 5-17 Using Multiple Bind and Define Buffers</p>
<pre>
/* The following macros mention the maximum length of the data in the 
 * different buffers. */
 
#define    LENGTH_DATE      10
#define    LENGTH_EMP_NAME  100
 
 
/* These two macros represent the number of elements in each bind and define 
   array */
#define  NUM_BIND     30
#define  NUM_DEFINE   45
 
/* The bind buffers for inserting dates */
char  buf_1[NUM_BIND][LENGTH_DATE], 
char  buf_2[NUM_BIND * 2][LENGTH_DATE], 
 
/* The bind buffer for inserting emp name */
char  buf_3[NUM_BIND * 3][LENGTH_EMP_NAME], 
 
/* The define buffers */
char  buf_4[NUM_DEFINE][LENGTH_EMP_NAME];
char  buf_5[NUM_DEFINE][LENGTH_EMP_NAME];
 
/* The size of data value for buffers corresponding to the same column must be
   the same, and that value is passed in the OCIBind or Define calls.
   buf_4 and buf_5 above have the same data values; that is, LENGTH_EMP_NAME
   although the  number of elements are different in the two buffers.
   
*/
OCIBind     *bndhp1 = (OCIBind   *)0;
OCIBind     *bndhp2 = (OCIBind   *)0;
OCIDefine   *defhp  = (OCIDefine *)0;
OCIStmt     *stmthp = (OCIStmt   *)0;
OCIError    *errhp  = (OCIError  *)0;
 
OCIIOV  bvec[2], dvec[2];
 
/* 
Example of how to use indicators and return codes with this feature, 
showing the allocation when using with define. You allocate memory 
for indicator, return code, and the length buffer as one chunk of 
NUM_DEFINE * 2 elements.
*/
short *indname[NUM_DEFINE*2];            /* indicators */
ub4   *alenname[NUM_DEFINE*2];           /* return lengths */
ub2   *rcodename[NUM_DEFINE*2];          /* return codes */
 
static text *insertstr  = 
             "INSERT INTO EMP (EMP_NAME, JOIN_DATE) VALUES (:1, :2)";
static text *selectstr  = "SELECT EMP_NAME FROM EMP";
 
/* Allocate environment, error handles, and so on, and then initialize the 
   environment.  */
...
/* Prepare the statement with the insert query in order to show the 
   binds. */
OCIStmtPrepare  (stmthp, errhp, insertstr,
                 (ub4)strlen((char *)insertstr),
                 (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
 
/* Populate buffers with values. The following represents the simplest
 * way of populating the buffers. However, in an actual scenario 
 * these buffers may have been populated by data received from different
 * sources. */
 
/* Store the date in the bind buffers for the date. */
strcpy(buf_1[0], "21-SEP-02");
...
strcpy(buf_1[NUM_BIND - 1], "21-OCT-02");
...
strcpy(buf_2[0], "22-OCT-02");
...
strcpy(buf_2[2*NUM_BIND - 1], "21-DEC-02");
...
memset(bvec[0], 0, sizeof(OCIIOV));
memset(bvec[1], 0, sizeof(OCIIOV));
 
/* Set up the addresses in the IO Vector structure */
bvec[0].bfp = buf_1[0];                       /* Buffer address of the data */
bvec[0].bfl = NUM_BIND*LENGTH_DATE;           /* Size of the buffer */
 
/* And so on for other structures as well. */
bvec[1].bfp = buf_2[0];                       /* Buffer address of the data */
bvec[1].bfl = NUM_BIND*2*LENGTH_DATE;         /* Size of the buffer  */ 
 
/* Do the bind for date, using OCIIOV */
OCIBindByPos (stmthp, &amp;bindhp2, errhp, 2, (void *)&amp;bvec[0], 
              sizeof(buf_1[0]), SQLT_STR, 
              (void *)inddate, (ub2 *)alendate, (ub2 *)rcodedate, 0,
              (ub4 *)0,  OCI_IOV);
 
/* Store the employee names in the bind buffers, 3 for the names */
strcpy (buf_3[0], "JOHN ");
...
strcpy (buf_3[NUM_BIND *3 - 1], "HARRY");
 
/* Do the bind for employee name */
OCIBindByPos  (stmthp,  &amp;bindhp1, errhp, 1, buf_3[0], sizeof(buf_3[0]),
      SQLT_STR, (void *)indemp, (ub2 *)alenemp, (ub2 *)rcodeemp, 0, 
      (ub4 *)0, OCI_DEFAULT);
 
OCIStmtExecute (svchp, stmthp, errhp, NUM_BIND*3, 0, 
               (OCISnapshot *)0, (OCISnapshot *)0, OCI_DEFAULT);
 
...
/* Now the statement to depict defines */
/* Prepare the statement with the select query in order to show the 
   defines */
OCIStmtPrepare(stmthp, errhp, selectstr,(ub4)strlen((char *)selectstr),
               (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
 
memset(dvec[0], 0, sizeof(OCIIOV);
memset(dvec[1], 0, sizeof(OCIIOV));
 
/* Set up the define vector */
dvec[0].bfp = buf_4[0];
dvec[0].bfl = NUM_DEFINE*LENGTH_EMP_NAME;
 
dvec[1].bfp = buf_5[0];
dvec[1].bfl = NUM_DEFINE*LENGTH_EMP_NAME;
 
/* 
Pass the buffers for the indicator, length of the data, and the 
return code.  Note that the buffer where you receive
the data is split into two locations, 
each having NUM_DEFINE number of elements. However, the indicator
buffer, the actual length buffer, and the return code buffer comprise a
single chunk of NUM_DEFINE * 2 elements.
*/
OCIDefineByPos (stmthp, &amp;defhp, errhp, 1, (void *)&amp;dvec[0], 
                sizeof(buf_4[0]), SQLT_STR, (void *)indname, 
                (ub2 *)alenname, (ub2 *)rcodename, OCI_IOV);
 
OCIStmtExecute (svchp, stmthp, errhp, NUM_DEFINE*2, 0, 
                (OCISnapshot*)0, 
                (OCISnapshot*)0, OCI_DEFAULT);
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i423484"></a>
<div id="LNOCI16402" class="sect1">
<h2 class="sect1">DML with a RETURNING Clause in OCI<a id="sthref789"></a></h2>
<p>OCI supports the use of the <code>RETURNING</code> clause with SQL <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements. This section outlines the rules for correctly implementing DML statements with the <code>RETURNING</code> clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The Database demonstration programs included with your Oracle installation for complete examples. For additional information, see <a href="ociabdem.htm#g462659">Appendix B</a>.</p>
</li>
<li>
<p><a class="olink SQLRF55083" href="../../server.112/e41084/statements_9014.htm#SQLRF55083"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the use of the <code>RETURNING</code> clause with <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statements</p>
</li>
</ul>
</div>
<div id="LNOCI16403" class="sect2"><a id="sthref790"></a>
<h3 class="sect2">Using DML with a RETURNING Clause to Combine Two SQL Statements</h3>
<p>Using the <code>RETURNING</code> clause with a DML statement enables you to combine two SQL statements into one, possibly saving a server round-trip. This is accomplished by adding an extra clause to the traditional <code>UPDATE</code>, <code>INSERT</code>, and <code>DELETE</code> statements. The extra clause effectively adds a query to the DML statement.</p>
<p>In OCI, values are returned to the application as <code>OUT</code> bind variables. In the following examples, the bind variables are indicated by a preceding colon, ":". These examples assume the existence of <code>table1</code>, a table that contains columns <code>col1</code>, <code>col2</code>, and <code>col3</code>.</p>
<p>The following statement inserts new values into the database and then retrieves the column values of the affected row from the database, for manipulating inserted rows.</p>
<pre>
INSERT INTO table1 VALUES (:1, :2, :3)
     RETURNING col1, col2, col3
     INTO :out1, :out2, :out3
</pre>
<p>The next example updates the values of all columns where the value of <code>col1</code> falls within a given range, and then returns the affected rows that were modified.</p>
<pre>
UPDATE table1 SET col1 = col1 + :1, col2 = :2, col3 = :3
     WHERE col1 &gt;= :low AND col1 &lt;= :high
     RETURNING col1, col2, col3
     INTO :out1, :out2, :out3
</pre>
<p>The <code>DELETE</code> statement deletes the rows where <code>col1</code> value falls within a given range, and then returns the data from those rows.</p>
<pre>
DELETE FROM table1 WHERE col1 &gt;= :low AND col2 &lt;= :high 
     RETURNING col1, col2, col3
     INTO :out1, :out2, :out3
</pre></div>
<!-- class="sect2" -->
<div id="LNOCI16404" class="sect2"><a id="sthref791"></a>
<h3 class="sect2">Binding RETURNING...INTO Variables<a id="sthref792"></a></h3>
<p>Because both the <code>UPDATE</code> and <code>DELETE</code> statements can affect multiple rows in the table, and a DML statement can be executed multiple times in a single <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call, how much data is returned may not be known at run time. As a result, the variables corresponding to the <code>RETURNING</code>...<code>INTO</code> placeholders must be bound in <code>OCI_DATA_AT_EXEC</code> mode. An application must define its own dynamic data handling callbacks rather than using a polling mechanism.</p>
<p>The returning clause can be particularly useful when working with LOBs. Normally, an application must insert an empty LOB locator into the database, and then select it back out again to operate on it. By using the <code>RETURNING</code> clause, the application can combine these two steps into a single statement:</p>
<pre>
INSERT INTO some_table VALUES (:in_locator)
    RETURNING lob_column
    INTO :out_locator
</pre>
<p>An OCI application implements the placeholders in the <code>RETURNING</code> clause as pure <code>OUT</code> bind variables. However, all binds in the <code>RETURNING</code> clause are initially <code>IN</code> and must be properly initialized. To provide a valid value, you can provide a <code>NULL</code> indicator and set that indicator to -1.<span class="bold"><a id="sthref793"></a></span></p>
<p>An application must adhere to the following rules when working with bind variables in a <code>RETURNING</code> clause:</p>
<ul>
<li>
<p>Bind <code>RETURNING</code> clause placeholders in <code>OCI_DATA_AT_EXEC</code> mode using <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>, followed by a call to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> for each placeholder.</p>
</li>
<li>
<p>When binding <code>RETURNING</code> clause placeholders, supply a valid <code>OUT</code> bind function as the <code>ocbfp</code> parameter of the <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> call. This function must provide storage to hold the returned data.</p>
</li>
<li>
<p>The <code>icbfp</code> parameter of <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> call should provide a default function that returns <code>NULL</code> values when called.</p>
</li>
<li>
<p>The <code>piecep</code> parameter of <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> must be set to <code>OCI_ONE_PIECE</code>.</p>
</li>
</ul>
<p>No duplicate binds are allowed in a DML statement with a <code>RETURNING</code> clause, and no duplication is allowed between bind variables in the DML section and the <code>RETURNING</code> section of the statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
OCI supports only the callback mechanism for <code>RETURNING</code> clause binds. The polling mechanism is not supported.</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16405" class="sect2"><a id="sthref794"></a>
<h3 class="sect2">OCI Error Handling<a id="sthref795"></a></h3>
<p>The <code>OUT</code> bind function provided to <code>OCIBindDynamic()</code> must be prepared to receive partial results of a statement if there is an error. If the application has issued a DML statement that is executed 10 times, and an error occurs during the fifth iteration, the Oracle database returns the data from iterations 1 through 4. The callback function is still called to receive data for the first four iterations.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16406" class="sect2"><a id="sthref796"></a>
<h3 class="sect2">DML with RETURNING REF...INTO Clause in OCI<a id="sthref797"></a></h3>
<p>The <code>RETURNING</code> clause can also be used to return a <code>REF</code> to an object that is being inserted into or updated in the database:</p>
<pre>
UPDATE extaddr e SET e.zip = '12345', e.state ='AZ'
    WHERE e.state = 'CA' AND e.zip = '95117'
    RETURNING REF(e), zip
    INTO :addref, :zip
</pre>
<p>The preceding statement updates several attributes of an object in an object table and returns a <code>REF</code> to the object (and a scalar postal code (ZIP)) in the <code>RETURNING</code> clause.</p>
<div id="LNOCI16407" class="sect3"><a id="sthref798"></a>
<h4 class="sect3">Binding the Output Variable</h4>
<p>Binding the <code>REF</code> output variable in an OCI application requires three steps:</p>
<ol>
<li>
<p>Set the initial bind information is set using <a href="oci16rel003.htm#i456223">OCIBindByName()</a>.</p>
</li>
<li>
<p>Set additional bind information for the <code>REF</code>, including the type description object (TDO), is set with <a href="oci16rel003.htm#i444090">OCIBindObject()</a>.</p>
</li>
<li>
<p>Make a call is made to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a>.</p>
</li>
</ol>
<p>The following pseudocode in <a href="#CIHDICFI">Example 5-18</a> shows a function that performs the binds necessary for the preceding three steps.</p>
<div id="LNOCI18158" class="example">
<p class="titleinexample"><a id="CIHDICFI"></a>Example 5-18 Binding the REF Output Variable in an OCI Application</p>
<pre>
sword bind_output(stmthp, bndhp, errhp)
OCIStmt *stmthp;
OCIBind *bndhp[];
OCIError *errhp;
{
  ub4 i;
                                  /* get TDO for BindObject call */
  if (OCITypeByName(envhp, errhp, svchp, (CONST text *) 0,
                   (ub4) 0, (CONST text *) "ADDRESS_OBJECT",
                   (ub4) strlen((CONST char *) "ADDRESS_OBJECT"),
                   (CONST text *) 0, (ub4) 0,
                    OCI_DURATION_SESSION, OCI_TYPEGET_HEADER, &amp;addrtdo))
  {
    return OCI_ERROR;
  }

                         /* initial bind call for both variables */
  if (OCIBindByName(stmthp, &amp;bndhp[2], errhp,
                       (text *) ":addref", (sb4) strlen((char *) ":addref"),
                       (void *) 0, (sb4) sizeof(OCIRef *), SQLT_REF,
                       (void *) 0, (ub2 *)0, (ub2 *)0,
                       (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC)
  ||  OCIBindByName(stmthp, &amp;bndhp[3], errhp,
                       (text *) ":zip", (sb4) strlen((char *) ":zip"),
                       (void *) 0, (sb4) MAXZIPLEN, SQLT_CHR,
                       (void *) 0, (ub2 *)0, (ub2 *)0,
                       (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC))
  {
    return OCI_ERROR;
  }

                                 /* object bind for REF variable */
  if (OCIBindObject(bndhp[2], errhp, (OCIType *) addrtdo,
          (void **) &amp;addrref[0], (ub4 *) 0, (void **) 0, (ub4 *) 0))
  {
    return OCI_ERROR;
  }


  for (i = 0; i &lt; MAXCOLS; i++)
    pos[i] = i;
                    /* dynamic binds for both RETURNING variables */
  if (OCIBindDynamic(bndhp[2], errhp, (void *) &amp;pos[0], cbf_no_data,
                    (void *) &amp;pos[0], cbf_get_data)
  ||  OCIBindDynamic(bndhp[3], errhp, (void *) &amp;pos[1], cbf_no_data,
                    (void *) &amp;pos[1], cbf_get_data))
  {
    return OCI_ERROR;
  }

  return OCI_SUCCESS;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16408" class="sect2"><a id="sthref799"></a>
<h3 class="sect2">Additional Notes About OCI Callbacks<a id="sthref800"></a></h3>
<p>When a callback function is called, the <code>OCI_ATTR_ROWS_RETURNED</code> attribute of the bind handle tells the application the number of rows being returned in that particular iteration. During the first callback of an iteration, you can allocate space for all rows that are returned for that bind variable. During subsequent callbacks of the same iteration, you increment the buffer pointer to the correct memory within the allocated space.</p>
</div>
<!-- class="sect2" -->
<a id="i426071"></a>
<div id="LNOCI16409" class="sect2">
<h3 class="sect2">Array Interface for DML RETURNING Statements in OCI</h3>
<p>OCI provides additional functionality for single-row DML and array DML operations in which each iteration returns more than one row. To take advantage of this feature, you must specify an OUT buffer in the bind call that is at least as big as the iteration count specified by the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call. This is in addition to the bind buffers provided through callbacks.</p>
<p>If any of the iterations returns more than one row, then the application receives an <code>OCI_SUCCESS_WITH_INFO</code> return code. In this case, the DML operation is successful. At this point, the application may choose to roll back the transaction or ignore the warning.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i422770"></a>
<div id="LNOCI16410" class="sect1">
<h2 class="sect1">Character Conversion in OCI Binding and Defining<a id="sthref801"></a></h2>
<p>This section discusses issues involving character conversions between the client and the server.</p>
<div id="LNOCI16411" class="sect2"><a id="sthref802"></a>
<h3 class="sect2">Choosing a Character Set<a id="sthref803"></a><a id="sthref804"></a></h3>
<p>If a database column containing character data is defined to be an <code>NCHAR</code> or <code>NVARCHAR2</code> column, then a bind or define involving that column must make special considerations for dealing with character set specifications.</p>
<p>These considerations are necessary in case the width of the client character set is different from the server character set, and also for proper character conversion. During conversion of data between different character sets, the size of the data may increase or decrease by a factor of four. Ensure that buffers that are provided to hold the data are of sufficient size.</p>
<p>In some cases, it may also be easier for an application to deal with <code>NCHAR</code> or <code>NVARCHAR2</code> data in terms of numbers of characters, rather than numbers of bytes, which is the usual case.</p>
<div id="LNOCI16412" class="sect3"><a id="sthref805"></a>
<h4 class="sect3">Character Set Form and ID</h4>
<p>Each OCI bind and define handle is associated with the <a id="sthref806"></a><code>OCI_ATTR_CHARSET_FORM</code> and <code><a id="sthref807"></a>OCI_ATTR_CHARSET_ID</code> attributes. An application can set these attributes with the <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> call to specify the character form and character set ID of the bind or define buffer.</p>
<p>The <code>csform</code> attribute (<code>OCI_ATTR_CHARSET_FORM</code>) indicates the character set of the client buffer for binds, and the character set in which to store fetched data for defines. It has two possible values:</p>
<ul>
<li>
<p><a id="sthref808"></a><code>SQLCS_IMPLICIT</code> - Default value indicates that the database character set ID for the bind or define buffer and the character buffer data are converted to the server database character set</p>
</li>
<li>
<p><code><a id="sthref809"></a>SQLCS_NCHAR</code> - Indicates that the national character set ID for the bind or define buffer and the client buffer data are converted to the server national character set.</p>
</li>
</ul>
<p>If the character set ID attribute, <code>OCI_ATTR_CHARSET_ID</code>, is not specified, either the default value of the database or the national character set ID of the client is used, depending on the value of <code>csform</code>. They are the values specified in the <code>NLS_LANG</code> and <code>NLS_NCHAR</code> environment variables, respectively.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>The data is converted and inserted into the database according to the server's database character set ID or national character set ID, regardless of the client-side character set ID.</p>
</li>
<li>
<p><code>OCI_ATTR_CHARSET_ID</code> must never be set to 0.</p>
</li>
<li>
<p>The define handle attributes <code>OCI_ATTR_CHARSET_FORM</code> and <code>OCI_ATTR_CHARSET_ID</code> do not affect the LOB types. LOB locators fetched from the server retain their original <code>csform</code>s. There is no <code>CLOB</code>/<code>NCLOB</code> conversion as part of define conversion based on these attributes.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN0041" href="../../server.112/e40402/limits001.htm#REFRN0041"><span class="italic">Oracle Database Reference</span></a> for more information about <code>NCHAR</code> data</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16413" class="sect3"><a id="sthref810"></a>
<h4 class="sect3">Implicit Conversion Between CHAR and NCHAR</h4>
<p>As the result of implicit conversion between database character sets and national character sets, OCI can support cross binding and cross defining between <code>CHAR</code> and <code>NCHAR</code>. Although the <code>OCI_ATTR_CHARSET_FORM</code> attribute is set to <code>SQLCS_NCHAR</code>, OCI enables conversion of data to the database character set if the data is inserted into a <code>CHAR</code> column.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i436743"></a>
<div id="LNOCI16414" class="sect2">
<h3 class="sect2">Setting Client Character Sets in OCI</h3>
<p>You can set the client character sets through the <code><a id="sthref811"></a></code><a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> function parameters <code>charset</code> and <code>ncharset</code>. Both of these parameters can be set as <code>OCI_UTF16ID</code>. The <code>charset</code> parameter controls coding of the metadata and <code>CHAR</code> data. The <code>ncharset</code> parameter controls coding of <code>NCHAR</code> data. The function <code><a id="sthref812"></a></code><a href="oci22glb001.htm#i529146">OCINlsEnvironmentVariableGet()</a> returns the character set from <code>NLS_LANG</code> and the national character set from <code>NLS_NCHAR</code>.</p>
<p><a href="#CIHFABJC">Example 5-19</a> illustrates the use of these functions (OCI provides a typedef called <span class="italic"><a id="sthref813"></a></span><code>utext</code> to facilitate binding and defining of UTF-16 data):</p>
<div id="LNOCI18159" class="example">
<p class="titleinexample"><a id="CIHFABJC"></a>Example 5-19 Setting the Client Character Set to OCI_UTF16ID in OCI</p>
<pre>
OCIEnv *envhp; 
ub2 ncsid = 2; /* we8dec */ 
ub2 hdlcsid, hdlncsid; 
OraText thename[20]; 
utext *selstmt = L"SELECT ename FROM emp"; /* UTF16 statement */ 
OCIStmt *stmthp; 
OCIDefine *defhp; 
OCIError *errhp; 
OCIEnvNlsCreate(OCIEnv **envhp, ..., OCI_UTF16ID, ncsid); 
... 
OCIStmtPrepare(stmthp, ..., selstmt, ...); /* prepare UTF16 statement */ 
OCIDefineByPos(stmthp, defnp, ..., 1, thename, sizeof(thename), SQLT_CHR,...); 
OCINlsEnvironmentVariableGet(&amp;hdlcsid, (size_t)0, OCI_NLS_CHARSET_ID, (ub2)0,
     (size_t*)NULL);
OCIAttrSet(defnp, ..., &amp;hdlcsid, 0, OCI_ATTR_CHARSET_ID, errhp); 
           /* change charset ID to NLS_LANG setting*/ 
...
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i562098">"OCIEnvNlsCreate()"</a></p>
</li>
<li>
<p><a href="oci22glb001.htm#i529146">"OCINlsEnvironmentVariableGet()"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI18160" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref814"></a>
<h3 class="sect2">Binding Variables in OCI</h3>
<p>Update or insert operations are done through variable binding. When binding variables, specify the <code>OCI_ATTR_MAXDATA_SIZE</code> attribute and <code>OCI_ATTR_MAXCHAR_SIZE</code> attribute in the bind handle to indicate the byte and character constraints used when inserting data in to the Oracle database.</p>
<p>These attributes are defined as:</p>
<ul>
<li>
<p>The <a id="sthref815"></a><code>OCI_ATTR_MAXDATA_SIZE</code> attribute sets the maximum number of bytes allowed in the buffer on the server side (see <a href="#i436480">Using the OCI_ATTR_MAXDATA_SIZE Attribute</a> for more information).</p>
</li>
<li>
<p>The <a id="sthref816"></a><code>OCI_ATTR_MAXCHAR_SIZE</code> attribute sets the maximum number of characters allowed in the buffer on the server side (see <a href="#i436084">Using the OCI_ATTR_MAXCHAR_SIZE Attribute</a> for more information).</p>
</li>
</ul>
<a id="i436480"></a>
<div id="LNOCI16415" class="sect3">
<h4 class="sect3">Using the OCI_ATTR_MAXDATA_SIZE Attribute<a id="sthref817"></a></h4>
<p>Every bind handle has an <code>OCI_ATTR_MAXDATA_SIZE</code> attribute that specifies the number of bytes allocated on the server to accommodate client-side bind data after character set conversions.</p>
<p>An application typically sets <code>OCI_ATTR_MAXDATA_SIZE</code> to the maximum size of the column or the size of the PL/SQL variable, depending on how it is used. Oracle Database issues an error if <code>OCI_ATTR_MAXDATA_SIZE</code> is not large enough to accommodate the data after conversion, and the operation fails.</p>
<p>For <code>IN/INOUT</code> binds, when <code>OCI_ATTR_MAXDATA_SIZE</code> attribute is set, the bind buffer must be large enough to hold the number of characters multiplied by the bytes in each character of the character set.</p>
<p>If <code>OCI_ATTR_MAXCHAR_SIZE</code> is set to a nonzero value such as 100, then if the character set has 2 bytes in each character, the minimum possible allocated size is 200 bytes.</p>
<p>The following scenarios demonstrate some uses of the <code>OCI_ATTR_MAXDATA_SIZE</code> attribute:</p>
<ul>
<li>
<p>Scenario 1: <code>CHAR</code> (source data) converted to non-<code>CHAR</code> (destination column)</p>
<p>There are implicit bind conversions of the data. The recommended value of <code>OCI_ATTR_MAXDATA_SIZE</code> is the size of the source buffer multiplied by the worst-case expansion factor between the client and Oracle Database character sets.</p>
</li>
<li>
<p>Scenario 2: <code>CHAR</code> (source data) converted to <code>CHAR</code> (destination column) or non-<code>CHAR</code> (source data) converted to <code>CHAR</code> (destination column)</p>
<p>The recommended value of <code>OCI_ATTR_MAXDATA_SIZE</code> is the size of the column.</p>
</li>
<li>
<p>Scenario 3: CHAR (source data) converted to a PL/SQL variable</p>
<p>In this case, the recommended value of <code>OCI_ATTR_MAXDATA_SIZE</code> is the size of the PL/SQL variable.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i436084"></a>
<div id="LNOCI16416" class="sect3">
<h4 class="sect3">Using the <a id="sthref818"></a>OCI_ATTR_MAXCHAR_SIZE Attribute</h4>
<p><code>OCI_ATTR_MAXCHAR_SIZE</code> enables processing to work with data in terms of number of characters, rather than number of bytes.</p>
<p>For binds, the <code>OCI_ATTR_MAXCHAR_SIZE</code> attribute sets the number of characters reserved in the Oracle database to store the bind data.</p>
<p>For example, if OCI_ATTR_MAXDATA_SIZE is set to 100, and <code>OCI_ATTR_MAXCHAR_SIZE</code> is set to 0, then the maximum possible size of the data in the Oracle database after conversion is 100 bytes. However, if <code>OCI_ATTR_MAXDATA_SIZE</code> is set to 300, and <code>OCI_ATTR_MAXCHAR_SIZE</code> is set to a nonzero value, such as 100, then if the character set has 2 bytes/character, the maximum possible allocated size is 200 bytes.</p>
<p>For defines, the <code>OCI_ATTR_MAXCHAR_SIZE</code> attribute specifies the maximum number of characters that the client application allows in the return buffer. Its derived byte length overrides the <code>maxlength</code> parameter specified in the <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> call.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Regardless of the value of the attribute <code>OCI_ATTR_MAXCHAR_SIZE</code>, the buffer lengths specified in a bind or define call are always in terms of bytes. The actual length values sent and received by you are also in bytes.</div>
</div>
<!-- class="sect3" -->
<a id="i435935"></a>
<div id="LNOCI16417" class="sect3">
<h4 class="sect3">Buffer Expansion During OCI Binding<a id="sthref819"></a><a id="sthref820"></a></h4>
<p>Do not set <code>OCI_ATTR_MAXDATA_SIZE</code> for <code>OUT</code> binds or for PL/SQL binds. Only set <code>OCI_ATTR_MAXDATA_SIZE</code> for <code>INSERT</code> or <code>UPDATE</code> statements.</p>
<p>If neither of these two attributes is set, OCI expands the buffer using its best estimates.</p>
<a id="i432029"></a>
<div id="LNOCI16418" class="sect4">
<h5 class="sect4">IN Binds</h5>
<p>For an <code>IN</code> bind, if the underlying column was created using <a id="sthref821"></a>character-length semantics, then it is preferable to specify the constraint using <code>OCI_ATTR_MAXCHAR_SIZE</code>. As long as the actual buffer contains fewer characters than specified in <code>OCI_ATTR_MAXCHAR_SIZE</code>, no constraints are violated at OCI level.</p>
<p>If the underlying column was created using byte-length semantics, then use <code>OCI_ATTR_MAXDATA_SIZE</code> in the bind handle to specify the byte constraint on the server. If you also specify an <code>OCI_ATTR_MAXCHAR_SIZE</code> value, then this constraint is imposed when allocating the receiving buffer on the server side.</p>
</div>
<!-- class="sect4" -->
<div id="LNOCI16419" class="sect4"><a id="sthref822"></a>
<h5 class="sect4">Dynamic SQL</h5>
<p>For dynamic SQL, you can use the explicit describe to get <code>OCI_ATTR_DATA_SIZE</code> and <code>OCI_ATTR_CHAR_SIZE</code> in parameter handles, as a guide for setting <code>OCI_ATTR_MAXDATA_SIZE</code> and <code>OCI_ATTR_MAXCHAR_SIZE</code> attributes in bind handles. It is a good practice to specify <code>OCI_ATTR_MAXDATA_SIZE</code> and <code>OCI_ATTR_MAXCHAR_SIZE</code> to be no more than the actual column width in bytes or characters.</p>
</div>
<!-- class="sect4" -->
<div id="LNOCI16420" class="sect4"><a id="sthref823"></a>
<h5 class="sect4">Buffer Expansion During Inserts</h5>
<p>Use <code>OCI_ATTR_MAXDATA_SIZE</code> to avoid unexpected behavior caused by buffer expansion during inserts.</p>
<p>Consider what happens when the database column has <a id="sthref824"></a>character-length semantics, and the user tries to insert data using <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> or <a href="oci16rel003.htm#i456223">OCIBindByName()</a> while setting only the <code>OCI_ATTR_MAXCHAR_SIZE</code> to 3000 bytes. The database character set is UTF8 and the client character set is ASCII. Then, in this case although 3000 characters fits in a buffer of size 3000 bytes for the client, on the server side it might expand to more than 4000 bytes. Unless the underlying column is a <code>LONG</code> or a LOB type, the server returns an error. To avoid this problem specify the <code>OCI_ATTR_MAXDATA_SIZE</code> to be 4000 to guarantee that the Oracle database never exceeds 4000 bytes.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNOCI16421" class="sect3"><a id="sthref825"></a>
<h4 class="sect3">Constraint Checking During Defining</h4>
<p>To select data from columns into client buffers, OCI uses defined variables. You can set an <code>OCI_ATTR_MAXCHAR_SIZE</code> value on the define buffer to impose an additional character-length constraint. There is no <code>OCI_ATTR_MAXDATA_SIZE</code> attribute for define handles because the buffer size in bytes serves as the limit on byte length. The define buffer size provided in the <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> call can be used as the byte constraint.</p>
<div id="LNOCI16422" class="sect4"><a id="sthref826"></a>
<h5 class="sect4">Dynamic SQL Selects</h5>
<p>When sizing buffers for dynamic SQL, always use the <code>OCI_ATTR_DATA_SIZE</code> value in the implicit describe to avoid data loss through truncation. If the database column is created using <a id="sthref827"></a>character-length semantics known through the <code>OCI_ATTR_CHAR_USED</code> attribute, then you can use the <code>OCI_ATTR_MAXCHAR_SIZE</code> value to set an additional constraint on the define buffer. A maximum number of <code>OCI_ATTR_MAXCHAR_SIZE</code> characters is put in the buffer.</p>
</div>
<!-- class="sect4" -->
<div id="LNOCI16423" class="sect4"><a id="sthref828"></a>
<h5 class="sect4">Return Lengths</h5>
<p>The following return length values are always in bytes regardless of the character-length semantics of the database:</p>
<ul>
<li>
<p>The value returned in the <code>alen</code>, or the actual length field in binds and defines</p>
</li>
<li>
<p>The value that appears in the length, prefixed in special data types such as <code>VARCHAR</code> and <code>LONG</code> <code>VARCHAR</code></p>
</li>
<li>
<p>The value of the indicator variable in case of truncation</p>
</li>
</ul>
<p>The only exception to this rule is for string buffers in the <code>OCI_UTF16ID</code> character set ID; then the return lengths are in UTF-16 units.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The buffer sizes in the bind and define calls and the piece sizes in the <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> and <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> and the callbacks are always in bytes.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="LNOCI16424" class="sect3"><a id="sthref829"></a>
<h4 class="sect3">General Compatibility Issues for Character-Length Semantics in OCI</h4>
<ul>
<li>
<p>For a release 9.0 or later client communicating with a release 8.1 or earlier Oracle database, <code>OCI_ATTR_MAXCHAR_SIZE</code> is not known by the Oracle database, so this value is ignored. If you specify only this value, OCI derives the corresponding <code>OCI_ATTR_MAXDATA_SIZE</code> value based on the maximum number of bytes for each character for the client-side character set.</p>
</li>
<li>
<p>For a release 8.1 or earlier client communicating with a release 9.0 or later Oracle database, the client can never specify an <code>OCI_ATTR_MAXCHAR_SIZE</code> value, so the Oracle database considers the client as always expecting byte-length semantics. This is similar to the situation when the client specifies only <code>OCI_ATTR_MAXDATA_SIZE</code>.</p>
</li>
</ul>
<p>So in both cases, the Oracle database and client can exchange information in an appropriate manner.</p>
<div id="LNOCI16425" class="sect4"><a id="sthref830"></a>
<h5 class="sect4">Code Example for Inserting and Selecting Using OCI_ATTR_MAXCHAR_SIZE</h5>
<p>When a column is created by specifying a number <code>N</code> of characters, the actual allocation in the database considers the worst case scenario, as shown in <a href="#CIHICCAH">Example 5-20</a>. The real number of bytes allocated is a multiple of <code>N</code>, say <code>M</code> times <code>N</code>. Currently, <code>M</code> is 3 as the maximum number of bytes allocated for each character in UTF-8.</p>
<p>For example, in <a href="#CIHICCAH">Example 5-20</a>, in the <code>EMP</code> table, the <code>ENAME</code> column is defined as 30 characters and the <code>ADDRESS</code> column is defined as 80 characters. Thus, the corresponding byte lengths in the database are M*30 or 3*30=90, and M*80 or 3*80=240, respectively.</p>
<div id="LNOCI18161" class="example">
<p class="titleinexample"><a id="CIHICCAH"></a>Example 5-20 Insert and Select Operations Using the OCI_ATTR_MAXCHAR_SIZE Attribute</p>
<pre>
...
utext ename[31], address[81];
/* E' &lt;= 30+ 1, D' &lt;= 80+ 1, considering null-termination */
sb4 ename_max_chars = EC=20, address_max_chars = ED=60;
 /* EC &lt;= (E' - 1), ED &lt;= (D' - 1) */
sb4 ename_max_bytes = EB=80, address_max_bytes = DB=200;
 /* EB &lt;= M * EC, DB &lt;= M * DC */
text *insstmt = (text *)"INSERT INTO EMP(ENAME, ADDRESS) VALUES (:ENAME, \
:ADDRESS)";
text *selstmt = (text *)"SELECT ENAME, ADDRESS FROM EMP";
...
/* Inserting Column Data */
OCIStmtPrepare(stmthp1, errhp, insstmt, (ub4)strlen((char *)insstmt),
    (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (text *)":ENAME",
    (sb4)strlen((char *)":ENAME"),
    (void *)ename, sizeof(ename), SQLT_STR, (void *)&amp;insname_ind,
    (ub2 *)alenp, (ub2 *)rcodep, (ub4)maxarr_len, (ub4 *)curelep, OCI_DEFAULT);
/* either */
OCIAttrSet((void *)bnd1p, (ub4)OCI_HTYPE_BIND, (void *)&amp;ename_max_bytes,
    (ub4)0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp);
/* or */
OCIAttrSet((void *)bnd1p, (ub4)OCI_HTYPE_BIND, (void *)&amp;ename_max_chars,
    (ub4)0, (ub4)OCI_ATTR_MAXCHAR_SIZE, errhp);
...
/* Retrieving Column Data */
OCIStmtPrepare(stmthp2, errhp, selstmt, strlen((char *)selstmt),
    (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIDefineByPos(stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
   (sb4)sizeof (ename),
   SQLT_STR, (void *)&amp;selname_ind, (ub2 *)alenp, (ub2 *)rcodep,
   (ub4)OCI_DEFAULT);
/* if not called, byte semantics is by default */
OCIAttrSet((void *)dfn1p, (ub4)OCI_HTYPE_DEFINE, (void *)&amp;ename_max_chars,
   (ub4)0,
   (ub4)OCI_ATTR_MAXCHAR_SIZE, errhp);
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<div id="LNOCI16426" class="sect4"><a id="sthref831"></a>
<h5 class="sect4">Code Example for UTF-16 Binding and Defining<a id="sthref832"></a></h5>
<p>The character set ID in bind and define of the <code>CHAR</code> or <code>VARCHAR2</code>, or in <code>NCHAR</code> or <code>NVARCHAR2</code> variant handles can be set to assume that all data is passed in UTF-16 (Unicode) encoding. To specify UTF-16, set <code>OCI_ATTR_CHARSET_ID</code> = <code>OCI_UTF16ID</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i430016">"Bind Handle Attributes"</a></div>
<p>OCI provides a typedef called <span class="italic"><a id="sthref833"></a><a id="sthref834"></a></span><code>utext</code> to facilitate binding and defining of UTF-16 data. The internal representation of <code>utext</code> is a 16-bit unsigned integer, <code>ub2</code>. Operating systems where the encoding scheme of the <code>wchar_t</code> data type conforms to UTF-16 can easily convert <code>utext</code> to the <code>wchar_t</code> data type using cast operators.</p>
<p>Even for UTF-16 data, the buffer size in bind and define calls is assumed to be in bytes. Users should use the <code>utext</code> data type as the buffer for input and output data.</p>
<p><a href="#CIHDCJAF">Example 5-21</a> shows pseudocode that illustrates a bind and define for UTF-16 data.</p>
<div id="LNOCI18162" class="example">
<p class="titleinexample"><a id="CIHDCJAF"></a>Example 5-21 Binding and Defining UTF-16 Data</p>
<pre>
...
OCIStmt  *stmthp1, *stmthp2;
OCIDefine *dfn1p, *dfn2p;
OCIBind *bnd1p, *bnd2p;
text *insstmt=
      (text *) "INSERT INTO EMP(ENAME, ADDRESS) VALUES (:ename, :address)"; \
text *selname =
      (text *) "SELECT ENAME, ADDRESS FROM EMP";
utext ename[21];   /* Name -    UTF-16 */
utext address[51]; /* Address - UTF-16 */
ub2 csid = OCI_UTF16ID;
sb4 ename_col_len = 20;
sb4 address_col_len = 50;
...
/* Inserting UTF-16 data */
OCIStmtPrepare (stmthp1, errhp, insstmt, (ub4)strlen ((char *)insstmt),
                (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIBindByName (stmthp1, &amp;bnd1p, errhp, (text*)":ENAME",
              (sb4)strlen((char *)":ENAME"),
              (void *) ename, sizeof(ename), SQLT_STR,
              (void *)&amp;insname_ind, (ub2 *) 0, (ub2 *) 0, (ub4) 0,
              (ub4 *)0, OCI_DEFAULT);
OCIAttrSet ((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp);
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp);
...
/* Retrieving UTF-16 data */
OCIStmtPrepare (stmthp2, errhp, selname, strlen((char *) selname),
                (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
                (sb4)sizeof(ename), SQLT_STR,
                (void *)0, (ub2 *)0, (ub2 *)0, (ub4)OCI_DEFAULT);
OCIAttrSet ((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid,
            (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp);
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i423493"></a>
<div id="LNOCI16427" class="sect1">
<h2 class="sect1">PL/SQL REF CURSORs and Nested Tables in OCI<a id="sthref835"></a><a id="sthref836"></a><a id="sthref837"></a></h2>
<p>OCI provides the ability to bind and define PL/SQL <code>REF</code> <code>CURSOR</code>s and nested tables. An application can use a statement handle to bind and define these types of variables. As an example, consider this PL/SQL block:</p>
<pre>
static const text *plsql_block = (text *)
  "begin \
     OPEN :cursor1 FOR SELECT employee_id, last_name, job_id, manager_id, \
             salary, department_id \
             FROM employees WHERE job_id=:job ORDER BY employee_id; \
     OPEN :cursor2 FOR SELECT * FROM departments ORDER BY department_id;
  end;";
</pre>
<p>An application allocates a statement handle for binding by calling <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>, and then binds the <code>:cursor1</code> placeholder to the statement handle, as in the following code, where <code>:cursor1</code> is bound to <code>stm2p</code>.</p>
<div id="LNOCI18163" class="example">
<p class="titleinexample"><a id="CIHGGCFF"></a>Example 5-22 Binding the :cursor1 Placeholder to the Statement Handle stm2p as a REF CURSOR</p>
<pre>
status = OCIStmtPrepare (stm1p, errhp, (text *) plsql_block,
             strlen((char *)plsql_block), OCI_NTV_SYNTAX, OCI_DEFAULT);
...
status = OCIBindByName (stm1p, (OCIBind **) &amp;bnd1p, errhp,
             (text *)":cursor1", (sb4)strlen((char *)":cursor1"),
             (void *)&amp;stm2p, (sb4) 0,  SQLT_RSET, (void *)0,
               (ub2 *)0, (ub2 *)0, (ub4)0, (ub4 *)0,   (ub4)OCI_DEFAULT);
</pre></div>
<!-- class="example" -->
<p>In this code in <a href="#CIHGGCFF">Example 5-22</a>, <code>stm1p</code> is the statement handle for the PL/SQL block, whereas <code>stm2p</code> is the statement handle that is bound as a <code>REF</code> <code>CURSOR</code> for later data retrieval. A value of <code>SQLT_RSET</code> is passed for the <code>dty</code> parameter.</p>
<p>As another example, consider the following:</p>
<pre>
static const text *nst_tab = (text *)
       "SELECT last_name, CURSOR(SELECT department_name, location_id \
        FROM  departments)  FROM employees WHERE last_name = 'FORD'";
</pre>
<p>The second position is a nested table, which an OCI application can define as a statement handle shown in <a href="#CIHDFFHJ">Example 5-23</a>.</p>
<div id="LNOCI18164" class="example">
<p class="titleinexample"><a id="CIHDFFHJ"></a>Example 5-23 Defining a Nested Table (Second Position) as a Statement Handle</p>
<pre>
status = OCIStmtPrepare (stm1p, errhp, (text *) nst_tab, 
         strlen((char *)nst_tab), OCI_NTV_SYNTAX, OCI_DEFAULT);
...
status = OCIDefineByPos (stm1p, (OCIDefine **) &amp;dfn2p, errhp, (ub4)2, 
          (void *)&amp;stm2p, (sb4)0, SQLT_RSET, (void *)0, (ub2 *)0,
                     (ub2 *)0, (ub4)OCI_DEFAULT);
</pre></div>
<!-- class="example" -->
<p>After execution, when you fetch a row into <code>stm2p</code> it becomes a valid statement handle.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have retrieved multiple <code>REF</code> <code>CURSOR</code>s, you must take care when fetching them into <code>stm2p</code>. If you fetch the first one, you can then perform fetches on it to retrieve its data. However, after you fetch the second <code>REF</code> <code>CURSOR</code> into <code>stm2p</code>, you no longer have access to the data from the first <code>REF</code> <code>CURSOR</code>.
<p>OCI does not support PL/SQL <code>REF</code> <code>CURSOR</code>s that were executed in scrollable mode.</p>
<p>OCI does not support scrollable <code>REF</code> <code>CURSOR</code>s because you cannot scroll back to the rows already fetched by a <code>REF</code> <code>CURSOR</code>.</p>
</div>
</div>
<!-- class="sect1" -->
<a id="i427753"></a>
<div id="LNOCI059" class="sect1">
<h2 class="sect1">Runtime Data Allocation and Piecewise Operations in OCI<a id="sthref838"></a><a id="sthref839"></a><a id="sthref840"></a><a id="sthref841"></a><a id="sthref842"></a><a id="sthref843"></a></h2>
<p>You can use OCI to perform piecewise inserts, updates, and fetches of data. You can also use OCI to provide data dynamically in case of array inserts or updates, instead of providing a static array of bind values. You can insert or retrieve a very large column as a series of chunks of smaller size, minimizing client-side memory requirements.</p>
<p>The size of individual pieces is determined at run time by the application and can be uniform or not.</p>
<p>The piecewise functionality of OCI is particularly useful when performing operations on extremely large blocks of string or binary data, operations involving database columns that store <code>CLOB</code>, <code>BLOB</code>, <code>LONG</code>, <code>RAW</code>, or <code>LONG</code> <code>RAW</code> data.</p>
<p>The piecewise fetch is complete when the final <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> call returns a value of OCI_SUCCESS.</p>
<p>In both the piecewise fetch and insert, it is important to understand the sequence of calls necessary for the operation to complete successfully. For a piecewise insert, you must call <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> one time more than the number of pieces to be inserted (if callbacks are not used). This is because the first time <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> is called, it returns a value indicating that the first piece to be inserted is required. As a result, if you are inserting <span class="italic">n</span> pieces, you must call <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> a total of <span class="italic">n+1</span> times.</p>
<p>Similarly, when performing a piecewise fetch, you must call <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> once more than the number of pieces to be fetched.</p>
<div id="LNOCI16428" class="sect2"><a id="sthref844"></a>
<h3 class="sect2">Valid Data Types for Piecewise Operations<a id="sthref845"></a><a id="sthref846"></a></h3>
<p>Only some data types can be manipulated in pieces. OCI applications can perform piecewise fetches, inserts, or updates of all the following data types:</p>
<ul>
<li>
<p><code>VARCHAR2</code></p>
</li>
<li>
<p><code>STRING</code></p>
</li>
<li>
<p><code>LONG</code></p>
</li>
<li>
<p><code>LONG</code> <code>RAW</code></p>
</li>
<li>
<p><code>RAW</code></p>
</li>
<li>
<p><code>CLOB</code></p>
</li>
<li>
<p><code>BLOB</code></p>
</li>
</ul>
<p>Another way of using this feature for all data types is to provide data dynamically for array inserts or updates. The callbacks should always specify <code>OCI_ONE_PIECE</code> for the <code>piecep</code> parameter of the callback for data types that do not support piecewise operations.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16429" class="sect2"><a id="sthref847"></a>
<h3 class="sect2">Types of Piecewise Operations</h3>
<p>You can perform piecewise operations in two ways:</p>
<ul>
<li>
<p>Use calls provided in the OCI library to execute piecewise operations under a polling paradigm.</p>
</li>
<li>
<p>Employ user-defined callback functions to provide the necessary information and data blocks.</p>
</li>
</ul>
<p>When you set the <code>mode</code> parameter of an <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> or <a href="oci16rel003.htm#i456223">OCIBindByName()</a> call to <code>OCI_DATA_AT_EXEC</code>, it indicates that an OCI application is providing data for an <code>INSERT</code> or <code>UPDATE</code> operation dynamically at runtime.</p>
<p>Similarly, when you set the <code>mode</code> parameter of an <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> call to <code>OCI_DYNAMIC_FETCH</code>, it indicates that an application dynamically provides allocation space for receiving data at the time of the fetch.</p>
<p>In each case, you can provide the runtime information for the <code>INSERT</code>, <code>UPDATE</code>, or <code>FETCH</code> operation in one of two ways: through callback functions, or by using piecewise operations. If callbacks are desired, an additional bind or define call is necessary to register the callbacks.</p>
<p>The following sections give specific information about runtime data allocation and piecewise operations for inserts, updates, and fetches.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Piecewise operations are also valid for SQL and PL/SQL blocks.</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16430" class="sect2"><a id="sthref848"></a>
<h3 class="sect2">Providing INSERT or UPDATE Data at Runtime<a id="sthref849"></a><a id="sthref850"></a><a id="sthref851"></a></h3>
<p>When you specify the <code>OCI_DATA_AT_EXEC</code> mode in a call to <a href="oci16rel003.htm#i456224">OCIBindByPos()</a> or <a href="oci16rel003.htm#i456223">OCIBindByName()</a>, the <code>value_sz</code> parameter defines the total size of the data that can be provided at run time. The application must be ready to provide to the OCI library the run time <code>IN</code> data buffers on demand as many times as is necessary to complete the operation. When the allocated buffers are no longer required, they must be freed by the client.</p>
<p>Runtime data is provided in one of two ways:</p>
<ul>
<li>
<p>You can define a callback using the <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> function, which when called at run time returns either a piece of the data or all of it.</p>
</li>
<li>
<p>If no callbacks are defined, the call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> to process the SQL statement returns the <code>OCI_NEED_DATA</code> error code. The client application then provides the <code>IN/OUT</code> data buffer or piece using the <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> call that specifies which bind and piece are being used.</p>
</li>
</ul>
<div id="LNOCI16431" class="sect3"><a id="sthref852"></a>
<h4 class="sect3">Performing a Piecewise Insert or Update</h4>
<p>Once the OCI environment has been initialized, and a database connection and session have been established, a piecewise insert begins with calls to prepare a SQL or PL/SQL statement and to bind input values. Piecewise operations using standard OCI calls rather than user-defined callbacks do not require a call to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Additional bind variables that are not part of piecewise operations may require additional bind calls, depending on their data types.</div>
<p>Following the statement preparation and bind, the application performs a series of calls to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>, <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a>, and <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> to complete the piecewise operation. Each call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> returns a value that determines what action should be performed next. In general, the application retrieves a value indicating that the next piece must be inserted, populates a buffer with that piece, and then executes an insert. When the last piece has been inserted, the operation is complete.</p>
<p>Keep in mind that the insert buffer can be of arbitrary size and is provided at run time. In addition, each inserted piece does not need to be of the same size. The size of each piece to be inserted is established by each <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> call.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the same piece size is used for all inserts, and the size of the data being inserted is not evenly divisible by the piece size, the final inserted piece is expected to be smaller. You must account for this by indicating the smaller size in the final <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> call.</div>
<p>The procedure is illustrated in <a href="#i440828">Figure 5-3</a> and expanded in the steps following the figure.</p>
<div id="LNOCI16432" class="figure">
<p class="titleinfigure"><a id="i440828"></a>Figure 5-3 Performing Piecewise Insert</p>
<img width="539" height="244" src="img/lnoci025.gif" alt="Description of Figure 5-3 follows" /><br />
<a id="sthref853" href="img_text/lnoci025.htm">Description of "Figure 5-3 Performing Piecewise Insert"</a><br />
<br /></div>
<!-- class="figure" -->
<ol>
<li>
<p>Initialize the OCI environment, allocate the necessary handles, connect to a server, authorize a user, and prepare a statement request by using <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a>.</p>
</li>
<li>
<p>Bind a placeholder by using <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>. You do not need to specify the actual size of the pieces you use, but you must provide the total size of the data that can be provided at run time.</p>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> for the first time. No data is being inserted here, and the <code>OCI_NEED_DATA</code> error code is returned to the application. If any other value is returned, it indicates that an error occurred.</p>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> to retrieve information about the piece that must be inserted. The parameters of <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> include a pointer to a value indicating if the required piece is the first piece, <code>OCI_FIRST_PIECE</code>, or a subsequent piece, <code>OCI_NEXT_PIECE</code>.</p>
</li>
<li>
<p>The application populates a buffer with the piece of data to be inserted and calls <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> with these parameters:</p>
<ul>
<li>
<p>A pointer to the piece</p>
</li>
<li>
<p>A pointer to the length of the piece</p>
</li>
<li>
<p>A value indicating whether this is the first piece (<code>OCI_FIRST_PIECE</code>), an intermediate piece (<code>OCI_NEXT_PIECE</code>), or the last piece (<code>OCI_LAST_PIECE</code>)</p>
</li>
</ul>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> again. If <code>OCI_LAST_PIECE</code> was indicated in Step 5 and <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> returns <code>OCI_SUCCESS</code>, all pieces were inserted successfully. If <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> returns <code>OCI_NEED_DATA</code>, go back to Step 3 for the next insert. If <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> returns any other value, an error occurred.</p>
</li>
</ol>
<p>The piecewise operation is complete when the final piece has been successfully inserted. This is indicated by the <code>OCI_SUCCESS</code> return value from the final <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call.</p>
<p>Piecewise updates are performed in a similar manner. In a piecewise update operation the insert buffer is populated with data that is being updated, and <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> is called to execute the update.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#BCFDHCIG">"Polling Mode Operations in OCI"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16433" class="sect2"><a id="sthref854"></a>
<h3 class="sect2">Piecewise Operations with PL/SQL<a id="sthref855"></a><a id="sthref856"></a></h3>
<p>An OCI application can perform piecewise operations with PL/SQL for <code>IN</code>, <code>OUT</code>, and <code>IN/OUT</code> bind variables in a method similar to that outlined previously. Keep in mind that all placeholders in PL/SQL statements are bound, rather than defined. The call to <a href="oci16rel003.htm#i444015">OCIBindDynamic()</a> specifies the appropriate callbacks for <code>OUT</code> or <code>IN/OUT</code> parameters.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI18165" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref857"></a>
<h3 class="sect2">PL/SQL Indexed Table Binding Support</h3>
<p>PL/SQL indexed tables can be passed as <code>IN/OUT</code> binds into PL/SQL anonymous blocks using OCI. The procedure for binding PL/SQL indexed tables is quite similar to performing an array bind for SQL statements. The OCI program must bind the location of an array with other metadata for the array as follows, using either <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>.The process of binding a C array into a PL/SQL indexed table bind variable must provide the following information during the bind call:</p>
<ul>
<li>
<p><code>void *valuep (IN/OUT)</code> - A pointer to a location that specifies the beginning of the array in client memory</p>
</li>
<li>
<p><code>ub2 dty (IN)</code> - The data type of the elements of the array as represented on the client</p>
</li>
<li>
<p><code>sb4 value_sz (IN)</code> - The maximum size (in bytes) of each element of the array as represented on the client</p>
</li>
<li>
<p><code>ub4 maxarr_len (IN)</code> - The maximum number of elements of the data type the array is expected to hold in its lifetime</p>
<p>If allocating the entire array up front for doing static bindings, the array must be sized sufficiently to contain <code>maxarr_len</code> number of elements, each of size <code>value_sz</code>. This information is also used to constrain the indexed table as seen by PL/SQL. PL/SQL cannot look up the indexed table (either for read or write) beyond this specified limit.</p>
</li>
<li>
<p><code>ub4 *curelep (IN/OUT)</code> - A pointer to the number of elements in the array (from the beginning of the array) that are currently valid.</p>
<p>This should be less than or equal to the maximum array length. Note that this information is also used to constrain the indexed table as seen by PL/SQL. For <code>IN</code> binds, PL/SQL cannot read from the indexed table beyond this specified limit. For <code>OUT</code> binds, PL/SQL can write to the indexed table beyond this limit, but not beyond the <code>maxarr_len</code> limit.</p>
</li>
</ul>
<p>For <code>IN</code> indexed table binds, before performing <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>, the user must set up the current array length (<code>*curelep</code>) for that execution. In addition, the user also must set up the actual length and indicator as applicable for each element of the array.</p>
<p>For <code>OUT</code> binds, OCI must return the current array length (<code>*curelep</code>) and the actual length, indicator and return code as applicable for each element of the array.</p>
<p>For best performance, keep the array allocated with maximum array length, and then vary the current array length between executes based on how many elements are actually being passed back and forth. Such an approach does not require repeatedly deallocating and reallocating the array for every execute, thereby helping overall application performance.</p>
<p>It is also possible to bind using OCI piecewise calls for PL/SQL indexed tables. Such an approach does not require preallocating the entire array up front. The <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> and <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> calls can be used to pass in individual elements piecewise.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i456223">"OCIBindByName()"</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456224">"OCIBindByPos()"</a></p>
</li>
</ul>
</div>
<div id="LNOCI18166" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref858"></a>
<h4 class="sect3">Restrictions</h4>
<p>The PL/SQL indexed table OCI binding interface does not support binding:</p>
<ul>
<li>
<p>Arrays of ADTs or <code>REF</code>s</p>
</li>
<li>
<p>Arrays of descriptor types such as LOB descriptors, ROWID descriptors, datetime or interval descriptors</p>
</li>
<li>
<p>Arrays of PLSQL record types</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16434" class="sect2"><a id="sthref859"></a>
<h3 class="sect2">Providing FETCH Information at Run Time<a id="sthref860"></a><a id="sthref861"></a></h3>
<p>When a call is made to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> with the <code>mode</code> parameter set to <code>OCI_DYNAMIC_FETCH</code>, an application can specify information about the data buffer at the time of fetch. You may also need to call <a href="oci16rel003.htm#i444226">OCIDefineDynamic()</a> to set a callback function that is invoked to get information about your data buffer.</p>
<p>Runtime data is provided in one of two ways:</p>
<ul>
<li>
<p>You can define a callback using the <a href="oci16rel003.htm#i444226">OCIDefineDynamic()</a> function. The <code>value_sz</code> parameter defines the maximum size of the data that is provided at run time. When the client library needs a buffer to return the fetched data, the callback is invoked to provide a runtime buffer into which either a piece of the data or all of it is returned.</p>
</li>
<li>
<p>If no callbacks are defined, the <code>OCI_NEED_DATA</code> error code is returned and the <code>OUT</code> data buffer or piece can then be provided by the client application by using <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a>. The <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> call provides information about which define and which piece are involved.</p>
</li>
</ul>
<div id="LNOCI16435" class="sect3"><a id="sthref862"></a>
<h4 class="sect3">Performing a Piecewise Fetch<a id="sthref863"></a></h4>
<p>The fetch buffer can be of arbitrary size. In addition, each fetched piece does not need to be of the same size. The only requirement is that the size of the final fetch must be exactly the size of the last remaining piece. The size of each piece to be fetched is established by each <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> call. This process is illustrated in <a href="#i430634">Figure 5-4</a> and explained in the steps following the figure.</p>
<div id="LNOCI16436" class="figure">
<p class="titleinfigure"><a id="i430634"></a>Figure 5-4 Performing Piecewise Fetch</p>
<img width="539" height="244" src="img/lnoci026.gif" alt="Description of Figure 5-4 follows" /><br />
<a id="sthref864" href="img_text/lnoci026.htm">Description of "Figure 5-4 Performing Piecewise Fetch"</a><br />
<br /></div>
<!-- class="figure" -->
<ol>
<li>
<p>Initialize the OCI environment, allocate necessary handles, connect to a database, authorize a user, prepare a statement, and execute the statement by using <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>.</p>
</li>
<li>
<p>Define an output variable by using <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>, with <code>mode</code> set to <code>OCI_DYNAMIC_FETCH</code>. At this point you do not need to specify the actual size of the pieces you use, but you must provide the total size of the data that is to be fetched at run time.</p>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> for the first time. No data is retrieved, and the <code>OCI_NEED_DATA</code> error code is returned to the application. If any other value is returned, then an error occurred.</p>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> to obtain information about the piece to be fetched. The <code>piecep</code> parameter indicates whether it is the first piece (<code>OCI_FIRST_PIECE</code>), a subsequent piece (<code>OCI_NEXT_PIECE</code>), or the last piece (<code>OCI_LAST_PIECE</code>).</p>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> to specify the fetch buffer.</p>
</li>
<li>
<p>Call <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> again to retrieve the actual piece. If <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> returns <code>OCI_SUCCESS</code>, all the pieces have been fetched successfully. If <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> returns <code>OCI_NEED_DATA</code>, return to Step 4 to process the next piece. If any other value is returned, an error occurred.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#BCFDHCIG">"Polling Mode Operations in OCI"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i440746"></a>
<div id="LNOCI16437" class="sect2">
<h3 class="sect2">P<a id="sthref865"></a>iecewise Binds and Defines for LOBs</h3>
<p>There are two ways of doing piecewise binds and defines for LOBs:</p>
<ul>
<li>
<p>Using the data interface</p>
<p>You can bind or define character data for <code>CLOB</code> columns using <code>SQLT_CHR</code> (<code>VARCHAR2</code>) or <code>SQLT_LNG</code> (<code>LONG</code>) as the input data type for the following functions. You can also bind or define raw data for <code>BLOB</code> columns using <code>SQLT_LBI</code> (<code>LONG</code> <code>RAW</code>), and <code>SQLT_BIN</code> (<code>RAW</code>) as the input data type for these functions:</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i459315">OCIDefineByPos()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456224">OCIBindByPos()</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i440236">"Binding LOB Data"</a> for usage and examples for both <code>INSERT</code> and <code>UPDATE statements</code></p>
</li>
<li>
<p><a href="#i440237">"Defining LOB Data"</a> for usage and examples of <code>SELECT</code> statements</p>
</li>
</ul>
</div>
</li>
</ul>
<p>All the piecewise operations described later are supported for <code>CLOB</code> and <code>BLOB</code> columns in this case.</p>
</li>
<li>
<p>Using the LOB locator</p>
<p>You can bind or define a LOB locator for <code>CLOB</code> and <code>BLOB</code> columns using <code>SQLT_CLOB</code> (<code>CLOB</code>) or <code>SQLT_BLOB</code> (<code>BLOB</code>) as the input data type for the following functions.</p>
<ul>
<li>
<p><a href="oci16rel003.htm#i459315">OCIDefineByPos()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456223">OCIBindByName()</a></p>
</li>
<li>
<p><a href="oci16rel003.htm#i456224">OCIBindByPos()</a></p>
</li>
</ul>
<p>You must then call OCILob* functions to read and manipulate the data. <a href="oci17msc002.htm#i578721">OCILobRead2()</a> and <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> support piecewise and callback modes.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#i578721">"OCILobRead2()"</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i578761">"OCILobWrite2()"</a></p>
</li>
<li>
<p><a href="oci07lob.htm#i444634">"LOB Read and Write Callbacks"</a> for information about streaming using callbacks with <code>OCILobWrite2()</code> and <code>OCILobRead2()</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci04sql.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci06des.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
