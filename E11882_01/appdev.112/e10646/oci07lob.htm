<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>LOB and BFILE Operations</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:23Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci06des.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci08sca.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/79</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='oci07lob'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="LNOCI070" class="chapter"><a id="g452677"></a> <a id="i445959"></a>
<h1 class="chapter"><span class="secnum">7</span> LOB and BFILE Operations</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i444168">Using OCI Functions for LOBs</a></p>
</li>
<li>
<p><a href="#i444197">Creating and Modifying Persistent LOBs</a></p>
</li>
<li>
<p><a href="#i444225">Associating a BFILE in a Table with an Operating System File</a></p>
</li>
<li>
<p><a href="#i444247">LOB Attributes of an Object</a></p>
</li>
<li>
<p><a href="#i444270">Array Interface for LOBs</a></p>
</li>
<li>
<p><a href="#i444306">Using LOBs of Size Greater than 4 GB</a></p>
</li>
<li>
<p><a href="#i444493">LOB and BFILE Functions in OCI</a></p>
</li>
<li>
<p><a href="#i445781">Temporary LOB Support</a></p>
</li>
<li>
<p><a href="#CHDDHFAB">Prefetching of LOB Data, Length, and Chunk Size</a></p>
</li>
<li>
<p><a href="#CHDHIADG">Options of SecureFiles LOBs</a></p>
</li>
</ul>
<a id="i444168"></a>
<div id="LNOCI16500" class="sect1">
<h2 class="sect1">Using OCI Functions for LOBs</h2>
<p>OCI includes a set of functions for performing operations on large objects (LOBs) in a database. Persistent LOBs (<code>BLOB</code>s, <code>CLOB</code>s, <code>NCLOB</code>s) are stored in the database tablespaces in a way that optimizes space and provides efficient access. These LOBs have the full transactional support of the Oracle database. <code>BFILE</code>s are large data objects stored in the server's operating system files outside the database tablespaces.</p>
<p>OCI also provides support for temporary LOBs, which can be used like local variables for operating on LOB data.</p>
<p><code>BFILE</code>s are read-only. Oracle Database supports only binary <code>BFILE</code>s.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a href="ociabdem.htm#g462659">Appendix B</a> for code samples showing the use of LOBs</p>
</li>
<li>
<p><code>$ORACLE_HOME/rdbms/demo/lobs/oci/</code> for specific LOB code samples</p>
</li>
<li>
<p><a class="olink ARPLS020" href="../../appdev.112/e40758/d_lob.htm#ARPLS020"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for the <code>DBMS_LOB</code> package</p>
</li>
<li>
<p><a class="olink ADLOB001" href="../../appdev.112/e18294/adlob_intro.htm#ADLOB001"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i444197"></a>
<div id="LNOCI13233" class="sect1">
<h2 class="sect1">Creating and Modifying Persistent LOBs<a id="sthref1249"></a><a id="sthref1250"></a></h2>
<p>LOB instances can be either persistent (stored in the database) or temporary (existing only in the scope of your application). Do not confuse the concept of a persistent LOB with a persistent object.</p>
<p>There are two ways of creating and modifying persistent LOBs:</p>
<ul>
<li>
<p>Using the data interface</p>
<p>You can create a LOB by inserting character data into a <code>CLOB</code> column or <code>RAW</code> data into a <code>BLOB</code> column directly. You can also modify LOBs by using a SQL <code>UPDATE</code> statement, to bind character data into a <code>CLOB</code> column or <code>RAW</code> data into a <code>BLOB</code> column.</p>
<p>Insert, update, and select of remote LOBs (over a dblink) is supported because neither the remote server nor the local server is of a release earlier than Oracle Database 10<span class="italic">g</span> Release 2. The data interface only supports data size up to 2 GB &ndash; 1, the maximum size of an <code>sb4</code> data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB1300" href="../../appdev.112/e18294/adlob_data_interface.htm#ADLOB1300"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> chapter about data interface for persistent LOBs for more information and examples</div>
</li>
<li>
<p>Using the LOB locator</p>
<p>You create a new internal LOB by initializing a new LOB locator using <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a>, calling <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set it to empty (using the <code>OCI_ATTR_LOBEMPTY</code> attribute), and then binding the locator to a placeholder in an <code>INSERT</code> statement. Doing so inserts the empty locator into a table with a LOB column or attribute. You can then perform a <code>SELECT</code>...<code>FOR</code> <code>UPDATE</code> operation on this row to get the locator, and write to it using one of the OCI LOB functions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To modify a LOB column or attribute (write, copy, trim, and so forth), you must lock the row containing the LOB. One way to do this is to use a <code>SELECT...FOR UPDATE</code> statement to select the locator before performing the operation.</div>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i440236">"Binding LOB Data"</a> for usage and examples for both <code>INSERT</code> and <code>UPDATE</code></div>
<p>For any LOB write command to be successful, a transaction must be open. If you commit a transaction before writing the data, you must lock the row again (by reissuing the <code>SELECT...FOR UPDATE</code> statement, for example), because the commit closes the transaction.</p>
</div>
<!-- class="sect1" -->
<a id="i444225"></a>
<div id="LNOCI16501" class="sect1">
<h2 class="sect1">Associating a BFILE in a Table with an Operating System File<a id="sthref1251"></a></h2>
<p>The <code>BFILENAME</code> function can be used in an <code>INSERT</code> statement to associate an external server-side (operating system) file with a <code>BFILE</code> column or attribute in a table. Using <code>BFILENAME</code> in an <code>UPDATE</code> statement associates the <code>BFILE</code> column or attribute with a different operating system file. <a href="oci17msc002.htm#i450493">OCILobFileSetName()</a> can also be used to associate a <code>BFILE</code> in a table with an operating system file. <code>BFILENAME</code> is usually used in an <code>INSERT</code> or <code>UPDATE</code> statement without bind variables, and <a href="oci17msc002.htm#i450493">OCILobFileSetName()</a> is used for bind variables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#i450493">"OCILobFileSetName()"</a></p>
</li>
<li>
<p><a class="olink ADLOB45832" href="../../appdev.112/e18294/adlob_bfile_ops.htm#ADLOB45832"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for more information about the <code>BFILENAME</code> function</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i444247"></a>
<div id="LNOCI16502" class="sect1">
<h2 class="sect1">LOB Attributes of an Object</h2>
<p>An OCI application can use the <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> function to create a persistent or transient object with a LOB attribute.</p>
<div id="LNOCI16503" class="sect2"><a id="sthref1252"></a>
<h3 class="sect2">Writing to a LOB Attribute of an Object</h3>
<p>It is possible to use OCI to create a new persistent object with a LOB attribute and write to that LOB attribute. The application would follow these steps when using a <span class="italic">LOB locator</span>:</p>
<ol>
<li>
<p>Call <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> to create a persistent object with a LOB attribute.</p>
</li>
<li>
<p>Mark the object as "dirty" (modified).</p>
</li>
<li>
<p>Flush the object, thereby inserting a row into the table.</p>
</li>
<li>
<p>Repin the latest version of the object (or refresh the object), thereby retrieving the object from the database and acquiring a valid locator for the LOB.</p>
</li>
<li>
<p>Call <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> using the LOB locator in the object to write the data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci11obj.htm#i450885">Chapter 11</a> and the chapters that follow it for more information about objects</div>
</li>
</ol>
<p>There is a second way of writing to a LOB attribute. When using the <span class="italic">data interface</span>, you can bind or define character data for a <code>CLOB</code> attribute or <code>RAW</code> data for a <code>BLOB</code> attribute.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci05bnd.htm#i440236">"Binding LOB Data"</a> for usage and examples for both <code>INSERT</code> and <code>UPDATE statements</code></p>
</li>
<li>
<p><a href="oci05bnd.htm#i440237">"Defining LOB Data"</a> for usage and examples of <code>SELECT</code> statements</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i444265"></a>
<div id="LNOCI16504" class="sect2">
<h3 class="sect2">Transient Objects with LOB Attributes<a id="sthref1253"></a><a id="sthref1254"></a><a id="sthref1255"></a></h3>
<p>An application can call <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> and create a transient object with an internal LOB (<code>BLOB</code>, <code>CLOB</code>, <code>NCLOB</code>) attribute. However, you cannot perform any operations, such as read or write, on the LOB attribute because transient objects with LOB attributes are not supported. Calling <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> to create a transient internal LOB type does not fail, but the application cannot use any LOB operations with the transient LOB.</p>
<p>An application can, however, create a transient object with a <code>BFILE</code> attribute and use the <code>BFILE</code> attribute to read data from a file stored in the server's file system. The application can also call <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> to create a transient <code>BFILE</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i444270"></a>
<div id="LNOCI16505" class="sect1">
<h2 class="sect1">Array Interface for LOBs</h2>
<p>You can use the OCI array interface with LOBs, just as with any other data type. There are two ways of using the array interface.</p>
<ul>
<li>
<p>Using the data interface</p>
<p>You can bind or define arrays of character data for a <code>CLOB</code> column or <code>RAW</code> data for a <code>BLOB</code> column. You can use array bind and define interfaces to insert and select multiple rows with LOBs in <span class="italic">one round-trip</span> to the server.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci05bnd.htm#i440236">"Binding LOB Data"</a> for usage and examples for both <code>INSERT</code> and <code>UPDATE statements</code></p>
</li>
<li>
<p><a href="oci05bnd.htm#i440237">"Defining LOB Data"</a> for usage and examples of <code>SELECT</code> statements</p>
</li>
</ul>
</div>
</li>
<li>
<p>Using the LOB locator</p>
<p>When using the LOB locator you must allocate the descriptors, as shown in <a href="#BGBGJBJG">Example 7-1</a>.</p>
<div id="LNOCI18173" class="example">
<p class="titleinexample"><a id="BGBGJBJG"></a>Example 7-1 Using the LOB Locator and Allocating the Descriptors</p>
<pre>
/* First create an array of OCILobLocator pointers: */
OCILobLocator *lobp[10];

for (i=0; i &lt; 10; i++)
{ OCIDescriptorAlloc (...,&amp;lobp[i],...);

/* Then bind the descriptor as follows */
  OCIBindByPos(... &amp;lobp[i], ...);
</pre></div>
<!-- class="example" --></li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i444306"></a>
<div id="LNOCI16506" class="sect1">
<h2 class="sect1">Using LOBs of Size Greater than 4 GB<a id="sthref1256"></a><a id="sthref1257"></a></h2>
<p>Starting with Oracle Database 10<span class="italic">g</span> Release 1 of OCI, functions were introduced to support LOBs of size greater than 4 GB. These new functions can also be used in new applications for LOBs of less than 4 GB.</p>
<p>Oracle Database enables you to create tablespaces with block sizes different from the database block size. The maximum size of a LOB depends on the size of the tablespace blocks. The tablespace block size in which the LOB is stored controls the value of <code><a id="sthref1258"></a>CHUNK</code>, which is a parameter of LOB storage. When you create a LOB column, you specify a value for <code>CHUNK</code>, which is the number of bytes to be allocated for LOB manipulation. The value must be a multiple of the tablespace block size, or Oracle Database rounds up to the next multiple. (If the tablespace block size equals the database block size, then <code>CHUNK</code> is also a multiple of the database block size.) The default <code>CHUNK</code> size is one tablespace block, and the maximum value is 32 KB.</p>
<p>In this guide, 4 GB is defined as 4 gigabytes &ndash; 1, or 4,294,967,295 bytes. The maximum size of a LOB, persistent or temporary, is (4 gigabytes &ndash; 1) * (<code>CHUNK</code>). The maximum LOB size can range from 8 terabytes (TB) to 128 TB.</p>
<p>For example, suppose that your database block size is 32 KB and you create a tablespace with a nonstandard block size of 8 KB. Further suppose that you create a table with a LOB column and specify a <code>CHUNK</code> size of 16 KB (which is a multiple of the 8 KB tablespace block size). Then the maximum size of a LOB in this column is (4 gigabytes &ndash; 1) * 16 KB.</p>
<p>The maximum size of a <code><a id="sthref1259"></a>BFILE</code> is the maximum file size allowed in the operating system, or <code>UB8MAXVAL</code>, whichever is smaller.</p>
<p>Older LOB functions use <code>ub4</code> as the data types of some parameters, and the <code>ub4</code> data type can only hold up to 4 GB. The newer functions use parameters of 8-byte length, <code><a id="sthref1260"></a><a id="sthref1261"></a>oraub8</code>, which is a data type defined in <code>oratypes.h</code>. The data types <code>oraub8</code> and <code>orasb8</code> are mapped to appropriate 64-bit native data types depending on the compiler and operating system. Macros are used to not define <code>oraub8</code> and <code>orasb8</code> if compiling in 32-bit mode with strict ANSI option.</p>
<p><a href="oci17msc002.htm#i493090">OCILobGetChunkSize()</a><code><a id="sthref1262"></a></code> returns the usable chunk size in bytes for <code>BLOB</code>s, <code>CLOB</code>s, and <code>NCLOB</code>s. The number of bytes stored in a chunk is actually less than the size of the <code>CHUNK</code> parameter due to internal storage overhead. The function <a href="oci17msc002.htm#i578858">OCILobGetStorageLimit()</a> is provided to return the maximum size in bytes of internal LOBs in the current installation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database does not support <code>BFILE</code>s larger than 4 gigabytes in any programmatic environment. An additional file size limit imposed by your operating system also applies to <code>BFILE</code>s.</div>
<div id="LNOCI16507" class="sect2"><a id="sthref1263"></a>
<h3 class="sect2">Functions to Use for the Increased LOB Sizes</h3>
<p>Eight functions with names that end in "2" and that use the data type <code>oraub8</code> in place of the data type <code>ub4</code> were introduced in Oracle Database 10<span class="italic">g</span> Release 1. Other changes were made in the read and write functions (<a href="oci17msc002.htm#i578721">OCILobRead2()</a>, <a href="oci17msc002.htm#i578761">OCILobWrite2()</a>, and <a href="oci17msc002.htm#i578780">OCILobWriteAppend2()</a>) to solve several problems:</p>
<p>Problem: Before Oracle Database 10<span class="italic">g</span> Release 1, the parameter <code>amtp</code> assumed either byte or char length for LOBs based on the locator type and character set. It was complicated and users did not have the flexibility to use byte length or char length according to their requirements.</p>
<p>Solution: Read/Write calls should take both <code>byte_amtp</code> and <code>char_amtp</code> parameters as replacement for the <code>amtp</code> parameter. The <code>char_amtp</code> parameter is preferred for <code>CLOB</code> and <code>NCLOB</code>, and the <code>byte_amtp</code> parameter is only considered as input if <code>char_amtp</code> is zero. On output for <code>CLOB</code> and <code>NCLOB</code>, both <code>byte_amtp</code> and <code>char_amtp</code> parameters are filled. For <code>BLOB</code> and <code>BFILE</code>, the <code>char_ampt</code> parameter is ignored for both input and output.</p>
<p>Problem: For <a href="oci17msc002.htm#i578721">OCILobRead2()</a>, there is no flag to indicate polling mode. There is no easy way for the users to say "I have a 100-byte buffer. Fill it as much as you can." Previously, they had to estimate how many characters to specify for the amount. If they guessed too much, they were forced into polling mode unintentionally. The user code thus can get trapped in the polling mode and subsequent OCI calls are all blocked.</p>
<p>Solution: This call should take <code>piece</code> as an input parameter and if <code>OCI_ONE_PIECE</code> is passed, it should fill the buffer as much as possible and come out even if the amount indicated by the <code>byte_amtp</code> parameter or <code>char_amtp</code> parameter is more than the buffer length. The value of <code>bufl</code> is used to specify the maximum amount of bytes to read.</p>
<p>Problem: After calling for a LOB write in polling mode, users do not know how many chars or bytes are actually fetched till the end of the polling.</p>
<p>Solution: Both the <code>byte_amtp</code> and <code>char_amtp</code> parameters must be updated after each call in polling mode.</p>
<p>Problem: While reading or writing data in streaming mode with callback, users must use the same buffer for each piece of data.</p>
<p>Solution: The callback function must have two new parameters to provide the buffer and the buffer length. Callback functions can set the buffer parameter to <code>NULL</code> to follow old behavior: to use the default buffer passed in the first call for all the pieces.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#CIHEEEHI">"LOB Functions"</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i578721">"OCILobRead2()"</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i578761">"OCILobWrite2()"</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i578780">"OCILobWriteAppend2()"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16508" class="sect2"><a id="sthref1264"></a>
<h3 class="sect2">Compatibility and Migration</h3>
<p>Existing OCI programs can be enhanced to process larger amounts of LOB data that are greater than 4 GB. <a href="#g446324">Table 7-1</a> summarizes compatibility issues in this table, "old" refers to releases before Oracle Database 10<span class="italic">g</span> Release 1, and NA means not applicable.</p>
<div id="LNOCI16509" class="tblformalwide">
<p class="titleintable"><a id="sthref1265"></a><a id="g446324"></a>Table 7-1 LOB Functions Compatibility and Migration</p>
<table class="cellalignment1011" title="LOB Functions Compatibility and Migration " summary="This table is described in the preceding text" >
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t12">LOB Function</th>
<th class="cellalignment1012" id="r1c2-t12">Old Client/New or Old Server<a id="sthref1266" href="#sthref1266" onclick='footdisplay(1,"The term \"old\" refers to releases before Oracle Database 10g Release 1.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></th>
<th class="cellalignment1012" id="r1c3-t12">New Client/Old Server</th>
<th class="cellalignment1012" id="r1c4-t12">New Client/New Server</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#BJFEJABB">OCILobArrayRead()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t12 r1c2-t12">
<p><a id="sthref1267" href="#sthref1267" onclick='footdisplay(2,"NA means not applicable.")'><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a>NA</p>
</td>
<td class="cellalignment1013" headers="r2c1-t12 r1c3-t12">
<p>OK until piece size and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r2c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#BJFFHCBB">OCILobArrayWrite()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r3c1-t12 r1c3-t12">
<p>OK until piece size and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r3c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578816">OCILobCopy2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r4c1-t12 r1c3-t12">
<p>OK until LOB size, piece size (amount) and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r4c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#CEGFJBBG">OCILobCopy()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t12 r1c2-t12">
<p>OK; limit is 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r5c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r5c1-t12 r1c4-t12">
<p>OK; limit is 4 GB.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578657">OCILobErase2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r6c1-t12 r1c3-t12">
<p>OK until piece size and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r6c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i450663">OCILobErase()</a></code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t12 r1c2-t12">
<p>OK; limit is 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r7c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r7c1-t12 r1c4-t12">
<p>OK; limit is 4 GB.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578679">OCILobGetLength2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r8c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r8c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i555226">OCILobGetLength()</a></code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t12 r1c2-t12">
<p>OK; limit is 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r9c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r9c1-t12 r1c4-t12">
<p>OK; <code>OCI_ERROR</code> if LOB size &gt; 4 GB.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578701">OCILobLoadFromFile2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r10c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r10c1-t12 r1c3-t12">
<p>OK until LOB size, piece size (amount), and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r10c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i455168">OCILobLoadFromFile()</a></code></p>
</td>
<td class="cellalignment1013" headers="r11c1-t12 r1c2-t12">
<p>OK; limit is 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r11c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r11c1-t12 r1c4-t12">
<p>OK; limit is 4 GB.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578721">OCILobRead2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r12c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r12c1-t12 r1c3-t12">
<p>OK until LOB size, piece size (amount), and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r12c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i427817">OCILobRead()</a></code></p>
</td>
<td class="cellalignment1013" headers="r13c1-t12 r1c2-t12">
<p>OK; limit 4 GB.</p>
<p>With new server: <code>OCI_ERROR</code> is returned if you try to read any amount &gt;= 4 GB from any offset &lt; 4 GB. This is because when you read any amount &gt;= 4 GB, that results in an overflow of returned value in *amtp, and so it is flagged as an error.</p>
<p>Note:</p>
<ul>
<li>
<p>If you read up to 4 GB &ndash; 1 from offset, that is not flagged as an error.</p>
</li>
<li>
<p>When you use streaming mode with polling, no error is returned if no attempt is made to use piece size &gt; 4 GB (you can read data &gt; 4 GB in this case).</p>
</li>
</ul>
</td>
<td class="cellalignment1013" headers="r13c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r13c1-t12 r1c4-t12">
<p>OK.</p>
<p><code>OCI_ERROR</code> is returned if you try to read any amount &gt;= 4 GB from any offset &lt; 4 GB. This is because when you read any amount &gt;= 4 GB, that results in an overflow of returned value in *amtp, and so it is flagged as an error.</p>
<p>Note:</p>
<ul>
<li>
<p>If you read up to 4 GB &ndash; 1 from offset, that is not to be flagged as an error.</p>
</li>
<li>
<p>When you use streaming mode with polling, no error is returned if no attempt is made to use piece size &gt; 4 GB.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578743">OCILobTrim2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r14c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r14c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r14c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i427862">OCILobTrim()</a></code></p>
</td>
<td class="cellalignment1013" headers="r15c1-t12 r1c2-t12">
<p>OK; limit 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r15c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r15c1-t12 r1c4-t12">
<p>OK; limit 4 GB.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578761">OCILobWrite2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r16c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r16c1-t12 r1c3-t12">
<p>OK until LOB size, piece size (amount) and offset are &lt; 4 GB.</p>
</td>
<td class="cellalignment1013" headers="r16c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r17c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i427882">OCILobWrite()</a></code></p>
</td>
<td class="cellalignment1013" headers="r17c1-t12 r1c2-t12">
<p>OK; limit 4 GB.</p>
<p>With new server:</p>
<p><code>OCI_ERROR</code> is returned if you write any amount &gt;= 4 GB (from any offset &lt; 4 GB) because that results an in overflow of returned value in <code>*amtp</code>.</p>
<p>Note: Updating a LOB of 10 GB from any offset up to 4 GB &ndash;1 by up to 4 GB &ndash;1 amount of data is not flagged as an error.</p>
</td>
<td class="cellalignment1013" headers="r17c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r17c1-t12 r1c4-t12">
<p>OK.</p>
<p><code>OCI_ERROR</code> is returned if you write any amount &gt; =4 GB (from any offset &lt; 4 GB) because that results in an overflow of returned value in *amtp.</p>
<p>Note: Updating a LOB of 10 GB from any offset up to 4 GB &ndash;1 by up to 4 GB &ndash;1 amount of data is not flagged as an error.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r18c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578780">OCILobWriteAppend2()</a></code></p>
</td>
<td class="cellalignment1013" headers="r18c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r18c1-t12 r1c3-t12">
<p>OK until LOB size and piece size are &lt;4 GB.</p>
</td>
<td class="cellalignment1013" headers="r18c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r19c1-t12" headers="r1c1-t12">
<p><code><a href="ociaedep003.htm#i493080">OCILobWriteAppend()</a></code></p>
</td>
<td class="cellalignment1013" headers="r19c1-t12 r1c2-t12">
<p>OK; limit 4 GB.</p>
<p>With new server: <code>OCI_ERROR</code> is returned if you append any amount &gt;= 4 GB of data because that results in an overflow of returned value in <code>*amtp</code>.</p>
</td>
<td class="cellalignment1013" headers="r19c1-t12 r1c3-t12">
<p>OK</p>
</td>
<td class="cellalignment1013" headers="r19c1-t12 r1c4-t12">
<p>OK; limit 4 GB.</p>
<p><code>OCI_ERROR</code> is returned if you append any amount &gt;= 4 GB of data because that results in an overflow of returned value in <code>*amtp</code>.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r20c1-t12" headers="r1c1-t12">
<p><code><a href="oci17msc002.htm#i578858">OCILobGetStorageLimit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r20c1-t12 r1c2-t12">
<p>NA</p>
</td>
<td class="cellalignment1013" headers="r20c1-t12 r1c3-t12">
<p>Error</p>
</td>
<td class="cellalignment1013" headers="r20c1-t12 r1c4-t12">
<p>OK</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>The term "old" refers to releases before Oracle Database 10g Release 1.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup>NA means not applicable.</p>
<p>Use the functions that end in "2" when using the current server and current client. Mixing deprecated functions with functions that end in "2" can result in unexpected situations, such as data written using <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> being greater than 4 GB if the application tries to read it with <a href="ociaedep003.htm#i427817">OCILobRead()</a> and gets only partial data (if a callback function is not used). In most cases, the application gets an error message when the size crosses 4 GB and the deprecated functions are used. However, there is no issue if you use those deprecated functions for LOBs of size smaller than 4 GB.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i444493"></a>
<div id="LNOCI16510" class="sect1">
<h2 class="sect1">LOB and BFILE Functions in OCI<a id="sthref1268"></a></h2>
<p>In all LOB operations that involve offsets into the data, the offset begins at 1. For LOB operations, such as <a href="oci17msc002.htm#i578816">OCILobCopy2()</a>, <a href="oci17msc002.htm#i578657">OCILobErase2()</a>, <a href="oci17msc002.htm#i578701">OCILobLoadFromFile2()</a>, and <a href="oci17msc002.htm#i578743">OCILobTrim2()</a>, the <code>amount</code> parameter is in characters for <code>CLOB</code>s and <code>NCLOB</code>s, regardless of the client-side character set.</p>
<p>These LOB operations refer to the amount of LOB data on the server. When the client-side character set is of varying width, the following general rules apply to the <code>amount</code> and <code>offset</code> parameters in LOB calls:</p>
<ul>
<li>
<p><code>amount</code> - When the amount parameter refers to the server-side LOB, the amount is in characters. When the amount parameter refers to the client-side buffer, the amount is in bytes.</p>
</li>
<li>
<p><code>offset</code> - Regardless of whether the client-side character set is varying-width, the offset parameter is always in characters for <code>CLOB</code>s or <code>NCLOB</code>s and in bytes for <code>BLOB</code>s or <code>BFILE</code>s.</p>
</li>
</ul>
<p>Exceptions to these general rules are noted in the description of the specific LOB call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#CIHEEEHI">"LOB Functions"</a></p>
</li>
<li>
<p><a href="oci05bnd.htm#i435935">"Buffer Expansion During OCI Binding"</a></p>
</li>
</ul>
</div>
<a id="i444520"></a>
<div id="LNOCI16511" class="sect2">
<h3 class="sect2">Improving LOB Read/Write Performance</h3>
<p>Here are some hints to improve performance.</p>
<div id="LNOCI16512" class="sect3"><a id="sthref1269"></a>
<h4 class="sect3">Using Data Interface for LOBs</h4>
<p>You can bind or define character data for a <code>CLOB</code> column or <code>RAW</code> data for a <code>BLOB</code> column. This requires only one round-trip for inserting or selecting a LOB, as opposed to the traditional LOB interface that requires multiple round-trips.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci05bnd.htm#i440236">"Binding LOB Data"</a> for usage and examples for both <code>INSERT</code> and <code>UPDATE</code> statements</p>
</li>
<li>
<p><a href="oci05bnd.htm#i440237">"Defining LOB Data"</a> for usage and examples of <code>SELECT</code> statements</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16513" class="sect3"><a id="sthref1270"></a>
<h4 class="sect3">Using OCILobGetChunkSize()</h4>
<p><a href="oci17msc002.htm#i493090">OCILobGetChunkSize()</a> returns the usable chunk size in bytes for <code>BLOB</code>s, <code>CLOB</code>s, and <code>NCLOB</code>s. You can use the <a href="oci17msc002.htm#i493090">OCILobGetChunkSize()</a> call to improve the performance of LOB read and write operations for BasicFile LOBs. When a read or write is done on BasicFile LOB data whose size is a multiple of the usable chunk size and the operation starts on a chunk boundary, performance is improved. There is no requirement for SecureFile LOBs to be written or read with <a href="oci17msc002.htm#i493090">OCILobGetChunkSize()</a> alignment.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
"<a href="#CHDHIADG">"Options of SecureFiles LOBs"</a></div>
<p>Calling <a href="oci17msc002.htm#i493090">OCILobGetChunkSize()</a> returns the usable chunk size of the LOB, so that an application can batch a series of write operations for the entire chunk, rather than issuing multiple LOB write calls for the same chunk.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16514" class="sect3"><a id="sthref1271"></a>
<h4 class="sect3">Using OCILobWriteAppend2()</h4>
<p>OCI provides a shortcut for more efficient writing of data to the end of a LOB. The <a href="oci17msc002.htm#i578780">OCILobWriteAppend2()</a> call appends data to the end of a LOB without first requiring a call to <a href="oci17msc002.htm#i578679">OCILobGetLength2()</a> to determine the starting point for an <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> operation. <a href="oci17msc002.htm#i578780">OCILobWriteAppend2()</a> does both steps.</p>
</div>
<!-- class="sect3" -->
<a id="CJHEJHGH"></a>
<div id="LNOCI11597" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using OCILobArrayRead() and OCILobArrayWrite()</h4>
<p>You can improve performance by using by using <a href="oci17msc002.htm#BJFEJABB">OCILobArrayRead()</a> to read LOB data for multiple LOB locators and <a href="oci17msc002.htm#BJFFHCBB">OCILobArrayWrite()</a> to write LOB data for multiple LOB locators. These functions, which were introduced in Oracle Database 10g Release 2, reduce the number of round-trips for these operations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB1400" href="../../appdev.112/e18294/adlob_lob_ops.htm#ADLOB1400"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide,</span></a> sections "<a class="olink ADLOB45747" href="../../appdev.112/e18294/adlob_lob_ops.htm#ADLOB45747">LOB Array Read</a>" and "<a class="olink ADLOB45792" href="../../appdev.112/e18294/adlob_lob_ops.htm#ADLOB45792">LOB Array Write</a>" for more information and code examples that show how to use these functions with callback functions and in piecewise mode</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i444556"></a>
<div id="LNOCI16515" class="sect2">
<h3 class="sect2">LOB Buffering Functions<a id="sthref1272"></a><a id="sthref1273"></a></h3>
<p>OCI provides several calls for controlling LOB buffering for small reads and writes of internal LOB values:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#i455643">OCILobEnableBuffering()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i455613">OCILobDisableBuffering()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i455682">OCILobFlushBuffer()</a></p>
</li>
</ul>
<p>These functions enable applications that are using internal LOBs (<code>BLOB</code>, <code>CLOB</code>, <code>NCLOB</code>) to buffer small reads and writes in client-side buffers. This reduces the number of network round-trips and LOB versions, thereby improving LOB performance significantly.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADLOB1400" href="../../appdev.112/e18294/adlob_lob_ops.htm#ADLOB1400"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide.</span></a> For more information on LOB buffering, see the chapter about using LOB APIs.</p>
</li>
<li>
<p><a href="ociacrou.htm#i421672">"LOB Function Round-Trips"</a> for a list of the server round-trips required for each function</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i444594"></a>
<div id="LNOCI16516" class="sect2">
<h3 class="sect2">Functions for Opening and Closing LOBs</h3>
<p>OCI provides functions to explicitly open a LOB, <a href="oci17msc002.htm#i493100">OCILobOpen()</a>, to close a LOB, <a href="oci17msc002.htm#i496459">OCILobClose()</a>, and to test whether a LOB is open, <a href="oci17msc002.htm#i493110">OCILobIsOpen()</a>. These functions mark the beginning and end of a series of LOB operations so that specific processing, such as updating indexes, can be performed when a LOB is closed.</p>
<p>For internal LOBs, the concept of openness is associated with a LOB and not its locator. The locator does not store any information about the state of the LOB. It is possible for more than one locator to point to the same open LOB. However, for <code>BFILE</code>s, being open is associated with a specific locator. Hence, more than one open call can be performed on the same <code>BFILE</code> by using different locators.</p>
<p>If an application does not wrap LOB operations within a set of <a href="oci17msc002.htm#i493100">OCILobOpen()</a> and <a href="oci17msc002.htm#i496459">OCILobClose()</a> calls, then each modification to the LOB implicitly opens and closes the LOB, thereby firing any triggers associated with changes to the LOB.</p>
<p>If LOB operations are not wrapped within open and close calls, any extensible indexes on the LOB are updated as LOB modifications are made, and thus are always valid and may be used at any time. If the LOB is modified within a set of <a href="oci17msc002.htm#i493100">OCILobOpen()</a> and <a href="oci17msc002.htm#i496459">OCILobClose()</a> calls, triggers are not fired for individual LOB modifications. Triggers are only fired after the <a href="oci17msc002.htm#i496459">OCILobClose()</a> call, so indexes are not updated until after the close call and thus are not valid within the open and close calls. <a href="oci17msc002.htm#i493110">OCILobIsOpen()</a> can be used with internal LOBs and <code>BFILEs</code>.</p>
<p>An error is returned when you commit the transaction before closing all opened LOBs that were opened by the transaction. When the error is returned, the LOB is no longer marked as open, but the transaction is successfully committed. Hence, all the changes made to the LOB and non-LOB data in the transaction are committed, but the domain and functional indexing are not updated. If this happens, rebuild your functional and domain indexes on the LOB column.</p>
<p>A LOB opened when there is no transaction must be closed before the end of the session. If there are LOBs open at the end of session, the LOB is no longer marked as open and the domain and functional indexing is not updated. If this happens, rebuild your functional and domain indexes on the LOB column.</p>
<div id="LNOCI16517" class="sect3"><a id="sthref1274"></a>
<h4 class="sect3">Restrictions on Opening and Closing LOBs</h4>
<p>The LOB opening and closing mechanism has the following restrictions:</p>
<ul>
<li>
<p>An application must close all previously opened LOBs before committing a transaction. Failing to do so results in an error. If a transaction is rolled back, all open LOBs are discarded along with the changes made. Because the LOBs are not closed, so the associated triggers are not fired.</p>
</li>
<li>
<p>Although there is no limit to the number of open internal LOBs, there is a limit on the number of open files. See the <code>SESSION_MAX_OPEN_FILES</code> parameter in <a class="olink REFRN10196" href="../../server.112/e40402/initparams233.htm#REFRN10196"><span class="italic">Oracle Database Reference</span></a>. Assigning an already opened locator to another locator does not count as opening a new LOB.</p>
</li>
<li>
<p>It is an error to open or close the same internal LOB twice within the same transaction, either with different locators or the same locator.</p>
</li>
<li>
<p>It is an error to close a LOB that has not been opened.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The definition of a <span class="italic">transaction</span> within which an open LOB value must be closed is one of the following:
<ul>
<li>
<p>Between <code>SET TRANSACTION</code> and <code>COMMIT</code></p>
</li>
<li>
<p>Between <code>DATA</code> <code>MODIFYING</code> <code>DML</code> or <code>SELECT</code> <code>... FOR UPDATE</code> and <code>COMMIT</code>.</p>
</li>
<li>
<p>Within an autonomous transaction block</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociabdem.htm#g462659">Appendix B</a> for examples of the use of the <a href="oci17msc002.htm#i493100">OCILobOpen()</a> and <a href="oci17msc002.htm#i496459">OCILobClose()</a> calls in the online demonstration programs</p>
</li>
<li>
<p><a href="ociacrou.htm#CACHAFFI">Table C-2, "Server Round-Trips for OCILob Calls"</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i444634"></a>
<div id="LNOCI16518" class="sect2">
<h3 class="sect2">LOB Read and Write Callbacks<a id="sthref1275"></a><a id="sthref1276"></a></h3>
<p>OCI supports read and write callback functions. The following sections describe the use of callbacks in more detail.</p>
<div id="LNOCI16519" class="sect3"><a id="sthref1277"></a>
<h4 class="sect3">Callback Interface for Streaming<a id="sthref1278"></a></h4>
<p>User-defined read and write callback functions for inserting or retrieving data provide an alternative to the polling methods for streaming LOBs. These functions are implemented by you and registered with OCI through the <a href="oci17msc002.htm#i578721">OCILobRead2()</a>, <a href="oci17msc002.htm#i578780">OCILobWriteAppend2()</a>, and <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> calls. These callback functions are called by OCI whenever they are required.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16520" class="sect3"><a id="sthref1279"></a>
<h4 class="sect3">Reading LOBs by Using Callbacks<a id="sthref1280"></a></h4>
<p>The user-defined read callback function is registered through the <a href="oci17msc002.htm#i578721">OCILobRead2()</a> function. The callback function should have the following prototype:</p>
<pre>
CallbackFunctionName ( void *ctxp, CONST void *bufp, oraub8 len, ub1 piece,
                       void **changed_bufpp, oraub8 *changed_lenp);
</pre>
<p>The first parameter, <code>ctxp</code>, is the context of the callback that is passed to OCI in the <a href="oci17msc002.htm#i578721">OCILobRead2()</a> function call. When the callback function is called, the information provided by you in <code>ctxp</code> is passed back to you (OCI does not use this information on the way IN). The <code>bufp</code> parameter in <a href="oci17msc002.htm#i578721">OCILobRead2()</a>) is the pointer to the storage where the LOB data is returned and <code>bufl</code> is the length of this buffer. It tells you how much data has been read into the buffer provided.</p>
<p>If the buffer length provided in the original <a href="oci17msc002.htm#i578721">OCILobRead2()</a> call is insufficient to store all the data returned by the server, then the user-defined callback is called. In this case, the <code>piece</code> parameter indicates whether the information returned in the buffer is the first, next, or last piece.</p>
<p>The parameters <code>changed_bufpp</code> and <code>changed_lenp</code> can be used inside the callback function to change the buffer dynamically. The <code>changed_bufpp</code> parameter should point to the address of the changed buffer and the <code>changed_lenp</code> parameter should point to the length of the changed buffer. The <code>changed_bufpp</code> and <code>changed_lenp</code> parameters need not be used inside the callback function if the application does not change the buffer dynamically.</p>
<p><a href="#BGBBBEDI">Example 7-2</a> shows a code fragment that implements read callback functions using <a href="oci17msc002.htm#i578721">OCILobRead2()</a>. Assume that <code>lobl</code> is a valid locator that has been previously selected, <code>svchp</code> is a valid service handle, and <code>errhp</code> is a valid error handle. In the example, the user-defined function <code>cbk_read_lob()</code> is repeatedly called until all the LOB data has been read.</p>
<div id="LNOCI18174" class="example">
<p class="titleinexample"><a id="BGBBBEDI"></a>Example 7-2 Implementing Read Callback Functions Using OCILobRead2()</p>
<pre>
...
oraub8   offset = 1;
oraub8   loblen = 0; 
oraub8   byte_amt = 0;
oraub8   char_amt = 0
ub1      bufp[MAXBUFLEN];

sword retval; 
byte_amtp = 4294967297;     /* 4 gigabytes plus 1 */ 

if (retval = OCILobRead2(svchp, errhp, lobl, &amp;byte_amt, &amp;char_amt, offset,
  (void *) bufp, (oraub8) MAXBUFLEN, (void *) 0, OCI_FIRST_PIECE, 
  cbk_read_lob, (ub2) 0, (ub1) SQLCS_IMPLICIT))
{
     (void) printf("ERROR: OCILobRead2() LOB.\n");
     report_error();
}
...
sb4 cbk_read_lob(ctxp, bufxp, len, piece, changed_bufpp, changed_lenp)
void       *ctxp;
CONST void *bufxp;
oraub8      len;
ub1         piece;
void       **changed_bufpp;
oraub8      *changed_lenp; 
{ 
    static ub4 piece_count = 0; 
    piece_count++; 

    switch (piece)
   {
      case OCI_LAST_PIECE:     /*--- buffer processing code goes here ---*/ 
          (void) printf("callback read the %d th piece\n\n", piece_count);
          piece_count = 0;
          break;
      case OCI_FIRST_PIECE:   /*--- buffer processing code goes here ---*/ 
          (void) printf("callback read the %d th piece\n", piece_count);
          /* --Optional code to set changed_bufpp and changed_lenp if the
              buffer must be changed dynamically --*/
          break;
      case OCI_NEXT_PIECE:   /*--- buffer processing code goes here ---*/
          (void) printf("callback read the %d th piece\n", piece_count);
         /* --Optional code to set changed_bufpp and changed_lenp if the
             buffer must be changed dynamically --*/
          break;
      default:
          (void) printf("callback read error: unknown piece = %d.\n", piece);
           return OCI_ERROR;
     } 
    return OCI_CONTINUE;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16521" class="sect3"><a id="sthref1281"></a>
<h4 class="sect3">Writing LOBs by Using Callbacks<a id="sthref1282"></a></h4>
<p>Similar to read callbacks, the user-defined write callback function is registered through the <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> function. The callback function should have the following prototype:</p>
<pre>
CallbackFunctionName ( void *ctxp, void *bufp, oraub8 *lenp, ub1 *piecep,
                        void **changed_bufpp, oraub8 *changed_lenp);
</pre>
<p>The first parameter, <code>ctxp</code>, is the context of the callback that is passed to OCI in the <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> function call. The information provided by you in <code>ctxp</code> is passed back to you when the callback function is called by OCI (OCI does not use this information on the way IN). The <code>bufp</code> parameter is the pointer to a storage area; you provide this pointer in the call to <a href="oci17msc002.htm#i578761">OCILobWrite2()</a>.</p>
<p>After inserting the data provided in the call to <a href="oci17msc002.htm#i578761">OCILobWrite2()</a> any data remaining is inserted by the user-defined callback. In the callback, provide the data to insert in the storage indicated by <code>bufp</code> and also specify the length in <code>lenp</code>. You also indicate whether it is the next (<code>OCI_NEXT_PIECE</code>) or the last (<code>OCI_LAST_PIECE</code>) piece using the <code>piecep</code> parameter. You must ensure that the storage pointer that is provided by the application does not write more than the allocated size of the storage.</p>
<p>The parameters <code>changed_bufpp</code> and <code>changed_lenp</code> can be used inside the callback function to change the buffer dynamically. The <code>changed_bufpp</code> parameter should point to the address of the changed buffer and the <code>changed_lenp</code> parameter should point to the length of the changed buffer. The <code>changed_bufpp</code> and <code>changed_lenp</code> parameters need not be used inside the callback function if the application does not change the buffer dynamically.</p>
<p><a href="#BGBCHBJA">Example 7-3</a> shows a code fragment that implements write callback functions using <a href="oci17msc002.htm#i578761">OCILobWrite2()</a>. Assume that <code>lobl</code> is a valid locator that has been locked for updating, <code>svchp</code> is a valid service handle, and <code>errhp</code> is a valid error handle. The user-defined function <code>cbk_write_lob()</code> is repeatedly called until the <code>piecep</code> parameter indicates that the application is providing the last piece.</p>
<div id="LNOCI18175" class="example">
<p class="titleinexample"><a id="BGBCHBJA"></a>Example 7-3 Implementing Write Callback Functions Using OCILobWrite2()</p>
<pre>
...
 
ub1      bufp[MAXBUFLEN];
oraub8   byte_amt = MAXBUFLEN * 20;
oraub8   char_amt = 0;
oraub8   offset = 1;
oraub8   nbytes = MAXBUFLEN; 

/*-- code to fill bufp with data goes here. nbytes should reflect the size and
 should be less than or equal to MAXBUFLEN --*/
if (retval = OCILobWrite2(svchp, errhp, lobl, &amp;byte_amt, &amp;char_amt, offset,
    (void*)bufp, (ub4)nbytes, OCI_FIRST_PIECE, (void *)0, cbk_write_lob, 
    (ub2) 0, (ub1) SQLCS_IMPLICIT)) 
{
   (void) printf("ERROR: OCILobWrite2().\n");
   report_error();
   return;
}
... 
sb4 cbk_write_lob(ctxp, bufxp, lenp,  piecep, changed_bufpp, changed_lenp)
void    *ctxp; 
void    *bufxp; 
oraub8  *lenp; 
ub1       *piecep;
void  **changed_bufpp;
oraub8  *changed_lenp; 
{ 
    /*-- code to fill bufxp with data goes here. *lenp should reflect the
        size and should be less than or equal to MAXBUFLEN -- */
    /* --Optional code to set changed_bufpp and changed_lenp if the
        buffer must be changed dynamically --*/
    if (this is the last data buffer) 
        *piecep = OCI_LAST_PIECE; 
    else
        *piecep = OCI_NEXT_PIECE; 
    return OCI_CONTINUE;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i445781"></a>
<div id="LNOCI16522" class="sect1">
<h2 class="sect1">Temporary LOB Support<a id="sthref1283"></a></h2>
<p>OCI provides functions for creating and freeing temporary LOBs, <a href="oci17msc002.htm#i578103">OCILobCreateTemporary()</a> and <a href="oci17msc002.htm#i491299">OCILobFreeTemporary()</a>, and a function for determining whether a LOB is temporary, <a href="oci17msc002.htm#i491312">OCILobIsTemporary()</a>.</p>
<p>Temporary LOBs are not permanently stored in the database, but act like local variables for operating on LOB data. OCI functions that operate on standard (persistent) LOBs can also be used on temporary LOBs.</p>
<p>As with persistent LOBs, all functions operate on the locator for the temporary LOB, and the actual LOB data is accessed through the locator.</p>
<p>Temporary LOB locators can be used as arguments to the following types of SQL statements:</p>
<ul>
<li>
<p><code>UPDATE</code> - The temporary LOB locator can be used as a value in a <code>WHERE</code> clause when testing for nullity or as a parameter to a function. The locator can also be used in a <code>SET</code> clause.</p>
</li>
<li>
<p><code>DELETE</code> - The temporary LOB locator can be used in a <code>WHERE</code> clause when testing for nullity or as a parameter to a function.</p>
</li>
<li>
<p><code>SELECT</code> - The temporary LOB locator can be used in a <code>WHERE</code> clause when testing for nullity or as a parameter to a function. The temporary LOB can also be used as a return variable in a <code>SELECT...INTO</code> statement when selecting the return value of a function.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you select a permanent locator into a temporary locator, the temporary locator is overwritten with the permanent locator. In this case, the temporary LOB is not implicitly freed. You must explicitly free the temporary LOB before the <code>SELECT...INTO</code> operation. If the temporary LOB is not freed explicitly, it is not freed until the end of its specified <code>duration</code>. Unless you have another temporary locator pointing to the same LOB, you no longer have a locator pointing to the temporary LOB, because the original locator was overwritten by the <code>SELECT...INTO</code> operation.</div>
<div id="LNOCI16523" class="sect2"><a id="sthref1284"></a>
<h3 class="sect2">Creating and Freeing Temporary LOBs<a id="sthref1285"></a><a id="sthref1286"></a></h3>
<p>You create a temporary LOB with the <a href="oci17msc002.htm#i578103">OCILobCreateTemporary()</a> function. The parameters passed to this function include a value for the duration of the LOB. The default duration is for the length of the current session. All temporary LOBs are deleted at the end of the duration. Users can reclaim temporary LOB space by explicitly freeing the temporary LOB with the <a href="oci17msc002.htm#i491299">OCILobFreeTemporary()</a> function. A temporary LOB is empty when it is created.</p>
<p>When creating a temporary LOB, you can also specify whether the temporary LOB is read into the server's buffer cache.</p>
<p>To make a temporary LOB permanent, use <a href="oci17msc002.htm#i578816">OCILobCopy2()</a> to copy the data from the temporary LOB into a permanent one. You can also use the temporary LOB in the <code>VALUES</code> clause of an <code>INSERT</code> statement, as the source of the assignment in an <code>UPDATE</code> statement, or assign it to a persistent LOB attribute and then flush the object. Temporary LOBs can be modified using the same functions that are used for standard LOBs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The most efficient way to<a id="sthref1287"></a><a id="sthref1288"></a> insert an empty LOB is to bind a temporary LOB with no value assigned to it. This uses less resources than the following method.
<pre>
INSERT INTO tab1 VALUES(EMPTY_CLOB())
</pre></div>
</div>
<!-- class="sect2" -->
<a id="i444762"></a>
<div id="LNOCI16524" class="sect2">
<h3 class="sect2">Temporary LOB Durations<a id="sthref1289"></a></h3>
<p>OCI supports several predefined durations for temporary LOBs, and a set of functions that the application can use to define application-specific durations. The predefined durations and their associated attributes are:</p>
<ul>
<li>
<p>Call, <code>OCI_DURATION_CALL</code>, only on the server side</p>
</li>
<li>
<p>Session, <code>OCI_DURATION_SESSION</code></p>
</li>
</ul>
<p>The session duration expires when the containing session or connection ends. The call duration expires at the end of the current OCI call.</p>
<p>When you run in object mode, you can also define application-specific durations. An application-specific duration, also referred to as a user duration, is defined by specifying the start of a duration using <a href="oci20ext002.htm#i448600">OCIDurationBegin()</a> and the end of the duration using <a href="oci20ext002.htm#i448204">OCIDurationEnd()</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
User-defined durations are only available if an application has been initialized in object mode.</div>
<p>Each application-specific duration has a duration identifier that is returned by <a href="oci20ext002.htm#i448600">OCIDurationBegin()</a> and is guaranteed to be unique until <a href="oci20ext002.htm#i448204">OCIDurationEnd()</a> is called. An application-specific duration can be as long as a session duration.</p>
<p>At the end of a duration, all temporary LOBs associated with that duration are freed. The descriptor associated with the temporary LOB must be freed explicitly with the <a href="oci16rel002.htm#i540811">OCIDescriptorFree()</a> call.</p>
<p>User-defined durations can be nested; one duration can be defined as a child duration of another user duration. It is possible for a parent duration to have child durations that have their own child durations.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a duration is started with <a href="oci20ext002.htm#i448600">OCIDurationBegin()</a>, one of the parameters is the identifier of a parent duration. When a parent duration is ended, all child durations are also ended.</div>
</div>
<!-- class="sect2" -->
<a id="BABHJFGF"></a>
<div id="LNOCI16525" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Freeing Temporary LOBs</h3>
<p>Any time that your OCI program obtains a LOB locator from SQL or PL/SQL, use the <a href="oci17msc002.htm#i491312">OCILobIsTemporary()</a> function to check that the locator is temporary. If it is, then free the locator when your application is finished with it by using the <a href="oci17msc002.htm#i491299">OCILobFreeTemporary()</a> call. The locator can be from a define during a select or an out bind. A temporary LOB duration is always upgraded to a session duration when it is shipped to the client side. The application must do the following before the locator is overwritten by the locator of the next row:</p>
<pre>
OCILobIsTemporary(env, err, locator, is_temporary);
if(is_temporary)
    OCILobFreeTemporary(svc, err, locator);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#i491312">"OCILobIsTemporary()"</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i491299">"OCILobFreeTemporary()"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16526" class="sect2"><a id="sthref1290"></a>
<h3 class="sect2">Take Care When Assigning Pointers</h3>
<p>Special care must be taken when assigning <code>OCILobLocator</code> pointers. Pointer assignments create a shallow copy of the LOB. After the pointer assignment, source and target LOBs point to the same copy of data. This behavior is different from using LOB APIs, such as <a href="oci17msc002.htm#i447732">OCILobAssign()</a> or <a href="oci17msc002.htm#i507395">OCILobLocatorAssign()</a>, to perform assignments. When the APIs are used, the locators logically point to independent copies of data after assignment.</p>
<p>For temporary LOBs, before pointer assignments, you must ensure that any temporary LOB in the target LOB locator is freed by <a href="oci17msc002.htm#i491299">OCILobFreeTemporary()</a>. When <a href="oci17msc002.htm#i507395">OCILobLocatorAssign()</a> is used, the original temporary LOB in the target LOB locator variable, if any, is freed before the assignment happens.</p>
<p>Before an out-bind variable is reused in executing a SQL statement, you must free any temporary LOB in the existing out-bind LOB locator buffer by using the <a href="oci17msc002.htm#i491299">OCILobFreeTemporary()</a> call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADLOB105" href="../../appdev.112/e18294/adlob_performance.htm#ADLOB105"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide,</span></a> "Temporary LOB Performance Guidelines" section</p>
</li>
<li>
<p><a class="olink ADLOB106" href="../../appdev.112/e18294/adlob_performance.htm#ADLOB106"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>, for a discussion of optimal performance of temporary LOBs</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16527" class="sect2"><a id="sthref1291"></a>
<h3 class="sect2">Temporary LOB Example<a id="sthref1292"></a></h3>
<p><a href="#BGBDECFH">Example 7-4</a> shows how temporary LOBs can be used.</p>
<div id="LNOCI18176" class="example">
<p class="titleinexample"><a id="BGBDECFH"></a>Example 7-4 Using Temporary LOBs</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;oci.h&gt;

/* Function Prototype */
static void checkerr (/*_ OCIError *errhp, sword status _*/);
sb4 select_and_createtemp (OCILobLocator *lob_loc,
                           OCIError      *errhp,
                           OCISvcCtx     *svchp,
                           OCIStmt       *stmthp,
                           OCIEnv        *envhp);
/* This function reads in a single video frame from the print_media table.
Then it creates a temporary LOB. The temporary LOB that is created is read
through the CACHE, and is automatically cleaned up at the end of the user's
session, if it is not explicitly freed sooner. This function returns OCI_SUCCESS
if it completes successfully or OCI_ERROR if it fails. */

sb4 select_and_createtemp (OCILobLocator *lob_loc,
                           OCIError      *errhp,
                           OCISvcCtx     *svchp,
                           OCIStmt       *stmthp,
                           OCIEnv        *envhp)
{
  OCIDefine     *defnp1;
  OCIBind       *bndhp;
  text          *sqlstmt;
  int rowind =1;
  ub4 loblen = 0;
  OCILobLocator *tblob;
  printf ("in select_and_createtemp \n");
    if(OCIDescriptorAlloc((void*)envhp, (void **)&amp;tblob,
                          (ub4)OCI_DTYPE_LOB, (size_t)0, (void**)0))
  {
    printf("failed in OCIDescriptor Alloc in select_and_createtemp \n");
    return OCI_ERROR;
 }
  /* arbitrarily select where Clip_ID =1 */
  sqlstmt=(text *)"SELECT Frame FROM print_media WHERE product_ID = 1 FOR UPDATE";
  if (OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4) strlen((char *)sqlstmt),
                     (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT))
  {
      (void) printf("FAILED: OCIStmtPrepare() sqlstmt\n");
      return OCI_ERROR;
  }
  /* Define for BLOB */
  if (OCIDefineByPos(stmthp, &amp;defnp1, errhp, (ub4)1, (void *) &amp;lob_loc, (sb4)0,
             (ub2) SQLT_BLOB, (void *)0, (ub2 *)0, (ub2 *)0, (ub4) OCI_DEFAULT))
  {
    (void) printf("FAILED: Select locator: OCIDefineByPos()\n");
    return OCI_ERROR;
  }
  /* Execute the select and fetch one row */
  if (OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                   (CONST OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT))
  {
    (void) printf("FAILED: OCIStmtExecute() sqlstmt\n");
    return OCI_ERROR;
  }
  if(OCILobCreateTemporary(svchp, errhp, tblob, (ub2)0, SQLCS_IMPLICIT,
                         OCI_TEMP_BLOB, OCI_ATTR_NOCACHE, OCI_DURATION_SESSION))
  {
    (void) printf("FAILED: CreateTemporary() \n");
    return OCI_ERROR;
  }
  if (OCILobGetLength(svchp, errhp, lob_loc, &amp;loblen) != OCI_SUCCESS)
  {
    printf("OCILobGetLength FAILED\n");
    return OCI_ERROR;
  }
  if (OCILobCopy(svchp, errhp, tblob,lob_loc,(ub4)loblen, (ub4) 1, (ub4) 1))
  {
    printf( "OCILobCopy FAILED \n");
  }
  if(OCILobFreeTemporary(svchp,errhp,tblob))
  {
    printf ("FAILED: OCILobFreeTemporary call \n");
    return OCI_ERROR;
  }
     return OCI_SUCCESS;
}
int main(char *argv, int argc)
{
  /* OCI Handles */
  OCIEnv        *envhp;
  OCIServer     *srvhp;
  OCISvcCtx     *svchp;
  OCIError      *errhp;
  OCISession    *authp;
  OCIStmt       *stmthp;
  OCILobLocator *clob, *blob;
  OCILobLocator *lob_loc;
  int type =1;
  /* Initialize and Log on */
  OCIEnvCreate(&amp;envhp, OCI_DEFAULT, (void *)0, 0, 0, 0,
        (size_t)0, (void *)0);
  (void) OCIHandleAlloc( (void *) envhp, (void **) &amp;errhp, OCI_HTYPE_ERROR,
                          (size_t) 0, (void **) 0);
  /* server contexts */
  (void) OCIHandleAlloc( (void *) envhp, (void **) &amp;srvhp, OCI_HTYPE_SERVER,
                         (size_t) 0, (void **) 0);
   /* service context */
  (void) OCIHandleAlloc( (void *) envhp, (void **) &amp;svchp, OCI_HTYPE_SVCCTX,
                         (size_t) 0, (void **) 0);
    /* attach to Oracle Database */
  (void) OCIServerAttach( srvhp, errhp, (text *)"", strlen(""), 0);
    /* set attribute server context in the service context */
  (void) OCIAttrSet ((void *) svchp, OCI_HTYPE_SVCCTX,
                     (void *)srvhp, (ub4) 0,
                     OCI_ATTR_SERVER, (OCIError *) errhp);
   (void) OCIHandleAlloc((void *) envhp,
                        (void **)&amp;authp, (ub4) OCI_HTYPE_SESSION,
                        (size_t) 0, (void **) 0);
   (void) OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_SESSION,
                    (void *) "scott", (ub4)5,
                    (ub4) OCI_ATTR_USERNAME, errhp);
  (void) OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_SESSION,
                    (void *) "<span class="italic">password</span>", (ub4) 5,
                    (ub4) OCI_ATTR_PASSWORD, errhp);
  /* Begin a User Session */
  checkerr(errhp, OCISessionBegin ( svchp,  errhp, authp, OCI_CRED_RDBMS,
                                    (ub4) OCI_DEFAULT));
  (void) OCIAttrSet((void *) svchp, (ub4) OCI_HTYPE_SVCCTX,
                    (void *) authp, (ub4) 0,
                    (ub4) OCI_ATTR_SESSION, errhp);
  /* ------- Done logging in ----------------------------------*/
   /* allocate a statement handle */
  checkerr(errhp, OCIHandleAlloc( (void *) envhp, (void **) &amp;stmthp,
                             OCI_HTYPE_STMT, (size_t) 0, (void **) 0));
  checkerr(errhp, OCIDescriptorAlloc((void *)envhp, (void **)&amp;lob_loc,
                   (ub4) OCI_DTYPE_LOB, (size_t) 0, (void **) 0));
  /* Subroutine calls begin here */
  printf("calling select_and_createtemp\n");
  select_and_createtemp (lob_loc, errhp, svchp,stmthp,envhp);
  return 0;
}
void checkerr(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  sb4 errcode = 0;
  switch (status)
  {
  case OCI_SUCCESS:
    break;
  case OCI_SUCCESS_WITH_INFO:
    (void) printf("Error - OCI_SUCCESS_WITH_INFO\n");
    break;
  case OCI_NEED_DATA:
    (void) printf("Error - OCI_NEED_DATA\n");
    break;
  case OCI_NO_DATA:
    (void) printf("Error - OCI_NODATA\n");
    break;
  case OCI_ERROR:
    (void) OCIErrorGet((void *)errhp, (ub4) 1, (text *) NULL, &amp;errcode,
                        errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
    (void) printf("Error - %.*s\n", 512, errbuf);
    break;
  case OCI_INVALID_HANDLE:
    (void) printf("Error - OCI_INVALID_HANDLE\n");
    break;
  case OCI_STILL_EXECUTING:
    (void) printf("Error - OCI_STILL_EXECUTE\n");
    break;
  case OCI_CONTINUE:
    (void) printf("Error - OCI_CONTINUE\n");
    break;
  default:
    break;
  }
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDHFAB"></a>
<div id="LNOCI07100" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1293"></a><a id="sthref1294"></a>Prefetching of LOB Data, Length, and Chunk Size</h2>
<p>To improve OCI access of smaller LOBs, LOB data can be prefetched and cached while also fetching the locator. This applies to internal LOBs, temporary LOBs, and <code>BFILE</code>s. Take the following steps to prepare your application:</p>
<ol>
<li>
<p>Set the <a id="sthref1295"></a><code>OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE</code> attribute for the session handle. The value of this attribute indicates the default prefetch data size for a LOB locator. This attribute value enables prefetching for all the LOB locators fetched in the session. The default value for this attribute is zero (no prefetch of LOB data). This option relieves the application developer from setting the prefetch LOB size for each define handle. You can either set this attribute or set (in Step 3) <code>OCI_ATTR_LOBPREFETCH_SIZE</code>.</p>
</li>
<li>
<p>Perform the prepare and define steps for the statement to be executed.</p>
</li>
<li>
<p>You can override the default prefetch size, if required, for the LOB locators to be fetched, by setting <code><a id="sthref1296"></a>OCI_ATTR_LOBPREFETCH_SIZE</code> attribute for the define handle. This optional attribute provides control of the prefetch size for the locators fetched from a particular column.</p>
</li>
<li>
<p>Set the <a id="sthref1297"></a><code>OCI_ATTR_LOBPREFETCH_LENGTH</code> attribute to the prefetch LOB length and chunk size.</p>
</li>
<li>
<p>Execute the statement.</p>
</li>
<li>
<p>Call <a href="oci17msc002.htm#i578721">OCILobRead2()</a> or <a id="sthref1298"></a><a href="oci17msc002.htm#BJFEJABB">OCILobArrayRead()</a> with individual LOB locators; OCI takes the data from the prefetch buffer, does the necessary character conversion, and copies the data into the LOB read buffer (no change in LOB semantic). If the data requested is bigger than the prefetch buffer, then it will require additional round-trips.</p>
</li>
<li>
<p>Call <a href="oci17msc002.htm#i578679">OCILobGetLength2()</a> and <a href="oci17msc002.htm#i493090">OCILobGetChunkSize()</a> to obtain the length and chunk size without making round-trips to the server.</p>
</li>
</ol>
<p>Note that the prefetch size is in number of bytes for <code>BLOB</code>s and <code>BFILE</code>s and in number of characters for <code>CLOB</code>s.</p>
<p><a href="#BGBGCGCB">Example 7-5</a> shows a code fragment illustrating these steps.</p>
<div id="LNOCI18177" class="example">
<p class="titleinexample"><a id="BGBGCGCB"></a>Example 7-5 Prefetching of LOB Data, Length, and Chunk Size</p>
<pre>
...
ub4 default_lobprefetch_size = 2000;                  /* Set default size to 2K */
... 
/* set LOB prefetch attribute to session */
OCIAttrSet (sesshp, (ub4) OCI_HTYPE_SESSION,
            (void *)&amp;default_lobprefetch_size,               /* attribute value */
            0,                      /* attribute size; not required to specify; */
            (ub4) OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE,
            errhp);
...
/* select statement */
char *stmt = "SELECT lob1 FROM lob_table";
...
/* declare and allocate LOB locator */
OCILobLocator * lob_locator;
lob_locator = OCIDescriptorAlloc(..., OCI_DTYPE_LOB, ...);
 
OCIDefineByPos(..., 1, (void *) &amp;lob_locator, ..., SQLT_CLOB, ...);
...
/* Override the default prefetch size to 4KB */
ub4 prefetch_size = 4000;
OCIAttrSet (defhp,  OCI_HTYPE_DEFINE,
            (void *) &amp;prefetch_size                             /* attr value */,
            0                  /* restricting prefetch size to be ub4 max val */,
            OCI_ATTR_LOBPREFETCH_SIZE                            /* attr type */,
            errhp);
...
/* Set prefetch length attribute */
boolean prefetch_length = TRUE;
OCIAttrSet( defhp,  OCI_HTYPE_DEFINE,
            (dvoid *) &amp;prefetch_length  /* attr value */,
            0,
            OCI_ATTR_LOBPREFETCH_LENGTH  /* attr type */,
            errhp );
...
/* execute the statement. 4KB of data for the LOB is read and
 * cached in descriptor cache buffer.
 */
OCIStmtExecute (svchp, stmthp, errhp,
                1,               /* iters */
                0,               /* row offset */
                NULL,            /* snapshot IN */
                NULL,            /* snapshot out */
                OCI_DEFAULT);    /* mode */
...
oraub8 char_amtp = 4000;
oraub8 lob_len;
ub4 chunk_size;
 
/* LOB chunk size, length, and data are read from cache. No round-trip. */
 
OCILobGetChunkSize (svchp, errhp, lob_locator, &amp;chunk_size);
 
OCILobGetLength2(svchp, errhp, lob_locator, &amp;lob_len );
 
OCILobRead2(svchp, errhp, lob_locator, NULL, &amp;char_amtp, ...);
...
</pre></div>
<!-- class="example" -->
<p><span class="bold">Prefetch cache allocation:</span> The prefetch cache buffer for a descriptor is allocated while fetching a LOB locator. The allocated buffer size is determined by the <code>OCI_ATTR_LOBPREFETCH_SIZE</code> attribute for the define handle; the default value of this attribute is indicated by the <code>OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE</code> attribute value of the session handle. If the cache buffer is already allocated, then it is resized if required.</p>
<p>For the following two LOB APIs, if the source locator has cached data, then the destination locator cache is allocated or resized and cached data is copied from source to destination.</p>
<ul>
<li>
<p><a href="oci17msc002.htm#i447732">OCILobAssign()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#i507395">OCILobLocatorAssign()</a></p>
</li>
</ul>
<p>Once allocated, the cache buffer memory for a descriptor is released when the descriptor itself is freed.</p>
<p><span class="bold">Prefetch cache invalidation:</span> The cache for a descriptor gets invalidated when LOB data is updated using the locator. Meaning the cache is no longer used for reading data and the next <a href="oci17msc002.htm#i578721">OCILobRead2()</a> call on the locator makes a round-trip.</p>
<p>The following LOB APIs invalidate the prefetch cache for the descriptor used:</p>
<ul>
<li>
<p><a href="ociaedep003.htm#i450663">OCILobErase()</a> (deprecated)</p>
</li>
<li>
<p><a href="oci17msc002.htm#i578657">OCILobErase2()</a></p>
</li>
<li>
<p><a href="ociaedep003.htm#i427862">OCILobTrim()</a> (deprecated)</p>
</li>
<li>
<p><a href="oci17msc002.htm#i578743">OCILobTrim2()</a></p>
</li>
<li>
<p><a href="ociaedep003.htm#i427882">OCILobWrite()</a> (deprecated)</p>
</li>
<li>
<p><a href="oci17msc002.htm#i578761">OCILobWrite2()</a></p>
</li>
<li>
<p><a href="ociaedep003.htm#i493080">OCILobWriteAppend()</a> (deprecated)</p>
</li>
<li>
<p><a href="oci17msc002.htm#i578780">OCILobWriteAppend2()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#BJFFHCBB">OCILobArrayWrite()</a></p>
</li>
</ul>
<p>The following LOB APIs invalidate the cache for the destination LOB locator:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#i428786">OCILobAppend()</a></p>
</li>
<li>
<p><a href="ociaedep003.htm#CEGFJBBG">OCILobCopy()</a> (deprecated)</p>
</li>
<li>
<p><a href="oci17msc002.htm#i578816">OCILobCopy2()</a></p>
</li>
<li>
<p><a href="ociaedep003.htm#i455168">OCILobLoadFromFile()</a> (deprecated)</p>
</li>
<li>
<p><a href="oci17msc002.htm#i578701">OCILobLoadFromFile2()</a></p>
</li>
</ul>
<p><span class="bold">Performance Tuning:</span> The prefetch buffer size must be decided upon based on average LOB size and client-side memory. If a large amount of data is prefetched, you must ensure the memory availability. Performance gain may not be significant for prefetching large LOBs, because the cost of fetching data is much higher compared to the cost of a round-trip to the server.</p>
<p>You must have a fair idea of the LOB data size to be able to make best use of this LOB prefetch feature. Because the parameters are part of application design, the application must be rebuilt if any parameter value must be modified.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#BAJJDCII">"OCI_ATTR_DEFAULT_LOBPREFETCH_SIZE"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#CHDECDDE">"OCI_ATTR_LOBPREFETCH_LENGTH"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#CHDJEBCB">"OCI_ATTR_LOBPREFETCH_SIZE"</a></p>
</li>
</ul>
</div>
<p><span class="bold">Upgrading:</span> LOB prefetching cannot be used against a pre-11.1 release server or in a pre-11.1 client against an 11.1 or later server. When you use a pre-11.1 server with an 11.1 or later client, <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> returns an error or an error-with-information saying that "server does not support this functionality."</p>
</div>
<!-- class="sect1" -->
<a id="CHDHIADG"></a>
<div id="LNOCI16528" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Options of <a id="sthref1299"></a><a id="sthref1300"></a><a id="sthref1301"></a>SecureFiles LOBs</h2>
<p>For <a id="sthref1302"></a>SecureFiles (LOBs with the <code>STORE AS SECUREFILE</code> option, which were introduced in Oracle Database 11<span class="italic">g</span> Release 1) you can specify the SQL parameter <a id="sthref1303"></a><code>DEDUPLICATE</code> in <code>CREATE</code> <code>TABLE</code> and <code>ALTER</code> <code>TABLE</code> statements. This parameter value enables you to specify that LOB data that is identical in two or more rows in a LOB column shares the same data blocks, thus saving disk space. <a id="sthref1304"></a><code>KEEP_DUPLICATES</code> turns off this capability. The following options are also used with <code>SECUREFILE</code>:</p>
<p>The parameter <code><a id="sthref1305"></a>COMPRESS</code> turns on LOB compression. <a id="sthref1306"></a><code>NOCOMPRESS</code> turns LOB compression off.</p>
<p>The parameter <code><a id="sthref1307"></a>ENCRYPT</code> turns on LOB encryption and optionally selects an encryption algorithm. <code><a id="sthref1308"></a>NOENCRYPT</code> turns off LOB encryption. Each LOB column can have its own encryption specification, independent of the encryption of other LOB or non-LOB columns. Valid algorithms are <code>3DES168</code>, <code>AES128</code>, <code>AES192</code>, and <code>AES256</code>.</p>
<p>The LOBs paradigm used before release 11.1 is the default. This default LOBs paradigm is also now explicitly set by the option <code>STORE AS BASICFILE</code>.</p>
<p>The following OCI functions are used with the <code>SECUREFILE</code> features:</p>
<ul>
<li>
<p><a href="oci17msc002.htm#CHDEAJAB">OCILobGetOptions()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#CHDBDAAF">OCILobSetOptions()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#CHDEHBCD">OCILobGetContentType()</a></p>
</li>
<li>
<p><a href="oci17msc002.htm#CHDHHGIC">OCILobSetContentType()</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB4444" href="../../appdev.112/e18294/adlob_smart.htm#ADLOB4444"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for complete details of relevant SQL functions and cross-references to PL/SQL packages and information about migrating to SecureFiles</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci06des.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci08sca.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
