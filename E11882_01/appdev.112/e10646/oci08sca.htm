<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Managing Scalable Platforms</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:23Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci07lob.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci09adv.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/79</span> <!-- End Header -->
<div id="LNOCI080" class="chapter"><a id="g459816"></a> <a id="i450228"></a>
<h1 class="chapter"><span class="secnum">8</span> Managing Scalable Platforms</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i421830">OCI Support for Transactions</a></p>
</li>
<li>
<p><a href="#i452233">Levels of Transactional Complexity</a></p>
</li>
<li>
<p><a href="#i422789">Password and Session Management</a></p>
</li>
<li>
<p><a href="#i451070">Middle-Tier Applications in OCI</a></p>
</li>
<li>
<p><a href="#i452816">Externally Initialized Context in OCI</a></p>
</li>
<li>
<p><a href="#CHDCIBHB">Client Application Context</a></p>
</li>
<li>
<p><a href="#CHDEIIAB">Edition-Based Redefinition</a></p>
</li>
<li>
<p><a href="#CHDDCIJG">OCI Security Enhancements</a></p>
</li>
<li>
<p><a href="#i456377">Overview of OCI Multithreaded Development</a></p>
</li>
<li>
<p><a href="#i434459">OCIThread Package</a></p>
</li>
</ul>
<a id="i421830"></a>
<div id="LNOCI16529" class="sect1">
<h2 class="sect1">OCI Support for Transactions<a id="sthref1309"></a></h2>
<p>OCI has a set of API calls to support operations on both local and global transactions. These calls include object support, so that if an OCI application is running in object mode, the commit and rollback calls synchronize the object cache with the state of the transaction.</p>
<p>The functions listed later perform transaction operations. Each call takes a service context handle that must be initialized with the proper server context and user session handle. The transaction handle is the third element of the service context; it stores specific information related to a transaction. When a SQL statement is prepared, it is associated with a particular service context. When the statement is executed, its effects (query, fetch, insert) become part of the transaction that is currently associated with the service context.</p>
<ul>
<li>
<p><a href="oci17msc006.htm#i458405">OCITransStart()</a> marks the start of a transaction.</p>
</li>
<li>
<p><a href="oci17msc006.htm#i428849">OCITransDetach()</a> detaches a transaction.</p>
</li>
<li>
<p><a href="oci17msc006.htm#i428845">OCITransCommit()</a> commits a transaction.</p>
</li>
<li>
<p><a href="oci17msc006.htm#i428853">OCITransRollback()</a> rolls back a transaction.</p>
</li>
<li>
<p><a href="oci17msc006.htm#i545171">OCITransPrepare()</a> prepares a transaction to be committed in a distributed processing environment.</p>
</li>
<li>
<p><a href="oci17msc006.htm#i545246">OCITransMultiPrepare()</a> prepares a transaction with multiple branches in a single call.</p>
</li>
<li>
<p><a href="oci17msc006.htm#i440625">OCITransForget()</a> causes the server to forget a heuristically completed global transaction.</p>
</li>
</ul>
<p>Depending on the level of transactional complexity in your application, you may need all or only a few of these calls. The following section discusses this in more detail.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc006.htm#i540469">"Transaction Functions"</a></div>
</div>
<!-- class="sect1" -->
<a id="i452233"></a>
<div id="LNOCI16530" class="sect1">
<h2 class="sect1">Levels of Transactional Complexity<a id="sthref1310"></a></h2>
<p>OCI supports several levels of transaction complexity, including the following:</p>
<ul>
<li>
<p><a href="#i431599">Simple Local Transactions</a></p>
</li>
<li>
<p><a href="#i429270">Serializable or Read-Only Local Transactions</a></p>
</li>
<li>
<p><a href="#i429274">Global Transactions</a></p>
</li>
</ul>
<a id="i431599"></a>
<div id="LNOCI16531" class="sect2">
<h3 class="sect2">Simple Local Transactions<a id="sthref1311"></a></h3>
<p>Many applications work with only simple local transactions. In these applications, an implicit transaction is created when the application makes database changes. The only transaction-specific calls needed by such applications are:</p>
<ul>
<li>
<p><a href="oci17msc006.htm#i428845">OCITransCommit()</a> to commit the transaction</p>
</li>
<li>
<p><a href="oci17msc006.htm#i428853">OCITransRollback()</a> to roll back the transaction</p>
</li>
</ul>
<p>As soon as one transaction has been committed or rolled back, the next modification to the database creates a new implicit transaction for the application.</p>
<p>Only one implicit transaction can be active at any time on a service context. Attributes of the implicit transaction are opaque to the user.</p>
<p>If an application creates multiple sessions, each one can have an implicit transaction associated with it.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc006.htm#i428845">"OCITransCommit()"</a> for sample code showing the use of simple local transactions.</div>
</div>
<!-- class="sect2" -->
<a id="i429270"></a>
<div id="LNOCI16532" class="sect2">
<h3 class="sect2">Serializable or Read-Only Local Transactions<a id="sthref1312"></a><a id="sthref1313"></a></h3>
<p>Applications requiring serializable or read-only transactions require an additional OCI <a href="oci17msc006.htm#i458405">OCITransStart()</a> call to start the transaction.</p>
<p>The <a href="oci17msc006.htm#i458405">OCITransStart()</a> call must specify <a id="sthref1314"></a><code>OCI_TRANS_SERIALIZABLE</code> or <code><a id="sthref1315"></a>OCI_TRANS_READONLY</code>, as appropriate, for the <code>flags</code> parameter. If no flag is specified, the default value is <code><a id="sthref1316"></a>OCI_TRANS_READWRITE</code> for a standard read/write transaction.</p>
<p>Specifying the read-only option in the <a href="oci17msc006.htm#i458405">OCITransStart()</a> call saves the application from performing a server round-trip to execute a <code>SET TRANSACTION READ ONLY</code> statement.</p>
</div>
<!-- class="sect2" -->
<a id="i429274"></a>
<div id="LNOCI16533" class="sect2">
<h3 class="sect2">Global Transactions<a id="sthref1317"></a><a id="sthref1318"></a></h3>
<p>Global transactions are necessary only in more sophisticated transaction-processing applications.</p>
<div id="LNOCI16534" class="sect3"><a id="sthref1319"></a>
<h4 class="sect3">Transaction Identifiers<a id="sthref1320"></a><a id="sthref1321"></a></h4>
<p>Three-tier applications such as transaction processing (TP) monitors create and manage global transactions. They supply a <span class="italic">global transaction identifier</span> (<code>XID</code>) that a server associates with a local transaction.</p>
<p>A global transaction has one or more <span class="italic">branches</span>. Each branch is identified by an <code>XID</code>. The <code>XID</code> consists of a <span class="italic">global transaction identifier</span> (<code>gtrid</code>) and a <span class="italic">branch qualifier</span> (<code>bqual</code>). This structure is based on the standard XA specification.<a id="sthref1322"></a></p>
<p><a href="#BGBDGIAF">Table 8-1</a> provides the structure for one possible <code>XID</code> of 1234.</p>
<div id="LNOCI16535" class="tblformal">
<p class="titleintable"><a id="sthref1323"></a><a id="BGBDGIAF"></a>Table 8-1 Global Transaction Identifier</p>
<table class="cellalignment1016" title="Global Transaction Identifier" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t4">Component</th>
<th class="cellalignment1012" id="r1c2-t4">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t4" headers="r1c1-t4">
<p><code>gtrid</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t4 r1c2-t4">
<p><code>12</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t4" headers="r1c1-t4">
<p><code>bqual</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t4 r1c2-t4">
<p><code>34</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t4" headers="r1c1-t4">
<p><code>gtrid+bqual=XID</code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t4 r1c2-t4">
<p><code>1234</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The transaction identifier used by OCI transaction calls is set in the <a id="sthref1324"></a><code>OCI_ATTR_XID</code> attribute of the transaction handle, by using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>. Alternately, the transaction can be identified by a name set in the <a id="sthref1325"></a><code>OCI_ATTR_TRANS_NAME</code> attribute.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16536" class="sect3"><a id="sthref1326"></a>
<h4 class="sect3">Attribute OCI_ATTR_TRANS_NAME</h4>
<p>When this attribute is set in a transaction handle, the length of the name can be at most 64 bytes. The <code>formatid</code> of the <code>XID</code> is 0 and the branch qualifier is 0.</p>
<p>When this attribute is retrieved from a transaction handle, the returned transaction name is the global transaction identifier. The size is the length of the global transaction identifier.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16537" class="sect3"><a id="sthref1327"></a>
<h4 class="sect3">Transaction Branches<a id="sthref1328"></a></h4>
<p>Within a single global transaction, Oracle Database supports both tightly coupled and loosely coupled relationships between a pair of branches.</p>
<ul>
<li>
<p>Tightly coupled branches share the same local transaction. The <code>gtrid</code> references a unique local transaction, and multiple branches point to that same transaction. The owner of the transaction is the branch that was created first.</p>
</li>
<li>
<p>Loosely coupled branches use different local transactions. The <code>gtrid</code> and <code>bqual</code> together map to a unique local transaction. Each branch points to a different transaction.</p>
</li>
</ul>
<p>The <code>flags</code> parameter of <a href="oci17msc006.htm#i458405">OCITransStart()</a> allows applications to pass <code><a id="sthref1329"></a>OCI_TRANS_TIGHT</code> or <a id="sthref1330"></a><code>OCI_TRANS_LOOSE</code> values to specify the type of coupling.</p>
<p>A session corresponds to a user session, created with <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>.</p>
<p><a href="#i443620">Figure 8-1</a> illustrates tightly coupled branches within an application. The <code>XID</code>s of the two branches (B1 and B2) share the same <code>gtrid</code>, because they are operating on the same transaction (T), but they have a different <code>bqual</code>, because they are on separate branches.</p>
<div id="LNOCI16538" class="figure">
<p class="titleinfigure"><a id="i443620"></a>Figure 8-1 Multiple Tightly Coupled Branches</p>
<img width="518" height="224" src="img/lnoci023.gif" alt="Description of Figure 8-1 follows" /><br />
<a id="sthref1331" href="img_text/lnoci023.htm">Description of "Figure 8-1 Multiple Tightly Coupled Branches"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#i433197">Figure 8-2</a> illustrates how a single session operates on different branches. The <code>gtrid</code> components of the <code>XID</code>s are different, because they represent separate global transactions.</p>
<div id="LNOCI16539" class="figure">
<p class="titleinfigure"><a id="i433197"></a>Figure 8-2 Session Operating on Multiple Branches</p>
<img width="520" height="224" src="img/lnoci024.gif" alt="Description of Figure 8-2 follows" /><br />
<a id="sthref1332" href="img_text/lnoci024.htm">Description of "Figure 8-2 Session Operating on Multiple Branches"</a><br />
<br /></div>
<!-- class="figure" -->
<p>It is possible for a single session to operate on multiple branches that share the same transaction, but this scenario does not have much practical value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc006.htm#i458405">"OCITransStart()"</a> for sample code demonstrating this scenario</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16540" class="sect3"><a id="sthref1333"></a>
<h4 class="sect3">Branch States<a id="sthref1334"></a></h4>
<p>Transaction branches are classified into two states: <span class="italic">active branches</span> and <span class="italic">inactive branches</span>.</p>
<p>A branch is active if a server process is executing requests on the branch. A branch is inactive if no server processes are executing requests in the branch. In this case, no session is the parent of the branch, and the branch becomes owned by the <code>PMON</code> process in the server.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16541" class="sect3"><a id="sthref1335"></a>
<h4 class="sect3">Detaching and Resuming Branches<a id="sthref1336"></a><a id="sthref1337"></a><a id="sthref1338"></a><a id="sthref1339"></a></h4>
<p>A branch becomes inactive when an OCI application detaches it, using the <a href="oci17msc006.htm#i428849">OCITransDetach()</a> call. The branch can be made active again by resuming it with a call to <a href="oci17msc006.htm#i458405">OCITransStart()</a> with the <code>flags</code> parameter set to <code>OCI_TRANS_RESUME</code>.</p>
<p>When an application detaches a branch with <a href="oci17msc006.htm#i428849">OCITransDetach()</a>, it uses the value specified in the <code>timeout</code> parameter of the <a href="oci17msc006.htm#i458405">OCITransStart()</a> call that created the branch. The <code>timeout</code> specifies the number of seconds the transaction can remain dormant as a child of <code>PMON</code> before being deleted.</p>
<p>To resume a branch, the application calls <a href="oci17msc006.htm#i458405">OCITransStart()</a>, specifying the <code>XID</code> of the branch as an attribute of the transaction handle, <code>OCI_TRANS_RESUME</code> for the <code>flags</code> parameter, and a different <code>timeout</code> parameter. This <span class="italic">timeout</span> value for this call specifies the length of time that the session waits for the branch to become available if it is currently in use by another process. If no other processes are accessing the branch, it can be resumed immediately. A transaction can be resumed by a different process than the one that detached it, if that process has the same authorization as the one that detached the transaction.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16542" class="sect3"><a id="sthref1340"></a>
<h4 class="sect3">Setting the Client Database Name</h4>
<p>The server handle has <a id="sthref1341"></a><code>OCI_ATTR_EXTERNAL_NAME</code> and <code><a id="sthref1342"></a>OCI_ATTR_INTERNAL_NAME</code> attributes. These attributes set the client database name recorded when performing global transactions. The name can be used by the database administrator to track transactions that may be pending in a prepared state because of failures.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An OCI application sets these attributes, by using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> before logging on and using global transactions.</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16543" class="sect3"><a id="sthref1343"></a>
<h4 class="sect3">One-Phase Commit Versus Two-Phase Commit<a id="sthref1344"></a><a id="sthref1345"></a><a id="sthref1346"></a><a id="sthref1347"></a></h4>
<p>Global transactions can be committed in one or two phases. The simplest situation is when a single transaction is operating against a single database. In this case, the application can perform a one-phase commit of the transaction by calling <a href="oci17msc006.htm#i428845">OCITransCommit()</a>, because the default value of the call is for one-phase commit.</p>
<p>The situation is more complicated if the application is processing transactions against multiple Oracle databases. In this case, a two-phase commit is necessary. A two-phase commit operation consists of these steps:</p>
<ol>
<li>
<p>Prepare - The application issues an <a href="oci17msc006.htm#i545171">OCITransPrepare()</a> call against each transaction. Each transaction returns a value indicating whether or not it can commit its current work (<a id="sthref1348"></a><code>OCI_SUCCESS</code>) or not (<a id="sthref1349"></a><code>OCI_ERROR</code>).</p>
</li>
<li>
<p>Commit - If each <a href="oci17msc006.htm#i545171">OCITransPrepare()</a> call returns a value of <code>OCI_SUCCESS</code>, the application can issue an <a href="oci17msc006.htm#i428845">OCITransCommit()</a> call to each transaction. The <code>flags</code> parameter of the commit call must be explicitly set to <code>OCI_TRANS_TWOPHASE</code> for the appropriate behavior, because the default for this call is for one-phase commit.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <a href="oci17msc006.htm#i545171">OCITransPrepare()</a> call can also return <code>OCI_SUCCESS_WITH_INFO</code> if a transaction must indicate that it is read-only. Thus a commit is neither appropriate nor necessary.</div>
</li>
</ol>
<p>An additional call, <a href="oci17msc006.htm#i440625">OCITransForget()</a>, causes a database to "forget" a completed transaction. This call is for situations in which a problem has occurred that requires that a two-phase commit be terminated. When an Oracle database receives an <a href="oci17msc006.htm#i440625">OCITransForget()</a> call, it removes all information about the transaction.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16544" class="sect3"><a id="sthref1350"></a>
<h4 class="sect3">Preparing Multiple Branches in a Single Message</h4>
<p>Sometimes when multiple applications use different branches of a global transaction against the same Oracle database. Before such a transaction can be committed, all branches must be prepared<a id="sthref1351"></a>.</p>
<p>Most often, the applications using the branches are responsible for preparing their own branches. However, some architectures turn this responsibility over to an external transaction service. This external transaction service must then prepare each branch of the global transaction. The traditional <a href="oci17msc006.htm#i545171">OCITransPrepare()</a> call is inefficient for this task as each branch must be individually prepared. The <a href="oci17msc006.htm#i545246">OCITransMultiPrepare()</a><code><a id="sthref1352"></a><a id="sthref1353"></a></code> call, prepares multiple branches involved in the same global transaction in one round-trip. This call is more efficient and can greatly reduce the number of messages sent from the client to the server.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16545" class="sect2"><a id="sthref1354"></a>
<h3 class="sect2">Transaction Examples<a id="sthref1355"></a></h3>
<p><a href="#BGBDGIAF">Table 8-1</a> through <a href="#BGBJJFHC">Table 8-5</a> illustrate how to use the transaction OCI calls.</p>
<p>They show a series of OCI calls and other actions, along with their resulting behavior. For simplicity, not all parameters to these calls are listed; rather, it is the flow of calls that is being demonstrated.</p>
<p>The OCI Action column indicates what the OCI application is doing, or what call it is making. The <code>XID</code> column lists the transaction identifier, when necessary. The Flags column lists the values passed in the <code>flags</code> parameter. The Result column describes the result of the call.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16546" class="sect2"><a id="sthref1356"></a>
<h3 class="sect2">Initialization Parameters<a id="sthref1357"></a></h3>
<p>Two initialization parameters relate to the use of global transaction branches and migratable open connections:</p>
<ul>
<li>
<p><code>TRANSACTIONS</code> - This parameter specifies the maximum number of global transaction branches in the entire system. In contrast, the maximum number of branches on a single global transaction is 8.</p>
</li>
<li>
<p><code>OPEN_LINKS_PER_INSTANCE</code> - This parameter specifies the maximum number of migratable open connections. Migratable open connections are used by global transactions to cache connections after committing a transaction. Contrast this with the <code>OPEN_LINKS</code> parameter, which controls the number of connections from a session and is not applicable to applications that use global transactions.</p>
</li>
</ul>
<div id="LNOCI16547" class="sect3"><a id="sthref1358"></a>
<h4 class="sect3">Update Successfully, One-Phase Commit</h4>
<p><a href="#BGBCCHBE">Table 8-2</a> lists the steps for a one-phase commit operation.</p>
<div id="LNOCI16548" class="tblformalwide">
<p class="titleintable"><a id="sthref1359"></a><a id="BGBCCHBE"></a>Table 8-2 One-Phase Commit</p>
<table class="cellalignment1011" title="One-Phase Commit " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t8">Step</th>
<th class="cellalignment1012" id="r1c2-t8">OCI Action</th>
<th class="cellalignment1012" id="r1c3-t8">XID</th>
<th class="cellalignment1012" id="r1c4-t8">Flags</th>
<th class="cellalignment1012" id="r1c5-t8">Result</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t8" headers="r1c1-t8">
<p>1</p>
</td>
<td class="cellalignment1013" headers="r2c1-t8 r1c2-t8">
<pre>
<a href="oci17msc006.htm#i458405">OCITransStart()</a>
</pre></td>
<td class="cellalignment1013" headers="r2c1-t8 r1c3-t8">
<p>1234</p>
</td>
<td class="cellalignment1013" headers="r2c1-t8 r1c4-t8">
<p><code>OCI_TRANS_NEW</code><a id="sthref1360"></a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t8 r1c5-t8">
<p>Starts new read/write transaction</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t8" headers="r1c1-t8">
<p>2</p>
</td>
<td class="cellalignment1013" headers="r3c1-t8 r1c2-t8">
<pre>
SQL UPDATE
</pre></td>
<td class="cellalignment1013" headers="r3c1-t8 r1c3-t8">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t8 r1c4-t8">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t8 r1c5-t8">
<p>Update rows</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t8" headers="r1c1-t8">
<p>3</p>
</td>
<td class="cellalignment1013" headers="r4c1-t8 r1c2-t8">
<pre>
<a href="oci17msc006.htm#i428845">OCITransCommit()</a>
</pre></td>
<td class="cellalignment1013" headers="r4c1-t8 r1c3-t8">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t8 r1c4-t8">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t8 r1c5-t8">
<p>Commit succeeds.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" -->
<div id="LNOCI16549" class="sect3"><a id="sthref1361"></a>
<h4 class="sect3">Start a Transaction, Detach, Resume, Prepare, Two-Phase Commit</h4>
<p><a href="#BGBECJCF">Table 8-3</a> lists the steps for a two-phase commit operation.</p>
<div id="LNOCI16550" class="tblformalwide">
<p class="titleintable"><a id="sthref1362"></a><a id="BGBECJCF"></a>Table 8-3 Two-Phase Commit</p>
<table class="cellalignment1011" title="Two-Phase Commit " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t9">Step</th>
<th class="cellalignment1012" id="r1c2-t9">OCI Action</th>
<th class="cellalignment1012" id="r1c3-t9">XID</th>
<th class="cellalignment1012" id="r1c4-t9">Flags</th>
<th class="cellalignment1012" id="r1c5-t9">Result</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t9" headers="r1c1-t9">
<p>1</p>
</td>
<td class="cellalignment1013" headers="r2c1-t9 r1c2-t9">
<pre>
<a href="oci17msc006.htm#i458405">OCITransStart()</a>
</pre></td>
<td class="cellalignment1013" headers="r2c1-t9 r1c3-t9">
<p>1234</p>
</td>
<td class="cellalignment1013" headers="r2c1-t9 r1c4-t9">
<p><code>OCI_TRANS_NEW</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t9 r1c5-t9">
<p>Starts new read-only transaction</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t9" headers="r1c1-t9">
<p>2</p>
</td>
<td class="cellalignment1013" headers="r3c1-t9 r1c2-t9">
<pre>
SQL UPDATE
</pre></td>
<td class="cellalignment1013" headers="r3c1-t9 r1c3-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t9 r1c4-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t9 r1c5-t9">
<p>Updates rows</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t9" headers="r1c1-t9">
<p>3</p>
</td>
<td class="cellalignment1013" headers="r4c1-t9 r1c2-t9">
<pre>
<a href="oci17msc006.htm#i428849">OCITransDetach()</a>
</pre></td>
<td class="cellalignment1013" headers="r4c1-t9 r1c3-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t9 r1c4-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t9 r1c5-t9">
<p>Transaction is detached.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t9" headers="r1c1-t9">
<p>4</p>
</td>
<td class="cellalignment1013" headers="r5c1-t9 r1c2-t9">
<pre>
<a href="oci17msc006.htm#i458405">OCITransStart()</a>
</pre></td>
<td class="cellalignment1013" headers="r5c1-t9 r1c3-t9">
<p>1234</p>
</td>
<td class="cellalignment1013" headers="r5c1-t9 r1c4-t9">
<p><a id="sthref1363"></a><code>OCI_TRANS_RESUME</code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t9 r1c5-t9">
<p>Transaction is resumed.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t9" headers="r1c1-t9">
<p>5</p>
</td>
<td class="cellalignment1013" headers="r6c1-t9 r1c2-t9">
<pre>
SQL UPDATE
</pre></td>
<td class="cellalignment1013" headers="r6c1-t9 r1c3-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r6c1-t9 r1c4-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r6c1-t9 r1c5-t9">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t9" headers="r1c1-t9">
<p>6</p>
</td>
<td class="cellalignment1013" headers="r7c1-t9 r1c2-t9">
<pre>
<a href="oci17msc006.htm#i545171">OCITransPrepare()</a>
</pre></td>
<td class="cellalignment1013" headers="r7c1-t9 r1c3-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r7c1-t9 r1c4-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r7c1-t9 r1c5-t9">
<p>Transaction is prepared for two-phase commit.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t9" headers="r1c1-t9">
<p>7</p>
</td>
<td class="cellalignment1013" headers="r8c1-t9 r1c2-t9">
<pre>
<a href="oci17msc006.htm#i428845">OCITransCommit()</a>
</pre></td>
<td class="cellalignment1013" headers="r8c1-t9 r1c3-t9">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r8c1-t9 r1c4-t9">
<p><a id="sthref1364"></a><code>OCI_TRANS_TWOPHASE</code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t9 r1c5-t9">
<p>Transaction is committed.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>In Step 4, the transaction can be resumed by a different process, as long as it had the same authorization.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16551" class="sect3"><a id="sthref1365"></a>
<h4 class="sect3">Read-Only Update Fails</h4>
<p><a href="#BGBBHJGC">Table 8-4</a> lists the steps in a failed read-only update operation.</p>
<div id="LNOCI16552" class="tblformalwide">
<p class="titleintable"><a id="sthref1366"></a><a id="BGBBHJGC"></a>Table 8-4 Read-Only Update Fails</p>
<table class="cellalignment1011" title="Read-Only Update Fails " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t10">Step</th>
<th class="cellalignment1012" id="r1c2-t10">OCI Action</th>
<th class="cellalignment1012" id="r1c3-t10">XID</th>
<th class="cellalignment1012" id="r1c4-t10">Flags</th>
<th class="cellalignment1012" id="r1c5-t10">Result</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t10" headers="r1c1-t10">
<p>1</p>
</td>
<td class="cellalignment1013" headers="r2c1-t10 r1c2-t10">
<pre>
<a href="oci17msc006.htm#i458405">OCITransStart()</a>
</pre></td>
<td class="cellalignment1013" headers="r2c1-t10 r1c3-t10">
<p>1234</p>
</td>
<td class="cellalignment1013" headers="r2c1-t10 r1c4-t10">
<p><code>OCI_TRANS_NEW</code> |</p>
<p><a id="sthref1367"></a><code>OCI_TRANS_READONLY</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t10 r1c5-t10">
<p>Starts new read-only transaction.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t10" headers="r1c1-t10">
<p>2</p>
</td>
<td class="cellalignment1013" headers="r3c1-t10 r1c2-t10">
<pre>
SQL UPDATE
</pre></td>
<td class="cellalignment1013" headers="r3c1-t10 r1c3-t10">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t10 r1c4-t10">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t10 r1c5-t10">
<p>Update fails, because the transaction is read-only.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t10" headers="r1c1-t10">
<p>3</p>
</td>
<td class="cellalignment1013" headers="r4c1-t10 r1c2-t10">
<pre>
<a href="oci17msc006.htm#i428845">OCITransCommit()</a>
</pre></td>
<td class="cellalignment1013" headers="r4c1-t10 r1c3-t10">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t10 r1c4-t10">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t10 r1c5-t10">
<p>Commit has no effect.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" -->
<div id="LNOCI16553" class="sect3"><a id="sthref1368"></a>
<h4 class="sect3">Start a Read-Only Transaction, Select, and Commit</h4>
<p><a href="#BGBJJFHC">Table 8-5</a> lists the steps for a read-only transaction.</p>
<div id="LNOCI16554" class="tblformalwide">
<p class="titleintable"><a id="sthref1369"></a><a id="BGBJJFHC"></a>Table 8-5 Read-Only Transaction</p>
<table class="cellalignment1011" title="Read-Only Transaction " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t11">Step</th>
<th class="cellalignment1012" id="r1c2-t11">OCI Action</th>
<th class="cellalignment1012" id="r1c3-t11">XID</th>
<th class="cellalignment1012" id="r1c4-t11">Flags</th>
<th class="cellalignment1012" id="r1c5-t11">Result</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t11" headers="r1c1-t11">
<p>1</p>
</td>
<td class="cellalignment1013" headers="r2c1-t11 r1c2-t11">
<pre>
<a href="oci17msc006.htm#i458405">OCITransStart()</a>
</pre></td>
<td class="cellalignment1013" headers="r2c1-t11 r1c3-t11">
<p>1234</p>
</td>
<td class="cellalignment1013" headers="r2c1-t11 r1c4-t11">
<p><code>OCI_TRANS_NEW</code> |</p>
<p><code>OCI_TRANS_READONLY</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t11 r1c5-t11">
<p>Starts new read-only transaction</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t11" headers="r1c1-t11">
<p>2</p>
</td>
<td class="cellalignment1013" headers="r3c1-t11 r1c2-t11">
<pre>
SQL SELECT
</pre></td>
<td class="cellalignment1013" headers="r3c1-t11 r1c3-t11">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t11 r1c4-t11">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t11 r1c5-t11">
<p>Queries the database</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t11" headers="r1c1-t11">
<p>3</p>
</td>
<td class="cellalignment1013" headers="r4c1-t11 r1c2-t11">
<pre>
<a href="oci17msc006.htm#i428845">OCITransCommit()</a>
</pre></td>
<td class="cellalignment1013" headers="r4c1-t11 r1c3-t11">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t11 r1c4-t11">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t11 r1c5-t11">
<p>No effect &mdash; transaction is read-only, no changes made</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i422789"></a>
<div id="LNOCI16555" class="sect1">
<h2 class="sect1">Password and Session Management<a id="sthref1370"></a><a id="sthref1371"></a></h2>
<p>OCI can authenticate and maintain multiple users.</p>
<div id="LNOCI16556" class="sect2"><a id="sthref1372"></a>
<h3 class="sect2">OCI Authentication Management<a id="sthref1373"></a></h3>
<p>The <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> <a id="sthref1374"></a>call authenticates a user against the server set in the service context handle. It must be the first call for any given server handle. <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> authenticates the user for access to the Oracle database specified by the server handle and the service context of the call: after <a href="oci16rel001.htm#i558225">OCIServerAttach()</a> initializes a server handle, <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> must be called to authenticate the user for that server.</p>
<p><a id="sthref1375"></a><a id="sthref1376"></a>When <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> is called for the first time on a server handle, the user session may not be created in migratable mode (<a id="sthref1377"></a><code>OCI_MIGRATE</code>). After <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> has been called for a server handle, the application can call <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> again to initialize another user session handle with different or the same credentials and different or the same operation modes. For an application to authenticate a user in <code>OCI_MIGRATE</code> mode, the service handle must already be associated with a nonmigratable user handle. The <code>userid</code> of that user handle becomes the ownership ID of the migratable user session. Every migratable session must have a nonmigratable parent session.</p>
<ul>
<li>
<p>If <code>OCI_MIGRATE</code> mode is not specified, then the user session context can be used only with the server handle specified with the <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>.</p>
</li>
<li>
<p>If <code>OCI_MIGRATE</code> mode is specified, then the user authentication can be set with other server handles. However, the user session context can only be used with server handles that resolve to the same database instance. Security checking is performed during session switching.</p>
</li>
</ul>
<p>A migratable session can switch to a different server handle only if the ownership ID of the session matches the <code>userid</code> of a nonmigratable session currently connected to that same server.</p>
<p><code>OCI_SYSDBA</code>, <code>OCI_SYSOPER</code>, and <code>OCI_PRELIM_AUTH</code> settings can only be used with a primary user session context.</p>
<p>A migratable session can be switched, or migrated, to a server handle within an environment represented by an environment handle. It can also migrate or be cloned to a server handle in another environment in the same process, or in a different process in a different mode. To perform this migration or cloning, you must do the following:</p>
<ol>
<li>
<p>Extract the session ID from the session handle using <code>OCI_ATTR_MIGSESSION</code>. This is an array of bytes that must not be modified by the caller.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428844">"User Session Handle Attributes"</a></div>
</li>
<li>
<p>Transport this session ID to another process.</p>
</li>
<li>
<p>In the new environment, create a session handle and set the session ID using <code>OCI_ATTR_MIGSESSION</code>.</p>
</li>
<li>
<p>Execute <code>OCISessionBegin()</code>. The resulting session handle is fully authenticated.</p>
</li>
</ol>
<p>To provide credentials for a call to <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>, you must provide a valid user name and password pair for database authentication in the user session handle parameter. This involves using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set the <code>OCI_ATTR_USERNAME</code> and <code>OCI_ATTR_PASSWORD</code> attributes on the user session handle. Then <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> is called with <code>OCI_CRED_RDBMS</code>.</p>
<p>When the user session handle is terminated using <a href="oci16rel001.htm#i556679">OCISessionEnd()</a>, the user name and password attributes are changed and thus cannot be reused in a future call to <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>. They must be reset to new values before the next <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> call.</p>
<p>Or, you can supply external credentials. No attributes need to be set on the user session handle before calling <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>. The credential type is <code>OCI_CRED_EXT</code>. If values have been set for <code>OCI_ATTR_USERNAME</code> and <code>OCI_ATTR_PASSWORD</code>, these are ignored if <code>OCI_CRED_EXT</code> is used.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16557" class="sect2"><a id="sthref1378"></a>
<h3 class="sect2">OCI Password Management<a id="sthref1379"></a></h3>
<p>The <a href="oci17msc007.htm#i573853">OCIPasswordChange()</a> call enables an application to modify a user's database password as necessary. This is particularly useful if a call to <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> returns an error message or warning indicating that a user's password has expired.</p>
<p>Applications can also use <a href="oci17msc007.htm#i573853">OCIPasswordChange()</a> to establish a user authentication context and to change the password. If <a href="oci17msc007.htm#i573853">OCIPasswordChange()</a> is called with an uninitialized service context, it establishes a service context and authenticates the user's account using the old password, and then changes the password to the new password. If the <code>OCI_AUTH</code> flag is set, the call leaves the user session initialized. Otherwise, the user session is cleared.</p>
<p>If the service context passed to <a href="oci17msc007.htm#i573853">OCIPasswordChange()</a> is already initialized, then <a href="oci17msc007.htm#i573853">OCIPasswordChange()</a> authenticates the given account using the old password and changes the password to the new password. In this case, no matter how the flag is set, the user session remains initialized.</p>
</div>
<!-- class="sect2" -->
<a id="CIAEIJCF"></a>
<div id="LNOCI13251" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Secure External Password Store</h3>
<p>For large-scale deployments where applications use password credentials to connect to databases, it is possible to store such credentials in a client-side Oracle wallet. An Oracle wallet is a secure software container that is used to store authentication and signing credentials.</p>
<p>Storing database password credentials in a client-side Oracle wallet eliminates the need to embed user names and passwords in application code, <a id="sthref1380"></a>batch jobs, or <a id="sthref1381"></a>scripts. This reduces the risk of exposing passwords in the clear in scripts and application code, and simplifies maintenance because you need not change your code each time user names and passwords change. In addition, not having to change application code makes it easier to enforce password management policies for these user accounts.</p>
<p>When you configure a client to use the external password store, applications can use the following syntax to connect to databases that use password authentication:</p>
<pre>
CONNECT /@<span class="italic">database_alias</span>
</pre>
<p>Note that you need not specify database login credentials in this <code>CONNECT</code> statement. Instead your system looks for database login credentials in the client wallet.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN11133" href="../../server.112/e25494/create.htm#ADMIN11133"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about configuring your client to use the secure external password store</div>
</div>
<!-- class="sect2" -->
<a id="i453378"></a>
<div id="LNOCI16558" class="sect2">
<h3 class="sect2">OCI Session Management<a id="sthref1382"></a></h3>
<p>Transaction servers that actively balance user load by multiplexing user sessions over a few server connections must group these connections into a server group. Oracle Database uses server groups to identify these connections so that sessions can be managed effectively and securely.</p>
<p>The attribute <code>OCI_ATTR_SERVER_GROUP</code> must be defined to specify the server group name by using the <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> call, as shown in <a href="#BGBFFEAB">Example 8-1</a>.</p>
<div id="LNOCI18178" class="example">
<p class="titleinexample"><a id="BGBFFEAB"></a>Example 8-1 Defining the OCI_ATTR_SERVER_GROUP Attribute to Pass the Server Group Name</p>
<pre>
OCIAttrSet ((void *) srvhp, (ub4) OCI_HTYPE_SERVER, (void *) group_name, 
            (ub4) strlen ((CONST char *) group_name), 
            (ub4) OCI_ATTR_SERVER_GROUP, errhp);
</pre></div>
<!-- class="example" -->
<p>The server group name is an alphanumeric string not exceeding 30 characters. This attribute can only be set <span class="italic">after</span> calling <a href="oci16rel001.htm#i558225">OCIServerAttach()</a>. <code>OCI_ATTR_SERVER_GROUP</code> <a id="sthref1383"></a>attribute must be set in the server context before creating the first nonmigratable session that uses that context. After the session is created successfully and the connection to the server is established, the server group name cannot be changed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i429949">"Server Handle Attributes"</a></div>
<p>All migratable sessions created on servers within a server group can only migrate to other servers in the same server group. Servers that terminate are removed from the server group. New servers can be created within an existing server group at any time.</p>
<p>The use of server groups is optional. If no server group is specified, the server is created in a server group called <code>DEFAULT</code>.</p>
<p>The owner of the first nonmigratable session created in a nondefault server group becomes the owner of the server group. All subsequent nonmigratable sessions for any server in this server group must be created by the owner of the server group.</p>
<p>The server group feature is useful when dedicated servers are used. It has no effect on shared servers. All shared servers effectively belong to the server group <code>DEFAULT</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i451070"></a>
<div id="LNOCI16559" class="sect1">
<h2 class="sect1">Middle-Tier Applications in OCI</h2>
<p>A middle-tier application receives requests from browser clients. The application determines database access and whether to generate an HTML page. Applications can have multiple <span class="italic">lightweight</span> user sessions within a single database session. These lightweight sessions allow each user to be authenticated without the overhead of a separate database connection, and they preserve the identity of the real user through the middle tier.</p>
<p>As long as the client authenticates itself with the middle tier, and the middle tier authenticates itself with the database, and the middle tier is authorized to act on behalf of the client by the administrator, client identities can be maintained all the way into the database without compromising the security of the client.</p>
<p>The design of a secure three-tier architecture is developed around a set of three trust zones.</p>
<p>The first is the client trust zone. Clients connecting to a web application server are authenticated by the middle tier using any means: password, cryptographic token, or another. This method can be entirely different from the method used to establish the other trust zones.</p>
<p>The second trust zone is the application server. The data server verifies the identity of the application server and trusts it to pass the correct identity of the client.</p>
<p>The third trust zone is the data server interaction with the authorization server to obtain the roles assigned to the client and the application server.</p>
<p>The application server creates a primary session for itself after it connects to a server. It authenticates itself in the normal manner to the database, creating the application server trust zone. The application server identity is now well known and trusted by the data server.</p>
<p>When the application verifies the identity of a client connecting to the application server, it creates the first trust zone. The application server now needs a session handle for the client so that it can service client requests. The middle-tier process allocates a session handle and then sets the following attributes of the client using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>:</p>
<ul>
<li>
<p><code>OCI_ATTR_USERNAME</code> sets the database user name of the client.</p>
</li>
<li>
<p><code>OCI_ATTR_PROXY_CREDENTIALS</code> indicates the authenticated application making the proxy request.</p>
</li>
</ul>
<p>To specify a list of roles activated after the application server connects as the client, it can call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> with the attribute <code>OCI_ATTR_INITIAL_CLIENT_ROLES</code> and an array of strings that contains the list of roles before the <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> call. Then the role is established and proxy capability is verified in one round-trip. If the application server is not allowed to act on behalf of the client, or if the application server is not allowed to activate the specified roles, the <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> call fails.</p>
<div id="LNOCI16560" class="sect2"><a id="sthref1384"></a>
<h3 class="sect2">OCI Attributes for Middle-Tier Applications</h3>
<p>The following attributes enable you to specify the external name and initial privileges of a client. These credentials are used by applications as alternative means of identifying or authenticating the client.</p>
<div id="LNOCI16561" class="sect3"><a id="sthref1385"></a>
<h4 class="sect3"><a id="sthref1386"></a>OCI_CRED_PROXY</h4>
<p>Use <code>OCI_CRED_PROXY</code> as the value passed in the <code>credt</code> parameter of <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> when an application server starts a session on behalf of a client, rather than <a id="sthref1387"></a><code>OCI_CRED_RDBMS</code> (database user name and password required) or <code><a id="sthref1388"></a>OCI_CRED_EXT</code> (externally provided credentials).</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16562" class="sect3"><a id="sthref1389"></a>
<h4 class="sect3"><a id="sthref1390"></a>OCI_ATTR_PROXY_CREDENTIALS</h4>
<p>Use the <code>OCI_ATTR_PROXY_CREDENTIALS</code> attribute to specify the credentials of the application server in client authentication. You can code the following declarations and <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> call, as shown in <a href="#BGBEJIGA">Example 8-2</a>.</p>
<div id="LNOCI18179" class="example">
<p class="titleinexample"><a id="BGBEJIGA"></a>Example 8-2 Defining the OCI_ATTR_PROXY_CREDENTIALS Attribute to Specify the Credentials of the Application Server for Client Authentication</p>
<pre>
OCISession *session_handle;
OCISvcCtx  *application_server_session_handle;
OCIError   *error_handle;
...
OCIAttrSet((void *)session_handle, (ub4) OCI_HTYPE_SESSION, 
           (void *)application_server_session_handle, (ub4) 0, 
            OCI_ATTR_PROXY_CREDENTIALS, error_handle);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16563" class="sect3"><a id="sthref1391"></a>
<h4 class="sect3"><a id="sthref1392"></a>OCI_ATTR_DISTINGUISHED_NAME</h4>
<p>Your applications can use the distinguished name contained within a X.509 certificate as the login name of the client, instead of the database user name.</p>
<p>To pass the distinguished name of the client, the middle-tier server calls <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>, passing <a id="sthref1393"></a><code>OCI_ATTR_DISTINGUISHED_NAME</code>, as shown in <a href="#BGBIGEGE">Example 8-3</a>.</p>
<div id="LNOCI18180" class="example">
<p class="titleinexample"><a id="BGBIGEGE"></a>Example 8-3 Defining the OCI_ATTR_DISTINGUISHED_NAME Attribute to Pass the Distinguished Name of the Client</p>
<pre>
/* Declarations */
...
OCIAttrSet((void *)session_handle, (ub4) OCI_HTYPE_SESSION,
           (void *)distinguished_name, (ub4) 0,
           OCI_ATTR_DISTINGUISHED_NAME, error_handle);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16564" class="sect3"><a id="sthref1394"></a>
<h4 class="sect3"><a id="sthref1395"></a>OCI_ATTR_CERTIFICATE<a id="sthref1396"></a></h4>
<p>Certificate-based proxy authentication using <code>OCI_ATTR_CERTIFICATE</code> will not be supported in future Oracle Database releases. Use <code>OCI_ATTR_DISTINGUISHED_NAME</code> or <code>OCI_ATTR_USERNAME</code> attribute instead. This method of authentication is similar to the use of the distinguished name. The entire X.509 certificate is passed by the middle-tier server to the database.</p>
<p>To pass over the entire certificate, the middle tier calls <a href="oci16rel002.htm#i443804">OCIAttrSet()</a><span class="italic">,</span> passing <code><a id="sthref1397"></a>OCI_ATTR_CERTIFICATE</code>, as shown in <a href="#BGBCCFFC">Example 8-4</a>.</p>
<div id="LNOCI18181" class="example">
<p class="titleinexample"><a id="BGBCCFFC"></a>Example 8-4 Defining the OCI_ATTR_CERTIFICATE Attribute to Pass the Entire X.509 Certificate</p>
<pre>
OCIAttrSet((void *)session_handle, (ub4) OCI_HTYPE_SESSION, 
           (void *)certificate, ub4 certificate_length, 
           OCI_ATTR_CERTIFICATE, error_handle);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16565" class="sect3"><a id="sthref1398"></a>
<h4 class="sect3"><a id="sthref1399"></a>OCI_ATTR_INITIAL_CLIENT_ROLES</h4>
<p>Use the <code>OCI_ATTR_INITIAL_CLIENT_ROLES</code> attribute to specify the roles the client is to possess when the application server connects to the Oracle database. To enable a set of roles, the function <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> is called with the attribute, an array of <code>NULL</code>-terminated strings, and the number of strings in the array, as shown in <a href="#BGBCGEEF">Example 8-5</a>.</p>
<div id="LNOCI18182" class="example">
<p class="titleinexample"><a id="BGBCGEEF"></a>Example 8-5 Defining the OCI_ATTR_INITIAL_CLIENT_ROLES Attribute to Pass the Client Roles</p>
<pre>
OCIAttrSet((void *)session_handle, (ub4) OCI_HTYPE_SESSION, 
           (void *)role_array, (ub4) number_of_strings,
           OCI_ATTR_INITIAL_CLIENT_ROLES, error_handle);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16566" class="sect3"><a id="sthref1400"></a>
<h4 class="sect3"><a id="sthref1401"></a>OCI_ATTR_CLIENT_IDENTIFIER</h4>
<p>Many middle-tier applications connect to the database as an application, and rely on the middle tier to track end-user identity. To integrate tracking of the identity of these users in various database components, the database client can set the <code>CLIENT_IDENTIFIER</code> (a predefined attribute from the application context namespace <code>USERENV</code>) in the session handle at any time. Use the OCI attribute <code>OCI_ATTR_CLIENT_IDENTIFIER</code> in the call to <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>, as shown in <a href="#BGBIEGGA">Example 8-6</a>. On the next request to the server, the information is propagated and stored in the server session.</p>
<p><code>OCI_ATTR_CLIENT_IDENTIFIER</code> can also be used in conjunction with the global application context to restrict availability of the context to the selected identity of these users.</p>
<div id="LNOCI18183" class="example">
<p class="titleinexample"><a id="BGBIEGGA"></a>Example 8-6 Defining the OCI_ATTR_CLIENT_IDENTIFIER Attribute to Pass the End-User Identity</p>
<pre>
OCIAttrSet((void *)session_handle, (ub4) OCI_HTYPE_SESSION, 
           (void *)"janedoe", (ub4)strlen("janedoe"),
           OCI_ATTR_CLIENT_IDENTIFIER, error_handle);
</pre></div>
<!-- class="example" -->
<p>When a client has multiple sessions, execute <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> for each session using the same client identifier. <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> must be executed manually for sessions that are reestablished through transparent application failover (TAF).</p>
<p>The client identifier is found in <code>V$SESSION</code> as a <code>CLIENT_IDENTIFIER</code> column or through the system context with this SQL statement:</p>
<pre>
SELECT SYS_CONTEXT('userenv', 'client_identifier') FROM DUAL;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DBSEG15003" href="../../network.112/e36292/authentication.htm#DBSEG15003"><span class="italic">Oracle Database Security Guide,</span></a> the section about preserving user identity in multi-tiered environments"</p>
</li>
<li>
<p><a href="oci09adv.htm#i449791">"Transparent Application Failover in OCI"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16567" class="sect3"><a id="sthref1402"></a>
<h4 class="sect3"><a id="sthref1403"></a><a id="sthref1404"></a>OCI_ATTR_PASSWORD<a id="sthref1405"></a></h4>
<p>A middle tier can ask the database server to authenticate a client on its behalf by validating the password of the client rather than doing the authentication itself. Although it appears that this is the same as a client/server connection, the client does not have to have Oracle Database software installed on the client's system to be able to perform database operations. To use the password of the client, the application server supplies <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> with the authentication data, using the existing attribute <code><a id="sthref1406"></a>OCI_ATTR_PASSWORD</code>, as shown in <a href="#BGBCIHIA">Example 8-7</a>.</p>
<div id="LNOCI18184" class="example">
<p class="titleinexample"><a id="BGBCIHIA"></a>Example 8-7 Defining the OCI_ATTR_PASSWORD Attribute to Pass the Password for Validation</p>
<pre>
OCIAttrSet((void *)session_handle, (ub4) OCI_HTYPE_SESSION, (void *)password,
           (ub4)0, OCI_ATTR_PASSWORD, error_handle);
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428844">"User Session Handle Attributes"</a></div>
<p><a href="#BGBBBEFJ">Example 8-8</a> shows OCI attributes that enable you to specify the external name and initial privileges of a client. These credentials are used by OCI applications as alternative means of identifying or authenticating the client.</p>
<div id="LNOCI18185" class="example">
<p class="titleinexample"><a id="BGBBBEFJ"></a>Example 8-8 OCI Attributes That Let You Specify the External Name and Initial Privileges of a Client</p>
<pre>
...
*OCIEnv *environment_handle; 
OCIServer *data_server_handle; 
OCIError *error_handle; 
OCISvcCtx *application_server_service_handle; 
OraText *client_roles[2]; 
OCISession *first_client_session_handle, second_client_session_handle; 
...
/*
** General initialization and allocation of contexts. 
*/
 
(void) OCIInitialize((ub4) OCI_DEFAULT, (void *)0,
                     (void * (*)(void *, size_t)) 0, 
                     (void * (*)(void *, void *, size_t))0, 
                     (void (*)(void *, void *)) 0 ); 
(void) OCIEnvInit( (OCIEnv **) &amp;environment_handle, OCI_DEFAULT, (size_t) 0,
                  (void **) 0 ); 
(void) OCIHandleAlloc( (void *) environment_handle, (void **) &amp;error_handle,
     OCI_HTYPE_ERROR, (size_t) 0, (void **) 0); 
/* 
** Allocate and initialize the server and service contexts used by the
** application server. 
*/ 

(void) OCIHandleAlloc( (void *) environment_handle, 
     (void **)&amp;data_server_handle, OCI_HTYPE_SERVER, (size_t) 0, (void **) 0); 
(void) OCIHandleAlloc( (void *) environment_handle, (void **)
     &amp;application_server_service_handle, OCI_HTYPE_SVCCTX, (size_t) 0, 
     (void **) 0);  
(void) OCIAttrSet((void *) application_server_service_handle,
     OCI_HTYPE_SVCCTX, (void *) data_server_handle, (ub4) 0, OCI_ATTR_SERVER,
     error_handle); 
/* 
** Authenticate the application server. In this case, external authentication is
** being used. 
*/

(void) OCIHandleAlloc((void *) environment_handle, 
     (void **)&amp;application_server_session_handle, (ub4) OCI_HTYPE_SESSION,
     (size_t) 0, (void **) 0); 
checkerr(error_handle, OCISessionBegin(application_server_service_handle,
     error_handle, application_server_session_handle, OCI_CRED_EXT,
     OCI_DEFAULT)); 
/* 
** Authenticate the first client. 
** Note that no password is specified by the 
** application server for the client as it is trusted. 
*/ 

(void) OCIHandleAlloc((void *) environment_handle, 
     (void **)&amp;first_client_session_handle, (ub4) OCI_HTYPE_SESSION, 
     (size_t) 0,(void **) 0); 
(void) OCIAttrSet((void *) first_client_session_handle, 
     (ub4) OCI_HTYPE_SESSION, (void *) "jeff", (ub4) strlen("jeff"),
     OCI_ATTR_USERNAME, error_handle); 
/* 
** In place of specifying a password, pass the session handle of the application
** server instead. 
*/ 

(void) OCIAttrSet((void *) first_client_session_handle, 
     (ub4) OCI_HTYPE_SESSION, (void *) application_server_session_handle, 
     (ub4) 0, OCI_ATTR_PROXY_CREDENTIALS, error_handle); 
(void) OCIAttrSet((void *) first_client_session_handle, 
     (ub4) OCI_HTYPE_SESSION, (void *) "jeff@VeryBigBank.com", 
     (ub4) strlen("jeff@VeryBigBank.com"), OCI_ATTR_EXTERNAL_NAME,
     error_handle); 
/* 
** Establish the roles that the application server can use as the client. 
*/
 
client_roles[0] = (OraText *) "TELLER"; 
client_roles[1] = (OraText *) "SUPERVISOR";
(void) OCIAttrSet((void *) first_client_session_handle, 
     OCI_ATTR_INITIAL_CLIENT_ROLES, error_handle); 
checkerr(error_handle, OCISessionBegin(application_server_service_handle,
     error_handle, first_client_session_handle, OCI_CRED_PROXY, OCI_DEFAULT)); 
/* 
** To start a session as another client, the application server does the 
** following.
** This code is unchanged from the current way of doing session switching. 
*/

(void) OCIHandleAlloc((void *) environment_handle, 
     (void **)&amp;second_client_session_handle, (ub4) OCI_HTYPE_SESSION, 
     (size_t) 0, (void **) 0); 
(void) OCIAttrSet((void *) second_client_session_handle, 
     (ub4) OCI_HTYPE_SESSION, (void *) "mutt", (ub4) strlen("mutt"),
     OCI_ATTR_USERNAME, error_handle); 
(void) OCIAttrSet((void *) second_client_session_handle, 
     (ub4) OCI_HTYPE_SESSION, (void *) application_server_session_handle, 
     (ub4) 0, OCI_ATTR_PROXY_CREDENTIALS, error_handle); 
(void) OCIAttrSet((void *) second_client_session_handle, 
     (ub4) OCI_HTYPE_SESSION, (void *) "mutt@VeryBigBank.com", 
     (ub4) strlen("mutt@VeryBigBank.com"), OCI_ATTR_EXTERNAL_NAME,
     error_handle); 
/* 
** Note that the application server has not specified any initial roles to have
** as the second client. 
*/
 
checkerr(error_handle, OCISessionBegin(application_server_service_handle,
     error_handle, second_client_session_handle, OCI_CRED_PROXY, OCI_DEFAULT)); 
/* 
** To switch to the first user, the application server applies the session
** handle obtained by the first 
** OCISessionBegin() call. This is the same as is currently done. 
*/ 

(void) OCIAttrSet((void *)application_server_service_handle, 
     (ub4) OCI_HTYPE_SVCCTX, (void *)first_client_session_handle, 
     (ub4)0, (ub4)OCI_ATTR_SESSION, error_handle); 
/* 
** After doing some operations, the application server can switch to
** the second client. That 
** is be done by the following call: 
*/

(void) OCIAttrSet((void *)application_server_service_handle, 
     (ub4) OCI_HTYPE_SVCCTX, 
     (void *)second_client_session_handle, (ub4)0, (ub4)OCI_ATTR_SESSION,
     error_handle); 
/* 
** and then do operations as that client 
*/
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i452816"></a>
<div id="LNOCI840" class="sect1">
<h2 class="sect1"><a id="sthref1407"></a>Externally Initialized Context in OCI</h2>
<p>An externally initialized context is an application context where attributes can be initialized from OCI. Use the SQL statement <code>CREATE</code> <code>CONTEXT</code> to create a context namespace in the server with the option <code>INITIALIZED</code> <code>EXTERNALLY</code>.</p>
<p>Then, you can initialize an OCI interface when establishing a session using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> and <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>. Issue subsequent commands to write to any attributes inside the namespace only with the PL/SQL package designated in the <code>CREATE</code> <code>CONTEXT</code> statement.</p>
<p>You can set default values and other session attributes through the <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> call, thus reducing server round-trips.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DBSEG005" href="../../network.112/e36292/app_devs.htm#DBSEG005"><span class="italic">Oracle Database Security Guide,</span></a> the chapter about managing security for application developers</p>
</li>
<li>
<p><a class="olink SQLRF01202" href="../../server.112/e41084/statements_5002.htm#SQLRF01202"><span class="italic">Oracle Database SQL Language Reference,</span></a> the <code>CREATE</code> <code>CONTEXT</code> statement and the <code>SYS_CONTEXT</code> function</p>
</li>
</ul>
</div>
<div id="LNOCI16573" class="sect2"><a id="sthref1408"></a>
<h3 class="sect2">Externally Initialized Context Attributes in OCI</h3>
<p>The client applications you develop can set application contexts explicitly in the session handle before authentication, using the following attributes in OCI functions:</p>
<div id="LNOCI16574" class="sect3"><a id="sthref1409"></a>
<h4 class="sect3"><a id="sthref1410"></a>OCI_ATTR_APPCTX_SIZE</h4>
<p>Use the <code>OCI_ATTR_APPCTX_SIZE</code> attribute to initialize the context array size with the desired number of context attributes in the <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> call, as shown in <a href="#BGBFJCBI">Example 8-9</a>.</p>
<div id="LNOCI18186" class="example">
<p class="titleinexample"><a id="BGBFJCBI"></a>Example 8-9 Defining the OCI_ATTR_APPCTX_SIZE Attribute to Initialize the Context Array Size with the Desired Number of Context Attributes</p>
<pre>
OCIAttrSet(session, (ub4) OCI_HTYPE_SESSION, 
           (void *)&amp;size, (ub4)0, OCI_ATTR_APPCTX_SIZE, error_handle); 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16575" class="sect3"><a id="sthref1411"></a>
<h4 class="sect3"><a id="sthref1412"></a>OCI_ATTR_APPCTX_LIST</h4>
<p>Use the <code>OCI_ATTR_APPCTX_LIST</code> attribute to get a handle on the application context list descriptor for the session in the <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> call, as shown in <a href="#BGBFBIAI">Example 8-10</a>. (The parameter <code>ctxl_desc</code> must be of data type <code>OCIParam *</code>).</p>
<div id="LNOCI18187" class="example">
<p class="titleinexample"><a id="BGBFBIAI"></a>Example 8-10 Using the OCI_ATTR_APPCTX_LIST Attribute to Get a Handle on the Application Context List Descriptor for the Session</p>
<pre>
OCIAttrGet(session, (ub4) OCI_HTYPE_SESSION, 
           (void *)&amp;ctxl_desc, (ub4)0, OCI_ATTR_APPCTX_LIST, error_handle);
</pre></div>
<!-- class="example" -->
<p><a href="#BGBHJGAG">Example 8-11</a> shows how to use the application context list descriptor to obtain an individual descriptor for the i-th application context in a call to <a href="oci16rel002.htm#i540956">OCIParamGet()</a>.</p>
<div id="LNOCI18188" class="example">
<p class="titleinexample"><a id="BGBHJGAG"></a>Example 8-11 Calling OCIParamGet() to Obtain an Individual Descriptor for the i-th Application Context Using the Application Context List Descriptor</p>
<pre>
OCIParamGet(ctxl_desc, OCI_DTYPE_PARAM, error_handle,(void **)&amp;ctx_desc, i);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIABCJIH"></a>
<div id="LNOCI16576" class="sect3">
<h4 class="sect3">Session Handle Attributes Used to Set an Externally Initialized Context</h4>
<p>Set the appropriate values of the application context using these attributes:</p>
<ul>
<li>
<p><a id="sthref1413"></a><code>OCI_ATTR_APPCTX_NAME</code> to set the namespace of the context, which must be a valid SQL identifier.</p>
</li>
<li>
<p><a id="sthref1414"></a><code>OCI_ATTR_APPCTX_ATTR</code> to set an attribute name in the given context, a non-case-sensitive string of up to 30 bytes.</p>
</li>
<li>
<p><a id="sthref1415"></a><code>OCI_ATTR_APPCTX_VALUE</code> to set the value of an attribute in the given context.</p>
</li>
</ul>
<p>Each namespace can have many attributes, each of which has one value. <a href="#BGBHCHGH">Example 8-12</a> shows the calls you can use to set them.</p>
<div id="LNOCI18189" class="example">
<p class="titleinexample"><a id="BGBHCHGH"></a>Example 8-12 Defining Session Handle Attributes to Set Externally Initialized Context</p>
<pre>
OCIAttrSet(ctx_desc, OCI_DTYPE_PARAM,
     (void *)ctx_name, sizeof(ctx_name), OCI_ATTR_APPCTX_NAME, error_handle);
  
OCIAttrSet(ctx_desc, OCI_DTYPE_PARAM,
     (void *)attr_name, sizeof(attr_name), OCI_ATTR_APPCTX_ATTR, error_handle);  
  
OCIAttrSet(ctx_desc, OCI_DTYPE_PARAM,
     (void *)value, sizeof(value), OCI_ATTR_APPCTX_VALUE, error_handle);  
</pre></div>
<!-- class="example" -->
<p>Note that only character type is supported, because application context operations are based on the <code>VARCHAR2</code> data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428844">"User Session Handle Attributes"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i452763"></a>
<div id="LNOCI16569" class="sect2">
<h3 class="sect2">End-to-End Application Tracing</h3>
<p>Use the following attributes to measure server call time, not including server round-trips. These attributes can also be set by using the PL/SQL package <code>DBMS_APPLICATION_INFO</code>, which incurs one round-trip to the server. Using OCI to set the attributes does not incur a round-trip.</p>
<div id="LNOCI16570" class="sect3"><a id="sthref1416"></a>
<h4 class="sect3"><a id="sthref1417"></a>OCI_ATTR_COLLECT_CALL_TIME</h4>
<p>Set a <code>boolean</code> variable to <code>TRUE</code> or <code>FALSE</code>. After you set the <code>OCI_ATTR_COLLECT_CALL_TIME</code> attribute by calling <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>, the server measures each call time. All server times between setting the variable to <code>TRUE</code> and setting it to <code>FALSE</code> are measured.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16571" class="sect3"><a id="sthref1418"></a>
<h4 class="sect3"><a id="sthref1419"></a>OCI_ATTR_CALL_TIME</h4>
<p>The elapsed time, in microseconds, of the last server call is returned in a <code>ub8</code> variable by calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> with the <code>OCI_ATTR_CALL_TIME</code> attribute. <a href="#BGBDBFIE">Example 8-13</a> shows how to do this in a code fragment.</p>
<div id="LNOCI18190" class="example">
<p class="titleinexample"><a id="BGBDBFIE"></a>Example 8-13 Using the OCI_ATTR_CALL_TIME Attribute to Get the Elapsed Time of the Last Server Call</p>
<pre>
boolean enable_call_time;
ub8 call_time;
...
enable_call_time = TRUE;
OCIAttrSet(session, OCI_HTYPE_SESSION, (void *)&amp;enable_call_time,
           (ub4)0, OCI_ATTR_COLLECT_CALL_TIME,
           (OCIError *)error_handle);
OCIStmtExecute(...);
OCIAttrGet(session, OCI_HTYPE_SESSION, (void *)&amp;call_time,
           (ub4)0, OCI_ATTR_CALL_TIME, 
           (OCIError *)error_handle);
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16572" class="sect3"><a id="sthref1420"></a>
<h4 class="sect3">Attributes for End-to-End Application Tracing</h4>
<p>Set these attributes for tracing and debugging applications:</p>
<ul>
<li>
<p><a id="sthref1421"></a><code>OCI_ATTR_MODULE</code> - Name of the current module in the client application.</p>
</li>
<li>
<p><a id="sthref1422"></a><code>OCI_ATTR_ACTION</code> - Name of the current action within the current module. Set to <code>NULL</code> if you do not want to specify an action.</p>
</li>
<li>
<p><a id="sthref1423"></a><code>OCI_ATTR_CLIENT_INFO</code> - Client application additional information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428844">"User Session Handle Attributes"</a></div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16577" class="sect2"><a id="sthref1424"></a>
<h3 class="sect2">Using OCISessionBegin() with an Externally Initialized Context</h3>
<p>When you call <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>, the context set in the session handle is pushed to the server. No additional contexts are propagated to the server session. <a href="#BGBCCBGF">Example 8-14</a> illustrates the use of these calls and attributes.</p>
<div id="LNOCI18191" class="example">
<p class="titleinexample"><a id="BGBCCBGF"></a>Example 8-14 Using OCISessionBegin() with an Externally Initialized Context</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;oci.h&gt;

static OraText *username = (OraText *) "HR";
static OraText *password = (OraText *) "HR";

static OCIEnv *envhp;
static OCIError *errhp;

int main(/*_ int argc, char *argv[] _*/);

static sword status;

int main(argc, argv)
int argc;
char *argv[];
{

  OCISession *authp = (OCISession *) 0;
  OCIServer *srvhp;
  OCISvcCtx *svchp;
  OCIDefine *defnp = (OCIDefine *) 0;
  void     *parmdp;
  ub4        ctxsize;
  OCIParam  *ctxldesc;
  OCIParam  *ctxedesc;

  OCIEnvCreate(&amp;envhp, OCI_DEFAULT, (void *)0, 0, 0, 0,
                            (size_t)0, (void *)0);

  (void) OCIHandleAlloc( (void *) envhp, (void **) &amp;errhp, OCI_HTYPE_ERROR,
                   (size_t) 0, (void **) 0);

  /* server contexts */
  (void) OCIHandleAlloc( (void *) envhp, (void **) &amp;srvhp, OCI_HTYPE_SERVER,
                   (size_t) 0, (void **) 0);

  (void) OCIHandleAlloc( (void *) envhp, (void **) &amp;svchp, OCI_HTYPE_SVCCTX,
                   (size_t) 0, (void **) 0);

  (void) OCIServerAttach( srvhp, errhp, (OraText *)"", strlen(""), 0);

  /* set attribute server context in the service context */
  (void) OCIAttrSet( (void *) svchp, OCI_HTYPE_SVCCTX, (void *)srvhp,
                    (ub4) 0, OCI_ATTR_SERVER, (OCIError *) errhp);

  (void) OCIHandleAlloc((void *) envhp, (void **)&amp;authp,
                        (ub4) OCI_HTYPE_SESSION, (size_t) 0, (void **) 0);
/****************************************/
  /* set app ctx size to 2 because you want to set up 2 application contexts */
  ctxsize = 2;

  /* set up app ctx buffer */
  (void) OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_SESSION,
                 (void *) &amp;ctxsize, (ub4) 0,
                 (ub4) OCI_ATTR_APPCTX_SIZE, errhp);

  /* retrieve the list descriptor */
  (void) OCIAttrGet((void *)authp, (ub4) OCI_HTYPE_SESSION,
                    (void *)&amp;ctxldesc, 0, OCI_ATTR_APPCTX_LIST, errhp );

  /* retrieve the 1st ctx element descriptor */
  (void) OCIParamGet(ctxldesc, OCI_DTYPE_PARAM, errhp, (void**)&amp;ctxedesc, 1);

  (void) OCIAttrSet((void *) ctxedesc, (ub4) OCI_DTYPE_PARAM,
                 (void *) "HR", (ub4) strlen((char *)"HR"),
                 (ub4) OCI_ATTR_APPCTX_NAME, errhp);

  (void) OCIAttrSet((void *) ctxedesc, (ub4) OCI_DTYPE_PARAM,
                 (void *) "ATTR1", (ub4) strlen((char *)"ATTR1"),
                 (ub4) OCI_ATTR_APPCTX_ATTR, errhp);

  (void) OCIAttrSet((void *) ctxedesc, (ub4) OCI_DTYPE_PARAM,
                 (void *) "VALUE1", (ub4) strlen((char *)"VALUE1"),
                 (ub4) OCI_ATTR_APPCTX_VALUE, errhp);

  /* set second context */
  (void) OCIParamGet(ctxldesc, OCI_DTYPE_PARAM, errhp, (void**)&amp;ctxedesc, 2);

  (void) OCIAttrSet((void *) ctxedesc, (ub4) OCI_DTYPE_PARAM,
                 (void *) "HR", (ub4) strlen((char *)"HR"),
                 (ub4) OCI_ATTR_APPCTX_NAME, errhp);

  (void) OCIAttrSet((void *) ctxedesc, (ub4) OCI_DTYPE_PARAM,
                 (void *) "ATTR2", (ub4) strlen((char *)"ATTR2"),
                 (ub4) OCI_ATTR_APPCTX_ATTR, errhp);

  (void) OCIAttrSet((void *) ctxedesc, (ub4) OCI_DTYPE_PARAM,
                 (void *) "VALUE2", (ub4) strlen((char *)"VALUE2"),
                 (ub4) OCI_ATTR_APPCTX_VALUE, errhp);
/****************************************/
  (void) OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_SESSION,
                 (void *) username, (ub4) strlen((char *)username),
                 (ub4) OCI_ATTR_USERNAME, errhp);

  (void) OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_SESSION,
                 (void *) password, (ub4) strlen((char *)password),
                 (ub4) OCI_ATTR_PASSWORD, errhp);

  OCISessionBegin ( svchp,  errhp, authp, OCI_CRED_EXT, (ub4) OCI_DEFAULT);

}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCIBHB"></a>
<div id="LNOCI3605" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1425"></a>Client Application Context</h2>
<p>Application context enables database clients (such as mid-tier applications) to set and send arbitrary session data to the server with each executed statement in only one round-trip. The server stores this data in the session context before statement execution, from which it can be used to restrict queries or DML operations. All database features such as views, triggers, virtual private database (VPD) policies, or PL/SQL stored procedures can use session data to constrain their operations.</p>
<p>A public writable namespace, <code>nm</code>, is created:</p>
<pre>
CREATE CONTEXT nm USING hr.package1;
</pre>
<p>To modify the data grouped in that namespace, users must execute the designated PL/SQL package, <code>hr.package1</code>. However, no privilege is needed to query this information in a user session.</p>
<p>The variable length application context data that is stored in the user session is in the form of an attribute and value pair grouped under the context namespace.</p>
<p>For example, if you want a human resources application to store an end-user's responsibility information in the user session, then it could create an <code>nm</code> namespace and an attribute called "responsibility" that can be assigned a value such as "manager" or "accountant". This is referred to as the <span class="italic">set operation</span> in this document.</p>
<p>If you want the application to clear the value of the "responsibility" attribute in the <code>nm</code> namespace, then it could set it to <code>NULL</code> or an empty string. This is referred to as the <span class="italic">clear operation</span> in this document.</p>
<p>To clear all information in the <code>nm</code> namespace, the application can send the namespace information as a part of the clear-all operation to the server. This is referred to as the <span class="italic">clear-all operation</span> in a namespace in this document.</p>
<p>If there is no package security defined for a namespace, then this namespace is deemed to be a client namespace, and any OCI client can transport data for that namespace to the server. No privilege or package security check is done.</p>
<p>Network transport of application context data is done in a single round-trip to the server.</p>
<div id="LNOCI16578" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1426"></a>
<h3 class="sect2">Multiple SET Operations</h3>
<p>Use the <a href="oci16rel001.htm#CHDICDCB">OCIAppCtxSet()</a><code><a id="sthref1427"></a></code> function to perform a series of set operations on the "responsibility" attribute in the <a id="sthref1428"></a><code>CLIENTCONTEXT</code> namespace. When this information is sent to the server, the latest value prevails for that particular attribute in a namespace. To change the value of the "responsibility" attribute in the <code>CLIENTCONTEXT</code> namespace from "manager" to "vp", use the code fragment shown in <a href="#BGBCEJGD">Example 8-15</a>, on the client side. When this information is transported to the server, the server shows the latest value "vp" for the "responsibility" attribute in the <code>CLIENTCONTEXT</code> namespace.</p>
<div id="LNOCI18192" class="example">
<p class="titleinexample"><a id="BGBCEJGD"></a>Example 8-15 Changing the "responsibility" Attribute Value in the CLIENTCONTEXT Namespace</p>
<pre>
err = OCIAppCtxSet((void *) sesshndl,(void *)"CLIENTCONTEXT",(ub4) 13,
                   (void *)"responsibility", 14
                   (void *)"manager", 7, errhp, OCI_DEFAULT);
err = OCIAppCtxSet((void *) sesshndl, (void*)"CLIENTCONTEXT", 13,
                   (void *)"responsibility", 14,(void *)"vp",2, errhp,
                   OCI_DEFAULT);
</pre></div>
<!-- class="example" -->
<p>You can clear specific attribute information in a client namespace. This can be done by setting the value of an attribute to <code>NULL</code> or to an empty string, as shown in <a href="#BGBCHDHB">Example 8-16</a> using the <a href="oci16rel001.htm#CHDICDCB">OCIAppCtxSet()</a> function.</p>
<div id="LNOCI18193" class="example">
<p class="titleinexample"><a id="BGBCHDHB"></a>Example 8-16 Two Ways to Clear Specific Attribute Information in a Client Namespace</p>
<pre>
(void) OCIAppCtxSet((void *) sesshndl, (void *)"CLIENTCONTEXT", 13,
                    (void *)"responsibility", 14, (void *)0, 0,errhp,
                    OCI_DEFAULT);

(void) OCIAppCtxSet((void *) sesshndl, (void *)"CLIENTCONTEXT", 13
                    (void *)"responsibility", 14, (void *)"", 0,errhp,
                     OCI_DEFAULT);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="LNOCI16579" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1429"></a>
<h3 class="sect2">CLEAR-ALL Operations Between SET Operations</h3>
<p>You can clear all the context information in a specific client namespace, using the <a href="oci16rel001.htm#CHDBCBIA">OCIAppCtxClearAll()</a><code><a id="sthref1430"></a></code> function, and it will also be cleared on the server-side user session, during the next network transport.</p>
<p>If the client application performs a clear-all operation in a namespace after several set operations, then values of all attributes in that namespace that were set before this clear-all operation are cleaned up on the client side and the server side. Only the set operations that were done after the clear-all operation are reflected on the server side. On the client side, the code appears, as shown in <a href="#BGBDGIEA">Example 8-17</a>.</p>
<div id="LNOCI18194" class="example">
<p class="titleinexample"><a id="BGBDGIEA"></a>Example 8-17 Clearing All the Context Information in a Specific Client Namespace</p>
<pre>
err = OCIAppCtxSet((void *) sesshndl,(void *)"CLIENTCONTEXT", 13,
                   (void *)"responsibility", 14,
                   (void *)"manager", 7,errhp, OCI_DEFAULT);
err = OCIAppCtxClearAll((void *) sesshndl, (void *)"CLIENTCONTEXT", 13, errhp,
                        OCI_DEFAULT);
err = OCIAppCtxSet((void *) sesshndl, (void*)"CLIENTCONTEXT",13
                   (void *)"office",6, (void *)"2op123", 5, errhp, OCI_DEFAULT);
</pre></div>
<!-- class="example" -->
<p>The clear-all operation clears any information set by earlier operations in the namespace <code>CLIENTCONTEXT</code>: "responsibility" = "manager" is removed. The information that was set subsequently will not be reflected on the server side.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16580" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1431"></a>
<h3 class="sect2">Network Transport and PL/SQL on Client Namespace</h3>
<p>It is possible that an application could send application context information on an <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call to the server, and also attempt to change the same context information during that call by executing the <code>DBMS_SESSION</code> package.</p>
<p>In general, on the server side, the transported information is processed first and the main call is processed later. This behavior applies to the application context network transports as well.</p>
<p>If they are both writing to the same client namespace and attribute set, then the main call's information overwrites the information set provided by the fast network transport mechanism. If an error occurs in the network transport call, the main call is not executed.</p>
<p>However, an error in the main call does not affect the processing of the network transport call. Once the network transport call is processed, then there is no way to undo it. When the error is reported to the caller (by an OCI function), it is reported as a generic ORA error. Currently, there is no easy way to distinguish an error in the network transport call from an error in the main call. The client should not assume that an error from the main call will undo the round-trip network processing and should implement appropriate exception-handling mechanisms to prevent any inconsistencies.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#CHDBCBIA">"OCIAppCtxClearAll()"</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#CHDICDCB">"OCIAppCtxSet()"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEIIAB"></a>
<div id="LNOCI08100" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1432"></a><a id="sthref1433"></a>Edition-Based Redefinition</h2>
<p>An edition provides a staging area where "editionable" objects changed by an application patch can be installed and executed while the existing application is still available. You can specify an edition other than the database default by setting the attribute <code><a id="sthref1434"></a>OCI_ATTR_EDITION</code> at session initiation time. The application can call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> specifying this attribute name and the edition as the value, as shown in <a href="#BGBHHAFE">Example 8-18</a>.</p>
<div id="LNOCI18195" class="example">
<p class="titleinexample"><a id="BGBHHAFE"></a>Example 8-18 Calling OCIAttrSet() to Set the OCI_ATTR_EDITION Attribute</p>
<pre>
static void workerFunction()
{
  OCISvcCtx *svchp = (OCISvcCtx *) 0;
  OCIAuthInfo *authp = (OCIAuthInfo *)0;
  sword err;
  err =  OCIHandleAlloc((void *) envhp, (void **)&amp;authp,
                        (ub4) OCI_HTYPE_AUTHINFO,
                        (size_t) 0, (void **) 0);
  if (err)
    checkerr(errhp, err);
 
  checkerr(errhp, OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_AUTHINFO,
           (void *) username, (ub4) strlen((char *)username),
           (ub4) OCI_ATTR_USERNAME, errhp));
 
  checkerr(errhp,OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_AUTHINFO,
           (void *) password, (ub4) strlen((char *)password),
           (ub4) OCI_ATTR_PASSWORD, errhp));
 
  (void) OCIAttrSet((void *) authp, (ub4) OCI_HTYPE_SESSION,
                    (void *) "Patch_Bug_12345",
                    (ub4) strlen((char *)"Patch_Bug_12345"),
                    (ub4) OCI_ATTR_EDITION, errhp);
 
  printf(("Create a new session that connects to the specified edition\n");
  if (err = OCISessionGet(envhp, errhp, &amp;svchp, authp,
               (OraText *)connstr, (ub4)strlen((char *)connstr), NULL,
               0, NULL, NULL, NULL, OCI_DEFAULT))
  {
    checkerr(errhp, err);
    exit(1);
  }
 
  checkerr(errhp, OCISessionRelease(svchp, errhp, NULL, (ub4)0, OCI_DEFAULT));
 
  OCIHandleFree((void *)authp, OCI_HTYPE_AUTHINFO);
}
</pre></div>
<!-- class="example" -->
<p>If <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> is not called, the value of the edition name is obtained from the operating system environment variable <code><a id="sthref1435"></a>ORA_EDITION</code>. If that variable is not set, then the value of <code>OCI_ATTR_EDITION</code> is the empty string. If a nonempty value was specified, then the server sets the specified edition for the session, or the session uses the database default edition. The server then checks that the user has the <code>USE</code> privilege on the edition. If not, then the connect fails. If a nonexistent edition name was specified, then an error is returned.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#BAJHBAFA">"OCI_ATTR_EDITION"</a></p>
</li>
<li>
<p><a class="olink ADFNS020" href="../../appdev.112/e41502/adfns_editions.htm#ADFNS020"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for a more complete description of edition-based redefinition</p>
</li>
<li>
<p><a href="oci16rel001.htm#BEIDIJBD">"Restrictions on Attributes Supported for OCI Session Pools"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CHDDCIJG"></a>
<div id="LNOCI08103" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">OCI <a id="sthref1436"></a>Security Enhancements</h2>
<p>The following security enhancements use configured parameters in the <a id="sthref1437"></a><a id="sthref1438"></a><code>init.ora</code> file or the <code><a id="sthref1439"></a>sqlnet.ora</code> file (the latter file is specifically noted for that feature), and are described in more detail in <span class="italic">Oracle Database Security Guide</span>. These initialization parameters apply to all instances of the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DBSEG70785" href="../../network.112/e36292/app_context.htm#DBSEG70785"><span class="italic">Oracle Database Security Guide</span></a>, section about embedding calls in middle-tier applications to get, set, and clear client session IDs</div>
<div id="LNOCI16581" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1440"></a>
<h3 class="sect2">Controlling the Database Version Banner Displayed</h3>
<p>The <a href="oci17msc007.htm#CHDEGCCB">OCIServerVersion()</a> function can be issued before authentication (on a connected server handle after calling <a href="oci16rel001.htm#i558225">OCIServerAttach()</a>) to get the database version. To avoid disclosing the database version string before authentication, set the <code>SEC_RETURN_SERVER_RELEASE_BANNER</code> initialization parameter to <code>NO</code>. For example:</p>
<pre>
SEC_RETURN_SERVER_RELEASE_BANNER = NO
</pre>
<p>This displays the following string for Oracle Database Release 11.1 and all subsequent 11.1 releases and patch sets:</p>
<pre>
Oracle Database 11g Release 11.1.0.0.0 - Production
</pre>
<p>Set <code>SEC_RETURN_SERVER_RELEASE_BANNER</code> to <code>YES</code> and then the current banner is displayed. If you have installed Oracle Database Release 11.2.0.2, the banner displayed is:</p>
<pre>
Oracle Database 11g Enterprise Edition Release 11.2.0.2 - Production
</pre>
<p>This feature works with an Oracle Database Release 11.1 or later server, and any version client.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16582" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1441"></a>
<h3 class="sect2">Banners for Unauthorized Access and User Actions Auditing</h3>
<p>The following systemwide parameters are in <code>sqlnet.ora</code> and warn users against unauthorized access and possible auditing of user actions. These features are available in Oracle Database Release 11.1 and later servers and clients. The content of the banners is in text files that the database administrator creates. There is a 512 byte buffer limit for displaying the banner content. If this buffer limit is exceeded, the banner content will appear to be cut off. The access banner syntax is:</p>
<pre>
SEC_USER_UNAUTHORIZED_ACCESS_BANNER = <span class="italic">file_path1</span>
</pre>
<p>In this syntax, <code><span class="codeinlineitalic">file_path1</span></code> is the path of a text file. To retrieve the banner, get the value of the attribute <a id="sthref1442"></a><code>OCI_ATTR_ACCESS_BANNER</code> from the server handle after calls to either <a href="oci16rel001.htm#i558225">OCIServerAttach()</a> or <a href="oci16rel001.htm#i563311">OCISessionGet()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#CHDBBEEC">"OCI_ATTR_ACCESS_BANNER"</a></div>
<p>The audit banner syntax is:</p>
<pre>
SEC_USER_AUDIT_ACTION_BANNER = <span class="italic">file_path2</span>
</pre>
<p>In this syntax, <code><span class="codeinlineitalic">file_path2</span></code> is the path of a text file. To retrieve the banner, get the value of the attribute <code><a id="sthref1443"></a>OCI_ATTR_AUDIT_BANNER</code> from the session handle after calls to either <a href="oci16rel001.htm#i556608">OCISessionBegin()</a>, <a href="oci16rel001.htm#i563311">OCISessionGet()</a>, <a href="oci16rel001.htm#i556477">OCILogon()</a>, or <a href="oci16rel001.htm#i558312">OCILogon2()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJIFFFE">"OCI_ATTR_AUDIT_BANNER"</a></div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16583" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1444"></a>
<h3 class="sect2">Non-Deferred Linkage</h3>
<p><a id="sthref1445"></a>Non-deferred linkage of applications is no longer supported and the <code>Makefile</code> is modified to remove it. This method of linking was used before OCI V7.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i456377"></a>
<div id="LNOCI16584" class="sect1">
<h2 class="sect1">Overview of OCI Multithreaded Development<a id="sthref1446"></a><a id="sthref1447"></a></h2>
<p>Threads are lightweight processes that exist within a larger process. Threads share the same code and data segments but have their own program counters, system registers, and stacks. Global and static variables are common to all threads, and a mutual exclusion mechanism is required to manage access to these variables from multiple threads within an application.</p>
<p>Once spawned, threads run asynchronously with respect to one another. They can access common data elements and make OCI calls in any order. Because of this shared access to data elements, a synchronized mechanism is required to maintain the integrity of data being accessed.</p>
<p>The mechanism to manage data access takes the form of <span class="italic"><a id="sthref1448"></a><a id="sthref1449"></a>mutexes</span> (mutual exclusion locks). This mechanism is implemented to ensure that no conflicts arise between multiple threads accessing shared internal data that are opaque to users. In OCI, mutexes are granted for each environment handle.</p>
<p><a id="sthref1450"></a>The thread safety feature of Oracle Database and the OCI libraries allows developers to use OCI in a multithreaded environment. Thread safety ensures that code can be reentrant, with multiple threads making OCI calls without side effects.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Thread safety is not available on every operating system. Check your Oracle Database system-specific documentation for more information.
<p><a id="sthref1451"></a>In a multithreaded Linux or UNIX environment, OCI calls except <a href="oci17msc007.htm#i540487">OCIBreak()</a> are not allowed in a user signal handler.</p>
<p>The correct way to use and free handles is to create the handle, use the handle, then free the handle only after all the threads have been destroyed, when the application is terminating.</p>
</div>
<div id="LNOCI16585" class="sect2"><a id="sthref1452"></a>
<h3 class="sect2">Advantages of OCI Thread Safety</h3>
<p><a id="sthref1453"></a>The implementation of thread safety in OCI has the following advantages:</p>
<ul>
<li>
<p>Multiple threads of execution can make OCI calls with the same result as successive calls made by a single thread.</p>
</li>
<li>
<p>When multiple threads make OCI calls, there are no side effects between threads.</p>
</li>
<li>
<p>Users who do not write multithreaded programs do not pay a performance penalty for using thread-safe OCI calls.</p>
</li>
<li>
<p>Use of multiple threads can improve program performance. Gains may be seen on multiprocessor systems where threads run concurrently on separate processors, and on single processor systems where overlap can occur between slower operations and faster operations.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNOCI16586" class="sect2"><a id="sthref1454"></a>
<h3 class="sect2">OCI Thread Safety and Three-Tier Architectures<a id="sthref1455"></a><a id="sthref1456"></a></h3>
<p>In addition to client/server applications, where the client can be a multithreaded program, a typical use of multithreaded applications is in three-tier (client-agent-server) architectures. In this architecture, the client is concerned only with presentation services. The agent (application server) processes the application logic for the client application. Typically, this relationship is a many-to-one relationship, with multiple clients sharing the same application server.</p>
<p>The server tier in this scenario is a database. The application server (agent) is very well suited to being a multithreaded application server, with each thread serving a single client application. In an Oracle Database environment, this application server is an OCI or precompiler program.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFEGIC"></a>
<div id="LNOCI16587" class="sect2">
<h3 class="sect2">Implementing Thread Safety<a id="sthref1457"></a><a id="sthref1458"></a></h3>
<p>To take advantage of thread safety, an application must be running on a thread-safe operating system. The application specifies that it is running in a multithreaded environment by making an <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> call with <a id="sthref1459"></a><code>OCI_THREADED</code> as the value of the <code>mode</code> parameter.</p>
<p>All subsequent calls to <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> must also be made with <code>OCI_THREADED</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Applications running on non-thread-safe operating systems must not pass a value of <code>OCI_THREADED</code> to <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a><span class="italic">.</span></div>
<p>If an application is single-threaded, whether or not the operating system is thread-safe, the application must pass a value of <a id="sthref1460"></a><code>OCI_DEFAULT</code> to <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a>. Single-threaded applications that run in <code>OCI_THREADED</code> mode may incur lower performance.</p>
<p>If a multithreaded application is running on a thread-safe operating system, the OCI library manages mutexes for the application for each environment handle. An application can override this feature and maintain its own mutex scheme by specifying a value of <a id="sthref1461"></a><code>OCI_ENV_NO_MUTEX</code> in the <code>mode</code> parameter of either the <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> calls.</p>
<p>The following scenarios are possible, depending on how many connections exist in each environment handle, and how many threads are spawned in each connection.</p>
<ul>
<li>
<p>If an application has multiple environment handles, with a single thread in each, mutexes are not required.</p>
</li>
<li>
<p>If an application running in <code>OCI_THREADED</code> mode maintains one or more environment handles, with multiple connections, it has these options:</p>
<ul>
<li>
<p>Pass a value of <code>OCI_ENV_NO_MUTEX</code> for the <code>mode</code> of <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a>. The application must set mutual exclusion locks (mutex) for OCI calls made on the same environment handle. This has the advantage that the mutex scheme can be optimized to the application design. The programmer must also ensure that only one OCI call is in process on the environment handle connection at any given time.</p>
</li>
<li>
<p>Pass a value of <code>OCI_DEFAULT</code> for the <code>mode</code> of <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a>. The OCI library automatically gets a mutex on every OCI call on the same environment handle.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Most processing of an OCI call happens on the server, so if two threads using OCI calls go to the same connection, then one of them can be blocked while the other finishes processing at the server.
<p><a id="i470685"></a>Use one error handle for each thread in an application, because OCI errors can be overwritten by other threads.</p>
</div>
</li>
</ul>
</li>
</ul>
<div id="LNOCI18196" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1462"></a>
<h4 class="sect3">Polling Mode Operations and Thread Safety</h4>
<p>OCI supports polling mode operations. When OCI is operating in threaded mode, OCI calls that poll for completion acquire mutexes when the OCI call is actively executing. However, when OCI returns control to the application, OCI releases any acquired mutexes. The caller should ensure that no other OCI call is made on the connection until the polling mode OCI operation in progress completes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#BCFDHCIG">"Polling Mode Operations in OCI"</a></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16588" class="sect3"><a id="sthref1463"></a>
<h4 class="sect3">Mixing 7.x and Later Release OCI Calls<a id="sthref1464"></a></h4>
<p>If an application is mixing later release and 7.x OCI calls, and the application has been initialized as thread-safe (with the appropriate calls of the later release), it is not necessary to call <code>opinit()</code> to achieve thread safety. The application gets 7.x behavior on any subsequent 7.x function calls.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i434459"></a>
<div id="LNOCI16589" class="sect1">
<h2 class="sect1">OCIThread Package<a id="sthref1465"></a><a id="sthref1466"></a></h2>
<p>The <code>OCIThread</code> package provides some commonly used threading primitives. It offers a portable interface to threading capabilities native to various operating systems, but does not implement threading on operating systems that do not have native threading capability.</p>
<p><code>OCIThread</code> does not provide a portable implementation, but it serves as a set of portable covers for native multithreaded facilities. Therefore, operating systems that do not have native support for multithreading are only able to support a limited implementation of the <code>OCIThread</code> package. As a result, products that rely on all of the <code>OCIThread</code> functionality do not port to all operating systems. Products that must be ported to all operating systems must use only a subset of the <code>OCIThread</code> functionality.</p>
<p>The <code>OCIThread</code> API consists of three main parts. Each part is described briefly here. The following subsections describe each in greater detail.</p>
<ul>
<li>
<p><a href="#i435712">Initialization and Termination</a>. These calls deal with the initialization and termination of <code>OCIThread</code> context, which is required for other <code>OCIThread</code> calls.</p>
<p><code>OCIThread</code> only requires that the process initialization function, <a href="oci17msc005.htm#i493062">OCIThreadProcessInit()</a>, is called when <code>OCIThread</code> is being used in a multithreaded application. Failing to call <a href="oci17msc005.htm#i493062">OCIThreadProcessInit()</a> in a single-threaded application is not an error.</p>
<p>Separate calls to <a href="oci17msc005.htm#i492958">OCIThreadInit()</a> all return the same <code>OCIThread</code> context. Each call to <a href="oci17msc005.htm#i492958">OCIThreadInit()</a> must eventually be matched by a call to <a href="oci17msc005.htm#i493066">OCIThreadTerm()</a>.</p>
</li>
<li>
<p><a href="#i435716">Passive Threading Primitives</a>. Passive threading primitives are used to manipulate mutual exclusion locks (mutex), thread IDs, and thread-specific data keys. These primitives are described as passive because although their specifications allow for the existence of multiple threads, they do not require it. It is possible for these primitives to be implemented according to specification in both single-threaded and multithreaded environments. As a result, <code>OCIThread</code> clients that use only these primitives do not require a multiple-thread environment to work correctly. They are able to work in single-threaded environments without branching code.</p>
</li>
<li>
<p><a href="#i435720">Active Threading Primitives</a>. Active threading primitives deal with the creation, termination, and manipulation of threads. These primitives are described as <span class="italic">active</span> because they can only be used in true multithreaded environments. Their specification explicitly requires multiple threads. If you must determine at run time whether you are in a multithreaded environment, call <a href="oci17msc005.htm#i492962">OCIThreadIsMulti()</a> before using an <code>OCIThread</code> active threading primitive.</p>
<p>To write a version of the same application to run on single-threaded operating system, it is necessary to branch your code, whether by branching versions of the source file or by branching at run time with the <a href="oci17msc005.htm#i492962">OCIThreadIsMulti()</a> call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc005.htm#i540465">"Thread Management Functions"</a></p>
</li>
<li>
<p><code>cdemothr.c</code> in the <code>demo</code> directory is an example of a multithreading application</p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i435712"></a>
<div id="LNOCI16590" class="sect2">
<h3 class="sect2">Initialization and Termination</h3>
<p>The types and functions described in this section are associated with the initialization and termination of the <code>OCIThread</code> package. <code>OCIThread</code> must be initialized before you can use any of its functionality.</p>
<p>The observed behavior of the initialization and termination functions is the same regardless of whether <code>OCIThread</code> is in a single-threaded or a multithreaded environment. <a href="#g473609">Table 8-6</a> lists functions for thread initialization and termination.</p>
<div id="LNOCI16591" class="tblformal">
<p class="titleintable"><a id="sthref1467"></a><a id="g473609"></a>Table 8-6 Initialization and Termination Multithreading Functions</p>
<table class="cellalignment1016" title="Initialization and Termination Multithreading Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t30">Function</th>
<th class="cellalignment1012" id="r1c2-t30">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t30" headers="r1c1-t30">
<p><a href="oci17msc005.htm#i493062">OCIThreadProcessInit()</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t30 r1c2-t30">
<p>Performs OCIThread process initialization</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t30" headers="r1c1-t30">
<p><code><a href="oci17msc005.htm#i492958">OCIThreadInit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t30 r1c2-t30">
<p>Initializes OCIThread context</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t30" headers="r1c1-t30">
<p><code><a href="oci17msc005.htm#i493066">OCIThreadTerm()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t30 r1c2-t30">
<p>Terminates the OCIThread layer and frees context memory</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t30" headers="r1c1-t30">
<p><code><a href="oci17msc005.htm#i492962">OCIThreadIsMulti()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t30 r1c2-t30">
<p>Tells the caller whether the application is running in a multithreaded environment or a single-threaded environment</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc005.htm#i540465">"Thread Management Functions"</a></div>
<div id="LNOCI16592" class="sect3"><a id="sthref1468"></a>
<h4 class="sect3">OCIThread Context</h4>
<p>Most calls to <code>OCIThread</code> functions use the OCI environment or user session handle as a parameter. The <code>OCIThread</code> context is part of the OCI environment or user session handle, and it must be initialized by calling <a href="oci17msc005.htm#i492958">OCIThreadInit()</a>. Termination of the <code>OCIThread</code> context occurs by calling <a href="oci17msc005.htm#i493066">OCIThreadTerm()</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>OCIThread</code> context is an opaque data structure. Do not attempt to examine the contents of the context.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i435716"></a>
<div id="LNOCI16593" class="sect2">
<h3 class="sect2">Passive Threading Primitives</h3>
<p>The passive threading primitives deal with the manipulation of mutex, thread IDs, and thread-specific data. Because the specifications of these primitives do not require the existence of multiple threads, they can be used both in multithreaded and single-threaded operating systems. <a href="#g473537">Table 8-7</a> lists functions used to implement passive threading.</p>
<div id="LNOCI16594" class="tblformal">
<p class="titleintable"><a id="sthref1469"></a><a id="g473537"></a>Table 8-7 Passive Threading Primitives</p>
<table class="cellalignment1016" title="Passive Threading Primitives " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t33">Function</th>
<th class="cellalignment1012" id="r1c2-t33">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i493054">OCIThreadMutexInit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t33 r1c2-t33">
<p>Allocates and initializes a mutex</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i493050">OCIThreadMutexDestroy()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t33 r1c2-t33">
<p>Destroys and deallocates a mutex</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492986">OCIThreadMutexAcquire()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t33 r1c2-t33">
<p>Acquires a mutex for the thread in which it is called</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i493058">OCIThreadMutexRelease()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t33 r1c2-t33">
<p>Releases a mutex</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492978">OCIThreadKeyInit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t33 r1c2-t33">
<p>Allocates and generates a new key</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492970">OCIThreadKeyDestroy()</a></code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t33 r1c2-t33">
<p>Destroys and deallocates a key</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492974">OCIThreadKeyGet()</a></code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t33 r1c2-t33">
<p>Gets the calling thread's current value for a key</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492982">OCIThreadKeySet()</a></code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t33 r1c2-t33">
<p>Sets the calling thread's value for a key</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492938">OCIThreadIdInit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r10c1-t33 r1c2-t33">
<p>Allocates and initializes a thread ID</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492930">OCIThreadIdDestroy()</a></code></p>
</td>
<td class="cellalignment1013" headers="r11c1-t33 r1c2-t33">
<p>Destroys and deallocates a thread ID</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492950">OCIThreadIdSet()</a></code></p>
</td>
<td class="cellalignment1013" headers="r12c1-t33 r1c2-t33">
<p>Sets one thread ID to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492954">OCIThreadIdSetNull()</a></code></p>
</td>
<td class="cellalignment1013" headers="r13c1-t33 r1c2-t33">
<p>Nulls a thread ID</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492934">OCIThreadIdGet()</a></code></p>
</td>
<td class="cellalignment1013" headers="r14c1-t33 r1c2-t33">
<p>Retrieves a thread ID for the thread in which it is called</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492946">OCIThreadIdSame()</a></code></p>
</td>
<td class="cellalignment1013" headers="r15c1-t33 r1c2-t33">
<p>Determines if two thread IDs represent the same thread</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t33" headers="r1c1-t33">
<p><code><a href="oci17msc005.htm#i492942">OCIThreadIdNull()</a></code></p>
</td>
<td class="cellalignment1013" headers="r16c1-t33 r1c2-t33">
<p>Determines if a thread ID is <code>NULL</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="LNOCI16595" class="sect3"><a id="sthref1470"></a>
<h4 class="sect3">OCIThreadMutex</h4>
<p>The <code>OCIThreadMutex</code> data type is used to represent a mutex. This mutex is used to ensure that either:</p>
<ul>
<li>
<p>Only one thread accesses a given set of data at a time</p>
</li>
<li>
<p>Only one thread executes a given critical section of code at a time</p>
</li>
</ul>
<p>Mutex pointers can be declared as parts of client structures or as standalone variables. Before they can be used, they must be initialized using <a href="oci17msc005.htm#i493054">OCIThreadMutexInit()</a>. Once they are no longer needed, they must be destroyed using <a href="oci17msc005.htm#i493050">OCIThreadMutexDestroy()</a>.</p>
<p>A thread can acquire a mutex by using <a href="oci17msc005.htm#i492986">OCIThreadMutexAcquire()</a>. This ensures that only one thread at a time is allowed to hold a given mutex. A thread that holds a mutex can release it by calling <a href="oci17msc005.htm#i493058">OCIThreadMutexRelease()</a>.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16596" class="sect3"><a id="sthref1471"></a>
<h4 class="sect3">OCIThreadKey</h4>
<p>The data type <code>OCIThreadKey</code> can be thought of as a process-wide variable with a thread-specific value. Thus all threads in a process can use a given key, but each thread can examine or modify that key independently of the other threads. The value that a thread sees when it examines the key is always the same as the value that it last set for the key. It does not see any values set for the key by other threads. The data type of the value held by a key is a <code>void *</code> generic pointer.</p>
<p>Keys can be created using <a href="oci17msc005.htm#i492978">OCIThreadKeyInit()</a>. Key value are initialized to <code>NULL</code> for all threads.</p>
<p>A thread can set a key's value using <a href="oci17msc005.htm#i492982">OCIThreadKeySet()</a>. A thread can get a key's value using <a href="oci17msc005.htm#i492974">OCIThreadKeyGet()</a>.</p>
<p>The <code>OCIThread</code> key functions save and retrieve data specific to the thread. When clients maintain a pool of threads and assign them to different tasks, it may not be appropriate for a task to use <code>OCIThread</code> key functions to save data associated with it.</p>
<p>Here is a scenario of how things can fail: A thread is assigned to execute the initialization of a task. During initialization, the task stores data in the thread using <code>OCIThread</code> key functions. After initialization, the thread is returned to the threads pool. Later, the threads pool manager assigns another thread to perform some operations on the task, and the task must retrieve the data it stored earlier in initialization. Because the task is running in another thread, it is not able to retrieve the same data. Application developers that use thread pools must be aware of this.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16597" class="sect3"><a id="sthref1472"></a>
<h4 class="sect3">OCIThreadKeyDestFunc</h4>
<p><code>OCIThreadKeyDestFunc</code> is the type of a pointer to a key's destructor routine. Keys can be associated with a destructor routine when they are created using <a href="oci17msc005.htm#i492978">OCIThreadKeyInit()</a>. A key's destructor routine is called whenever a thread with a non-<code>NULL</code> value for the key terminates. The destructor routine returns nothing and takes one parameter, the value that was set for key when the thread terminated.</p>
<p>The destructor routine is guaranteed to be called on a thread's value in the key after the termination of the thread and before process termination. No more precise guarantee can be made about the timing of the destructor routine call; no code in the process may assume any post-condition of the destructor routine. In particular, the destructor is not guaranteed to execute before a join call on the terminated thread returns.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16598" class="sect3"><a id="sthref1473"></a>
<h4 class="sect3">OCIThreadId</h4>
<p><code>OCIThreadId</code> data type is used to identify a thread. At any given time, no two threads can have the same <code>OCIThreadId</code>, but <code>OCIThreadId</code> values can be recycled; after a thread dies, a new thread may be created that has the same <code>OCIThreadId</code> value. In particular, the thread ID must uniquely identify a thread <code>T</code> within a process, and it must be consistent and valid in all threads <code>U</code> of the process for which it can be guaranteed that <code>T</code> is running concurrently with <code>U</code>. The thread ID for a thread <code>T</code> must be retrievable within thread <code>T</code>. This is done using <a href="oci17msc005.htm#i492934">OCIThreadIdGet()</a>.</p>
<p>The <code>OCIThreadId</code> type supports the concept of a <code>NULL</code> thread ID: the <code>NULL</code> thread ID can never be the same as the ID of an actual thread.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i435720"></a>
<div id="LNOCI16599" class="sect2">
<h3 class="sect2">Active Threading Primitives</h3>
<p>The active threading primitives deal with manipulation of actual threads. Because specifications of most of these primitives require multiple threads, they work correctly only in the enabled <code>OCIThread</code>. In the disabled <code>OCIThread</code>, they always return an error. The exception is <a href="oci17msc005.htm#i492918">OCIThreadHandleGet()</a>; it may be called in a single-threaded environment and has no effect.</p>
<p>Active primitives can only be called by code running in a multithreaded environment. You can call <a href="oci17msc005.htm#i492962">OCIThreadIsMulti()</a> to determine whether the environment is multithreaded or single-threaded. <a href="#g473467">Table 8-8</a> lists functions used to implement active threading.</p>
<div id="LNOCI16600" class="tblformal">
<p class="titleintable"><a id="sthref1474"></a><a id="g473467"></a>Table 8-8 Active Threading Primitives</p>
<table class="cellalignment1016" title="Active Threading Primitives " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t34">Function</th>
<th class="cellalignment1012" id="r1c2-t34">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t34" headers="r1c1-t34">
<p><code><a href="oci17msc005.htm#i492926">OCIThreadHndInit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t34 r1c2-t34">
<p>Allocates and initializes a thread handle</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t34" headers="r1c1-t34">
<p><code><a href="oci17msc005.htm#i492922">OCIThreadHndDestroy()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t34 r1c2-t34">
<p>Destroys and deallocates a thread handle</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t34" headers="r1c1-t34">
<p><code><a href="oci17msc005.htm#i492914">OCIThreadCreate()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t34 r1c2-t34">
<p>Creates a new thread</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t34" headers="r1c1-t34">
<p><code><a href="oci17msc005.htm#i492966">OCIThreadJoin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t34 r1c2-t34">
<p>Allows the calling thread to join with another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t34" headers="r1c1-t34">
<p><code><a href="oci17msc005.htm#i532971">OCIThreadClose()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t34 r1c2-t34">
<p>Closes a thread handle</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t34" headers="r1c1-t34">
<p><code><a href="oci17msc005.htm#i492918">OCIThreadHandleGet()</a></code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t34 r1c2-t34">
<p>Retrieves a thread handle</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="LNOCI16601" class="sect3"><a id="sthref1475"></a>
<h4 class="sect3">OCIThreadHandle</h4>
<p>Data type <code>OCIThreadHandle</code> is used<a id="sthref1476"></a> to manipulate a thread in the active primitives, <a href="oci17msc005.htm#i492966">OCIThreadJoin()</a> and <a href="oci17msc005.htm#i532971">OCIThreadClose()</a>. A thread handle opened by <a href="oci17msc005.htm#i492914">OCIThreadCreate()</a> must be closed in a matching call to <a href="oci17msc005.htm#i532971">OCIThreadClose()</a>. A thread handle is invalid after the call to <a href="oci17msc005.htm#i532971">OCIThreadClose()</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci07lob.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci09adv.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
