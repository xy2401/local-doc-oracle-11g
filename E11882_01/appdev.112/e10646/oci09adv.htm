<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>OCI Programming Advanced Topics</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:23Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci08sca.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci10new.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/79</span> <!-- End Header -->
<div id="LNOCI090" class="chapter"><a id="g489977"></a> <a id="i441210"></a>
<h1 class="chapter"><span class="secnum">9</span> OCI Programming Advanced Topics</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i452584">Connection Pooling in OCI</a></p>
</li>
<li>
<p><a href="#i465498">Session Pooling in OCI</a></p>
</li>
<li>
<p><a href="#CHDBIBBF">Database Resident Connection Pooling</a></p>
</li>
<li>
<p><a href="#i471769">When to Use Connection Pooling, Session Pooling, or Neither</a></p>
</li>
<li>
<p><a href="#i471377">Statement Caching in OCI</a></p>
</li>
<li>
<p><a href="#i466264">User-Defined Callback Functions in OCI</a></p>
</li>
<li>
<p><a href="#i449791">Transparent Application Failover in OCI</a></p>
</li>
<li>
<p><a href="#CJGDCEFG">HA Event Notification</a></p>
</li>
<li>
<p><a href="#i467582">OCI and Streams Advanced Queuing</a></p>
</li>
<li>
<p><a href="#i435757">Publish-Subscribe Notification in OCI</a></p>
</li>
</ul>
<a id="i452584"></a>
<div id="LNOCI16602" class="sect1">
<h2 class="sect1"><a id="sthref1477"></a>Connection Pooling in OCI</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACFJJEF">OCI Connection Pooling Concepts</a></p>
</li>
<li>
<p><a href="#CACFGDFC">OCI Calls for Connection Pooling</a></p>
</li>
<li>
<p><a href="#CACJHGAF">Examples of OCI Connection Pooling</a></p>
</li>
</ul>
<p>Connection pooling is the use of a group (the pool) of reusable physical connections by several sessions to balance loads. The pool is managed by OCI, not the application. Applications that can use connection pooling include middle-tier applications for web application servers and email servers.</p>
<p>One use of this feature is in a web application server connected to a back-end Oracle database. Suppose that a web application server gets several concurrent requests for data from the database server. The application can create a pool (or a set of pools) in each environment during application initialization.</p>
<a id="CACFJJEF"></a>
<div id="LNOCI16603" class="sect2">
<h3 class="sect2">OCI Connection Pooling Concepts</h3>
<p>Oracle Database has several transaction monitoring capabilities such as the fine-grained management of database sessions and connections. Fine-grained management of database sessions is done by separating the notion of database sessions (user handles) from connections (server handles). By using OCI calls for session switching and session migration, an application server or transaction monitor can multiplex several sessions over fewer physical connections, thus achieving a high degree of scalability by pooling connections and back-end Oracle server processes.</p>
<p>The connection pool itself is normally configured with a shared pool of physical connections, translating to a back-end server pool containing an identical number of dedicated server processes.</p>
<p>The number of physical connections is less than the number of database sessions in use by the application. The number of physical connections and back-end server processes are also reduced by using connection pooling. Thus many more database sessions can be multiplexed.</p>
<div id="LNOCI16604" class="sect3"><a id="sthref1478"></a>
<h4 class="sect3">Similarities and Differences from a Shared Server</h4>
<p>Connection pooling on the middletier is similar to what a shared server offers on the back end. Connection pooling makes a dedicated server instance behave like a shared server instance by managing the session multiplexing logic on the middle tier.</p>
<p>The connection pool on the middle tier controls the pooling of dedicated server processes including incoming connections into the dedicated server processes. The main difference between connection pooling and a shared server is that in the latter case, the connection from the client is normally to a dispatcher in the database instance. The dispatcher is responsible for directing the client request to an appropriate shared server. However, the physical connection from the connection pool is established directly from the middletier to the dedicated server process in the back-end server pool.</p>
<p>Connection pooling is beneficial only if the middle tier is multithreaded. Each thread can maintain a session to the database. The actual connections to the database are maintained by the connection pool, and these connections (including the pool of dedicated database server processes) are shared among all the threads in the middle tier.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16605" class="sect3"><a id="sthref1479"></a>
<h4 class="sect3"><a id="sthref1480"></a><a id="sthref1481"></a>Stateless Sessions Versus Stateful Sessions</h4>
<p>Stateless sessions are serially reusable across mid-tier threads. After a thread is done processing a database request on behalf of a three-tier user, the same database session can be reused for a completely different request on behalf of a completely different three-tier user.</p>
<p>Stateful sessions to the database, however, are not serially reusable across mid-tier threads because they may have some particular state associated with a particular three-tier user. Examples of such state may include open transactions, the fetch state from a statement, or a PL/SQL package state. So long as the state exists, the session is not reusable for a different request.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Stateless sessions too may have open transactions, open statement fetch state, and so on. However, such a state persists for a relatively short duration (only during the processing of a particular three-tier request by a mid-tier thread) that allows the session to be serially reused for a different three-tier user (when such state is cleaned up).
<p>Stateless sessions are typically used in conjunction with statement caching.</p>
</div>
<p>What connection pooling offers is stateless connections and stateful sessions. If you must work with stateless sessions, see <a href="#i465498">"Session Pooling in OCI"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16606" class="sect3"><a id="sthref1482"></a>
<h4 class="sect3">Multiple Connection Pools</h4>
<p>You can use the advanced concept of multiple connection pools for different database connections. Multiple connection pools can also be used when different priorities are assigned to users. Different service-level guarantees can be implemented using connection pooling.</p>
<p><a href="#CHDHJEDC">Figure 9-1</a> illustrates OCI connection pooling.</p>
<div id="LNOCI16607" class="figure">
<p class="titleinfigure"><a id="CHDHJEDC"></a>Figure 9-1 OCI Connection Pooling</p>
<img width="514" height="290" src="img/lnoci043.gif" alt="Description of Figure 9-1 follows" /><br />
<a id="sthref1483" href="img_text/lnoci043.htm">Description of "Figure 9-1 OCI Connection Pooling"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="CHDIIAJD"></a>
<div id="LNOCI16608" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref1484"></a><a id="sthref1485"></a>Transparent Application Failover</h4>
<p>Transaction application failover (TAF) is enabled for connection pooling. The concepts of TAF apply equally well with connections in the connection pool except that the <code>BACKUP</code> and <code>PRECONNECT</code> clauses should not be used in the connect string and do not work with connection pooling and TAF.</p>
<p>When a connection in the connection pool fails over, it uses the primary connect string itself to connect. Sessions fail over when they use the pool for a database round-trip after their instance failure. The listener is configured to route the connection to a good instance if available, as is typical with service-based connect strings.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NETAG0131" href="../../network.112/e41945/advcfg.htm#NETAG0131"><span class="italic">Oracle Database Net Services Administrator's Guide</span></a>, the chapter about configuring transparent application failover</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACFGDFC"></a>
<div id="LNOCI091" class="sect2">
<h3 class="sect2">OCI Calls for Connection Pooling</h3>
<p>To use connection pooling in your application, you must:</p>
<ol>
<li>
<p><a href="#i470594">Allocate the Pool Handle</a></p>
</li>
<li>
<p><a href="#i470602">Create the Connection Pool</a></p>
</li>
<li>
<p><a href="#i470604">Log On to the Database</a></p>
</li>
<li>
<p><a href="#i470609">Deal with SGA Limitations in Connection Pooling</a></p>
</li>
<li>
<p><a href="#i470614">Log Off from the Database</a></p>
</li>
<li>
<p><a href="#i470619">Destroy the Connection Pool</a></p>
</li>
<li>
<p><a href="#i470624">Free the Pool Handle</a></p>
</li>
</ol>
<a id="i470594"></a>
<div id="LNOCI16609" class="sect3">
<h4 class="sect3">Allocate the Pool Handle</h4>
<p>Connection pooling requires that the pool handle <a id="sthref1486"></a><code>OCI_HTYPE_CPOOL</code> be allocated by <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. Multiple pools can be created for a given environment handle.</p>
<p>For a single connection pool, here is an allocation example:</p>
<pre>
OCICPool *poolhp;
OCIHandleAlloc((void *) envhp, (void **) &amp;poolhp, OCI_HTYPE_CPOOL, 
                      (size_t) 0, (void **) 0));
</pre></div>
<!-- class="sect3" -->
<a id="i470602"></a>
<div id="LNOCI16610" class="sect3">
<h4 class="sect3">Create the Connection Pool</h4>
<p>The function <a href="oci16rel001.htm#i556060">OCIConnectionPoolCreate()</a> <a id="sthref1487"></a>initializes the <a id="sthref1488"></a><a id="sthref1489"></a>connection pool handle. It has these <code>IN</code> parameters:</p>
<ul>
<li>
<p><code>connMin</code>, the minimum number of connections to be opened when the pool is created.</p>
</li>
<li>
<p><code>connIncr</code>, the incremental number of connections to be opened when all the connections are busy and a call needs a connection. This increment is used only when the total number of open connections is less than the maximum number of connections that can be opened in that pool.</p>
</li>
<li>
<p><code>connMax</code>, the maximum number of connections that can be opened in the pool. When the maximum number of connections are open in the pool, and all the connections are busy, if a call needs a connection, it waits until it gets one. However, if the <code>OCI_ATTR_CONN_NOWAIT</code> attribute is set for the pool, an error is returned.</p>
</li>
<li>
<p>A <code>poolUsername</code> and a <code>poolPassword</code>, to allow user sessions to transparently migrate between connections in the pool.</p>
</li>
<li>
<p>In addition, an attribute <code><a id="sthref1490"></a></code><a href="ociaahan.htm#CACFEFEB">OCI_ATTR_CONN_TIMEOUT</a>, can be set to time out the connections in the pool. Connections idle for more than this time are terminated periodically to maintain an optimum number of open connections. If this attribute is not set, then the connections are never timed out.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Shrinkage of the pool only occurs when there is a network round-trip. If there are no operations, then the connections stay active.</div>
<p>Because all the preceding attributes can be configured dynamically, the application can read the current load (number of open connections and number of busy connections) and tune these attributes appropriately.</p>
<p>If the pool attributes (<code>connMax</code>, <code>connMin</code><span class="italic">,</span> <code>connIncr</code>) are to be changed dynamically, <a href="oci16rel001.htm#i556060">OCIConnectionPoolCreate()</a> must be called with <code>mode</code> set to <code>OCI_CPOOL_REINITIALIZE</code>.</p>
<p>The OUT parameters <code>poolName</code> and <code>poolNameLen</code> contain values to be used in subsequent <a href="oci16rel001.htm#i558225">OCIServerAttach()</a> and <a href="oci16rel001.htm#i558312">OCILogon2()</a> calls in place of the database name and the database name length arguments.</p>
<p>There is no limit on the number of pools that can be created by an application. Middle-tier applications can create multiple pools to connect to the same server or to different servers, to balance the load based on the specific needs of the application.</p>
<p>Here is an example of this call:</p>
<pre>
OCIConnectionPoolCreate((OCIEnv *)envhp,
                   (OCIError *)errhp, (OCICPool *)poolhp,
                   &amp;poolName, &amp;poolNameLen,
                   (text *)database,strlen(database),
                   (ub4) connMin, (ub4) connMax, (ub4) connIncr,
                   (text *)poolUsername,strlen(poolUserLen),
                   (text *)poolPassword,strlen(poolPassLen),
                   OCI_DEFAULT));
</pre></div>
<!-- class="sect3" -->
<a id="i470604"></a>
<div id="LNOCI16611" class="sect3">
<h4 class="sect3">Log On to the Database</h4>
<p>The application must log on to the database for each thread, using one of the following interfaces.</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i558312">OCILogon2()</a></p>
<p>This is the simplest interface. Use this interface when you need a simple connection pool connection and do not need to alter any attributes of the session handle. This interface can also be used to make proxy connections to the database.</p>
<p>Here is an example using <code>OCILogon2()</code>:</p>
<pre>
for (i = 0; i &lt; MAXTHREADS; ++i) 
{ 
   OCILogon2(envhp, errhp, &amp;svchp[i], "hr", 2, "hr", 2, poolName,
             poolNameLen, OCI_LOGON2_CPOOL));

}
</pre>
<p>To use this interface to get a proxy connection, set the password parameter to <code>NULL</code>.</p>
</li>
<li>
<p><a href="oci16rel001.htm#i563311">OCISessionGet()</a></p>
<p>This is the recommended interface. It gives the user the additional option of using external authentication methods, such as certificates, distinguished name, and so on. <code>OCISessionGet()</code> is the recommended uniform function call to retrieve a session.</p>
<p>Here is an example using <code>OCISessionGet()</code>:</p>
<pre>
for (i = 0; i &lt; MAXTHREADS; ++i) 
{ 
        OCISessionGet(envhp, errhp, &amp;svchp, authp,
                      (OraText *) poolName,
                      strlen(poolName), NULL, 0, NULL, NULL, NULL,
                      OCI_SESSGET_CPOOL)
 }
</pre></li>
<li>
<p><a href="oci16rel001.htm#i558225">OCIServerAttach()</a> and <a href="oci16rel001.htm#i556608">OCISessionBegin()</a></p>
<p>You can use another interface if the application must set any special attributes on the user session handle and server handle. For such a requirement, applications must allocate all the handles (connection pool handle, server handles, session handles, and service context handles). You would follow this sequence:</p>
<ol>
<li>
<p>Create the connection pool.</p>
<p>Connection pooling does the multiplexing of a virtual server handle over physical connections transparently, eliminating the need for users to do so. The user gets the feeling of a session having a dedicated (virtual) connection. Because the multiplexing is done transparently to the user, users must not attempt to multiplex sessions over the virtual server handles themselves. The concepts of session migration and session switching, which require explicit multiplexing at the user level, are defunct for connection pooling and should not be used.</p>
</li>
<li>
<p>Call <a href="oci16rel001.htm#i558225">OCIServerAttach()</a> with mode set to <code>OCI_CPOOL</code>.</p>
<p>In an OCI program, the user should create (<code>OCIServerAttach()</code> with mode set to <code>OCI_CPOOL</code>), a unique virtual server handle for each session that is created using the connection pool. There should be a one-to-one mapping between virtual server handles and sessions.</p>
</li>
<li>
<p>Call <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> with mode set to <code>OCI_DEFAULT</code>.</p>
<p>Credentials can be set to <code>OCI_CRED_RDBMS</code>, <code>OCI_CRED_EXT</code>, or <code>OCI_CRED_PROXY</code> using <code>OCISessionBegin()</code>. If the credentials are set to <code>OCI_CRED_EXT</code>, no user name and no password need to be set on the session handle. If the credentials are set to <code>OCI_CRED_PROXY</code>, only the user name must be set on the session handle. (no explicit primary session must be created and <code>OCI_ATTR_MIGSESSION</code> need not be set).</p>
<p>The user should not set <code>OCI_MIGRATE</code> flag in the call to <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> when the virtual server handle points to a connection pool (<a href="oci16rel001.htm#i558225">OCIServerAttach()</a> called with <code>mode</code> set to <code>OCI_CPOOL</code>). Oracle supports passing the <code>OCI_MIGRATE</code> flag only for compatibility reasons. Do not use the <code>OCI_MIGRATE</code> flag, because the perception that the user gets when using a connection pool is of sessions having their own dedicated (virtual) connections that are transparently multiplexed onto real connections.</p>
</li>
</ol>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i470609"></a>
<div id="LNOCI16612" class="sect3">
<h4 class="sect3">Deal with SGA Limitations in Connection Pooling</h4>
<p>With <code>OCI_CPOOL</code> mode (connection pooling), the session memory (UGA) in the back-end database comes out of the SGA. This may require some SGA tuning on the back-end database to have a larger SGA if your application consumes more session memory than the SGA can accommodate. The memory tuning requirements for the back-end database are similar to configuring the LARGE POOL in a shared server back end except that the instance is still in dedicated mode.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF021" href="../../server.112/e41573/build_db.htm#PFGRF021"><span class="italic">Oracle Database Performance Tuning Guide</span></a>, the section about configuring a shared server</div>
<p>If you are still running into the SGA limitation, you must consider:</p>
<ul>
<li>
<p>Reducing the session memory consumption by having fewer open statements for each session</p>
</li>
<li>
<p>Reducing the number of sessions in the back end by pooling sessions on the mid-tier</p>
</li>
<li>
<p>Or otherwise, turning off connection pooling</p>
</li>
</ul>
<p>The application must avoid using dedicated database links on the back end with connection pooling.</p>
<p>If the back end is a dedicated server, effective connection pooling is not possible because sessions using dedicated database links are tied to a physical connection rendering that same connection unusable by other sessions. If your application uses dedicated database links and you do not see effective sharing of back-end processes among your sessions, you must consider using shared database links.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Oracle Database Administrator's Guide, the section on shared database links for more information about distributed databases</div>
</div>
<!-- class="sect3" -->
<a id="i470614"></a>
<div id="LNOCI16613" class="sect3">
<h4 class="sect3">Log Off from the Database</h4>
<p>From the following calls, choose the one that corresponds to the logon call and use it to log off from the database in connection pooling mode.</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i556437">OCILogoff()</a>:</p>
<p>If <a href="oci16rel001.htm#i558312">OCILogon2()</a> was used to make the connection, <code>OCILogoff()</code> must be used to log off.</p>
</li>
<li>
<p><a href="oci16rel001.htm#i563322">OCISessionRelease()</a></p>
<p>If <a href="oci16rel001.htm#i563311">OCISessionGet()</a> was called to make the connection, then <code>OCISessionRelease()</code> must be called to log off.</p>
</li>
<li>
<p><a href="oci16rel001.htm#i556679">OCISessionEnd()</a> and <a href="oci16rel001.htm#i556585">OCIServerDetach()</a></p>
<p>If <a href="oci16rel001.htm#i558225">OCIServerAttach()</a> and <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> were called to make the connection and start the session, then <code>OCISessionEnd()</code> must be called to end the session and <code>OCIServerDetach()</code> must be called to release the connection.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i470619"></a>
<div id="LNOCI16614" class="sect3">
<h4 class="sect3">Destroy the Connection Pool</h4>
<p>Use <a href="oci16rel001.htm#i556129">OCIConnectionPoolDestroy()</a> to destroy the connection pool.</p>
</div>
<!-- class="sect3" -->
<a id="i470624"></a>
<div id="LNOCI16615" class="sect3">
<h4 class="sect3">Free the Pool Handle</h4>
<p>The pool handle is freed using <a href="oci16rel002.htm#i540911">OCIHandleFree()</a>.</p>
<p>These last three actions are illustrated in this code fragment:</p>
<pre>
 for (i = 0; i &lt; MAXTHREADS; ++i)
  {
    checkerr(errhp, OCILogoff((void *) svchp[i], errhp));
  }
  checkerr(errhp, OCIConnectionPoolDestroy(poolhp, errhp, OCI_DEFAULT));
  checkerr(errhp, OCIHandleFree((void *)poolhp, OCI_HTYPE_CPOOL));
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#i450511">"Connection Pool Handle Attributes"</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#i556060">"OCIConnectionPoolCreate()"</a>, <a href="oci16rel001.htm#i558312">"OCILogon2()"</a>, and <a href="oci16rel001.htm#i556129">"OCIConnectionPoolDestroy()"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACJHGAF"></a>
<div id="LNOCI16616" class="sect2">
<h3 class="sect2">E<a id="sthref1491"></a>xamples of OCI Connection Pooling</h3>
<p>Examples of connection pooling in tested complete programs can be found in c<code>democp.c and cdemocpproxy.c</code> in directory <code>demo</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i465498"></a>
<div id="LNOCI16617" class="sect1">
<h2 class="sect1"><a id="sthref1492"></a>Session Pooling in OCI</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACFHCJA">Functionality of OCI Session Pooling</a></p>
</li>
<li>
<p><a href="#CACIJFBF">Homogeneous and Heterogeneous Session Pools</a></p>
</li>
<li>
<p><a href="#i465805">Using Tags in Session Pools</a></p>
</li>
<li>
<p><a href="#CACDHBCD">OCI Handles for Session Pooling</a></p>
</li>
<li>
<p><a href="#CACHIIIE">Using OCI Session Pooling</a></p>
</li>
<li>
<p><a href="#CACCCIJB">OCI Calls for Session Pooling</a></p>
</li>
<li>
<p><a href="#CACBIJJC">Example of OCI Session Pooling</a></p>
</li>
<li>
<p><a href="#CHDDJHGH">Runtime Connection Load Balancing</a></p>
</li>
</ul>
<p><span class="italic">Session pooling</span> means that the application creates and maintains a group of stateless sessions to the database. These sessions are provided to thin clients as requested. If no sessions are available, a new one may be created. When the client is done with the session, the client releases it to the pool. Thus, the number of sessions in the pool can increase dynamically.</p>
<p><a id="sthref1493"></a><a id="sthref1494"></a>Some of the sessions in the pool may be tagged with certain properties. For instance, a user may request a default session, set certain attributes on it, label it or tag it, and return it to the pool. That user, or some other user, can require a session with the same attributes, and thus request a session with the same tag. There may be several sessions in the pool with the same tag. The tag on a session can be changed or reset.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i465805">"Using Tags in Session Pools"</a></div>
<p>Proxy sessions, too, can be created and maintained through session pooling in OCI.</p>
<p>The behavior of the application when no free sessions are available and the pool has reached its maximum size depends on certain attributes. A new session may be created or an error returned, or the thread may just block and wait for a session to become free.</p>
<p>The main benefit of session pooling is performance. Making a connection to the database is a time-consuming activity, especially when the database is remote. Thus, instead of a client spending time connecting to the server, authenticating its credentials, and then receiving a valid session, it can just pick one from the pool.</p>
<a id="CACFHCJA"></a>
<div id="LNOCI16618" class="sect2">
<h3 class="sect2">F<a id="sthref1495"></a>unctionality of OCI Session Pooling</h3>
<p>Session pooling can perform the following tasks:</p>
<ul>
<li>
<p>Create, maintain, and manage a pool of stateless sessions transparently.</p>
</li>
<li>
<p>Provide an interface for the application to create a pool and specify the minimum, increment, and maximum number of sessions in the pool.</p>
</li>
<li>
<p>Provide an interface for the user to obtain and release a default or tagged session to the pool. A tagged session is one with certain client-defined properties.</p>
</li>
<li>
<p>Allow the application to dynamically change the number of minimum and maximum number of sessions.</p>
</li>
<li>
<p>Provide a mechanism to always maintain an optimum number of open sessions, by closing sessions that have been idle for a very long time, and creating sessions when required.</p>
</li>
<li>
<p>Allow for session pooling with authentication.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACIJFBF"></a>
<div id="LNOCI16619" class="sect2">
<h3 class="sect2">Homogeneous and Heterogeneous Session Pools</h3>
<p>A session pool can be either homogeneous or heterogeneous. <span class="italic">Homogeneous</span> session pooling means that sessions in the pool are alike for authentication (they have the same user name, password, and privileges). <span class="italic">Heterogeneous</span> session pooling means that you must provide authentication information because the sessions can have different security attributes and privileges.</p>
</div>
<!-- class="sect2" -->
<a id="i465805"></a>
<div id="LNOCI16620" class="sect2">
<h3 class="sect2">Using Tags in Session Pools</h3>
<p>The tags provide a way for users to customize sessions in the pool. A client can get a default or untagged session from a pool, set certain attributes on the session (such as NLS settings), and return the session to the pool, labeling it with an appropriate tag in the <a href="oci16rel001.htm#i563322">OCISessionRelease()</a> call.</p>
<p>The user, or some other user, can request a session with the same tags to have a session with the same attributes, and can do so by providing the same tag in the <a href="oci16rel001.htm#i563311">OCISessionGet()</a> call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci16rel001.htm#i563311">"OCISessionGet()"</a> for a further discussion of tagging sessions</div>
</div>
<!-- class="sect2" -->
<a id="CACDHBCD"></a>
<div id="LNOCI16621" class="sect2">
<h3 class="sect2">OCI Handles for Session Pooling</h3>
<p>The following handle types are for session pooling.</p>
<a id="i465713"></a>
<div id="LNOCI16622" class="sect3">
<h4 class="sect3">OCISPool</h4>
<p>This is the session pool handle. It is allocated using <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. It must be passed to <a href="oci16rel001.htm#i563356">OCISessionPoolCreate()</a> and <a href="oci16rel001.htm#i561765">OCISessionPoolDestroy()</a>. It has the attribute type <code>OCI_HTYPE_SPOOL</code>.</p>
<p>An example of the <code>OCIHandleAlloc()</code> call follows:</p>
<pre>
OCISPool *spoolhp;
OCIHandleAlloc((void *) envhp, (void **) &amp;spoolhp, OCI_HTYPE_SPOOL, 
                        (size_t) 0, (void **) 0));
</pre>
<p>For an environment handle, multiple session pools can be created.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16623" class="sect3"><a id="sthref1496"></a>
<h4 class="sect3"><a id="sthref1497"></a><a id="sthref1498"></a>OCIAuthInfo</h4>
<p>This is the authentication information handle. It is allocated using <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. It is passed to <a href="oci16rel001.htm#i563311">OCISessionGet()</a>. It supports all the attributes that are supported for a user session handle. See <a href="ociaahan.htm#i428844">User Session Handle Attributes</a> for more information. The authentication information handle has the attribute type <code>OCI_HTYPE_AUTHINFO</code> (see <a href="oci02bas.htm#g466063">Table 2-1</a>).</p>
<p>An example of the <code>OCIHandleAlloc()</code> call follows:</p>
<pre>
OCIAuthInfo *authp;
OCIHandleAlloc((void *) envhp, (void **) &amp;authp, OCI_HTYPE_AUTHINFO, 
                      (size_t) 0, (void **) 0));
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#i428844">"User Session Handle Attributes"</a> for the attributes that belong to the authentication information handle</p>
</li>
<li>
<p><a href="ociaahan.htm#i455080">"Session Pool Handle Attributes"</a> for more information about the session pooling attributes</p>
</li>
<li>
<p><a href="oci16rel001.htm#CIHDFJBA">"Connect, Authorize, and Initialize Functions"</a> for complete information about the functions used in session pooling</p>
</li>
<li>
<p>See <a href="oci16rel001.htm#i563311">"OCISessionGet()"</a> for details of the session handle attributes that you can use with this call</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACHIIIE"></a>
<div id="LNOCI16624" class="sect2">
<h3 class="sect2">Using OCI Session Pooling</h3>
<p>The steps in writing a simple session pooling application that uses a user name and password are as follows:</p>
<ol>
<li>
<p>Allocate the session pool handle using <code>OCIHandleAlloc()</code> for an <code>OCISPool</code> handle. Multiple session pools can be created for an environment handle.</p>
</li>
<li>
<p>Create the session pool using <a href="oci16rel001.htm#i563356">OCISessionPoolCreate()</a> with <code>mode</code> set to <code>OCI_DEFAULT</code> (for a new session pool). See the function for a discussion of the other modes.</p>
</li>
<li>
<p>Loop for each thread. Create the thread with a function that does the following:</p>
<ol>
<li>
<p>Allocates an authentication information handle of type <code>OCIAuthInfo</code> using <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a></p>
</li>
<li>
<p>Sets the user name and password in the authentication information handle using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a></p>
</li>
<li>
<p>Gets a pooled session using <a href="oci16rel001.htm#i563311">OCISessionGet()</a> with <code>mode</code> set to <code>OCI_SESSGET_SPOOL</code></p>
</li>
<li>
<p>Performs the transaction</p>
</li>
<li>
<p>Allocates the handle</p>
</li>
<li>
<p>Prepares the statement</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When using service contexts obtained from OCI session pool, you are required to use the service context returned by <a href="oci16rel001.htm#i563311">OCISessionGet()</a> (or <a href="oci16rel001.htm#i558312">OCILogon2()</a>), and not create other service contexts outside of these calls.
<p>Any statement handle obtained using <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> with the service context should be subsequently used only in conjunction with the same service context, and never with a different service context.</p>
</div>
</li>
<li>
<p>Executes the statement</p>
</li>
<li>
<p>Commits or rolls back the transactions</p>
</li>
<li>
<p>Releases the session (log off) with <a href="oci16rel001.htm#i563322">OCISessionRelease()</a></p>
</li>
<li>
<p>Frees the authentication information handle with <a href="oci16rel002.htm#i540911">OCIHandleFree()</a></p>
</li>
<li>
<p>Ends the loop for each thread</p>
</li>
</ol>
</li>
<li>
<p>Destroy the session pool using <a href="oci16rel001.htm#i561765">OCISessionPoolDestroy()</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CACCCIJB"></a>
<div id="LNOCI16625" class="sect2">
<h3 class="sect2">OCI Calls for Session Pooling</h3>
<p>Here are the usages for OCI calls for session pooling. OCI provides calls for session pooling to perform the following tasks:</p>
<ul>
<li>
<p><a href="#i470594">Allocate the Pool Handle</a></p>
</li>
<li>
<p><a href="#i470602">Create the Connection Pool</a></p>
</li>
<li>
<p><a href="#i470604">Log On to the Database</a></p>
</li>
<li>
<p><a href="#i470614">Log Off from the Database</a></p>
</li>
<li>
<p><a href="#i470619">Destroy the Connection Pool</a></p>
</li>
<li>
<p><a href="#i470624">Free the Pool Handle</a></p>
</li>
</ul>
<div id="LNOCI16626" class="sect3"><a id="sthref1499"></a>
<h4 class="sect3">Allocate the Pool Handle</h4>
<p>Session pooling requires that the pool handle <code>OCI_HTYPE_SPOOL</code> be allocated by calling <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>.</p>
<p>Multiple pools can be created for a given environment handle. For a single session pool, here is an allocation example:</p>
<pre>
OCISPool *poolhp; 
OCIHandleAlloc((void *) envhp, (void **) &amp;poolhp, OCI_HTYPE_SPOOL, (size_t) 0,
               (void **) 0));
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI16627" class="sect3"><a id="sthref1500"></a>
<h4 class="sect3">Create the Pool Session</h4>
<p>You can use the function <a href="oci16rel001.htm#i563356">OCISessionPoolCreate()</a> to create the session pool. Here is an example of how to use this call:</p>
<pre>
OCISessionPoolCreate(envhp, errhp, poolhp, (OraText **)&amp;poolName, 
              (ub4 *)&amp;poolNameLen, database, 
              (ub4)strlen((const signed char *)database),
              sessMin, sessMax, sessIncr,
              (OraText *)appusername,
              (ub4)strlen((const signed char *)appusername),
              (OraText *)apppassword,
              (ub4)strlen((const signed char *)apppassword),
              OCI_DEFAULT);
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI16628" class="sect3"><a id="sthref1501"></a>
<h4 class="sect3">Log On to the Database</h4>
<p>You can use these calls to log on to the database in session pooling mode.</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i558312">OCILogon2()</a></p>
<p>This is the simplest call. However, it does not give the user the option of using tagging. Here is an example of how to use <code>OCILogon2()</code> to log on to the database in session pooling mode:</p>
<pre>
for (i = 0; i &lt; MAXTHREADS; ++i) 
{ 
  OCILogon2(envhp, errhp, &amp;svchp[i], "hr", 2, "hr", 2, poolName,
            poolNameLen, OCI_LOGON2_SPOOL));
}
</pre></li>
<li>
<p><a href="oci16rel001.htm#i563311">OCISessionGet()</a></p>
<p>This is the recommended call to use. It gives the user the option of using tagging to label sessions in the pool, which makes it easier to retrieve specific sessions. An example of using <code>OCISessionGet()</code> follows. It is taken from <code>cdemosp.c</code> in the <code>demo</code> directory.</p>
<pre>
OCISessionGet(envhp, errhp, &amp;svchp, authInfop,
             (OraText *)database,strlen(database), tag,
             strlen(tag), &amp;retTag, &amp;retTagLen, &amp;found, 
             OCI_SESSGET_SPOOL);
</pre>
<p>When using service contexts obtained from an OCI session pool, you are required to use the service context returned by <a href="oci16rel001.htm#i563311">OCISessionGet()</a> (or <a href="oci16rel001.htm#i558312">OCILogon2()</a>), and not create other service contexts outside of these calls.</p>
<p>Any statement handle obtained using <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> with the service context should be subsequently used only in conjunction with the same service context, and never with a different service context.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16629" class="sect3"><a id="sthref1502"></a>
<h4 class="sect3">Log Off from the Database</h4>
<p>From the following calls, choose the one that corresponds to the logon call and use it to log off from the database in session pooling mode.</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i556437">OCILogoff()</a></p>
<p>If you used <a href="oci16rel001.htm#i558312">OCILogon2()</a> to make the connection, you must call <code>OCILogoff()</code> to log off.</p>
</li>
<li>
<p><a href="oci16rel001.htm#i563322">OCISessionRelease()</a></p>
<p>If you used <a href="oci16rel001.htm#i563311">OCISessionGet()</a> to make the connection, then you must call <code>OCISessionRelease()</code> to log off. Pending transactions are automatically committed.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16630" class="sect3"><a id="sthref1503"></a>
<h4 class="sect3">Destroy the Session Pool</h4>
<p>Call <a href="oci16rel001.htm#i561765">OCISessionPoolDestroy()</a> to destroy the session pool, as shown in the following example:</p>
<pre>
OCISessionPoolDestroy(poolhp, errhp, OCI_DEFAULT);
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI16631" class="sect3"><a id="sthref1504"></a>
<h4 class="sect3">Free the Pool Handle</h4>
<p>Call <a href="oci16rel002.htm#i540911">OCIHandleFree()</a> to free the session pool handle, as shown in the following example:</p>
<pre>
OCIHandleFree((void *)poolhp, OCI_HTYPE_SPOOL);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Developers: You are advised to commit or roll back any open transaction before releasing the connection back to the pool. If this is not done, Oracle Database automatically commits any open transaction when the connection is released.
<p>If an instance failure is detected while the session pool is being used, OCI tries to clean up the sessions to that instance.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACBIJJC"></a>
<div id="LNOCI16632" class="sect2">
<h3 class="sect2"><a id="sthref1505"></a>Example of OCI Session Pooling</h3>
<p>For an example of session pooling in a tested complete program, see <code>cdemosp.c</code> in directory <code>demo</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDDJHGH"></a>
<div id="LNOCI09100" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1506"></a><a id="sthref1507"></a><a id="sthref1508"></a>Runtime Connection Load Balancing</h3>
<p>Oracle Real Application Clusters (Oracle RAC) is a database option in which a single database is hosted by multiple instances on multiple nodes. The Oracle RAC shared disk method of clustering databases increases scalability. The nodes can easily be added or freed to meet current needs and improve availability, because if one node fails, another can assume its workload. Oracle RAC adds high availability and failover capacity to the database, because all instances have access to the whole database.</p>
<p>Balancing of work requests occurs at two different times: at connect time and at runtime. These are referred to as <span class="italic">connect time load balancing</span> (provided by Oracle Net Services) and <span class="italic">runtime connection load balancing</span>. For Oracle RAC environments, session pools use service metrics received from the Oracle RAC load balancing advisory through <a id="sthref1509"></a>Fast Application Notification (FAN) events to balance application session requests. The work requests coming into the session pool can be distributed across the instances of Oracle RAC offering a service, using the current service performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><code>cdemosp.c</code> in the directory <code>demo</code></p>
</li>
<li>
<p><a href="#CHDBIBBF">"Database Resident Connection Pooling"</a></p>
</li>
</ul>
</div>
<p>Connect time load balancing occurs when a session is first created by the application. It is necessary that the sessions that are part of the pool be well distributed across Oracle RAC instances, when they are first created. This ensures that sessions on each of the instances get a chance to execute work.</p>
<p>Runtime connection load balancing routes work requests to sessions in a session pool that best serve the work. It occurs when an application selects a session from an existing session pool and thus is a very frequent activity. For session pools that support services at one instance only, the first available session in the pool is adequate. When the pool supports services that span multiple instances, there is a need to distribute the work requests across instances so that the instances that are providing better service or have greater capacity get more requests.</p>
<p>Runtime connection load balancing is enabled by default in an Oracle Database Release 11.1 or later client communicating with a server of Oracle Database Release 10.2 or later. Setting the <code>mode</code> parameter to <code><a id="sthref1510"></a>OCI_SPC_NO_RLB</code> when calling <a href="oci16rel001.htm#i563356">OCISessionPoolCreate()</a> disables runtime connection load balancing.</p>
<div id="LNOCI16633" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1511"></a>
<h4 class="sect3">Receiving Load Balancing Advisory FAN Events</h4>
<p>To receive the service metrics based on the service time, the following requirements must be met:</p>
<ul>
<li>
<p>Oracle RAC environment with Oracle Clusterware must be set up and enabled.</p>
</li>
<li>
<p>The application must have been linked with the threads library.</p>
</li>
<li>
<p>The OCI environment must be created in <code>OCI_EVENTS</code> and <code>OCI_THREADED</code> mode.</p>
</li>
<li>
<p>The service must be modified to set up its goal and the connection load balancing goal as follows:</p>
<pre>
EXEC DBMS_SERVICE.MODIFY_SERVICE("myService",
     DBMS_SERVICE.GOAL_SERVICE_TIME,
     clb_goal =&gt; dbms_service.clb_goal_short);
</pre></li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i563356">"OCISessionPoolCreate()"</a></p>
</li>
<li>
<p><a class="olink RACAD8286" href="../../rac.112/e41960/hafeats.htm#RACAD8286"><span class="italic">Oracle Real Application Clusters Administration and Deployment Guide</span></a>, the section about enabling OCI clients to receive FAN events</p>
</li>
<li>
<p><a class="olink ARPLS092" href="../../appdev.112/e40758/d_serv.htm#ARPLS092"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, "DBMS_SERVICE"</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBIBBF"></a>
<div id="LNOCI9110" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Database <a id="sthref1512"></a><a id="sthref1513"></a><a id="sthref1514"></a>Resident Connection Pooling</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACIECGI">Configuring Database Resident Connection Pooling</a></p>
</li>
<li>
<p><a href="#CACCGGHH">Using OCI Session Pool APIs with DRCP</a></p>
</li>
<li>
<p><a href="#CACIJCJC">Session Purity and Connection Class</a></p>
</li>
<li>
<p><a href="#CACFAEGF">Starting the Database Resident Connection Pool</a></p>
</li>
<li>
<p><a href="#CACIDBGB">Enabling Database Resident Connection Pooling</a></p>
</li>
<li>
<p><a href="#CACJJEFB">Benefiting from the Scalability of DRCP in an OCI Application</a></p>
</li>
<li>
<p><a href="#CACJDDEE">Best Practices for Using DRCP</a></p>
</li>
<li>
<p><a href="#CACHDAAF">Compatibility and Migration</a></p>
</li>
<li>
<p><a href="#CACHJCBD">Restrictions on Using Database Resident Connection Pooling</a></p>
</li>
<li>
<p><a href="#CJGICGJC">Using DRCP with Custom Pools</a></p>
</li>
<li>
<p><a href="#CJGHFDFA">Marking Sessions Explicitly as Stateful or Stateless</a></p>
</li>
<li>
<p><a href="#CACCJBCE">DRCP with Real Application Clusters</a></p>
</li>
<li>
<p><a href="#CACJJFAC">DRCP with Data Guard</a></p>
</li>
</ul>
<p>Database resident connection pooling (DRCP) provides a connection pool in the database server for typical web application usage scenarios where the application acquires a database connection, works on it for a relatively short duration, and then releases it. DRCP pools server processes, each of which is the equivalent of a dedicated server process and a database session combined, which are referred to as pooled servers. Pooled servers can be shared across multiple applications running on the same or several hosts. A connection broker process manages the pooled servers at the database instance level. DRCP is a configurable feature chosen at program runtime, allowing traditional and DRCP-based connection architectures to be in concurrent use.</p>
<p>DRCP is especially relevant for architectures with multiprocess single-threaded application servers (such as PHP and Apache) that cannot do middle-tier connection pooling. DRCP is also very useful in large scale Web deployments where hundreds or thousands of web servers or mid-tiers need database access, client-side pools (even in multithreaded systems and languages such as Java). Using DRCP, the database can scale to tens of thousands of simultaneous connections. If your Database web application must scale with large numbers of connections, DRCP is your connection pooling solution.</p>
<p>DRCP complements middle-tier connection pools that share connections between threads in a middle-tier process. In addition, DRCP enables sharing of database connections across middle-tier processes on the same middle-tier host, across multiple middle-tier hosts, and across multiple middle-tiers (web servers, containers) accommodating applications written in different languages. This results in significant reduction in key database resources needed to support a large number of client connections, thereby reducing the database tier memory footprint and boosting the scalability of both middle-tier and database tiers. Having a pool of readily available servers has the additional benefit of reducing the cost of creating and tearing down client connections.</p>
<p>Clients get connections out of the database resident connection pool connect to an Oracle Database background process known as the connection broker. The connection broker implements the pool functionality and multiplexes pooled servers among persistent inbound connections from the client</p>
<p>When a client requires database access, the connection broker picks up a server process from the pool and hands it off to the client. The client is then directly connected to the server process until the request is served. After the server has finished, the server process is released back into the pool and the connection from the client is restored to the connection broker as a persistent inbound connection from the client process. In DRCP, releasing resources leaves the session intact, but no longer associated with a connection (server process). Because this session stores its user global area (UGA) in the program global area (PGA), not in the system global area (SGA), a client can reestablish a connection transparently upon detecting activity.</p>
<p>DRCP is typically preferred for applications with a large number of connections. Shared servers are useful for a medium number of connections and dedicated sessions are preferred for small numbers of connections. The threshold sizes are relative to the amount of memory available on the database host.</p>
<p>DRCP provides the following advantages:</p>
<ul>
<li>
<p>It enables resource sharing among multiple client applications and middle-tier application servers.</p>
</li>
<li>
<p>It improves scalability of databases and applications by reducing resource usage on the database host.</p>
</li>
</ul>
<p>Compared to shared servers, DRCP offers theses additional benefits:</p>
<ul>
<li>
<p>DRCP provides a direct tie with the database server furnished by client-side connection pooling (that is, there is no man-in-the-middle like client-side connection pooling, but unlike shared servers)</p>
</li>
<li>
<p>DRCP can pool database servers (like client-side connection pooling and shared servers),</p>
</li>
<li>
<p>DRCP can pool sessions (like client-side connection pooling and unlike shared servers)</p>
</li>
<li>
<p>DRCP can share connections across mid-tier boundaries (unlike client-side connection pooling)</p>
</li>
</ul>
<p>DRCP offers a unique connection pooling solution that addresses scalability requirements in environments requiring large numbers of connections with minimal database resource usage.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT1896" href="../../server.112/e40540/dist_pro.htm#CNCPT1896"><span class="italic">Oracle Database Concepts</span></a> for details about the DRCP architecture</p>
</li>
</ul>
</div>
<a id="CACIECGI"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Configuring Database Resident Connection Pooling</h3>
<p>The pool is managed by the DBA using the <code>DBMS_CONNECTION_POOL</code> package. The pool is installed by default, but is shutdown. The DBA must start it and specify DRCP configuration options that include, for example, the minimum and maximum number of pooled servers to be allowed in the pool, the number of connection brokers to be created, and the maximum number of connections that each connection broker can handle, and so forth. See the references for more information.</p>
<p>OCI session pool APIs have been extended to interoperate with the database resident connection pool. See the references for more information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS215" href="../../appdev.112/e40758/d_connection_pool.htm#ARPLS215"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details about the <code>DBMS_CONNECTION_POOL</code> package</p>
</li>
<li>
<p><a class="olink ADMIN12347" href="../../server.112/e25494/manproc.htm#ADMIN12347"><span class="italic">Oracle Database Administrator's Guide</span></a> for the details of configuring a database for DRCP</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CACCGGHH"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using OCI Session Pool APIs with DRCP</h3>
<p>The sections that follow describe OCI session pool APIs that have been extended to interoperate with the database resident connection pool. An OCI application typically initializes the environment for the OCI session pool for DRCP using <a href="oci16rel001.htm#i563356">OCISessionPoolCreate()</a> by specifying the database connection string (<code>connStr</code>), whether a user name (<code>userid</code>) and password (<code>password</code>) are associated with each session, the minimum (<code>sessMin</code>) and the next increment (<code>sessIncr</code>) of sessions to be started if the <code>mode</code> parameter is specified as <code>OCI_SPC_HOMOGENEOUS</code> to allow all sessions in the pool to be authenticated with the user name and password passed in, the maximum (<code>sessMax</code>) number of sessions allowed in the session pool, and so forth.</p>
<p>Sessions are obtained from DRCP from the OCI session pool using <a href="oci16rel001.htm#i563311">OCISessionGet()</a>, by specifying the <code>OCI_SESSGET_SPOOL</code> attribute in the <code>mode</code> parameter and sessions are released to DRCP to the OCI session pool using <a href="oci16rel001.htm#i563322">OCISessionRelease()</a>. The OCI session pool can also transparently keep connections to the connection broker cached to improve performance. OCI applications can reuse the sessions within which the application leaves sessions of a similar state by using <a href="oci16rel001.htm#i563311">OCISessionGet()</a> (<code>authInfop</code>) and setting the <code>OCI_ATTR_CONNECTION_CLASS</code> attribute and specifying a connection class name or by using the <code>OCIAuthInfo</code> handle before calling <a href="oci16rel001.htm#i563311">OCISessionGet()</a>. Using <a href="oci16rel001.htm#i563311">OCISessionGet()</a> (<code>mode</code>), OCI applications can also specify session purity, that is, whether to reuse a pooled session (set the <code>OCI_SESSGET_PURITY_SELF</code> attribute) or to use a new session (set the <code>OCI_SESSGET_PURITY_NEW</code> attribute).</p>
<p>In addition, features offered by the traditional client-side OCI session pool, such as tagging, statement caching, and transparent application failover (TAF) are also supported with DRCP.</p>
</div>
<!-- class="sect2" -->
<a id="CACIJCJC"></a>
<div id="LNOCI16634" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Session Purity and Connection Class</h3>
<p>In Oracle Database Release 11.1, OCI introduced two settings that can be specified when obtaining a session using <a href="oci16rel001.htm#i563311">OCISessionGet()</a>:</p>
<ul>
<li>
<p><a href="#CACFHIIB">Session Purity</a></p>
</li>
<li>
<p><a href="#CACCDDHD">Connection Class</a></p>
</li>
<li>
<p><a href="#CACDCIFH">Defaults for Session Purity and Connection Class</a></p>
</li>
</ul>
<a id="CACFHIIB"></a>
<div id="LNOCI16635" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Session Purity</h4>
<p><span class="italic">Session purity</span> specifies whether the application logic is set up to reuse a pooled session or to use a new session. <a href="oci16rel001.htm#i563311">OCISessionGet()</a> has been enhanced to take in a purity setting of <code><a id="sthref1515"></a>OCI_SESSGET_PURITY_NEW</code> or <code><a id="sthref1516"></a>OCI_SESSGET_PURITY_SELF</code>. Alternatively, you can set <code><a id="sthref1517"></a>OCI_ATTR_PURITY_NEW</code> or <code><a id="sthref1518"></a>OCI_ATTR_PURITY_SELF</code> on the <code>OCIAuthInfo</code> handle before calling <code>OCISessionGet()</code>. Both methods are equivalent.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When reusing a session from the pool, the NLS attributes of the server take precedence over those of the client.
<p>For example, if the client has <code>NLS_LANG</code> set to <code>french_france.us7ascii</code> and if it is assigned a German session from the pool, the client session would be German.</p>
<p>You can use connection classes to restrict sharing and to avoid this problem.</p>
</div>
<p><a href="#CACIAEIG">Example 9-1</a> shows how a connection pooling application sets up a <code>NEW</code> session.</p>
<div id="LNOCI18198" class="example">
<p class="titleinexample"><a id="CACIAEIG"></a>Example 9-1 Setting Session Purity</p>
<pre>
/* OCIAttrSet method */

ub4 purity = OCI_ATTR_PURITY_NEW;
OCIAttrSet (authInfop, OCI_HTYPE_AUTHINFO,  &amp;purity, sizeof (purity),
            OCI_ATTR_PURITY, errhp);
OCISessionGet (envhp, errhp, &amp;svchp, authInfop, poolName, poolNameLen, NULL, 0,
               NULL, NULL, NULL, OCI_SESSGET_SPOOL);
/* poolName is the name returned by OCISessionPoolCreate() */

/*  OCISessionGet mode method */
OCISessionGet (envhp, errhp, &amp;svchp, authInfop, poolName, poolNameLen, NULL, 0,
               NULL, NULL, NULL, OCI_SESSGET_SPOOL | OCI_SESSGET_PURITY_NEW);
/* poolName is the name returned by OCISessionPoolCreate() */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CACCDDHD"></a>
<div id="LNOCI16637" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Connection Class</h4>
<p><span class="italic">Connection class</span> defines a logical name for the type of connection required by the application. Sessions from the OCI session pool cannot be shared by different users (A session first created for user <code>HR</code> is only given out to subsequent requests by user <code>HR</code>.) The connection class setting allows for further separation between the sessions of a given user. The connection class setting lets different applications (connecting as the same database user) identify their sessions using a logical name that corresponds to the application. OCI then ensures that such sessions belonging to a particular connection class are not shared outside of the connection class.</p>
<p>You can use the <code>OCI_ATTR_CONNECTION_CLASS</code> attribute on the <code>OCIAuthInfo</code> handle to set the connection class. The connection class is a string attribute. OCI supports a maximum connection class length of 1024 bytes. The asterisk (*) is a special character and is not allowed in the connection class name.</p>
<p><a href="#CACFGAGD">Example 9-2</a> shows that an HRMS application needs sessions identified with the connection class <code>HRMS</code>.</p>
<div id="LNOCI18199" class="example">
<p class="titleinexample"><a id="CACFGAGD"></a>Example 9-2 Setting the Connection Class as HRMS</p>
<pre>
OCISessionPoolCreate (envhp, errhp, spoolhp, &amp;poolName, &amp;poolNameLen, "HRDB",
    strlen("HRDB"), 0, 10, 1, "HR", strlen("HR"), "HR", strlen("HR"),
    OCI_SPC_HOMOGENEOUS);
 
OCIAttrSet (authInfop, OCI_HTYPE_AUTHINFO, "HRMS", strlen ("HRMS"),
    OCI_ATTR_CONNECTION_CLASS, errhp);
OCISessionGet (envhp, errhp, &amp;svchp, authInfop, poolName, poolNameLen, NULL, 0,
    NULL, NULL, NULL, OCI_SESSGET_SPOOL);
</pre></div>
<!-- class="example" -->
<p><a href="#CACGIAAB">Example 9-3</a> shows that a recruitment application needs sessions identified with the connection class <code>RECMS</code>.</p>
<div id="LNOCI18200" class="example">
<p class="titleinexample"><a id="CACGIAAB"></a>Example 9-3 Setting the Connection Class as RECMS</p>
<pre>
OCISessionPoolCreate (envhp, errhp, spoolhp, &amp;poolName, &amp;poolNameLen, "HRDB",
    strlen("HRDB"), 0, 10, 1, "HR", strlen("HR"), "HR", strlen("HR"),
    OCI_SPC_HOMOGENEOUS);
 
OCIAttrSet (authInfop, OCI_HTYPE_AUTHINFO,  "RECMS", strlen("RECMS"),
    OCI_ATTR_CONNECTION_CLASS, errhp);
OCISessionGet (envhp, errhp, &amp;svchp, authInfop, poolName, poolNameLen, NULL, 0,
    NULL, NULL, NULL, OCI_SESSGET_SPOOL);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CACDCIFH"></a>
<div id="LNOCI16639" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Defaults for Session Purity and Connection Class</h4>
<p><a href="#CHDHDABE">Table 9-1</a> illustrates the defaults used in various client scenarios.</p>
<div id="LNOCI16640" class="tblformalwide">
<p class="titleintable"><a id="sthref1519"></a><a id="CHDHDABE"></a>Table 9-1 Defaults Used in Various Client Scenarios</p>
<table class="cellalignment1011" title="Defaults Used in Various Client Scenarios" summary="Session purity and connection class defaults for Database Resident Connection Pooling." dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t18">Attribute or Setting</th>
<th class="cellalignment1012" id="r1c2-t18">Application Uses OCISessionGet() from Session Pool</th>
<th class="cellalignment1012" id="r1c3-t18">Other Connections Are Not Obtained from OCI Session Pool</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t18" headers="r1c1-t18">
<p>OCI_ATTR_PURITY</p>
</td>
<td class="cellalignment1013" headers="r2c1-t18 r1c2-t18">
<p>OCI_ATTR_PURITY_SELF</p>
</td>
<td class="cellalignment1013" headers="r2c1-t18 r1c3-t18">
<p>OCI_ATTR_PURITY_NEW</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t18" headers="r1c1-t18">
<p>OCI_ATTR_CONNECTION_CLASS</p>
</td>
<td class="cellalignment1013" headers="r3c1-t18 r1c2-t18">
<p>OCI-generated globally unique name for each client-side session pool that is used as the default connection class for all connections in the OCI session pool.</p>
</td>
<td class="cellalignment1013" headers="r3c1-t18 r1c3-t18">
<p>SHARED</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t18" headers="r1c1-t18">
<p>Sharing of sessions</p>
</td>
<td class="cellalignment1013" headers="r4c1-t18 r1c2-t18">
<p>Sharing of sessions between threads requesting sessions from the OCI session pool.</p>
</td>
<td class="cellalignment1013" headers="r4c1-t18 r1c3-t18">
<p>Sharing among all connections of a particular database using the default SHARED connection class.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACFAEGF"></a>
<div id="LNOCI16641" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Starting the Database Resident Connection Pool</h3>
<p>The database administrator (DBA) must log on as <code>SYSDBA</code> and start the default pool, <code>SYS_DEFAULT_CONNECTION_POOL</code>, using <code>DBMS_CONNECTION_POOL.START_POOL</code> with the default settings.</p>
<p>For detailed information about configuring the pool, see <a class="olink ADMIN12347" href="../../server.112/e25494/manproc.htm#ADMIN12347"><span class="italic">Oracle Database Administrator's Guide</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="CACIDBGB"></a>
<div id="LNOCI16642" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Enabling Database Resident Connection Pooling</h3>
<p>Any application can benefit from database resident connection pool by specifying <code>:POOLED</code> in the Easy Connect string (see <a href="#CACGIFBD">Example 9-4</a>) or by specifying <code>(SERVER=POOLED)</code> in the TNS connect string (see <a href="#CACFGCGE">Example 9-5</a>).</p>
<div id="LNOCI18201" class="example">
<p class="titleinexample"><a id="CACGIFBD"></a>Example 9-4 Specifying :POOLED in the Easy Connect String for Enabling DRCP</p>
<pre>
oraclehost.company.com:1521/books.company.com:POOLED
</pre></div>
<!-- class="example" -->
<div id="LNOCI18202" class="example">
<p class="titleinexample"><a id="CACFGCGE"></a>Example 9-5 Specifying SERVER=POOLED in a TNS Connect String for Enabling DRCP</p>
<pre>
BOOKSDB = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=oraclehost.company.com)
     (PORT=1521))(CONNECT_DATA = (SERVICE_NAME=books.company.com)(SERVER=POOLED)))
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CACJJEFB"></a>
<div id="LNOCI16645" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Benefiting from the Scalability of DRCP in an OCI Application</h3>
<p>Consider the following three types of application scenarios and note how each benefits from DRCP:</p>
<ul>
<li>
<p>Applications that do not use OCI session pooling and also do not specify any connection class or purity setting (or specify a purity setting of <code>NEW</code>) get a new session from the DRCP. Similarly, when the application releases a connection back to the pool, the session is not shared with other instances of the same application by default. SQL*Plus is an example of a client that does not use OCI session pooling. It holds on to connections even when the connection is idle. As result, the pool server remains assigned to the client if the client session exists or if the client session does not log off. The application, however, does get the benefit of reusing an existing pooled server process.</p>
</li>
<li>
<p>Applications that use the <a href="oci16rel001.htm#i563311">OCISessionGet()</a> call outside of an OCI session pool, or to specify the connection class and set <code>purity=SELF</code> can reuse both DRCP pooled server processes and sessions. However, following an <a href="oci16rel001.htm#i563322">OCISessionRelease()</a> call, OCI terminates the connection to the connection broker. On the next <code>OCISessionGet()</code> call, the application reconnects to the broker. Once it reconnects, the DRCP assigns a pooled server (and session) belonging to the connection class specified. Reconnecting, however, incurs the cost of connection establishment and reauthentication. Such applications achieve better sharing of DRCP resources (processes and sessions) but do not get the benefit of caching connections to the connection broker.</p>
</li>
<li>
<p>Applications that use OCI session pool APIs and specify the connection class and set <code>purity=SELF</code> make full use of the DRCP functionality through reuse of both the pooled server process and the associated session. They get the benefit of cached connections to the connection broker. Cached connections do not incur the cost of reauthentication on the <code>OCISessionGet()</code> call.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACJDDEE"></a>
<div id="LNOCI16646" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Best Practices for Using DRCP</h3>
<p>The steps to design an application that can benefit from the full power of DRCP are very similar to the steps required for an application that uses the OCI session pool as described in <a href="#CACHIIIE">"Using OCI Session Pooling"</a> and <a href="#CACCCIJB">"OCI Calls for Session Pooling"</a>.</p>
<p>The only additional step is that for best performance, when deployed to run with DRCP, the application should specify an explicit connection class setting.</p>
<p>Multiple instances of the same application should specify the same connection class setting for best performance and enhanced sharing of DRCP resources. Ensure that the different instances of the application can share database sessions.</p>
<p><a href="#CACCEEEH">Example 9-6</a> shows a database resident connection pooling DRCP application.</p>
<div id="LNOCI18203" class="example">
<p class="titleinexample"><a id="CACCEEEH"></a>Example 9-6 Database Resident Connection Pooling Application</p>
<pre>
/* Assume that all necessary handles are allocated. */
 
/*   This middletier uses a single database user. Create a homogeneous
     client-side session pool */
OCISessionPoolCreate (envhp, errhp, spoolhp, &amp;poolName, &amp;poolNameLen, "BOOKSDB",
    strlen("BOOKSDB"), 0, 10, 1, "SCOTT", strlen("SCOTT"), "<span class="italic">password</span>",
    strlen("<span class="italic">password</span>"), OCI_SPC_HOMOGENEOUS);
 
while (1)
{
   /* Process a client request */
   WaitForClientRequest();
   /* Application function */
 
   /* Set the Connection Class on the OCIAuthInfo handle that is passed as
      argument to OCISessionGet*/
   
   OCIAttrSet (authInfop, OCI_HTYPE_AUTHINFO,  "BOOKSTORE", strlen("BOOKSTORE"),
               OCI_ATTR_CONNECTION_CLASS, errhp);
 
   /* Purity need not be set, as default is OCI_ATTR_PURITY_SELF for OCISessionPool
       connections */
 
   /* You can get a SCOTT session released by Mid-tier 2 */
   OCISessionGet(envhp, errhp, &amp;svchp, authInfop, poolName, poolNameLen, NULL, 0,
                 NULL, NULL, NULL, OCI_SESSGET_SPOOL); 
 
   /* Database calls using the svchp obtained above  */
   OCIStmtExecute(...)
 
   /* This releases the pooled server on the database for reuse */
   OCISessionRelease (svchp, errhp, NULL, 0, OCI_DEFAULT);
}
 
/* Mid-tier is done - exiting */
OCISessionPoolDestroy (spoolhp, errhp, OCI_DEFAULT);
</pre></div>
<!-- class="example" -->
<p><a href="#CACCDBHD">Example 9-7</a> and <a href="#CACIICBH">Example 9-8</a> show two deployment examples, each based on code in <a href="#CACCEEEH">Example 9-6</a>, in which code is deployed in 10 middle-tier hosts servicing the BOOKSTORE application.</p>
<p>For the first deployment example, assume that the database used is Oracle Database 11<span class="italic">g</span> (or earlier) in dedicated server mode but with DRCP not enabled. The client side has 11<span class="italic">g</span> libraries. <a href="#CACCDBHD">Example 9-7</a> shows the connect string to use for this deployment. In this case, the application obtains dedicated server connections from the database.</p>
<div id="LNOCI18204" class="example">
<p class="titleinexample"><a id="CACCDBHD"></a>Example 9-7 Connect String to Use for a Deployment in Dedicated Server Mode with DRCP Not Enabled</p>
<pre>
BOOKSDB = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=oraclehost.company.com)
   (PORT=1521))(CONNECT_DATA = (SERVICE_NAME=books.company.com)))
</pre></div>
<!-- class="example" -->
<p>For the second deployment example, assume that DRCP is enabled on the Oracle Database 11<span class="italic">g</span> database. Now all the middle-tier processes can benefit from the pooling capabilities offered by DRCP. The database resource requirement with DRCP is much less than what would be required with dedicated server mode. <a href="#CACIICBH">Example 9-8</a> shows how you change the connect string for this type of deployment.</p>
<div id="LNOCI18205" class="example">
<p class="titleinexample"><a id="CACIICBH"></a>Example 9-8 Connect String to Use for a Deployment with DRCP Enabled</p>
<pre>
BOOKSDB = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=oraclehost.company.com)
  (PORT=1521))(CONNECT_DATA = (SERVICE_NAME=books.company.com)(SERVER=POOLED)))
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CACHDAAF"></a>
<div id="LNOCI16650" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Compatibility and Migration</h3>
<p>An OCI application linked with Oracle Database 11<span class="italic">g</span> client libraries works unaltered against:</p>
<ul>
<li>
<p>An Oracle Database 11<span class="italic">g</span> database with DRCP disabled</p>
</li>
<li>
<p>A database server from a release earlier than Oracle Database 11g</p>
</li>
<li>
<p>An Oracle Database 11<span class="italic">g</span> database server with DRCP enabled, when deployed with the DRCP connect string</p>
</li>
</ul>
<p>Suitable clients benefit from enhanced scalability offered by DRCP if they are appropriately modified to use the OCI session pool APIs with the connection class and purity settings as previously described.</p>
</div>
<!-- class="sect2" -->
<a id="CACHJCBD"></a>
<div id="LNOCI16651" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Restrictions on Using Database Resident Connection Pooling</h3>
<p>The following actions cannot be performed or used with pooled servers:</p>
<ul>
<li>
<p>Shutting down the database</p>
</li>
<li>
<p>Stopping the database resident connection pool</p>
</li>
<li>
<p>Change the password for the connected user</p>
</li>
<li>
<p>Using shared database links to connect to a database resident connection pool that is on a different instance</p>
</li>
<li>
<p>Using Advanced Security Options (ASO) with TCPS</p>
</li>
<li>
<p>Using migratable sessions on the server side, directly by using the <code>OCI_MIGRATE</code> option or indirectly by using the <a href="oci16rel001.htm#i563356">OCISessionPoolCreate()</a> call</p>
</li>
<li>
<p>Using initial client roles</p>
</li>
<li>
<p>Using Application context attributes such as <code>OCI_ATTR_APPCTX_NAME</code> and <code>OCI_ATTR_APPCTX_VALUE</code></p>
</li>
</ul>
<p>DDL statements that pertain to database users in the pool need to be performed carefully, as the pre-DDL sessions in the pool can still be given to clients post-DDL. For example, while dropping users, ensure that there are no sessions of that user in the pool and no connections to the Broker that were authenticated as that user.</p>
<p>Sessions with explicit roles enabled, that are released to the pool, can be later handed out to connections (of the same user) that need the default logon role. Avoid releasing sessions with explicit roles, and instead terminate them.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use Oracle Advanced Security features such as encryption and strong authentication with DRCP.</div>
</div>
<!-- class="sect2" -->
<a id="CJGICGJC"></a>
<div id="LNOCI18206" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using DRCP with Custom Pools</h3>
<p>DRCP is well integrated with OCI session pooling as described in <a href="#CHDBIBBF">"Database Resident Connection Pooling"</a>. Oracle highly recommends using OCI session pool as it is already integrated with DRCP, FAN, and RLB.</p>
<p>However, if an application is built using its own custom connection pool (or if the application does not use any pooling at all, but has periods of time when the session is not used and the application does not depend on getting back the specific session for correctness), it can still integrate with DRCP. You can do this by enabling the <code><a id="sthref1520"></a>OCI_ATTR_SESSION_STATE</code> attribute as described in <a href="#CJGHFDFA">"Marking Sessions Explicitly as Stateful or Stateless"</a>.</p>
<p>When an application flags a session as being <a id="sthref1521"></a><code>OCI_SESSION_STATELESS</code>, OCI benefits from this session annotation to return the session transparently to the DRCP pool (when DRCP is enabled). Similarly, when the application indicates the session as being <code>OCI_SESSION_STATEFUL</code>, OCI benefits from this changed session state annotation to transparently check out an appropriate session from the DRCP pool.</p>
<p>Applications should mark session state as promptly as possible to enable efficient utilization of the underlying database resources.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Other DRCP attributes such as connection class and purity still must be specified as previously described in detail.</div>
</div>
<!-- class="sect2" -->
<a id="CJGHFDFA"></a>
<div id="LNOCI18197" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Marking Sessions Explicitly as Stateful or Stateless</h3>
<p>An application typically requires a specific database session for the duration of a unit of work. The session is said to be STATEFUL for this duration. At the end of this unit of work, if the application does not depend on retaining the specific session for subsequent units of work, the session is said to be STATELESS.</p>
<p>As the application detects when a session transitions from being STATEFUL to STATELESS and vice versa, the application can explicitly inform OCI regarding these transitions by using <a id="sthref1522"></a><a id="sthref1523"></a><a id="sthref1524"></a><code>OCI_ATTR_SESSION_STATE</code>.</p>
<p>This indication by the application or caller can allow OCI and Oracle Database to take advantage of this information for transparently performing certain scalability optimizations. For example, the session could be given to someone else who needs it when the application is not working on it. Or, the session could be replaced by a different session when the application needs it again.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJGICGJC">"Using DRCP with Custom Pools"</a></div>
<p>Here is an example of marking the state of sessions in a code fragment:</p>
<pre>
wait_for_transaction_request();
do {
 
ub1 state;
 
/* mark  database session as STATEFUL  */
state = OCI_SESSION_STATEFUL;
checkerr(errhp, OCIAttrSet(usrhp, OCI_HTYPE_SESSION,
        &amp;state, 0, OCI_ATTR_SESSION_STATE, errhp));
/* do database work consisting of one or more related calls to the database */
 
...
 
/* done with database work, mark session as stateless */
state = OCI_SESSION_STATELESS;
checkerr(errhp, OCIAttrSet(usrhp, OCI_HTYPE_SESSION,
         &amp;state, 0,OCI_ATTR_SESSION_STATE, errhp));
 
wait_for_transaction_request();
 
} while(not _done); 
</pre>
<p>If a session is obtained from outside an OCI session pool, the session starts as <code><a id="sthref1525"></a><a id="sthref1526"></a>OCI_SESSION_STATEFUL</code> and remains <code>OCI_SESSION_STATEFUL</code> throughout the life of the session unless the application explicitly changes it to <code>OCI_SESSION_STATELESS</code>.</p>
<p>If a session is obtained from an OCI session pool, the session is by default marked as <code>OCI_SESSION_STATEFUL</code> when the first call is initiated on that session after getting it from the pool. The session is also by default marked as being <code>OCI_SESSION_STATELESS</code> when it is released to the pool. Hence, there is no need to set this attribute explicitly with an OCI session pool. OCI session pooling does this transparently. Use this attribute only if you are not using OCI session pooling.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJEIIAB">"OCI_ATTR_SESSION_STATE"</a></div>
</div>
<!-- class="sect2" -->
<a id="CACCJBCE"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DRCP with Real Application Clusters</h3>
<p>When the Database Resident Connection Pool is configured in a database in a Real Application Clusters environment, the pool configuration is applied to each of the database instances. Starting or stopping of the pool on one instance will start or stop the pool on all the instances.</p>
</div>
<!-- class="sect2" -->
<a id="CACJJFAC"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DRCP with Data Guard</h3>
<p>The Database Resident Connection Pool has certain conditions to operate in a Data Guard environment.</p>
<ul>
<li>
<p>Starting the pool: The pool can be started on a physical standby database only if the pool has been already started on the primary database. If the pool is down on the primary, it cannot be started on the standby database.</p>
</li>
<li>
<p>Stopping the pool: The pool cannot be stopped on a physical standby database if it is up and running on the primary database. It can only be stopped if on the primary database, the pool is not running.</p>
</li>
<li>
<p>Pool parameters cannot be configured, restored to defaults, or altered on a physical standby database.</p>
</li>
<li>
<p>When role reversal takes place, that is, the Primary goes down and the Secondary database takes up the role of the Primary database, the limitations mentioned previously for the physical standby database no longer holds. Since the Standby database has now become the Primary, all pool operations are allowed.</p>
</li>
<li>
<p>On a logical standby database, all pool operations are allowed.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i471769"></a>
<div id="LNOCI16652" class="sect1">
<h2 class="sect1"><a id="sthref1527"></a><a id="sthref1528"></a>When to Use Connection Pooling, Session Pooling, or Neither</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACEAGBB">Functions for Session Creation</a></p>
</li>
<li>
<p><a href="#CACHIDHD">Choosing Between Different Types of OCI Sessions</a></p>
</li>
</ul>
<p>If database sessions are not reusable by mid-tier threads (that is, they are stateful) and the number of back-end server processes may cause scaling problems on the database, use OCI connection pooling.</p>
<p>If database sessions are reusable by mid-tier threads (that is, they are stateless) and the number of back-end server processes may cause scaling problems on the database, use OCI session pooling.</p>
<p>If database sessions are not reusable by mid-tier threads (that is, they are stateful) and the number of back-end server processes is never large enough to potentially cause any scaling issue on the database, there is no need to use any pooling mechanism.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Having nonpooled sessions or connections results in tearing down and re-creating the database session/connection for every mid-tier user request. This can cause severe scaling problems on the database side and excessive latency for the fulfillment of the request. Hence, Oracle strongly recommends that you adopt one of the pooling strategies for mid-tier applications based on whether the database session is stateful or stateless.</div>
<p>In connection pooling, the pool element is a connection and in session pooling, the pool element is a session.</p>
<p>As with any pool, the pooled resource is locked by the application thread for a certain duration until the thread has done its job on the database and the resource is released. The resource is unavailable to other threads during its period of use. Hence, application developers must be aware that any kind of pooling works effectively with relatively short tasks. However, if the application is performing a long-running transaction, it may deny the pooled resource to other sharers for long periods of time, leading to starvation. Hence, pooling should be used in conjunction with short tasks, and the size of the pool should be sufficiently large to maintain the desired concurrency of transactions.</p>
<p>Note the following additional information about connection pooling and session pooling:</p>
<ul>
<li>
<p>OCI Connection Pooling</p>
<p>Connections to the database are pooled. Sessions are created and destroyed by the user. Each call to the database picks up an appropriate available connection from the pool.</p>
<p>The application is multiplexing several sessions over fewer physical connections to the database. The users can tune the pool configuration to achieve required concurrency.</p>
<p>The life-time of the application sessions is independent of the life-time of the cached pooled connections.</p>
</li>
<li>
<p>OCI Session Pooling</p>
<p>Sessions and connections are pooled by OCI. The application gets sessions from the pool and releases sessions back to the pool.</p>
</li>
</ul>
<a id="CACEAGBB"></a>
<div id="LNOCI16653" class="sect2">
<h3 class="sect2">Functions for Session Creation</h3>
<p>OCI offers the following functions for session creation:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i556477">OCILogon()</a></p>
<p><a href="oci16rel001.htm#i556477">OCILogon()</a> is the simplest way to get an OCI session. The advantage is ease of obtaining an OCI service context. The disadvantage is that you cannot perform any advance OCI operations, such as session migration, proxy authentication, or using a connection pool or a session pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i556477">"OCILogon()"</a></p>
</li>
<li>
<p><a href="oci02bas.htm#i462054">"Application Initialization, Connection, and Session Creation"</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="oci16rel001.htm#i558312">OCILogon2()</a></p>
<p><a href="oci16rel001.htm#i558312">OCILogon2()</a> includes the functionality of <code>OCILogon()</code> to get a session. This session may be a new one with a new underlying connection, or one that is started over a virtual connection from an existing connection pool, or one from an existing session pool. The <code>mode</code> parameter value that the function is called with determines its behavior.</p>
<p>The user cannot modify the attributes (except <code>OCI_ATTR_</code><code>STMTCACHESIZE</code>) of the service context returned by OCI.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci16rel001.htm#i558312">"OCILogon2()"</a></div>
</li>
<li>
<p><a href="oci16rel001.htm#i556608">OCISessionBegin()</a></p>
<p><a href="oci16rel001.htm#i556608">OCISessionBegin()</a> supports all the various options of an OCI session, such as proxy authentication, getting a session from a connection pool or a session pool, external credentials, and migratable sessions. This is the lowest level call, where all handles must be explicitly allocated and all attributes set. <code>OCIServerAttach()</code> must be called before this call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci16rel001.htm#i556608">"OCISessionBegin()"</a></div>
</li>
<li>
<p><a href="oci16rel001.htm#i563311">OCISessionGet()</a></p>
<p><a href="oci16rel001.htm#i563311">OCISessionGet()</a> is now the recommended method to get a session. This session may be a new one with a new underlying connection, or one that is started over a virtual connection from an existing connection pool, or one from an existing session pool. The <code>mode</code> parameter value that the function is called with determines its behavior. This works like <code>OCILogon2()</code> but additionally enables you to specify tags for obtaining specific sessions from the pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci16rel001.htm#i563311">"OCISessionGet()"</a></div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACHIDHD"></a>
<div id="LNOCI16654" class="sect2">
<h3 class="sect2">Choosing Between Different Types of OCI Sessions</h3>
<p>OCI includes the following types of sessions:</p>
<ul>
<li>
<p>Basic OCI sessions</p>
<p>The basic OCI session works by using user name and password over a dedicated OCI server handle. This is the no-pool mechanism. See <a href="#i471769">When to Use Connection Pooling, Session Pooling, or Neither</a> for information of when to use it.</p>
<p>If authentication is obtained through external credentials, then a user name or password is not required.</p>
</li>
<li>
<p>Session pool sessions</p>
<p>Session pool sessions are from the session pool cache. Some sessions may be tagged. These are stateless sessions. Each <a href="oci16rel001.htm#i563311">OCISessionGet()</a> and <a href="oci16rel001.htm#i563322">OCISessionRelease()</a> call gets and releases a session from the session cache. This saves the server from creating and destroying sessions.</p>
<p>See <a href="#i471769">When to Use Connection Pooling, Session Pooling, or Neither</a> on connection pool sessions versus session pooling sessions versus no-pooling sessions.</p>
</li>
<li>
<p>Connection pool sessions</p>
<p>Connection pool sessions are created using <a href="oci16rel001.htm#i563311">OCISessionGet()</a> and <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> calls from an OCI connection pool. There is no session cache as these are stateful sessions. Each call creates a new session, and the user is responsible for terminating these sessions.</p>
<p>The sessions are automatically migratable between the server handles of the connection pool. Each session can have user name and password or be a proxy session. See <a href="#i471769">When to Use Connection Pooling, Session Pooling, or Neither</a> on connection pool sessions versus session pooling sessions versus no-pooling sessions.</p>
</li>
<li>
<p>Sessions sharing a server handle</p>
<p>You can multiplex several OCI sessions over a few physical connections. The application does this manually by having the same server handle for these multiple sessions. It is preferred to have the session multiplexing details be left to OCI by using the OCI connection pool APIs.</p>
</li>
<li>
<p>Proxy sessions</p>
<p>Proxy sessions are useful if the password of the client must be protected from the middle tier. Proxy sessions can also be part of an OCI connection pool or an OCI session pool.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci08sca.htm#i451070">"Middle-Tier Applications in OCI"</a></div>
</li>
<li>
<p>Migratable Sessions</p>
</li>
</ul>
<p>With transaction handles being migratable, there should be no need for applications to use migratable sessions, instead use OCI connection pooling.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci08sca.htm#i453378">"OCI Session Management"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i471377"></a>
<div id="LNOCI16655" class="sect1">
<h2 class="sect1"><a id="sthref1529"></a>Statement Caching in OCI</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACEJCID">Statement Caching Without Session Pooling in OCI</a></p>
</li>
<li>
<p><a href="#CACEEJAI">Statement Caching with Session Pooling in OCI</a></p>
</li>
<li>
<p><a href="#CACJBJAD">Rules for Statement Caching in OCI</a></p>
</li>
<li>
<p><a href="#CACEDIHB">Bind and Define Optimization in Statement Caching</a></p>
</li>
<li>
<p><a href="#CACIIJAC">OCI Statement Caching Code Example</a></p>
</li>
</ul>
<p>Statement caching refers to the feature that provides and manages a cache of statements for each session. In the server, it means that cursors are ready to be used without the need to parse the statement again. You can use statement caching with connection pooling and with session pooling, and improve performance and scalability. You can use it without session pooling as well. OCI calls that implement statement caching are:</p>
<ul>
<li>
<p><a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a></p>
</li>
<li>
<p><a href="oci17msc001.htm#i575264">OCIStmtRelease()</a></p>
</li>
</ul>
<a id="CACEJCID"></a>
<div id="LNOCI16656" class="sect2">
<h3 class="sect2">Statement Caching Without Session Pooling in OCI</h3>
<p>To perform statement caching without session pooling, users perform the usual OCI steps to log on. The call to obtain a session has a mode that specifies whether statement caching is enabled for the session. Initially the statement cache is empty. Developers try to find a statement in the cache using the statement text. If the statement exists, the API returns a previously prepared statement handle; otherwise, it returns a newly prepared statement handle.</p>
<p>The application developer can perform binds and defines and then simply execute and fetch the statement before returning the statement to the cache. If the statement handle is not found in the cache, the developer must set different attributes on the handle in addition to the other steps.</p>
<p><a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> takes a mode that determines if the developer wants a prepared statement handle or a null statement handle if the statement is not found in the cache.</p>
<p>The pseudocode looks like this:</p>
<pre>
OCISessionBegin( userhp, ... OCI_STMT_CACHE)  ;
OCIAttrset(svchp, userhp, ...);  /* Set the user handle in the service context */
OCIStmtPrepare2(svchp, &amp;stmthp, stmttext, key, ...);
OCIBindByPos(stmthp, ...);
OCIDefineByPos(stmthp, ...);
OCIStmtExecute(svchp, stmthp, ...);
OCIStmtFetch2(svchp, ...);
OCIStmtRelease(stmthp, ...);
...
</pre></div>
<!-- class="sect2" -->
<a id="CACEEJAI"></a>
<div id="LNOCI16657" class="sect2">
<h3 class="sect2">Statement Caching with Session Pooling in OCI</h3>
<p>For statement caching with session pooling, the concepts remain the same, except that the statement cache is enabled at the session pool layer rather than at the session layer.</p>
<p>The attribute <code>OCI_ATTR_SPOOL_STMTCACHESIZE</code> sets the default statement cache size for each of the sessions in the session pool. It is set on the <code>OCI_HTYPE_SPOOL</code> handle. The statement cache size for a particular session in the pool can be overridden at any time by using <code>OCI_ATTR_STMTCACHESIZE</code> on that session. The value of <code>OCI_ATTR_SPOOL_STMTCACHESIZE</code> can be changed at any time. You can use this attribute to enable or disable statement caching at the pool level, after creation, just as attribute <code>OCI_ATTR_STMTCACHESIZE</code> (on the service context) is used to enable or disable statement caching at the session level. This change is reflected on individual sessions in the pool, when they are provided to a user. Tagged sessions are an exception to this behavior. This is explained later in this section.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can change the attributes after acquiring a session. However, once an attribute is changed, it will remain set on the underlying physical session. This value will not be reset back implicitly while releasing the session back to the session pool. Hence, it is the developer's responsibility to maintain the state of the sessions before releasing the session using <code>OCIStmtRelease()</code>.</div>
<p>Enabling or disabling of statement caching is allowed on individual pooled sessions as it is on nonpooled sessions.</p>
<p>A user can enable statement caching on a session retrieved from a non-statement cached pool in an <a href="oci16rel001.htm#i563311">OCISessionGet()</a> or <a href="oci16rel001.htm#i558312">OCILogon2()</a> call by specifying <code><a id="sthref1530"></a>OCI_SESSGET_STMTCACHE</code> or <a id="sthref1531"></a><code>OCI_LOGON2_STMTCACHE</code>, respectively, in the mode argument.</p>
<p>When a user asks for a session from a session pool, the statement cache size for that session defaults to that of the pool. This may also mean enabling or disabling statement caching in that session. For example, if a pooled session (Session A) has statement caching enabled, and statement caching is turned off in the pool, and a user asks for a session, and Session A is returned, then statement caching is turned off in Session A. As another example, if Session A in a pool does not have statement caching enabled, and statement caching at the pool level is turned on, then before returning Session A to a user, statement caching on Session A with size equal to that of the pool is turned on.</p>
<p>This does not hold true if a tagged session is asked for and retrieved. In this case, the size of the statement cache is not changed. Consequently, it is not turned on or off. Moreover, if the user specifies mode <code>OCI_SESSGET_STMTCACHE</code> in the <a href="oci16rel001.htm#i563311">OCISessionGet()</a> call, this is ignored if the session is tagged. In our earlier example, if Session A was tagged, then it is returned as is to the user.</p>
</div>
<!-- class="sect2" -->
<a id="CACJBJAD"></a>
<div id="LNOCI16658" class="sect2">
<h3 class="sect2">Rules for Statement Caching in OCI</h3>
<p>Here are some rules to follow for statement caching in OCI:</p>
<ul>
<li>
<p>Use the function <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> instead of <code>OCIStmtPrepare()</code>. If you are using <code>OCIStmtPrepare()</code>, you are strongly urged not to use a statement handle across different service contexts. Doing so raises an error if the statement has been obtained by <code>OCIStmtPrepare2()</code>. Migration of a statement handle to a new service context actually closes the cursor associated with the old session and therefore no sharing is achieved. Client-side sharing is also not obtained, because OCI frees all buffers associated with the old session when the statement handle is migrated.</p>
</li>
<li>
<p>You are required to keep one service context per session. Any statement handle obtained using <code>OCIStmtPrepare2()</code> with a certain service context should be subsequently used only in conjunction with the same service context, and never with a different service context.</p>
</li>
<li>
<p>A call to <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a>, even if the session does not have a statement cache, also allocates the statement handle. Therefore, applications using only <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> must not call <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> for the statement handle.</p>
</li>
<li>
<p>A call to <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> must be followed by a call to <a href="oci17msc001.htm#i575264">OCIStmtRelease()</a> after the user is done with the statement handle. If statement caching is used, this releases the statement to the cache. If statement caching is not used, the statement is deallocated. Do not call <a href="oci16rel002.htm#i540911">OCIHandleFree()</a> to free the memory.</p>
</li>
<li>
<p>If the call to <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> is made with the <code>OCI_PREP2_CACHE_SEARCHONLY</code> mode and a <code>NULL</code> statement was returned (statement was not found), the subsequent call to <a href="oci17msc001.htm#i575264">OCIStmtRelease()</a> is not required and must not be performed.</p>
</li>
<li>
<p>Do not call <a href="oci17msc001.htm#i575264">OCIStmtRelease()</a> for a statement that was prepared using <code>OCIStmtPrepare()</code>.</p>
</li>
<li>
<p>The statement cache has a maximum size (number of statements) that can be modified by an attribute on the service context, <a id="sthref1532"></a><code>OCI_ATTR_STMTCACHESIZE</code>. The default value is 20. This attribute can also be used to enable or disable statement caching for the session, pooled or nonpooled. If <a href="oci16rel001.htm#i556608">OCISessionBegin()</a> is called without the mode set as <code>OCI_STMT_CACHE</code>, then <code>OCI_ATTR_STMTCACHESIZE</code> can be set on the service context to a nonzero attribute to turn on statement caching. If statement caching is not turned on at the session pool level, <a href="oci16rel001.htm#i563311">OCISessionGet()</a> returns a non-statement cache-enabled session. You can use <code>OCI_ATTR_STMTCACHESIZE</code> to turn the caching on. Similarly, you can use the same attribute to turn off statement caching by setting the cache size to zero.</p>
</li>
<li>
<p>You can tag a statement at the release time so that the next time you can request a statement of the same tag. The tag is used to search the cache. An untagged statement (tag is <code>NULL</code>) is a special case of a tagged statement. Two statements are considered different if they differ in their tags, or if one is untagged and the other is not.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc001.htm#i575537">"Statement Functions"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#i428836">"Service Context Handle Attributes"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#i455080">"Session Pool Handle Attributes"</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACEDIHB"></a>
<div id="LNOCI18207" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1533"></a>Bind and Define Optimization in Statement Caching</h3>
<p>To avoid repeated bind and define operations on statements in the cache by the application, the application can register an opaque context with a statement taken from the statement cache and register a callback function with the service context. The application data such as bind and define buffers can be enclosed in the opaque context. This context is registered with the statement the first time it is taken from the cache. When a statement is taken from the cache the second time and onwards, the application can reuse the bind and define buffers, that it had registered with that statement. It is still the application's responsibility to manage the bind and defines. It can reuse both the bind and define data and the buffers, or it can change only the data and reuse the buffers, or it can free and reallocate the buffers if the current size is not enough. In the last case, it must rebind and redefine. To clean up the memory allocated by the application toward these bind and define buffers, the callback function is called during aging out of the statement or purging of the whole cache as part of session closure. The callback is called for every statement being purged. The application frees the memory and does any other cleanup required, inside the callback function. <a href="#CACJDEDA">Example 9-9</a> shows the pseudocode.</p>
<div id="LNOCI18208" class="example">
<p class="titleinexample"><a id="CACJDEDA"></a>Example 9-9 Optimizing Bind and Define Operations on Statements in the Cache</p>
<pre>
Get the statement using OCIStmtPrepare2(...)
 
Get the opaque context from the statement if it exists
 
If opaque context does not exist
 
{
 
  Allocate fetch buffers, do the OCIBindByPos, OCIDefineByPos, and so forth
 
  Enclose the buffer addresses inside a context and set the context and
  callback function on the statement
 
}
Execute/Fetch using the statement, and process the data in the fetch buffers. 
 
OCIStmtRelease() that statement
 
Next OCIStmtPrepare2()
 
OCIAttrGet() opaque application context from statement handle
 
Execute/Fetch using the statement and process the data in the fetch buffers.
 
OCIStmtRelease()
 
. . .
 
void callback_fn (context, statement, mode)
 
{
 
   /* mode= OCI_CBK_STMTCACHE_STMTPURGE means this was called when statement was
      aging out of the statement cache or if the session is ended */
 
  &lt;free the buffers in the context.&gt;
 
}
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#BAJIDBEG">"OCI_ATTR_STMTCACHE_CBKCTX"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#BAJDGBHB">"OCI_ATTR_STMTCACHE_CBK"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CACIIJAC"></a>
<div id="LNOCI16659" class="sect2">
<h3 class="sect2"><a id="sthref1534"></a>OCI Statement Caching Code Example</h3>
<p>See <code>cdemostc.c</code> in directory <code>demo</code> for a working example of statement caching.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i466264"></a>
<div id="LNOCI16660" class="sect1">
<h2 class="sect1">User-Defined Callback Functions in OCI<a id="sthref1535"></a><a id="sthref1536"></a></h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACJEHEA">Registering User Callbacks in OCI</a></p>
</li>
<li>
<p><a href="#i448018">OCI Callbacks from External Procedures</a></p>
</li>
</ul>
<p>Oracle Call Interface can execute user-specific code in addition to OCI calls. You can use this functionality for:</p>
<ul>
<li>
<p>Adding tracing and performance measurement code to enable users to tune their applications</p>
</li>
<li>
<p>Performing preprocessing or postprocessing code for specific OCI calls</p>
</li>
<li>
<p>Accessing other data sources with OCI by using the native OCI interface for Oracle Databases and directing the OCI calls to use user callbacks for non-Oracle data sources</p>
</li>
</ul>
<p>The OCI callback feature provides support for calling user code before or after executing the OCI calls. It also allows the user-defined code to be executed instead of executing the OCI code.</p>
<p>The user callback code can be registered dynamically without modifying the source code of the application. The dynamic registration is implemented by loading up to five user-created dynamically linked libraries after the initialization of the environment handle during the <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> call. These user-created libraries (such as dynamic-link libraries (DLLs) on Windows, or shared libraries on Solaris, register the user callbacks for the selected OCI calls transparently to the application.</p>
<p class="subhead1"><a id="LNOCI16661"></a>Sample Application</p>
<p>For a listing of the complete demonstration programs that illustrate the OCI user callback feature, see <a href="ociabdem.htm#g462659">Appendix B</a>.</p>
<a id="CACJEHEA"></a>
<div id="LNOCI16662" class="sect2">
<h3 class="sect2">Registering User Callbacks in OCI<a id="sthref1537"></a></h3>
<p><span class="bold"><a id="sthref1538"></a></span>An application can register user callback libraries with the <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> function. Callbacks are registered in the context of the environment handle. An application can retrieve information about callbacks registered with a handle with the <a href="oci17msc007.htm#i491405">OCIUserCallbackGet()</a> function.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc007.htm#i491405">"OCIUserCallbackGet()"</a> and <a href="oci17msc007.htm#i523285">"OCIUserCallbackRegister()"</a></div>
<p>A user-defined callback is a subroutine that is registered against an OCI call and an environment handle. It can be specified to be either an entry callback, a replacement callback, or an exit callback.</p>
<ul>
<li>
<p>If it is an entry callback, it is called when the program enters the OCI function.</p>
</li>
<li>
<p>Replacement callbacks are executed after entry callbacks. If the replacement callback returns a value of <code>OCI_CONTINUE</code>, then a subsequent replacement callback or the normal OCI-specific code is executed. If a replacement callback returns anything other than <code>OCI_CONTINUE</code>, then subsequent replacement callbacks and the OCI code do not execute.</p>
</li>
<li>
<p>After a replacement callback returns something other than <code>OCI_CONTINUE</code>, or an OCI function successfully executes, program control transfers to the exit callback (if one is registered).</p>
</li>
</ul>
<p>If a replacement or exit callback returns anything other than <code>OCI_CONTINUE</code>, then the return code from the callback is returned from the associated OCI call.</p>
<p>A user callback can return <code>OCI_INVALID_HANDLE</code> when either an invalid handle or an invalid context is passed to it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If any callback returns anything other than <code>OCI_CONTINUE</code>, then that return code is passed to the subsequent callbacks. If a replacement or exit callback returns a return code other than <code>OCI_CONTINUE</code>, then the final (not <code>OCI_CONTINUE</code>) return code is returned from the OCI call.</div>
<div id="LNOCI16663" class="sect3"><a id="sthref1539"></a>
<h4 class="sect3">OCIUserCallbackRegister</h4>
<p>A user callback is registered using the <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc007.htm#i523285">"OCIUserCallbackRegister()"</a></div>
<p>Currently, <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> is only registered on the environment handle. The user's callback function of typedef <code>OCIUserCallback</code> is registered along with its context for the OCI call identified by the OCI function code, <span class="italic">fcode</span>. The type of the callback, whether entry, replacement, or exit, is specified by the <span class="italic">when</span> parameter.</p>
<p>For example, the <code>stmtprep_entry_dyncbk_fn</code> entry callback function and its context <code>dynamic_context</code>, are registered against the environment handle <code>hndlp</code> for the <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> call by calling the <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> function with the following parameters.</p>
<pre>
OCIUserCallbackRegister( hndlp, 
                         OCI_HTYPE_ENV, 
                         errh, 
                         stmtprep_entry_dyncbk_fn, 
                         dynamic_context, 
                         OCI_FNCODE_STMTPREPARE,
                         OCI_UCBTYPE_ENTRY
                         (OCIUcb*) NULL);
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI16664" class="sect3"><a id="sthref1540"></a>
<h4 class="sect3">User Callback Function</h4>
<p>The user callback function must use the following syntax:</p>
<pre>
typedef sword (*OCIUserCallback)
     (void *ctxp,      /* context for the user callback*/
      void *hndlp,     /* handle for the callback, env handle for now */
      ub4 type,         /* type of handlp, OCI_HTYPE_ENV for this release */
      ub4 fcode,        /* function code of the OCI call */
      ub1 when,         /* type of the callback, entry or exit */
      sword returnCode, /* OCI return code */
      ub4 *errnop,      /* Oracle error number */
      va_list arglist); /* parameters of the oci call */
</pre>
<p>In addition to the parameters described in the <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> call, the callback is called with the return code, <span class="italic">errnop</span>, and all the parameters of the original OCI as declared by the prototype definition.</p>
<p>The return code is always passed in as <code>OCI_SUCCESS</code> and <code>*errnop</code> is always passed in as 0 for the first entry callback. Note that <code>*errnop</code> refers to the content of <code>errnop</code> because <code>errnop</code> is an IN/OUT parameter.</p>
<p>If the callback does not want to change the OCI return code, then it must return <code>OCI_CONTINUE</code>, and the value returned in <code>*errnop</code> is ignored. If, however, the callback returns any return code other than <code>OCI_CONTINUE</code>, the last returned return code becomes the return code for the call. At this point, the value returned for <code>*errnop</code> is set in the error handle, or in the environment handle if the error information is returned in the environment handle because of the absence of the error handle for certain OCI calls such as <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>.</p>
<p>For replacement callbacks, the <code>returnCode</code> is the non-<code>OCI_CONTINUE</code> return code from the previous callback or OCI call, and <code>*errnop</code> is the value of the error number being returned in the error handle. This allows the subsequent callback to change the return code or error information if needed.</p>
<p>The processing of replacement callbacks is different in that if it returns anything other than <code>OCI_CONTINUE</code>, then subsequent replacement callbacks and OCI code are bypassed and processing jumps to the exit callbacks.</p>
<p>Note that if the replacement callbacks return <code>OCI_CONTINUE</code> to allow processing of OCI code, then the return code from entry callbacks is ignored.</p>
<p>All the original parameters of the OCI call are passed to the callback as variable parameters, and the callback must retrieve them using the <span class="italic">va_arg</span> macros. The callback demonstration programs provide examples.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociabdem.htm#g462659">Appendix B, "OCI Demonstration Programs"</a></div>
<p>A null value can be registered to deregister a callback. That is, if the value of the callback (<code>OCIUserCallback()</code>) is <code>NULL</code> in the <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> call, then the user callback is deregistered.</p>
<p>When using the thread-safe mode, the OCI program acquires all mutexes before calling the user callbacks.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16665" class="sect3"><a id="sthref1541"></a>
<h4 class="sect3">User Callback Control Flow</h4>
<p><a href="#CACJAFAG">Example 9-10</a> shows pseudocode that describes the overall processing of a typical OCI call.</p>
<div id="LNOCI18209" class="example">
<p class="titleinexample"><a id="CACJAFAG"></a>Example 9-10 Pseudocode That Describes the Overall Processing of a Typical OCI Call</p>
<pre>
OCIXyzCall()
{
 Acquire mutexes on handles;
 retCode = OCI_SUCCESS;
 errno = 0;
 for all ENTRY callbacks do
  {
     
     EntryretCode = (*entryCallback)(..., retcode, &amp;errno, ...);
     if (retCode != OCI_CONTINUE)
      {
         set errno in error handle or environment handle;
         retCode = EntryretCode;
       }
   }
  for all REPLACEMENT callbacks do
  {
   retCode = (*replacementCallback) (..., retcode, &amp;errno, ...);
   if (retCode != OCI_CONTINUE)
      {
       set errno in error handle or environment handle
       goto executeEXITCallback;
       }
   }

   retCode = return code for XyzCall; /* normal processing of OCI call */

   errno = error number from error handle or env handle;

 executeExitCallback:
   for all EXIT callbacks do
   {
       exitRetCode = (*exitCallback)(..., retCode, &amp;errno,...);
       if (exitRetCode != OCI_CONTINUE)
       {
           set errno in error handle or environment handle;
           retCode = exitRetCode;
       }
   }
    release mutexes;
    return retCode
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16666" class="sect3"><a id="sthref1542"></a>
<h4 class="sect3">User Callback for OCIErrorGet()</h4>
<p>If the callbacks are a total replacement of the OCI code, then they usually maintain their own error information in the call context and use that to return error information in <code>bufp</code> and <code>errcodep</code> parameters of the replacement callback of the <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> call.</p>
<p>If, however, the callbacks are either partially overriding OCI code, or just doing some other postprocessing, then they can use the exit callback to modify the error text and <code>errcodep</code> parameters of the <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> call by their own error message and error number. Note that the <code>*errnop</code> passed into the exit callback is the error number in the error or the environment handle.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16667" class="sect3"><a id="sthref1543"></a>
<h4 class="sect3">Errors from Entry Callbacks</h4>
<p>If an entry callback wants to return an error to the caller of the OCI call, then it must register a replacement or exit callback. This is because if the OCI code is executed, then the error code from the entry callback is ignored. Therefore, the entry callback must pass the error to the replacement or exit callback through its own context.</p>
</div>
<!-- class="sect3" -->
<a id="i449022"></a>
<div id="LNOCI16668" class="sect3">
<h4 class="sect3">Dynamic Callback Registrations<a id="sthref1544"></a></h4>
<p>Because user callbacks are expected to be used for monitoring OCI behavior or to access other data sources, it is desirable that the registration of the callbacks be done transparently and nonintrusively. This is accomplished by loading user-created dynamically linked libraries at OCI initialization time. These dynamically linked libraries are called <span class="italic">packages</span>. The user-created packages register the user callbacks for the selected OCI calls. These callbacks can further register or deregister user callbacks as needed when receiving control at runtime.</p>
<p>A makefile (<code>ociucb.mk</code> on Solaris) is provided with the OCI demonstration programs to create the package. The exact naming and location of this package is operating system-dependent. The source code for the package must provide code for special callbacks that are called at OCI initialization and environment creation times.</p>
<p>Setting an operating system environment variable, <code>ORA_OCI_UCBPKG</code>, controls the loading of the package. This variable names the packages in a generic way. The packages must be located in the <code>$ORACLE_HOME/lib</code> directory.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16669" class="sect3"><a id="sthref1545"></a>
<h4 class="sect3">Loading Multiple Packages</h4>
<p>The <code>ORA_OCI_UCBPKG</code> variable can contain a semicolon-separated list of package names. The packages are loaded in the order they are specified in the list.</p>
<p>For example, in the past the package was specified as:</p>
<pre>
setenv ORA_OCI_UCBPKG mypkg
</pre>
<p>Currently, you can still specify the package as before, but in addition multiple packages can be specified as:</p>
<pre>
setenv ORA_OCI_UCBPKG "mypkg;yourpkg;oraclepkg;sunpkg;msoftpkg"
</pre>
<p>All these packages are loaded in order. That is, <code>mypkg</code> is loaded first and <code>msoftpkg</code> is loaded last.</p>
<p>A maximum of five packages can be specified.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The sample makefile <code>ociucb.mk</code> creates <code>ociucb.so.1.0</code> on a Solaris or <code>ociucb.dll</code> on a Windows system. To load the <code>ociucb</code> package, the environmental variable <code>ORA_OCI_UCBPKG</code> must be set to <code>ociucb</code>. On Solaris, if the package name ends with <code>.so</code>, <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> fails. The package name must end with <code>.so.1.0</code>.
<p>For further details about creating the dynamic-link libraries, read the Makefiles provided in the demo directory for your operating system. For further information about user-defined callbacks, see your operating system-specific documentation on compiling and linking applications.</p>
</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16670" class="sect3"><a id="sthref1546"></a>
<h4 class="sect3">Package Format</h4>
<p>In the past, a package had to specify the source code for the <code>OCIEnvCallback()</code> function. However, the <code>OCIEnvCallback()</code> function is obsolete. Instead, the package source must provide two functions. The first function must be named as <span class="italic">packagename</span> suffixed with the word <span class="italic">Init</span>. For example, if the package is named <code>foo</code>, then the source file (for example, but not necessarily, foo.c) must contain a <code>fooInit()</code> function with a call to <code>OCISharedLibInit()</code> function specified exactly as:</p>
<pre>
sword fooInit(metaCtx, libCtx, argfmt, argc, argv)
      void *     metaCtx;         /* The metacontext */
      void *     libCtx;          /* The context for this package. */
      ub4        argfmt;          /* package argument format */
      sword      argc;            /* package arg count*/
      void *     argv[];          /* package arguments */
{
  return  (OCISharedLibInit(metaCtx, libCtx, argfmt, argc, argv,
                            fooEnvCallback));
}
</pre>
<p>The last parameter of the <code>OCISharedLibInit()</code> function, <code>fooEnvCallback()</code> in this case, is the name of the second function. It can be named anything, but by convention it is named <span class="italic">packagename</span> suffixed with the word <span class="italic">EnvCallback</span>.</p>
<p>This function is a replacement for <code>OCIEnvCallback()</code>. Currently, all the dynamic user callbacks must be registered in this function. The function must be of type <code>OCIEnvCallbackType</code>, which is specified as:</p>
<pre>
typedef sword (*OCIEnvCallbackType)(OCIEnv *env, ub4 mode,
                                    size_t xtramem_sz, void *usrmemp,
                                    OCIUcb *ucbDesc);
</pre>
<p>When an environment handle is created, then this callback function is called at the very end. The <code>env</code> parameter is the newly created environment handle.</p>
<p>The <code>mode</code>, <code>xtramem_sz</code>, and <code>usrmempp</code> are the parameters passed to the <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> call. The last parameter, <code>ucbDesc</code>, is a descriptor that is passed to the package. The package uses this descriptor to register the user callbacks as described later.</p>
<p>A sample <code>ociucb.c</code> file is provided in the <code>demo</code> directory. The makefile <code>ociucb.mk</code> is also provided (on Solaris) in the <code>demo</code> directory to create the package. Please note that this may be different on other operating systems. The <code>demo</code> directory also contains full user callback demo programs (<code>cdemoucb.c, cdemoucbl.c</code>) illustrating this.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16671" class="sect3"><a id="sthref1547"></a>
<h4 class="sect3">User Callback Chaining</h4>
<p>User callbacks can be registered statically in the application itself or dynamically at runtime in the DLLs. A mechanism is needed to allow the application to override a previously registered callback and then later invoke the overridden one in the newly registered callback to preserve the behavior intended by the dynamic registrations. This can result in chaining of user callbacks.</p>
<p>The <a href="oci17msc007.htm#i491405">OCIUserCallbackGet()</a> function determines which function and context is registered for an OCI call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc007.htm#i491405">"OCIUserCallbackGet()"</a></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16672" class="sect3"><a id="sthref1548"></a>
<h4 class="sect3">Accessing Other Data Sources Through OCI</h4>
<p>Because Oracle Database is the predominant database software accessed, applications can take advantage of the OCI interface to access non-Oracle data by using the user callbacks to access them. This allows an application written in OCI to access Oracle data without any performance penalty. Drivers can be written that access the non-Oracle data in user callbacks. Because OCI provides a very rich interface, there is usually a straightforward mapping of OCI calls to most data sources. This solution is better than writing applications for other middle layers such as ODBC that introduce performance penalties for all data sources. Using OCI does not incur any penalty to access Oracle data sources, and incurs the same penalty that ODBC does for non-Oracle data sources.</p>
</div>
<!-- class="sect3" -->
<a id="i448855"></a>
<div id="LNOCI16673" class="sect3">
<h4 class="sect3">Restrictions on Callback Functions<a id="sthref1549"></a></h4>
<p>There are certain restrictions on the usage of callback functions, including <code>OCIEnvCallback()</code>:</p>
<ul>
<li>
<p>A callback cannot call other OCI functions except <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a>, <a href="oci17msc007.htm#i491405">OCIUserCallbackGet()</a>, <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>, and <a href="oci16rel002.htm#i540911">OCIHandleFree()</a>. Even for these functions, if they are called in a user callback, then callbacks on them are not called to avoid recursion. For example, if <code>OCIHandleFree()</code> is called in the callback for <a href="oci16rel001.htm#i556437">OCILogoff()</a>, then the callback for <code>OCIHandleFree()</code> is disabled during the execution of the callback for <code>OCILogoff()</code>.</p>
</li>
<li>
<p>A callback cannot modify OCI data structures such as the environment or error handles.</p>
</li>
<li>
<p>A callback cannot be registered for the <a href="oci17msc007.htm#i523285">OCIUserCallbackRegister()</a> call itself, or for any of the following calls:</p>
<ul>
<li>
<p><a href="oci17msc007.htm#i491405">OCIUserCallbackGet()</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#i556149">OCIEnvCreate()</a></p>
</li>
<li>
<p><a href="ociaedep001.htm#i556330">OCIInitialize()</a> (Deprecated)</p>
</li>
<li>
<p><a href="oci16rel001.htm#i556149">OCIEnvCreate()</a></p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16674" class="sect3"><a id="sthref1550"></a>
<h4 class="sect3">Example of OCI Callbacks</h4>
<p>Suppose that there are five packages each registering entry, replacement, and exit callbacks for the <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> call. That is, the <code>ORA_OCI_UCBPKG</code> variable is set as shown in <a href="#CACBICBD">Example 9-11</a>.</p>
<div id="LNOCI18210" class="example">
<p class="titleinexample"><a id="CACBICBD"></a>Example 9-11 Environment Variable Setting for the ORA_OCI_UCBPKG Variable</p>
<pre>
setenv ORA_OCI_UCBPKG "pkg1;pkg2;pkg3;pkg4;pkg5" 
</pre></div>
<!-- class="example" -->
<p>In each package <code>pkgN</code> (where N can be 1 through 5), the <code>pkgNInit()</code> and <code>PkgNEnvCallback()</code> functions are specified, as shown in <a href="#CACJEBJF">Example 9-12</a>.</p>
<div id="LNOCI18211" class="example">
<p class="titleinexample"><a id="CACJEBJF"></a>Example 9-12 Specifying the pkgNInit() and PkgNEnvCallback() Functions</p>
<pre>
pkgNInit(void *metaCtx, void *libCtx, ub4 argfmt, sword argc, void **argv)
{
  return OCISharedLibInit(metaCtx, libCtx, argfmt, argc, argv, pkgNEnvCallback);
}
</pre></div>
<!-- class="example" -->
<p><a href="#CACDFCCC">Example 9-13</a> shows how the <code>pkgNEnvCallback()</code> function registers the entry, replacement, and exit callbacks.</p>
<div id="LNOCI18212" class="example">
<p class="titleinexample"><a id="CACDFCCC"></a>Example 9-13 Using pkgNEnvCallback() to Register Entry, Replacement, and Exit Callbacks</p>
<pre>
pkgNEnvCallback(OCIEnv *env, ub4 mode, size_t xtramemsz,
                                void *usrmemp, OCIUcb *ucbDesc)
{
  OCIHandleAlloc((void *)env, (void **)&amp;errh, OCI_HTYPE_ERROR, (size_t) 0,
        (void **)NULL);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, pkgN_entry_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_ENTRY, ucbDesc);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, pkgN_replace_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_REPLACE, ucbDesc);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, pkgN_exit_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_EXIT, ucbDesc);

  return OCI_CONTINUE;
}
 
</pre></div>
<!-- class="example" -->
<p>Finally, <a href="#CACBJDFA">Example 9-14</a> shows how in the source code for the application, user callbacks can be registered with the <code>NULL</code> <span class="italic">ucbDesc</span>.</p>
<div id="LNOCI18213" class="example">
<p class="titleinexample"><a id="CACBJDFA"></a>Example 9-14 Registering User Callbacks with the NULL ucbDesc</p>
<pre>
  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, static_entry_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_ENTRY, (OCIUcb *)NULL);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, static_replace_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_REPLACE, (OCIUcb *)NULL);

  OCIUserCallbackRegister(env, OCI_HTYPE_ENV, errh, static_exit_callback_fn,
        pkgNctx, OCI_FNCODE_STMTPREPARE, OCI_UCBTYPE_EXIT, (OCIUcb *)NULL);
 
</pre></div>
<!-- class="example" -->
<p><a href="#CACJHCID">Example 9-15</a> shows that when the <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> call is executed, the callbacks are called in the following order.</p>
<div id="LNOCI18214" class="example">
<p class="titleinexample"><a id="CACJHCID"></a>Example 9-15 Using the OCIStmtPrepare() Call to Call the Callbacks in Order</p>
<pre>
static_entry_callback_fn() 
pkg1_entry_callback_fn() 
pkg2_entry_callback_fn() 
pkg3_entry_callback_fn() 
pkg4_entry_callback_fn() 
pkg5_entry_callback_fn() 
 
static_replace_callback_fn() 
 pkg1_replace_callback_fn() 
  pkg2_replace_callback_fn() 
   pkg3_replace_callback_fn() 
    pkg4_replace_callback_fn() 
     pkg5_replace_callback_fn() 
 
      OCI code for OCIStmtPrepare call 
 
pkg5_exit_callback_fn() 
pkg4_exit_callback_fn() 
pkg3_exit_callback_fn() 
pkg2_exit_callback_fn() 
pkg1_exit_callback_fn()

static_exit_callback_fn()
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The exit callbacks are called in the reverse order of the entry and replacement callbacks.</div>
<p>The entry and exit callbacks can return any return code and the processing continues to the next callback. However, if the replacement callback returns anything other than <code>OCI_CONTINUE</code>, then the next callback (or OCI code if it is the last replacement callback) in the chain is bypassed and processing jumps to the exit callback. For example, if <code>pkg3_replace_callback_fn()</code> returned <code>OCI_SUCCESS</code>, then <code>pkg4_replace_callback_fn()</code>, <code>pkg5_replace_callback_fn()</code>, and the OCI processing for the <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> call are bypassed. Instead, <code>pkg5_exit_callback_fn()</code> is executed next.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i448018"></a>
<div id="LNOCI16675" class="sect2">
<h3 class="sect2">OCI Callbacks from External Procedures<a id="sthref1551"></a><a id="sthref1552"></a></h3>
<p>There are several OCI functions that you can use as callbacks from external procedures. These functions are listed in <a href="oci20ext.htm#i442542">Chapter 20</a>. For information about writing C subroutines that can be called from PL/SQL code, including a list of which OCI calls you can use and some example code, see <a class="olink ADFNS010" href="../../appdev.112/e41502/adfns_externproc.htm#ADFNS010"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449791"></a>
<div id="LNOCI16679" class="sect1">
<h2 class="sect1">Transparent Application Failover in OCI<a id="sthref1553"></a><a id="sthref1554"></a><a id="sthref1555"></a></h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACEJFAF">Configuring Transparent Application Failover</a></p>
</li>
<li>
<p><a href="#CACDAACB">Transparent Application Failover Callbacks in OCI</a></p>
</li>
<li>
<p><a href="#CACDHAFE">Failover Callback Structure and Parameters</a></p>
</li>
<li>
<p><a href="#CACEGHDJ">Failover Callback Registration</a></p>
</li>
<li>
<p><a href="#i429213">Failover Callback Example</a></p>
</li>
<li>
<p><a href="#i468318">Handling OCI_FO_ERROR</a></p>
</li>
</ul>
<p>Transparent application failover (TAF) is a client-side feature designed to minimize disruptions to end-user applications that occur when database connectivity fails because of instance or network failure. TAF can be implemented on a variety of system configurations including Oracle Real Application Clusters (Oracle RAC) and Oracle Data Guard physical standby databases. TAF can also be used after restarting a single instance system (for example, when repairs are made).</p>
<p>TAF can be configured to restore database sessions and, optionally, to replay open queries. Prior to Oracle Database 10g Release 2 (10.2), TAF with the <code>SELECT</code> failover option would be engaged only on the statement that was in use at the time of a failure. For example, if there were 10 statement handles in use by the application, and statement 7 was the failure-time statement (the statement in use when the failure happened), statements 1 through 6 and 8 through 10 would have to be reexecuted after statement 7 was failed over using TAF.</p>
<p>Starting with Oracle Database 10g Release 2 (10.2), this has been improved. Now all statements that an application attempts to use after a failure attempt failover. That is, an attempt to execute or fetch against other statements engages TAF recovery just as for the failure-time statement. Subsequent statements may now succeed (whereas in the past they failed), or the application may receive errors corresponding to an attempted TAF recovery (such as <code>ORA-25401</code>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
TAF is not supported for remote database links or for DML statements.</div>
<a id="CACEJFAF"></a>
<div id="LNOCI16680" class="sect2">
<h3 class="sect2">Configuring Transparent Application Failover</h3>
<p>TAF can be configured on both the client side and the server side. If both are configured, server-side settings take precedence.</p>
<p>Configure TAF on the client side by including the <code>FAILOVER_MODE</code> parameter in the <code>CONNECT_DATA</code> portion of a connect descriptor.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NETRF279" href="../../network.112/e10835/tnsnames.htm#NETRF279"><span class="italic">Oracle Database Net Services Reference</span></a> for more information about client-side configuration of TAF (Connect Data Section)</div>
<p>Configure TAF on the server side by modifying the target service with the <code>DBMS_SERVICE.MODIFY_SERVICE</code> packaged procedure.</p>
<p>An initial attempt at failover may not always succeed. OCI provides a mechanism for retrying failover after an unsuccessful attempt.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS092" href="../../appdev.112/e40758/d_serv.htm#ARPLS092"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the server-side configuration of TAF (DBMS_SERVICE)</div>
</div>
<!-- class="sect2" -->
<a id="CACDAACB"></a>
<div id="LNOCI16681" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Transparent Application Failover Callbacks in OCI</h3>
<p>Because of the delay that can occur during failover, the application developer may want to inform the user that failover is in progress, and request that the user wait for notification that failover is complete. Additionally, the session on the initial instance may have received some <code>ALTER</code> <code>SESSION</code> commands. These <code>ALTER</code> <code>SESSION</code> commands are not automatically replayed on the second instance. Consequently, the developer may want to replay them on the second instance. <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> calls that affect the session must also be reexecuted.</p>
<p>To accommodate these requirements, the application developer can register a failover callback function. If failover occurs, the callback function is invoked several times while reestablishing the user's session.</p>
<p>The first call to the callback function occurs when the database first detects an instance connection loss. This callback is intended to allow the application to inform the user of an upcoming delay. If failover is successful, a second call to the callback function occurs when the connection is reestablished and usable.</p>
<p>Once the connection has been reestablished, the client may want to replay <code>ALTER</code> <code>SESSION</code> commands and inform the user that failover has happened. If failover is unsuccessful, then the callback is called to inform the application that failover cannot occur. Additionally, the callback is called each time a user handle besides the primary handle is reauthenticated on the new connection. Because each user handle represents a server-side session, the client may want to replay <code>ALTER</code> <code>SESSION</code> commands for that session.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i468318">"Handling OCI_FO_ERROR"</a> for more information about this scenario</div>
</div>
<!-- class="sect2" -->
<a id="CACDHAFE"></a>
<div id="LNOCI16682" class="sect2">
<h3 class="sect2"><a id="sthref1556"></a>Failover Callback Structure and Parameters</h3>
<p>The basic structure of a user-defined application failover callback function is as follows:</p>
<pre>
sb4 appfocallback_fn ( void       * svchp, 
                       void       * envhp, 
                       void       * fo_ctx, 
                       ub4        fo_type, 
                       ub4        fo_event );
</pre>
<p>An example is provided in <a href="#i429213">"Failover Callback Example"</a> for the following parameters:</p>
<a id="i463279"></a>
<dl>
<dt>svchp</dt>
<dd>
<p>The first parameter, <code>svchp</code>, is the service context handle. It is of type <code>void *</code>.</p>
</dd>
<dt>envhp</dt>
<dd>
<p>The second parameter, <code>envhp</code>, is the OCI environment handle. It is of type <code>void *</code>.</p>
</dd>
<dt>fo_ctx</dt>
<dd>
<p>The third parameter, <code>fo_ctx</code>, is a client context. It is a pointer to memory specified by the client. In this area the client can keep any necessary state or context. It is passed as a <code>void *</code>.</p>
</dd>
<dt>fo_type</dt>
<dd>
<p>The fourth parameter, <code>fo_type</code>, is the failover type. This lets the callback know what type of failover the client has requested. The usual values are as follows:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_FO_SESSION</code> indicates that the user has requested only session failover.</p>
</li>
<li>
<p><code>OCI_FO_SELECT</code> indicates that the user has requested select failover as well.</p>
</li>
</ul>
<dl>
<dt>fo_event</dt>
<dd>
<p>The last parameter is the failover event. This indicates to the callback why it is being called. It has several possible values:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_FO_BEGIN</code> indicates that failover has detected a lost connection and failover is starting.</p>
</li>
<li>
<p><code>OCI_FO_END</code> indicates successful completion of failover.</p>
</li>
<li>
<p><code>OCI_FO_ABORT</code> indicates that failover was unsuccessful, and there is no option of retrying.</p>
</li>
<li>
<p><code>OCI_FO_ERROR</code> also indicates that failover was unsuccessful, but it gives the application the opportunity to handle the error and retry failover.</p>
</li>
<li>
<p><code>OCI_FO_REAUTH</code> indicates that you have multiple authentication handles and failover has occurred after the original authentication. It indicates that a user handle has been reauthenticated. To determine which one, the application checks the <code>OCI_ATTR_SESSION</code> attribute of the service context handle (which is the first parameter).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACEGHDJ"></a>
<div id="LNOCI16683" class="sect2">
<h3 class="sect2">Failover Callback Registration<a id="sthref1557"></a><a id="sthref1558"></a></h3>
<p>For the failover callback to be used, it must be registered on the server context handle. This registration is done by creating a callback definition structure and setting the <code>OCI_ATTR_FOCBK</code> attribute of the server handle to this structure.</p>
<p>The callback definition structure must be of type <code>OCIFocbkStruct</code>. It has two fields: <code>callback_function</code>, which contains the address of the function to call, and <code>fo_ctx</code>, which contains the address of the client context.</p>
<p>An example of callback registration is included as part of <a href="#CACDAEEJ">Example 9-17</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i429213"></a>
<div id="LNOCI16684" class="sect2">
<h3 class="sect2">Failover Callback Example<a id="sthref1559"></a></h3>
<p>This section shows an example of a simple user-defined callback function definition (see <a href="#CACJJHGH">Example 9-16</a>), failover callback registration (see <a href="#CACDAEEJ">Example 9-17</a>), and failover callback unregistration (see <a href="#CACDJGDG">Example 9-18</a>).</p>
<div id="LNOCI18215" class="example">
<p class="titleinexample"><a id="CACJJHGH"></a>Example 9-16 User-Defined Failover Callback Function Definition</p>
<pre>
sb4  callback_fn(svchp, envhp, fo_ctx, fo_type, fo_event)
void * svchp;
void * envhp;
void *fo_ctx;
ub4 fo_type;
ub4 fo_event;
{
switch (fo_event) 
   {
   case OCI_FO_BEGIN:
   {
     printf(" Failing Over ... Please stand by \n");
     printf(" Failover type was found to be %s \n",
                     ((fo_type==OCI_FO_SESSION) ? "SESSION" 
                     :(fo_type==OCI_FO_SELECT) ? "SELECT"
                     : "UNKNOWN!")); 
     printf(" Failover Context is :%s\n", 
                    (fo_ctx?(char *)fo_ctx:"NULL POINTER!"));
     break;
   }
   case OCI_FO_ABORT:
   {
     printf(" Failover stopped. Failover will not occur.\n");
     break;
   }
   case    OCI_FO_END:
   {
       printf(" Failover ended ...resuming services\n");
     break;
   }
   case OCI_FO_REAUTH:
   {
       printf(" Failed over user. Resuming services\n");
     break;
   }
   default:
   {
     printf("Bad Failover Event: %d.\n",  fo_event);
     break;
   }
   }
   return 0;
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18216" class="example">
<p class="titleinexample"><a id="CACDAEEJ"></a>Example 9-17 Failover Callback Registration</p>
<pre>
int register_callback(srvh, errh)
void *srvh; /* the server handle */
OCIError *errh; /* the error handle */
{
  OCIFocbkStruct failover;                 /*  failover callback structure */
  /* allocate memory for context */
  if (!(failover.fo_ctx = (void *)malloc(strlen("my context.")+1)))
     return(1);
  /* initialize the context. */
  strcpy((char *)failover.fo_ctx, "my context.");
  failover.callback_function = &amp;callback_fn;
  /* do the registration */
  if (OCIAttrSet(srvh, (ub4) OCI_HTYPE_SERVER,
                (void *) &amp;failover, (ub4) 0,
                (ub4) OCI_ATTR_FOCBK, errh)  != OCI_SUCCESS)
     return(2);
  /* successful conclusion */
  return (0);
}
</pre></div>
<!-- class="example" -->
<div id="LNOCI18217" class="example">
<p class="titleinexample"><a id="CACDJGDG"></a>Example 9-18 Failover Callback Unregistration</p>
<pre>
OCIFocbkStruct failover;   /*  failover callback structure */
sword status;
 
  /* set the failover context to null */
  failover.fo_ctx = NULL; 
  /* set the failover callback to null */ 
  failover.callback_function = NULL; 
  /* unregister the callback */
  status = OCIAttrSet(srvhp, (ub4) OCI_HTYPE_SERVER,
                      (void *) &amp;failover, (ub4) 0,
                      (ub4) OCI_ATTR_FOCBK, errhp);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i468318"></a>
<div id="LNOCI16688" class="sect2">
<h3 class="sect2">Handling OCI_FO_ERROR</h3>
<p>A failover attempt is not always successful. If the attempt fails, the callback function receives a value of <code>OCI_FO_ABORT</code> or <code>OCI_FO_ERROR</code> in the <code>fo_event</code> parameter. A value of <code>OCI_FO_ABORT</code> indicates that failover was unsuccessful, and no further failover attempts are possible. <code>OCI_FO_ERROR</code>, however, provides the callback function with the opportunity to handle the error. For example, the callback may choose to wait a specified period of time and then indicate to the OCI library that it must reattempt failover.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This functionality is only available to applications linked with the 8.0.5 or later OCI libraries running against any Oracle Database server.
<p><a id="sthref1560"></a>Failover does not work if a LOB column is part of the select list.</p>
</div>
<p>Consider the timeline of events presented in <a href="#CACEHAGA">Table 9-2</a>.</p>
<div id="LNOCI16689" class="tblformal">
<p class="titleintable"><a id="sthref1561"></a><a id="CACEHAGA"></a>Table 9-2 Time and Event</p>
<table class="cellalignment1016" title="Time and Event" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t45">Time</th>
<th class="cellalignment1012" id="r1c2-t45">Event</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t45" headers="r1c1-t45">
<p>T0</p>
</td>
<td class="cellalignment1013" headers="r2c1-t45 r1c2-t45">
<p>Database fails (failure lasts until T5).</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t45" headers="r1c1-t45">
<p>T1</p>
</td>
<td class="cellalignment1013" headers="r3c1-t45 r1c2-t45">
<p>Failover is triggered by user activity.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t45" headers="r1c1-t45">
<p>T2</p>
</td>
<td class="cellalignment1013" headers="r4c1-t45 r1c2-t45">
<p>User attempts to reconnect; attempt fails.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t45" headers="r1c1-t45">
<p>T3</p>
</td>
<td class="cellalignment1013" headers="r5c1-t45 r1c2-t45">
<p>Failover callback is invoked with <code>OCI_FO_ERROR</code>.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t45" headers="r1c1-t45">
<p>T4</p>
</td>
<td class="cellalignment1013" headers="r6c1-t45 r1c2-t45">
<p>Failover callback enters a predetermined sleep period.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t45" headers="r1c1-t45">
<p>T5</p>
</td>
<td class="cellalignment1013" headers="r7c1-t45 r1c2-t45">
<p>Database comes back up again.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t45" headers="r1c1-t45">
<p>T6</p>
</td>
<td class="cellalignment1013" headers="r8c1-t45 r1c2-t45">
<p>Failover callback triggers a new failover attempt; it is successful.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t45" headers="r1c1-t45">
<p>T7</p>
</td>
<td class="cellalignment1013" headers="r9c1-t45 r1c2-t45">
<p>User successfully reconnects.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The callback function triggers the new failover attempt by returning a value of <code>OCI_FO_RETRY</code> from the function.</p>
<p><a href="#CACFEBEJ">Example 9-19</a> shows a callback function that you can use to implement the failover strategy similar to the scenario described earlier. In this case, the failover callback enters a loop in which it sleeps and then reattempts failover until it is successful:</p>
<div id="LNOCI18218" class="example">
<p class="titleinexample"><a id="CACFEBEJ"></a>Example 9-19 Callback Function That Implements a Failover Strategy</p>
<pre>
/*--------------------------------------------------------------------*/
/* the user-defined failover callback  */
/*--------------------------------------------------------------------*/
sb4  callback_fn(svchp, envhp, fo_ctx, fo_type, fo_event )
void * svchp;
void * envhp;
void *fo_ctx;
ub4 fo_type;
ub4 fo_event;
{
   OCIError *errhp;
   OCIHandleAlloc(envhp, (void **)&amp;errhp, (ub4) OCI_HTYPE_ERROR,
              (size_t) 0, (void **) 0);
   switch (fo_event) 
   {
   case OCI_FO_BEGIN:
   {
     printf(" Failing Over ... Please stand by \n");
     printf(" Failover type was found to be %s \n",
            ((fo_type==OCI_FO_NONE) ? "NONE"
             :(fo_type==OCI_FO_SESSION) ? "SESSION" 
             :(fo_type==OCI_FO_SELECT) ? "SELECT"
             :(fo_type==OCI_FO_TXNAL) ? "TRANSACTION"
             : "UNKNOWN!")); 
     printf(" Failover Context is :%s\n", 
            (fo_ctx?(char *)fo_ctx:"NULL POINTER!"));
     break;
   }
   case OCI_FO_ABORT:
   {
     printf(" Failover aborted. Failover will not occur.\n");
     break;
   }
   case    OCI_FO_END:
   { 
       printf("\n Failover ended ...resuming services\n");
     break;
   }
   case OCI_FO_REAUTH:
   { 
       printf(" Failed over user. Resuming services\n");
     break;
   }
   case OCI_FO_ERROR:
   {
     /* all invocations of this can only generate one line. The newline
      * will be put at fo_end time.
      */
     printf(" Failover error gotten. Sleeping...");
     sleep(3);
     printf("Retrying. ");
     return (OCI_FO_RETRY);
     break;
   }
   default:
   {
     printf("Bad Failover Event: %d.\n",  fo_event);
     break;
   }
   }
   return 0;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJGDCEFG"></a>
<div id="LNOCI093" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">HA Event Notification<a id="sthref1562"></a></h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACCACHJ">OCIEvent Handle</a></p>
</li>
<li>
<p><a href="#CACECDCI">OCI Failover for Connection and Session Pools</a></p>
</li>
<li>
<p><a href="#CACIDHJH">OCI Failover for Independent Connections</a></p>
</li>
<li>
<p><a href="#CACJGHFF">Event Callback</a></p>
</li>
<li>
<p><a href="#CJGBJIAB">Custom Pooling: Tagged Server Handles</a></p>
</li>
<li>
<p><a href="#CACIFIAG">Determining Transparent Application Failover (TAF) Capabilities</a></p>
</li>
</ul>
<p>Suppose that a user employs a web browser to log in to an application server that accesses a back-end database server. Failure of the database instance can result in a wait that can be up to minutes in duration before the failure is known to the user. The ability to quickly detect failures of server instances, communicate this to the client, close connections, and clean up idle connections in connection pools is provided by HA event notification.</p>
<p>For high availability clients connected to an Oracle RAC database, you can use HA event notification to provide a best-effort programmatic signal to the client if there is a database failure. Client applications can register a callback on the environment handle to signal interest in this information. When a significant failure event occurs that applies to a connection made by this client, the callback is invoked, with information concerning the event (the event payload) and a list of connections (server handles) that were disconnected because of the failure.</p>
<p>For example, consider a client application that has two connections to instance A and two connections to instance B of the same database. If instance A goes down, a notification of the event is sent to the client, which then disconnects the two connections to instance B and invokes the registered callback. Note that if another instance C of the same database goes down, the client is not notified (because it does not affect any of the client's connections).</p>
<p>The HA event notification mechanism improves the response time of the application in the presence of failure. Before the mechanism was introduced in Oracle Database 10g Release 2 (10.2), a failure would result in the connection being broken only after the TCP timeout interval expired, which could take minutes. With HA event notification, the standalone, connection pool, and session pool connections are automatically broken and cleaned up by OCI, and the application callback is invoked within seconds of the failure event. If any of these server handles are TAF-enabled, failover is also automatically engaged by OCI.</p>
<p>Applications must connect to an Oracle RAC instance to enable HA event notification. Furthermore, these applications must:</p>
<ul>
<li>
<p>Initialize the OCI Environment in <code>OCI_EVENTS</code> mode</p>
</li>
<li>
<p>Connect to a service that has notifications enabled (use the <code>DBMS_SERVICE.MODIFY_SERVICE</code> procedure to set <code>AQ_HA_NOTIFICATIONS</code> to <code>TRUE</code>)</p>
</li>
<li>
<p>Link with a thread library</p>
</li>
</ul>
<p>Then these applications can register a callback that is invoked whenever an HA event occurs.</p>
<a id="CACCACHJ"></a>
<div id="LNOCI16690" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">OCIEvent Handle</h3>
<p>The <a id="sthref1563"></a><code>OCIEvent</code> handle encapsulates the attributes from the event payload. OCI implicitly allocates this handle before calling the event callback, which can obtain the read-only attributes of the event by calling <code>OCIAttrGet()</code>. Memory associated with these attributes is only valid for the duration of the event callback.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJCEDGJ">"Event Handle Attributes"</a></div>
</div>
<!-- class="sect2" -->
<a id="CACECDCI"></a>
<div id="LNOCI16691" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">OCI Failover for Connection and Session Pools</h3>
<p>A connection pool in an instance of Oracle RAC consists of a pool of connections connected to different instances of Oracle RAC. Upon receiving the node failure notification, all the connections connected to that particular instance should be cleaned up. For the connections that are in use, OCI must close the connections: transparent application failover (TAF) occurs immediately, and those connections are reestablished. The connections that are idle and in the free list of the pool must be purged, so that a bad connection is never returned to the user from the pool.</p>
<p>To accommodate custom connection pools, OCI provides a callback function that can be registered on the environment handle. If registered, this callback is invoked when an HA event occurs. Session pools are treated the same way as connection pools. Note that server handles from OCI connection pools or session pools are not passed to the callback. Hence in some cases, the callback could be called with an empty list of connections.</p>
</div>
<!-- class="sect2" -->
<a id="CACIDHJH"></a>
<div id="LNOCI16692" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">OCI Failover for Independent Connections</h3>
<p>No special handling is required for independent connections; all such connections that are connected to failed instances are immediately disconnected. For idle connections, TAF is engaged to reestablish the connection when the connection is used on a subsequent OCI call. Connections that are in use at the time of the failure event are broken out immediately, so that TAF can begin. Note that this applies for the "in-use" connections of connection and session pools also.</p>
</div>
<!-- class="sect2" -->
<a id="CACJGHFF"></a>
<div id="LNOCI16693" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Event Callback</h3>
<p>The event callback, of type <code><a id="sthref1564"></a><a id="sthref1565"></a>OCIEventCallback</code>, has the following signature:</p>
<pre>
void evtcallback_fn (void      *evtctx,
                     OCIEvent  *eventhp );
</pre>
<p>In this signature <code>evtctx</code> is the client context, and <code>OCIEvent</code> is an event handle that is opaque to the OCI library. The other input argument is <code>eventhp</code>, the event handle (the attributes associated with an event).</p>
<p>If registered, this function is called once for each event. For Oracle RAC HA events, this callback is invoked after the affected connections have been disconnected. The following environment handle attributes are used to register an event callback and context, respectively:</p>
<ul>
<li>
<p><a id="sthref1566"></a><code>OCI_ATTR_EVTCBK</code> is of data type <code>OCIEventCallback</code> <code>*</code>. It is read-only.</p>
</li>
<li>
<p><a id="sthref1567"></a><code>OCI_ATTR_EVTCTX</code> is of data type <code>void</code> <code>*</code>. It is also read-only.</p>
</li>
</ul>
<pre>
text *myctx = "dummy context"; /* dummy context passed to callback fn */
...
/* OCI_ATTR_EVTCBK and OCI_ATTR_EVTCTX are read-only. */
OCIAttrSet(envhp, (ub4) OCI_HTYPE_ENV, (void *) evtcallback_fn,
           (ub4) 0, (ub4) OCI_ATTR_EVTCBK, errhp);
OCIAttrSet(envhp, (ub4) OCI_HTYPE_ENV, (void *) myctx,
           (ub4) 0, (ub4) OCI_ATTR_EVTCTX, errhp);
...
</pre>
<p>Within the OCI event callback, the list of affected server handles is encapsulated in the <code>OCIEvent</code> handle. For Oracle RAC HA DOWN events, client applications can iterate over a list of server handles that are affected by the event by using <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> with attribute types <code><a id="sthref1568"></a>OCI_ATTR_HA_SRVFIRST</code> and <a id="sthref1569"></a><code>OCI_ATTR_HA_SRVNEXT</code>:</p>
<pre>
OCIAttrGet(eventhp, OCI_HTYPE_EVENT, (void *)&amp;srvhp, (ub4 *)0,
           OCI_ATTR_HA_SRVFIRST, errhp); 
/* or, */
OCIAttrGet(eventhp, OCI_HTYPE_EVENT, (void *)&amp;srvhp, (ub4 *)0,
           OCI_ATTR_HA_SRVNEXT, errhp);
</pre>
<p>When called with attribute <code>OCI_ATTR_HA_SRVFIRST</code>, this function retrieves the first server handle in the list of server handles affected. When called with attribute <code>OCI_ATTR_HA_SRVNEXT</code>, this function retrieves the next server handle in the list. This function returns <code>OCI_NO_DATA</code> and <code>srvhp</code> is a <code>NULL</code> pointer, when there are no more server handles to return.</p>
<p><code>srvhp</code> is an output pointer to a server handle whose connection has been closed because of an HA event. <code>errhp</code> is an error handle to populate. The application returns an <code>OCI_NO_DATA</code> error when there are no more affected server handles to retrieve.</p>
<p>When retrieving the list of server handles that have been affected by an HA event, be aware that the connection has already been closed and many server handle attributes are no longer valid. Instead, use the user memory segment of the server handle to store any per-connection attributes required by the event notification callback. This memory remains valid until the server handle is freed.</p>
</div>
<!-- class="sect2" -->
<a id="CJGBJIAB"></a>
<div id="LNOCI16694" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1570"></a>Custom Pooling: Tagged Server Handles</h3>
<p>The following features apply to custom pools:</p>
<ul>
<li>
<p>You can tag a server handle with its parent connection object if it is created on behalf of a custom pool. Use the "user memory" parameters of <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> to request that the server handle be allocated with a user memory segment. A pointer to the "user memory" segment is returned by <code>OCIHandleAlloc()</code>.</p>
</li>
<li>
<p>When an HA event occurs and an affected server handle has been retrieved, there is a means to retrieve the server handle's tag information so appropriate cleanup can be performed. The attribute <a id="sthref1571"></a><code>OCI_ATTR_USER_MEMORY</code> is used to retrieve a pointer to a handle's user memory segment. <code>OCI_ATTR_USER_MEMORY</code> is valid for all user-allocated handles. If the handle was allocated with extra memory, this attribute returns a pointer to the user memory. A <code>NULL</code> pointer is returned for those handles not allocated with extra memory. This attribute is read-only and is of data type <code>void*</code>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You are free to define the precise contents of the server handle's user memory segment to facilitate cleanup activities from within the HA event callback (or for other purposes if needed) because OCI does not write or read from this memory in any way. The user memory segment is freed with the <a href="oci16rel002.htm#i540911">OCIHandleFree()</a> call on the server handle.</div>
<p><a href="#CACCIFIF">Example 9-20</a> shows an example of event notification.</p>
<div id="LNOCI18219" class="example">
<p class="titleinexample"><a id="CACCIFIF"></a>Example 9-20 Event Notification</p>
<pre>
sword retval;
OCIServer *srvhp;
struct myctx {
   void *parentConn_myctx;
   uword numval_myctx;
};
typedef struct myctx myctx; 
myctx  *myctxp;
/* Allocate a server handle with user memory - pre 10.2 functionality */
if (retval = OCIHandleAlloc(envhp, (void **)&amp;srvhp, OCI_HTYPE_SERVER,
                            (size_t)sizeof(myctx), (void **)&amp;myctxp)
/* handle error */
myctxp-&gt;parentConn_myctx = &lt;parent connection reference&gt;;
 
/* In an event callback function, retrieve the pointer to the user memory */
evtcallback_fn(void *evtctx, OCIEvent *eventhp)
{ 
  myctx *ctxp = (myctx *)evtctx;
  OCIServer *srvhp;
  OCIError *errhp;
  sb4       retcode;
  retcode = OCIAttrGet(eventhp, OCI_HTYPE_SERVER, &amp;srvhp, (ub4 *)0,
                       OCI_ATTR_HA_SRVFIRST, errhp); 
  while (!retcode) /* OCIAttrGet will return OCI_NO_DATA if no more srvhp */ 
  {  
     OCIAttrGet((void *)srvhp, OCI_HTYPE_SERVER, (void *)&amp;ctxp,
                (ub4)0, (ub4)OCI_ATTR_USER_MEMORY, errhp);
           /* Remove the server handle from the parent connection object */
     retcode = OCIAttrGet(eventhp, OCI_HTYPE_SERVER, &amp;srvhp, (ub4 *)0,
                          OCI_ATTR_HA_SRVNEXT, errhp);
...
  }
...
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CACIFIAG"></a>
<div id="LNOCI16696" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1572"></a>Determining Transparent Application Failover (TAF) Capabilities</h3>
<p>You can have the application adjust its behavior if a connection is or is not TAF-enabled. Use <code>OCIAttrGet()</code> as follows to determine if a server handle is TAF-enabled:</p>
<pre>
boolean taf_capable;
...
OCIAttrGet(srvhp, (ub4) OCI_HTYPE_SERVER, (void *) &amp;taf_capable, 
           (ub4) sizeof(taf_capable), (ub4)OCI_ATTR_TAF_ENABLED, errhp);
...
</pre>
<p>In this example, <code>taf_capable</code> is a Boolean variable, which this call sets to <code>TRUE</code> if the server handle is TAF-enabled, and <code>FALSE</code> if not; <code>srvhp</code> is an input target server handle; <code><a id="sthref1573"></a>OCI_ATTR_TAF_ENABLED</code> is an attribute that is a pointer to a Boolean variable and is read-only; <code>errhp</code> is an input error handle.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i467582"></a>
<div id="LNOCI16697" class="sect1">
<h2 class="sect1">OCI and Streams Advanced Queuing<a id="sthref1574"></a><a id="sthref1575"></a></h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CACCIAII">OCI Streams Advanced Queuing Functions</a></p>
</li>
<li>
<p><a href="#CACHFJFA">OCI Streams Advanced Queuing Descriptors</a></p>
</li>
<li>
<p><a href="#i462622">Streams Advanced Queuing in OCI Versus PL/SQL</a></p>
</li>
<li>
<p><a href="#BABBFIGJ">Buffered Messaging</a></p>
</li>
</ul>
<p>OCI provides an interface to the Streams Advanced Queuing (Streams AQ) feature. Streams AQ provides message queuing as an integrated part of Oracle Database. Streams AQ provides this functionality by integrating the queuing system with the database, thereby creating a <span class="italic">message-enabled database.</span> By providing an integrated solution, Streams AQ frees application developers to devote their efforts to their specific business logic rather than having to construct a messaging infrastructure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To use Streams Advanced Queuing, you must be using the Enterprise Edition of Oracle Database.</div>
<pre>
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADQUE0100" href="../../server.112/e11013/aq_intro.htm#ADQUE0100"><span class="italic">Oracle Streams Advanced Queuing User's Guide</span></a></p>
</li>
<li>
<p><a class="olink ADXDK100" href="../../appdev.112/e23582/adx_overview.htm#ADXDK100"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a></p>
</li>
<li>
<p>The description of <a href="oci17msc003.htm#i555913">"OCIAQEnq()"</a> for example code demonstrating the use of OCI with AQ</p>
</li>
</ul>
</div>
<a id="CACCIAII"></a>
<div id="LNOCI16698" class="sect2">
<h3 class="sect2">OCI Streams Advanced Queuing Functions<a id="sthref1576"></a></h3>
<p>The OCI library includes several functions related to Streams Advanced Queuing:</p>
<ul>
<li>
<p><a href="oci17msc003.htm#i555913">OCIAQEnq()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#i555815">OCIAQDeq()</a></p>
</li>
<li>
<p><a href="ociaedep004.htm#i556429">OCIAQListen()</a> (Deprecated)</p>
</li>
<li>
<p><a href="oci17msc003.htm#BJFGAFJE">OCIAQListen2()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#i576291">OCIAQEnqArray()</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#i576305">OCIAQDeqArray()</a></p>
</li>
</ul>
<p>You can enqueue an array of messages to a single queue. The messages all share the same enqueue options, but each message in the array can have different message properties. You can also dequeue an array of messages from a single queue. For transaction group queues, you can dequeue all messages for a single transaction group using one call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc003.htm#CIHBIGHB">"Streams Advanced Queuing and Publish-Subscribe Functions"</a></div>
</div>
<!-- class="sect2" -->
<a id="CACHFJFA"></a>
<div id="LNOCI16699" class="sect2">
<h3 class="sect2">OCI Streams Advanced Queuing Descriptors<a id="sthref1577"></a></h3>
<p>The following descriptors are used by OCI Streams AQ operations:</p>
<ul>
<li>
<p><code>OCIAQEnqOptions</code></p>
</li>
<li>
<p><code>OCIAQDeqOptions</code></p>
</li>
<li>
<p><code>OCIAQMsgProperties</code></p>
</li>
<li>
<p><code>OCIAQAgent</code></p>
</li>
</ul>
<p>You can allocate these descriptors with the service handle using the standard <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a> call. The following code shows examples of this:</p>
<pre>
OCIDescriptorAlloc(svch, &amp;enqueue_options, OCI_DTYPE_AQENQ_OPTIONS, 0, 0 ); 
OCIDescriptorAlloc(svch, &amp;dequeue_options, OCI_DTYPE_AQDEQ_OPTIONS, 0, 0 ); 
OCIDescriptorAlloc(svch, &amp;message_properties, OCI_DTYPE_AQMSG_PROPERTIES, 0, 0);
OCIDescriptorAlloc(svch, &amp;agent, OCI_DTYPE_AQAGENT, 0, 0 ); 
</pre>
<p>Each descriptor has a variety of attributes that can be set or read.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i453062">"Streams Advanced Queuing Descriptor Attributes"</a></div>
</div>
<!-- class="sect2" -->
<a id="i462622"></a>
<div id="LNOCI16700" class="sect2">
<h3 class="sect2">Streams Advanced Queuing in OCI Versus PL/SQL<a id="sthref1578"></a></h3>
<p>The following tables compare functions, parameters, and options for OCI Streams AQ functions and descriptors, and PL/SQL AQ functions in the DBMS_AQ package. <a href="#CACIAFCB">Table 9-3</a> compares AQ functions.</p>
<div id="LNOCI16701" class="tblformal">
<p class="titleintable"><a id="sthref1579"></a><a id="CACIAFCB"></a>Table 9-3 AQ Functions</p>
<table class="cellalignment1016" title="AQ Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t52">PL/SQL Function</th>
<th class="cellalignment1012" id="r1c2-t52">OCI Function</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t52" headers="r1c1-t52">
<p>DBMS_AQ.ENQUEUE</p>
</td>
<td class="cellalignment1013" headers="r2c1-t52 r1c2-t52">
<p><code>OCIAQEnq()</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t52" headers="r1c1-t52">
<p>DBMS_AQ.DEQUEUE</p>
</td>
<td class="cellalignment1013" headers="r3c1-t52 r1c2-t52">
<p><code>OCIAQDeq()</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t52" headers="r1c1-t52">
<p>DBMS_AQ.LISTEN</p>
</td>
<td class="cellalignment1013" headers="r4c1-t52 r1c2-t52">
<p><code>OCIAQListen(), OCIAQListen2()</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t52" headers="r1c1-t52">
<p>DBMS_AQ.ENQUEUE_ARRAY</p>
</td>
<td class="cellalignment1013" headers="r5c1-t52 r1c2-t52">
<p><code>OCIAQEnqArray()</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t52" headers="r1c1-t52">
<p>DBMS_AQ.DEQUEUE_ARRAY</p>
</td>
<td class="cellalignment1013" headers="r6c1-t52 r1c2-t52">
<p><code>OCIAQDeqArray()</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACBJFAJ">Table 9-4</a> compares the parameters for the enqueue functions.</p>
<div id="LNOCI16702" class="tblformal">
<p class="titleintable"><a id="sthref1580"></a><a id="CACBJFAJ"></a>Table 9-4 Enqueue Parameters</p>
<table class="cellalignment1016" title="Enqueue Parameters " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t53">DBMS_AQ.ENQUEUE Parameter</th>
<th class="cellalignment1012" id="r1c2-t53">OCIAQEnq() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t53" headers="r1c1-t53">
<pre>
queue_name
</pre></td>
<td class="cellalignment1013" headers="r2c1-t53 r1c2-t53">
<pre>
queue_name
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t53" headers="r1c1-t53">
<pre>
enqueue_options
</pre></td>
<td class="cellalignment1013" headers="r3c1-t53 r1c2-t53">
<pre>
enqueue_options
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t53" headers="r1c1-t53">
<pre>
message_properties
</pre></td>
<td class="cellalignment1013" headers="r4c1-t53 r1c2-t53">
<pre>
message_properties
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t53" headers="r1c1-t53">
<pre>
payload
</pre></td>
<td class="cellalignment1013" headers="r5c1-t53 r1c2-t53">
<pre>
payload
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t53" headers="r1c1-t53">
<pre>
msgid
</pre></td>
<td class="cellalignment1013" headers="r6c1-t53 r1c2-t53">
<pre>
msgid
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t53" headers="r1c1-t53">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r7c1-t53 r1c2-t53">
<p>Note: <code>OCIAQEnq()</code> requires the following additional parameters: <code>svch</code><code>,</code> <code>errh, payload_tdo, payload_ind</code><code>, and</code> <code>flags</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACIEGEG">Table 9-5</a> compares the parameters for the dequeue functions.</p>
<div id="LNOCI16703" class="tblformal">
<p class="titleintable"><a id="sthref1581"></a><a id="CACIEGEG"></a>Table 9-5 Dequeue Parameters</p>
<table class="cellalignment1016" title="Dequeue Parameters " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t54">DBMS_AQ.DEQUEUE Parameter</th>
<th class="cellalignment1012" id="r1c2-t54">OCIAQDeq() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t54" headers="r1c1-t54">
<pre>
queue_name
</pre></td>
<td class="cellalignment1013" headers="r2c1-t54 r1c2-t54">
<pre>
queue_name
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t54" headers="r1c1-t54">
<pre>
dequeue_options
</pre></td>
<td class="cellalignment1013" headers="r3c1-t54 r1c2-t54">
<pre>
dequeue_options
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t54" headers="r1c1-t54">
<pre>
message_properties
</pre></td>
<td class="cellalignment1013" headers="r4c1-t54 r1c2-t54">
<pre>
message_properties
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t54" headers="r1c1-t54">
<pre>
payload
</pre></td>
<td class="cellalignment1013" headers="r5c1-t54 r1c2-t54">
<pre>
payload
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t54" headers="r1c1-t54">
<pre>
msgid
</pre></td>
<td class="cellalignment1013" headers="r6c1-t54 r1c2-t54">
<pre>
msgid
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t54" headers="r1c1-t54">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r7c1-t54 r1c2-t54">
<p>Note: <code>OCIAQDeq()</code> requires the following additional parameters: <code>svch</code><code>,</code> <code>errh, dequeue_options, message_properties, payload_tdo, payload, payload_ind</code><code>, and</code> <code>flags</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACCCDID">Table 9-6</a> compares parameters for the listen functions.</p>
<div id="LNOCI16704" class="tblformal">
<p class="titleintable"><a id="sthref1582"></a><a id="CACCCDID"></a>Table 9-6 Listen Parameters</p>
<table class="cellalignment1016" title="Listen Parameters " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t55">DBMS_AQ.LISTEN Parameter</th>
<th class="cellalignment1012" id="r1c2-t55">OCIAQListen2() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t55" headers="r1c1-t55">
<pre>
agent_list
</pre></td>
<td class="cellalignment1013" headers="r2c1-t55 r1c2-t55">
<pre>
agent_list
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t55" headers="r1c1-t55">
<pre>
wait
</pre></td>
<td class="cellalignment1013" headers="r3c1-t55 r1c2-t55">
<pre>
wait
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t55" headers="r1c1-t55">
<pre>
agent
</pre></td>
<td class="cellalignment1013" headers="r4c1-t55 r1c2-t55">
<pre>
agent
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t55" headers="r1c1-t55">
<pre>
listen_delivery_mode
</pre></td>
<td class="cellalignment1013" headers="r5c1-t55 r1c2-t55">
<p><code>lopts</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t55" headers="r1c1-t55">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r6c1-t55 r1c2-t55">
<p>Note: <code>OCIAQListen2()</code> requires the following additional parameters: <code>svchp, errhp, agent_list, num_agents, agent</code><code>, lmops, and</code> <code>flags</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACGGDAF">Table 9-7</a> compares parameters for the array enqueue functions.</p>
<div id="LNOCI16705" class="tblformal">
<p class="titleintable"><a id="sthref1583"></a><a id="CACGGDAF"></a>Table 9-7 Array Enqueue Parameters</p>
<table class="cellalignment1016" title="Array Enqueue Parameters " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t56">DBMS_AQ.ENQUEUE_ARRAY Parameter</th>
<th class="cellalignment1012" id="r1c2-t56">OCIAQEnqArray() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t56" headers="r1c1-t56">
<pre>
queue_name
</pre></td>
<td class="cellalignment1013" headers="r2c1-t56 r1c2-t56">
<pre>
queue_name
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t56" headers="r1c1-t56">
<pre>
enqueue_options
</pre></td>
<td class="cellalignment1013" headers="r3c1-t56 r1c2-t56">
<pre>
enqopt
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t56" headers="r1c1-t56">
<pre>
array_size
</pre></td>
<td class="cellalignment1013" headers="r4c1-t56 r1c2-t56">
<pre>
iters
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t56" headers="r1c1-t56">
<pre>
message_properties_array
</pre></td>
<td class="cellalignment1013" headers="r5c1-t56 r1c2-t56">
<pre>
msgprop
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t56" headers="r1c1-t56">
<pre>
payload_array
</pre></td>
<td class="cellalignment1013" headers="r6c1-t56 r1c2-t56">
<pre>
payload
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t56" headers="r1c1-t56">
<pre>
msgid_array
</pre></td>
<td class="cellalignment1013" headers="r7c1-t56 r1c2-t56">
<pre>
msgid
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t56" headers="r1c1-t56">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r8c1-t56 r1c2-t56">
<p>Note: <code>OCIAQEnqArray()</code> requires the following additional parameters: <code>svch</code><code>,</code> <code>errh, payload_tdo, payload_ind, ctxp, enqcbfp,</code> <code>and</code> <code>flags</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACFHBEI">Table 9-8</a> compares parameters for the array dequeue functions.</p>
<div id="LNOCI16706" class="tblformal">
<p class="titleintable"><a id="sthref1584"></a><a id="CACFHBEI"></a>Table 9-8 Array Dequeue Parameters</p>
<table class="cellalignment1016" title="Array Dequeue Parameters " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t57">DBMS_AQ.DEQUEUE_ARRAY Parameter</th>
<th class="cellalignment1012" id="r1c2-t57">OCIAQDeqArray() Parameter</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t57" headers="r1c1-t57">
<pre>
queue_name
</pre></td>
<td class="cellalignment1013" headers="r2c1-t57 r1c2-t57">
<pre>
queue_name
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t57" headers="r1c1-t57">
<pre>
dequeue_options
</pre></td>
<td class="cellalignment1013" headers="r3c1-t57 r1c2-t57">
<pre>
deqopt
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t57" headers="r1c1-t57">
<pre>
array_size
</pre></td>
<td class="cellalignment1013" headers="r4c1-t57 r1c2-t57">
<pre>
iters
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t57" headers="r1c1-t57">
<pre>
message_properties_array
</pre></td>
<td class="cellalignment1013" headers="r5c1-t57 r1c2-t57">
<pre>
msgprop
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t57" headers="r1c1-t57">
<pre>
payload_array
</pre></td>
<td class="cellalignment1013" headers="r6c1-t57 r1c2-t57">
<pre>
payload
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t57" headers="r1c1-t57">
<pre>
msgid_array
</pre></td>
<td class="cellalignment1013" headers="r7c1-t57 r1c2-t57">
<pre>
msgid
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t57" headers="r1c1-t57">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r8c1-t57 r1c2-t57">
<p>Note: <code>OCIAQDeqArray()</code> requires the following additional parameters: <code>svch</code><code>,</code> <code>errh,</code> <code>msgprop, payload_tdo, payload_ind, ctxp, deqcbfp,</code> <code>and</code> <code>flags</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACJHHDB">Table 9-9</a> compares parameters for the agent attributes.</p>
<div id="LNOCI16707" class="tblformal">
<p class="titleintable"><a id="sthref1585"></a><a id="CACJHHDB"></a>Table 9-9 Agent Parameters</p>
<table class="cellalignment1016" title="Agent Parameters " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t58">PL/SQL Agent Parameter</th>
<th class="cellalignment1012" id="r1c2-t58">OCIAQAgent Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t58" headers="r1c1-t58">
<pre>
name
</pre></td>
<td class="cellalignment1013" headers="r2c1-t58 r1c2-t58">
<p><code>OCI_ATTR_AGENT_NAME</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t58" headers="r1c1-t58">
<pre>
address
</pre></td>
<td class="cellalignment1013" headers="r3c1-t58 r1c2-t58">
<p><code>OCI_ATTR_AGENT_ADDRESS</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t58" headers="r1c1-t58">
<pre>
protocol
</pre></td>
<td class="cellalignment1013" headers="r4c1-t58 r1c2-t58">
<p><code>OCI_ATTR_AGENT_PROTOCOL</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACJGGBC">Table 9-10</a> compares parameters for the message properties.</p>
<div id="LNOCI16708" class="tblformal">
<p class="titleintable"><a id="sthref1586"></a><a id="CACJGGBC"></a>Table 9-10 Message Properties</p>
<table class="cellalignment1016" title="Message Properties " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t59">PL/SQL Message Property</th>
<th class="cellalignment1012" id="r1c2-t59">OCIAQMsgProperties Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t59" headers="r1c1-t59">
<pre>
priority
</pre></td>
<td class="cellalignment1013" headers="r2c1-t59 r1c2-t59">
<p><code>OCI_ATTR_PRIORITY</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t59" headers="r1c1-t59">
<pre>
delay
</pre></td>
<td class="cellalignment1013" headers="r3c1-t59 r1c2-t59">
<p><code>OCI_ATTR_DELAY</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t59" headers="r1c1-t59">
<pre>
expiration
</pre></td>
<td class="cellalignment1013" headers="r4c1-t59 r1c2-t59">
<p><code>OCI_ATTR_EXPIRATION</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t59" headers="r1c1-t59">
<pre>
correlation
</pre></td>
<td class="cellalignment1013" headers="r5c1-t59 r1c2-t59">
<p><code>OCI_ATTR_CORRELATION</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t59" headers="r1c1-t59">
<pre>
attempts
</pre></td>
<td class="cellalignment1013" headers="r6c1-t59 r1c2-t59">
<p><code>OCI_ATTR_ATTEMPTS</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t59" headers="r1c1-t59">
<pre>
recipient_list
</pre></td>
<td class="cellalignment1013" headers="r7c1-t59 r1c2-t59">
<p><code>OCI_ATTR_RECIPIENT_LIST</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t59" headers="r1c1-t59">
<pre>
exception_queue
</pre></td>
<td class="cellalignment1013" headers="r8c1-t59 r1c2-t59">
<p><code>OCI_ATTR_EXCEPTION_QUEUE</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t59" headers="r1c1-t59">
<pre>
enqueue_time
</pre></td>
<td class="cellalignment1013" headers="r9c1-t59 r1c2-t59">
<p><code>OCI_ATTR_ENQ_TIME</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t59" headers="r1c1-t59">
<pre>
state
</pre></td>
<td class="cellalignment1013" headers="r10c1-t59 r1c2-t59">
<p><code>OCI_ATTR_MSG_STATE</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t59" headers="r1c1-t59">
<pre>
sender_id
</pre></td>
<td class="cellalignment1013" headers="r11c1-t59 r1c2-t59">
<p><code>OCI_ATTR_SENDER_ID</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t59" headers="r1c1-t59">
<pre>
transaction_group
</pre></td>
<td class="cellalignment1013" headers="r12c1-t59 r1c2-t59">
<p><code>OCI_ATTR_TRANSACTION_NO</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t59" headers="r1c1-t59">
<pre>
original_msgid
</pre></td>
<td class="cellalignment1013" headers="r13c1-t59 r1c2-t59">
<p><code>OCI_ATTR_ORIGINAL_MSGID</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t59" headers="r1c1-t59">
<pre>
delivery_mode
</pre></td>
<td class="cellalignment1013" headers="r14c1-t59 r1c2-t59">
<p><code>OCI_ATTR_MSG_DELIVERY_MODE</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACFFHAH">Table 9-11</a> compares enqueue option attributes.</p>
<div id="LNOCI16709" class="tblformal">
<p class="titleintable"><a id="sthref1587"></a><a id="CACFFHAH"></a>Table 9-11 Enqueue Option Attributes</p>
<table class="cellalignment1016" title="Enqueue Option Attributes " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t60">PL/SQL Enqueue Option</th>
<th class="cellalignment1012" id="r1c2-t60">OCIAQEnqOptions Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t60" headers="r1c1-t60">
<pre>
visibility
</pre></td>
<td class="cellalignment1013" headers="r2c1-t60 r1c2-t60">
<p><code>OCI_ATTR_VISIBILITY</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t60" headers="r1c1-t60">
<pre>
relative_msgid
</pre></td>
<td class="cellalignment1013" headers="r3c1-t60 r1c2-t60">
<p><code>OCI_ATTR_RELATIVE_MSGID</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t60" headers="r1c1-t60">
<pre>
sequence_deviation
</pre></td>
<td class="cellalignment1013" headers="r4c1-t60 r1c2-t60">
<p><code>OCI_ATTR_SEQUENCE_DEVIATION</code></p>
<p>(deprecated)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t60" headers="r1c1-t60">
<p><code>transformation</code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t60 r1c2-t60">
<p><code>OCI_ATTR_TRANSFORMATION</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t60" headers="r1c1-t60">
<pre>
delivery_mode
</pre></td>
<td class="cellalignment1013" headers="r6c1-t60 r1c2-t60">
<p><code>OCI_ATTR_MSG_DELIVERY_MODE</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#CACEAIFB">Table 9-12</a> compares dequeue option attributes.</p>
<div id="LNOCI16710" class="tblformal">
<p class="titleintable"><a id="sthref1588"></a><a id="CACEAIFB"></a>Table 9-12 Dequeue Option Attributes</p>
<table class="cellalignment1016" title="Dequeue Option Attributes " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t61">PL/SQL Dequeue Option</th>
<th class="cellalignment1012" id="r1c2-t61">OCIAQDeqOptions Attribute</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t61" headers="r1c1-t61">
<pre>
consumer_name
</pre></td>
<td class="cellalignment1013" headers="r2c1-t61 r1c2-t61">
<p><code>OCI_ATTR_CONSUMER_NAME</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t61" headers="r1c1-t61">
<pre>
dequeue_mode
</pre></td>
<td class="cellalignment1013" headers="r3c1-t61 r1c2-t61">
<p><code>OCI_ATTR_DEQ_MODE</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t61" headers="r1c1-t61">
<pre>
navigation
</pre></td>
<td class="cellalignment1013" headers="r4c1-t61 r1c2-t61">
<p><code>OCI_ATTR_NAVIGATION</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t61" headers="r1c1-t61">
<pre>
visibility
</pre></td>
<td class="cellalignment1013" headers="r5c1-t61 r1c2-t61">
<p><code>OCI_ATTR_VISIBILITY</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t61" headers="r1c1-t61">
<pre>
wait
</pre></td>
<td class="cellalignment1013" headers="r6c1-t61 r1c2-t61">
<p><code>OCI_ATTR_WAIT</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t61" headers="r1c1-t61">
<pre>
msgid
</pre></td>
<td class="cellalignment1013" headers="r7c1-t61 r1c2-t61">
<p><code>OCI_ATTR_DEQ_MSGID</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t61" headers="r1c1-t61">
<pre>
correlation
</pre></td>
<td class="cellalignment1013" headers="r8c1-t61 r1c2-t61">
<p><code>OCI_ATTR_CORRELATION</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t61" headers="r1c1-t61">
<p><code>deq_condition</code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t61 r1c2-t61">
<p><code>OCI_ATTR_DEQCOND</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t61" headers="r1c1-t61">
<p><code>transformation</code></p>
</td>
<td class="cellalignment1013" headers="r10c1-t61 r1c2-t61">
<p><code>OCI_ATTR_TRANSFORMATION</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t61" headers="r1c1-t61">
<pre>
delivery_mode
</pre></td>
<td class="cellalignment1013" headers="r11c1-t61 r1c2-t61">
<p><code>OCI_ATTR_MSG_DELIVERY_MODE</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<a href="oci17msc003.htm#i555913">OCIAQEnq()</a> returns the error <a id="sthref1589"></a><code>ORA-25219</code> while specifying the enqueue option <a id="sthref1590"></a><code>OCI_ATTR_SEQUENCE</code> along with <code><a id="sthref1591"></a>OCI_ATTR_RELATIVE_MSGID.</code> This happens when enqueuing two messages. For the second message, enqueue options <code>OCI_ATTR_SEQUENCE</code> and <code>OCI_ATTR_RELATIVE_MSGID</code> are set to dequeue this message before the first one. An error is not returned if you do not specify the sequence but, of course, the message is not dequeued before the relative message.
<p><a href="oci17msc003.htm#i555913">OCIAQEnq()</a> does not return an error if the <code>OCI_ATTR_SEQUENCE</code> attribute is not set, but the message is not dequeued before the message with relative message ID.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="BABBFIGJ"></a>
<div id="LNOCI13268" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1592"></a>Buffered Messaging</h3>
<p>Buffered messaging is a nonpersistent messaging capability within Streams AQ that was first available in Oracle Database 10<span class="italic">g</span> Release 2. Buffered messages reside in shared memory and can be lost if there is an instance failure. Unlike persistent messages, redo does not get written to disk. Buffered message enqueue and dequeue is much faster than persistent message operations. Because shared memory is limited, buffered messages may have to be spilled to disk. Flow control can be enabled to prevent applications from flooding the shared memory when the message consumers are slow or have stopped for some reason. The following functions are used for buffered messaging:</p>
<ul>
<li>
<p><a href="oci17msc003.htm#i555913">"OCIAQEnq()"</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#i555815">"OCIAQDeq()"</a></p>
</li>
<li>
<p><a href="oci17msc003.htm#BJFGAFJE">"OCIAQListen2()"</a></p>
</li>
</ul>
<p><a href="#CACBCHCE">Example 9-21</a> shows an example of enqueue buffered messaging.</p>
<div id="LNOCI18220" class="example">
<p class="titleinexample"><a id="CACBCHCE"></a>Example 9-21 Enqueue Buffered Messaging</p>
<pre>
...
OCIAQMsgProperties  *msgprop;
OCIAQEnqueueOptions *enqopt;
message              msg;    /* message is an object type */
null_message         nmsg;   /* message indicator */
...
/* Allocate descriptors */
  OCIDescriptorAlloc(envhp, (void **)&amp;enqopt, OCI_DTYPE_AQENQ_OPTIONS, 0,
                     (void **)0));
 
 OCIDescriptorAlloc(envhp, (void **)&amp;msgprop,OCI_DTYPE_AQMSG_PROPERTIES, 0,
                    (void **)0));
 
/* Set delivery mode to buffered */
 dlvm = OCI_MSG_BUFFERED;
 OCIAttrSet(enqopt,  OCI_DTYPE_AQENQ_OPTIONS, (void *)&amp;dlvm, sizeof(ub2),
            OCI_ATTR_MSG_DELIVERY_MODE, errhp);
/* Set visibility to Immediate (visibility must always be immediate for buffered
   messages) */
vis = OCI_ENQ_ON_COMMIT;
 
OCIAttrSet(enqopt, OCI_DTYPE_AQENQ_OPTIONS,(void *)&amp;vis, sizeof(ub4),
           OCI_ATTR_VISIBILITY, errhp)
 
/* Message was an object type created earlier, msg_tdo is its type
   descriptor object */
OCIAQEnq(svchp, errhp, "Test_Queue", enqopt, msgprop, msg_tdo, (void **)&amp;mesg,
         (void **)&amp;nmesg, (OCIRaw **)0, 0));
...
</pre></div>
<!-- class="example" -->
<p><a href="#CACJHBEE">Example 9-22</a> shows an example of dequeue buffered messaging.</p>
<div id="LNOCI18221" class="example">
<p class="titleinexample"><a id="CACJHBEE"></a>Example 9-22 Dequeue Buffered Messaging</p>
<pre>
...
OCIAQMsgProperties  *msgprop;
OCIAQDequeueOptions *deqopt;
...
OCIDescriptorAlloc(envhp, (void **)&amp;mprop, OCI_DTYPE_AQMSG_PROPERTIES, 0,
                   (void **)0));
OCIDescriptorAlloc(envhp, (void **)&amp;deqopt, OCI_DTYPE_AQDEQ_OPTIONS, 0,
                   (void **)0);

/* Set visibility to Immediate (visibility must always be immediate for buffered
   message operations) */
vis = OCI_ENQ_ON_COMMIT;
OCIAttrSet(deqopt, OCI_DTYPE_AQDEQ_OPTIONS,(void *)&amp;vis, sizeof(ub4),
           OCI_ATTR_VISIBILITY, errhp)
/* delivery mode is buffered */
dlvm  = OCI_MSG_BUFFERED;
OCIAttrSet(deqopt, OCI_DTYPE_AQDEQ_OPTIONS, (void *)&amp;dlvm,  sizeof(ub2),
           OCI_ATTR_MSG_DELIVERY_MODE, errhp);
/* Set the consumer for which to dequeue the message (this must be specified
   regardless of the type of message being dequeued).
*/
consumer = "FIRST_SUBSCRIBER";
OCIAttrSet(deqopt, OCI_DTYPE_AQDEQ_OPTIONS, (void *)consumer,
           (ub4)strlen((char*)consumer), OCI_ATTR_CONSUMER_NAME, errhp);
/* Dequeue the message but do not return the payload (to simplify the code
   fragment)
*/
OCIAQDeq(svchp, errhp,  "test_queue", deqopt, msgprop, msg_tdo, (void **)0,
         (void **)0, (OCIRaw**)0, 0);
...
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Array operations are not supported for buffered messaging. Applications can use the <code>OCIAQEnqArray()</code> and <code>OCIAQDeqArray()</code> functions with the array size set to 1.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i435757"></a>
<div id="LNOCI16713" class="sect1">
<h2 class="sect1">Publish-Subscribe Notification in OCI</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#i462621">Publish-Subscribe Registration Functions in OCI</a></p>
</li>
<li>
<p><a href="#i462244">Notification Callback in OCI</a></p>
</li>
<li>
<p><a href="#i457165">Notification Procedure</a></p>
</li>
<li>
<p><a href="#i471826">Publish-Subscribe Direct Registration Example</a></p>
</li>
<li>
<p><a href="#i463278">Publish-Subscribe LDAP Registration Example</a></p>
</li>
</ul>
<p>The publish-subscribe notification<a id="sthref1593"></a><a id="sthref1594"></a> feature allows an OCI application to receive client notifications directly, register an email address to which notifications can be sent, register an HTTP URL to which notifications can be posted, or register a PL/SQL procedure to be invoked on a notification. <a href="#i457371">Figure 9-2</a> illustrates the process.</p>
<div id="LNOCI16714" class="figure">
<p class="titleinfigure"><a id="i457371"></a>Figure 9-2 Publish-Subscribe Model</p>
<img width="644" height="470" src="img/lnoci039.gif" alt="Description of Figure 9-2 follows" /><br />
<a id="sthref1595" href="img_text/lnoci039.htm">Description of "Figure 9-2 Publish-Subscribe Model"</a><br />
<br /></div>
<!-- class="figure" -->
<p>An OCI application can:</p>
<ul>
<li>
<p>Register interest in notifications in the AQ namespace and be notified when an enqueue occurs</p>
</li>
<li>
<p>Register interest in subscriptions to database events and receive notifications when the events are triggered</p>
</li>
<li>
<p>Manage registrations, such as disabling registrations temporarily or dropping the registrations entirely</p>
</li>
<li>
<p>Post or send notifications to registered clients</p>
</li>
</ul>
<p>In all the preceding scenarios the notification can be received directly by the OCI application, or the notification can be sent to a prespecified email address, or it can be sent to a predefined HTTP URL, or a prespecified database PL/SQL procedure can be invoked because of a notification.</p>
<p>Registered clients are notified asynchronously when events are triggered or on an explicit AQ enqueue. Clients do not need to be connected to a database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i467582">"OCI and Streams Advanced Queuing"</a> for information about Streams Advanced Queuing</p>
</li>
<li>
<p><a class="olink ADQUE0100" href="../../server.112/e11013/aq_intro.htm#ADQUE0100">Oracle Streams Advanced Queuing User's Guide</a> for information about creating queues and about Streams AQ, including concepts, features, and examples</p>
</li>
<li>
<p>The chapter about <code>CREATE</code> <code>TRIGGER</code> in the <a class="olink SQLRF01405" href="../../server.112/e41084/statements_7004.htm#SQLRF01405"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about creating triggers</p>
</li>
</ul>
</div>
<a id="i462621"></a>
<div id="LNOCI16715" class="sect2">
<h3 class="sect2"><a id="sthref1596"></a>Publish-Subscribe Registration Functions in OCI</h3>
<p>Registration can be done in two ways:</p>
<ul>
<li>
<p>Direct registration. You register directly to the database. This way is simple and the registration takes effect immediately. See <a href="#CHDDHHEE">"Publish-Subscribe Register Directly to the Database"</a>.</p>
</li>
<li>
<p>Open registration. You register using Lightweight Directory Access Protocol (LDAP), from which the database receives the registration request. This is useful when the client cannot have a database connection (the client wants to register for a database open event while the database is down), or if the client wants to register for the same event or events in multiple databases simultaneously. See <a href="#CACFGBCA">"Open Registration for Publish-Subscribe"</a>.</p>
</li>
</ul>
<a id="CHDDHHEE"></a>
<div id="LNOCI16716" class="sect3">
<h4 class="sect3">Publish-Subscribe Register Directly to the Database</h4>
<p>The following steps are required in an OCI application to register directly and receive notifications for events. It is assumed that the appropriate event trigger or AQ queue has been set up. The initialization parameter <code>COMPATIBLE</code> must be set to 8.1 or higher.<span class="bold"><a id="sthref1597"></a></span></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci17msc003.htm#CIHBIGHB">"Streams Advanced Queuing and Publish-Subscribe Functions"</a></p>
</li>
<li>
<p><a href="#i471826">"Publish-Subscribe Direct Registration Example"</a> for examples of the use of these functions in an application</p>
</li>
</ul>
</div>
<pre>
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The publish-subscribe feature is only available on multithreaded operating systems.</div>
<ol>
<li>
<p>Call <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> with <a id="sthref1598"></a><code>OCI_EVENTS</code> mode to specify that the application is interested in registering for and receiving notifications. This starts a dedicated listening thread for notifications on the client.</p>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> with handle type <code>OCI_HTYPE_SUBSCRIPTION</code> to allocate a <a id="sthref1599"></a><a id="sthref1600"></a>subscription handle.</p>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set the <a id="sthref1601"></a>subscription handle attributes for:</p>
<ul>
<li>
<p><code><a id="sthref1602"></a>OCI_ATTR_SUBSCR_NAME</code> - subscription name</p>
</li>
<li>
<p><a id="sthref1603"></a><code>OCI_ATTR_SUBSCR_NAMESPACE</code> - subscription namespace</p>
</li>
<li>
<p><code><a id="sthref1604"></a>OCI_ATTR_SUBSCR_HOSTADDR</code> - environment handle attribute that sets the client IP (in either IPv4 or IPv6 format) to which notification is sent</p>
<p>Oracle Database components and utilities support <a id="sthref1605"></a>Internet Protocol version 6 (IPv6) addresses.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJDBBIC">"OCI_ATTR_SUBSCR_HOSTADDR"</a>, <a href="ociaahan.htm#BAJHEBIA">"OCI_ATTR_SUBSCR_IPADDR"</a>, and <a class="olink NETAG1453" href="../../network.112/e41945/layers.htm#NETAG1453">Oracle Database Net Services Administrator's Guide</a> for more information about the IPv6 format for IP addresses</div>
</li>
<li>
<p><code><a id="sthref1606"></a>OCI_ATTR_SUBSCR_CALLBACK</code> - notification callback</p>
</li>
<li>
<p><code><a id="sthref1607"></a>OCI_ATTR_SUBSCR_CTX</code> - callback context</p>
</li>
<li>
<p><code><a id="sthref1608"></a>OCI_ATTR_SUBSCR_PAYLOAD</code> - payload buffer for posting</p>
</li>
<li>
<p><code><a id="sthref1609"></a>OCI_ATTR_SUBSCR_RECPT</code> - recipient name</p>
</li>
<li>
<p><code><a id="sthref1610"></a>OCI_ATTR_SUBSCR_RECPTPROTO</code> - protocol to receive notification with</p>
</li>
<li>
<p><code><a id="sthref1611"></a>OCI_ATTR_SUBSCR_RECPTPRES</code> - presentation to receive notification with</p>
</li>
<li>
<p><code><a id="sthref1612"></a>OCI_ATTR_SUBSCR_QOSFLAGS</code> - QOS (quality of service) levels with the following values:</p>
<ul>
<li>
<p>If <code><a id="sthref1613"></a>OCI_SUBSCR_QOS_PURGE_ON_NTFN</code> is set, the registration is purged on the first notification.</p>
</li>
<li>
<p>If <code><a id="sthref1614"></a>OCI_SUBSCR_QOS_RELIABLE</code> is set, notifications are persistent. You can use surviving instances of an Oracle RAC database to send and retrieve change notification messages even after a node failure, because invalidations associated with this registration are queued persistently into the database. If <code>FALSE</code>, then invalidations are enqueued into a fast in-memory queue. Note that this option describes the persistence of notifications and not the persistence of registrations. Registrations are automatically persistent by default.</p>
</li>
</ul>
</li>
<li>
<p><code><a id="sthref1615"></a>OCI_ATTR_SUBSCR_TIMEOUT</code> - Registration timeout interval in seconds. The default is 0 if a timeout is not set.</p>
</li>
<li>
<p><code><a id="sthref1616"></a>OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS</code> - notification grouping class</p>
<p>Notifications can be spaced out by using the grouping NTFN option with the following constants. A value supported for notification grouping class is:</p>
<pre>
#define OCI_SUBSCR_NTFN_GROUPING_CLASS_TIME   1 /* time  */
</pre></li>
<li>
<p><code><a id="sthref1617"></a>OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE</code> - notification grouping value in seconds</p>
</li>
<li>
<p><code><a id="sthref1618"></a>OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE</code> - notification grouping type</p>
<p>Supported values for notification grouping type:</p>
<pre>
#define OCI_SUBSCR_NTFN_GROUPING_TYPE_SUMMARY 1  /* summary */
#define OCI_SUBSCR_NTFN_GROUPING_TYPE_LAST    2  /* last */ 
</pre></li>
<li>
<p><code><a id="sthref1619"></a>OCI_ATTR_SUBSCR_NTFN_GROUPING_START_TIME</code> - notification grouping start time</p>
</li>
<li>
<p><code><a id="sthref1620"></a>OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT</code> - notification grouping repeat count</p>
</li>
</ul>
<p><code>OCI_ATTR_SUBSCR_NAME</code>, <code>OCI_ATTR_SUBSCR_NAMESPACE</code>, and <code>OCI_ATTR_SUBSCR_RECPTPROTO</code> must be set before you register a subscription.</p>
<p>If <code>OCI_ATTR_SUBSCR_RECPTPROTO</code> is set to <code>OCI_SUBSCR_PROTO_OCI</code>, then <code>OCI_ATTR_SUBSCR_CALLBACK</code> and <code>OCI_ATTR_SUBSCR_CTX</code> also must be set.</p>
<p>If <code>OCI_ATTR_SUBSCR_RECPTPROTO</code> is set to <code>OCI_SUBSCR_PROTO_MAIL</code>, <code>OCI_SUBSCR_PROTO_SERVER</code>, or <code>OCI_SUBSCR_PROTO_HTTP</code>, then <code>OCI_ATTR_SUBSCR_RECPT</code> also must be set.</p>
<p>Setting <code>OCI_ATTR_SUBSCR_CALLBACK</code> and <code>OCI_ATTR_SUBSCR_RECPT</code> at the same time causes an application error.</p>
<p><code>OCI_ATTR_SUBSCR_PAYLOAD</code> is required before the application can perform a post to a subscription.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i439205">"Subscription Handle Attributes"</a> and <a href="oci02bas.htm#i464242">"Creating the OCI Environment"</a> for setting up the environment with <code>mode = OCI_EVENTS | <a id="sthref1621"></a>OCI_OBJECT</code>. <code>OCI_OBJECT</code> is required for grouping notifications.</div>
</li>
<li>
<p>Set he values of QOS, timeout interval, namespace, and port (see <a href="#CACFFAEH">Example 9-23</a>).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJGDFFFJ">"Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number"</a></div>
</li>
<li>
<p>Set <code>OCI_ATTR_SUBSCR_RECPTPROTO</code> to <code>OCI_SUBSCR_PROTO_OCI</code>, then define the callback routine to be used with the subscription handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i462244">"Notification Callback in OCI"</a></div>
</li>
<li>
<p>Set <code>OCI_ATTR_SUBSCR_RECPTPROTO</code> to <code>OCI_SUBSCR_PROTO_SERVER</code>, then define the PL/SQL procedure, to be invoked on notification, in the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i457165">"Notification Procedure"</a></div>
</li>
<li>
<p>Call <a href="oci17msc003.htm#i556638">OCISubscriptionRegister()</a> to register with the subscriptions. This call can register interest in several subscriptions at the same time.</p>
</li>
</ol>
<p><a href="#CACFFAEH">Example 9-23</a> shows an example of setting QOS levels.</p>
<div id="LNOCI18222" class="example">
<p class="titleinexample"><a id="CACFFAEH"></a>Example 9-23 Setting QOS Levels, the Notification Grouping Class, Value, and Type, and the Namespace Specific Context</p>
<pre>
/* Set QOS levels */
ub4 qosflags = OCI_SUBSCR_QOS_PAYLOAD;
 
/* Set QOS flags in subscription handle */
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;qosflags, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_QOSFLAGS, errhp);
 
/* Set notification grouping class */
ub4 ntfn_grouping_class = OCI_SUBSCR_NTFN_GROUPING_CLASS_TIME;
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;ntfn_grouping_class, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS, errhp);
 
/* Set notification grouping value of 10 minutes */
ub4 ntfn_grouping_value = 600;
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;ntfn_grouping_value, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE, errhp);
 
/* Set notification grouping type */
ub4 ntfn_grouping_type = OCI_SUBSCR_NTFN_GROUPING_TYPE_SUMMARY;
 
/* Set notification grouping type in subscription handle */
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) &amp;ntfn_grouping_type, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE, errhp);
 
/* Set namespace specific context */
(void) OCIAttrSet((dvoid *) subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (dvoid *) NULL, (ub4) 0,
                 (ub4) OCI_ATTR_SUBSCR_NAMESPACE_CTX, errhp);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CACFGBCA"></a>
<div id="LNOCI16718" class="sect3">
<h4 class="sect3">Open Registration for Publish-Subscribe</h4>
<p>Prerequisites for the open registration for publish-subscribe are as follows:</p>
<ul>
<li>
<p>Registering using LDAP (open registration) requires the client to be an enterprise user.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ASOAG9470" href="../../network.112/e40393/asointro.htm#ASOAG9470"><span class="italic">Oracle Database Advanced Security Administrator's Guide</span></a>, sections about managing enterprise user security</div>
</li>
</ul>
<ul>
<li>
<p>The compatibility of the database must be 9.0 or higher.</p>
</li>
<li>
<p><code>LDAP_REGISTRATION_ENABLED</code> must be set to <code>TRUE</code>. This can be done this way:</p>
<pre>
 ALTER SYSTEM SET LDAP_REGISTRATION_ENABLED=TRUE
</pre>
<p>The default is <code>FALSE</code>.</p>
</li>
<li>
<p><code>LDAP_REG_SYNC_INTERVAL</code> must be set to the time interval (in seconds) to refresh registrations from LDAP:</p>
<pre>
 ALTER SYSTEM SET LDAP_REG_SYNC_INTERVAL =  time_interval
</pre>
<p>The default is 0, which means do not refresh.</p>
</li>
<li>
<p>To force a database refresh of LDAP registration information immediately:</p>
<pre>
ALTER SYSTEM REFRESH LDAP_REGISTRATION
</pre></li>
</ul>
<p>The steps for open registration using Oracle Enterprise Security Manager (OESM) are:</p>
<ol>
<li>
<p>In each enterprise domain, create the enterprise role, <code>ENTERPRISE_AQ_USER_ROLE</code>.</p>
</li>
<li>
<p>For each database in the enterprise domain, add the global role <code>GLOBAL_AQ_USER_ROLE</code> to the enterprise role <code>ENTERPRISE_AQ_USER_ROLE</code>.</p>
</li>
<li>
<p>For each enterprise domain, add the enterprise role <code>ENTERPRISE_AQ_USER_ROLE</code> to the privilege group <code>cn=OracleDBAQUsers</code>, under <code>cn=oraclecontext</code>, under the administrative context.</p>
</li>
<li>
<p>For each enterprise user that is authorized to register for events in the database, grant the enterprise role <code>ENTERPRISE_AQ_USER_ROLE</code>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="LNOCI16719" class="sect3"><a id="sthref1622"></a>
<h4 class="sect3">Using OCI to Open Register with LDAP<a id="sthref1623"></a><a id="sthref1624"></a></h4>
<ol>
<li>
<p>Call <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> with <code>mode</code> set to <code>OCI_EVENTS</code> | <code>OCI_USE_LDAP</code>.</p>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set the following environment handle attributes for accessing LDAP:</p>
<ul>
<li>
<p><code><a id="sthref1625"></a>OCI_ATTR_LDAP_HOST</code>: the host name on which the LDAP server resides</p>
</li>
<li>
<p><code><a id="sthref1626"></a>OCI_ATTR_LDAP_PORT</code>: the port on which the LDAP server is listening</p>
</li>
<li>
<p><code><a id="sthref1627"></a>OCI_ATTR_BIND_DN</code>: the distinguished name to log in to the LDAP server, usually the DN of the enterprise user</p>
</li>
<li>
<p><code><a id="sthref1628"></a>OCI_ATTR_LDAP_CRED</code>: the credential used to authenticate the client, for example, the password for simple authentication (user name and password)</p>
</li>
<li>
<p><code><a id="sthref1629"></a>OCI_ATTR_WALL_LOC</code>: for SSL authentication, the location of the client wallet</p>
</li>
<li>
<p><code><a id="sthref1630"></a>OCI_ATTR_LDAP_AUTH</code>: the authentication method code</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428587">"Environment Handle Attributes"</a> for a complete list of authentication modes</div>
</li>
<li>
<p><code><a id="sthref1631"></a>OCI_ATTR_LDAP_CTX</code>: the administrative context for Oracle Database in the LDAP server</p>
</li>
</ul>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> with handle type <code>OCI_HTYPE_SUBSCRIPTION</code>, to allocate a subscription handle.</p>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i493114">OCIArrayDescriptorAlloc()</a> with descriptor type <code>OCI_DTYPE_SRVDN</code>, to allocate a server DN descriptor.</p>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set the server DN descriptor attributes for <code>OCI_ATTR_SERVER_DN</code>, the distinguished name of the database in which the client wants to receive notifications. <code>OCIAttrSet()</code> can be called multiple times for this attribute so that more than one database server is included in the registration.</p>
</li>
<li>
<p>Call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set the subscription handle attributes for:</p>
<ul>
<li>
<p><code><a id="sthref1632"></a>OCI_ATTR_SUBSCR_NAME</code> - subscription name</p>
</li>
<li>
<p><a id="sthref1633"></a><code>OCI_ATTR_SUBSCR_NAMESPACE</code> - subscription namespace</p>
</li>
<li>
<p><code><a id="sthref1634"></a>OCI_ATTR_SUBSCR_CALLBACK</code>- notification callback</p>
</li>
<li>
<p><code><a id="sthref1635"></a>OCI_ATTR_SUBSCR_CTX</code> - callback context</p>
</li>
<li>
<p><code><a id="sthref1636"></a>OCI_ATTR_SUBSCR_PAYLOAD</code> - payload buffer for posting</p>
</li>
<li>
<p><code><a id="sthref1637"></a>OCI_ATTR_SUBSCR_RECPT</code> - recipient name</p>
</li>
<li>
<p><code><a id="sthref1638"></a>OCI_ATTR_SUBSCR_RECPTPROTO</code> - protocol to receive notification with</p>
</li>
<li>
<p><code><a id="sthref1639"></a>OCI_ATTR_SUBSCR_RECPTRES</code> - presentation to receive notification with</p>
</li>
<li>
<p><code><a id="sthref1640"></a>OCI_ATTR_SUBSCR_QOSFLAGS</code> - QOS (quality of service) levels</p>
</li>
<li>
<p><code><a id="sthref1641"></a>OCI_ATTR_SUBSCR_TIMEOUT</code> - Registration timeout interval in seconds. The default is 0 if a timeout is not set.</p>
</li>
<li>
<p><a id="sthref1642"></a><code>OCI_ATTR_SUBSCR_SERVER_DN</code> - the descriptor handles you populated in Step 5</p>
</li>
</ul>
</li>
<li>
<p>The values of QOS, timeout interval, namespace, and port are set. See <a href="#CJGDFFFJ">"Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number"</a>.</p>
</li>
<li>
<p>Call <a href="oci17msc003.htm#i556638">OCISubscriptionRegister()</a> to register the subscriptions. The registration takes effect when the database accesses LDAP to pick up new registrations. The frequency of pickups is determined by the value of <code>LDAP_REG_SYNC_INTERVAL</code>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="CJGDFFFJ"></a>
<div id="LNOCI16720" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Setting QOS, Timeout Interval, Namespace, Client Address, and Port Number</h4>
<p>You can set QOSFLAGS to the following QOS levels using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>:</p>
<ul>
<li>
<p><a id="sthref1643"></a><code>OCI_SUBSCR_QOS_RELIABLE</code> - Reliable notification persists across instance and database restarts. Reliability is of the server only and is only for persistent queues or buffered messages. This option describes the persistence of the notifications. Registrations are persistent by default.</p>
</li>
<li>
<p><a id="sthref1644"></a><code>OCI_SUBSCR_QOS_PURGE_ON_NTFN</code> - Once notification is received, purge registration on first notification. (Subscription is unregistered.)</p>
</li>
</ul>
<pre>
/* Set QOS levels */
ub4 qosflags = OCI_SUBSCR_QOS_RELIABLE | OCI_SUBSCR_QOS_PURGE_ON_NTFN;

/* Set flags in subscription handle */
(void)OCIAttrSet((void *)subscrhp, (ub4)OCI_HTYPE_SUBSCRIPTION,
               (void *)&amp;qosflags, (ub4)0, (ub4)OCI_ATTR_SUBSCR_QOSFLAGS, errhp);

/* Set auto-expiration after 30 seconds */
ub4 timeout = 30;
(void)OCIAttrSet((void *)subscrhp, (ub4)OCI_HTYPE_SUBSCRIPTION,
                 (void *)&amp;timeout, (ub4)0, (ub4)OCI_ATTR_SUBSCR_TIMEOUT, errhp);
</pre>
<p>The registration is purged when the timeout is exceeded, and a notification is sent to the client, so that the client can invoke its callback and take any necessary action. For client failure before the timeout, the registration is purged.</p>
<p>You can set the port number on the environment handle, which is important if the client is on a system behind a firewall that can receive notifications only on certain ports. Clients can specify the port for the listener thread before the first registration, using an attribute in the environment handle. The thread is started the first time <a href="oci17msc003.htm#i556638">OCISubscriptionRegister()</a> is called. If available, this specified port number is used. An error is returned if the client tries to start another thread on a different port using a different environment handle.</p>
<pre>
ub4 port = 1581;
(void)OCIAttrSet((void *)envhp, (ub4)OCI_HTYPE_ENV, (void *)&amp;port, (ub4)0,
                 (ub4)OCI_ATTR_SUBSCR_PORTNO, errhp);
</pre>
<p>If instead, the port is determined automatically, you can get the port number at which the client thread is listening for notification by obtaining the attribute from the environment handle.</p>
<pre>
(void)OCIAttrGet((void *)subhp, (ub4)OCI_HTYPE_ENV, (void *)&amp;port, (ub4)0, 
                 (ub4)OCI_ATTR_SUBSCR_PORTNO, errhp);
</pre>
<p>Example to set client address:</p>
<pre>
text ipaddr[16] = "10.177.246.40";
(void)(OCIAttrSet((dvoid *) envhp, (ub4) OCI_HTYPE_ENV,
       (dvoid *) ipaddr, (ub4) strlen((const char *)ipaddr),
       (ub4) OCI_ATTR_SUBSCR_IPADDR, errhp));
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJHEBIA">"OCI_ATTR_SUBSCR_IPADDR"</a></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16721" class="sect3"><a id="sthref1645"></a>
<h4 class="sect3">OCI Functions Used to Manage Publish-Subscribe Notification</h4>
<p><a href="#CACBABFH">Table 9-13</a> lists the functions that are used to manage publish-subscribe notification.</p>
<div id="LNOCI16722" class="tblformal">
<p class="titleintable"><a id="sthref1646"></a><a id="CACBABFH"></a>Table 9-13 Publish-Subscribe Functions</p>
<table class="cellalignment1016" title="Publish-Subscribe Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t75">Function</th>
<th class="cellalignment1012" id="r1c2-t75">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t75" headers="r1c1-t75">
<p><a href="oci17msc003.htm#i556482">OCISubscriptionDisable()</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t75 r1c2-t75">
<p>Disables a subscription</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t75" headers="r1c1-t75">
<p><a href="oci17msc003.htm#i556532">OCISubscriptionEnable()</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t75 r1c2-t75">
<p>Enables a subscription</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t75" headers="r1c1-t75">
<p><a href="oci17msc003.htm#i556581">OCISubscriptionPost()</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t75 r1c2-t75">
<p>Posts a subscription</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t75" headers="r1c1-t75">
<p><a href="oci17msc003.htm#i556638">OCISubscriptionRegister()</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t75 r1c2-t75">
<p>Registers a subscription</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t75" headers="r1c1-t75">
<p><a href="oci17msc003.htm#i556699">OCISubscriptionUnRegister()</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t75 r1c2-t75">
<p>Unregisters a subscription</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i462244"></a>
<div id="LNOCI16723" class="sect2">
<h3 class="sect2"><a id="sthref1647"></a>Notification Callback in OCI</h3>
<p>The client must register a notification callback that gets invoked when there is some activity on the subscription for which interest has been registered. In the AQ namespace, for instance, this occurs when a message of interest is enqueued.</p>
<p>This callback is typically set through the <code>OCI_ATTR_SUBSCR_CALLBACK</code> attribute of the subscription handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i439205">"Subscription Handle Attributes"</a></div>
<p>The callback must return a value of <code>OCI_CONTINUE</code> and adhere to the following specification:</p>
<pre>
typedef ub4 (*OCISubscriptionNotify) ( void            *pCtx,
                                       OCISubscription *pSubscrHp,
                                       void            *pPayload,
                                       ub4             iPayloadLen,
                                       void            *pDescriptor,
                                       ub4             iMode);
</pre>
<p>The parameters are described as follows:</p>
<dl>
<dt>pCtx (IN)</dt>
<dd>
<p>A user-defined context specified when the callback was registered.</p>
</dd>
<dt>pSubscrHp (IN)</dt>
<dd>
<p>The subscription handle specified when the callback was registered.</p>
</dd>
<dt>pPayload (IN)</dt>
<dd>
<p>The payload for this notification. Currently, only ub1 * (a sequence of bytes) for the payload is supported.</p>
</dd>
<dt>iPayloadLen (IN)</dt>
<dd>
<p>The length of the payload for this notification.</p>
</dd>
<dt>pDescriptor (IN)</dt>
<dd>
<p>The namespace-specific descriptor. Namespace-specific parameters can be extracted from this descriptor. The structure of this descriptor is opaque to the user and its type is dependent on the namespace.</p>
<p>The attributes of the descriptor are namespace-specific. For Advanced Queuing (AQ), the descriptor is <code>OCI_DTYPE_AQNFY</code>. For the AQ namespace, the count of notifications received in the group is provided in the notification descriptor. The attributes of <code>pDescriptor</code> are:</p>
</dd>
</dl>
<ul>
<li>
<p>Notification flag (regular = 0, timeout = 1, or grouping notification = 2) - <code><a id="sthref1648"></a>OCI_ATTR_NFY_FLAGS</code></p>
</li>
<li>
<p>Queue name - <code><a id="sthref1649"></a>OCI_ATTR_QUEUE_NAME</code></p>
</li>
<li>
<p>Consumer name - <code><a id="sthref1650"></a>OCI_ATTR_CONSUMER_NAME</code></p>
</li>
<li>
<p>Message ID - <code><a id="sthref1651"></a>OCI_ATTR_NFY_MSGID</code></p>
</li>
<li>
<p>Message properties - <code><a id="sthref1652"></a>OCI_ATTR_MSG_PROP</code></p>
</li>
<li>
<p>Count of notifications received in the group - <code><a id="sthref1653"></a>OCI_ATTR_AQ_NTFN_GROUPING_COUNT</code></p>
</li>
<li>
<p>The group, an OCI collection - <code><a id="sthref1654"></a>OCI_ATTR_AQ_NTFN_GROUPING_MSGID_ARRAY</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i467582">"OCI and Streams Advanced Queuing"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#CHDBCADH">"Notification Descriptor Attributes"</a></p>
</li>
</ul>
</div>
<dl>
<dt>iMode (IN)</dt>
<dd>
<p>Call-specific mode. The only valid value is <code>OCI_DEFAULT</code>. This value executes the default call.</p>
</dd>
</dl>
<p><a href="#CACGEABA">Example 9-24</a> shows how to use AQ grouping notification attributes in a notification callback.</p>
<div id="LNOCI18223" class="example">
<p class="titleinexample"><a id="CACGEABA"></a>Example 9-24 Using AQ Grouping Notification Attributes in an OCI Notification Callback</p>
<pre>
ub4 notifyCB1(void *ctx, OCISubscription *subscrhp, void *pay, ub4 payl,
              void *desc, ub4 mode)
{
 oratext            *subname;
 ub4                 size;
 OCIColl            *msgid_array = (OCIColl *)0;
 ub4                 msgid_cnt = 0;
 OCIRaw             *msgid;
 void              **msgid_ptr;
 sb4                 num_msgid = 0;
 void               *elemind = (void *)0;
 boolean             exist;
 ub2                 flags;
 oratext            *hexit = (oratext *)"0123456789ABCDEF";
 ub4                 i, j;
 
 /* get subscription name */
 OCIAttrGet(subscrhp, OCI_HTYPE_SUBSCRIPTION, (void *)&amp;subname, &amp;size,
            OCI_ATTR_SUBSCR_NAME,ctxptr-&gt;errhp);
 
 /* print subscripton name */
 printf("Got notification for %.*s\n", size, subname);
 fflush((FILE *)stdout);
 
 /* get the #ntfns received in this group */
 OCIAttrGet(desc, OCI_DTYPE_AQNFY, (void *)&amp;msgid_cnt, &amp;size,
            OCI_ATTR_AQ_NTFN_GROUPING_COUNT, ctxptr-&gt;errhp);
 
 /* get the group - collection of msgids */
 OCIAttrGet(desc, OCI_DTYPE_AQNFY, (void *)&amp;msgid_array, &amp;size,
            OCI_ATTR_AQ_NTFN_GROUPING_MSGID_ARRAY, ctxptr-&gt;errhp);
 
 /* get notification flag - regular, timeout, or grouping notification? */
 OCIAttrGet(desc, OCI_DTYPE_AQNFY, (void *)&amp;flags, &amp;size,
            OCI_ATTR_NFY_FLAGS, ctxptr-&gt;errhp);
 
 /* print notification flag */
 printf("Flag: %d\n", (int)flags);
 
 /* get group (collection) size */
 if (msgid_array)
   checkerr(ctxptr-&gt;errhp,
        OCICollSize(ctxptr-&gt;envhp, ctxptr-&gt;errhp,
        CONST OCIColl *) msgid_array, &amp;num_msgid),
        "Inside notifyCB1-OCICollSize");
 else
   num_msgid =0;
 
 /* print group size */
 printf("Collection size: %d\n", num_msgid);
 
 /* print all msgids in the group */
 for(i = 0; i &lt; num_msgid; i++)
 {
   ub4  rawSize;                                             /* raw size    */
   ub1 *rawPtr;                                              /* raw pointer */
     /* get msgid from group */
   checkerr(ctxptr-&gt;errhp,
        OCICollGetElem(ctxptr-&gt;envhp, ctxptr-&gt;errhp,
               (OCIColl *) msgid_array, i, &amp;exist,
               (void **)(&amp;msgid_ptr), &amp;elemind),
        "Inside notifyCB1-OCICollGetElem");
   msgid = *msgid_ptr;
   rawSize = OCIRawSize(ctxptr-&gt;envhp, msgid);
   rawPtr = OCIRawPtr(ctxptr-&gt;envhp, msgid);
 
   /* print msgid size */
   printf("Msgid size: %d\n", rawSize);
 
   /* print msgid in hexadecimal format */
   for (j = 0; j &lt; rawSize; j++)
   {                                           /* for each byte in the raw */
     printf("%c", hexit[(rawPtr[j] &amp; 0xf0) &gt;&gt; 4]);
     printf("%c", hexit[(rawPtr[j] &amp; 0x0f)]);
   }
   printf("\n");
 }
 
 /* print #ntfns received in group */
 printf("Notification Count: %d\n", msgid_cnt);
 printf("\n");
 printf("***********************************************************\n");
 fflush((FILE *)stdout);
 return 1;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i457165"></a>
<div id="LNOCI16725" class="sect2">
<h3 class="sect2">Notification Procedure</h3>
<p>The PL/SQL notification procedure that is invoked when there is some activity on the subscription for which interest has been registered, must be created in the database.</p>
<p>This procedure is typically set through the <code>OCI_ATTR_SUBSCR_RECPT</code> attribute of the subscription handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#i439205">"Subscription Handle Attributes"</a></p>
</li>
<li>
<p>"Oracle Streams AQ PL/SQL Callback" in <a class="olink ARPLS401" href="../../appdev.112/e40758/d_aq.htm#ARPLS401"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for the PL/SQL procedure specification</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i471826"></a>
<div id="LNOCI16726" class="sect2">
<h3 class="sect2"><a id="sthref1655"></a>Publish-Subscribe Direct Registration Example</h3>
<p><a href="#CACHDEAE">Example 9-25</a> shows how system events, client notification, and Advanced Queuing work together to implement publish subscription notification.</p>
<p>The PL/SQL code in <a href="#CACHDEAE">Example 9-25</a> creates all objects necessary to support a publish-subscribe mechanism under the user schema <code>pubsub</code>. In this code, the Agent <code>snoop</code> subscribes to messages that are published at logon events. Note that the user <code>pubsub</code> needs <code>AQ_ADMINISTRATOR_ROLE</code> and <code>AQ_USER_ROLE</code> privileges to use Advance Queuing functionality. The initialization parameter <code>_SYSTEM_TRIG_ENABLED</code> must be set to <code>TRUE</code> (the default) to enable triggers for system events.<span class="bold"><a id="sthref1656"></a></span> Connect as <code>pubsub</code> before running <a href="#CACHDEAE">Example 9-25</a>.</p>
<div id="LNOCI18224" class="example">
<p class="titleinexample"><a id="CACHDEAE"></a>Example 9-25 Implementing a Publish Subscription Notification</p>
<pre>
----------------------------------------------------------
----create queue table for persistent multiple consumers
----------------------------------------------------------
---- Create or replace a queue table
begin
  DBMS_AQADM.CREATE_QUEUE_TABLE(
  QUEUE_TABLE=&gt;'pubsub.raw_msg_table', 
  MULTIPLE_CONSUMERS =&gt; TRUE,
  QUEUE_PAYLOAD_TYPE =&gt;'RAW',
  COMPATIBLE =&gt; '8.1.5');
end;
/
----------------------------------------------------------
---- Create a persistent queue for publishing messages
----------------------------------------------------------
---- Create a queue for logon events
begin
  DBMS_AQADM.CREATE_QUEUE(QUEUE_NAME=&gt;'pubsub.logon',
  QUEUE_TABLE=&gt;'pubsub.raw_msg_table',
  COMMENT=&gt;'Q for error triggers');
end;
/
----------------------------------------------------------
---- Start the queue
----------------------------------------------------------
begin
  DBMS_AQADM.START_QUEUE('pubsub.logon');
end;
/
----------------------------------------------------------
---- define new_enqueue for convenience
----------------------------------------------------------
create or replace procedure new_enqueue(queue_name  in varchar2,
                                        payload  in raw ,
correlation in varchar2 := NULL,
exception_queue in varchar2 := NULL)
as
  enq_ct     dbms_aq.enqueue_options_t;
  msg_prop   dbms_aq.message_properties_t;
  enq_msgid  raw(16);
  userdata   raw(1000);
begin
  msg_prop.exception_queue := exception_queue;
  msg_prop.correlation := correlation;
  userdata := payload;
  DBMS_AQ.ENQUEUE(queue_name,enq_ct, msg_prop,userdata,enq_msgid);
end;
/
----------------------------------------------------------
---- add subscriber with rule based on current user name, 
---- using correlation_id
----------------------------------------------------------
declare
subscriber sys.aq$_agent;
begin
  subscriber := sys.aq$_agent('SNOOP', null, null);
  dbms_aqadm.add_subscriber(queue_name =&gt; 'pubsub.logon',
                            subscriber =&gt; subscriber,
                            rule =&gt; 'CORRID = ''ix'' ');
end;
/
----------------------------------------------------------
---- create a trigger on logon on database
----------------------------------------------------------
---- create trigger on after logon
create or replace trigger systrig2
   AFTER LOGON
   ON DATABASE
   begin
     new_enqueue('pubsub.logon', hextoraw('9999'), dbms_standard.login_user);
   end;
/

----------------------------------------------------------
---- create a PL/SQL callback for notification of logon 
---- of user 'ix' on database
----------------------------------------------------------
---- 
create or replace procedure plsqlnotifySnoop(
  context raw, reginfo sys.aq$_reg_info, descr sys.aq$_descriptor,
  payload raw, payloadl number)
as
begin
 dbms_output.put_line('Notification : User ix Logged on\n');
end;
/
</pre></div>
<!-- class="example" -->
<p>After the subscriptions are created, the client must register for notification using callback functions. <a href="#CACBBGGJ">Example 9-26</a> shows sample code that performs the necessary steps for registration. The initial steps of allocating and initializing session handles are omitted here for clarity.</p>
<div id="LNOCI18225" class="example">
<p class="titleinexample"><a id="CACBBGGJ"></a>Example 9-26 Registering for Notification Using Callback Functions</p>
<pre>
...
static ub4 namespace = OCI_SUBSCR_NAMESPACE_AQ;

static OCISubscription *subscrhpSnoop = (OCISubscription *)0;
static OCISubscription *subscrhpSnoopMail = (OCISubscription *)0;
static OCISubscription *subscrhpSnoopServer = (OCISubscription *)0;

/* callback function for notification of logon of user 'ix' on database */

static ub4 notifySnoop(ctx, subscrhp, pay, payl, desc, mode)
    void *ctx;
    OCISubscription *subscrhp;
    void *pay;
    ub4 payl;
    void *desc;
    ub4 mode;
{
    printf("Notification : User ix Logged on\n");
  (void)OCIHandleFree((void *)subscrhpSnoop,
            (ub4) OCI_HTYPE_SUBSCRIPTION);
    return 1;
}

static void checkerr(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  ub4 buflen;
  sb4 errcode;

  if (status == OCI_SUCCESS) return;

  switch (status)
  {
  case OCI_SUCCESS_WITH_INFO:
    printf("Error - OCI_SUCCESS_WITH_INFO\n");
    break;
  case OCI_NEED_DATA:
    printf("Error - OCI_NEED_DATA\n");
    break;
  case OCI_NO_DATA:
    printf("Error - OCI_NO_DATA\n");
    break;
  case OCI_ERROR:
    OCIErrorGet ((void *) errhp, (ub4) 1, (text *) NULL, &amp;errcode,
            errbuf, (ub4) sizeof(errbuf), (ub4) OCI_HTYPE_ERROR);
    printf("Error - %s\n", errbuf);
    break;
  case OCI_INVALID_HANDLE:
    printf("Error - OCI_INVALID_HANDLE\n");
    break;
  case OCI_STILL_EXECUTING:
    printf("Error - OCI_STILL_EXECUTING\n");
    break;
  case OCI_CONTINUE:
    printf("Error - OCI_CONTINUE\n");
    break;
  default:
    printf("Error - %d\n", status);
    break;
  }
}

static void initSubscriptionHn (subscrhp,
                         subscriptionName,
                         func,
                         recpproto,
                         recpaddr,
                         recppres)
OCISubscription **subscrhp;
  char * subscriptionName;
  void * func;
  ub4 recpproto;
  char * recpaddr;
  ub4 recppres;
{
    /* allocate subscription handle */
    (void) OCIHandleAlloc((void *) envhp, (void **)subscrhp,
        (ub4) OCI_HTYPE_SUBSCRIPTION,
        (size_t) 0, (void **) 0);

    /* set subscription name in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) subscriptionName,
        (ub4) strlen((char *)subscriptionName),
        (ub4) OCI_ATTR_SUBSCR_NAME, errhp);

    /* set callback function in handle */
    if (func)
      (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
          (void *) func, (ub4) 0,
          (ub4) OCI_ATTR_SUBSCR_CALLBACK, errhp);

    /* set context in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) 0, (ub4) 0,
       (ub4) OCI_ATTR_SUBSCR_CTX, errhp);

    /* set namespace in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) &amp;namespace, (ub4) 0,
        (ub4) OCI_ATTR_SUBSCR_NAMESPACE, errhp);

    /* set receive with protocol in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) &amp;recpproto, (ub4) 0,
        (ub4) OCI_ATTR_SUBSCR_RECPTPROTO, errhp);

    /* set recipient address in handle */
    if (recpaddr)
      (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
          (void *) recpaddr, (ub4) strlen(recpaddr),
          (ub4) OCI_ATTR_SUBSCR_RECPT, errhp);

    /* set receive with presentation in handle */
    (void) OCIAttrSet((void *) *subscrhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
        (void *) &amp;recppres, (ub4) 0,
        (ub4) OCI_ATTR_SUBSCR_RECPTPRES, errhp);

    printf("Begining Registration for subscription %s\n", subscriptionName);
    checkerr(errhp, OCISubscriptionRegister(svchp, subscrhp, 1, errhp,
        OCI_DEFAULT));
   printf("done\n");

}


int main( argc, argv)
int    argc;
char * argv[];
{
    OCISession *authp = (OCISession *) 0;

/*****************************************************
Initialize OCI Process/Environment
Initialize Server Contexts
Connect to Server
Set Service Context
******************************************************/

/* Registration Code Begins */
/* Each call to initSubscriptionHn allocates
   and initializes a Registration Handle */

/* Register for OCI notification */
    initSubscriptionHn(    &amp;subscrhpSnoop,    /* subscription handle*/
    (char*) "PUBSUB.LOGON:SNOOP", /* subscription name */
                                  /*&lt;queue_name&gt;:&lt;agent_name&gt; */
        (void*)notifySnoop,  /* callback function */
        OCI_SUBSCR_PROTO_OCI, /* receive with protocol */
        (char *)0, /* recipient address */
        OCI_SUBSCR_PRES_DEFAULT); /* receive with presentation */

/* Register for email notification */
    initSubscriptionHn(    &amp;subscrhpSnoopMail,  /* subscription handle */
     (char*) "PUBSUB.LOGON:SNOOP",              /* subscription name */ 
                                                /* &lt;queue_name&gt;:&lt;agent_name&gt; */
        (void*)0, /* callback function */
        OCI_SUBSCR_PROTO_MAIL, /* receive with protocol */
        (char*)  "xyz@company.com", /* recipient address */
        OCI_SUBSCR_PRES_DEFAULT); /* receive with presentation */

/* Register for server to server notification */
    initSubscriptionHn(    &amp;subscrhpSnoopServer, /* subscription handle */
       (char*)  "PUBSUB.LOGON:SNOOP",            /* subscription name */
                                                 /* &lt;queue_name&gt;:&lt;agent_name&gt; */
        (void*)0, /* callback function */
        OCI_SUBSCR_PROTO_SERVER, /* receive with protocol */
         (char*) "pubsub.plsqlnotifySnoop", /* recipient address */
        OCI_SUBSCR_PRES_DEFAULT); /* receive with presentation */

    checkerr(errhp, OCITransCommit(svchp, errhp, (ub4) OCI_DEFAULT));

/*****************************************************
The Client Process does not need a live Session for Callbacks.
End Session and Detach from Server.
******************************************************/

    OCISessionEnd ( svchp,  errhp, authp, (ub4) OCI_DEFAULT);

    /* detach from server */
    OCIServerDetach( srvhp, errhp, OCI_DEFAULT);

   while (1)    /* wait for callback */
    sleep(1);
}
</pre></div>
<!-- class="example" -->
<p>If user <code>IX</code> logs on to the database, the client is notified by email, and the callback function <code>notifySnoop</code> is called. An email notification is sent to the address xyz@company.com and the PL/SQL procedure <code>plsqlnotifySnoop</code> is also called in the database.</p>
</div>
<!-- class="sect2" -->
<a id="i463278"></a>
<div id="LNOCI16727" class="sect2">
<h3 class="sect2">Publish-Subscribe LDAP Registration Example</h3>
<p><a href="#CACBFFEB">Example 9-27</a> shows a code fragment that illustrates how to do LDAP registration. Please read all the program comments.</p>
<div id="LNOCI18226" class="example">
<p class="titleinexample"><a id="CACBFFEB"></a>Example 9-27 LDAP Registration</p>
<pre>
...

  /* To use the LDAP registration feature, OCI_EVENTS | OCI_EVENTS |OCI_USE_LDAP*/
  /*   must be set in OCIEnvCreate or OCIEnvNlsCreate */
  /*     (Note: OCIInitialize is deprecated): */
  (void) OCIInitialize((ub4) OCI_EVENTS|OCI_OBJECT|OCI_USE_LDAP, (void *)0,
                       (void * (*)(void *, size_t)) 0,
                       (void * (*)(void *, void *, size_t))0,
                       (void (*)(void *, void *)) 0 );

...

  /* set LDAP attributes in the environment handle */

  /* LDAP host name */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)"yow", 3,
                    OCI_ATTR_LDAP_HOST, (OCIError *)errhp);

  /* LDAP server port */ 
  ldap_port = 389;
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;ldap_port,
                    (ub4)0, OCI_ATTR_LDAP_PORT, (OCIError *)errhp);

  /* bind DN of the client, normally the enterprise user name */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)"cn=orcladmin",
                    12, OCI_ATTR_BIND_DN, (OCIError *)errhp);

  /* password of the client */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)"welcome",
                    7, OCI_ATTR_LDAP_CRED, (OCIError *)errhp);

  /* authentication method is "simple", username/password authentication */
  ldap_auth = 0x01;
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;ldap_auth,
                    (ub4)0, OCI_ATTR_LDAP_AUTH, (OCIError *)errhp);

  /* administrative context: this is the DN above cn=oraclecontext */
  (void) OCIAttrSet((void *)envhp, OCI_HTYPE_ENV, (void *)"cn=acme,cn=com",
                    14, OCI_ATTR_LDAP_CTX, (OCIError *)errhp);

...

  /* retrieve the LDAP attributes from the environment handle */

  /* LDAP host */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_LDAP_HOST,  (OCIError *)errhp);

  /* LDAP server port */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;intval, 
                    0,  OCI_ATTR_LDAP_PORT,  (OCIError *)errhp);

  /* client binding DN */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_BIND_DN,  (OCIError *)errhp);

  /* client password */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_LDAP_CRED,  (OCIError *)errhp);

  /* administrative context */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;buf, 
                    &amp;szp,  OCI_ATTR_LDAP_CTX,  (OCIError *)errhp);

  /* client authentication method */
  (void) OCIAttrGet((void *)envhp, OCI_HTYPE_ENV, (void *)&amp;intval, 
                    0,  OCI_ATTR_LDAP_AUTH,  (OCIError *)errhp);
  
  ...

  /* to set up the server DN descriptor in the subscription handle */

  /* allocate a server DN descriptor, dn is of type "OCIServerDNs **", 
     subhp is of type "OCISubscription **" */
  (void) OCIDescriptorAlloc((void *)envhp, (void **)dn, 
                         (ub4) OCI_DTYPE_SRVDN, (size_t)0, (void **)0);

  /* now *dn is the server DN descriptor, add the DN of the first database 
     that you want to register */
  (void) OCIAttrSet((void *)*dn, (ub4) OCI_DTYPE_SRVDN, 
                    (void *)"cn=server1,cn=oraclecontext,cn=acme,cn=com",
                    42, (ub4)OCI_ATTR_SERVER_DN, errhp);
  /* add the DN of another database in the descriptor */
  (void) OCIAttrSet((void *)*dn, (ub4) OCI_DTYPE_SRVDN, 
                    (void *)"cn=server2,cn=oraclecontext,cn=acme,cn=com",
                    42, (ub4)OCI_ATTR_SERVER_DN, errhp);

  /* set the server DN descriptor into the subscription handle */
  (void) OCIAttrSet((void *) *subhp, (ub4) OCI_HTYPE_SUBSCRIPTION,
                 (void *) *dn, (ub4)0, (ub4) OCI_ATTR_SERVER_DNS, errhp);

  ...

  /* now you will try to get the server DN information from the subscription
     handle */
 
  /* first, get the server DN descriptor out */
  (void) OCIAttrGet((void *) *subhp, (ub4) OCI_HTYPE_SUBSCRIPTION, 
                    (void *)dn, &amp;szp, OCI_ATTR_SERVER_DNS, errhp);

  /* then, get the number of server DNs in the descriptor */
  (void) OCIAttrGet((void *) *dn, (ub4)OCI_DTYPE_SRVDN, (void *)&amp;intval,
                    &amp;szp, (ub4)OCI_ATTR_DN_COUNT, errhp);

  /* allocate an array of char * to hold server DN pointers returned by
     an Oracle database*/
    if (intval)
    {
      arr = (char **)malloc(intval*sizeof(char *));
      (void) OCIAttrGet((void *)*dn, (ub4)OCI_DTYPE_SRVDN, (void *)arr,
                        &amp;intval, (ub4)OCI_ATTR_SERVER_DN, errhp);
    }

  /* OCISubscriptionRegister() calls have two modes: OCI_DEFAULT and 
     OCI_REG_LDAPONLY. If OCI_DEFAULT is used, there should be only one
     server DN in the server DN descriptor. The registration request will
     be sent to the database. If a database connection is not available,
     the registration request will be detoured to the LDAP server. However,
     if mode OCI_REG_LDAPONLY is used, the registration request
     will be directly sent to LDAP. This mode should be used when there is 
     more than one server DN in the server DN descriptor or you are sure
     that a database connection is not available.

     In this example, two DNs are entered, so you should use mode 
     OCI_REG_LDAPONLY in LDAP registration. */
  OCISubscriptionRegister(svchp, subhp, 1, errhp, OCI_REG_LDAPONLY);

  ...

  /* as OCISubscriptionRegister(), OCISubscriptionUnregister() also has
     mode OCI_DEFAULT and OCI_REG_LDAPONLY. The usage is the same. */

  OCISubscriptionUnRegister(svchp, *subhp, errhp, OCI_REG_LDAPONLY);
}
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci08sca.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci10new.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
