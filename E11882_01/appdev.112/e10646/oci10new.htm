<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>More OCI Advanced Topics</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:23Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci09adv.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci11obj.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/79</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='oci10new'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="LNOCI092" class="chapter"><a id="g489978"></a> <a id="i441219"></a>
<h1 class="chapter"><span class="secnum">10</span> More OCI Advanced Topics</h1>
<p>You can use OCI to access Oracle <a id="sthref1657"></a>TimesTen In-Memory Database and Oracle TimesTen Application-Tier Database Cache. See <a class="olink TTCDV190" href="../../timesten.112/e21637/oci.htm#TTCDV190"><span class="italic">Oracle TimesTen In-Memory Database C Developer's Guide</span></a><span class="italic">,</span> for information about Times Ten support for Oracle Call Interface.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CJGHFEDD">Continuous Query Notification</a></p>
</li>
<li>
<p><a href="#CJGDJFAF">Database Startup and Shutdown</a></p>
</li>
<li>
<p><a href="#CHDDIGCG">Implicit Fetching of ROWIDs</a></p>
</li>
<li>
<p><a href="#CHDGGFEF">Client Result Cache</a></p>
</li>
<li>
<p><a href="#CHDCIAHJ">Fault Diagnosability in OCI</a></p>
</li>
<li>
<p><a href="#CJADCGBB">Client and Server Operating with Different Versions of Time Zone Files</a></p>
</li>
</ul>
<a id="CJGHFEDD"></a>
<div id="LNOCI13111" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1658"></a>Continuous Query Notification</h2>
<p>Continuous Query Notification enables client applications to register queries with the database and receive notifications in response to DML or DDL changes on the objects or in response to result set changes associated with the queries. The notifications are published by the database when the DML or DDL transaction commits.</p>
<p>During registration, the application specifies a notification handler and associates a set of interesting queries with the notification handler. A notification handler can be either a server-side PL/SQL procedure or a client-side C callback. Registrations are created at either the object level or the query level. If registration is at the object level, then whenever a transaction changes any of the registered objects and commits, the notification handler is invoked. If registration is at the query level, then whenever a transaction commits changes such that the result set of the query is modified, the notification handler is invoked, but if the changes do not affect the result set of the query, the notification handler is not invoked.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADFNS018" href="../../appdev.112/e41502/adfns_cqn.htm#ADFNS018"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>, "Using Continuous Query Notification" for a complete discussion of the concepts of this feature</div>
<p>One use of continuous query notification is in middle-tier applications that must have cached data and keep the cache as recent as possible for the back-end database.</p>
<p>The notification includes the following information:</p>
<ul>
<li>
<p>Query IDs of queries whose result sets have changed. This is if the registration was at query granularity.</p>
</li>
<li>
<p>Names of the modified objects or changed rows.</p>
</li>
<li>
<p>Operation type (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>ALTER</code> <code>TABLE</code>, <code>DROP</code> <code>TABLE</code>).</p>
</li>
<li>
<p><code>ROWID</code>s of the changed rows and the associated DML operation (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>).</p>
</li>
<li>
<p>Global database events (<code>STARTUP</code>, <code>SHUTDOWN</code>). In Oracle Real Application Cluster (Oracle RAC) the database delivers a notification when the first instance starts or the last instance shuts down.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci09adv.htm#i435757">"Publish-Subscribe Notification in OCI"</a></div>
<div id="LNOCI16728" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1659"></a>
<h3 class="sect2">Using Query Result Set Notifications</h3>
<p>To record QOS (quality of service flags) specific to continuous query (CQ) notifications, set the attribute <code>OCI_ATTR_SUBSCR_CQ_QOSFLAGS</code> on the subscription handle <code>OCI_HTYPE_SUBSCR</code>. To request that the registration is at query granularity, as opposed to object granularity, set the <code>OCI_SUBSCR_CQ_QOS_QUERY</code> flag bit on the attribute <code>OCI_ATTR_SUBSCR_CQ_QOSFLAGS</code>.</p>
<p>The pseudocolumn <code>CQ_NOTIFICATION_QUERY_ID</code> can be optionally specified to retrieve the query ID of a registered query. Note that this does not automatically convert the granularity to query level. The value of the pseudocolumn on return is set to the unique query ID assigned to the query. The query ID pseudocolumn can be omitted for OCI-based registrations, in which case the query ID is returned as a <code>READ</code> attribute of the statement handle. (This attribute is called <code>OCI_ATTR_CQ_QUERYID</code>).</p>
<p>During notifications, the client-specified callback is invoked and the top-level notification descriptor is passed as an argument.</p>
<p>Information about the query IDs of the changed queries is conveyed through a special descriptor type called <code>OCI_DTYPE_CQDES</code>. A collection (<code>OCIColl</code>) of query descriptors is embedded inside the top-level notification descriptor. Each descriptor is of type <code>OCI_DTYPE_CQDES</code>. The query descriptor has the following attributes:</p>
<ul>
<li>
<p><code>OCI_ATTR_CQDES_OPERATION</code> - can be one of <code>OCI_EVENT_QUERYCHANGE</code> or <code>OCI_EVENT_DEREG</code>.</p>
</li>
<li>
<p><code>OCI_ATTR_CQDES_QUERYID</code> - query ID of the changed query.</p>
</li>
<li>
<p><code>OCI_ATTR_CQDES_TABLE_CHANGES</code> - array of table descriptors describing DML operations on tables that led to the query result set change. Each table descriptor is of the type <code>OCI_DTYPE_TABLE_CHDES</code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDHFFDB">"OCI_DTYPE_CQDES"</a></div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16729" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1660"></a>
<h3 class="sect2">Registering for Continuous Query Notification</h3>
<p>The calling session must have the <code>CHANGE</code> <code>NOTIFICATION</code> system privilege and <code>SELECT</code> privileges on all objects that it attempts to register. A registration is a persistent entity that is recorded in the database, and is visible to all instances of Oracle RAC. If the registration was at query granularity, transactions that cause the query result set to change and commit in any instance of Oracle RAC generate notification.If the registration was at object granularity, transactions that modify registered objects in any instance of Oracle RAC generate notification.</p>
<p>Queries involving materialized views or nonmaterialized views are <span class="italic">not</span> supported.</p>
<p>The registration interface employs a callback to respond to changes in underlying objects of a query and uses a namespace extension (<code>DBCHANGE</code>) to AQ.</p>
<p>The steps in writing the registration are as follows:</p>
<ol>
<li>
<p>Create the environment in <code>OCI_EVENTS</code> and <code>OCI_OBJECT</code> mode.</p>
</li>
<li>
<p>Set the subscription handle attribute <code>OCI_ATTR_SUBSCR_NAMESPACE</code> to namespace <code>OCI_SUBSCR_NAMESPACE_DBCHANGE</code>.</p>
</li>
<li>
<p>Set the subscription handle attribute <code>OCI_ATTR_SUBSCR_CALLBACK</code> to store the OCI callback associated with the query handle. The callback has the following prototype:</p>
<pre>
void notification_callback (void *ctx, OCISubscription *subscrhp, 
                            void *payload, ub4 paylen, void *desc, ub4 mode);
</pre>
<p>The parameters are described in <a href="oci09adv.htm#i462244">"Notification Callback in OCI"</a>.</p>
</li>
<li>
<p>Optionally associate a client-specific context using <code>OCI_ATTR_SUBSCR_CTX</code> attribute.</p>
</li>
<li>
<p>Set the <code>OCI_ATTR_SUBSCR_TIMEOUT</code> attribute to specify a <code>ub4</code> timeout interval in seconds. If it is not set, there is no timeout.</p>
</li>
<li>
<p>Set the <code>OCI_ATTR_SUBSCR_QOSFLAGS</code> attribute, the QOS (quality of service) levels, with the following values:</p>
<ul>
<li>
<p>The <code>OCI_SUBSCR_QOS_PURGE_ON_NTFN</code> flag allows the registration to be purged on the first notification.</p>
</li>
<li>
<p>The <code>OCI_SUBSCR_QOS_RELIABLE</code> flag allows notifications to be persistent. You can use surviving instances of Oracle RAC to send and retrieve continuous query notification messages, even after a node failure, because invalidations associated with this registration are queued persistently into the database. If <code>FALSE</code>, then invalidations are enqueued into a fast in-memory queue. Note that this option describes the persistence of notifications and not the persistence of registrations. Registrations are automatically persistent by default.</p>
</li>
</ul>
</li>
<li>
<p>Call <a href="oci17msc003.htm#i556638">OCISubscriptionRegister()</a> to create a new registration in the <code>DBCHANGE</code> namespace.</p>
</li>
<li>
<p>Associate multiple query statements with the subscription handle by setting the attribute <code>OCI_ATTR_CHNF_REGHANDLE</code> of the statement handle, <code>OCI_HTYPE_STMT</code>. The registration is completed when the query is executed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#CHDEDAEA">"OCI_ATTR_CHNF_REGHANDLE"</a></div>
</li>
<li>
<p>Optionally unregister a subscription. The client can call the <a href="oci17msc003.htm#i556699">OCISubscriptionUnRegister()</a> function with the subscription handle as a parameter.</p>
</li>
</ol>
<p>A binding of a statement handle to a subscription handle is only valid for the first execution of a query. If the application must use the same OCI statement handle for subsequent executions, it must repopulate the registration handle attribute of the statement handle. A binding of a subscription handle to a statement handle is only permitted when the statement is a query (determined at execute time). If a DML statement is executed as part of the execution, then an exception is issued.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFCCJE"></a>
<div id="LNOCI16730" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Subscription Handle Attributes for Continuous Query Notification</h3>
<p>The subscription handle attributes for continuous query notification can be divided into generic attributes (common to all subscriptions) and namespace-specific attributes (particular to continuous query notification).</p>
<p>The <code>WRITE</code> attributes on the statement handle can only be modified before the registration is created.</p>
<p class="subhead2"><a id="LNOCI18227"></a>Generic Attributes - Common to All Subscriptions</p>
<p><code><a id="sthref1661"></a>OCI_ATTR_SUBSCR_NAMESPACE</code> (<code>WRITE</code>) - Set this attribute to <code>OCI_SUBSCR_NAMESPACE_DBCHANGE</code> for subscription handles.</p>
<p><a id="sthref1662"></a><code>OCI_ATTR_SUBSCR_CALLBACK</code> (<code>WRITE</code>) - Use this attribute to store the callback associated with the subscription handle. The callback is executed when a notification is received.</p>
<p>When a new continuous query notification message becomes available, the callback is invoked in the listener thread with <code>desc</code> pointing to a descriptor of type <code>OCI_DTYPE_CHDES</code> that contains detailed information about the invalidation.</p>
<p><code><a id="sthref1663"></a>OCI_ATTR_SUBSCR_QOSFLAGS</code> - This attribute is a generic flag with the following values:</p>
<pre>
#define OCI_SUBSCR_QOS_RELIABLE             0x01                 /* reliable */
#define OCI_SUBSCR_QOS_PURGE_ON_NTFN        0x10      /* purge on first ntfn */
</pre>
<ul>
<li>
<p><code><a id="sthref1664"></a>OCI_SUBSCR_QOS_RELIABLE</code> - Set this bit to allow notifications to be persistent. Therefore, you can use surviving instances of an Oracle RAC cluster to send and retrieve invalidation messages, even after a node failure, because invalidations associated with this registration ID are queued persistently into the database. If this bit is <code>FALSE</code>, then invalidations are enqueued in to a fast in-memory queue. Note that this option describes the persistence of notifications and not the persistence of registrations. Registrations are automatically persistent by default.</p>
</li>
<li>
<p><a id="sthref1665"></a><code>OCI_SUBSCR_QOS_PURGE_ON_NTFN</code> - Set this bit to allow the registration to be purged on the first notification.</p>
</li>
</ul>
<p>A parallel example is presented in <a href="oci09adv.htm#i462621">"Publish-Subscribe Registration Functions in OCI"</a>.</p>
<p><a id="sthref1666"></a><code>OCI_ATTR_SUBSCR_CQ_QOSFLAGS</code> - This attribute describes the continuous query notification-specific QOS flags (mode is <code>WRITE</code>, data type is <code>ub4</code>), which are:</p>
<ul>
<li>
<p><code>0x1 OCI_SUBSCR_CQ_QOS_QUERY</code> - Set this flag to indicate that query-level granularity is required. Notification should be only generated if the query result set changes. By default, this level of QOS has no false positives.</p>
</li>
<li>
<p><code>0x2 OCI_SUBSCR_CQ_QOS_BEST_EFFORT</code> - Set this flag to indicate that best effort filtering is acceptable. It may be used by caching applications. The database may use heuristics based on cost of evaluation and avoid full pruning in some cases.</p>
</li>
</ul>
<p><a id="sthref1667"></a><code>OCI_ATTR_SUBSCR_TIMEOUT</code> - Use this attribute to specify a <code>ub4</code> timeout value defined in seconds. If the timeout value is 0 or not specified, then the registration is active until explicitly unregistered.</p>
<p class="subhead2"><a id="LNOCI18228"></a>Namespace- Specific or Feature-Specific Attributes</p>
<p>The following attributes are namespace-specific or feature-specific to the continuous query notification feature.</p>
<p><code><a id="sthref1668"></a>OCI_ATTR_CHNF_TABLENAMES</code> (data type is <code>(OCIColl *)</code>) - These attributes are provided to retrieve the list of table names that were registered. These attributes are available from the subscription handle, after the query is executed.</p>
<p><a id="sthref1669"></a><code>OCI_ATTR_CHNF_ROWIDS</code> - A Boolean attribute (default <code>FALSE</code>). If set to <code>TRUE</code>, then the continuous query notification message includes row-level details such as operation type and <code>ROWID</code>.</p>
<p><code><a id="sthref1670"></a>OCI_ATTR_CHNF_OPERATIONS</code> - Use this <code>ub4</code> flag to selectively filter notifications based on operation type. This option is ignored if the registration is of query-level granularity. Flags stored are as follows:</p>
<ul>
<li>
<p><code>OCI_OPCODE_ALL</code> - All operations</p>
</li>
<li>
<p><code>OCI_OPCODE_INSERT</code> - Insert operations on the table</p>
</li>
<li>
<p><code>OCI_OPCODE_UPDATE</code> - Update operations on the table</p>
</li>
<li>
<p><code>OCI_OPCODE_DELETE</code> - Delete operations on the table</p>
</li>
</ul>
<p><a id="sthref1671"></a><code>OCI_ATTR_CHNF_CHANGELAG</code> - The client can use this <code>ub4</code> value to specify the number of transactions by which the client is willing to lag behind. The client can also use this option as a throttling mechanism for continuous query notification messages. When you choose this option, <code>ROWID</code>-level granularity of information is not available in the notifications, even if <code>OCI_ATTR_CHNF_ROWIDS</code> was set to <code>TRUE</code>. This option is ignored if the registration is of query-level granularity.</p>
<p>Once the <a href="oci17msc003.htm#i556638">OCISubscriptionRegister()</a> call is invoked, none of the preceding attributes (generic, name-specific, or feature-specific) can be modified on the registration already created. Any attempt to modify those attributes is not reflected on the registration already created, but it does take effect on newly created registrations that use the same registration handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJHGABI">"Continuous Query Notification Attributes"</a></div>
<p>Notifications can be spaced out by using the grouping NTFN option. The relevant generic notification attributes are:</p>
<pre>
OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE
OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE
OCI_ATTR_SUBSCR_NTFN_GROUPING_START_TIME
OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci09adv.htm#CHDDHHEE">"Publish-Subscribe Register Directly to the Database"</a> for more details about these attributes</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16731" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1672"></a>
<h3 class="sect2">Using <a id="sthref1673"></a>OCI_ATTR_CQ_QUERYID Attribute</h3>
<p>The attribute <code>OCI_ATTR_CQ_QUERYID</code> on the statement handle, <code>OCI_HTYPE_STMT</code>, obtains the query ID of a registered query after registration is made by the call to <code>OCIStmtExecute()</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#CHDFHDBF">"OCI_ATTR_CQ_QUERYID"</a></div>
</div>
<!-- class="sect2" -->
<a id="CJGHGDCC"></a>
<div id="LNOCI16732" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Continuous Query Notification Descriptors</h3>
<p>The continuous query notification descriptor is passed into the <code>desc</code> parameter of the notification callback specified by the application. The following attributes are specific to continuous query notification. The OCI type constant of the continuous query notification descriptor is <code>OCI_DTYPE_CHDES</code>.</p>
<p>The notification callback receives the top-level notification descriptor, <code>OCI_DTYPE_CHDES</code>, as an argument. This descriptor in turn includes either a collection of <code>OCI_DTYPE_CQDES</code> or <code>OCI_DTYPE_TABLE_CHDES</code> descriptors based on whether the event type was <code>OCI_EVENT_QUERYCHANGE</code> or <code>OCI_EVENT_OBJCHANGE</code>. An array of table continuous query descriptors is embedded inside the continuous query descriptor for notifications of type <code>OCI_EVENT_QUERYCHANGE</code>. If <code>ROWID</code> level granularity of information was requested, each <code>OCI_DTYPE_TABLE_CHDES</code> contains an array of row-level continuous query descriptors (<code>OCI_DTYPE_ROW_CHDES</code>) corresponding to each modified <code>ROWID</code>.</p>
<div id="LNOCI16733" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1674"></a>
<h4 class="sect3">OCI_DTYPE_CHDES</h4>
<p>This is the top-level continuous query notification descriptor type.</p>
<p><a id="sthref1675"></a><code>OCI_ATTR_CHDES_DBNAME</code> (<code>oratext *</code>) - Name of the database (source of the continuous query notification)</p>
<p><a id="sthref1676"></a><code>OCI_ATTR_CHDES_XID</code> (<code>RAW(8)</code>) - Message ID of the message</p>
<p><a id="sthref1677"></a><code>OCI_ATTR_CHDES_NFYTYPE</code> - Flags describing the notification type:</p>
<ul>
<li>
<p><code>0x0 OCI_EVENT_NONE</code> - No further information about the continuous query notification</p>
</li>
<li>
<p><code>0x1 OCI_EVENT_STARTUP</code> - Instance startup</p>
</li>
<li>
<p><code>0x2 OCI_EVENT_SHUTDOWN</code> - Instance shutdown</p>
</li>
<li>
<p><code>0x3 OCI_EVENT_SHUTDOWN_ANY</code> - Any instance shutdown - Oracle Real Application Clusters (Oracle RAC)</p>
</li>
<li>
<p><code>0x5 OCI_EVENT_DEREG</code> - Unregistered or timed out</p>
</li>
<li>
<p><code>0x6 OCI_EVENT_OBJCHANGE</code> - Object change notification</p>
</li>
<li>
<p><code>0x7 OCI_EVENT_QUERYCHANGE</code> - Query change notification</p>
</li>
</ul>
<p><a id="sthref1678"></a><code>OCI_ATTR_CHDES_TABLE_CHANGES</code> - A collection type describing operations on tables of data type <code>(OCIColl *)</code>. This attribute is present only if the <code>OCI_ATTR_CHDES_NFTYPE</code> attribute was of type <code>OCI_EVENT_OBJCHANGE</code>; otherwise, it is <code>NULL</code>. Each element of the collection is a table of continuous query descriptors of type <code>OCI_DTYPE_TABLE_CHDES</code>.</p>
<p><code><a id="sthref1679"></a>OCI_ATTR_CHDES_QUERIES</code> - A collection type describing the queries that were invalidated. Each member of the collection is of type <code>OCI_DTYPE_CQDES</code>. This attribute is present only if the attribute <code>OCI_ATTR_CHDES_NFTYPE</code> was of type <code>OCI_EVENT_QUERYCHANGE</code>; otherwise, it is <code>NULL</code>.</p>
<a id="CHDHFFDB"></a>
<div id="LNOCI16734" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4"><a id="sthref1680"></a>OCI_DTYPE_CQDES</h5>
<p>This notification descriptor describes a query that was invalidated, usually in response to the commit of a DML or a DDL transaction. It has the following attributes:</p>
<ul>
<li>
<p><a id="sthref1681"></a><code>OCI_ATTR_CQDES_OPERATION</code> (<code>ub4</code>, <code>READ</code>) - Operation that occurred on the query. It can be one of these values:</p>
<ul>
<li>
<p><code>OCI_EVENT_QUERYCHANGE</code> - Query result set change</p>
</li>
<li>
<p><code>OCI_EVENT_DEREG</code> - Query unregistered</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref1682"></a><code>OCI_ATTR_CQDES_TABLE_CHANGES</code> (<code>OCIColl *</code>, <code>READ</code>) - A collection of table continuous query descriptors describing DML or DDL operations on tables that caused the query result set change. Each element of the collection is of type <code>OCI_DTYPE_TABLE_CHDES</code>.</p>
</li>
<li>
<p><a id="sthref1683"></a><code>OCI_ATTR_CQDES_QUERYID</code> (<code>ub8</code>, <code>READ</code>) - Query ID of the query that was invalidated.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="CHDFHJJB"></a>
<div id="LNOCI16735" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">OCI_DTYPE_TABLE_CHDES</h5>
<p>This notification descriptor conveys information about changes to a table involved in a registered query. It has the following attributes:</p>
<ul>
<li>
<p><a id="sthref1684"></a><code>OCI_ATTR_CHDES_TABLE_NAME</code> <code>(oratext *)</code> - Schema annotated table name.</p>
</li>
<li>
<p><a id="sthref1685"></a><code>OCI_ATTR_CHDES_TABLE_OPFLAGS</code> (<code>ub4</code>) - Flag field describing the operations on the table. Each of the following flag fields is in a separate bit position in the attribute:</p>
<ul>
<li>
<p><code>0x1 OCI_OPCODE_ALLROWS</code> - The table is completely invalidated.</p>
</li>
<li>
<p><code>0x2 OCI_OPCODE_INSERT</code> - Insert operations on the table.</p>
</li>
<li>
<p><code>0x4 OCI_OPCODE_UPDATE</code> - Update operations on the table.</p>
</li>
<li>
<p><code>0x8 OCI_OPCODE_DELETE</code> - Delete operations on the table.</p>
</li>
<li>
<p><code>0x10 OCI_OPCODE_ALTER</code> - Table altered (schema change). This includes DDL statements and internal operations that cause row migration.</p>
</li>
<li>
<p><code>0x20 OCI_OPCODE_DROP</code> - Table dropped.</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref1686"></a><code>OCI_ATTR_CHDES_TABLE_ROW_CHANGES</code> - This is an embedded collection describing the changes to the rows within the table. Each element of the collection is a row continuous query descriptor of type <code>OCI_DTYPE_ROW_CHDES</code> that has the following attributes:</p>
<ul>
<li>
<p><code><a id="sthref1687"></a>OCI_ATTR_CHDES_ROW_ROWID</code> (<code>OraText *</code>) - String representation of a <code>ROWID</code>.</p>
</li>
<li>
<p><code><a id="sthref1688"></a>OCI_ATTR_CHDES_ROW_OPFLAGS</code> - Reflects the operation type: <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, or <code>OTHER</code>.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJCIGDB">"Continuous Query Notification Descriptor Attributes"</a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16736" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1689"></a>
<h3 class="sect2"><a id="sthref1690"></a>Continuous Query Notification Example</h3>
<p><a href="#CEGBCIJB">Example 10-1</a> is a simple OCI program, <code>demoquery.c</code>. See the comments in the listing. The calling session must have the <code>CHANGE</code> <code>NOTIFICATION</code> system privilege and <code>SELECT</code> privileges on all objects that it attempts to register.</p>
<div id="LNOCI18229" class="example">
<p class="titleinexample"><a id="CEGBCIJB"></a>Example 10-1 Program Listing That Demonstrates Continuous Query Notification</p>
<pre>
/* Copyright (c) 2010, Oracle. All rights reserved.  */
 
#ifndef S_ORACLE
# include &lt;oratypes.h&gt;
#endif
 
/**************************************************************************
 *This is a DEMO program. To test, compile the file to generate the executable
 *demoquery. Then demoquery can be invoked from a command prompt.
 *It will have the following output:
 
Initializing OCI Process
Registering query : select last_name, employees.department_id, department_name 
                     from employees, departments 
                     where employee_id = 200 
                     and employees.department_id = departments.department_id
Query Id 23
Waiting for Notifications

*Then from another session, log in as HR/HR and perform the following
* DML transactions. It will cause two notifications to be generated.
 
update departments set department_name ='Global Admin' where department_id=10;
commit;
update departments set department_name ='Adminstration' where department_id=10;
commit;

*The demoquery program will now show the following output corresponding
*to the notifications received.
 
 
Query 23 is changed
Table changed is HR.DEPARTMENTS table_op 4
Row changed is AAAMBoAABAAAKX2AAA row_op 4
Query 23 is changed
Table changed is HR.DEPARTMENTS table_op 4
Row changed is AAAMBoAABAAAKX2AAA row_op 4
 
 
*The demo program waits for exactly 10 notifications to be received before
*logging off and unregistering the subscription.
 
***************************************************************************/
 
/*---------------------------------------------------------------------------
                     PRIVATE TYPES AND CONSTANTS
  ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
                     STATIC FUNCTION DECLARATIONS 
  ---------------------------------------------------------------------------*/
 
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;oci.h&gt;
 
#define MAXSTRLENGTH 1024
#define bit(a,b) ((a)&amp;(b))
 
static int notifications_processed = 0;
static OCISubscription *subhandle1 = (OCISubscription *)0;
static OCISubscription *subhandle2 = (OCISubscription *)0;
static void checker(/*_ OCIError *errhp, sword status _*/);
static void registerQuery(/*_ OCISvcCtx *svchp, OCIError *errhp, OCIStmt *stmthp,
                           OCIEnv *envhp _*/);
static void myCallback (/*_  dvoid *ctx, OCISubscription *subscrhp, 
                        dvoid *payload, ub4 *payl, dvoid *descriptor, 
                        ub4 mode _*/);
static int NotificationDriver(/*_ int argc, char *argv[]  _*/);
static sword status;
static boolean logged_on = FALSE;
static void processRowChanges(OCIEnv *envhp, OCIError *errhp, OCIStmt *stmthp, 
                               OCIColl *row_changes);
static void processTableChanges(OCIEnv *envhp, OCIError *errhp,
                 OCIStmt *stmthp, OCIColl *table_changes);
static void processQueryChanges(OCIEnv *envhp, OCIError *errhp, OCIStmt *stmthp,
                 OCIColl *query_changes);
static int nonractests2(/*_ int argc, char *argv[] _*/);
 
 
int main(int argc, char **argv)
{
 
  NotificationDriver(argc, argv);
  return 0;
}
 
 
int NotificationDriver(argc, argv)
int argc;
char *argv[];
{
  OCIEnv *envhp;
  OCISvcCtx *svchp, *svchp2;
  OCIError *errhp, *errhp2;
  OCISession *authp, *authp2;
  OCIStmt *stmthp, *stmthp2;
  OCIDuration dur, dur2;
  int i;
  dvoid *tmp;
  OCISession *usrhp;
  OCIServer *srvhp;
 
  printf("Initializing OCI Process\n");
/* Initialize the environment. The environment must be initialized
     with OCI_EVENTS and OCI_OBJECT to create a continuous query notification
     registration and receive notifications.
  */
  OCIEnvCreate( (OCIEnv **) &amp;envhp, OCI_EVENTS|OCI_OBJECT, (dvoid *)0,
                    (dvoid * (*)(dvoid *, size_t)) 0,
                    (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                    (void (*)(dvoid *, dvoid *)) 0,
                    (size_t) 0, (dvoid **) 0 );
 
  OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;errhp, OCI_HTYPE_ERROR,
                         (size_t) 0, (dvoid **) 0);
   /* server contexts */
  OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;srvhp, OCI_HTYPE_SERVER, 
                 (size_t) 0, (dvoid **) 0);
  OCIHandleAlloc((dvoid *) envhp, (dvoid **) &amp;svchp, OCI_HTYPE_SVCCTX,
                 (size_t) 0, (dvoid **) 0);
   checker(errhp,OCIServerAttach(srvhp, errhp, (text *) 0, (sb4) 0, 
                                 (ub4) OCI_DEFAULT));
  /* set attribute server context in the service context */
  OCIAttrSet( (dvoid *) svchp, (ub4) OCI_HTYPE_SVCCTX, (dvoid *)srvhp,
              (ub4) 0, (ub4) OCI_ATTR_SERVER, (OCIError *) errhp);
 
   /* allocate a user context handle */
  OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;usrhp, (ub4) OCI_HTYPE_SESSION,
                               (size_t) 0, (dvoid **) 0);
 
  OCIAttrSet((dvoid *)usrhp, (ub4)OCI_HTYPE_SESSION,
             (dvoid *)((text *)"HR"), (ub4)strlen((char *)"HR"), 
              OCI_ATTR_USERNAME, errhp);
 
 OCIAttrSet((dvoid *)usrhp, (ub4)OCI_HTYPE_SESSION,
            (dvoid *)((text *)"HR"), (ub4)strlen((char *)"HR"),  
             OCI_ATTR_PASSWORD, errhp);
   checker(errhp,OCISessionBegin (svchp, errhp, usrhp, OCI_CRED_RDBMS,
           OCI_DEFAULT));
   /* Allocate a statement handle */
  OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;stmthp,
                                (ub4) OCI_HTYPE_STMT, 52, (dvoid **) &amp;tmp);
 
  OCIAttrSet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX, (dvoid *)usrhp, (ub4)0,
                       OCI_ATTR_SESSION, errhp);
 
  registerQuery(svchp, errhp, stmthp, envhp);
  printf("Waiting for Notifications\n");
  while (notifications_processed !=10)
  {
    sleep(1);
  }
  printf ("Going to unregister HR\n");
  fflush(stdout);
  /* Unregister HR */
  checker(errhp,
           OCISubscriptionUnRegister(svchp, subhandle1, errhp, OCI_DEFAULT));
  checker(errhp, OCISessionEnd(svchp, errhp, usrhp, (ub4) 0));
   printf("HR Logged off.\n");
 
  if (subhandle1)
     OCIHandleFree((dvoid *)subhandle1, OCI_HTYPE_SUBSCRIPTION);
  if (stmthp)
     OCIHandleFree((dvoid *)stmthp, OCI_HTYPE_STMT);
  if (srvhp)
     OCIHandleFree((dvoid *) srvhp, (ub4) OCI_HTYPE_SERVER);
  if (svchp)
     OCIHandleFree((dvoid *) svchp, (ub4) OCI_HTYPE_SVCCTX);
  if (authp)
     OCIHandleFree((dvoid *) usrhp, (ub4) OCI_HTYPE_SESSION);
  if (errhp)
     OCIHandleFree((dvoid *) errhp, (ub4) OCI_HTYPE_ERROR);
  if (envhp)
     OCIHandleFree((dvoid *) envhp, (ub4) OCI_HTYPE_ENV);
 
 
  return 0;
 
}
 
void checker(errhp, status)
OCIError *errhp;
sword status;
{
  text errbuf[512];
  sb4 errcode = 0;
  int retval = 1;
 
  switch (status)
  {
  case OCI_SUCCESS:
    retval = 0;
    break;
  case OCI_SUCCESS_WITH_INFO:
    (void) printf("Error - OCI_SUCCESS_WITH_INFO\n");
    break;
 case OCI_NEED_DATA:
    (void) printf("Error - OCI_NEED_DATA\n");
    break;
  case OCI_NO_DATA:
    (void) printf("Error - OCI_NODATA\n");
    break;
  case OCI_ERROR:
    (void) OCIErrorGet((dvoid *)errhp, (ub4) 1, (text *) NULL, &amp;errcode,
                        errbuf, (ub4) sizeof(errbuf), OCI_HTYPE_ERROR);
    (void) printf("Error - %.*s\n", 512, errbuf);
    break;
  case OCI_INVALID_HANDLE:
    (void) printf("Error - OCI_INVALID_HANDLE\n");
    break;
  case OCI_STILL_EXECUTING:
    (void) printf("Error - OCI_STILL_EXECUTE\n");
    break; 
  case OCI_CONTINUE:
    (void) printf("Error - OCI_CONTINUE\n");
    break; 
  default:
    break;
 }
  if (retval)
  {
    exit(1);
  }
}
 
 
void processRowChanges(OCIEnv *envhp, OCIError *errhp, OCIStmt *stmthp,
                         OCIColl *row_changes)
{
  dvoid **row_descp;
  dvoid *row_desc;
  boolean exist; 
  ub2 i, j;
  dvoid *elemind = (dvoid *)0;
  oratext *row_id;
  ub4 row_op;
 
 
   sb4 num_rows;
   if (!row_changes) return;
    checker(errhp, OCICollSize(envhp, errhp,
                    (CONST OCIColl *) row_changes, &amp;num_rows));
    for (i=0; i&lt;num_rows; i++)
    {
      checker(errhp, OCICollGetElem(envhp,
                     errhp, (OCIColl *) row_changes,
                     i, &amp;exist, &amp;row_descp, &amp;elemind));
 
      row_desc = *row_descp;
      checker(errhp, OCIAttrGet (row_desc, 
                  OCI_DTYPE_ROW_CHDES, (dvoid *)&amp;row_id,
                  NULL, OCI_ATTR_CHDES_ROW_ROWID, errhp));
      checker(errhp, OCIAttrGet (row_desc, 
                  OCI_DTYPE_ROW_CHDES, (dvoid *)&amp;row_op, 
                  NULL, OCI_ATTR_CHDES_ROW_OPFLAGS, errhp));
 
      printf ("Row changed is %s row_op %d\n", row_id, row_op);
      fflush(stdout); 
    }  
}
 
void processTableChanges(OCIEnv *envhp, OCIError *errhp, OCIStmt *stmthp,
                         OCIColl *table_changes)
{
  dvoid **table_descp;
  dvoid *table_desc;
  dvoid **row_descp;
  dvoid *row_desc;
  OCIColl *row_changes = (OCIColl *)0;
  boolean exist; 
  ub2 i, j;
  dvoid *elemind = (dvoid *)0;
  oratext *table_name;
  ub4 table_op;
 
 
   sb4 num_tables;
   if (!table_changes) return;
    checker(errhp, OCICollSize(envhp, errhp,
                    (CONST OCIColl *) table_changes, &amp;num_tables));
    for (i=0; i&lt;num_tables; i++)
    {
      checker(errhp, OCICollGetElem(envhp,
                     errhp, (OCIColl *) table_changes,
                     i, &amp;exist, &amp;table_descp, &amp;elemind));
 
      table_desc = *table_descp;
      checker(errhp, OCIAttrGet (table_desc, 
                  OCI_DTYPE_TABLE_CHDES, (dvoid *)&amp;table_name,
                  NULL, OCI_ATTR_CHDES_TABLE_NAME, errhp));
      checker(errhp, OCIAttrGet (table_desc, 
                  OCI_DTYPE_TABLE_CHDES, (dvoid *)&amp;table_op, 
                  NULL, OCI_ATTR_CHDES_TABLE_OPFLAGS, errhp));
      checker(errhp, OCIAttrGet (table_desc, 
                  OCI_DTYPE_TABLE_CHDES, (dvoid *)&amp;row_changes, 
                  NULL, OCI_ATTR_CHDES_TABLE_ROW_CHANGES, errhp));
 
      printf ("Table changed is %s table_op %d\n", table_name,table_op);
      fflush(stdout); 
     if (!bit(table_op, OCI_OPCODE_ALLROWS))
       processRowChanges(envhp, errhp, stmthp, row_changes);
    }  
}
 
void processQueryChanges(OCIEnv *envhp, OCIError *errhp, OCIStmt *stmthp,
                         OCIColl *query_changes)
{
  sb4 num_queries;
  ub8 queryid;
  OCINumber qidnum;
  ub4 queryop;
  dvoid *elemind = (dvoid *)0;
  dvoid *query_desc;
  dvoid **query_descp;
  ub2 i;
  boolean exist;
  OCIColl *table_changes = (OCIColl *)0;
  
  if (!query_changes) return;
  checker(errhp, OCICollSize(envhp, errhp,
                     (CONST OCIColl *) query_changes, &amp;num_queries));
  for (i=0; i &lt; num_queries; i++)
  {
    checker(errhp, OCICollGetElem(envhp,
                     errhp, (OCIColl *) query_changes,
                     i, &amp;exist, &amp;query_descp, &amp;elemind));
 
    query_desc = *query_descp;
    checker(errhp, OCIAttrGet (query_desc,
                  OCI_DTYPE_CQDES, (dvoid *)&amp;queryid,
                  NULL, OCI_ATTR_CQDES_QUERYID, errhp));
    checker(errhp, OCIAttrGet (query_desc,
                  OCI_DTYPE_CQDES, (dvoid *)&amp;queryop,
                  NULL, OCI_ATTR_CQDES_OPERATION, errhp));
    printf(" Query %d is changed\n", queryid);
    if (queryop == OCI_EVENT_DEREG)
      printf("Query Deregistered\n");
      checker(errhp, OCIAttrGet (query_desc,
                  OCI_DTYPE_CQDES, (dvoid *)&amp;table_changes,
                  NULL, OCI_ATTR_CQDES_TABLE_CHANGES, errhp));
      processTableChanges(envhp, errhp, stmthp, table_changes);
 
 
   }
}
 
   
void myCallback (ctx, subscrhp, payload, payl, descriptor, mode)
dvoid *ctx;
OCISubscription *subscrhp;
dvoid *payload;
ub4 *payl; 
dvoid *descriptor;
ub4 mode;
{
  OCIColl *table_changes = (OCIColl *)0;
  OCIColl *row_changes = (OCIColl *)0;
  dvoid *change_descriptor = descriptor;
  ub4 notify_type;
  ub2 i, j;
  OCIEnv *envhp;
  OCIError *errhp;
  OCIColl *query_changes = (OCIColl *)0;
  OCIServer *srvhp;
  OCISvcCtx *svchp;
  OCISession *usrhp;
  dvoid     *tmp; 
  OCIStmt *stmthp;
 
 (void)OCIEnvInit( (OCIEnv **) &amp;envhp, OCI_DEFAULT, (size_t)0, (dvoid **)0 );
  
  (void) OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;errhp, OCI_HTYPE_ERROR,
                   (size_t) 0, (dvoid **) 0);
   /* server contexts */
  (void) OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;srvhp, OCI_HTYPE_SERVER,
                   (size_t) 0, (dvoid **) 0);
 
  (void) OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;svchp, OCI_HTYPE_SVCCTX,
                   (size_t) 0, (dvoid **) 0);
 
  OCIAttrGet (change_descriptor, OCI_DTYPE_CHDES, (dvoid *) &amp;notify_type,
              NULL, OCI_ATTR_CHDES_NFYTYPE, errhp);
  fflush(stdout);
  if (notify_type == OCI_EVENT_SHUTDOWN ||
      notify_type == OCI_EVENT_SHUTDOWN_ANY)
  {
     printf("SHUTDOWN NOTIFICATION RECEIVED\n");
     fflush(stdout);
     notifications_processed++;
     return;
  }
 if (notify_type == OCI_EVENT_STARTUP)
  {
     printf("STARTUP NOTIFICATION RECEIVED\n");
     fflush(stdout);
     notifications_processed++; 
     return;
  }
  
  notifications_processed++;
  checker(errhp, OCIServerAttach( srvhp, errhp, (text *) 0, (sb4) 0,
                                  (ub4) OCI_DEFAULT));
 
  OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;svchp, (ub4) OCI_HTYPE_SVCCTX,
                  52, (dvoid **) &amp;tmp);
  /* set attribute server context in the service context */
  OCIAttrSet( (dvoid *) svchp, (ub4) OCI_HTYPE_SVCCTX, (dvoid *)srvhp,
              (ub4) 0, (ub4) OCI_ATTR_SERVER, (OCIError *) errhp);
 
  /* allocate a user context handle */
  OCIHandleAlloc((dvoid *)envhp, (dvoid **)&amp;usrhp, (ub4) OCI_HTYPE_SESSION,
           (size_t) 0, (dvoid **) 0);
 
  OCIAttrSet((dvoid *)usrhp, (ub4)OCI_HTYPE_SESSION,
           (dvoid *)"HR", (ub4)strlen("HR"), OCI_ATTR_USERNAME, errhp);
 
  OCIAttrSet((dvoid *)usrhp, (ub4)OCI_HTYPE_SESSION,
           (dvoid *)"HR", (ub4)strlen("HR"),
           OCI_ATTR_PASSWORD, errhp);
 
  checker(errhp, OCISessionBegin (svchp, errhp, usrhp, OCI_CRED_RDBMS,
                                   OCI_DEFAULT));
 
  OCIAttrSet((dvoid *)svchp, (ub4)OCI_HTYPE_SVCCTX,
           (dvoid *)usrhp, (ub4)0, OCI_ATTR_SESSION, errhp);
 
  /* Allocate a statement handle */
  OCIHandleAlloc( (dvoid *) envhp, (dvoid **) &amp;stmthp,
                  (ub4) OCI_HTYPE_STMT, 52, (dvoid **) &amp;tmp);
 
  if (notify_type == OCI_EVENT_OBJCHANGE)
  {
    checker(errhp, OCIAttrGet (change_descriptor,
                OCI_DTYPE_CHDES, &amp;table_changes, NULL,
                OCI_ATTR_CHDES_TABLE_CHANGES, errhp));
    processTableChanges(envhp, errhp, stmthp, table_changes);
  }
  else if (notify_type == OCI_EVENT_QUERYCHANGE)
  {
     checker(errhp, OCIAttrGet (change_descriptor,
                OCI_DTYPE_CHDES, &amp;query_changes, NULL,
                OCI_ATTR_CHDES_QUERIES, errhp));
      processQueryChanges(envhp, errhp, stmthp, query_changes);
  }
   checker(errhp, OCISessionEnd(svchp, errhp, usrhp, OCI_DEFAULT));
  checker(errhp, OCIServerDetach(srvhp, errhp, OCI_DEFAULT));
 if (stmthp)
    OCIHandleFree((dvoid *)stmthp, OCI_HTYPE_STMT);
  if (errhp)
    OCIHandleFree((dvoid *)errhp, OCI_HTYPE_ERROR);
  if (srvhp)
    OCIHandleFree((dvoid *)srvhp, OCI_HTYPE_SERVER);
  if (svchp)
    OCIHandleFree((dvoid *)svchp, OCI_HTYPE_SVCCTX);
  if (usrhp)
    OCIHandleFree((dvoid *)usrhp, OCI_HTYPE_SESSION);
  if (envhp)
    OCIHandleFree((dvoid *)envhp, OCI_HTYPE_ENV);
 
}
 
void registerQuery(svchp, errhp, stmthp, envhp)
OCISvcCtx *svchp; 
OCIError *errhp; 
OCIStmt *stmthp;
OCIEnv *envhp;
{
  OCISubscription *subscrhp;
  ub4 namespace = OCI_SUBSCR_NAMESPACE_DBCHANGE;
  ub4 timeout = 60;
  OCIDefine *defnp1 = (OCIDefine *)0;
  OCIDefine *defnp2 = (OCIDefine *)0;
  OCIDefine *defnp3 = (OCIDefine *)0;
  OCIDefine *defnp4 = (OCIDefine *)0;
  OCIDefine *defnp5 = (OCIDefine *)0;
  int mgr_id =0;
text query_text1[] = "select last_name, employees.department_id, department_name \
 from employees,departments where employee_id = 200 and employees.department_id =\
  departments.department_id";
 
  ub4 num_prefetch_rows = 0;
  ub4 num_reg_tables;
  OCIColl *table_names;
  ub2 i;
  boolean rowids = TRUE;
  ub4 qosflags = OCI_SUBSCR_CQ_QOS_QUERY  ;
  int empno=0;
  OCINumber qidnum;
  ub8 qid;
  char outstr[MAXSTRLENGTH], dname[MAXSTRLENGTH];
  int q3out;
 
    fflush(stdout);
  /* allocate subscription handle */
  OCIHandleAlloc ((dvoid *) envhp, (dvoid **) &amp;subscrhp,
                  OCI_HTYPE_SUBSCRIPTION, (size_t) 0, (dvoid **) 0);
  
  /* set the namespace to DBCHANGE */
  checker(errhp, OCIAttrSet (subscrhp, OCI_HTYPE_SUBSCRIPTION,
                  (dvoid *) &amp;namespace, sizeof(ub4),
                  OCI_ATTR_SUBSCR_NAMESPACE, errhp));
  
  /* Associate a notification callback with the subscription */
  checker(errhp, OCIAttrSet (subscrhp, OCI_HTYPE_SUBSCRIPTION,
                  (void *)myCallback, 0, OCI_ATTR_SUBSCR_CALLBACK, errhp));
 /* Allow extraction of rowid information */
  checker(errhp, OCIAttrSet (subscrhp, OCI_HTYPE_SUBSCRIPTION,
                  (dvoid *)&amp;rowids, sizeof(ub4), 
                  OCI_ATTR_CHNF_ROWIDS, errhp));
   
     checker(errhp, OCIAttrSet (subscrhp, OCI_HTYPE_SUBSCRIPTION,
                  (dvoid *)&amp;qosflags, sizeof(ub4),
                  OCI_ATTR_SUBSCR_CQ_QOSFLAGS, errhp));
 
  /* Create a new registration in the DBCHANGE namespace */
  checker(errhp,
           OCISubscriptionRegister(svchp, &amp;subscrhp, 1, errhp, OCI_DEFAULT));
 
  /* Multiple queries can now be associated with the subscription */
 
    subhandle1 = subscrhp;
 
 
    printf("Registering query : %s\n", (const signed char *)query_text1);
    /* Prepare the statement */
    checker(errhp, OCIStmtPrepare (stmthp, errhp, query_text1, 
            (ub4)strlen((const signed char *)query_text1), OCI_V7_SYNTAX,
            OCI_DEFAULT));
 
    checker(errhp,
           OCIDefineByPos(stmthp, &amp;defnp1,
                  errhp, 1, (dvoid *)outstr, MAXSTRLENGTH * sizeof(char),
                  SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, OCI_DEFAULT));
    checker(errhp,
           OCIDefineByPos(stmthp, &amp;defnp2,
                     errhp, 2, (dvoid *)&amp;empno, sizeof(empno),
                     SQLT_INT, (dvoid *)0, (ub2 *)0, (ub2 *)0, OCI_DEFAULT));
    checker(errhp,
           OCIDefineByPos(stmthp, &amp;defnp3,
                      errhp, 3, (dvoid *)&amp;dname, sizeof(dname),
                     SQLT_STR, (dvoid *)0, (ub2 *)0, (ub2 *)0, OCI_DEFAULT));
 
    /* Associate the statement with the subscription handle */
    OCIAttrSet (stmthp, OCI_HTYPE_STMT, subscrhp, 0,
              OCI_ATTR_CHNF_REGHANDLE, errhp);
 
    /* Execute the statement, the execution performs object registration */
    checker(errhp, OCIStmtExecute (svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (CONST OCISnapshot *) NULL, (OCISnapshot *) NULL ,
                 OCI_DEFAULT));
    fflush(stdout);
 
    OCIAttrGet(stmthp, OCI_HTYPE_STMT, &amp;qid, (ub4 *)0,
                OCI_ATTR_CQ_QUERYID, errhp);
    printf("Query Id %d\n", qid);
 
  /* commit */
  checker(errhp, OCITransCommit(svchp, errhp, (ub4) 0));
 
}
 
static void cleanup(envhp, svchp, srvhp, errhp, usrhp)
OCIEnv *envhp;
OCISvcCtx *svchp;
OCIServer *srvhp;
OCIError *errhp;
OCISession *usrhp;
{
  /* detach from the server */
  checker(errhp, OCISessionEnd(svchp, errhp, usrhp, OCI_DEFAULT));
  checker(errhp, OCIServerDetach(srvhp, errhp, (ub4)OCI_DEFAULT));
 
  if (usrhp)
    (void) OCIHandleFree((dvoid *) usrhp, (ub4) OCI_HTYPE_SESSION);
  if (svchp)
    (void) OCIHandleFree((dvoid *) svchp, (ub4) OCI_HTYPE_SVCCTX);
  if (srvhp)
    (void) OCIHandleFree((dvoid *) srvhp, (ub4) OCI_HTYPE_SERVER);
  if (errhp)
    (void) OCIHandleFree((dvoid *) errhp, (ub4) OCI_HTYPE_ERROR);
  if (envhp)
    (void) OCIHandleFree((dvoid *) envhp, (ub4) OCI_HTYPE_ENV);
 
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJGDJFAF"></a>
<div id="LNOCI096" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1691"></a><a id="sthref1692"></a>Database Startup and Shutdown</h2>
<p>The OCI functions <a href="oci16rel001.htm#BEIDFIBJ">OCIDBStartup()</a> and <a href="oci16rel001.htm#BEIHACDC">OCIDBShutdown()</a> provide the minimal interface needed to start and shut down an Oracle database<a id="sthref1693"></a><a id="sthref1694"></a>. Before calling <code>OCIDBStartup()</code>, the C program must connect to the server and start a <code>SYSDBA</code> or <code>SYSOPER</code> session in the preliminary authentication mode. This mode is the only one permitted when the instance is not up, and it is used only to start the instance. A call to <a href="oci16rel001.htm#BEIDFIBJ">OCIDBStartup()</a> starts one server instance without mounting or opening the database. To mount and open the database, end the preliminary authentication session and start a regular <code>SYSDBA</code> or <code>SYSOPER</code> session to execute the appropriate <code>ALTER</code> <code>DATABASE</code> statements.</p>
<p>An active <code>SYSDBA</code> or <code>SYSOPER</code> session is needed to shut down the database. For all modes other than <code>OCI_DBSHUTDOWN_ABORT</code>, make two calls to <a href="oci16rel001.htm#BEIHACDC">OCIDBShutdown()</a>: one to initiate shutdown by prohibiting further connections to the database, followed by the appropriate <code>ALTER</code> <code>DATABASE</code> commands to dismount and close it; and the other call to finish shutdown by bringing the instance down. In special circumstances, to shut down the database as fast as possible, call <a href="oci16rel001.htm#BEIHACDC">OCIDBShutdown()</a> in the <code>OCI_DBSHUTDOWN_ABORT</code> mode, which is equivalent to <code>SHUTDOWN</code> <code>ABORT</code> in SQL*Plus.</p>
<p>Both of these functions require a dedicated connection to the server. <code>ORA-106</code> is signaled if an attempt is made to start or shut down the database when it is connected to a shared server through a dispatcher.</p>
<p>The <code>OCIAdmin</code> <a id="sthref1695"></a><a id="sthref1696"></a>administration handle<a id="sthref1697"></a><a id="sthref1698"></a><a id="sthref1699"></a> C data type is used to make the interface extensible. <code>OCIAdmin</code> is associated with the handle type <code>OCI_HTYPE_ADMIN</code>. Passing a value for the <code>OCIAdmin</code> parameter, <code>admhp</code>, is optional for <a href="oci16rel001.htm#BEIDFIBJ">OCIDBStartup()</a> and is not needed by <a href="oci16rel001.htm#BEIHACDC">OCIDBShutdown()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#BEIDFIBJ">"OCIDBStartup()"</a></p>
</li>
<li>
<p><a href="oci16rel001.htm#BEIHACDC">"OCIDBShutdown()"</a></p>
</li>
<li>
<p><a href="ociaahan.htm#BAJCBGAG">"Administration Handle Attributes"</a></p>
</li>
<li>
<p><a class="olink ADMIN004" href="../../server.112/e25494/start.htm#ADMIN004"><span class="italic">Oracle Database Administrator's Guide</span></a></p>
</li>
</ul>
</div>
<div id="LNOCI16737" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1700"></a>
<h3 class="sect2">Examples of Startup and Shutdown in OCI</h3>
<p>To perform a startup, you must be connected to the database as <code>SYSOPER</code> or <code>SYSDBA</code> in <code>OCI_PRELIM_AUTH</code> mode. You cannot be connected to a shared server through a dispatcher. To use a client-side parameter file (<code>pfile</code>), the attribute <code>OCI_ATTR_ADMIN_PFILE</code> must be set in the administration handle using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>; otherwise, a server-side parameter file (<code>spfile</code>) is used. In the latter case, pass <code>(OCIAdmin *)0</code>. A call to <a href="oci16rel001.htm#BEIDFIBJ">OCIDBStartup()</a> starts one instance on the server.</p>
<p><a href="#CEGJIADH">Example 10-2</a> shows sample code that uses a client-side parameter file (<code>pfile</code>) that is set in the administration handle and performs a database startup operation.</p>
<div id="LNOCI18230" class="example">
<p class="titleinexample"><a id="CEGJIADH"></a>Example 10-2 Calling OCIDBStartup() to Perform a Database Startup Operation</p>
<pre>
...

/*  Example 0 - Startup:  */
OCIAdmin *admhp;
text *mount_stmt = (text *)"ALTER DATABASE MOUNT";
text *open_stmt = (text *)"ALTER DATABASE OPEN";
text *pfile = (text *)"/ade/viewname/oracle/work/t_init1.ora";

/* Start the authentication session */
checkerr(errhp, OCISessionBegin (svchp, errhp, usrhp,
         OCI_CRED_RDBMS, OCI_SYSDBA|OCI_PRELIM_AUTH));

/* Allocate admin handle for OCIDBStartup */
checkerr(errhp, OCIHandleAlloc((void *) envhp, (void **) &amp;admhp,
         (ub4) OCI_HTYPE_ADMIN, (size_t) 0, (void **) 0));

/* Set attribute pfile in the admin handle 
(do not do this if you want to use the spfile) */
checkerr (errhp, OCIAttrSet( (void *) admhp, (ub4) OCI_HTYPE_ADMIN,
          (void *) pfile, (ub4) strlen(pfile),
          (ub4) OCI_ATTR_ADMIN_PFILE, (OCIError *) errhp));

/* Start up in NOMOUNT mode */
  checkerr(errhp, OCIDBStartup(svchp, errhp, admhp, OCI_DEFAULT, 0));
   checkerr(errhp, OCIHandleFree((void *) admhp, (ub4) OCI_HTYPE_ADMIN));

/* End the authentication session */
OCISessionEnd(svchp, errhp, usrhp, (ub4)OCI_DEFAULT);

/* Start the sysdba session */
checkerr(errhp, OCISessionBegin (svchp, errhp, usrhp, OCI_CRED_RDBMS,
         OCI_SYSDBA));

/* Mount the database */
checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, mount_stmt, (ub4)
         strlen((char*) mount_stmt),
         (CONST OraText *) 0, (ub4) 0, (ub4) OCI_NTV_SYNTAX, (ub4)
         OCI_DEFAULT));
checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4)0,
         (OCISnapshot *) NULL, (OCISnapshot *) NULL, OCI_DEFAULT));
checkerr(errhp, OCIStmtRelease(stmthp, errhp, (OraText *)0, 0, OCI_DEFAULT));

/* Open the database */
checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, open_stmt, (ub4)
         strlen((char*) open_stmt),
         (CONST OraText *)0, (ub4)0, (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));
checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4)0,
         (OCISnapshot *) NULL, (OCISnapshot *) NULL, OCI_DEFAULT));
checkerr(errhp, OCIStmtRelease(stmthp, errhp, (OraText *)0, 0, OCI_DEFAULT));

/* End the sysdba session */
OCISessionEnd(svchp, errhp, usrhp, (ub4)OCI_DEFAULT);
...
</pre></div>
<!-- class="example" -->
<p>To perform a shutdown, you must be connected to the database as <code>SYSOPER</code> or <code>SYSDBA</code>. You cannot be connected to a shared server through a dispatcher. When shutting down in any mode other than <code>OCI_DBSHUTDOWN_ABORT</code>, use the following procedure:</p>
<ol>
<li>
<p>Call <a href="oci16rel001.htm#BEIHACDC">OCIDBShutdown()</a> in <code>OCI_DEFAULT</code>, <code>OCI_DBSHUTDOWN_TRANSACTIONAL</code>, <code>OCI_DBSHUTDOWN_TRANSACTIONAL_LOCAL</code>, or <code>OCI_DBSHUTDOWN_IMMEDIATE</code> mode to prohibit further connections.</p>
</li>
<li>
<p>Use the necessary <code>ALTER</code> <code>DATABASE</code> commands to close and dismount the database.</p>
</li>
<li>
<p>Call <a href="oci16rel001.htm#BEIHACDC">OCIDBShutdown()</a> in <code>OCI_DBSHUTDOWN_FINAL</code> mode to shut down the instance.</p>
</li>
</ol>
<p><a href="#CEGCGHGJ">Example 10-3</a> shows sample code that uses a client-side parameter file (<code>pfile</code>) that is set in the administration handle that performs an orderly database shutdown operation.</p>
<div id="LNOCI18231" class="example">
<p class="titleinexample"><a id="CEGCGHGJ"></a>Example 10-3 Calling OCIDBShutdown() in OCI_DBSHUTDOWN_FINAL Mode</p>
<pre>
/*  Example 1 - Orderly shutdown:  */
...
text *close_stmt = (text *)"ALTER DATABASE CLOSE NORMAL";
text *dismount_stmt = (text *)"ALTER DATABASE DISMOUNT";

/* Start the sysdba session */
checkerr(errhp, OCISessionBegin (svchp, errhp, usrhp, OCI_CRED_RDBMS,
         OCI_SYSDBA));

/* Shutdown in the default mode (transactional, transactional-local,
  immediate would be fine too) */
checkerr(errhp, OCIDBShutdown(svchp, errhp, (OCIAdmin *)0, OCI_DEFAULT));

/* Close the database */
checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, close_stmt, (ub4)
         strlen((char*) close_stmt),
         (CONST OraText *)0, (ub4)0, (ub4) OCI_NTV_SYNTAX,
         (ub4) OCI_DEFAULT));
checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4)0,
        (OCISnapshot *) NULL,
        (OCISnapshot *) NULL, OCI_DEFAULT));
checkerr(errhp, OCIStmtRelease(stmthp, errhp, (OraText *)0, 0, OCI_DEFAULT));

/* Dismount the database */
checkerr(errhp, OCIStmtPrepare2(svchp, &amp;stmthp, errhp, dismount_stmt,
         (ub4) strlen((char*) dismount_stmt), (CONST OraText *)0, (ub4)0,
         (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));
checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4)0,
         (OCISnapshot *) NULL,
         (OCISnapshot *) NULL, OCI_DEFAULT));
checkerr(errhp, OCIStmtRelease(stmthp, errhp, (OraText *)0, 0, OCI_DEFAULT));

/* Final shutdown */
checkerr(errhp, OCIDBShutdown(svchp, errhp, (OCIAdmin *)0,
         OCI_DBSHUTDOWN_FINAL));

/* End the sysdba session */
checkerr(errhp, OCISessionEnd(svchp, errhp, usrhp, (ub4)OCI_DEFAULT));
...
</pre></div>
<!-- class="example" -->
<p><a href="#CEGHIFGA">Example 10-4</a> shows a shutdown example that uses <code>OCI_DBSHUTDOWN_ABORT</code> mode.</p>
<div id="LNOCI18232" class="example">
<p class="titleinexample"><a id="CEGHIFGA"></a>Example 10-4 Calling OCIDBShutdown() in OCI_DBSHUTDOWN_ABORT Mode</p>
<pre>
/*  Example 2 - Shutdown using abort:  */
...
/* Start the sysdba session */
...
checkerr(errhp, OCISessionBegin (svchp, errhp, usrhp, OCI_CRED_RDBMS,
         OCI_SYSDBA));

/* Shutdown in the abort mode */
checkerr(errhp, OCIDBShutdown(svchp, errhp, (OCIAdmin *)0,
         OCI_DBSHUTDOWN_ABORT));

/* End the sysdba session */
checkerr(errhp, OCISessionEnd(svchp, errhp, usrhp, (ub4)OCI_DEFAULT));
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDIGCG"></a>
<div id="LNOCI10100" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1701"></a>Implicit Fetching of ROWIDs</h2>
<p><code>ROWID</code> is a globally unique identifier for a row in a database. It is created at the time the row is inserted into the table, and destroyed when it is removed. <code>ROWID</code> values have several important uses. They are unique identifiers for rows in a table. They are the fastest way to access a single row and can show how the rows in the table are stored.</p>
<p>Implicit fetching of <code>ROWID</code>s in <code>SELECT</code> <code>...</code> <code>FOR</code> <code>UPDATE</code> statements means that the <code>ROWID</code> is retrieved at the client side, even if it is not one of the columns named in the select statement. The <code>position</code> parameter of <code>OCIDefineByPos()</code> is set to zero (0). These host variables can be specified for retrieving the <code>ROWID</code> pseudocolumn values:</p>
<ul>
<li>
<p><code>SQLT_CHR</code> (<code>VARCHAR2</code>)</p>
</li>
<li>
<p><code>SQLT_VCS</code> (<code>VARCHAR</code>)</p>
</li>
<li>
<p><code>SQLT_STR</code> (<code>NULL</code>-terminated string)</p>
</li>
<li>
<p><code>SQLT_LVC</code> (<code>LONG</code> <code>VARCHAR</code>)</p>
</li>
<li>
<p><code>SQLT_AFC</code> (<code>CHAR</code>)</p>
</li>
<li>
<p><code>SQLT_AVC</code> (<code>CHARZ</code>)</p>
</li>
<li>
<p><code>SQLT_VST</code> (OCI String)</p>
</li>
<li>
<p><code>SQLT_RDD</code> (<code>ROWID</code> descriptor)</p>
</li>
</ul>
<p>The <code>SELECT</code> <code>...</code> <code>FOR</code> <code>UPDATE</code> statement identifies the rows that are to be updated and then locks each row in the result set. This is useful when you want to base an update on the existing values in a row. In that case, you must ensure that another user does not change the row.</p>
<p>When you specify character buffers for storing the values of the <code>ROWID</code>s (for example, if getting it in <code>SQLT_STR</code> format), allocate enough memory for storing <code>ROWID</code>s. Remember the differences between the <code>ROWID</code> data type and the <code>UROWID</code> data type. The <code>ROWID</code> data type can only store physical <code>ROWID</code>s, but <code>UROWID</code> can store logical <code>ROWID</code>s (identifiers for the rows of index-organized tables) as well. The maximum internal length for the <code>ROWID</code> type is 10 bytes; it is 3950 bytes for the <code>UROWID</code> data type.</p>
<p>Dynamic define is equivalent to calling <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> with <code>mode</code> set as <code>OCI_DYNAMIC_FETCH</code>. Dynamic defines enable you to set up additional attributes for a particular define handle. It specifies a callback function that is invoked at runtime to get a pointer to the buffer into which the fetched data or a piece of it is to be retrieved.</p>
<p>The attribute <code><a id="sthref1702"></a>OCI_ATTR_FETCH_ROWID</code> must be set on the statement handle before you can use implicit fetching of <code>ROWID</code>s, in this way:</p>
<pre>
OCIAttrSet(stmthp, OCI_HTYPE_STMT, 0, 0 , OCI_ATTR_FETCH_ROWID, errhp);
</pre>
<p>Dynamic define is not compatible with implicit fetching of <code>ROWID</code>s. In normal scenarios this mode allows the application to provide buffers for a column, for each row; that is, a callback is invoked every time a column value is fetched.</p>
<p>This feature, using <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> for position 0, is for fetching an array of data simultaneously into the user buffers and getting their respective <code>ROWID</code>s at the same time. It allows for fetching of <code>ROWID</code>s with <code>SELECT....FOR UPDATE</code> statements even when <code>ROWID</code> is not one of the columns in the <code>SELECT</code> query. When fetching the data one by one into the user buffers, you can use the existing attribute <code>OCI_ATTR_ROWID</code>.</p>
<p>If you use this feature to fetch the <code>ROWID</code>s, the attribute <code>OCI_ATTR_ROWID</code> on the statement handle cannot be used simultaneously to get the <code>ROWID</code>s. You can only use one of them at a time for a particular statement handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#CHDEJDEE">"OCI_ATTR_FETCH_ROWID"</a></div>
<div id="LNOCI16738" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1703"></a>
<h3 class="sect2">Example of Implicit Fetching of ROWIDs</h3>
<p>Use the fragment of a C program in <a href="#CEGFFICH">Example 10-5</a> to build upon.</p>
<div id="LNOCI18233" class="example">
<p class="titleinexample"><a id="CEGFFICH"></a>Example 10-5 Implicit Fetching of ROWIDs</p>
<pre>
#include &lt;oci.h&gt;
 
int main()
{
 ...
 text *mySql = (text *) "SELECT emp_name FROM emp FOR UPDATE";
 text rowid[100][15] = {0};
 text empName[100][15] = {0};
 ...
 
 /* Set up the environment, error handle, etc. */
 ...
 
 /* Prepare the statement -  select ... for update. */
 
 
  if (OCIStmtPrepare (select_p, errhp,
                      mySql, strlen(mySql), OCI_NTV_SYNTAX, OCI_DEFAULT))
  {
    printf ("Prepare failed \n");
    return (OCI_ERROR);
  }
 
 /* Set attribute for implicit fetching of ROWIDs on the statement handle. */
 if (OCIAttrSet(select_p, OCI_HTYPE_STMT, 0, 0, OCI_ATTR_FETCH_ROWID, errhp))
 {
   printf ("Unable to set the attribute - OCI_ATTR_FETCH_ROWID \n");
   return OCI_ERROR;
 }
  /* 
   * Define the positions: 0 for getting ROWIDs and other positions 
   * to fetch other columns.
   * Also, get the define conversion done implicitly by fetching 
   * the ROWIDs in the string format. 
   */
 
  if (OCIDefineByPos ( select_p,
                       &amp;defnp0,
                       errhp,
                       0,
                       rowid[0],
                       15,
                       SQLT_STR,
                       (void *) ind,
                       (void *) 0,
                       (void *) 0,
                       OCI_DEFAULT) ||
       OCIDefineByPos(select_p,
                       &amp;defnp1,
                       errhp,
                       1,
                       empName[0],
                       15,
                       SQLT_STR,
                       (void *) 0,
                       (void *) 0,
                       (void *) 0,
                       OCI_DEFAULT)
                       )
  {
    printf ("Failed to define\n");
    return (OCI_ERROR);
  }
 
 
  /* Execute the statement. */
 
 if (errr = OCIStmtExecute(svchp,
                            select_p,
                            errhp,
                            (ub4) 5,
                            (ub4) 0,
                            (OCISnapshot *) NULL,
                            (OCISnapshot *) NULL,
                            (ub4) OCI_DEFAULT))
  {
    if (errr != OCI_NO_DATA) 
       return errr;
  }
 
  printf ("Column 0  \t Column 1\n");
  printf ("_________ \t ________\n");
 
  for (i =0 ;i&lt;5 i++)
   {
     printf("%s \t %s \n", rowid[i], empName[i]);
   }
 
 return OCI_SUCCESS;  
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDGGFEF"></a>
<div id="LNOCI10103" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Client Result Cache<a id="sthref1704"></a><a id="sthref1705"></a><a id="sthref1706"></a></h2>
<p>OCI applications can use client memory to take advantage of the OCI result cache to improve response times of repetitive queries.</p>
<p>The client result cache enables client-side caching of SQL query result sets in client memory. The OCI result cache is completely transparent to OCI applications, and its cache of result set data is kept consistent with any session or database changes that affect its result set.</p>
<p>Applications employing this feature see improved performance for queries that have a cache hit. OCI can transparently use cached results for future executions of these queries. Because retrieving results locally from an OCI client process is faster than making a database call and rerunning a query, frequently run queries experience a significant performance improvement when their results are cached.</p>
<p>The OCI cache also reduces the server CPU that would have been consumed for processing the query, thereby improving server scalability. OCI statements from multiple sessions can match the same cached result set in the OCI process memory, if they have similar schema, SQL text, bind values, and session settings. Otherwise, with any dissimilarity, the query execution is directed to the server.</p>
<p>You must enable OCI statement caching or cache statements at the application level when using the client result cache.</p>
<p>Client result cache works with OCI features such as OCI session pooling, OCI connection pooling, database resident connection pooling, and OCI transparent application failover (TAF).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci09adv.htm#i471377">"Statement Caching in OCI"</a></div>
<div id="LNOCI16739" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1707"></a>
<h3 class="sect2">Benefits of Client Result Cache</h3>
<p>The benefits of OCI client query result cache are as follows:</p>
<ul>
<li>
<p>Because the result cache is on the client side, a cache hit causes <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> and <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> calls to be processed locally, instead of making server round-trips. This can result in huge performance savings for server resources, for example, server CPU and server I/O.</p>
</li>
<li>
<p>The OCI client-side query result set cache is a transparent and consistent cache.</p>
</li>
<li>
<p>The result cache on OCI client is per-process, so multiple client sessions can simultaneously use matching cached result sets.</p>
</li>
<li>
<p>It minimizes the need for each OCI application to have its own custom result set cache.</p>
</li>
<li>
<p>It transparently manages the caching aspects of the cached result sets, that is: concurrent access by multiple threads, multiple statements, multiple sessions, invalidation, refreshing of result sets in the cache, and cache memory management.</p>
</li>
<li>
<p>It transparently invalidates the cached result sets on any database changes that may affect the result sets, when an OCI process makes round-trips to the server.</p>
</li>
<li>
<p>This consistent cache is automatically available to all OCI applications and drivers (such as JDBC OCI, ODP.Net, OCCI, Pro*C/C++, Pro*COBOL, ODBC, and so on) built using OCI.</p>
</li>
<li>
<p>The cache uses OCI client memory that may be less expensive than server memory.</p>
</li>
<li>
<p>A local cache on the client has better locality of reference for queries executed by that client.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNOCI16740" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1708"></a>
<h3 class="sect2">Guidelines for Using Client Result Cache</h3>
<p>You can enable client result caching in several ways for your application and establish an order of precedence in its usage based on the methods selected. See <a href="#CEGEEAHF">"Cache Example Use Cases"</a> for more usage information.</p>
<ul>
<li>
<p><a href="#CEGDFJHG">SQL Hints</a> - Annotate a query with a SQL hint <code>/*+ result_cache */</code> to indicate that results are to be stored in the query result cache. Using SQL hints is the highest order of precedence; it takes precedence over table annotations and session parameters. It is applicable to a single query. This method requires application-level changes.</p>
</li>
<li>
<p><a href="#CEGDEAGC">Table Annotation</a> - Annotate a table during deployment using result cache hints in the <code>ALTER</code> <code>TABLE</code> and <code>CREATE</code> <code>TABLE</code> statements. Using table annotation is the next highest order of precedence below SQL hints and above session parameters when using <code>MODE FORCE</code>. It is applicable to all queries for that table. This method requires no application-level changes.</p>
</li>
<li>
<p><a href="#CEGJCCHC">Session Parameters</a> - Works across all tables for all queries; use this method when possible. You can either set the <code>RESULT_CACHE_MODE</code> initialization parameter in the server parameter file (<code>init.ora</code>) or use <code>RESULT_CACHE_MODE</code> clause in <code>the ALTER</code> <code>SESSION</code> and <code>the ALTER</code> <code>SYSTEM</code> statements. Using session parameters is the lowest order of precedence; both SQL hints and table annotations take precedence over session parameters usage. It is the most widely effective usage being applicable to all tables. This method requires no application-level changes.</p>
</li>
</ul>
<p>Oracle recommends that applications annotate tables and queries with result cache hints for read-only or read-mostly database objects. If the result caching happens for queries with large results, these results can use a large amount of cache memory.</p>
<p>As each set of bind values specified by the application creates a different cached result set (for the same SQL text), these result sets together can use a large amount of client result cache memory.</p>
<p>When client result caching is enabled, the query result set can be cached on the client or on the server or both. The client result caching can be enabled even if the server result cache (that is enabled by default) is disabled.</p>
<p>The first <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call of every OCI statement handle call always goes to the server even if there might be a valid cached result set. It is necessary that an <code>OCIStmtExecute()</code> call be made for each statement handle to be able to match a cached result set. Oracle recommends that applications have their own statement caching for OCI statement handles, or use OCI statement caching so that <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> can return an OCI statement handle that has been executed once. Multiple OCI statement handles, from the same or different sessions, can simultaneously fetch data from the same cached result set.</p>
<p>For a result set to be cached, the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> or <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> calls that transparently create this cached result set must fetch rows until an <code>ORA-01403 "No Data Found"</code> error is returned. Subsequent <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> or <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> calls that match a locally cached result set need not fetch to completion.</p>
<a id="CEGDFJHG"></a>
<div id="LNOCI16741" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL Hints</h4>
<p>Unless the <code>RESULT_CACHE_MODE</code> server initialization parameter is set to <code>FORCE</code>, you must explicitly specify the queries to be cached using SQL hints. The SQL <code>/*+ result_cache */</code> or <code>/*+ no_result_cache */</code> hint must be set in SQL text passed to <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> and <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> calls.</p>
</div>
<!-- class="sect3" -->
<a id="CEGDEAGC"></a>
<div id="LNOCI16742" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Table Annotation</h4>
<p>The <code>ALTER</code> <code>TABLE</code> and <code>CREATE</code> <code>TABLE</code> statements enable you to annotate tables with result cache mode. There are also session parameters as mentioned in a later section. The matrix of table annotations and session parameters dictates the effective result cache mode for queries on that table. Note that SQL hints override table annotations and session parameters. The syntax is:</p>
<pre>
CREATE|ALTER TABLE [&lt;schema&gt;.]&lt;table&gt; ... [RESULT_CACHE (MODE {FORCE|DEFAULT})]
</pre>
<p>Here is an example of <code>CREATE</code> <code>TABLE</code>. It defines the table columns:</p>
<pre>
CREATE TABLE foo (a NUMBER, b VARCHAR2(20)) RESULT_CACHE (MODE FORCE); 
</pre>
<p>Here is an example of <code>ALTER</code> <code>TABLE</code>:</p>
<pre>
ALTER TABLE foo RESULT_CACHE (MODE DEFAULT);
</pre>
<p>This <code>ALTER TABLE</code> statement is used to annotate tables so that results of statements or query blocks (for server result cache) using these tables are stored in the result cache. If a given query has a SQL hint <code>/*+ result_cache /</code> or <code>/*+ no_result_cache */</code> or if the parameter <code>RESULT_CACHE_MODE</code> is set to <code>FORCE</code>, then the hint or session variable take precedence over the table annotation.</p>
<p>You should annotate all tables you want stored in the result cache. Then all SQL queries, whether single table selects or with joins, for these tables with cache hints, are considered for caching assuming they are cache-worthy.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF30051" href="../../server.112/e41084/statements_7002.htm#SQLRF30051"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code>RESULT_CACHE</code> clause, SQL hints, <code>ALTER</code> <code>TABLE</code>, and <code>CREATE</code> <code>TABLE</code></p>
</li>
<li>
<p><a class="olink REFRN10270" href="../../server.112/e40402/initparams221.htm#REFRN10270"><span class="italic">Oracle Database Reference</span></a> for more information about <code>RESULT_CACHE_MODE</code></p>
</li>
</ul>
</div>
<p><a href="#CJAEJEHD">Table 10-1</a> summarizes the result cache annotation mode values.</p>
<div id="LNOCI16743" class="tblformal">
<p class="titleintable"><a id="sthref1709"></a><a id="CJAEJEHD"></a>Table 10-1 DDL Table Result Cache Annotation Modes</p>
<table class="cellalignment1016" title="DDL Table Result Cache Annotation Modes" summary="Table Result Cache Annotation Modes" >
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t14">Mode Value</th>
<th class="cellalignment1012" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t14" headers="r1c1-t14">
<p><code>DEFAULT</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c2-t14">
<p>The default value. Result caching is not determined at the table level. You can use this value to clear any table annotations.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t14" headers="r1c1-t14">
<p><code>FORCE</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c2-t14">
<p>If all table names in the query have this setting, then the query is always considered for caching unless the <code>NO_RESULT_CACHE</code> hint is specified for the query. If one or more tables named in the query are set to <code>DEFAULT</code>, then the effective table annotation for that query is <code>DEFAULT</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="LNOCI16744" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1710"></a>
<h4 class="sect3">Checking Table Annotation Mode</h4>
<p>The <code>RESULT_CACHE</code> column in the DBA views <code>DBA_TABLES</code>, <code>USER_TABLES</code>, and <code>ALL_TABLES</code> shows the result cache mode annotation for the table. If the table has not been annotated, it shows <code>DEFAULT</code>.</p>
<p>Suppose that table <code>emp</code> is annotated as <code>ALTER</code> <code>TABLE</code> <code>emp</code> <code>RESULT_CACHE</code> (<code>MODE</code> <code>FORCE</code>).</p>
<p>Then execute the following query in the session:</p>
<p><code>SELECT</code> <code>table_name</code>, <code>result_cache</code> <code>FROM</code> <code>user_tables</code></p>
<p>The output is as follows:</p>
<pre>
TABLE_NAME    RESULT_CACHE
----------    ------------
   EMP           FORCE
   FOO           DEFAULT
</pre>
<p>The output shows that table <code>FOO</code> either has not been annotated or has been annotated using the following statement:</p>
<pre>
ALTER TABLE foo RESULT_CACHE (MODE DEFAULT);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN20286" href="../../server.112/e40402/statviews_2117.htm#REFRN20286"><span class="italic">Oracle Database Reference</span></a> for more information about the <code>RESULT_CACHE</code> column on these DBA views</div>
</div>
<!-- class="sect3" -->
<a id="CEGJCCHC"></a>
<div id="LNOCI16745" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Session Parameters</h4>
<p>The <code>RESULT_CACHE_MODE</code> parameter enables you to decide result cache mode across tables in your queries. Use this clause in <code>ALTER</code> <code>SESSION</code> and <code>ALTER</code> <code>SYSTEM</code> statements, or inside the server parameter file (<code>init.ora</code>) to determine result caching.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN10270" href="../../server.112/e40402/initparams221.htm#REFRN10270"><span class="italic">Oracle Database Reference</span></a> for more information about <code>RESULT_CACHE_MODE</code></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16746" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1711"></a>
<h4 class="sect3">Effective Result Cache Table Mode</h4>
<p>The SQL query level result cache hints take precedence over the session parameter <code>RESULT_CACHE_MODE</code> and result cache table annotations. In addition, table annotation <code>FORCE</code> takes precedence over the session parameter <code>MANUAL</code> as indicated in <a href="#CEGDJDJA">Table 10-2</a>. <a href="#CEGDJDJA">Table 10-2</a> compares modes (<code>MANUAL</code> and <code>FORCE</code>) for the session parameter <code>RESULT_CACHE_MODE</code> versus the comparable table annotation modes and shows the effective result cache mode.</p>
<div id="LNOCI16747" class="tblformal">
<p class="titleintable"><a id="sthref1712"></a><a id="CEGDJDJA"></a>Table 10-2 Effective Result Cache Table Mode</p>
<table class="cellalignment1016" title="Effective Result Cache Table Mode" summary="Effective Result Cache Table Mode" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t17">RESULT_CACHE_MODE Parameter</th>
<th class="cellalignment1012" id="r1c2-t17">MANUAL</th>
<th class="cellalignment1012" id="r1c3-t17">FORCE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t17" headers="r1c1-t17">
<p>Table Annotation = <code>FORCE</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t17 r1c2-t17">
<p><code>FORCE</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t17 r1c3-t17">
<p><code>FORCE</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t17" headers="r1c1-t17">
<p>Table Annotation = <code>DEFAULT</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t17 r1c2-t17">
<p><code>MANUAL</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t17 r1c3-t17">
<p><code>FORCE</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Note that when the effective mode is <code>FORCE</code>, then the actual caching depends on internal restrictions for client and server cache, query cache worthiness (for example, there is no <code>SYSDATE</code> in the query), and space available in the cache. This is similar to the SQL query hint <code>/*+ result_cache */</code> because it is just a hint. It does not imply that the query is actually cached. Recall that table annotation <code>DEFAULT</code> indicates that result caching is not determined at the table level and session parameter mode MANUAL indicates that the query must be annotated with a SQL hint for the hint to take precedence, so in effect these are equivalent methods for this setting.</p>
</div>
<!-- class="sect3" -->
<a id="CEGEEAHF"></a>
<div id="LNOCI16748" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Cache Example Use Cases</h4>
<p>The following are some use cases that show when SQL hints take precedence over table annotations and session parameter.</p>
<ul>
<li>
<p>If the <code>emp</code> table is annotated as <code>ALTER</code> <code>TABLE</code> <code>emp</code> <code>RESULT_CACHE</code> (<code>MODE</code> <code>FORCE</code>) and the session parameter is not set, (it has its default value of <code>MANUAL</code>), this implies queries on table <code>emp</code> are considered for query caching.</p>
</li>
<li>
<p>If in an example, the SQL query is <code>SELECT</code> <code>/*+ no_result_cache */</code> <code>empno</code> <code>FROM</code> <code>emp</code>, the query is not cached. This is because SQL hints take precedence over table annotations and session parameter.</p>
</li>
<li>
<p>If the <code>emp</code> table is not annotated or is annotated as <code>ALTER</code> <code>TABLE</code> <code>emp</code> <code>RESULT_CACHE</code> (<code>MODE</code> <code>DEFAULT</code>) and the session parameter is not set (it has a default value of <code>MANUAL</code>), this implies queries are not cached.</p>
</li>
<li>
<p>If in an example, the SQL query has the hint <code>SELECT</code> <code>/*+ result_cache */</code> <code>*</code> <code>FROM</code> <code>emp</code>, then this query is considered for query caching.</p>
</li>
<li>
<p>If there is no table annotation and there is no SQL query hint, but the session or system parameter is set to <code>FORCE</code>, all queries on all tables are considered for query caching.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF30051" href="../../server.112/e41084/statements_7002.htm#SQLRF30051"><span class="italic">Oracle Database SQL Language Reference</span></a> for more about caching</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16749" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1713"></a>
<h4 class="sect3">Queries That Are Not Cached</h4>
<p>There are queries that are not cached on the OCI client even if the result cache hint is specified. Such queries may be cached on the database if the server result cache feature is enabled (see the discussion of the SQL query result cache in <a class="olink CNCPT007" href="../../server.112/e40540/memory.htm#CNCPT007"><span class="italic">Oracle Database Concepts</span></a> for more information). If a SQL query includes any of the following, then the result set of that query is not cached in the OCI client result cache:</p>
<ul>
<li>
<p>Remote objects</p>
</li>
<li>
<p>Complex types in the select list</p>
</li>
<li>
<p>Snapshot-based queries or flashback queries</p>
</li>
<li>
<p>Queries executed in a serializable, read-only transaction, or inside a flashback session</p>
</li>
<li>
<p>Queries that have PL/SQL functions in them</p>
</li>
<li>
<p>Queries that have virtual private database (VPD) policies enabled on the tables</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16750" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1714"></a>
<h3 class="sect2">Client Cache Consistency</h3>
<p>The client cache transparently keeps the result set consistent with any session state or database changes that can affect its cached result sets.</p>
<p>When a transaction modifies the data or metadata of any of the database objects used to construct that cached result, invalidation is sent to the OCI client on its subsequent round-trip to the server. If the OCI application does no database calls for a period of time, then the client cache lag setting forces the next <code>OCIStmtExecute()</code> call to make a database call to check for such invalidations.</p>
<p>The cached result sets relevant to database invalidations are immediately invalidated, and no subsequent <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> calls can match such result sets. The OCI statement handles currently fetching from these cached result sets, at the time such invalidations are received, can continue fetching from this (invalidated) cached result set.</p>
<p>The next <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call by the process may cache the new result set if there is space available in the cache. The OCI client result cache periodically reclaims unused memory.</p>
<p>If a session has a transaction open, OCI ensures that its queries that reference database objects changed in this transaction go to the server instead of the client cache.</p>
<p>This consistency mechanism ensures that the OCI cache is always close to committed database changes. If the OCI application has relatively frequent calls involving database round-trips due to queries that cannot be cached, (such as DMLs, <code>OCILob</code> calls, and so on) then these calls transparently keep the client cache up-to-date with database changes.</p>
<p>Note that sometimes when a table is modified, a trigger can cause another table to be modified. OCI client result cache is sensitive to all such changes.</p>
<p>When the session state is altered, for example, if NLS session parameters are modified, this can cause the query results to be different. The OCI result cache is sensitive to such changes and on subsequent query executions, returns the correct query result set. The current cached result sets are kept (and not invalidated) for any other session in the process to match; otherwise, these result sets get "Ruled" after a while. There are new result sets cached corresponding to the new session state.</p>
<p>If the application must keep track of all such database and session changes it can be cumbersome and prone to errors. Hence, OCI result cache transparently keeps the result sets consistent with any database or session changes.</p>
<p>The OCI client result cache does not require thread support in the client.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16751" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1715"></a>
<h3 class="sect2">Deployment Time Settings for Client Result Cache</h3>
<p>The client result cache has server initialization parameters and client configuration parameters for its deployment time settings.</p>
<p>These are the server initialization parameters:</p>
<ul>
<li>
<p><code>CLIENT_RESULT_CACHE_SIZE</code></p>
<p>The default value is zero, implying that the client cache feature is disabled. To enable the client result cache feature, set the size to 32768 bytes (32 Kilobytes (KB)) or greater. This is the minimum size of the client per-process result set cache. All OCI client processes get this minimum size. This can be overridden by the <code>sqlnet.ora</code> configuration parameter <code>OCI_RESULT_CACHE_MAX_SIZE</code> only if this feature is enabled on the server by the <code>CLIENT_RESULT_CACHE_SIZE</code> initialization parameter.</p>
<p>You can view the current default maximum size by displaying the value of the <code>CLIENT_RESULT_CACHE_SIZE</code> parameter. To increase this maximum size, you can set <code>CLIENT_RESULT_CACHE_SIZE</code>. However, because <code>CLIENT_RESULT_CACHE_SIZE</code> is a static parameter, you must include the <code>SCOPE = SPFILE</code> clause if you use an <code>ALTER SYSTEM</code> statement, and you must restart the database before any changes to this parameter take effect.</p>
<p>Note that if the client result cache feature is disabled at the server, the client configuration parameter <code>OCI_RESULT_CACHE_MAX_SIZE</code> is ignored and the client result cache cannot be enabled at the client.</p>
<p>The cache size can be set to the minimum of:</p>
<p>(available client memory) and</p>
<p>((the possible number of result sets to be cached)</p>
<p>* (the average size of a row in a result set)</p>
<p>* (the average number of rows in a result set)).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The client result cache has a maximum value of <a id="sthref1716"></a>2 GB; setting it higher causes a truncation to 2 GB.
<p>Do not set the <code>CLIENT_RESULT_CACHE_SIZE</code> parameter during database creation, because that can cause errors.</p>
</div>
</li>
<li>
<p><code>CLIENT_RESULT_CACHE_LAG</code></p>
<p>The <code>CLIENT_RESULT_CACHE_LAG</code> initialization parameter enables you to specify the maximum amount of time in milliseconds that the client result cache can lag behind any changes in the database that affect its result sets. The default is 3000 milliseconds.</p>
<p>You can view the current lag by displaying the value of the <code>CLIENT_RESULT_CACHE_LAG</code> parameter. To change this value, you can set <code>CLIENT_RESULT_CACHE_LAG</code>. However, because <code>CLIENT_RESULT_CACHE_LAG</code> is a static parameter, you must include the <code>SCOPE = SPFILE</code> clause if you use an <code>ALTER SYSTEM</code> statement, and you must restart the database before any changes to this parameter take effect.</p>
</li>
<li>
<p>Table annotation. Optional. One can annotate read-only, read-mostly tables for result caching during deployment. No application-level changes are required. Note SQL result cache hints, if specified, override the table annotations. See Oracle Database SQL Language Reference for more information.</p>
</li>
<li>
<p><code>compatible</code></p>
<p>Specifies the release with which Oracle Database must maintain compatibility. This parameter must be set to 11.0.0.0 or higher for the client result cache to be enabled. If you want client caching on views, <code>compatible</code> must be set to 11.2.0.0 or higher.</p>
</li>
</ul>
<div id="LNOCI16752" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1717"></a>
<h4 class="sect3">Client Configuration File</h4>
<p>A client configuration file is optional and overrides the cache parameters set in the server <code>init.ora</code> initialization file. These parameters are part of a <code>sqlnet.ora</code> file. The following optional parameters are available for client configuration:</p>
<ul>
<li>
<p><code>OCI_RESULT_CACHE_MAX_SIZE</code> (optional) - Maximum size in bytes for the per-process query cache. Specifying a size less than 32768 in the client <code>sqlnet.ora</code> file disables the client result cache feature for client processes reading this <code>sqlnet.ora</code> file.</p>
</li>
<li>
<p><code>OCI_RESULT_CACHE_MAX_RSET_SIZE</code> (optional) - Maximum size of any result set in bytes in the per-process query cache.</p>
</li>
<li>
<p><code>OCI_RESULT_CACHE_MAX_RSET_ROWS</code> (optional) - Maximum size of any result set in rows in the per-process query cache.</p>
</li>
</ul>
<p>Note that the cache lag cannot be set on the client.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16753" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1718"></a>
<h3 class="sect2">Client Cache Statistics</h3>
<p>On existing round-trips from the OCI client, OCI periodically sends statistics related to its client cache to the server. These statistics are stored in the <code>CLIENT_RESULT_CACHE_STATS$</code> view. Information such as the number of result sets successfully cached, number of cache hits, and number of cached result sets invalidated are stored here. The number of cache misses for queries is at least equal to the number of Create Counts in client result cache statistics. More precisely, the cache miss count equals the number of server executions as seen in server <a id="sthref1719"></a>Automatic Workload Repository (AWR) reports.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN29085" href="../../server.112/e40402/statviews_2156.htm#REFRN29085"><span class="italic">Oracle Database Reference</span></a> for information about the <code>CLIENT_RESULT_CACHE_STAT$</code> view</p>
</li>
<li>
<p><a class="olink PFGRF973" href="../../server.112/e41573/memory.htm#PFGRF973"><span class="italic">Oracle Database Performance Tuning Guide</span></a> to find the client process IDs and session IDs for the sessions doing client caching</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI18234" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1720"></a>
<h3 class="sect2">Validation of the Client Result Cache</h3>
<p>The following sections provide some more information about performing validations of the client result cache.</p>
<div id="LNOCI18235" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1721"></a>
<h4 class="sect3">Timing Measurement</h4>
<p>First, to determine the performance gain of adding result cache hints to the queries, measure the time taken to run the queries without the <code>/*+ result_cache */</code> hints. Then add the <code>/*+ result_cache */</code> hints to the query and measure the time again. The difference in time is your performance gain.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI18236" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1722"></a>
<h4 class="sect3">Using v$mystat</h4>
<p>Query the <code>v$mystat</code> view. To query this view, you must be granted permissions. Perform these two queries</p>
<p>Query-1: Measures the "SQL*Net round-trips to and from the client" from <code>v$mystat</code>.</p>
<p>Query-2: Measures the "SQL*Net round-trips to and from the client" without the SQL result cache hint.</p>
<p>The difference between Query-2 and Query-1 queries is the number of round-trips that it usually takes without enabling client result cache.</p>
<p>Note that the Query-1 query itself would make some round-trips (approximately 2) in this calculation.</p>
<p>If you add a result cache hint to the query or add the <code>FORCE</code> table annotation to the query for table <code>emp</code> and perform the query again, the difference between Query-2 and Query-1 is much less.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI18237" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1723"></a>
<h4 class="sect3">Using v$sqlarea</h4>
<p>Query the <code>v$sqlarea</code> view. To query this view, you must be granted permissions.</p>
<p>Run the following SQL statement:</p>
<pre>
SELECT COUNT(*) FROM emp
</pre>
<p>Reexecute this preceding SQL statement a few times.</p>
<p>Then query select executions, fetches, parse_calls from <code>v$sqlarea</code> where <code>sql_tex</code>t like '<code>% from emp</code>';</p>
<p>Next, add the result cache table hint for <code>emp</code> to the query.</p>
<p>Reexecute the query a few times.</p>
<p>With client caching, the values for column1, column2 are less.</p>
<p>Note that the preceding validations can also be performed with result cache table annotations.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16754" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1724"></a>
<h3 class="sect2">OCI Client-Side Result Cache and Server Result Cache</h3>
<p>The client-side result cache is a separate feature from the server result cache. The client-side result cache caches results of top-level SQL queries in OCI client memory, whereas the server result cache caches result sets in server SGA memory.</p>
<p>The server result cache may also cache query fragments. The client-side result caching can be enabled independently of the server result cache, though they both share the result cache SQL hints, table annotation, and session parameter <code>RESULT_CACHE_MODE</code>. See <span class="italic">Oracle Database Concepts</span> for more information about SQL query result cache. <a href="#CJAEAHHE">Table 10-3</a> shows the specific result cache association for client-site result cache or server result cache, or both, with regard to setting specific parameters, running particular PL/SQL packages, and querying specific Oracle database views.</p>
<div id="LNOCI16755" class="tblformal">
<p class="titleintable"><a id="sthref1725"></a><a id="CJAEAHHE"></a>Table 10-3 Setting Client-Side Result Cache and Server Result Cache</p>
<table class="cellalignment1016" title="Setting Client-Side Result Cache and Server Result Cache" summary="Ways to set client result cache" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t21">Parameters, PL/SQL Package, and Database Views</th>
<th class="cellalignment1012" id="r1c2-t21">Result Cache Association</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t21" headers="r1c1-t21">
<p>client_result_cache_* parameters</p>
<p>client_result_cache_size,</p>
<p>client_result_cache_lag</p>
</td>
<td class="cellalignment1013" headers="r2c1-t21 r1c2-t21">
<p>client result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t21" headers="r1c1-t21">
<p>SQL hints /*+ result_cache */,</p>
<p>/*+ no_result_cache */</p>
</td>
<td class="cellalignment1013" headers="r3c1-t21 r1c2-t21">
<p>client result cache, server result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t21" headers="r1c1-t21">
<p>sqlnet.ora OCI_RESULT_CACHE* parameters:</p>
<p>OCI_RESULT_CACHE_MAX_SIZE</p>
<p>OCI_RESULT_CACHE_MAX_RSET_SIZE</p>
<p>OCI_RESULT_CACHE_MAX_RSET_ROWS</p>
</td>
<td class="cellalignment1013" headers="r4c1-t21 r1c2-t21">
<p>client result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t21" headers="r1c1-t21">
<p>Statistics view: client_result_cache_stats$</p>
</td>
<td class="cellalignment1013" headers="r5c1-t21 r1c2-t21">
<p>client result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t21" headers="r1c1-t21">
<p>result_cache_mode parameter</p>
</td>
<td class="cellalignment1013" headers="r6c1-t21 r1c2-t21">
<p>client result cache, server result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t21" headers="r1c1-t21">
<p>All other result_cache* parameters, for example, result_cache_max_size</p>
</td>
<td class="cellalignment1013" headers="r7c1-t21 r1c2-t21">
<p>server result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t21" headers="r1c1-t21">
<p>Package DBMS_RESULT_CACHE</p>
</td>
<td class="cellalignment1013" headers="r8c1-t21 r1c2-t21">
<p>server result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t21" headers="r1c1-t21">
<p>Statistics views v$result_cache_*, gv$result_cache_*.</p>
<p>For example, v$result_cache_statistics, gv$result_cache_memory</p>
</td>
<td class="cellalignment1013" headers="r9c1-t21 r1c2-t21">
<p>server result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t21" headers="r1c1-t21">
<p>create table annotation</p>
</td>
<td class="cellalignment1013" headers="r10c1-t21 r1c2-t21">
<p>client result cache, server result cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t21" headers="r1c1-t21">
<p>alter table annotation</p>
</td>
<td class="cellalignment1013" headers="r11c1-t21 r1c2-t21">
<p>client result cache, server result cache</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI16756" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1726"></a>
<h3 class="sect2">Client Result Cache Demo Files</h3>
<p>See the files <code>cdemoqc.sql</code>, <code>cdemoqc.c</code>, and <code>cdemoqc2.c</code> (all are in the <code>demo</code> directory for your operating system) for demonstration files for this feature.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16757" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1727"></a>
<h3 class="sect2">Compatibility with Previous Releases</h3>
<p>To use client result cache, applications must be relinked with Oracle Database Release 11.1 or later client libraries and be connected to an Oracle Database Release 11.1 or later database server. This feature is available to all OCI applications including JDBC Type II driver, OCCI, Pro*C/C++, and ODP.NET. The OCI drivers automatically pass the result cache hint to <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> and <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a> calls, thereby getting the benefits of caching.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCIAHJ"></a>
<div id="LNOCI1020" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Fault Diagnosability in OCI</h2>
<p><a id="sthref1728"></a>Fault diagnosability was introduced into OCI in Oracle Database 11<span class="italic">g</span> Release 1 (11.1). An incident (an occurrence of a problem) on the OCI client is captured without user intervention in the form of diagnostic data: dump files or core dump files. The diagnostic data is stored in an <a id="sthref1729"></a><a id="sthref1730"></a>Automatic Diagnostic Repository (ADR) subdirectory created for the incident. For example, if a Linux or UNIX application fails with a <code>NULL</code> pointer reference, then the core file is written in the ADR home directory (if it exists) instead of the operating system directory. The ADR subdirectory structure and a utility to deal with the output, ADR Command Interpreter (ADRCI), are discussed in the following sections.</p>
<p>An ADR home is the root directory for all diagnostic data for an instance of a particular product such as OCI and a particular operating system user. ADR homes are grouped under the same root directory, the ADR base.</p>
<p>Fault diagnosability and the ADR structure for Oracle Database are described in detail in the discussion of managing diagnostic data in Oracle Database Administrator's Guide.</p>
<div id="LNOCI16758" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1731"></a>
<h3 class="sect2"><a id="sthref1732"></a>ADR Base Location</h3>
<p>The location of the ADR base is determined by OCI in the following order:</p>
<ol>
<li>
<p>OCI first looks in the file <code>sqlnet.ora</code> (if it exists) for a statement such as (Linux or UNIX):</p>
<pre>
ADR_BASE=<span class="italic">/foo/adr</span>
</pre>
<p><code>adr</code> (the name of a directory) must exist and be writable by all operating system users who execute OCI applications and want to share the same ADR base. <code>foo</code> stands for a path name. The location of <code>sqlnet.ora</code> is given in the directory <code>$TNS_ADMIN</code> (<code>%TNS_ADMIN%</code> on Windows). If there is no <code>$TNS_ADMIN</code> then the current directory is used. If <code>ADR_BASE</code> is set and one <code>sqlnet.ora</code> is shared by all users, then OCI stops searching when directory <code>adr</code> does not exist or is not writable by the user. If <code>ADR_BASE</code> is not set, then OCI continues the search, testing for the existence of certain directories.</p>
<p>For example, if <code>sqlnet.ora</code> contains the entry <code>ADR_BASE=/home/chuck/test</code> then the ADR base is <code>/home/chuck/test/oradiag_chuck</code> and the ADR home could be something like <code>/home/chuck/test/oradiag_chuck/diag/clients/user_chuck/host_4144260688_11</code>.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">$ORACLE_BASE</span></code> (<code><span class="codeinlineitalic">%ORACLE_BASE%</span></code> on Windows) exists. In this case, the client subdirectory exists because it was created during installation of the database using Oracle Universal Installer.</p>
<p>For example, if <code><span class="codeinlineitalic">$ORACLE_BASE</span></code> is <code>/home/chuck/obase</code> then the ADR base is <code>/home/chuck/obase</code> and the ADR home could be similar to <code>/home/chuck/obase/diag/clients/user_chuck/host_4144260688_11</code>.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">$ORACLE_HOME</span></code> <code><span class="codeinlineitalic">(%ORACLE_BASE%</span></code> on Windows) exists. In this case, the client subdirectory exists because it was created during installation of the database using Oracle Universal Installer.</p>
<p>For example, if <code><span class="codeinlineitalic">$ORACLE_HOME</span></code> is <code>/ade/chuck_l1/oracle</code> then the ADR base is <code>/ade/chuck_l1/oracle/log</code> and the ADR home could be similar to <code>/ade/chuck_l1/oracle/log/diag/clients/user_chuck/host_4144260688_11</code>.</p>
</li>
<li>
<p>Operating system home directory: <code><span class="codeinlineitalic">$HOME</span></code> on Linux or UNIX, or <code><span class="codeinlineitalic">%USERPROFILE%</span></code> on Windows. On Linux or UNIX the location could be something like this for user <code>chuck</code>: <code>/home/chuck/oradiag_chuck</code>. On Windows, a folder named <code>Oracle</code> is created under <code>C:\Documents and Settings\chuck</code>.</p>
<p>For example, in an Instant Client, if <code><span class="codeinlineitalic">$HOME</span></code> is <code>/home/chuck</code> then the ADR base is <code>/home/chuck/oradiag_chuck</code> and the ADR home could be <code>/home/chuck/oradiag_chuck/diag/clients/user_chuck/host_4144260688_11</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci01int.htm#i423362">"OCI Instant Client"</a></div>
</li>
<li>
<p>On Windows, if the application is run as a service, the home directory option is skipped.</p>
</li>
<li>
<p>Temporary directory in the Linux or UNIX operating system: <code>/var/tmp</code>.</p>
<p>For example, in an Instant Client, if <code><span class="codeinlineitalic">$HOME</span></code> is not writable, then the ADR base is <code>/var/tmp/oradiag_chuck</code> and the ADR home could be <code>/var/tmp/oradiag_chuck/diag/clients/user_chuck/host_4144260688_11</code>.</p>
<p>Temporary directories in the Windows operating system, searched in this order:</p>
<ol>
<li>
<p><code><span class="codeinlineitalic">%TMP%</span></code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">%TEMP%</span></code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">%USERPROFILE%</span></code></p>
</li>
<li>
<p>Windows system directory</p>
</li>
</ol>
</li>
</ol>
<p>If none of these directory choices are available and writable, or the ADR base is not created and there are no diagnostics.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NETRF398" href="../../network.112/e10835/sqlnet.htm#NETRF398"><span class="italic">Oracle Database Net Services Reference</span></a></div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16759" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1733"></a>
<h3 class="sect2">Using ADRCI</h3>
<p><a id="sthref1734"></a>ADRCI is a command-line tool that enables you to view diagnostic data within the ADR and to package incident and problem information into a zip file for Oracle Support to use. You can use ADRCI interactively and from a script. A <span class="italic">problem</span> is a critical error in OCI or the client. Each problem has a problem key. An <span class="italic">incident</span> is a single occurrence of a problem and is identified by a unique numeric incident ID. Each incident has a problem key that is a set of attributes: the <code>ORA</code> error number, error parameter values, and other information. Two incidents have the same root cause if their problem keys match.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL700" href="../../server.112/e22490/adrci.htm#SUTIL700"><span class="italic">Oracle Database Utilities</span></a> for an introduction to ADRCI</div>
<p>What follows is a launch of ADRCI in a Linux system, a use of the <code>HELP</code> command for the <code>SHOW</code> <code>BASE</code> command, and then the use of the <code>SHOW</code> <code>BASE</code> command with the option <code>-PRODUCT</code> <code>CLIENT</code>, which is necessary for OCI applications. The ADRCI commands are case-insensitive. User input is shown in bold.</p>
<pre>
% <span class="bold">adrci</span>
 
ADRCI: Release 11.1.0.5.0 - Beta on Wed May 2 15:53:06 2007
 
Copyright (c) 1982, 2007, Oracle.  All rights reserved.
 
adrci&gt; <span class="bold">help show base</span>
 
  Usage: SHOW BASE [-product &lt;product_name&gt;]
 
  Purpose: Show the current ADR base setting.
 
  Options:
    [-product &lt;product_name&gt;]: This option allows users to show the
    given product's ADR Base location. The current registered products are
    "CLIENT" and "ADRCI".
 
  Examples: 
    show base -product client
    show base
 
adrci&gt; <span class="bold">show base -product client</span>
ADR base is "/ade/chuck_l3/oracle/log/oradiag_chuck"
</pre>
<p>Next, the <code>SET</code> <code>BASE</code> command is described:</p>
<pre>
adrci&gt; <span class="bold">help set base</span>
 
  Usage:  SET BASE &lt;base_str&gt;
 
  Purpose: Set the ADR base to use in the current ADRCI session.
           If there are valid ADR homes under the base, all homes will
           will be added to the current ADRCI session.
 
  Arguments:
    &lt;base_str&gt;: It is the ADR base directory, which is a system-dependent
    directory path string.
 
  Notes:
    On platforms that use "." to signify current working directory,
    it can be used as base_str.
 
  Example: 
    set base /net/sttttd1/scratch/someone/view_storage/someone_v1/log
    set base .
 
adrci&gt; <span class="bold">quit</span>
</pre>
<p>When <code>ADRCI</code> is started, the default ADR base is for the <code>rdbms</code> server. <code><span class="codeinlineitalic">$ORACLE_HOME</span></code> is set to <code>/ade/chuck_l3/oracle</code>:</p>
<pre>
% <span class="bold">adrci</span>
 
ADRCI: Release 11.1.0.5.0 - Beta on Wed May 2 16:16:55 2007
 
Copyright (c) 1982, 2007, Oracle.  All rights reserved.
 
ADR base = "/ade/chuck_l3/oracle/log"
</pre>
<p>For OCI application incidents you must check and set the base:</p>
<pre>
adrci&gt; <span class="bold">show base -product client</span>
ADR base is "/ade/chuck_l3/oracle/log"
adrci&gt; <span class="bold">set base /ade/chuck_l3/oracle/log</span>
</pre>
<p>For Instant Client there is no <code><span class="codeinlineitalic">$ORACLE_HOME</span></code>, so the default base is the user's home directory:</p>
<pre>
adrci&gt; <span class="bold">show base -product client</span>
ADR base is "/home/chuck/oradiag_chuck"
adrci&gt; <span class="bold">set base /home/chuck/oradiag_chuck</span>
adrci&gt; <span class="bold">show incidents</span>
 
ADR Home = /home/chuck/oradiag_chuck/diag/clients/user_chuck/host_4144260688_11:
*************************************************************************
INCIDENT_ID    PROBLEM_KEY           CREATE_TIME
-------------------------------------------------------------------------
1                     oci 24550 [6]              2007-05-01 17:20:02.803697 -07:00                      
1 rows fetched
 
adrci&gt;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci01int.htm#i423362">"OCI Instant Client"</a></div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16760" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1735"></a>
<h3 class="sect2">Controlling ADR Creation and Disabling Fault Diagnosability Using <a id="sthref1736"></a><a id="sthref1737"></a>sqlnet.ora</h3>
<p>To disable diagnosability, turn off diagnostics by setting the following parameters in <code>sqlnet.ora</code> (the default is <code>TRUE</code>):</p>
<pre>
<a id="sthref1738"></a>DIAG_ADR_ENABLED=FALSE
<a id="sthref1739"></a>DIAG_DDE_ENABLED=FALSE
</pre>
<p>To turn off the OCI signal handler and reenable standard operating system failure processing, place the following parameter setting in <code>sqlnet.ora</code>:</p>
<pre>
<a id="sthref1740"></a>DIAG_SIGHANDLER_ENABLED=FALSE
</pre>
<p>As noted previously, <code>ADR_BASE</code> is used in <code>sqlnet.ora</code> to set the location of the ADR base.</p>
<p>Oracle Database client contains advanced features for diagnosing issues, including the ability to dump diagnostic information when important errors are detected. By default, these dumps are restricted to a small subset of available information, to ensure that application data is not dumped. However, in many installations, secure locations for dump files may be configured, ensuring the privacy of such logs. In such cases, it is recommended to turn on full dumps; this can greatly speed resolution of issues. Full dumps can be enabled by adding the following line to the <code>sqlnet.ora</code> file used by your Oracle Database client installation:</p>
<pre>
<a id="sthref1741"></a>DIAG_RESTRICTED=FALSE
</pre>
<p>To verify that diagnosability features are working correctly:</p>
<ol>
<li>
<p>Upgrade your application to use the latest client libraries.</p>
</li>
<li>
<p>Start your application.</p>
</li>
<li>
<p>Check the file <code>sqlnet.log</code> in your application's <code>TNS_ADMIN</code> directory for error messages indicating that diagnosability could not be started (normally this is due to invalid directory names or permissions).</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink NETRF397" href="../../network.112/e10835/sqlnet.htm#NETRF397"><span class="italic">Oracle Database Net Services Reference</span></a> for the ADR parameter settings in <code>sqlnet.ora</code></p>
</li>
<li>
<p><a class="olink NETAG1524" href="../../network.112/e41945/trouble.htm#NETAG1524"><span class="italic">Oracle Database Net Services Administrator's Guide</span></a> for more information about the structure of ADR</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJADCGBB"></a>
<div id="LNOCI16761" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1742"></a>Client and Server Operating with Different Versions of Time Zone Files</h2>
<p>In Oracle Database Release 11.2 (or later) you can use different versions of the time zone file on the client and server; this mode of operation was not supported before Oracle database Release 11.2. Both client and server must be 11.2 or later to operate in such a mixed mode. This section discusses the ramifications of operating in such a mode. To avoid these ramifications use the same time zone file version for client and server.</p>
<p>The following behavior is seen when the client and server use different time zones file versions. Note that the use of different time zone file versions only affects the handling of <code>TIMESTAMP</code> <code>WITH</code> <code>TIMEZONE</code> (<code>TSTZ</code>) data type values.</p>
<ul>
<li>
<p>The OCI Datetime and Interval APIs listed here unconditionally raise an error when the input parameters are of <code>TSTZ</code> type. This is because these operations depend on the local time zone file on the client that is not synchronized with the database. Continuing with the computation in such a configuration can result in inconsistent computations across the client and database tiers.</p>
<pre>
<a href="oci19map002.htm#i508759">OCIDateTimeCompare()</a>
<a href="oci19map002.htm#i512069">OCIDateTimeConstruct()</a>
<a href="oci19map002.htm#i508796">OCIDateTimeConvert()</a>
<a href="oci19map002.htm#i511964">OCIDateTimeSubtract()</a>
<a href="oci19map002.htm#i512468">OCIIntervalAdd()</a>
<a href="oci19map002.htm#i510871">OCIIntervalSubtract()</a>
<a href="oci19map002.htm#i519352">OCIIntervalFromTZ()</a>
<a href="oci19map002.htm#i512092">OCIDateTimeGetTimeZoneName()</a>
<a href="oci19map002.htm#i508981">OCIDateTimeGetTimeZoneOffset()</a><a id="sthref1743" href="#sthref1743" onclick='footdisplay(1,"Returns an \u003ccode\u003eORA-01805\u003c/code\u003e error when timezone files on the client and server do not match (regions are not synchronized); returns \u003ccode\u003eOCI_SUCCESS\u003c/code\u003e when region time zone values are the same (represent the same instant in UTC), though the \u003ccode\u003eTIME ZONE\u003c/code\u003e offsets are different.")'><sup class="tablefootnote">Foot 1 </sup></a>
<a href="oci19map002.htm#i512454">OCIDateTimeSysTimeStamp()</a>
</pre></li>
<li>
<p>There is a performance penalty when you retrieve or modify <code>TSTZ</code> values. The performance penalty arises because of the additional conversions needed to compensate for the client and server using different time zone file versions.</p>
</li>
<li>
<p>If new time zone regions are defined by the more recent time zone file, you can see an error operating on a <code>TIMESTAMP</code> <code>WITH</code> <code>TIMEZONE</code> value belonging to the new region on a node that has a time zone file version that does not recognize the new time zone region.</p>
</li>
</ul>
<p>Applications that manipulate opaque type or <code>XMLType</code> instances or both containing <code>TSTZ</code> type attributes must use the same time zone file version on client and server to avoid data loss.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG259" href="../../server.112/e10729/ch4datetime.htm#NLSPG259"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about upgrading the time zone file and timestamp with time zone data</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;Returns an <code>ORA-01805</code> error when timezone files on the client and server do not match (regions are not synchronized); returns <code>OCI_SUCCESS</code> when region time zone values are the same (represent the same instant in UTC), though the <code>TIME ZONE</code> offsets are different.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci09adv.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci11obj.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
