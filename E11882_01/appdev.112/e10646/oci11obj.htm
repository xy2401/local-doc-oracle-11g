<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>OCI Object-Relational Programming</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:24Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci10new.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci12oty.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">18/79</span> <!-- End Header -->
<div id="LNOCI100" class="chapter"><a id="i450885"></a>
<h1 class="chapter"><span class="secnum">11</span> OCI Object-Relational Programming</h1>
<p>This chapter introduces the OCI facility for working with objects in an Oracle database. It also discusses the object navigational function calls of OCI.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i440271">OCI Object Overview</a></p>
</li>
<li>
<p><a href="#i440300">Working with Objects in OCI</a></p>
</li>
<li>
<p><a href="#i440360">Developing an OCI Object Application</a></p>
</li>
<li>
<p><a href="#i449841">Type Inheritance</a></p>
</li>
<li>
<p><a href="#i450362">Type Evolution</a></p>
</li>
</ul>
<a id="i440271"></a>
<div id="LNOCI16776" class="sect1">
<h2 class="sect1">OCI Object Overview<a id="sthref1744"></a></h2>
<p>OCI allows applications to access any of the data types found in Oracle Database, including scalar values, collections, and instances of any object type. This includes all of the following:</p>
<ul>
<li>
<p>Objects</p>
</li>
<li>
<p>Variable-length arrays (<a id="sthref1745"></a><code>varray</code>s)</p>
</li>
<li>
<p>Nested tables (multisets)</p>
</li>
<li>
<p>References (<code>REF</code>s)</p>
</li>
<li>
<p>LOBs</p>
</li>
</ul>
<p>To take full advantage of Oracle Database object capabilities, most applications must do more than just access objects. After an object has been retrieved, the application must navigate through references from that object to other objects. OCI provides the capability to do this. Through the OCI object <span class="italic">navigational calls</span>, an application can perform any of the following functions on objects:</p>
<ul>
<li>
<p>Creating, accessing, locking, deleting, copying, and flushing objects</p>
</li>
<li>
<p>Getting references to the objects and their meta-objects</p>
</li>
<li>
<p>Dynamically getting and setting values of objects' attributes</p>
</li>
</ul>
<p>The OCI navigational calls are discussed in more detail beginning in <a href="#i440360">"Developing an OCI Object Application"</a>.</p>
<p>OCI also provides the ability to access type information stored in an Oracle database. The <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> function enables an application to access most information relating to types stored in the database, including information about methods, attributes, and type metadata.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci06des.htm#g464132">Chapter 6</a> for a discussion of <code>OCIDescribeAny()</code></div>
<p>Applications interacting with Oracle Database objects need a way to represent those objects in a host language format. Oracle Database provides a utility called the Object Type Translator (OTT), which can convert type definitions in the database to C struct declarations. The declarations are stored in a header file that can be included in an OCI application.</p>
<p>When type definitions are represented in C, the types of attributes are mapped to special C variable types. OCI includes a set of <span class="italic">data type mapping and manipulation functions</span> that enable an application to manipulate these data types, and thus manipulate the attributes of objects.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci12oty.htm#g453655">Chapter 12</a> for a more detailed discussion about functions</div>
<p>The terminology for objects can occasionally become confusing. In the remainder of this chapter, the terms <span class="italic">object</span> and <span class="italic">instance</span> both refer to an object that is either stored in the database or is present in the object cache.</p>
</div>
<!-- class="sect1" -->
<a id="i440300"></a>
<div id="LNOCI16777" class="sect1">
<h2 class="sect1">Working with Objects in OCI</h2>
<p>Many of the programming principles that govern a relational OCI application are the same for an object-relational application. An object-relational application uses the standard OCI calls to establish database connections and process SQL statements. The difference is that the SQL statements issued retrieve object references, which can then be manipulated with the OCI object functions. An object can also be directly manipulated as a value instance (without using its object reference).</p>
<a id="i440303"></a>
<div id="LNOCI16778" class="sect2">
<h3 class="sect2">Basic Object Program Structure<a id="sthref1746"></a><a id="sthref1747"></a></h3>
<p>The basic structure of an OCI application that uses objects is essentially the same as that for a relational OCI application, as described in <a href="oci02bas.htm#i461059">"Overview of OCI Program Programming"</a>. That paradigm is reproduced here, with extra information covering basic object functionality.</p>
<ol>
<li>
<p>Initialize the OCI programming environment. You <span class="italic">must</span> initialize the environment in object mode.</p>
<p>Your application must include C struct representations of database objects in a header file. These structs can be created by the programmer, or, more easily, they can be generated by the Object Type Translator (OTT), as described in <a href="oci15ott.htm#g455369">Chapter 15</a>.</p>
</li>
<li>
<p>Allocate necessary handles, and establish a connection to a server.</p>
</li>
<li>
<p>Prepare a SQL statement for execution. This is a local (client-side) step, which may include binding placeholders and defining output variables. In an object-relational application, this SQL statement should return a reference (<code>REF</code>) to an object.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is also possible to fetch an entire object, rather than just a reference (<code>REF</code>). If you select a referenceable object, rather than pinning it, you get that object <span class="italic">by value</span>. You can also select a nonreferenceable object. <a href="#i440601">"Fetching Embedded Objects"</a> describes fetching the entire object.</div>
</li>
<li>
<p>Associate the prepared statement with a database server, and execute the statement.</p>
</li>
<li>
<p>Fetch returned results.</p>
<p>In an object-relational application, this step entails retrieving the <code>REF</code>, and then pinning the object to which it refers. Once the object is pinned, your application can do some or all of the following:</p>
<ul>
<li>
<p>Manipulate the attributes of the object and mark it as <span class="italic">dirty</span> (modified)</p>
</li>
<li>
<p>Follow a <code>REF</code> to another object or series of objects</p>
</li>
<li>
<p>Access type and attribute information</p>
</li>
<li>
<p>Navigate a complex object retrieval graph</p>
</li>
<li>
<p>Flush modified objects to the server</p>
</li>
</ul>
</li>
<li>
<p>Commit the transaction. This step implicitly flushes all modified objects to the server and commits the changes.</p>
</li>
<li>
<p>Free statements and handles not to be reused, or reexecute prepared statements again.</p>
</li>
</ol>
<p>These steps are discussed in more detail in the remainder of this chapter.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci02bas.htm#g478150">Chapter 2</a> for information about using OCI to connect to a server, process SQL statements, and allocate handles and the description of the OCI relational functions in <a href="oci16rel.htm#i560652">Chapter 16</a></p>
</li>
<li>
<p><a href="#i440367">"Representing Objects in C Applications"</a> for information about OTT and <a href="oci15ott.htm#g455369">Chapter 15</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i442662"></a>
<div id="LNOCI16779" class="sect2">
<h3 class="sect2">Persistent Objects, Transient Objects, and Values<a id="sthref1748"></a><a id="sthref1749"></a><a id="sthref1750"></a><a id="sthref1751"></a><a id="sthref1752"></a><a id="sthref1753"></a></h3>
<p>Instances of an Oracle type are categorized into <span class="italic">persistent objects</span> and <span class="italic">transient objects</span> based on their lifetime. Instances of persistent objects can be further divided into <span class="italic">standalone objects</span> and <span class="italic">embedded objects</span> depending on whether they are referenceable by way of an object identifier.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The terms <span class="italic">object</span> and <span class="italic">instance</span> are used interchangeably in this manual.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ001" href="../../appdev.112/e11822/adobjint.htm#ADOBJ001"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for more information about objects</div>
<div id="LNOCI16780" class="sect3"><a id="sthref1754"></a>
<h4 class="sect3">Persistent Objects<a id="sthref1755"></a><a id="sthref1756"></a></h4>
<p>A persistent object is an object that is stored in an Oracle database. It may be fetched into the object cache and modified by an OCI application. The lifetime of a persistent object can exceed that of the application that is accessing it. Once it is created, it remains in the database until it is explicitly deleted. There are two types of persistent objects:</p>
<ul>
<li>
<p>Standalone instances are stored in rows of an object table, and each instance has a unique object identifier. An OCI application can retrieve a <code>REF</code> to a standalone instance, pin the object, and navigate from the pinned object to other related objects. Standalone objects may also be referred to as <span class="italic">referenceable objects</span>.</p>
<p>It is also possible to select a referenceable object, in which case you fetch the object <span class="italic">by value</span> instead of fetching its <code>REF</code>.</p>
</li>
<li>
<p>Embedded instances are not stored as rows in an object table. They are embedded within other structures. Examples of embedded objects are objects that are attributes of another object, or instances that exist in an object column of a database table. Embedded instances do not have object identifiers, and OCI applications cannot get <code>REF</code>s to embedded instances.</p>
<p>Embedded objects may also be referred to as <span class="italic">nonreferenceable objects</span> or <span class="italic">value instances</span>. You may sometimes see them referred to as <span class="italic">values</span>, which is not to be confused with scalar data values. The context should make the meaning clear.</p>
</li>
</ul>
<p><a href="#BGBDBIFJ">Example 11-1</a> and <a href="#BGBGEACI">Example 11-2</a> show SQL examples that demonstrate the difference between these two types of persistent objects.</p>
<div id="LNOCI18238" class="example">
<p class="titleinexample"><a id="BGBDBIFJ"></a>Example 11-1 SQL Definition of Standalone Objects</p>
<pre>
CREATE TYPE person_t AS OBJECT
   (name      varchar2(30),
    age       number(3));
CREATE TABLE person_tab OF person_t;
</pre></div>
<!-- class="example" -->
<p>Objects that are stored in the object table <code>person_tab</code> are standalone instances. They have object identifiers and are referenceable. They can be pinned in an OCI application.</p>
<div id="LNOCI18239" class="example">
<p class="titleinexample"><a id="BGBGEACI"></a>Example 11-2 SQL Definition of Embedded Objects</p>
<pre>
CREATE TABLE department
   (deptno     number,
    deptname   varchar2(30),
    manager    person_t);
</pre></div>
<!-- class="example" -->
<p>Objects that are stored in the <code>manager</code> column of the <code>department</code> table are embedded objects. They do not have object identifiers, and they are not referenceable; this means they cannot be pinned in an OCI application, and they also never need to be unpinned. They are always retrieved into the object cache <span class="italic">by value</span>.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16783" class="sect3"><a id="sthref1757"></a>
<h4 class="sect3">Transient Objects<a id="sthref1758"></a><a id="sthref1759"></a></h4>
<p>A transient object is a temporary instance whose life does not exceed that of the application, and that cannot be stored or flushed to the server. The application can delete a transient object at any time.</p>
<p>Transient objects are often created by the application using the <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> function to store temporary values for computation. Transient objects cannot be converted to persistent objects. Their role is fixed at the time they are instantiated.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i440918">"Creating Objects"</a> for more information about using <code>OCIObjectNew()</code></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16784" class="sect3"><a id="sthref1760"></a>
<h4 class="sect3">Values<a id="sthref1761"></a></h4>
<p>In the context of this manual, a <span class="italic">value</span> refers to either:</p>
<ul>
<li>
<p>A scalar value that is stored in a non-object column of a database table. An OCI application can fetch values from a database by issuing SQL statements.</p>
</li>
<li>
<p>An embedded or nonreferenceable object.</p>
</li>
</ul>
<p>The context should make it clear which meaning is intended.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is possible to select a referenceable object into the object cache, rather than pinning it, in which case you fetch the object <span class="italic">by value</span> instead of fetching its <code>REF</code>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i440360"></a>
<div id="LNOCI16785" class="sect1">
<h2 class="sect1">Developing an OCI Object Application</h2>
<p>This section discusses the steps involved in developing a basic OCI object application. Each step discussed in <a href="#i440303">"Basic Object Program Structure"</a> is described here in more detail.</p>
<p><a href="#BGBCJDIH">Figure 11-1</a> shows a simple program logic flow for how an application might work with objects. For simplicity, some required steps are omitted. Each step in this diagram is discussed in the following sections.</p>
<div id="LNOCI16786" class="figure">
<p class="titleinfigure"><a id="BGBCJDIH"></a>Figure 11-1 Basic Object Operational Flow</p>
<img width="229" height="285" src="img/lnoci035.gif" alt="Description of Figure 11-1 follows" /><br />
<a id="sthref1762" href="img_text/lnoci035.htm">Description of "Figure 11-1 Basic Object Operational Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="i440367"></a>
<div id="LNOCI16787" class="sect2">
<h3 class="sect2">Representing Objects in C Applications<a id="sthref1763"></a><a id="sthref1764"></a></h3>
<p>Before an OCI application can work with object types, those types must exist in the database. Typically, you create types with SQL DDL statements, such as <code>CREATE</code> <code>TYPE</code>.</p>
<p>When the Oracle database processes the type definition DDL commands, it stores the type definitions in the data dictionary as <span class="italic"><a id="sthref1765"></a>type descriptor objects</span> (TDOs).</p>
<p>When your application retrieves instances of object types from the database, it must have a client-side representation of the objects. In a C program, the representation of an object type is a struct. In an OCI object application, you may also include a <code>NULL</code> indicator structure corresponding to each object type structure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Application programmers who want to use object representations other than the default structs generated by the object cache should see <a href="oci14oca.htm#i450269">"Object Cache and Memory Management"</a>.</div>
<p>Oracle Database provides a utility called the Object Type Translator (OTT), which generates C struct representations of database object types for you. For example, suppose that you have a type in your database declared as follows:</p>
<pre>
CREATE TYPE emp_t AS OBJECT
( name       VARCHAR2(30),
  empno      NUMBER,
  deptno     NUMBER,
  hiredate   DATE,
  salary     NUMBER);
</pre>
<p><a id="sthref1766"></a><a id="sthref1767"></a>OTT produces the following C struct and corresponding <code>NULL</code> indicator struct:</p>
<pre>
struct emp_t
{
  OCIString    * name;
  OCINumber    empno;
  OCINumber    deptno;
  OCIDate      hiredate;
  OCINumber    salary;
};
typedef struct emp_t emp_t

struct emp_t_ind
{
  OCIInd     _atomic;
  OCIInd     name;
  OCIInd     empno;
  OCIInd     deptno;
  OCIInd     hiredate;
  OCIInd     salary;
};
typedef struct emp_t_ind emp_t_ind;
</pre>
<p>The variable types used in the struct declarations are special types employed by the OCI object calls. A subset of OCI functions manipulate data of these types. These functions are mentioned later in this chapter, and are discussed in more detail in <a href="oci12oty.htm#g453655">Chapter 12</a>.</p>
<p>These struct declarations are automatically written to a header file whose name is determined by the OTT input parameters. You can include this header file in the code files for an application to provide access to objects.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i440892">"NULL Indicator Structure"</a></p>
</li>
<li>
<p><a href="oci15ott.htm#g455369">Chapter 15</a> for more information about OTT</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i440421"></a>
<div id="LNOCI16788" class="sect2">
<h3 class="sect2">Initializing the Environment and the Object Cache<a id="sthref1768"></a><a id="sthref1769"></a><a id="sthref1770"></a><a id="sthref1771"></a><a id="sthref1772"></a></h3>
<p>If your OCI application is going to access and manipulate objects, it is essential that you specify a value of <code>OCI_OBJECT</code> for the <code>mode</code> parameter of the <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> call, which is the first OCI call in any OCI application. Specifying this value for <code>mode</code> indicates to the OCI libraries that your application is working with objects. This notification has the following important effects:</p>
<ul>
<li>
<p>It establishes the <span class="italic">object runtime environment</span>.</p>
</li>
<li>
<p>It sets up the <span class="italic">object cache</span>.</p>
</li>
</ul>
<p>Memory for the object cache is allocated on demand when objects are loaded into the cache.</p>
<p>If the <span class="italic">mode</span> parameter of <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> is not set to <code>OCI_OBJECT</code>, any attempt to use an object-related function results in an error.</p>
<p>The client-side object cache is allocated in the program's process space. This cache is the memory for objects that have been retrieved from the server and are available to your application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you initialize the OCI environment in object mode, your application allocates memory for the object cache, whether or not the application actually uses object calls.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci14oca.htm#g458990">Chapter 14</a> for a detailed explanation of the object cache</div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16789" class="sect2"><a id="sthref1773"></a>
<h3 class="sect2">Making Database Connections<a id="sthref1774"></a><a id="sthref1775"></a></h3>
<p>Once the OCI environment has been properly initialized, the application can connect to a server. This is accomplished through the standard OCI connect calls described in <a href="oci02bas.htm#i461853">"OCI Programming Steps"</a>. When you use these calls, no additional considerations must be made because this application is accessing objects.</p>
<p>Only one object cache is allocated for each OCI environment. All objects retrieved or created through different connections within the environment use the same physical object cache. Each connection has its own logical object cache.</p>
</div>
<!-- class="sect2" -->
<a id="i440442"></a>
<div id="LNOCI16790" class="sect2">
<h3 class="sect2">Retrieving an Object Reference from the Server <a id="sthref1776"></a></h3>
<p>To work with objects, your application must first retrieve one or more objects from the server. You accomplish this by issuing a SQL statement that returns <code>REF</code>s to one or more objects.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is also possible for a SQL statement to fetch embedded objects, rather than <code>REF</code>s, from a database. See <a href="#i440601">"Fetching Embedded Objects"</a> for more information.</div>
<p>In the following example, the application declares a text block that stores a SQL statement designed to retrieve a <code>REF</code> to a single employee object from an object table of employees (<code>emp_tab</code>) in the database, when given a particular employee number that is passed as an input variable (<code>:emp_num</code>) at runtime:</p>
<pre>
text *selemp = (text *) "SELECT REF(e)
                          FROM emp_tab e
                          WHERE empno = :emp_num";
</pre>
<p>Your application should prepare and process this statement as follows in the same way that it would handle any relational SQL statement, as described in <a href="oci02bas.htm#g478150">Chapter 2</a>:</p>
<ol>
<li>
<p>Prepare an application request, using <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a>.</p>
</li>
<li>
<p>Bind the host input variable using one or more appropriate bind calls.</p>
</li>
<li>
<p>Declare and prepare an output variable to receive the employee object reference. Here you would use an employee object reference, like the one declared in <a href="#i440367">"Representing Objects in C Applications"</a>:</p>
<pre>
OCIRef  *emp1_ref = (OCIRef *) 0; /* reference to an employee object */
</pre>
<p>When you define the output variable, set the <span class="italic">dty</span> data type parameter for the define call to SQLT_REF, the data type constant for <code>REF</code>.</p>
</li>
<li>
<p>Execute the statement with <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>.</p>
</li>
<li>
<p>Fetch the resulting <code>REF</code> into <code>emp1_ref</code>, using <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a>.</p>
</li>
</ol>
<p>At this point, you could use the object reference to access and manipulate an object or objects from the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci02bas.htm#i461853">"OCI Programming Steps"</a> for general information about preparing and executing SQL statements</p>
</li>
<li>
<p><a href="oci05bnd.htm#i421489">"Advanced Bind Operations in OCI"</a> and <a href="oci05bnd.htm#i421090">"Advanced Define Operations in OCI"</a> for specific information about binding and defining <code>REF</code> variables</p>
</li>
<li>
<p>The demonstration programs included with your Oracle installation for a code example showing <code>REF</code> retrieval and pinning. For additional information, see <a href="ociabdem.htm#g462659">Appendix B</a>.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i440479"></a>
<div id="LNOCI16791" class="sect2">
<h3 class="sect2">Pinning an Object<a id="sthref1777"></a></h3>
<p>Upon completion of the fetch step, your application has a <code>REF</code>, or pointer, to an object. The actual object is not currently available to work with. Before you can manipulate an object, it must be <span class="italic">pinned</span>. Pinning an object loads the object instance into the object cache, and enables you to access and modify the instance's attributes and follow references from that object to other objects, if necessary. Your application also controls when modified objects are written back to the server.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This section deals with a simple pin operation involving a single object at a time. For information about retrieving multiple objects through complex object retrieval, see <a href="#i440830">"Complex Object Retrieval"</a>.</div>
<p>An application pins an object by calling the function <a href="oci18nav005.htm#i433563">OCIObjectPin()</a>. The parameters for this function allow you to specify the <span class="italic">pin option, pin duration,</span> and <span class="italic">lock option</span> for the object.</p>
<p><a href="#BGBDEJIB">Example 11-3</a> shows sample code that illustrates a pin operation for the employee reference your application retrieved in the previous section, <a href="#i440442">"Retrieving an Object Reference from the Server"</a>.</p>
<div id="LNOCI18240" class="example">
<p class="titleinexample"><a id="BGBDEJIB"></a>Example 11-3 Pinning an Object</p>
<pre>
if (OCIObjectPin(env, err, emp1_ref, (OCIComplexObject *) 0, 
     OCI_PIN_ANY, 
     OCI_DURATION_TRANS, 
     OCI_LOCK_X,  &amp;emp1) != OCI_SUCCESS)
     process_error(err);
</pre></div>
<!-- class="example" -->
<p>In this example, <code>process_error()</code> represents an error-handling function. If the call to <code>OCIObjectPin()</code> returns anything but <code>OCI_SUCCESS</code>, the error-handling function is called. The parameters of the <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> function are as follows:</p>
<ul>
<li>
<p><code>env</code> is the OCI environment handle.</p>
</li>
<li>
<p><code>err</code> is the OCI error handle.</p>
</li>
<li>
<p><code>emp1_ref</code> is the reference that was retrieved through SQL.</p>
</li>
<li>
<p><code>(OCIComplexObject *) 0</code> indicates that this pin operation is not utilizing complex object retrieval.</p>
</li>
<li>
<p><code>OCI_PIN_ANY</code> is the pin option. See <a href="oci14oca.htm#i440293">"Pinning an Object Copy"</a> for more information.</p>
</li>
<li>
<p><code>OCI_DURATION_TRANS</code> is the pin duration. See <a href="oci14oca.htm#i437805">"Object Duration"</a> for more information.</p>
</li>
<li>
<p><code>OCI_LOCK_X</code> is the lock option. See <a href="oci14oca.htm#i440635">"Locking Objects for Update"</a> for more information.</p>
</li>
<li>
<p><code>emp1</code> is an out parameter that returns a pointer to the pinned object.</p>
</li>
</ul>
<p>Now that the object has been pinned, the OCI application can modify that object. In this simple example, the object contains no references to other objects.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci14oca.htm#i442207">"Simple Object Navigation"</a> for an example of navigation from one instance to another</div>
<div id="LNOCI16792" class="sect3"><a id="sthref1778"></a>
<h4 class="sect3">Array Pin<a id="sthref1779"></a></h4>
<p>Given an array of references, an OCI application can pin an array of objects by calling <a href="oci18nav005.htm#i427422">OCIObjectArrayPin()</a>. The references may point to objects of different types. This function provides the ability to fetch objects of different types from different tables in one network round-trip.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i440522"></a>
<div id="LNOCI16793" class="sect2">
<h3 class="sect2">Manipulating Object Attributes<a id="sthref1780"></a></h3>
<p>Once an object has been pinned, an OCI application can modify its attributes. OCI provides a set of functions for working with data types of object type structs, known as the OCI <span class="italic">data type mapping and manipulation functions</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Changes made to objects pinned in the object cache affect only those object copies (instances), and <span class="italic">not</span> the original object in the database. For changes made by the application to reach the database, those changes must be flushed or committed to the server. See <a href="#i440564">"Marking Objects and Flushing Changes"</a> for more information.</div>
<p>For example, assume that the employee object in the previous section was pinned so that the employee's salary could be increased. Assume also that at this company, yearly salary increases are prorated for employees who have been at the company for less than 180 days.</p>
<p>For this example, you must access the employee's hire date and check whether it is more or less than 180 days before the current date. Based on that calculation, the employee's salary is increased by either $5000 (for more than 180 days) or $3000 (for less than 180 days). The sample code in <a href="#BGBBCFBA">Example 11-4</a> demonstrates this process.</p>
<p>Note that the data type mapping and manipulation functions work with a specific set of data types; you must convert other types, like <code>int</code>, to the appropriate OCI types before using them in calculations.</p>
<div id="LNOCI18241" class="example">
<p class="titleinexample"><a id="BGBBCFBA"></a>Example 11-4 Manipulating Object Attributes in OCI</p>
<pre>
/* assume that sysdate has been fetched into sys_date, a string. */
/* emp1 and emp1_ref are the same as in previous sections. */
/* err is the OCI error handle. */
/* NOTE: error handling code is not included in this example. */

sb4 num_days;        /* the number of days between today and hiredate */
OCIDate curr_date;          /* holds the current date for calculations */
int raise;   /* holds the employee's raise amount before calculations */
OCINumber raise_num;       /* holds employee's raise for calculations */
OCINumber new_sal;                 /* holds the employee's new salary */

/* convert date string to an OCIDate */
OCIDateFromText(err, (text *) sys_date, (ub4) strlen(sys_date), (text *) 
          NULL, (ub1) 0, (text *) NULL, (ub4) 0, &amp;curr_date);

  /* get number of days between hire date and today */
OCIDateDaysBetween(err, &amp;curr_date, &amp;emp1-&gt;hiredate, &amp;num_days);

/* calculate raise based on number of days since hiredate */
if (num_days &gt; 180)
    raise = 5000;
else
    raise = 3000;

/* convert raise value to an OCINumber */
OCINumberFromInt(err, (void  *)&amp;raise, (uword)sizeof(raise),      
                 OCI_NUMBER_SIGNED, &amp;raise_num);

/* add raise amount to salary */
OCINumberAdd(err, &amp;raise_num, &amp;emp1-&gt;salary, &amp;new_sal);
OCINumberAssign(err, &amp;new_sal, &amp;emp1-&gt;salary);
</pre></div>
<!-- class="example" -->
<p><a href="#BGBBCFBA">Example 11-4</a> points out how values must be converted to OCI data types (for example, <code>OCIDate</code>, <code>OCINumber</code>) before being passed as parameters to the OCI data type mapping and manipulation functions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci12oty.htm#g453655">Chapter 12</a> for more information about the OCI data types and the data type mapping and manipulation functions</div>
</div>
<!-- class="sect2" -->
<a id="i440564"></a>
<div id="LNOCI16794" class="sect2">
<h3 class="sect2">Marking Objects and Flushing Changes<a id="sthref1781"></a><a id="sthref1782"></a><a id="sthref1783"></a></h3>
<p>In <a href="#BGBBCFBA">Example 11-4</a>, an attribute of an object instance was changed. At this point, however, that change exists only in the client-side object cache. The application must take specific steps to ensure that the change is written in the database.</p>
<p>The first step is to indicate that the object has been modified. This is done with the <a href="oci18nav002.htm#i470154">OCIObjectMarkUpdate()</a> function. This function marks the object as <span class="italic">dirty</span> (modified).</p>
<p>Objects that have had their dirty flag set must be flushed to the server for the changes to be recorded in the database. You can do this in three ways:</p>
<ul>
<li>
<p>Flush a single dirty object by calling <a href="oci18nav001.htm#i469090">OCIObjectFlush()</a>.</p>
</li>
<li>
<p>Flush the entire cache using <a href="oci18nav001.htm#i427410">OCICacheFlush()</a>. In this case OCI traverses the dirty list maintained by the cache and flushes the dirty objects to the server.</p>
</li>
<li>
<p>Call <a href="oci17msc006.htm#i428845">OCITransCommit()</a> to commit a transaction. Doing so also traverses the dirty list and flushes the dirty objects to the server.</p>
</li>
</ul>
<p>The flush operations work only on persistent objects in the cache. Transient objects are never flushed to the server.</p>
<p>Flushing an object to the server can activate triggers in the database. In fact, on some occasions an application may want to explicitly flush objects just to fire triggers on the server side.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci08sca.htm#i421830">"OCI Support for Transactions"</a> for more information about <code>OCITransCommit()</code></p>
</li>
<li>
<p><a href="#i440918">"Creating Objects"</a> for information about transient and persistent objects</p>
</li>
<li>
<p><a href="#i440653">"Object Meta-Attributes"</a> for information about seeing and checking object meta-attributes, such as <span class="italic">dirty</span></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i440601"></a>
<div id="LNOCI16795" class="sect2">
<h3 class="sect2">Fetching Embedded Objects<a id="sthref1784"></a></h3>
<p>If your application must fetch an embedded object instance&mdash;an object stored in a column of a regular table, rather than an object table&mdash;you cannot use the <code>REF</code> retrieval mechanism described in <a href="#i440442">"Retrieving an Object Reference from the Server"</a>. Embedded instances do not have object identifiers, so it is not possible to get a <code>REF</code> to them; they cannot serve as the basis for object navigation. Many situations exist, however, in which an application must fetch embedded instances.</p>
<p>For example, assume that an <code>address</code> type has been created.</p>
<pre>
CREATE TYPE address AS OBJECT
( street1             varchar2(50),
  street2             varchar2(50),
  city                varchar2(30),
  state               char(2),
  zip                 number(5));
</pre>
<p>You could then use that type as the data type of a column in another table:</p>
<pre>
CREATE TABLE clients
( name          varchar2(40),
  addr          address);
</pre>
<p>Your OCI application could then issue the following SQL statement:</p>
<pre>
SELECT addr FROM clients
WHERE name='BEAR BYTE DATA MANAGEMENT'
</pre>
<p>This statement would return an embedded <code>address</code> object from the <code>clients</code> table. The application could then use the values in the attributes of this object for other processing.</p>
<p>Your application should prepare and process this statement in the same way that it would handle any relational SQL statement, as described in <a href="oci02bas.htm#g478150">Chapter 2</a>:</p>
<ul>
<li>
<p>Prepare an application request, using <a href="oci17msc001.htm#i575217">OCIStmtPrepare2()</a>.</p>
</li>
<li>
<p>Bind the input variable using one or more appropriate bind calls.</p>
</li>
<li>
<p>Define an output variable to receive the <code>address</code> instance. You use a C struct representation of the object type that was generated by OTT, as described in <a href="#i440367">"Representing Objects in C Applications"</a>.</p>
<pre>
addr1      *address; /* variable of the address struct type */
</pre>
<p>When you define the output variable, set the <code>dty</code> data type parameter for the define call to SQLT_NTY, the data type constant for named data types.</p>
</li>
<li>
<p>Execute the statement with <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>.</p>
</li>
<li>
<p>Fetch the resulting instance into <code>addr1</code>, using <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a>.</p>
</li>
</ul>
<p>Following this operation, you can access the attributes of the instance, as described in <a href="#i440522">"Manipulating Object Attributes"</a>, or pass the instance as an input parameter for another SQL statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Changes made to an embedded instance can be made persistent only by executing a SQL <code>UPDATE</code> statement.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#i461853">"OCI Programming Steps"</a> for more information about preparing and executing SQL statements</div>
</div>
<!-- class="sect2" -->
<a id="i440653"></a>
<div id="LNOCI16796" class="sect2">
<h3 class="sect2">Object Meta-Attributes<a id="sthref1785"></a><a id="sthref1786"></a><a id="sthref1787"></a><a id="sthref1788"></a></h3>
<p>An object's <span class="italic">meta-attributes</span> serve as flags that can provide information to an application, or to the object cache, about the status of an object. For example, one of the meta-attributes of an object indicates whether it has been flushed to the server. Object meta-attributes can help an application control the behavior of instances.</p>
<p>Persistent and transient object instances have different sets of meta-attributes. The meta-attributes for persistent objects are further subdivided into <span class="italic">persistent meta-attributes</span> and <span class="italic">transient meta-attributes</span>. Transient meta-attributes exist only when an instance is in memory. Persistent meta-attributes also apply to objects stored in the server.</p>
<div id="LNOCI16797" class="sect3"><a id="sthref1789"></a>
<h4 class="sect3">Persistent Object Meta-Attributes<a id="sthref1790"></a><a id="sthref1791"></a></h4>
<p><a href="#BGBHDIIB">Table 11-1</a> shows the meta-attributes for <span class="italic">standalone</span> persistent objects.</p>
<div id="LNOCI16798" class="tblformal">
<p class="titleintable"><a id="sthref1792"></a><a id="BGBHDIIB"></a>Table 11-1 Meta-Attributes of Persistent Objects</p>
<table class="cellalignment1016" title="Meta-Attributes of Persistent Objects" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t23">Meta-Attributes</th>
<th class="cellalignment1012" id="r1c2-t23">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t23" headers="r1c1-t23">
<p>existent</p>
</td>
<td class="cellalignment1013" headers="r2c1-t23 r1c2-t23">
<p>Does the object exist?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t23" headers="r1c1-t23">
<p>nullity</p>
</td>
<td class="cellalignment1013" headers="r3c1-t23 r1c2-t23">
<p>Null information of the instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t23" headers="r1c1-t23">
<p>locked</p>
</td>
<td class="cellalignment1013" headers="r4c1-t23 r1c2-t23">
<p>Has the object been locked?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t23" headers="r1c1-t23">
<p>dirty</p>
</td>
<td class="cellalignment1013" headers="r5c1-t23 r1c2-t23">
<p>Has the object been marked as <span class="italic">dirtied?</span></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t23" headers="r1c1-t23">
<p>pinned</p>
</td>
<td class="cellalignment1013" headers="r6c1-t23 r1c2-t23">
<p>Is the object pinned?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t23" headers="r1c1-t23">
<p>allocation duration</p>
</td>
<td class="cellalignment1013" headers="r7c1-t23 r1c2-t23">
<p>See <a href="oci14oca.htm#i437805">"Object Duration"</a>.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t23" headers="r1c1-t23">
<p>pin duration</p>
</td>
<td class="cellalignment1013" headers="r8c1-t23 r1c2-t23">
<p>See <a href="oci14oca.htm#i437805">"Object Duration"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Embedded persistent objects only have the <span class="italic">nullity</span> and <span class="italic">allocation duration</span> attributes, which are transient.</div>
<p>OCI provides the <a href="oci18nav003.htm#i469364">OCIObjectGetProperty()</a> function, which allows an application to check the status of a variety of attributes of an object. The syntax of the function is:</p>
<pre>
sword OCIObjectGetProperty ( OCIEnv              *envh, 
                             OCIError            *errh, 
                             const void          *obj, 
                             OCIObjectPropId     propertyId,
                             void                *property, 
                             ub4                 *size );
</pre>
<p>The <code>propertyId</code> and <code>property</code> parameters are used to retrieve information about any of a variety of properties or attributes.</p>
<p>The different property IDs and the corresponding type of <code>property</code> argument follow.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci18nav003.htm#i469364">"OCIObjectGetProperty()"</a></div>
<dl>
<dt>OCI_OBJECTPROP_LIFETIME</dt>
<dd>
<p>This identifies whether the given object is a persistent object or a transient object or a value instance. The <code>property</code> argument must be a pointer to a variable of type <code>OCIObjectLifetime</code>. Possible values include:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_OBJECT_PERSISTENT</code></p>
</li>
<li>
<p><code>OCI_OBJECT_TRANSIENT</code></p>
</li>
<li>
<p><code>OCI_OBJECT_VALUE</code></p>
</li>
</ul>
<dl>
<dt>OCI_OBJECTPROP_SCHEMA</dt>
<dd>
<p>This returns the schema name of the table in which the object exists. An error is returned if the given object points to a transient instance or a value. If the input buffer is not big enough to hold the schema name, an error is returned; the error message communicates the required size. Upon success, the size of the returned schema name in bytes is returned by <code>size</code>. The <code>property</code> argument must be an array of type <code>text</code>, and <code>size</code> should be set to the size of the array in bytes by the caller.</p>
</dd>
<dt>OCI_OBJECTPROP_TABLE</dt>
<dd>
<p>This returns the table name in which the object exists. An error is returned if the given object points to a transient instance or a value. If the input buffer is not big enough to hold the table name, an error is returned; the error message communicates the required size. Upon success, the size of the returned table name in bytes is returned by <code>size</code>. The <code>property</code> argument must be an array of type <code>text</code> and <code>size</code> should be set to the size of the array in bytes by the caller.</p>
</dd>
<dt>OCI_OBJECTPROP_PIN_DURATION</dt>
<dd>
<p>This returns the pin duration of the object. An error is returned if the given object points to a value instance. The <code>property</code> argument must be a pointer to a variable of type <code>OCIDuration</code>. Valid values include:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_DURATION_SESSION</code></p>
</li>
<li>
<p><code>OCI_DURATION_TRANS</code></p>
</li>
</ul>
<dl>
<dt>OCI_OBJECTPROP_ALLOC_DURATION</dt>
<dd>
<p>This returns the allocation duration of the object. The <code>property</code> argument must be a pointer to a variable of type <code>OCIDuration</code>. Valid values include:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_DURATION_SESSION</code></p>
</li>
<li>
<p><code>OCI_DURATION_TRANS</code></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci14oca.htm#i437805">"Object Duration"</a> for more information about durations</div>
</li>
</ul>
<dl>
<dt>OCI_OBJECTPROP_LOCK</dt>
<dd>
<p>This returns the lock status of the object. The possible lock status is indicated by <code>OCILockOpt</code>. An error is returned if the given object points to a transient or value instance. The <code>property</code> argument must be a pointer to a variable of type <code>OCILockOpt</code>. The lock status of an object can also be retrieved by calling <a href="oci18nav003.htm#i469520">OCIObjectIsLocked()</a>.</p>
</dd>
<dt>OCI_OBJECTPROP_MARKSTATUS</dt>
<dd>
<p>This returns the dirty status and indicates whether the object is a new object, updated object, or deleted object. An error is returned if the given object points to a transient or value instance. The <code>property</code> argument must be of type <code>OCIObjectMarkStatus</code>. Valid values include:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_OBJECT_NEW</code></p>
</li>
<li>
<p><code>OCI_OBJECT_DELETED</code></p>
</li>
<li>
<p><code>OCI_OBJECT_UPDATED</code></p>
</li>
</ul>
<p>The following macros are available to test the object mark status:</p>
<ul>
<li>
<p><code>OCI_OBJECT_IS_UPDATED</code> (flag)</p>
</li>
<li>
<p><code>OCI_OBJECT_IS_DELETED</code> (flag)</p>
</li>
<li>
<p><code>OCI_OBJECT_IS_NEW</code> (flag)</p>
</li>
<li>
<p><code>OCI_OBJECT_IS_DIRTY</code> (flag)</p>
</li>
</ul>
<dl>
<dt>OCI_OBJECTPROP_VIEW</dt>
<dd>
<p>This identifies whether the specified object is an object view or not. If the property value returned is <code>TRUE</code>, the object is a view; otherwise, it is not. An error is returned if the given object points to a transient or value instance. The <code>property</code> argument must be of type <code>boolean</code>.</p>
<p><a id="sthref1793"></a>Just as a view is a virtual table, an object view is a virtual object table. Each row in the view is an object: you can call its methods, access its attributes using the dot notation, and create a <code>REF</code> that points to it.</p>
</dd>
</dl>
</div>
<!-- class="sect3" -->
<div id="LNOCI16799" class="sect3"><a id="sthref1794"></a>
<h4 class="sect3">Additional Attribute Functions</h4>
<p>OCI also provides functions that allow an application to set or check some of these attributes directly or indirectly, as shown in <a href="#BGBDCDFB">Table 11-2</a>.</p>
<div id="LNOCI16800" class="tblformal">
<p class="titleintable"><a id="sthref1795"></a><a id="BGBDCDFB"></a>Table 11-2 Set and Check Functions</p>
<table class="cellalignment1016" title="Set and Check Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t27">Meta-Attribute</th>
<th class="cellalignment1012" id="r1c2-t27">Set with</th>
<th class="cellalignment1012" id="r1c3-t27">Check with</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t27" headers="r1c1-t27">
<p>nullity</p>
</td>
<td class="cellalignment1013" headers="r2c1-t27 r1c2-t27">
<p>&lt;none&gt;</p>
</td>
<td class="cellalignment1013" headers="r2c1-t27 r1c3-t27">
<p><code><a href="oci18nav004.htm#i469963">OCIObjectGetInd()</a></code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t27" headers="r1c1-t27">
<p>existence</p>
</td>
<td class="cellalignment1013" headers="r3c1-t27 r1c2-t27">
<p>&lt;none&gt;</p>
</td>
<td class="cellalignment1013" headers="r3c1-t27 r1c3-t27">
<p><code><a href="oci18nav003.htm#i469319">OCIObjectExists()</a></code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t27" headers="r1c1-t27">
<p>locked</p>
</td>
<td class="cellalignment1013" headers="r4c1-t27 r1c2-t27">
<p><code><a href="oci18nav004.htm#i469657">OCIObjectLock()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t27 r1c3-t27">
<p><code><a href="oci18nav003.htm#i469520">OCIObjectIsLocked()</a></code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t27" headers="r1c1-t27">
<p>dirty</p>
</td>
<td class="cellalignment1013" headers="r5c1-t27 r1c2-t27">
<p><code><a href="oci18nav002.htm#i470154">OCIObjectMarkUpdate()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t27 r1c3-t27">
<p><code><a href="oci18nav003.htm#i473099">OCIObjectIsDirty()</a></code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<div id="LNOCI16801" class="sect3"><a id="sthref1796"></a>
<h4 class="sect3">Transient Object Meta-Attributes<a id="sthref1797"></a><a id="sthref1798"></a></h4>
<p>Transient objects have no persistent attributes. <a href="#BGBHIGGG">Table 11-3</a> shows the following transient attributes.</p>
<div id="LNOCI16802" class="tblformal">
<p class="titleintable"><a id="sthref1799"></a><a id="BGBHIGGG"></a>Table 11-3 Transient Meta-Attributes</p>
<table class="cellalignment1016" title="Transient Meta-Attributes " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t28">Transient Meta-Attributes</th>
<th class="cellalignment1012" id="r1c2-t28">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t28" headers="r1c1-t28">
<p>existent</p>
</td>
<td class="cellalignment1013" headers="r2c1-t28 r1c2-t28">
<p>Does the object exist?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t28" headers="r1c1-t28">
<p>pinned</p>
</td>
<td class="cellalignment1013" headers="r3c1-t28 r1c2-t28">
<p>Is the object being accessed by the application?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t28" headers="r1c1-t28">
<p>dirty</p>
</td>
<td class="cellalignment1013" headers="r4c1-t28 r1c2-t28">
<p>Has the object been marked as <span class="italic">dirtied</span>?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t28" headers="r1c1-t28">
<p>nullity</p>
</td>
<td class="cellalignment1013" headers="r5c1-t28 r1c2-t28">
<p>Null information of the instance.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t28" headers="r1c1-t28">
<p>allocation duration</p>
</td>
<td class="cellalignment1013" headers="r6c1-t28 r1c2-t28">
<p>See <a href="oci14oca.htm#i437805">"Object Duration"</a>.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t28" headers="r1c1-t28">
<p>pin duration</p>
</td>
<td class="cellalignment1013" headers="r7c1-t28 r1c2-t28">
<p>See <a href="oci14oca.htm#i437805">"Object Duration"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i440830"></a>
<div id="LNOCI16803" class="sect2">
<h3 class="sect2">Complex Object Retrieval<a id="sthref1800"></a></h3>
<p>In <a href="#BGBDEJIB">Example 11-3</a> and <a href="#BGBBCFBA">Example 11-4</a>, only a single instance at a time was fetched or pinned. In these cases, each pin operation involved a separate server round-trip to retrieve the object.</p>
<p>Object-oriented applications often model their problems as a set of interrelated objects that form graphs of objects. The applications process these objects by starting at some initial set of objects, and then using the references in these initial objects to traverse the remaining objects. In a client/server setting, each of these traversals could result in costly network round-trips to fetch objects.</p>
<p>Application performance with objects can be improved with <span class="italic">complex object retrieval (COR)</span>. This is a prefetching mechanism in which an application specifies the criteria for retrieving a set of linked objects in a single operation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As described later, this does not mean that these prefetched objects are all pinned. They are fetched into the object cache, so that subsequent pin calls are local operations.</div>
<p>A <span class="italic">complex object</span> is a set of logically related objects consisting of a root object, and a set of objects each of which is prefetched based on a given depth level. The <span class="italic">root object</span> is explicitly fetched or pinned. The <span class="italic">depth level</span> is the shortest number of references that must be traversed from the root object to a given prefetched object in a complex object.</p>
<p>An application specifies a complex object by describing its content and boundary. The fetching of complex objects is constrained by an environment's <span class="italic">prefetch limit</span>, the amount of memory in the object cache that is available for prefetching objects.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The use of COR does not add functionality, but it improves performance. Its use is optional.</div>
<p>Consider the following type declaration:</p>
<pre>
CREATE TYPE customer(...);
CREATE TYPE line_item(...);
CREATE TYPE line_item_varray as VARRAY(100) of REF line_item;
CREATE TYPE purchase_order AS OBJECT
( po_number         NUMBER,
  cust              REF customer,
  related_orders    REF purchase_order,
  line_items        line_item_varray);
</pre>
<p>The <code>purchase_order</code> type contains a scalar value for <code>po_number</code>, a <code>VARRAY</code> of line items, and two references. The first is to a <code>customer</code> type, and the second is to a <code>purchase_order</code> type, indicating that this type may be implemented as a linked list.</p>
<p>When fetching a complex object, an application must specify the following:</p>
<ul>
<li>
<p>A <code>REF</code> to the desired root object.</p>
</li>
<li>
<p>One or more pairs of type and depth information to specify the boundaries of the complex object. The type information indicates which <code>REF</code> attributes should be followed for COR, and the depth level indicates how many levels deep those links should be followed.</p>
</li>
</ul>
<p>In the preceding purchase order object, the application must specify the following:</p>
<ul>
<li>
<p>The <code>REF</code> to the root purchase order object</p>
</li>
<li>
<p>One or more pairs of type and depth information for <code>cust</code>, <code>related_orders</code>, or <code>line_items</code></p>
</li>
</ul>
<p>An application fetching a purchase order may very likely need access to the customer information for that order. Using simple navigation, this would require two server accesses to retrieve the two objects. Through complex object retrieval, the customer can be prefetched when the application pins the purchase order. In this case, the complex object would consist of the purchase order object and the customer object that it references.</p>
<p>In the previous example, the application would specify the <code>purchase_order</code> <code>REF</code>, and would indicate that the <code>cust</code> <code>REF</code> attribute should be followed to a depth level of 1, as follows:</p>
<ul>
<li>
<p><code>REF(PO object)</code></p>
</li>
<li>
<p>{<code>(customer, 1</code>)}</p>
</li>
</ul>
<p>For the application to prefetch the <code>purchase_order</code> object and all objects in the object graph it contains, the application would specify that both the <code>cust</code> and <code>related_orders</code> should be followed to the maximum depth level possible.</p>
<ul>
<li>
<p><code>REF(PO object)</code></p>
</li>
<li>
<p>{<code>(customer, UB4MAXVAL), (purchase_order, UB4MAXVAL)</code>}</p>
</li>
</ul>
<p>(In this example, <code>UB4MAXVAL</code> specifies that all objects of the specified type reachable through references from the root object should be prefetched.)</p>
<p>For an application to fetch a PO and all the associated line items, it would specify:</p>
<ul>
<li>
<p><code>REF(PO object)</code></p>
</li>
<li>
<p>{<code>(line_item, 1)</code>}</p>
</li>
</ul>
<p>The application can also fetch all objects reachable from the root object by way of <code>REF</code>s (transitive closure) by setting the level parameter to the depth desired. For the preceding two examples, the application could also specify <code>(PO object REF, UB4MAXVAL)</code> and <code>(PO object REF, 1)</code> respectively, to prefetch required objects. Although, doing so results in many extraneous fetches, quite simple to specify and requires only one server round-trip.</p>
<div id="LNOCI16804" class="sect3"><a id="sthref1801"></a>
<h4 class="sect3">Prefetching Objects</h4>
<p>After specifying and fetching a complex object, subsequent fetches of objects contained in the complex object do not incur the cost of a network round-trip, because these objects have been prefetched and are in the object cache. Consider that excessive prefetching of objects can lead to a flooding of the object cache. This flooding, in turn, may force out other objects that the application had pinned, leading to a performance degradation instead of performance improvement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If there is insufficient memory in the cache to hold all prefetched objects, some objects may not be prefetched. The application incurs a network round-trip when those objects are accessed later.</div>
<p>The <code>SELECT</code> privilege is needed for all prefetched objects. Objects in the complex object for which the application does not have <code>SELECT</code> privilege are not prefetched.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16805" class="sect3"><a id="sthref1802"></a>
<h4 class="sect3">Implementing Complex Object Retrieval in OCI<a id="sthref1803"></a></h4>
<p>Complex object retrieval (COR) allows an application to prefetch a complex object while fetching the root object. The complex object specifications are passed to the same <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> function used for simple objects.</p>
<p>An application specifies the parameters for complex object retrieval using a <span class="italic">complex object retrieval handle</span>. This handle is of type <code>OCIComplexObject</code> and is allocated in the same way as other OCI handles.<a id="sthref1804"></a></p>
<p>The complex object retrieval handle contains a list of <span class="italic">complex object retrieval descriptors</span>. The descriptors are of type <code>OCIComplexObjectComp</code>, and are allocated in the same way as other OCI descriptors.<a id="sthref1805"></a></p>
<p>Each COR descriptor contains a type <code>REF</code> and a depth level. The type <code>REF</code> specifies a type of reference to be followed while constructing the complex object. The depth level indicates how far a particular type of reference should be followed. Specify an integer value, or specify the constant <code>UB4MAXVAL</code> for the maximum possible depth level.</p>
<p>The application can also specify the depth level in the COR handle without creating COR descriptors for type and depth parameters. In this case, all <code>REF</code>s are followed to the depth specified in the COR handle. The COR handle can also be used to specify whether a collection attribute should be fetched separately on demand (out-of-line) as opposed to the default case of fetching it along with the containing object (inline).</p>
<p>The application uses <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to set the attributes of a COR handle. The attributes are:</p>
<p><code>OCI_ATTR_COMPLEXOBJECT_LEVEL</code> - the depth level</p>
<p><code>OCI_ATTR_COMPLEXOBJECT_COLL_OUTOFLINE</code> - fetch collection attribute in an object type out-of-line</p>
<p>The application allocates the COR descriptor using <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a> and then can set the following attributes:</p>
<p><code>OCI_ATTR_COMPLEXOBJECTCOMP_TYPE</code> - the type <code>REF</code></p>
<p><code>OCI_ATTR_COMPLEXOBJECTCOMP_TYPE_LEVEL</code> - the depth level for references of the preceding type</p>
<p>Once these attributes are set, the application calls <a href="oci16rel002.htm#i541003">OCIParamSet()</a> to put the descriptor into a complex object retrieval handle. The handle has an <code>OCI_ATTR_PARAM_COUNT</code> attribute that specifies the number of descriptors on the handle. This attribute can be read with <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a>.</p>
<p>Once the handle has been populated, it can be passed to the <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> call to pin the root object and prefetch the remainder of the complex object.</p>
<p>The complex object retrieval handles and descriptors must be freed explicitly when they are no longer needed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci02bas.htm#i461125">"Handles"</a></p>
</li>
<li>
<p><a href="oci02bas.htm#i463442">"OCI Descriptors"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16806" class="sect2"><a id="sthref1806"></a>
<h3 class="sect2">COR Prefetching<a id="sthref1807"></a></h3>
<p>The application specifies a complex object while fetching the root object. The prefetched objects are obtained by doing a breadth-first traversal of the graphs of objects rooted at a given root object. The traversal stops when all required objects have been prefetched, or when the total size of all the prefetched objects exceeds the <span class="italic">prefetch limit</span>.</p>
<div id="LNOCI16807" class="sect3"><a id="sthref1808"></a>
<h4 class="sect3">COR Interface</h4>
<p>The interface for fetching complex objects is the OCI pin interface. The application can pass an initialized COR handle to <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> (or an array of handles to <a href="oci18nav005.htm#i427422">OCIObjectArrayPin()</a>) to fetch the root object and the prefetched objects specified in the COR handle.</p>
<pre>
sword OCIObjectPin ( OCIEnv              *env, 
                     OCIError            *err, 
                     OCIRef              *object_ref,
                     OCIComplexObject    *corhdl,
                     OCIPinOpt           pin_option, 
                     OCIDuration         pin_duration, 
                     OCILockOpt          lock_option,
                     void                **object );

sword OCIObjectArrayPin ( OCIEnv            *env, 
                          OCIError          *err, 
                          OCIRef            **ref_array, 
                          ub4               array_size,
                          OCIComplexObject  **cor_array,
                          ub4               cor_array_size, 
                          OCIPinOpt         pin_option, 
                          OCIDuration       pin_duration,
                          OCILockOpt        lock, 
                          void              **obj_array,
                          ub4               *pos );
</pre>
<p>Note the following points when using COR:</p>
<ul>
<li>
<p>A null COR handle argument defaults to pinning just the root object.</p>
</li>
<li>
<p>A COR handle with the type of the root object and a depth level of 0 fetches only the root object and is thus equivalent to a null COR handle.</p>
</li>
<li>
<p>The lock options apply only to the root object.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To specify lock options for prefetched objects, the application can visit all the objects in a complex object, create an array of <code>REF</code>s, and lock the entire complex object in another round-trip using the array interface (<a href="oci18nav005.htm#i427422">OCIObjectArrayPin()</a>).</div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16808" class="sect3"><a id="sthref1809"></a>
<h4 class="sect3">Example of COR</h4>
<p><a href="#BGBGCEHH">Example 11-5</a> illustrates how an application program can be modified to use complex object retrieval.</p>
<p>Consider an application that displays a purchase order and the line items associated with it. The code in boldface accomplishes this. The rest of the code uses complex object retrieval for prefetching and thus enhances the application's performance.</p>
<div id="LNOCI18242" class="example">
<p class="titleinexample"><a id="BGBGCEHH"></a>Example 11-5 Using Complex Object Retrieval in OCI</p>
<pre>
<span class="bold">OCIEnv *envhp;</span>
<span class="bold">OCIError *errhp;</span>
<span class="bold">OCIRef **liref;</span>
<span class="bold">OCIRef *poref;</span>
<span class="bold">OCIIter *itr;</span>
<span class="bold">boolean  eoc;</span>
<span class="bold">purchase_order *po = (purchase_order *)0;</span>
<span class="bold">line_item *li = (line_item *)0;</span>
<span class="bold">OCISvcCtx *svchp;</span>
<span class="bold">OCIComplexObject *corhp;</span>
<span class="bold">OCIComplexObjectComp *cordp;</span>
<span class="bold">OCIType *litdo;</span>
<span class="bold">ub4 level = 0;</span>

/* get COR Handle */
OCIHandleAlloc((void  *) envhp, (void  **) &amp;corhp, (ub4)
                OCI_HTYPE_COMPLEXOBJECT, 0, (void  **)0);

/* get COR descriptor for type line_item */
OCIDescriptorAlloc((void  *) envhp, (void  **) &amp;cordp, (ub4)
                OCI_DTYPE_COMPLEXOBJECTCOMP, 0, (void  **) 0);

/* get type of line_item to set in COR descriptor */
OCITypeByName(envhp, errhp, svchp, (const text *) 0, (ub4) 0,
              (const text *) "LINE_ITEM",
              (ub4) strlen((const char *) "LINE_ITEM"), (text *) 0,
              (ub4) 0, OCI_DURATION_SESSION,
              OCI_TYPEGET_HEADER, &amp;litdo);

/* set line_item type in COR descriptor */
OCIAttrSet( (void  *) cordp, (ub4) OCI_DTYPE_COMPLEXOBJECTCOMP,
            (void  *) litdo, (ub4) sizeof(void  *), (ub4)
            OCI_ATTR_COMPLEXOBJECTCOMP_TYPE, (OCIError *) errhp);
level = 1;

/* set depth level for line_item_varray in COR descriptor */
OCIAttrSet( (void  *) cordp, (ub4) OCI_DTYPE_COMPLEXOBJECTCOMP,
            (void  *) &amp;level, (ub4) sizeof(ub4), (ub4)
            OCI_ATTR_COMPLEXOBJECTCOMP_TYPE_LEVEL, (OCIError *) errhp);

/* put COR descriptor in COR handle */
OCIParamSet(corhp, OCI_HTYPE_COMPLEXOBJECT, errhp, cordp,
            OCI_DTYPE_COMPLEXOBJECTCOMP, 1);

<span class="bold">/* pin the purchase order */</span>
<span class="bold">OCIObjectPin(envhp, errhp, poref, corhp, OCI_PIN_LATEST,</span>
<span class="bold">   OCI_DURATION_SESSION, OCI_LOCK_NONE, (void  **)&amp;po);</span>

/* free COR descriptor and COR handle */
OCIDescriptorFree((void  *) cordp, (ub4) OCI_DTYPE_COMPLEXOBJECTCOMP);
OCIHandleFree((void  *) corhp, (ub4) OCI_HTYPE_COMPLEXOBJECT);

<span class="bold">/* iterate and print line items for this purchase order */</span>
<span class="bold">OCIIterCreate(envhp, errhp, po-&gt;line_items, &amp;itr);</span>

<span class="bold">/* get first line item */</span>
<span class="bold">OCIIterNext(envhp, errhp, itr, (void  **)&amp;liref, (void  **)0, &amp;eoc);</span>
<span class="bold">while (!eoc)        /* not end of collection */</span>
<span class="bold">{</span>
/* pin line item */
   OCIObjectPin(envhp, errhp, *liref, (void  *)0, OCI_PIN_RECENT,
       OCI_DURATION_SESSION,
       OCI_LOCK_NONE, (void  **)&amp;li));
<span class="bold">  display_line_item(li);</span>

<span class="bold">/* get next line item */</span>
<span class="bold">OCIIterNext(envhp, errhp, itr, (void  **)&amp;liref, (void  **)0, &amp;eoc);</span>
<span class="bold">}</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16809" class="sect2"><a id="sthref1810"></a>
<h3 class="sect2">OCI Versus SQL Access to Objects</h3>
<p>If an application must manipulate a graph of objects (interrelated by object references), then it is more effective to use the OCI interface rather than the SQL interface for accessing objects. Retrieving a graph of objects using the SQL interface may require executing multiple <code>SELECT</code> statements, requiring multiple network round-trips. Using the complex object retrieval capability provided by OCI, the application can retrieve the graph of objects in one <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> call.</p>
<p>Consider the update case where the application retrieves a graph of objects, and modifies it based upon user interaction, and then wants to make the modifications persistent in the database. Using the SQL interface, the application would have to execute multiple <code>UPDATE</code> statements to update the graph of objects. If the modifications involved creation of new objects and deletion of existing objects, then execution of corresponding <code>INSERT</code> and <code>DELETE</code> statements would also be required. In addition, the application would have to do more bookkeeping, such as keeping track of table names, because this information is required for executing the <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements.</p>
<p>Using the <a href="oci18nav001.htm#i427410">OCICacheFlush()</a> function, the application can flush all modifications (insertion, deletion, and update of objects) in a single operation. OCI does all the bookkeeping, thereby requiring less coding in the application. For manipulating a graph of objects OCI is not only efficient, but also provides an easy-to-use interface.</p>
<p>Consider a different case in which the application must fetch an object when given its <code>REF</code>. In OCI, this is achieved by pinning the object using the <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> call. In the SQL interface, this can be achieved by dereferencing the <code>REF</code> in a <code>SELECT</code> statement (for example, <code>SELECT DEREF(ref) from tbl;</code>). Consider situations where the same <code>REF</code> (reference to the same object) is being dereferenced multiple times in a transaction. By calling <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> with the <code>OCI_PIN_RECENT</code> option, the object is fetched from the server only once for the transaction, and repeated pins on the same <code>REF</code> return a pointer to the pinned object in the cache. In the SQL interface, each execution of the <code>SELECT</code> <code>DEREF...</code> statement would result in fetching the object from the server. This would result in multiple round-trips to the server and multiple copies of the same object.</p>
<p>Finally, consider the case in which the application must fetch a nonreferenceable object, as in the following example:</p>
<pre>
CREATE TABLE department 
( 
deptno number, 
deptname varchar2(30), 
manager employee_t 
); 
</pre>
<p>The <code>employee_t</code> instances stored in the <code>manager</code> column are nonreferenceable. You can only use the SQL interface to fetch <code>manager</code> column instances. But if <code>employee_t</code> has any <code>REF</code> attributes, OCI calls can then be used to navigate the <code>REF</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i446786"></a>
<div id="LNOCI16810" class="sect2">
<h3 class="sect2">Pin Count and Unpinning<a id="sthref1811"></a><a id="sthref1812"></a><a id="sthref1813"></a></h3>
<p>Each object in the object cache has a <span class="italic">pin count</span> associated with it. The pin count indicates the number of code modules that are concurrently accessing the object. The pin count is set to 1 when an object is pinned into the cache for the first time. Objects prefetched with complex object retrieval enter the object cache with a pin count of zero.</p>
<p>It is possible to pin an pinned object. Doing so increases the pin count by one. When a process finishes using an object, it should <span class="italic">unpin</span> it, using <a href="oci18nav005.htm#i438263">OCIObjectUnpin()</a>. This call decrements the pin count by one.</p>
<p>When the pin count of an object reaches zero, that object is eligible to be aged out of the cache if necessary, freeing up the memory space occupied by the object.</p>
<p>The pin count of an object can be set to zero explicitly by calling <a href="oci18nav005.htm#i433515">OCIObjectPinCountReset()</a>.</p>
<p>An application can unpin all objects in the cache related to a specific connection, by calling <a href="oci18nav005.htm#i469229">OCICacheUnpin()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci14oca.htm#i440637">"Freeing an Object Copy"</a> for more information about the conditions under which objects with zero pin count are removed from the cache and about objects being aged out of the cache</p>
</li>
<li>
<p><a href="#i440564">"Marking Objects and Flushing Changes"</a> for information about explicitly flushing an object or the entire cache</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i440892"></a>
<div id="LNOCI16811" class="sect2">
<h3 class="sect2">NULL Indicator Structure<a id="sthref1814"></a><a id="sthref1815"></a><a id="sthref1816"></a><a id="sthref1817"></a><a id="sthref1818"></a></h3>
<p>If a column in a row of a database table has no value, then that column is said to be <code>NULL</code>, or to contain a <code>NULL</code>. Two different types of <code>NULL</code>s can apply to objects:</p>
<ul>
<li>
<p>Any attribute of an object can have a <code>NULL</code> value. This indicates that the value of that attribute of the object is not known.</p>
</li>
<li>
<p>An object instance may be <span class="italic">atomically NULL</span>, meaning that the value of the entire object is unknown.</p>
</li>
</ul>
<p>Atomic nullity is not the same thing as nonexistence. An atomically <code>NULL</code> instance still exists; its value is just not known. It may be thought of as an existing object with no data.</p>
<p>When working with objects in OCI, an application can define a <span class="italic">NULL indicator structure</span> for each object type used by the application. In most cases, doing so simply requires including the <code>NULL</code> indicator structure generated by OTT along with the struct declaration. When the OTT output header file is included, the <code>NULL</code> indicator struct becomes available to your application.</p>
<p><a id="sthref1819"></a>For each type, the <code>NULL</code> indicator structure includes an atomic <code>NULL</code> indicator (whose type is <code>OCIInd</code>), and a <code>NULL</code> indicator for each attribute of the instance. If the type has an object attribute, the <code>NULL</code> indicator structure includes that attribute's <code>NULL</code> indicator structure. <a href="#BGBHFCEC">Example 11-6</a> shows the C representations of types with their corresponding <code>NULL</code> indicator structures.</p>
<div id="LNOCI18243" class="example">
<p class="titleinexample"><a id="BGBHFCEC"></a>Example 11-6 C Representations of Types with Their Corresponding NULL Indicator Structures</p>
<pre>
struct address
{
   OCINumber    no;
   OCIString    *street; 
   OCIString    *state;
   OCIString    *zip;
};
typedef struct address address;

struct address_ind
{
  OCIInd    _atomic;
  OCIInd    no;
  OCIInd    street;
  OCIInd    state;
  OCIInd    zip;
};
typedef struct address_ind address_ind;
    

struct person 
{
   OCIString      *fname;
   OCIString      *lname;
   OCINumber      age;
   OCIDate        birthday;
   OCIArray       *dependentsAge;
   OCITable       *prevAddr;
   OCIRaw         *comment1;
   OCILobLocator  *comment2;
   address        addr;
   OCIRef         *spouse;
};
typedef struct person person;
    
struct person_ind
{
  OCIInd        _atomic;
  OCIInd        fname;
  OCIInd        lname;
  OCIInd        age;
  OCIInd        birthday;
  OCIInd        dependentsAge;
  OCIInd        prevAddr;
  OCIInd        comment1;
  OCIInd        comment2;
  address_ind   addr;
  OCIInd        spouse;
};
typedef struct person_ind person_ind;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>dependentsAge</code> field of <code>person_ind</code> indicates whether the entire <a id="sthref1820"></a>varray (<code>dependentsAge</code> field of <code>person</code>) is atomically <code>NULL</code> or not. <code>NULL</code> information of individual elements of <code>dependentsAge</code> can be retrieved through the <code>elemind</code> parameter of a call to <a href="oci19map001.htm#i449838">OCICollGetElem()</a>. Similarly, the <code>prevAddr</code> field of <code>person_ind</code> indicates whether the entire nested table (<code>prevAddr</code> field of <code>person</code>) is atomically <code>NULL</code> or not. <code>NULL</code> information of individual elements of <code>prevAddr</code> can be retrieved through the <code>elemind</code> parameter of a call to <a href="oci19map001.htm#i449838">OCICollGetElem()</a>.</div>
<p>For an object type instance, the first field of the <code>NULL</code> indicator structure is the atomic <code>NULL</code> indicator, and the remaining fields are the attribute <code>NULL</code> indicators whose layout resembles the layout of the object type instance's attributes.</p>
<p>Checking the value of the atomic <code>NULL</code> indicator allows an application to test whether an instance is atomically <code>NULL</code>. Checking any of the others allows an application to test the <code>NULL</code> status of that attribute, as in the following code sample:</p>
<pre>
person_ind *my_person_ind
if( my_person_ind -&gt; _atomic == OCI_IND_NULL)
   printf ("instance is atomically NULL\n");
else
if( my_person_ind -&gt; fname == OCI_IND_NULL)
   printf ("fname attribute is NULL\n");
</pre>
<p>In the preceding example, the value of the atomic <code>NULL</code> indicator, or one of the attribute <code>NULL</code> indicators, is compared to the predefined value <a id="sthref1821"></a><code>OCI_IND_NULL</code> to test if it is <code>NULL</code>. The following predefined values are available for such a comparison:</p>
<ul>
<li>
<p><code>OCI_IND_NOTNULL</code>, indicating that the value is not <code>NULL</code></p>
</li>
<li>
<p><code>OCI_IND_NULL</code>, indicating that the value is <code>NULL</code></p>
</li>
<li>
<p><code>OCI_IND_BADNULL</code> indicates that an enclosing object (or parent object) is <code>NULL</code>. This is used by PL/SQL, and may also be referred to as an INVALID_NULL. For example, if a type instance is <code>NULL</code>, then its attributes are INVALID_NULLs.</p>
</li>
</ul>
<p><a id="sthref1822"></a>Use the function <a href="oci18nav004.htm#i469963">"OCIObjectGetInd()"</a> to retrieve the <code>NULL</code> indicator structure of an object.</p>
<p><a id="sthref1823"></a>If you update an attribute in its C structure, you must also set the <code>NULL</code> indicator for that attribute:</p>
<pre>
obj-&gt;attr1 = string1;
OCIObjectGetInd(envhp, errhp, obj, &amp;ind);
ind-&gt;attr1 = OCI_IND_NOTNULL;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci15ott.htm#g455369">Chapter 15</a> for more information about OTT-generated <code>NULL</code> indicator structures</div>
</div>
<!-- class="sect2" -->
<a id="i440918"></a>
<div id="LNOCI16812" class="sect2">
<h3 class="sect2">Creating Objects<a id="sthref1824"></a><a id="sthref1825"></a><a id="sthref1826"></a><a id="sthref1827"></a><a id="sthref1828"></a><a id="sthref1829"></a></h3>
<p>An OCI application can create any object using <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>. To create a persistent object, the application must specify the object table where the new object resides. This value can be retrieved by calling <a href="oci18nav005.htm#i433457">OCIObjectPinTable()</a>, and it is passed in the <code>table</code> parameter. To create a transient object, the application must pass only the type descriptor object (retrieved by calling <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a>) for the type of object being created.</p>
<p><a href="oci18nav004.htm#i470965">OCIObjectNew()</a> can also be used to create instances of scalars (for example, <code>REF</code>, LOB, string, raw, number, and date) and collections (for example, varray and nested table) by passing the appropriate value for the <code>typecode</code> parameter.</p>
<a id="i446308"></a>
<div id="LNOCI16813" class="sect3">
<h4 class="sect3">Attribute Values of New Objects</h4>
<p>By default, all attributes of a newly created object have <code>NULL</code> values. After initializing attribute data, the user must change the corresponding <code>NULL</code> status of each attribute to non-<code>NULL</code>.</p>
<p>It is possible to have attributes set to non-<code>NULL</code> values when an object is created. This is accomplished by setting the <code>OCI_ATTR_OBJECT_NEWNOTNULL</code> attribute of the environment handle to <code>TRUE</code> using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>. This mode can later be turned off by setting the attribute to <code>FALSE</code>.</p>
<p>If <code>OCI_ATTR_OBJECT_NEWNOTNULL</code> is set to <code>TRUE</code>, then <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> creates a non-<code>NULL</code> object. The attributes of the object have the default values described in <a href="#g475191">Table 11-4</a>, and the corresponding <code>NULL</code> indicators are set to <code>NOT NULL</code>.</p>
<div id="LNOCI16814" class="tblformal">
<p class="titleintable"><a id="sthref1830"></a><a id="g475191"></a>Table 11-4 Attribute Values for New Objects</p>
<table class="cellalignment1016" title="Attribute Values for New Objects " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t37">Attribute Type</th>
<th class="cellalignment1012" id="r1c2-t37">Default Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t37" headers="r1c1-t37">
<pre>
REF
</pre></td>
<td class="cellalignment1013" headers="r2c1-t37 r1c2-t37">
<p>If an object has a <code>REF</code> attribute, the user must set it to a valid <code>REF</code> before flushing the object or an error is returned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t37" headers="r1c1-t37">
<pre>
DATE
</pre></td>
<td class="cellalignment1013" headers="r3c1-t37 r1c2-t37">
<p>The earliest possible date that Oracle Database allows, which is midnight, 01-JAN-4712 BCE (equivalent to Julian day 1)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t37" headers="r1c1-t37">
<pre>
ANSI DATE
</pre></td>
<td class="cellalignment1013" headers="r4c1-t37 r1c2-t37">
<p>The earliest possible date that Oracle Database allows, 01-JAN-4712 BCE (equivalent to Julian day 1)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t37" headers="r1c1-t37">
<pre>
TIMESTAMP
</pre></td>
<td class="cellalignment1013" headers="r5c1-t37 r1c2-t37">
<p>The earliest possible date and time that Oracle Database allows, which is midnight, 01-JAN-4712 BCE (equivalent to Julian day 1)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t37" headers="r1c1-t37">
<pre>
TIMESTAMP WITH TIME ZONE
</pre></td>
<td class="cellalignment1013" headers="r6c1-t37 r1c2-t37">
<p>The earliest possible date and time that Oracle Database allows, which is midnight, 01-JAN-4712 BCE (equivalent to Julian day 1) at UTC (0:0) time zone</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t37" headers="r1c1-t37">
<pre>
TIMESTAMP WITH LOCAL TIME ZONE
</pre></td>
<td class="cellalignment1013" headers="r7c1-t37 r1c2-t37">
<p>The earliest possible date and time that Oracle Database allows, which is midnight, 01-JAN-4712 BCE (equivalent to Julian day 1) at UTC (0:0) time zone</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t37" headers="r1c1-t37">
<pre>
INTERVAL YEAR TO MONTH
</pre></td>
<td class="cellalignment1013" headers="r8c1-t37 r1c2-t37">
<p><code>INTERVAL '0-0' YEAR TO MONTH</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t37" headers="r1c1-t37">
<pre>
INTERVAL DAY TO SECOND
</pre></td>
<td class="cellalignment1013" headers="r9c1-t37 r1c2-t37">
<p><code>INTERVAL '0 0:0:0' DAY TO SECOND</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t37" headers="r1c1-t37">
<pre>
FLOAT
</pre></td>
<td class="cellalignment1013" headers="r10c1-t37 r1c2-t37">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t37" headers="r1c1-t37">
<pre>
NUMBER
</pre></td>
<td class="cellalignment1013" headers="r11c1-t37 r1c2-t37">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t37" headers="r1c1-t37">
<pre>
DECIMAL
</pre></td>
<td class="cellalignment1013" headers="r12c1-t37 r1c2-t37">
<p>0</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t37" headers="r1c1-t37">
<pre>
RAW
</pre></td>
<td class="cellalignment1013" headers="r13c1-t37 r1c2-t37">
<p>Raw data with length set to 0. Note: the default value for a <code>RAW</code> attribute is the same as that for a <code>NULL RAW</code> attribute.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t37" headers="r1c1-t37">
<pre>
VARCHAR2, NVARCHAR2
</pre></td>
<td class="cellalignment1013" headers="r14c1-t37 r1c2-t37">
<p><code>OCIString</code> with 0 length and first char set to <code>NULL</code>. The default value is the same as that of a <code>NULL</code> string attribute.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t37" headers="r1c1-t37">
<pre>
CHAR, NCHAR
</pre></td>
<td class="cellalignment1013" headers="r15c1-t37 r1c2-t37">
<p><code>OCIString</code> with 0 length and first char set to <code>NULL</code>. The default value is the same as that of a null string attribute.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t37" headers="r1c1-t37">
<pre>
VARCHAR
</pre></td>
<td class="cellalignment1013" headers="r16c1-t37 r1c2-t37">
<p><code>OCIString</code> with 0 length and first char set to <code>NULL</code>. The default value is the same as that of a null string attribute.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r17c1-t37" headers="r1c1-t37">
<pre>
VARRAY
</pre></td>
<td class="cellalignment1013" headers="r17c1-t37 r1c2-t37">
<p>Collection with 0 elements</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r18c1-t37" headers="r1c1-t37">
<pre>
NESTED TABLE
</pre></td>
<td class="cellalignment1013" headers="r18c1-t37 r1c2-t37">
<p>Table with 0 elements</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r19c1-t37" headers="r1c1-t37">
<pre>
CLOB, NCLOB
</pre></td>
<td class="cellalignment1013" headers="r19c1-t37 r1c2-t37">
<p>Empty <code>CLOB</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r20c1-t37" headers="r1c1-t37">
<pre>
BLOB
</pre></td>
<td class="cellalignment1013" headers="r20c1-t37 r1c2-t37">
<p>Empty <code>BLOB</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r21c1-t37" headers="r1c1-t37">
<pre>
BFILE
</pre></td>
<td class="cellalignment1013" headers="r21c1-t37 r1c2-t37">
<p>The user must initialize the <code>BFILE</code> to a valid value by setting the directory object and file name.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16815" class="sect2"><a id="sthref1831"></a>
<h3 class="sect2">Freeing and Copying Objects</h3>
<p>Use <a href="oci18nav005.htm#i430212">OCIObjectFree()</a> to free memory allocated by <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>. An object instance can have attributes that are pointers to additional memory (secondary memory chunks).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci14oca.htm#i435233">"Memory Layout of an Instance"</a></div>
<p>Freeing an object deallocates all the memory allocated for the object, including the associated NULL indicator structure and any secondary memory chunks. You must neither explicitly free the secondary memory chunks nor reassign the pointers. Doing so can result in memory leaks and memory corruption. This procedure deletes a transient, but not a persistent, object before its lifetime expires. An application should use <a href="oci18nav002.htm#i470079">OCIObjectMarkDelete()</a> to delete a persistent object.</p>
<p>An application can copy one instance to another instance of the same type using <a href="oci18nav004.htm#i469562">OCIObjectCopy()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci18nav.htm#i476164">Chapter 18, "OCI Navigational and Type Functions"</a></div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16816" class="sect2"><a id="sthref1832"></a>
<h3 class="sect2">Object Reference and Type Reference<a id="sthref1833"></a><a id="sthref1834"></a></h3>
<p>The object extensions to OCI provide the application with the flexibility to access the contents of objects using their pointers or their references. OCI provides the function <a href="oci18nav004.htm#i469995">OCIObjectGetObjectRef()</a> to return a reference to an object when given the object's pointer.</p>
<p>For applications that also want to access the type information of objects, OCI provides the function <a href="oci18nav003.htm#i469364">OCIObjectGetProperty()</a> to return a reference to an object's type descriptor object (TDO), when given a pointer to the object.</p>
<p>When a persistent object based on an object table with system-generated <a id="sthref1835"></a>object identifiers (OIDs) is created, a reference to this object may be immediately obtained by using <a href="oci18nav004.htm#i469995">OCIObjectGetObjectRef()</a>. But when a persistent object is based on an object view or on an object table with primary-key-based OIDs, all attributes belonging to the primary key must first be set before a reference can be obtained.</p>
</div>
<!-- class="sect2" -->
<a id="i446572"></a>
<div id="LNOCI16817" class="sect2">
<h3 class="sect2">Create Objects Based on Object Views and Object Tables with Primary-Key-Based OIDs</h3>
<p>Applications can use the <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> call to create objects, which are based on object views, or on object tables with primary-key-based <a id="sthref1836"></a>object identifiers (OIDs). Because object identifiers of such views and tables are based on attribute values, applications must then use <a href="oci18nav004.htm#i470296">OCIObjectSetAttr()</a> to set all attributes belonging to the primary key. Once the attribute values have been set, applications can obtain an object reference based on the attribute value by calling <a href="oci18nav004.htm#i469995">OCIObjectGetObjectRef()</a>.</p>
<p>This process involves the following steps:</p>
<ol>
<li>
<p>Pin the object view or object table on which the new object is to be based.</p>
</li>
<li>
<p>Create a new object using <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>, passing in the handle to the table or view obtained by the pin operation in Step 1.</p>
</li>
<li>
<p>Use <a href="oci18nav004.htm#i470296">OCIObjectSetAttr()</a> to fill in the necessary values for the object attributes. These must include those attributes that make up the user-defined object identifier for the object table or object view.</p>
</li>
<li>
<p>Use <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> to allocate an object reference, passing in the handle to the table or view obtained by the pin operation in Step 1.</p>
</li>
<li>
<p>Use <a href="oci18nav004.htm#i469995">OCIObjectGetObjectRef()</a> to obtain the primary-key-based reference to the object, if necessary. If desired, return to Step 2 to create more objects.</p>
</li>
<li>
<p>Flush the newly created objects to the server.</p>
</li>
</ol>
<p><a href="#BGBFGJII">Example 11-7</a> shows how this process might be implemented to create a new object for the <code>emp_view</code> object view in the <code>HR</code> schema.</p>
<div id="LNOCI18244" class="example">
<p class="titleinexample"><a id="BGBFGJII"></a>Example 11-7 Creating a New Object for an Object View</p>
<pre>
void object_view_new ()
{
void     *table;
OCIRef   *pkref;
void     *object;
OCIType  *emptdo;
...
/* Set up the service context, error handle and so on.. */
...
/* Pin the object view */
OCIObjectPinTable(envp,errorp,svctx, "HR", strlen("HR"), "EMP_VIEW",
    strlen("EMP_VIEW"),(void  *) 0, OCI_DURATION_SESSION, (void  **) &amp;table);

/* Create a new object instance  */
OCIObjectNew(envp, errorp, svctx, OCI_TYPECODE_OBJECT,(OCIType *)emptdo, table,
OCI_DURATION_SESSION,FALSE,&amp;object);

/* Populate the attributes of "object" */
OCIObjectSetAttr(...);
...
/* Allocate an object reference */
OCIObjectNew(envp, errorp, svctx, OCI_TYPECODE_REF, (OCIType *)0, (void  *)0,
    OCI_DURATION_SESSION,TRUE,&amp;pkref);

/* Get the reference using OCIObjectGetObjectRef */
OCIObjectGetObjectRef(envp,errorp,object,pkref);
...
/* Flush new objects to server */
...
} /* end function */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="LNOCI16818" class="sect2"><a id="sthref1837"></a>
<h3 class="sect2">Error Handling in Object Applications<a id="sthref1838"></a></h3>
<p>Error handling in OCI applications is the same whether or not the application uses objects. For more information about function return codes and error messages, see <a href="oci02bas.htm#i462233">"Error Handling in OCI"</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i449841"></a>
<div id="LNOCI16819" class="sect1">
<h2 class="sect1">Type Inheritance</h2>
<p>Type inheritance of objects has many similarities to inheritance in C++ and Java. You can create an object type as a <span class="italic">subtype</span> of an existing object type. The subtype is said to inherit all the attributes and methods (member functions and procedures) of the <span class="italic">supertype</span>, which is the original type. Only single inheritance is supported; an object cannot have more than one supertype. The subtype can add new attributes and methods to the ones it inherits. It can also override (redefine the implementation) of any of its inherited methods. A subtype is said to <span class="italic">extend</span> (that is, inherit from) its supertype.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ00205" href="../../appdev.112/e11822/adobjbas.htm#ADOBJ00205"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for a more complete discussion</div>
<p>As an example, a type <code>Person_t</code> can have a subtype <code>Student_t</code> and a subtype <code>Employee_t</code>. In turn, <code>Student_t</code> can have its own subtype, <code>PartTimeStudent_t</code>. A type declaration must have the flag <code>NOT</code> <code>FINAL</code> so that it can have subtypes. The default is <code>FINAL</code>, which means that the type can have no subtypes.</p>
<p>All types discussed so far in this chapter are <code>FINAL</code>. All types in applications developed before Oracle Database Release 9.0 are <code>FINAL</code>. A type that is <code>FINAL</code> can be altered to be <code>NOT</code> <code>FINAL</code>. A <code>NOT</code> <code>FINAL</code> type with no subtypes can be altered to be <code>FINAL</code>. <code>Person_t</code> is declared as <code>NOT</code> <code>FINAL</code> for our example:</p>
<pre>
CREATE TYPE Person_t AS OBJECT
( ssn NUMBER,
  name VARCHAR2(30),
  address VARCHAR2(100)) NOT FINAL;
</pre>
<p>A subtype inherits all the attributes and methods declared in its supertype. It can also declare new attributes and methods, which must have different names than those of the supertype. The keyword <code>UNDER</code> identifies the supertype, like this:</p>
<pre>
CREATE TYPE Student_t UNDER Person_t
( deptid NUMBER,
  major  VARCHAR2(30)) NOT FINAL;
</pre>
<p>The newly declared attributes <code>deptid</code> and <code>major</code> belong to the subtype <code>Student_t</code>. The subtype <code>Employee_t</code> is declared as, for example:</p>
<pre>
CREATE TYPE Employee_t UNDER Person_t
( empid NUMBER,
  mgr   VARCHAR2(30));
</pre>
<p>See <a href="oci15ott.htm#i440520">"OTT Support for Type Inheritance"</a> for the resulting structs generated by OTT for this example.</p>
<p>This subtype <code>Student_t</code> can have its own subtype, such as <code>PartTimeStudent_t</code>:</p>
<pre>
CREATE TYPE PartTimeStudent_t UNDER Student_t
( numhours NUMBER) ;
</pre>
<div id="LNOCI16820" class="sect2"><a id="sthref1839"></a>
<h3 class="sect2">Substitutability</h3>
<p>The benefits of <a class="olink ADOBJ7633" href="../../appdev.112/e11822/glossary.htm#ADOBJ7633"><span class="italic">polymorphism</span></a> derive partially from the property <span class="italic">substitutability</span>. Substitutability allows a value of some subtype to be used by code originally written for the supertype, without any specific knowledge of the subtype being needed in advance. The subtype value behaves to the surrounding code, just like a value of the supertype would, even if it perhaps uses different mechanisms within its specializations of methods.</p>
<p>Instance substitutability refers to the ability to use an object value of a subtype in a context declared in terms of a supertype. <code>REF</code> substitutability refers to the ability to use a <code>REF</code> to a subtype in a context declared in terms of a <code>REF</code> to a supertype.</p>
<p><code>REF</code> type attributes are substitutable; that is, an attribute defined as <code>REF</code> T can hold a <code>REF</code> to an instance of T or any of its subtypes.</p>
<p>Object type attributes are substitutable; an attribute defined to be of (an object) type T can hold an instance of T or any of its subtypes.</p>
<p>Collection element types are substitutable; if you define a collection of elements of type T, it can hold instances of type T and any of its subtypes. Here is an example of object attribute substitutability:</p>
<pre>
CREATE TYPE Book_t AS OBJECT 
( title VARCHAR2(30),
  author Person_t     /* substitutable */);
</pre>
<p>Thus, a <code>Book_t</code> instance can be created by specifying a title string and a <code>Person_t</code> (or any subtype of <code>Person_t</code>) instance:</p>
<pre>
Book_t('My Oracle Experience',
        Employee_t(12345, 'Joe', 'SF', 1111, NULL))
</pre></div>
<!-- class="sect2" -->
<div id="LNOCI16821" class="sect2"><a id="sthref1840"></a>
<h3 class="sect2">NOT INSTANTIABLE Types and Methods</h3>
<p>A type can be declared to be <code>NOT</code> <code>INSTANTIABLE</code>, which means that there is no constructor (default or user-defined) for the type. Thus, it is not possible to construct instances of this type. The typical usage would be to define instantiable subtypes for such a type. Here is how this property is used:</p>
<pre>
CREATE TYPE Address_t AS OBJECT(...) NOT INSTANTIABLE NOT FINAL;
CREATE TYPE USAddress_t UNDER Address_t(...);
CREATE TYPE IntlAddress_t UNDER Address_t(...);
</pre>
<p>A method of a type can be declared to be <code>NOT</code> <code>INSTANTIABLE</code>. Declaring a method as <code>NOT</code> <code>INSTANTIABLE</code> means that the type is not providing an implementation for that method. Further, a type that contains any <code>NOT</code> <code>INSTANTIABLE</code> methods must necessarily be declared as <code>NOT</code> <code>INSTANTIABLE</code>. For example:</p>
<pre>
CREATE TYPE T AS OBJECT
(
  x NUMBER,
  NOT INSTANTIABLE MEMBER FUNCTION func1() RETURN NUMBER
) NOT INSTANTIABLE NOT FINAL;
</pre>
<p>A subtype of a <code>NOT</code> <code>INSTANTIABLE</code> type can override any of the <code>NOT</code> <code>INSTANTIABLE</code> methods of the supertype and provide concrete implementations. If there are any <code>NOT</code> <code>INSTANTIABLE</code> methods remaining, the subtype must also necessarily be declared as <code>NOT</code> <code>INSTANTIABLE</code>.</p>
<p>A <code>NOT</code> <code>INSTANTIABLE</code> subtype can be defined under an instantiable supertype. Declaring a <code>NOT</code> <code>INSTANTIABLE</code> type to be <code>FINAL</code> is not useful and is not allowed.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16822" class="sect2"><a id="sthref1841"></a>
<h3 class="sect2">OCI Support for Type Inheritance</h3>
<p>The following calls support type inheritance.</p>
<div id="LNOCI16823" class="sect3"><a id="sthref1842"></a>
<h4 class="sect3">OCIDescribeAny()</h4>
<p>The <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> function provides information specific to inherited types. Additional attributes have been added for the properties of inherited types. For example, you can get the supertype of a type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci06des.htm#g453808">Table 6-7</a> and <a href="oci06des.htm#g454036">Table 6-9</a> for attributes that <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> can use to describe existing schema and subschema objects</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16824" class="sect3"><a id="sthref1843"></a>
<h4 class="sect3">Bind and Define Functions</h4>
<p>OCI bind functions support <code>REF</code>, instance, and collection element substitutability (subtype instances can be passed in where supertype is expected). There are no changes to the OCI bind interface, because all type checking and conversions are done on the server side.</p>
<p>OCI define functions also support substitutability (subtype instances can be fetched into define variables declared to hold the supertype). However, this might require the system to resize the memory to hold the subtype instance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The client program must use objects that are allocated out of the object cache (and are thus resizable) in such scenarios.</div>
<p>The client should not use a struct (allocated on the stack) as the define variable if the value is potentially polymorphic.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci12oty.htm#g453655">Chapter 12</a> for details of the bind and define processes</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16825" class="sect3"><a id="sthref1844"></a>
<h4 class="sect3">OCIObjectGetTypeRef()</h4>
<p>The <a href="oci18nav004.htm#i470280">OCIObjectGetTypeRef()</a> function returns the <code>REF</code> of the TDO of the most specific type of the input object. This operation returns an error if the user does not have privileges on the most specific type.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16826" class="sect3"><a id="sthref1845"></a>
<h4 class="sect3">OCIObjectCopy()</h4>
<p>The <a href="oci18nav004.htm#i469562">OCIObjectCopy()</a> function copies the contents of the source instance to the target instance. The source and target instances must be of the same type. It is not possible to copy between a supertype and a subtype.</p>
<p>Similarly, the <code>tdo</code> argument must describe the same object type as the source and target objects, and must not refer to a subtype or supertype of the source and target objects.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16827" class="sect3"><a id="sthref1846"></a>
<h4 class="sect3">OCICollAssignElem()</h4>
<p>The input element can be an instance of the subtype of the declared type. If the collection is of type <code>Person_t</code>, you can use the <a href="oci19map001.htm#i457193">OCICollAssignElem()</a> function to assign an <code>Employee_t</code> instance as an element of the collection.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16828" class="sect3"><a id="sthref1847"></a>
<h4 class="sect3">OCICollAppend()</h4>
<p>The input element can be an instance of the subtype of the declared type; if the collection is of type <code>Person_t</code>, you can use the <a href="oci19map001.htm#i448982">OCICollAppend()</a> function to append an <code>Employee_t</code> instance to the collection.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16829" class="sect3"><a id="sthref1848"></a>
<h4 class="sect3">OCICollGetElem()</h4>
<p>The collection element returned could be an instance of the subtype of the declared type; if the collection is of type <code>Person_t</code>, you can use the <a href="oci19map001.htm#i449838">OCICollGetElem()</a> function to get a pointer to an element, such as an <code>Employee_t</code> instance, in this collection.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16830" class="sect2"><a id="sthref1849"></a>
<h3 class="sect2">OTT Support for Type Inheritance</h3>
<p>The Object Type Translator (OTT) supports type inheritance of objects by declaring first the inherited attributes in an encapsulated struct called "_super", followed by the new declared attributes. This is done because C does not support type inheritance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci15ott.htm#i440520">"OTT Support for Type Inheritance"</a> for an example and discussion</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i450362"></a>
<div id="LNOCI16831" class="sect1">
<h2 class="sect1"><a id="sthref1850"></a>Type Evolution</h2>
<p><a id="i450280"></a>Adding, dropping, and modifying type attributes are supported. This concept is known as <span class="italic">type evolution</span>. It is discussed in the <a class="olink ADOBJ00603" href="../../appdev.112/e11822/adobjadv.htm#ADOBJ00603">Oracle Database Object-Relational Developer's Guide</a>.</p>
<p><a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> returns information about the latest version of the requested type if the type of the input object is <code>OCI_OTYPE_NAME</code>, and the type of the described object is <code>OCI_PTYPE_TYPE</code>, that is, if the name input to <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> is a type name.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci18nav006.htm#i455420">OCITypeArrayByName()</a> and <a href="oci18nav006.htm#i455564">OCITypeByName()</a>. To access type information, use these functions and <code>OCIDescribeAny()</code></p>
</li>
<li>
<p><a href="oci14oca.htm#i445166">"Type Evolution and the Object Cache"</a> for a discussion of the effect of type evolution on the object cache</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci10new.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci12oty.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
