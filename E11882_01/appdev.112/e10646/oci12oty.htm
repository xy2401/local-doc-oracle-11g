<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Object-Relational Data Types in OCI</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:24Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci11obj.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci13obn.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/79</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='oci12oty'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="LNOCI110" class="chapter"><a id="g453655"></a> <a id="i431532"></a>
<h1 class="chapter"><span class="secnum">12</span> Object-Relational Data Types in OCI</h1>
<p>This chapter describes the purpose and structure of each of the data types that can be manipulated by the OCI data type mapping and manipulation functions; it also summarizes the different function groups giving lists of available functions and their purposes. In addition, provides information about how to use these data types in bind and define operations within an OCI application.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i432584">Overview of OCI Functions for Objects</a></p>
</li>
<li>
<p><a href="#CDDHFIAA">Mapping Oracle Data Types to C</a></p>
</li>
<li>
<p><a href="#i423862">Manipulating C Data Types with OCI</a></p>
</li>
<li>
<p><a href="#i424575">Date (OCIDate)</a></p>
</li>
<li>
<p><a href="#i438442">Datetime and Interval (OCIDateTime, OCIInterval)</a></p>
</li>
<li>
<p><a href="#i434059">Number (OCINumber)</a></p>
</li>
<li>
<p><a href="#i421612">Fixed or Variable-Length String (OCIString)</a></p>
</li>
<li>
<p><a href="#i421681">Raw (OCIRaw)</a></p>
</li>
<li>
<p><a href="#i421736">Collections (OCITable, OCIArray, OCIColl, OCIIter)</a></p>
</li>
<li>
<p><a href="#i436452">Multilevel Collection Types</a></p>
</li>
<li>
<p><a href="#i426837">REF (OCIRef)</a></p>
</li>
<li>
<p><a href="#i426966">Object Type Information Storage and Access</a></p>
</li>
<li>
<p><a href="#i435657">AnyType, AnyData, and AnyDataSet Interfaces</a></p>
</li>
<li>
<p><a href="#i437157">Binding Named Data Types</a></p>
</li>
<li>
<p><a href="#i437252">Defining Named Data Types</a></p>
</li>
<li>
<p><a href="#i437327">Binding and Defining Oracle C Data Types</a></p>
</li>
<li>
<p><a href="#i437615">SQLT_NTY Bind and Define Examples</a></p>
</li>
</ul>
<a id="i432584"></a>
<div id="LNOCI16832" class="sect1">
<h2 class="sect1">Overview of OCI Functions for Objects</h2>
<p>The OCI data type mapping and manipulation functions provide the ability to manipulate instances of predefined Oracle C data types. These data types are used to represent the attributes of user-defined data types, including object types in Oracle Database.</p>
<p>Each group of functions within OCI is distinguished by a particular naming convention. The data type mapping and manipulation functions, for example, can be easily recognized because the function names start with the prefix <span class="italic">OCI</span>, followed by the name of a data type, as in <a href="oci19map002.htm#i450182">OCIDateFromText()</a> and <a href="oci19map004.htm#i458762">OCIRawSize()</a>. As will be explained later, the names can be further subdivided into function groups that operate on a particular type of data.</p>
<p>The predefined Oracle C types on which these functions operate are also distinguished by names that begin with the prefix <span class="italic">OCI</span>, as in <code>OCIDate</code> or <code>OCIString</code>.</p>
<p>The data type mapping and manipulation functions are used when an application must manipulate, bind, or define attributes of objects that are stored in an Oracle database, or that have been retrieved by a SQL query. Retrieved objects are stored in the client-side object cache, and described in <a href="oci14oca.htm#g458990">Chapter 14</a>.</p>
<p>The OCI client must allocate a descriptor before performing a bind or define operation. <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> and <a href="oci17msc001.htm#i575019">OCIStmtFetch2()</a> cannot allocate the memory for the descriptors if they are not allocated by <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a>.</p>
<p>These functions are valid only when an OCI application is running in object mode. For information about initializing OCI in object mode and creating an OCI application that accesses and manipulates objects, see <a href="oci11obj.htm#i440421">"Initializing the Environment and the Object Cache"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Oracle Database Concepts for detailed information about object types, attributes, and collection data types</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Operations on object types such as <code>OCIDate</code>, allow the address of the result to be the same as that of one of the operands.</div>
</div>
<!-- class="sect1" -->
<a id="CDDHFIAA"></a>
<div id="LNOCI16833" class="sect1">
<h2 class="sect1">Mapping Oracle Data Types to C<a id="sthref1851"></a><a id="sthref1852"></a></h2>
<p>Oracle provides a rich set of predefined data types with which you can create tables and specify user-defined data types (including object types). Object types extend the functionality of Oracle Database by allowing you to create data types that precisely model the types of data with which they work. This can provide increased efficiency and ease-of-use for programmers who are accessing the data.</p>
<p>You can use <a id="sthref1853"></a><code>NCHAR</code> and <code>NVARCHAR2</code> as attributes in objects and map to <code>OCIString *</code> in C.</p>
<p>Database tables and object types are based upon the data types supplied by Oracle. These tables and types are created with SQL statements and stored using a specific set of Oracle internal data types, like <code>VARCHAR2</code> or <code>NUMBER</code>. For example, the following SQL statements create a user-defined <code>address</code> data type and an object table to store instances of that type:</p>
<pre>
CREATE TYPE address AS OBJECT
(street1    varchar2(50),
street2     varchar2(50),
city        varchar2(30),
state       char(2),
zip         number(5));
CREATE TABLE address_table OF address;
</pre>
<p>The new <code>address</code> type could also be used to create a regular table with an object column:</p>
<pre>
CREATE TABLE employees
(name         varchar2(30),
birthday      date,
home_addr     address);
</pre>
<p>An OCI application can manipulate information in the <code>name</code> and <code>birthday</code> columns of the <code>employees</code> table using straightforward bind and define operations in association with SQL statements. Accessing information stored as attributes of objects requires some extra steps.</p>
<p>The OCI application first needs a way to represent the objects in a C language format. This is accomplished by using the Object Type Translator (OTT) to generate C struct representations of user-defined types. The elements of these structs have data types that represent C language mappings of Oracle data types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci15ott.htm#CIHEBCFC">Table 15-1</a> for the available Oracle types and their C mappings you can use as object attribute types</div>
<p>An additional C type, <code>OCIInd</code>, is used to represent null indicator information corresponding to attributes of object types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci15ott.htm#g455369">Chapter 15</a> for more information and examples about using OTT</div>
<div id="LNOCI16834" class="sect2"><a id="sthref1854"></a>
<h3 class="sect2">OCI Type Mapping Methodology<a id="sthref1855"></a></h3>
<p>Oracle followed a distinct design philosophy when specifying the mappings of Oracle predefined types. The current system has the following benefits and advantages:</p>
<ul>
<li>
<p>The actual representation of data types like <code>OCINumber</code> is opaque to client applications, and the data types are manipulated with a set of predefined functions. This allows the internal representation to change to accommodate future enhancements without breaking user code.</p>
</li>
<li>
<p>The implementation is consistent with object-oriented paradigms in which class implementation is hidden and only the required operations are exposed.</p>
</li>
<li>
<p>This implementation can have advantages for programmers. Consider writing a C program to manipulate Oracle number variables without losing the accuracy provided by Oracle numbers. To do this operation in Oracle Database Release 7, you would have had to issue a "<code>SELECT ... FROM DUAL</code>" statement. In later releases, this is accomplished by invoking the <code>OCINumber*()</code> functions.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i423862"></a>
<div id="LNOCI16835" class="sect1">
<h2 class="sect1">Manipulating C Data Types with OCI<a id="sthref1856"></a><a id="sthref1857"></a></h2>
<p>In an OCI application, the manipulation of data may be as simple as adding together two integer variables and storing the result in a third variable:</p>
<pre>
int    int_1, int_2, sum;
...
/* some initialization occurs */
...
sum = int_1 + int_2;
</pre>
<p>The C language provides a set of predefined operations on simple types such as <code>integer</code>. However, the C data types listed in <a href="oci15ott.htm#CIHEBCFC">Table 15-1</a> are not simple C primitives. Types such as <code>OCIString</code> and <code>OCINumber</code> are actually structs with a specific Oracle-defined internal structure. It is not possible to simply add together two <code>OCINumber</code>s and store the value in the third.</p>
<p>The following is not valid:</p>
<pre>
OCINumber    num_1, num_2, sum;
...
/* some initialization occurs */
...
sum = num_1 + num_2;           /* NOT A VALID OPERATION */
</pre>
<p>The OCI data type mapping and manipulation functions are provided to enable you to perform operations on these new data types. For example, the preceding addition of <code>OCINumber</code>s could be accomplished as follows, using the <a href="oci19map003.htm#i430094">OCINumberAdd()</a> function:</p>
<pre>
OCINumber    num_1, num_2, sum;
...
/* some initialization occurs */
...
OCINumberAdd(errhp, &amp;num_1, &amp;num_2, &amp;sum): /* errhp is error handle */
</pre>
<p>OCI provides functions to operate on each of the new data types. The names of the functions provide information about the data types on which they operate. The first three letters, <span class="italic">OCI</span>, indicate that the function is part of OCI. The next part of the name indicates the data type on which the function operates. <a href="#BGBICHGB">Table 12-1</a> shows the various function prefixes, along with example function names and the data types on which the functions operate.</p>
<div id="LNOCI16836" class="tblformal">
<p class="titleintable"><a id="sthref1858"></a><a id="BGBICHGB"></a>Table 12-1 Function Prefix Examples</p>
<table class="cellalignment1016" title="Function Prefix Examples" summary="This table is described in the preceding text" >
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t6">Function Prefix</th>
<th class="cellalignment1012" id="r1c2-t6">Example</th>
<th class="cellalignment1012" id="r1c3-t6">Operates on</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t6" headers="r1c1-t6">
<pre>
OCIColl
</pre></td>
<td class="cellalignment1013" headers="r2c1-t6 r1c2-t6">
<pre>
<a href="oci19map001.htm#i449838">OCICollGetElem()</a>
</pre></td>
<td class="cellalignment1013" headers="r2c1-t6 r1c3-t6">
<pre>
OCIColl, OCIIter, OCITable, OCIArray
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t6" headers="r1c1-t6">
<pre>
OCIDate
</pre></td>
<td class="cellalignment1013" headers="r3c1-t6 r1c2-t6">
<pre>
<a href="oci19map002.htm#i430033">OCIDateDaysBetween()</a>
</pre></td>
<td class="cellalignment1013" headers="r3c1-t6 r1c3-t6">
<pre>
OCIDate
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t6" headers="r1c1-t6">
<pre>
OCIDateTime
</pre></td>
<td class="cellalignment1013" headers="r4c1-t6 r1c2-t6">
<pre>
<a href="oci19map002.htm#i511964">OCIDateTimeSubtract()</a>
</pre></td>
<td class="cellalignment1013" headers="r4c1-t6 r1c3-t6">
<pre>
OCIDate, OCIDateTime
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t6" headers="r1c1-t6">
<pre>
OCIInterval
</pre></td>
<td class="cellalignment1013" headers="r5c1-t6 r1c2-t6">
<pre>
<a href="oci19map002.htm#i510940">OCIIntervalToText()</a>
</pre></td>
<td class="cellalignment1013" headers="r5c1-t6 r1c3-t6">
<pre>
OCIInterval
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t6" headers="r1c1-t6">
<pre>
OCIIter
</pre></td>
<td class="cellalignment1013" headers="r6c1-t6 r1c2-t6">
<pre>
<a href="oci19map001.htm#i499993">OCIIterInit()</a>
</pre></td>
<td class="cellalignment1013" headers="r6c1-t6 r1c3-t6">
<pre>
OCIIter
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t6" headers="r1c1-t6">
<pre>
OCINumber
</pre></td>
<td class="cellalignment1013" headers="r7c1-t6 r1c2-t6">
<pre>
<a href="oci19map003.htm#i430094">OCINumberAdd()</a>
</pre></td>
<td class="cellalignment1013" headers="r7c1-t6 r1c3-t6">
<pre>
OCINumber
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t6" headers="r1c1-t6">
<pre>
OCIRaw
</pre></td>
<td class="cellalignment1013" headers="r8c1-t6 r1c2-t6">
<pre>
<a href="oci19map004.htm#i450943">OCIRawResize()</a>
</pre></td>
<td class="cellalignment1013" headers="r8c1-t6 r1c3-t6">
<pre>
OCIRaw *
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t6" headers="r1c1-t6">
<pre>
OCIRef
</pre></td>
<td class="cellalignment1013" headers="r9c1-t6 r1c2-t6">
<pre>
<a href="oci19map005.htm#i445077">OCIRefAssign()</a>
</pre></td>
<td class="cellalignment1013" headers="r9c1-t6 r1c3-t6">
<pre>
OCIRef *
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t6" headers="r1c1-t6">
<pre>
OCIString
</pre></td>
<td class="cellalignment1013" headers="r10c1-t6 r1c2-t6">
<pre>
<a href="oci19map006.htm#i458763">OCIStringSize()</a>
</pre></td>
<td class="cellalignment1013" headers="r10c1-t6 r1c3-t6">
<pre>
OCIString *
</pre></td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t6" headers="r1c1-t6">
<pre>
OCITable
</pre></td>
<td class="cellalignment1013" headers="r11c1-t6 r1c2-t6">
<pre>
<a href="oci19map007.htm#i450671">OCITableLast()</a>
</pre></td>
<td class="cellalignment1013" headers="r11c1-t6 r1c3-t6">
<pre>
OCITable *
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The structure of each of the data types is described later in this chapter, along with a list of the functions that manipulate that type.</p>
<div id="LNOCI16837" class="sect2"><a id="sthref1859"></a>
<h3 class="sect2">Precision of Oracle Number Operations</h3>
<p>Oracle numbers have a precision of 38 decimal digits. All Oracle number operations are accurate to the full precision, with the following exceptions:</p>
<ul>
<li>
<p>Inverse trigonometric functions are accurate to 28 decimal digits.</p>
</li>
<li>
<p>Other transcendental functions, including trigonometric functions, are accurate to approximately 37 decimal digits.</p>
</li>
<li>
<p>Conversions to and from native floating-point types have the precision of the relevant floating-point type, not to exceed 38 decimal digits.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i424575"></a>
<div id="LNOCI16838" class="sect1">
<h2 class="sect1">Date (OCIDate)<a id="sthref1860"></a><a id="sthref1861"></a></h2>
<p>The Oracle date format is mapped in C by the <code>OCIDate</code> type, which is an opaque C struct. Elements of the struct represent the year, month, day, hour, minute, and second of the date. The specific elements can be set and retrieved using the appropriate OCI functions.</p>
<p>The <code>OCIDate</code> data type can be bound or defined directly using the external typecode <code>SQLT_ODT</code> in the bind or define call.</p>
<p>Unless otherwise specified, the term <span class="italic">date</span> in these function calls refers to a value of type <code>OCIDate</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map.htm#i518093">Chapter 19</a> for the prototypes and descriptions of all the functions</div>
<a id="i439854"></a>
<div id="LNOCI16839" class="sect2">
<h3 class="sect2">Date Example<a id="sthref1862"></a></h3>
<p><a href="#BGBFJEFJ">Example 12-1</a> provides examples of how to manipulate an attribute of type <code>OCIDate</code> using OCI calls. For this example, assume that <code>OCIEnv</code> and <code>OCIError</code> have been initialized as described in <a href="oci02bas.htm#i461923">"OCI Environment Initialization"</a>. See <a href="oci14oca.htm#BGBHEHFI">"Object Cache Operations"</a> for information about pinning.</p>
<div id="LNOCI18245" class="example">
<p class="titleinexample"><a id="BGBFJEFJ"></a>Example 12-1 Manipulating an Attribute of Type OCIDate</p>
<pre>
#define FMT "DAY, MONTH DD, YYYY"
#define LANG "American"
struct person
{
OCIDate start_date;
};
typedef struct person person;

OCIError *err;
person *tim;
sword status;                      /* error status */
uword invalid;
OCIDate last_day, next_day;
text buf[100], last_day_buf[100], next_day_buf[100];
ub4 buflen = sizeof(buf);

/* Pin tim person object in the object cache. */
/*  For this example, assume that
/* tim is pointing to the pinned object. */
/* set the start date of tim */

OCIDateSetTime(&amp;tim-&gt;start_date,8,0,0);
OCIDateSetDate(&amp;tim-&gt;start_date,1990,10,5);

/* check if the date is valid */
if (OCIDateCheck(err, &amp;tim-&gt;start_date, &amp;invalid) != OCI_SUCCESS)
/* error handling code */

if (invalid)
/* error handling code */

/* get the last day of start_date's month */
if (OCIDateLastDay(err, &amp;tim-&gt;start_date, &amp;last_day) != OCI_SUCCESS)
/* error handling code */

/* get date of next named day */
if (OCIDateNextDay(err, &amp;tim-&gt;start_date, "Wednesday",    strlen("Wednesday"),
&amp;next_day) != OCI_SUCCESS)
/* error handling code */
/* convert dates to strings and print the information */
/* first convert the date itself*/
buflen = sizeof(buf);
if (OCIDateToText(err, &amp;tim-&gt;start_date, FMT, sizeof(FMT)-1, LANG,
    sizeof(LANG)-1,             &amp;buflen, buf) != OCI_SUCCESS)
/* error handling code */

/* now the last day of the month */
buflen = sizeof(last_day_buf);
if (OCIDateToText(err, &amp;last_day, FMT, sizeof(FMT)-1, LANG,    sizeof(LANG)-1,
&amp;buflen, last_day_buf) != OCI_SUCCESS)
/* error handling code */

/* now the first Wednesday after this date */
buflen = sizeof(next_day_buf);
if (OCIDateToText(err, &amp;next_day, FMT, sizeof(FMT)-1, LANG,
   sizeof(LANG)-1, &amp;buflen, next_day_buf) != OCI_SUCCESS)
/* error handling code */

/* print the information */
printf("For: %s\n", buf);
printf("The last day of the month is: %s\n", last_day_buf);
printf("The next Wednesday is: %s\n", next_day_buf);
</pre></div>
<!-- class="example" -->
<p>The output is:</p>
<pre>
For: FRIDAY   , OCTOBER   05, 1990
The last day of the month is: WEDNESDAY, OCTOBER   31, 1990
The next Wednesday is: WEDNESDAY, OCTOBER   10, 1990
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i438442"></a>
<div id="LNOCI16840" class="sect1">
<h2 class="sect1">Datetime and Interval (OCIDateTime, OCIInterval)</h2>
<p>The <code>OCIDateTime</code> data type is an opaque structure used to represent Oracle time-stamp data types (<code>TIMESTAMP</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code>, <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code>) and the <code>ANSI DATE</code> data type. You can set or retrieve the data in these types (that is, year, day, fractional second) using the appropriate OCI functions.</p>
<p>The <code>OCIInterval</code> data type is also an opaque structure and is used to represent Oracle interval data types (<code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code>, <code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code>).</p>
<p>You can bind and define <code>OCIDateTime</code> and <code>OCIInterval</code> data using the following external typecodes shown in <a href="#BGBJBCDC">Table 12-2</a> in the bind or define call.</p>
<div id="LNOCI16841" class="tblformal">
<p class="titleintable"><a id="sthref1863"></a><a id="BGBJBCDC"></a>Table 12-2 Binding and Defining Datetime and Interval Data Types</p>
<table class="cellalignment1016" title="Binding and Defining Datetime and Interval Data Types" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t8">OCI Data Type</th>
<th class="cellalignment1012" id="r1c2-t8">Type of Data</th>
<th class="cellalignment1012" id="r1c3-t8">External Typecode for Binding/Defining</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t8" headers="r1c1-t8">
<pre>
OCIDateTime
</pre></td>
<td class="cellalignment1013" headers="r2c1-t8 r1c2-t8">
<p>ANSI DATE</p>
</td>
<td class="cellalignment1013" headers="r2c1-t8 r1c3-t8">
<p>SQLT_DATE</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t8" headers="r1c1-t8">
<pre>
OCIDateTime
</pre></td>
<td class="cellalignment1013" headers="r3c1-t8 r1c2-t8">
<p>TIMESTAMP</p>
</td>
<td class="cellalignment1013" headers="r3c1-t8 r1c3-t8">
<p>SQLT_TIMESTAMP</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t8" headers="r1c1-t8">
<pre>
OCIDateTime
</pre></td>
<td class="cellalignment1013" headers="r4c1-t8 r1c2-t8">
<p>TIMESTAMP WITH TIME ZONE</p>
</td>
<td class="cellalignment1013" headers="r4c1-t8 r1c3-t8">
<p>SQLT_TIMESTAMP_TZ</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t8" headers="r1c1-t8">
<pre>
OCIDateTime
</pre></td>
<td class="cellalignment1013" headers="r5c1-t8 r1c2-t8">
<p>TIMESTAMP WITH LOCAL TIME ZONE</p>
</td>
<td class="cellalignment1013" headers="r5c1-t8 r1c3-t8">
<p>SQLT_TIMESTAMP_LTZ</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t8" headers="r1c1-t8">
<pre>
OCIInterval
</pre></td>
<td class="cellalignment1013" headers="r6c1-t8 r1c2-t8">
<p>INTERVAL YEAR TO MONTH</p>
</td>
<td class="cellalignment1013" headers="r6c1-t8 r1c3-t8">
<p>SQLT_INTERVAL_YM</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t8" headers="r1c1-t8">
<pre>
OCIInterval
</pre></td>
<td class="cellalignment1013" headers="r7c1-t8 r1c2-t8">
<p>INTERVAL DAY TO SECOND</p>
</td>
<td class="cellalignment1013" headers="r7c1-t8 r1c3-t8">
<p>SQLT_INTERVAL_DS</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The OCI functions that operate on datetime and interval data are listed in <a href="#BGBFHBDD">Table 12-3</a> and <a href="#BGBDAIGI">Table 12-4</a>. More detailed information about these functions can be found in <a href="oci19map002.htm#i490882">"OCI Date, Datetime, and Interval Functions"</a>.</p>
<p>In general, functions that operate on <code>OCIDateTime</code> data are also valid for <code>OCIDate</code> data.</p>
<div id="LNOCI16842" class="sect2"><a id="sthref1864"></a>
<h3 class="sect2">Datetime Functions</h3>
<p>The following functions operate on <code>OCIDateTime</code> values. Some of these functions also perform arithmetic operations on datetime and interval values. Some functions may only work for certain datetime types. The possible types are:</p>
<ul>
<li>
<p><code>SQLT_DATE</code> - <code>DATE</code></p>
</li>
<li>
<p><code>SQLT_TIMESTAMP</code> - <code>TIMESTAMP</code></p>
</li>
<li>
<p><code>SQLT_TIMESTAMP_TZ</code> - <code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code></p>
</li>
<li>
<p><code>SQLT_TIMESTAMP_LTZ</code> - <code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code></p>
</li>
</ul>
<p>See the individual function descriptions listed in <a href="#BGBFHBDD">Table 12-3</a> for more information about input types that are valid for a particular function.</p>
<div id="LNOCI16843" class="tblformal">
<p class="titleintable"><a id="sthref1865"></a><a id="BGBFHBDD"></a>Table 12-3 Datetime Functions</p>
<table class="cellalignment1016" title="Datetime Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t9">Function</th>
<th class="cellalignment1012" id="r1c2-t9">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508673">"OCIDateTimeAssign()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t9 r1c2-t9">
<p>Performs datetime assignment</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i517610">"OCIDateTimeCheck()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t9 r1c2-t9">
<p>Checks if the given date is valid</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508759">"OCIDateTimeCompare()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t9 r1c2-t9">
<p>Compares two datetime values</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i512069">"OCIDateTimeConstruct()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t9 r1c2-t9">
<p>Constructs a datetime descriptor</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508796">"OCIDateTimeConvert()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t9 r1c2-t9">
<p>Converts one datetime type to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i512426">"OCIDateTimeFromArray()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t9 r1c2-t9">
<p>Converts an array containing a date to an <code>OCIDateTime</code> descriptor</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i520832">"OCIDateTimeFromText()"</a></p>
</td>
<td class="cellalignment1013" headers="r8c1-t9 r1c2-t9">
<p>Converts the given string to Oracle datetime type in the <code>OCIDateTime</code> descriptor, according to the specified format</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508882">"OCIDateTimeGetDate()"</a></p>
</td>
<td class="cellalignment1013" headers="r9c1-t9 r1c2-t9">
<p>Gets the date (year, month, day) portion of a datetime value</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508932">"OCIDateTimeGetTime()"</a></p>
</td>
<td class="cellalignment1013" headers="r10c1-t9 r1c2-t9">
<p>Gets the time (hour, minute, second, fractional second) from datetime value</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i512092">"OCIDateTimeGetTimeZoneName()"</a></p>
</td>
<td class="cellalignment1013" headers="r11c1-t9 r1c2-t9">
<p>Gets the time zone name portion of a datetime value</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508981">"OCIDateTimeGetTimeZoneOffset()"</a></p>
</td>
<td class="cellalignment1013" headers="r12c1-t9 r1c2-t9">
<p>Gets the time zone (hour, minute) portion of a datetime value</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i508985">"OCIDateTimeIntervalAdd()"</a></p>
</td>
<td class="cellalignment1013" headers="r13c1-t9 r1c2-t9">
<p>Adds an interval to a datetime to produce a resulting datetime</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i509023">"OCIDateTimeIntervalSub()"</a></p>
</td>
<td class="cellalignment1013" headers="r14c1-t9 r1c2-t9">
<p>Subtracts an interval from a datetime and stores the result in a datetime</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i511964">"OCIDateTimeSubtract()"</a></p>
</td>
<td class="cellalignment1013" headers="r15c1-t9 r1c2-t9">
<p>Takes two datetimes as input and stores their difference in an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i512454">"OCIDateTimeSysTimeStamp()"</a></p>
</td>
<td class="cellalignment1013" headers="r16c1-t9 r1c2-t9">
<p>Gets the system current date and time as a time stamp with time zone</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r17c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i512458">"OCIDateTimeToArray()"</a></p>
</td>
<td class="cellalignment1013" headers="r17c1-t9 r1c2-t9">
<p>Converts an <code>OCIDateTime</code> descriptor to an array</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r18c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i509197">"OCIDateTimeToText()"</a></p>
</td>
<td class="cellalignment1013" headers="r18c1-t9 r1c2-t9">
<p>Converts the given date to a string according to the specified format</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r19c1-t9" headers="r1c1-t9">
<p><a href="oci19map002.htm#i430061">"OCIDateZoneToZone()"</a></p>
</td>
<td class="cellalignment1013" headers="r19c1-t9 r1c2-t9">
<p>Converts the date from one time zone to another time zone</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI16844" class="sect2"><a id="sthref1866"></a>
<h3 class="sect2">Datetime Example</h3>
<p>The code fragment in <a href="#BGBEHEBE">Example 12-2</a> shows how to use an <code>OCIDateTime</code> data type to select data from a <code>TIMESTAMP WITH LOCAL TIME ZONE</code> column.</p>
<div id="LNOCI18246" class="example">
<p class="titleinexample"><a id="BGBEHEBE"></a>Example 12-2 Manipulating an Attribute of Type OCIDateTime</p>
<pre>
...

/* allocate the program variable for storing the data */
OCIDateTime *tstmpltz = (OCIDateTime *)NULL;

/* Col1 is a time stamp with local time zone column */
OraText *sqlstmt = (OraText *)"SELECT col1 FROM foo";

/* Allocate the descriptor (storage) for the data type */
status = OCIDescriptorAlloc(envhp,(void  **)&amp;tstmpltz, OCI_DTYPE_TIMESTAMP_LTZ,
         0, (void  **)0);
....

status = OCIStmtPrepare (stmthp, errhp, sqlstmt, (ub4)strlen ((char *)sqlstmt),
         (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT);

/* specify the define buffer for col1 */
status = OCIDefineByPos(stmthp, &amp;defnp, errhp, 1, &amp;tstmpltz, sizeof(tstmpltz),
         SQLT_TIMESTAMP_LTZ, 0, 0, 0, OCI_DEFAULT);

/* Execute and Fetch */
OCIStmtExecute(svchp, stmthp, errhp, 1, 0,(OCISnapshot *) NULL,
         (OCISnapshot *)NULL, OCI_DEFAULT)

At this point tstmpltz contains a valid time stamp with local time zone data. You
can get the time zone name of the datetime data using:

status = OCIDateTimeGetTimeZoneName(envhp, errhp, tstmpltz, (ub1 *)buf,
         (ub4 *)&amp;buflen);
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="LNOCI16845" class="sect2"><a id="sthref1867"></a>
<h3 class="sect2">Interval Functions</h3>
<p>The functions listed in <a href="#BGBDAIGI">Table 12-4</a> operate exclusively on interval data. In some cases it is necessary to specify the type of interval involved. Possible types include:</p>
<ul>
<li>
<p><code>SQLT_INTERVAL_YM</code> - interval year to month</p>
</li>
<li>
<p><code>SQLT_INTERVAL_DS</code> - interval day to second</p>
</li>
</ul>
<p>See the individual function descriptions for more detailed information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map002.htm#i490882">"OCI Date, Datetime, and Interval Functions"</a> for complete lists of the names and purposes and more detailed information about these functions</div>
<div id="LNOCI16846" class="tblformal">
<p class="titleintable"><a id="sthref1868"></a><a id="BGBDAIGI"></a>Table 12-4 Interval Functions</p>
<table class="cellalignment1016" title="Interval Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t11">Function</th>
<th class="cellalignment1012" id="r1c2-t11">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i512468">"OCIIntervalAdd()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t11 r1c2-t11">
<p>Adds two intervals to produce a resulting interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510645">"OCIIntervalAssign()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t11 r1c2-t11">
<p>Copies one interval to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510673">"OCIIntervalCheck()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t11 r1c2-t11">
<p>Checks the validity of an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510718">"OCIIntervalCompare()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t11 r1c2-t11">
<p>Compares two intervals</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510753">"OCIIntervalDivide()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t11 r1c2-t11">
<p>Divides an interval by an Oracle <code>NUMBER</code> to produce an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i512484">"OCIIntervalFromNumber()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t11 r1c2-t11">
<p>Converts an Oracle <code>NUMBER</code> to an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510787">"OCIIntervalFromText()"</a></p>
</td>
<td class="cellalignment1013" headers="r8c1-t11 r1c2-t11">
<p>When given an interval string, converts the interval represented by the string</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i519352">"OCIIntervalFromTZ()"</a></p>
</td>
<td class="cellalignment1013" headers="r9c1-t11 r1c2-t11">
<p>Returns an interval when given an input string of time zone form</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i519278">"OCIIntervalGetDaySecond()"</a></p>
</td>
<td class="cellalignment1013" headers="r10c1-t11 r1c2-t11">
<p>Gets values of day, hour, minute, and second from an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i512495">"OCIIntervalGetYearMonth()"</a></p>
</td>
<td class="cellalignment1013" headers="r11c1-t11 r1c2-t11">
<p>Gets year and month from an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510838">"OCIIntervalMultiply()"</a></p>
</td>
<td class="cellalignment1013" headers="r12c1-t11 r1c2-t11">
<p>Multiplies an interval by an Oracle <code>NUMBER</code> to produce an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i512522">"OCIIntervalSetDaySecond()"</a></p>
</td>
<td class="cellalignment1013" headers="r13c1-t11 r1c2-t11">
<p>Sets day, hour, minute, and second in an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i512526">"OCIIntervalSetYearMonth()"</a></p>
</td>
<td class="cellalignment1013" headers="r14c1-t11 r1c2-t11">
<p>Sets year and month in an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510871">"OCIIntervalSubtract()"</a></p>
</td>
<td class="cellalignment1013" headers="r15c1-t11 r1c2-t11">
<p>Subtracts two intervals and stores the result in an interval</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510907">"OCIIntervalToNumber()"</a></p>
</td>
<td class="cellalignment1013" headers="r16c1-t11 r1c2-t11">
<p>Converts an interval to an Oracle <code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r17c1-t11" headers="r1c1-t11">
<p><a href="oci19map002.htm#i510940">"OCIIntervalToText()"</a></p>
</td>
<td class="cellalignment1013" headers="r17c1-t11 r1c2-t11">
<p>When given an interval, produces a string representing the interval</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i434059"></a>
<div id="LNOCI16847" class="sect1">
<h2 class="sect1">Number (OCINumber)<a id="sthref1869"></a><a id="sthref1870"></a></h2>
<p>The <code>OCINumber</code> data type is an opaque structure used to represent Oracle numeric data types (<code>NUMBER,</code> <code>FLOAT,</code> <code>DECIMAL</code>, and so forth). You can bind or define this type using the external typecode <code>SQLT_VNU</code> in the bind or define call.</p>
<p>Unless otherwise specified, the term <span class="italic">number</span> in these functions refers to a value of type <code>OCINumber</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map003.htm#CEGDBEBG">Table 19-11</a>for the prototypes and descriptions for all the OCI <code>NUMBER</code> functions</div>
<a id="i423538"></a>
<div id="LNOCI16848" class="sect2">
<h3 class="sect2">OCINumber Examples<a id="sthref1871"></a></h3>
<p>The code fragment in <a href="#BGBGDHIF">Example 12-3</a> shows how to manipulate an attribute of type <code>OCINumber</code>. The code fragment in <a href="#BGBBCHEC">Example 12-4</a> shows how to convert values in <code>OCINumber</code> format returned from <code>OCIDescribeAny()</code> calls to unsigned integers.</p>
<div id="LNOCI18247" class="example">
<p class="titleinexample"><a id="BGBGDHIF"></a>Example 12-3 Manipulating an Attribute of Type OCINumber</p>
<pre>
/* Example 1  */
struct person
{
OCINumber sal;
};
typedef struct person person;
OCIError *err;
person* steve;
person* scott;
person* jason;
OCINumber  *stevesal;
OCINumber  *scottsal;
OCINumber *debsal;
sword   status;
int     inum;
double  dnum;
OCINumber ornum;
text   buffer[21];
ub4     buflen;
sword   result;

/* For this example, assume OCIEnv and OCIError are initialized. */
/* For this example, assume that steve, scott, and jason are pointing to
  person objects that have been pinned in the object cache. */
stevesal = &amp;steve-&gt;sal;
scottsal = &amp;scott-&gt;sal;
debsal = &amp;jason-&gt;sal;

/* initialize steve's salary to be $12,000 */
inum = 12000;
status = OCINumberFromInt(err, &amp;inum, sizeof(inum), OCI_NUMBER_SIGNED,
    stevesal);
if (status != OCI_SUCCESS)  /* handle error from OCINumberFromInt */;

/* initialize scott's salary to be the same as steve's */
OCINumberAssign(err, stevesal, scottsal);

/* initialize jason's salary to be 20% more than steve's */
dnum = 1.2;
status = OCINumberFromReal(err, &amp;dnum, sizeof(dnum), &amp;ornum);
if (status != OCI_SUCCESS)  /* handle error from OCINumberFromReal */;
status = OCINumberMul(err, stevesal, &amp;ornum, debsal);
if (status != OCI_SUCCESS)  /* handle error from OCINumberMul */;

/* give scott a 50% raise */
dnum = 1.5;
status = OCINumberFromReal(err, &amp;dnum, sizeof(dnum), &amp;ornum);
if (status != OCI_SUCCESS)  /* handle error from OCINumberFromReal */;
status = OCINumberMul(err, scottsal, &amp;ornum, scottsal);
if (status != OCI_SUCCESS)  /* handle error from OCINumberMul */;

/* double steve's salary */
status = OCINumberAdd(err, stevesal, stevesal, stevesal);
if (status != OCI_SUCCESS)  /* handle error from OCINumberAdd */;

/* get steve's salary in integer */
status = OCINumberToInt(err, stevesal, sizeof(inum), OCI_NUMBER_SIGNED, &amp;inum);
if (status != OCI_SUCCESS)  /* handle error from OCINumberToInt */;

/* inum is set to 24000 */
/* get jason's salary in double */
status = OCINumberToReal(err, debsal, sizeof(dnum), &amp;dnum);
if (status != OCI_SUCCESS)  /* handle error from OCINumberToReal */;

/* dnum is set to 14400 */
/* print scott's salary as DEM0001'8000.00 */
buflen = sizeof(buffer);
status = OCINumberToText(err, scottsal, (text *)"C0999G9999D99", 13,
         (text *)"NLS_NUMERIC_CHARACTERS='.'' NLS_ISO_CURRENCY='Germany'",
         54, &amp;buflen, (text *)buffer);
if (status != OCI_SUCCESS)  /* handle error from OCINumberToText */;
printf("scott's salary = %s\n", buffer);

/* compare steve and scott's salaries */
status = OCINumberCmp(err, stevesal, scottsal, &amp;result);
if (status != OCI_SUCCESS)  /* handle error from OCINumberCmp */;

/* result is positive */
/* read jason's new salary from string */
status = OCINumberFromText(err, (text *)"48'000.00", 9, (text
*)"99G999D99", 9,
    (text *)"NLS_NUMERIC_CHARACTERS='.''", 27, debsal);
if (status != OCI_SUCCESS)  /* handle error from OCINumberFromText */;
/* jason's salary is now 48000.00 */
</pre></div>
<!-- class="example" -->
<p><a href="#BGBBCHEC">Example 12-4</a> shows how to convert a numeric type returned from an <code>OCIDescribeAny()</code> call in <code>OCINumber</code> format, such as <code>OCI_ATTR_MAX</code> or <code>OCI_ATTR_MIN</code>, to an unsigned C integer.</p>
<div id="LNOCI18248" class="example">
<p class="titleinexample"><a id="BGBBCHEC"></a>Example 12-4 Converting Values in OCINumber Format Returned from OCIDescribeAny() Calls to Unsigned Integers</p>
<pre>
/* Example 2 */
ub4  max_seq_val  = 0;
ub1 *max_valp     = NULL;
ub4  max_val_size;
OCINumber max_val;
    OCINumberSetZero(_errhp, &amp;max_val);
    OCIParam* parmdp = 0;
    status = OCIAttrGet ((void *)_dschp, (ub4)OCI_HTYPE_DESCRIBE, &amp;parmdp, 0,
                         (ub4)OCI_ATTR_PARAM, _errhp);
if (isError (status, _errhp))
{
return 0;
}
status = OCIAttrGet ((void *)parmdp, (ub4)OCI_DTYPE_PARAM, &amp;max_valp,
                     &amp;max_val_size, (ub4)OCI_ATTR_MAX, _errhp);
//create an OCINumber object from the ORACLE NUMBER FORMAT
max_val.OCINumberPart[0] = max_val_size; //set the length byte
memcpy(&amp;max_val.OCINumberPart[1], max_valp, max_val_size); //copy the actual bytes
//now convert max_val to an unsigned C integer, max_seq_val 
status = OCINumberToInt(_errhp, &amp;max_val, sizeof(max_seq_val),
                        OCI_NUMBER_UNSIGNED, &amp;max_seq_val);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421612"></a>
<div id="LNOCI16849" class="sect1">
<h2 class="sect1">Fixed or Variable-Length String (OCIString)<a id="sthref1872"></a><a id="sthref1873"></a></h2>
<p>Fixed or variable-length string data is represented to C programs as an <code>OCIString *</code>.</p>
<p>The length of the string does not include the NULL character.</p>
<p>For binding and defining variables of type <code>OCIString *</code> use the external typecode <code>SQLT_VST</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map006.htm#CEGGEHJF">Table 19-16</a> for the prototypes and descriptions for all the string functions</div>
<a id="i426866"></a>
<div id="LNOCI16850" class="sect2">
<h3 class="sect2">String Functions</h3>
<p><a href="#BGBJGFCA">Table 12-5</a> shows the functions that allow the C programmer to manipulate an instance of a string.</p>
<div id="LNOCI16851" class="tblformal">
<p class="titleintable"><a id="sthref1874"></a><a id="BGBJGFCA"></a>Table 12-5 String Functions</p>
<table class="cellalignment1016" title="String Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t14">Function</th>
<th class="cellalignment1012" id="r1c2-t14">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t14" headers="r1c1-t14">
<p><a href="oci19map006.htm#i430393">"OCIStringAllocSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c2-t14">
<p>Get allocated size of string memory in code points (Unicode) or bytes</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t14" headers="r1c1-t14">
<p><a href="oci19map006.htm#i460203">"OCIStringAssign()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c2-t14">
<p>Assign one string to another string</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t14" headers="r1c1-t14">
<p><a href="oci19map006.htm#i430380">"OCIStringAssignText()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c2-t14">
<p>Assign the source text string to the target string</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t14" headers="r1c1-t14">
<p><a href="oci19map006.htm#i517655">"OCIStringPtr()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c2-t14">
<p>Get a pointer to the text of a given string</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t14" headers="r1c1-t14">
<p><a href="oci19map006.htm#i430414">"OCIStringResize()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c2-t14">
<p>Resize the memory of a given string</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t14" headers="r1c1-t14">
<p><a href="oci19map006.htm#i458763">"OCIStringSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c2-t14">
<p>Get the size of a given string</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI16852" class="sect2"><a id="sthref1875"></a>
<h3 class="sect2">String Example<a id="sthref1876"></a></h3>
<p><a href="#BGBGFBCB">Example 12-5</a> assigns a text string to a string, then gets a pointer to the string part of the string, and the string size, and prints it out.</p>
<p>Note the double indirection used in passing the <code><span class="codeinlineitalic">vstring1</span></code> parameter in <a href="oci19map006.htm#i430380">OCIStringAssignText()</a>.</p>
<div id="LNOCI18249" class="example">
<p class="titleinexample"><a id="BGBGFBCB"></a>Example 12-5 Manipulating an Attribute of Type OCIString</p>
<pre>
OCIEnv       *envhp;
OCIError     *errhp;
OCIString     *vstring1 = (OCIString *)0;
OCIString     *vstring2 = (OCIString *)0;
text          c_string[20];
text         *text_ptr;
sword        status;

strcpy((char *)c_string, "hello world");
/* Assign a text string to an OCIString */
status = OCIStringAssignText(envhp, errhp, c_string,
      (ub4)strlen((char *)c_string),&amp;vstring1);
/* Memory for vstring1 is allocated as part of string assignment */

status = OCIStringAssignText(envhp, errhp, (text *)"hello again",
       (ub4)strlen("This is a longer string."),&amp;vstring1);
/* vstring1 is automatically resized to store the longer string */

/* Get a pointer to the string part of vstring1 */
text_ptr = OCIStringPtr(envhp, vstring1);
/* text_ptr now points to "hello world" */
printf("%s\n", text_ptr);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421681"></a>
<div id="LNOCI16853" class="sect1">
<h2 class="sect1">Raw (OCIRaw)<a id="sthref1877"></a><a id="sthref1878"></a></h2>
<p>Variable-length raw data is represented in C using the <code>OCIRaw *</code> data type.</p>
<p>For binding and defining variables of type <code>OCIRaw *</code>, use the external typecode <code>SQLT_LVB</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map004.htm#CEGGJJID">Table 19-14</a> for the prototypes and descriptions for all the raw functions</div>
<a id="i423925"></a>
<div id="LNOCI16854" class="sect2">
<h3 class="sect2">Raw Functions</h3>
<p><a href="#BGBHAFCB">Table 12-6</a> shows the functions that perform OCIRaw operations.</p>
<div id="LNOCI16855" class="tblformal">
<p class="titleintable"><a id="sthref1879"></a><a id="BGBHAFCB"></a>Table 12-6 Raw Functions</p>
<table class="cellalignment1016" title="Raw Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t16">Function</th>
<th class="cellalignment1012" id="r1c2-t16">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t16" headers="r1c1-t16">
<p><a href="oci19map004.htm#i460204">"OCIRawAllocSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t16 r1c2-t16">
<p>Get the allocated size of raw memory in bytes</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t16" headers="r1c1-t16">
<p><a href="oci19map004.htm#i450861">"OCIRawAssignBytes()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t16 r1c2-t16">
<p>Assign raw data (ub1 *) to OCIRaw *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t16" headers="r1c1-t16">
<p><a href="oci19map004.htm#i450893">"OCIRawAssignRaw()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t16 r1c2-t16">
<p>Assign one OCIRaw * to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t16" headers="r1c1-t16">
<p><a href="oci19map004.htm#i450924">"OCIRawPtr()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t16 r1c2-t16">
<p>Get pointer to raw data</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t16" headers="r1c1-t16">
<p><a href="oci19map004.htm#i450943">"OCIRawResize()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t16 r1c2-t16">
<p>Resize memory of variable-length raw data</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t16" headers="r1c1-t16">
<p><a href="oci19map004.htm#i458762">"OCIRawSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t16 r1c2-t16">
<p>Get size of raw data</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI16856" class="sect2"><a id="sthref1880"></a>
<h3 class="sect2">Raw Example<a id="sthref1881"></a></h3>
<p><a href="#BGBJFAHI">Example 12-6</a> shows how to set up a raw data block and obtain a pointer to its data.</p>
<p>Note the double indirection in the call to <a href="oci19map004.htm#i450861">OCIRawAssignBytes()</a>.</p>
<div id="LNOCI18250" class="example">
<p class="titleinexample"><a id="BGBJFAHI"></a>Example 12-6 Manipulating an Attribute of Type OCIRaw</p>
<pre>
OCIEnv      *envhp;
OCIError    *errhp;
sword       status;
ub1         data_block[10000];
ub4         data_block_len = 10000;
OCIRaw      *raw1 = (OCIRaw *) 0;
ub1 *raw1_pointer;

/* Set up the RAW */
/* assume 'data_block' has been initialized */
status = OCIRawAssignBytes(envhp, errhp, data_block, data_block_len,
&amp;raw1);

/* Get a pointer to the data part of the RAW */
raw1_pointer = OCIRawPtr(envhp, raw1);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i421736"></a>
<div id="LNOCI16857" class="sect1">
<h2 class="sect1">Collections (OCITable, OCIArray, OCIColl, OCIIter)<a id="sthref1882"></a><a id="sthref1883"></a><a id="sthref1884"></a><a id="sthref1885"></a><a id="sthref1886"></a><a id="sthref1887"></a><a id="sthref1888"></a><a id="sthref1889"></a><a id="sthref1890"></a></h2>
<p>Oracle Database provides two types of collections: variable-length arrays (<code><a id="sthref1891"></a>varray</code>s) and nested tables. In C applications, varrays are represented as <code>OCIArray *</code>, and nested tables are represented as <code>OCITable *</code>. Both of these data types (along with <code>OCIColl</code> and <code>OCIIter</code>, described later) are opaque structures.</p>
<p>A variety of generic collection functions enable you to manipulate collection data. You can use these functions on both varrays and nested tables. In addition, there is a set of functions specific to nested tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i436885">"Nested Table Manipulation Functions"</a></div>
<p>You can allocate an instance of a varray or nested table using <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> and free it using <a href="oci18nav005.htm#i430212">OCIObjectFree()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map001.htm#CEGGDJBE">"OCI Collection and Iterator Functions"</a> for the prototypes and descriptions for these functions</div>
<div id="LNOCI16858" class="sect2"><a id="sthref1892"></a>
<h3 class="sect2">Generic Collection Functions<a id="sthref1893"></a></h3>
<p>Oracle Database provides two types of collections: variable-length arrays (varrays) and nested tables. Both varrays and nested tables can be viewed as subtypes of a generic collection type.</p>
<p>In C, a generic collection is represented as <code>OCIColl *</code>, a varray is represented as <code>OCIArray *</code>, and a nested table is represented as <code>OCITable *</code><span class="italic">.</span> Oracle provides a set of functions to operate on generic collections (such as <code>OCIColl *</code>). These functions start with the prefix <code>OCIColl</code>, as in <code>OCICollGetElem()</code>. The <code>OCIColl*()</code> functions can also be called to operate on varrays and nested tables.</p>
<p>The generic collection functions are grouped into two main categories:</p>
<ul>
<li>
<p>Manipulating varray or nested table data</p>
</li>
<li>
<p>Scanning through a collection with a collection iterator</p>
</li>
</ul>
<p>The generic collection functions represent a complete set of functions for manipulating varrays. Additional functions are provided to operate specifically on nested tables. They are identified by the prefix <code>OCITable</code>, as in <a href="oci19map007.htm#i460202">OCITableExists()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i436885">"Nested Table Manipulation Functions"</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Indexes passed to collection functions are zero-based.</div>
</div>
<!-- class="sect2" -->
<a id="i424004"></a>
<div id="LNOCI16859" class="sect2">
<h3 class="sect2">Collection Data Manipulation Functions<a id="sthref1894"></a></h3>
<p><a href="#BGBIHHEI">Table 12-7</a> shows the generic functions that manipulate collection data.</p>
<div id="LNOCI16860" class="tblformal">
<p class="titleintable"><a id="sthref1895"></a><a id="BGBIHHEI"></a>Table 12-7 Collection Functions</p>
<table class="cellalignment1016" title="Collection Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t21">Function</th>
<th class="cellalignment1012" id="r1c2-t21">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i448982">"OCICollAppend()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t21 r1c2-t21">
<p>Append an element to the end of a collection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i524110">"OCICollAssign()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t21 r1c2-t21">
<p>Assign one collection to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i457193">"OCICollAssignElem()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t21 r1c2-t21">
<p>Assign element at given index</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i449838">"OCICollGetElem()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t21 r1c2-t21">
<p>Get pointer to an element when given its index</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i526117">"OCICollGetElemArray()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t21 r1c2-t21">
<p>Get array of elements from a collection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i476415">"OCICollIsLocator()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t21 r1c2-t21">
<p>Indicate whether a collection is locator-based or not</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i449873">"OCICollMax()"</a></p>
</td>
<td class="cellalignment1013" headers="r8c1-t21 r1c2-t21">
<p>Get upper bound of collection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i449891">"OCICollSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r9c1-t21 r1c2-t21">
<p>Get current size of collection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t21" headers="r1c1-t21">
<p><a href="oci19map001.htm#i449909">"OCICollTrim()"</a></p>
</td>
<td class="cellalignment1013" headers="r10c1-t21 r1c2-t21">
<p>Trim <span class="italic">n</span> elements from the end of the collection</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i421787"></a>
<div id="LNOCI16861" class="sect2">
<h3 class="sect2">Collection Scanning Functions<a id="sthref1896"></a></h3>
<p><a href="#BGBIJHJD">Table 12-8</a> shows the generic functions that enable you to scan collections with a collection iterator. The iterator is of type <code>OCIIter</code>, and is created by first calling <a href="oci19map001.htm#i499885">OCIIterCreate()</a>.</p>
<div id="LNOCI16862" class="tblformal">
<p class="titleintable"><a id="sthref1897"></a><a id="BGBIJHJD"></a>Table 12-8 Collection Scanning Functions</p>
<table class="cellalignment1016" title="Collection Scanning Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t22">Function</th>
<th class="cellalignment1012" id="r1c2-t22">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t22" headers="r1c1-t22">
<p><a href="oci19map001.htm#i499885">"OCIIterCreate()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t22 r1c2-t22">
<p>Create an iterator to scan the elements of a collection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t22" headers="r1c1-t22">
<p><a href="oci19map001.htm#i499922">"OCIIterDelete()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t22 r1c2-t22">
<p>Delete a collection iterator</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t22" headers="r1c1-t22">
<p><a href="oci19map001.htm#i499958">"OCIIterGetCurrent()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t22 r1c2-t22">
<p>Get a pointer to the current element pointed to by the iterator</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t22" headers="r1c1-t22">
<p><a href="oci19map001.htm#i499993">"OCIIterInit()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t22 r1c2-t22">
<p>Initialize an iterator to scan the given collection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t22" headers="r1c1-t22">
<p><a href="oci19map001.htm#i500027">"OCIIterNext()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t22 r1c2-t22">
<p>Get a pointer to the next iterator collection element</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t22" headers="r1c1-t22">
<p><a href="oci19map001.htm#i500070">"OCIIterPrev()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t22 r1c2-t22">
<p>Get pointer to the previous iterator collection element</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI16863" class="sect2"><a id="sthref1898"></a>
<h3 class="sect2">V<a id="sthref1899"></a>array/Collection Iterator Example<a id="sthref1900"></a><a id="sthref1901"></a></h3>
<p><a href="#BGBHJDDD">Example 12-7</a> creates and uses a collection iterator to scan through a varray.</p>
<div id="LNOCI18251" class="example">
<p class="titleinexample"><a id="BGBHJDDD"></a>Example 12-7 Using Collection Data Manipulation Functions</p>
<pre>
OCIEnv       *envhp;
OCIError     *errhp;
text         *text_ptr;
sword        status;
OCIArray     *clients;
OCIString    *client_elem;
OCIIter      *iterator;
boolean      eoc;
void         *elem;
OCIInd       *elemind;

/* Assume envhp, errhp have been initialized */
/* Assume clients points to a varray */

/* Print the elements of clients */
/* To do this, create an iterator to scan the varray */
status = OCIIterCreate(envhp, errhp, clients, &amp;iterator);

/* Get the first element of the clients varray */
printf("Clients' list:\n");
status = OCIIterNext(envhp, errhp, iterator, &amp;elem,
                    (void  **) &amp;elemind, &amp;eoc);

while (!eoc &amp;&amp; (status == OCI_SUCCESS))
{
  client_elem = *((OCIString **)elem);
                             /* client_elem points to the string */

 /*
    the element pointer type returned by OCIIterNext() through 'elem' is

    the same as that of OCICollGetElem(). See OCICollGetElem() for
    details.  */

  /*
    client_elem points to an OCIString descriptor, so to print it out,
    get a pointer to where the text begins
  */
  text_ptr = OCIStringPtr(envhp, client_elem);

  /*
    text_ptr now points to the text part of the client OCIString, which
is a
NULL-terminated string
  */
  printf("  %s\n", text_ptr);
  status = OCIIterNext(envhp, errhp, iterator, &amp;elem,
                      (void  **)&amp;elemind, &amp;eoc);
}

if (status != OCI_SUCCESS)
{
  /* handle error */
}

/* destroy the iterator */
status = OCIIterDelete(envhp, errhp, &amp;iterator);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i436885"></a>
<div id="LNOCI16864" class="sect2">
<h3 class="sect2">Nested Table Manipulation Functions<a id="sthref1902"></a></h3>
<p>As its name implies, one table may be <span class="italic">nested,</span> or contained within another, as a variable, attribute, parameter, or column. Nested tables may have elements deleted by the <a href="oci19map007.htm#i454295">OCITableDelete()</a> function.</p>
<p>For example, suppose a table is created with 10 elements, and <a href="oci19map007.htm#i454295">OCITableDelete()</a> is used to delete elements at index 0 through 4 and 9. The first existing element is now element 5, and the last existing element is element 8.</p>
<p>As noted previously, the generic collection functions may be used to map to and manipulate nested tables. In addition, <a href="#BGBBDIAI">Table 12-9</a> shows the functions that are specific to nested tables. They should not be used on varrays.</p>
<div id="LNOCI16865" class="tblformal">
<p class="titleintable"><a id="sthref1903"></a><a id="BGBBDIAI"></a>Table 12-9 Nested Table Functions</p>
<table class="cellalignment1016" title="Nested Table Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t23">Function</th>
<th class="cellalignment1012" id="r1c2-t23">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i454295">"OCITableDelete()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t23 r1c2-t23">
<p>Delete an element at a given index</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i460202">"OCITableExists()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t23 r1c2-t23">
<p>Test whether an element exists at a given index</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i450567">"OCITableFirst()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t23 r1c2-t23">
<p>Return the index for the first existing element of a table</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i450671">"OCITableLast()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t23 r1c2-t23">
<p>Return the index for the last existing element of a table</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i450702">"OCITableNext()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t23 r1c2-t23">
<p>Return the index for the next existing element of a table</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i450740">"OCITablePrev()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t23 r1c2-t23">
<p>Return the index for the previous existing element of a table</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t23" headers="r1c1-t23">
<p><a href="oci19map007.htm#i450779">"OCITableSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r8c1-t23 r1c2-t23">
<p>Return the table size, not including any deleted elements</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="LNOCI16866" class="sect3"><a id="sthref1904"></a>
<h4 class="sect3">Nested Table Element Ordering<a id="sthref1905"></a></h4>
<p>When a nested table is fetched into the object cache, its elements are given a transient ordering, numbered from zero to the number of elements, minus 1. For example, a table with 40 elements would be numbered from 0 to 39.</p>
<p>You can use these position ordinals to fetch and assign the values of elements (for example, fetch to element <span class="italic">i</span>, or assign to element <span class="italic">j</span>, where <span class="italic">i</span> and <span class="italic">j</span> are valid position ordinals for the given table).</p>
<p>When the table is copied back to the database, its transient ordering is lost. Delete operations may be performed against elements of the table. Delete operations create transient <span class="italic">holes</span>; that is, they do not change the position ordinals of the remaining table elements.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16867" class="sect2"><a id="sthref1906"></a>
<h3 class="sect2">Nested Table Locators</h3>
<p>You can retrieve a locator to a nested table. A locator is like a handle to a collection value, and it contains information about the database snapshot that exists at the time of retrieval. This snapshot information helps the database retrieve the correct instantiation of a collection value at a later time when collection elements are fetched using the locator.</p>
<p>Unlike a LOB locator, a collection locator cannot be used to modify a collection instance; it only locates the correct data. Using the locator enables an application to return a handle to a nested table without having to retrieve the entire collection, which may be quite large.</p>
<p>A user specifies when a table is created if a locator should be returned when a collection column or attribute is fetched, using the <code>RETURN</code> <code>AS</code> <code>LOCATOR</code> specification.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF53401" href="../../server.112/e41084/statements_3001.htm#SQLRF53401"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<p>You can use the <a href="oci19map001.htm#i476415">OCICollIsLocator()</a> function to determine whether a collection is locator-based or not.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i436452"></a>
<div id="LNOCI16868" class="sect1">
<h2 class="sect1"><a id="sthref1907"></a>Multilevel Collection Types</h2>
<p>The collection element itself can be directly or indirectly another collection type. Multilevel collection type is the name given to such a top-level collection type.</p>
<p>Multilevel collections have the following characteristics:</p>
<ul>
<li>
<p>They can be collections of other collection types.</p>
</li>
<li>
<p>They can be collections of objects with collection attributes.</p>
</li>
<li>
<p>They have no limit to the number of nesting levels.</p>
</li>
<li>
<p>They can contain any combination of varrays and nested tables.</p>
</li>
<li>
<p>They can be used as columns in tables.</p>
</li>
</ul>
<p>OCI routines work with multilevel collections. The following routines can return in parameter <code><span class="codeinlineitalic">*elem</span></code> an <code>OCIColl*</code>, which you can use in any of the collection routines:</p>
<ul>
<li>
<p><a href="oci19map001.htm#i449838">OCICollGetElem()</a></p>
</li>
<li>
<p><a href="oci19map001.htm#i499958">OCIIterGetCurrent()</a></p>
</li>
<li>
<p><a href="oci19map001.htm#i500027">OCIIterNext()</a></p>
</li>
<li>
<p><a href="oci19map001.htm#i500070">OCIIterPrev()</a></p>
</li>
</ul>
<p>The following functions take a collection element and add it to an existing collection. Parameter <code><span class="codeinlineitalic">elem</span></code> could be an <code>OCIColl*</code> if the element type is another collection:</p>
<ul>
<li>
<p><a href="oci19map001.htm#i457193">OCICollAssignElem()</a></p>
</li>
<li>
<p><a href="oci19map001.htm#i448982">OCICollAppend()</a></p>
</li>
</ul>
<div id="LNOCI16869" class="sect2"><a id="sthref1908"></a>
<h3 class="sect2">Multilevel Collection Type Example</h3>
<p>The following types and tables are used for <a href="#BGBFCBDE">Example 12-8</a>.</p>
<pre>
type_1 (a NUMBER, b NUMBER)
NT1 TABLE OF type_1
NT2 TABLE OF NT1
</pre>
<p>The code fragment in <a href="#BGBFCBDE">Example 12-8</a> iterates over the multilevel collection.</p>
<div id="LNOCI18252" class="example">
<p class="titleinexample"><a id="BGBFCBDE"></a>Example 12-8 Using Multilevel Collection Data Manipulation Functions</p>
<pre>
...
OCIColl *outer_coll;
OCIColl *inner_coll;
OCIIter *itr1, *itr2;
Type_1 *type_1_instance;
..
/* assume that outer_coll points to a valid coll of type NT2 */
checkerr(errhp, OCIIterCreate(envhp, errhp, outer_coll, &amp;itr1));
for(eoc = FALSE;!OCIIterNext(envhp, errhp, itr1, (void  **) &amp;elem,
                               (void  **) &amp;elem_null, &amp;eoc) &amp;&amp; !eoc;)
{
   inner_coll = (OCIColl *)elem;
   /* iterate over inner collection.. */
   checkerr(errhp, OCIIterCreate(envhp, errhp, inner_coll, &amp;itr2));
   for(eoc2 = FALSE;!OCIIterNext(envhp, errhp, itr2, (void  **)&amp;elem2,
              (void  **) &amp;elem2_null, &amp;eoc2) &amp;&amp; !eoc2;)
       {
        type_1_instance = (Type_1 *)elem2;
        /* use the fields of type_1_instance */
       }
   /* close iterator over inner collection */
   checkerr(errhp, OCIIterDelete(envhp, errhp, &amp;itr2));
}
/* close iterator over outer collection */
checkerr(errhp, OCIIterDelete(envhp, errhp, &amp;itr1));
...
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i426837"></a>
<div id="LNOCI16870" class="sect1">
<h2 class="sect1">REF (OCIRef)<a id="sthref1909"></a><a id="sthref1910"></a></h2>
<p>A <code>REF</code> (reference) is an identifier to an object. It is an opaque structure that uniquely locates the object. An object may point to another object by way of a <code>REF</code>.</p>
<p>In C applications, the <code>REF</code> is represented by <code>OCIRef*</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci19map005.htm#CEGIBDHA">Table 19-15</a> for the prototypes and descriptions for all the <code>REF</code> manipulation functions</div>
<a id="i423965"></a>
<div id="LNOCI16871" class="sect2">
<h3 class="sect2">REF Manipulation Functions</h3>
<p><a href="#BGBFDGIJ">Table 12-10</a> shows the functions that perform <code>REF</code> operations.</p>
<div id="LNOCI16872" class="tblformal">
<p class="titleintable"><a id="sthref1911"></a><a id="BGBFDGIJ"></a>Table 12-10 REF Manipulation Functions</p>
<table class="cellalignment1016" title="REF Manipulation Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t26">Function</th>
<th class="cellalignment1012" id="r1c2-t26">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i445077">"OCIRefAssign()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t26 r1c2-t26">
<p>Assign one <code>REF</code> to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i430265">"OCIRefClear()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t26 r1c2-t26">
<p>Clear or nullify a <code>REF</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i445081">"OCIRefFromHex()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t26 r1c2-t26">
<p>Convert a hexadecimal string to a <code>REF</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i449064">"OCIRefHexSize()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t26 r1c2-t26">
<p>Return the size of a hexadecimal string representation of <code>REF</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i451016">"OCIRefIsEqual()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t26 r1c2-t26">
<p>Compare two <code>REF</code>s for equality</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i448096">"OCIRefIsNull()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t26 r1c2-t26">
<p>Test whether a <code>REF</code> is <code>NULL</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t26" headers="r1c1-t26">
<p><a href="oci19map005.htm#i460201">"OCIRefToHex()"</a></p>
</td>
<td class="cellalignment1013" headers="r8c1-t26 r1c2-t26">
<p>Convert a <code>REF</code> to a hexadecimal string</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI16873" class="sect2"><a id="sthref1912"></a>
<h3 class="sect2">REF Example<a id="sthref1913"></a></h3>
<p><a href="#BGBBAIHG">Example 12-9</a> tests two <code>REF</code>s for <code>NULL</code>, compares them for equality, and assigns one <code>REF</code> to another. Note the double indirection in the call to <a href="oci19map005.htm#i445077">OCIRefAssign()</a>.</p>
<div id="LNOCI18253" class="example">
<p class="titleinexample"><a id="BGBBAIHG"></a>Example 12-9 Using REF Manipulation Functions</p>
<pre>
OCIEnv       *envhp;
OCIError     *errhp;
sword        status;
boolean      refs_equal;
OCIRef       *ref1, *ref2;

/* assume REFs have been initialized to point to valid objects */
/*Compare two REFs for equality */
refs_equal = OCIRefIsEqual(envhp, ref1, ref2);
printf("After first OCIRefIsEqual:\n");
if(refs_equal)
   printf("REFs equal\n");
else
   printf("REFs not equal\n");

/*Assign ref1 to ref2 */
status = OCIRefAssign (envhp, errhp, ref1, &amp;ref2);
if(status != OCI_SUCCESS)
/*error handling*/

/*Compare the two REFs again for equality */
refs_equal = OCIRefIsEqual(envhp, ref1, ref2);
printf("After second OCIRefIsEqual:\n");
if(refs_equal)
   printf("REFs equal\n");
else
   printf("REFs not equal\n");
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i426966"></a>
<div id="LNOCI16874" class="sect1">
<h2 class="sect1">Object Type Information Storage and Access</h2>
<p>The OCI data types and type descriptors are discussed in this section.</p>
<a id="i426973"></a>
<div id="LNOCI16875" class="sect2">
<h3 class="sect2">Descriptor Objects<a id="sthref1914"></a><a id="sthref1915"></a><a id="sthref1916"></a></h3>
<p><span class="bold"><a id="sthref1917"></a><a id="sthref1918"></a><a id="sthref1919"></a><a id="sthref1920"></a><a id="sthref1921"></a><a id="sthref1922"></a><a id="sthref1923"></a><a id="sthref1924"></a></span>When a given type is created with the <code>CREATE TYPE</code> statement, it is stored in the server and associated with a type descriptor object (TDO). In addition, the database stores descriptor objects for each data attribute of the type, each method of the type, each parameter of each method, and the results returned by methods. <a href="#BGBBFIHG">Table 12-11</a> lists the OCI data types associated with each type of descriptor object.</p>
<div id="LNOCI16876" class="tblformal">
<p class="titleintable"><a id="sthref1925"></a><a id="BGBBFIHG"></a>Table 12-11 Descriptor Objects</p>
<table class="cellalignment1016" title="Descriptor Objects " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t27">Information Type</th>
<th class="cellalignment1012" id="r1c2-t27">OCI Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t27" headers="r1c1-t27">
<p>Type</p>
</td>
<td class="cellalignment1013" headers="r2c1-t27 r1c2-t27">
<p>OCIType</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t27" headers="r1c1-t27">
<p>Type Attributes Collection Elements Method Parameters Method Results</p>
</td>
<td class="cellalignment1013" headers="r3c1-t27 r1c2-t27">
<p>OCITypeElem</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t27" headers="r1c1-t27">
<p>Method</p>
</td>
<td class="cellalignment1013" headers="r4c1-t27 r1c2-t27">
<p>OCITypeMethod</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Several OCI functions (including <a href="oci16rel003.htm#i444090">OCIBindObject()</a> and <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>) require a TDO as an input parameter. An application can obtain the TDO by calling <a href="oci18nav006.htm#i455564">OCITypeByName()</a>, which gets the type's TDO in an <code>OCIType</code> variable. Once you obtain the TDO, you can pass it, as necessary, to other calls.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i435657"></a>
<div id="LNOCI16877" class="sect1">
<h2 class="sect1"><a id="sthref1926"></a><a id="sthref1927"></a><a id="sthref1928"></a>AnyType, AnyData, and AnyDataSet Interfaces</h2>
<p>The AnyType, AnyData, and AnyDataSet interfaces allow you to model self-descriptive data. You can store heterogeneous data types in the same column and query the type of data in an application.</p>
<p>These definitions are used in the discussion in the following sections:</p>
<ul>
<li>
<p><span class="italic">Persistent types.</span> Types that are created using the SQL statement <code>CREATE TYPE</code>. They are stored persistently in the database.</p>
</li>
<li>
<p><span class="italic">Transient types.</span> Anonymous type descriptions that are not stored persistently in the database. They are created by programs as needed. They are useful for exchanging type information, if necessary, between various components of an application in a dynamic fashion.</p>
</li>
<li>
<p><span class="italic">Self-descriptive data.</span> Data encapsulating type information with its actual contents. The <code>OCIAnyData</code> data type models such data in OCI. A data value of most SQL types can be converted to an OCIAnyData that can then be converted back to the old data value. The type <code>SYS.ANYDATA</code> models such data in SQL or PL/SQL.</p>
</li>
<li>
<p><span class="italic">Self-descriptive dataset.</span> Encapsulation of a set of data instances (all of the same type) along with their type description. They should all have the same type description. The <code>OCIDataAnySet</code> data type models this data in OCI. The type <code>SYS.ANYDATASET</code> models such data in SQL or PL/SQL.</p>
</li>
</ul>
<p>Interfaces are available in both OCI (C language) and in SQL and PL/SQL for constructing and manipulating these type descriptions and self-descriptive data. The following sections describe the relevant OCI interfaces.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci11obj.htm#i442662">"Persistent Objects, Transient Objects, and Values"</a></p>
</li>
<li>
<p><a class="olink SQLRF30022" href="../../server.112/e41084/sql_elements001.htm#SQLRF30022"><span class="italic">Oracle Database SQL Language Reference</span></a> for an overview in the section about Oracle-supplied types</p>
</li>
</ul>
</div>
<div id="LNOCI16878" class="sect2"><a id="sthref1929"></a>
<h3 class="sect2">Type Interfaces</h3>
<p>You can use the type interfaces to construct named and anonymous transient object types (structured with attributes) and collection types. Use the <a href="oci21any001.htm#i521669">OCITypeBeginCreate()</a> call to begin type construction of transient object types and collection types (the typecode parameter determines which one is being constructed).</p>
<p>You must allocate a parameter handle using <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a>. Subsequently, you set type information (for attributes of an object type and for the collection element's type) by using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>. For object types, as shown in <a href="#BGBEEFJE">Example 12-10</a>, use <a href="oci21any001.htm#i518663">OCITypeAddAttr()</a> to add the attribute information to the type. After adding information for the last attribute, you must call <a href="oci21any001.htm#i521680">OCITypeEndCreate()</a>.</p>
<div id="LNOCI18254" class="example">
<p class="titleinexample"><a id="BGBEEFJE"></a>Example 12-10 Using Type Interfaces to Construct Object Types</p>
<pre>
OCITypeBeginCreate( ...)        /* Begin Type Creation */
OCIDescriptorAlloc(...)
OCIAttrSet(...)
OCITypeAddAttr(...)             /* Add attribute 1 */
OCIAttrSet(...)
OCITypeAddAttr(...)             /* Add attribute 2 */
...
OCITypeEndCreate(...)           /* End Type Creation */
</pre></div>
<!-- class="example" -->
<p>For collection types, as shown in <a href="#BGBBFBFI">Example 12-11</a>, use <a href="oci21any001.htm#i521697">OCITypeSetCollection()</a> to set the information on the collection element type. Subsequently, call <a href="oci21any001.htm#i521680">OCITypeEndCreate()</a> to finish construction.</p>
<div id="LNOCI18255" class="example">
<p class="titleinexample"><a id="BGBBFBFI"></a>Example 12-11 Using Type Interfaces to Construct Collection Types</p>
<pre>
OCITypeBeginCreate( ...)        /* Begin Type Creation */
OCIDescriptorAlloc(...)
OCIAttrSet(...)
OCITypeSetCollection(...)       /* Set information on collection element */
OCITypeEndCreate(...)           /* End Type Creation */
</pre></div>
<!-- class="example" -->
<p>You can use the <code>OCIDescribeAny()</code> call to obtain the <code>OCIType</code> corresponding to a persistent type.</p>
<div id="LNOCI16879" class="sect3"><a id="sthref1930"></a>
<h4 class="sect3">Creating a Parameter Descriptor for OCIType Calls</h4>
<p>You can use the <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a> call to allocate an <code>OCIParam</code> (with the parent handle being the environment handle). Subsequently, you can call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> with the following allowed attribute types to set relevant type information:</p>
<ul>
<li>
<p><code>OCI_ATTR_PRECISION</code></p>
</li>
</ul>
<p>To set numeric precision. Pass a <code>(ub1 *)</code> attribute value to the buffer holding the precision value.</p>
<ul>
<li>
<p><code>OCI_ATTR_SCALE</code></p>
</li>
</ul>
<p>To set numeric scale. Pass a <code>(sb1 *)</code> attribute value to the buffer that is holding the scale value.</p>
<ul>
<li>
<p><code>OCI_ATTR_CHARSET_ID</code></p>
</li>
</ul>
<p>To set the character set ID for character types. Pass a <code>(ub2 *)</code> attribute value to the buffer holding the char set ID.</p>
<ul>
<li>
<p><code>OCI_ATTR_CHARSET_FORM</code></p>
</li>
</ul>
<p>To set the character set form for character types. Pass a <code>(ub1 *)</code> attribute value to the buffer holding the character set form value.</p>
<ul>
<li>
<p><code>OCI_ATTR_DATA_SIZE</code></p>
</li>
</ul>
<p>Length of <code>VARCHAR2</code>, <code>RAW</code>, and so on. Pass a <code>(ub2 *)</code> attribute value to the buffer holding the length.</p>
<ul>
<li>
<p><code>OCI_ATTR_TYPECODE</code></p>
</li>
</ul>
<p>To set typecode. Pass a <code>(ub2 *)</code> attribute value to the buffer holding the typecode. This attribute must be set first.</p>
<ul>
<li>
<p><code>OCI_ATTR_TDO</code></p>
</li>
</ul>
<p>To set <code>OCIType</code> of an object or collection attribute. Pass an <code>(OCIType *)</code> attribute value to the <code>OCIType</code> corresponding to the attribute. Ensure that the <code>OCIType</code> is pinned when this <code>OCIParam</code> is used during <code>AnyType</code> construction. If it is a transient type attribute, its allocation duration should be at least as much as the top-level <code>OCIType</code> being created. Otherwise, an exception is returned.</p>
<ul>
<li>
<p>For built-in types, the following typecodes are acceptable (permissible values for <code>OCI_ATTR_TYPECODE</code>) for SQL type attributes:</p>
<p><code>OCI_TYPECODE_DATE</code>, <code>OCI_TYPECODE_NUMBER</code>,</p>
<p><code>OCI_TYPECODE_VARCHAR</code>, <code>OCI_TYPECODE_RAW</code>,</p>
<p><code>OCI_TYPECODE_CHAR</code>, <code>OCI_TYPECODE_VARCHAR2</code>,</p>
<p><code>OCI_TYPECODE_VARCHAR</code>, <code>OCI_TYPECODE_BLOB</code>,</p>
<p><code>OCI_TYPECODE_BFILE</code>, <code>OCI_TYPECODE_CLOB</code>,</p>
<p><code>OCI_TYPECODE_TIMESTAMP</code>, <code>OCI_TYPECODE_TIMESTAMP_TZ</code>,</p>
<p><code>OCI_TYPECODE_TIMESTAMP_LTZ</code>,</p>
<p><code>OCI_TYPECODE_INTERVAL_YM</code>, and <code>OCI_TYPECODE_INTERVAL_DS</code>.</p>
</li>
<li>
<p>If the attribute or collection element type is itself another transient type, set <code>OCI_ATTR_TYPECODE</code> to <code>OCI_TYPECODE_OBJECT</code> or <code>OCI_TYPECODE_REF</code> (for <code>REF</code>s) or <code>OCI_TYPECODE_VARRAY</code> or <code>OCI_TYPECODE_TABLE</code> and set the <code>OCI_ATTR_TDO</code> to the <code>OCIType</code> corresponding to the transient type.</p>
</li>
<li>
<p>For user-defined type attributes, the permissible values for <code>OCI_ATTR_TYPECODE</code> are:</p>
<ul>
<li>
<p><code>OCI_TYPECODE_OBJECT</code> (for an Object Type)</p>
</li>
<li>
<p><code>OCI_TYPECODE_REF</code> (for a <code>REF</code> type)</p>
</li>
<li>
<p>and <code>OCI_TYPECODE_VARRAY</code> or <code>OCI_TYPECODE_TABLE</code> (for collections)</p>
</li>
</ul>
<p>The <code>OCI_ATTR_TDO</code> should be set in these cases to the appropriate user-defined type's <code>OCIType</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16880" class="sect3"><a id="sthref1931"></a>
<h4 class="sect3">Obtaining the OCIType for Persistent Types</h4>
<p>You can use the <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> call to obtain the <code>OCIType</code> corresponding to a persistent type, as in the following example:</p>
<pre>
OCIDescribeAny(svchp, errhp. (void  *)"HR.EMPLOYEES",
               (ub4)strlen("HR.EMPLOYEES"),
               (ub1)OCI_OTYPE_NAME, (ub1)OCI_DEFAULT, OCI_PTYPE_TYPE, dschp);
</pre>
<p>From the describe handle (<code><span class="codeinlineitalic">dschp</span></code>), you can use <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> calls to obtain the <code>OCIType</code>.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16881" class="sect3"><a id="sthref1932"></a>
<h4 class="sect3">Type Access Calls</h4>
<p><a href="oci16rel003.htm#i455723">OCIDescribeAny()</a> can be called with these transient type descriptions for a dynamic description of the type. The <code>OCIType</code> pointer can be passed directly to <code>OCIDescribeAny()</code> (with <code><span class="codeinlineitalic">objtype</span></code> set to <code>OCI_OTYPE_PTR</code>). This provides a way to obtain attribute information by name and position.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16882" class="sect3"><a id="sthref1933"></a>
<h4 class="sect3">Extensions to OCIDescribeAny()</h4>
<p>For transient types that represent built-in types (created with a built-in typecode), the parameter handle that describes these types (which are of type <code>OCI_PTYPE_TYPE</code>) supports the following extra attributes:</p>
<ul>
<li>
<p><code>OCI_ATTR_DATA_SIZE</code></p>
</li>
<li>
<p><code>OCI_ATTR_TYPECODE</code></p>
</li>
<li>
<p><code>OCI_ATTR_DATA_TYPE</code></p>
</li>
<li>
<p><code>OCI_ATTR_PRECISION</code></p>
</li>
<li>
<p><code>OCI_ATTR_SCALE</code></p>
</li>
<li>
<p><code>OCI_ATTR_CHARSET_ID</code></p>
</li>
<li>
<p><code>OCI_ATTR_CHARSET_FORM</code></p>
</li>
<li>
<p><code>OCI_ATTR_LFPRECISION</code></p>
</li>
<li>
<p><code>OCI_ATTR_FSPRECISION</code></p>
</li>
</ul>
<p>These attributes have the usual meanings they have while describing a type attribute.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
These attributes are supported only for transient built-in types. The attributes <code>OCI_ATTR_IS_TRANSIENT_TYPE</code> and <code>OCI_ATTR_IS_PREDEFINED_TYPE</code> are true for these types. For persistent types, these attributes are supported only from the parameter handle of the type's attributes (which are of type <code>OCI_PTYPE_TYPE_ATTR</code>).</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16883" class="sect2"><a id="sthref1934"></a>
<h3 class="sect2">OCIAnyData Interfaces</h3>
<p>An <code>OCIAnyData</code> encapsulates type information and a data instance of that type (that is, self-descriptive data). An <code>OCIAnyData</code> can be created from any built-in or user-defined type instance by using the <a href="oci21any002.htm#i521756">OCIAnyDataConvert()</a> call. This call does a conversion (cast) to an <code>OCIAnyData</code>.</p>
<p>Alternatively, object types and collection types can be constructed piece by piece (an attribute at a time for object types or a collection element at a time) by calling <a href="oci21any002.htm#i522801">OCIAnyDataBeginCreate()</a> with the type information (<code>OCIType</code>). Subsequently, you can use <a href="oci21any002.htm#i522394">OCIAnyDataAttrSet()</a> for object types and use <a href="oci21any002.htm#i521748">OCIAnyDataCollAddElem()</a> for collection types. Finally, use the <a href="oci21any002.htm#i521764">OCIAnyDataEndCreate()</a> call to finish the construction process.</p>
<p>Subsequently, you can invoke the access routines. To convert (cast) an <code>OCIAnyData</code> to the corresponding type instance, you can use <a href="oci21any002.htm#i521738">OCIAnyDataAccess()</a>.</p>
<p>An <code>OCIAnyData</code> that is based on an object or collection type can also be accessed piece by piece.</p>
<p>Special collection construction and access calls are provided for performance improvement. You can use these calls to avoid unnecessary creation and copying of the entire collection in memory, as shown in <a href="#BGBJBGHE">Example 12-12</a>.</p>
<div id="LNOCI18256" class="example">
<p class="titleinexample"><a id="BGBJBGHE"></a>Example 12-12 Using Special Construction and Access Calls for Improved Performance</p>
<pre>
OCIAnyDataConvert(...)        /* Cast a built-in or user-defined type instance
                                 to an OCIAnyData in 1 call. */

OCIAnyDataBeginCreate(...)    /* Begin AnyData Creation */

OCIAnyDataAttrSet(...)        /* Attribute-wise construction for object types */
</pre></div>
<!-- class="example" -->
<p>or</p>
<pre>
OCIAnyDataCollAddElem(...)    /* Element-wise construction for collections */

OCIAnyDataEndCreate(...)      /* End OCIAnyData Creation */
</pre></div>
<!-- class="sect2" -->
<a id="i438070"></a>
<div id="LNOCI16884" class="sect2">
<h3 class="sect2">NCHAR Typecodes for OCIAnyData Functions</h3>
<p>The function <a id="sthref1935"></a><a href="oci21any002.htm#i524177">OCIAnyDataTypeCodeToSqlt()</a> converts the <code>OCITypeCode</code> for an OCIAnyData value to the SQLT code that corresponds to the representation of the value as returned by the OCIAnyData API.</p>
<p>The following typecodes are used in the OCIAnyData functions only:</p>
<ul>
<li>
<p><a id="sthref1936"></a><code>OCI_TYPECODE_NCHAR</code></p>
</li>
<li>
<p><a id="sthref1937"></a><code>OCI_TYPECODE_NVARCHAR2</code></p>
</li>
<li>
<p><code>OCI_TYPECODE_NCLOB</code></p>
</li>
</ul>
<p>In calls to other functions, such as <a href="oci16rel003.htm#i455723">OCIDescribeAny()</a>, these typecodes are not returned, and you must use the character set form to determine if the data is <code>NCHAR</code> (if character set form is SQLCS_NCHAR).</p>
<p><a href="oci21any002.htm#i524177">OCIAnyDataTypeCodeToSqlt()</a> converts <code>OCI_TYPECODE_CHAR</code> and <code>OCI_TYPECODE_VARCHAR2</code> to the output values <code>SQLT_VST</code> (which corresponds to the <code>OCIString</code> mapping) with a character set form of <code>SQLCS_IMPLICIT</code>. <code>OCI_TYPECODE_NVARCHAR2</code> also returns <code>SQLT_VST</code> (<code>OCIString</code> mapping is used by OCIAnyData API) with a character set form of <code>SQLCS_NCHAR</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci21any002.htm#i524177">"OCIAnyDataTypeCodeToSqlt()"</a></div>
</div>
<!-- class="sect2" -->
<div id="LNOCI16885" class="sect2"><a id="sthref1938"></a>
<h3 class="sect2">OCIAnyDataSet Interfaces</h3>
<p>An <code>OCIAnyDataSet</code> encapsulates type information and <span class="italic">a set of instances</span> of that type. To begin the construction process, call <a href="oci21any003.htm#i521892">OCIAnyDataSetBeginCreate()</a>. Call <a href="oci21any003.htm#i521888">OCIAnyDataSetAddInstance()</a> to add a new instance; this call returns the <code>OCIAnyData</code> corresponding to that instance.</p>
<p>Then, you can invoke the OCIAnyData functions to construct this instance. Call <a href="oci21any003.htm#i521900">OCIAnyDataSetEndCreate()</a> when all instances have been added.</p>
<p>For access, call <a href="oci21any003.htm#i521908">OCIAnyDataSetGetInstance()</a> to get the <code>OCIAnyData</code> corresponding to the instance. Only sequential access is supported. Subsequently, you can invoke the OCIAnyData access functions, as in the following example:</p>
<pre>
OCIAnyDataSetBeginCreate(...)   /* Begin AnyDataSet Creation */
OCIAnyDataSetAddInstance(...)   /* Add a new instance to the AnyDataSet */
                                /* Use the OCIAnyData*() functions to create
                                   the instance */
OCIAnyDataSetEndCreate(...)     /* End OCIAnyDataSet Creation */
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci21any.htm#i525174">Chapter 21</a> for complete descriptions of all the calls in these interfaces</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i437157"></a>
<div id="LNOCI16886" class="sect1">
<h2 class="sect1">Binding Named Data Types<a id="sthref1939"></a><a id="sthref1940"></a></h2>
<p>This section provides information about binding named data types (such as objects and collections) and <code>REF</code>s.</p>
<a id="i437161"></a>
<div id="LNOCI16887" class="sect2">
<h3 class="sect2">Named Data Type Binds<a id="sthref1941"></a><a id="sthref1942"></a></h3>
<p>For a named data type (object type or collection) bind, a second bind call is necessary following <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>. The <a href="oci16rel003.htm#i444090">OCIBindObject()</a> call sets up additional attributes specific to the object type bind. An OCI application uses this call when fetching data from a table that has a column with an object data type.</p>
<p>The <a href="oci16rel003.htm#i444090">OCIBindObject()</a> call takes, among other parameters, a type descriptor object (TDO) for the named data type. The TDO of data type <code>OCIType</code> is created and stored in the database when a named data type is created. It contains information about the type and its attributes. An application can obtain a TDO by calling <a href="oci18nav006.htm#i455564">OCITypeByName()</a>.<a id="sthref1943"></a></p>
<p>The <a href="oci16rel003.htm#i444090">OCIBindObject()</a> call also sets up the indicator variable or structure for the named data type bind.</p>
<p>When binding a named data type, use the <code>SQLT_NTY</code> data type constant to indicate the data type of the program variable being bound. <code>SQLT_NTY</code> indicates that a C struct representing the named data type is being bound. A pointer to this structure is passed to the bind call.</p>
<p>With inheritance and instance substitutability, you can bind a subtype instance where the supertype is expected.</p>
<p>Working with named data types may require the use of three bind calls in some circumstances. For example, to bind a static array of named data types to a PL/SQL table, three calls must be invoked: <a href="oci16rel003.htm#i456223">OCIBindByName()</a>, <a href="oci16rel003.htm#i444152">OCIBindArrayOfStruct()</a>, and <a href="oci16rel003.htm#i444090">OCIBindObject()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci11obj.htm#i440601">"Fetching Embedded Objects"</a> for information about using these data types to fetch an embedded object from the database</p>
</li>
<li>
<p><a href="#i437227">"Information for Named Data Type and REF Binds"</a></p>
</li>
<li>
<p><a href="#i426973">"Descriptor Objects"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i437201"></a>
<div id="LNOCI16888" class="sect2">
<h3 class="sect2">Binding REFs<a id="sthref1944"></a><a id="sthref1945"></a></h3>
<p>As with named data types, binding <code>REF</code>s is a two-step process. First, call <a href="oci16rel003.htm#i456223">OCIBindByName()</a> or <a href="oci16rel003.htm#i456224">OCIBindByPos()</a>, and then call <a href="oci16rel003.htm#i444090">OCIBindObject()</a>.</p>
<p><code>REF</code>s are bound using the <code>SQLT_REF</code> data type. When <code>SQLT_REF</code> is used, then the program variable being bound must be of type <code>OCIRef *</code>.</p>
<p>With inheritance and <code>REF</code> substitutability, you can bind a <code>REF</code> value to a subtype instance where a <code>REF</code> to the supertype is expected.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci11obj.htm#i440442">"Retrieving an Object Reference from the Server"</a> for information about binding and pinning <code>REF</code>s to objects</p>
</li>
<li>
<p><a href="#i437227">"Information for Named Data Type and REF Binds"</a> for additional important information</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i437227"></a>
<div id="LNOCI16889" class="sect2">
<h3 class="sect2">Information for Named Data Type and REF Binds<a id="sthref1946"></a><a id="sthref1947"></a></h3>
<p>Remember the following important information when you work with named data type and <code>REF</code> binds. It includes pointers about memory allocation and indicator variable usage.</p>
<ul>
<li>
<p>If the data type being bound is <code>SQLT_NTY</code>, the indicator struct parameter of the <a href="oci16rel003.htm#i444090">OCIBindObject()</a> call (<code>void ** indpp</code>) is used, and the scalar indicator is completely ignored.</p>
</li>
<li>
<p>If the data type is <code>SQLT_REF</code>, the scalar indicator is used, and the indicator struct parameter of <a href="oci16rel003.htm#i444090">OCIBindObject()</a> is completely ignored.</p>
</li>
<li>
<p>The use of indicator structures is optional. The user can pass a <code>NULL</code> pointer in the <code><span class="codeinlineitalic">indpp</span></code> parameter for the <a href="oci16rel003.htm#i444090">OCIBindObject()</a> call. During the bind, therefore, the object is not atomically <code>NULL</code> and none of its attributes are <code>NULL</code>.</p>
</li>
<li>
<p>The indicator struct size pointer, <code><span class="codeinlineitalic">indsp</span></code>, and program variable size pointer, <code><span class="codeinlineitalic">pgvsp</span></code>, in the <a href="oci16rel003.htm#i444090">OCIBindObject()</a> call are optional. Users can pass <code>NULL</code> if these parameters are not needed.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNOCI16890" class="sect2"><a id="sthref1948"></a>
<h3 class="sect2">Information Regarding Array Binds<a id="sthref1949"></a><a id="sthref1950"></a></h3>
<p>For doing array binds of named data types or <code>REF</code>s, for array inserts or fetches, the user must pass in an array of pointers to buffers (preallocated or otherwise) of the appropriate type. Similarly, an array of scalar indicators for <code>SQLT_REF</code> types or an array of pointers to indicator structs for <code>SQLT_NTY</code> types must be passed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci03typ.htm#i449533">"Named Data Types: Object, VARRAY, Nested Table"</a> for more information about <code>SQLT_NTY</code></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i437252"></a>
<div id="LNOCI16891" class="sect1">
<h2 class="sect1">Defining Named Data Types<a id="sthref1951"></a><a id="sthref1952"></a></h2>
<p>This section provides information about defining named data types (for example, objects, collections) and <code>REF</code>s.</p>
<a id="i437256"></a>
<div id="LNOCI16892" class="sect2">
<h3 class="sect2">Defining Named Data Type Output Variables<a id="sthref1953"></a><a id="sthref1954"></a></h3>
<p>For a named data type (object type, nested table, <a id="sthref1955"></a>varray) define, two define calls are necessary. The application should first call <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>, specifying <code>SQLT_NTY</code> in the <code><span class="codeinlineitalic">dty</span></code> parameter. Following <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>, the application must call <a href="oci16rel003.htm#i555538">OCIDefineObject()</a> to set up additional attributes pertaining to a named data type define. In this case, the data buffer pointer in <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a> is ignored.</p>
<p>Specify the <code>SQLT_NTY</code> data type constant for a named data type define. In this case, the application fetches the result data into a host-language representation of the named data type. In most cases, this is a C struct generated by the Object Type Translator.</p>
<p>To make an <a href="oci16rel003.htm#i555538">OCIDefineObject()</a> call, a pointer to the address of the C struct (preallocated or otherwise) must be provided. The object may have been created with <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>, allocated in the cache, or with user-allocated memory.</p>
<p>However, in the presence of inheritance, Oracle strongly recommends using objects in the object cache and <span class="italic">not</span> passing objects allocated out of user memory from the stack. Otherwise, due to instance substitutability, the server may send back a <span class="italic">subtype</span> instance when the client is expecting a supertype instance. This requires the server to dynamically resize the object, which is possible only for objects in the cache.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i437290">"Information for Named Data Type and REF Defines, and PL/SQL OUT Binds"</a> for more important information about defining named data types</div>
</div>
<!-- class="sect2" -->
<a id="i437274"></a>
<div id="LNOCI16893" class="sect2">
<h3 class="sect2">Defining REF Output Variables<a id="sthref1956"></a><a id="sthref1957"></a></h3>
<p>As with named data types, defining for a <code>REF</code> output variable is a two-step process. The first step is a call to <a href="oci16rel003.htm#i459315">OCIDefineByPos()</a>, and the second is a call to <a href="oci16rel003.htm#i555538">OCIDefineObject()</a>. Also as with named data types, the <code>SQLT_REF</code> data type constant is passed to the <code><span class="codeinlineitalic">dty</span></code> parameter of <code>OCIDefineByPos()</code>.</p>
<p><code>SQLT_REF</code> indicates that the application is fetching the result data into a variable of type <code>OCIRef *</code>. This <code>REF</code> can then be used as part of object pinning and navigation as described in <a href="oci11obj.htm#i440300">"Working with Objects in OCI"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i437290">"Information for Named Data Type and REF Defines, and PL/SQL OUT Binds"</a> for more important information about defining <code>REF</code>s</div>
</div>
<!-- class="sect2" -->
<a id="i437290"></a>
<div id="LNOCI16894" class="sect2">
<h3 class="sect2">Information for Named Data Type and REF Defines, and PL/SQL OUT Binds<a id="sthref1958"></a><a id="sthref1959"></a><a id="sthref1960"></a></h3>
<p>Consider the following important information as you work with named data type and <code>REF</code> defines. It includes pointers about memory allocation and indicator variable usage.</p>
<p>A PL/SQL OUT bind refers to binding a placeholder to an output variable in a PL/SQL block. Unlike a SQL statement, where output buffers are set up with define calls, in a PL/SQL block, output buffers are set up with bind calls. See <a href="oci05bnd.htm#i421871">"Binding Placeholders in PL/SQL"</a> for more information.</p>
<ul>
<li>
<p>If the data type being defined is <code>SQLT_NTY</code>, then the indicator struct parameter of the <a href="oci16rel003.htm#i555538">OCIDefineObject()</a> call (<code><span class="codeinlineitalic">void ** indpp</span></code>) is used, and the scalar indicator is completely ignored.</p>
</li>
<li>
<p>If the data type is <code>SQLT_REF</code>, then the scalar indicator is used, and the indicator struct parameter of <code>OCIDefineObject()</code> is completely ignored.</p>
</li>
<li>
<p>The use of indicator structures is optional. The user can pass a <code>NULL</code> pointer in the <code><span class="codeinlineitalic">indpp</span></code> parameter for the <a href="oci16rel003.htm#i555538">OCIDefineObject()</a> call. During a fetch or PL/SQL OUT bind, therefore, the user is not interested in any information about being null.</p>
</li>
<li>
<p>In a SQL define or PL/SQL OUT bind, you can pass in preallocated memory for either the output variable or the indicator. Then that preallocated memory is used to store result data, and any secondary memory (out-of-line memory), is deallocated. The preallocated memory must come from the cache (the result of an <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> call).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you want your client application to allocate memory from its own private memory space, instead of the cache, your application must ensure that there is no secondary out-of-line memory in the object.</div>
</li>
</ul>
<p><a id="sthref1961"></a>To preallocate object memory for an object define with type <code>SQLT_NTY</code>, client applications must use the <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> function. A client application should not allocate the object in its own private memory space, such as with <code>malloc()</code> or on the stack. The <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> function allocates the object in the object cache. The allocated object can be freed using <a href="oci18nav005.htm#i430212">OCIObjectFree()</a>. See <a href="oci18nav.htm#i476164">Chapter 18</a> for details about <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> and <a href="oci18nav005.htm#i430212">OCIObjectFree()</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is no change to the behavior of <a href="oci16rel003.htm#i555538">OCIDefineObject()</a> when the user does not preallocate the object memory and instead initializes the output variable to null pointer value. In this case, the object is implicitly allocated in the object cache by the OCI library.</div>
<ul>
<li>
<p>In a SQL define or PL/SQL OUT bind, if the user passes in a <code>NULL</code> address for the output variable or the indicator, memory for the variable or the indicator is implicitly allocated by OCI.</p>
</li>
<li>
<p>If an output object of type <code>SQLT_NTY</code> is atomically <code>NULL</code> (in a SQL define or PL/SQL OUT bind), only the <code>NULL</code> indicator struct gets allocated (implicitly if necessary) and populated accordingly to indicate the atomic nullity of the object. The top-level object does not get implicitly allocated.</p>
</li>
<li>
<p>An application can free indicators by calling <a href="oci18nav005.htm#i430212">OCIObjectFree()</a>. If there is a top-level object (as with a non-atomically <code>NULL</code> object), then the indicator is freed when the top-level object is freed with <code>OCIObjectFree()</code>. If the object is atomically null, then there is no top-level object, so the indicator must be freed separately.</p>
</li>
<li>
<p>The indicator struct size pointer, <code><span class="codeinlineitalic">indszp</span></code>, and program variable size pointer, <code><span class="codeinlineitalic">pvszsp</span></code>, in the <a href="oci16rel003.htm#i555538">OCIDefineObject()</a> call are optional. Users can pass <code>NULL</code> if these parameters are not needed.</p>
</li>
</ul>
<div id="LNOCI16895" class="sect3"><a id="sthref1962"></a>
<h4 class="sect3">Information About Array Defines<a id="sthref1963"></a><a id="sthref1964"></a></h4>
<p>To perform array defines of named data types or <code>REF</code>s, the user must pass in an array of pointers to buffers (preallocated or otherwise) of the appropriate type. Similarly, an array of scalar indicators (for <code>SQLT_REF</code> types) or an array of pointers to indicator structs (for <code>SQLT_NTY</code> types) must be passed.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i437327"></a>
<div id="LNOCI16896" class="sect1">
<h2 class="sect1">Binding and Defining Oracle C Data Types<a id="sthref1965"></a><a id="sthref1966"></a><a id="sthref1967"></a><a id="sthref1968"></a><a id="sthref1969"></a><a id="sthref1970"></a><a id="sthref1971"></a><a id="sthref1972"></a></h2>
<p>Previous chapters of this book have discussed OCI bind and define operations. <a href="oci04sql.htm#i420655">"Binding Placeholders in OCI"</a> discussed the basics of OCI bind operations, whereas <a href="oci04sql.htm#i448834">"Defining Output Variables in OCI"</a> discussed the basics of OCI define operations. Information specific to binding and defining named data types and <code>REF</code>s was described in <a href="oci05bnd.htm#g453183">Chapter 5</a>.</p>
<p>The sections covering basic bind and define functionality showed how an application could use a scalar variable or array of scalars as an input (bind) value in a SQL statement, or as an output (define) buffer for a query.</p>
<p>The sections covering named data types and <code>REF</code>s showed how to bind or define an object or reference. <a href="oci11obj.htm#i440479">"Pinning an Object"</a> expanded on this to talk about pinning object references, <a href="oci11obj.htm#i440601">"Fetching Embedded Objects"</a> discussed fetching embedded instances, and <a href="oci14oca.htm#i440496">"Object Navigation"</a> discussed object navigation.</p>
<p>The purpose of this section is to cover binding and defining of individual attribute values, using the data type mappings explained in this chapter.</p>
<p>Variables of one of the types defined in this chapter, such as <code>OCINumber</code> or <code>OCIString</code>, can typically be declared in an application and used directly in an OCI bind or define operation because the appropriate data type code is specified. <a href="#BGBJJCEH">Table 12-12</a> lists the data types that you can use for binds and defines, along with their C mapping, and the OCI external data type that must be specified in the <span class="italic">dty</span> (data type code) parameter of the bind or define call.</p>
<div id="LNOCI16897" class="tblformal">
<p class="titleintable"><a id="sthref1973"></a><a id="BGBJJCEH"></a>Table 12-12 Data Type Mappings for Binds and Defines</p>
<table class="cellalignment1016" title="Data Type Mappings for Binds and Defines " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t39">Data Type</th>
<th class="cellalignment1012" id="r1c2-t39">C Mapping</th>
<th class="cellalignment1012" id="r1c3-t39">OCI External Data Type and Code</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t39" headers="r1c1-t39">
<p>Oracle <code>NUMBER</code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t39 r1c2-t39">
<pre>
OCINumber
</pre></td>
<td class="cellalignment1013" headers="r2c1-t39 r1c3-t39">
<p>VARNUM (SQLT_VNU)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t39" headers="r1c1-t39">
<p>Oracle <code>DATE</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t39 r1c2-t39">
<pre>
OCIDate
</pre></td>
<td class="cellalignment1013" headers="r3c1-t39 r1c3-t39">
<p>SQLT_ODT</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t39" headers="r1c1-t39">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t39 r1c2-t39">
<pre>
OCILobLocator *
</pre></td>
<td class="cellalignment1013" headers="r4c1-t39 r1c3-t39">
<p>SQLT_BLOB</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t39" headers="r1c1-t39">
<p><code>CLOB</code>, <code>NCLOB</code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t39 r1c2-t39">
<pre>
CILobLocator *
</pre></td>
<td class="cellalignment1013" headers="r5c1-t39 r1c3-t39">
<p>SQLTY_LOB</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t39" headers="r1c1-t39">
<p><code>VARCHAR2</code>, <code>NVARCHAR2</code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t39 r1c2-t39">
<pre>
OCIString *
</pre></td>
<td class="cellalignment1013" headers="r6c1-t39 r1c3-t39">
<p>SQLT_VST <a id="BGBGIDDF" href="#BGBGIDDF" onclick='footdisplay(1,"Before fetching data into a define variable of type \u003ccode\u003eOCIString *\u003c/code\u003e, the size of the string must first be set using the \u003ca target=\"oci12oty\" href=\"oci19map006.htm#i430414\"\u003eOCIStringResize()\u003c/a\u003e routine. This may require a describe operation to obtain the length of the select-list data. Similarly, an \u003ccode\u003eOCIRaw *\u003c/code\u003e must be first sized with \u003ca target=\"oci12oty\" href=\"oci19map006.htm#i430414\"\u003eOCIStringResize()\u003c/a\u003e.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t39" headers="r1c1-t39">
<p><code>RAW</code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t39 r1c2-t39">
<pre>
OCIRaw *
</pre></td>
<td class="cellalignment1013" headers="r7c1-t39 r1c3-t39">
<p>SQLT_LVB <a id="sthref1974" href="#sthref1974" onclick='footdisplay(1,"Before fetching data into a define variable of type \u003ccode\u003eOCIString *\u003c/code\u003e, the size of the string must first be set using the \u003ca target=\"oci12oty\" href=\"oci19map006.htm#i430414\"\u003eOCIStringResize()\u003c/a\u003e routine. This may require a describe operation to obtain the length of the select-list data. Similarly, an \u003ccode\u003eOCIRaw *\u003c/code\u003e must be first sized with \u003ca target=\"oci12oty\" href=\"oci19map006.htm#i430414\"\u003eOCIStringResize()\u003c/a\u003e.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t39" headers="r1c1-t39">
<p><code>CHAR</code>, <code>NCHAR</code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t39 r1c2-t39">
<pre>
OCIString *
</pre></td>
<td class="cellalignment1013" headers="r8c1-t39 r1c3-t39">
<p>SQLT_VST</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t39" headers="r1c1-t39">
<p>Object</p>
</td>
<td class="cellalignment1013" headers="r9c1-t39 r1c2-t39">
<pre>
struct *
</pre></td>
<td class="cellalignment1013" headers="r9c1-t39 r1c3-t39">
<p>Named Data Type (SQLT_NTY)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t39" headers="r1c1-t39">
<p><code>REF</code></p>
</td>
<td class="cellalignment1013" headers="r10c1-t39 r1c2-t39">
<pre>
OCIRef *
</pre></td>
<td class="cellalignment1013" headers="r10c1-t39 r1c3-t39">
<p>REF (SQLT_REF)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t39" headers="r1c1-t39">
<p><code>VARRAY</code></p>
</td>
<td class="cellalignment1013" headers="r11c1-t39 r1c2-t39">
<pre>
OCIArray *
</pre></td>
<td class="cellalignment1013" headers="r11c1-t39 r1c3-t39">
<p>Named Data Type (SQLT_NTY)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t39" headers="r1c1-t39">
<p>Nested Table</p>
</td>
<td class="cellalignment1013" headers="r12c1-t39 r1c2-t39">
<pre>
OCITable *
</pre></td>
<td class="cellalignment1013" headers="r12c1-t39 r1c3-t39">
<p>Named Data Type (SQLT_NTY)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t39" headers="r1c1-t39">
<p><code>DATETIME</code></p>
</td>
<td class="cellalignment1013" headers="r13c1-t39 r1c2-t39">
<pre>
OCIDateTime *
</pre></td>
<td class="cellalignment1013" headers="r13c1-t39 r1c3-t39">
<p>See <a href="#i438442">"Datetime and Interval (OCIDateTime, OCIInterval)"</a>.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t39" headers="r1c1-t39">
<p><code>INTERVAL</code></p>
</td>
<td class="cellalignment1013" headers="r14c1-t39 r1c2-t39">
<pre>
OCIInterval *
</pre></td>
<td class="cellalignment1013" headers="r14c1-t39 r1c3-t39">
<p>See <a href="#i438442">"Datetime and Interval (OCIDateTime, OCIInterval)"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>Before fetching data into a define variable of type <code>OCIString *</code>, the size of the string must first be set using the <a href="oci19map006.htm#i430414">OCIStringResize()</a> routine. This may require a describe operation to obtain the length of the select-list data. Similarly, an <code>OCIRaw *</code> must be first sized with <a href="oci19map006.htm#i430414">OCIStringResize()</a>.</p>
<p>The following section presents examples of how to use C-mapped data types in an OCI application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci03typ.htm#g467721">Chapter 3</a> for a discussion of OCI external data types, and a list of data typecodes</div>
<div id="LNOCI16898" class="sect2"><a id="sthref1975"></a>
<h3 class="sect2">Bind and Define Examples<a id="sthref1976"></a><a id="sthref1977"></a><a id="sthref1978"></a><a id="sthref1979"></a></h3>
<p>The examples in this section demonstrate how you can use variables of type <code>OCINumber</code> in OCI bind and define operations.</p>
<p>Assume, for this example, that the following <code>person</code> object type was created:</p>
<pre>
CREATE TYPE person AS OBJECT
(name     varchar2(30),
salary     number);
</pre>
<p>This type is then used to create an <code>employees</code> table that has a column of type <code>person</code>.</p>
<pre>
CREATE TABLE employees
(emp_id    number,
job_title  varchar2(30),
emp        person);
</pre>
<p>The Object Type Translator (OTT) generates the following C struct and null indicator struct for <code>person</code>:</p>
<pre>
struct person
{   OCIString * name;
   OCINumber salary;};
typedef struct person person;

struct person_ind
{   OCIInd  _atomic;
   OCIInd  name;
   OCIInd  salary;}
typedef struct person_ind person_ind;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci15ott.htm#g455369">Chapter 15</a> for a complete discussion of OTT</div>
<p>Assume that the <code>employees</code> table has been populated with values, and an OCI application has declared a <code>person</code> variable:</p>
<pre>
person *my_person;
</pre>
<p>The application then fetches an object into that variable through a <code>SELECT</code> statement, such as:</p>
<pre>
text *mystmt = (text *) "SELECT person FROM employees
                        WHERE emp.name='Andrea'";
</pre>
<p>This requires defining <code>my_person</code> to be the output variable for this statement, using appropriate OCI define calls for named data types, as described in <a href="oci05bnd.htm#i421090">"Advanced Define Operations in OCI"</a>. Executing the statement retrieves the <code>person</code> object named <code>Andrea</code> into the <code>my_person</code> variable.</p>
<p>Once the object is retrieved into <code>my_person</code>, the OCI application has access to the attributes of <code>my_person</code>, including the name and the salary.</p>
<p>The application could go on to update another employee's salary to be the same as Andrea's, as in the following example:</p>
<pre>
text *updstmt = (text *) "UPDATE employees SET emp.salary = :newsal 
                            WHERE emp.name = 'MONGO'";
</pre>
<p>Andrea's salary (stored in <code>my_person-&gt;salary</code>) would be bound to the placeholder <code>:newsal</code>, specifying an external data type of <code>VARNUM</code> (data type code=6) in the bind operation:</p>
<pre>
OCIBindByName(...,":newsal",...,&amp;my_person-&gt;salary,...,6,...);
OCIStmtExecute(...,updstmt,...);
</pre>
<p>Executing the statement updates Mongo's salary in the database to be equal to Andrea's, as stored in <code>my_person.</code></p>
<p>Conversely, the application could update Andrea's salary to be the same as Mongo's, by querying the database for Mongo's salary, and then making the necessary salary assignment:</p>
<pre>
text *selstmt = (text *) "SELECT emp.salary FROM employees 
                           WHERE emp.name = 'MONGO'";
OCINumber mongo_sal;
...
OCIDefineByPos(...,1,...,&amp;mongo_sal,...,6,...);
OCIStmtExecute(...,selstmt,...);
OCINumberAssign(...,&amp;mongo_sal, &amp;my_person-&gt;salary);
</pre>
<p>In this case, the application declares an output variable of type <code>OCINumber</code> and uses it in the define step. The application also defines an output variable for position 1, and uses the appropriate data type code (6 for <code>VARNUM</code>).</p>
<p>The salary value is fetched into the <code>mongo_sal</code> <code>OCINumber</code>, and the appropriate OCI function, <a href="oci19map003.htm#i430098">OCINumberAssign()</a>, is used to assign the new salary to the copy of the <code>Andrea</code> object currently in the cache. To modify the data in the database, the change must be flushed to the server.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16899" class="sect2"><a id="sthref1980"></a>
<h3 class="sect2">Salary Update Examples</h3>
<p>The examples in the previous section demonstrate the flexibility that the Oracle data types provide for bind and define operations. This section shows how you can perform the same operation in several different ways. You can use these data types in variety of ways in OCI applications.</p>
<p>The examples in this section demonstrate the flow of calls used to perform certain OCI tasks. An expanded pseudocode is used for these examples. Actual function names are used, but for simplicity not all parameters and typecasts are filled in. Other necessary OCI calls, such as handle allocations, have been omitted.</p>
<p class="subhead2"><a id="LNOCI18257"></a>The Scenario</p>
<p>The scenario for these examples is as follows:</p>
<ul>
<li>
<p>An employee named <code><span class="codeinlineitalic">BRUCE</span></code> exists in the <code>employees</code> table for a hospital. See <code>person</code> type and <code>employees</code> table creation statements in the previous section.</p>
</li>
<li>
<p>Bruce's current job title is <code><span class="codeinlineitalic">RADIOLOGIST</span></code>.</p>
</li>
<li>
<p>Bruce is being promoted to <code><span class="codeinlineitalic">RADIOLOGY_CHIEF</span></code>, and along with the promotion comes a salary increase.</p>
</li>
<li>
<p>Hospital salaries are in whole dollar values, are set according to job title, and are stored in a table called <code>salaries</code>, defined as follows:</p>
<pre>
CREATE TABLE salaries
(job_title   varchar2(20),
salary       integer));
</pre></li>
<li>
<p>Bruce's salary must be updated to reflect his promotion.</p>
</li>
</ul>
<p>To update Bruce's salary to reflect the promotion, the application must retrieve the salary corresponding to <code><span class="codeinlineitalic">RADIOLOGY_CHIEF</span></code> from the <code>salaries</code> table, and update Bruce's salary. A separate step would write his new title and the modified object back to the database.</p>
<p>Assume that a variable of type <code>person</code> has been declared as follows:</p>
<pre>
person * my_person;
</pre>
<p>The object corresponding to Bruce has been fetched into <code>person</code>. The following sections present three different ways in which the salary update could be performed.</p>
<div id="LNOCI16900" class="sect3"><a id="sthref1981"></a>
<h4 class="sect3">Method 1 - Fetch, Convert, Assign</h4>
<p><a href="#BGBCHECA">Example 12-13</a> uses the following method:</p>
<ol>
<li>
<p>Do a traditional OCI define using an integer variable to retrieve the new salary from the database.</p>
</li>
<li>
<p>Convert the integer to an <code>OCINumber.</code></p>
</li>
<li>
<p>Assign the new salary to Bruce.</p>
</li>
</ol>
<div id="LNOCI18258" class="example">
<p class="titleinexample"><a id="BGBCHECA"></a>Example 12-13 Method 1 for a Salary Update: Fetch, Convert, and Assign</p>
<pre>
#define INT_TYPE 3        /* data type code for sword integer define */

text *getsal = (text *) "SELECT salary FROM salaries
                        WHERE job_title='RADIOLOGY_CHIEF'";
sword    new_sal;
OCINumber   orl_new_sal;
...
OCIDefineByPos(...,1,...,new_sal,...,INT_TYPE,...);
                        /* define int output */
OCIStmtExecute(...,getsal,...);
                        /* get new salary as int */
OCINumberFromInt(...,new_sal,...,&amp;orl_new_sal);
                        /* convert salary to OCINumber */
OCINumberAssign(...,&amp;orl_new_sal, &amp;my_person-&gt;salary);
                        /* assign new salary */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16901" class="sect3"><a id="sthref1982"></a>
<h4 class="sect3">Method 2 - Fetch and Assign</h4>
<p>This method (<a href="#BGBFEAHJ">Example 12-14</a>) eliminates one of the steps described in Method 1.</p>
<ol>
<li>
<p>Define an output variable of type <code>OCINumber</code>, so that no conversion is necessary after the value is retrieved.</p>
</li>
<li>
<p>Assign the new salary to Bruce.</p>
</li>
</ol>
<div id="LNOCI18259" class="example">
<p class="titleinexample"><a id="BGBFEAHJ"></a>Example 12-14 Method 2 for a Salary Update: Fetch and Assign, No Convert</p>
<pre>
#define VARNUM_TYPE 6         /* data type code for defining VARNUM */

text *getsal = (text *) "SELECT salary FROM salaries
                              WHERE job_title='RADIOLOGY_CHIEF'";
OCINumber   orl_new_sal;
...
OCIDefineByPos(...,1,...,orl_new_sal,...,VARNUM_TYPE,...);
                                     /* define OCINumber output */
OCIStmtExecute(...,getsal,...);      /* get new salary as OCINumber */
OCINumberAssign(...,&amp;orl_new_sal, &amp;my_person-&gt;salary); 
                                     /* assign new salary */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16902" class="sect3"><a id="sthref1983"></a>
<h4 class="sect3">Method 3 - Direct Fetch</h4>
<p>This method (<a href="#BGBBEBFH">Example 12-15</a>) accomplishes the entire operation with a single define and fetch. No intervening output variable is used, and the value retrieved from the database is fetched directly into the salary attribute of the object stored in the cache.</p>
<p>Because the object corresponding to Bruce is pinned in the object cache, use the location of his salary attribute as the define variable, and execute or fetch directly into it.</p>
<div id="LNOCI18260" class="example">
<p class="titleinexample"><a id="BGBBEBFH"></a>Example 12-15 Method 3 for a Salary Update: Direct Fetch</p>
<pre>
#define VARNUM_TYPE 6         /* data type code for defining VARNUM */

text *getsal = (text *) "SELECT salary FROM salaries
                            WHERE job_title='RADIOLOGY_CHIEF'";
...
OCIDefineByPos(...,1,...,&amp;my_person-&gt;salary,...,VARNUM_TYPE,...);
            /* define bruce's salary in cache as output variable */
OCIStmtExecute(...,getsal,...);
             /* execute and fetch directly */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16903" class="sect3"><a id="sthref1984"></a>
<h4 class="sect3">Summary and Notes</h4>
<p>As the previous three examples show, the C data types provide flexibility for binding and defining. In these examples an integer can be fetched, and then converted to an <code>OCINumber</code> for manipulation. You can use an <code>OCINumber</code> as an intermediate variable to store the results of a query. Or, data can be fetched directly into a desired <code>OCINumber</code> attribute of an object.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In these examples it is important to remember that in OCI, if an output variable is defined before the execution of a query, the resulting data is prefetched directly into the output buffer.</div>
<p>In the preceding examples, extra steps would be necessary to ensure that the application writes changes to the database permanently. These might involve SQL <code>UPDATE</code> calls and OCI transaction commit calls.</p>
<p>These examples all dealt with define operations, but a similar situation applies for binding.</p>
<p>Similarly, although these examples dealt exclusively with the <code>OCINumber</code> type, a similar variety of operations are possible for the other Oracle C types described in the remainder of this chapter.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i437615"></a>
<div id="LNOCI16904" class="sect1">
<h2 class="sect1">SQLT_NTY Bind and Define Examples</h2>
<p>The following code fragments demonstrate the use of the <code>SQLT_NTY</code> named data type in the bind call including <a href="oci16rel003.htm#i444090">OCIBindObject()</a> and the <code>SQLT_NTY</code> named data type in the define call including <a href="oci16rel003.htm#i555538">OCIDefineObject()</a>. In each example, a previously defined SQL statement is being processed.</p>
<div id="LNOCI16905" class="sect2"><a id="sthref1985"></a>
<h3 class="sect2">SQLT_NTY Bind Example<a id="sthref1986"></a></h3>
<p><a href="#BGBCACCG">Example 12-16</a> shows how to use the <code>SQLT_NTY</code> named data type in the bind call including <a href="oci16rel003.htm#i444090">OCIBindObject()</a>.</p>
<div id="LNOCI18261" class="example">
<p class="titleinexample"><a id="BGBCACCG"></a>Example 12-16 Using the SQLT_NTY Bind Call Including OCIBindObject()</p>
<pre>
/*
** This example performs a SQL insert statement
*/
void insert(envhp, svchp, stmthp, errhp, insstmt, nrows)
OCIEnv *envhp;
OCISvcCtx *svchp;
OCIStmt *stmthp;
OCIError *errhp;
text *insstmt;
ub2   nrows;
{
  OCIType *addr_tdo = (OCIType *)0 ;
  address  addrs;
  null_address naddrs;
  address *addr = &amp;addrs;
  null_address *naddr = &amp;naddrs;
  sword custno =300;
  OCIBind *bnd1p, *bnd2p;
  ub2 i;

  /* define the application request  */
  checkerr(errhp, OCIStmtPrepare(stmthp, errhp, (text *) insstmt,
           (ub4) strlen((char *)insstmt),
           (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));

  /* bind the input variable */
 checkerr(errhp, OCIBindByName(stmthp, &amp;bnd1p, errhp, (text *) ":custno",
          (sb4) -1, (void  *) &amp;custno,
          (sb4) sizeof(sword), SQLT_INT,
          (void  *) 0, (ub2 *)0, (ub2 *)0, (ub4) 0, (ub4 *) 0,
          (ub4) OCI_DEFAULT));

  checkerr(errhp, OCIBindByName(stmthp, &amp;bnd2p, errhp, (text *) ":addr",
          (sb4) -1, (void  *) 0,
          (sb4) 0, SQLT_NTY, (void  *) 0, (ub2 *)0, (ub2 *)0,
          (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT));

  checkerr(errhp,
                OCITypeByName(envhp, errhp, svchp, (const text *)
                SCHEMA, (ub4) strlen((char *)SCHEMA),
                (const text *)"ADDRESS_VALUE",
                (ub4) strlen((char *)"ADDRESS_VALUE"),
                (text *)0, 0, OCI_DURATION_SESSION,
                OCI_TYPEGET_HEADER, &amp;addr_tdo));

  if(!addr_tdo)
  {
    printf("Null tdo returned\n");
    return;
  }

  checkerr(errhp, OCIBindObject(bnd2p, errhp, addr_tdo, (void  **) &amp;addr,
        (ub4 *) 0, (void  **) &amp;naddr, (ub4 *) 0));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="LNOCI16906" class="sect2"><a id="sthref1987"></a>
<h3 class="sect2">SQLT_NTY Define Example<a id="sthref1988"></a></h3>
<p><a href="#BGBDFDAD">Example 12-17</a> shows how to use the <code>SQLT_NTY</code> named data type in the define call including <a href="oci16rel003.htm#i555538">OCIDefineObject()</a>.</p>
<div id="LNOCI18262" class="example">
<p class="titleinexample"><a id="BGBDFDAD"></a>Example 12-17 Using the SQLT_NTY Define Call Including OCIDefineObject()</p>
<pre>
/*
** This example executes a SELECT statement from a table that includes
** an object.
*/

void selectval(envhp, svchp, stmthp, errhp)
OCIEnv *envhp;
OCISvcCtx *svchp;
OCIStmt *stmthp;
OCIError *errhp;
{
  OCIType *addr_tdo = (OCIType *)0;
  OCIDefine *defn1p, *defn2p;
  address *addr = (address *)NULL;
  sword custno =0;
  sb4 status;

  /* define the application request  */
  checkerr(errhp, OCIStmtPrepare(stmthp, errhp, (text *) selvalstmt,
                        (ub4) strlen((char *)selvalstmt),
                        (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT));

  /* define the output variable */
checkerr(errhp, OCIDefineByPos(stmthp, &amp;defn1p, errhp, (ub4) 1, (void  *)
       &amp;custno, (sb4) sizeof(sword), SQLT_INT, (void  *) 0, (ub2 *)0,
       (ub2 *)0, (ub4) OCI_DEFAULT));

checkerr(errhp, OCIDefineByPos(stmthp, &amp;defn2p, errhp, (ub4) 2, (void  *)
        0, (sb4) 0, SQLT_NTY, (void  *) 0, (ub2 *)0,
        (ub2 *)0, (ub4) OCI_DEFAULT));

checkerr(errhp,
               OCITypeByName(envhp, errhp, svchp, (const text *)
               SCHEMA, (ub4) strlen((char *)SCHEMA),
               (const text *) "ADDRESS_VALUE",
               (ub4) strlen((char *)"ADDRESS_VALUE"),
               (text *)0, 0, OCI_DURATION_SESSION,
               OCI_TYPEGET_HEADER, &amp;addr_tdo));

  if(!addr_tdo)
  {
    printf("NULL tdo returned\n");
    return;
  }


  checkerr(errhp, OCIDefineObject(defn2p, errhp, addr_tdo, (void  **)
       &amp;addr, (ub4 *) 0, (void  **) 0, (ub4 *) 0));

  checkerr(errhp, OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
       (OCISnapshot *) NULL, (OCISnapshot *) NULL, (ub4) OCI_DEFAULT));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci11obj.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci13obn.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
