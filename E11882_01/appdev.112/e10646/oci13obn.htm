<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Direct Path Loading</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:24Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci12oty.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci14oca.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">20/79</span> <!-- End Header -->
<div id="LNOCI120" class="chapter"><a id="g443680"></a> <a id="i433129"></a>
<h1 class="chapter"><span class="secnum">13</span> Direct Path Loading</h1>
<p>The direct path loading functions are used to load data from external files into tables and partitions.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i426339">Direct Path Loading Overview</a></p>
</li>
<li>
<p><a href="#i426844">Direct Path Loading of Object Types</a></p>
</li>
<li>
<p><a href="#i429049">Direct Path Loading in Pieces</a></p>
</li>
<li>
<p><a href="#i429028">Direct Path Context Handles and Attributes for Object Types</a></p>
</li>
</ul>
<a id="i426339"></a>
<div id="LNOCI16907" class="sect1">
<h2 class="sect1"><a id="sthref1989"></a>Direct Path Loading Overview</h2>
<p>The direct path load interface enables an OCI application to access the direct path load engine of Oracle Database to perform the functions of the SQL*Loader utility. This functionality provides the ability to load data from external files into either a table or a partition of a partitioned table.</p>
<p><a href="#CHDDEJBF">Figure 13-1</a> introduces the subject of this chapter. On the client side of the illustration, data enters a column array through an input buffer. The <a href="oci17msc004.htm#i557345">OCIDirPathColArrayToStream()</a> call moves the data to the server side through stream formats. These pass data to a column array that uses a block formatter to send the data to the database table.</p>
<div id="LNOCI16908" class="figure">
<p class="titleinfigure"><a id="CHDDEJBF"></a>Figure 13-1 Direct Path Loading</p>
<img width="660" height="323" src="img/lnoci040.gif" alt="Description of Figure 13-1 follows" /><br />
<a id="sthref1990" href="img_text/lnoci040.htm">Description of "Figure 13-1 Direct Path Loading"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The OCI direct path load interface can load multiple rows by loading a direct path stream that contains data for multiple rows.</p>
<p>To use the direct path API, the client application performs the following steps:</p>
<ol>
<li>
<p>Initialize OCI.</p>
</li>
<li>
<p>Allocate a direct path context handle and set the attributes.</p>
</li>
<li>
<p>Supply the name of the object (table, partition, or subpartition) to be loaded.</p>
</li>
<li>
<p>Describe the external data types of the columns of the object.</p>
</li>
<li>
<p>Prepare the direct path interface.</p>
</li>
<li>
<p>Allocate one or more column arrays.</p>
</li>
<li>
<p>Allocate one or more direct path streams.</p>
</li>
<li>
<p>Set entries in the column array to point to the input data value for each column.</p>
</li>
<li>
<p>Convert a column array to a direct path stream format.</p>
</li>
<li>
<p>Load the direct path stream.</p>
</li>
<li>
<p>Retrieve any errors that may have occurred.</p>
</li>
<li>
<p>Invoke the direct path finishing function.</p>
</li>
<li>
<p>Free handles and data structures.</p>
</li>
<li>
<p>Disconnect from the server.</p>
</li>
</ol>
<p>Steps 8 through 11 can be repeated many times, depending on the data to be loaded.</p>
<p>A direct load operation requires that the object being loaded is locked to prevent DML operations on the object. Note that queries are lock-free and are allowed while the object is being loaded. The mode of the DML lock, and which DML locks are obtained, depend upon the specification of the <a id="sthref1991"></a><code>OCI_ATTR_DIRPATH_PARALLEL</code> option, and if a partition or subpartition load is being done as opposed to an entire table load.</p>
<ul>
<li>
<p>For a table load, if the <code>OCI_ATTR_DIRPATH_PARALLEL</code> option is set to:</p>
<ul>
<li>
<p>FALSE, then the table DML X-Lock is acquired</p>
</li>
<li>
<p>TRUE, then the table DML S-Lock is acquired</p>
</li>
</ul>
</li>
<li>
<p>For a partition load, if the <code>OCI_ATTR_DIRPATH_PARALLEL</code> option is set to:</p>
<ul>
<li>
<p>FALSE, then the table DML SX-Lock and partition DML X-Lock are acquired</p>
</li>
<li>
<p>TRUE, then the table DML SS-Lock and partition DML S-Lock are acquired</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i453506">"Direct Path Context Handle (OCIDirPathCtx) Attributes"</a></div>
<div id="LNOCI16909" class="sect2"><a id="sthref1992"></a>
<h3 class="sect2">Data Types Supported for Direct Path Loading</h3>
<p><a id="sthref1993"></a><a id="sthref1994"></a>The following external data types are valid for scalar columns in a direct path load operation:</p>
<ul>
<li>
<p><code>SQLT_CHR</code></p>
</li>
<li>
<p><code>SQLT_DAT</code></p>
</li>
<li>
<p><code>SQLT_INT</code></p>
</li>
<li>
<p><code>SQLT_UIN</code></p>
</li>
<li>
<p><code>SQLT_FLT</code></p>
</li>
<li>
<p><code>SQLT_BIN</code></p>
</li>
<li>
<p><code>SQLT_NUM</code></p>
</li>
<li>
<p><code>SQLT_PDN</code></p>
</li>
<li>
<p><code>SQLT_CLOB</code></p>
</li>
<li>
<p><code>SQLT_BLOB</code></p>
</li>
<li>
<p><code>SQLT_DATE</code></p>
</li>
<li>
<p><code>SQLT_TIMESTAMP</code></p>
</li>
<li>
<p><code>SQLT_TIMESTAMP_TZ</code></p>
</li>
<li>
<p><code>SQLT_TIMESTAMP_LTZ</code></p>
</li>
<li>
<p><code>SQLT_INTERVAL_YM</code></p>
</li>
<li>
<p><code>SQLT_INTERVAL_DS</code></p>
</li>
</ul>
<p>The following external object data types are supported:</p>
<ul>
<li>
<p><code>SQLT_NTY</code> - column objects (<code>FINAL</code> and <code>NOT FINAL</code>) and SQL string columns</p>
</li>
<li>
<p><code>SQLT_REF</code> - <code>REF</code> columns (<code>FINAL</code> and <code>NOT FINAL</code>)</p>
</li>
</ul>
<p>The following table types are supported:</p>
<ul>
<li>
<p>Nested tables</p>
</li>
<li>
<p>Object tables (<code>FINAL</code> and <code>NOT FINAL</code>)</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ociaahan.htm#BAJIIHDA">"Accessing Column Parameter Attributes"</a> for information on setting or retrieving the data type of a column</p>
</li>
<li>
<p><a href="oci03typ.htm#CEGIEEJI">Table 3-2</a> for information about data types</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="LNOCI16910" class="sect2"><a id="sthref1995"></a>
<h3 class="sect2"><a id="sthref1996"></a>Direct Path Handles</h3>
<p>A direct path load corresponds to a direct path array insert operation. The direct path load interface uses the following handles to keep track of the objects loaded and the specification of the data operated on:</p>
<ul>
<li>
<p><a href="#BAJGEJDC">Direct Path Context</a></p>
</li>
<li>
<p><a href="#CACEEHHE">OCI Direct Path Function Context</a></p>
</li>
<li>
<p><a href="#CACDIIEI">Direct Path Column Array and Direct Path Function Column Array</a></p>
</li>
<li>
<p><a href="#i428926">Direct Path Stream</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i444702">"Direct Path Loading Handle Attributes"</a> and all the descriptions of direct path attributes that follow</div>
</li>
</ul>
<a id="BAJGEJDC"></a>
<div id="LNOCI16911" class="sect3">
<h4 class="sect3">Direct Path Context<a id="sthref1997"></a></h4>
<p>The direct path context handle must be allocated for each object, either a table or a partition of a partitioned table, being loaded. Because an <code><a id="sthref1998"></a>OCIDirPathCtx</code> handle is the parent handle of the <code>OCIDirPathFuncCtx</code>, <code><a id="sthref1999"></a>OCIDirPathColArray,</code> and <code><a id="sthref2000"></a>OCIDirPathStream</code> handles, freeing an <code>OCIDirPathCtx</code> handle frees its child handles also (although for good coding practices, free child handles individually before you free the parent handle).</p>
<p>A direct path context is allocated with <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. Note that the parent handle of a direct path context is always the environment handle. A direct path context is freed with <a href="oci16rel002.htm#i540911">OCIHandleFree()</a>. Include the header files in the first two lines in all direct path programs, as shown in <a href="#CACIIBIB">Example 13-1</a>.</p>
<div id="LNOCI18263" class="example">
<p class="titleinexample"><a id="CACIIBIB"></a>Example 13-1 Direct Path Programs Must Include the Header Files</p>
<pre>
...
#include &lt;cdemodp0.h&gt;
#include &lt;cdemodp.h&gt;

OCIEnv *envp;
OCIDirPathCtx *dpctx;
sword error;
error = OCIHandleAlloc((void  *)envp, (void  **)&amp;dpctx,
                    OCI_HTYPE_DIRPATH_CTX, (size_t)0,(void  **)0);
...
error = OCIHandleFree(dpctx, OCI_HTYPE_DIRPATH_CTX);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CACEEHHE"></a>
<div id="LNOCI16912" class="sect3">
<h4 class="sect3"><a id="sthref2001"></a>OCI Direct Path Function Context</h4>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ00204" href="../../appdev.112/e11822/adobjcol.htm#ADOBJ00204"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for more information about the data types supported</div>
<p>The direct path function context handle, of type <code>OCIDirPathFuncCtx</code>, is used to describe the following named type and <code>REF</code> columns:</p>
<ul>
<li>
<p>Column objects. The function context here describes the object type, which is to be used as the default constructor to construct the object, and the object attributes of the constructor.</p>
</li>
<li>
<p><code>REF</code> columns. The function context here describes a single object table (optional) to reference row objects from, and the <code>REF</code> arguments that identify each row object.</p>
</li>
<li>
<p>SQL string columns. The function context here describes a SQL string and its arguments to compute the value to be loaded into the column.</p>
</li>
</ul>
<p>The handle type <code>OCI_HTYPE_DIRPATH_FN_CTX</code> is passed to <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> to indicate that a function context is to be allocated, as shown in <a href="#CACGFJGC">Example 13-2</a>.</p>
<div id="LNOCI18264" class="example">
<p class="titleinexample"><a id="CACGFJGC"></a>Example 13-2 Passing the Handle Type to Allocate the Function Context</p>
<pre>
OCIDirPathCtx *dpctx;       /* direct path context */
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
sword error;

error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpfnctx,
                       OCI_HTYPE_DIRPATH_FN_CTX,
                       (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" -->
<p>Note that the parent handle of a direct path function context is always the direct path context handle. A direct path function context handle is freed with <a href="oci16rel002.htm#i540911">OCIHandleFree()</a>:</p>
<pre>
error = OCIHandleFree(dpfnctx, OCI_HTYPE_DIRPATH_FN_CTX);
</pre></div>
<!-- class="sect3" -->
<a id="CACDIIEI"></a>
<div id="LNOCI16913" class="sect3">
<h4 class="sect3">Direct Path Column Array and Direct Path Function Column Array<a id="sthref2002"></a></h4>
<p>The direct path column array handle and direct path function column handle are used to present an array of rows to the direct path interface. A row is represented by three arrays: column values, column lengths, and column flags. Methods used on a column array include: allocate the array handle and set or get values corresponding to an array entry.</p>
<p>Both handles share the same data structure, <code>OCIDirPathColArray</code>, but these column array handles differ in parent handles and handle types.</p>
<p>A direct path column array handle is allocated with <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. The code fragment in <a href="#CACBICAG">Example 13-3</a> shows explicit allocation of the direct path column array handle.</p>
<div id="LNOCI18265" class="example">
<p class="titleinexample"><a id="CACBICAG"></a>Example 13-3 Explicit Allocation of Direct Path Column Array Handle</p>
<pre>
OCIDirPathCtx *dpctx;      /* direct path context */
OCIDirPathColArray *dpca;  /* direct path column array */
sword error;
error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpca,
               OCI_HTYPE_DIRPATH_COLUMN_ARRAY, 
               (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" -->
<p>A direct path column array handle is freed with <code>OCIHandleFree()</code>.</p>
<pre>
error = OCIHandleFree(dpca, OCI_HTYPE_DIRPATH_COLUMN_ARRAY);
</pre>
<p><a href="#CACEDGCI">Example 13-4</a> shows that a direct path function column array handle is allocated in almost the same way.</p>
<div id="LNOCI18266" class="example">
<p class="titleinexample"><a id="CACEDGCI"></a>Example 13-4 Explicit Allocation of Direct Path Function Column Array Handle</p>
<pre>
OCIDirPathFuncCtx *dpfnctx;   /* direct path function context */
OCIDirPathColArray *dpfnca;   /* direct path function column array */
sword error;
error = OCIHandleAlloc((void  *)dpfnctx, (void  **)&amp;dpfnca,
                        (ub4)OCI_HTYPE_DIRPATH_FN_COL_ARRAY,
                        (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" -->
<p>A direct path function column array is freed with <code>OCIHandleFree()</code>:</p>
<pre>
error = OCIHandleFree(dpfnca, OCI_HTYPE_DIRPATH_FN_COL_ARRAY);
</pre>
<p>Freeing an <code>OCIDirPathColArray</code> handle also frees the column array associated with the handle.</p>
</div>
<!-- class="sect3" -->
<a id="i428926"></a>
<div id="LNOCI16914" class="sect3">
<h4 class="sect3">Direct Path Stream<a id="sthref2003"></a></h4>
<p>The direct path stream handle is used by the conversion operation, <a href="oci17msc004.htm#i557345">OCIDirPathColArrayToStream()</a>, and by the load operation, <a href="oci17msc004.htm#i557793">OCIDirPathLoadStream()</a>.</p>
<p>Direct path stream handles are allocated by the client with <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. The structure of an <code>OCIDirPathStream</code> handle can be thought of as a pair in the form (buffer, buffer length).</p>
<p>A direct path stream is a linear representation of Oracle table data. The conversion operations always append to the end of the stream. Load operations always start from the beginning of the stream. After a stream is completely loaded, the stream must be reset by calling <a href="oci17msc004.htm#i563566">OCIDirPathStreamReset()</a>.</p>
<p><a href="#CACGGEEA">Example 13-5</a> shows a direct path stream handle allocated with <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a>. The parent handle is always an <code>OCIDirPathCtx</code> handle.</p>
<div id="LNOCI18267" class="example">
<p class="titleinexample"><a id="CACGGEEA"></a>Example 13-5 Allocating a Direct Path Stream Handle</p>
<pre>
OCIDirPathCtx *dpctx;    /* direct path context */
OCIDirPathStream *dpstr; /* direct path stream */
sword error;
error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpstr,
               OCI_HTYPE_DIRPATH_STREAM, (size_t)0,(void  **)0);
</pre></div>
<!-- class="example" -->
<p>A direct path stream handle is freed using <code>OCIHandleFree()</code>.</p>
<pre>
error = OCIHandleFree(dpstr, OCI_HTYPE_DIRPATH_STREAM);
</pre>
<p>Freeing an <code>OCIDirPathStream</code> handle also frees the stream buffer associated with the handle.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16915" class="sect2"><a id="sthref2004"></a>
<h3 class="sect2"><a id="sthref2005"></a>Direct Path Interface Functions</h3>
<p>The functions listed in this section are used with the direct path load interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci17msc004.htm#CIHBFHJJ">"Direct Path Loading Functions"</a> for detailed descriptions of each function</div>
<p>Operations on the direct path context are performed by the functions in <a href="#CACFGHAG">Table 13-1</a>.</p>
<div id="LNOCI16916" class="tblformal">
<p class="titleintable"><a id="sthref2006"></a><a id="CACFGHAG"></a>Table 13-1 Direct Path Context Functions</p>
<table class="cellalignment1016" title="Direct Path Context Functions" summary="Direct Path Context Functions" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t7">Function</th>
<th class="cellalignment1012" id="r1c2-t7">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t7" headers="r1c1-t7">
<p><a href="oci17msc004.htm#i580214">OCIDirPathAbort()</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t7 r1c2-t7">
<p>Terminates a direct path operation</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t7" headers="r1c1-t7">
<p><a href="oci17msc004.htm#i557393">OCIDirPathDataSave()</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t7 r1c2-t7">
<p>Executes a data savepoint</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t7" headers="r1c1-t7">
<p><a href="oci17msc004.htm#i563562">OCIDirPathFinish()</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t7 r1c2-t7">
<p>Commits the loaded data</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t7" headers="r1c1-t7">
<p><a href="oci17msc004.htm#i557759">OCIDirPathFlushRow()</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t7 r1c2-t7">
<p>Flushes a partially loaded row from the server. This function is deprecated.</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t7" headers="r1c1-t7">
<p><a href="oci17msc004.htm#i557793">OCIDirPathLoadStream()</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t7 r1c2-t7">
<p>Loads the data that has been converted to direct path stream format</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t7" headers="r1c1-t7">
<p><a href="oci17msc004.htm#i557836">OCIDirPathPrepare()</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t7 r1c2-t7">
<p>Prepares the direct path interface to convert or load rows</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Operations on the direct path column array are performed by the functions in <a href="#g434329">Table 13-2</a>.</p>
<div id="LNOCI16917" class="tblformal">
<p class="titleintable"><a id="sthref2007"></a><a id="g434329"></a>Table 13-2 Direct Path Column Array Functions</p>
<table class="cellalignment1016" title="Direct Path Column Array Functions" summary="Direct Path Column Array functions" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t8">Function</th>
<th class="cellalignment1012" id="r1c2-t8">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t8" headers="r1c1-t8">
<p><a href="oci17msc004.htm#i563564">OCIDirPathColArrayEntryGet()</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t8 r1c2-t8">
<p>Gets a specified entry in a column array</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t8" headers="r1c1-t8">
<p><a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t8 r1c2-t8">
<p>Sets a specified entry in a column array to a specific value</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t8" headers="r1c1-t8">
<p><a href="oci17msc004.htm#i557275">OCIDirPathColArrayRowGet()</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t8 r1c2-t8">
<p>Gets the base row pointers for a specified row number</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t8" headers="r1c1-t8">
<p><a href="oci17msc004.htm#i557316">OCIDirPathColArrayReset()</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t8 r1c2-t8">
<p>Resets the row array state</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t8" headers="r1c1-t8">
<p><a href="oci17msc004.htm#i557345">OCIDirPathColArrayToStream()</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t8 r1c2-t8">
<p>Converts from a column array format to a direct path stream format</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Operations on the direct path stream are performed by the function <a href="oci17msc004.htm#i563566">OCIDirPathStreamReset()</a> that resets the direct stream state.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16918" class="sect2"><a id="sthref2008"></a>
<h3 class="sect2"><a id="sthref2009"></a>Limitations and Restrictions of the Direct Path Load Interface</h3>
<p>The direct path load interface has the following limitations that are the same as SQL*Loader:</p>
<ul>
<li>
<p>Triggers are not supported.</p>
</li>
<li>
<p>Referential integrity constraints are not supported.</p>
</li>
<li>
<p>Clustered tables are not supported.</p>
</li>
<li>
<p>Loading of remote objects is not supported.</p>
</li>
<li>
<p><code>LONGs</code> must be specified last.</p>
</li>
<li>
<p>SQL strings that return LOBs, objects, or collections are not supported.</p>
</li>
<li>
<p>Loading of <code><a id="sthref2010"></a>VARRAY</code> columns is not supported.</p>
</li>
<li>
<p>All partitioning columns must come before any LOBs. This is because you must determine what partition the LOB goes into before you start writing to it.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i426660"></a>
<div id="LNOCI16919" class="sect2">
<h3 class="sect2"><a id="sthref2011"></a>Direct Path Load Examples for Scalar Columns</h3>
<p>This section describes the direct path load examples for scalar columns.</p>
<div id="LNOCI16920" class="sect3"><a id="sthref2012"></a>
<h4 class="sect3">Data Structures Used in Direct Path Loading Example</h4>
<p><a href="#CACBDCEE">Example 13-6</a> shows the data structure used in <a href="#CACBEJCG">Example 13-7</a> through <a href="#CACDGHIB">Example 13-17</a>.</p>
<div id="LNOCI18268" class="example">
<p class="titleinexample"><a id="CACBDCEE"></a>Example 13-6 Data Structures Used in Direct Path Loading Examples</p>
<pre>
/* load control structure */
struct loadctl
{
  ub4                 nrow_ctl;            /* number of rows in column array */
  ub2                 ncol_ctl;         /* number of columns in column array */
  OCIEnv             *envhp_ctl;                       /* environment handle */
  OCIServer          *srvhp_ctl;                            /* server handle */
  OCIError           *errhp_ctl;                             /* error handle */
  OCIError           *errhp2_ctl;                /* yet another error handle */
  OCISvcCtx          *svchp_ctl;                          /* service context */
  OCISession         *authp_ctl;                   /* authentication context */
  OCIParam           *colLstDesc_ctl;        /* column list parameter handle */
  OCIDirPathCtx      *dpctx_ctl;                      /* direct path context */
  OCIDirPathColArray *dpca_ctl;           /* direct path column array handle */
  OCIDirPathColArray *dpobjca_ctl;          /* dp column array handle for obj*/
  OCIDirPathColArray *dpnestedobjca_ctl;  /* dp col array hndl for nested obj*/
  OCIDirPathStream   *dpstr_ctl;                /* direct path stream handle */
  ub1                *buf_ctl;    /* pre-alloc'd buffer for out-of-line data */
  ub4                 bufsz_ctl;                 /* size of buf_ctl in bytes */
  ub4                 bufoff_ctl;                     /* offset into buf_ctl */
  ub4                *otor_ctl;                  /* Offset to Recnum mapping */
  ub1                *inbuf_ctl;                 /* buffer for input records */
  struct pctx         pctx_ctl;                     /* partial field context */
  boolean             loadobjcol_ctl;             /* load to obj col(s)? T/F */
};
</pre></div>
<!-- class="example" -->
<p><a href="#CACBEJCG">Example 13-7</a> shows the header file <code>cdemodp.h</code> from the <code>demo</code> directory, which defines several structs.</p>
<div id="LNOCI18269" class="example">
<p class="titleinexample"><a id="CACBEJCG"></a>Example 13-7 Contents of the Header File cdemodp.h</p>
<pre>
#ifndef cdemodp_ORACLE
# define cdemodp_ORACLE

# include &lt;oratypes.h&gt;

# ifndef externdef
#  define externdef
# endif

/* External column attributes */
struct col
{
  text *name_col;                                             /* column name */
  ub2   id_col;                                            /* column load ID */
  ub2   exttyp_col;                                         /* external type */
  text *datemask_col;                             /* datemask, if applicable */
  ub1   prec_col;                                /* precision, if applicable */
  sb1   scale_col;                                   /* scale, if applicable */
  ub2   csid_col;                                        /* character set ID */
  ub1   date_col;            /* is column a chrdate or date? 1=TRUE. 0=FALSE */
  struct obj * obj_col;          /* description of object, if applicable */
#define COL_OID 0x1                                         /* col is an OID */
  ub4   flag_col;
};

/* Input field descriptor
 * For this example (and simplicity),
 * fields are strictly positional.
 */
struct fld
{
  ub4  begpos_fld;                             /* 1-based beginning position */
  ub4  endpos_fld;                             /* 1-based ending    position */
  ub4  maxlen_fld;                       /* max length for out-of-line field */
  ub4    flag_fld;
#define FLD_INLINE            0x1
#define FLD_OUTOFLINE         0x2
#define FLD_STRIP_LEAD_BLANK  0x4
#define FLD_STRIP_TRAIL_BLANK 0x8
};

struct obj
{
  text               *name_obj;                                /* type  name*/
  ub2                 ncol_obj;              /* number of columns in col_obj*/
  struct col         *col_obj;                          /* column attributes*/
  struct fld         *fld_obj;                           /* field descriptor*/
  ub4                 rowoff_obj;  /* current row offset in the column array*/
  ub4                 nrows_obj;              /* number of rows in col array*/
  OCIDirPathFuncCtx  *ctx_obj;       /* Function context for this obj column*/
  OCIDirPathColArray *ca_obj;           /* column array  for this obj column*/
  ub4                 flag_obj;                              /* type of obj */
#define OBJ_OBJ  0x1                                             /* obj col */
#define OBJ_OPQ  0x2                                  /* opaque/sql str col */
#define OBJ_REF  0x4                                             /* ref col */
};

struct tbl
{
  text        *owner_tbl;                                     /* table owner */
  text        *name_tbl;                                       /* table name */
  text        *subname_tbl;                        /* subname, if applicable */
  ub2          ncol_tbl;                     /* number of columns in col_tbl */
  text        *dfltdatemask_tbl;            /* table level default date mask */
  struct col  *col_tbl;                                 /* column attributes */
  struct fld  *fld_tbl;                                  /* field descriptor */
  ub1          parallel_tbl;                         /* parallel: 1 for true */
  ub1          nolog_tbl;                          /* no logging: 1 for true */
  ub4          xfrsz_tbl;                   /* transfer buffer size in bytes */
  text         *objconstr_tbl;   /* obj constr/type if loading a derived obj */
};

struct sess                        /* options for a direct path load session */
{
  text        *username_sess;                                        /* user */
  text        *password_sess;                                    /* password */
  text        *inst_sess;                            /* remote instance name */
  text        *outfn_sess;                                /* output filename */
  ub4          maxreclen_sess;          /* max size of input record in bytes */
};
#endif                                              /* cdemodp_ORACLE */
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16921" class="sect3"><a id="sthref2013"></a>
<h4 class="sect3">Outline of an Example of a Direct Path Load for Scalar Columns</h4>
<p><a href="#CACHIHDD">Example 13-8</a> shows sample code that illustrates the use of several of the OCI direct path interfaces. It is not a complete code example.</p>
<p>The <span class="italic">init_load</span> function performs a direct path load using the direct path API on the table described by <span class="italic">tblp</span>. The <span class="italic">loadctl</span> structure given by <span class="italic">ctlp</span> has an appropriately initialized environment and service context. A connection has been made to the server.</p>
<div id="LNOCI18270" class="example">
<p class="titleinexample"><a id="CACHIHDD"></a>Example 13-8 Use of OCI Direct Path Interfaces</p>
<pre>
STATICF void
init_load(ctlp, tblp)
struct loadctl *ctlp;
struct tbl     *tblp;
{
  struct  col   *colp;
  struct  fld   *fldp;
  sword          ociret;                       /* return code from OCI calls */
  OCIDirPathCtx *dpctx;                               /* direct path context */
  OCIParam      *colDesc;                     /* column parameter descriptor */
  ub1            parmtyp;
  ub1           *timestamp = (ub1 *)0;
  ub4            size;
  ub4            i;
  ub4            pos;

  /* allocate and initialize a direct path context */
  /* See cdemodp.c for the definition of OCI_CHECK */
  OCI_CHECK(ctlp-&gt;envhp_ctl, OCI_HTYPE_ENV, ociret, ctlp,
            OCIHandleAlloc((void  *)ctlp-&gt;envhp_ctl,
                           (void  **)&amp;ctlp-&gt;dpctx_ctl,
                           (ub4)OCI_HTYPE_DIRPATH_CTX,
                           (size_t)0, (void  **)0));

  dpctx = ctlp-&gt;dpctx_ctl;                                      /* shorthand */

  OCI_CHECK(ctlp-&gt;errhp_ctl, OCI_HTYPE_ERROR, ociret, ctlp,
            OCIAttrSet((void  *)dpctx, (ub4)OCI_HTYPE_DIRPATH_CTX,
                       (void  *)tblp-&gt;name_tbl,
                       (ub4)strlen((const char *)tblp-&gt;name_tbl),
                       (ub4)OCI_ATTR_NAME, ctlp-&gt;errhp_ctl));
</pre></div>
<!-- class="example" -->
<p>Additional attributes, such as <code>OCI_ATTR_SUB_NAME</code> and <code>OCI_ATTR_SCHEMA_NAME</code>, are also set here. After the attributes have been set, prepare the load.</p>
<pre>
  OCI_CHECK(ctlp-&gt;errhp_ctl, OCI_HTYPE_ERROR, ociret, ctlp,
            OCIDirPathPrepare(dpctx, ctlp-&gt;svchp_ctl, ctlp-&gt;errhp_ctl));
</pre>
<p class="subhead2"><a id="LNOCI18271"></a>Allocate the Column Array and Stream Handles</p>
<p>Note that the direct path context handle is the parent handle for the column array and stream handles, as shown in <a href="#CACIBGCE">Example 13-9</a>. Also note that errors are returned with the environment handle associated with the direct path context.</p>
<div id="LNOCI18272" class="example">
<p class="titleinexample"><a id="CACIBGCE"></a>Example 13-9 Allocating the Column Array and Stream Handles</p>
<pre>
   OCI_CHECK(ctlp-&gt;envhp_ctl, OCI_HTYPE_ENV, ociret, ctlp,
            OCIHandleAlloc((void  *)ctlp-&gt;dpctx_ctl, (void  **)&amp;ctlp-&gt;dpca_ctl,
                           (ub4)OCI_HTYPE_DIRPATH_COLUMN_ARRAY,
                           (size_t)0, (void  **)0));

  OCI_CHECK(ctlp-&gt;envhp_ctl, OCI_HTYPE_ENV, ociret, ctlp,
            OCIHandleAlloc((void  *)ctlp-&gt;dpctx_ctl,(void  **)&amp;ctlp-&gt;dpstr_ctl,
                           (ub4)OCI_HTYPE_DIRPATH_STREAM,
                           (size_t)0, (void  **)0));
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18273"></a>Get the Number of Rows and Columns</p>
<p>Get the number of rows and columns in the column array just allocated, as shown in <a href="#CACEDHIG">Example 13-10</a>.</p>
<div id="LNOCI18274" class="example">
<p class="titleinexample"><a id="CACEDHIG"></a>Example 13-10 Getting the Number of Rows and Columns</p>
<pre>
  OCI_CHECK(ctlp-&gt;errhp_ctl, OCI_HTYPE_ERROR, ociret, ctlp,
            OCIAttrGet(ctlp-&gt;dpca_ctl, (ub4)OCI_HTYPE_DIRPATH_COLUMN_ARRAY,
                       &amp;ctlp-&gt;nrow_ctl, 0, OCI_ATTR_NUM_ROWS,
                       ctlp-&gt;errhp_ctl));

   OCI_CHECK(ctlp-&gt;errhp_ctl, OCI_HTYPE_ERROR, ociret, ctlp,
            OCIAttrGet(ctlp-&gt;dpca_ctl, (ub4)OCI_HTYPE_DIRPATH_COLUMN_ARRAY,
                       &amp;ctlp-&gt;ncol_ctl, 0, OCI_ATTR_NUM_COLS,
                       ctlp-&gt;errhp_ctl));
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18275"></a>Set the Input Data Fields</p>
<p>Set the input data fields to their corresponding data columns, as shown in <a href="#CACEEJGJ">Example 13-11</a>.</p>
<div id="LNOCI18276" class="example">
<p class="titleinexample"><a id="CACEEJGJ"></a>Example 13-11 Setting Input Data Fields</p>
<pre>
ub4            rowoff;                          /* column array row offset */
ub4            clen;                                      /* column length */
ub1            cflg;                                  /* column state flag */
ub1           *cval;                             /* column character value */

OCI_CHECK(ctlp-&gt;errhp_ctl, OCI_HTYPE_ERROR, ociret, ctlp,
            OCIDirPathColArrayEntrySet(ctlp-&gt;dpca_ctl, ctlp-&gt;errhp_ctl,
                                       rowoff, colp-&gt;id_col,
                                       cval, clen, cflg));
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18277"></a>Reset the Column Array State</p>
<p>Reset the column array state in case a previous conversion must be continued or a row is expecting more data, as shown in <a href="#CACGHJED">Example 13-12</a>.</p>
<div id="LNOCI18278" class="example">
<p class="titleinexample"><a id="CACGHJED"></a>Example 13-12 Resetting the Column Array State</p>
<pre>
(void) OCIDirPathColArrayReset(ctlp-&gt;dpca_ctl, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18279"></a>Reset the Stream State</p>
<p>Reset the stream state to start a new stream, as shown in <a href="#CACJCJHC">Example 13-13</a>. Otherwise, data in the stream is appended to existing data.</p>
<div id="LNOCI18280" class="example">
<p class="titleinexample"><a id="CACJCJHC"></a>Example 13-13 Resetting the Stream State</p>
<pre>
(void) OCIDirPathStreamReset(ctlp-&gt;dpstr_ctl, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18281"></a>Convert the Data in the Column Array to Stream Format</p>
<p>After inputting the data, convert the data in the column array to stream format and filter out any bad records, as shown in <a href="#CACIIBGH">Example 13-14</a>.</p>
<div id="LNOCI18282" class="example">
<p class="titleinexample"><a id="CACIIBGH"></a>Example 13-14 Converting Data to Stream Format</p>
<pre>
ub4            rowcnt;                   /* number of rows in column array */
ub4            startoff;         /* starting row offset into column array  */

/* convert array to stream, filter out bad records */
ocierr = OCIDirPathColArrayToStream(ctlp-&gt;dpca_ctl, ctlp-&gt;dpctx_ctl,
                                        ctlp-&gt;dpstr_ctl, ctlp-&gt;errhp_ctl,
                                        rowcnt, startoff);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18283"></a>Load the Stream</p>
<p>Note that the position in the stream is maintained internally to the stream handle, along with offset information for the column array that produced the stream. When the conversion to stream format is done, the data is appended to the stream, as shown in <a href="#CACGJIHI">Example 13-15</a>. It is the responsibility of the caller to reset the stream when appropriate. On errors, the position is moved to the next row, or to the end of the stream if the error occurs on the last row. The next <a href="oci17msc004.htm#i557793">OCIDirPathLoadStream()</a> call starts on the next row, if any. If an <code>OCIDirPathLoadStream()</code> call is made and the end of a stream has been reached, <code>OCI_NO_DATA</code> is returned.</p>
<div id="LNOCI18284" class="example">
<p class="titleinexample"><a id="CACGJIHI"></a>Example 13-15 Loading the Stream</p>
<pre>
/* load the stream */
ociret = OCIDirPathLoadStream(ctlp-&gt;dpctx_ctl, ctlp-&gt;dpstr_ctl,
            ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18285"></a>Finish the Direct Path Load</p>
<p>Finish the direct path load as shown in <a href="#CACHAHGB">Example 13-16</a>.</p>
<div id="LNOCI18286" class="example">
<p class="titleinexample"><a id="CACHAHGB"></a>Example 13-16 Finishing the Direct Path Load Operation</p>
<pre>
/* finish the direct path load operation */
OCI_CHECK(ctlp-&gt;errhp_ctl, OCI_HTYPE_ERROR, ociret, ctlp,
          OCIDirPathFinish(ctlp-&gt;dpctx_ctl, ctlp-&gt;errhp_ctl));
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18287"></a>Free the Direct Path Handles</p>
<p>Free all the direct path handles allocated, as shown in <a href="#CACDGHIB">Example 13-17</a>. Note that the direct path column array and stream handles are freed before the parent direct path context handle is freed.</p>
<div id="LNOCI18288" class="example">
<p class="titleinexample"><a id="CACDGHIB"></a>Example 13-17 Freeing the Direct Path Handles</p>
<pre>
/* free up server data structures for the load */
ociret = OCIHandleFree((void  *)ctlp-&gt;dpca_ctl,
                           OCI_HTYPE_DIRPATH_COLUMN_ARRAY);
ociret = OCIHandleFree((void  *)ctlp-&gt;dpstr_ctl,
                           OCI_HTYPE_DIRPATH_STREAM);
ociret = OCIHandleFree((void  *)ctlp-&gt;dpctx_ctl, 
                          OCI_HTYPE_DIRPATH_CTX);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i431608"></a>
<div id="LNOCI16931" class="sect2">
<h3 class="sect2">Using a Date Cache in Direct Path Loading of Dates in OCI</h3>
<p>The <span class="italic"><a id="sthref2014"></a><a id="sthref2015"></a>date cache</span> feature provides improved performance when loading Oracle date and time-stamp values that require data type conversions to be stored in the table. For more information about using this feature in direct path loading, see <a class="olink SUTIL1327" href="../../server.112/e22490/ldr_modes.htm#SUTIL1327"><span class="italic">Oracle Database Utilities</span></a>.</p>
<p>This feature is specifically targeted to direct path loads where the same input date or timestamp values are being loaded over and over again. Date conversions are very expensive and can account for a large percentage of the total load time, especially if multiple date columns are being loaded. The date cache feature can significantly improve performance by reducing the actual number of date conversions done when many duplicate date values occur in the input data. However, date cache only improves performance when many duplicate input date values are being loaded into date columns (the word <span class="italic">date</span> in this chapter applies to all the date and time-stamp data types).</p>
<p>The date cache is enabled by default. When you explicitly specify the date cache size, the date cache feature is not disabled, by default. To override this behavior, set <code>OCI_ATTR_DIRPATH_DCACHE_DISABLE</code> to 1. Otherwise, the cache continues to be searched to avoid date conversions. However, any misses (entries for which there are no duplicate values) are converted the usual way using expensive date conversion functions without the benefit of using the date cache feature.</p>
<p>Query the attributes <code>OCI_ATTR_DIRPATH_DCACHE_NUM</code>, <code>OCI_ATTR_DIRPATH_DCACHE_MISSES</code>, and <code>OCI_ATTR_DIRPATH_DCACHE_HITS</code> and then tune the cache size for future loads.</p>
<p>You can lower the cache size when there are no misses and the number of elements in the cache is less than the cache size. The cache size can be increased if there are many cache misses and relatively few hits (entries for which there are duplicate values). Excessive date cache misses, however, can cause the application to run slower than not using the date cache at all. Note that increasing the cache size too much can cause other problems, like paging or exhausting memory. If increasing the cache size does not improve performance, the feature should not be used.</p>
<p>The date cache feature can be explicitly and totally disabled by setting the date cache size to 0.</p>
<p>The following OCI direct path context attributes support this functionality.</p>
<div id="LNOCI16932" class="sect3"><a id="sthref2016"></a>
<h4 class="sect3"><a id="sthref2017"></a>OCI_ATTR_DIRPATH_DCACHE_SIZE</h4>
<p>This attribute, when not equal to 0, sets the date cache size (in elements) for a table. For example, if the date cache size is set to 200, then at most 200 unique date or time-stamp values can be stored in the cache. The date cache size cannot be changed once <a href="oci17msc004.htm#i557836">OCIDirPathPrepare()</a> has been called. The default value is 0, meaning a date cache is not created for a table. A date cache is created for a table only if one or more date or time-stamp values are loaded that require data type conversions and the attribute value is nonzero.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16933" class="sect3"><a id="sthref2018"></a>
<h4 class="sect3">O<a id="sthref2019"></a>CI_ATTR_DIRPATH_DCACHE_NUM</h4>
<p>This attribute is used to query the current number of entries in a date cache.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16934" class="sect3"><a id="sthref2020"></a>
<h4 class="sect3"><a id="sthref2021"></a>OCI_ATTR_DIRPATH_DCACHE_MISSES</h4>
<p>This attribute is used to query the current number of date cache misses. If the number of misses is high, consider using a larger date cache size. If increasing the date cache size does not cause this number to decrease significantly, the date cache should probably not be used. Date cache misses are expensive, due to hashing and lookup times.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16935" class="sect3"><a id="sthref2022"></a>
<h4 class="sect3"><a id="sthref2023"></a>OCI_ATTR_DIRPATH_DCACHE_HITS</h4>
<p>This attribute is used to query the number of date cache hits. This number should be relatively large to see any benefit of using the date cache support.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16936" class="sect3"><a id="sthref2024"></a>
<h4 class="sect3"><a id="sthref2025"></a>OCI_ATTR_DIRPATH_DCACHE_DISABLE</h4>
<p>Setting this attribute to 1 indicates that the date cache should be disabled if the size is exceeded. Note that this attribute cannot be changed or set after <a href="oci17msc004.htm#i557836">OCIDirPathPrepare()</a> has been called.</p>
<p>The default (= 0) is to not disable a cache on overflow. When not disabled, the cache is searched to avoid conversions, but overflow input date value entries are not added to the date cache, and are converted using expensive date conversion functions. Again, excessive date cache misses can cause the application to run slower than not using the date cache at all.</p>
<p>This attribute can also be queried to see if a date cache has been disabled due to overflow.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i453506">"Direct Path Context Handle (OCIDirPathCtx) Attributes"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i426844"></a>
<div id="LNOCI16937" class="sect1">
<h2 class="sect1">Direct Path Loading of Object Types</h2>
<p>The use of the direct path function contexts to load various nonscalar types is discussed in this section.</p>
<p>The nonscalar types are:</p>
<ul>
<li>
<p>Nested tables</p>
</li>
<li>
<p>Object tables (<code>FINAL</code> and <code>NOT FINAL</code>)</p>
</li>
<li>
<p>Column objects (<code>FINAL</code> and <code>NOT FINAL</code>)</p>
</li>
<li>
<p><code>REF</code> columns (<code>FINAL</code> and <code>NOT FINAL</code>)</p>
</li>
<li>
<p>SQL string columns</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociabdem.htm#CACCAHCE">Table B-1</a> for a listing of the programs demonstrating direct path loading that are available with your Oracle Database installation</div>
</li>
</ul>
<div id="LNOCI16938" class="sect2"><a id="sthref2026"></a>
<h3 class="sect2"><a id="sthref2027"></a>Direct Path Loading of Nested Tables</h3>
<p>Nested tables are stored in a separate table. Using the direct path loading API, a nested table is loaded separately from its parent table with a foreign key, called a <code>SETID</code>, to link the two tables together.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Currently, the <code>SETID</code>s must be user-supplied and are not system-generated.</p>
</li>
<li>
<p>When loading the parent and child tables separately, it is possible for orphaned children to be created when the rows are inserted in to the child table, but the corresponding parent row is not inserted in to the parent table. It is also possible to insert a parent row in to the parent table without inserting child rows in to the child table, so that the parent row has missing children.</p>
</li>
</ul>
</div>
<div id="LNOCI16939" class="sect3"><a id="sthref2028"></a>
<h4 class="sect3">Describing a Nested Table Column and Its Nested Table</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from loading scalar data are in italic.</div>
<p>Loading the parent table with a nested table column is a separate action from loading the child nested table.</p>
<ul>
<li>
<p><span class="italic">To load the parent table with a nested table column:</span></p>
<ol>
<li>
<p>Describe the parent table and its columns as usual, except:</p>
</li>
<li>
<p><span class="italic">When describing the nested table column, this is the column that stores the</span> <span class="italic">SETIDs</span><span class="italic">. Its external data type is SQLT_CHR if the</span> <span class="italic">SETID</span><span class="italic">s in the data file are in characters, SQLT_BIN if binary.</span></p>
</li>
</ol>
</li>
<li>
<p><span class="italic">To load the nested table (child):</span></p>
<ol>
<li>
<p>Describe the nested table and its columns as usual.</p>
</li>
<li>
<p><span class="italic">The</span> <span class="italic">SETID</span> <span class="italic">column is required.</span></p>
<ul>
<li>
<p><span class="italic">Set its OCI_ATTR_NAME using a dummy name (for example "setid"), because the API does not expect you to know its system name.</span></p>
</li>
<li>
<p><span class="italic">Set the column attribute with OCI_ATTR_DIRPATH_SID to indicate that this is a</span> <span class="italic">SETID</span> <span class="italic">column:</span></p>
<pre>
ub1 flg = 1;
sword error;

error = OCIAttrSet((void  *)colDesc,
                   OCI_DTYPE_PARAM,
                   (void  *)&amp;flg, (ub4)0,
                   OCI_ATTR_DIRPATH_SID, ctlp-&gt;errhp_ctl);
</pre></li>
</ul>
</li>
</ol>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACDIFDJ"></a>
<div id="LNOCI16940" class="sect2">
<h3 class="sect2"><a id="sthref2029"></a>Direct Path Loading of Column Objects</h3>
<p>A column object is a table column that is defined as an object. Currently only the default constructor, which consists of all of the constituent attributes, is supported.</p>
<div id="LNOCI16941" class="sect3"><a id="sthref2030"></a>
<h4 class="sect3">Describing a Column Object</h4>
<p>To describe a column object and its object attributes, use a direct path function context. Describing a column object requires setting its object constructor. Describing object attributes is similar to describing a list of scalar columns.</p>
<p>To describe a column object:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Nested column objects are supported.</p>
</li>
<li>
<p>The steps shown here are similar to those describing a list of scalar columns to be loaded for a table. Steps that are different from loading scalar data are in italic.</p>
</li>
</ul>
</div>
<ol>
<li>
<p>Allocate a parameter handle on the column object with <code>OCI_DTYPE_PARAM</code>. This parameter handle is used to set the column's external attributes.</p>
</li>
<li>
<p>Set the column name and its other external column attributes (for example, maximum data size, precision, scale).</p>
</li>
<li>
<p><span class="italic">Set the external type as SQLT_NTY (named type) with OCI_ATTR_DATA_TYPE.</span></p>
</li>
<li>
<p><span class="italic">Allocate a direct path function context handle. This context is used to describe the column's object type and attributes:</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx  /* direct path function context */;
sword error;
error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpfnctx,
               OCI_HTYPE_DIRPATH_FN_CTX, 
               (size_t)0, (void  **)0);
</pre></li>
<li>
<p><span class="italic">Set the column's object type name (for example, "Employee") with OCI_ATTR_NAME in the function context:</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
text *obj_type;   /* column object's object type */
sword error;

error = OCIAttrSet((void  *)dpfnctx,
                   OCI_HTYPE_DIRPATH_FN_CTX,
                   (void  *)obj_type, (ub4)strlen((const char *)obj_type),
                   OCI_ATTR_NAME, ctlp-&gt;errhp_ctl);
</pre></li>
<li>
<p><span class="italic">Set the expression type, OCI_ATTR_DIRPATH_EXPR_TYPE, to be OCI_DIRPATH_EXPR_OBJ_CONSTR. This indicates that the expression set with OCI_ATTR_NAME is used as the default object constructor:</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
ub1 expr_type = OCI_DIRPATH_EXPR_OBJ_CONSTR;
sword error;

error = OCIAttrSet((void  *)dpfnctx,
                   OCI_HTYPE_DIRPATH_FN_CTX,
                   (void  *)&amp;expr_type, (ub4)0,
                   OCI_ATTR_DIRPATH_EXPR_TYPE,
                   ctlp-&gt;errhp_ctl);
</pre></li>
<li>
<p><span class="italic">Set the number of columns or object attributes that are to be loaded for this column object using OCI_ATTR_NUM_COLS.</span></p>
</li>
<li>
<p><span class="italic">Get the column or attribute parameter list for the function context</span> <code><span class="codeinlineitalic">OCIDirPathFuncCtx</span></code><span class="italic">.</span></p>
</li>
<li>
<p><span class="italic">For each object attribute:</span></p>
<ol>
<li>
<p>Get the column descriptor for the object attribute with <code>OCI_DTYPE_PARAM</code>.</p>
</li>
<li>
<p>Set the attribute's column name with <code>OCI_ATTR_NAME</code>.</p>
</li>
<li>
<p>Set the external column type (the type of the data that is to be passed to the direct path API) with <code>OCI_ATTR_DATA_TYPE</code>.</p>
</li>
<li>
<p>Set any other external column attributes (maximum data size, precision, scale, and so on.)</p>
</li>
<li>
<p><span class="italic">If this attribute column is a column object, then do Steps 3 through 10 for its object attributes.</span></p>
</li>
<li>
<p>Free the handle to the column descriptor.</p>
</li>
</ol>
</li>
<li>
<p><span class="italic">Set the function context</span> <code><span class="codeinlineitalic">OCIDirPathFuncCtx</span></code> <span class="italic">that was created in Step 4 into the parent column object's parameter handle with OCI_ATTR_DIRPATH_FN_CTX.</span></p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="LNOCI16942" class="sect3"><a id="sthref2031"></a>
<h4 class="sect3">Allocating the Array Column for the Column Object</h4>
<p>When you direct path load a column object, the data for its object attributes is loaded into a separate column array created just for that object. A child column array is allocated for each column object, whether it is nested or not. Each row of object attributes in the child column array maps to the corresponding non-NULL row of its parent column object in the parent column array.</p>
<p>Use the column object's direct path function context handle and function column array value <a id="sthref2032"></a><code>OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code>.</p>
<p><a href="#CACJDIFA">Example 13-18</a> shows how to allocate a child column array for a column object.</p>
<div id="LNOCI18289" class="example">
<p class="titleinexample"><a id="CACJDIFA"></a>Example 13-18 Allocating a Child Column Array for a Column Object</p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
OCIDirPathColArray *dpfnca;   /* direct path function column array */
sword error;

error = OCIHandleAlloc((void  *)dpfnctx, (void  **)&amp;dpfnca,
                       OCI_HTYPE_DIRPATH_FN_COL_ARRAY,
                       (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16943" class="sect3"><a id="sthref2033"></a>
<h4 class="sect3">Loading Column Object Data into the Column Array</h4>
<p>If a column is scalar, its value is set in the column array by passing the address of its value to <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a>. If a column is an object, the address of its child column array handle is passed instead. The child column array contains the data of the object attributes.</p>
<p>To load data into a column object:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from loading scalar data are in italic.</div>
<p><span class="italic">(Start.) For each column object:</span></p>
<ol>
<li>
<p><span class="italic">If the column is non-NULL:</span></p>
<ol>
<li>
<p><span class="italic">For each of its object attribute columns:</span></p>
<p><span class="italic">If an object attribute is a nested column object, then go to (Start.) and do this entire procedure recursively.</span></p>
<p><span class="italic">Set the data in the child column array using</span> <span class="italic">OCIDirPathColArrayEntrySet()</span><span class="italic">.</span></p>
</li>
<li>
<p><span class="italic">Set the column object's data in the column array by passing the address of its child column array handle to</span> <code><span class="codeinlineitalic">OCIDirPathColArrayEntrySet()</span></code>.</p>
</li>
</ol>
</li>
<li>
<p>Else if the column is NULL:</p>
<p>Set the column object's data in the column array by passing a NULL address for the data, a length of 0, and an <code>OCI_DIRPATH_COL_NULL</code> flag to <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="BAJFCFGB"></a>
<div id="LNOCI16944" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref2034"></a>OCI_DIRPATH_COL_ERROR</h4>
<p>The <code>OCI_DIRPATH_COL_ERROR</code> value is passed to <code>OCIDirPathColArrayEntry()</code> to indicate that the current column array row should be ignored. A typical use of this value is to back out all previous conversions for a row when an error occurs, providing that more data for a partial column (<code>OCI_NEED_DATA</code> was returned from the previous <a href="oci17msc004.htm#i557345">OCIDirPathColArrayToStream()</a> call). Any previously converted data placed in the output stream buffer for the current row is removed. Conversion then continues with the next row in the column array. The purged row is counted in the converted row count.</p>
<p>When <code>OCI_DIRPATH_COL_ERROR</code> is specified, the current row is ignored, as well as any corresponding rows in any child column arrays referenced, starting from the top-level column array row. Any <code>NULL</code> child column array references are ignored when moving all referenced child column arrays to their next row.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BAJHAJFF"></a>
<div id="LNOCI16945" class="sect2">
<h3 class="sect2">Direct Path Loading of SQL String Columns</h3>
<p>A column value can be computed by a SQL string. SQL strings can be used for scalar column types. SQL strings cannot be used for object types, but can be used for object attributes of scalar column types. They cannot be used for nested tables, sequences, and <code>LONG</code>s.</p>
<p>A SQL expression is represented to the direct path API using the <code>OCIDirPathFuncCtx</code>. Its <code>OCI_ATTR_NAME</code> value is the SQL string with the parameter list of the named bind variables for the expression.</p>
<p>The bind variable namespace is limited to a column's SQL string. The same bind variable name can be used for multiple columns, but any arguments with the same name only apply to the SQL string of that column.</p>
<p>If a SQL string of a column contains multiple references to a bind variable and multiple arguments are specified for that name, all of the values must be the same; otherwise, the results are undefined. Only one argument is actually required for this case, as all references to the same bind variable name in a particular SQL expression are bound to that single argument.</p>
<p>A SQL string example is:</p>
<pre>
substr(substr(:string, :offset, :length), :offset, :length)
</pre>
<p>Things to note about this example are:</p>
<ul>
<li>
<p>SQL expressions can be nested.</p>
</li>
<li>
<p>Bind variable names can be repeated within the expression.</p>
</li>
</ul>
<div id="LNOCI16946" class="sect3"><a id="sthref2035"></a>
<h4 class="sect3">Describing a SQL String Column</h4>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from loading scalar data are in italic.</div>
<ol>
<li>
<p>Allocate a parameter handle on the SQL string column with <code>OCI_DTYPE_PARAM</code>. This parameter handle is used to set the column's external attributes.</p>
</li>
<li>
<p>Set the column name and its other external column attributes (for example, maximum data size, precision, scale).</p>
</li>
<li>
<p><span class="italic">Set the SQL string column's external type as SQLT_NTY with OCI_ATTR_DATA_TYPE.</span></p>
</li>
<li>
<p><span class="italic">Allocate a direct path function context handle. This context is used to describe the arguments of the SQL string.</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx  /* direct path function context */;
sword error;
error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpfnctx,
               OCI_HTYPE_DIRPATH_FN_CTX, 
               (size_t)0, (void  **)0);
</pre></li>
<li>
<p><span class="italic">Set the column's SQL string in OCI_ATTR_NAME in the function context.</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
text *sql_str;   /* column's SQL string expression */
sword error;

error = OCIAttrSet((void  *)dpfnctx,
                   OCI_HTYPE_DIRPATH_FN_CTX,
                   (void  *)sql_str, (ub4)strlen((const char *)sql_str),
                   OCI_ATTR_NAME, ctlp-&gt;errhp_ctl);
</pre></li>
<li>
<p><span class="italic">Set the expression type, OCI_ATTR_DIRPATH_EXPR_TYPE, to be OCI_DIRPATH_EXPR_SQL. This indicates that the expression set with OCI_ATTR_NAME is used as the SQL string to derive the value from.</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
ub1 expr_type = OCI_DIRPATH_EXPR_SQL;
sword error;

error = OCIAttrSet((void  *)dpfnctx,
                   OCI_HTYPE_DIRPATH_FN_CTX,
                   (void  *)&amp;expr_type, (ub4)0,
                   OCI_ATTR_DIRPATH_EXPR_TYPE, ctlp-&gt;errhp_ctl);
</pre></li>
<li>
<p><span class="italic">Set the number of arguments that are to be passed to the SQL string with OCI_ATTR_NUM_COLS.</span></p>
</li>
<li>
<p><span class="italic">Get the column or attribute parameter list for the function context.</span></p>
</li>
<li>
<p><span class="italic">For each SQL string argument:</span></p>
<ol>
<li>
<p>Get the column descriptor for the object attribute with <code>OCI_DTYPE_PARAM</code>.</p>
</li>
<li>
<p><span class="italic">The order in which the SQL string arguments are defined does not matter. The order does not have to match the order used in the SQL string.</span></p>
</li>
<li>
<p>Set the attribute's column name with <code>OCI_ATTR_NAME</code>.</p>
</li>
<li>
<p><span class="italic">Use the naming convention for SQL string arguments.</span></p>
</li>
<li>
<p><span class="italic">The argument names must match the bind variable names used in the SQL string in content but not in case. For example, if the SQL string is "substr(:INPUT_STRING, 3, 5)", then it is acceptable if you give the argument name as "input_string".</span></p>
</li>
<li>
<p><span class="italic">If an argument is used multiple times in a SQL string, declaring it once and counting it as one argument only is correct.</span></p>
</li>
<li>
<p>Set the external column type (the type of the data that is to be passed to the direct path API) with <code>OCI_ATTR_DATA_TYPE</code>.</p>
</li>
<li>
<p>Set any other external column attributes (maximum data size, precision, scale, and so on).</p>
</li>
<li>
<p>Free the handle to the column descriptor.</p>
</li>
</ol>
</li>
<li>
<p><span class="italic">Set the function context</span> <code><span class="codeinlineitalic">OCIDirPathFuncCtx</span></code> <span class="italic">that was created in Step 4 into the parent column object's parameter handle with OCI_ATTR_DIRPATH_FN_CTX.</span></p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="LNOCI16947" class="sect3"><a id="sthref2036"></a>
<h4 class="sect3">Allocating the Column Array for SQL String Columns</h4>
<p>When you direct path load a SQL string column, the data for its arguments is loaded into a separate column array created just for that SQL string column. A child column array is allocated for each SQL string column. Each row of arguments in the child column array maps to the corresponding non-NULL row of its parent SQL string column in the parent column array.</p>
<p><a href="#CACDIEEJ">Example 13-19</a> shows how to allocate a child column array for a SQL string column.</p>
<div id="LNOCI18290" class="example">
<p class="titleinexample"><a id="CACDIEEJ"></a>Example 13-19 Allocating a Child Column Array for a SQL String Column</p>
<pre>
OCIDirPathFuncCtx *dpfnctx;        /* direct path function context */
OCIDirPathColArray *dpfnca;   /* direct path function column array */
sword error;

error = OCIHandleAlloc((void  *)dpfnctx, (void  **)&amp;dpfnca, 
                       OCI_HTYPE_DIRPATH_FN_COL_ARRAY,
                       (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16948" class="sect3"><a id="sthref2037"></a>
<h4 class="sect3">Loading the SQL String Data into the Column Array</h4>
<p>If a column is scalar, its value would be set in the column array by passing the address of its value to <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a>. If a column is of a SQL string type, the address of its child column array handle would be passed instead. The child column array would contain the SQL string's argument data.</p>
<p>To load data into a SQL string column:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from loading scalar data are in italic.</div>
<p><span class="italic">For each SQL string column:</span></p>
<ol>
<li>
<p><span class="italic">If the column is non-NULL:</span></p>
<ol>
<li>
<p><span class="italic">For each of its function argument columns:</span></p>
<p><span class="italic">Set the data in the child column array using</span> <span class="italic">OCIDirPathColArrayEntrySet()</span><span class="italic">.</span></p>
</li>
<li>
<p><span class="italic">Set the SQL string column's data into the column array by passing the address of its child column array handle to</span> <span class="italic">OCIDirPathColArrayEntrySet()</span><span class="italic">.</span></p>
</li>
</ol>
</li>
<li>
<p>Else if the column is NULL:</p>
<p>Set the SQL string column data into the column array by passing a NULL address for the data, a length of 0, and an <code>OCI_DIRPATH_COL_NULL</code> flag to <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a>.</p>
</li>
</ol>
<p>This process is similar to that for column objects.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BAJFCFGB">"OCI_DIRPATH_COL_ERROR"</a> for more information about passing the <code>OCI_DIRPATH_COL_ERROR</code> value to <code>OCIDirPathColArrayEntry()</code> to indicate that the current column array row should be ignored when an error occurs.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACCFGGA"></a>
<div id="LNOCI16949" class="sect2">
<h3 class="sect2"><a id="sthref2038"></a>Direct Path Loading of REF Columns</h3>
<p>The <code>REF</code> type is a pointer, or reference, to a row object in an object table.</p>
<div id="LNOCI16950" class="sect3"><a id="sthref2039"></a>
<h4 class="sect3">Describing the REF Column</h4>
<p>Describing the arguments to a <code>REF</code> column is similar to describing the list of columns to be loaded for a table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A <code>REF</code> column can be a top-table-level column or nested as an object attribute to a column object.
<p>Steps that are different from loading scalar data are in italic.</p>
</div>
<ol>
<li>
<p>Get a parameter handle on the <code>REF</code> column with <code>OCI_DTYPE_PARAM</code>. This parameter handle is used to set the column's external attributes.</p>
</li>
<li>
<p>Set the column name and its other external column attributes (for example, maximum data size, precision, scale).</p>
</li>
<li>
<p><span class="italic">Set the REF column's external type as SQLT_REF with OCI_ATTR_DATA_TYPE.</span></p>
</li>
<li>
<p><span class="italic">Allocate a direct path function context handle. This context is used to describe the REF column's arguments.</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
sword error;

error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpfnctx,
                       OCI_HTYPE_DIRPATH_FN_CTX,
                       (size_t)0, (void  **)0);
</pre></li>
<li>
<p><span class="italic">OPTIONAL: Set the REF column's table name in OCI_ATTR_NAME in the function context. See the next step for more details.</span></p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
text *ref_tbl;     /* column's reference table */
sword error;

error = OCIAttrSet((void  *)dpfnctx,
                   OCI_HTYPE_DIRPATH_FN_CTX,
                   (void  *)ref_tbl, (ub4)strlen((const char *)ref_tbl),
                   OCI_ATTR_NAME, ctlp-&gt;errhp_ctl);
</pre></li>
<li>
<p><span class="italic">OPTIONAL: Set the expression type, OCI_ATTR_DIRPATH_EXPR_TYPE, to be OCI_DIRPATH_EXPR_REF_TBLNAME. Set this only if Step 5 was done. This indicates that the expression set with OCI_ATTR_NAME is to be used as the object table to reference row objects from. This parameter is optional. The behavior for this parameter varies for the REF type.</span></p>
<ul>
<li>
<p><span class="italic">Unscoped REF columns (unscoped, system-OID-based):</span></p>
<p><span class="italic">If not set, then by the definition of an "unscoped" REF column, this REF column is required to have a reference table name as its argument for every data row.</span></p>
<p><span class="italic">If set, this REF column can only refer to row objects from this specified object table for the duration of the load. And the REF column is not allowed to have a reference table name as its argument. (The direct path API is providing this parameter as a shortcut to users who will be loading to an unscoped REF column that refers to the same reference object table during the entire load.)</span></p>
</li>
<li>
<p><span class="italic">Scoped REF columns (scoped, system-OID-based, and primary-key-based):</span></p>
<p><span class="italic">If not set, the direct path API uses the reference table specified in the schema.</span></p>
<p><span class="italic">If set, the reference table name must match the object table specified in the schema for this scoped REF column. An error occurs if the table names do not match.</span></p>
<p><span class="italic">Whether this parameter is set or not, it does not matter to the API whether this reference table name is in the data row or not. If the name is in the data row, it must match the table name specified in the schema. If it is not in the data row, the API uses the reference table specified in the schema.</span></p>
</li>
</ul>
</li>
<li>
<p><span class="italic">Set the number of REF arguments that are to be used to reference a row object with OCI_ATTR_NUM_COLS. The number of arguments required varies for the REF column type. This number is derived from Step 6 earlier.</span></p>
<ul>
<li>
<p><span class="italic">Unscoped REF columns (unscoped, system-OID-based REF columns):</span></p>
<p><span class="italic">One if OCI_DIRPATH_EXPR_REF_TBLNAME is used. None for the reference table name, and one for the OID value.</span></p>
<p><span class="italic">Two if OCI_DIRPATH_EXPR_REF_TBLNAME is not used. One for the reference table name, and one for the OID value.</span></p>
</li>
<li>
<p><span class="italic">Scoped REF columns (scoped, system-OID-based, and primary-key-based):</span></p>
<p><span class="italic">N or N+1 are acceptable, where N is the number of columns making up the object ID, regardless if <a id="sthref2040"></a>OCI_DIRPATH_EXPR_REF_TBLNAME is used or not. Minimum is N if the reference table name is not in the data row. It is N+1 if the reference table name is in the data row. Note: If the REF is system-OID-based, then N is one. If the REF is primary-key-based, then N is the number of component columns that make up the primary key. If the reference table name is in the data row, then add one to N.</span></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To simplify the error message if you pass in some <code>REF</code> arguments other than N or N+1, the error message says that it found so-and-so number of arguments when it expects N. Although N+1 is not stated in the message, N+1 is acceptable (even though the reference table name is not needed) and does not invoke an error message.</div>
</li>
</ul>
</li>
<li>
<p><span class="italic">Get the column or attribute parameter list for the function context.</span></p>
</li>
<li>
<p><span class="italic">For each REF argument or attribute:</span></p>
<ol>
<li>
<p>Get the column descriptor for the <code>REF</code> argument using <code>OCI_DTYPE_PARAM</code>.</p>
</li>
<li>
<p>Set the attribute's column name using <code>OCI_ATTR_NAME</code>.</p>
<p><span class="italic">The order of the REF arguments given matter.</span> <span class="italic">The reference table name comes first, if given.</span> <span class="italic">The object ID, whether it is system-generated or primary-key-based, comes next.</span></p>
<p><span class="italic">There is a naming convention for the REF arguments.</span> <span class="italic">Because the reference table name is not a table column, you can use any dummy names for its column name, such as "ref-tbl."</span> <span class="italic">For a system-generated OID column, you can use any dummy names for its column name, such as "sys-OID".</span> <span class="italic">For a primary-key-based object ID, list all the primary-key columns to load into. There is no need to create a dummy name for OID. The component column names, if given (see shortcut note later), can be given in any order.</span></p>
<p><span class="italic">Do not set the attribute column names for the object ID to use the shortcut.</span></p>
<p><span class="bolditalic">Shortcut.</span> <span class="italic">If loading a system-OID-based REF column, do not set the column name with a name. The API figures it out. But you must still set other column attributes, such as external data type.</span></p>
<p><span class="italic">If loading a primary-key REF column and its primary key consists of multiple columns, the shortcut is not to set their column names. But you must still set other column attributes, such as external data type.</span></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the component column names are NULL, then the API code determines the column names in the position or order in which they were defined for the primary key. So, when you set column attributes other than the name, ensure that the attributes are set for the component columns in the correct order.</div>
</li>
<li>
<p>Set the external column type (the type of the data that is to be passed to the direct path API) using <code>OCI_ATTR_DATA_TYPE</code>.</p>
</li>
<li>
<p>Set any other external column attributes (max data size, precision, scale, and so on).</p>
</li>
<li>
<p>Free the handle to the column descriptor.</p>
</li>
<li>
<p><span class="italic">Set the function context</span> <code><span class="codeinlineitalic">OCIDirPathFuncCtx</span></code> <span class="italic">that was created in Step 4 in the parent column object's parameter handle using OCI_ATTR_DIRPATH_FN_CTX.</span></p>
</li>
</ol>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="LNOCI16951" class="sect3"><a id="sthref2041"></a>
<h4 class="sect3">Allocating the Column Array for a REF Column</h4>
<p><a href="#CACJJCCB">Example 13-20</a> shows how to allocate a child column array for a <code>REF</code> column.</p>
<div id="LNOCI18291" class="example">
<p class="titleinexample"><a id="CACJJCCB"></a>Example 13-20 Allocating a Child Column Array for a REF Column</p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
OCIDirPathColArray *dpfnca; /* direct path function column array */
sword error;

error = OCIHandleAlloc((void  *)dpfnctx, (void  **)&amp;dpfnca,
                       OCI_HTYPE_DIRPATH_FN_COL_ARRAY,
                       (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="LNOCI16952" class="sect3"><a id="sthref2042"></a>
<h4 class="sect3">Loading the REF Data into the Column Array</h4>
<p>If a column is scalar, its value is set in the column array by passing the address of its value to <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a>. If a column is a <code>REF</code>, the address of its child column array handle is passed instead. The child column array contains the <code>REF</code> arguments' data.</p>
<p>To load data into a <code>REF</code> column:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from loading scalar data are in italic.</div>
<p><span class="italic">For each REF column:</span></p>
<ol>
<li>
<p><span class="italic">If the column is non-NULL:</span></p>
<ol>
<li>
<p><span class="italic">For each of its REF argument columns:</span></p>
<p><span class="italic">Set its data in the child column array using</span> <span class="italic">OCIDirPathColArrayEntrySet()</span><span class="italic">.</span></p>
</li>
<li>
<p><span class="italic">Set the REF column's data into the column array by passing the address of its child column array handle to</span> <span class="italic">OCIDirPathColArrayEntrySet()</span><span class="italic">.</span></p>
</li>
</ol>
</li>
<li>
<p>Else if the column is NULL:</p>
<p>Set the <code>REF</code> column's data into the column array by passing a NULL address for the data, a length of 0, and an <code>OCI_DIRPATH_COL_NULL</code> flag to <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BAJFCFGB">"OCI_DIRPATH_COL_ERROR"</a></div>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16953" class="sect2"><a id="sthref2043"></a>
<h3 class="sect2">Direct Path Loading of NOT FINAL Object and REF Columns</h3>
<p>Recall that SQL object inheritance is based on a family tree of object types that forms a type hierarchy. The type hierarchy consists of a parent object type, called a supertype, and one or more levels of child object types, called subtypes, which are derived from the parent.</p>
<div id="LNOCI16954" class="sect3"><a id="sthref2044"></a>
<h4 class="sect3">Inheritance Hierarchy</h4>
<p><a href="#CACEJFED">Figure 13-2</a> diagrams the inheritance hierarchy for a column of type <code>Person</code>. The <code>Person</code> supertype is at the top of the hierarchy with two attributes: <code>Name</code>, <code>Address</code>. <code>Person</code> has two subtypes, <code>Employee</code> and <code>Student</code>. The <code>Employee</code> subtype has two attributes: <code>Manager</code>, <code>Deptid</code>. The <code>Student</code> subtype has two attributes: <code>Units</code>, <code>GPA</code>. <code>ParttimeEmployee</code> is a subtype of <code>Employee</code> and appears below it. The subtype <code>ParttimeEmployee</code> has one attribute: <code>Hours</code>. These are the types that can be stored in a <code>Person</code> column.</p>
<div id="LNOCI18292" class="figure">
<p class="titleinfigure"><a id="CACEJFED"></a>Figure 13-2 Inheritance Hierarchy for a Column of Type Person</p>
<img width="300" height="156" src="img/lnoci046.gif" alt="Description of Figure 13-2 follows" /><br />
<a id="sthref2045" href="img_text/lnoci046.htm">Description of "Figure 13-2 Inheritance Hierarchy for a Column of Type Person"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Recall that for an object type to be inheritable, the object type definition must specify that it is inheritable. Once specified, subtypes can be derived from it. To specify an object to be inheritable, the keyword <code>NOT FINAL</code> must be specified in its type definition. To specify an object to not be inheritable, the keyword FINAL must be specified in its type definition. See <a class="olink ADOBJ7103" href="../../appdev.112/e11822/adobjbas.htm#ADOBJ7103"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for more information about defining <code>FINAL</code> and <code>NOT FINAL</code> types.</p>
<p>When you direct path load a table that contains a column of type <code>Person</code>, the actual set of types could include any of these four: the <code>NOT FINAL</code> type <code>Person</code>, and its three subtypes: <code>Student</code>, <code>Employee</code>, and <code>ParttimeEmployee</code>. Because the direct path load API only supports the loading of one fixed, derived type to this <code>NOT FINAL</code> column for the duration of this load, the direct path load API must know which one of these types is to be loaded, the attributes to load for this type, and the function used to create this type.</p>
<p>So when you describe and load a derived type, you must specify all of the attributes for that type that are to be loaded. Think of a subtype as a flattened representation of all the object attributes that are unique to this type, plus all the attributes of its ancestors. Therefore, any of these attribute columns that are to be loaded into, you must describe and count.</p>
<p>For example, to load all columns in <code>ParttimeEmployee</code>, you must describe and count five object attributes to load into: <code>Name</code>, <code>Address</code>, <code>Manager</code>, <code>Deptid</code>, and <code>Hours.</code></p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16955" class="sect3"><a id="sthref2046"></a>
<h4 class="sect3">Describing a Fixed, Derived Type to Be Loaded</h4>
<p>Note that the steps to describe a <code>NOT FINAL</code> or substitutable object columns and <code>REF</code> columns of a fixed, derived type are similar to the steps that describe its <code>FINAL</code> counterpart.</p>
<p>To describe a <code>NOT FINAL</code> column of type X (where X is an object or a <code>REF</code>), see <a href="#CACDIFDJ">"Direct Path Loading of Column Objects"</a> or <a href="#CACCFGGA">"Direct Path Loading of REF Columns"</a>. These sections describe a <code>FINAL</code> column of this type. Because the derived type (could be a supertype or a subtype) is fixed for the duration of the load, the client interface for describing a <code>NOT FINAL</code> column is the same as for describing a <code>FINAL</code> column.</p>
<p>A subtype can be thought of as a flattened representation of all the object attributes that are unique to this type plus all the attributes of its ancestors. Therefore, any of these attribute columns that are to be loaded into must be described and counted.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16956" class="sect3"><a id="sthref2047"></a>
<h4 class="sect3">Allocating the Column Array</h4>
<p>Allocating the column array is the same as for a <code>FINAL</code> column of the same type.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16957" class="sect3"><a id="sthref2048"></a>
<h4 class="sect3">Loading the Data into the Column Array</h4>
<p>Loading the data into the column array is the same as for a <code>FINAL</code> column of the same type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16958" class="sect2"><a id="sthref2049"></a>
<h3 class="sect2"><a id="sthref2050"></a>Direct Path Loading of Object Tables</h3>
<p>An object table is a table in which each row is an object (or row object). Each column in the table is an object attribute.</p>
<p class="subhead2"><a id="LNOCI18293"></a>Describing an Object Table</p>
<p>Describing an object table is very similar to describing a non-object table. Each object attribute is a column in the table. The only difference is that you may need to describe the OID, which could be system-generated, user-generated, or primary-key-based.</p>
<p>To describe an object table:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from loading a non-object table are in italic.</div>
<p><span class="italic">For each object attribute column:</span></p>
<p>Describe each object attribute column as it must be described, depending on its type (for example, <code>NUMBER</code>, <code>REF</code>):</p>
<p><span class="italic">For the object table OID (Oracle Internet Directory):</span></p>
<ol>
<li>
<p><span class="italic">If the object ID is system-generated:</span></p>
<p><span class="italic">There is nothing extra to do. The system generates OIDs for each row object.</span></p>
</li>
<li>
<p><span class="italic">If the object ID is user-generated:</span></p>
<ol>
<li>
<p><span class="italic">Use a dummy name to represent the column name for the OID (for example, "cust_oid").</span></p>
</li>
<li>
<p><span class="italic">Set the OID column attribute with OCI_ATTR_DIRPATH_OID.</span></p>
</li>
</ol>
</li>
<li>
<p><span class="italic">If the object ID is primary-key-based:</span></p>
<ol>
<li>
<p><span class="italic">Load all of the primary-key columns making up the OID.</span></p>
</li>
<li>
<p><span class="italic">Do not set OCI_ATTR_DIRPATH_OID, because no OID column with a dummy name was created.</span></p>
</li>
</ol>
</li>
</ol>
<p class="subhead2"><a id="LNOCI18294"></a>Allocating the Column Array for the Object Table</p>
<p><a href="#CACDAFEE">Example 13-21</a> shows that allocating the column array for the object table is the same as allocating a column array for a non-object table.</p>
<div id="LNOCI18295" class="example">
<p class="titleinexample"><a id="CACDAFEE"></a>Example 13-21 Allocating the Column Array for the Object Table</p>
<pre>
OCIDirPathColArray *dpca;  /* direct path column array */
sword error;

error = OCIHandleAlloc((void  *)dpctx, (void  **)&amp;dpca,
                       OCI_HTYPE_DIRPATH_COLUMN_ARRAY,
                       (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNOCI18296"></a>Loading Data into the Column Array</p>
<p>Loading data into the column array is the same as loading data into a non-object table.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI16962" class="sect2"><a id="sthref2051"></a>
<h3 class="sect2"><a id="sthref2052"></a>Direct Path Loading a NOT FINAL Object Table</h3>
<p>A <code>NOT FINAL</code> object table supports inheritance and a <code>FINAL</code> object table cannot.</p>
<p class="subhead2"><a id="LNOCI18297"></a>Describing a NOT FINAL Object Table</p>
<p>Describing a <code>NOT FINAL</code> object table of a fixed derived type is very similar to describing a <code>FINAL</code> object table.</p>
<p>To describe a <code>NOT FINAL</code> object table of a fixed derived type:</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Steps that are different from describing a <code>FINAL</code> object table are in italic.</div>
<ol>
<li>
<p><span class="italic">Set the object table's object type in the direct path context with OCI_ATTR_DIRPATH_OBJ_CONSTR. This indicates that the object type, whether it is a supertype or a derived type, are used as the default object constructor when loading to this table for the duration of the load.</span></p>
<pre>
text *obj_type;            /* the object type to load into this NOT FINAL */
                           /* object table */
sword error;

error = OCIAttrSet((void  *)dpctx,
                   OCI_HTYPE_DIRPATH_CTX,
                   (void  *) obj_type,
                   (ub4)strlen((const char *) obj_type),
                   OCI_ATTR_DIRPATH_OBJ_CONSTR, ctlp-&gt;errhp_ctl);
</pre></li>
<li>
<p>Describe according to its data type each of the object attribute columns to be loaded. Describe the object ID, if needed. This is the same as describing a <code>FINAL</code> object table.</p>
</li>
</ol>
<p class="subhead2"><a id="LNOCI18298"></a>Allocating the Column Array for the NOT FINAL Object Table</p>
<p>Allocating the column array for the <code>NOT FINAL</code> object table is the same as for a <code>FINAL</code> object table.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i429049"></a>
<div id="LNOCI16965" class="sect1">
<h2 class="sect1"><a id="sthref2053"></a>Direct Path Loading in Pieces</h2>
<p>To support loading data that does not all fit in memory at one time, use loading in pieces.</p>
<p>The direct path API supports loading <code>LONG</code>s and LOBs incrementally. This is accomplished through the following steps:</p>
<ol>
<li>
<p>Set the first piece into the column array using <a href="oci17msc004.htm#i563565">OCIDirPathColArrayEntrySet()</a> and passing in the <code>OCI_DIRPATH_COL_PARTIAL</code> flag to indicate that all the data for this column has not been loaded yet.</p>
</li>
<li>
<p>Convert the column array to a stream.</p>
</li>
<li>
<p>Load the stream.</p>
</li>
<li>
<p>Set the next piece of that data into the column array. If it is not complete, set the partial flag and go back to Step 2. If it is complete, then set the <code>OCI_DIRPATH_COL_COMPLETE</code> flag and continue to the next column.</p>
</li>
</ol>
<p>This approach is essentially the same for dealing with large attributes for column objects and large arguments for SQL string types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BAJFCFGB">"OCI_DIRPATH_COL_ERROR"</a> for more information about passing the <code>OCI_DIRPATH_COL_ERROR</code> value to <code>OCIDirPathColArrayEntry()</code> to indicate that the current column array row should be ignored when an error occurs.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Collections are not loaded in pieces, as such. Nested tables are loaded separately and are loaded like a top-level table. Nested tables can be loaded incrementally and can have columns that are loaded in pieces. Therefore, do not set the <code>OCI_DIRPATH_COL_PARTIAL</code> flag for the column containing the collection.</div>
<div id="LNOCI16966" class="sect2"><a id="sthref2054"></a>
<h3 class="sect2">Loading Object Types in Pieces</h3>
<p>Objects are loaded into a separate column array from the parent table that contains them. Therefore, when they need to be loaded in pieces you must set the elements in the child column array up to and including the pieced element.</p>
<p>The general steps are:</p>
<ol>
<li>
<p>For the pieced element, set the <code>OCI_DIRPATH_COL_PARTIAL</code> flag.</p>
</li>
<li>
<p>Set the child column array handle into the parent column array and mark that entry with the <code>OCI_DIRPATH_COL_PARTIAL</code> flag as well.</p>
</li>
<li>
<p>Convert the parent column array to a stream. This converts the child column array as well.</p>
</li>
<li>
<p>Load the stream.</p>
</li>
<li>
<p>Go back to Step 1 and continue loading the remaining data for that element until it is complete.</p>
</li>
</ol>
<p>Here are some rules about loading in pieces:</p>
<ul>
<li>
<p>There can only be one partial element at a time at any level. Once one partial element is marked complete, then another one at that level can be partial.</p>
</li>
<li>
<p>If an element is partial and it is not top-level, then all of its ancestors up the containment hierarchy must be marked partial as well.</p>
</li>
<li>
<p>If there are multiple levels of nesting, it is necessary to go up to a level where the data can be converted into a stream. This is a top-level table.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BAJFCFGB">"OCI_DIRPATH_COL_ERROR"</a> for more information about passing the <code>OCI_DIRPATH_COL_ERROR</code> value to <code>OCIDirPathColArrayEntry()</code> to indicate that the current column array row should be ignored when an error occurs.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i429028"></a>
<div id="LNOCI16967" class="sect1">
<h2 class="sect1">Direct Path Context Handles and Attributes for Object Types</h2>
<p>The following discussion gives the supplemental details of the handles and attributes that are listed in <a href="ociaahan.htm#i442199">Appendix A</a>.</p>
<div id="LNOCI16968" class="sect2"><a id="sthref2055"></a>
<h3 class="sect2">Direct Path Context Attributes</h3>
<p>There is one direct path context attribute.</p>
<div id="LNOCI16969" class="sect3"><a id="sthref2056"></a>
<h4 class="sect3"><a id="sthref2057"></a>OCI_ATTR_DIRPATH_OBJ_CONSTR</h4>
<p>Indicates the object type to load into a <code>NOT FINAL</code> object table.</p>
<pre>
ttext *obj_type;            /* the object type to load into this NOT FINAL */
                           /* object table */
sword error;

error = OCIAttrSet((void  *)dpctx,
                   OCI_HTYPE_DIRPATH_CTX,
                   (void  *) obj_type,
                   (ub4)strlen((const char *) obj_type),
                   OCI_ATTR_DIRPATH_OBJ_CONSTR, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i430560"></a>
<div id="LNOCI16970" class="sect2">
<h3 class="sect2">Direct Path Function Context and Attributes</h3>
<p>Here is a summary of the attributes for function context handles.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i453506">"Direct Path Context Handle (OCIDirPathCtx) Attributes"</a></div>
<div id="LNOCI16971" class="sect3"><a id="sthref2058"></a>
<h4 class="sect3"><a id="sthref2059"></a>OCI_ATTR_DIRPATH_OBJ_CONSTR</h4>
<p>Indicates the object type to load into a substitutable object table.</p>
<pre>
text *obj_type; /* stores an object type name */
sword error;

error = OCIAttrSet((void  *)dpctx,
                   OCI_HTYPE_DIRPATH_CTX,
                   (void  *) obj_type,
                   (ub4)strlen((const char *) obj_type),
                   OCI_ATTR_DIRPATH_OBJ_CONSTR, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="sect3" -->
<a id="i432341"></a>
<div id="LNOCI16972" class="sect3">
<h4 class="sect3">O<a id="sthref2060"></a>CI_ATTR_NAME</h4>
<p>When a function context is created, set <code>OCI_ATTR_NAME</code> equal to the expression that describes the nonscalar column. Then set an OCI attribute to indicate the type of the expression. The expression type varies depending on whether it is a column object, a <code>REF</code> column, or a SQL string column.</p>
<p class="subhead2"><a id="LNOCI18299"></a>Column Objects</p>
<p>This required expression is the object type name. The object type is used as the default object constructor.</p>
<p>Set the expression type <code>OCI_ATTR_DIRPATH_EXPR_TYPE</code> to <code><a id="sthref2061"></a>OCI_DIRPATH_EXPR_OBJ_CONSTR</code> to indicate that this expression is an object type name.</p>
<p class="subhead2"><a id="LNOCI18300"></a>REF Columns</p>
<p>This optional expression is the reference table name. This table is the object table from which the <code>REF</code> column is to reference row objects.</p>
<p>Set the expression type <code>OCI_ATTR_DIRPATH_EXPR_TYPE</code> to <code>OCI_DIRPATH_EXPR_REF_TBLNAME</code> to indicate that this expression is a reference object table.</p>
<p>The behavior for this parameter, set or not set, varies for each <code>REF</code> type.</p>
<ul>
<li>
<p>Unscoped <code>REF</code> columns (unscoped, system-OID-based):</p>
<ul>
<li>
<p>If not set, then by the definition of an "unscoped" <code>REF</code> column, this <code>REF</code> column must have a reference table name as its argument for every data row.</p>
</li>
<li>
<p>If set, this <code>REF</code> column can only refer to row objects from this specified object table for the duration of the load. The <code>REF</code> column is not allowed to have a reference table name as its argument. (Direct path API provides this parameter as a shortcut for the users who will be loading to an unscoped <code>REF</code> column that refers to the same reference object table during the entire load.)</p>
</li>
</ul>
</li>
<li>
<p>Scoped <code>REF</code>columns (scoped, system-OID-based and primary-key-based):</p>
<ul>
<li>
<p>If not set, the direct path API uses the reference table specified in the schema.</p>
</li>
<li>
<p>If set, the reference table name must match the object table specified in the schema for this scoped <code>REF</code> column. An error occurs if the table names do not match.</p>
</li>
<li>
<p>Whether this parameter is set or not, it does not matter to the API whether this reference table name is in the data row or not. If the name is in the data row, it must match the table name specified in the schema. If it is not in the data row, the API uses the reference table defined in the schema.</p>
</li>
</ul>
</li>
</ul>
<p class="subhead2"><a id="LNOCI18301"></a>SQL String Columns</p>
<p>This mandatory expression contains a SQL string to derive the value that is to be stored in the column.</p>
<p>Set the expression type <code>OCI_ATTR_DIRPATH_EXPR_TYPE</code> to <code><a id="sthref2062"></a>OCI_DIRPATH_EXPR_SQL</code> to indicate that this expression is a SQL string.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16973" class="sect3"><a id="sthref2063"></a>
<h4 class="sect3"><a id="sthref2064"></a>OCI_ATTR_DIRPATH_EXPR_TYPE</h4>
<p>This attribute is used to indicate the type of the expression specified in <code>OCI_ATTR_NAME</code> for the nonscalar column's function context.</p>
<p>If <code>OCI_ATTR_NAME</code> is set, then <code>OCI_ATTR_DIRPATH_EXPR_TYPE</code> is required.</p>
<p>The possible values for <code>OCI_ATTR_DIRPATH_EXPR_TYPE</code> are:</p>
<ul>
<li>
<p><a id="sthref2065"></a><code>OCI_DIRPATH_EXPR_OBJ_CONSTR</code></p>
<ul>
<li>
<p>Indicates that the expression is an object type name and is to be used as the default object constructor for a column object.</p>
</li>
<li>
<p>Is required for column objects.</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref2066"></a><code>OCI_DIRPATH_EXPR_REF_TBLNAME</code></p>
<ul>
<li>
<p>Indicates that the expression is a reference object table name. This table is the object table from which the <code>REF</code> column is referencing row objects.</p>
</li>
<li>
<p>Is optional for <code>REF</code> columns.</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref2067"></a><code>OCI_DIRPATH_EXPR_SQL</code></p>
<ul>
<li>
<p>Indicates that the expression is a SQL string that is executed to derive a value to be stored in the column.</p>
</li>
<li>
<p>Is required for SQL string columns.</p>
</li>
</ul>
</li>
</ul>
<p><a href="#CACBHCFG">Example 13-22</a> shows the pseudocode that illustrates the preceding rules and values.</p>
<div id="LNOCI18302" class="example">
<p class="titleinexample"><a id="CACBHCFG"></a>Example 13-22 Specifying Values for the OCI_ATTR_DIRPATH_EXPR_TYPE Attribute</p>
<pre>
OCIDirPathFuncCtx  *dpfnctx; /* function context for this nonscalar column */
ub1 expr_type; /* expression type */
sword error;

if (...) /* (column type is an object) */
expr_type = OCI_DIRPATH_EXPR_OBJ_CONSTR;
...
if (...) /* (column type is a REF &amp;&amp; function context name exists) */
expr_type = OCI_DIRPATH_EXPR_REF_TBLNAME;
...
if (...) /* (column type is a SQL string) */
expr_type = OCI_DIRPATH_EXPR_SQL;
...
error = OCIAttrSet((void  *)(dpfnctx),
                   OCI_HTYPE_DIRPATH_FN_CTX,
                   (void  *)&amp;expr_type, (ub4)0,
                   OCI_ATTR_DIRPATH_EXPR_TYPE, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BAJJGACH"></a>
<div id="LNOCI16974" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref2068"></a><a id="sthref2069"></a>OCI_ATTR_DIRPATH_NO_INDEX_ERRORS</h4>
<p>When <code>OCI_ATTR_DIRPATH_NO_INDEX_ERRORS</code> is 1, indexes are not set unusable at any time during the load. And, if any index errors are detected, the load is terminated. That is, no rows are loaded, and the indexes are left as is. The default is 0.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#BAJGFDEH">"OCI_ATTR_DIRPATH_NO_INDEX_ERRORS"</a></div>
</div>
<!-- class="sect3" -->
<a id="i428014"></a>
<div id="LNOCI16975" class="sect3">
<h4 class="sect3"><a id="sthref2070"></a>OCI_ATTR_NUM_COLS</h4>
<p>This attribute describes the number of attributes or arguments that are to be loaded or processed for a nonscalar column. This parameter must be set before the column list can be retrieved. The expression type varies depending on whether it is a column object, a SQL string column, or a <code>REF</code> column.</p>
<p class="subhead2"><a id="LNOCI18303"></a>Column Objects</p>
<p>The number of object attribute columns to be loaded for this column object.</p>
<p class="subhead2"><a id="LNOCI18304"></a>SQL String Columns</p>
<p>The number of arguments to be passed to the SQL string.</p>
<p>If an argument is used multiple times in the function, counting it as one is correct.</p>
<p class="subhead2"><a id="LNOCI18305"></a>REF Columns</p>
<p>The number of <code>REF</code> arguments to identify the row object the <code>REF</code> column should point to.</p>
<p>The number of arguments required varies for the <code>REF</code> column type:</p>
<ul>
<li>
<p>Unscoped <code>REF</code> columns (unscoped, system-OID-based <code>REF</code> columns):</p>
<ul>
<li>
<p>If <code>OCI_DIRPATH_EXPR_REF_TBLNAME</code> is used. None for the reference table name, and one for the OID value. (Only the OID values are in the data rows.)</p>
</li>
<li>
<p>If <code>OCI_DIRPATH_EXPR_REF_TBLNAME</code> is not used. One for the reference table name, and one for the OID value. (Both the reference table names and the OID values are in the data rows.)</p>
</li>
</ul>
</li>
<li>
<p>Scoped <code>REF</code> columns (scoped, system-OID-based and primary-key-based):</p>
<ul>
<li>
<p>N or N+1 are acceptable, where N is the number of columns making up the object ID, regardless if <code>OCI_DIRPATH_EXPR_REF_TBLNAME</code> is used or not. The minimum is N if the reference table name is not in the data row. Use N+1 if the reference table name is in the data row.</p>
</li>
<li>
<p>If the <code>REF</code> is system-OID-based, then N is 1. If the <code>REF</code> is primary-key-based, then N is the number of component columns that make up the primary key. If the reference table name is in the data row, then add 1 to N.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
To simplify the error message if you pass in some <code>REF</code> arguments other than N or N+1, the error message says that it found so-and-so number of arguments when it expects N. Although N+1 is not stated in the message, N+1 is acceptable (even though the reference table name is not needed) and does not invoke an error message.</div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16976" class="sect3"><a id="sthref2071"></a>
<h4 class="sect3"><a id="sthref2072"></a>OCI_ATTR_NUM_ROWS</h4>
<p>This attribute, when used for an <code>OCI_HTYPE_DIRPATH_FN_CTX</code> (function context), is retrievable only, and cannot be set by the user. You can only use this attribute in <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> and not <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>. When <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> is called with OCI_ATTR_NUM_ROWS, the number of rows loaded so far is returned.</p>
<p>However, the attribute <code>OCI_ATTR_NUM_ROWS</code>, when used for an <code>OCI_HTYPE_DIRPATH_CTX</code> (table-level context), can be both set and retrieved by the user.</p>
<p>Calling <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> with <code>OCI_ATTR_NUM_ROWS</code> and <code>OCI_HTYPE_DIRPATH_CTX</code> sets the number of rows to be allocated for the table-level column array. If not set, the direct path API code derives a "reasonable" number based on the maximum record size and the transfer buffer size. To see how many rows were allocated, call <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> with <code>OCI_ATTR_NUM_ROWS</code> on <code>OCI_HTYPE_DIRPATH_COLUMN_ARRAY</code> for a table-level column array, and with <a id="sthref2073"></a><code>OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code> for a function column array.</p>
<p>Calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> with <code>OCI_ATTR_NUM_ROWS</code> and <code>OCI_HTYPE_DIRPATH_CTX</code> returns the number of rows loaded so far.</p>
<p>This attribute cannot be set by the user for a function context. You are not allowed to specify the number of rows desired in a function column array through <code>OCI_ATTR_NUM_ROWS</code> with <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> because then all function column arrays will have the same number of rows as the table-level column array. Thus this attribute can only be set for a table-level context and not for a function context.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16977" class="sect2"><a id="sthref2074"></a>
<h3 class="sect2">Direct Path Column Parameter Attributes</h3>
<p>When you describe an object, SQL string, or <code>REF</code> column, one of its column attributes is a function context.</p>
<p>If a column is an object, then its function context describes its object type and object attributes. If the column is a SQL string, then its function context describes the expression to be called. If the column is a REF, its function context describes the reference table name and row object identifiers.</p>
<p><a href="#CACGEACB">Example 13-23</a> shows that when you set a function context as a column attribute, <code>OCI_ATTR_DIRPATH_FN_CTX</code> is used in the <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> call.</p>
<div id="LNOCI18306" class="example">
<p class="titleinexample"><a id="CACGEACB"></a>Example 13-23 Setting a Function Context as a Column Attribute</p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
sword error;

error = OCIAttrSet((void  *)colDesc,
                   OCI_DTYPE_PARAM,
                   (void  *)(dpfnctx), (ub4)0,
                   OCI_ATTR_DIRPATH_FN_CTX, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="example" -->
<p>Attributes for column parameter context handles follow.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i448019">"Direct Path Column Parameter Attributes"</a></div>
<div id="LNOCI16978" class="sect3"><a id="sthref2075"></a>
<h4 class="sect3"><a id="sthref2076"></a>OCI_ATTR_NAME</h4>
<p>The naming conventions for loading nested tables, object tables, SQL string columns, and <code>REF</code> columns are described in the following paragraphs.</p>
<p>In general, a dummy column name is used if you are loading data into a column that is a system column with a system name that you are not aware of (for example, an object table's system-generated object ID (<code>OID</code>) column or a nested table's <code>SETID</code> (<code>SID</code>) column) or if a column is an argument that does not have a database table column (for example, SQL string and <code>REF</code> arguments).</p>
<p>If the column is a database table column but a dummy name was used, then a column attribute must be set so that the function can identify the column even though it is not under the name known to the database.</p>
<p>The naming rules are as follows:</p>
<ul>
<li>
<p>Child nested table's <code>SETID</code> (<code>SID</code>) column</p>
<p>The SETID column is required. Set its <code>OCI_ATTR_NAME</code> using a dummy name, because the API does not expect the user to know its system name. Then set the column attribute with <code>OCI_ATTR_DIRPATH_SID</code> to indicate that this is a <code>SID</code> column.</p>
</li>
<li>
<p>Object table's object ID (<code>OID</code>) column</p>
<p>An object ID is required if:</p>
<ol>
<li>
<p>The object ID is system-generated:</p>
<p>Use a dummy name as its column name (for example, "cust_oid").</p>
<p>Set its column attribute with <code>OCI_ATTR_DIRPATH_OID</code>. So if you have multiple columns with dummy names, you know which one represents the system-generated <code>OID</code>.</p>
</li>
<li>
<p>The object id is primary-key-based:</p>
<p>You cannot use a dummy name as its column name. Therefore, you do not need to set its column attribute with <code>OCI_ATTR_DIRPATH_OID</code>.</p>
</li>
</ol>
</li>
<li>
<p>SQL string argument</p>
<ol>
<li>
<p>Set the attribute's column name with <code>OCI_ATTR_NAME</code>.</p>
</li>
<li>
<p>The order of the SQL string arguments given does not matter. The order does not have to match the order used in the SQL string.</p>
</li>
<li>
<p>Use the naming convention for SQL string arguments.</p>
<ul>
<li>
<p>The argument names must match the bind variable names used in the SQL string in content but not in case. For example, if the SQL string is <code>substr(:INPUT_STRING, 3, 5)</code>, then you can give the argument name as "input_string".</p>
</li>
<li>
<p>If an argument is used multiple times in an SQL string, then you can declare it once and count it as only one argument.</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><code>REF</code> argument</p>
<ol>
<li>
<p>Set the attribute's column name using <code>OCI_ATTR_NAME</code>.</p>
<p>The order of the <code>REF</code> arguments does matter.</p>
<ul>
<li>
<p>The reference table name comes first, if given.</p>
</li>
<li>
<p>The object ID, whether it is system-generated or primary-key-based, comes next.</p>
</li>
</ul>
</li>
<li>
<p>Use the naming convention for the <code>REF</code> arguments.</p>
<ul>
<li>
<p>For the reference table name argument, use any dummy name for its column name, for example, "ref-tbl."</p>
</li>
<li>
<p>For the system-generated OID argument, use any dummy name for its column name, such as "sys-OID." Note: Because this column is used as an argument and not as a column to load into, do not set this column with <code>OCI_ATTR_DIRPATH_OID</code>.</p>
</li>
<li>
<p>For a primary-key-based object ID, list all the primary-key columns to load into. There is no need to create a dummy name for OID. The component column names, if given (see step for shortcut later), can be given in any order.</p>
</li>
</ul>
</li>
<li>
<p>Do not set the attribute column names for the object ID to use the shortcut.</p>
<ul>
<li>
<p><span class="bold">Shortcut.</span> If loading a system-OID-based <code>REF</code> column, do not set the column name with a name. The API figures it out. But you must still set other column attributes, such as external data type.</p>
</li>
<li>
<p>If loading a primary-key <code>REF</code> column and its primary key consists of multiple columns, the shortcut is not to set their column names. However, you must set other column attributes, such as the external data type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the component column names are NULL, then the API code determines the column names in the position or order in which they were defined for the primary key. So, when you set column attributes other than the name, ensure that the attributes are set for the component columns in the correct order.</div>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="LNOCI16979" class="sect3"><a id="sthref2077"></a>
<h4 class="sect3"><a id="sthref2078"></a>OCI_ATTR_DIRPATH_SID</h4>
<p>Indicates that a column is a nested table's <code>SETID</code> column. Required if loading to a nested table.</p>
<pre>
ub1 flg = 1;
sword error;

error = OCIAttrSet((void  *)colDesc, 
                   OCI_DTYPE_PARAM,
                   (void  *)&amp;flg, (ub4)0,
                   OCI_ATTR_DIRPATH_SID, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI16980" class="sect3"><a id="sthref2079"></a>
<h4 class="sect3"><a id="sthref2080"></a>OCI_ATTR_DIRPATH_OID</h4>
<p>Indicates that a column is an object table's object ID column.</p>
<pre>
ub1 flg = 1;
sword error;

error = OCIAttrSet((void  *)colDesc, 
                   OCI_DTYPE_PARAM,
                   (void  *)&amp;flg, (ub4)0,
                   OCI_ATTR_DIRPATH_OID, ctlp-&gt;errhp_ctl);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16981" class="sect2"><a id="sthref2081"></a>
<h3 class="sect2">Direct Path Function Column Array Handle for Nonscalar Columns</h3>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i453507">"Direct Path Function Column Array Handle (OCIDirPathColArray) Attributes"</a></div>
<p>The handle type <code><a id="sthref2082"></a>OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code> is used if the column is an object, SQL string, or <code>REF</code>. The structure <code>OCIDirPathColArray</code> is the same for both scalar and nonscalar columns.</p>
<p><a href="#CACCHAJG">Example 13-24</a> shows how to allocate a child column array for a function context.</p>
<div id="LNOCI18307" class="example">
<p class="titleinexample"><a id="CACCHAJG"></a>Example 13-24 Allocating a Child Column Array for a Function Context</p>
<pre>
OCIDirPathFuncCtx *dpfnctx; /* direct path function context */
OCIDirPathColArray *dpfnca; /* direct path function column array */
sword error;

error = OCIHandleAlloc((void  *)dpfnctx, (void  **)&amp;dpfnca,
                       OCI_HTYPE_DIRPATH_FN_COL_ARRAY,
                       (size_t)0, (void  **)0);
</pre></div>
<!-- class="example" -->
<div id="LNOCI16982" class="sect3"><a id="sthref2083"></a>
<h4 class="sect3"><a id="sthref2084"></a>OCI_ATTR_NUM_ROWS Attribute</h4>
<p>This attribute, when used for an <code>OCI_HTYPE_DIRPATH_FN_COL_ARRAY</code> (function column array), is retrievable only, and cannot be set by the user. When the <code>OCI_ATTR_NUM_ROWS</code> attribute is called with the function <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a>, the number of rows allocated for the function column array is returned.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci12oty.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci14oca.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
