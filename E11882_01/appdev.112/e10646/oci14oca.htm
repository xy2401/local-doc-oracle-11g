<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Object Advanced Topics in OCI</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:24Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci13obn.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci15ott.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">21/79</span> <!-- End Header -->
<div id="LNOCI130" class="chapter"><a id="g458990"></a> <a id="i443693"></a>
<h1 class="chapter"><span class="secnum">14</span> Object Advanced Topics in OCI</h1>
<p>This chapter introduces the OCI facility for working with objects in an Oracle Database. It also discusses the object navigational function calls, type evolution, and support for XML produced by OCI.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i450269">Object Cache and Memory Management</a></p>
</li>
<li>
<p><a href="#i440496">Object Navigation</a></p>
</li>
<li>
<p><a href="#i433513">OCI Navigational Functions</a></p>
</li>
<li>
<p><a href="#i445166">Type Evolution and the Object Cache</a></p>
</li>
<li>
<p><a href="#i450162">OCI Support for XML</a></p>
</li>
</ul>
<a id="i450269"></a>
<div id="LNOCI16983" class="sect1">
<h2 class="sect1">Object Cache and Memory Management<a id="sthref2085"></a><a id="sthref2086"></a><a id="sthref2087"></a></h2>
<p>The object cache is a client-side memory buffer that provides lookup and memory management support for objects. It stores and tracks object instances that have been fetched by an OCI application. The object cache provides memory management.</p>
<p>When objects are fetched by the application through a SQL <code>SELECT</code> statement, or through an OCI pin operation, a copy of the object is stored in the object cache. Objects that are fetched directly through a <code>SELECT</code> statement are fetched <span class="italic">by value</span>, and they are nonreferenceable objects that cannot be pinned. Only referenceable objects can be pinned.</p>
<p>If an object is being pinned, and an appropriate version exists in the cache, it does not need to be fetched from the server.</p>
<p>Every client program that uses OCI to dereference <code>REF</code>s to retrieve objects utilizes the object cache. A client-side object cache is allocated for every OCI environment handle initialized in object mode. Multiple threads of a process can share the same client-side cache by sharing the same OCI environment handle.</p>
<p>Exactly one copy of each referenceable object exists in the cache for each connection. The object cache is logically partitioned by the connection.</p>
<p>Dereferencing a <code>REF</code> many times or dereferencing several equivalent <code>REF</code>s in the same connection returns the same copy of the object.</p>
<p>If you modify a copy of an object in the cache, you must flush the changes to the server before they are visible to other processes. Objects that are no longer needed can be unpinned or freed; they can then be swapped out of the cache, freeing the memory space they occupied.</p>
<p>When database objects are loaded into the cache, they are transparently mapped into the C language structures. The object cache maintains the association between all object copies in the cache and their corresponding objects in the database. When the transaction is committed, changes made to the object copy in the cache are automatically propagated to the database.</p>
<p>The cache does not manage the contents of object copies; it does not automatically refresh object copies. The application must ensure the correctness and consistency of the contents of object copies. For example, if the application marks an object copy for insert, update, or delete, and then terminates the transaction, the cache simply unmarks the object copy but does not purge or invalidate the copy. The application must pin <span class="italic">recent</span> or <span class="italic">latest</span>, or refresh the object copy in the next transaction. If it pins <span class="italic">any</span>, it may get the same object copy with its uncommitted changes from the previous terminated transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i440293">"Pinning an Object Copy"</a></div>
<p>The object cache is created when the OCI environment is initialized using <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> with <code>mode</code> set to <code>OCI_OBJECT</code>.</p>
<p>The object cache maintains a fast lookup table for mapping <code>REF</code>s to objects. When an application dereferences a <code>REF</code> and the corresponding object is not yet cached in the object cache, the object cache automatically sends a request to the server to fetch the object from the database and load it into the object cache.</p>
<p>Subsequent dereferences of the same <code>REF</code> are faster because they use local cache access and do not incur network round-trips. To notify the object cache that an application is accessing an object in the cache, the application pins the object; when it is done with the object, it should unpin it. The object cache maintains a pin count for each object in the cache; the count is incremented upon a pin call, and an unpin call decrements it. The pin count goes to zero when the object is no longer needed by the application.</p>
<p>The object cache uses a least recently used (LRU) algorithm to manage the size of the cache. The LRU algorithm frees candidate objects when the cache reaches the maximum size. The candidate objects are objects with a pin count of zero.</p>
<p>Each application process running against the same server has its own object cache, as shown in <a href="#i444407">Figure 14-1</a>.</p>
<div id="LNOCI16984" class="figure">
<p class="titleinfigure"><a id="i444407"></a>Figure 14-1 Object Cache</p>
<img width="389" height="482" src="img/lnoci028.gif" alt="Description of Figure 14-1 follows" /><br />
<a id="sthref2088" href="img_text/lnoci028.htm">Description of "Figure 14-1 Object Cache"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The object cache tracks the objects that are currently in memory, maintains references to the objects, manages automatic object swapping, and tracks object meta-attributes.</p>
<div id="LNOCI16985" class="sect2"><a id="sthref2089"></a>
<h3 class="sect2">Cache Consistency and Coherency<a id="sthref2090"></a><a id="sthref2091"></a><a id="sthref2092"></a><a id="sthref2093"></a></h3>
<p>The object cache does not automatically maintain value coherency or consistency between object copies and their corresponding objects in the database. In other words, if an application makes changes to an object copy, the changes are not automatically applied to the corresponding object in the database, and vice versa. The cache provides operations such as flushing a modified object copy to the database and refreshing a stale object copy with the latest value from the database to enable the program to maintain some coherency.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database does not support automatic cache coherency with the server's buffer cache or database. Automatic cache coherency refers to the mechanism by which the object cache refreshes local object copies when the corresponding objects have been modified in the server's buffer cache. This mechanism occurs when the object cache flushes the changes made to local object copies to the buffer cache before any direct access of corresponding objects in the server. Direct access includes using SQL, triggers, or stored procedures to read or modify objects in the server.</div>
</div>
<!-- class="sect2" -->
<a id="i441889"></a>
<div id="LNOCI16986" class="sect2">
<h3 class="sect2">Object Cache Parameters<a id="sthref2094"></a><a id="sthref2095"></a></h3>
<p>The object cache has two important parameters associated with it, which are attributes of the environment handle:</p>
<ul>
<li>
<p><a id="sthref2096"></a><code>OCI_ATTR_CACHE_MAX_SIZE</code> &ndash; The maximum cache size</p>
</li>
<li>
<p><a id="sthref2097"></a><code>OCI_ATTR_CACHE_OPT_SIZE</code> &ndash; The optimal cache size</p>
</li>
</ul>
<p>These parameters refer to levels of cache memory usage, and they help determine when the cache automatically ages out eligible objects to free up memory.</p>
<p>If the memory occupied by the objects currently in the cache reaches or exceeds the maximum cache size, the cache automatically begins to free (or ages out) unmarked objects that have a pin count of zero. The cache continues freeing such objects until memory usage in the cache reaches the optimal size, or until it runs out of objects eligible for freeing. Note that the cache can grow beyond the specified maximum cache size.</p>
<p><code>OCI_ATTR_CACHE_MAX_SIZE</code> is specified as a percentage of <code>OCI_ATTR_CACHE_OPT_SIZE</code>. The maximum object cache size (in bytes) is computed by incrementing <code>OCI_ATTR_CACHE_OPT_SIZE</code> by the <code>OCI_ATTR_CACHE_MAX_SIZE</code> percentage, using the following algorithm:</p>
<pre>
maximum_cache_size = optimal_size + optimal_size * max_size_percentage / 100
</pre>
<p>Next, represent the algorithm in terms of environment handle attributes.</p>
<pre>
maximum_cache_size = OCI_ATTR_CACHE_OPT_SIZE + OCI_ATTR_CACHE_OPT_SIZE * 
                                            OCI_ATTR_CACHE_MAX_SIZE / 100
</pre>
<p>You can set the value of <code>OCI_ATTR_CACHE_MAX_SIZE</code> at 10% (the default) of the <code>OCI_ATTR_CACHE_OPT_SIZE</code>. The default value for <code>OCI_ATTR_CACHE_OPT_SIZE</code> is 8 MB.</p>
<p>The cache size attributes of the environment handle can be set with the <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> call and retrieved with the <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> function.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
See <a href="ociaahan.htm#i428587">"Environment Handle Attributes"</a> for more information</div>
</div>
<!-- class="sect2" -->
<a id="BGBHEHFI"></a>
<div id="LNOCI16987" class="sect2">
<h3 class="sect2">Object Cache Operations<a id="sthref2098"></a></h3>
<p>This section describes the most important functions that the object cache provides to operate on object copies.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i433513">"OCI Navigational Functions"</a> for a list of all the OCI navigational, cache, and object management functions</div>
<div id="LNOCI16988" class="sect3"><a id="sthref2099"></a>
<h4 class="sect3">Pinning and Unpinning</h4>
<p>Pinning an object copy enables the application to access it in the cache by dereferencing the <code>REF</code> to it.</p>
<p>Unpinning an object indicates to the cache that the object currently is not being used. Objects should be unpinned when they are no longer needed to make them eligible for implicit freeing by the cache, thus freeing up memory.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16989" class="sect3"><a id="sthref2100"></a>
<h4 class="sect3">Freeing</h4>
<p>Freeing an object copy removes it from the cache and frees its memory.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16990" class="sect3"><a id="sthref2101"></a>
<h4 class="sect3">Marking and Unmarking</h4>
<p>Marking an object notifies the cache that an object copy has been updated in the cache and the corresponding object must be updated in the server when the object copy is flushed.</p>
<p>Unmarking an object removes the indication that the object has been updated.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16991" class="sect3"><a id="sthref2102"></a>
<h4 class="sect3">Flushing</h4>
<p>Flushing an object writes local changes made to marked object copies in the cache to the corresponding objects in the server. When this happens, the copies in the object cache are unmarked.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16992" class="sect3"><a id="sthref2103"></a>
<h4 class="sect3">Refreshing</h4>
<p>Refreshing an object copy in the cache replaces it with the latest value of the corresponding object in the server.</p>
<p>Note that pointers to top-level object memory are valid after a refresh. However, pointers to secondary-level memory (for example, string text pointers, collections, and so on) may become invalid after a refresh.</p>
<p>For example, if the object is of type <code>person</code> with two attributes: <code>salary (number)</code>, and <code>name (varchar2(20)</code>). The type is:</p>
<pre>
struct Person {
OCINumber salary;
OCIString *name;
}
</pre>
<p>If the client has a pointer <code>scott_p</code> to <code>Person</code> instance, and calls <a href="oci18nav001.htm#i469130">OCIObjectRefresh()</a> on that instance, the pointer <code>scott_p</code> is still the same after the refresh, but the pointers to second-level memory, such as <code>scott_p-&gt;name</code>, can be different.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16993" class="sect2"><a id="sthref2104"></a>
<h3 class="sect2">Loading and Removing Object Copies<a id="sthref2105"></a><a id="sthref2106"></a></h3>
<p>Pin, unpin, and free functions are discussed in this section.</p>
<a id="i440293"></a>
<div id="LNOCI16994" class="sect3">
<h4 class="sect3">Pinning an Object Copy<a id="sthref2107"></a><a id="sthref2108"></a></h4>
<p>When an application must dereference a <code>REF</code> in the object cache, it calls <a href="oci18nav005.htm#i433563">OCIObjectPin()</a>. This call dereferences the <code>REF</code> and pins the object copy in the cache. As long as the object copy is pinned, it is guaranteed to be accessible by the application. <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> takes a pin option, <span class="italic">any</span>, <span class="italic">recent</span>, or <span class="italic">latest</span>. The data type of the pin option is <code>OCIPinOpt</code>.<a id="sthref2109"></a></p>
<ul>
<li>
<p>If the <span class="italic">any</span> (<a id="sthref2110"></a><code>OCI_PIN_ANY</code>) option is specified, the object cache immediately returns the object copy that is in the cache, if one exists. If no copy is in the cache, the object cache loads the latest object copy from the database and then returns the object copy. The <span class="italic">any</span> option is appropriate for read-only, informational, fact, or meta objects, such as products, sales representatives, vendors, regions, parts, or offices. These objects usually do not change often, and even if they change, the change does not affect the application.</p>
<p>Note that the object cache looks for the object copy only within the logical partition of the cache for the specified connection. If there is no copy in the partition, the latest copy of the object is loaded from the server.</p>
</li>
<li>
<p>If the <span class="italic">latest</span> (<a id="sthref2111"></a><code>OCI_PIN_LATEST</code>) option is specified, the object cache loads into the cache the latest object copy from the database. It returns that copy unless the object copy is locked in the cache, in which case the marked object copy is returned immediately. If the object is in the cache and not locked, the latest object copy is loaded and overwrites the existing one. The <span class="italic">latest</span> option is appropriate for operational objects, such as purchase orders, bugs, line items, bank accounts, or stock quotes. These objects usually change often, and it is important that the program access these objects at their latest possible state.</p>
</li>
<li>
<p>If the <span class="italic">recent</span> (<a id="sthref2112"></a><code>OCI_PIN_RECENT</code>) option is specified, there are two possibilities:</p>
<ul>
<li>
<p>If in the same transaction the object copy has been previously pinned using the <span class="italic">latest</span> or <span class="italic">recent</span> option, the <span class="italic">recent</span> option becomes equivalent to the <span class="italic">any</span> option.</p>
</li>
<li>
<p>If the previous condition does not apply, the <span class="italic">recent</span> option becomes equivalent to the <span class="italic">latest</span> option.</p>
</li>
</ul>
</li>
</ul>
<p>When the program pins an object, the program also specifies one of two possible values for the pin duration: <span class="italic">session</span> or <span class="italic">transaction</span>. The data type of the duration is <code>OCIDuration</code>.<a id="sthref2113"></a></p>
<ul>
<li>
<p>If the pin duration is <span class="italic">session</span> (<a id="sthref2114"></a><code>OCI_DURATION_SESSION</code>), the object copy remains pinned until the end of session (that is, end of connection) or until it is unpinned explicitly by the program (by calling <code>OCIObjectUnpin()</code>).</p>
</li>
<li>
<p>If the pin duration is <span class="italic">transaction</span> (<a id="sthref2115"></a><code>OCI_DURATION_TRANS</code>), the object copy remains pinned until the end of transaction or until it is unpinned explicitly.</p>
</li>
</ul>
<p>When loading an object copy into the cache from the database, the cache effectively executes the following statement:</p>
<pre>
SELECT VALUE(t) FROM t WHERE REF(t) = :r
</pre>
<p>In this statement, <code>t</code> is the object table storing the object, <code>r</code> is the <code>REF</code>, and the fetched value becomes the value of the object copy in the cache.</p>
<p>Because the object cache effectively executes a separate <code>SELECT</code> statement to load each object copy into the cache, in a read-committed transaction, object copies are not guaranteed to be read-consistent with each other.</p>
<p>In a serializable transaction, object copies pinned as <span class="italic">recent</span> or <span class="italic">latest</span> are read-consistent with each other because the <code>SELECT</code> statements to load these object copies are executed based on the same database snapshot.</p>
<p>Read-committed and serialized transactions refer to different isolation levels that a database can support. There are other isolation levels also, such as read-uncommitted, repeatable read, and so on. Each isolation level permits more or less interference among concurrent transactions. Typically, when an isolation level permits more interference, simultaneous transactions have higher concurrency. In a read-committed transaction, when a query is executed multiple times, this type of transaction can produce inconsistent sets of data because it allows changes made by other committed transactions to be seen. This does not happen in serializable transactions.</p>
<p>The object cache model is orthogonal to or independent of the Oracle Database transaction model. The behavior of the object cache does not change based on the transaction model, even though the objects that are retrieved from the server through the object cache can be different when running the same program under different transaction models (for example, read-committed versus serializable).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For <a href="oci18nav005.htm#i427422">OCIObjectArrayPin()</a> the pin option has no effect, because objects are always retrieved from the database. If a <code>REF</code> is to an object in the cache, <code>OCIObjectArrayPin()</code> fails with:
<pre>
ORA-22881: dangling REF
</pre></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI16995" class="sect3"><a id="sthref2116"></a>
<h4 class="sect3">Unpinning an Object Copy<a id="sthref2117"></a><a id="sthref2118"></a></h4>
<p>An object copy can be unpinned when it is no longer used by the program. It then becomes available to be freed. An object copy must be both completely unpinned and unmarked to become eligible to be implicitly freed by the cache when the cache begins to run out of memory. To be completely unpinned, an object copy that has been pinned <span class="italic">n</span> times must be unpinned <span class="italic">n</span> times.</p>
<p>An unpinned but marked object copy is not eligible for implicit freeing until the object copy is flushed or explicitly unmarked by the user. However, the object cache implicitly frees object copies only when it begins to run out of memory, so an unpinned object copy need not necessarily be freed. If it has not been implicitly freed and is pinned again (with the any or recent options), the program gets the same object copy.</p>
<p>An application calls <a href="oci18nav005.htm#i438263">OCIObjectUnpin()</a> or <a href="oci18nav005.htm#i433515">OCIObjectPinCountReset()</a> to unpin an object copy. In addition, a program can call <a href="oci18nav005.htm#i469229">OCICacheUnpin()</a> to completely unpin all object copies in the cache for a specific connection.</p>
</div>
<!-- class="sect3" -->
<a id="i440637"></a>
<div id="LNOCI16996" class="sect3">
<h4 class="sect3">Freeing an Object Copy<a id="sthref2119"></a><a id="sthref2120"></a></h4>
<p>Freeing an object copy removes it from the object cache and frees up its memory. The cache supports two methods for freeing up memory:</p>
<ul>
<li>
<p>Explicit freeing &ndash; A program explicitly frees or removes an object copy from the cache by calling <a href="oci18nav005.htm#i430212">OCIObjectFree()</a>, which takes an option to (forcefully) free either a marked or pinned object copy. The program can also call <a href="oci18nav005.htm#i471310">OCICacheFree()</a> to free all object copies in the cache.</p>
</li>
<li>
<p>Implicit freeing &ndash; if the cache begins to run out of memory, it implicitly frees object copies that are both unpinned and unmarked. Unpinned objects that are marked are eligible for implicitly freeing only when the object copy is flushed or unmarked.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i441889">"Object Cache Parameters"</a> for more information</div>
</li>
</ul>
<p>For memory management reasons, it is important that applications unpin objects when they are no longer needed. This makes these objects available for aging out of the cache, and makes it easier for the cache to free memory when necessary.</p>
<p>OCI does not provide a function to free unreferenced objects in the client-side cache.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI16997" class="sect2"><a id="sthref2121"></a>
<h3 class="sect2">Making Changes to Object Copies</h3>
<p>Functions for marking and unmarking object copies are discussed in this section.</p>
<div id="LNOCI16998" class="sect3"><a id="sthref2122"></a>
<h4 class="sect3">Marking an Object Copy<a id="sthref2123"></a><a id="sthref2124"></a></h4>
<p>An object copy can be created, updated, and deleted locally in the cache. If the object copy is created in the cache (by calling <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>), the object copy is marked for insert by the object cache, so that the object is inserted in the server when the object copy is flushed.</p>
<p>If the object copy is updated in the cache, the user must notify the object cache by marking the object copy for update (by calling <a href="oci18nav002.htm#i470154">OCIObjectMarkUpdate()</a>). When the object copy is flushed, the corresponding object in the server is updated with the value in the object copy.</p>
<p>If the object copy is deleted, the object copy is marked for delete in the object cache (by calling <a href="oci18nav002.htm#i470079">OCIObjectMarkDelete()</a>). When the object copy is flushed, the corresponding object in the server is deleted. The memory of the marked object copy is not freed until it is flushed and unpinned. When pinning an object marked for delete, the program receives an error, as if the program is dereferencing a dangling reference.</p>
<p>When a user makes multiple changes to an object copy, it is the final results of these changes that are applied to the object in the server when the copy is flushed. For example, if the user updates and deletes an object copy, the object in the server is deleted when the object copy is flushed. Similarly, if an attribute of an object copy is updated multiple times, it is the final value of this attribute that is updated in the server when the object copy is flushed.</p>
<p>The program can mark an object copy as updated or deleted only if the object copy has been loaded into the object cache.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI16999" class="sect3"><a id="sthref2125"></a>
<h4 class="sect3">Unmarking an Object Copy<a id="sthref2126"></a><a id="sthref2127"></a></h4>
<p>A marked object copy can be unmarked in the object cache. By unmarking a marked object copy, the program ensures that the changes that are made to the object copy are not flushed to the server. The object cache does not undo the local changes that are made to the object copy.</p>
<p>A program calls <a href="oci18nav002.htm#i470209">OCIObjectUnmark()</a> to unmark an object. In addition, a program can call <a href="oci18nav002.htm#i437386">OCICacheUnmark()</a> to unmark all object copies in the cache for a specific connection.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI17000" class="sect2"><a id="sthref2128"></a>
<h3 class="sect2">Synchronizing Object Copies with the Server</h3>
<p>Cache and server synchronization operations (flushing, refreshing) are discussed in this section.</p>
<a id="i440636"></a>
<div id="LNOCI17001" class="sect3">
<h4 class="sect3">Flushing Changes to the Server<a id="sthref2129"></a><a id="sthref2130"></a><a id="sthref2131"></a></h4>
<p>When the program flushes the object copy, it writes the local changes made to a marked object copy in the cache to the server. The program can call <a href="oci18nav001.htm#i469090">OCIObjectFlush()</a> to flush a single object copy. The program can call <a href="oci18nav001.htm#i427410">OCICacheFlush()</a> to flush all marked object copies in the cache or a list of selected marked object copies. <a href="oci18nav001.htm#i427410">OCICacheFlush()</a> flushes objects associated with a specific service context. See <a href="oci18nav001.htm#i427410">OCICacheFlush()</a>.</p>
<p>After the object copy is flushed, it is unmarked. (Note that the object is locked in the server after it is flushed; the object copy is therefore marked as locked in the cache.)</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <a href="oci18nav001.htm#i469090">OCIObjectFlush()</a> operation incurs only a single server round-trip even if multiple objects are being flushed.</div>
<p>The callback function (an optional argument to the <a href="oci18nav001.htm#i427410">OCICacheFlush()</a> call) enables an application to flush only dirty objects of a certain type. The application can define a callback that returns only the desired objects. In this case, the operation still incurs only a single server round-trip for the flush.</p>
<p>In the default mode during <a href="oci18nav001.htm#i427410">OCICacheFlush()</a>, the objects are flushed in the order that they are marked dirty. The performance of this flush operation can be considerably improved by setting the <a id="sthref2132"></a><code>OCI_ATTR_CACHE_ARRAYFLUSH</code> attribute in the environment handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i428587">"Environment Handle Attributes"</a></div>
<p>However, the <code>OCI_ATTR_CACHE_ARRAYFLUSH</code> attribute should be used only if the order in which the objects are flushed is not important. While this attribute is in effect, the dirty objects are grouped together and sent to the server in a manner that enables the server to efficiently update its tables. When this attribute is enabled, it is not guaranteed that the order in which the objects are marked dirty is preserved.</p>
</div>
<!-- class="sect3" -->
<a id="i440793"></a>
<div id="LNOCI17002" class="sect3">
<h4 class="sect3">Refreshing an Object Copy<a id="sthref2133"></a><a id="sthref2134"></a><a id="sthref2135"></a></h4>
<p>When refreshed, an object copy is reloaded with the latest value of the corresponding object in the server. The latest value may contain changes made by other committed transactions and changes made directly (not through the object cache) in the server by the transaction. The program can change objects directly in the server using SQL DML, triggers, or stored procedures.</p>
<p>To refresh a marked object copy, the program must first unmark the object copy. An unpinned object copy is freed when it is refreshed (that is, when the whole cache is refreshed).</p>
<p>The program can call <a href="oci18nav001.htm#i469130">OCIObjectRefresh()</a> to refresh a single object copy or <a href="oci18nav001.htm#i469031">OCICacheRefresh()</a> to refresh all object copies in the cache, all object copies that are loaded in a transaction (that is, object copies that are pinned recent or pinned latest), or a list of selected object copies.</p>
<p>When an object is flushed to the server, triggers can be fired to modify more objects in the server. The same objects (modified by the triggers) in the object cache become out-of-date, and must be refreshed before they can be locked or flushed.</p>
<p>The various meta-attribute flags and durations of an object are modified as described in <a href="#BGBEEIIA">Table 14-1</a> after being refreshed.</p>
<div id="LNOCI17003" class="tblformal">
<p class="titleintable"><a id="sthref2136"></a><a id="BGBEEIIA"></a>Table 14-1 Object Attributes After a Refresh Operation</p>
<table class="cellalignment1016" title="Object Attributes After a Refresh Operation" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t10">Object Attribute</th>
<th class="cellalignment1012" id="r1c2-t10">Status After Refresh</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t10" headers="r1c1-t10">
<p>Existent</p>
</td>
<td class="cellalignment1013" headers="r2c1-t10 r1c2-t10">
<p>Set to appropriate value</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t10" headers="r1c1-t10">
<p>Pinned</p>
</td>
<td class="cellalignment1013" headers="r3c1-t10 r1c2-t10">
<p>Unchanged</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t10" headers="r1c1-t10">
<p>Flushed</p>
</td>
<td class="cellalignment1013" headers="r4c1-t10 r1c2-t10">
<p>Reset</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t10" headers="r1c1-t10">
<p>Allocation duration</p>
</td>
<td class="cellalignment1013" headers="r5c1-t10 r1c2-t10">
<p>Unchanged</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t10" headers="r1c1-t10">
<p>Pin duration</p>
</td>
<td class="cellalignment1013" headers="r6c1-t10 r1c2-t10">
<p>Unchanged</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>During the refresh operation, the object cache loads the new data into the top-level memory of an object copy, thus reusing the top-level memory. The top-level memory of an object copy contains the inline attributes of the object. However, the memory for the out-of-line attributes of an object copy can be freed and relocated, because the out-of-line attributes can vary in size.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
See <a href="#i435233">"Memory Layout of an Instance"</a> for more information about object memory</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI17004" class="sect2"><a id="sthref2137"></a>
<h3 class="sect2">Object Locking</h3>
<p>OCI functions related to object locking are discussed in this section.</p>
<div id="LNOCI17005" class="sect3"><a id="sthref2138"></a>
<h4 class="sect3">Lock Options</h4>
<p>When pinning an object, you can specify whether the object should be locked or not through lock options. When an object is locked, a server-side lock is acquired, which prevents any other user from modifying the object. The lock is released when the transaction commits or rolls back. The different lock options are as follows:</p>
<ul>
<li>
<p>The lock option <a id="sthref2139"></a><code>OCI_LOCK_NONE</code> instructs the cache to pin the object without locking.</p>
</li>
<li>
<p>The lock option <a id="sthref2140"></a><code>OCI_LOCK_X</code> instructs the cache to pin the object only after acquiring a lock. If the object is currently locked by another user, the pin call with this option waits until it can acquire the lock before returning to the caller. This is equivalent to executing a <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement.</p>
</li>
<li>
<p>The lock option <a id="sthref2141"></a><code>OCI_LOCK_X_NOWAIT</code> instructs the cache to pin the object only after acquiring a lock. Unlike the <code>OCI_LOCK_X</code> option, the pin call with the <code>OCI_LOCK_X_NOWAIT</code> option does not wait if the object is currently locked by another user. This is equivalent to executing a <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> <code>WITH</code> <code>NOWAIT</code> statement.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i440635"></a>
<div id="LNOCI17006" class="sect3">
<h4 class="sect3">Locking Objects for Update<a id="sthref2142"></a><a id="sthref2143"></a><a id="sthref2144"></a></h4>
<p>The program can optionally call <a href="oci18nav004.htm#i469657">OCIObjectLock()</a> to lock an object for update. This call instructs the object cache to get a row lock on the object in the database. This is similar to executing the following statement:</p>
<pre>
SELECT NULL FROM t WHERE REF(t) = :r FOR UPDATE
</pre>
<p>In this statement, <code>t</code> is the object table storing the object to be locked, and <code>r</code> is the <code>REF</code> identifying the object. The object copy is marked locked in the object cache after <code>OCIObjectLock()</code> is called.</p>
<p>To lock a graph or set of objects, several <a href="oci18nav004.htm#i469657">OCIObjectLock()</a> calls are required (one for each object) or the array pin <a href="oci18nav005.htm#i427422">OCIObjectArrayPin()</a> call can be used for better performance.</p>
<p>By locking an object, the application is guaranteed that the object in the cache is up-to-date. No other transaction can modify the object while the application has it locked.</p>
<p>At the end of a transaction, all locks are released automatically by the server. The locked indicator in the object copy is reset.</p>
</div>
<!-- class="sect3" -->
<a id="i443357"></a>
<div id="LNOCI17007" class="sect3">
<h4 class="sect3">Locking with the NOWAIT Option<a id="sthref2145"></a></h4>
<p>Occasionally, an application attempts to lock an object that is currently locked by another user. In this case, the application is blocked.</p>
<p>To avoid blocking when trying to lock an object, an application can use the <a href="oci18nav004.htm#i469704">OCIObjectLockNoWait()</a> call instead of <a href="oci18nav004.htm#i469657">OCIObjectLock()</a>. This function returns an error if it cannot lock an object immediately because it is locked by another user.</p>
<p>The <code>NOWAIT</code> option is also available to pin calls by passing a value of <code><a id="sthref2146"></a>OCI_LOCK_X_NOWAIT</code> as the lock option parameter.</p>
</div>
<!-- class="sect3" -->
<a id="i443415"></a>
<div id="LNOCI17008" class="sect3">
<h4 class="sect3">Implementing Optimistic Locking<a id="sthref2147"></a><a id="sthref2148"></a><a id="sthref2149"></a></h4>
<p>There are two options available for implementing optimistic locking in an OCI application. Optimistic locking makes the assumption that a transaction will modify objects in the cache, flush them, and commit the changes successfully.</p>
<dl>
<dt>Optimistic Locking Option 1</dt>
<dd>
<p>The first optimistic locking option is for OCI applications that run transactions at the serializable level.</p>
<p>OCI supports calls that allow you to dereference and pin objects in the object cache without locking them, modify them in the cache (again without locking them), and then flush them (the dirtied objects) to the database.</p>
<p>During the flush operation, if a dirty object has been modified by another committed transaction since the beginning of your transaction, a nonserializable transaction error is returned. If none of the dirty objects has been modified by any other transaction since the beginning of your transaction, then your transaction writes the changes to the database successfully.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a href="oci17msc006.htm#i428845">OCITransCommit()</a> flushes dirty objects into the database before committing a transaction.</div>
<p>The preceding mechanism effectively implements an optimistic locking model.</p>
</dd>
<dt>Optimistic Locking Option 2</dt>
<dd>
<p>Alternately, an application can enable object change detection mode. To do this operation, set the <code><a id="sthref2150"></a>OCI_ATTR_OBJECT_DETECTCHANGE</code> attribute of the environment handle to a value of <code>TRUE</code>.</p>
<p>When this mode has been activated, the application receives an <code>ORA-08179</code> error ("concurrency check failed") when it attempts to flush an object that has been changed in the server by another committed transaction. The application can then handle this error in an appropriate manner.</p>
</dd>
</dl>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="LNOCI17009" class="sect2"><a id="sthref2151"></a>
<h3 class="sect2">Commit and Rollback in Object Applications<a id="sthref2152"></a><a id="sthref2153"></a><a id="sthref2154"></a><a id="sthref2155"></a></h3>
<p>When a transaction is committed (<a href="oci17msc006.htm#i428845">OCITransCommit()</a>), all marked objects are flushed to the server. If an object copy is pinned with a transaction duration, the object copy is unpinned.</p>
<p>When a transaction is rolled back, all marked objects are unmarked. If an object copy is pinned with a transaction duration, the object copy is unpinned.</p>
</div>
<!-- class="sect2" -->
<a id="i437805"></a>
<div id="LNOCI17010" class="sect2">
<h3 class="sect2">Object Duration<a id="sthref2156"></a><a id="sthref2157"></a><a id="sthref2158"></a><a id="sthref2159"></a><a id="sthref2160"></a><a id="sthref2161"></a></h3>
<p>To maintain free space in memory, the object cache attempts to reuse objects' memory whenever possible. The object cache reuses an object's memory when the object's lifetime (<span class="italic">allocation duration)</span> expires or when the object's <span class="italic">pin duration</span> expires. The allocation duration is set when an object is created with <a href="oci18nav004.htm#i470965">OCIObjectNew()</a>, and the pin duration is set when an object is pinned with <a href="oci18nav005.htm#i433563">OCIObjectPin()</a>. The data type of the duration value is <code><a id="sthref2162"></a>OCIDuration</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The pin duration for an object cannot be longer than the object's allocation duration.</div>
<p>When an object reaches the end of its allocation duration, it is automatically deleted and its memory can be reused. The pin duration indicates when an object's memory can be reused; memory is reused when the cache is full.</p>
<p>OCI supports two predefined durations:</p>
<ul>
<li>
<p>Transaction (<code>OCI_DURATION_TRANS</code>)</p>
</li>
<li>
<p>Session (<code>OCI_DURATION_SESSION</code>)</p>
</li>
</ul>
<p>The <span class="italic">transaction duration</span> expires when the containing transaction ends (commits or terminates). The <span class="italic">session duration</span> expires when the containing session or connection ends.</p>
<p>The application can explicitly unpin an object using <a href="oci18nav005.htm#i438263">OCIObjectUnpin()</a>. To minimize explicit unpinning of individual objects, the application can unpin all objects currently pinned in the object cache using the function <a href="oci18nav005.htm#i469229">OCICacheUnpin()</a>. By default, all objects are unpinned at the end of the pin duration.</p>
<div id="LNOCI17011" class="sect3"><a id="sthref2163"></a>
<h4 class="sect3">Durations Example<a id="sthref2164"></a><a id="sthref2165"></a><a id="sthref2166"></a></h4>
<p><a href="#g453011">Table 14-2</a> illustrates the use of the different durations in an application. Four objects are created or pinned in this application over the course of one connection and three transactions. The first column is the relative time indicator. The second column indicates the action performed by the database, and the third column indicates the function that performs the action. The remaining columns indicate the states of the various objects at each point in the application.</p>
<p>For example, Object 1 comes into existence at T2 when it is created with a connection duration, and it exists until T19 when the connection is terminated. Object 2 is pinned at T7 with a transaction duration, after being fetched at T6, and it remains pinned until T9 when the transaction is committed.</p>
<div id="LNOCI17012" class="tblformalwide">
<p class="titleintable"><a id="sthref2167"></a><a id="g453011"></a>Table 14-2 Example of Allocation and Pin Durations</p>
<table class="cellalignment1011" title="Example of Allocation and Pin Durations " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t14">Time</th>
<th class="cellalignment1012" id="r1c2-t14">Application Action</th>
<th class="cellalignment1012" id="r1c3-t14">Function</th>
<th class="cellalignment1012" id="r1c4-t14">Object 1</th>
<th class="cellalignment1012" id="r1c5-t14">Object 2</th>
<th class="cellalignment1012" id="r1c6-t14">Object 3</th>
<th class="cellalignment1012" id="r1c7-t14">Object 4</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t14" headers="r1c1-t14">
<p>T<sub>1</sub></p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c2-t14">
<p>Establish connection</p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c3-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c4-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r2c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t14" headers="r1c1-t14">
<p>T<sub>2</sub></p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c2-t14">
<p>Create object 1 - allocation duration = connection</p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c3-t14">
<p><code><a href="oci18nav004.htm#i470965">OCIObjectNew()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r3c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t14" headers="r1c1-t14">
<p>T<sub>5</sub></p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c2-t14">
<p>Start Transaction1</p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c3-t14">
<p><code><a href="oci17msc006.htm#i458405">OCITransStart()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r4c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t14" headers="r1c1-t14">
<p>T<sub>6</sub></p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c2-t14">
<p>SQL - fetch <code>REF</code> to object 2</p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c3-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r5c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t14" headers="r1c1-t14">
<p>T<sub>7</sub></p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c2-t14">
<p>Pin object 2 - pin duration = transaction</p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c3-t14">
<p><code><a href="oci18nav005.htm#i433563">OCIObjectPin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c5-t14">
<p>Pinned</p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r6c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t14" headers="r1c1-t14">
<p>T<sub>8</sub></p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c2-t14">
<p>Process application data</p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c3-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c5-t14">
<p>Pinned</p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r7c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t14" headers="r1c1-t14">
<p>T<sub>9</sub></p>
</td>
<td class="cellalignment1013" headers="r8c1-t14 r1c2-t14">
<p>Commit Transaction1</p>
</td>
<td class="cellalignment1013" headers="r8c1-t14 r1c3-t14">
<p><code><a href="oci17msc006.htm#i428845">OCITransCommit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r8c1-t14 r1c5-t14">
<p>Unpinned</p>
</td>
<td class="cellalignment1013" headers="r8c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r8c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t14" headers="r1c1-t14">
<p>T<sub>10</sub></p>
</td>
<td class="cellalignment1013" headers="r9c1-t14 r1c2-t14">
<p>Start Transaction2</p>
</td>
<td class="cellalignment1013" headers="r9c1-t14 r1c3-t14">
<p><code><a href="oci17msc006.htm#i458405">OCITransStart()</a></code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r9c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r9c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r9c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t14" headers="r1c1-t14">
<p>T<sub>11</sub></p>
</td>
<td class="cellalignment1013" headers="r10c1-t14 r1c2-t14">
<p>Create object 3 - allocation duration = transaction</p>
</td>
<td class="cellalignment1013" headers="r10c1-t14 r1c3-t14">
<p><code><a href="oci18nav004.htm#i470965">OCIObjectNew()</a></code></p>
</td>
<td class="cellalignment1013" headers="r10c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r10c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r10c1-t14 r1c6-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r10c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t14" headers="r1c1-t14">
<p>T<sub>12</sub></p>
</td>
<td class="cellalignment1013" headers="r11c1-t14 r1c2-t14">
<p>SQL - fetch <code>REF</code> to object 4</p>
</td>
<td class="cellalignment1013" headers="r11c1-t14 r1c3-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r11c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r11c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r11c1-t14 r1c6-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r11c1-t14 r1c7-t14">
<p>-</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t14" headers="r1c1-t14">
<p>T<sub>13</sub></p>
</td>
<td class="cellalignment1013" headers="r12c1-t14 r1c2-t14">
<p>Pin object 4 - pin duration = connection</p>
</td>
<td class="cellalignment1013" headers="r12c1-t14 r1c3-t14">
<p><code><a href="oci18nav005.htm#i433563">OCIObjectPin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r12c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r12c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r12c1-t14 r1c6-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r12c1-t14 r1c7-t14">
<p>Pinned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t14" headers="r1c1-t14">
<p>T<sub>14</sub></p>
</td>
<td class="cellalignment1013" headers="r13c1-t14 r1c2-t14">
<p>Commit Transaction2</p>
</td>
<td class="cellalignment1013" headers="r13c1-t14 r1c3-t14">
<p><code><a href="oci17msc006.htm#i428845">OCITransCommit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r13c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r13c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r13c1-t14 r1c6-t14">
<p>Deleted</p>
</td>
<td class="cellalignment1013" headers="r13c1-t14 r1c7-t14">
<p>Pinned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t14" headers="r1c1-t14">
<p>T<sub>15</sub></p>
</td>
<td class="cellalignment1013" headers="r14c1-t14 r1c2-t14">
<p>Terminate session1</p>
</td>
<td class="cellalignment1013" headers="r14c1-t14 r1c3-t14">
<p><code><a href="oci17msc002.htm#i541163">OCIDurationEnd()</a></code></p>
</td>
<td class="cellalignment1013" headers="r14c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r14c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r14c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r14c1-t14 r1c7-t14">
<p>Pinned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t14" headers="r1c1-t14">
<p>T<sub>16</sub></p>
</td>
<td class="cellalignment1013" headers="r15c1-t14 r1c2-t14">
<p>Start Transaction3</p>
</td>
<td class="cellalignment1013" headers="r15c1-t14 r1c3-t14">
<p><code><a href="oci17msc006.htm#i458405">OCITransStart()</a></code></p>
</td>
<td class="cellalignment1013" headers="r15c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r15c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r15c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r15c1-t14 r1c7-t14">
<p>Pinned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t14" headers="r1c1-t14">
<p>T<sub>17</sub></p>
</td>
<td class="cellalignment1013" headers="r16c1-t14 r1c2-t14">
<p>Process application data</p>
</td>
<td class="cellalignment1013" headers="r16c1-t14 r1c3-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r16c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r16c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r16c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r16c1-t14 r1c7-t14">
<p>Pinned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r17c1-t14" headers="r1c1-t14">
<p>T<sub>18</sub></p>
</td>
<td class="cellalignment1013" headers="r17c1-t14 r1c2-t14">
<p>Commit Transaction3</p>
</td>
<td class="cellalignment1013" headers="r17c1-t14 r1c3-t14">
<p><code><a href="oci17msc006.htm#i428845">OCITransCommit()</a></code></p>
</td>
<td class="cellalignment1013" headers="r17c1-t14 r1c4-t14">
<p>Exists</p>
</td>
<td class="cellalignment1013" headers="r17c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r17c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r17c1-t14 r1c7-t14">
<p>Pinned</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r18c1-t14" headers="r1c1-t14">
<p>T<sub>19</sub></p>
</td>
<td class="cellalignment1013" headers="r18c1-t14 r1c2-t14">
<p>Terminate connection</p>
</td>
<td class="cellalignment1013" headers="r18c1-t14 r1c3-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r18c1-t14 r1c4-t14">
<p>Deleted</p>
</td>
<td class="cellalignment1013" headers="r18c1-t14 r1c5-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r18c1-t14 r1c6-t14">
<p>-</p>
</td>
<td class="cellalignment1013" headers="r18c1-t14 r1c7-t14">
<p>Unpinned</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The descriptions of <a href="oci18nav004.htm#i470965">OCIObjectNew()</a> and <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> in <a href="oci18nav.htm#i476164">Chapter 18</a> for specific information about parameter values that can be passed to these functions</p>
</li>
<li>
<p><a href="oci11obj.htm#i440918">"Creating Objects"</a> for information about freeing up an object's memory before its allocation duration has expired</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i435233"></a>
<div id="LNOCI17013" class="sect2">
<h3 class="sect2">Memory Layout of an Instance<a id="sthref2168"></a><a id="sthref2169"></a><a id="sthref2170"></a><a id="sthref2171"></a><a id="sthref2172"></a></h3>
<p>An instance in memory is composed of a top-level memory chunk of the instance, a top-level memory of the null indicator structure and optionally, some secondary memory chunks. Consider the <code>DEPARTMENT</code> row type defined in <a href="#BGBCACDA">Example 14-1</a>.</p>
<div id="LNOCI18308" class="example">
<p class="titleinexample"><a id="BGBCACDA"></a>Example 14-1 Object Type Representation of a Department Row</p>
<pre>
CREATE TYPE department AS OBJECT
( dep_name      varchar2(20),
  budget        number,
  manager       person,            /* person is an object type */
  employees     person_array );   /* varray of person objects */
</pre></div>
<!-- class="example" -->
<p>The C representation of the <code>DEPARTMENT</code> is shown in <a href="#BGBEIHFD">Example 14-2</a>.</p>
<div id="LNOCI18309" class="example">
<p class="titleinexample"><a id="BGBEIHFD"></a>Example 14-2 C Representation of a Department Row</p>
<pre>
struct department
{
OCIString * dep_name;
OCINumber budget;
struct person manager;
OCIArray * employees;
);
typedef struct department department;
</pre></div>
<!-- class="example" -->
<p>Each instance of <code>DEPARTMENT</code> has a top-level memory chunk that contains the top-level attributes such as <code>dep_name</code>, <code>budget</code>, <code>manager</code>, and <code>employees</code>. The attributes <code>dep_name</code> and <code>employees</code> are pointers to the additional memory (the secondary memory chunks). The secondary memory is used to contain the data for the embedded instances (for example, <code>employees</code> varray and <code>dep_name</code> string).</p>
<p>The top-level memory of the null indicator structure contains the null statuses of the attributes in the top-level memory chunk of the instance. In <a href="#BGBEIHFD">Example 14-2</a>, the top-level memory of the null structure contains the null statuses of the attributes <code>dep_name</code>, <code>budget</code>, and <code>manager</code>, and the atomic nullity of <code>employees</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i440496"></a>
<div id="LNOCI17014" class="sect1">
<h2 class="sect1">Object Navigation<a id="sthref2173"></a><a id="sthref2174"></a></h2>
<p>This section discusses how OCI applications can navigate through graphs of objects in the object cache.</p>
<a id="i442207"></a>
<div id="LNOCI17015" class="sect2">
<h3 class="sect2">Simple Object Navigation<a id="sthref2175"></a></h3>
<p>In <a href="#BGBCACDA">Example 14-1</a> and <a href="#BGBEIHFD">Example 14-2</a>, the object retrieved by the application was a simple object, whose attributes were all scalar values. If an application retrieves an object with an attribute that is a <code>REF</code> to another object, the application can use OCI calls to traverse the <span class="italic">object graph</span> and access the referenced instance.</p>
<p>As an example, consider the following declaration for a new type in the database:</p>
<pre>
CREATE TYPE person_t AS OBJECT
(  name          VARCHAR2(30),
  mother          REF person_t,
  father          REF person_t);
</pre>
<p>An object table of <code>person_t</code> objects is created with the following statement:</p>
<pre>
CREATE TABLE person_table OF person_t;
</pre>
<p>Instances of the <code>person_t</code> type can now be stored in the typed table. Each instance of <code>person_t</code> includes references to two other objects, which would also be stored in the table. A <code>NULL</code> reference could represent a parent about whom information is not available.</p>
<p>An object graph is a graphical representation of the <code>REF</code> links between object instances. For example, <a href="#i440204">Figure 14-2</a> depicts an object graph of <code>person_t</code> instances, showing the links from one object to another. The circles represent objects, and the arrows represent references to other objects. The M and F adjacent to the arrows indicate mother and father, respectively.</p>
<div id="LNOCI17016" class="figure">
<p class="titleinfigure"><a id="i440204"></a>Figure 14-2 Object Graph of person_t Instances</p>
<img width="503" height="868" src="img/lnoci027.gif" alt="Description of Figure 14-2 follows" /><br />
<a id="sthref2176" href="img_text/lnoci027.htm">Description of "Figure 14-2 Object Graph of person_t Instances"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In this case, each object has links to two other instances (M and F) of the same object. This need not always be the case. Objects may have links to other object types. Other types of graphs are also possible. For example, if a set of objects is implemented as a linked list, the object graph could be viewed as a simple chain, where each object references either the previous or next objects or both in the linked list.</p>
<p>You can use the methods described earlier in this chapter to retrieve a reference to a <code>person_t</code> instance and then pin that instance. OCI provides functionality that enables you to traverse the object graph by following a reference from one object to another.</p>
<p>As an example, assume that an application fetches the <code>person1</code> instance in the preceding graph and pins it as <code>pers_1</code>. Once that has been done, the application can access the mother instance of <code>person1</code> and pin it into <code>pers_2</code> through a second pin operation:</p>
<pre>
OCIObjectPin(env, err, pers_1-&gt;mother, OCI_PIN_ANY, OCI_DURATION_TRANS,
             OCI_LOCK_X, (OCIComplexObject *) 0, &amp;pers_2);
</pre>
<p>In this case, an OCI fetch operation is not required to retrieve the second instance.</p>
<p>The application could then pin the father instance of <code>person1</code>, or it could operate on the reference links of <code>person2</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Attempting to pin a <code>NULL</code> or dangling <code>REF</code> results in an error on the <a href="oci18nav005.htm#i433563">OCIObjectPin()</a> call.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i433513"></a>
<div id="LNOCI17017" class="sect1">
<h2 class="sect1">OCI Navigational Functions<a id="sthref2177"></a><a id="sthref2178"></a></h2>
<p>This section provides a brief summary of the available OCI navigational functions. The functions are grouped according to their general functionality.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci18nav.htm#i476164">Chapter 18</a> for more detailed descriptions of each of these functions</div>
<p>Earlier sections of this chapter describe the use of these functions.</p>
<p>The navigational functions follow a naming scheme that uses different prefixes for different types of functionality:</p>
<p><code>OCICache*()</code> &ndash; These functions are cache operations.</p>
<p><code>OCIObject*()</code> &ndash; These functions are individual object operations.</p>
<div id="LNOCI17018" class="sect2"><a id="sthref2179"></a>
<h3 class="sect2">Pin/Unpin/Free Functions<a id="sthref2180"></a></h3>
<p>The functions in <a href="#BGBDIFGI">Table 14-3</a> are available to pin, unpin, or free objects.</p>
<div id="LNOCI17019" class="tblformal">
<p class="titleintable"><a id="sthref2181"></a><a id="BGBDIFGI"></a>Table 14-3 Pin, Free, and Unpin Functions</p>
<table class="cellalignment1016" title="Pin, Free, and Unpin Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t18">Function</th>
<th class="cellalignment1012" id="r1c2-t18">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i471310">OCICacheFree()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t18 r1c2-t18">
<p>Free all instances in the cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i469229">OCICacheUnpin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t18 r1c2-t18">
<p>Unpin persistent objects in cache or connection</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i427422">OCIObjectArrayPin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t18 r1c2-t18">
<p>Pin an array of references</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i430212">OCIObjectFree()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t18 r1c2-t18">
<p>Free and unpin a standalone instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i433563">OCIObjectPin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t18 r1c2-t18">
<p>Pin an object</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i433515">OCIObjectPinCountReset()</a></code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t18 r1c2-t18">
<p>Unpin an object to zero pin count</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i433457">OCIObjectPinTable()</a></code></p>
</td>
<td class="cellalignment1013" headers="r8c1-t18 r1c2-t18">
<p>Pin a table object with a given duration</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t18" headers="r1c1-t18">
<p><code><a href="oci18nav005.htm#i438263">OCIObjectUnpin()</a></code></p>
</td>
<td class="cellalignment1013" headers="r9c1-t18 r1c2-t18">
<p>Unpin an object</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI17020" class="sect2"><a id="sthref2182"></a>
<h3 class="sect2">Flush and Refresh Functions<a id="sthref2183"></a></h3>
<p>The functions in <a href="#BGBDFADA">Table 14-4</a> are available to flush modified objects to the server.</p>
<div id="LNOCI17021" class="tblformal">
<p class="titleintable"><a id="sthref2184"></a><a id="BGBDFADA"></a>Table 14-4 Flush and Refresh Functions</p>
<table class="cellalignment1016" title="Flush and Refresh Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t19">Function</th>
<th class="cellalignment1012" id="r1c2-t19">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t19" headers="r1c1-t19">
<p><code><a href="oci18nav001.htm#i427410">OCICacheFlush()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t19 r1c2-t19">
<p>Flush modified persistent objects in cache to server</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t19" headers="r1c1-t19">
<p><code><a href="oci18nav001.htm#i469090">OCIObjectFlush()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t19 r1c2-t19">
<p>Flush a modified persistent object to the server</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t19" headers="r1c1-t19">
<p><code><a href="oci18nav001.htm#i469031">OCICacheRefresh()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t19 r1c2-t19">
<p>Refresh pinned persistent objects in the cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t19" headers="r1c1-t19">
<p><code><a href="oci18nav001.htm#i469130">OCIObjectRefresh()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t19 r1c2-t19">
<p>Refresh a single persistent object</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI17022" class="sect2"><a id="sthref2185"></a>
<h3 class="sect2">Mark and Unmark Functions<a id="sthref2186"></a></h3>
<p>The functions in <a href="#BGBCDJDH">Table 14-5</a> allow an application to mark or unmark an object by modifying one of its meta-attributes.</p>
<div id="LNOCI17023" class="tblformal">
<p class="titleintable"><a id="sthref2187"></a><a id="BGBCDJDH"></a>Table 14-5 Mark and Unmark Functions</p>
<table class="cellalignment1016" title="Mark and Unmark Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t20">Function</th>
<th class="cellalignment1012" id="r1c2-t20">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t20" headers="r1c1-t20">
<p><code><a href="oci18nav002.htm#i470117">OCIObjectMarkDeleteByRef()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t20 r1c2-t20">
<p>Mark an object deleted when given a <code>REF</code></p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t20" headers="r1c1-t20">
<p><code><a href="oci18nav002.htm#i470154">OCIObjectMarkUpdate()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t20 r1c2-t20">
<p>Mark an object as updated (dirty)</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t20" headers="r1c1-t20">
<p><code><a href="oci18nav002.htm#i470079">OCIObjectMarkDelete()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t20 r1c2-t20">
<p>Mark an object deleted or delete a value instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t20" headers="r1c1-t20">
<p><code><a href="oci18nav002.htm#i437386">OCICacheUnmark()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t20 r1c2-t20">
<p>Unmark all objects in the cache</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t20" headers="r1c1-t20">
<p><code><a href="oci18nav002.htm#i470209">OCIObjectUnmark()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t20 r1c2-t20">
<p>Mark a given object as updated</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t20" headers="r1c1-t20">
<p><code><a href="oci18nav002.htm#i470242">OCIObjectUnmarkByRef()</a></code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t20 r1c2-t20">
<p>Mark an object as updated, when given a <code>REF</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI17024" class="sect2"><a id="sthref2188"></a>
<h3 class="sect2">Object Meta-Attribute Accessor Functions<a id="sthref2189"></a></h3>
<p>The functions in <a href="#BGBDBGJH">Table 14-6</a> allow an application to access the meta-attributes of an object.</p>
<div id="LNOCI17025" class="tblformal">
<p class="titleintable"><a id="sthref2190"></a><a id="BGBDBGJH"></a>Table 14-6 Object Meta-Attributes Functions</p>
<table class="cellalignment1016" title="Object Meta-Attributes Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t21">Function</th>
<th class="cellalignment1012" id="r1c2-t21">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t21" headers="r1c1-t21">
<p><code><a href="oci18nav003.htm#i469319">OCIObjectExists()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t21 r1c2-t21">
<p>Get existence status of an instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t21" headers="r1c1-t21">
<p><code>OCIObjectFlushStatus()</code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t21 r1c2-t21">
<p>Get the flush status of an instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t21" headers="r1c1-t21">
<p><code><a href="oci18nav004.htm#i469963">OCIObjectGetInd()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t21 r1c2-t21">
<p>Get null structure of an instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t21" headers="r1c1-t21">
<p><code><a href="oci18nav003.htm#i473099">OCIObjectIsDirty()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t21 r1c2-t21">
<p>Has an object been marked as updated?</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t21" headers="r1c1-t21">
<p><code><a href="oci18nav003.htm#i469520">OCIObjectIsLocked()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t21 r1c2-t21">
<p>Is an object locked?</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="LNOCI17026" class="sect2"><a id="sthref2191"></a>
<h3 class="sect2">Other Functions<a id="sthref2192"></a></h3>
<p>The functions in <a href="#BGBDHJHB">Table 14-7</a> provide additional object functionality for OCI applications.</p>
<div id="LNOCI17027" class="tblformal">
<p class="titleintable"><a id="sthref2193"></a><a id="BGBDHJHB"></a>Table 14-7 Other Object Functions</p>
<table class="cellalignment1016" title="Other Object Functions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t22">Function</th>
<th class="cellalignment1012" id="r1c2-t22">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t22" headers="r1c1-t22">
<p><code><a href="oci18nav004.htm#i469562">OCIObjectCopy()</a></code></p>
</td>
<td class="cellalignment1013" headers="r2c1-t22 r1c2-t22">
<p>Copy one instance to another</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t22" headers="r1c1-t22">
<p><code><a href="oci18nav004.htm#i469995">OCIObjectGetObjectRef()</a></code></p>
</td>
<td class="cellalignment1013" headers="r3c1-t22 r1c2-t22">
<p>Return a reference to a given object</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t22" headers="r1c1-t22">
<p><code><a href="oci18nav004.htm#i470280">OCIObjectGetTypeRef()</a></code></p>
</td>
<td class="cellalignment1013" headers="r4c1-t22 r1c2-t22">
<p>Get a reference to a TDO of an instance</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t22" headers="r1c1-t22">
<p><code><a href="oci18nav004.htm#i469657">OCIObjectLock()</a></code></p>
</td>
<td class="cellalignment1013" headers="r5c1-t22 r1c2-t22">
<p>Lock a persistent object</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t22" headers="r1c1-t22">
<p><code><a href="oci18nav004.htm#i469704">OCIObjectLockNoWait()</a></code></p>
</td>
<td class="cellalignment1013" headers="r6c1-t22 r1c2-t22">
<p>Lock an object in NOWAIT mode</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t22" headers="r1c1-t22">
<p><code><a href="oci18nav004.htm#i470965">OCIObjectNew()</a></code></p>
</td>
<td class="cellalignment1013" headers="r7c1-t22 r1c2-t22">
<p>Create a new instance</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i445166"></a>
<div id="LNOCI17028" class="sect1">
<h2 class="sect1"><a id="sthref2194"></a>Type Evolution and the Object Cache</h2>
<p>When type information is requested based on the type name, OCI returns the type descriptor object (TDO) corresponding to the latest version of the type. Because there is no synchronization between the server and the object cache, the <a id="sthref2195"></a>TDO in the object cache may not be current.</p>
<p>It is possible that the version of the image might differ from the TDO version during the pinning of an object. Then, an error is issued. It is up to you to stop the application or refresh the TDO and repin the object. Continuing with the application may cause the application to fail because even if the image and the TDO are at the same version, there is no guarantee that the object structure (that is, C struct) defined in the application is compatible with the new type version, especially when an attribute has been dropped from the type in the server.</p>
<p>Thus, when the structure of a type is altered, you must regenerate the header files of the changed type, modify their application, recompile, and relink before executing the program again.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci11obj.htm#i450362">"Type Evolution"</a></div>
</div>
<!-- class="sect1" -->
<a id="i450162"></a>
<div id="LNOCI1390" class="sect1">
<h2 class="sect1"><a id="sthref2196"></a>OCI Support for XML</h2>
<p>Oracle XML DB<a id="sthref2197"></a> provides support for storing and manipulating XML instances by using the <code>XMLType</code> data type. You can access these XML instances with OCI, in conjunction with the C DOM API for XML.</p>
<p>An application program must initialize the usual OCI handles, such as the server handle or the statement handle, and it must then initialize the XML context. The program can either operate on XML instances in the back end or create new instances on the client side. The initialized XML context can be used with all the C DOM functions.</p>
<p>XML data stored in Oracle XML DB can be accessed on the client side with the C DOM structure <code>xmldocnode</code>. You can use this structure for binding, defining, and operating on XML values in OCI statements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci23xml.htm#i522847">Chapter 23</a> for information about the XML support in C</p>
</li>
<li>
<p><a class="olink ADXDB1400" href="../../appdev.112/e23094/xdb12oci.htm#ADXDB1400"><span class="italic">Oracle XML DB Developer's Guide</span></a> for more information about using the C API for XML, including a binary XML example</p>
</li>
<li>
<p><a class="olink ADXDK1400" href="../../appdev.112/e23582/adx_c_parser.htm#ADXDK1400"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a> for more information about the XML parser for C</p>
</li>
<li>
<p><a class="olink CAXML00300" href="../../appdev.112/e10770/dom.htm#CAXML00300"><span class="italic">Oracle XML Reference</span></a> for information about the DOM C APIs for XML</p>
</li>
</ul>
</div>
<div id="LNOCI17029" class="sect2"><a id="sthref2198"></a>
<h3 class="sect2">XML Context</h3>
<p>An XML context is a required parameter in all the C DOM API functions. This opaque context encapsulates information pertaining to data encoding, error message language, and so on. The contents of this context are different for XDK and for Oracle XML DB applications.</p>
<p>For Oracle XML DB, there are two OCI functions provided to initialize and free an XML context:</p>
<pre>
xmlctx *OCIXmlDbInitXmlCtx (OCIEnv *envhp, OCISvcCtx *svchp, OCIError *errhp,
       ocixmldbparam *params, ub4 num_params);

void OCIXmlDbFreeXmlCtx (xmlctx *xctx);
</pre></div>
<!-- class="sect2" -->
<div id="LNOCI17030" class="sect2"><a id="sthref2199"></a>
<h3 class="sect2">XML Data on the Server</h3>
<p>XML data on the server can be operated on with OCI statement calls. You can bind and define <code>XMLType</code> values using <code>xmldocnode</code>, as with other object instances. OCI statements are used to select XML data from the server. This data can be used in the C DOM functions directly. Similarly, the values can be bound back to SQL statements directly.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJEAJI"></a>
<div id="LNOCI17031" class="sect2">
<h3 class="sect2">Using OCI <a id="sthref2200"></a>XML DB Functions</h3>
<p>To initialize and terminate the XML context, use the functions <code><a id="sthref2201"></a></code><a href="oci23xml001.htm#i530458">OCIXmlDbInitXmlCtx()</a> and <code><a id="sthref2202"></a></code><a href="oci23xml001.htm#i530442">OCIXmlDbFreeXmlCtx()</a> respectively. The header file <a id="sthref2203"></a><code>ocixmldb.h</code> is used with the unified C API.</p>
<p><a href="#BGBDIEFE">Example 14-3</a> is a code fragment of a tested example that shows how to perform operations with the C API.</p>
<div id="LNOCI18310" class="example">
<p class="titleinexample"><a id="BGBDIEFE"></a>Example 14-3 Initializing and Terminating XML Context with a C API</p>
<pre>
#ifndef S_ORACLE
#include &lt;s.h&gt;
#endif
#ifndef ORATYPES_ORACLE
#include &lt;oratypes.h&gt;
#endif
#ifndef XML_ORACLE
#include &lt;xml.h&gt;
#endif
#ifndef OCIXML_ORACLE
#include &lt;ocixmldb.h&gt;
#endif
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
#include &lt;string.h&gt;

typedef struct test_ctx {
        OCIEnv *envhp;
        OCIError *errhp;
        OCISvcCtx *svchp;
        OCIStmt *stmthp;
        OCIServer *srvhp;
        OCIDuration dur;
        OCISession *sesshp;
        oratext *username;
        oratext *password;
} test_ctx;

...
void main()
{
  test_ctx temp_ctx;
  test_ctx *ctx = &amp;temp_ctx;
  OCIType *xmltdo = (OCIType *) 0;
  xmldocnode *doc = (xmldocnode *)0;
  ocixmldbparam params[1];
  xmlnode *quux, *foo, *foo_data, *top;
  xmlerr err;
  sword status = 0;
  xmlctx *xctx;
 ...
  /* Initialize envhp, svchp, errhp, dur, stmthp */
  ...
 
  /* Get an xml context */
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;ctx-&gt;dur;
  xctx = OCIXmlDbInitXmlCtx(ctx-&gt;envhp, ctx-&gt;svchp, ctx-&gt;errhp, params, 1);

/* Do unified C API operations next */
...

/* Free the statement handle using OCIHandleFree() */
...
/* Free the allocations associated with the context */
OCIXmlDbFreeXmlCtx(xctx);
/* Free envhp, svchp, errhp, stmthp */
...
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="LNOCI17032" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref2204"></a>
<h3 class="sect2">OCI Client Access to Binary XML</h3>
<p>The middle tier and client tiers can produce, consume, and process XML in binary XML format. The C application fetches data from the XML DB repository, performs updates on the XML using DOM, and stores it back in the database. Or an XML document is created or input on the client and XSLT, XQuery, and other utilities can be used on it. Then the output XML is saved in XML DB.</p>
<p>A client application requires a connection (called a metadata connection) to the metadata repository (typically a back-end database) to fetch token definitions, XML schemas, and DTDs while encoding or decoding a binary XML document.</p>
<p>A repository context is initialized using either a dedicated connection or a connection pool. The connection obtained from the repository context is used to fetch metadata such as token definitions and XML schemas. In contrast, the application also has data connections that are used for the regular transfer of data (including XML data) to and from the database. A repository context is explicitly associated with (one or more) data connections. When XML data is read or written from or to the database using the data connection, the appropriate repository context is accessed during the underlying encode or decode operations. As required, the metadata connection is used to fetch the metadata from the repository.</p>
<div id="LNOCI17033" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2205"></a>
<h4 class="sect3">Accessing XML Data from an OCI Application</h4>
<p>Your C application can use OCI to access persistent XML in the database and the Unified XML C API to operate on the fetched XML data.</p>
<p>The following steps are taken by a client application:</p>
<ol>
<li>
<p>Create the usual OCI handles such as <code>OCIEnv</code>, <code>OCISvcCtx</code>, and <code>OCIError</code>.</p>
</li>
<li>
<p>Create one or more repository contexts to fetch the binary XML metadata.</p>
</li>
<li>
<p>Associate the repository context with the data connection.</p>
</li>
<li>
<p>Bind or define (<code>xmldocnode</code>) variables into the select, insert, and update statements.</p>
</li>
<li>
<p>Execute the select, insert, or update statement to fetch or store the XML document. At this point, the client OCI libraries interact with the database back end to fetch the needed XML Schemas, DTDs, token definitions, and so on.</p>
</li>
<li>
<p>Use the Unified C API to operate on the XML data (DOM).</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="LNOCI17034" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2206"></a>
<h4 class="sect3">Repository Context</h4>
<p><code><a id="sthref2207"></a>OCIBinXmlReposCtx</code> is the repository context data structure. The client application creates this context by providing the connection information to the metadata repository. An application can create multiple repository contexts to connect to multiple token repositories. A repository context is explicitly associated with a data connection (<code>OCISvcCtx</code>). When the system must fetch metadata to encode or decode data to or from a data connection, it accesses the appropriate metadata.</p>
<p>It is recommended that applications create one repository context per <code>OCIEnv</code>. This allows better concurrency for multithreaded applications.</p>
<p>The repository context can be created out of a dedicated OCI connection or an OCI connection pool.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17035" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2208"></a>
<h4 class="sect3">Create Repository Context from a Dedicated OCI Connection</h4>
<p><code><a id="sthref2209"></a></code><a href="oci23xml001.htm#CHDBFBBH">OCIBinXmlCreateReposCtxFromConn()</a> creates a repository context using the specified dedicated OCI connection. The OCI connection is only to be used for metadata access and should not be used in any other scenarios by the application. Also note that the access to this connection is serialized; that is, if multiple threads try to use the same connection, access is limited to one thread at a time. For scalability reasons, it is recommended that applications create a repository context using a connection pool, as described in the next section.</p>
<p>Note: You can also potentially pass in the same connection as the one being used for data. However, this might result in an error in certain cases where the client system attempts to contact the metadata repository while part of another operation (such as select or insert).</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17036" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2210"></a>
<h4 class="sect3">Create Repository Context from a Connection Pool</h4>
<p><code><a id="sthref2211"></a></code><a href="oci23xml001.htm#CHDBJBEG">OCIBinXmlCreateReposCtxFromCPool()</a> creates a repository context from a connection pool. When the application accesses the back-end repository, any available connection from the pool is used. Further, this connection is released back to the pool as soon as the metadata operation is complete. Connection pools are highly recommended for multithreaded application scenarios. Different threads can use different connections in the pool and release them as soon as they are done. This approach allows for higher scalability and concurrency with a smaller number of physical connections.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17037" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2212"></a>
<h4 class="sect3">Associating Repository Context with a Data Connection</h4>
<p><code><a id="sthref2213"></a></code><a href="oci23xml001.htm#CHDBCIFG">OCIBinXmlSetReposCtxForConn()</a> associates a repository context with a data connection described by <code>OCISvcCtx</code> <code>*</code>. Multiple data connections can share the same repository context, but access to the repository can be serialized (if it is based on a dedicated connection). When the system must fetch the metadata for encode or decode operations, it looks up the appropriate repository connection from the <code>OCIEnv</code>, <code>OCISvcCtx</code> pair and uses it to fetch the metadata required.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17038" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2214"></a>
<h4 class="sect3">Setting XMLType Encoding Format Preference</h4>
<p>By default, XML data sent to the database is encoded in one of these possible formats (text, object-relational, or binary XML) based on certain internal criteria such as the source format (if it was read from the DB). <a id="sthref2215"></a><a href="oci23xml001.htm#CHDBACCB">OCIBinXmlSetFormatPref()</a> provides an explicit mechanism to set the preference for encoding format. In the future, the default format can be binary XML, but this function could be used to override it if needed.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17039" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2216"></a>
<h4 class="sect3">Example of Using a Connection Pool</h4>
<p>Creating a repository context from a connection pool and associating the repository context with a data connection is shown in this example in the XML DB documentation. The database is local and the test is in single-threaded mode.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB1400" href="../../appdev.112/e23094/xdb12oci.htm#ADXDB1400"><span class="italic">Oracle XML DB Developer's Guide</span></a> for more information about using OCI and the C API for XML with Oracle XML DB</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci13obn.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci15ott.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
