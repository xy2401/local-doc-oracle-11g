<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using the Object Type Translator with OCI</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:24Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci14oca.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci16rel.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">22/79</span> <!-- End Header -->
<div id="LNOCI140" class="chapter"><a id="g455369"></a> <a id="i438677"></a>
<h1 class="chapter"><span class="secnum">15</span> Using the Object Type Translator with OCI</h1>
<p>This chapter discusses the Object Type Translator (OTT)<a id="sthref2217"></a>, which is used to map database object types and named collection types to C structs for use in OCI applications.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i420185">OTT Overview</a></p>
</li>
<li>
<p><a href="#i426555">What Is the Object Type Translator?</a></p>
</li>
<li>
<p><a href="#i427005">OTT Command Line</a></p>
</li>
<li>
<p><a href="#i432196">Intype File</a></p>
</li>
<li>
<p><a href="#i426569">OTT Data Type Mappings</a></p>
</li>
<li>
<p><a href="#i432200">Outtype File</a></p>
</li>
<li>
<p><a href="#i427628">Using OTT with OCI Applications</a></p>
</li>
<li>
<p><a href="#i439554">OTT Reference</a></p>
</li>
</ul>
<a id="i420185"></a>
<div id="LNOCI17040" class="sect1">
<h2 class="sect1">OTT Overview<a id="sthref2218"></a></h2>
<p>The Object Type Translator (OTT) assists in the development of C language applications that make use of user-defined types in an Oracle database.</p>
<p>With SQL <code>CREATE TYPE</code> statements, you can create object types. The definitions of these types are stored in the database, and can be used in the creation of database tables. Once these tables are populated, an OCI programmer can access objects stored in the tables.</p>
<p>An application that accesses object data must be able to represent the data in a host language format. This is accomplished by representing object types as C structs. Although it is possible for a programmer to code struct declarations by hand to represent database object types, this can be very time-consuming and error-prone if many types are involved. OTT obviates the need for such manual coding by automatically generating appropriate struct declarations. In OCI, the application also must call an initialization function generated by OTT.</p>
<p>In addition to creating structs that represent stored data types, OTT generates parallel indicator structs that indicate whether an object type or its fields are <code>NULL</code>.</p>
</div>
<!-- class="sect1" -->
<a id="i426555"></a>
<div id="LNOCI17041" class="sect1">
<h2 class="sect1">What Is the Object Type Translator?<a id="sthref2219"></a></h2>
<p>The Object Type Translator (OTT) converts database definitions of object types and named collection types into C struct declarations that can be included in an OCI application.</p>
<p>You must explicitly invoke OTT to translate database types to C representations.</p>
<p>On most operating systems, OTT is invoked on the command line. It takes as input an <span class="italic">intype file</span>, and it generates an <span class="italic">outtype file</span> and one or more C <span class="italic">header files</span> and an optional <span class="italic">implementation file</span>. The following is an example of a command that invokes OTT:</p>
<pre>
ott userid=scott intype=demoin.typ outtype=demoout.typ code=c hfile=demo.h\
    initfile=demov.c
</pre>
<p>This command causes OTT to connect to the database with user name <code>scott</code>. The user is prompted for the password.</p>
<p>The implementation file (<code>demov.c</code>) contains the function to initialize the type version table with information about the user-defined types translated.</p>
<p>Later sections of this chapter describe each of these parameters in more detail.</p>
<p>Sample <code>demoin.typ</code> file:</p>
<pre>
CASE=LOWER
TYPE emptype
</pre>
<p>Sample <code>demoout.typ</code> file:</p>
<pre>
CASE = LOWER
TYPE SCOTT.EMPTYPE AS emptype
  VERSION = "$8.0"
  HFILE = demo.h
</pre>
<p>In this example, the <code>demoin.typ</code> file contains the type to be translated, preceded by <code>TYPE</code> (for example, <code>TYPE emptype</code>). The structure of the outtype file is similar to the intype file, with the addition of information obtained by OTT.</p>
<p>Once OTT has completed the translation, the header file contains a C struct representation of each type specified in the intype file, and a <code>NULL</code> indicator struct corresponding to each type. Suppose for example, that the employee type listed in the intype file was defined as shown in <a href="#CIHHEFAF">Example 15-1</a>.</p>
<div id="LNOCI18311" class="example">
<p class="titleinexample"><a id="CIHHEFAF"></a>Example 15-1 Definition of the Employee Object Type Listed in the Intype File</p>
<pre>
CREATE TYPE emptype AS OBJECT
(
    name       VARCHAR2(30),
    empno      NUMBER,
    deptno     NUMBER,
    hiredate   DATE,
    salary     NUMBER
);
</pre></div>
<!-- class="example" -->
<p>Then the header file generated by OTT (<code>demo.h</code>) includes, among other items, the declarations shown in <a href="#CIHDJDHC">Example 15-2</a>.</p>
<div id="LNOCI18312" class="example">
<p class="titleinexample"><a id="CIHDJDHC"></a>Example 15-2 Contents of the Generated Header File demo.h</p>
<pre>
struct emptype
{
    OCIString * name;
    OCINumber empno;
    OCINumber deptno;
    OCIDate   hiredate;
    OCINumber salary;
};
typedef struct emptype emptype;

struct emptype_ind
{
    OCIInd _atomic;
    OCIInd name;
    OCIInd empno;
    OCIInd deptno;
    OCIInd hiredate;
    OCIInd salary;
};
typedef struct employee_ind employee_ind;
</pre></div>
<!-- class="example" -->
<p><a href="#CIHFDHDC">Example 15-3</a> shows what a sample implementation file (<code>demov.c</code>) produced by this command contains.</p>
<div id="LNOCI18313" class="example">
<p class="titleinexample"><a id="CIHFDHDC"></a>Example 15-3 Contents of the demov.c File</p>
<pre>
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

sword demov(OCIEnv *env, OCIError *err)
{
   sword status = OCITypeVTInit(env, err);
   if (status == OCI_SUCCESS)
       status = OCITypeVTInsert(env, err, 
           "HR", 2,
           "EMPTYPE", 7,
           "$8.0", 4);
   return status;
}
</pre></div>
<!-- class="example" -->
<p>Parameters in the intype file control the way generated structs are named. In this example, the struct name <code>emptype</code> matches the database type name <code>emptype</code>. The struct name is in lowercase because of the line <code>CASE=lower</code> in the intype file.</p>
<p>The data types that appear in the struct declarations (for example, <code>OCIString</code>, <code>OCIInd</code>) are special data types.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i426569">"OTT Data Type Mappings"</a> for more information about these types</div>
<p>The remaining sections of this chapter discuss the use of OTT with OCI, followed by a reference section that describes command-line syntax, parameters, intype file structure, nested <code>#include</code> file generation, schema names usage, default name mapping, and restrictions.</p>
<a id="i426997"></a>
<div id="LNOCI17042" class="sect2">
<h3 class="sect2">Creating Types in the Database<a id="sthref2220"></a></h3>
<p>The first step in using OTT is to create object types or named collection types and store them in the database. This is accomplished through the use of the SQL <code>CREATE TYPE</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Oracle Database SQL Language Reference for information about the <code>CREATE</code> <code>TYPE</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="i434134"></a>
<div id="LNOCI17043" class="sect2">
<h3 class="sect2">Invoking OTT</h3>
<p>The next step is to invoke OTT. OTT parameters can be specified on the command line, or in a file called a configuration file. Certain parameters can also be specified in the intype file.</p>
<p>If a parameter is specified in more than one place, its value on the command line takes precedence over its value in the intype file, which takes precedence over its value in a user-defined configuration file, which takes precedence over its value in the default configuration file.</p>
<p>For global options &mdash; that is, options on the command line or options at the beginning of the intype file before any <code>TYPE</code> statements &mdash; the value on the command line overrides the value in the intype file. (The options that can be specified globally in the intype file are <code>CASE,</code> <code>CODE,</code> <code>INITFILE</code>, and <code>INITFUNC</code>, but not <code>HFILE</code>.) However, anything in the intype file in a <code>TYPE</code> specification applies to a particular type only, and overrides anything on the command line that would otherwise apply to the type. So if you enter <code>TYPE person HFILE=p.h</code>, it applies to <code>person</code> only and overrides the <code>HFILE</code> on the command line. The statement is not considered a command-line parameter.</p>
<div id="LNOCI17044" class="sect3"><a id="sthref2221"></a>
<h4 class="sect3">Command Line</h4>
<p>Parameters (also called options) set on the command line override any set elsewhere.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i427005">"OTT Command Line"</a></div>
</div>
<!-- class="sect3" -->
<div id="LNOCI17045" class="sect3"><a id="sthref2222"></a>
<h4 class="sect3">Configuration File</h4>
<p>A configuration file is a text file that contains OTT parameters. Each nonblank line in the file contains one parameter, with its associated value or values. If more than one parameter is put on a line, only the first one is used. Whitespace is not allowed on any nonblank line of a configuration file.</p>
<p>A configuration file can be named on the command line. In addition, a default configuration file is always read. This default configuration file must always exist, but can be empty. The name of the default configuration file is <code>ottcfg.cfg</code>, and the location of the file is system-specific. For example, on Solaris, the file specification is <code>$ORACLE_HOME/precomp/admin/ottcfg.cfg</code>. See your operating system-specific documentation for further information.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17046" class="sect3"><a id="sthref2223"></a>
<h4 class="sect3">INTYPE File</h4>
<p>The intype file gives a list of user-defined types for OTT to translate.</p>
<p>The parameters <code>CASE, HFILE, INITFUNC</code>, and <code>INITFILE</code> can appear in the intype file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i432196">"Intype File"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i427005"></a>
<div id="LNOCI17047" class="sect1">
<h2 class="sect1">OTT Command Line<a id="sthref2224"></a></h2>
<p>On most operating systems, OTT is invoked on the command line. You can specify the input and output files, and the database connection information, among other things. Consult your operating system-specific documentation to see how to invoke OTT.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociadwin.htm#i634811">"Using the Object Type Translator for Windows"</a></div>
<a id="i435156"></a>
<div id="LNOCI17048" class="sect2">
<h3 class="sect2">OTT Command-Line Invocation Example</h3>
<p><a href="#CIHBDJIB">Example 15-4</a> shows how to invoke OTT from the command line.</p>
<div id="LNOCI18314" class="example">
<p class="titleinexample"><a id="CIHBDJIB"></a>Example 15-4 Invoking OTT from the Command Line</p>
<pre>
ott userid=bren intype=demoin.typ outtype=demoout.typ code=c \
    hfile=demo.h initfile=demov.c
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
No spaces are permitted around the equal sign (=).</div>
<p>The following sections describe the elements of the command line used in this example.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i439554">"OTT Reference"</a> for a detailed discussion of the various OTT command-line options</div>
<div id="LNOCI17049" class="sect3"><a id="sthref2225"></a>
<h4 class="sect3">OTT</h4>
<p>Causes OTT to be invoked. It must be the first item on the command line.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17050" class="sect3"><a id="sthref2226"></a>
<h4 class="sect3">USERID</h4>
<p>Specifies the database connection information that OTT uses.</p>
<p>In <a href="#CIHBDJIB">Example 15-4</a>, OTT attempts to connect with user name <code>bren</code> and is then prompted for the password.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17051" class="sect3"><a id="sthref2227"></a>
<h4 class="sect3">INTYPE</h4>
<p>Specifies the name of the intype file that is used.</p>
<p>In <a href="#CIHBDJIB">Example 15-4</a>, the name of the intype file is specified as <code>demoin.typ</code>.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17052" class="sect3"><a id="sthref2228"></a>
<h4 class="sect3">OUTTYPE</h4>
<p>Specifies the name of the outtype file. When OTT generates the C header file, it also writes information about the translated types into the outtype file. This file contains an entry for each of the types that is translated, including its version string, and the header file to which its C representation was written.</p>
<p>In <a href="#CIHBDJIB">Example 15-4</a>, the name of the outtype file is specified as <code>demoout.typ</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the file specified by the outtype keyword exists, it is overwritten when OTT runs. If the name of the outtype file is the same as the name of the intype file, the outtype information overwrites the intype file.</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI17053" class="sect3"><a id="sthref2229"></a>
<h4 class="sect3">CODE</h4>
<p>Specifies the target language for the translation. The following options are available:</p>
<ul>
<li>
<p>C (equivalent to ANSI_C)</p>
</li>
<li>
<p>ANSI_C (for ANSI C)</p>
</li>
<li>
<p>KR_C (for Kernighan &amp; Ritchie C)</p>
</li>
</ul>
<p>There is currently no default option, so this parameter is required.</p>
<p>Struct declarations are identical in both C dialects. The style in the initialization function defined in the <code>INITFILE</code> file depends on whether <code>KR_C</code> is used. If the <code>INITFILE</code> option is not used, all three options are equivalent.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17054" class="sect3"><a id="sthref2230"></a>
<h4 class="sect3">HFILE</h4>
<p>Specifies the name of the C header file to which the generated structs should be written.</p>
<p>In <a href="#CIHBDJIB">Example 15-4</a>, the generated structs are stored in a file called <code>demo.h</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the file specified by the <code>hfile</code> keyword exists, it is overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT does not actually write to the file. This preserves the modification time of the file so that Linux and UNIX <code>make</code> and similar facilities on other operating systems do not perform unnecessary recompilations.</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI17055" class="sect3"><a id="sthref2231"></a>
<h4 class="sect3">INITFILE</h4>
<p>Specifies the name of the C source file into which the type initialization function is to be written.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the file specified by the <code>initfile</code> keyword exists, it is overwritten when OTT runs, with one exception: if the contents of the file as generated by OTT are identical to the previous contents of the file, OTT does not actually write to the file. This preserves the modification time of the file so that Linux and UNIX <code>make</code> and similar facilities on other operating systems do not perform unnecessary recompilations.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i432196"></a>
<div id="LNOCI17056" class="sect1">
<h2 class="sect1">Intype File<a id="sthref2232"></a><a id="sthref2233"></a></h2>
<p>When OTT runs, the intype file tells OTT which database types should be translated. It can also control the naming of the generated structs. The intype file can be a user-created file, or it can be the outtype file of a previous invocation of OTT. If the <code>intype</code> parameter is not used, all types in the schema to which OTT connects are translated.</p>
<p><a href="#CIHJFADB">Example 15-5</a> shows a simple user-created intype file.</p>
<div id="LNOCI18315" class="example">
<p class="titleinexample"><a id="CIHJFADB"></a>Example 15-5 Contents of a User-Created Intype File</p>
<pre>
CASE=LOWER
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE "Person"
TYPE PURCHASE_ORDER AS p_o
</pre></div>
<!-- class="example" -->
<p><a href="#CIHJFADB">Example 15-5</a> is further described as follows.</p>
<p>The first line, with the <code>CASE</code> keyword, indicates that generated C identifiers should be in lowercase. However, this <code>CASE</code> option is only applied to those identifiers that are not explicitly mentioned in the intype file. Thus, <code>employee</code> and <code>ADDRESS</code> would always result in C structures <code>employee</code> and <code>ADDRESS</code>, respectively. The members of these structures would be named in lowercase.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i428925">"CASE"</a></div>
<p>In the lines that begin with the <code>TYPE</code> keyword specify which types in the database should be translated: in this case, the <code>employee, ADDRESS, item, Person</code>, and <code>PURCHASE_ORDER</code> types.</p>
<p>The <code>TRANSLATE ... AS</code> keywords specify that the name of an object attribute should be changed when the type is translated into a C struct. In this case, the <code>SALARY$</code> attribute of the employee type is translated to <code>salary</code>.</p>
<p>The <code>AS</code> keyword in the final line specifies that the name of an object type should be changed when it is translated into a struct. In this case, the <code>PURCHASE_ORDER</code> database type is translated into a struct called <code>p_o</code>.</p>
<p>If <code>AS</code> is not used to translate a type or attribute name, the database name of the type or attribute is used as the C identifier name, except that the <code>CASE</code> option is observed, and any character that cannot be mapped to a legal C identifier character is replaced by an underscore. Reasons for translating a type or attribute name include the following:</p>
<ul>
<li>
<p>The name contains characters other than letters, digits, and underscores</p>
</li>
<li>
<p>The name conflicts with a C keyword.</p>
</li>
<li>
<p>The type name conflicts with another identifier in the same scope. This can happen, for example, if the program uses two types with the same name from different schemas.</p>
</li>
<li>
<p>The programmer prefers a different name.</p>
</li>
</ul>
<p>OTT may need to translate additional types that are not listed in the intype file. This is because OTT analyzes the types in the intype file for type dependencies before performing the translation, and translates other types as necessary. For example, if the <code>ADDRESS</code> type were not listed in the intype file, but the <code>"Person"</code> type had an attribute of type <code>ADDRESS</code>, OTT would still translate <code>ADDRESS</code> because it is required to define the <code>"Person"</code> type.</p>
<p>If you specify <code>FALSE</code> as the value of the <a id="sthref2234"></a><code>TRANSITIVE</code> parameter, then OTT does not generate types that are not specified in the intype file.</p>
<p>A normal case-insensitive SQL identifier can be spelled in any combination of uppercase and lowercase in the intype file, and is not enclosed within quotation marks.</p>
<p>Use quotation marks, such as <code>TYPE</code> <code>"Person"</code>, to reference SQL identifiers that have been created in a case-sensitive manner (for example, <code>CREATE TYPE "Person"</code>). A SQL identifier is case-sensitive if it was enclosed within quotation marks when it was declared. Quotation marks can also be used to refer to a SQL identifier that is an OTT-reserved word (for example, <code>TYPE "CASE"</code>). Therefore, when a name is enclosed within quotation marks, the name enclosed within quotation marks must be in uppercase if the SQL identifier was created in a case-insensitive manner (for example, <code>CREATE TYPE Case</code>). If an OTT-reserved word is used to refer to the name of a SQL identifier but is not enclosed within quotation marks, OTT reports a syntax error in the intype file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i420386">"Structure of the Intype File"</a> for a more detailed specification of the structure of the intype file and the available options</div>
</div>
<!-- class="sect1" -->
<a id="i426569"></a>
<div id="LNOCI17057" class="sect1">
<h2 class="sect1">OTT Data Type Mappings<a id="sthref2235"></a><a id="sthref2236"></a></h2>
<p>When OTT generates a C struct from a database type, the struct contains one element corresponding to each attribute of the object type. The data types of the attributes are mapped to types that are used in Oracle's object data types. The data types found in Oracle Database include a set of predefined, primitive types. These data types provide for the creation of user-defined types, such as object types and collections.</p>
<p>Oracle Database also includes a set of predefined types that are used to represent object type attributes in C structs. As an example, consider the object type definition in <a href="#CIHIIIJA">Example 15-6</a>, and its corresponding OTT-generated struct declarations in <a href="#CIHCCJFD">Example 15-7</a>.</p>
<div id="LNOCI18316" class="example">
<p class="titleinexample"><a id="CIHIIIJA"></a>Example 15-6 Object Type Definition for Employee</p>
<pre>
CREATE TYPE employee AS OBJECT
(   name       VARCHAR2(30),
    empno      NUMBER,
    deptno     NUMBER,
    hiredate   DATE,
    salary$    NUMBER);
</pre></div>
<!-- class="example" -->
<p>The OTT output, assuming <code>CASE=LOWER</code> and no explicit mappings of type or attribute names, is shown in <a href="#CIHCCJFD">Example 15-7</a>.</p>
<div id="LNOCI18317" class="example">
<p class="titleinexample"><a id="CIHCCJFD"></a>Example 15-7 OTT-Generated Struct Declarations</p>
<pre>
struct employee
{   OCIString * name;
    OCINumber empno;
    OCINumber deptno;
    OCIDate   hiredate;
    OCINumber salary_;
};
typedef struct emp_type emp_type;
struct employee_ind
{
    OCIInd _atomic;
    OCIInd name;
    OCIInd empno;
    OCIInd deptno;
    OCIInd hiredate;
    OCIInd salary_;
}
typedef struct employee_ind employee_ind;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i427012">"Null Indicator Structs"</a> for an explanation of the indicator struct (<code>struct employee_ind</code>)</div>
<p>The data types in the struct declarations&mdash;<code>OCIString</code>, <code>OCINumber</code>, <code>OCIDate</code>, and <code>OCIInd</code>&mdash;are used here to map the data types of the object type attributes. The <code>NUMBER</code> data type of the <code>empno</code> attribute maps to the <code>OCINumber</code> data type, for example. These data types can also be used as the types of bind and define variables.</p>
<a id="i426677"></a>
<div id="LNOCI17058" class="sect2">
<h3 class="sect2">Mapping Object Data Types to C</h3>
<p>This section describes the mappings of Oracle object attribute types to C types generated by OTT. The <a href="#i427342">"OTT Type Mapping Example"</a> includes examples of many of these different mappings. <a href="#CIHEBCFC">Table 15-1</a> lists the mappings from types that you can use as attributes to object data types that are generated by OTT.</p>
<div id="LNOCI17059" class="tblformal">
<p class="titleintable"><a id="sthref2237"></a><a id="CIHEBCFC"></a>Table 15-1 Object Data Type Mappings for Object Type Attributes</p>
<table class="cellalignment1016" title="Object Data Type Mappings for Object Type Attributes" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t15">Object Attribute Types</th>
<th class="cellalignment1012" id="r1c2-t15">C Mapping</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t15" headers="r1c1-t15">
<p>BFILE</p>
</td>
<td class="cellalignment1013" headers="r2c1-t15 r1c2-t15">
<p>OCIBFileLocator*</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t15" headers="r1c1-t15">
<p>BLOB</p>
</td>
<td class="cellalignment1013" headers="r3c1-t15 r1c2-t15">
<p>OCILobLocator * or OCIBlobLocator *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t15" headers="r1c1-t15">
<p>CHAR(N), CHARACTER(N), NCHAR(N)</p>
</td>
<td class="cellalignment1013" headers="r4c1-t15 r1c2-t15">
<p>OCIString *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t15" headers="r1c1-t15">
<p>CLOB, NCLOB</p>
</td>
<td class="cellalignment1013" headers="r5c1-t15 r1c2-t15">
<p>OCILobLocator * or OCIClobLocator *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t15" headers="r1c1-t15">
<p>DATE</p>
</td>
<td class="cellalignment1013" headers="r6c1-t15 r1c2-t15">
<p>OCIDate</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t15" headers="r1c1-t15">
<p>ANSI DATE</p>
</td>
<td class="cellalignment1013" headers="r7c1-t15 r1c2-t15">
<p>OCIDateTime *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t15" headers="r1c1-t15">
<p>TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE</p>
</td>
<td class="cellalignment1013" headers="r8c1-t15 r1c2-t15">
<p>OCIDateTime *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t15" headers="r1c1-t15">
<p>INTERVAL YEAR TO MONTH, INTERVAL DAY TO SECOND</p>
</td>
<td class="cellalignment1013" headers="r9c1-t15 r1c2-t15">
<p>OCIInterval *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t15" headers="r1c1-t15">
<p>DEC, DEC(N), DEC(N,N)</p>
</td>
<td class="cellalignment1013" headers="r10c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t15" headers="r1c1-t15">
<p>DECIMAL, DECIMAL(N), DECIMAL(N,N)</p>
</td>
<td class="cellalignment1013" headers="r11c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t15" headers="r1c1-t15">
<p>FLOAT, FLOAT(N), DOUBLE PRECISION</p>
</td>
<td class="cellalignment1013" headers="r12c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r13c1-t15" headers="r1c1-t15">
<p>BINARY_FLOAT</p>
</td>
<td class="cellalignment1013" headers="r13c1-t15 r1c2-t15">
<p>float</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r14c1-t15" headers="r1c1-t15">
<p>BINARY_DOUBLE</p>
</td>
<td class="cellalignment1013" headers="r14c1-t15 r1c2-t15">
<p>double</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r15c1-t15" headers="r1c1-t15">
<p>INT, INTEGER, SMALLINT</p>
</td>
<td class="cellalignment1013" headers="r15c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r16c1-t15" headers="r1c1-t15">
<p>Nested Object Type</p>
</td>
<td class="cellalignment1013" headers="r16c1-t15 r1c2-t15">
<p>C name of the nested object type</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r17c1-t15" headers="r1c1-t15">
<p>Nested Table</p>
</td>
<td class="cellalignment1013" headers="r17c1-t15 r1c2-t15">
<p>OCITable *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r18c1-t15" headers="r1c1-t15">
<p>NUMBER, NUMBER(N), NUMBER(N,N)</p>
</td>
<td class="cellalignment1013" headers="r18c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r19c1-t15" headers="r1c1-t15">
<p>NUMERIC, NUMERIC(N), NUMERIC(N,N)</p>
</td>
<td class="cellalignment1013" headers="r19c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r20c1-t15" headers="r1c1-t15">
<p>RAW(N)</p>
</td>
<td class="cellalignment1013" headers="r20c1-t15 r1c2-t15">
<p>OCIRaw *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r21c1-t15" headers="r1c1-t15">
<p>REAL</p>
</td>
<td class="cellalignment1013" headers="r21c1-t15 r1c2-t15">
<p>OCINumber</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r22c1-t15" headers="r1c1-t15">
<p>REF</p>
</td>
<td class="cellalignment1013" headers="r22c1-t15 r1c2-t15">
<p>OCIRef *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r23c1-t15" headers="r1c1-t15">
<p>VARCHAR(N)</p>
</td>
<td class="cellalignment1013" headers="r23c1-t15 r1c2-t15">
<p>OCIString *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r24c1-t15" headers="r1c1-t15">
<p>VARCHAR2(N), NVARCHAR2(N)</p>
</td>
<td class="cellalignment1013" headers="r24c1-t15 r1c2-t15">
<p>OCIString *</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r25c1-t15" headers="r1c1-t15">
<p><a id="sthref2238"></a>VARRAY</p>
</td>
<td class="cellalignment1013" headers="r25c1-t15 r1c2-t15">
<p>OCIArray *</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For <code>REF</code>, <code>varray</code>, and <code>nested table</code> types, OTT generates a typedef. The type declared in the typedef is then used as the type of the data member in the struct declaration. For an example, see <a href="#i427342">"OTT Type Mapping Example"</a>.</div>
<p>If an object type includes an attribute of a <code>REF</code> or collection type, a typedef for the <code>REF</code> or collection type is first generated. Then the struct declaration corresponding to the object type is generated. The struct includes an element whose type is a pointer to the <code>REF</code> or collection type.</p>
<p>If an object type includes an attribute whose type is another object type, OTT first generates the nested type (if <code>TRANSITIVE=TRUE</code>). It then maps the object type attribute to a nested struct of the type of the nested object type.</p>
<p>The Oracle C data types to which OTT maps non-object database attribute types are structures, which, except for <code>OCIDate</code>, are opaque.</p>
</div>
<!-- class="sect2" -->
<a id="i427342"></a>
<div id="LNOCI17060" class="sect2">
<h3 class="sect2">OTT Type Mapping Example</h3>
<p><a href="#CIHCBFIH">Example 15-9</a> demonstrates the various type mappings created by OTT when given the database types shown in <a href="#CIHJBHGE">Example 15-8</a>.</p>
<div id="LNOCI18318" class="example">
<p class="titleinexample"><a id="CIHJBHGE"></a>Example 15-8 Object Type Definitions for the OTT Type Mapping Example</p>
<pre>
CREATE TYPE my_varray AS VARRAY(5) of integer;

CREATE TYPE object_type AS OBJECT
(object_name    VARCHAR2(20));

CREATE TYPE my_table AS TABLE OF object_type;

CREATE TYPE other_type AS OBJECT (object_number NUMBER);

CREATE TYPE many_types AS OBJECT
( the_varchar    VARCHAR2(30),
  the_char       CHAR(3),
  the_blob       BLOB,
  the_clob       CLOB,
  the_object     object_type,
  another_ref    REF other_type,
  the_ref        REF many_types,
  the_varray     my_varray,
  the_table      my_table,
  the_date       DATE,
  the_num        NUMBER,
  the_raw        RAW(255));
</pre></div>
<!-- class="example" -->
<p>The intype file includes the following:</p>
<pre>
CASE = LOWER
TYPE many_types
</pre>
<p>OTT generates the C structs shown in <a href="#CIHCBFIH">Example 15-9</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Comments are provided in <a href="#CIHCBFIH">Example 15-9</a> to help explain the structs. These comments are not part of actual OTT output.</div>
<div id="LNOCI18319" class="example">
<p class="titleinexample"><a id="CIHCBFIH"></a>Example 15-9 Various Type Mappings Created by OTT from Object Type Definitions</p>
<pre>
#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

typedef OCIRef many_types_ref;
typedef OCIRef object_type_ref;
typedef OCIArray my_varray;            /* used in many_types */
typedef OCITable my_table;             /* used in many_types*/
typedef OCIRef other_type_ref;
struct object_type                     /* used in many_types */
{
   OCIString * object_name;
};
typedef struct object_type object_type;

struct object_type_ind               /*indicator struct for*/
{                                            /*object_types*/
   OCIInd _atomic;
   OCIInd object_name;
};
typedef struct object_type_ind object_type_ind;

struct many_types
{
   OCIString *        the_varchar;
   OCIString *        the_char;
   OCIBlobLocator *   the_blob;
   OCIClobLocator *   the_clob;
   struct object_type the_object;
   other_type_ref *   another_ref;
   many_types_ref *   the_ref;
   my_varray *        the_varray;
   my_table *         the_table; 
   OCIDate            the_date;
   OCINumber          the_num;
   OCIRaw *           the_raw;
};
typedef struct many_types many_types;

struct many_types_ind                  /*indicator struct for*/
{                                               /*many_types*/
   OCIInd _atomic;
   OCIInd the_varchar;
   OCIInd the_char;
   OCIInd the_blob;
   OCIInd the_clob;
   struct object_type_ind the_object;              /*nested*/
   OCIInd another_ref;
   OCIInd the_ref;
   OCIInd the_varray;
   OCIInd the_table;
   OCIInd the_date;
   OCIInd the_num;
   OCIInd the_raw;
};
typedef struct many_types_ind many_types_ind;

#endif
</pre></div>
<!-- class="example" -->
<p>Notice that although only one item was listed for translation in the intype file, two object types and two named collection types were translated. This is because the OTT parameter <a id="sthref2239"></a><a href="#i440618">"TRANSITIVE"</a> has the default value of <code>TRUE</code>. As described in that section, when <code>TRANSITIVE=TRUE</code>, OTT automatically translates any types that are used as attributes of a type being translated, to complete the translation of the listed type.</p>
<p>This is not the case for types that are only accessed by a pointer or <code>REF</code> in an object type attribute. For example, although the <code>many_types</code> type contains the attribute <code>another_ref REF other_type</code>, a declaration of struct <code>other_type</code> was not generated.</p>
<p>This example also illustrates how typedefs are used to declare <code>varray, nested table</code>, and <code>REF</code> types.</p>
<p>The typedefs occur near the beginning:</p>
<pre>
typedef OCIRef many_types_ref;
typedef OCIRef object_type_ref;
typedef OCIArray my_varray;    
typedef OCITable my_table; 
typedef OCIRef other_type_ref;
</pre>
<p>In the struct <code>many_types</code>, the <code>varray, nested table</code>, and <code>REF</code> attributes are declared:</p>
<pre>
struct many_types
{  ...
   other_type_ref *   another_ref;
   many_types_ref *   the_ref;
   my_varray *        the_varray;
   my_table *         the_table;
   ...
}
</pre></div>
<!-- class="sect2" -->
<a id="i427012"></a>
<div id="LNOCI17061" class="sect2">
<h3 class="sect2">Null Indicator Structs</h3>
<p>Each time OTT generates a C struct to represent a database object type, it also generates a corresponding <code>NULL</code> indicator struct. When an object type is selected into a C struct, <code>NULL</code> indicator information may be selected into a parallel struct.</p>
<p>For example, the following <code>NULL</code> indicator struct was generated in <a href="#CIHCBFIH">Example 15-9</a>.</p>
<pre>
struct many_types_ind
{
OCIInd _atomic;
OCIInd the_varchar;
OCIInd the_char;
OCIInd the_blob;
OCIInd the_clob;
struct object_type_ind the_object;
OCIInd another_ref;
OCIInd the_ref;
OCIInd the_varray;
OCIInd the_table;
OCIInd the_date;
OCIInd the_num;
OCIInd the_raw;
};
typedef struct many_types_ind many_types_ind;
</pre>
<p>The layout of the <code>NULL</code> struct is important. The first element in the struct (<code>_atomic</code>) is the <span class="italic">atomic null indicator</span>. This value indicates the <code>NULL</code> status for the object type as a whole. The atomic null indicator is followed by an indicator element corresponding to each element in the OTT-generated struct representing the object type.</p>
<p>Notice that when an object type contains another object type as part of its definition (in the preceding example it is the <code>object_type</code> attribute), the indicator entry for that attribute is the <code>NULL</code> indicator struct (<code>object_type_ind</code>) corresponding to the nested object type (if <code>TRANSITIVE=TRUE</code>).</p>
<p>The <code>varrays</code> and <code>nested tables</code> contain the <code>NULL</code> information for their elements.</p>
<p>The data type for all other elements of a <code>NULL</code> indicator struct is <code>OCIInd</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci11obj.htm#i440892">"NULL Indicator Structure"</a> for more information about atomic nullity</div>
</div>
<!-- class="sect2" -->
<a id="i440520"></a>
<div id="LNOCI17062" class="sect2">
<h3 class="sect2"><a id="sthref2240"></a>OTT Support for Type Inheritance</h3>
<p>To support type inheritance of objects, OTT generates a C struct to represent an object subtype by declaring the inherited attributes in an encapsulated struct with the special name "<code>_super</code>", before declaring the new attributes. Thus, for an object subtype that inherits from a supertype, the first element in the struct is named "<code>_super</code>", followed by elements corresponding to each attribute of the subtype. The type of the element named "<code>_super</code>" is the name of the supertype.</p>
<p>For example, suppose that you have a type <code>Person_t</code>, with subtype <code>Student_t</code> and subtype <code>Employee_t</code>, as shown in <a href="#CIHDFCFH">Example 15-10</a>.</p>
<div id="LNOCI18320" class="example">
<p class="titleinexample"><a id="CIHDFCFH"></a>Example 15-10 Object Type and Subtype Definitions</p>
<pre>
CREATE TYPE Person_t AS OBJECT
( ssn     NUMBER,
  name    VARCHAR2(30),
  address VARCHAR2(100)) NOT FINAL;

CREATE TYPE Student_t UNDER Person_t
( deptid NUMBER,
  major  VARCHAR2(30)) NOT FINAL;

CREATE TYPE Employee_t UNDER Person_t
( empid NUMBER,
  mgr   VARCHAR2(30));
</pre></div>
<!-- class="example" -->
<p>Suppose that you also have an intype file with the content shown in <a href="#CIHBJEBC">Example 15-11</a>.</p>
<div id="LNOCI18321" class="example">
<p class="titleinexample"><a id="CIHBJEBC"></a>Example 15-11 Contents of the Intype File</p>
<pre>
CASE=SAME
TYPE EMPLOYEE_T
TYPE STUDENT_T
TYPE PERSON_T
</pre></div>
<!-- class="example" -->
<p>Then, OTT generates the C structs for <code>Person_t</code>, <code>Student_t</code>, and <code>Employee_t</code>, and their <code>NULL</code> indicator structs, as shown in <a href="#CIHCBDGA">Example 15-12</a>.</p>
<div id="LNOCI18322" class="example">
<p class="titleinexample"><a id="CIHCBDGA"></a>Example 15-12 OTT Generates C Structs for the Types and Null Indicator Structs</p>
<pre>
#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

typedef OCIRef EMPLOYEE_T_ref;
typedef OCIRef STUDENT_T_ref;
typedef OCIRef PERSON_T_ref;

struct PERSON_T
{
   OCINumber SSN;
   OCIString * NAME;
   OCIString * ADDRESS;
};
typedef struct PERSON_T PERSON_T;

struct PERSON_T_ind
{
   OCIInd _atomic;
   OCIInd SSN;
   OCIInd NAME;
   OCIInd ADDRESS;
};
typedef struct PERSON_T_ind PERSON_T_ind;

struct EMPLOYEE_T
{
   PERSON_T_ind;
   OCINumber EMPID;
   OCIString * MGR;
};
typedef struct EMPLOYEE_T EMPLOYEE_T;

struct EMPLOYEE_T_ind
{
   PERSON_T _super;
   OCIInd EMPID;
   OCIInd MGR;
};
typedef struct EMPLOYEE_T_ind EMPLOYEE_T_ind;

struct STUDENT_T
{
   PERSON_T _super;
   OCINumber DEPTID;
   OCIString * MAJOR;
};
typedef struct STUDENT_T STUDENT_T;

struct STUDENT_T_ind
{
   PERSON_T _super;
   OCIInd DEPTID;
   OCIInd MAJOR;
};
typedef struct STUDENT_T_ind STUDENT_T_ind;

#endif
</pre></div>
<!-- class="example" -->
<p>The preceding C mapping convention allows simple upcasting from an instance of a subtype to an instance of a supertype in C to work properly. For example:</p>
<pre>
STUDENT_T *stu_ptr = some_ptr;               /* some STUDENT_T instance  */
PERSON_T  *pers_ptr = (PERSON_T *)stu_ptr;   /* upcasting */
</pre>
<p>The <code>NULL</code> indicator structs are generated similarly. Note that for the supertype <code>Person_t</code> <code>NULL</code> indicator struct, the first element is "<code>_atomic</code>", and that for the subtypes <code>Employee_t</code> and <code>Student_t</code> <code>NULL</code> indicator structs, the first element is "<code>_super</code>" (no atomic element is generated for subtypes).</p>
<div id="LNOCI17063" class="sect3"><a id="sthref2241"></a>
<h4 class="sect3">Substitutable Object Attributes</h4>
<p>For attributes of <code>NOT FINAL</code> types (potentially substitutable), the embedded attribute is represented as a pointer.</p>
<p>Consider a type <code>Book_t</code> created as follows:</p>
<pre>
CREATE TYPE Book_t AS OBJECT 
( title   VARCHAR2(30),
  author  Person_t     /* substitutable */);
</pre>
<p>The corresponding C struct generated by OTT contains a pointer to <code>Person_t</code>:</p>
<pre>
struct Book_t
{
  OCIString  *title;
  Person_t   *author;    /* pointer to Person_t struct */
}
</pre>
<p>The <code>NULL</code> indicator struct corresponding to the preceding type is as follows:</p>
<pre>
struct Book_t_ind
{ 
  OCIInd  _atomic;
  OCIInd  title;
  OCIInd  author;
}
</pre>
<p>Note that the <code>NULL</code> indicator struct corresponding to the <code>author</code> attribute can be obtained from the <code>author</code> object itself. See <a href="oci18nav004.htm#i469963">OCIObjectGetInd()</a>.</p>
<p>If a type is defined to be <code>FINAL</code>, it cannot have any subtypes. An attribute of a <code>FINAL</code> type is therefore not substitutable. In such cases, the mapping is as before: the attribute struct is inline. Now, if the type is altered and defined to be <code>NOT FINAL</code>, the mapping must change. The new mapping is generated by running OTT again.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i432200"></a>
<div id="LNOCI17064" class="sect1">
<h2 class="sect1">Outtype File<a id="sthref2242"></a><a id="sthref2243"></a></h2>
<p>The outtype file is named on the OTT command line. When OTT generates the C header file, it also writes the results of the translation into the outtype file. This file contains an entry for each of the types that is translated, including its version string, and the header file to which its C representation was written.</p>
<p>The outtype file from one OTT run can be used as the intype file for a subsequent OTT invocation.</p>
<p>For example, suppose that you have a simple intype file, as shown in <a href="#CIHBIJAH">Example 15-13</a>, which was used in <a href="#CIHJFADB">Example 15-5</a>.</p>
<div id="LNOCI18323" class="example">
<p class="titleinexample"><a id="CIHBIJAH"></a>Example 15-13 Contents of an Intype File</p>
<pre>
CASE=LOWER
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE "Person"
TYPE PURCHASE_ORDER AS p_o
</pre></div>
<!-- class="example" -->
<p>The user has chosen to specify the case for the OTT-generated C identifiers, and has provided a list of types to be translated. In two of these types, naming conventions are specified.</p>
<p><a href="#CIHFHCAJ">Example 15-14</a> shows what the outtype file might look like after running OTT.</p>
<div id="LNOCI18324" class="example">
<p class="titleinexample"><a id="CIHFHCAJ"></a>Example 15-14 Contents of the Outtype File After Running OTT</p>
<pre>
CASE = LOWER
TYPE EMPLOYEE AS employee
  VERSION = "$8.0"
  HFILE = demo.h
  TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS AS ADDRESS
  VERSION = "$8.0"
  HFILE = demo.h
TYPE ITEM AS item
  VERSION = "$8.0"
  HFILE = demo.h
TYPE "Person" AS Person
  VERSION = "$8.0"
  HFILE = demo.h
TYPE PURCHASE_ORDER AS p_o
  VERSION = "$8.0"
  HFILE = demo.h
</pre></div>
<!-- class="example" -->
<p>When examining the contents of the outtype file, you might discover types listed that were not included in the intype specification. For example, suppose that the intype file only specified that the <code>person</code> type was to be translated as follows:</p>
<pre>
CASE = LOWER
TYPE PERSON
</pre>
<p>However, because the definition of the <code>person</code> type includes an attribute of type <code>address</code>, the outtype file includes entries for both <code>PERSON</code> and <code>ADDRESS</code>. The <code>person</code> type cannot be translated completely without first translating <code>address</code>.</p>
<p>When the parameter <code>TRANSITIVE</code> has been set to <code>TRUE</code> (it is the default), OTT analyzes the types in the intype file for type dependencies before performing the translation, and translates other types as necessary.</p>
</div>
<!-- class="sect1" -->
<a id="i427628"></a>
<div id="LNOCI17065" class="sect1">
<h2 class="sect1">Using OTT with OCI Applications<a id="sthref2244"></a></h2>
<p>An OCI application that accesses objects in an Oracle server can use C header and implementation files that have been generated by OTT. The header file is incorporated into the OCI code with an <code>#include</code> statement.</p>
<p>Once the header file has been included, the OCI application can access and manipulate object data in the host language format.</p>
<p><a href="#i434792">Figure 15-1</a> shows the steps involved in using OTT with OCI for the simplest applications:</p>
<ol>
<li>
<p>SQL is used to create type definitions in the database.</p>
</li>
<li>
<p>OTT generates a header file containing C representations of object types and named collection types. It also generates an implementation file, as named with the <code>INITFILE</code> option.</p>
</li>
<li>
<p>The application is written. User-written code in the OCI application declares and calls the <code>INITFUNC</code> function.</p>
</li>
<li>
<p>The header file is included in an OCI source code file.</p>
</li>
<li>
<p>The OCI application, including the implementation file generated by OTT, is compiled and linked with the OCI libraries.</p>
</li>
<li>
<p>The OCI executable is run against the Oracle database.</p>
</li>
</ol>
<div id="LNOCI17066" class="figure">
<p class="titleinfigure"><a id="i434792"></a>Figure 15-1 Using OTT with OCI</p>
<img width="557" height="491" src="img/lnoci029.gif" alt="Description of Figure 15-1 follows" /><br />
<a id="sthref2245" href="img_text/lnoci029.htm">Description of "Figure 15-1 Using OTT with OCI"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="i424522"></a>
<div id="LNOCI17067" class="sect2">
<h3 class="sect2">Accessing and Manipulating Objects with OCI<a id="sthref2246"></a><a id="sthref2247"></a><a id="sthref2248"></a></h3>
<p>Within the application, the OCI program can perform bind and define operations using program variables declared to be of types that appear in the OTT-generated header file.</p>
<p>For example, an application might fetch a <code>REF</code> to an object using a SQL <code>SELECT</code> statement and then pin that object using the appropriate OCI function. Once the object has been pinned, its attribute data can be accessed and manipulated with other OCI functions.</p>
<p>OCI includes a set of data type mapping and manipulation functions that are specifically designed to work on attributes of object types and named collection types.</p>
<p>The following are examples of the available functions:</p>
<ul>
<li>
<p><a href="oci19map006.htm#i458763">OCIStringSize()</a> gets the size of an <code>OCIString</code> string.</p>
</li>
<li>
<p><a href="oci19map003.htm#i430094">OCINumberAdd()</a> adds two <code>OCINumber</code> numbers together.</p>
</li>
<li>
<p><a href="oci17msc002.htm#i450869">OCILobIsEqual()</a> compares two LOB locators for equality.</p>
</li>
<li>
<p><a href="oci19map004.htm#i450924">OCIRawPtr()</a> gets a pointer to an <code>OCIRaw</code> raw data type.</p>
</li>
<li>
<p><a href="oci19map001.htm#i448982">OCICollAppend()</a> appends an element to a collection type (<code>OCIArray</code> or <code>OCITable</code>).</p>
</li>
<li>
<p><a href="oci19map007.htm#i450567">OCITableFirst()</a> returns the index for the first existing element of a nested table (<code>OCITable</code>).</p>
</li>
<li>
<p><a href="oci19map005.htm#i448096">OCIRefIsNull()</a> tests if a <code>REF</code> (<code>OCIRef</code>) is <code>NULL</code>.</p>
</li>
</ul>
<p>These functions are described in detail in other chapters of this guide.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI17068" class="sect2"><a id="sthref2249"></a>
<h3 class="sect2">Calling the Initialization Function<a id="sthref2250"></a></h3>
<p>OTT generates a C initialization function if requested. The initialization function tells the environment, for each object type used in the program, which version of the type is used. You can specify a name for the initialization function when you invoke OTT with the <code>INITFUNC</code> option, or you can allow OTT to select a default name based on the name of the implementation file (<code>INITFILE</code>) containing the function.</p>
<p>The initialization function takes two arguments; an environment handle pointer and an error handle pointer. There is typically a single initialization function, but this is not required. If a program has several separately compiled pieces requiring different types, you may want to execute OTT separately for each piece, requiring for each piece, one initialization file containing an initialization function.</p>
<p>After an environment handle is created by an explicit OCI object call (for example, by calling <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a>) you must also explicitly call the initialization functions. All the initialization functions must be called for each explicitly created environment handle. This gives each handle access to all the Oracle data types used in the entire program.</p>
<p>If an environment handle is implicitly created by embedded SQL statements, such as <code>EXEC SQL CONTEXT USE</code> and <code>EXEC SQL CONNECT</code>, the handle is initialized implicitly, and the initialization functions need not be called. This is only relevant when Pro*C/C++ is being combined with OCI applications.</p>
<p>The following example shows an initialization function.</p>
<p>Suppose that you have an intype file, <code>ex2c.typ</code>, containing the content shown in <a href="#CIHBJAIG">Example 15-15</a>.</p>
<div id="LNOCI18325" class="example">
<p class="titleinexample"><a id="CIHBJAIG"></a>Example 15-15 Content of an Intype File Named ex2c.typ</p>
<pre>
TYPE BREN.PERSON
TYPE BREN.ADDRESS
</pre></div>
<!-- class="example" -->
<p>Then you invoke OTT from the command line and specify the initialization function, as shown in <a href="#CIHIJJHH">Example 15-16</a>.</p>
<div id="LNOCI18326" class="example">
<p class="titleinexample"><a id="CIHIJJHH"></a>Example 15-16 Invoking OTT and Specifying the Initialization Function</p>
<pre>
ott userid=bren intype=ex2c outtype=ex2co hfile=ex2ch.h initfile=ex2cv.c
</pre></div>
<!-- class="example" -->
<p>OTT generates the <code>ex2cv.c</code> file with the contents shown in <a href="#CIHDFEGJ">Example 15-17</a>.</p>
<div id="LNOCI18327" class="example">
<p class="titleinexample"><a id="CIHDFEGJ"></a>Example 15-17 Content of an OTT-Generated File Named ex2cv.c</p>
<pre>
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif

sword ex2cv(OCIEnv *env, OCIError *err)
{
   sword status = OCITypeVTInit(env, err);
   if (status == OCI_SUCCESS)
      status = OCITypeVTInsert(env, err,
          "BREN", 5,
          "PERSON", 6,
          "$8.0", 4);
    if (status == OCI_SUCCESS)
        status = OCITypeVTInsert(env, err,
           "BREN", 5,
           "ADDRESS", 7,
           "$8.0", 4);
    return status;
}
</pre></div>
<!-- class="example" -->
<p>The function <code>ex2cv()</code> creates the type version table and inserts the types <code>BREN.PERSON</code> and <code>BREN.ADDRESS</code>.</p>
<p>If a program explicitly creates an environment handle, all the initialization functions must be generated, compiled, and linked, because they must be called for each explicitly created handle. If a program does not explicitly create any environment handles, initialization functions are not required.</p>
<p>A program that uses an OTT-generated header file must also use the initialization function generated at the same time. When a header file is generated by OTT and an environment handle is explicitly created in the program, then the implementation file must also be compiled and linked into the executable.</p>
</div>
<!-- class="sect2" -->
<div id="LNOCI17069" class="sect2"><a id="sthref2251"></a>
<h3 class="sect2">Tasks of the Initialization Function<a id="sthref2252"></a></h3>
<p>The C initialization function supplies version information about the types processed by OTT. It adds to the type-version table the name and version identifier of every OTT-processed object data type.</p>
<p>The type-version table is used by the Oracle database type manager to determine which version of a type a particular program uses. Different initialization functions generated by OTT at different times can add some of the same types to the type version table. When a type is added more than once, Oracle Database ensures that the same version of the type is registered each time.</p>
<p>It is the OCI programmer's responsibility to declare a function prototype for the initialization function, and to call the function.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the current release of Oracle Database, each type has only one version. Initialization of the type version table is required only for compatibility with future releases of Oracle Database.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i439554"></a>
<div id="LNOCI17070" class="sect1">
<h2 class="sect1">OTT Reference<a id="sthref2253"></a></h2>
<p>Parameters that can appear on the OTT command line or in a <code>CONFIG</code> file control the behavior of OTT. Certain parameters can also appear in the intype file.</p>
<p>This section provides detailed information about the following topics:</p>
<ul>
<li>
<p><a href="#i428059">OTT Command-Line Syntax</a></p>
</li>
<li>
<p><a href="#i428064">OTT Parameters</a></p>
</li>
<li>
<p><a href="#i441984">Where OTT Parameters Can Appear</a></p>
</li>
<li>
<p><a href="#i420386">Structure of the Intype File</a></p>
</li>
<li>
<p><a href="#i432204">Nested Included File Generation</a></p>
</li>
<li>
<p><a href="#i432208">SCHEMA_NAMES Usage</a></p>
</li>
<li>
<p><a href="#i433388">Default Name Mapping</a></p>
</li>
<li>
<p><a href="#i432220">OTT Restriction on File Name Comparison</a></p>
</li>
</ul>
<p>The following conventions are used in this section to describe OTT syntax:</p>
<ul>
<li>
<p>Italic strings are variables or parameters to be supplied by the user.</p>
</li>
<li>
<p>Strings in UPPERCASE are entered as shown, except that case is not significant.</p>
</li>
<li>
<p>OTT keywords are listed in a lowercase monospaced font in examples and headings, but are printed in uppercase in text to make them more distinctive.</p>
</li>
<li>
<p>Square brackets [...] enclose optional items.</p>
</li>
<li>
<p>An ellipsis (...) immediately following an item (or items enclosed in brackets) means that the item can be repeated any number of times.</p>
</li>
<li>
<p>Punctuation symbols other than those described earlier are entered as shown. These include ".", "@", and so on.</p>
</li>
</ul>
<a id="i428059"></a>
<div id="LNOCI17071" class="sect2">
<h3 class="sect2">OTT Command-Line Syntax<a id="sthref2254"></a></h3>
<p>The OTT command-line interface is used when explicitly invoking OTT to translate database types into C structs. This is always required when you develop OCI applications that use objects.</p>
<p>An OTT command-line statement consists of the keyword <code>OTT</code>, followed by a list of OTT parameters.</p>
<p>The parameters<a id="sthref2255"></a> that can appear on an OTT command-line statement are as follows:</p>
<pre>
[userid=<span class="italic">username/password[@db_name</span>]]

[intype=<span class="italic">filename</span>]

outtype=<span class="italic">filename</span>

code=C|ANSI_C|KR_C

[hfile=<span class="italic">filename</span>]

[errtype=<span class="italic">filename</span>]

[config=<span class="italic">filename</span>]

[initfile=<span class="italic">filename</span>]

[initfunc=<span class="italic">filename</span>]

[case=SAME|LOWER|UPPER|OPPOSITE]

[schema_name=ALWAYS|IF_NEEDED|FROM_INTYPE]

[transitive=TRUE|FALSE]

[URL=<span class="italic">url</span>]
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generally, the order of the parameters following the <code>OTT</code> command does not matter. Only the <code>OUTTYPE</code> and <code>CODE</code> parameters are always required.</div>
<p>The <code>HFILE</code> parameter is almost always used. If omitted from the command line, <code>HFILE</code> must be specified individually for each type in the intype file. If OTT determines that a type not listed in the intype file must be translated, an error is reported. Therefore, it is safe to omit the <code>HFILE</code> parameter only if the intype file was previously generated as an OTT outtype file.</p>
<p>If the intype file is omitted, the entire schema is translated. See the parameter descriptions in <a href="#i428064">"OTT Parameters"</a> for more information.</p>
<p>The following is an example of an OTT command-line statement (you are prompted for the password):</p>
<pre>
OTT userid=marc intype=in.typ outtype=out.typ code=c hfile=demo.h\
   errtype=demo.tls case=lower
</pre>
<p>The following sections describe each of the OTT command-line parameters.</p>
</div>
<!-- class="sect2" -->
<a id="i428064"></a>
<div id="LNOCI17072" class="sect2">
<h3 class="sect2">OTT Parameters<a id="sthref2256"></a></h3>
<p>Enter parameters on the OTT <a id="sthref2257"></a>command line using the following format:</p>
<pre>
<span class="italic">parameter</span>=<span class="italic">value</span>
</pre>
<p>In this format, <code>parameter</code> is the literal parameter string and <code>value</code> is a valid parameter setting. The literal parameter string is not case-sensitive.</p>
<p>Separate command-line parameters by using either spaces or tabs.</p>
<p>Parameters can also appear within a configuration file, but, in that case, no whitespace is permitted within a line, and each parameter must appear on a separate line. Additionally, the parameters <code>CASE,</code> <code>HFILE,INITFUNC</code>, and <code>INITFILE</code> can appear in the intype file.</p>
<div id="LNOCI17073" class="sect3"><a id="sthref2258"></a>
<h4 class="sect3"><a id="sthref2259"></a><a id="sthref2260"></a>USERID</h4>
<p>The <code>USERID</code> parameter specifies the database user name, password, and optional database name (Oracle Net Services database specification string). If the database name is omitted, the default database is assumed. The syntax of this parameter is:</p>
<pre>
userid=<span class="italic">username/password[@db_name]</span>
</pre>
<p>The <code>USERID</code> parameter is optional. If it is omitted, OTT automatically attempts to connect to the default database as user <code>OPS$username</code>, where <code>username</code> is the user's operating system user name. If this is the first parameter, "<code>USERID=</code>" and the password and the database name can be omitted, as shown here:</p>
<pre>
OTT <span class="italic">username ...</span>
</pre>
<p>For security purposes, when you enter only the user name you are prompted for the rest of the entry.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17074" class="sect3"><a id="sthref2261"></a>
<h4 class="sect3">INTYPE<a id="sthref2262"></a><a id="sthref2263"></a></h4>
<p>The <code>INTYPE</code> parameter specifies the name of the file from which to read the list of object type specifications. OTT translates each type in the list.</p>
<p>The syntax for this parameter is</p>
<pre>
intype=<span class="italic">filename</span>
</pre>
<p>"<code>INTYPE=</code>" can be omitted if <code>USERID</code> and <code>INTYPE</code> are the first two parameters, in that order, and "<code>USERID=</code>" is omitted. If the <code>INTYPE</code> parameter is not specified, all types in the user's schema are translated.</p>
<pre>
OTT <span class="italic">username filename...</span>
</pre>
<p>The intype file can be thought of as a makefile for type declarations. It lists the types for which C struct declarations are needed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i420386">"Structure of the Intype File"</a> for a description of the format of the intype file</div>
<p>If the file name on the command line or in the intype file does not include an extension, an operating system-specific extension such as "<code>TYP</code>" or "<code>.typ</code>" is added.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17075" class="sect3"><a id="sthref2264"></a>
<h4 class="sect3">OUTTYPE<a id="sthref2265"></a><a id="sthref2266"></a></h4>
<p>The <code>OUTTYPE</code> parameter specifies the name of a file into which OTT writes type information for all the object data types it processes. This includes all types explicitly named in the intype file, and can include additional types that are translated because they are used in the declarations of other types that must be translated (if <code>TRANSITIVE=TRUE</code>). This file must be used as an intype file in a future invocation of OTT.</p>
<pre>
outtype=<span class="italic">filename</span>
</pre>
<p>If the <code>INTYPE</code> and <code>OUTTYPE</code> parameters refer to the same file, the new <code>INTYPE</code> parameter information replaces the old information in the intype file. This provides a convenient way for the same intype file to be used repeatedly in the cycle of altering types, generating type declarations, editing source code, precompiling, compiling, and debugging.</p>
<p>The parameter <code>OUTTYPE</code> must be specified.</p>
<p>If the file name on the command line or in the outtype file does not include an extension, an operating system-specific extension such as "<code>TYP</code>" or "<code>.typ</code>" is added.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17076" class="sect3"><a id="sthref2267"></a>
<h4 class="sect3">CODE<a id="sthref2268"></a><a id="sthref2269"></a></h4>
<p>This is the desired host language for OTT output, which is specified as <code>CODE=C, CODE=KR_C,</code> or <code>CODE=ANSI_C</code>. "<code>CODE=C</code>" is equivalent to "<code>CODE=ANSI_C</code>".</p>
<pre>
CODE=C|KR_C|ANSI_C
</pre>
<p>There is no default value for this parameter; it must be supplied.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17077" class="sect3"><a id="sthref2270"></a>
<h4 class="sect3">INITFILE<a id="sthref2271"></a><a id="sthref2272"></a></h4>
<p>The <code>INITFILE</code> parameter specifies the name of the file where the OTT-generated initialization file is to be written. The initialization function is not generated if this parameter is omitted.</p>
<p>For Pro*C/C++ programs, the <code>INITFILE</code> is not necessary, because the SQLLIB runtime library performs the necessary initializations. An OCI program user must compile and link the <code>INITFILE</code> files, and must call the initialization file functions when an environment handle is created.</p>
<p>If the file name of an <code>INITFILE</code> on the command line or in the intype file does not include an extension, an operating system-specific extension such as "<code>C</code>" or "<code>.c</code>" is added.</p>
<pre>
initfile=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI17078" class="sect3"><a id="sthref2273"></a>
<h4 class="sect3">INITFUNC<a id="sthref2274"></a><a id="sthref2275"></a></h4>
<p>The <code>INITFUNC</code> parameter is only used in OCI programs. It specifies the name of the initialization function generated by OTT. If this parameter is omitted, the name of the initialization function is derived from the name of the <code>INITFILE</code>.</p>
<pre>
initfunc=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI17079" class="sect3"><a id="sthref2276"></a>
<h4 class="sect3">HFILE<a id="sthref2277"></a><a id="sthref2278"></a></h4>
<p>The <code>HFILE</code> parameter specifies the name of the include (<code>.h</code>) file to be generated by OTT for the declarations of types that are mentioned in the intype file but whose include files are not specified there. This parameter is required unless the include file for each type is specified individually in the intype file. This parameter is also required if a type not mentioned in the intype file must be generated because other types require it, and these other types are declared in two or more different files, and <code>TRANSITIVE=TRUE</code>.</p>
<p>If the file name of an <code>HFILE</code> on the command line or in the intype file does not include an extension, an operating system-specific extension such as "<code>H</code>" or "<code>.h</code>" is added.</p>
<pre>
hfile=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<div id="LNOCI17080" class="sect3"><a id="sthref2279"></a>
<h4 class="sect3">CONFIG<a id="sthref2280"></a><a id="sthref2281"></a></h4>
<p>The <code>CONFIG</code> parameter specifies the name of the OTT configuration file, which lists commonly used parameter specifications. Parameter specifications are also read from a system configuration file in an operating system-dependent location. All remaining parameter specifications must appear on the command line, or in the intype file.</p>
<pre>
config=<span class="italic">filename</span> 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A <code>CONFIG</code> parameter is not allowed in the <code>CONFIG</code> file.</div>
</div>
<!-- class="sect3" -->
<div id="LNOCI17081" class="sect3"><a id="sthref2282"></a>
<h4 class="sect3">ERRTYPE<a id="sthref2283"></a><a id="sthref2284"></a></h4>
<p>If the <code>ERRTYPE</code> parameter is supplied, OTT writes a listing of the intype file to the <code>ERRTYPE</code> file, along with all informational and error messages. Informational and error messages are sent to the standard output whether <code>ERRTYPE</code> parameter is specified or not.</p>
<p>Essentially, the <code>ERRTYPE</code> file is a copy of the intype file with error messages added. In most cases, an error message includes a pointer to the text that caused the error.</p>
<p>If the file name of an <code>ERRTYPE</code> on the command line or in the intype file does not include an extension, an operating system-specific extension such as "<code>TLS</code>" or "<code>.tls</code>" is added.</p>
<pre>
errtype=<span class="italic">filename</span>
</pre></div>
<!-- class="sect3" -->
<a id="i428925"></a>
<div id="LNOCI17082" class="sect3">
<h4 class="sect3">CASE<a id="sthref2285"></a><a id="sthref2286"></a></h4>
<p>This <code>CASE</code> parameter affects the case of certain C identifiers generated by OTT. The possible values of <code>CASE</code> are <code>SAME, LOWER, UPPER</code>, and <code>OPPOSITE</code>. If <code>CASE = SAME</code>, the case of letters is not changed when converting database type and attribute names to C identifiers. If <code>CASE=LOWER</code>, all uppercase letters are converted to lowercase. If <code>CASE=UPPER</code>, all lowercase letters are converted to uppercase. If <code>CASE=OPPOSITE</code>, all uppercase letters are converted to lowercase, and vice versa.</p>
<pre>
CASE=[SAME|LOWER|UPPER|OPPOSITE]
</pre>
<p>This option affects only those identifiers (attributes or types not explicitly listed) not mentioned in the intype file. Case conversion occurs after a legal identifier has been generated.</p>
<p>Note that the case of the C struct identifier for a type specifically mentioned in the <code>INTYPE</code> parameter option is the same as its case in the intype file. For example, if the intype file includes the following line:</p>
<pre>
TYPE Worker
</pre>
<p>Then OTT generates the following line:</p>
<pre>
struct Worker {...};
</pre>
<p>However, suppose that the intype file is written as follows:</p>
<pre>
TYPE wOrKeR
</pre>
<p>Then OTT generates the following line, following the case specified in the intype file.</p>
<pre>
struct wOrKeR {...};
</pre>
<p>Case-insensitive SQL identifiers not mentioned in the intype file appear in uppercase if <code>CASE=SAME</code>, and in lowercase if <code>CASE=OPPOSITE</code>. A SQL identifier is case-insensitive if it was not enclosed in quotation marks when it was declared.</p>
</div>
<!-- class="sect3" -->
<div id="LNOCI17083" class="sect3"><a id="sthref2287"></a>
<h4 class="sect3">SCHEMA_NAMES<a id="sthref2288"></a><a id="sthref2289"></a></h4>
<p>The <code>SCHEMA_NAMES</code> parameter offers control in qualifying the database name of a type from the default schema with a schema name in the outtype file. The outtype file generated by OTT contains information about the types processed by OTT, including the type names.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i432208">"SCHEMA_NAMES Usage"</a></div>
</div>
<!-- class="sect3" -->
<a id="i440618"></a>
<div id="LNOCI17084" class="sect3">
<h4 class="sect3">TRANSITIVE<a id="sthref2290"></a><a id="sthref2291"></a></h4>
<p>The <code>TRANSITIVE</code> parameter takes the values <code>TRUE</code> (the default) or <code>FALSE</code>. It indicates whether type dependencies not explicitly listed in the intype file are to be translated or not.</p>
<p>If <code>TRANSITIVE=TRUE</code> is specified, then types needed by other types but not mentioned in the intype file are generated.</p>
<p>If <code>TRANSITIVE=FALSE</code> is specified, then types not mentioned in the intype file are not generated, even if they were used as attribute types of other generated types.</p>
</div>
<!-- class="sect3" -->
<a id="i442194"></a>
<div id="LNOCI17085" class="sect3">
<h4 class="sect3">URL<a id="sthref2292"></a><a id="sthref2293"></a></h4>
<p>For the <code>URL</code> parameter, OTT uses JDBC (Java Database Connectivity), the Java interface for connecting to the database. The default value of parameter <code>URL</code> is:</p>
<pre>
URL=jdbc:oracle:oci8:@
</pre>
<p>The OCI8 driver is for client-side use with an Oracle Database installation.</p>
<p>To specify the JDBC Thin driver (the Java driver for client-side use without an Oracle Database installation), use the following <code>URL</code> parameter syntax:</p>
<pre>
URL=jdbc:oracle:thin:@<span class="italic">host:port:sid</span>
</pre>
<p>The <code>host</code> is the name of the host on which the database is running, <code>port</code> is the port number, and <code>sid</code> is the Oracle SID.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i441984"></a>
<div id="LNOCI17086" class="sect2">
<h3 class="sect2">Where OTT Parameters Can Appear<a id="sthref2294"></a></h3>
<p>OTT parameters can appear on the command line, in a <code>CONFIG</code> file named on the command line, or both. Some parameters are also allowed in the intype file.</p>
<p>OTT is invoked as follows:</p>
<pre>
OTT <span class="italic">username</span>/<span class="italic">password</span> parameters
</pre>
<p>If one of the parameters on the command line is the following, then additional parameters are read from the configuration file <code>filename</code>:</p>
<pre>
config=<span class="italic">filename</span>
</pre>
<p>In addition, parameters are also read from a default configuration file in an operating system-dependent location. This file must exist, but can be empty. Parameters in a configuration file must appear one in each line, with no whitespace on the line.</p>
<p>If OTT is executed without any arguments, an online parameter reference is displayed.</p>
<p>The types for OTT to translate are named in the file specified by the <code>INTYPE</code> parameter. The parameters <code>CASE, INITFILE, INITFUNC</code>, and <code>HFILE</code> can also appear in the intype file. The outtype files generated by OTT include the <code>CASE</code> parameter, and include the <code>INITFILE</code>, and <code>INITFUNC</code> parameters if an initialization file was generated. The outtype file specifies the <code>HFILE</code> individually for each type.</p>
<p>The case of the OTT command is operating system-dependent.</p>
</div>
<!-- class="sect2" -->
<a id="i420386"></a>
<div id="LNOCI17087" class="sect2">
<h3 class="sect2">Structure of the Intype File</h3>
<p>The intype and outtype files<a id="sthref2295"></a><a id="sthref2296"></a><a id="sthref2297"></a> list the types translated by OTT, and provide all the information needed to determine how a type or attribute name is translated to a legal C identifier. These files contain one or more type specifications. These files also can contain specifications of the following options:</p>
<ul>
<li>
<p><code>CASE</code></p>
</li>
<li>
<p><code>HFILE</code></p>
</li>
<li>
<p><code>INITFILE</code></p>
</li>
<li>
<p><code>INITFUNC</code></p>
</li>
</ul>
<p>If the <code>CASE, INITFILE</code>, or <code>INITFUNC</code> options are present, they must precede any type specifications. If these options appear both on the command line and in the intype file, the value on the command line is used.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i432200">"Outtype File"</a> for an example of a simple user-defined intype file, and of the full outtype file that OTT generates from it</div>
<div id="LNOCI17088" class="sect3"><a id="sthref2298"></a>
<h4 class="sect3">Intype File Type Specifications</h4>
<p>A type specification in the intype file names an object data type that is to be translated. A type specification in the outtype file names an object data type that has been translated.</p>
<pre>
TYPE employee
  TRANSLATE SALARY$ AS salary
            DEPTNO AS department
TYPE ADDRESS
TYPE PURCHASE_ORDER AS p_o
</pre>
<p>The structure of a type specification is as follows, where [] indicates optional inputs inside:</p>
<pre>
TYPE <span class="italic">type_name</span> [AS <span class="italic">type_identifier</span>]
[VERSION [=] <span class="italic">version_string</span>]
[HFILE [=] <span class="italic">hfile_name</span>]
[TRANSLATE{<span class="italic">member_name</span> [AS <span class="italic">identifier</span>]}...]
</pre>
<p>The syntax of <code>type_name</code> is:</p>
<pre>
[<span class="italic">schema_name</span>.]<span class="italic">type_name</span>
</pre>
<p>The <code>schema_name</code> is the name of the schema that owns the given object data type, and <code>type_name</code> is the name of the type. The default schema is that of the user running OTT. The default database is the local database.</p>
<p>The components of a type specification are described as follows:</p>
<ul>
<li>
<p><code>type_name</code> is the name of an Oracle Database object data type.</p>
</li>
<li>
<p><code>type_identifier</code> is the C identifier used to represent the type. If <code>type_identifier</code> is omitted, the default name mapping algorithm is used.</p>
</li>
<li>
<p><code>version_string</code> is the version string of the type that was used when the code was generated by a previous invocation of OTT. The version string is generated by OTT and written to the outtype file, which can be used as the intype file when OTT is executed later. The version string does not affect the operation of OTT, but is eventually used to select the version of the object data type that should be used in the running program.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i433388">"Default Name Mapping"</a></div>
<ul>
<li>
<p><code>hfile_name</code> is the name of the header file in which the declarations of the corresponding struct or class appear. If <code>hfile_name</code> is omitted, the file named by the command-line <code>HFILE</code> parameter is used if a declaration is generated.</p>
</li>
<li>
<p><code>member_name</code> is the name of an attribute (data member) that is to be translated to the <code>identifier</code>.</p>
</li>
<li>
<p><code>identifier</code> is the C identifier used to represent the attribute in the user program. Identifiers can be specified in this way for any number of attributes. The default name mapping algorithm is used for the attributes that are not mentioned.</p>
</li>
</ul>
<p>An object data type may need to be translated for one of two reasons:</p>
<ul>
<li>
<p>It appears in the intype file.</p>
</li>
<li>
<p>It is required to declare another type that must be translated, and <code>TRANSITIVE=TRUE</code>.</p>
</li>
</ul>
<p>If a type that is not mentioned explicitly is required by types declared in exactly one file, OTT writes the translation of the required type to the same file or files as the explicitly declared types that require it.</p>
<p>If a type that is not mentioned explicitly is required by types declared in two or more different files, OTT writes the translation of the required type to the global <code>HFILE</code> file.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i432204"></a>
<div id="LNOCI17089" class="sect2">
<h3 class="sect2">Nested Included File Generation</h3>
<p>Every <code>HFILE</code> generated by OTT uses <code>#include</code> directives to include other necessary files and <code>#define</code> directives to define a symbol constructed from the name of the file, which can be used to determine if the <code>HFILE</code> has been included. Consider, for example, a database with the types shown in <a href="#CIHEJEGB">Example 15-18</a>.</p>
<div id="LNOCI18328" class="example">
<p class="titleinexample"><a id="CIHEJEGB"></a>Example 15-18 Object Type Definition to Demonstrate How OTT Generates Include Files</p>
<pre>
create type px1 AS OBJECT (col1 number, col2 integer);
create type px2 AS OBJECT (col1 px1);
create type px3 AS OBJECT (col1 px1);
</pre></div>
<!-- class="example" -->
<p>The intype file content is shown in <a href="#CIHDHGCG">Example 15-19</a>.</p>
<div id="LNOCI18329" class="example">
<p class="titleinexample"><a id="CIHDHGCG"></a>Example 15-19 Content of the Intype File</p>
<pre>
CASE=lower
type pxl
  hfile tott95a.h
type px3
  hfile tott95b.h
</pre></div>
<!-- class="example" -->
<p>If you invoke OTT with the command shown in <a href="#CIHEIIFH">Example 15-20</a>, then it generates the header files shown in <a href="#CIHGGFJH">Example 15-21</a> and <a href="#CIHGFIEC">Example 15-22</a>.</p>
<div id="LNOCI18330" class="example">
<p class="titleinexample"><a id="CIHEIIFH"></a>Example 15-20 Invoking OTT from the Command Line</p>
<pre>
ott scott tott95i.typ outtype=tott95o.typ code=c
</pre></div>
<!-- class="example" -->
<p>The content of the header file <code>tott95b.h</code> is shown in <a href="#CIHGGFJH">Example 15-21</a>.</p>
<div id="LNOCI18331" class="example">
<p class="titleinexample"><a id="CIHGGFJH"></a>Example 15-21 Content of the Header File tott95b.h</p>
<pre>
#ifndef TOTT95B_ORACLE
#define TOTT95B_ORACLE
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
#ifndef TOTT95A_ORACLE
#include "tott95a.h"
#endif
typedef OCIRef px3_ref;
struct px3
{
   struct px1 col1;
};
typedef struct px3 px3;
struct px3_ind
{
   OCIInd _atomic;
   struct px1_ind col1
};
typedef struct px3_ind px3_ind;
#endif
</pre></div>
<!-- class="example" -->
<p>The content of the header file tott95a.h is shown in <a href="#CIHGFIEC">Example 15-22</a>.</p>
<div id="LNOCI18332" class="example">
<p class="titleinexample"><a id="CIHGFIEC"></a>Example 15-22 Content of the Header File tott95a.h</p>
<pre>
#ifndef TOTT95A_ORACLE
#define TOTT95A_ORACLE
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
typedef OCIRef px1_ref;
struct px1
{
   OCINumber col1;
   OCINumber col2;
}
typedef struct px1 px1;
struct px1_ind
{
   OCIInd _atomic;
   OCIInd col1;
   OCIInd col2;
}
typedef struct px1_ind px1_ind;
#endif
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHGGFJH">Example 15-21</a>, the symbol <code>TOTT95B_ORACLE</code> is defined first so that the programmer can conditionally include <code>tott95b.h</code> without having to worry whether <code>tott95b.h</code> depends on the include file using the construct, as shown in <a href="#CIHEDJIA">Example 15-23</a>.</p>
<div id="LNOCI18333" class="example">
<p class="titleinexample"><a id="CIHEDJIA"></a>Example 15-23 Construct to Use to Conditionally Include the Header File tott95b.h</p>
<pre>
#ifndef TOTT95B_ORACLE
#include "tott95b.h"
#endif
</pre></div>
<!-- class="example" -->
<p>Using this technique, the programmer can include <code>tott95b.h</code> from some file, say <code>foo.h</code>, without having to know whether some other file included by <code>foo.h</code> also includes <code>tott95b.h</code>.</p>
<p>After the definition of the symbol <code>TOTT95B_ORACLE</code>, the file <code>oci.h</code> is included. Every <code>HFILE</code> generated by OTT includes <code>oci.h</code>, which contains type and function declarations that the Pro*C/C++ or OCI programmer can use. This is the only case in which OTT uses angle brackets in an <code>#include</code> directive.</p>
<p>Next, the file <code>tott95a.h</code> is included. This file is included because it contains the declaration of "<code>struct px1</code>", which <code>tott95b.h</code> requires. When the user's intype file requests that type declarations be written to more than one file, OTT determines which other files each <code>HFILE</code> must include, and generates the necessary <code>#includes</code> directives.</p>
<p>Note that OTT uses quotation marks in this <code>#include</code> directive. When a program including <code>tott95b.h</code> is compiled, the search for <code>tott95a.h</code> begins where the source program was found, and thereafter follows an implementation-defined search rule. If <code>tott95a.h</code> cannot be found in this way, a complete file name (for example, a Linux or UNIX absolute path name beginning with /) should be used in the intype file to specify the location of <code>tott95a.h</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i432208"></a>
<div id="LNOCI17090" class="sect2">
<h3 class="sect2">SCHEMA_NAMES Usage<a id="sthref2299"></a></h3>
<p>This parameter affects whether the name of a type from the default schema to which OTT is connected is qualified with a schema name in the outtype file.</p>
<p>The name of a type from a schema other than the default schema is always qualified with a schema name in the outtype file.</p>
<p>The schema name, or its absence, determines in which schema the type is found during program execution.</p>
<p>There are three settings:</p>
<ul>
<li>
<p><code>schema_names=ALWAYS</code> (default)</p>
<p>All type names in the outtype file are qualified with a schema name.</p>
</li>
<li>
<p><code>schema_names=IF_NEEDED</code></p>
<p>The type names in the outtype file that belong to the default schema are not qualified with a schema name. As always, type names belonging to other schemas are qualified with the schema name.</p>
</li>
<li>
<p><code>schema_names=FROM_INTYPE</code></p>
<p>A type mentioned in the intype file is qualified with a schema name in the outtype file if, and only if, it was qualified with a schema name in the intype file. A type in the default schema that is not mentioned in the intype file but that must be generated because of type dependencies is written with a schema name only if the first type encountered by OTT that depends on it was written with a schema name. However, a type that is not in the default schema to which OTT is connected is always written with an explicit schema name.</p>
</li>
</ul>
<p>The outtype file generated by OTT is an input parameter to Pro*C/C++. From the point of view of Pro*C/C++, it is the Pro*C/C++ intype file. This file matches database type names to C struct names. This information is used at runtime to ensure that the correct database type is selected into the struct. If a type appears with a schema name in the outtype file (Pro*C/C++ intype file), the type is found in the named schema during program execution. If the type appears without a schema name, the type is found in the default schema to which the program connects, which can be different from the default schema that OTT used.</p>
<div id="LNOCI17091" class="sect3"><a id="sthref2300"></a>
<h4 class="sect3">Example: Schema_Names Usage</h4>
<p>Suppose that <code>SCHEMA_NAMES</code> is set to <code>FROM_INTYPE</code>, and the intype file reads as follows:</p>
<pre>
TYPE Person
TYPE david.Dept
TYPE sam.Company
</pre>
<p>Then the Pro*C/C++ application that uses the OTT-generated structs uses the types <code>sam.Company</code>, <code>david.Dept</code>, and <code>Person</code>. Using <code>Person</code> without a schema name refers to the <code>Person</code> type in the schema to which the application is connected.</p>
<p>If OTT and the application both connect to schema <code>david</code>, the application uses the same type (<code>david.Person</code>) that OTT used. If OTT connected to schema <code>david</code> but the application connects to schema <code>jana</code>, the application uses the type <code>jana.Person</code>. This behavior is appropriate only if the same "<code>CREATE TYPE Person</code>" statement has been executed in schema <code>david</code> and schema <code>jana</code>.</p>
<p>In contrast, the application uses type <code>david.Dept</code> regardless of to which schema the application is connected. If this is the behavior that you want, be sure to include schema names with your type names in the intype file.</p>
<p>In some cases, OTT translates a type that the user did not explicitly name. For example, consider the following SQL declarations:</p>
<pre>
CREATE TYPE Address AS OBJECT
( street    VARCHAR2(40),
  city      VARCHAR(30),
  state     CHAR(2),
  zip_code  CHAR(10) );

CREATE TYPE Person AS OBJECT
( name      CHAR(20),
  age       NUMBER,
  addr      ADDRESS );
</pre>
<p>Now suppose that OTT connects to schema <code>david</code>, <code>SCHEMA_NAMES=FROM_INTYPE</code> is specified, and the user's intype files include either TYPE <code>Person</code> or TYPE <code>david.Person</code>.</p>
<p>However, the intype file does not mention the type <code>david.Address</code>, which is used as a nested object type in type <code>david.Person</code>. If "<code>TYPE david.Person</code>" appeared in the intype file, then "<code>TYPE david.Person</code>" and "<code>TYPE david.Address</code>" appear in the outtype file. If "<code>Type Person</code>" appeared in the intype file, then "<code>TYPE Person</code>" and "<code>TYPE Address</code>" appear in the outtype file.</p>
<p>If the <code>david.Address</code> type is embedded in several types translated by OTT, but is not explicitly mentioned in the intype file, the decision of whether to use a schema name is made the first time OTT encounters the embedded <code>david.Address</code> type. If, for some reason, the user wants type <code>david.Address</code> to have a schema name but does not want type <code>Person</code> to have one, the user should explicitly specify the following in the intype file:</p>
<pre>
TYPE      david.Address
</pre>
<p>In the usual case in which each type is declared in a single schema, it is safest for the user to qualify all type names with schema names in the intype file.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i433388"></a>
<div id="LNOCI17092" class="sect2">
<h3 class="sect2">Default Name Mapping<a id="sthref2301"></a><a id="sthref2302"></a><a id="sthref2303"></a></h3>
<p>When OTT creates a C identifier name for an object type or attribute, it translates the name from the database character set to a legal C identifier. First, the name is translated from the database character set to the character set used by OTT. Next, if a translation of the resulting name is supplied in the intype file, that translation is used. Otherwise, OTT translates the name character-by-character to the compiler character set, applying the <code>CASE</code> option. The following describes this process in more detail.</p>
<p>When OTT reads the name of a database entity, the name is automatically translated from the database character set to the character set used by OTT. In order for OTT to read the name of the database entity successfully, all the characters of the name must be found in the OTT character set, although a character can have different encodings in the two character sets.</p>
<p>The easiest way to guarantee that the character set used by OTT contains all the necessary characters is to make it the same as the database character set. Note, however, that the OTT character set must be a superset of the compiler character set. That is, if the compiler character set is 7-bit ASCII, the OTT character set must include 7-bit ASCII as a subset, and if the compiler character set is 7-bit EBCDIC, the OTT character set must include 7-bit EBCDIC as a subset. The user specifies the character set that OTT uses by setting the <code>NLS_LANG</code> environment variable, or by some other operating system-specific mechanism.</p>
<p>Once OTT has read the name of a database entity, it translates the name from the character set used by OTT to the compiler's character set. If a translation of the name appears in the intype file, OTT uses that translation.</p>
<p>Otherwise, OTT attempts to translate the name by using the following steps:</p>
<ol>
<li>
<p>If the OTT character set is a multibyte character set, all multibyte characters in the name that have single-byte equivalents are converted to those single-byte equivalents.</p>
</li>
<li>
<p>The name is converted from the OTT character set to the compiler character set. The compiler character set is a single-byte character set such as US7ASCII.</p>
</li>
<li>
<p>The case of letters is set according to the <code>CASE</code> option in effect, and any character that is not legal in a C identifier, or that has no translation in the compiler character set, is replaced by an underscore. If at least one character is replaced by an underscore, OTT gives a warning message. If all the characters in a name are replaced by underscores, OTT gives an error message.</p>
</li>
</ol>
<p>Character-by-character name translation does not alter underscores, digits, or single-byte letters that appear in the compiler character set, so legal C identifiers are not altered.</p>
<p>Name translation can, for example, translate accented single-byte characters such as "o" with an umlaut or "a" with an accent grave to "o" or "a", and can translate a multibyte letter to its single-byte equivalent. Name translation typically fails if the name contains multibyte characters that lack single-byte equivalents. In this case, the user must specify name translations in the intype file.</p>
<p>OTT does not detect a naming clash caused by two or more database identifiers being mapped to the same C name, nor does it detect a naming problem where a database identifier is mapped to a C keyword.</p>
</div>
<!-- class="sect2" -->
<a id="i432220"></a>
<div id="LNOCI17093" class="sect2">
<h3 class="sect2">OTT Restriction on File Name Comparison<a id="sthref2304"></a></h3>
<p>Currently, OTT determines if two files are the same by comparing the file names provided by the user on the command line or in the intype file. But one potential problem can occur when OTT needs to know if two file names refer to the same file. For example, if the OTT-generated file <code>foo.h</code> requires a type declaration written to <code>foo1.h</code>, and another type declaration written to <code>/private/elias/foo1.h</code>, OTT should generate one <code>#include</code> directive if the two files are the same, and two <code>#includes</code> directives if the files are different. In practice, though, it would conclude that the two files are different, and would generate two <code>#includes</code> directives, as follows:</p>
<pre>
#ifndef FOO1_ORACLE
#include "foo1.h"
#endif
#ifndef FOO1_ORACLE
#include "/private/elias/foo1.h"
#endif
</pre>
<p>If <code>foo1.h</code> and <code>/private/elias/foo1.h</code> are different files, only the first one is included. If <code>foo1.h</code> and <code>/private/elias/foo1.h</code> are the same file, a redundant <code>#include</code> directive is written.</p>
<p>Therefore, if a file is mentioned several times on the command line or in the intype file, each mention of the file should use exactly the same file name.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci14oca.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci16rel.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
