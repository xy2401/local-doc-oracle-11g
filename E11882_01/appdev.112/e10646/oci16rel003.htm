<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Bind, Define, and Describe Functions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="dcterms.created" content="2014-07-18T15:18:26Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Call Interface Programmer's Guide" />
<meta name="dcterms.identifier" content="E10646-15" />
<meta name="dcterms.isVersionOf" content="LNOCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="oci16rel002.htm" title="Previous" type="text/html" />
<link rel="Next" href="oci17msc.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10646.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">26/79</span> <!-- End Header --><a id="i567777"></a>
<div id="LNOCI153" class="refsect1">
<h1 class="refsect1">Bind, Define, and Describe Functions<a id="sthref2580"></a><a id="sthref2581"></a><a id="sthref2582"></a></h1>
<p><a href="#CIHJJHGB">Table 16-4</a> lists the bind, define, and describe functions that are described in this section.</p>
<div id="LNOCI17138" class="tblformalwide">
<p class="titleintable"><a id="sthref2583"></a><a id="CIHJJHGB"></a>Table 16-4 Bind, Define, and Describe Functions&nbsp;</p>
<table class="cellalignment1011" title="Bind, Define, and Describe Functions&nbsp;" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1005">
<th class="cellalignment1012" id="r1c1-t30">Function</th>
<th class="cellalignment1012" id="r1c2-t30">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r2c1-t30" headers="r1c1-t30">
<p><a href="#i444152">"OCIBindArrayOfStruct()"</a></p>
</td>
<td class="cellalignment1013" headers="r2c1-t30 r1c2-t30">
<p>Set skip parameters for static array bind</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r3c1-t30" headers="r1c1-t30">
<p><a href="#i456223">"OCIBindByName()"</a></p>
</td>
<td class="cellalignment1013" headers="r3c1-t30 r1c2-t30">
<p>Bind by name</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r4c1-t30" headers="r1c1-t30">
<p><a href="#i456224">"OCIBindByPos()"</a></p>
</td>
<td class="cellalignment1013" headers="r4c1-t30 r1c2-t30">
<p>Bind by position</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r5c1-t30" headers="r1c1-t30">
<p><a href="#i444015">"OCIBindDynamic()"</a></p>
</td>
<td class="cellalignment1013" headers="r5c1-t30 r1c2-t30">
<p>Set additional attributes after bind with <code>OCI_DATA_AT_EXEC</code> mode</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r6c1-t30" headers="r1c1-t30">
<p><a href="#i444090">"OCIBindObject()"</a></p>
</td>
<td class="cellalignment1013" headers="r6c1-t30 r1c2-t30">
<p>Set additional attributes for bind of named data type</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r7c1-t30" headers="r1c1-t30">
<p><a href="#i498627">"OCIDefineArrayOfStruct()"</a></p>
</td>
<td class="cellalignment1013" headers="r7c1-t30 r1c2-t30">
<p>Set additional attributes for static array define</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r8c1-t30" headers="r1c1-t30">
<p><a href="#i459315">"OCIDefineByPos()"</a></p>
</td>
<td class="cellalignment1013" headers="r8c1-t30 r1c2-t30">
<p>Define an output variable association</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r9c1-t30" headers="r1c1-t30">
<p><a href="#i444226">"OCIDefineDynamic()"</a></p>
</td>
<td class="cellalignment1013" headers="r9c1-t30 r1c2-t30">
<p>Set additional attributes for define in <code>OCI_DYNAMIC_FETCH</code> mode</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r10c1-t30" headers="r1c1-t30">
<p><a href="#i555538">"OCIDefineObject()"</a></p>
</td>
<td class="cellalignment1013" headers="r10c1-t30 r1c2-t30">
<p>Set additional attributes for define of named data type</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r11c1-t30" headers="r1c1-t30">
<p><a href="#i455723">"OCIDescribeAny()"</a></p>
</td>
<td class="cellalignment1013" headers="r11c1-t30 r1c2-t30">
<p>Describe existing schema objects</p>
</td>
</tr>
<tr class="cellalignment1005">
<td class="cellalignment1013" id="r12c1-t30" headers="r1c1-t30">
<p><a href="#i541225">"OCIStmtGetBindInfo()"</a></p>
</td>
<td class="cellalignment1013" headers="r12c1-t30 r1c2-t30">
<p>Get bind and indicator variable names and handle</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<div id="LNOCI17139" class="refsect2"><a id="i444152"></a>
<h2 class="refsect2">OCIBindArrayOfStruct()<a id="sthref2584"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2585"></a>Purpose</p>
<p>Sets up the skip parameters for a static array bind.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2586"></a>Syntax</p>
<pre>
sword OCIBindArrayOfStruct ( OCIBind     *bindp,
                             OCIError    *errhp,
                             ub4         pvskip, 
                             ub4         indskip, 
                             ub4         alskip, 
                             ub4         rcskip );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2587"></a>Parameters</p>
<dl>
<dt><span class="bold">bindp</span> (IN/OUT)</dt>
<dd>
<p>The handle to a bind structure.</p>
</dd>
<dt><span class="bold">errhp</span> (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <code>OCIErrorGet()</code> for diagnostic information when there is an error.</p>
</dd>
<dt><span class="bold">pvskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next data value.</p>
</dd>
<dt><span class="bold">indskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next indicator value or structure.</p>
</dd>
<dt><span class="bold">alskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next actual length value.</p>
</dd>
<dt><span class="bold">rcskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next column-level return code value.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2588"></a>Comments</p>
<p>This call sets up the skip parameters necessary for a static array bind. It follows a call to <code><a href="#i456223">OCIBindByName()</a></code> or <code><a href="#i456224">OCIBindByPos()</a></code>. The bind handle returned by that initial bind call is used as a parameter for the <code>OCIBindArrayOfStruct()</code> call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i421503">"Binding and Defining Arrays of Structures in OCI"</a> for information about skip parameters</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2589"></a>Related Functions</p>
<p><a href="#i456223">OCIBindByName()</a>, <a href="#i456224">OCIBindByPos()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17140" class="refsect2"><a id="i456223"></a>
<h2 class="refsect2">OCIBindByName()<a id="sthref2590"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2591"></a>Purpose</p>
<p>Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2592"></a>Syntax</p>
<pre>
sword OCIBindByName ( OCIStmt       *stmtp, 
                      OCIBind       **bindpp,
                      OCIError      *errhp,
                      const OraText *placeholder,
                      sb4           placeh_len,
                      void          *valuep,
                      sb4           value_sz,
                      ub2           dty,
                      void          *indp,
                      ub2           *alenp,
                      ub2           *rcodep,
                      ub4           maxarr_len,
                      ub4           *curelep, 
                      ub4           mode ); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2593"></a>Parameters</p>
<dl>
<dt>stmtp (IN/OUT)</dt>
<dd>
<p>The statement handle to the SQL or PL/SQL statement being processed.</p>
</dd>
<dt>bindpp (IN/OUT)</dt>
<dd>
<p>A pointer to save the pointer of a bind handle that is implicitly allocated by this call. The bind handle maintains all the bind information for this particular input value. The default encoding for the call depends on the <code>UTF-16</code> setting in <code>stmtp</code> unless the <code>mode</code> parameter has a different value. The handle is freed implicitly when the statement handle is deallocated. On input, the value of the pointer must be <code>NULL</code> or a valid bind handle.</p>
</dd>
<dt>errhp (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt>placeholder (IN)</dt>
<dd>
<p>The placeholder, specified by its name, that maps to a variable in the statement associated with the statement handle. The encoding of <code>placeholder</code> should always be consistent with that of the environment. That is, if the statement is prepared in <code>UTF-16</code>, so is the placeholder. As a string type parameter, the placeholder should be cast as <code>(text *)</code> and terminated with <code>NULL</code>.</p>
</dd>
<dt>placeh_len (IN)</dt>
<dd>
<p>The length of the name specified in <code>placeholder</code>, in number of bytes regardless of the encoding.</p>
</dd>
<dt>valuep (IN/OUT)</dt>
<dd>
<p>The pointer to a data value or an array of data values of type specified in the <code>dty</code> parameter. This data could be a <code>UTF-16</code> (formerly known as UCS-2) string, if an <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> function has been called to set <code>OCI_ATTR_CHARSET_ID</code> as <code>OCI_UTF16ID</code> or the deprecated <code>OCI_UCS2ID</code>. <code>OCI_UTF16ID</code> is the new designation for <code>OCI_UCS2ID</code>.</p>
<p>Furthermore, as pointed out for <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a>, the default encoding for the string type <code>valuep</code> is in the encoding specified by the <code>charset</code> parameter of a previous call to <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a>, unless users call <a href="oci16rel002.htm#i443804">OCIAttrSet()</a> to manually reset the character set for the bind handle.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i430016">"Bind Handle Attributes"</a></div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<p>An array of data values can be specified for mapping into a PL/SQL table or for providing data for SQL multiple-row operations. When an array of bind values is provided, this is called an array bind in OCI terms.</p>
<p>For <code>SQLT_NTY</code> or <code>SQLT_REF</code> binds, the <code>valuep</code> parameter is ignored. The pointers to OUT buffers are set in the <code>pgvpp</code> parameter initialized by <code>OCIBindObject()</code>.</p>
<p>When <code>mode</code> is set to <code>OCI_IOV</code>, pass the base address of the <code>OCIIOV</code> struct.</p>
<dl>
<dt>value_sz (IN)</dt>
<dd>
<p>The maximum size possible in bytes of any data value (passed using <code>valuep</code>) for this bind variable. This size is always expected to be the size in bytes. In the case of an array bind, this is the maximum size of any element possible with the actual sizes being specified in the <code>alenp</code> parameter.</p>
<p>For descriptors, locators, or REFs, whose size is unknown to client applications, use the size of the pointer to the specific type; for example, <code>sizeof</code> (<code>OCILobLocator *</code>).</p>
<p>The same applies even when mode is <code>OCI_IOV</code>.</p>
</dd>
<dt>dty (IN)</dt>
<dd>
<p>The data type of the values being bound. Named data types (<code>SQLT_NTY</code>) and <code>REF</code>s (<code>SQLT_REF</code>) are valid only if the application has been initialized in object mode. For named data types or <code>REF</code>s, additional calls must be made with the bind handle to set up the data type-specific attributes.</p>
</dd>
<dt>indp (IN/OUT)</dt>
<dd>
<p>Pointer to an indicator variable or array. For all data types except <code>SQLT_NTY</code>, this is a pointer to <code>sb2</code> or an array of <code>sb2</code>.</p>
<p>For <code>SQLT_NTY</code>, this pointer is ignored, and the actual pointer to the indicator structure or an array of indicator structures is initialized in a subsequent call to <code>OCIBindObject()</code>. This parameter is ignored for dynamic binds.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#i462559">"Indicator Variables"</a></div>
</dd>
</dl>
<dl>
<dt>alenp (IN/OUT)</dt>
<dd>
<p>Pointer to the array of actual lengths of array elements.</p>
<p>When <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> (which is the recommended OCI environment handle creation interface) is used, then <code>alenp</code> lengths are consistently expected in bytes (for IN binds) and reported in bytes for OUT binds. The same treatment consistently also holds for the length prefix in <code>SQLT_VCS</code> (2-byte length prefix) and <code>SQLT_LVC</code> (4-byte length prefix) types. There are no special exceptions for UCS2 or for NCHAR cases.</p>
<p>When the older OCI environment handle creation interfaces are used (either <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a>) or deprecated <a href="ociaedep001.htm#BEIGIBFB">OCIEnvInit()</a>), <code>alenp</code> lengths are in bytes in general. However, <code>alenp</code> lengths are expected in characters for IN binds and also reported in characters for OUT binds only when either the character set is OCI_UC2ID (= OCI_UTF16ID) or when <code>OCI_ATTR_CHAR_COUNT</code> attribute is set on the corresponding OCIBind handle. The same treatment holds for the length prefix in <code>SQLT_VCS</code> (2-byte length prefix) and <code>SQLT_LVC</code> (4-byte length prefix) types.</p>
<p>This parameter is ignored for dynamic binds.</p>
</dd>
<dt>rcodep (OUT)</dt>
<dd>
<p>Pointer to the array of column-level return codes. This parameter is ignored for dynamic binds.</p>
</dd>
<dt>maxarr_len (IN)</dt>
<dd>
<p>A maximum array length parameter (the maximum possible number of elements the user's array can accommodate). Used only for PL/SQL indexed table bindings.</p>
</dd>
<dt>curelep (IN/OUT)</dt>
<dd>
<p>Current array length parameter (a pointer to the actual number of elements in the array before or after the execute operation). Used only for PL/SQL indexed table bindings.</p>
</dd>
<dt>mode (IN)</dt>
<dd>
<p>To maintain coding consistency, theoretically this parameter can take all three possible values used by <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a>. Because the encoding of bind variables should always be same as that of the statement containing this variable, an error is raised if the user specifies an encoding other than that of the statement. So the recommended setting for <code>mode</code> is <code>OCI_DEFAULT</code>, which makes the bind variable have the same encoding as its statement.</p>
<p>The valid modes are:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_DEFAULT</code> - The default mode. The statement handle that <code>stmtp</code> uses whatever is specified by its parent environment handle.</p>
</li>
<li>
<p><a id="sthref2594"></a><code>OCI_BIND_SOFT</code> - Soft bind mode. This mode increases the performance of the call. If this is the first bind or some input value like <code>dty</code> or <code>value_sz</code> is changed from the previous bind, this mode is ignored. An error is returned if the statement is not executed. Unexpected behavior results if the bind handle passed is not valid.</p>
</li>
<li>
<p><a id="sthref2595"></a><code>OCI_DATA_AT_EXEC</code> - When this mode is selected, the <code>value_sz</code> parameter defines the maximum size of the data that can be provided at run time. The application must be ready to provide the OCI library runtime IN data buffers at any time and any number of times. Runtime data is provided in one of these two ways:</p>
<ul>
<li>
<p>Callbacks using a user-defined function that must be registered with a subsequent call to <code>OCIBindDynamic()</code>.</p>
</li>
<li>
<p>A polling mechanism using calls supplied by the OCI. This mode is assumed if no callbacks are defined.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about using the <code>OCI_DATA_AT_EXEC</code> mode</div>
</li>
</ul>
<p>When <code>mode</code> is set to <code>OCI_DATA_AT_EXEC</code>, do not provide values for <code>valuep</code>, <code>indp</code>, <code>alenp</code>, and <code>rcodep</code> in the main call. Pass zeros (0) for <code>indp</code> and <code>alenp</code>. Provide the values through the callback function registered using <code>OCIBindDynamic()</code>.</p>
</li>
<li>
<p><code>OCI_IOV</code> - Bind noncontiguous addresses of data. The <code>valuep</code> parameter must be of the type <code>OCIIOV</code> *.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#BABGDJDD">"Binding and Defining Multiple Buffers"</a></div>
</li>
</ul>
<p>When the allocated buffers are not required anymore, they should be freed by the client.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2596"></a>Comments</p>
<p>This call is used to perform a basic bind operation. The bind creates an association between the address of a program variable and a placeholder in a SQL statement or PL/SQL block. The bind call also specifies the type of data that is being bound, and may also indicate the method by which data is provided at run time.</p>
<p>Encoding is determined by either the bind handle using the setting in the statement handle as default, or you can override the setting by specifying the <code>mode</code> parameter explicitly.</p>
<p>The <code>OCIBindByName()</code> also implicitly allocates the bind handle indicated by the <code>bindpp</code> parameter. If a non-<code>NULL</code> pointer is passed in <code>**bindpp</code>, the OCI assumes that this points to a valid handle that has been previously allocated with a call to <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> or <code>OCIBindByName()</code>.</p>
<p>Data in an OCI application can be bound to placeholders statically or dynamically. Binding is <span class="italic">static</span> when all the IN bind data and the OUT bind buffers are well defined just before the execute. Binding is <span class="italic">dynamic</span> when the IN bind data and the OUT bind buffers are provided by the application on demand at execute time to the client library. Dynamic binding is indicated by setting the <code>mode</code> parameter of this call to <code>OCI_DATA_AT_EXEC</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about dynamic binding</div>
</div>
<!-- class="refsubsect" -->
<p>Both <code>OCIBindByName()</code> and <a href="#i456224">OCIBindByPos()</a> take as a parameter a bind handle, which is implicitly allocated by the bind call A separate bind handle is allocated for each placeholder the application is binding.</p>
<p>Additional bind calls may be required to specify particular attributes necessary when binding certain data types or handling input data in certain ways:</p>
<ul>
<li>
<p>If arrays of structures are being used, <a href="#i444152">OCIBindArrayOfStruct()</a> must be called to set up the necessary skip parameters.</p>
</li>
<li>
<p>If data is being provided dynamically at run time, and the application uses user-defined callback functions, <a href="#i444015">OCIBindDynamic()</a> must be called to register the callbacks.</p>
</li>
<li>
<p>If lengths in <code>alenp</code> greater than 64 Kilobytes (KB) are required, use <code>OCIBindDynamic()</code>.</p>
</li>
<li>
<p>If a named data type is being bound, <a href="#i444090">OCIBindObject()</a> must be called to specify additional necessary information.</p>
</li>
<li>
<p>If a statement with the <code>RETURNING</code> clause is used, a call to <code>OCIBindDynamic()</code> must follow this call.</p>
</li>
</ul>
<p>With IN binds, the values for each element of the array, the actual lengths of each element, and the actual array length must be set up before the call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>.</p>
<p>With OUT binds, the values for each element of the array, the actual lengths of each element, and the actual array length are returned from the server after the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2597"></a>Related Functions</p>
<p><a href="#i444015">OCIBindDynamic()</a>, <a href="#i444090">OCIBindObject()</a>, <a href="#i444152">OCIBindArrayOfStruct()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17141" class="refsect2"><a id="i456224"></a>
<h2 class="refsect2">OCIBindByPos()<a id="sthref2598"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2599"></a>Purpose</p>
<p>Creates an association between a program variable and a placeholder in a SQL statement or PL/SQL block.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2600"></a>Syntax</p>
<pre>
sword OCIBindByPos ( OCIStmt      *stmtp, 
                     OCIBind      **bindpp,
                     OCIError     *errhp,
                     ub4          position,
                     void         *valuep,
                     sb4          value_sz,
                     ub2          dty,
                     void         *indp,
                     ub2          *alenp,
                     ub2          *rcodep,
                     ub4          maxarr_len,
                     ub4          *curelep, 
                     ub4          mode );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2601"></a>Parameters</p>
<dl>
<dt>stmtp (IN/OUT)</dt>
<dd>
<p>The statement handle to the SQL or PL/SQL statement being processed.</p>
</dd>
<dt>bindpp (IN/OUT)</dt>
<dd>
<p>An address of a bind handle that is implicitly allocated by this call. The bind handle maintains all the bind information for this particular input value. The handle is freed implicitly when the statement handle is deallocated. On input, the value of the pointer must be <code>NULL</code> or a valid bind handle.</p>
</dd>
<dt>errhp (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt>position (IN)</dt>
<dd>
<p>The placeholder attributes are specified by position if <code>OCIBindByPos()</code> is being called.</p>
</dd>
<dt>valuep (IN/OUT)</dt>
<dd>
<p>An address of a data value or an array of data values of the type specified in the <code>dty</code> parameter. An array of data values can be specified for mapping into a PL/SQL table or for providing data for SQL multiple-row operations. When an array of bind values is provided, this is called an array bind in OCI terms.</p>
<p>For a LOB, the buffer pointer must be a pointer to a LOB locator of type <code>OCILobLocator</code>. Give the address of the pointer.</p>
<p>For SQLT_NTY or SQLT_REF binds, the <code>valuep</code> parameter is ignored. The pointers to OUT buffers are set in the <code>pgvpp</code> parameter initialized by <code>OCIBindObject()</code>.</p>
<p>If the <code>OCI_ATTR_CHARSET_ID</code> attribute is set to <code>OCI_UTF16ID</code> (replaces the deprecated <code>OCI_UCS2ID</code>, which is retained for backward compatibility), all data passed to and received with the corresponding bind call is assumed to be in <code>UTF-16</code> encoding.</p>
<p>When <code>mode</code> is set to <code>OCI_IOV</code>, pass the base address of the <code>OCIIOV</code> struct.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i430016">"Bind Handle Attributes"</a></div>
</dd>
<dt>value_sz (IN)</dt>
<dd>
<p>The maximum size possible in bytes of any data value (passed using <code>valuep</code>) for this bind variable. This size is always expected to be the size in bytes. In the case of an array bind, this is the maximum size of any element possible with the actual sizes being specified in the <code>alenp</code> parameter.</p>
<p>For descriptors, locators, or <code>REF</code>s, whose size is unknown to client applications, use the size of the pointer to the specific type; for example, <code>sizeof</code> (<code>OCILobLocator *</code>).</p>
<p>The same applies even when mode is <code>OCI_IOV</code>.</p>
</dd>
<dt>dty (IN)</dt>
<dd>
<p>The data type of the values being bound. Named data types (SQLT_NTY) and <code>REF</code>s (SQLT_REF) are valid only if the application has been initialized in object mode. For named data types or <code>REF</code>s, additional calls must be made with the bind handle to set up the attributes specific to the data type.</p>
</dd>
<dt>indp (IN/OUT)</dt>
<dd>
<p>Pointer to an indicator variable or array. For all data types, this is a pointer to <code>sb2</code> or an array of <code>sb2</code> values. The only exception is SQLT_NTY, where this pointer is ignored and the actual pointer to the indicator structure or an array of indicator structures is initialized by <code>OCIBindObject()</code>. The <code>indp</code> parameter is ignored for dynamic binds. If <code>valuep</code> is an <code>OUT</code> parameter, then you must set <code>indp</code> to point to <code><a id="sthref2602"></a>OCI_IND_NULL</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#i462559">"Indicator Variables"</a></div>
</dd>
<dt>alenp (IN/OUT)</dt>
<dd>
<p>Pointer to an array of actual lengths of array elements.</p>
<p>When <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> (which is the recommended OCI environment handle creation interface) is used, then <code>alenp</code> lengths are consistently expected in bytes (for IN binds) and reported in bytes for OUT binds. The same treatment consistently also holds for the length prefix in <code>SQLT_VCS</code> (2-byte length prefix) and <code>SQLT_LVC</code> (4-byte length prefix) types. There are no special exceptions for UCS2 or for NCHAR cases.</p>
<p>When the older OCI environment handle creation interfaces are used (either <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or deprecated <a href="ociaedep001.htm#BEIGIBFB">OCIEnvInit()</a>), <code>alenp</code> lengths are in bytes in general. However, <code>alenp</code> lengths are expected in characters for IN binds and also reported in characters for OUT binds only when either the character set is OCI_UC2ID (= OCI_UTF16ID) or when <code>OCI_ATTR_CHAR_COUNT</code> attribute is set on the corresponding OCIBind handle. The same treatment holds for the length prefix in <code>SQLT_VCS</code> (2-byte length prefix) and <code>SQLT_LVC</code> (4-byte length prefix) types.</p>
<p>This parameter is ignored for dynamic binds.</p>
</dd>
<dt>rcodep (OUT)</dt>
<dd>
<p>Pointer to an array of column-level return codes. This parameter is ignored for dynamic binds.</p>
</dd>
<dt>maxarr_len (IN)</dt>
<dd>
<p>A maximum array length parameter (the maximum possible number of elements that the user's array can accommodate). Used only for PL/SQL indexed table bindings.</p>
</dd>
<dt>curelep (IN/OUT)</dt>
<dd>
<p>Current array length parameter (a pointer to the actual number of elements in the array before or after the execute operation). Used only for PL/SQL indexed table bindings.</p>
</dd>
<dt>mode (IN)</dt>
<dd>
<p>The valid modes for this parameter are:</p>
<ul>
<li>
<p><code>OCI_DEFAULT</code> - This is default mode.</p>
</li>
<li>
<p><a id="sthref2603"></a><code>OCI_BIND_SOFT</code> - Soft bind mode. This mode increases the performance of the call. If this is the first bind or some input value like <code>dty</code> or <code>value_sz</code> is changed from the previous bind, this mode is ignored. An error is returned if the statement is not executed. Unexpected behavior results if the bind handle passed is not valid.</p>
</li>
<li>
<p><a id="sthref2604"></a><code>OCI_DATA_AT_EXEC</code> - When this mode is selected, the <code>value_sz</code> parameter defines the maximum size of the data that can be provided at run time. The application must be ready to provide the OCI library runtime IN data buffers at any time and any number of times. Runtime data is provided in one of the following ways:</p>
<ul>
<li>
<p>Callbacks using a user-defined function that must be registered with a subsequent call to <code>OCIBindDynamic()</code>.</p>
</li>
<li>
<p>A polling mechanism using calls supplied by OCI. This mode is assumed if no callbacks are defined.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about using the <code>OCI_DATA_AT_EXEC</code> mode</div>
<p>When <code>mode</code> is set to <code>OCI_DATA_AT_EXEC</code>, do not provide values for <code>valuep</code>, <code>indp</code>, <code>alenp</code>, and <code>rcodep</code> in the main call. Pass zeros (0) for <code>indp</code> and <code>alenp</code>. Provide the values through the callback function registered using <code>OCIBindDynamic()</code>.</p>
</li>
</ul>
</li>
<li>
<p><code><a id="sthref2605"></a>OCI_IOV</code> - Bind noncontiguous addresses of data. The <code>valuep</code> parameter must be of the type <code>OCIIOV</code> *.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#BABGDJDD">"Binding and Defining Multiple Buffers"</a></div>
</li>
</ul>
</dd>
</dl>
<p>When the allocated buffers are not required anymore, they should be freed by the client.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2606"></a>Comments</p>
<p>This call is used to perform a basic bind operation. The bind creates an association between the address of a program variable and a placeholder in a SQL statement or PL/SQL block. The bind call also specifies the type of data that is being bound, and may also indicate the method by which data is to be provided at run time.</p>
<p>This function also implicitly allocates the bind handle indicated by the <code>bindpp</code> parameter. If a non-<code>NULL</code> pointer is passed in <code>**bindpp</code>, OCI assumes that this points to a valid handle that has been previously allocated with a call to <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> or <code>OCIBindByPos()</code>.</p>
<p>Data in an OCI application can be bound to placeholders statically or dynamically. Binding is <span class="italic">static</span> when all the IN bind data and the OUT bind buffers are well defined just before the execute operation. Binding is <span class="italic">dynamic</span> when the IN bind data and the OUT bind buffers are provided by the application on demand at execute time to the client library. Dynamic binding is indicated by setting the <code>mode</code> parameter of this call to <code>OCI_DATA_AT_EXEC</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about dynamic binding</div>
<p>Both <a href="#i456223">OCIBindByName()</a> and <code>OCIBindByPos()</code> take as a parameter a bind handle, which is implicitly allocated by the bind call A separate bind handle is allocated for each placeholder the application is binding.</p>
<p>Additional bind calls may be required to specify particular attributes necessary when binding certain data types or handling input data in certain ways:</p>
<ul>
<li>
<p>If arrays of structures are being used, <a href="#i444152">OCIBindArrayOfStruct()</a> must be called to set up the necessary skip parameters.</p>
</li>
<li>
<p>If data is being provided dynamically at run time, and the application uses user-defined callback functions, <a href="#i444015">OCIBindDynamic()</a> must be called to register the callbacks.</p>
</li>
<li>
<p>If lengths in <code>alenp</code> greater than 64 KB are required, use <code>OCIBindDynamic()</code>.</p>
</li>
<li>
<p>If a named data type is being bound, <a href="#i444090">OCIBindObject()</a> must be called to specify additional necessary information.</p>
</li>
<li>
<p>If a statement with the <code>RETURNING</code> clause is used, a call to <a href="#i444015">OCIBindDynamic()</a> must follow this call.</p>
</li>
</ul>
<p>With IN binds, the values for each element of the array, the actual lengths of each element, and the actual array length must be set up before the call to <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a>.</p>
<p>With OUT binds, the values for each element of the array, the actual lengths of each element, and the actual array length are returned from the server after the <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> call.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2607"></a>Related Functions</p>
<p><a href="#i444015">OCIBindDynamic()</a>, <a href="#i444090">OCIBindObject()</a>, <a href="#i444152">OCIBindArrayOfStruct()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17142" class="refsect2"><a id="i444015"></a>
<h2 class="refsect2">OCIBindDynamic()<a id="sthref2608"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2609"></a>Purpose</p>
<p>Registers user callbacks for dynamic data allocation.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2610"></a>Syntax</p>
<pre>
sword OCIBindDynamic ( OCIBind     *bindp,
                       OCIError    *errhp,
                       void        *ictxp, 
                       OCICallbackInBind         (icbfp)(
                                void             *ictxp,
                                OCIBind          *bindp,
                                ub4              iter, 
                                ub4              index, 
                                void             **bufpp,
                                ub4              *alenp,
                                ub1              *piecep, 
                                void             **indpp ),
                                void             *octxp,
                       OCICallbackOutBind        (ocbfp)(
                                void             *octxp,
                                OCIBind          *bindp,
                                ub4              iter, 
                                ub4              index, 
                                void             **bufpp, 
                                ub4              **alenpp,
                                ub1              *piecep,
                                void             **indpp, 
                                ub2              **rcodepp ) );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2611"></a>Parameters</p>
<dl>
<dt>bindp (IN/OUT)</dt>
<dd>
<p>A bind handle returned by a call to <a href="#i456223">OCIBindByName()</a> or <a href="#i456224">OCIBindByPos()</a>.</p>
</dd>
<dt>errhp (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt>ictxp (IN)</dt>
<dd>
<p>The context pointer required by the callback function <code>icbfp</code>.</p>
</dd>
<dt>icbfp (IN)</dt>
<dd>
<p>The callback function that returns a pointer to the IN bind value or piece at run time. The callback takes in the following parameters:</p>
</dd>
<dt>ictxp (IN/OUT)</dt>
<dd>
<p>The context pointer for this callback function.</p>
</dd>
<dt>bindp (IN)</dt>
<dd>
<p>The bind handle passed in to uniquely identify this bind variable.</p>
</dd>
<dt>iter (IN)</dt>
<dd>
<p>A 0-based execute iteration value.</p>
</dd>
<dt>index (IN)</dt>
<dd>
<p>Index of the current array, for an array bind in PL/SQL. For SQL it is the row index. The value is 0-based and not greater than the <code>curelep</code> parameter of the bind call.</p>
</dd>
<dt>bufpp (OUT)</dt>
<dd>
<p>The pointer to the buffer or storage. For descriptors, <code>*bufpp</code> contains a pointer to the descriptor. For example, if you define the following parameter, then you set <code>*bufpp</code> to <code>lobp</code>, not <code>*lobp</code>.</p>
<pre>
OCILobLocator    *lobp;
</pre>
<p>For <code>REF</code>s, pass the address of the ref; that is, pass <code>&amp;my_ref</code> for <code>*bufpp</code>.</p>
<p>If the <code>OCI_ATTR_CHARSET_ID</code> attribute is set to <code>OCI_UTF16ID</code> (replaces the deprecated <code>OCI_UCS2ID</code>, which is retained for backward compatibility), all data passed to and received with the corresponding bind call is assumed to be in <code>UTF-16</code> encoding.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i430016">"Bind Handle Attributes"</a></div>
</dd>
<dt>alenp (OUT)</dt>
<dd>
<p>A pointer to storage for OCI to fill in the size of the bind value or piece after it has been read. For descriptors, pass the size of the pointer to the descriptor; for example, <code>sizeof(OCILobLocator *)</code>.</p>
</dd>
<dt>piecep (OUT)</dt>
<dd>
<p>A piece of the bind value. This can be one of the following values: <code>OCI_ONE_PIECE</code>, <code>OCI_FIRST_PIECE</code>, <code>OCI_NEXT_PIECE</code>, and <code>OCI_LAST_PIECE</code>. For data types that do not support piecewise operations, you must pass <code>OCI_ONE_PIECE</code> or an error is generated.</p>
</dd>
<dt>indpp (OUT)</dt>
<dd>
<p>Contains the indicator value. This is either a pointer to an sb2 value or a pointer to an indicator structure for binding named data types.</p>
</dd>
<dt>octxp (IN)</dt>
<dd>
<p>The context pointer required by the callback function <code>ocbfp()</code>.</p>
</dd>
<dt>ocbfp (IN)</dt>
<dd>
<p>The callback function that returns a pointer to the OUT bind value or piece at run time. The callback takes in the following parameters:</p>
</dd>
<dt>octxp (IN/OUT)</dt>
<dd>
<p>The context pointer for this callback function.</p>
</dd>
<dt>bindp (IN)</dt>
<dd>
<p>The bind handle passed in to uniquely identify this bind variable.</p>
</dd>
<dt>iter (IN)</dt>
<dd>
<p>A 0-based execute iteration value.</p>
</dd>
<dt>index (IN)</dt>
<dd>
<p>For PL/SQL, the index of the current array for an array bind. For SQL, the index is the row number in the current iteration. It is 0-based, and must not be greater than the <code>curelep</code> parameter of the bind call.</p>
</dd>
<dt>bufpp (OUT)</dt>
<dd>
<p>A pointer to a buffer to write the bind value or piece in.</p>
<p>If the <code>OCI_ATTR_CHARSET_ID</code> attribute is set to <code>OCI_UTF16ID</code> (replaces the deprecated <code>OCI_UCS2ID</code>, which is retained for backward compatibility), all data passed to and received with the corresponding bind call is assumed to be in <code>UTF-16</code> encoding. For more information, see <a href="ociaahan.htm#i430016">"Bind Handle Attributes"</a>.</p>
</dd>
<dt>alenpp (IN/OUT)</dt>
<dd>
<p>A pointer to storage for OCI to fill in the size of the bind value or piece after it has been read. It is in bytes except for Unicode encoding (if the <code>OCI_ATTR_CHARSET_ID</code> attribute is set to <code>OCI_UTF16ID</code>), when it is in code points.</p>
</dd>
<dt>piecep (IN/OUT)</dt>
<dd>
<p>Returns a piece value from the callback (application) to the Oracle Database, as follows:</p>
<ul>
<li>
<p><code>IN</code> - The value can be <code>OCI_ONE_PIECE</code> or <code>OCI_NEXT_PIECE</code>.</p>
</li>
<li>
<p><code>OUT</code> - Depends on the IN value:</p>
<ul>
<li>
<p>If IN value is <code>OCI_ONE_PIECE</code>, then OUT value can be <code>OCI_ONE_PIECE</code> or <code>OCI_FIRST_PIECE</code>.</p>
</li>
<li>
<p>If IN value is <code>OCI_NEXT_PIECE</code>, then OUT value can be <code>OCI_NEXT_PIECE</code> or <code>OCI_LAST_PIECE</code>.</p>
</li>
</ul>
</li>
</ul>
</dd>
<dt>indpp (OUT)</dt>
<dd>
<p>Contains the indicator value. This is either a pointer to an <code>sb2</code> value, or a pointer to an indicator structure for binding named data types.</p>
</dd>
<dt>rcodepp (OUT)</dt>
<dd>
<p>Returns a pointer to the return code.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2612"></a>Comments</p>
<p>This call is used to register user-defined callback functions for providing or receiving data if <code>OCI_DATA_AT_EXEC</code> mode was specified in a previous call to <code>OCIBindByName()</code> or <code>OCIBindByPos()</code>.</p>
<p>The callback function pointers must return <code>OCI_CONTINUE</code> if the call is successful. Any return code other than <code>OCI_CONTINUE</code> signals that the client wants to terminate processing immediately.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about the <code>OCI_DATA_AT_EXEC</code> mode</div>
</div>
<!-- class="refsubsect" -->
<p>When passing the address of a storage area, ensure that the storage area exists even after the application returns from the callback. This means that you should not allocate such storage on the stack.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
After you use <code>OCIEnvNlsCreate()</code> to create the environment handle, the actual lengths and returned lengths of bind and define handles are always in number of bytes.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2613"></a>Related Functions</p>
<p><a href="#i456223">OCIBindByName()</a>, <a href="#i456224">OCIBindByPos()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17143" class="refsect2"><a id="i444090"></a>
<h2 class="refsect2">OCIBindObject()<a id="sthref2614"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2615"></a>Purpose</p>
<p>Sets up additional attributes that are required for a named data type (object) bind.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2616"></a>Syntax</p>
<pre>
sword OCIBindObject ( OCIBind          *bindp,
                      OCIError         *errhp, 
                      const OCIType    *type,
                      void             **pgvpp, 
                      ub4              *pvszsp, 
                      void             **indpp, 
                      ub4              *indszp, );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2617"></a>Parameters</p>
<dl>
<dt><span class="bold">bindp</span> (IN/OUT)</dt>
<dd>
<p>The bind handle returned by the call to <a href="#i456223">OCIBindByName()</a> or <a href="#i456224">OCIBindByPos()</a>.</p>
</dd>
<dt><span class="bold">errhp</span> (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt><span class="bold">type</span> (IN)</dt>
<dd>
<p>Points to the TDO that describes the type of program variable being bound. Retrieved by calling <code>OCITypeByName()</code>. Optional for <code>REF</code>s in SQL, but required for <code>REF</code>s in PL/SQL.</p>
</dd>
<dt><span class="bold">pgvpp</span> (IN/OUT)</dt>
<dd>
<p>Address of the program variable buffer. For an array, <code>pgvpp</code> points to an array of addresses. When the bind variable is also an OUT variable, the OUT named data type value or <code>REF</code> is allocated in the Object Cache, and a <code>REF</code> is returned.</p>
<p><code>pgvpp</code> is ignored if the <code>OCI_DATA_AT_EXEC</code> mode is set. Then the named data type buffers are requested at run time. For static array binds, skip factors may be specified using the <a href="#i444152">OCIBindArrayOfStruct()</a> call. The skip factors are used to compute the address of the next pointer to the value, the indicator structure, and their sizes.</p>
</dd>
<dt><span class="bold">pvszsp</span> (OUT) [optional]</dt>
<dd>
<p>Points to the size of the program variable. The size of the named data type is not required on input. For an array, <code>pvszsp</code> is an array of <code>ub4</code>s. On return, for OUT bind variables, this points to sizes of the named data types and <code>REF</code>s received. <code>pvszsp</code> is ignored if the <code>OCI_DATA_AT_EXEC</code> mode is set. Then the size of the buffer is taken at run time.</p>
</dd>
<dt><span class="bold">indpp</span> (IN/OUT) [optional]</dt>
<dd>
<p>Address of the program variable buffer containing the parallel indicator structure. For an array, <code>indpp</code> points to an array of pointers. When the bind variable is also an OUT bind variable, memory is allocated in the object cache, to store the OUT indicator values. At the end of the execute operation when all OUT values have been received, <code>indpp</code> points to the pointers of these newly allocated indicator structures. Required only for SQLT_NTY binds. The <code>indpp</code> parameter is ignored if the <code>OCI_DATA_AT_EXEC</code> mode is set. Then the indicator is requested at run time.</p>
</dd>
<dt><span class="bold">indszp</span> (IN/OUT)</dt>
<dd>
<p>Points to the size of the IN indicator structure program variable. For an array, it is an array of <code>sb2</code>s. On return for OUT bind variables, this points to sizes of the received OUT indicator structures. <code>indszp</code> is ignored if the <code>OCI_DATA_AT_EXEC</code> mode is set. Then the indicator size is requested at run time.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2618"></a>Comments</p>
<p>This function sets up additional attributes for binding a named data type or a <code>REF</code>. An error is returned if this function is called when the OCI environment has been initialized in non-object mode.</p>
<p>This call takes as a parameter a type descriptor object (TDO) of data type <code>OCIType</code> for the named data type being defined. The TDO can be retrieved with a call to <a href="oci18nav006.htm#i455564">OCITypeByName()</a>.</p>
<p>If the <code>OCI_DATA_AT_EXEC</code> mode was specified in <a href="#i456223">OCIBindByName()</a> or <a href="#i456224">OCIBindByPos()</a>, the pointers to the IN buffers are obtained either using the callback <code>icbfp</code> registered in the <a href="#i444015">OCIBindDynamic()</a> call or by the <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> call.</p>
<p>The buffers are dynamically allocated for the OUT data. The pointers to these buffers are returned either by:</p>
<ul>
<li>
<p>Calling <code>ocbfp()</code> registered by the <a href="#i444015">OCIBindDynamic()</a></p>
</li>
<li>
<p>Setting the pointer to the buffer in the buffer passed in by <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a> called when <a href="oci17msc001.htm#i574897">OCIStmtExecute()</a> returned <code>OCI_NEED_DATA</code></p>
</li>
</ul>
<p>The memory of these client library-allocated buffers must be freed when not in use anymore by using the <a href="oci18nav005.htm#i430212">OCIObjectFree()</a> call.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2619"></a>Related Functions</p>
<p><a href="#i456223">OCIBindByName()</a>, <a href="#i456224">OCIBindByPos()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17144" class="refsect2"><a id="i498627"></a>
<h2 class="refsect2">OCIDefineArrayOfStruct()<a id="sthref2620"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2621"></a>Purpose</p>
<p>Specifies additional attributes necessary for a static array define, used in an array of structures (multirow, multicolumn) fetch.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2622"></a>Syntax</p>
<pre>
sword OCIDefineArrayOfStruct ( OCIDefine   *defnp,
                               OCIError    *errhp,
                               ub4         pvskip, 
                               ub4         indskip, 
                               ub4         rlskip,
                               ub4         rcskip );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2623"></a>Parameters</p>
<dl>
<dt><span class="bold">defnp</span> (IN/OUT)</dt>
<dd>
<p>The handle to the define structure that was returned by a call to <a href="#i459315">OCIDefineByPos()</a>.</p>
</dd>
<dt><span class="bold">errhp</span> (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt><span class="bold">pvskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next data value.</p>
</dd>
<dt><span class="bold">indskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next indicator location.</p>
</dd>
<dt><span class="bold">rlskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next return length value.</p>
</dd>
<dt><span class="bold">rcskip</span> (IN)</dt>
<dd>
<p>Skip parameter for the next return code.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2624"></a>Comments</p>
<p>This call follows a call to <a href="#i459315">OCIDefineByPos()</a>. If the application is binding an array of structures involving objects, it must call <a href="#i555538">OCIDefineObject()</a> first, and then call <a href="#i498627">OCIDefineArrayOfStruct()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i421388">"Skip Parameters"</a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2625"></a>Related Functions</p>
<p><a href="#i459315">OCIDefineByPos()</a>, <a href="#i555538">OCIDefineObject()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17145" class="refsect2"><a id="i459315"></a>
<h2 class="refsect2">OCIDefineByPos()<a id="sthref2626"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2627"></a>Purpose</p>
<p>Associates an item in a select list with the type and output data buffer.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2628"></a>Syntax</p>
<pre>
sword OCIDefineByPos ( OCIStmt     *stmtp, 
                       OCIDefine   **defnpp,
                       OCIError    *errhp,
                       ub4         position,
                       void        *valuep,
                       sb4         value_sz,
                       ub2         dty,
                       void        *indp,
                       ub2         *rlenp,
                       ub2         *rcodep,
                       ub4         mode );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2629"></a>Parameters</p>
<dl>
<dt><span class="bold">stmtp</span> (IN/OUT)</dt>
<dd>
<p>A handle to the requested SQL query operation.</p>
</dd>
<dt><span class="bold">defnpp</span> (IN/OUT)</dt>
<dd>
<p>A pointer to a pointer to a define handle. If this parameter is passed as <code>NULL</code>, this call implicitly allocates the define handle. For a redefine, a non-<code>NULL</code> handle can be passed in this parameter. This handle is used to store the define information for this column.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The user must keep track of this pointer. If a second call to <code>OCIDefineByPos()</code> is made for the same column position, there is no guarantee that the same pointer will be returned.</div>
</dd>
<dt><span class="bold">errhp</span> (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt><span class="bold">position</span> (IN)</dt>
<dd>
<p>The position of this value in the select list. Positions are 1-based and are numbered from left to right. The value 0 selects <code>ROWID</code>s (the globally unique identifier for a row in a table).</p>
</dd>
<dt><span class="bold">valuep</span> (IN/OUT)</dt>
<dd>
<p>A pointer to a buffer or an array of buffers of the type specified in the <code>dty</code> parameter. A number of buffers can be specified when results for more than one row are desired in a single fetch call.</p>
<p>For a LOB, the buffer pointer must be a pointer to a LOB locator of type <code>OCILobLocator</code>. Give the address of the pointer.</p>
<p>When <code>mode</code> is set to <code>OCI_IOV</code>, pass the base address of the <code>OCIIOV</code> struct.</p>
</dd>
<dt><span class="bold">value_sz</span> (IN)</dt>
<dd>
<p>The size of each <code>valuep</code> buffer in bytes. If the data is stored internally in VARCHAR2 format, the number of characters desired, if different from the buffer size in bytes, may be additionally specified by using <a href="oci16rel002.htm#i443804">OCIAttrSet()</a>.</p>
<p>In a multibyte conversion environment, a truncation error is generated if the number of bytes specified is insufficient to handle the number of characters needed.</p>
<p>If the <code>OCI_ATTR_CHARSET_ID</code> attribute is set to <code>OCI_UTF16ID</code> (replaces the deprecated <code>OCI_UCS2ID</code>, which is retained for backward compatibility), all data passed to and received with the corresponding define call is assumed to be in <code>UTF-16</code> encoding.</p>
<p>When <code>mode</code> is set to <code>OCI_IOV</code>, pass the size of the data value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ociaahan.htm#i430016">"Bind Handle Attributes"</a></div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<dl>
<dt><span class="bold">dty</span> (IN)</dt>
<dd>
<p>The data type. Named data type (SQLT_NTY) and <code>REF</code> (SQLT_REF) are valid only if the environment has been initialized in object mode.</p>
<p>SQLT_CHR and SQLT_LNG can be specified for <code>CLOB</code> columns, and SQLT_BIN and SQLT_LBI can be specified for <code>BLOB</code> columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci03typ.htm#g467721">Chapter 3</a> for a listing of data type codes and values</div>
</dd>
</dl>
<dl>
<dt><span class="bold">indp (IN)</span></dt>
<dd>
<p>Pointer to an indicator variable or array. For scalar data types, pointer to <code>sb2</code> or an array of <code>sb2</code>s. Ignored for SQLT_NTY defines. For SQLT_NTY defines, a pointer to a named data type indicator structure or an array of named data type indicator structures is associated by a subsequent <code>OCIDefineObject()</code> call.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci02bas.htm#i462559">"Indicator Variables"</a></div>
</dd>
</dl>
<dl>
<dt><span class="bold">rlenp</span> (IN/OUT)</dt>
<dd>
<p>Pointer to array of length of data fetched.</p>
<p>When <code>OCIEnvNlsCreate()</code> (which is the recommended OCI environment handle creation interface) is used, then <code>rlenp</code> lengths are consistently reported in bytes. The same treatment consistently also holds for the length prefix in <code>SQLT_VCS</code> (2-byte length prefix) and <code>SQLT_LVC</code> (4-byte length prefix) types. There are no special exceptions for UCS2 or for NCHAR cases.</p>
<p>When the older OCI environment handle creation interfaces are used (either <a href="oci16rel001.htm#i556149">OCIEnvCreate()</a> or deprecated <a href="ociaedep001.htm#BEIGIBFB">OCIEnvInit()</a>), <code>rlenp</code> lengths are in bytes in general. However, <code>rlenp</code> lengths are reported in characters when either the character set is OCI_UC2ID (= OCI_UTF16ID) or when <code>OCI_ATTR_CHAR_COUNT</code> attribute is set on the corresponding OCIBind handle. The same treatment holds for the length prefix in <code>SQLT_VCS</code> (2-byte length prefix) and <code>SQLT_LVC</code> (4-byte length prefix) types.</p>
</dd>
<dt><span class="bold">rcodep</span> (OUT)</dt>
<dd>
<p>Pointer to array of column-level return codes.</p>
</dd>
<dt><span class="bold">mode</span> (IN)</dt>
<dd>
<p>The valid modes are:</p>
</dd>
</dl>
<ul>
<li>
<p><a id="sthref2630"></a><code>OCI_DEFAULT</code> - This is the default mode.</p>
</li>
<li>
<p><a id="sthref2631"></a><code>OCI_DEFINE_SOFT</code> - Soft define mode. This mode increases the performance of the call. If this is the first define, or some input parameter such as <code>dty</code> or <code>value_sz</code> is changed from the previous define, this mode is ignored. Unexpected behavior results if an invalid define handle is passed. An error is returned if the statement is not executed.</p>
</li>
<li>
<p><a id="sthref2632"></a><code>OCI_DYNAMIC_FETCH</code> - For applications requiring dynamically allocated data at the time of fetch, this mode must be used. You can define a callback using the <code>OCIDefineDynamic()</code> call. The <code>value_sz</code> parameter defines the maximum size of the data that is to be provided at run time. When the client library needs a buffer to return the fetched data, the callback is invoked to provide a runtime buffer into which a piece or all the data is returned.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci10new.htm#CHDDIGCG">"Implicit Fetching of ROWIDs"</a></div>
</li>
<li>
<p><a id="sthref2633"></a><code>OCI_IOV</code> - Define noncontiguous addresses of data. The <code>valuep</code> parameter must be of the type <code>OCIIOV</code> *.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#BABGDJDD">"Binding and Defining Multiple Buffers"</a></div>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2634"></a>Comments</p>
<p>This call defines an output buffer that receives data retrieved from Oracle Database. The define is a local step that is necessary when a <code>SELECT</code> statement returns data to your OCI application.</p>
<p>This call also implicitly allocates the define handle for the select-list item. If a non-<code>NULL</code> pointer is passed in <code>*defnpp</code>, OCI assumes that this points to a valid handle that has been previously allocated with a call to <a href="oci16rel002.htm#i540847">OCIHandleAlloc()</a> or <code>OCIDefineByPos()</code>. This would be true for an application that is redefining a handle to a different address so that it can reuse the same define handle for multiple fetches.</p>
<p>Defining attributes of a column for a fetch is done in one or more calls. The first call is to <code>OCIDefineByPos()</code>, which defines the minimal attributes required to specify the fetch.</p>
<p>Following the call to <code>OCIDefineByPos()</code> additional define calls may be necessary for certain data types or fetch modes:</p>
<ul>
<li>
<p>A call to <a href="#i498627">OCIDefineArrayOfStruct()</a> is necessary to set up skip parameters for an array fetch of multiple columns.</p>
</li>
<li>
<p>A call to <a href="#i555538">OCIDefineObject()</a> is necessary to set up the appropriate attributes of a named data type (that is, object or collection) or <code>REF</code> fetch. In this case, the data buffer pointer in <code>OCIDefineByPos()</code> is ignored.</p>
</li>
<li>
<p>Both <a href="#i498627">OCIDefineArrayOfStruct()</a> and <a href="#i555538">OCIDefineObject()</a> must be called after <code>OCIDefineByPos()</code> to fetch multiple rows with a column of named data types.</p>
</li>
</ul>
<p>For a LOB define, the buffer pointer must be a pointer to a LOB locator of type <code>OCILobLocator</code>, allocated by the <a href="oci16rel002.htm#i540763">OCIDescriptorAlloc()</a> call. LOB locators, and not LOB values, are always returned for a LOB column. LOB values can then be fetched using OCI LOB calls on the fetched locator. This same mechanism applies for all descriptor data types.</p>
<p>For NCHAR (fixed and varying length), the buffer pointer must point to an array of bytes sufficient for holding the required NCHAR characters.</p>
<p>Nested table columns are defined and fetched like any other named data type.</p>
<p>When defining an array of descriptors or locators, you should pass in an array of pointers to descriptors or locators.</p>
<p>When doing an array define for character columns, you should pass in an array of character buffers.</p>
<p>If the <code>mode</code> parameter in this call is set to <code>OCI_DYNAMIC_FETCH</code>, the client application can fetch data dynamically at run time. Runtime data can be provided in one of two ways:</p>
<ul>
<li>
<p>Callbacks using a user-defined function that must be registered with a subsequent call to <a href="#i444226">OCIDefineDynamic()</a>. When the client library needs a buffer to return the fetched data, the callback is invoked and the runtime buffers provided return a piece or all of the data.</p>
</li>
<li>
<p>A polling mechanism using calls supplied by OCI. This mode is assumed if no callbacks are defined. In this case, the fetch call returns the <code>OCI_NEED_DATA</code> error code, and a piecewise polling method is used to provide the data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about using the <code>OCI_DYNAMIC_FETCH</code> mode</p>
</li>
<li>
<p><a href="oci05bnd.htm#i421494">"Overview of Defining in OCI"</a> for more information about defines</p>
</li>
<li>
<p><a href="oci10new.htm#CHDDIGCG">"Implicit Fetching of ROWIDs"</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2635"></a>Related Functions</p>
<p><a href="#i498627">OCIDefineArrayOfStruct()</a>, <a href="#i444226">OCIDefineDynamic()</a>, <a href="#i555538">OCIDefineObject()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17146" class="refsect2"><a id="i444226"></a>
<h2 class="refsect2">OCIDefineDynamic()<a id="sthref2636"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2637"></a>Purpose</p>
<p>Sets the additional attributes required if the <code>OCI_DYNAMIC_FETCH</code> mode was selected in <code>OCIDefineByPos()</code>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2638"></a>Syntax</p>
<pre>
sword OCIDefineDynamic ( OCIDefine   *defnp,
                         OCIError    *errhp,
                         void        *octxp, 
                         OCICallbackDefine       (ocbfp)(
                                  void           *octxp,
                                  OCIDefine      *defnp,
                                  ub4            iter, 
                                  void           **bufpp,
                                  ub4            **alenpp,
                                  ub1            *piecep,
                                  void           **indpp,
                                  ub2            **rcodep );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2639"></a>Parameters</p>
<dl>
<dt>defnp (IN/OUT)</dt>
<dd>
<p>The handle to a define structure returned by a call to <code>OCIDefineByPos()</code>.</p>
</dd>
<dt>errhp (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <code>OCIErrorGet()</code> for diagnostic information when there is an error.</p>
</dd>
<dt>octxp (IN)</dt>
<dd>
<p>Points to a context for the callback function.</p>
</dd>
<dt>ocbfp (IN)</dt>
<dd>
<p>Points to a callback function. This is invoked at run time to get a pointer to the buffer into which the fetched data or a piece of it is to be retrieved. The callback also specifies the indicator, the return code, and the lengths of the data piece and indicator.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Normally, in an OCI function, an <code>IN</code> parameter refers to data being passed to OCI, and an <code>OUT</code> parameter refers to data coming back from OCI. For callbacks, this is reversed. <code>IN</code> means that data is coming from OCI into the callback, and <code>OUT</code> means that data is coming out of the callback and going to OCI.</div>
<p><a id="sthref2640"></a>The callback parameters are:</p>
</dd>
<dt>octxp (IN/OUT)</dt>
<dd>
<p>A context pointer passed as an argument to all the callback functions. When the client library needs a buffer to return the fetched data, the callback is invoked and the runtime buffers provided return a piece or all of the data.</p>
</dd>
<dt>defnp (IN)</dt>
<dd>
<p>The define handle.</p>
</dd>
<dt>iter (IN)</dt>
<dd>
<p>Specifies which row of this current fetch; 0-based.</p>
</dd>
<dt>bufpp (OUT)</dt>
<dd>
<p>Returns a pointer to a buffer to store the column value; that is, <code>*bufpp</code> points to some appropriate storage for the column value.</p>
</dd>
<dt>alenpp (IN/OUT)</dt>
<dd>
<p>Used by the application to set the size of the storage it is providing in <code>*bufpp</code>. After data is fetched into the buffer, <code>alenpp</code> indicates the actual size of the data in bytes. If the buffer length provided in the first call is insufficient to store all the data returned by the server, then the callback is called again, and so on.</p>
</dd>
<dt>piecep (IN/OUT)</dt>
<dd>
<p>Returns a piece value from the callback (application) to OCI, as follows:</p>
<p>The <code>piecep</code> parameter indicates whether the piece to be fetched is the first piece, <code>OCI_FIRST_PIECE</code>, a subsequent piece, <code>OCI_NEXT_PIECE</code>, or the last piece, <code>OCI_LAST_PIECE</code>. The program can process the piece the next time the callback is called, or after the series of callbacks is over.</p>
<ul>
<li>
<p><code>IN</code> - The value can be <code>OCI_ONE_PIECE</code>, <code>OCI_FIRST_PIECE</code>, or <code>OCI_NEXT_PIECE</code>.</p>
</li>
<li>
<p><code>OUT</code> - Depends on the IN value:</p>
<ul>
<li>
<p>The <code>OUT</code> value can be <code>OCI_ONE_PIECE</code> if the <code>IN</code> value was <code>OCI_ONE_PIECE</code>.</p>
</li>
<li>
<p>The <code>OUT</code> value can be <code>OCI_ONE_PIECE</code> or <code>OCI_FIRST_PIECE</code> if the <code>IN</code> value was <code>OCI_FIRST_PIECE</code>.</p>
</li>
<li>
<p>The <code>OUT</code> value can be <code>OCI_NEXT_PIECE</code> or <code>OCI_LAST_PIECE</code> if the <code>IN</code> value was <code>OCI_NEXT_PIECE</code>.</p>
</li>
</ul>
</li>
</ul>
</dd>
<dt>indpp (IN)</dt>
<dd>
<p>Indicator variable pointer.</p>
</dd>
<dt>rcodep (IN)</dt>
<dd>
<p>Return code variable pointer.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2641"></a>Comments</p>
<p>This call is used to set the additional attributes required if the <code>OCI_DYNAMIC_FETCH</code> mode has been selected in a call to <a href="#i459315">OCIDefineByPos()</a>. If <code>OCI_DYNAMIC_FETCH</code> mode was selected, and the call to <code>OCIDefineDynamic()</code> is skipped, then the application can fetch data piecewise using OCI calls (<a href="oci17msc001.htm#i575083">OCIStmtGetPieceInfo()</a> and <a href="oci17msc001.htm#i575292">OCIStmtSetPieceInfo()</a>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
After you use <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a> to create the environment handle, the actual lengths and returned lengths of bind and define handles are always in number of bytes.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci05bnd.htm#i427753">"Runtime Data Allocation and Piecewise Operations in OCI"</a> for more information about <code>OCI_DYNAMIC_FETCH</code> mode</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2642"></a>Related Functions</p>
<p><a href="#i555538">OCIDefineObject()</a>, <a href="#i444015">OCIBindDynamic()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17147" class="refsect2"><a id="i555538"></a>
<h2 class="refsect2"><a id="sthref2643"></a>OCIDefineObject()</h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2644"></a>Purpose</p>
<p>Sets up additional attributes necessary for a named data type or <code>REF</code> define.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2645"></a>Syntax</p>
<pre>
sword OCIDefineObject ( OCIDefine       *defnp,
                        OCIError        *errhp,
                        const OCIType   *type,
                        void            **pgvpp, 
                        ub4             *pvszsp, 
                        void            **indpp, 
                        ub4             *indszp );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2646"></a>Parameters</p>
<dl>
<dt><span class="bold">defnp</span> (IN/OUT)</dt>
<dd>
<p>A define handle previously allocated in a call to <a href="#i459315">OCIDefineByPos()</a>.</p>
</dd>
<dt><span class="bold">errhp</span> (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt><span class="bold">type</span> (IN) [optional]</dt>
<dd>
<p>Points to the type descriptor object (TDO) that describes the type of the program variable. This parameter is optional for variables of type <code>SQLT_REF</code>, and may be passed as <code>NULL</code> if it is not being used.</p>
</dd>
<dt><span class="bold">pgvpp</span> (IN/OUT)</dt>
<dd>
<p>Points to a pointer to a program variable buffer. For an array, <code>pgvpp</code> points to an array of pointers. Memory for the fetched named data type instances is dynamically allocated in the object cache. At the end of the fetch when all the values have been received, <code>pgvpp</code> points to the pointers to these newly allocated named data type instances. The application must call <a href="oci18nav005.htm#i430212">OCIObjectFree()</a> to deallocate the named data type instances when they are no longer needed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the application wants the buffer to be implicitly allocated in the cache, <code>*pgvpp</code> should be passed in as <code>NULL</code>.</div>
</dd>
<dt><span class="bold">pvszsp</span> (IN/OUT)</dt>
<dd>
<p>Points to the size of the program variable. For an array, it is an array of <code>ub4</code>.</p>
</dd>
<dt><span class="bold">indpp</span> (IN/OUT)</dt>
<dd>
<p>Points to a pointer to the program variable buffer containing the parallel indicator structure. For an array, points to an array of pointers. Memory is allocated to store the indicator structures in the object cache. At the end of the fetch when all values have been received, <code>indpp</code> points to the pointers to these newly allocated indicator structures.</p>
</dd>
<dt><span class="bold">indszp</span> (IN/OUT)</dt>
<dd>
<p>Points to the sizes of the indicator structure program variable. For an array, it is an array of <code>ub4</code>s.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2647"></a>Comments</p>
<p>This function follows a call to <a href="#i459315">OCIDefineByPos()</a> to set initial define information. This call sets up additional attributes necessary for a named data type define. An error is returned if this function is called when the OCI environment has been initialized in non-object mode.</p>
<p>This call takes as a parameter a type descriptor object (TDO) of data type <code>OCIType</code> for the named data type being defined. The TDO can be retrieved with a call to <a href="#i455723">OCIDescribeAny()</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="oci16rel001.htm#i556149">"OCIEnvCreate()"</a>, and <a href="oci16rel001.htm#i562098">"OCIEnvNlsCreate()"</a> for more information about initializing the OCI process environment</p>
</li>
<li>
<p><a href="oci05bnd.htm#BABGDJDD">"Binding and Defining Multiple Buffers"</a> for an example of using multiple buffers</p>
</li>
</ul>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2648"></a>Related Functions</p>
<p><a href="#i459315">OCIDefineByPos()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17148" class="refsect2"><a id="i455723"></a>
<h2 class="refsect2">OCIDescribeAny()<a id="sthref2649"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2650"></a>Purpose</p>
<p>Describes existing schema and subschema objects.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2651"></a>Syntax</p>
<pre>
sword OCIDescribeAny ( OCISvcCtx       *svchp,
                       OCIError        *errhp,
                       void            *objptr,
                       ub4             objptr_len,
                       ub1             objptr_typ,
                       ub1             info_level,
                       ub1             objtyp,
                       OCIDescribe     *dschp );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2652"></a>Parameters</p>
<dl>
<dt>svchp (IN)</dt>
<dd>
<p>A service context handle.</p>
</dd>
<dt>errhp (IN/OUT)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt>objptr (IN)</dt>
<dd>
<p>This parameter can be:</p>
</dd>
</dl>
<ol>
<li>
<p>A string containing the name of the object to be described. Must be in the encoding specified by the <code>charset</code> parameter of a previous call to <code>OCIEnvNlsCreate()</code>.</p>
</li>
<li>
<p>A pointer to a <code>REF</code> to the TDO (for a type).</p>
</li>
<li>
<p>A pointer to a TDO (for a type).</p>
</li>
</ol>
<p>These cases are distinguished by passing the appropriate value for <code>objptr_typ</code>. This parameter must be non-<code>NULL</code>.</p>
<p>In case 1, the string containing the object name should be in the format <code>name1[.name2 ...][@linkname]</code>, such as <code>hr.employees.employee_id@mydb</code>. Database links are only allowed to Oracle8<span class="italic">i</span> or later databases. The object name is interpreted by the following SQL rules:</p>
<ul>
<li>
<p>If only <code>name1</code> is entered and <code>objtyp</code> is equal to <code>OCI_PTYPE_SCHEMA</code>, then the name refers to the named schema. The Oracle Database must be release 8.1 or later.</p>
</li>
<li>
<p>If only <code>name1</code> is entered and <code>objtyp</code> is equal to <code>OCI_PTYPE_DATABASE</code>, then the name refers to the named database. When describing a remote database with <code>database_name@db_link_name</code>, the remote Oracle Database must be release 8.1 or later.</p>
</li>
<li>
<p>If only <code>name1</code> is entered and <code>objtyp</code> is not equal to <code>OCI_PTYPE_SCHEMA</code> or <code>OCI_PTYPE_DATABASE</code>, then the name refers to the named object (of type table, view, procedure, function, package, type, synonym, sequence) in the current schema of the current user. When connected to an Oracle7 Server, the only valid types are procedure and function.</p>
</li>
<li>
<p>If <code>name1.name2.name3 ...</code> is entered, the object name refers to a schema or subschema object in the schema named <code>name1</code>. For example, in the string <code>hr.employees.department_id</code>, <code>hr</code> is the name of the schema, <code>employees</code> is the name of a table in the schema, and <code>department_id</code> is the name of a column in the table.</p>
</li>
</ul>
<dl>
<dt>objnm_len (IN)</dt>
<dd>
<p>The length of the name string pointed to by <code>objptr</code>. Must be nonzero if a name is passed. Can be zero if <code>objptr</code> is a pointer to a TDO or its <code>REF</code>.</p>
</dd>
<dt>objptr_typ (IN)</dt>
<dd>
<p>The type of object passed in <code>objptr</code>. Valid values are:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_OTYPE_NAME</code>, if <code>objptr</code> points to the name of a schema object</p>
</li>
<li>
<p><code>OCI_OTYPE_REF</code>, if <code>objptr</code> is a pointer to a <code>REF</code> to a TDO</p>
</li>
<li>
<p><code>OCI_OTYPE_PTR</code>, if <code>objptr</code> is a pointer to a TDO</p>
</li>
</ul>
<dl>
<dt>info_level (IN)</dt>
<dd>
<p>Reserved for future extensions. Pass <code>OCI_DEFAULT</code>.</p>
</dd>
<dt>objtyp (IN)</dt>
<dd>
<p>The type of schema object being described. Valid values are:</p>
</dd>
</dl>
<ul>
<li>
<p><code>OCI_PTYPE_TABLE</code>, for tables</p>
</li>
<li>
<p><code>OCI_PTYPE_VIEW</code>, for views</p>
</li>
<li>
<p><code>OCI_PTYPE_PROC</code>, for procedures</p>
</li>
<li>
<p><code>OCI_PTYPE_FUNC</code>, for functions</p>
</li>
<li>
<p><code>OCI_PTYPE_PKG</code>, for packages</p>
</li>
<li>
<p><code>OCI_PTYPE_TYPE</code>, for types</p>
</li>
<li>
<p><code>OCI_PTYPE_SYN</code>, for synonyms</p>
</li>
<li>
<p><code>OCI_PTYPE_SEQ</code>, for sequences</p>
</li>
<li>
<p><code>OCI_PTYPE_SCHEMA</code>, for schemas</p>
</li>
<li>
<p><code>OCI_PTYPE_DATABASE</code>, for databases</p>
</li>
<li>
<p><code>OCI_PTYPE_UNK</code>, for unknown schema objects</p>
</li>
</ul>
<dl>
<dt>dschp (IN/OUT)</dt>
<dd>
<p>A describe handle that is populated with describe information about the object after the call. Must be non-<code>NULL</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2653"></a>Comments</p>
<p>This is a generic describe call that describes existing schema objects: tables, views, synonyms, procedures, functions, packages, sequences, types, schemas, and databases. This call also describes subschema objects, such as a column in a table. This call populates the describe handle with the object-specific attributes that can be obtained through an <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> call.</p>
<p>An <a href="oci16rel002.htm#i540956">OCIParamGet()</a> on the describe handle returns a parameter descriptor for a specified position. Parameter positions begin with 1. Calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> on the parameter descriptor returns the specific attributes of a stored procedure or function parameter, or a table column descriptor. These subsequent calls do not need an extra round-trip to the server because the entire schema object description is cached on the client side by <code>OCIDescribeAny()</code>. Calling <a href="oci16rel002.htm#CHDHCHID">OCIAttrGet()</a> on the describe handle also returns the total number of positions.</p>
<p>If the <a id="sthref2654"></a><code>OCI_ATTR_DESC_PUBLIC</code> attribute is set on the describe handle, then the object named is looked up as a public synonym when the object does not exist in the current schema and only <code>name1</code> is specified.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oci06des.htm#g464132">Chapter 6</a> for more information about describe operations</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2655"></a>Related Functions</p>
<p><a href="oci16rel002.htm#i493114">OCIArrayDescriptorAlloc()</a>, <a href="oci16rel002.htm#i540956">OCIParamGet()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="LNOCI17149" class="refsect2"><a id="i541225"></a>
<h2 class="refsect2">OCIStmtGetBindInfo()<a id="sthref2656"></a></h2>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2657"></a>Purpose</p>
<p>Gets the bind and indicator variable names.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2658"></a>Syntax</p>
<pre>
sword OCIStmtGetBindInfo ( OCIStmt      *stmtp,
                           OCIError     *errhp,
                           ub4          size,
                           ub4          startloc,
                           sb4          *found,
                           OraText      *bvnp[],
                           ub1          bvnl[],
                           OraText      *invp[],
                           ub1          inpl[],
                           ub1          dupl[],
                           OCIBind      *hndl[] );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2659"></a>Parameters</p>
<dl>
<dt><span class="bold">stmtp</span> (IN)</dt>
<dd>
<p>The statement handle prepared by <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a>.</p>
</dd>
<dt><span class="bold">errhp</span> (IN)</dt>
<dd>
<p>An error handle that you can pass to <a href="oci17msc007.htm#i540516">OCIErrorGet()</a> for diagnostic information when there is an error.</p>
</dd>
<dt><span class="bold">size</span> (IN)</dt>
<dd>
<p>The number of elements in each array.</p>
</dd>
<dt><span class="bold">startloc</span> (IN)</dt>
<dd>
<p>Position of the bind variable at which to start getting bind information.</p>
</dd>
<dt><span class="bold">found</span> (IN)</dt>
<dd>
<p>The expression <code>abs</code>(<code>found</code>) gives the total number of bind variables in the statement irrespective of the start position. Positive value if the number of bind variables returned is less than the size provided, otherwise negative.</p>
</dd>
<dt>bvnp (OUT)</dt>
<dd>
<p>Array of pointers to hold bind variable names. Is in the encoding specified by the <code>charset</code> parameter of a previous call to <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a>.</p>
</dd>
<dt>bvnl (OUT)</dt>
<dd>
<p>Array to hold the length of the each <code>bvnp</code> element. The length is in bytes.</p>
</dd>
<dt>invp (OUT)</dt>
<dd>
<p>Array of pointers to hold indicator variable names. Must be in the encoding specified by the <code>charset</code> parameter of a previous call to <a href="oci16rel001.htm#i562098">OCIEnvNlsCreate()</a>.</p>
</dd>
<dt>inpl (OUT)</dt>
<dd>
<p>Array of pointers to hold the length of the each <code>invp</code> element. In number of bytes.</p>
</dd>
<dt>dupl (OUT)</dt>
<dd>
<p>An array whose element value is 0 or 1 depending on whether the bind position is a duplicate of another.</p>
</dd>
<dt>hndl (OUT)</dt>
<dd>
<p>An array that returns the bind handle if binds have been done for the bind position. No handle is returned for duplicates.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2660"></a>Comments</p>
<p>This call returns information about bind variables after a statement has been prepared. This includes bind names, indicator names, and whether binds are duplicate binds. This call also returns an associated bind handle if there is one. The call sets the <code>found</code> parameter to the total number of bind variables and not just the number of distinct bind variables.</p>
<p><code>OCI_NO_DATA</code> is returned if the statement has no bind variables or if the starting bind position specified in the invocation does not exist in the statement.</p>
<p>This function does not include <code>SELECT INTO</code> list variables, because they are not considered to be binds.</p>
<p>The statement must have been prepared with a call to <a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a> prior to this call. The encoding setting in the statement handle determines whether Unicode strings are retrieved.</p>
<p>This call is processed locally.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2661"></a>Related Functions</p>
<p><a href="oci17msc001.htm#i575144">OCIStmtPrepare()</a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" -->
<!-- class="chapter" -->
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1004">
<tr>
<td class="cellalignment1013">
<table class="cellalignment1009">
<tr>
<td class="cellalignment1008"><a href="oci16rel002.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1008"><a href="oci17msc.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1015">
<table class="cellalignment1007">
<tr>
<td class="cellalignment1008"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1008"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1008"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1008"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1008"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1008"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
