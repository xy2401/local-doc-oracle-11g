<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Object Programming</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 711" />
<meta name="dcterms.created" content="2013-02-06T9:20:48Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="C++ Call Interface Programmer's Guide," />
<meta name="dcterms.identifier" content="E10764-04" />
<meta name="dcterms.isVersionOf" content="LNCPP" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="relational.htm" title="Previous" type="text/html" />
<link rel="Next" href="types.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10764.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/54</span> <!-- End Header --><a id="CIHDHCCH"></a><a id="LNCPP004"></a><a id="i1001003"></a>
<h1 class="chapter"><span class="secnum">4</span> Obje<a id="sthref208"></a>ct Programming</h1>
<p>This chapter provides information on how to implement object-relational programming using the Oracle C++ Call Interface (OCCI).</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1001705">Overview of Object Programming</a></p>
</li>
<li>
<p><a href="#i1003618">Working with Objects in OCCI</a></p>
</li>
<li>
<p><a href="#i1007093">Representing Objects in C++ Applications</a></p>
</li>
<li>
<p><a href="#CIHBEAFE">Developing an OCCI Object Application</a></p>
</li>
<li>
<p><a href="#BAJIEEHG">Migrating C++ Applications Using OCCI</a></p>
</li>
<li>
<p><a href="#i1003644">Overview of Associative Access</a></p>
</li>
<li>
<p><a href="#i1007163">Overview of Navigational Access</a></p>
</li>
<li>
<p><a href="#i1009758">Overview of Complex Object Retrieval</a></p>
</li>
<li>
<p><a href="#i1003654">Working with Collections</a></p>
</li>
<li>
<p><a href="#i1007323">Using Object References</a></p>
</li>
<li>
<p><a href="#i1007327">Deleting Objects from the Database</a></p>
</li>
<li>
<p><a href="#CIHHEFEH">Type Inheritance</a></p>
</li>
<li>
<p><a href="#i1005035">A Sample OCCI Application</a></p>
</li>
</ul>
<a id="i1001705"></a><a id="LNCPP20143"></a>
<div class="sect1">
<h2 class="sect1">Overview of Object P<a id="sthref209"></a>rogramming</h2>
<p>OCCI supports both the associative and navigational style of data access. Traditionally, third-generation language (3GL) programs manipulate data stored in a database by using the <span class="bold">associative access</span> based on the associations organized by relational database tables. In associative access, data is manipulated by executing SQL statements and PL/SQL procedures. OCCI supports associative access to objects by enabling your applications to execute SQL statements and PL/SQL procedures on the database server without incurring the cost of transporting data to the client.</p>
<p>Object-oriented programs that use OCCI can also make use of <span class="bold">navigational access</span> that is a key aspect of this programming paradigm. Object relationships between objects are implemented as references (<code>REF</code>s). Typically, an object application that uses navigational access first retrieves one or more objects from the database server by issuing a SQL statement that returns <code>REF</code>s to those objects. The application then uses those <code>REF</code>s to traverse related objects, and perform computations on these other objects as required. Navigational access does not involve executing SQL statements, except to fetch the references of an initial set of objects. By using the OCCI APIs for navigational access, your application can perform the following functions on Oracle objects:</p>
<ul>
<li>
<p>Creating, accessing, locking, deleting, copying and flushing objects</p>
</li>
<li>
<p>Getting references to objects and navigating through the references</p>
</li>
</ul>
<p>This chapter gives examples that show you how to create a persistent object, access an object, modify an object, and flush the changes to the database server. It discusses how to access the object using both navigational and associative approaches.</p>
</div>
<!-- class="sect1" -->
<a id="i1003618"></a><a id="LNCPP20144"></a>
<div class="sect1">
<h2 class="sect1">Working with <a id="sthref210"></a>Objects in OCCI</h2>
<p>Many of the programming principles that govern a relational OCCI applications are identical for object-relational applications. An object-relational application uses the standard OCCI calls to establish database connections and process SQL statements. The difference is that the SQL statements that are issued retrieve object references, which can then be manipulated with OCCI object functions. An object can also be directly manipulated as a value (without using its object reference).</p>
<p>Instances of an Oracle type are categorized into <span class="bold">per<a id="sthref211"></a>sistent objects</span> and <span class="bold">trans<a id="sthref212"></a>ient objects</span> based on their lifetime. Instances of persistent objects can be further divided into <span class="bold">standalone objects</span> and <span class="bold">embedded objects</span> depending on whether they are referenced by way of an object identifier.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1001967">Persistent Objects</a></p>
</li>
<li>
<p><a href="#CIHBBCFJ">Transient Objects</a></p>
</li>
<li>
<p><a href="#BEIHJBBJ">Values</a></p>
</li>
</ul>
<a id="i1001967"></a><a id="LNCPP20145"></a>
<div class="sect2">
<h3 class="sect2">Persistent<a id="sthref213"></a> Objects</h3>
<p>A <span class="bold">persistent object</span> is an object which is stored in an Oracle database. It may be fetched into the object cache and modified by an OCCI application. The lifetime of a persistent object can exceed that of the application which is accessing it. There are two types of persistent objects:</p>
<ul>
<li>
<p>A <span class="bold">standa<a id="sthref214"></a>lone <a id="sthref215"></a>instance</span> is stored in a database table row, and has a unique object identifier. An OCCI application can retrieve a reference to a standalone object, pin the object, and navigate from the pinned object to other related objects. Standalone objects may also be referred to as <span class="bold">ref<a id="sthref216"></a>erenc<a id="sthref217"></a>eable objects</span>.</p>
<p>It is also possible to select a persistent object, in which case you fetch the object <span class="italic">by value</span> instead of fetching it by reference.</p>
</li>
<li>
<p>An <span class="bold">embed<a id="sthref218"></a>ded<a id="sthref219"></a> instance</span> is not stored in a database table row, but rather is embedded within another object. Examples of embedded objects are objects which are attributes of another object, or objects that exist in an object column of a database table. Embedded objects do not have object identifiers, and OCCI applications cannot get <code>REF</code>s to embedded instances.</p>
<p>Embedded objects may also be referred to as <span class="bold">no<a id="sthref220"></a>nreferencea<a id="sthref221"></a>ble objects</span> or <span class="bold">value instances</span>. You may sometimes see them referred to as <span class="bold">values</span>, which is not to be confused with scalar data values. The context should make the meaning clear.</p>
</li>
</ul>
<p>Users do not have to explicitly delete persistent objects that have been materialized through references.</p>
<p>Users should delete persistent objects created by application when the transactions are rolled back</p>
<p>The SQL examples, <a href="#BEICJAAH">Example 4-1</a> and <a href="#BEIIABGC">Example 4-2</a>, demonstrate the difference between these two types of persistent objects.</p>
<div class="example">
<p class="titleinexample"><a id="BEICJAAH"></a><a id="LNCPP20146"></a>Example 4-1 <a id="sthref222"></a><a id="sthref223"></a>Creating Standalone Objects</p>
<p>Objects that are stored in the object table <code>person_tab</code> are standalone objects. They have object identifiers and can be referenced. They can be pinned in an OCCI application.</p>
<pre>
CREATE TYPE person_t AS OBJECT
   (name      varchar2(30),
    age       number(3));
CREATE TABLE person_tab OF person_t;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEIIABGC"></a><a id="LNCPP20147"></a>Example 4-2 Creating Em<a id="sthref224"></a>bedded Objects</p>
<p>Objects which are stored in the <code>manager</code> column of the <code>department</code> table are embedded objects. They do not have object identifiers, and they cannot be referenced. Therefore, they cannot be pinned in an OCCI application, and they also never have to be unpinned. They are always retrieved into the object cache <span class="italic">by value</span>.</p>
<pre>
CREATE TABLE department
   (deptno     number,
    deptname   varchar2(30),
    manager    person_t);
</pre>
<p>The Array Pin feature allows a vector of references to be dereferenced in one round-trip to return a vector of the corresponding objects. A new global method, <code>pinVectorOfRefs()</code>, takes a vector of <code>Ref</code>s and populates a vector of <code>PObject</code>s in a single round-trip, saving the cost of pinning <code>n-1</code> references in <code>n-1</code> round-trips.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHBBCFJ"></a><a id="LNCPP20148"></a>
<div class="sect2">
<h3 class="sect2">Transient Obje<a id="sthref225"></a>cts</h3>
<p>A transient object is an instance of an object type. Its lifetime cannot exceed that of the application. The application can also delete a transient object at any time.</p>
<p>The Object Type Translator (OTT) utility generates two <code>operator new</code> methods for each C++ class, as demonstrated in <a href="#BEIDGFBH">Two Methods for Operator new() in the Object Type Translator Utility</a><a href="#BEIDGFBH">Example 4-3</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BEIDGFBH"></a><a id="LNCPP20149"></a>Example 4-3 Two Methods for Operator new() in the Object Type Translator Utility</p>
<pre>
class Person : public PObject {
   ...
public:
   dvoid *operator new(size_t size);    // creates transient instance
   dvoid *operator new(size_t size, Connection &amp;conn, string table);
                                        // creates persistent instance
}
</pre></div>
<!-- class="example" -->
<p><a href="#BEICGCBD">Example 4-4</a> demonstrates how to dynamically create a transient object. Transient objects cannot be converted to persistent objects. Their role is fixed at the time they are instantiated, and it is your responsibility to free memory by deleting transient objects.</p>
<div class="example">
<p class="titleinexample"><a id="BEICGCBD"></a><a id="LNCPP20150"></a>Example 4-4 How to Dynamically Create a Transient Object</p>
<pre>
Person *p = new P<a id="sthref226"></a>erson();
</pre></div>
<!-- class="example" -->
<p>A transient object can also be created on the stack as a local variable, as demonstrated in <a href="#BEIGDIHD">Example 4-5</a>. The latter approach guarantees that the transient object is destroyed when the scope of the variable ends.</p>
<div class="example">
<p class="titleinexample"><a id="BEIGDIHD"></a><a id="LNCPP20151"></a>Example 4-5 How to Create a Transient Object as a Local Variable</p>
<pre>
Person p;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink CNCPT111" href="../../server.112/e40540/tablecls.htm#CNCPT111"><span class="italic">Oracle Database Concepts</span></a> for more information about objects</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BEIHJBBJ"></a><a id="LNCPP20152"></a>
<div class="sect2">
<h3 class="sect2">Val<a id="sthref227"></a>ues<a id="sthref228"></a></h3>
<p>In this manual, a <span class="bold">value</span> refers to either:</p>
<ul>
<li>
<p>A scalar value which is stored in a non-object column of a database table. An OCCI application can fetch values from a database by issuing SQL statements.</p>
</li>
<li>
<p>An embedded (nonreferenceable) object.</p>
</li>
</ul>
<p>The context should make it clear which meaning is intended.</p>
<p>It is possible to <code>SELECT</code> a referenceable object into the object cache, rather than pinning it, in which case you fetch the object <span class="italic">by value</span> instead of fetching it by reference.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007093"></a><a id="LNCPP20153"></a>
<div class="sect1">
<h2 class="sect1">Representing Objects in C++ Applications</h2>
<p>Before an OCCI application can work with object types, those types must exist in the database. Typically, you create types with SQL DDL statements, such as <code>CREATE</code> <code>TYPE</code>.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BEIDADDJ">Creating Persistent and Transient Objects</a></p>
</li>
<li>
<p><a href="#BEICIDEE">Creating Object Representations using the OTT Utility</a></p>
</li>
</ul>
<a id="BEIDADDJ"></a><a id="LNCPP20154"></a>
<div class="sect2">
<h3 class="sect2">Creating Persistent and Transient Objects</h3>
<p>This section discusses how persistent and transient objects are created.</p>
<p>Before you create a persistent object, you must have created the environment and opened a connection.</p>
<p>A persistent object is created in the database only when one of the following occurs:</p>
<ul>
<li>
<p>The transaction is committed (<code>Connection::commit()</code>)</p>
</li>
<li>
<p>The object cache is flushed (<code>Connection::flushCache()</code>)</p>
</li>
<li>
<p>The object itself is flushed (<code>PObject::flush()</code>)</p>
</li>
</ul>
<p><a href="#BEIJIHDH">Example 4-6</a> shows how to create a persistent object, <code>addr</code>, in the database table, <code>addr_tab</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BEIJIHDH"></a><a id="LNCPP20155"></a>Example 4-6 How to Create a <a id="sthref229"></a>Persistent Object</p>
<pre>
CREATE TYPE ADDRESS AS OBJECT (
   state CHAR(2), 
   zip_code CHAR(5));
CREATE TABLE ADDR_TAB of ADDRESS;
ADDRESS *addr = new(conn, "ADDR_TAB") ADDRESS("CA", "94065");
</pre></div>
<!-- class="example" -->
<p><a href="#BEIFGGJJ">Example 4-7</a> shows hot to create an instance of the transient object <code>ADDRESS</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BEIFGGJJ"></a><a id="LNCPP20156"></a>Example 4-7 How to Create a <a id="sthref230"></a>Transient Object</p>
<pre>
ADDRESS *addr_trans = new ADDRESS("MD", "94111");
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BEICIDEE"></a><a id="LNCPP20157"></a>
<div class="sect2">
<h3 class="sect2">Creating Object Representations using the OTT Utility</h3>
<p>When your C++ application retrieves instances of object types from the database, it must have a client-side representation of the objects. The Object Type Translator (OTT) utility generates C++ class representations of database object types for you. <a href="#BEIGDFED">Example 4-8</a> shows the declaration of a custom type in the database, and the corresponding C++ class that the OTT utility generates.</p>
<div class="example">
<p class="titleinexample"><a id="BEIGDFED"></a><a id="LNCPP21904"></a>Example 4-8 How to Declare a Custom Type in the Database</p>
<pre>
CREATE TYPE address AS OBJECT (state CHAR(2), zip_code CHAR(5));
</pre>
<p>The OTT utility produces the following C++ class:</p>
<pre>
class ADDRESS : public PObject {

   protected:
      string state;
      string zip;

   public:
      void *operator new(size_t size); 
      void *operator new(size_t size, 
         const Connection* conn, 
         const string&amp; table);
      string  getSQLTypeName() const;
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      ADDRESS(void *ctx) : PObject(ctx) { };
      static void *readSQL(void *ctx);
      virtual void readSQL(AnyData&amp; stream);
      static void writeSQL(void *obj, void *ctx);
      virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
<!-- class="example" -->
<p>These class declarations in <a href="#BEIGDFED">Example 4-8</a> are automatically written by OTT to a header file that you name. This header file is included in the source files for an application to provide access to objects. Instances of a <code>PObject</code> (and also instances of classes derived from <code>PObject</code>s) can be either transient or persistent. The methods <code>writeSQL()</code> and <code>readSQL()</code> are used internally by the OCCI object cache to linearize and delinearize the objects and are not to be used or modified by OCCI clients.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ottutility.htm#CHDBCDBH">Chapter 8, "Object Type Translator Utility"</a> for more information about the OTT utility</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHBEAFE"></a><a id="LNCPP20158"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Developing <a id="sthref231"></a>an OCCI Object Application</h2>
<p>This section discusses the steps involved in developing a basic OCCI object application.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1007455">Basic Object Program Structure</a></p>
</li>
<li>
<p><a href="#BEICAJHJ">Basic Object Operational Flow</a></p>
</li>
</ul>
<a id="i1007455"></a><a id="LNCPP20159"></a>
<div class="sect2">
<h3 class="sect2">Basic Obj<a id="sthref232"></a>ect Program Structure</h3>
<p>The basic structure of an OCCI application that uses objects is similar to a relational OCCI application, the difference being object functionality. The steps involved in an OCCI object program include:</p>
<ol>
<li>
<p>Initialize the <code>Environment</code>. Initialize the OCCI programming environment in object mode. Your application must include C++ class representations of database objects in a header file. You can create these classes by using the Object Type Translator (OTT) utility, as described in <a href="ottutility.htm#CHDBCDBH">Chapter 8, "Object Type Translator Utility"</a>.</p>
</li>
<li>
<p>Establish a Connection. Use the environment handle to establish a connection to the database server.</p>
</li>
<li>
<p>Prepare a SQL statement. This is a local (client-side) step, which may include binding placeholders. In an object-relational application, this SQL statement should return a reference (<code>REF</code>) to an object.</p>
</li>
<li>
<p>Access the object.</p>
<ol>
<li>
<p>Associate the prepared statement with a database server, and execute the statement.</p>
</li>
<li>
<p>By using navigational access, retrieve an object reference (<code>REF</code>) from the database server and pin the object. You can then perform some or all of the following:</p>
<ul>
<li>
<p>Manipulate the attributes of an object and mark it as <span class="bold">dirty</span> (modified)</p>
</li>
<li>
<p>Follow a reference to another object or series of objects</p>
</li>
<li>
<p>Access type and attribute information</p>
</li>
<li>
<p>Navigate a complex object retrieval graph</p>
</li>
<li>
<p>Flush modified objects to the database server</p>
</li>
</ul>
</li>
<li>
<p>By using associative access, you can fetch an entire object <span class="italic">by value</span> by using SQL. Alternately, you can select an embedded (nonreferenceable) object. You can then perform some or all of the following:</p>
<ul>
<li>
<p>Insert values into a table</p>
</li>
<li>
<p>Modify existing values</p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>Commit the transaction. This step implicitly writes all modified objects to the database server and commits the changes.</p>
</li>
<li>
<p>Free statements and handles; the prepared statements should not be used or executed again.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="relational.htm#CHDJCICB">Chapter 3, " Relational Programming"</a> for information about using OCCI to connect to a database server, process SQL statements, and allocate handles</p>
</li>
<li>
<p><a href="ottutility.htm#CHDBCDBH">Chapter 8, "Object Type Translator Utility"</a> for information about the OTT utility</p>
</li>
<li>
<p><a href="reference.htm#CIAJIDCF">Chapter 13, "OCCI Application Programming Interface"</a> for descriptions of OCCI relational functions and the <code>Connect</code> class and the <code>getMetaData()</code> method</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BEICAJHJ"></a><a id="LNCPP20160"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Basic Ob<a id="sthref233"></a>ject Operational Flow</h3>
<p>Figure&nbsp;3-1 shows a simple program logic flow for how an application might work with objects. For simplicity, some required steps are omitted.</p>
<div class="figure">
<p class="titleinfigure"><a id="LNCPP20161"></a><a id="sthref234"></a>Figure 4-1 Basic Object Operational Flow</p>
<img width="235" height="303" src="img/object_operational_flow.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref235" href="img_text/object_operational_flow.htm">Description of "Figure 4-1 Basic Object Operational Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The steps shown in Figure&nbsp;3-1 are discussed in the following sections:</p>
<a id="i1003634"></a><a id="LNCPP20162"></a>
<div class="sect3">
<h4 class="sect3">Initialize OCCI i<a id="sthref236"></a><a id="sthref237"></a>n Object Mode</h4>
<p>If your OCCI application accesses and manipulates objects, then it is essential that you specify a value of <code>OBJECT</code> for the <code>mode</code> parameter of the <code>createEnvironment()</code> method, the first call in any OCCI application. Specifying this value for <code>mode</code> indicates to OCCI that your application works with objects. This notification has the following important effects:</p>
<ul>
<li>
<p>The object run-time environment is established.</p>
</li>
<li>
<p>The object cache is set up.</p>
</li>
</ul>
<p>Note that ithe <code>mode</code> parameter is not set to <code>OBJECT</code>, any attempt to use an object-related function results in an error.</p>
<p>The following code example demonstrates how to specify the <code>OBJECT</code> <code>mode</code> when creating an OCCI environment:</p>
<pre>
Environment *env;
Connection *con;
Statement *stmt;

env = Environment::createEnvironment(Environment::OBJECT);
con = Connection(userName, password, connectString);
</pre>
<p>Your application does not have to allocate memory when database objects are loaded into the object cache. The object cache provides transparent and efficient memory management for database objects. When database objects are loaded into the object cache, they are transparently mapped into the host language (C++) representation.</p>
<p>The object cache<a id="sthref238"></a> maintains the association between the object copy in the object cache and the corresponding database object. Upon <code>commit</code>, changes made to the object copy in the object cache are automatically propagated back to the database.</p>
<p>The object cache maintains a look-up table for mapping references to objects. When an application dereferences a reference to an object and the corresponding object is not yet cached in the object cache, the object cache automatically sends a request to the database server to fetch the object from the database and load it into the object cache. Subsequent dereferences of the same reference are faster since they are to the object cache itself and do not incur a round-trip to the database server.</p>
<p>Subsequent dereferences of the same reference fetch from the cache instead of requiring a round-trip. The exception to this is in a dereferencing operation that occurs just after a commit. In this case, the latest object copy from the server is returned. This ensures that the latest object from the database is cached after each transaction.</p>
<p>The object cache maintains a pin count for each persistent object in the object cache. When an application dereferences a reference to an object, the pin count of the object is incremented. The subsequent dereferencing of the same reference to the object does not change the pin count. Until the reference to the object goes out of scope, the object continues to be pinned in the object cache and be accessible by the OCCI client.</p>
<p>The pin count functions as a reference count for the object. The pin count of the object becomes zero (<code>0</code>) only when there are no more references referring to this object, during which time the object becomes eligible for garbage collection. The object cache uses a least recently used algorithm to manage the size of the object cache. This algorithm frees objects with a pin count of 0 when the object cache reaches the maximum size.</p>
</div>
<!-- class="sect3" -->
<a id="i1010314"></a><a id="LNCPP20163"></a>
<div class="sect3">
<h4 class="sect3">Pin <a id="sthref239"></a><a id="sthref240"></a>Object</h4>
<p>In most situations, OCCI users do not have to explicitly pin or unpin the objects because the object cache automatically keeps track of the pin counts of all the objects in the cache. As explained earlier, the object cache increments the pin count when a reference points to the object and decrements it when the reference goes out of scope or no longer points to the object.</p>
<p>But there is one exception. If an OCCI application uses <code>Ref&lt;T&gt;::ptr()</code> method to get a pointer to the object, then the <code>pin</code> and <code>unpin</code> methods of the <code>PObject</code> class can be used by the application to control pinning and unpinning of the objects in the object cache.</p>
</div>
<!-- class="sect3" -->
<a id="LNCPP20164"></a>
<div class="sect3"><a id="sthref241"></a>
<h4 class="sect3">Operate on Objec<a id="sthref242"></a>t in Cache</h4>
<p>Note that the object cache does not manage the contents of object copies; it does not automatically refresh object copies. Your application must ensure the validity and consistency of object copies.</p>
</div>
<!-- class="sect3" -->
<a id="LNCPP20165"></a>
<div class="sect3"><a id="sthref243"></a>
<h4 class="sect3">Flush Chang<a id="sthref244"></a>es to Object</h4>
<p>Whenever changes are made to object copies in the object cache, your application is responsible for flushing the changed object to the database.</p>
<p>Memory for the object cache is allocated on demand when objects are loaded into the object cache.</p>
<p>The client-side object cache is allocated in the program's process space. This object cache is the memory for objects that have been retrieved from the database server and are available to your application.</p>
<p>If you initialize the OCCI environment in object mode, your application allocates memory for the object cache, whether the application actually uses object calls.</p>
<p>There is only one object cache allocated for each OCCI environment. All objects retrieved or created through different connections within the environment use the same physical object cache. Each connection has its own logical object cache.</p>
</div>
<!-- class="sect3" -->
<a id="i1010645"></a><a id="LNCPP20166"></a>
<div class="sect3">
<h4 class="sect3">Deletion of an Object</h4>
<p>For objects retrieved into the cache by dereferencing a reference, you should not perform an explicit delete. For such objects, the pin count is incremented when a reference is dereferenced for the first time and decremented when the reference goes out of scope. When the pin count of the object becomes <code>0</code>, indicating that all references to that object are out of scope, the object is automatically eligible for garbage collection and subsequently deleted from the cache.</p>
<p>For persistent objects that have been created by calling the <code>new</code> operator, you must call a <code>delete</code> if you do not commit the transaction. Otherwise, the object is garbage collected after the commit. This is because when such an object is created using <code>new</code>, its pin count is initially <code>0</code>. However, because the object is dirty it remains in the cache. After a commit, it is no longer dirty and thus garbage collected. Therefore, a delete is not required.</p>
<p>If a commit is not performed, then you must explicitly call <code>delete</code> to destroy that object. You can do this if there are no references to that object. For transient objects, you must delete explicitly to destroy the object.</p>
<p>You should not call a delete operator on a persistent object. A persistent object that is not marked/dirty is freed by the garbage collector when its pin count is 0. However, for transient objects you must delete explicitly to destroy the object.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BAJIEEHG"></a><a id="LNCPP20167"></a>
<div class="sect1">
<h2 class="sect1">Migrating C++ Applications Using OCCI</h2>
<p>This section describes how to migrate existing C++ applications using OCCI.</p>
<p>The steps of migration are:</p>
<ol>
<li>
<p>Determine object model and class hierarchy</p>
</li>
<li>
<p>Use JDeveloper9<span class="italic">i</span> to map to Oracle object schema</p>
</li>
<li>
<p>Generate C++ header files using Oracle Type Translator</p>
</li>
<li>
<p>Modify old C++ access classes as required to work with new object type definitions</p>
</li>
<li>
<p>Add functionality for transient and persistent object management, as required.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1003644"></a><a id="LNCPP20169"></a>
<div class="sect1">
<h2 class="sect1">Overview of <a id="sthref245"></a>Associative Access</h2>
<p>You can employ SQL within OCCI to retrieve objects, and to perform DML operations.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1003409">Using SQL to Access Objects</a></p>
</li>
<li>
<p><a href="#i1003414">Inserting and Modifying Values</a></p>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1079">
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
</li>
</ul>
<a id="i1003409"></a><a id="LNCPP20170"></a>
<div class="sect2">
<h3 class="sect2">Using SQL to Ac<a id="sthref246"></a>cess Objects</h3>
<p>In the previous sections we discussed navigational access, where SQL is used only to fetch the references of an initial set of objects and then navigate from them to the other objects. Here we discuss how to fetch the objects using SQL.</p>
<p>The following example shows how to use the <code>ResultSet::getObject()</code> method to fetch objects through associative access where it gets each object from the table, <code>addr_tab</code>, using SQL:</p>
<pre>
string sel_addr_val = "SELECT VALUE(address) FROM ADDR_TAB address";

ResultSet *rs = stmt-&gt;executeQuery(sel_addr_val);

while (rs-&gt;next())
{
   ADDRESS *addr_val = rs-&gt;getObject(1); 
   cout &lt;&lt; "state: " &lt;&lt; addr_val-&gt;getState();
}
</pre>
<p>The objects fetched through associative access are termed value instances and they behave just like transient objects. Methods such as <code>markModified()</code>, <code>flush()</code>, and <code>markDeleted()</code> are applicable only for persistent objects.</p>
<p>Any changes made to these objects are not reflected in the database.</p>
<p>Since the object returned is a value instance, it is the user's responsibility to free memory by deleting the object pointer.</p>
</div>
<!-- class="sect2" -->
<a id="i1003414"></a><a id="LNCPP20171"></a>
<div class="sect2">
<h3 class="sect2">Inserting and<a id="sthref247"></a> Modifying Values</h3>
<p>We have just seen how to use SQL to access objects. OCCI also provides the ability to use SQL to insert new objects or modify existing objects in the database server through the <code>Statement::setObject</code> method interface.</p>
<p><a id="sthref248"></a>The following example creates a transient object <code>Address</code> and inserts it into the database table <code>addr_tab</code>:</p>
<pre>
ADDRESS *addr_val = new address("NV", "12563");  // new a transient instance
stmt-&gt;setSQL("INSERT INTO ADDR_TAB values(:1)");
stmt-&gt;setObject(1, addr_val);
stmt-&gt;execute();
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007163"></a><a id="LNCPP20172"></a>
<div class="sect1">
<h2 class="sect1">Overvi<a id="sthref249"></a>ew of Navigational Access</h2>
<p>By using navigational access, you engage in a series of operations.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1007201">Retrieving an Object Reference (REF) from the Database Server</a></p>
</li>
<li>
<p><a href="#i1007233">Pinning an Object</a></p>
</li>
<li>
<p><a href="#i1007266">Manipulating Object Attributes</a></p>
</li>
<li>
<p><a href="#i1007278">Marking Objects and Flushing Changes</a></p>
</li>
<li>
<p><a href="#BEIJBGGE">Marking an Object as Modified (Dirty)</a></p>
</li>
<li>
<p><a href="#BEIDBGDH">Recording Changes in the Database</a></p>
</li>
<li>
<p><a href="#i1010647">Collecting Garbage in the Object Cache</a></p>
</li>
<li>
<p><a href="#i1010648">Ensuring Transactional Consistency of References</a></p>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1079">
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
</li>
</ul>
<a id="i1007201"></a><a id="LNCPP20173"></a>
<div class="sect2">
<h3 class="sect2">Retrieving an Object Reference (REF) from the Database Server</h3>
<p>To work with objects, your application must first retrieve one or more objects from the database server. You accomplish this by issuing a SQL statement that returns references (<code>REF</code>s) to one or more objects.</p>
<p>It is also possible for a SQL statement to fetch value instances, rather than <code>REF</code>s, from a database.</p>
<p>The following SQL statement retrieves a <code>REF</code> to a single object <code>address</code> from the database table <code>addr_tab</code>:</p>
<pre>
string sel_addr = "SELECT REF(address) 
   FROM addr_tab address 
   WHERE zip_code = '94065'";
</pre>
<p>The following code example illustrates how to execute the query and fetch the <code>REF</code> from the result set.</p>
<pre>
ResultSet *rs = stmt-&gt;executeQuery(sel_addr);
rs-&gt;next();
Ref&lt;address&gt; addr_ref = rs-&gt;getRef(1);
</pre>
<p>At this point, you could use the object reference to access and manipulate the object or objects from the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="relational.htm#CHDHCIGI">"Executing SQL DDL and DML Statements"</a> for general information about preparing and executing SQL statements</div>
</div>
<!-- class="sect2" -->
<a id="i1007233"></a><a id="LNCPP20174"></a>
<div class="sect2">
<h3 class="sect2">Pinning an <a id="sthref250"></a><a id="sthref251"></a>Object<a id="sthref252"></a></h3>
<p>This section deals with a simple pin operation involving a single object at a time. For information about retrieving multiple objects through complex object retrieval, see the section <a href="#i1009758">Overview of Complex Object Retrieval</a>.</p>
<p>Upon completion of the fetch step, your application has a <code>REF</code> to an object. The actual object is not currently available to work with. Before you can manipulate an object, it must be <span class="bold">pinn<a id="sthref253"></a>ed</span>. Pinning an object loads the object into the object cache, and enables you to access and modify the object's attributes and follow references from that object to other objects. Your application also controls when modified objects are written back to the database server.</p>
<p>OCCI requires only that you dereference the <code>REF</code> in the same way you would dereference any C++ pointer. Dereferencing the <code>REF</code> transparently materializes the object as a C++ class instance.</p>
<p>Continuing the <code>Address</code> class example from the previous section, assume that the user has added the following method:</p>
<pre>
string  Address::getState()
{
   return state;
}
</pre>
<p>To dereference this <code>REF</code> and access the object's attributes and methods:</p>
<pre>
string state = addr_ref-&gt;getState();     // -&gt; pins the object
</pre>
<p>The first time <code>Ref&lt;T&gt;</code> <code>(addr_ref)</code> is dereferenced, the object is pinned, which is to say that it is loaded into the object cache from the database server. From then on, the behavior of operator <code>-&gt;</code> on <code>Ref&lt;T&gt;</code> is just like that of any C++ pointer <code>(T *)</code>. The object remains in the object cache until the <code>REF</code> <code>(addr_ref)</code> goes out of scope. It then becomes eligible for garbage collection.</p>
<p>Now that the object has been pinned, your application can modify that object.</p>
</div>
<!-- class="sect2" -->
<a id="i1007266"></a><a id="LNCPP20175"></a>
<div class="sect2">
<h3 class="sect2">Manipula<a id="sthref254"></a><a id="sthref255"></a>ting Object Attributes</h3>
<p>Manipulating object attributes is no different from that of accessing them as shown in the previous section. Let us assume the <code>Address</code> class has the following user defined method that sets the <code>state</code> attribute to the input value:</p>
<pre>
void Address::setState(string new_state)
{
   state = new_state;
}
</pre>
<p>The following example shows how to modify the state attribute of the object, <code>addr</code>:</p>
<pre>
addr_ref-&gt;setState("PA");
</pre>
<p>As explained earlier, the first invocation of the operator <code>-&gt;</code> on <code>Ref&lt;T&gt;</code> loads the object, if it is not in the object cache.</p>
</div>
<!-- class="sect2" -->
<a id="i1007278"></a><a id="LNCPP20176"></a>
<div class="sect2">
<h3 class="sect2">Marking O<a id="sthref256"></a>b<a id="sthref257"></a>jects and Flushing Changes</h3>
<p>In the example in the previous section, an attribute of an object was changed. This change exists only in the client-side cache; you must implement specific programmatic steps to write the changes to the database.</p>
</div>
<!-- class="sect2" -->
<a id="BEIJBGGE"></a><a id="LNCPP20177"></a>
<div class="sect2">
<h3 class="sect2">Marking an<a id="sthref258"></a> Object as Modified (Dirty)</h3>
<p>The first step is to indicate that the object has been modified. This is done by calling the <code>markModified()</code> method on the object (derived method of <code>PObject</code>). This method marks the object as <span class="bold">dirty</span> (modified).</p>
<p>Continuing the previous example, after object attributes are manipulated, the object referred to by <code>addr_ref</code> can be marked dirty as follows:</p>
<pre>
addr_ref-&gt;markModified();
</pre></div>
<!-- class="sect2" -->
<a id="BEIDBGDH"></a><a id="LNCPP20178"></a>
<div class="sect2">
<h3 class="sect2">Recording Changes in<a id="sthref259"></a> the Database</h3>
<p>Objects that have had their dirty flag set must be flushed to the database server for the changes to be recorded in the database. This can be done in three ways:</p>
<ul>
<li>
<p>Flush a single object marked dirty by calling the method <code>flush</code>, a derived method of <code>PObject</code>.</p>
</li>
<li>
<p>Flush the entire object cache using the <code>Connection::flushCache()</code> method. In this case, OCCI traverses the dirty list maintained by the object cache and flushes all the dirty objects.</p>
</li>
<li>
<p>Commit a transaction by calling the <code>Connection::commit()</code> method. Doing so also traverses the dirty list and flushes the objects to the database server. The dirty list includes newly created persistent objects.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1010647"></a><a id="LNCPP20179"></a>
<div class="sect2">
<h3 class="sect2">Collecting Garbage in the Object Cache</h3>
<p>The object cache has two important associated parameters:</p>
<ul>
<li>
<p>The maximum cache size percentage</p>
</li>
<li>
<p>The optimal cache size</p>
</li>
</ul>
<p>These parameters refer to levels of cache memory usage, and they help determine when the cache automatically 'ages out' eligible objects to free up memory.</p>
<p>If the memory occupied by the objects currently in the cache reaches or exceeds the maximum cache size, the cache automatically begins to free (or age out) unmarked objects which have a pin count of zero. The cache continues freeing such objects until memory usage in the cache reaches the optimal size, or until it runs out of objects eligible for freeing. Note that the cache can grow beyond the specified maximum cache size.</p>
<p>The maximum object cache size (in bytes) is computed by incrementing the optimal cache size (<code>optimal_size</code>) by the maximum cache size percentage (<code>max_size_percentage</code>), as follows:</p>
<pre>
Maximum cache size = optimal_size + optimal_size * max_size_percentage / 100;
</pre>
<p>The default value for the maximum cache size percentage is 10%. The default value for the optimal cache size is 8MB. When a persistent object is created through the overloaded <code>PObject::new()</code> operator, the newly created object is marked dirty and its pin count is set to <code>0</code>.</p>
<p>These parameters can be set or retrieved using the following member functions of the Environment class:</p>
<ul>
<li>
<p><code>void setCacheMaxSize(unsigned int maxSize);</code></p>
</li>
<li>
<p><code>unsigned int getCacheMaxSize() const;</code></p>
</li>
<li>
<p><code>void setCacheOptSize(unsigned int OptSize);</code></p>
</li>
<li>
<p><code>unsigned int getCacheOptSize() const;</code></p>
</li>
</ul>
<p><a href="#i1010314">"Pin Object"</a> describes how pin count of an object functions as a reference count and how an unmarked object with a <code>0</code> pin count can become eligible for garbage collection. For a newly created persistent object, the object is unmarked after the transaction is committed or aborted, and if the object has a <code>0</code> pin count. Because nothing is referencing this object, it becomes a candidate for ageing out.</p>
<p>If you are working with several object that have a large number of string or collection attributes, most of the memory is allocated from the C++ heap; this is because OCCI uses STLs. You should therefore set the cache size to a low value to avoid high memory use before garbage collection activates.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="reference.htm#CIAJIDCF">Chapter 13, "OCCI Application Programming Interface"</a> for details.</div>
</div>
<!-- class="sect2" -->
<a id="i1010648"></a><a id="LNCPP20180"></a>
<div class="sect2">
<h3 class="sect2">Ensuring Transactional Consistency of References</h3>
<p>As described in the previous section, dereferencing a <code>Ref&lt;T&gt;</code> for the first time results in the object being loaded into the object cache from the database server. From then on, the behavior of operator <code>-&gt;</code> on <code>Ref&lt;T&gt;</code> equals any C++ pointer, and it provides access to the object copy in the cache. But when the transaction commits or aborts, the object copy in the cache can no longer be valid because it could be modified by any other client. Therefore, after the transaction ends, when the <code>Ref&lt;T&gt;</code> is again dereferenced, the object cache recognizes the fact that the object is no longer valid and fetches the most recent copy from the database server.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009758"></a><a id="LNCPP20181"></a>
<div class="sect1">
<h2 class="sect1">Overview o<a id="sthref260"></a>f Complex Object Retrieval</h2>
<p>In the examples discussed earlier, only a single object was fetched or pinned at a time. In these cases, each pin operation involved a separate database server round-trip to retrieve the object.</p>
<p>Object-oriented applications often model their problems as a set of interrelated objects that form graphs of objects. These applications process objects by starting with some initial set of objects and then using the references in these objects to traverse the remaining objects. In a client/server setting, each of these traversals could result in costly network round-trips to fetch objects.</p>
<p>The performance of such applications can be increased with <span class="bold">complex object retrieval</span> (COR). This is a prefetching mechanism in which an application specifies some criteria (content and boundary) for retrieving a set of linked objects in a single network round-trip. Using COR does not mean that these prefetched objects are pinned. They are fetched into the object cache, so that subsequent pin calls are local operations.</p>
<p>A <span class="bold">comple<a id="sthref261"></a>x ob<a id="sthref262"></a>ject</span> is a set of logically related objects consisting of a root object, and a set of objects each of which is prefetched based on a given depth level. The <span class="bold">ro<a id="sthref263"></a><a id="sthref264"></a>ot</span> object is explicitly fetched or pinned. The <span class="bold">d<a id="sthref265"></a>epth</span> <span class="bold">le<a id="sthref266"></a>vel</span> is the shortest number of references that have to be traversed from the root object to a given prefetched object in a complex object.</p>
<p>An application specifies a complex object by describing its content and boundary. The fetching of complex objects is constrained by an environment's <span class="bold">prefetc<a id="sthref267"></a><a id="sthref268"></a>h limit</span>, the amount of memory in the object cache that is available for prefetching objects.</p>
<p>The use of complex object retrieval does not add functionality; it only improves performance, and so its use is optional.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BEICCIEA">Retrieving Complex Objects</a></p>
</li>
<li>
<p><a href="#BEIBDGIC">Prefetching Complex Objects</a></p>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1079">
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
</li>
</ul>
<a id="BEICCIEA"></a><a id="LNCPP20182"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref269"></a>Retrieving Co<a id="sthref270"></a>mplex Objects</h3>
<p>An OCCI application can achieve COR by setting the appropriate attributes of a <code>Ref&lt;T&gt;</code> before dereferencing it using the following methods:</p>
<pre>
// prefetch attributes of the specified type name up to the specified depth
Ref&lt;T&gt;::setPrefetch(const string &amp;typeName, unsigned int depth);
// prefetch all the attribute types up to the specified depth.
Ref&lt;T&gt;::setPrefetch(unsigned int depth);
</pre>
<p>The application can also choose to fetch all objects reachable from the root object by way of REFs (transitive closure) to a certain depth. To do so, set the level parameter to the depth desired. For the preceding two examples, the application could also specify <code>(PO object REF, OCCI_MAX_PREFETCH_DEPTH)</code> and <code>(PO object REF, 1)</code> respectively to prefetch required objects. Doing so results in many extraneous fetches but is quite simple to specify, and requires only one database server round-trip.</p>
<p>As an example for this discussion, consider the following type declaration:</p>
<pre>
CREATE TYPE customer(...);
CREATE TYPE line_item(...);
CREATE TYPE line_item_varray as VARRAY(100) of REF line_item;
CREATE TYPE purchase_order AS OBJECT
   ( po_number         NUMBER, 
    cust              REF customer,
    related_orders    REF purchase_order,
    line_items        line_item_varray);
</pre>
<p>The <code>purchase_order</code> type contains a scalar value for <code>po_number</code>, a <code>VARRAY</code> of <code>line_items</code>, and two references. The first is to a <code>customer</code> type and the second is to a <code>purchase_order</code> type, indicating that this type can be implemented as a linked list.</p>
<p>When fetching a complex object, an application must specify the following:</p>
<ul>
<li>
<p>A reference to the desired root object</p>
</li>
<li>
<p>One or more pairs of type and depth information to specify the boundaries of the complex object. The type information indicates which <code>REF</code> attributes should be followed for COR, and the depth level indicates how many levels deep those links should be followed.</p>
</li>
</ul>
<p>In the case of the <code>purchase_order</code> object in the preceding example, the application must specify the following:</p>
<ul>
<li>
<p>The reference to the root <code>purchase_order</code> object</p>
</li>
<li>
<p>One or more pairs of type and depth information for <code>customer</code>, <code>purchase_order</code>, or <code>line_item</code></p>
</li>
</ul>
<p>An application prefetching a purchase order needs access to the customer information for that purchase order. Using simple navigation, this would require two database server accesses to retrieve the two objects.</p>
<p>Through complex object retrieval, <code>customer</code> can be prefetched when the application pins the <code>purchase_order</code> object. In this case, the complex object would consist of the <code>purchase_order</code> object and the <code>customer</code> object it references.</p>
<p>In the previous example, if the application wanted to prefetch a purchase order and the related customer information, the application would specify the <code>purchase_order</code> object and indicate that <code>customer</code> should be followed to a depth level of one as follows:</p>
<pre>
Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch("CUSTOMER",1);
</pre>
<p>If the application wanted to prefetch a <code>purchase order</code> and all objects in the object graph it contains, the application would specify the <code>purchase_order</code> object and indicate that both <code>customer</code> and <code>purchase_order</code> should be followed to the maximum depth level possible as follows:</p>
<pre>
Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch("CUSTOMER", OCCI_MAX_PREFETCH_DEPTH);
poref.setPrefetch("PURCHASE_ORDER", OCCI_MAX_PREFETCH_DEPTH);
</pre>
<p>where <code>OCCI_MAX_PREFETCH_DEPTH</code> specifies that all objects of the specified type reachable through references from the root object should be prefetched.</p>
<p>If an application wanted to prefetch a purchase order and all the line items associated with it, the application would specify the <code>purchase_order</code> object and indicate that <code>line_items</code> should be followed to the maximum depth level possible as follows:</p>
<pre>
Ref&lt;PURCHASE_ORDER&gt; poref;
poref.setPrefetch("LINE_ITEM", 1);
</pre></div>
<!-- class="sect2" -->
<a id="BEIBDGIC"></a><a id="LNCPP20183"></a>
<div class="sect2">
<h3 class="sect2">Prefetching Com<a id="sthref271"></a>plex Objects</h3>
<p>After specifying and fetching a complex object, subsequent fetches of objects contained in the complex object do not incur the cost of a network round-trip, because these objects have been prefetched and are in the object cache. Keep in mind that excessive prefetching of objects can lead to a flooding of the object cache. This flooding, in turn, may force out other objects that the application had pinned, leading to a performance degradation instead of performance improvement.</p>
<p>Note that if there is insufficient memory in the object cache to hold all prefetched objects, some objects may not be prefetched. The application then incurs a network round-trip when those objects are accessed later.</p>
<p>You must have the <code>SELECT</code> privilege for all prefetched objects. Objects in the complex object for which the application does not have <code>SELECT</code> privilege cannot prefetched.</p>
<p>An entire vector of <code>Ref</code>s can be prefetched into object cache in a single round-trip by using the global <a href="reference010.htm#CACCCEJG">pinVectorOfRefs()</a> method of the <a href="reference010.htm#i1118650">Connection Class</a>. This method reduces the number of round-trips for an <code>n</code>-sized vector of <code>Ref</code>s from <code>n</code> to <code>1</code>, and tracks the newly pinned objects through an <code>OUT</code> parameter vector.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1003654"></a><a id="LNCPP20184"></a>
<div class="sect1">
<h2 class="sect1">Working with <a id="sthref272"></a>Collections</h2>
<p>Oracle supports two kinds of collections - variable length arrays (ordered collections) and nested tables (unordered collections). OCCI maps both of them to a Standard Template Library (STL) vector container, giving you the full power, flexibility, and speed of an STL vector to access and manipulate the collection elements. <a href="#BEIJBAIA">Example 4-9</a> shows the SQL DDL to create a <code>VARRAY</code> and an object that contains an attribute of type <code>VARRAY</code>, and the resulting C++ declaration that OTT generates.</p>
<div class="example">
<p class="titleinexample"><a id="BEIJBAIA"></a><a id="LNCPP21905"></a>Example 4-9 How to Create a VARRAY Collection</p>
<pre>
CREATE TYPE ADDR_LIST AS VARRAY(3) OF REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (name VARCHAR2(20), addr_l ADDR_LIST);
</pre>
<p>Here is the C++ class declaration generated by OTT:</p>
<pre>
class PERSON : public PObject
{
   protected:
      string name;
      vector&lt; Ref&lt; ADDRESS &gt; &gt; addr_1;

   public:
      void *operator new(size_t size); 
      void *operator new(size_t size,
      const Connection* conn,
      const string&amp; table); 
      string  getSQLTypeName() const;
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      PERSON (void *ctx) : PObject(ctx) { };
      static void *readSQL(void *ctx);
      virtual void readSQL(AnyData&amp; stream);
      static void writeSQL(void *obj, void *ctx);
      virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
<!-- class="example" -->
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1079">
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075">
<p class="notep1">See Also:</p>
complete code listing of the demonstration programs</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<a id="LNCPP20185"></a>
<div class="sect2"><a id="sthref273"></a>
<h3 class="sect2">Fetching Emb<a id="sthref274"></a>edded Objects<a id="sthref275"></a></h3>
<p>If your application must fetch an embedded object, which is an object stored in a column of a regular table rather than an object table, you cannot use the <code>REF</code> retrieval mechanism. Embedded instances do not have object identifiers, so it is not possible to get a reference to them. Therefore, they cannot serve as the basis for object navigation. There are still many situations, however, in which an application fetches embedded instances.</p>
<p>For example, assume that an <code>address</code> type has been created.</p>
<pre>
CREATE TYPE address AS OBJECT
(  street1             varchar2(50),
   street2             varchar2(50),
   city                varchar2(30),
   state               char(2),
   zip                 number(5));
</pre>
<p>You could then use that type as the data type of a column in another table:</p>
<pre>
CREATE TABLE clients
( name          varchar2(40),
   addr          address);
</pre>
<p>Your OCCI application could then issue the following SQL statement:</p>
<pre>
SELECT addr FROM clients
WHERE name='BEAR BYTE DATA MANAGEMENT';
</pre>
<p>This statement would return an embedded <code>address</code> object from the <code>clients</code> table. The application could then use the values in the attributes of this object for other processing. The application should execute the statement and fetch the object in the same way as described in the section <a href="#i1003644">"Overview of Associative Access"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="LNCPP20186"></a>
<div class="sect2"><a id="sthref276"></a>
<h3 class="sect2">Nu<a id="sthref277"></a>llness</h3>
<p>If a column in a row of a database table has no value, then that column is said to be <code>NULL</code>, or to contain a <code>NULL</code>. Two different types of <code>NULL</code>s can apply to objects:</p>
<ul>
<li>
<p>Any attribute of an object can have a <code>NULL</code> value. This indicates that the value of that attribute of the object is not known.</p>
</li>
<li>
<p>An object may be <span class="bold">atomic<a id="sthref278"></a>ally NULL</span>. Therefore, the value of the entire object is unknown.</p>
</li>
</ul>
<p>Atomic <code>NULL</code>ness is different from nonexistence. An atomically <code>NULL</code> object still exists, its value is just not known. It may be thought of as an existing object with no data.</p>
<p>For every type of object attribute, OCCI provides a corresponding class. For instance, <code>NUMBER</code> attribute type maps to the <code>Number</code> class, <code>REF</code> maps to <code>RefAny</code>, and so on. Each and every OCCI class that represents a data type provides two methods:</p>
<ul>
<li>
<p><code>isNull()</code> &mdash; returns whether the object is <code>NULL</code></p>
</li>
<li>
<p><code>setNull()</code> &mdash; sets the object to <code>NULL</code></p>
</li>
</ul>
<p>Similarly, these methods are inherited from the <code>PObject</code> class by all the objects and can be used to access and set atomically <code>NULL</code> information about them.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007323"></a><a id="LNCPP20187"></a>
<div class="sect1">
<h2 class="sect1">Using Obj<a id="sthref279"></a><a id="sthref280"></a>ect References</h2>
<p>OCCI provides the application with the flexibility to access the contents of the objects using their pointers or their references. OCCI provides the <code>PObject::getRef()</code> method to return a reference to a persistent object. This call is valid for persistent objects only.</p>
</div>
<!-- class="sect1" -->
<a id="i1007327"></a><a id="LNCPP20188"></a>
<div class="sect1">
<h2 class="sect1">Deleting Objects from the Database</h2>
<p>OCCI users can use the overloaded <code>PObject::operator</code> <code>new()</code> to create the persistent objects. However, to delete the object from the database server, it is best to call <code>ref</code>.<a href="reference023.htm#i1072305">markDelete()</a> directly on the <code>Ref</code>; this prevents the object from getting into the client cache. If the object is in the client cache, it can be removed by an <code>obj</code>.<a href="reference023.htm#i1072305">markDelete()</a> call on the object. The object marked for deletion is permanently removed when the transaction commits.</p>
</div>
<!-- class="sect1" -->
<a id="CIHHEFEH"></a><a id="LNCPP20189"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref281"></a>Type Inheritance</h2>
<p>Type inheritance of objects has many similarities to inheritance in C++ and Java. You can create an object type as a subtype of an existing object type. The subtype is said to inherit all the attributes and methods (member functions and procedures) of the supertype, which is the original type. Only single inheritance is supported; an object cannot have multiple supertypes. The subtype can add new attributes and methods to the ones it inherits. It can also override (redefine the implementation) of any of its inherited methods. A subtype is said to extend (that is, inherit from) its supertype.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ00107" href="../../appdev.112/e11822/adobjint.htm#ADOBJ00107"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for a more complete discussion of this topic</div>
<p>As an example, a type <code>Person_t</code> can have a subtype <code>Student_t</code> and a subtype <code>Employee_t</code>. In turn, <code>Student_t</code> can have its own subtype, <code>PartTimeStudent_t</code>. A type declaration must have the flag <code>NOT FINAL</code> so that it can have subtypes. The default is <code>FINAL</code>, which means that the type can have no subtypes.</p>
<p>All types discussed so far in this chapter are <code>FINAL</code>. All types in applications developed before Oracle Database release 8.1.7 are <code>FINAL</code>. A type that is <code>FINAL</code> can be altered to be <code>NOT FINAL</code>. A <code>NOT FINAL</code> type with no subtypes can be altered to be <code>FINAL</code>. <code>Person_ t</code> is declared as <code>NOT FINAL</code> for our example:</p>
<pre>
CREATE TYPE Person_t AS OBJECT
(  ssn NUMBER,
   name VARCAHR2(30),
   address VARCHAR2(100)) NOT FINAL; 
</pre>
<p>A subtype inherits all the attributes and methods declared in its supertype. It can also declare new attributes and methods, which must have different names than those of the supertype. The keyword <code>UNDER</code> identifies the supertype, like this:</p>
<pre>
CREATE TYPE Student_t UNDER Person_t
(  deptid NUMBER,
   major  VARCHAR2(30)) NOT FINAL;
</pre>
<p>The newly declared attributes <code>deptid</code> and <code>major</code> belong to the subtype <code>Student_t</code>. The subtype <code>Employee_t</code> is declared as, for example:</p>
<pre>
CREATE TYPE Employee_t UNDER Person_t
(  empid NUMBER,
   mgr   VARCHAR2(30));
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1005167">"OTT Support for Type Inheritance"</a> for the classes generated by OTT for this example.</p>
</li>
</ul>
</div>
<p>Subtype <code>Student_t</code> can have its own subtype, such as <code>PartTimeStudent_t</code>:</p>
<pre>
CREATE TYPE PartTimeStuden_t UNDER Student_t ( numhours NUMBER) ;
</pre>
<a id="LNCPP20190"></a>
<div class="sect2"><a id="sthref282"></a>
<h3 class="sect2">Substitutabi<a id="sthref283"></a>lity</h3>
<p>The benefits of polymorphism derive partially from the property substitutability. Substitutability allows a value of some subtype to be used by code originally written for the supertype, without any specific knowledge of the subtype being needed in advance. The subtype value behaves to the surrounding code just like a value of the supertype would, even if it perhaps uses different mechanisms within its specializations of methods.</p>
<p>Instance substitutability refers to the ability to use an object value of a subtype in a context declared in terms of a supertype. <code>REF</code> substitutability refers to the ability to use a <code>REF</code> to a subtype in a context declared in terms of a <code>REF</code> to a supertype.</p>
<p><code>REF</code> type attributes are substitutable, that is, an attribute defined as <code>REF T</code> can hold a <code>REF</code> to an instance of <code>T</code> or any of its subtypes.</p>
<p>Object type attributes are substitutable, that is, an attribute defined to be of (an object) type <code>T</code> can hold an instance of <code>T</code> or any of its subtypes.</p>
<p>Collection element types are substitutable, that is, if we define a collection of elements of type <code>T</code>, then it can hold instances of type <code>T</code> and any of its subtypes. Here is an example of object attribute substitutability:</p>
<pre>
CREATE TYPE Book_t AS OBJECT 
(  title VARCHAR2(30),
   author Person_t     /* substitutable */);
</pre>
<p>Thus, a <code>Book_t</code> instance can be created by specifying a title string and a <code>Person_t</code> (or any subtype of <code>Person_t</code>) object:</p>
<pre>
Book_t('My Oracle Experience',
   Employee_t(12345, 'Joe', 'SF', 1111, NULL))
</pre></div>
<!-- class="sect2" -->
<a id="LNCPP20191"></a>
<div class="sect2"><a id="sthref284"></a>
<h3 class="sect2">NOT INSTANTIABLE Types and Methods</h3>
<p>A type can be declared <code>NOT INSTANTIABLE</code>, which means that there is no constructor (default or user defined) for the type. Thus, it is not be possible to construct instances of this type. The typical usage would be to define instantiable subtypes for such a type. Here is how this property is used:</p>
<pre>
CREATE TYPE Address_t AS OBJECT(...) NOT INSTANTIABLE NOT FINAL;
CREATE TYPE USAddress_t UNDER Address_t(...);
CREATE TYPE IntlAddress_t UNDER Address_t(...);
</pre>
<p>A method of a type can be declared to be <code>NOT INSTANTIABLE</code>. Declaring a method as <code>NOT INSTANTIABLE</code> means that the type is not providing an implementation for that method. Further, a type that contains any <code>NOT INSTANTIABLE</code> methods must necessarily be declared as <code>NOT INSTANTIABLE</code>. For example:</p>
<pre>
CREATE TYPE T AS OBJECT
(  x NUMBER,
   NOT INSTANTIABLE MEMBER FUNCTION func1() RETURN NUMBER 
) NOT INSTANTIABLE;
</pre>
<p>A subtype of <code>NOT INSTANTIABLE</code> can override any of the <code>NOT INSTANTIABLE</code> methods of the supertype and provide concrete implementations. If there are any <code>NOT INSTANTIABLE</code> methods remaining, the subtype must also necessarily be declared as <code>NOT INSTANTIABLE</code>.</p>
<p>A <code>NOT INSTANTIABLE</code> subtype can be defined under an instantiable supertype. Declaring a <code>NOT INSTANTIABLE</code> type to be <code>FINAL</code> is not useful and is not allowed.</p>
</div>
<!-- class="sect2" -->
<a id="LNCPP20192"></a>
<div class="sect2"><a id="sthref285"></a>
<h3 class="sect2">OCCI Support for Type Inh<a id="sthref286"></a>eritance</h3>
<p>The following calls support type inheritance.</p>
<a id="LNCPP20193"></a>
<div class="sect3"><a id="sthref287"></a>
<h4 class="sect3">Connection::getMetaData()</h4>
<p>This method provides information specific to inherited types. Additional attributes have been added for the properties of inherited types. For example, you can get the supertype of a type.</p>
</div>
<!-- class="sect3" -->
<a id="LNCPP20194"></a>
<div class="sect3"><a id="sthref288"></a>
<h4 class="sect3">Bind and Define Functions</h4>
<p>The <code>setRef()</code>, <code>setObject()</code> and <code>setVector()</code> methods of the <code>Statement</code> class are used to bind <code>REF</code>, object, and collections respectively. All these functions support <code>REF</code>, instance, and collection element substitutability. Similarly, the corresponding <code>get</code><code><span class="codeinlineitalic">xxx</span></code><code>()</code> methods to fetch the data also support substitutability.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005167"></a><a id="LNCPP20195"></a>
<div class="sect2">
<h3 class="sect2">OTT Support for Ty<a id="sthref289"></a>pe Inheritance</h3>
<p>Class declarations for objects with inheritance are similar to the simple object declarations except that the class is derived from the parent type class and only the fields corresponding to attributes not in the parent class are included. The structure for these declarations is listed in <a href="#CIHFBACF">Example 4-10</a>:</p>
<div class="example">
<p class="titleinexample"><a id="CIHFBACF"></a><a id="LNCPP20196"></a>Example 4-10 OTT Support Inheritance</p>
<pre>
class &lt;typename&gt; : public &lt;parentTypename&gt; 
{
   protected:
      &lt;OCCItype1&gt; &lt;attributename1&gt;;
      ...
      &lt;OCCItypen&gt; &lt;attributenamen&gt;;

   public:
      void *operator new(size_t size); 
      void *operator new(size_t size, const Connection* conn, 
                          const string&amp; table); 
      string  getSQLTypeName() const;
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      &lt;typename&gt; (void *ctx) : &lt;parentTypename&gt;(ctx) { };
      static void *readSQL(void *ctx);
      virtual void readSQL(AnyData&amp; stream);
      static void writeSQL(void *obj, void *ctx);
      virtual void writeSQL(AnyData&amp; stream);
}
</pre></div>
<!-- class="example" -->
<p>In this structure, all variables are the same as in the simple object case. <code>parentTypename</code> refers to the name of the parent type, that is, the class name of the type from which typename inherits.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005035"></a><a id="LNCPP20197"></a>
<div class="sect1">
<h2 class="sect1">A Sam<a id="sthref290"></a>ple OCCI Application</h2>
<p>This section describes a sample OCCI application that uses some features discussed in this chapter.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20198"></a><a id="sthref291"></a>Example 4-11 Listing of demo2.sql for a Sample OCCI Application</p>
<pre>
drop table ADDR_TAB
/
drop table PERSON_TAB
/
drop type STUDENT
/
drop type PERSON
/
drop type ADDRESS_TAB
/
drop type ADDRESS
/
drop type FULLNAME
/
CREATE TYPE FULLNAME AS OBJECT (first_name CHAR(20), last_name CHAR(20))
/
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20)) 
/
CREATE TYPE ADDRESS_TAB  AS VARRAY(3) OF REF ADDRESS
/
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULLNAME,curr_addr REF ADDRESS, 
prev_addr_l ADDRESS_TAB) NOT FINAL
/
CREATE TYPE STUDENT UNDER  PERSON (school_name CHAR(20))
/
CREATE TABLE ADDR_TAB OF ADDRESS
/
CREATE TABLE PERSON_TAB OF PERSON
/
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="CIHEEFFI"></a><a id="LNCPP20199"></a>Example 4-12 Listing of demo2.typ for a Sample OCCI Application</p>
<pre>
TYPE FULLNAME GENERATE CFullName as MyFullName
TYPE ADDRESS GENERATE CAddress as MyAddress
TYPE PERSON GENERATE CPerson as MyPerson
TYPE STUDENT GENERATE CStudent as MyStudent
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20200"></a><a id="sthref292"></a>Example 4-13 Listing of OTT Command that Generates Files for a Sample OCCI Application</p>
<p>OTT attempts to connect with username <code>demousr</code>; the system prompts for the password.</p>
<pre>
ott userid=demousr intype=demo2.typ code=cpp hfile=demo2.h
   cppfile=demo2.cpp mapfile=mappings.cpp attraccess=private
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20201"></a><a id="sthref293"></a>Example 4-14 Listing of mappings.h for a Sample OCCI Application</p>
<pre>
#ifndef MAPPINGS_ORACLE
# define MAPPINGS_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

#ifndef DEMO2_ORACLE
# include "demo2.h"
#endif

void mappings(oracle::occi::Environment* envOCCI_);

#endif
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20202"></a><a id="sthref294"></a>Example 4-15 Listing of mappings.cpp for a Sample OCCI Application</p>
<pre>
#ifndef MAPPINGS_ORACLE
# include "mappings.h"
#endif

void mappings(oracle::occi::Environment* envOCCI_)
{
  oracle::occi::Map *mapOCCI_ = envOCCI_-&gt;getMap();
  mapOCCI_-&gt;put("HR.FULLNAME", &amp;CFullName::readSQL, &amp;CFullName::writeSQL);
  mapOCCI_-&gt;put("HR.ADDRESS", &amp;CAddress::readSQL, &amp;CAddress::writeSQL);
  mapOCCI_-&gt;put("HR.PERSON", &amp;CPerson::readSQL, &amp;CPerson::writeSQL);
  mapOCCI_-&gt;put("HR.STUDENT", &amp;CStudent::readSQL, &amp;CStudent::writeSQL);
}
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20203"></a><a id="sthref295"></a>Example 4-16 Listing of demo2.h for a Sample OCCI Application</p>
<pre>
#ifndef DEMO2_ORACLE
# define DEMO2_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

using namespace std;
using namespace oracle::occi;

class MyFullName;
class MyAddress;
class MyPerson;
/*   Changes ended here */

/*  GENERATED DECLARATIONS FOR THE FULLNAME OBJECT TYPE. */
class CFullName : public oracle::occi::PObject {

private:
   OCCI_STD_NAMESPACE::string FIRST_NAME;
   OCCI_STD_NAMESPACE::string LAST_NAME;

public:   OCCI_STD_NAMESPACE::string getFirst_name() const;
   void setFirst_name(const OCCI_STD_NAMESPACE::string &amp;value);
   OCCI_STD_NAMESPACE::string getLast_name() const;
   void setLast_name(const OCCI_STD_NAMESPACE::string &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CFullName();
   CFullName(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CFullName();
};

/* GENERATED DECLARATIONS FOR THE ADDRESS OBJECT TYPE. */ 
class CAddress : public oracle::occi::PObject {

private:
   OCCI_STD_NAMESPACE::string STATE;
   OCCI_STD_NAMESPACE::string ZIP;

public:
   OCCI_STD_NAMESPACE::string getState() const;
   void setState(const OCCI_STD_NAMESPACE::string &amp;value);
   OCCI_STD_NAMESPACE::string getZip() const;
   void setZip(const OCCI_STD_NAMESPACE::string &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CAddress();
   CAddress(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CAddress();
};

/* GENERATED DECLARATIONS FOR THE PERSON OBJECT TYPE. */
class CPerson : public oracle::occi::PObject {

private:
   oracle::occi::Number ID;
   MyFullName * NAME;
   oracle::occi::Ref&lt; MyAddress &gt; CURR_ADDR;
   OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt; PREV_ADDR_L;

public:   oracle::occi::Number getId() const;
   void setId(const oracle::occi::Number &amp;value);
   MyFullName * getName() const;
   void setName(MyFullName * value);
   oracle::occi::Ref&lt; MyAddress &gt; getCurr_addr() const;
   void setCurr_addr(const oracle::occi::Ref&lt; MyAddress &gt; &amp;value);
   OCCI_STD_NAMESPACE::vector&lt;oracle::occi::Ref&lt; MyAddress&gt;&gt;&amp; 
      getPrev_addr_l();
   const OCCI_STD_NAMESPACE::vector&lt;oracle::occi::Ref&lt;MyAddress&gt;&gt;&amp; 
      getPrev_addr_l() const;
   void setPrev_addr_l(const OCCI_STD_NAMESPACE::vector 
      &lt;oracle::occi::Ref&lt; MyAddress &gt; &gt; &amp;value);
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CPerson();
   CPerson(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CPerson();
};

/* GENERATED DECLARATIONS FOR THE STUDENT OBJECT TYPE. */
/*  changes to the generated file - declarations for the MyPerson class. */
class MyPerson : public CPerson {

public:
      MyPerson(Number id_i, MyFullName *name_i, const Ref&lt;MyAddress&gt;&amp; addr_i) ;
      MyPerson(void *ctxOCCI_);
      void move(const Ref&lt;MyAddress&gt;&amp; new_addr);
      void displayInfo();
      MyPerson();
};
/* changes  end here */

class CStudent : public MyPerson {
private:
   OCCI_STD_NAMESPACE::string SCHOOL_NAME;

public:
   OCCI_STD_NAMESPACE::string getSchool_name() const;
   void setSchool_name(const OCCI_STD_NAMESPACE::string &amp;value);\
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,\
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   string  getSQLTypeName() const;
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   CStudent();
   CStudent(void *ctxOCCI_) : MyPerson (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~CStudent();
};

/*changes  made to the generated file */
/* declarations for the MyFullName class. */
class MyFullName : public  CFullName
{  public:
      MyFullName(string first_name, string last_name);
      void displayInfo();
      MyFullName(void *ctxOCCI_);
};

// declarations for the MyAddress class.
class MyAddress : public CAddress
{  public:
      MyAddress(string state_i, string zip_i);
      void displayInfo();
      MyAddress(void *ctxOCCI_);
};

class MyStudent : public CStudent
{
  public :
     MyStudent(void *ctxOCCI_) ;
};
/* changes end here */ 
#endif
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20204"></a><a id="sthref296"></a>Example 4-17 Listing of demo2.cpp for a Sample OCCI Application</p>
<pre>
#ifndef DEMO2_ORACLE
# include "demo2.h"
#endif

/* GENERATED METHOD IMPLEMENTATIONS FOR THE FULLNAME OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CFullName::getFirst_name() const
{
  return FIRST_NAME;
}

void CFullName::setFirst_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  FIRST_NAME = value;
}

OCCI_STD_NAMESPACE::string CFullName::getLast_name() const
{
  return LAST_NAME;
}

void CFullName::setLast_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  LAST_NAME = value;
}

void *CFullName::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CFullName::operator new(size_t size, const oracle::occi::Connection *
  sess,  const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.FULLNAME");
}

void *CFullName::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CFullName::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CFullName::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.FULLNAME");
}

void CFullName::getSQLTypeName(oracle::occi::Environment *env,
     void  **schemaName, unsigned int &amp;schemaNameLen, void **typeName,
     unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CFullName::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CFullName::CFullName()
{
}

void *CFullName::readSQL(void *ctxOCCI_)
{
  MyFullName *objOCCI_ = new(ctxOCCI_) MyFullName(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CFullName::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   FIRST_NAME = streamOCCI_.getString();
   LAST_NAME = streamOCCI_.getString();
}

void CFullName::writeSQL(void *objectOCCI_, void *ctxOCCI_){
  CFullName *objOCCI_ = (CFullName *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CFullName::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setString(FIRST_NAME);
   streamOCCI_.setString(LAST_NAME);
}

CFullName::~CFullName()
{
  int i;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE ADDRESS OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CAddress::getState() const
{
  return STATE;
}

void CAddress::setState(const OCCI_STD_NAMESPACE::string &amp;value)
{
  STATE = value;
}

OCCI_STD_NAMESPACE::string CAddress::getZip() const
{
  return ZIP;
}

void CAddress::setZip(const OCCI_STD_NAMESPACE::string &amp;value)
{
  ZIP = value;
}

void *CAddress::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CAddress::operator new(size_t size, 
                             const oracle::occi::Connection * sess,
                             const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.ADDRESS");
}

void *CAddress::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CAddress::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CAddress::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.ADDRESS");
}

void CAddress::getSQLTypeName(oracle::occi::Environment *env, 
                              void **schemaName,
                              unsigned int &amp;schemaNameLen, 
                              void **typeName, 
                              unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CAddress::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CAddress::CAddress()
{
}

void *CAddress::readSQL(void *ctxOCCI_)
{
  MyAddress *objOCCI_ = new(ctxOCCI_) MyAddress(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CAddress::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   STATE = streamOCCI_.getString();
   ZIP = streamOCCI_.getString();
}

void CAddress::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CAddress *objOCCI_ = (CAddress *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CAddress::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setString(STATE);
   streamOCCI_.setString(ZIP);
}

CAddress::~CAddress()
{
  int i;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE PERSON OBJECT TYPE. */
oracle::occi::Number CPerson::getId() const
{
  return ID;
}

void CPerson::setId(const oracle::occi::Number &amp;value)
{
  ID = value;
}

MyFullName * CPerson::getName() const
{
  return NAME;
}

void CPerson::setName(MyFullName * value)
{
  NAME = value;
}

oracle::occi::Ref&lt; MyAddress &gt; CPerson::getCurr_addr() const
{
  return CURR_ADDR;
}

void CPerson::setCurr_addr(const oracle::occi::Ref&lt; MyAddress &gt; &amp;value)
{
  CURR_ADDR = value;
}

OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt;&amp;
   CPerson::getPrev_addr_l() 
{
  return PREV_ADDR_L;
}

const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Ref&lt; MyAddress &gt; &gt;&amp;
  CPerson::getPrev_addr_l() const
{
  return PREV_ADDR_L;
}

void CPerson::setPrev_addr_l(const OCCI_STD_NAMESPACE::vector&lt;
 oracle::occi::Ref&lt; MyAddress &gt; &gt; &amp;value)
{
  PREV_ADDR_L = value;
}
void *CPerson::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CPerson::operator new(size_t size, 
                            const oracle::occi::Connection * sess,
                            const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.PERSON");
}

void *CPerson::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CPerson::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CPerson::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.PERSON");
}

void CPerson::getSQLTypeName(oracle::occi::Environment *env, 
                             void **schemaName,
                             unsigned int &amp;schemaNameLen, 
                             void **typeName, 
                             unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CPerson::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CPerson::CPerson()
{
   NAME = (MyFullName *) 0;
}

void *CPerson::readSQL(void *ctxOCCI_)
{
  MyPerson *objOCCI_ = new(ctxOCCI_) MyPerson(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CPerson::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   ID = streamOCCI_.getNumber();
   NAME = (MyFullName *) streamOCCI_.getObject(&amp;MyFullName::readSQL);
   CURR_ADDR = streamOCCI_.getRef();
   oracle::occi::getVectorOfRefs(streamOCCI_, PREV_ADDR_L);
}

void CPerson::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CPerson *objOCCI_ = (CPerson *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CPerson::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   streamOCCI_.setNumber(ID);
   streamOCCI_.setObject(NAME);
   streamOCCI_.setRef(CURR_ADDR);
   oracle::occi::setVectorOfRefs(streamOCCI_, PREV_ADDR_L);
}

CPerson::~CPerson()
{
  int i;
  delete NAME;
}

/* GENERATED METHOD IMPLEMENTATIONS FOR THE STUDENT OBJECT TYPE. */
OCCI_STD_NAMESPACE::string CStudent::getSchool_name() const
{
  return SCHOOL_NAME;
}

void CStudent::setSchool_name(const OCCI_STD_NAMESPACE::string &amp;value)
{
  SCHOOL_NAME = value;
}

void *CStudent::operator new(size_t size)
{
  return oracle::occi::PObject::operator new(size);
}

void *CStudent::operator new(size_t size, 
                             const oracle::occi::Connection * sess,
                             const OCCI_STD_NAMESPACE::string&amp; table)
{
  return oracle::occi::PObject::operator new(size, sess, table, 
            (char *) "HR.STUDENT");
}

void *CStudent::operator new(size_t size, void *ctxOCCI_)
{
 return oracle::occi::PObject::operator new(size, ctxOCCI_);
}

void *CStudent::operator new(size_t size,
    const oracle::occi::Connection *sess,
    const OCCI_STD_NAMESPACE::string &amp;tableName, 
    const OCCI_STD_NAMESPACE::string &amp;typeName,
    const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
    const OCCI_STD_NAMESPACE::string &amp;typeSchema)
{
  return oracle::occi::PObject::operator new(size, sess, tableName,
        typeName, tableSchema, typeSchema);
}

OCCI_STD_NAMESPACE::string CStudent::getSQLTypeName() const
{ 
  return OCCI_STD_NAMESPACE::string("HR.STUDENT");
}

void CStudent::getSQLTypeName(oracle::occi::Environment *env, 
                              void **schemaName,
                              unsigned int &amp;schemaNameLen,
                              void **typeName,
                              unsigned int &amp;typeNameLen) const
{
  PObject::getSQLTypeName(env, &amp;CStudent::readSQL, schemaName,
        schemaNameLen, typeName, typeNameLen);
}

CStudent::CStudent()
{
}
void *CStudent::readSQL(void *ctxOCCI_)
{
  MyStudent *objOCCI_ = new(ctxOCCI_) MyStudent(ctxOCCI_);
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);

  try
  {
    if (streamOCCI_.isNull())
      objOCCI_-&gt;setNull();
    else
      objOCCI_-&gt;readSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    delete objOCCI_;
    excep.setErrorCtx(ctxOCCI_);
    return (void *)NULL;
  }
  return (void *)objOCCI_;
}

void CStudent::readSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   CPerson::readSQL(streamOCCI_);
   SCHOOL_NAME = streamOCCI_.getString();
}

void CStudent::writeSQL(void *objectOCCI_, void *ctxOCCI_)
{
  CStudent *objOCCI_ = (CStudent *) objectOCCI_;
  oracle::occi::AnyData streamOCCI_(ctxOCCI_);
  try
  {
    if (objOCCI_-&gt;isNull())
      streamOCCI_.setNull();
    else
      objOCCI_-&gt;writeSQL(streamOCCI_);
  }
  catch (oracle::occi::SQLException&amp; excep)
  {
    excep.setErrorCtx(ctxOCCI_);
  }
  return;
}

void CStudent::writeSQL(oracle::occi::AnyData&amp; streamOCCI_)
{
   CPerson::writeSQL(streamOCCI_);
   streamOCCI_.setString(SCHOOL_NAME);
}

CStudent::~CStudent()
{
  int i;
}
</pre></div>
<!-- class="example" -->
<p>Let us assume OTT generates <code>FULL_NAME</code>, <code>ADDRSESS</code>, <code>PERSON</code>, and <code>PFGRFDENT</code> class declarations in <code>demo2.h</code>. The following sample OCCI application extends the classes generated by OTT, as specified in <code>demo2.typ</code> file in <a href="#CIHEEFFI">Example 4-12</a>, and adds some user-defined methods. Note that these class declarations have been incorporated into <code>demo2.h</code> to ensure correct compilation.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20205"></a><a id="i1012401"></a>Example 4-18 Listing of myDemo.h for a Sample OCCI Application</p>
<pre>
#ifndef MYDEMO_ORACLE
#define MYDEMO_ORACLE

#include &lt;string&gt;

#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

using namespace std;
using namespace oracle::occi;

// declarations for the MyFullName class.
class MyFullName : public  CFullName
{  public:
      MyFullName(string first_name, string last_name);
      void displayInfo();
};

// declarations for the MyAddress class.
class MyAddress : public CAddress 
{  public:
      MyAddress(string state_i, string zip_i);
      void displayInfo();
};

// declarations for the MyPerson class.
class MyPerson : public CPerson
{  public:
      MyPerson(Number id_i, MyFullname *name_i, 
               const Ref&lt;MyAddress&gt;&amp; addr_i);
      void move(const Ref&lt;MyAddress&gt;&amp; new_addr);
      void displayInfo();
};

#endif
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20206"></a><a id="sthref297"></a>Example 4-19 Listing for myDemo.cpp for a Sample OCCI Application</p>
<pre>
#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

using namespace std;

/* initialize MyFullName */
MyFullName::MyFullName(string first_name,string last_name)
{
 setFirst_name(first_name);
 setLast_name(last_name);
}

/* display all the information in MyFullName */
void MyFullName::displayInfo()
{
   cout &lt;&lt; "FIRST NAME is" &lt;&lt; getFirst_name() &lt;&lt; endl;
   cout &lt;&lt; "LAST NAME is" &lt;&lt; getLast_name() &lt;&lt; endl;
}

MyFullName::MyFullName(void *ctxOCCI_):CFullName(ctxOCCI_)
{
}

/* METHOD IMPLEMENTATIONS FOR MyAddress CLASS. */

/* initialize MyAddress */
MyAddress::MyAddress(string state_i, string zip_i)
{
  setState(state_i); 
  setZip(zip_i);
}

/* display all the information in MyAddress */
void MyAddress::displayInfo()
{
   cout &lt;&lt; "STATE is" &lt;&lt; getState() &lt;&lt; endl;
   cout &lt;&lt; "ZIP is" &lt;&lt; getZip() &lt;&lt; endl;
}

MyAddress::MyAddress(void *ctxOCCI_) :CAddress(ctxOCCI_)
{
}

/* METHOD IMPLEMENTATIONS FOR MyPerson CLASS. */

/* initialize MyPerson */
MyPerson::MyPerson(Number id_i, MyFullName* name_i, 
           const Ref&lt;MyAddress&gt;&amp; addr_i)
{
  setId(id_i);
  setName(name_i);
  setCurr_addr(addr_i);
}

MyPerson::MyPerson(void *ctxOCCI_) :CPerson(ctxOCCI_)
{
}

/* move Person from curr_addr to new_addr */ 
void MyPerson::move(const Ref&lt;MyAddress&gt;&amp; new_addr)
{
   // append curr_addr to the vector //
   getPrev_addr_l().push_back(getCurr_addr());  
   setCurr_addr(new_addr);

   // mark the object as dirty
   this-&gt;markModified();
}

/*  display all the information of MyPerson */
void MyPerson::displayInfo()
{
   cout &lt;&lt; "ID is" &lt;&lt; (int)getId() &lt;&lt; endl;
   getName()-&gt;displayInfo();

   // de-referencing the Ref attribute using -&gt; operator
   getCurr_addr()-&gt;displayInfo();
   cout &lt;&lt; "Prev Addr List: " &lt;&lt; endl;
   for (int i = 0; i &lt; getPrev_addr_l().size(); i++)
   {  
      // access the collection elements using [] operator
      (getPrev_addr_l())[i]-&gt;displayInfo();
   }
}

MyPerson::MyPerson()
{
}

MyStudent::MyStudent(void *ctxOCCI_) : CStudent(ctxOCCI_)
{
}
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20207"></a><a id="sthref298"></a>Example 4-20 Listing of main.cpp for a Sample OCCI Application</p>
<pre>
#ifndef DEMO2_ORACLE
#include &lt;demo2.h&gt;
#endif

#ifndef MAPPINGS_ORACLE
#include &lt;mappings.h&gt;
#endif

#include &lt;iostream&gt;
using namespace std;
using namespace::oracle;

int main()
{
   Environment *env = Environment::createEnvironment(Environment::OBJECT);
   mappings(env);

   try {
     Connection *conn = Connection("HR", <span class="italic">"password</span>");

    /* Call the OTT generated function to register the mappings */
    /* create a persistent object of type ADDRESS in the database table, 
       ADDR_TAB */
    MyAddress *addr1 = new(conn, "ADDR_TAB") MyAddress("CA", "94065");
    conn-&gt;commit();

    Statement *st = conn-&gt;createStatement("select ref(a) from addr_tab a");
   ResultSet *rs = st-&gt;executeQuery();
   Ref&lt;MyAddress&gt; r1;
   if ( rs-&gt;next())
      r1 = rs-&gt;getRef(1);
   st-&gt;closeResultSet(rs);
   conn-&gt;terminateStatement(st);

   MyFullName * name1 = new MyFullName("Joe", "Black");

   /* create a persistent object of type Person in the database table 
      PERSON_TAB */
   MyPerson *person1 = new(conn, "PERSON_TAB") MyPerson(1,name1,r1);
   conn-&gt;commit();

   /* selecting the inserted information */
   Statement *stmt = conn-&gt;createStatement();
   ResultSet *resultSet = 
        stmt-&gt;executeQuery("SELECT REF(a) from person_tab a where id = 1");

   if (resultSet-&gt;next())
   {
      Ref&lt;MyPerson&gt; joe_ref = (Ref&lt;MyPerson&gt;) resultSet-&gt;getRef(1);
      joe_ref-&gt;displayInfo();

      /* create a persistent object of type ADDRESS in the database table
         ADDR_TAB */
      MyAddress *new_addr1 = new(conn, "ADDR_TAB") MyAddress("PA", "92140");
      joe_ref-&gt;move(new_addr1-&gt;getRef());
      joe_ref-&gt;displayInfo();
   }

   /* commit the transaction which results in the newly created object
       new_addr and the dirty object joe to be flushed to the server.
       Note that joe was marked dirty in move(). */
   conn-&gt;commit();

   conn-&gt;terminateStatement(stmt);
   env-&gt;terminateConnection(conn);
 }

 catch ( exception &amp;x)

 {
  cout &lt;&lt; x.what () &lt;&lt; endl;
 }
   Environment::terminateEnvironment(env);
   return 0;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1066">
<tr>
<td class="cellalignment1075">
<table class="cellalignment1071">
<tr>
<td class="cellalignment1070"><a href="relational.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1070"><a href="types.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1078">
<table class="cellalignment1069">
<tr>
<td class="cellalignment1070"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1070"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1070"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1070"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1070"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1070"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
