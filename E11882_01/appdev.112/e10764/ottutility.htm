<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Object Type Translator Utility</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 711" />
<meta name="dcterms.created" content="2013-02-06T9:20:49Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="C++ Call Interface Programmer's Guide," />
<meta name="dcterms.identifier" content="E10764-04" />
<meta name="dcterms.isVersionOf" content="LNCPP" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="lobs.htm" title="Previous" type="text/html" />
<link rel="Next" href="globalization.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10764.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/54</span> <!-- End Header --><a id="CHDBCDBH"></a><a id="LNCPP008"></a><a id="i441621"></a>
<h1 class="chapter"><span class="secnum">8</span> Object Type Translator Utility</h1>
<p>This chapter discusses the Object Type Translator (OTT) utility, which is used to map database object types, LOB types, and named collection types to C++ class declarations for use in OCCI applications.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i420185">Overview of the Object Type Translator Utility</a></p>
</li>
<li>
<p><a href="#i439131">Using the OTT Utility</a></p>
</li>
<li>
<p><a href="#i426997">Creating Types in the Database</a></p>
</li>
<li>
<p><a href="#i434134">Invoking the OTT Utility</a></p>
</li>
<li>
<p><a href="#i432196">Using the INTYPE File</a></p>
</li>
<li>
<p><a href="#i426569">OTT Utility Data Type Mappings</a></p>
</li>
<li>
<p><a href="#i440359">Overview of the OUTTYPE File</a></p>
</li>
<li>
<p><a href="#CHDDJHFG">The OTT Utility and OCCI Applications</a></p>
</li>
<li>
<p><a href="#i469445">Carrying Forward User Added Code</a></p>
</li>
</ul>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1079">
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075">
<p class="notep1">See Also:</p>
<code>$</code><code><span class="codeinlineitalic">ORACLE_HOME</span></code><code>/rdbms/demo</code> for a complete code listing of the demonstration program used in this chapter, and the class and method implementation generated by the OTT utility.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<a id="i420185"></a><a id="LNCPP20348"></a>
<div class="sect1">
<h2 class="sect1">Overview of the Object Type Translator Utility</h2>
<p>The Object Type Translator (OTT) utility assists in the development of applications that make use of user-defined types in an Oracle database server.</p>
<p>You can create object types using the SQL <code>CREATE TYPE</code> statement. The definitions of these types are stored in the database, and can be subsequently used to create database tables. Once these tables are populated, an OCCI programmer can access objects stored in the tables.</p>
<p>An application that accesses object data must be able to represent the data in a host language format. This is accomplished by representing object types classes in C++.</p>
<p>You could code structures or classes manually to represent database object types, but this is time-consuming and error-prone. The OTT utility simplifies this step by automatically generating the appropriate classes for C++.</p>
<p>For OCCI, the application must include and link the following files:</p>
<ul>
<li>
<p>Include the header file containing the generated class declarations</p>
</li>
<li>
<p>Include the header file containing the prototype for the function to register the mappings</p>
</li>
<li>
<p>Link with the C++ source file containing the static methods to be called by OCCI while instantiating the objects</p>
</li>
<li>
<p>Link with the file containing the function to register the mappings with the environment and call this function</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i439131"></a><a id="LNCPP20349"></a>
<div class="sect1">
<h2 class="sect1">Using the OTT Utility<a id="sthref528"></a></h2>
<p>To translate database types to C++ representation, you must explicitly invoke the OTT utility. OCCI programmers must register the mappings with the environment. This function is generated by the OTT utility.</p>
<p>On most operating systems, the OTT utility is invoked on the command line. It takes as input an <code>INTYPE</code> file, and generates an <code>OUTTYPE</code> file, one or more C++ header files that contain the prototype information, and additional C++ method files that register generated mappings.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20350"></a><a id="sthref529"></a>Example 8-1 How to Use the OTT Utility</p>
<p>The following command invokes the OTT utility and generates C++ classes. OTT attempts to connect with username <code>demousr</code>; the system prompts for the password.</p>
<pre>
ott userid=demousr intype=demoin.typ outtype=demoout.typ code=cpp
   hfile=demo.h cppfile=demo.cpp mapfile=RegisterMappings.cpp
</pre>
<p>OTT utility uses the <code>demoin.typ</code> file as the <code>INTYPE</code> file, and the <code>demoout.typ</code> file as the <code>OUTTYPE</code> file. The resulting declarations are output to the file <code>demo.h</code> in C++, specified by the <code>CODE=cpp</code> parameter, the method implementations written to the file <code>demo.cpp</code>, and the functions to register mappings is written to <code>RegisterMappings.cpp</code> with its prototype written to <code>RegisterMappings.h</code>.</p>
</div>
<!-- class="example" -->
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1079">
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075">
<p class="notep1">See Also:</p>
<a href="#i458231">Extending C++ Classes</a> for a complete C++ example</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
</div>
<!-- class="sect1" -->
<a id="i426997"></a><a id="LNCPP20351"></a>
<div class="sect1">
<h2 class="sect1">Creating Types in the Database<a id="sthref530"></a></h2>
<p>The first step in using the OTT utility is to create object types or named collection types and store them in the database. This is accomplished by the SQL <code>CREATE TYPE</code> statement.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20352"></a><a id="sthref531"></a>Example 8-2 Object Creation Statements of the OTT Utility</p>
<pre>
CREATE TYPE FULL_NAME AS OBJECT (first_name CHAR(20), last_name CHAR(20));
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20));
CREATE TYPE ADDRESS_TAB AS VARRAY(3) OF REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULL_NAME, curr_addr REF ADDRESS,
   prev_addr_1 ADDRESS_TAB) NOT FINAL;
CREATE TYPE STUDENT UNDER PERSON (school_name CHAR(20));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i434134"></a><a id="LNCPP20353"></a>
<div class="sect1">
<h2 class="sect1">Invoking the OTT Utility<a id="sthref532"></a></h2>
<p>After creating types in the database, the next step is to invoke the OTT utility.</p>
<a id="LNCPP20354"></a>
<div class="sect2"><a id="sthref533"></a>
<h3 class="sect2">Specifying OTT Parameters</h3>
<p>You can specify OTT parameters either on the command line or in a configuration file. Certain parameters can also be specified in the <code>INTYPE</code> file.</p>
<p>If you specify a parameter in multiple locations, then its value on the command line takes precedence over its value in the <code>INTYPE</code> file. The value in the <code>INTYPE</code> file takes precedence over its value in a user-defined configuration file, which takes precedence over its value in the default configuration file.</p>
<p>Parameter precedence then is as follows:</p>
<ol>
<li>
<p>OTT command line</p>
</li>
<li>
<p>Value in <code>INTYPE</code> file</p>
</li>
<li>
<p>User-defined configuration file</p>
</li>
<li>
<p>Default configuration file</p>
</li>
</ol>
<p>For global options (that is, options on the command line or options at the beginning of the <code>INTYPE</code> file before any <code>TYPE</code> statements), the value on the command line overrides the value in the <code>INTYPE</code> file. (The options that can be specified globally in the <code>INTYPE</code> file are <code>CASE</code>, <code>INITFILE</code>, <code>INITFUNC</code>, <code>MAPFILE</code> and <code>MAPFUNC</code>, but not <code>HFILE</code> or <code>CPPFILE</code>.) Anything in the <code>INTYPE</code> file in a <code>TYPE</code> specification applies to a particular type only and overrides anything on the command line that would otherwise apply to the type. So if you enter <code>TYPE person HFILE=p.h</code>, then it applies to <code>person</code> only and overrides the <code>HFILE</code> on the command line. The statement is not considered a command line parameter.</p>
<a id="LNCPP20355"></a>
<div class="sect3"><a id="sthref534"></a>
<h4 class="sect3">Setting Parameters on the Command Line</h4>
<p>Parameters (also called options) set on the command line override any parameters or option set elsewhere.</p>
</div>
<!-- class="sect3" -->
<a id="LNCPP20356"></a>
<div class="sect3"><a id="sthref535"></a>
<h4 class="sect3">Setting Parameters in the INTYPE File</h4>
<p>The <code>INTYPE</code> file gives a list of types for the OTT utility to translate.</p>
<p>The parameters <code>CASE</code>, <code>CPPFILE</code>, <code>HFILE</code>, <code>INITFILE</code>, <code>INITFUNC</code>, <code>MAPFILE</code>, and <code>MAPFUNC</code> can appear in the <code>INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="LNCPP20357"></a>
<div class="sect3"><a id="sthref536"></a>
<h4 class="sect3">Setting Parameters in the Configuration File</h4>
<p>A configuration file is a text file that contains OTT parameters. Each nonblank line in the file contains one parameter, with its associated value or values. If multiple parameters are on the same line, then only the first one is used. No blank space is allowed on any nonblank line of a configuration file.</p>
<p>A configuration file can be named on the command line. In addition, a default configuration file is always read. This default configuration file must always exist, but can be empty. The name of the default configuration file is <code>ottcfg.cfg</code>, and the location of the file is operating system-specific.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Your operating system-specific documentation for more information about the location of the default configuration file.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="LNCPP20358"></a>
<div class="sect2"><a id="sthref537"></a>
<h3 class="sect2">Invoking the OTT Utility on the Command Line</h3>
<p>On most platforms, the OTT utility is invoked on the command line. You can specify the input and output files and the database connection information at the command line, among other things.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Your operating system-specific documentation to see how to invoke the OTT utility on your operating system</div>
<div class="example">
<p class="titleinexample"><a id="LNCPP20359"></a><a id="sthref538"></a>Example 8-3 How to Invoke the OTT Utility to Generate C++ Classes</p>
<p>OTT attempts to connect with username <code>demousr</code>; the system prompts for the password.</p>
<pre>
ott userid=demousr intype=demoin.typ outtype=demoout.typ code=cpp
   hfile=demo.h cppfile=demo.cpp mapfile=RegisterMappings.cpp
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Caution:</p>
No spaces are permitted around the equals sign (<code>=</code>) on the OTT command line.</div>
<p>An OTT command line statement consists of the command OTT, followed by a list of OTT utility parameters.</p>
<p>The <code>HFILE</code> parameter is almost always used. If omitted, then <code>HFILE</code> must be specified individually for each type in the <code>INTYPE</code> file. If the OTT utility determines that a type not listed in the <code>INTYPE</code> file must be translated, then an error is reported. Therefore, it is safe to omit the <code>HFILE</code> parameter only if the <code>INTYPE</code> file was previously generated as an OTT <code>OUTTYPE</code> file.</p>
<p>If the <code>INTYPE</code> file is omitted, then the entire schema is translated. See the parameter descriptions in the following section for more information.</p>
<a id="LNCPP20360"></a>
<div class="sect3"><a id="sthref539"></a>
<h4 class="sect3">Elements Used on the OTT Command Line</h4>
<p>Elements used on the OTT command line are:</p>
<ul>
<li>
<p>OTT command that invokes the OTT utility. It must be the first item on the command line.</p>
</li>
<li>
<p><a href="#i461368">USERID</a> parameter</p>
</li>
<li>
<p><a href="#i461337">INTYPE</a> parameter</p>
</li>
<li>
<p><a href="#i461357">OUTTYPE</a> parameter.</p>
</li>
<li>
<p><a href="#i461309">CODE</a> parameter.</p>
</li>
<li>
<p><a href="#i461325">HFILE</a> parameter.</p>
</li>
<li>
<p><a href="#i461317">CPPFILE</a> parameter.</p>
</li>
<li>
<p><a href="#i461349">MAPFILE</a> parameter.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i428064"></a><a id="LNCPP20361"></a>
<div class="sect2">
<h3 class="sect2">OTT Utility Parameters<a id="sthref540"></a></h3>
<p>To generate C++ using the OTT utility, the <code>CODE</code> parameter must be set to <code>CODE=CPP</code>. Once <code>CODE=CPP</code> is specified, you are required to specify the <code>CPPFILE</code> and <code>MAPFILE</code> parameters to define the filenames for the method implementation file and the mappings registration function file. The name of the mapping function is derived by the OTT utility from the <code>MAPFILE</code> or you may specify the name with the <code>MAPFUNC</code> parameter. <code>ATTRACCESS</code> is also an optional parameter that can be specified to change the generated code. These parameters control the generation of C++ classes.</p>
<ul>
<li>
<p>Enter parameters on the OTT command line where <code>parameter</code> is the literal parameter string and <code>value</code> is a valid parameter setting. The literal parameter string is not case sensitive:</p>
<pre>
parameter=value
</pre></li>
<li>
<p>Separate command line parameters by using either spaces or tabs.</p>
</li>
<li>
<p>Parameters can also appear within a configuration file, but, in that case, no whitespace is permitted within a line, and each parameter must appear on a separate line. Additionally, the parameters <code>CASE</code>, <code>CPPFILE</code>, <code>HFILE</code>, <code>INITFILE</code>, <code>INTFUNC</code>, <code>MAPFILE</code>, and <code>MAPFUNC</code> can appear in the <code>INTYPE</code> file.</p>
</li>
</ul>
<p><a href="#BABBEIHG">Table 8-1</a> lists all OTT Utility parameters:</p>
<div class="tblformal">
<p class="titleintable"><a id="LNCPP20362"></a><a id="sthref541"></a><a id="BABBEIHG"></a>Table 8-1 Summary of OTT Utility Parameters</p>
<table class="cellalignment1073" title="Summary of OTT Utility Parameters" summary="Parameter and description" dir="ltr">
<thead>
<tr class="cellalignment1067">
<th class="cellalignment1074" id="r1c1-t7">Parameter</th>
<th class="cellalignment1074" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r2c1-t7" headers="r1c1-t7">
<p><a href="#i461293">ATTRACCESS</a></p>
</td>
<td class="cellalignment1075" headers="r2c1-t7 r1c2-t7">
<p>Specifies whether the access to type attributes is <code>PROTECTED</code> or <code>PRIVATE</code>.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r3c1-t7" headers="r1c1-t7">
<p><a href="#i443287">CASE</a></p>
</td>
<td class="cellalignment1075" headers="r3c1-t7 r1c2-t7">
<p>Affects the letter case of generated C++ identifiers</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r4c1-t7" headers="r1c1-t7">
<p><a href="#i461309">CODE</a></p>
</td>
<td class="cellalignment1075" headers="r4c1-t7 r1c2-t7">
<p>Specifies the target language for the translation. Use <code>CPP</code>.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r5c1-t7" headers="r1c1-t7">
<p><a href="#i461313">CONFIG</a></p>
</td>
<td class="cellalignment1075" headers="r5c1-t7 r1c2-t7">
<p>Specifies the name of the OTT configuration file that lists commonly used parameter specifications.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r6c1-t7" headers="r1c1-t7">
<p><a href="#i461317">CPPFILE</a></p>
</td>
<td class="cellalignment1075" headers="r6c1-t7 r1c2-t7">
<p>Specifies the name of the C++ source file into which the method implementations are written.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r7c1-t7" headers="r1c1-t7">
<p><a href="#i461321">ERRTYPE</a></p>
</td>
<td class="cellalignment1075" headers="r7c1-t7 r1c2-t7">
<p>Specifies the name of the error message output file.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r8c1-t7" headers="r1c1-t7">
<p><a href="#i461325">HFILE</a></p>
</td>
<td class="cellalignment1075" headers="r8c1-t7 r1c2-t7">
<p>Specifies the name of the C++ header file to which the generated C++ classes are written.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r9c1-t7" headers="r1c1-t7">
<p><a href="#i461337">INTYPE</a></p>
</td>
<td class="cellalignment1075" headers="r9c1-t7 r1c2-t7">
<p>Specifies the name of the <code>INTYPE</code> file.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r10c1-t7" headers="r1c1-t7">
<p><a href="#i461349">MAPFILE</a></p>
</td>
<td class="cellalignment1075" headers="r10c1-t7 r1c2-t7">
<p>Specifies the name of the mapping file and the corresponding header file generated by the OTT utility.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r11c1-t7" headers="r1c1-t7">
<p><a href="#i461353">MAPFUNC</a></p>
</td>
<td class="cellalignment1075" headers="r11c1-t7 r1c2-t7">
<p>Specifies the name of the function used to register generated mappings.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r12c1-t7" headers="r1c1-t7">
<p><a href="#i461357">OUTTYPE</a></p>
</td>
<td class="cellalignment1075" headers="r12c1-t7 r1c2-t7">
<p>Specifies the name of the <code>OUTTYPE</code> file.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r13c1-t7" headers="r1c1-t7">
<p><a href="#i461361">SCHEMA_NAMES</a></p>
</td>
<td class="cellalignment1075" headers="r13c1-t7 r1c2-t7">
<p>Controls the qualifying the database name of a type from the default schema</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r14c1-t7" headers="r1c1-t7">
<p><a href="#i461506">TRANSITIVE</a></p>
</td>
<td class="cellalignment1075" headers="r14c1-t7 r1c2-t7">
<p>Indicates whether to translate type dependency that are not explicitly listed in the <a href="#i461337">INTYPE</a>.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r15c1-t7" headers="r1c1-t7">
<p><a href="#BABHGEHE">UNICODE</a></p>
</td>
<td class="cellalignment1075" headers="r15c1-t7 r1c2-t7">
<p>Indicates whether the application should provide UTF16 support generate <code>UString</code> types.</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r16c1-t7" headers="r1c1-t7">
<p><a href="#i469376">USE_MARKER</a></p>
</td>
<td class="cellalignment1075" headers="r16c1-t7 r1c2-t7">
<p>Indicates whether OTT markers should be supported to carry forward user added cod</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r17c1-t7" headers="r1c1-t7">
<p><a href="#i461368">USERID</a></p>
</td>
<td class="cellalignment1075" headers="r17c1-t7 r1c2-t7">
<p>Specifies the database connection information that the OTT utility uses.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="i461293"></a><a id="LNCPP20363"></a>
<div class="sect3">
<h4 class="sect3">ATTRACCESS</h4>
<p>This parameter specifies access to type attributes:</p>
<ul>
<li>
<p><code>PROTECTED</code> is the default.</p>
</li>
<li>
<p><code>PRIVATE</code> indicates that the OTT utility generates accessory and mutator methods for each type attribute, <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i443287"></a><a id="LNCPP20364"></a>
<div class="sect3">
<h4 class="sect3">CASE<a id="sthref542"></a><a id="sthref543"></a></h4>
<p>This parameter affects the letter case of generated C++ identifiers. The valid values of <code>CASE</code> are:</p>
<ul>
<li>
<p><code>SAME</code> is the case of letters remains unchanged when converting database type and attribute names to C++ identifiers.</p>
</li>
<li>
<p><code>LOWER</code> indicates that all uppercase letters are converted to lowercase.</p>
</li>
<li>
<p><code>UPPER</code> indicates that all lowercase letters are converted to uppercase.</p>
</li>
<li>
<p><code>OPPOSITE</code> indicates that all uppercase letters are converted to lowercase, and all lowercase letters are converted to uppercase.</p>
</li>
</ul>
<p>This parameter affects only those identifiers (attributes or types not explicitly listed) not mentioned in the <code>INTYPE</code> file. Case conversion takes place after a legal identifier has been generated.</p>
<p>Case insensitive SQL identifiers not mentioned in the <code>INTYPE</code> file appear in uppercase if <code>CASE=SAME</code>, and in lowercase if <code>CASE=OPPOSITE</code>. A SQL identifier is case insensitive if it was not quoted when it was declared.</p>
</div>
<!-- class="sect3" -->
<a id="i461309"></a><a id="LNCPP20365"></a>
<div class="sect3">
<h4 class="sect3">CODE<a id="sthref544"></a><a id="sthref545"></a></h4>
<p>This parameter specifies the host language to be output by the OTT utility. <code>CODE=CPP</code> must be specified for the OTT utility to generate C++ code for OCCI applications.</p>
</div>
<!-- class="sect3" -->
<a id="i461313"></a><a id="LNCPP20366"></a>
<div class="sect3">
<h4 class="sect3">CONFIG<a id="sthref546"></a><a id="sthref547"></a></h4>
<p>This parameter specifies the name of the OTT configuration file that lists commonly used parameter specifications. Parameter specifications are also read from a system configuration file found in an operating system-dependent location. All remaining parameter specifications must appear either on the command line or in the <code>INTYPE</code> file.</p>
<p>The <code>CONFIG</code> parameter can only be specified on the OTT command line. It is not allowed in the <code>CONFIG</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461317"></a><a id="LNCPP20367"></a>
<div class="sect3">
<h4 class="sect3">CPPFILE</h4>
<p>This parameter specifies the name of the C++ source file that contains the method implementations generated by the OTT utility. The methods generated in this file are called by OCCI while instantiating the objects and are not to be called directly in the an application.</p>
<p>This parameter is required under the following conditions:</p>
<ul>
<li>
<p>A type not mentioned in the <code>INTYPE</code> file must be generated and two or more <code>CPPFILE</code>s are being generated. In this case, the unmentioned type goes in the <code>CPPFILE</code> specified on the command line.</p>
</li>
<li>
<p>The <code>INTYPE</code> parameter is not specified, and you want the OTT utility to translate all the types in the schema.</p>
</li>
</ul>
<p>This parameter is optional when the <code>CPPFILE</code> is specified for individual types in the <code>INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461321"></a><a id="LNCPP20368"></a>
<div class="sect3">
<h4 class="sect3">ERRTYPE<a id="sthref548"></a><a id="sthref549"></a></h4>
<p>This parameter specifies the name of the error message output file. Information and error messages are sent to the standard output regardless of whether the <code>ERRTYPE</code> parameter is specified. Essentially, the <code>ERRTYPE</code> file is a copy of the <code>INTYPE</code> file with error messages added. In most cases, an error message includes a pointer to the text that caused the error.</p>
<p>If the filename specified for the <code>ERRTYPE</code> parameter on the command line does not include an extension, a platform-specific extension, like .<code>TLS</code> or .<code>tls</code>, is added automatically.</p>
</div>
<!-- class="sect3" -->
<a id="i461325"></a><a id="LNCPP20369"></a>
<div class="sect3">
<h4 class="sect3">HFILE<a id="sthref550"></a><a id="sthref551"></a></h4>
<p>This parameter specifies the name of the header (<code>.h</code>) file to be generated by the OTT utility. The <code>HFILE</code> specified on the command line contains the declarations of types that are mentioned in the <code>INTYPE</code> file but whose header files are not specified there.</p>
<p>This parameter is required unless the header file for each type is specified individually in the <code>INTYPE</code> file. This parameter is also required if a type not mentioned in the <code>INTYPE</code> file must be generated because other types require it, and these other types are declared in two or more different files.</p>
<p>If the filename specified for the <code>HFILE</code> parameter on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension, like <code>.H</code> or <code>.h</code>, is added automatically.</p>
</div>
<!-- class="sect3" -->
<a id="i461337"></a><a id="LNCPP20370"></a>
<div class="sect3">
<h4 class="sect3">INTYPE<a id="sthref552"></a><a id="sthref553"></a></h4>
<p>This parameter specifies the name of the file from which to read the list of object type specifications. The OTT utility translates each type in the list. If the <code>INTYPE</code> parameter is not specified, all types in the user's schema is translated.</p>
<p>If the filename specified for the <code>INTYPE</code> parameter on the command line does not include an extension, a platform-specific extension, like <code>.TYP</code> or <code>.typ</code>, is automatically added.</p>
<p><code>INTYPE=</code> may be omitted if <code>USERID</code> and <code>INTYPE</code> are the first two parameters, in that order, and <code>USERID=</code> is omitted.</p>
<p>The <code>INTYPE</code> file can be thought of as a makefile for type declarations. It lists the types for which C++ classes are needed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i420386">"Structure of the INTYPE File"</a> for more information about the format of the <code>INTYPE</code> file</div>
</div>
<!-- class="sect3" -->
<a id="i461349"></a><a id="LNCPP20371"></a>
<div class="sect3">
<h4 class="sect3">MAPFILE</h4>
<p>This parameter specifies the name of the mapping file (<code><span class="codeinlineitalic">XXX</span></code><code>.cpp</code>) and corresponding header file (<code><span class="codeinlineitalic">XXX</span></code><code>.h</code>) that are generated by the OTT utility. The <code><span class="codeinlineitalic">XXX</span></code><code>.cpp</code> file contains the implementation of the functions to register the mappings, while the <code><span class="codeinlineitalic">XXX</span></code><code>.h</code> file contains the prototype for the function.</p>
<p>This parameter may be specified either on the command line or in the <code>INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461353"></a><a id="LNCPP20372"></a>
<div class="sect3">
<h4 class="sect3">MAPFUNC</h4>
<p>This parameter specifies the name of the function to be used to register the mappings generated by the OTT utility.</p>
<p>If this parameter is omitted, then the name of the function to register the mappings is derived from the filename specified in the <code>MAPFILE</code> parameter.</p>
<p>This parameter may be specified either on the command line or in the <code>INTYPE</code> file.</p>
</div>
<!-- class="sect3" -->
<a id="i461357"></a><a id="LNCPP20373"></a>
<div class="sect3">
<h4 class="sect3">OUTTYPE<a id="sthref554"></a><a id="sthref555"></a></h4>
<p>This parameter specifies the name of the file into which the OTT utility writes type information for all the object data types it processes. This file includes all types explicitly named in the <code>INTYPE</code> file, and may include additional types that are translated because they are used in the declarations of other types that must be translated. This file may be used as an <code>INTYPE</code> file in a future invocation of the OTT utility.</p>
<p>If the <code>INTYPE</code> and <code>OUTTYPE</code> parameters refer to the same file, then the new <code>INTYPE</code> information replaces the old information in the <code>INTYPE</code> file. This provides a convenient way for the same <code>INTYPE</code> file to be used repeatedly in the cycle of altering types, generating type declarations, editing source code, precompiling, compiling, and debugging.</p>
<p>If the filename specified for the <code>OUTTYPE</code> parameter on the command line or in the <code>INTYPE</code> file does not include an extension, a platform-specific extension, like<code>.TYP</code> or <code>.typ</code>, is automatically added.</p>
</div>
<!-- class="sect3" -->
<a id="i461361"></a><a id="LNCPP20374"></a>
<div class="sect3">
<h4 class="sect3">SCHEMA_NAMES<a id="sthref556"></a><a id="sthref557"></a></h4>
<p>This parameter offers control in qualifying the database name of a type from the default schema that is named in the <a href="#i461357">OUTTYPE</a> file. The <a href="#i461357">OUTTYPE</a> file generated by the OTT utility contains information about the types processed by the OTT utility, including the type names. Valid values include:</p>
<ul>
<li>
<p><code>ALWAYS</code> (default) indicates that all type names in the <a href="#i461357">OUTTYPE</a> file are qualified with a schema name.</p>
</li>
<li>
<p><code>IF_NEEDED</code> indicates that the type names in the <a href="#i461357">OUTTYPE</a> file that belong to the default schema are not qualified with a schema name. Type names belonging to other schemas are qualified with the schema name.</p>
</li>
<li>
<p><code>FROM_INTYPE</code> indicates that a type mentioned in the <a href="#i461337">INTYPE</a> file is qualified with a schema name in the <a href="#i461357">OUTTYPE</a> file only if it was qualified with a schema name in the <a href="#i461337">INTYPE</a> file. A type in the default schema that is not mentioned in the <a href="#i461337">INTYPE</a> file but generated because of type dependency is written with a schema name only if the first type encountered by the OTT utility that depends on it is also written with a schema name. However, a type that is not in the default schema to which the OTT utility is connected is always written with an explicit schema name.</p>
</li>
</ul>
<p>The name of a type from a schema other that the default schema is always qualified with a schema name in the <a href="#i461357">OUTTYPE</a> file.</p>
<p>The schema name, or its absence, determines in which schema the type is found during program execution.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20375"></a><a id="sthref558"></a>Example 8-4 How to use the SCHEMA_NAMES Parameter in OTT Utility</p>
<p>Consider an example where the <code>SCHEMA_NAMES</code> parameter is set to <code>FROM_INTYPE</code>, and the <code>INTYPE</code> file contains the following:</p>
<pre>
TYPE Person
TYPE joe.Dept
TYPE sam.Company
</pre>
<p>If the OTT utility and the application both connect to schema joe, then the application uses the same type (<code>joe.Person</code>) that the OTT utility uses. If the OTT utility connects to schema <code>joe</code> but the application connects to schema <code>mary</code>, then the application uses the type <code>mary.Person</code>. This behavior is appropriate only if the same <code>CREATE TYPE Person</code> statement has been executed in schema <code>joe</code> and schema <code>mary</code>.</p>
<p>On the other hand, the application uses type <code>joe.Dept</code> regardless of which schema the application is connected to. If this is the behavior you want, then be sure to include schema names with your type names in the <code>INTYPE</code> file.</p>
<p>In some cases, the OTT utility translates a type that the user did not explicitly name. For example, consider the following SQL declarations:</p>
<pre>
CREATE TYPE Address AS OBJECT
(
   street    VARCHAR2(40),
   city      VARCHAR(30),
   state     CHAR(2),
   zip_code  CHAR(10)
);

CREATE TYPE Person AS OBJECT
(
   name      CHAR(20),
   age       NUMBER,
   addr      ADDRESS
);
</pre>
<p>Suppose that the OTT utility connects to schema <code>joe</code>, <code>SCHEMA_NAMES=FROM_INTYPE</code> is specified, and the user's <code>INTYPE</code> files include either <code>TYPE Person</code> or <code>TYPE joe.Person</code>. The <code>INTYPE</code> file does not mention the type <code>joe.Address</code>, which is used as a nested object type in type <code>joe.Person</code>.</p>
<ul>
<li>
<p>If <code>Type Person</code> appears in the <code>INTYPE</code> file, then <code>TYPE Person</code> and <code>TYPE Address</code> appears in the <code>OUTTYPE</code> file.</p>
</li>
<li>
<p>If <code>TYPE joe.Person</code> appears in the <code>INTYPE</code> file, then <code>TYPE joe.Person</code> and <code>TYPE joe.Address</code> appear in the <code>OUTTYPE</code> file.</p>
</li>
<li>
<p>If the <code>joe.Address</code> type is embedded in several types translated by the OTT utility, but it is not explicitly mentioned in the <code>INTYPE</code> file, then the decision of whether to use a schema name is made the first time the OTT utility encounters the embedded <code>joe.Address</code> type. If, for some reason, the user wants type <code>joe.Address</code> to have a schema name but does not want type <code>Person</code> to have one, then you must explicitly request this in the <code>INTYPE</code> file: <code>TYPE joe.Address</code>.</p>
</li>
</ul>
<p>In the usual case in which each type is declared in a single schema, it is safest for you to qualify all type names with schema names in the <code>INTYPE</code> file.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i461506"></a><a id="LNCPP20376"></a>
<div class="sect3">
<h4 class="sect3">TRANSITIVE<a id="sthref559"></a><a id="sthref560"></a></h4>
<p>This parameter indicates whether type dependencies not explicitly listed in the <code>INTYPE</code> file are to be translated. Valid values are:</p>
<ul>
<li>
<p><code>TRUE</code> (default): types needed by other types and not mentioned in the <code>INTYPE</code> file are generated</p>
</li>
<li>
<p><code>FALSE</code>: types not mentioned in the <code>INTYPE</code> file are not generated, even if they are used as attribute types of other generated types.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABHGEHE"></a><a id="LNCPP20377"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">UNICODE</h4>
<p>This parameter specifies whether the application provides unicode (<code>UTF16</code>) support.</p>
<ul>
<li>
<p><code>NONE</code> (default)</p>
</li>
<li>
<p><code>ALL</code>: All <code>CHAR</code> (<code>CHAR</code>/<code>VARCHAR</code>) and <code>NCHAR</code> (<code>NCHAR</code>/<code>NVARCHAR2</code>) type attributes are declared as <code>UString</code> type in the OTT generated C++ class files. The corresponding <code>get</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code>/<code>set</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> return values or parameters are <code>UString</code> types. The generated persistent operator new would also take only <code>UString</code> arguments.</p>
<p>This setting is necessary when both the client characterset and the national characterset is <code>UTF16</code>.</p>
</li>
<li>
<p><code>ONLYNCHAR</code>: Similar to the <code>ALL</code> option, but only <code>NCHAR</code> type attributes are declared as <code>UString</code>.</p>
<p>This setting is necessary when the application sets only the Environment's national characterset to <code>UTF16</code>.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="LNCPP20378"></a><a id="sthref561"></a>Example 8-5 How to Define a Schema for Unicode Support in OTT</p>
<pre>
create type CitiesList as varray(100) of varchar2(100);
 
create type Country as object
(  CNo Number(10),
   CName Varchar2(100),
   CNationalName NVarchar2(100),
   MainCities CitiesList);
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20379"></a><a id="sthref562"></a>Example 8-6 How to Use UNICODE=ALL Parameter in OTT</p>
<pre>
class Country : public oracle::occi::PObject
{
   private:
      oracle::occi::Number CNO;
      oracle::occi::UString CNAME;
      oracle::occi::UString CNATIONALNAME;
      OCCI_STD_NAMESPACE:::vector&lt; oracle::occi::UString &gt; MAINCITIES;

   public:

      oracle::occi::Number getCno() const;
      void setCno(const oracle::occi::Number &amp;value);

      oracle::occi::UString getCname() const;
      void setCname(const oracle::occi::UString &amp;value);
 
      oracle::occi::UString getCnationalname() const;
      void setCnationalname(const oracle::occi::UString &amp;value);
 
      OCCI_STD_NAMESPACE::vector&lt; oracle::occi::UString &gt;&amp; getMaincities();
      const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::UString &gt;&amp; 
          getMaincities() const;
     void setMaincities(const OCCI_STD_NAMESPACE::vector&lt; oracle::occi::UString
          &gt; &amp;value);
...
}
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20380"></a><a id="sthref563"></a>Example 8-7 How to Use UNICODE=ONLYCHAR Parameter in OTT</p>
<pre>
class Country : public oracle::occi::PObject
{
   private:
      oracle::occi::Number CNO;
      oracle::occi::string CNAME;
      oracle::occi::UString CNATIONALNAME;
      OCCI_STD_NAMESPACE::vector&lt; std::string &gt; MAINCITIES;

   public:

      oracle::occi::Number getCno() const;
      void setCno(const oracle::occi::Number &amp;value);

      oracle::occi::string getCname() const;
      void setCname(const OCCI_STD_NAMESPACE::string &amp;value);
 
      oracle::occi::UString getCnationalname() const;
      void setCnationalname(const oracle::occi::UString &amp;value);
 
      OCCI_STD_NAMESPACE::vector&lt; OCCI_STD_NAMESPACE::string&gt;&amp; 
         getMaincities();
      const OCCI_STD_NAMESPACE::vector&lt; OCCI_STD_NAMESPACE::string &gt;&amp;
         getMaincities() const;
     void setMaincities(const OCCI_STD_NAMESPACE::vector
         &lt; OCCI_STD_NAMESPACE::string &gt; &amp;value);
...
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i469376"></a><a id="LNCPP20381"></a>
<div class="sect3">
<h4 class="sect3"><a id="sthref564"></a><a id="sthref565"></a>USE_MARKER</h4>
<p>This parameter indicates whether to support OTT markers for carrying forward user added code. Valid values are:</p>
<ul>
<li>
<p><code>FALSE</code> (default): User-supplied code is not carried forward, even if the code is added between <code>OTT_USERCODE_START</code> and <code>OTT_USERCODE_END</code> markers.</p>
</li>
<li>
<p><code>TRUE</code>: User-supplied code, between the markers <code>OTT_USER_CODESTART</code> and <code>OTT_USERCODE_END</code>, is carried forward when the same file is generated again.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i461368"></a><a id="LNCPP20382"></a>
<div class="sect3">
<h4 class="sect3"><a id="sthref566"></a><a id="sthref567"></a>USERID</h4>
<p>This parameter specifies the Oracle username and optional database name (Oracle Net database specification string). If the database name is omitted, the default database is assumed.</p>
<pre>
USERID=<span class="italic">username</span>[@db_name]
</pre>
<p>If this is the first parameter, then <code>USERID=</code> may be omitted as shown:</p>
<pre>
OTT <span class="italic">username</span> ...
</pre>
<p>Note that the system prompts you for the password that corresponds to the user id.</p>
<p>This parameter is optional. If omitted, the OTT utility automatically attempts to connect to the default database as user <code><span class="codeinlineitalic">OPS$username</span></code>, where <code><span class="codeinlineitalic">username</span></code> is the user's operating system username.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i450542"></a><a id="LNCPP20383"></a>
<div class="sect2">
<h3 class="sect2">Where OTT Parameters Can Appear<a id="sthref568"></a></h3>
<p>Supply OTT parameters on the command line, in a <code>CONFIG</code> file named on the command line, or both. Some parameters are also allowed in the <code>INTYPE</code> file.</p>
<p>The OTT utility is invoked as follows:</p>
<pre>
OTT parameters
</pre>
<p>You can name a configuration file on the command line with the <code>CONFIG</code> parameter as follows:</p>
<pre>
CONFIG=<span class="italic">filename</span>
</pre>
<p>If you name this parameter on the command line, then additional parameters are read from the configuration file named <code><span class="codeinlineitalic">filename</span></code>.</p>
<p>In addition, parameters are also read from a default configuration file that resides in an operating system-dependent location. This file must exist, but can be empty. If you choose to enter data in the configuration file, note that no white space is allowed on a line and parameters must be entered one to a line.</p>
<p>If the OTT utility is executed without any arguments, then an online parameter reference is displayed.</p>
<p>The types for the OTT utility to translate are named in the file specified by the <code>INTYPE</code> parameter. The parameters <code>CASE</code>, <code>CPPFILE</code>, <code>HFILE</code>, <code>INITFILE</code>, <code>INITFUNC</code>, <code>MAPFILE</code>, and <code>MAPFNC</code> may also appear in the <code>INTYPE</code> file. <code>OUTTYPE</code> files generated by the OTT utility include the <code>CASE</code> parameter, and include the <code>INITFILE</code>, and <code>INITFUNC</code> parameters if an initialization file was generated or the <code>MAPFILE</code> and <code>MAPFUNC</code> parameters if C++ codes was generated. The <code>OUTTYPE</code> file and the <code>CPPFILE</code> for C++ specify the <code>HFILE</code> individually for each type.</p>
<p>The case of the OTT command is operating system-dependent.</p>
</div>
<!-- class="sect2" -->
<a id="i432220"></a><a id="LNCPP20384"></a>
<div class="sect2">
<h3 class="sect2">File Name Comparison Restriction</h3>
<p>Currently, the OTT utility determines if two files are the same by comparing the filenames provided by the user either on the command line or in the <code>INTYPE</code> file. But one potential problem can occur when the OTT utility must know if two filenames refer to the same file. For example, if the OTT-generated file foo.h requires a type declaration written to <code>foo1.h</code>, and another type declaration written to <code>/private/smith/foo1.h</code>, then the OTT utility should generate one <code>#include</code> if the two files are the same, and two <code>#include</code>s if the files are different. In practice, though, it concludes that the two files are different, and generates two <code>#include</code>s as follows:</p>
<pre>
#ifndef FOO1_ORACLE
#include "foo1.h"
#endif
#ifndef FOO1_ORACLE
#include "/private/smith/foo1.h"
#endif
</pre>
<p>If <code>foo1.h</code> and <code>/private/smith/foo1.h</code> are different files, then only the first one is included. If <code>foo1.h</code> and <code>/private/smith/foo1.h</code> are the same file, then a redundant <code>#include</code> is written.</p>
<p>Therefore, if a file is mentioned several times on the command line or in the <code>INTYPE</code> file, then each mention of the file should use the same filename.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i432196"></a><a id="LNCPP20385"></a>
<div class="sect1">
<h2 class="sect1">Using the INTYPE File</h2>
<p>When you run the OTT utility, the <code>INTYPE</code> file tells the OTT utility which database types should be translated. The <code>INTYPE</code> file also controls the naming of the generated structures or classes. You can either create an <code>INTYPE</code> file or use the <code>OUTTYPE</code> file of a previous invocation of the OTT utility. If you do not use an <code>INTYPE</code> file, then all types in the schema to which the OTT utility connects are translated.</p>
<a id="LNCPP20386"></a>
<div class="sect2"><a id="sthref569"></a>
<h3 class="sect2">Overview of the INTYPE File</h3>
<div class="example">
<p class="titleinexample"><a id="LNCPP20387"></a><a id="sthref570"></a>Example 8-8 How to Create a User Defined INTYPE File Using the OTT Utility</p>
<pre>
CASE=LOWER
TYPE employee
   TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS
TYPE item
TYPE "Person"
TYPE PURCHASE_ORDER AS p_o
</pre>
<ul>
<li>
<p>In the first line, the <code>CASE</code> parameter indicates that generated C identifiers should be in lowercase. However, this <code>CASE</code> parameter is only applied to those identifiers that are not explicitly mentioned in the <code>INTYPE</code> file. Thus, <code>employee</code> and <code>ADDRESS</code> would always result in C structures <code>employee</code> and <code>ADDRESS</code>, respectively. The members of these structures are named in lowercase.</p>
</li>
<li>
<p>The lines that begin with the <code>TYPE</code> keyword specify which types in the database should be translated. In this case, the <code>EMPLOYEE</code>, <code>ADDRESS</code>, <code>ITEM</code>, <code>PERSON</code>, and <code>PURCHASE_ORDER</code> types are set to be translated.</p>
</li>
<li>
<p>The <code>TRANSLATE...AS</code> keywords specify that the name of an object attribute should be changed when the type is translated into a C structure. In this case, the <code>SALARY$</code> attribute of the <code>employee</code> type is translated to <code>salary</code>.</p>
</li>
<li>
<p>The <code>AS</code> keyword in the final line specifies that the name of an object type should be changed when it is translated into a structure. In this case, the <code>purchase_order</code> database type is translated into a structure called <code>p_o</code>.</p>
</li>
</ul>
</div>
<!-- class="example" -->
<p>The OTT utility may have to translate additional types that are not listed in the <code>INTYPE</code> file. This is because the OTT utility analyzes the types in the <code>INTYPE</code> file for type dependencies before performing the translation, and it translates other types as necessary. For example, if the <code>ADDRESS</code> type were not listed in the <code>INTYPE</code> file, but the <code>Person</code> type had an attribute of type <code>ADDRESS</code>, then the OTT utility would still translate <code>ADDRESS</code> because it is required to define the <code>Person</code> type.</p>
<p>You may indicate whether the OTT utility should generate required object types that are not specified in the <code>INTYPE</code> file. Set <code>TRANSITIVE=FALSE</code> so the OTT utility does not to generate required object types. The default is <code>TRANSITIVE=TRUE</code>.</p>
<p>A normal case insensitive SQL identifier can be spelled in any combination of uppercase and lowercase in the <code>INTYPE</code> file, and is not quoted.</p>
<p>Use quotation marks, such as <code>TYPE "Person"</code> to reference SQL identifiers that have been created in a case sensitive manner, for example, <code>CREATE TYPE "Person"</code>. A SQL identifier is case sensitive if it was quoted when it was declared. Quotation marks can also be used to refer to a SQL identifier that is an OTT-reserved word, for example, <code>TYPE "CASE"</code>. In this case, the quoted name must be in uppercase if the SQL identifier was created in a case insensitive manner, for example, <code>CREATE TYPE Case</code>. If an OTT-reserved word is used to refer to the name of a SQL identifier but is not quoted, then the OTT utility reports a syntax error in the <code>INTYPE</code> file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i420386">"Structure of the INTYPE File"</a> for a more detailed specification of the structure of the <code>INTYPE</code> file and the available options.</p>
</li>
<li>
<p><a href="#i443287">"CASE"</a> for further information regarding the <code>CASE</code> parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i420386"></a><a id="LNCPP20388"></a>
<div class="sect2">
<h3 class="sect2">Structure of the INTYPE File</h3>
<p>The <code>INTYPE</code> and <code>OUTTYPE</code> files<a id="sthref571"></a> list the types translated by the OTT utility and provide all the information needed to determine how a type or attribute name is translated to a legal C or C++ identifier. These files contain one or more type specifications, and may also contain specifications of <code>CASE</code>, <code>CPPFILE</code>, <code>HFILE</code>, <code>INITFILE</code>, <code>INITFUNC</code>, <code>MAPFILE</code>, or <code>MAPFUNC</code>.</p>
<p>If the <code>CASE</code>, <code>INITFILE</code>, <code>INITFUNC</code>, <code>MAPFILE</code>, or <code>MAPFUNC</code> options are present, then they must precede any type specifications. If these options appear both on the command line and in the <code>INTYPE</code> file, then the value on the command line is used.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i440359">"Overview of the OUTTYPE File"</a> for an example of a simple user-defined <code>INTYPE</code> file and of the full <code>OUTTYPE</code> file that the OTT utility generates from it</div>
<a id="LNCPP20389"></a>
<div class="sect3"><a id="sthref572"></a>
<h4 class="sect3">INTYPE File Type Specifications</h4>
<p>A type specification in the <code>INTYPE</code> file names an object data type that is to be translated. The following is an example of a user-created <code>INTYPE</code> file:</p>
<pre>
TYPE employee
   TRANSLATE SALARY$ AS salary
      DEPTNO AS department
TYPE ADDRESS
TYPE PURCHASE_ORDER AS p_o
</pre>
<p>The structure of a type specification is as follows:</p>
<pre>
TYPE type_name
[GENERATE type_identifier]
[AS type_identifier]
[VERSION [=] version_string]
[HFILE [=] hfile_name]
[CPPFILE [=] cppfile_name]
[TRANSLATE{member_name [AS identifier]}...]
</pre>
<p>The <code>type_name</code> syntax follows this form:</p>
<pre>
[schema_name.]type_name
</pre>
<p>In this syntax, <code><span class="codeinlineitalic">schema_name</span></code> is the name of the schema that owns the given object data type, and <code><span class="codeinlineitalic">type_name</span></code> is the name of the type. The default schema, if one is not specified, is that of the userID invoking the OTT utility. To use a specific schema, you must use schema_name.</p>
<p>The components of the type specification are:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">type_name</span></code>: Name of the object data type.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">type_identifier</span></code>: C / C++ identifier used to represent the class. The <code>GENERATE</code> clause is used to specify the name of the class that the OTT utility generates. The AS clause specifies the name of the class that you write. The <code>GENERATE</code> clause is typically used to extend a class. The <code>AS</code> clause, when optionally used without the <code>GENERATE</code> clause, specifies the name of the C structure or the C++ class that represents the user-defined type.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">version_string</span></code>: Version string of the type that was used when the code was generated by the previous invocation of the OTT utility. The version string is generated by the OTT utility and written to the <code>OUTTYPE</code> file, which can later be used as the <code>INTYPE</code> file in later invocations of the OTT utility. The version string does not affect how the OTT utility operates, but can be used to select which version of the object data type is used in the running program.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">hfile_name</span></code>: Name of the header file into which the declarations of the corresponding class are written. If you omit the <code>HFILE</code> clause, then the file specified by the command line <code>HFILE</code> parameter is used.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">cppfile_name</span></code>: Name of the C++ source file into which the method implementations of the corresponding class is written. If you omit the <code>CPPFILE</code> clause, the file specified by the command line <code>CPPFILE</code> parameter is used.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">member_name</span></code>: Name of an attribute (data member) that is to be translated to the identifier.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">identifier</span></code>: C / C++ identifier used to represent the attribute in the program. You can specify identifiers in this way for any number of attributes. The default name mapping algorithm is used for the attributes not mentioned.</p>
</li>
</ul>
<p>An object data type may be translated for one of two reasons:</p>
<ul>
<li>
<p>It appears in the <code>INTYPE</code> file.</p>
</li>
<li>
<p>It is required to declare another type that must be translated, and the <code>TRANSITIVE</code> parameter is set to <code>TRUE</code>.</p>
</li>
</ul>
<p>If a type that is not mentioned explicitly is necessary to types declared in exactly one file, then the translation of the required type is written to the same files as the explicitly declared types that require it.</p>
<p>If a type that is not mentioned explicitly is necessary to types declared in multiple files, then the translation of the required type is written to the global <code>HFILE</code> file.</p>
<p>You may indicate whether the OTT utility should generate required object types that are not specified in the <code>INTYPE</code> file. Set <code>TRANSITIVE=FALSE</code> so the OTT utility does not to generate required object types. The default is <code>TRANSITIVE=TRUE</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i432204"></a><a id="LNCPP20390"></a>
<div class="sect2">
<h3 class="sect2">Nested #include File Generation</h3>
<p><code>HFILE</code> files generated by the OTT utility <code>#include</code> other necessary files, and <code>#define</code> a symbol constructed from the name of the file. This symbol <code>#define</code> can then be used to determine if the related <code>HFILE</code> file has been included. Consider, for example, a database with the following types:</p>
<pre>
create type px1 AS OBJECT (col1 number, col2 integer);
create type px2 AS OBJECT (col1 px1);
create type px3 AS OBJECT (col1 px1);
</pre>
<p>The <code>INTYPE</code> file contains the following information:</p>
<pre>
CASE=lower
type pxl
   hfile tott95a.h
type px3
   hfile tott95b.h
</pre>
<p>You invoke the OTT utility as follows:</p>
<pre>
&gt;ott hr intype=tott95i.typ outtype=tott95o.typ code=cpp
...
Enter password: <span class="italic">password</span>
</pre>
<p>The OTT utility then generates the following two header files, named <code>tott95a.h</code> and <code>tott95b.h</code>. They are listed in</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20391"></a><a id="sthref573"></a>Example 8-9 Listing of ott95a.h</p>
<pre>
#ifndef TOTT95A_ORACLE
# define TOTT95A_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

/************************************************************/
//  generated declarations for the PX1 object type.
/************************************************************/

class px1 : public oracle::occi::PObject {

protected:
   oracle::occi::Number col1;
   oracle::occi::Number col2;

public:
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   px1();
   px1(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~px1();
};

#endif
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20392"></a><a id="sthref574"></a>Example 8-10 Listing of ott95b.h</p>
<pre>
#ifndef TOTT95B_ORACLE
# define TOTT95B_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

#ifndef TOTT95A_ORACLE
# include "tott95a.h"
#endif

/************************************************************/
//  generated declarations for the PX3 object type.
/************************************************************/

class px3 : public oracle::occi::PObject {

protected:
   px1 * col1;

public:
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   px3();
   px3(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~px3();
};
#endif
</pre></div>
<!-- class="example" -->
<p>In the <code>tott95b.h</code> file, the symbol <code>TOTT95B_ORACLE</code> is <code>#define</code> d at the beginning of the file. This enables you to conditionally <code>#include</code> this header file in another file, using the following construct:</p>
<pre>
#ifndef TOTT95B_ORACLE
#include "tott95b.h"
#endif
</pre>
<p>By using this technique, you can <code>#include</code> <code>tott95b.h</code> in, say <code>foo.h</code>, without having to know whether some other file <code>#includ</code>ed in <code>foo.h</code> also <code>#include</code>s <code>tott95b.h</code>.</p>
<p>Next, the file <code>tott95a.h</code> is included because it contains the declaration of <code>struct px1</code>, that <code>tott95b.h</code> requires. When the <code>INTYPE</code> file requests that type declarations be written to multiple files, the OTT utility determines which other files each <code>HFILE</code> must <code>#include</code>, and generates each necessary <code>#include</code>.</p>
<p>Note that the OTT utility uses quotes in this <code>#include</code>. When a program including <code>tott95b.h</code> is compiled, the search for <code>tott95a.h</code> begins where the source program was found, and thereafter follows an implementation-defined search rule. If <code>tott95a.h</code> cannot be found in this way, then a complete filename (for example, a UNIX absolute path name beginning with a slash character (<code>/</code>)) is necessary in the <code>INTYPE</code> file to specify the location of <code>tott95a.h</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i426569"></a><a id="LNCPP20393"></a>
<div class="sect1">
<h2 class="sect1">OTT Utility Data Type Mappings<a id="sthref575"></a></h2>
<p>When the OTT utility generates a C++ class from a database type, the structure or class contains one element corresponding to each attribute of the object type. The data types of the attributes are mapped to types that are used in Oracle object data types. The data types found in Oracle include a set of predefined, primitive types and provide for the creation of user-defined types, like object types and collections.</p>
<p>The set of predefined types includes standard types that are familiar to most programmers, including number and character types. It also includes large object data types (for example, <code>BLOB</code> or <code>CLOB</code>).</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20394"></a><a id="sthref576"></a>Example 8-11 How to Represent Object Attributes Using the OTT Utility</p>
<p>Oracle also includes a set of predefined types that are used to represent object type attributes in C++ classes. Consider the following object type definition, and its corresponding OTT-generated structure declarations:</p>
<pre>
CREATE TYPE employee AS OBJECT
(  name       VARCHAR2(30),
   empno      NUMBER,
   deptno     NUMBER,
   hiredate   DATE,
   salary     NUMBER
);
</pre>
<p>The OTT utility, assuming that the <code>CASE</code> parameter is set to <code>LOWER</code> and there are no explicit mappings of type or attribute names, produces the following output:</p>
<pre>
#ifndef DATATYPES_ORACLE
# define DATATYPES_ORACLE

#ifndef OCCI_ORACLE
# include &lt;occi.h&gt;
#endif

/************************************************************/
//  generated declarations for the EMPLOYEE object type.
/************************************************************/

class employee : public oracle::occi::PObject {

protected:
   OCCI_STD_NAMESPACE::string NAME;
   oracle::occi::Number EMPNO;
   oracle::occi::Number DEPTNO;   oracle::occi::Date HIREDATE;
   oracle::occi::Number SALARY;

public:
   void *operator new(size_t size);
   void *operator new(size_t size, const oracle::occi::Connection * sess,
      const OCCI_STD_NAMESPACE::string&amp; table);
   void *operator new(size_t, void *ctxOCCI_);
   void *operator new(size_t size, const oracle::occi::Connection *sess,
      const OCCI_STD_NAMESPACE::string &amp;tableName, 
      const OCCI_STD_NAMESPACE::string &amp;typeName,
      const OCCI_STD_NAMESPACE::string &amp;tableSchema, 
      const OCCI_STD_NAMESPACE::string &amp;typeSchema);
   void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
      unsigned int &amp;schemaNameLen, void **typeName,
      unsigned int &amp;typeNameLen) const;
   employee();
   employee(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
   static void *readSQL(void *ctxOCCI_);
   virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
   static void writeSQL(void *objOCCI_, void *ctxOCCI_);
   virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
   ~employee();

};

#endif
</pre>
<p><a href="#g498965">Table 8-2</a> lists the mappings from types that can be used as attributes to object data types that are generated by the OTT utility.</p>
</div>
<!-- class="example" -->
<div class="tblformal">
<p class="titleintable"><a id="LNCPP20395"></a><a id="sthref577"></a><a id="g498965"></a>Table 8-2 C++ Object Data Type Mappings for Object Type Attributes</p>
<table class="cellalignment1073" title="C++ Object Data Type Mappings for Object Type Attributes" summary="First column lists object attribute types; second column provides C++ mappings." dir="ltr">
<thead>
<tr class="cellalignment1067">
<th class="cellalignment1074" id="r1c1-t11">Object Attribute Types</th>
<th class="cellalignment1074" id="r1c2-t11">C++ Mapping</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r2c1-t11" headers="r1c1-t11">
<p><code>BFILE</code></p>
</td>
<td class="cellalignment1075" headers="r2c1-t11 r1c2-t11">
<p><code>Bfile</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r3c1-t11" headers="r1c1-t11">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment1075" headers="r3c1-t11 r1c2-t11">
<p><code>Blob</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r4c1-t11" headers="r1c1-t11">
<p><code>BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment1075" headers="r4c1-t11 r1c2-t11">
<p><code>BDouble</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r5c1-t11" headers="r1c1-t11">
<p><code>BINARY_FLOAT</code></p>
</td>
<td class="cellalignment1075" headers="r5c1-t11 r1c2-t11">
<p><code>BFloat</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r6c1-t11" headers="r1c1-t11">
<p><code>CHAR(n), CHARACTER(n)</code></p>
</td>
<td class="cellalignment1075" headers="r6c1-t11 r1c2-t11">
<p><code>string</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r7c1-t11" headers="r1c1-t11">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment1075" headers="r7c1-t11 r1c2-t11">
<p><code>Clob</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r8c1-t11" headers="r1c1-t11">
<p><code>DATE</code></p>
</td>
<td class="cellalignment1075" headers="r8c1-t11 r1c2-t11">
<p><code>Date</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r9c1-t11" headers="r1c1-t11">
<p><code>DEC, DEC(n), DEC(n,n)</code></p>
</td>
<td class="cellalignment1075" headers="r9c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r10c1-t11" headers="r1c1-t11">
<p><code>DECIMAL, DECIMAL(n), DECIMAL(n,n)</code></p>
</td>
<td class="cellalignment1075" headers="r10c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r11c1-t11" headers="r1c1-t11">
<p><code>FLOAT, FLOAT(n), DOUBLE PRECISION</code></p>
</td>
<td class="cellalignment1075" headers="r11c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r12c1-t11" headers="r1c1-t11">
<p><code>INT, INTEGER, SMALLINT</code></p>
</td>
<td class="cellalignment1075" headers="r12c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r13c1-t11" headers="r1c1-t11">
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment1075" headers="r13c1-t11 r1c2-t11">
<p><code>IntervalDS</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r14c1-t11" headers="r1c1-t11">
<p><code>INTERVAL YEAR TO MONTH</code></p>
</td>
<td class="cellalignment1075" headers="r14c1-t11 r1c2-t11">
<p><code>IntervalYM</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r15c1-t11" headers="r1c1-t11">
<p><code>Nested Object Type</code></p>
</td>
<td class="cellalignment1075" headers="r15c1-t11 r1c2-t11">
<p>C++ name of the nested object type</p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r16c1-t11" headers="r1c1-t11">
<p><code>NESTED TABLE</code></p>
</td>
<td class="cellalignment1075" headers="r16c1-t11 r1c2-t11">
<p><code>vector&lt;attribute_type&gt;</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r17c1-t11" headers="r1c1-t11">
<p><code>NUMBER, NUMBER(n), NUMBER(n,n)</code></p>
</td>
<td class="cellalignment1075" headers="r17c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r18c1-t11" headers="r1c1-t11">
<p><code>NUMERIC, NUMERIC(n), NUMERIC(n,n)</code></p>
</td>
<td class="cellalignment1075" headers="r18c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r19c1-t11" headers="r1c1-t11">
<p><code>RAW</code></p>
</td>
<td class="cellalignment1075" headers="r19c1-t11 r1c2-t11">
<p><code>Bytes</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r20c1-t11" headers="r1c1-t11">
<p><code>REAL</code></p>
</td>
<td class="cellalignment1075" headers="r20c1-t11 r1c2-t11">
<p><code>Number</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r21c1-t11" headers="r1c1-t11">
<p><code>REF</code></p>
</td>
<td class="cellalignment1075" headers="r21c1-t11 r1c2-t11">
<p><code>Ref&lt;attribute_type&gt;</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r22c1-t11" headers="r1c1-t11">
<p><code>TIMESTAMP,TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</td>
<td class="cellalignment1075" headers="r22c1-t11 r1c2-t11">
<p><code>Timestamp</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r23c1-t11" headers="r1c1-t11">
<p><code>VARCHAR(n)</code></p>
</td>
<td class="cellalignment1075" headers="r23c1-t11 r1c2-t11">
<p><code>string</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r24c1-t11" headers="r1c1-t11">
<p><code>VARCHAR2(n)</code></p>
</td>
<td class="cellalignment1075" headers="r24c1-t11 r1c2-t11">
<p><code>string</code></p>
</td>
</tr>
<tr class="cellalignment1067">
<td class="cellalignment1075" id="r25c1-t11" headers="r1c1-t11">
<p><code>VARRAY</code></p>
</td>
<td class="cellalignment1075" headers="r25c1-t11 r1c2-t11">
<p><code>vector&lt;attribute_type&gt;</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="example">
<p class="titleinexample"><a id="LNCPP20396"></a><a id="sthref578"></a>Example 8-12 How to Map Object Data Types Using the OTT Utility</p>
<p>The example assumes that the following database types are created:</p>
<pre>
CREATE TYPE my_varray AS VARRAY(5) of integer;

CREATE TYPE object_type AS OBJECT
   (object_name VARCHAR2(20));

CREATE TYPE other_type AS OBJECT
   (object_number NUMBER);

CREATE TYPE my_table AS TABLE OF object_type;

CREATE TYPE many_types AS OBJECT
(
    the_varchar    VARCHAR2(30),
   the_char       CHAR(3),
   the_blob       BLOB,
   the_clob       CLOB,
   the_object     object_type,
   another_ref    REF other_type,
   the_ref        REF many_types,
   the_varray     my_varray,
   the_table      my_table,
   the_date       DATE,
   the_num        NUMBER,
   the_raw        RAW(255)
);
</pre>
<p>An <code>INTYPE</code> file exists, and includes the following:</p>
<pre>
CASE = LOWER
TYPE many_types
</pre>
<p>The following is an example of the OTT type mappings for C++, given the types created in the example in the previous section, and an <code>INTYPE</code> file that includes the following:</p>
<pre>
CASE = LOWER
TYPE many_types
</pre>
<pre>
#ifndef MYFILENAME_ORACLE
#define MYFILENAME_ORACLE

#ifndef OCCI_ORACLE
#include &lt;occi.h&gt;
#endif

/************************************************************/
//  generated declarations for the OBJECT_TYPE object type.
/************************************************************/

class object_type : public oracle::occi::PObject 
{
   protected:
      OCCI_STD_NAMESPACE::string object_name;

   public:
      void *operator new(size_t size);
      void *operator new(size_t size, const oracle::occi::Connection * sess,
         const OCCI_STD_NAMESPACE::string&amp; table);
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      object_type();
      object_type(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
      static void *readSQL(void *ctxOCCI_);
      virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
      static void writeSQL(void *objOCCI_, void *ctxOCCI_);
      virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
};

/************************************************************/
//  generated declarations for the OTHER_TYPE object type.
/************************************************************/

class other_type : public oracle::occi::PObject
{
   protected:
      oracle::occi::Number object_number;

   public:
      void *operator new(size_t size);
      void *operator new(size_t size, const oracle::occi::Connection * sess,
         const OCCI_STD_NAMESPACE::string&amp; table);
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      other_type();
      other_type(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
      static void *readSQL(void *ctxOCCI_);
      virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
      static void writeSQL(void *objOCCI_, void *ctxOCCI_);
      virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
};

/************************************************************/
//  generated declarations for the MANY_TYPES object type.
/************************************************************/

class many_types : public oracle::occi::PObject 
{
   protected:
      OCCI_STD_NAMESPACE::string the_varchar;
      OCCI_STD_NAMESPACE::string the_char;
      oracle::occi::Blob the_blob;
      oracle::occi::Clob the_clob;
      object_type * the_object;
      oracle::occi::Ref&lt; other_type &gt; another_ref;
      oracle::occi::Ref&lt; many_types &gt; the_ref;
      OCCI_STD_NAMESPACE::vector&lt; oracle::occi::Number &gt; the_varray;
      OCCI_STD_NAMESPACE::vector&lt; object_type * &gt; the_table;
      oracle::occi::Date the_date;
      oracle::occi::Number the_num;
      oracle::occi::Bytes the_raw;

   public:
      void *operator new(size_t size);
      void *operator new(size_t size, const oracle::occi::Connection * sess,
         const OCCI_STD_NAMESPACE::string&amp; table);
      void getSQLTypeName(oracle::occi::Environment *env, void **schemaName,
                          unsigned int &amp;schemaNameLen, void **typeName,
                          unsigned int &amp;typeNameLen) const;
      many_types();
      many_types(void *ctxOCCI_) : oracle::occi::PObject (ctxOCCI_) { };
      static void *readSQL(void *ctxOCCI_);
      virtual void readSQL(oracle::occi::AnyData&amp; streamOCCI_);
      static void writeSQL(void *objOCCI_, void *ctxOCCI_);
      virtual void writeSQL(oracle::occi::AnyData&amp; streamOCCI_);
};

#endif
</pre>
<p>The OTT utility generates the following C++ class declarations (comments are not part of the OTT output, and are added only to clarify the example):</p>
<p>For C++, when <code>TRANSITIVE=TRUE</code>, the OTT utility automatically translates any types that are used as attributes of a type being translated, including types that are only being accessed by a pointer or <code>REF</code> in an object type attribute. Even though only the <code>many_types</code> object was specified in the <code>INTYPE</code> file for the C++ example, a class declaration was generated for all the object types, including the <code>other_type</code> object, which was only accessed by a <code>REF</code> in the <code>many_types</code> object.</p>
</div>
<!-- class="example" -->
<a id="i433388"></a><a id="LNCPP20397"></a>
<div class="sect2">
<h3 class="sect2">Default Name Mapping<a id="sthref579"></a></h3>
<p>When the OTT utility creates a C or C++ identifier name for an object type or attribute, it translates the name from the database character set to a legal C or C++ identifier. First, the name is translated from the database character set to the character set used by the OTT utility. Next, if a translation of the resulting name is supplied in the <code>INTYPE</code> file, that translation is used. Otherwise, the OTT utility translates the name character-by-character to the compiler character set, applying the character case specified in the CASE parameter. The following text describes this in more detail.</p>
<p>When the OTT utility reads the name of a database entity, the name is automatically translated from the database character set to the character set used by the OTT utility. In order for the OTT utility to read the name of the database entity successfully, all the characters of the name must be found in the OTT character set, although a character may have different encodings in the two character sets.</p>
<p>The easiest way to guarantee that the character set used by the OTT utility contains all the necessary characters is to make it the same as the database character set. Note, however, that the OTT character set must be a superset of the compiler character set. That is, if the compiler character set is 7-bit ASCII, then the OTT character set must include 7-bit ASCII as a subset, and if the compiler character set is 7-bit EBCDIC, then the OTT character set must include 7-bit EBCDIC as a subset. The user specifies the character set that the OTT utility uses by setting the <code>NLS_LANG</code> environment variable, or by some other operating system-specific mechanism.</p>
<p>Once the OTT utility has read the name of a database entity, it translates the name from the character set used by the OTT utility to the compiler's character set. If a translation of the name appears in the <code>INTYPE</code> file, then the OTT utility uses that translation.</p>
<p>Otherwise, the OTT utility attempts to translate the name as follows:</p>
<ol>
<li>
<p>If the OTT character set is a multibyte character set, all multibyte characters in the name that have single-byte equivalents are converted to those single-byte equivalents.</p>
</li>
<li>
<p>The name is converted from the OTT character set to the compiler character set. The compiler character set is a single-byte character set such as <code>US7ASCII</code>.</p>
</li>
<li>
<p>The case of letters is set according to how the <code>CASE</code> parameter is defined, and any character that is not legal in a C or C++ identifier, or that has no translation in the compiler character set, is replaced by an underscore character (<code>_</code>). If at least one character is replaced by an underscore, then the OTT utility gives a warning message. If all the characters in a name are replaced by underscores, the OTT utility gives an error message.</p>
</li>
</ol>
<p>Character-by-character name translation does not alter underscores, digits, or single-byte letters that appear in the compiler character set, so legal C or C++ identifiers are not altered.</p>
<p>Name translation may, for example, translate accented single-byte characters such as <span class="italic">o</span> with an umlaut or an <span class="italic">a</span> with an accent grave to <span class="italic">o</span> or <span class="italic">a</span>, with no accent, and may translate a multibyte letter to its single-byte equivalent. Name translation typically fails if the name contains multibyte characters that lack single-byte equivalents. In this case, the user must specify name translations in the <code>INTYPE</code> file.</p>
<p>The OTT utility does not detect a naming clash caused by two or more database identifiers being mapped to the same C name, nor does it detect a naming problem where a database identifier is mapped to a C keyword.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i440359"></a><a id="LNCPP20398"></a>
<div class="sect1">
<h2 class="sect1">Overview of the OUTTYPE File</h2>
<p>The <code>OUTTYPE</code> file is named on the OTT command line. When the OTT utility generates a C++ header file, it also writes the results of the translation into the <code>OUTTYPE</code> file. This file contains an entry for each of the translated types, including its version string and the header file to which its C++ representation was written.</p>
<p>The <code>OUTTYPE</code> file from one OTT utility run can be used as the <code>INTYPE</code> file for a subsequent invocation of the OTT utility.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20399"></a><a id="sthref580"></a>Example 8-13 OUTTYPE File Generated by the OTT Utility</p>
<p>In this <code>INTYPE</code> file, the programmer specifies the case for OTT-generated C++ identifiers, and provides a list of types that should be translated. In two of these types, naming conventions are specified. This is what the <code>OUTTYPE</code> file looks like after running the OTT utility:</p>
<p>The following example shows what t:</p>
<pre>
CASE = LOWER
TYPE EMPLOYEE AS employee
   VERSION = "$8.0"
   HFILE = demo.h
   TRANSLATE SALARY$ AS salary
             DEPTNO AS department
TYPE ADDRESS AS ADDRESS
   VERSION = "$8.0"
   HFILE = demo.h
TYPE ITEM AS item
   VERSION = "$8.0"
   HFILE = demo.h
TYPE "Person" AS Person
   VERSION = "$8.0"
   HFILE = demo.h
TYPE PURCHASE_ORDER AS p_o
   VERSION = "$8.0"
   HFILE = demo.h
</pre>
<p>When examining the contents of the <code>OUTTYPE</code> file, you might discover types listed that were not included in the <code>INTYPE</code> file specification. For example, consider the case where the <code>INTYPE</code> file only specified that the <code>person</code> type was to be translated:</p>
<pre>
CASE = LOWER
TYPE PERSON
</pre>
<p>If the definition of the <code>person</code> type includes an attribute of type <code>address</code>, then the <code>OUTTYPE</code> file includes entries for both <code>PERSON</code> and <code>ADDRESS</code>. The <code>person</code> type cannot be translated completely without first translating <code>address</code>.</p>
</div>
<!-- class="example" -->
<p>The OTT utility analyzes the types in the <code>INTYPE</code> file for type dependencies before performing the translation, and translates other types as necessary.</p>
<p>You may indicate whether the OTT utility should generate required object types that are not specified in the <code>INTYPE</code> file. Set <code>TRANSITIVE=FALSE</code> so the OTT utility does not generate required object types. The default is <code>TRANSITIVE=TRUE</code>.</p>
</div>
<!-- class="sect1" -->
<a id="CHDDJHFG"></a><a id="LNCPP20400"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The OTT Utility and OCCI Applications</h2>
<p>The OTT utility generates objects and maps SQL data types to C++ classes. The OTT utility also implements a few methods called by OCCI when instantiating objects and a function that is called in the OCCI application to register the mappings with the environment. These declarations are stored in a header file that you include (<code>#include</code>) in your OCCI application. The prototype for the function that registers the mappings is written to a separate header file, which you also include in your OCCI application. The method implementations are stored in a C++ source code file (with extension <code>.cpp</code>) that is linked with the OCCI application. The function that registers the mappings is stored in a separate C++ (<code><span class="codeinlineitalic">xxx</span></code><code>.cpp</code>) file that is also linked with the application.</p>
<p><a href="#CHDCICIE">Figure 8-1</a> shows the steps involved in using the OTT utility with OCCI. These steps are described following the figure.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDCICIE"></a><a id="LNCPP20401"></a>Figure 8-1 The OTT Utility with OCCI</p>
<img width="569" height="430" src="img/ott_utility_with_occi.gif" alt="Description of Figure 8-1 follows" /><br />
<a id="sthref581" href="img_text/ott_utility_with_occi.htm">Description of "Figure 8-1 The OTT Utility with OCCI"</a><br />
<br /></div>
<!-- class="figure" -->
<ol>
<li>
<p>Create the type definitions in the database by using the SQL DLL.</p>
</li>
<li>
<p>Create the <code>INTYPE</code> file that contains the database types to be translated by the OTT utility.</p>
</li>
<li>
<p>Specify that C++ should be generated and invoke the OTT utility.</p>
<p>The OTT utility then generates the following files:</p>
<ul>
<li>
<p>A header file (with the extension <code>.h</code>) that contains C++ class representations of object types; the filename is specified on the OTT command line by the <code>HFILE</code> parameter.</p>
</li>
<li>
<p>A header file that contains the prototype of the function (<code>MAPFUNC</code>) that registers the mappings.</p>
</li>
<li>
<p>A C++ source file (with the extension <code>.cpp</code>) that contains the static methods called by OCCI while instantiating the objects; the filename is specified on the OTT command line by the <code>CPPFILE</code> parameter. Do not call these methods directly from your OCCI application.</p>
</li>
<li>
<p>A file that contains the function used to register the mappings with the environment (with the extension <code>.cpp</code>); the filename is specified on the OTT command line by the <code>MAPFILE</code> parameter.</p>
</li>
<li>
<p>A file (<code>OUTTYPE</code> file) that contains an entry for each of the translated types, including the version string and the file into which it is written; the filename is specified on the OTT command line by the <code>OUTTYPE</code> parameter.</p>
</li>
</ul>
</li>
<li>
<p>Write the OCCI application and include the header files created by the OTT utility in the OCCI source code file.</p>
<p>The application declares an environment and calls the function <code>MAPFUNC</code> to register the mappings.</p>
</li>
<li>
<p>Compile the OCCI application to create the OCCI object code, and link the object code with the OCCI libraries to create the program executable.</p>
</li>
</ol>
<a id="g528741"></a><a id="LNCPP20402"></a>
<div class="sect2">
<h3 class="sect2">C++ Classes Generated by the OTT Utility</h3>
<p>When the OTT utility generates a C++ class from a database object type, the class declaration contains one element corresponding to each attribute of the object type. The data types of the attribute are mapped to types that are used in Oracle object data types, as defined in <a href="#g498965">Table 8-2</a>.</p>
<p>For each class, two new operators, <code>readSQL()</code> and <code>writeSQL()</code> methods are generated. They are used by OCCI to marshall and unmarshall objects.</p>
<p>By default, the C++ classes generated by the OTT utility for an object type are derived from the <code>PObject</code> class, so the generated constructor in the class also derives from the <code>PObject</code> class. For inherited database types, the class is derived from the parent type class as is the generated constructor and only the elements corresponding to attributes not in the parent class are included.</p>
<p>Class declarations that include the elements corresponding to the database type attributes and the method declarations are included in the header file generated by the OTT utility. The method implementations are included in the <code>CPPFILE</code> file generated by the OTT utility.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20403"></a><a id="sthref582"></a>Example 8-14 How to Generate C++ Classes Using the OTT Utility</p>
<p>This example demonstrates how to generate C++ classes using the OTT utility:</p>
<ol>
<li>
<p>Define the types:</p>
<pre>
CREATE TYPE FULL_NAME AS OBJECT (first_name CHAR(20), 
   last_name CHAR(20));
CREATE TYPE ADDRESS AS OBJECT (state CHAR(20), zip CHAR(20));
CREATE TYPE ADDRESS_TAB AS VARRAY(3) of REF ADDRESS;
CREATE TYPE PERSON AS OBJECT (id NUMBER, name FULL_NAME, 
   curr_addr REF ADDRESS, prev_addr_l ADDRESS_TAB) NOT FINAL;
CREATE TYPE STUDENT UNDER PERSON (school_name CHAR(20));
</pre></li>
<li>
<p>Provide an <code>INTYPE</code> file:</p>
<pre>
CASE = SAME
MAPFILE = RegisterMappings_3.cpp
TYPE FULL_NAME AS FullName
   TRANSLATE first_name as FirstName
             last_name as LastName
TYPE ADDRESS
TYPE PERSON
TYPE STUDENT
</pre></li>
<li>
<p>Invoke the OTT utility:</p>
<pre>
ott userid=demousr intype=demoin_3.typ outype=demoout_3.typ 
   code=cpp hfile=demo_3.h cppfile=demo_3.cpp
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="LNCPP20404"></a>
<div class="sect2"><a id="sthref583"></a>
<h3 class="sect2">Map Registry Function</h3>
<p>One function to register the mappings with the environment is generated by the OTT utility. The function contains the mappings for all the types translated by the invocation of the OTT utility. The function name is either specified in the <code>MAPFUNC</code> parameter or, if that parameter is not specified, derived from <code>MAPFILE</code> parameter. The only argument to the function is the pointer to <code>Environment</code>.</p>
<p>The function uses the provided <code>Environment</code> to get <code>Map</code> and then registers the mapping of each translated type.</p>
</div>
<!-- class="sect2" -->
<a id="i458231"></a><a id="LNCPP20405"></a>
<div class="sect2">
<h3 class="sect2">Extending C++ Classes</h3>
<p>To enhance the functionality of a class generated by the OTT utility, you can derive new classes. You can also add methods to a class, but Oracle does not recommend doing so due to an inherent risk.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i469445">"Carrying Forward User Added Code"</a> for details on how to use OTT markers to retain code you want to add in OTT generated files</div>
<p>To generate both <code>CAddress</code> and <code>MyAddress</code> classes from the SQL object type <code>ADDRESS</code>, <code>MyAddress</code> class can be derived from <code>CAddress</code> class. The OTT utility must then alter the code it generates in the following ways:</p>
<ul>
<li>
<p>By using the <code>MyAddress</code> class instead of the <code>CAddress</code> class to represent attributes whose database type is <code>ADDRESS</code></p>
</li>
<li>
<p>By using the <code>MyAddress</code> class instead of the <code>CAddress</code> class to represent vector and <code>REF</code> elements whose database type is <code>ADDRESS</code></p>
</li>
<li>
<p>By using the <code>MyAddress</code> class instead of the <code>CAddress</code> class as the base class for database object types that are inherited from <code>ADDRESS</code>. Even though a derived class is a subtype of <code>MyAddress</code>, the <code>readSQL</code>() and <code>writeSQL()</code> methods called are those of the <code>CAddress</code> class.</p>
</li>
</ul>
<div class="infoboxnotewarn">
<p class="notep1">Caution:</p>
When a class is both extended and used as a base class for another generated class, the <span class="italic">inheriting</span> type class and the <span class="italic">inherited</span> type class must be generated in separate files.</div>
<div class="example">
<p class="titleinexample"><a id="LNCPP20406"></a><a id="sthref584"></a>Example 8-15 How to Extend C++ Classes Using the OTT Utility</p>
<p>To use the OTT utility to generate the <code>CAddress</code> class, which is derived from <code>MyAddress</code> class), the following clause must be specified in the <code>TYPE</code> statement:</p>
<pre>
TYPE ADDRESS GENERATE CAdress AS MyAddress
</pre>
<p>Given the database types <code>FULL_NAME</code>, <code>ADDRESS</code>, <code>PERSON</code>, and <code>PFGRFDENT</code> as they were created before and changing the <code>INTYPE</code> file to include the <code>GENERATE...</code><code>AS</code> clause:</p>
<pre>
CASE = SAME
MAPFILE = RegisterMappings_5.cpp

TYPE FULL_NAME GENERATE CFullName AS MyFullName
   TRANSLATE first_name as FirstName
             last_name as LastName

TYPE ADDRESS GENERATE CAddress AS MyAddress
TYPE PERSON GENERATE CPerson AS MyPerson
TYPE STUDENT GENERATE CStudent AS MyStudent
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i469445"></a><a id="LNCPP20407"></a>
<div class="sect1">
<h2 class="sect1">Carrying Forward User Added Code</h2>
<p>To extend the functionality of OTT generated code, at times programmers may want to add code in the OTT generated file. The way OTT can distinguish between OTT generated code and code added by the user is by looking for some predefined markers (tags). OTT recognizes <code>OTT_USERCODE_START</code> as the start of user code marker, and <code>OTT_USERCODE_END</code> as the end of user code marker.</p>
<p>For OTT marker support, a user block is defined as</p>
<pre>
OTT_USERCODE_START + user added code + OTT_USERCODE_END
</pre>
<p>OTT marker support enables carrying forward the user added blocks in *.h and *.cpp files.</p>
<a id="i474922"></a><a id="LNCPP20408"></a>
<div class="sect2">
<h3 class="sect2">Properties of OTT Markers</h3>
<p>These items describe the properties of OTT Markers Support:</p>
<ol>
<li>
<p>User must use the command line option <code>USE_MARKER=TRUE</code> from the very first time OTT is invoked to generate a file.</p>
</li>
<li>
<p>User should treat markers like other C++ statements; a marker defined by OTT in the generated file as follows when the command line option <code>USE_MARKER=TRUE</code> is used:</p>
<pre>
         #ifndef OTT_USERCODE_START 
         #define OTT_USERCODE_START 
         #endif
         #ifndef OTT_USERCODE_END
         #define OTT_USERCODE_END
         #endif
</pre></li>
<li>
<p>The markers, <code>OTT_USERCODE_START</code> and <code>OTT_USERCODE_END</code>, must be preceded and followed by white space.</p>
</li>
<li>
<p>OTT copies the text or code given within markers verbatim, along with the markers, while generating the code next time.</p>
<p>User modified code:</p>
<pre>
         1  // --- modified generated code 
         2  OTT_USERCODE_START 
         3  // --- including "myfullname.h" 
         4  #ifndef MYFULLNAME_ORACLE 
         5  #include "myfullname.h" 
         6  #endif 
         7  OTT_USERCODE_END 
         8  // --- end of code addition 
</pre>
<p>Carried forward code:</p>
<pre>
         1  OTT_USERCODE_START 
         2  // --- including "myfullname.h" 
         3  #ifndef MYFULLNAME_ORACLE 
         4  #include "myfullname.h" 
         5  #endif 
         6  OTT_USERCODE_END 
</pre></li>
<li>
<p>OTT does not carry forward user-added code properly if the database <code>TYPE</code> or <code>INTYPE</code> file undergoes changes as shown in the following cases:</p>
<ul>
<li>
<p>If user modifies the case of the type name, OTT fails to determine the class name with which the code was associated earlier, as the case of the class name is modified by the user in the <code>INTYPE</code> file.</p>
<pre>
<span class="bold">CASE=UPPER                               CASE=LOWER </span>
TYPE employee                            TYPE employee 
TRANSLATE SALARY$ AS salary              TRANSLATE SALARY$ AS salary 
   DEPTNO AS department                     DEPTNO AS department 
TYPE ADDRESS                             TYPE ADDRESS 
TYPE item                                TYPE item 
TYPE "Person"                            TYPE "Person" 
TYPE PURCHASE_ORDER AS p_o               TYPE PURCHASE_ORDER AS p_o
</pre></li>
<li>
<p>If user asks to generate the class with a different name (<code>GENERATE AS</code> clause of <code>INTYPE</code> file), OTT fails to determine the class name with which the code was associated earlier as the class name was modified by the user in the <code>INTYPE</code> file.</p>
<pre>
CASE=LOWER                           CASE=LOWER 
TYPE employee                        TYPE employee 
TRANSLATE SALARY$ AS salary          TRANSLATE SALARY$ AS salary 
   DEPTNO AS department                 DEPTNO AS department 
TYPE ADDRESS                         TYPE ADDRESS 
TYPE item                            TYPE item 
TYPE "Person"                        TYPE "Person" 
<span class="bold">TYPE PURCHASE_ORDER AS p_o           TYPE PURCHASE_ORDER AS</span>
<span class="bold">                                        purchase_order</span>
</pre></li>
</ul>
</li>
<li>
<p>If OTT encounters an error while parsing an <code>.h</code> or <code>.cpp</code> file, it reports the error and leaves the file having error as it is so that the user can go back and correct the error reported, and rerun OTT.</p>
</li>
<li>
<p>OTT flags an error if:</p>
<ul>
<li>
<p>it does not find a matching <code>OTT_USERCODE_END</code> for <code>OTT_USERCODE_START</code> encountered</p>
</li>
<li>
<p>markers are nested (OTT finds next <code>OTT_USERCODE_START</code> before <code>OTT_USERCODE_END</code> is found for the previous <code>OTT_USERCODE_START</code>)</p>
</li>
<li>
<p><code>OTT_USERCODE_END</code> is encountered before <code>OTT_USERCODE_START</code></p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i474923"></a><a id="LNCPP20409"></a>
<div class="sect2">
<h3 class="sect2">Using OTT Markers</h3>
<p>The user must use command line option <code>USE_MARKER=TRUE</code> to turn on marker support. There are two general ways in which OTT markers can carry forward user added code:</p>
<ol>
<li>
<p><span class="bold">User code added in .h file.</span></p>
<ul>
<li>
<p><span class="bold">User code added in global scope.</span> This is typically the case when user must include different header files, forward declaration, and so on. Refer to the code example provided later.</p>
</li>
<li>
<p><span class="bold">User code added in class declaration.</span> At any point of time OTT generated class declaration has private scope for data members and public scope for methods, or protected scope for data members and public scope for methods. User blocks can be added after all OTT generated declarations in either access specifiers.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="LNCPP20410"></a><a id="sthref585"></a>Example 8-16 How to Add User Code to a Header File Using OTT Utility</p>
<pre>
...                                                 
#ifndef OTT_USERCODE_START                                  
#define OTT_USERCODE_START 
#endif
#ifndef OTT_USERCODE_END
#define OTT_USERCODE_END
#endif           

#ifndef OCCI_ORACLE
#include &lt;occi.h&gt;
#endif

OTT_USERCODE_START     // user added code 
...
OTT_USERCODE_END

#ifndef ...            // OTT generated include
#include " ... "
#endif

OTT_USERCODE_START     // user added code 
...
OTT_USERCODE_END

class &lt;class_name_1&gt; : public oracle::occi::PObject
{  protected:
      ...             // OTT generated data members 
      OTT_USERCODE_START    // user added code  for data member / method
      ...                   //    declaration / inline method
      OTT_USERCODE_END
     
   public:
      void *operator new(size_t size);
      ...
      OTT_USERCODE_START   // user added code  for data member / method
      ...                  // declaration / inline method definition
      OTT_USERCODE_END
};
  
OTT_USERCODE_START     // user added code 
...
OTT_USERCODE_END

class &lt;class_name_2&gt; : public oracle::occi::PObject
{
   ...
};

OTT_USERCODE_START     // user added code 
...                                                          
OTT_USERCODE_END                                             
...                                                                  
#endif                 // end of .h file                     
</pre></div>
<!-- class="example" --></li>
<li>
<p><span class="bold">User code added in .cpp file.</span> OTT supports adding a new user defined method within OTT markers. The user block must be added at the beginning of the file, just after the includes and before the definition of OTT-generated methods. If there are multiple OTT-generated <code>include</code>s, user code can also be added between OTT generated includes. User code added in any other part of a <code><span class="codeinlineitalic">xxx</span></code><code>.cpp</code> file is not carried forward.</p>
<div class="example">
<p class="titleinexample"><a id="LNCPP20411"></a><a id="sthref586"></a>Example 8-17 How to Add User Code to the Source File Using the OTT Utility</p>
<pre>
#ifndef OTT_USERCODE_START                                   
#define OTT_USERCODE_START                                  
#endif                                                       
                                                                   
#ifndef OTT_USERCODE_END
#define OTT_USERCODE_END
#endif
...
   OTT_USERCODE_START    // user added code 
      ...
   OTT_USERCODE_END
...
   OTT_USERCODE_START    // user added code 
      ...
   OTT_USERCODE_END

/*************************************************************
/ generated method implementations for the ... object type.
/*************************************************************/

void *&lt;class_name_1&gt;::operator new(size_t size)
{
   return oracle::occi::PObject::operator new(size);
}
...                                                          
// end of .cpp file                                          
</pre></div>
<!-- class="example" --></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1066">
<tr>
<td class="cellalignment1075">
<table class="cellalignment1071">
<tr>
<td class="cellalignment1070"><a href="lobs.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1070"><a href="globalization.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1078">
<table class="cellalignment1069">
<tr>
<td class="cellalignment1070"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1070"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1070"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1070"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1070"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1070"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
