<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Building Domain Indexes</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2010-03-08T13:16:27Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Cartridge Developer's Guide" />
<meta name="dcterms.identifier" content="E10765-02" />
<meta name="dcterms.isVersionOf" content="ADDCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ext_idx_frmwork.htm" title="Previous" type="text/html" />
<link rel="Next" href="operators.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10765.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/36</span> <!-- End Header --><a id="BHADJHIF"></a><a id="ADDCI290"></a>
<h1 class="chapter"><span class="secnum">8</span> Building Domain Indexes</h1>
<p>This chapter introduces the concept of domain indexes and the <code>ODCIIndex</code> interface. It then demonstrates the uses of domain indexes, their partitioning, applicable restrictions, and migration procedures.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#BABDEGCF">Overview of Indextypes and Domain Indexes</a></p>
</li>
<li>
<p><a href="#CHDBIIIE">ODCIIndex Interface</a></p>
</li>
<li>
<p><a href="#BABJHJGA">Creating, Dropping, and Commenting Indextypes</a></p>
</li>
<li>
<p><a href="#CHDCFFFC">Domain Indexes</a></p>
</li>
<li>
<p><a href="#CHDEHABI">Object Dependencies, Drop Semantics, and Validation</a></p>
</li>
<li>
<p><a href="#CHDJEJFH">Indextype, Domain Index, and Operator Privileges</a></p>
</li>
<li>
<p><a href="#i1006614">Partitioned Domain Indexes</a></p>
</li>
<li>
<p><a href="#BHACAFIG">Using System Partitioning</a></p>
</li>
<li>
<p><a href="#BHAFCACE">Using System-Managed Domain Indexes</a></p>
</li>
<li>
<p><a href="#BHADBEIH">Designing System-Managed Domain Indexes</a></p>
</li>
<li>
<p><a href="#BHAHHAGF">Creating Local Domain Indexes</a></p>
</li>
<li>
<p><a href="#BHABGABF">Maintaining Local Domain Indexes with INSERT, DELETE, and UPDATE</a></p>
</li>
<li>
<p><a href="#BHAHDGGD">Querying Local Domain Indexes</a></p>
</li>
<li>
<p><a href="#BHAECDGJ">Restrictions of System-Managed Domain Indexing</a></p>
</li>
<li>
<p><a href="#BGBHGBJF">Migrating Non-Partitioned Indexes</a></p>
</li>
<li>
<p><a href="#BGBJBCDA">Migrating Local Partitioned Indexes</a></p>
</li>
</ul>
<p>If you use user-managed domain indexes, the information specific to their implementation is in <a href="user_man_idx_apnd.htm#BABJGEEF">Appendix A, "User-Managed Local Domain Indexes"</a></p>
<a id="BABDEGCF"></a><a id="ADDCI4409"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of Indextypes and Domain Indexes</h2>
<p>A <a id="sthref313"></a><span class="glossaryterm">domain index</span> is an index designed for a specialized domain, such as spatial or image processing. Users can build a domain index of a given type after the designer creates the <span class="glossaryterm"><a id="sthref314"></a>indextype</span>. The behavior of domain indexes is specific to an industry, a business function, or some other special purpose; you must specify it during cartridge development.</p>
<p>The system-managed approach to domain indexes, new in the Oracle Database 11g Release 1, requires less programmatic overhead and delivers better performance than the earlier user-managed domain indexes. It addresses the limitations of the user-managed approach, and has the following benefits:</p>
<ul>
<li>
<p>Because the kernel performs many more maintenance tasks on behalf of the user, there is no need for programmatic support for table and partition maintenance operations. These operations are implemented by taking actions in the server, thus requiring a very minimal set of user-defined interface routines to be coded by the user. The cartridge code can then be relatively unaware of partition issues.</p>
</li>
<li>
<p>The number of objects that must be managed to support local partitioned domain indexes is identical to identical to those for non-partitioned domain indexes. For local partitioned indexes, the domain index storage tables are equipartitioned with respect to the base tables (using system-partitioned tables); therefore, the number of domain index storage tables does not increase with an increase in the number of partitions.</p>
</li>
<li>
<p>A single set of query and DML statements can now access and manipulate the system-partitioned storage tables, facilitating cursor sharing and enhancing performance.</p>
</li>
</ul>
<p>Oracle recommends that you develop new applications with system-managed domain indexes instead of user-managed domain indexes.</p>
<p>Indextypes encapsulate search and retrieval methods for complex domains such as text, spatial, and image processing. An indextype is similar to the indexes that are supplied with the Oracle Database. The difference is that you provide the application software that implements the indextype.</p>
<p>An indextype has two major components:</p>
<ul>
<li>
<p>The methods that implement the behavior of the indextype, such as creating and scanning the index</p>
</li>
<li>
<p>The operators that the indextype supports, such as <code>Contains()</code> or <code>Overlaps()</code></p>
</li>
</ul>
<p>To create an indextype:</p>
<ul>
<li>
<p>Define the supported operators and create the functions that implement them</p>
</li>
<li>
<p>Create the methods that implement the <code>ODCIIndex</code> interface, and define the type that encapsulates them, called the <a id="sthref315"></a><span class="glossaryterm">implementation type</span></p>
</li>
<li>
<p>Create the indextype, specifying the implementation type and listing the operators with their <a id="sthref316"></a>bindings</p>
</li>
</ul>
<p>In this context:</p>
<ul>
<li>
<p>Interface means a logical set of documented method specifications (not a separate schema object)</p>
</li>
<li>
<p><code>ODCIIndex</code> interface means a set of index definition, maintenance, and scan routine specifications</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="operators.htm#BACJHBGC">Chapter 9, "Defining Operators"</a></div>
</div>
<!-- class="sect1" -->
<a id="CHDBIIIE"></a><a id="ADDCI4410"></a>
<div class="sect1">
<h2 class="sect1">ODCIIndex Interface</h2>
<p>The <code>ODCIIndex</code> interface specifies all the routines you must supply to implement an indextype. The routines must be implemented as type methods.</p>
<p>The <code>ODCIIndex</code> interface comprises the following method classes:</p>
<ul>
<li>
<p>Index definition methods</p>
</li>
<li>
<p>Index maintenance methods</p>
</li>
<li>
<p>Index scan methods</p>
</li>
<li>
<p>Index metadata method</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ext_idx_ref.htm#CHECIBFB">Chapter 20, "Extensible Indexing Interface"</a> for method signatures and parameter descriptions</div>
<a id="ADDCI4411"></a>
<div class="sect2"><a id="sthref317"></a>
<h3 class="sect2">Index Definition Methods</h3>
<p>Your index definition methods are called when a user issues a <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, or <code>TRUNCATE</code> statement on an index of your indextype.</p>
<a id="ADDCI4412"></a>
<div class="sect3"><a id="sthref318"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a></h4>
<p>When a user issues a <code>CREATE INDEX</code> statement that references the indextype, Oracle calls your <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> method, passing it any parameters specified as part of the <code>CREATE</code> <code>INDEX</code>... <code>PARAMETERS</code> (...) statement, plus the description of the index.</p>
<p>Typically, this method creates the tables or files in which you plan to store index data. Unless the base table is empty, the method should also build the index.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4413"></a>
<div class="sect3"><a id="sthref319"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a></h4>
<p>When a user issues an <code>ALTER INDEX</code> statement referencing your indextype, Oracle calls your <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> method, passing it the description of the domain index to be altered along with any specified parameters. This method is also called to handle an <code>ALTER INDEX</code> with the <code>REBUILD</code> or <code>RENAME</code> options. What your method must do depends on the nature of your domain index, so the details are left to you as the designer of the indextype.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4414"></a>
<div class="sect3"><a id="sthref320"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a></h4>
<p>When a user destroys an index of your indextype by issuing a <code>DROP</code> <code>INDEX</code> statement, Oracle calls your <a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a> method.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4415"></a>
<div class="sect2"><a id="sthref321"></a>
<h3 class="sect2">Index Maintenance Methods</h3>
<p>Your index maintenance methods are called when users issue <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements on tables with columns or object type attributes indexed by your indextype.</p>
<a id="ADDCI4416"></a>
<div class="sect3"><a id="sthref322"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a></h4>
<p>When a user inserts a record, Oracle calls your <a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a> method, passing it the new values in the indexed columns and the corresponding row identifier.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4417"></a>
<div class="sect3"><a id="sthref323"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a></h4>
<p>When a user deletes a record, Oracle calls your <a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a> method, passing it the old values in the indexed columns and the corresponding row identifier.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4418"></a>
<div class="sect3"><a id="sthref324"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a></h4>
<p>When a user updates a record, Oracle calls your <a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a> method, passing it the old and new values in the indexed columns and the corresponding row identifier.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4419"></a>
<div class="sect2"><a id="sthref325"></a>
<h3 class="sect2">Index Scan Methods</h3>
<p>Your index scan methods specify the index-based implementation for evaluating predicates containing the operators supported by your indextype. Index scans involve methods for initialization, fetching rows or row identifiers, and cleaning up after all rows are returned.</p>
<p>There are two modes of evaluating the operator predicate and returning the resulting set of rows:</p>
<ul>
<li>
<p><span class="bold">Precompute All</span>: Compute the entire result set in <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a>. Iterate over the results returning a batch of rows from each call to <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a>. This mode is applicable to operators that must look at the entire result set to compute ranking, relevance, and so on for each candidate row. It is also possible to return one row at a time if your application requires that.</p>
</li>
<li>
<p><span class="bold">Incremental Computation</span>: Compute a batch of result rows in each call to <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a>. This mode is applicable to operators that can determine the candidate rows one at a time without having to look at the entire result set. It is also possible to return one row at a time if your application requires that.</p>
</li>
</ul>
<a id="ADDCI4420"></a>
<div class="sect3"><a id="sthref326"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a></h4>
<p>Oracle calls your <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> method at the beginning of an index scan, passing it information on the index and the operator. Typically, this method:</p>
<ul>
<li>
<p>Initializes data structures used in the scan</p>
</li>
<li>
<p>Parses and executes SQL statements that query the tables storing the index data</p>
</li>
<li>
<p>Saves any state information required by the fetch and cleanup methods, and returns the state or a handle to it</p>
</li>
<li>
<p>Sometimes generates a set of result rows to be returned at the first invocation of <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a></p>
</li>
</ul>
<p>The information on the index and the operator is not passed to the fetch and cleanup methods. Thus, <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> must save <span class="glossaryterm">state</span> data that must be shared among the index scan routines and return it through an output <code>sctx</code> parameter. To share large amounts of state data, allocate cursor-duration memory and return a handle to the memory in the <code>sctx</code> parameter.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI190" href="../../appdev.112/e10646/oci20ext.htm#LNOCI190"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for information on memory services and maintaining context</div>
<p>As member methods, <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> and <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> are passed the built-in <code>SELF</code> parameter, through which they can access the state data.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4421"></a>
<div class="sect3"><a id="sthref327"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a></h4>
<p>Oracle calls your <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> method to return the row identifiers of the next batch of rows that satisfies the operator predicate, passing it the state data returned by <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> or the previous <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> call. The operator predicate is specified in terms of the operator expression (name and arguments) and a lower and upper bound on the operator return values. Thus, <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> must return the row identifiers of the rows for which the operator return value falls within the specified bounds. To indicate the end of index scan, return a <code>NULL</code>.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4422"></a>
<div class="sect3"><a id="sthref328"></a>
<h4 class="sect3"><a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a></h4>
<p>Oracle calls your <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> method when the cursor is closed or reused, passing it the current state. <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> should perform whatever cleanup or closure operations your indextype requires.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4423"></a>
<div class="sect2"><a id="sthref329"></a>
<h3 class="sect2">Index Metadata Method</h3>
<p>The <a href="ext_idx_ref.htm#i76838">ODCIIndexGetMetadata()</a> method is optional. If you implement it, the Export utility calls it to write implementation-specific metadata into the Export dump file. This metadata might be policy information, version information, individual user settings, and so on, which are not stored in the system catalogs. The metadata is written to the dump files as anonymous PL/SQL blocks that are executed at import time immediately before the creation of the associated index.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4424"></a>
<div class="sect2"><a id="sthref330"></a>
<h3 class="sect2">Transaction Semantics During Index Method Execution</h3>
<p>The index interface methods (with the exception of the index definition methods, <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a>, <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a>, and <a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a>) are invoked under the same transaction that triggered these actions. Thus, the changes made by these routines are atomic and are committed or aborted based on the parent transaction. To achieve this, there are certain restrictions on the nature of the actions that you can perform in the different indextype routines:</p>
<ul>
<li>
<p>Index definition routines have no restrictions.</p>
</li>
<li>
<p>Index maintenance routines can only execute Data Manipulation Language statements. These DML statements cannot update the base table on which the domain index is created.</p>
</li>
<li>
<p>Index scan routines can only execute SQL query statements.</p>
</li>
</ul>
<p>For example, if an <code>INSERT</code> statement caused the <a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a> routine to be invoked, <a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a> runs under the same transaction as <code>INSERT</code>. The <a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a> routine can execute any number of DML statements (for example, insert into index-organized tables). If the original transaction aborts, all the changes made by the indextype routines are rolled back.</p>
<p>However, if the indextype routines cause changes external to the database (like writing to external files), transaction semantics are not assured.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4425"></a>
<div class="sect2"><a id="sthref331"></a>
<h3 class="sect2">Transaction Semantics for Index Definition Routines</h3>
<p>The index definition routines do not have any restrictions on the nature of actions within them. Consider <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> to understand this difference. A typical set of actions to be performed in <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> could be:</p>
<ol>
<li>
<p>Create an index-organized table.</p>
</li>
<li>
<p>Insert data into the index-organized table.</p>
</li>
<li>
<p>Create a secondary index on a column of the index-organized table.</p>
</li>
</ol>
<p>To allow <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> to execute an arbitrary sequence of DDL and DML statements, each statement is considered to be an independent operation. Consequently, the changes made by <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> are not guaranteed to be atomic. The same is true for other index-definition routines.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4426"></a>
<div class="sect2"><a id="sthref332"></a>
<h3 class="sect2">Consistency Semantics during Index Method Execution</h3>
<p>The index maintenance (and scan routines) execute with the same snapshot as the top level SQL statement performing the DML (or query) operation. This keeps the index data processed by the index method consistent with the data in the base tables.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4427"></a>
<div class="sect2"><a id="sthref333"></a>
<h3 class="sect2">Privileges During Index Method Execution</h3>
<p>Indextype routines always execute as the owner of the index. To support this, the index access driver dynamically changes user mode to index owner before invoking the indextype routines.</p>
<p>For certain operations, indextype routines store information in tables owned by the indextype designer. The indextype implementation must perform those actions in a separate routine, which is executed using the definer's privileges.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="variable">Oracle Database SQL Language Reference</span></a> for details on <code>CREATE TYPE</code></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJHJGA"></a><a id="ADDCI4428"></a>
<div class="sect1">
<h2 class="sect1">Creating, Dropping, and Commenting Indextypes</h2>
<p>This section describes the SQL statements that manipulate indextypes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for complete descriptions of these SQL statements</div>
<a id="ADDCI4429"></a>
<div class="sect2"><a id="sthref334"></a>
<h3 class="sect2">Creating Indextypes</h3>
<p>When you have implemented the <code>ODCIIndex</code> interface and defined the implementation type, you can create a new indextype by specifying the list of operators supported by the indextype and referring to the type that implements the index interface.</p>
<p>Using the information retrieval example, the DDL statement for defining the new indextype <code>TextIndexType</code>, which supports the <code>Contains</code> operator and whose implementation is provided by the type <code>TextIndexMethods</code>, as demonstrated by <a href="#BHABFJIG">Example 8-1</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHABFJIG"></a><a id="ADDCI4430"></a>Example 8-1 Creating an Indextype</p>
<pre>
CREATE INDEXTYPE TextIndexType
FOR Contains (VARCHAR2, VARCHAR2)
USING TextIndexMethods
WITH SYSTEM MANAGED STORAGE TABLES;
</pre></div>
<!-- class="example" -->
<p>In addition to the <code>ODCIIndex</code> interface routines, the implementation type must implement the <a href="ext_idx_ref.htm#BJEJEIJD">ODCIGetInterfaces()</a> routine. This routine returns the version of the interface implemented by the implementation type. Oracle invokes the <a href="ext_idx_ref.htm#BJEJEIJD">ODCIGetInterfaces()</a> routine when <code>CREATE INDEXTYPE</code> is executed.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4431"></a>
<div class="sect2"><a id="sthref335"></a>
<h3 class="sect2">Dropping Indextypes</h3>
<p>To remove the definition of an indextype, use the <code>DROP</code> statement, as in <a href="#BHAGCEBA">Example 8-2</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAGCEBA"></a><a id="ADDCI4432"></a>Example 8-2 Dropping an IndexType</p>
<pre>
DROP INDEXTYPE TextIndexType;
</pre></div>
<!-- class="example" -->
<p>The default <code>DROP</code> behavior is <code>DROP RESTRICT</code> semantics, that is, if one or more domain indexes exist that uses the indextype then the <code>DROP</code> operation is disallowed. Users can override the default behavior with the <code>FORCE</code> option, which drops the indextype and marks any dependent domain indexes invalid.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDEHABI">"Object Dependencies, Drop Semantics, and Validation"</a> for details on object dependencies and drop semantics</div>
</div>
<!-- class="sect2" -->
<a id="ADDCI4433"></a>
<div class="sect2"><a id="sthref336"></a>
<h3 class="sect2">Commenting Indextypes</h3>
<p>Use the <code>COMMENT</code> statement to supply information about an indextype or operator, as shown in <a href="#BHACJDCF">Example 8-3</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BHACJDCF"></a><a id="ADDCI4434"></a>Example 8-3 Commenting an INDEXTYPE</p>
<pre>
COMMENT ON INDEXTYPE
TextIndexType IS 'implemented by the type TextIndexMethods to support the Contains operator';
</pre></div>
<!-- class="example" -->
<p>Comments on indextypes can be viewed in these data dictionary views:</p>
<ul>
<li>
<p><a id="sthref337"></a><a id="sthref338"></a><code>ALL_INDEXTYPE_COMMENTS</code> displays comments for the user-defined indextypes accessible to the current user.</p>
</li>
<li>
<p><a id="sthref339"></a><a id="sthref340"></a><code>DBA_INDEXTYPE_COMMENTS</code> displays comments for all user-defined indextypes in the database.</p>
</li>
<li>
<p><a id="sthref341"></a><a id="sthref342"></a><code>USER_INDEXTYPE_COMMENTS</code> displays comments for the user-defined indextypes owned by the current user.</p>
</li>
</ul>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4435"></a><a id="sthref343"></a><a id="sthref344"></a>Table 8-1 Views ALL_INDEXTYPE_COMMENTS, DBA_INDEXTYPE_COMMENTS, and USER_INDEXTYPE_COMMENTS</p>
<table class="cellalignment1246" title="Views ALL_INDEXTYPE_COMMENTS, DBA_INDEXTYPE_COMMENTS, and USER_INDEXTYPE_COMMENTS" summary="Column 1 lists the view column; column 2 shows the datatype used; column 3 indicates if a value is required, and column 4 gives the description" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t8">Column</th>
<th class="cellalignment1247" id="r1c2-t8">Data Type</th>
<th class="cellalignment1247" id="r1c3-t8">Required</th>
<th class="cellalignment1247" id="r1c4-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t8" headers="r1c1-t8">
<pre>
OWNER
</pre></td>
<td class="cellalignment1243" headers="r2c1-t8 r1c2-t8">
<pre>
VARCHAR2(30)
</pre></td>
<td class="cellalignment1243" headers="r2c1-t8 r1c3-t8">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r2c1-t8 r1c4-t8">
<p>Owner of the user-defined indextype</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t8" headers="r1c1-t8">
<pre>
INDEXTYPE_NAME
</pre></td>
<td class="cellalignment1243" headers="r3c1-t8 r1c2-t8">
<pre>
VARCHAR2(30)
</pre></td>
<td class="cellalignment1243" headers="r3c1-t8 r1c3-t8">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r3c1-t8 r1c4-t8">
<p>Name of the user-defined indextype</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t8" headers="r1c1-t8">
<pre>
COMMENT
</pre></td>
<td class="cellalignment1243" headers="r4c1-t8 r1c2-t8">
<pre>
VARCHAR2(4000)
</pre></td>
<td class="cellalignment1243" headers="r4c1-t8 r1c3-t8">
<pre>
 
</pre></td>
<td class="cellalignment1243" headers="r4c1-t8 r1c4-t8">
<p>Comment for the user-defined indextype</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>To place a comment on an indextype, the indextype must be in your own schema or you must have the <code>COMMENT ANY INDEXTYPE</code> privilege.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCFFFC"></a><a id="ADDCI4436"></a>
<div class="sect1">
<h2 class="sect1">Domain Indexes</h2>
<p>This section describes the <a id="sthref345"></a>domain index operations and how metadata associated with the domain index can be obtained.</p>
<a id="ADDCI4437"></a>
<div class="sect2"><a id="sthref346"></a>
<h3 class="sect2">Domain Index Operations</h3>
<p>The following sections describe and demonstrated how to create, alter, truncate, and drop a domain index.</p>
<a id="ADDCI4438"></a>
<div class="sect3"><a id="sthref347"></a>
<h4 class="sect3">Creating a Domain Index</h4>
<p>A domain index can be created on a column of a table, just like a B-tree index. However, an indextype must be explicitly specified. <a href="#BHAFCECC">Example 8-4</a> shows how to specify an indextype on the <code>MyEmployees</code> table that was declared in <a href="ext_idx_frmwork.htm#BHCBEFIG">Example 7-1</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BHAFCECC"></a><a id="ADDCI4439"></a>Example 8-4 Creating a Domain Index</p>
<pre>
CREATE INDEX ResumeTextIndex ON MyEmployees(resume)
INDEXTYPE IS TextIndexType
PARAMETERS (':Language English :Ignore the a an');
</pre></div>
<!-- class="example" -->
<p>The <code>INDEXTYPE</code> clause specifies the indextype to be used. The <code>PARAMETERS</code> clause identifies any parameters for the domain index, specified as a string. This string is passed uninterpreted to the <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> routine for creating the domain index. In the preceding example, the parameters string identifies the language of the text document (thus identifying the lexical analyzer to use) and the list of stop words which are to be ignored while creating the text index.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4440"></a>
<div class="sect3"><a id="sthref348"></a>
<h4 class="sect3">Altering a Domain Index</h4>
<p>A domain index can be <a id="sthref349"></a>altered using the <code><a id="sthref350"></a>ALTER</code> <code>INDEX</code> statement, as shown in<a href="#BHAHFCDB">Example 8-5</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAHFCDB"></a><a id="ADDCI4441"></a>Example 8-5 Changing a Domain Index</p>
<pre>
ALTER INDEX ResumeTextIndex PARAMETERS (':Ignore on');
</pre></div>
<!-- class="example" -->
<p>The parameter string is passed uninterpreted to <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> routine, which takes appropriate actions to alter the domain index. This example specifies an additional stop word to ignore in the text index.</p>
<p>The <code>ALTER</code> statement can be used to rename a domain index, as shown in <a href="#BHAEBCFC">Example 8-6</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAEBCFC"></a><a id="ADDCI4442"></a>Example 8-6 Renaming a Domain Index</p>
<pre>
ALTER INDEX ResumeTextIndex RENAME TO ResumeTIdx;
</pre></div>
<!-- class="example" -->
<p>A statement of this form causes Oracle to invoke the <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> method, which takes appropriate actions to rename the domain index.</p>
<p>In addition, the <code>ALTER</code> statement can be used to rebuild a domain index, as shown in <a href="#BHAEEHBB">Example 8-7</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAEEHBB"></a><a id="ADDCI4443"></a>Example 8-7 Rebuilding a Domain Index</p>
<pre>
ALTER INDEX ResumeTextIndex REBUILD PARAMETERS (':Ignore off');
</pre></div>
<!-- class="example" -->
<p>The same <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> routine is called as before, but with additional information about the <code>ALTER</code> option.</p>
<p>When the end user executes an <code>ALTER INDEX</code> <span class="italic">domain_index</span> <code>UPDATE BLOCK REFERENCES</code> for a domain index on an index-organized table (IOT), <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> is called with the <code>AlterIndexUpdBlockRefs</code> bit set. This gives you the opportunity to update guesses as to the block locations of rows that are stored in the domain index in logical rowids.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4444"></a>
<div class="sect3"><a id="sthref351"></a>
<h4 class="sect3">Truncating a Domain Index</h4>
<p>There is no explicit statement for truncating a domain index. However, when the corresponding base table is truncated, the underlying storage table for the domain indexes are also truncated. Additionally, <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> is invoked by the command in <a href="#BHAGEEBA">Example 8-8</a>, and it truncates <code>ResumeTextIndex</code> because its <code>alter_option</code> is set to <code>AlterIndexRebuild</code>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAGEEBA"></a><a id="ADDCI4445"></a>Example 8-8 Truncating a Domain Index</p>
<pre>
TRUNCATE TABLE MyEmployees;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4446"></a>
<div class="sect3"><a id="sthref352"></a>
<h4 class="sect3">Dropping a Domain Index</h4>
<p>To drop an instance of a domain index, use the <code>DROP</code> <code>INDEX</code> statement, shown in <a href="#BHAFBGDD">Example 8-9</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAFBGDD"></a><a id="ADDCI4447"></a>Example 8-9 Dropping a Domain Index</p>
<pre>
DROP INDEX ResumeTextIndex;
</pre></div>
<!-- class="example" -->
<p>This results in Oracle calling the <a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a> method, passing it information about the index.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4448"></a>
<div class="sect2"><a id="sthref353"></a>
<h3 class="sect2">Domain Indexes on Index-Organized Tables</h3>
<p>This section discusses some issues you must consider if your indextype creates domain indexes on index-organized tables. You can use the <code>IndexOnIOT</code> bit of <code>IndexInfoFlags</code> in the <code>ODCIIndexInfo</code> structure to determine if the base table is an IOT.</p>
<a id="ADDCI4449"></a>
<div class="sect3"><a id="sthref354"></a>
<h4 class="sect3">Storing Rowids in a UROWID Column</h4>
<p>When the base table of a domain index is an index-organized table, and you want to store rowids for the base table in a table of your own, you should store the rowids in a <code>UROWID</code> (universal rowid) column if you are testing rowids for equality.</p>
<p>If the rowids are stored in a <code>VARCHAR</code> column instead, comparisons for textual equality of a rowid from the base table and a rowid from your own table fail in some cases where the rowids pick out the same row. This is because index-organized tables use logical instead of physical rowids, and, unlike physical rowids, logical rowids for the same row can have different textual representations. Two logical rowids are equivalent when they have the same primary key, regardless of the guess data block addresses stored with them.</p>
<p>A <code>UROWID</code> column can contain both physical and logical rowids. Storing rowids for an IOT in a <code>UROWID</code> column ensures that the equality operator succeeds on two logical rowids that have the same primary key information but different guess DBAs.</p>
<p>If you create an index storage table with a rowid column by performing a <code>CREATE TABLE AS SELECT</code> from the IOT base table, then a <code>UROWID</code> column of the correct size is created for you in your index table. If you create a table with a rowid column, then you must explicitly declare your rowid column to be of type <code>UROWID(x)</code>, where <code>x</code> is the size of the <code>UROWID</code> column. The size chosen should be large enough to hold any rowid from the base table; thus, it should be a function of the primary key from the base table. Use the query demonstrated by <a href="#BHADEBHA">Example 8-10</a> to determine a suitable size for the <code>UROWID</code> column.</p>
<div class="example">
<p class="titleinexample"><a id="BHADEBHA"></a><a id="ADDCI4450"></a>Example 8-10 Getting the Size of a UROWID Column</p>
<pre>
SELECT (SUM(column_length + 3) + 7) 
FROM user_ind_columns ic, user_indexes i 
WHERE ic.index_name = i.index_name 
AND i.index_type = 'IOT - TOP'
AND ic.table_ name = <span class="italic">base_table</span>;
</pre></div>
<!-- class="example" -->
<p>Doing an <code>ALTER INDEX REBUILD</code> on index storage tables raises the same issues as doing a <code>CREATE TABLE</code> if you drop your storage tables and re-create them. If, on the other hand, you reuse your storage tables, no additional work should be necessary if your base table is an IOT.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4451"></a>
<div class="sect3"><a id="sthref355"></a>
<h4 class="sect3">DML on Index Storage Tables</h4>
<p>If you maintain a <code>UROWID</code> column in the index storage table, then you must change the type of the rowid bind variable in DML <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements so that it works for all kinds of rowids. Converting the rowid argument passed in to a text string and then binding it as a text string works well for both physical and universal rowids. This strategy may help you to code your indextype to work with both regular tables and IOTs.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4452"></a>
<div class="sect3"><a id="sthref356"></a>
<h4 class="sect3">Start, Fetch, and Close Operations on Index Storage Tables</h4>
<p>If you use an index scan-context structure to pass context between <code>Start</code>, <code>Fetch</code>, and <code>Close</code>, you must alter this structure. In particular, if you store the rowid define variable for the query in a buffer in this structure, then you must allocate the maximum size for a <code>UROWID</code> in this buffer (3800 bytes for universal rowids in byte format, 5072 for universal rowids in character format) unless you know the size of the primary key of the base table in advance or wish to determine it at run time. You also must store a bit in the context to indicate if the base table is an IOT, since <code>ODCIIndexInfo</code> is not available in <code>Fetch</code>.</p>
<p>As with DML operations, setting up the define variable as a text string works well for both physical and universal rowids. When physical rowids are fetched from the index table, you can be sure that their length is 18 characters. Universal rowids, however, may be up to 5072 characters long, so a string length function must be used to determine the actual length of a fetched universal rowid.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4453"></a>
<div class="sect3"><a id="sthref357"></a>
<h4 class="sect3">Indexes on Non-Unique Columns</h4>
<p>All values of a primary key column must be unique, so a domain index defined upon a non-unique column of a table cannot use this column as the primary key of an underlying IOT used to store the index. To work around this, you can add a column in the IOT, holding the index data, to hold a unique sequence number. When a column value is inserted in the table, generate a unique sequence number to go with it; you can then use the indexed column with the sequence number as the primary key of the IOT. (Note that the sequence-number column cannot be a <code>UROWID</code> because <code>UROWID</code> columns cannot be part of a primary key for an IOT.) This approach also preserves the fast access to primary key column values that is a major benefit of IOTs.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4454"></a>
<div class="sect2"><a id="sthref358"></a>
<h3 class="sect2">Domain Index Metadata</h3>
<p>For B-tree indexes, users can query the <code>USER_INDEXES</code> view to get index information. To provide similar support for domain indexes, you can provide domain-specific metadata in the following manner:</p>
<ul>
<li>
<p>Define one or more tables that contain this meta information. The key column of this table must be a unique identifier for the index. This unique key could be the index name (<code>schema.index</code>). The remainder of the columns can contain your metadata.</p>
</li>
<li>
<p>Create views that join the system-defined metadata tables with the index meta tables to provide a comprehensive set of information for each instance of a domain index. It is your responsibility as the indextype designer to provide the view definitions.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="ADDCI4455"></a>
<div class="sect2"><a id="sthref359"></a>
<h3 class="sect2">Moving Domain Indexes Using Export/Import</h3>
<p>Like B-tree and bitmap indexes, domain indexes are <a id="sthref360"></a>exported and subsequently imported when their base tables are exported. However, domain indexes can have implementation-specific metadata associated with them that is not stored in the system catalogs. For example, a text domain index can have associated policy information, a list of irrelevant words, and so on. The export/import mechanism moves this metadata from the source platform to the target platform.</p>
<p>To move the domain index metadata, the indextype must implement the <a href="ext_idx_ref.htm#i76838">ODCIIndexGetMetadata()</a> interface method. When a domain index is being exported, this method is invoked and passes the domain index information. It can return any number of anonymous PL/SQL blocks that are written into the dump file and executed on import. If present, these anonymous PL/SQL blocks are executed immediately before the creation of the associated domain index.</p>
<p>By default, secondary objects of the domain are not imported or exported. However, if the interfaces <a href="ext_idx_ref.htm#CHDGJAGF">ODCIIndexUtilGetTableNames()</a> and <a href="ext_idx_ref.htm#CHDBJBBB">ODCIIndexUtilCleanup()</a> are present, the system invokes them to determine if the secondary objects associated with the domain indexes are part of the export/import operation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL" href="../../server.112/e22490/toc.htm"><span class="italic">Oracle Database Utilities</span></a> for information about using Export/Import</div>
</div>
<!-- class="sect2" -->
<a id="ADDCI4456"></a>
<div class="sect2"><a id="sthref361"></a>
<h3 class="sect2">Moving Domain Indexes Using Transportable Tablespaces</h3>
<p>The <span class="bold">transportable tablespaces</span> feature lets you <a id="sthref362"></a>move tablespaces from one Oracle database into another. You can use transportable tablespaces to move domain index data as an alternative to exporting and importing it.</p>
<p>Moving data using transportable tablespaces can be much faster than performing either an export and import, or unload and load of the data because transporting a tablespace only requires copying datafiles and integrating tablespace structural information. Also, you do not have to rebuild the index afterward as you do when loading or importing. You can check for the presence of the <code>TransTblspc</code> flag in <code>ODCIIndexInfo</code> to determine whether the <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> call is the result of an imported domain index.</p>
<p>To use transportable tablespace for the secondary tables of a domain index, you must provide two additional ODCI interfaces, <a href="ext_idx_ref.htm#CHDGJAGF">ODCIIndexUtilGetTableNames()</a> and <a href="ext_idx_ref.htm#CHDBJBBB">ODCIIndexUtilCleanup()</a>, in the implementation type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../../server.112/e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about using transportable tablespaces</div>
</div>
<!-- class="sect2" -->
<a id="ADDCI4457"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref363"></a>
<h3 class="sect2">Domain Index Views</h3>
<p>Additionally, the following views provide information about secondary objects associated with domain indexes accessible to the user; they are only relevant for domain indexes.</p>
<ul>
<li>
<p><code><a id="sthref364"></a><a id="sthref365"></a>ALL_SECONDARY_OBJECTS</code> provide information about secondary objects associated with domain indexes accessible to the user.</p>
</li>
<li>
<p><a id="sthref366"></a><a id="sthref367"></a><code>DBA_SECONDARY_OBJECTS</code> provides information about all secondary objects that are associated with domain indexes in the database.</p>
</li>
<li>
<p><code><a id="sthref368"></a><a id="sthref369"></a>USER_SECONDARY_OBJECTS</code> provides information about secondary objects associated with domain indexes owned by the current user.</p>
</li>
</ul>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4458"></a><a id="sthref370"></a><a id="sthref371"></a>Table 8-2 Views ALL_SECONDARY_OBJECTS, DBA_SECONDARY_OBJECTS, and USER_SECONDARY_OBJECTS</p>
<table class="cellalignment1246" title="Views ALL_SECONDARY_OBJECTS, DBA_SECONDARY_OBJECTS, and USER_SECONDARY_OBJECTS" summary="Column 1 lists the view column; column 2 shows the datatype used; column 3 indicates if a value is required, and column 4 gives the description" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t11">Column</th>
<th class="cellalignment1247" id="r1c2-t11">Data Type</th>
<th class="cellalignment1247" id="r1c3-t11">Required</th>
<th class="cellalignment1247" id="r1c4-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t11" headers="r1c1-t11">
<pre>
INDEX_OWNER
</pre></td>
<td class="cellalignment1243" headers="r2c1-t11 r1c2-t11">
<pre>
VARCHAR2(30)
</pre></td>
<td class="cellalignment1243" headers="r2c1-t11 r1c3-t11">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r2c1-t11 r1c4-t11">
<p>Name of the domain index owner</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t11" headers="r1c1-t11">
<pre>
INDEX_NAME
</pre></td>
<td class="cellalignment1243" headers="r3c1-t11 r1c2-t11">
<pre>
VARCHAR2(30)
</pre></td>
<td class="cellalignment1243" headers="r3c1-t11 r1c3-t11">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r3c1-t11 r1c4-t11">
<p>Name of the domain index</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t11" headers="r1c1-t11">
<pre>
SECONDARY_INDEX_OWNER
</pre></td>
<td class="cellalignment1243" headers="r4c1-t11 r1c2-t11">
<pre>
VARCHAR2(30)
</pre></td>
<td class="cellalignment1243" headers="r4c1-t11 r1c3-t11">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r4c1-t11 r1c4-t11">
<p>Owner of the secondary object created by the domain index</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t11" headers="r1c1-t11">
<pre>
SECONDARY_INDEX_NAME
</pre></td>
<td class="cellalignment1243" headers="r5c1-t11 r1c2-t11">
<pre>
VARCHAR2(30)
</pre></td>
<td class="cellalignment1243" headers="r5c1-t11 r1c3-t11">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r5c1-t11 r1c4-t11">
<p>Name of the secondary object created by the domain index</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t11" headers="r1c1-t11">
<pre>
SECONDARY_OBJDATA_TYPE
</pre></td>
<td class="cellalignment1243" headers="r6c1-t11 r1c2-t11">
<pre>
VARCHAR2(20)
</pre></td>
<td class="cellalignment1243" headers="r6c1-t11 r1c3-t11">
<pre>
NOT NULL
</pre></td>
<td class="cellalignment1243" headers="r6c1-t11 r1c4-t11">
<p>Specifies if a secondary object is created by either indextype or statistics type</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#BHAEIECJ">Example 8-11</a> demonstrates how the <code>USER_SECONDARY_OBJECTS</code> view may be used to obtain information on the <code>ResumeTextIndex</code> that was created in <a href="#BHAFCECC">Example 8-4</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BHAEIECJ"></a><a id="ADDCI4459"></a>Example 8-11 Using *_SECONDARY_OBJECTS Views</p>
<pre>
SELECT SECONDARY_OBJECT_OWNER, SECONDARY_OBJECT_NAME 
  FROM USER_SECONDARY_OBJECTS 
  WHERE INDEX_OWNER = USER and INDEX_NAME = 'ResumeTextIndex' 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEHABI"></a><a id="ADDCI4460"></a>
<div class="sect1">
<h2 class="sect1">Object Dependencies, Drop Semantics, and Validation</h2>
<p>This section discusses issues that affect objects used in domain indexes.</p>
<a id="ADDCI4461"></a>
<div class="sect2"><a id="sthref372"></a>
<h3 class="sect2">Object Dependencies</h3>
<p>The dependencies among various objects are as follows:</p>
<ul>
<li>
<p><span class="bold">Functions, Packages, and Object Types:</span> referenced by operators and indextypes</p>
</li>
<li>
<p><span class="bold">Operators:</span> referenced by indextypes, DML, and query SQL Statements</p>
</li>
<li>
<p><span class="bold">Indextypes:</span> referenced by domain indexes</p>
</li>
<li>
<p><span class="bold">Domain Indexes:</span> referenced (used implicitly) by DML and query SQL statements</p>
</li>
</ul>
<p>Thus, the order in which these objects must be created, or their definitions exported for future import, is:</p>
<ol>
<li>
<p>Functions, packages, and object types</p>
</li>
<li>
<p>Operators</p>
</li>
<li>
<p>Indextypes</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="ADDCI4462"></a>
<div class="sect2"><a id="sthref373"></a>
<h3 class="sect2">Object Drop Semantics</h3>
<p>The drop behavior for an object is as follows:</p>
<ul>
<li>
<p><code><span class="codeinlinebold">RESTRICT</span></code> <span class="bold">semantics:</span> if there are any dependent objects the drop operation is disallowed.</p>
</li>
<li>
<p><code><span class="codeinlinebold">FORCE</span></code> <span class="bold">semantics:</span> the object is dropped even in the presence of dependent objects; any dependent objects are recursively marked invalid.</p>
</li>
</ul>
<p><a href="#BABGBEBF">Table 8-3</a> shows the default and explicit drop options supported for operators and indextypes. The other schema objects are included for completeness and context.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4463"></a><a id="sthref374"></a><a id="BABGBEBF"></a>Table 8-3 Default and Explicit Drop Options for Operators and Index Types</p>
<table class="cellalignment1246" title="Default and Explicit Drop Options for Operators and Index Types" summary="Schema Object, Default Drop Behavior, and Supported Explicit Options" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t12">Schema Object</th>
<th class="cellalignment1247" id="r1c2-t12">Default Drop Behavior</th>
<th class="cellalignment1247" id="r1c3-t12">Explicit Options Supported</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t12" headers="r1c1-t12">
<p>Function</p>
</td>
<td class="cellalignment1243" headers="r2c1-t12 r1c2-t12">
<p><code>FORCE</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t12 r1c3-t12">
<p>None</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t12" headers="r1c1-t12">
<p>Package</p>
</td>
<td class="cellalignment1243" headers="r3c1-t12 r1c2-t12">
<p><code>FORCE</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t12 r1c3-t12">
<p>None</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t12" headers="r1c1-t12">
<p>Object Types</p>
</td>
<td class="cellalignment1243" headers="r4c1-t12 r1c2-t12">
<p><code>RESTRICT</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t12 r1c3-t12">
<p><code>FORCE</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t12" headers="r1c1-t12">
<p>Operator</p>
</td>
<td class="cellalignment1243" headers="r5c1-t12 r1c2-t12">
<p><code>RESTRICT</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t12 r1c3-t12">
<p><code>FORCE</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t12" headers="r1c1-t12">
<p>Indextype</p>
</td>
<td class="cellalignment1243" headers="r6c1-t12 r1c2-t12">
<p><code>RESTRICT</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t12 r1c3-t12">
<p><code>FORCE</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="ADDCI4464"></a>
<div class="sect2"><a id="sthref375"></a>
<h3 class="sect2">Object Validation</h3>
<p>Invalid objects are automatically validated, if possible, the next time they are referenced.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJEJFH"></a><a id="ADDCI4465"></a>
<div class="sect1">
<h2 class="sect1">Indextype, Domain Index, and Operator Privileges</h2>
<ul>
<li>
<p>To create an operator and its bindings, you must have <code>EXECUTE</code> privilege on the function, operator, package, or the type referenced in addition to <code>CREATE</code> <code>OPERATOR</code> or <code>CREATE</code> <code>ANY</code> <code>OPERATOR</code> privilege.</p>
</li>
<li>
<p>To create an indextype, you must have <code>EXECUTE</code> privilege on the type that implements the indextype in addition to <code>CREATE</code> <code>INDEXTYPE</code> or <code>CREATE</code> <code>ANY</code> <code>INDEXTYPE</code> privilege. Also, you must have <code>EXECUTE</code> privileges on the operators that the indextype supports.</p>
</li>
<li>
<p>To alter an indextype in your own schema, you must have <code>CREATE INDEXTYPE</code> system privilege.</p>
</li>
<li>
<p>To alter an indextype or operator in another user's schema, you must have the <code>ALTER ANY INDEXTYPE</code> or <code>ALTER ANY OPERATOR</code> system privilege.</p>
</li>
<li>
<p>To create a domain index, you must have <code>EXECUTE</code> privilege on the indextype in addition to <code>CREATE</code> <code>INDEX</code> or <code>CREATE</code> <code>ANY</code> <code>INDEX</code> privileges.</p>
</li>
<li>
<p>To alter a domain index, you must have <code>EXECUTE</code> privilege on the indextype.</p>
</li>
<li>
<p>To use the operators in queries or DML statements, you must have <code>EXECUTE</code> privilege on the operator and the associated function, package, and indextype.</p>
</li>
<li>
<p>To change the implementation type, you must have <code>EXECUTE</code> privilege on the new implementation type.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1006614"></a><a id="ADDCI4466"></a>
<div class="sect1">
<h2 class="sect1">Partitioned Domain Indexes</h2>
<p>A domain index can be built to have discrete index partitions that correspond to the partitions of a range- or list-partitioned table. Such an index is called a <span class="bold"><a id="ABC1025240"></a>local domain index</span>, as opposed to a <span class="italic">global</span> domain index, which has no index partitions. Local domain index refers to a partitioned index as a whole, not to the partitions that compose a local domain index.</p>
<p>A local domain index is equipartitioned with the underlying table: all keys in a local domain index refer to rows stored in its corresponding table partition; none refer to rows in other partitions.</p>
<p>You provide for using local domain indexes in the indextype, with the <code>CREATE INDEXTYPE</code> statement, as demonstrated in <a href="#BHAECEIJ">Example 8-12</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BHAECEIJ"></a><a id="ADDCI4467"></a>Example 8-12 Using Local Domain Index Methods Within an Indextype</p>
<pre>
CREATE INDEXTYPE TextIndexType
  FOR Contains (VARCHAR2, VARCHAR2)
  USING TextIndexMethods
  WITH LOCAL PARTITION
  WITH SYSTEM MANAGED STORAGE TABLES;
</pre></div>
<!-- class="example" -->
<p>This statement specifies that the implementation type <code>TextIndexMethods</code> is capable of creating and maintaining local domain indexes.</p>
<p>The <code>CREATE INDEX</code> statement creates and partitions the index, as demonstrated by <a href="#BHABAHED">Example 8-13</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BHABAHED"></a><a id="ADDCI4468"></a>Example 8-13 Creating and Partition an Index</p>
<pre>
CREATE INDEX [schema.]index 
  ON [schema.]table [t.alias] (indexed_column)
  INDEXTYPE IS indextype
  [LOCAL [PARTITION [partition [PARAMETERS ('string')]]] [...] ]
  [PARALLEL parallel_degree]
  [PARAMETERS ('string')];
</pre></div>
<!-- class="example" -->
<p>The <code>LOCAL [PARTITION]</code> clause indicates that the index is a local index on a partitioned table. You can specify partition names or allow Oracle to generate them.</p>
<p>The <code>PARALLEL</code> clause specifies that the index partitions are to be created in parallel. The <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> routines, which correspond to index partition create, rebuild, or populate, are called in parallel.</p>
<p>In the <code>PARAMETERS</code> clause, specify the parameter string that is passed uninterpreted to the appropriate ODCI indextype routine. The maximum length of the parameter string is <code>1000</code> characters.</p>
<p>When you specify this clause at the top level of the syntax, the parameters become the default parameters for the index partitions. If you specify this clause as part of the <code>LOCAL [PARTITION]</code> clause, you override any default parameters with parameters for the individual partition. The <code>LOCAL [PARTITION]</code> clause can specify multiple partitions.</p>
<p>When the domain index is created, Oracle invokes the appropriate ODCI routine. If the routine does not return successfully, the domain index is marked <code>FAILED</code>. The only operations supported on an failed domain index are <code>DROP INDEX</code> and (for non-local indexes) <code>REBUILD INDEX</code>. <a href="#BHAIIDIB">Example 8-14</a> creates a local domain index <code>ResumeIndex</code>:</p>
<div class="example">
<p class="titleinexample"><a id="BHAIIDIB"></a><a id="ADDCI4469"></a>Example 8-14 Creating a Local Domain Index</p>
<pre>
CREATE INDEX ResumeIndex ON MyEmployees(Resume)
  INDEXTYPE IS TextIndexType LOCAL;
</pre></div>
<!-- class="example" -->
<a id="ADDCI4470"></a>
<div class="sect2"><a id="sthref376"></a>
<h3 class="sect2">Dropping a Local Domain Index</h3>
<p>A specified index partition cannot be dropped explicitly. To drop a local index partition, you must drop the entire local domain index:</p>
<div class="example">
<p class="titleinexample"><a id="ADDCI4471"></a><a id="sthref377"></a>Example 8-15 Dropping a Local Index Partition</p>
<pre>
DROP INDEX ResumeIndex;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4472"></a>
<div class="sect2"><a id="sthref378"></a>
<h3 class="sect2">Altering a Local Domain Index</h3>
<p>Use the <code>ALTER INDEX</code> statement to perform the following operations on a local domain index:</p>
<ul>
<li>
<p>Rename the top level index.</p>
</li>
<li>
<p>Modify the default parameter string for all the index partitions.</p>
</li>
<li>
<p>Modify the parameter string associated with a specific partition.</p>
</li>
<li>
<p>Rename an index partition.</p>
</li>
<li>
<p>Rebuild an index partition.</p>
</li>
</ul>
<p>The <code>ALTER INDEXTYPE</code> statement lets you change properties and the implementation type of an indextype without having to drop and re-create the indextype, then rebuild all dependent indexes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for complete syntax of the SQL statements mentioned in this section</div>
</div>
<!-- class="sect2" -->
<a id="ADDCI4473"></a>
<div class="sect2"><a id="sthref379"></a>
<h3 class="sect2">Summary of Index States</h3>
<p>Like a domain index, a partition of a local domain index can be in one or more of several states, listed in <a href="#BABHBHHJ">Table 8-4</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4474"></a><a id="sthref380"></a><a id="BABHBHHJ"></a>Table 8-4 Summary of Index States</p>
<table class="cellalignment1246" title="Summary of Index States" summary="Desciption of possible states" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t14">State</th>
<th class="cellalignment1247" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t14" headers="r1c1-t14">
<p><code>IN_PROGRESS</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t14 r1c2-t14">
<p>The index or the index partition is in this state before and during the execution of the <code>ODCIIndex</code> DDL interface routines. The state is generally transitional and temporary. However, if the routine ends prematurely, the index could remain marked <code>IN_PROGRESS</code>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t14" headers="r1c1-t14">
<p><code>FAILED</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t14 r1c2-t14">
<p>If the <code>ODCIIndex</code> interface routine doing DDL operations on the index returns an error, the index or index partition is marked <code>FAILED</code>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t14" headers="r1c1-t14">
<p><code>UNUSABLE</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t14 r1c2-t14">
<p>Same as for regular indexes: An index on a partitioned table is marked <code>UNUSABLE</code> as a result of certain partition maintenance operations. Note that, for partitioned indexes, <code>UNUSABLE</code> is associated only with an index partition, not with the index as a whole.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t14" headers="r1c1-t14">
<p><code>VALID</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t14 r1c2-t14">
<p>An index is marked <code>VALID</code> if an object that the index directly or indirectly depends upon is exists and is valid. This property is associated only with an index, never with an index partition.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t14" headers="r1c1-t14">
<p><code>INVALID</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t14 r1c2-t14">
<p>An index is marked <code>INVALID</code> if an object that the index directly or indirectly depends upon is dropped or invalidated. This property is associated only with an index, never with an index partition.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="ADDCI4475"></a>
<div class="sect2"><a id="sthref381"></a>
<h3 class="sect2">DML Operations with Local Domain Indexes</h3>
<p>DML operations cannot be performed on the underlying table if an index partition of a local domain index is in any of these states: <code>IN_PROGRESS</code>, <code>FAILED</code>, or <code>UNUSABLE</code>. However, if the index is marked <code>UNUSABLE</code>, and <code>SKIP_UNUSABLE_INDEXES = true</code>, then index maintenance is not performed.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4476"></a>
<div class="sect2"><a id="sthref382"></a>
<h3 class="sect2">Table Operations that Affect Indexes</h3>
<p>The tables in this section list operations that can be performed on the underlying table of an index and describe the effect, if any, on the index. <a href="#BHAFHAFH">Table 8-5</a> lists TABLE operations, while <a href="#BABDJCCI">Table 8-6</a> lists <code>ALTER</code> <code>TABLE</code> operations.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4477"></a><a id="sthref383"></a><a id="BHAFHAFH"></a>Table 8-5 Summary of Table Operations</p>
<table class="cellalignment1246" title="Summary of Table Operations" summary="Table operations" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t15">Table Operation</th>
<th class="cellalignment1247" id="r1c2-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t15" headers="r1c1-t15">
<p><code>DROP</code> <code><span class="codeinlineitalic">table</span></code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t15 r1c2-t15">
<p>Drops the table. Drops all the indexes and their corresponding partitions</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t15" headers="r1c1-t15">
<p><code>TRUNCATE</code> <code><span class="codeinlineitalic">table</span></code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t15 r1c2-t15">
<p>Truncates the table. Truncates all the indexes and the index partitions</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4478"></a><a id="sthref384"></a><a id="BABDJCCI"></a>Table 8-6 Summary of ALTER TABLE Operations With Partition Maintenance</p>
<table class="cellalignment1246" title="Summary of ALTER TABLE Operations With Partition Maintenance" summary="Operations" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t16">ALTER TABLE Operation</th>
<th class="cellalignment1247" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t16" headers="r1c1-t16">
<p>Modify Partition Unusable local indexes</p>
</td>
<td class="cellalignment1243" headers="r2c1-t16 r1c2-t16">
<p>Marks the local index partition associated with the table partition as <code>UNUSABLE</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t16" headers="r1c1-t16">
<p>Modify Partition Rebuild Unusable local indexes</p>
</td>
<td class="cellalignment1243" headers="r3c1-t16 r1c2-t16">
<p>Rebuilds the local index partitions that are marked <code>UNUSABLE</code> and are associated with this table partition</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t16" headers="r1c1-t16">
<p>Add Partition</p>
</td>
<td class="cellalignment1243" headers="r4c1-t16 r1c2-t16">
<p>Adds a new table partition. Also adds a new local index partition.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t16" headers="r1c1-t16">
<p>Drop Partition</p>
</td>
<td class="cellalignment1243" headers="r5c1-t16 r1c2-t16">
<p>Drops a base table partition. Also drops the associated local index partition</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t16" headers="r1c1-t16">
<p>Truncate Partition</p>
</td>
<td class="cellalignment1243" headers="r6c1-t16 r1c2-t16">
<p>Truncate the table partition. Also truncates the associated local index partition</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t16" headers="r1c1-t16">
<p>Move Partition</p>
</td>
<td class="cellalignment1243" headers="r7c1-t16 r1c2-t16">
<p>Moves the base table partition to another tablespace. Corresponding local index partitions are marked <code>UNUSABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t16" headers="r1c1-t16">
<p>Split Partition</p>
</td>
<td class="cellalignment1243" headers="r8c1-t16 r1c2-t16">
<p>Splits a table partition into two partitions. Corresponding local index partition is also split. If the resulting partitions are non-empty, the index partitions are marked <code>UNUSABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t16" headers="r1c1-t16">
<p>Merge Partition</p>
</td>
<td class="cellalignment1243" headers="r9c1-t16 r1c2-t16">
<p>Merges two table partitions into one partition. Corresponding local index partitions should also merge. If the resulting partition contains data, the index partition is marked <code>UNUSABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t16" headers="r1c1-t16">
<p>Exchange Partition Excluding Indexes</p>
</td>
<td class="cellalignment1243" headers="r10c1-t16 r1c2-t16">
<p>Exchanges a table partition with a non-partitioned table. Local index partitions and global indexes are marked <code>UNUSABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t16" headers="r1c1-t16">
<p>Exchange Partition Including Indexes</p>
</td>
<td class="cellalignment1243" headers="r11c1-t16 r1c2-t16">
<p>Exchanges a table partition with a non-partitioned table. Local index partition is exchanged with global index on the non-partitioned table. Index partitions remain <code>USABLE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="ADDCI4479"></a>
<div class="sect2"><a id="sthref385"></a>
<h3 class="sect2">ODCIIndex Interfaces for Partitioning Domain Indexes</h3>
<p>To support local domain indexes, you must implement the standard <code>ODCIIndex</code> methods, plus two additional methods that are specific to local domain indexes:</p>
<ul>
<li>
<p><a href="ext_idx_ref.htm#i78919">ODCIIndexExchangePartition()</a></p>
</li>
<li>
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="ADDCI4480"></a>
<div class="sect2"><a id="sthref386"></a>
<h3 class="sect2">Domain Indexes and SQL*Loader</h3>
<p><a id="sthref387"></a>SQL*Loader conventional path loads and direct path loads are supported for tables on which domain indexes are defined, with two limitations:</p>
<ul>
<li>
<p>The table must be heap-organized.</p>
</li>
<li>
<p>The domain index cannot be defined on a <code>LOB</code> column.</p>
</li>
</ul>
<p>To do a direct path load on a domain index defined on an <code>IOT</code> or on a <code>LOB</code> column, perform these tasks:</p>
<ol>
<li>
<p>Drop the domain index</p>
</li>
<li>
<p>Do the direct path load in SQL*Loader.</p>
</li>
<li>
<p>Re-create the domain indexes.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BHACAFIG"></a><a id="ADDCI2801"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using System Partitioning</h2>
<p>System Partitioning enables you to create a single table consisting of multiple physical partitions. System partitioning does not use partitioning keys. Instead, it creates the number of partitions specified. Therefore, the resulting partitions have no bounds (range), values (list), or a partitioning method.</p>
<p>Because there are no partitioning keys, you must explicitly map the distributed table rows to the destination partition. When inserting a row, for example, you must use the partition extended syntax to specify the partition to which a row must be mapped.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Supporting SQL syntax in the <a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
<a id="ADDCI4481"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref388"></a>
<h3 class="sect2">Advantages of System Partitioned Tables</h3>
<p>The main advantages of system-partitioned tables is that it can be used to create and maintain tables that are equipartitioned with respect to another table. For example, this means that a dependent table could be created as a system-partitioned table, with the same number of partitions as the base table. It follows that such a system-partitioned table can be used to store index data for a domain index, with the following implications:</p>
<ul>
<li>
<p>Pruning follows the base table pruning rules: when a partition is accessed in the base table, the corresponding partition can be accessed in the system-partitioned table.</p>
</li>
<li>
<p>DDLs of the base table can be duplicated on the system-partitioned table. Therefore, if a partition is dropped on the base table, the corresponding partition on the system-partitioned table is dropped automatically.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="ADDCI4482"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref389"></a>
<h3 class="sect2">Implementing System Partitioning</h3>
<p>This section describes how to implement system partitioning.</p>
<a id="ADDCI4483"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref390"></a>
<h4 class="sect3">Creating a System-Partitioned Table</h4>
<p><a href="#BHAFECIE">Example 8-16</a> describes how to create a system-partitioned table with four partitions. Each partition can have different physical attributes.</p>
<div class="example">
<p class="titleinexample"><a id="BHAFECIE"></a><a id="ADDCI4484"></a>Example 8-16 Creating a System-Partitioned Table</p>
<pre>
CREATE TABLE SystemPartitionedTable (c1 integer, c2 integer)
PARTITION BY SYSTEM
(
  PARTITION p1 TABLESPACE tbs_1,
  PARTITION p2 TABLESPACE tbs_2,
  PARTITION p3 TABLESPACE tbs_3,
  PARTITION p4 TABLESPACE tbs_4
);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4485"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref391"></a>
<h4 class="sect3">Inserting Data into a System-Partitioned Table</h4>
<p><a href="#BHAGFFGA">Example 8-17</a> demonstrates how to insert data into a system-partitioned table. Both <code>INSERT</code> and <code>MERGE</code> statements (not shown here) must use the partition extended syntax to identify the partition to which the row should be added. The tuple <code>(4,5)</code> could have been inserted into any of the four partitions created in <a href="#BHAFECIE">Example 8-16</a>. <code>DATAOBJ_TO_PARTITION</code> can also be used, as demonstrated by <a href="#BHACBCJE">Example 8-18</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BHAGFFGA"></a><a id="ADDCI4486"></a>Example 8-17 Inserting Data into a System-Partitioned Table</p>
<pre>
INSERT INTO SystemPartitionedTable PARTITION (p1) VALUES (4,5);
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BHACBCJE"></a><a id="ADDCI4487"></a>Example 8-18 Inserting Data into a System-Partitioned Table Using DATAOBJ_TO_PARTITION</p>
<pre>
INSERT INTO SystemPartitionedTable PARTITION 
  (DATAOBJ_TO_PARTITION (<span class="italic">base_table</span>, :<span class="italic">physical_partid</span>))
  VALUES (...);
</pre></div>
<!-- class="example" -->
<p>Note that the first line of code shows how to insert data into a named partition, while the second line of code shows that data can also be inserted into a partition based on the partition's order. The support for bind variables, illustrated on the third code line, is important because it allows cursor sharing between <code>INSERT</code> statements.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4488"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref392"></a>
<h4 class="sect3">Deleting and Updating Data in a System-Partitioned Table</h4>
<p>While delete and update operations do not require the partition extended syntax, Oracle recommends that you use it if at all possible. Because there is no partition pruning, the entire table is scanned to execute the operation if the partition-extended syntax is omitted. This highlights the fact that there is no implicit mapping between the rows and the partitions.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4489"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref393"></a>
<h3 class="sect2">Supporting Operations with System-Partitioned Tables</h3>
<p>The following operations continue to be supported by system partitioning:</p>
<ul>
<li>
<p>Partition maintenance operations and other DDLs, with the exception of:</p>
<ul>
<li>
<p><code>ALTER INDEX SPLIT PARTITION</code></p>
</li>
<li>
<p><code>ALTER TABLE SPLIT PARTITION</code></p>
</li>
<li>
<p><code>CREATE TABLE</code> (as <code>SELECT</code>)</p>
</li>
</ul>
</li>
<li>
<p>Creation of local indexes, with the exception of unique local indexes because they require a partitioning key</p>
</li>
<li>
<p>Creation of local bitmapped indexes</p>
</li>
<li>
<p>Creation of global indexes</p>
</li>
<li>
<p>All DML operations</p>
</li>
<li>
<p><code>INSERT AS SELECT</code> operations with partition extended syntax, as shown in <a href="#BHABACEB">Example 8-19</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHABACEB"></a><a id="ADDCI4490"></a>Example 8-19 Inserting Data into a Particular Partition of a Table</p>
<pre>
INSERT INTO <span class="italic">TableName</span> 
  PARTITION (
    <span class="italic">PartitionName</span>|
    DATAOBJ_TO_PARTITION(<span class="italic">base_table</span>, :<span class="italic">physical_partid</span>))
  AS <span class="italic">SubQuery</span>
</pre></div>
<!-- class="example" --></li>
</ul>
<p>The following operations are no longer supported by system partitioning because system partitioning does not use a partitioning method, and therefore does not distribute rows to partitions.</p>
<ul>
<li>
<p><code>CREATE TABLE AS SELECT</code> An alternative approach is to first create the table, and then insert rows into each partition.</p>
</li>
<li>
<p><code>INSERT INTO</code> <code><span class="codeinlineitalic">TableName</span></code> <code>AS</code> <code><span class="codeinlineitalic">SubQuery</span></code></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BHADEDAG"></a><a id="ADDCI4491"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Running Partition Maintenance Operations</h3>
<p>As an example, this section discusses an <code>ALTER TABLE SPLIT PARTITION</code> routine issued for the base table of a domain index.</p>
<ol>
<li>
<p>The system invokes the <a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a> method using the information about the partition being added or dropped; remember that a 1:2 split involves dropping of one partition and adding two new partitions.</p>
</li>
<li>
<p>The system invokes the <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> on the affected partitions.</p>
</li>
<li>
<p>The system drops the partition that has been split from all system-partition index and statistics storage tables.</p>
</li>
<li>
<p>The system adds two new partitions to the system-partitioned tables.</p>
</li>
<li>
<p>If the partition that is being split is empty, then one call to <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> rebuilds the split partition, and a second call to <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> rebuilds the newly added partition.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BHAECACJ"></a><a id="ADDCI4492"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Altering Table Exchange Partitions with Indexes</h3>
<p>The <code>ALTER TABLE EXCHANGE PARTITION</code> command is allowed for tables with domain indexes only under the following circumstances:</p>
<ul>
<li>
<p>a domain index is defined on both the non-partitioned table, and the partitioned table</p>
</li>
<li>
<p>both the non-partitioned table and the partitioned table have the same associated indextype</p>
</li>
</ul>
<p>The <code>ALTER TABLE EXCHANGE PARTITION</code> routine invokse the following user-implemented methods:</p>
<ol>
<li>
<p><a href="ext_idx_ref.htm#i78919">ODCIIndexExchangePartition()</a> for the affected partition and index</p>
</li>
<li>
<p><a href="ext_opt_ref.htm#CHEDHDAJ">ODCIStatsExchangePartition()</a> for the affected partition and index if statistics are collected for them</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BHAFCACE"></a><a id="ADDCI4493"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using System-Managed Domain Indexes</h2>
<p>This section describes how system-managed domain indexes work, how to collect and store statistics for them, and lists restrictions for use.</p>
<p>Let us examine how system-managed domain indexes work.</p>
<p><a href="#BHABCBAB">Figure 8-1</a> illustrates the initial setup of a base table <code>T1</code>. <code>T1</code> has the following elements:</p>
<ul>
<li>
<p>three partitions</p>
</li>
<li>
<p>a local domain index on one of its columns, <code>IT1</code></p>
</li>
<li>
<p>a table of corresponding metadata objects, <code>MT1</code>, which is the optional metadata table created by the indextype to store information specific to each partition of the local domain index</p>
</li>
<li>
<p>a system-partitioned table, <code>SPT1</code>, created by the indextype to store index data</p>
</li>
</ul>
<p>The structures shown in these tables (table <code>T1</code>, index <code>IT1</code> and the system partitioned table <code>SPT1</code>) have the same number of partitions, in a one-to-one relationship. The metadata table <code>MT1</code> has as many rows as the number of partitions in these tables.</p>
<div class="figure">
<p class="titleinfigure"><a id="BHABCBAB"></a><a id="ADDCI4494"></a>Figure 8-1 Three-Partition Table with a Local Domain Index, and Associated Structures</p>
<img width="488" height="452" src="img/addci047.gif" alt="Description of Figure 8-1 follows" title="Description of Figure 8-1 follows" /><br />
<a id="sthref394" href="img_text/addci047.htm">Description of "Figure 8-1 Three-Partition Table with a Local Domain Index, and Associated Structures"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BHAHBFAI">Figure 8-2</a> illustrates what happens to T1 and its related structures after splitting one of its partitions with the operation in <a href="#BHABABIF">Example 8-20</a>:</p>
<div class="example">
<p class="titleinexample"><a id="BHABABIF"></a><a id="ADDCI4495"></a>Example 8-20 Splitting an Existing Table Partition</p>
<pre>
ALTER TABLE T1 SPLIT PARTITION P2 INTO P21, P22
</pre></div>
<!-- class="example" -->
<ul>
<li>
<p>the partition <code>P2</code> in the base table <code>T1</code> splits into <code>P21</code> and <code>P22</code></p>
</li>
<li>
<p>in the local domain index, partition <code>IP2</code> is dropped and two new partitions, <code>IP21</code> and <code>IP22</code>, are created</p>
</li>
<li>
<p>the indextype invokes the <a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a> method that makes the necessary updates to the metadata table <code>MT1</code></p>
</li>
<li>
<p>in the system partitioned table <code>SPT1</code>, the partition that corresponds to partition <code>IP2</code> is dropped and two new partitions are created</p>
</li>
<li>
<p>index partitions are marked <code>UNUSABLE</code> as a result of the split operation; they must be rebuilt to make them <code>USABLE</code></p>
</li>
</ul>
<div class="figure">
<p class="titleinfigure"><a id="BHAHBFAI"></a><a id="ADDCI4496"></a>Figure 8-2 A Three-Partition Table after ALTER TABLE SPLIT PARTITION</p>
<img width="480" height="518" src="img/addci048.gif" alt="Description of Figure 8-2 follows" title="Description of Figure 8-2 follows" /><br />
<a id="sthref395" href="img_text/addci048.htm">Description of "Figure 8-2 A Three-Partition Table after ALTER TABLE SPLIT PARTITION "</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="BHADBEIH"></a><a id="ADDCI4497"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Designing System-Managed Domain Indexes</h2>
<p>When a top-level DDL that affects a non-partitioned domain index is called, the system invokes user-implemented <code>ODCIIndex</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>ODCIStats</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods. <a href="#BHACDBCG">Table 8-7</a> shows these methods.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4498"></a><a id="sthref396"></a><a id="BHACDBCG"></a>Table 8-7 ODCI<span class="italic">XXX</span>() Methods for Non-Partitioned Domain Indexes</p>
<table class="cellalignment1246" title="ODCIXXX() Methods for Non-Partitioned Domain Indexes" summary="Mapping between DDLs and various ODCI methods used for non-partitioned domain indexes" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t18">DDL</th>
<th class="cellalignment1247" id="r1c2-t18">ODCI<span class="italic">XXX</span>() Method Used in System-Managed Approach</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t18" headers="r1c1-t18">
<pre>
CREATE INDEXTYPE
</pre></td>
<td class="cellalignment1243" headers="r2c1-t18 r1c2-t18">
<p>Specify the system-managed approach</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t18" headers="r1c1-t18">
<pre>
CREATE INDEX
</pre></td>
<td class="cellalignment1243" headers="r3c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t18" headers="r1c1-t18">
<pre>
TRUNCATE TABLE
</pre></td>
<td class="cellalignment1243" headers="r4c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a>,</p>
<p>with the <code>alter_option=</code><code>AlterIndexRebuild</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t18" headers="r1c1-t18">
<pre>
ALTER INDEX
</pre></td>
<td class="cellalignment1243" headers="r5c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t18" headers="r1c1-t18">
<pre>
GATHER_INDEX_STATS()
</pre>
<p>in <code>DBMS_STATS</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t18 r1c2-t18">
<p><a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t18" headers="r1c1-t18">
<pre>
DELETE_INDEX_STATS()
</pre>
<p>in <code>DBMS_STATS</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t18 r1c2-t18">
<p><a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t18" headers="r1c1-t18">
<pre>
DROP INDEX
</pre>
<p>(Force)</p>
</td>
<td class="cellalignment1243" headers="r8c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a> and <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t18" headers="r1c1-t18">
<pre>
INSERT
</pre></td>
<td class="cellalignment1243" headers="r9c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t18" headers="r1c1-t18">
<pre>
DELETE
</pre></td>
<td class="cellalignment1243" headers="r10c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t18" headers="r1c1-t18">
<pre>
UPDATE
</pre></td>
<td class="cellalignment1243" headers="r11c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r12c1-t18" headers="r1c1-t18">
<pre>
QUERY
</pre></td>
<td class="cellalignment1243" headers="r12c1-t18 r1c2-t18">
<p><a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a>, <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> and <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>When a top-level DDL that affects a local system managed domain index is called, the system invokes user-implemented <code>ODCIIndex</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>ODCIStats</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods. <a href="#BHAIGBIH">Table 8-8</a> shows these methods. In summary, the following rules apply:</p>
<ul>
<li>
<p>For <code>ODCIIndex</code><code><span class="codeinlineitalic">XXX</span></code> <code>()</code> DMLs and queries, both the index partition object identifier (<code>ODCIIndexInfo.IndexPartitionIden</code>) and a base table partition physical identifier (<code>ODIIndexInfo.IndexCols(1).TablePartitionIden</code>) are required. For <code>ODCIIndex</code><code><span class="codeinlineitalic">XXX</span></code> <code>()</code> DDL routines, both the index partition object identifier and the index partition name are supplied.</p>
</li>
<li>
<p>The <code>CREATE INDEX</code> routine uses two calls to <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> (one at the beginning and one at the end), and as many calls to <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> with <code>alter_option=</code><code>AlterIndexRebuild</code> as there are partitions.</p>
</li>
<li>
<p>The <code>TRUNCATE TABLE</code> routine uses as many calls to <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> with <code>alter_option=</code><code>AlterIndexRebuild</code> as there are partitions.</p>
</li>
<li>
<p>All partition maintenance operations invoke <a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a> so that the indextype correctly updates its partition metadata table. The list of index partitions is specified by the index partition name and the index partition object identifier, and is supplied with information regarding addition or dropping of the partition. No DDLs are allowed in these calls.With each partition maintenance operation, the system implicitly transforms the system-partitioned storage tables that were created using domain indexes. The names of the newly generated partitions correspond to the index partition names.</p>
</li>
<li>
<p>If the system-partitioned tables are used to store partition-level statistics, then the tables and indexes created by <a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a> and dropped by <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a> are tracked by the system to maintain equipartitioning.</p>
</li>
<li>
<p>If the application implements user-defined partition-level statistics, the system invokes <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> with every partition maintenance operation. This ensure that the statistics type updates its partition-level statistics, and (optionally) its aggregate global statistics. No DDLs are allowed in these calls. If <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> is not implemented, the system does not raise an exception but proceeds to the next programmatic step.</p>
</li>
</ul>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4499"></a><a id="sthref397"></a><a id="BHAIGBIH"></a>Table 8-8 ODCI<span class="italic">XXX</span>() Methods for Local System-Managed Domain Indexes</p>
<table class="cellalignment1246" title="ODCIXXX() Methods for Local System-Managed Domain Indexes" summary="Mapping between DDLs and various ODCI methods used for local system-managed domain indexes" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t19">DDL</th>
<th class="cellalignment1247" id="r1c2-t19">ODCI<span class="italic">XXX</span>() Method Used in System-Managed Approach</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t19" headers="r1c1-t19">
<pre>
CREATE INDEXTYPE
</pre></td>
<td class="cellalignment1243" headers="r2c1-t19 r1c2-t19">
<p>Specify the system-managed approach</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t19" headers="r1c1-t19">
<pre>
CREATE INDEX
</pre></td>
<td class="cellalignment1243" headers="r3c1-t19 r1c2-t19">
<p>One call to <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a>, one <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> call for each partition, with <code>alter_option=</code><code>AlterIndexRebuild</code>, and then a final call to <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t19" headers="r1c1-t19">
<pre>
TRUNCATE TABLE
</pre></td>
<td class="cellalignment1243" headers="r4c1-t19 r1c2-t19">
<p>One call for each partition: <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a>, with <code>alter_option=</code><code>AlterIndexRebuild</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t19" headers="r1c1-t19">
<pre>
ALTER INDEX
</pre></td>
<td class="cellalignment1243" headers="r5c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t19" headers="r1c1-t19">
<pre>
GATHER_INDEX_STATS()
</pre>
<p>in <code>DBMS_STATS</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t19 r1c2-t19">
<p>One call to <a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t19" headers="r1c1-t19">
<pre>
DELETE_INDEX_STATS()
</pre>
<p>in <code>DBMS_STATS</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t19 r1c2-t19">
<p>One call to <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t19" headers="r1c1-t19">
<pre>
DROP INDEX
</pre>
<p>(Force)</p>
</td>
<td class="cellalignment1243" headers="r8c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a>, and if user-defined statistics have been collected then <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE ADD PARTITION
</pre></td>
<td class="cellalignment1243" headers="r9c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a>, <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> with <code>alter_option=</code><code>AlterIndexRebuild</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE DROP PARTITION
</pre></td>
<td class="cellalignment1243" headers="r10c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a>; <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> if statistics are collected</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE TRUNCATE PARTITION
</pre></td>
<td class="cellalignment1243" headers="r11c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a>; <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> with <code>alter_option=</code><code>AlterIndexRebuild</code>; <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> if a statistics type is associated with the indextype and if user-defined statistics have been collected</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r12c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE SPLIT PARTITION
</pre></td>
<td class="cellalignment1243" headers="r12c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a>; <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> with <code>alter_option=</code><code>AlterIndexRebuild</code> only if the result partitions are empty; <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> if a statistics type is associated with the indextype and if user-defined statistics have been collected</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r13c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE MERGE PARTITION
</pre></td>
<td class="cellalignment1243" headers="r13c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a>; <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> with <code>alter_option=</code><code>AlterIndexRebuild</code> only if the result partitions are empty; <a href="ext_opt_ref.htm#CHEGAICB">ODCIStatsUpdPartStatistics()</a> if a statistics type is associated with the indextype and if user-defined statistics have been collected</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r14c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE EXCHANGE PARTITION
</pre></td>
<td class="cellalignment1243" headers="r14c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i78919">ODCIIndexExchangePartition()</a>; if a statistics type is associated with the indextype, and if user-defined statistics have been collected, also <a href="ext_opt_ref.htm#CHEDHDAJ">ODCIStatsExchangePartition()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r15c1-t19" headers="r1c1-t19">
<pre>
ALTER TABLE MOVE PARTITION
</pre></td>
<td class="cellalignment1243" headers="r15c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#CHEDHCCB">ODCIIndexUpdPartMetadata()</a> if a partitioned table has a valid system-managed local domain index that has been updated as part of a partition <code>MOVE</code> and rename operation. If a partition is moved without updating the system-managed indexes, the index partition is marked <code>UNUSABLE</code> .</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r16c1-t19" headers="r1c1-t19">
<pre>
GATHER_TABLE_STATS()
</pre>
<p>in <code>DBMS_STATS</code></p>
</td>
<td class="cellalignment1243" headers="r16c1-t19 r1c2-t19">
<p>One call to <a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r17c1-t19" headers="r1c1-t19">
<pre>
DELETE_TABLE_STATS()
</pre>
<p>in <code>DBMS_STATS</code></p>
</td>
<td class="cellalignment1243" headers="r17c1-t19 r1c2-t19">
<p>One call to <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a>, if a statistics type is associated with the indextype, and if user-defined statistics have been collected</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r18c1-t19" headers="r1c1-t19">
<pre>
ALTER INDEX PARTITION
</pre></td>
<td class="cellalignment1243" headers="r18c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r19c1-t19" headers="r1c1-t19">
<pre>
INSERT
</pre></td>
<td class="cellalignment1243" headers="r19c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r20c1-t19" headers="r1c1-t19">
<pre>
DELETE
</pre></td>
<td class="cellalignment1243" headers="r20c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r21c1-t19" headers="r1c1-t19">
<pre>
UPDATE
</pre></td>
<td class="cellalignment1243" headers="r21c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r22c1-t19" headers="r1c1-t19">
<pre>
QUERY
</pre></td>
<td class="cellalignment1243" headers="r22c1-t19 r1c2-t19">
<p><a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a>, <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> and <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect1" -->
<a id="BHAHHAGF"></a><a id="ADDCI4500"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Creating Local Domain Indexes</h2>
<p>The <code>CREATE INDEX</code> routine implements the following steps:</p>
<ol>
<li>
<p>To create system-partitioned storage tables, the system calls <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> with index information. The number of partitions is supplied in the <code>ODCIIndexInfo.IndexPartitionTotal</code> attribute. Note that all the partitioned storage tables should be system-partitioned.</p>
<p>The object-level <code>CREATE</code> routine passes in only the object-level parameter string. To construct the storage attributes for all partitions, the indextype needs partition-level parameter strings. To obtain these, the cartridge must programmatically query the <code><span class="codeinlineitalic">XXX</span></code><code>_IND_PARTITIONS</code> views on the dictionary tables.</p>
<p>Oracle recommends that the indextype assign names to the storage tables and its partitions using the index partition name. Note that you must also obtain index partition names programmatically, from the <code><span class="codeinlineitalic">XXX</span></code><code>_IND_PARTITIONS</code> views.</p>
</li>
<li>
<p>For each partition, the system calls the <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> method with <code>alter_option=AlterIndexRebuild</code>.</p>
<p>You can verify if this <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> call has been made as part of a <code>CREATE INDEX</code> call by checking whether the <code>ODICEnv.IntermediateCall</code> bit was set.</p>
<p>Programatically select the index column values for each partition from the base table partition, transform them, and store the transformed data in the corresponding system-partitioned table.</p>
<p>During DML or query operations, if the indextype must refer to the metadata table, it should be programmed to insert the index partition object identifier into the corresponding row of the metadata table.</p>
<p>To store values in non-partitioned tables, you can program the cartridge either at the level of the initial <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> call, or at the level of the <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> calls made for each partition.</p>
</li>
<li>
<p>The system makes a final call to the <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> method so that the indextype can create any necessary indexes on the storage tables.</p>
<p>The <code>CREATE</code> routine may use temporary storage tables for intermediate data. As an option, you can programmatically instruct your application to use external files; it is then the application's responsibility to manage these files.</p>
<p>After this <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> call completes, all partitioned tables created and not dropped by this call are managed by the system.</p>
</li>
</ol>
<p>Note that creation of global indexes of any type on a system-partitioned index storage table is flagged as an error.</p>
</div>
<!-- class="sect1" -->
<a id="BHABGABF"></a><a id="ADDCI4501"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Maintaining Local Domain Indexes with INSERT, DELETE, and UPDATE</h2>
<p>DML operations should be implemented in the following manner:</p>
<ol>
<li>
<p>One of <a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a>, <a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a>, or <a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a> is invoked. Both the index partition object identifier (for accessing the metadata table) and the base table partition physical identifier (for performing DMLs in the corresponding partition) are supplied as part of the <code>ODICIndexInfo</code> structure.</p>
</li>
<li>
<p>To implement DMLs on a system-partitioned table, the cartridge code must include the syntax in <a href="#BHACFFFF">Example 8-21</a>. The <code>DATAOBJ_TO_PARTITION()</code> function is provided by the system.</p>
<div class="example">
<p class="titleinexample"><a id="BHACFFFF"></a><a id="ADDCI4502"></a>Example 8-21 Calling DML Operations on System-Partitioned Tables</p>
<pre>
INSERT INTO SP PARTITION
   (DATAOBJ_TO_PARTITION(<span class="italic">base_table</span>, :<span class="italic">physical_partid</span>)) VALUES(...)
</pre></div>
<!-- class="example" --></li>
</ol>
</div>
<!-- class="sect1" -->
<a id="BHAHDGGD"></a><a id="ADDCI4503"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Querying Local Domain Indexes</h2>
<p>Follow these steps to query local domain indexes:</p>
<ol>
<li>
<p>When the optimizer receives a query that has a user-defined operator, if it determines to use a domain index scan for evaluation, <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a>, <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a>, or <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> is invoked.</p>
</li>
<li>
<p>The index partition object identifier and the base table partition physical identifier are passed in as part of <code>ODCIIndexInfo</code> structure.</p>
</li>
<li>
<p>The index partition object identifier can be used to look up the metadata table, if necessary.</p>
</li>
<li>
<p>And the base table physical partition identifier can be used to query the corresponding partition of the system partitioned table.</p>
</li>
<li>
<p>The cartridge code must use the syntax in <a href="#BHAGJDAG">Example 8-22</a> and the provided function <code>DATAOBJ_TO_PARTITION()</code>, for querying the system partitioned table.</p>
<div class="example">
<p class="titleinexample"><a id="BHAGJDAG"></a><a id="ADDCI4504"></a>Example 8-22 Querying a System-Partitioned Table</p>
<pre>
SELECT FROM SP PARTITION
   (DATAOBJ_TO_PARTITION(<span class="italic">base_table</span>, <span class="italic">:physical_partid</span>)) WHERE &lt;..&gt;;
</pre></div>
<!-- class="example" --></li>
</ol>
</div>
<!-- class="sect1" -->
<a id="BHAECDGJ"></a><a id="ADDCI4505"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Restrictions of System-Managed Domain Indexing</h2>
<p>The system-managed domain indexing approach supports the following structures:</p>
<ul>
<li>
<p>Non-partitioned system managed domain indexes</p>
</li>
<li>
<p>Local system managed domain indexes on range- and list-partitioned tables</p>
</li>
<li>
<p>Local domain indexes can be created only for range- and list-partitioned heap-organized tables. Local domain indexes cannot be built for hash-partitioned, ref-partitioned, or interval-partitioned tables or <code>IOT</code>s.</p>
</li>
<li>
<p>A system-managed domain index can index only a single column.</p>
</li>
<li>
<p>You cannot specify a bitmap or unique domain index</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BGBHGBJF"></a><a id="ADDCI4506"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Migrating Non-Partitioned Indexes</h2>
<p>The following steps show how to migrate non-partitioned user-managed domain indexes into system-managed domain indexes.</p>
<ol>
<li>
<p>Modify metadata: issue an <code>ALTER INDEXTYPE</code> command to register the property of the indextype with the system. This disassociates the statistics type.</p>
</li>
<li>
<p>The index is marked as <code>INVALID</code>. You must implicitly issue an <code>ALTER INDEX ... COMPILE</code> command to validate the index again. This calls the <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> method with <code>alter_option=AlterIndexMigrate</code>.</p>
</li>
<li>
<p>Issue an <code>ASSOCIATE STATISTICS</code> command to associate a system-managed statistics type with the system-managed indextype.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="BGBJBCDA"></a><a id="ADDCI4507"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Migrating Local Partitioned Indexes</h2>
<p>The following steps show how to migrate local partitioned user-managed domain indexes into system-managed equi-partitioned domain indexes.</p>
<ol>
<li>
<p>Modify metadata: issue an <code>ALTER INDEXTYPE</code> command to register the new index routines and the property of the indextype so it can be managed by the system. All indexes of this indextype are marked <code>INVALID</code>, and cannot be used until after the completion of the next step. This disassociates the statistics type and erases the old statistics.</p>
</li>
<li>
<p>Modify index data: invoke the <code>ALTER INDEX ... COMPILE</code> command for the new indextype of each index. This calls the <a href="ext_idx_ref.htm#i76608">ODCIIndexAlter()</a> method with <code>alter_option=AlterIndexMigrate</code>. You must implement this method to transform groups on non-partitioned tables into system-partitioned tables. For each set of <code><span class="codeinlineitalic">n</span></code> tables that represent a partitioned table, the cartridge code should perform the following actions. Note that the migration does not require re-generation of index data, but involves only exchange operations.</p>
<ul>
<li>
<p>Create a system-partitioned table.</p>
</li>
<li>
<p>For each of the <code><span class="codeinlineitalic">n</span></code> non-partitioned tables, call the <code>ALTER TABLE EXCHANGE PARTITION [INCLUDING INDEXES]</code> routine to exchange a non-partitioned table for a partition of the system-partitioned table.</p>
</li>
<li>
<p>Drop all <code><span class="codeinlineitalic">n</span></code> non-partitioned tables.</p>
</li>
</ul>
</li>
<li>
<p>Issue an <code>ASSOCIATE STATISTICS</code> command to associate a system-managed statistics type with the system-managed indextype.</p>
</li>
</ol>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1236">
<tr>
<td class="cellalignment1243">
<table class="cellalignment1241">
<tr>
<td class="cellalignment1240"><a href="ext_idx_frmwork.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1240"><a href="operators.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1245">
<table class="cellalignment1239">
<tr>
<td class="cellalignment1240"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1240"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1240"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1240"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1240"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1240"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
