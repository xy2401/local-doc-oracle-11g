<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Extensible Indexing Interface</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2010-03-08T13:16:29Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Cartridge Developer's Guide" />
<meta name="dcterms.identifier" content="E10765-02" />
<meta name="dcterms.isVersionOf" content="ADDCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ext_types_ref.htm" title="Previous" type="text/html" />
<link rel="Next" href="ext_opt_ref.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10765.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">31/36</span> <!-- End Header --><a id="CHECIBFB"></a><a id="ADDCI4200"></a>
<h1 class="chapter"><span class="secnum">20</span> Extensible Indexing Interface</h1>
<p>This chapter describes Oracle Data Cartridge Interface extensible indexing interfaces. This chapter contains this topic:</p>
<ul>
<li>
<p><a href="#CHEFCJCA">Extensible Indexing - System-Defined Interface Routines</a></p>
</li>
</ul>
<a id="CHEFCJCA"></a><a id="ADDCI5023"></a>
<div class="sect1">
<h2 class="sect1">Extensible Indexing - System-Defined Interface Routines</h2>
<p><a href="#CHECCCID">Table 20-1</a> summarizes the extensible indexing routines.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Caution</span>:</p>
These routines are invoked by Oracle at the appropriate times based on SQL statements executed by the end user. Do not invoke these routines directly as this may result in corruption of index data.</div>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI5024"></a><a id="sthref764"></a><a id="CHECCCID"></a>Table 20-1 Summary of System-Defined Extensible Indexing Interface Routines</p>
<table class="cellalignment1246" title="Summary of System-Defined Extensible Indexing Interface Routines" summary="Column 1 is the Routine, column 2 is its description" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t3">Routine</th>
<th class="cellalignment1247" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t3" headers="r1c1-t3">
<p><a href="#BJEJEIJD">ODCIGetInterfaces()</a></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c2-t3">
<p>Invoked when an <code>INDEXTYPE</code> is created by a <code>CREATE</code> <code>INDEXTYPE...</code> statement or is altered.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t3" headers="r1c1-t3">
<p><a href="#i76608">ODCIIndexAlter()</a></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c2-t3">
<p>Invoked when a domain index or a domain index partition is altered using an <code>ALTER INDEX</code>, an <code>ALTER INDEX PARTITION</code>, a <code>TRUNCATE TABLE</code>, a <code>RENAME TABLE</code>, an <code>ALTER TABLE RENAME COLUMN</code>, or an <code>ALTER TABLE [ADD|TRUNCATE|SPLIT|MERGE] PARTITION</code> statement.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t3" headers="r1c1-t3">
<p><a href="#i77457">ODCIIndexClose()</a></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c2-t3">
<p>Invoked to end the processing of an operator.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t3" headers="r1c1-t3">
<p><a href="#i78714">ODCIIndexCreate()</a></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c2-t3">
<p>Invoked when a domain index is created by a <code>CREATE INDEX...INDEXTYPE IS...PARAMETERS...</code> statement issued by the user.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t3" headers="r1c1-t3">
<p><a href="#i76734">ODCIIndexDelete()</a></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c2-t3">
<p>Invoked when a row is deleted from a table that has a domain index defined on one or more of its columns.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t3" headers="r1c1-t3">
<p><a href="#i79038">ODCIIndexDrop()</a></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c2-t3">
<p>Invoked when a domain index is dropped explicitly using a <code>DROP</code> <code>INDEX</code> statement, or implicitly through a <code>DROP</code> <code>TABLE</code> or <code>DROP</code> <code>USER</code> statement.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t3" headers="r1c1-t3">
<p><a href="#i78919">ODCIIndexExchangePartition()</a></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c2-t3">
<p>Invoked when an <code>ALTER TABLE EXCHANGE PARTITION...INCLUDING INDEXES</code> is issued on a partitioned table on which a local domain index is defined.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t3" headers="r1c1-t3">
<p><a href="#i76798">ODCIIndexFetch()</a></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c2-t3">
<p>Invoked repeatedly to retrieve the rows satisfying the operator predicate.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t3" headers="r1c1-t3">
<p><a href="#i76838">ODCIIndexGetMetadata()</a></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c2-t3">
<p>Returns a series of strings of PL/SQL code that comprise the non-dictionary metadata associated with the index.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t3" headers="r1c1-t3">
<p><a href="#i76892">ODCIIndexInsert()</a></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c2-t3">
<p>Invoked when a row or a set of rows is inserted into a table that has a domain index defined on one or more of its columns.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r12c1-t3" headers="r1c1-t3">
<p><a href="#i78634">ODCIIndexStart()</a></p>
</td>
<td class="cellalignment1243" headers="r12c1-t3 r1c2-t3">
<p>Invoked to start the evaluation of an operator on an indexed column.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r13c1-t3" headers="r1c1-t3">
<p><a href="#i77033">ODCIIndexUpdate()</a></p>
</td>
<td class="cellalignment1243" headers="r13c1-t3 r1c2-t3">
<p>Invoked when a row is updated in a table and the updated column has a domain index defined on.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r14c1-t3" headers="r1c1-t3">
<p><a href="#CHEDHCCB">ODCIIndexUpdPartMetadata()</a></p>
</td>
<td class="cellalignment1243" headers="r14c1-t3 r1c2-t3">
<p>Invoked during partition maintenance operations. Patches the indextype metadata tables to correctly reflect the partition maintenance operation.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r15c1-t3" headers="r1c1-t3">
<p><a href="#CHDBJBBB">ODCIIndexUtilCleanup()</a></p>
</td>
<td class="cellalignment1243" headers="r15c1-t3 r1c2-t3">
<p>Cleans up temporary states created by <a href="#CHDGJAGF">ODCIIndexUtilGetTableNames()</a>.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r16c1-t3" headers="r1c1-t3">
<p><a href="#CHDGJAGF">ODCIIndexUtilGetTableNames()</a></p>
</td>
<td class="cellalignment1243" headers="r16c1-t3 r1c2-t3">
<p>IDetermines if the secondary tables storing the index data should be transported.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="BJEJEIJD"></a><a id="ADDCI5025"></a>
<div class="sect2">
<h3 class="sect2">ODCIGetInterfaces()</h3>
<p>Invoked when an <code>INDEXTYPE</code> is created by a <code>CREATE</code> <code>INDEXTYPE...</code> statement or is altered.</p>
<p class="subhead1"><a id="ADDCI5026"></a>Syntax</p>
<pre>
FUNCTION ODCIGetInterfaces(
   ifclist OUT ODCIObjectList)
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t4">Parameter</th>
<th class="cellalignment1247" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t4" headers="r1c1-t4">
<pre>
ifclist
</pre></td>
<td class="cellalignment1243" headers="r2c1-t4 r1c2-t4">Contains information about the interfaces it supports</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5027"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success or <code>ODCIConst.Error</code> on error</p>
<p class="subhead1"><a id="ADDCI5028"></a>Usage Notes</p>
<p>This function should be implemented as a static type method.</p>
<p>This function must return <code>SYS.ODCIINDEX2</code> in the <code>ODCIObjectList</code> if the indextype uses the second version of the <code>ODCIIndex</code> interface, which was implemented in the current version of the Oracle Database and is described in this book.</p>
</div>
<!-- class="sect2" -->
<a id="i76608"></a><a id="ADDCI5029"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexAlter()</h3>
<p>Invoked when a domain index or a domain index partition is altered using one of the following methods:</p>
<ul>
<li>
<p><code>ALTER INDEX</code></p>
</li>
<li>
<p><code>ALTER INDEX PARTITION</code></p>
</li>
<li>
<p><code>TRUNCATE TABLE</code> <code><span class="codeinlineitalic">table_name</span></code></p>
</li>
<li>
<p><code>RENAME TABLE</code></p>
</li>
<li>
<p><code>ALTER TABLE...[ADD|TRUNCATE|SPLIT|MERGE]...PARTITION</code></p>
</li>
<li>
<p><code>ALTER TABLE RENAME</code></p>
</li>
<li>
<p><code>ALTER TABLE RENAME COLUMN</code></p>
</li>
</ul>
<p>To populate the index partitions when creating local domain indexes, this method is invoked for each partition of the base table.</p>
<p class="subhead1"><a id="ADDCI5030"></a>Syntax</p>
<pre>
STATIC FUNCTION ODCIIndexAlter(
   ia ODCIIndexInfo, 
   parms IN OUT VARCHAR2, 
   alter_option NUMBER, 
   env ODCIEnv) 
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t5">Parameter</th>
<th class="cellalignment1247" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t5" headers="r1c1-t5">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t5 r1c2-t5">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t5" headers="r1c1-t5">
<pre>
parms (IN)
</pre></td>
<td class="cellalignment1243" headers="r3c1-t5 r1c2-t5">Parameter string
<ul>
<li>
<p>With <code>ALTER</code> <code>INDEX</code> <code>PARAMETERS</code> or <code>ALTER</code> <code>INDEX</code> <code>REBUILD</code>, contains the user specified parameter string</p>
</li>
<li>
<p>With <code>ALTER</code> <code>INDEX</code> <code>RENAME</code>, contains the new name of the domain index</p>
</li>
<li>
<p>With <code>ALTER TABLE RENAME COLUMN</code>, contains the new domain-indexed column name</p>
</li>
<li>
<p>With <code>ALTER TABLE RENAME or RENAME TABLE</code>, contains the new table name</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t5" headers="r1c1-t5">
<pre>
parms (OUT)
</pre></td>
<td class="cellalignment1243" headers="r4c1-t5 r1c2-t5">Parameter string
<p>Valid only with <code>ALTER</code> <code>INDEX</code> <code>PARAMETERS</code> or <code>ALTER</code> <code>INDEX</code> <code>REBUILD</code>; contains the resultant string to be stored in system catalogs</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t5" headers="r1c1-t5">
<pre>
alter_option
</pre></td>
<td class="cellalignment1243" headers="r5c1-t5 r1c2-t5">Specifies one of the following options:
<ul>
<li>
<p><code>AlterIndexNone</code> if <code>ALTER INDEX [PARTITION] PARAMETERS</code></p>
</li>
<li>
<p><code>AlterIndexRename</code> if <code>ALTER INDEX RENAME [PARTITION]</code></p>
</li>
<li>
<p><code>AlterIndexRebuild</code> if <code>ALTER INDEX REBUILD [PARTITION] [PARAMETERS]</code></p>
</li>
<li>
<p><code>AlterIndexRenameCol</code> if <code>ALTER TABLE RENAME COLUMN</code></p>
</li>
<li>
<p><code>AlterIndexRenameTab</code> if <code>ALTER TABLE RENAME</code> or <code>RENAME TABLE</code></p>
</li>
<li>
<p><code>AlterIndexUpdBlockRefs</code> if <code>ALTER TABLE UPDATE BLOCK REFERENCES</code></p>
</li>
<li>
<p><code>AlterIndexMigrate</code> if <code>ALTER INDEX COMPILE</code> when the domain index is user-managed, but its indextype is system-managed</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t5" headers="r1c1-t5">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r6c1-t5 r1c2-t5">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5031"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success, <code>ODCIConst.Error</code> on error, or <code>ODCIConst.Warning</code> otherwise. When invoked to rebuild local index partitions, may also return <code>ODCIConst.ErrContinue</code>.</p>
<p class="subhead1"><a id="ADDCI5032"></a>Usage Notes</p>
<ul>
<li>
<p>This function should be implemented as a static type method.</p>
</li>
<li>
<p>An <code>ALTER</code> <code>INDEX</code> statement can be invoked for domain indexes in multiple ways.</p>
<pre>
ALTER INDEX <span class="italic">index_name</span>
PARAMETERS (<span class="italic">parms</span>);
</pre>
<p>or</p>
<pre>
ALTER INDEX <span class="italic">index_name</span>
REBUILD PARAMETERS (<span class="italic">parms</span>);
</pre>
<p>The precise behavior in these two cases is defined by the implementation. One possibility is that the first statement would merely reorganize the index based on the parameters while the second would rebuild it from scratch.</p>
</li>
<li>
<p>The maximum length of the input parameters string is 1000 characters. The <code>OUT</code> value of the <code>parms</code> argument can be set to resultant parameters string to be stored in the system catalogs.</p>
</li>
<li>
<p>The <code>ALTER</code> <code>INDEX</code> statement can also be used to rename a domain index in the following way:</p>
<pre>
ALTER INDEX <span class="italic">index_name</span>
RENAME TO <span class="italic">new_index_name</span>
</pre></li>
<li>
<p>When the name of the table on which a domain index is created changes, <a href="#i76608">ODCIIndexAlter()</a> is invoked with <code>alter_option=AlterIndexRenameTab</code>, and <code><span class="codeinlineitalic">new_table_name</span></code> is passed to the <code>parms</code> argument:</p>
<pre>
ALTER TABLE table_name 
RENAME <span class="italic">new_table_name</span>
</pre>
<p>or</p>
<pre>
RENAME <span class="italic">table_name</span> 
TO <span class="italic">new_table_name</span>
</pre></li>
<li>
<p>When the name of the column on which a domain index is created changes, <a href="#i76608">ODCIIndexAlter()</a> is invoked with <code>alter_option=AlterIndexRenameCol</code>, and <code><span class="codeinlineitalic">new_column_name</span></code> is passed to the <code>parms</code> argument:</p>
<pre>
ALTER TABLE table_name 
RENAME COLUMN <span class="italic">column_name</span> 
TO <span class="italic">new_column_name</span>
</pre></li>
<li>
<p>If the <code>PARALLEL</code> clause is omitted, then the domain index or local domain index partition is rebuilt sequentially.</p>
</li>
<li>
<p>If the <code>PARALLEL</code> clause is specified, the parallel degree is passed to the <a href="#i76608">ODCIIndexAlter()</a> invocation in the <code>IndexParaDegree</code> attribute of <code>ODCIIndexInfo</code>, and the <code>Parallel</code> bit of the <code>IndexInfoFlags</code> attribute is set. The parallel degree is determined as follows:</p>
<ul>
<li>
<p>If <code>PARALLEL DEGREE</code> <span class="italic">deg</span> is specified, <span class="italic">deg</span> is passed.</p>
</li>
<li>
<p>If only <code>PARALLEL</code> is specified, then a constant is passed to indicate that the default degree of parallelism was specified.</p>
</li>
</ul>
</li>
<li>
<p>If the <code>ODCIIndexAlter</code> routine returns with the <code>ODCIConst</code>.<code>Success</code>, the index is valid and usable. If the <a href="#i76608">ODCIIndexAlter()</a> routine returns with <code>ODCIConst</code>.<code>Warning</code>, the index is valid and usable but a warning message is returned to the user. If <a href="#i76608">ODCIIndexAlter()</a> returns with an error (or exception), the domain index is marked <code>FAILED</code>.</p>
</li>
<li>
<p>When the <a href="#i76608">ODCIIndexAlter()</a> routine is being executed, the domain index is marked <code>LOADING</code>.</p>
</li>
<li>
<p>Every SQL statement executed by <a href="#i76608">ODCIIndexAlter()</a> is treated as an independent operation. The changes made by <a href="#i78714">ODCIIndexCreate()</a> are not guaranteed to be atomic.</p>
</li>
<li>
<p>The <code>AlterIndexUpdBlockRefs</code> alter option applies only to domain indexes on index-organized tables. When the end user executes an <code>ALTER INDEX</code> <code><span class="codeinlineitalic">domain_index</span></code> <code>UPDATE BLOCK REFERENCES</code>, <a href="#i76608">ODCIIndexAlter()</a> is called with the <code>AlterIndexUpdBlockRefs</code> bit set to give the cartridge developer the opportunity to update guesses as to the block locations of rows, stored in logical rowids.</p>
</li>
<li>
<p>The <code>AlterIndexMigrate</code> alter options applies only to migration of user-managed domain indexes to system-managed domain indexes. When the user-managed domain index is marked <code>INVALID</code>, but its indextype is system-managed, you must make an <code>ALTER INDEX</code> <code><span class="codeinlineitalic">domain_index</span></code> <code>COMPILE</code> call to re-validate the domain index. This calls the <a href="#i76608">ODCIIndexAlter()</a> method with <code>alter_option=AlterIndexMigrate</code>, to allow an opportunity to migrate the domain index to the system-managed approach.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i77457"></a><a id="ADDCI5033"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexClose()</h3>
<p>Invoked to end the processing of an operator.</p>
<p class="subhead1"><a id="ADDCI5034"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexClose(
   self IN <span class="italic">impltype</span>, 
   env ODCIEnv) 
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t6">Parameter</th>
<th class="cellalignment1247" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t6" headers="r1c1-t6">
<pre>
self(IN)
</pre></td>
<td class="cellalignment1243" headers="r2c1-t6 r1c2-t6">Is the value of the context returned by the previous invocation of <a href="#i76798">ODCIIndexFetch()</a></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t6" headers="r1c1-t6">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r3c1-t6 r1c2-t6">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5035"></a>Returns</p>
<ul>
<li>
<p><code>ODCIConst.Success</code> on success</p>
</li>
<li>
<p><code>ODCIConst.Error</code> on error</p>
</li>
</ul>
<p class="subhead1"><a id="ADDCI5036"></a>Usage Notes</p>
<p>The index implementor can perform any appropriate actions to finish up the processing of an domain index scan, such as freeing memory and other resources.</p>
</div>
<!-- class="sect2" -->
<a id="i78714"></a><a id="ADDCI5037"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexCreate()</h3>
<p>Invoked when a domain index is created by a <code>CREATE INDEX...INDEXTYPE IS...PARAMETERS...</code> statement issued by the user. The domain index can be either a non-partitioned index or a local partitioned domain index. The local partitioned domain index can be created in either a system- or a user-managed scheme.</p>
<p class="subhead1"><a id="ADDCI5038"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexCreate(
   ia ODCIIndexInfo, 
   parms VARCHAR2, 
   env ODCIEnv)
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t7">Parameter</th>
<th class="cellalignment1247" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t7" headers="r1c1-t7">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t7 r1c2-t7">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t7" headers="r1c1-t7">
<pre>
parms
</pre></td>
<td class="cellalignment1243" headers="r3c1-t7 r1c2-t7">The <code>PARAMETERS</code> string passed in not interpreted by Oracle. The maximum size of the parameter string is <code>1,000</code> characters.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t7" headers="r1c1-t7">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r4c1-t7 r1c2-t7">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5039"></a>Returns</p>
<p><code>ODCIConst.Success</code> , <code>ODCIConst.Error</code>, <code>ODCIConst.Warning</code>, <code>ODCIConst.ErrContinue</code> if the method is invoked at the partition level for creation of a local partitioned index, to continue to the next partition even in case of an error, or <code>ODCIConst.Fatal</code> to signify that all dictionary entries for the index are cleaned up and that the <code>CREATE INDEX</code> operation is rolled back. Returning this status code assumes that the cartridge code has not created any objects (or cleaned up any objects created).</p>
<p class="subhead1"><a id="ADDCI5040"></a>Usage Notes</p>
<ul>
<li>
<p>This function should be implemented as a <code>STATIC</code> type method.</p>
</li>
<li>
<p>Creates objects (such as tables) to store the index data, generate the index data, and store the data in the index data tables.</p>
</li>
<li>
<p>This procedure should handle creation of indexes on both empty and non-empty tables. If the base table is not empty, the procedure can scan the entire table and generate index data.</p>
</li>
<li>
<p>When the <a href="#i78714">ODCIIndexCreate()</a> routine is running, the domain index is marked <code>LOADING</code>.</p>
</li>
<li>
<p>Every SQL statement executed by <a href="#i78714">ODCIIndexCreate()</a> is treated as an independent operation. The changes made by <a href="#i78714">ODCIIndexCreate()</a> are not guaranteed to be atomic.</p>
</li>
<li>
<p>To create a non-partitioned domain index, the <a href="#i78714">ODCIIndexCreate()</a> method is invoked, and the only valid return codes are <code>ODCIConst.Success</code>, <code>ODCIConst.Warning</code>, <code>ODCIConst.Error</code>, or <code>ODCIConst.Fatal</code>. If the operation returns <code>ODCIConst.Fatal</code>, the <code>CREATE INDEX</code> statement is rolled back by the server.</p>
</li>
<li>
<p>In a non-partitioned domain index, the <code>IndexPartition</code>, <code>TablePartition</code> name, and the <code>callProperty</code> should be <code>NULL</code>.</p>
</li>
<li>
<p>For a non-partitioned domain index, the parallel degree is passed to the <a href="#i78714">ODCIIndexCreate()</a> invocation in the <code>IndexParaDegree</code> attribute of <code>ODCIIndexInfo</code>, and the <code>Parallel</code> bit of the <code>IndexInfoFlags</code> is set. The parallel degree is determined as follows:</p>
<ul>
<li>
<p>If <code>PARALLEL DEGREE</code> <code><span class="codeinlineitalic">deg</span></code> is specified, <code><span class="codeinlineitalic">deg</span></code> is passed.</p>
</li>
<li>
<p>If only <code>PARALLEL</code> is specified, then a constant indicating that the default degree of parallelism was specified, is passed.</p>
</li>
<li>
<p>If the <code>PARALLEL</code> clause is omitted entirely, the operation is performed sequentially.</p>
</li>
</ul>
</li>
<li>
<p>If the <a href="#i78714">ODCIIndexCreate()</a> routine returns with the <code>ODCIConst</code>.<code>Success</code>, the index is valid and usable. If the <a href="#i78714">ODCIIndexCreate()</a> routine returns with <code>ODCIConst</code>.<code>Warning</code>, the index is valid and usable but a warning message is returned to the user. If the <a href="#i78714">ODCIIndexCreate()</a> routine returns with an <code>ODCIConst</code>.<code>Error</code> (or exception), the domain index is marked <code>FAILED.</code></p>
</li>
<li>
<p>The only operations permitted on <code>FAILED</code> domain indexes is <code>DROP</code> <code>INDEX</code>, <code>TRUNCATE</code> <code>TABLE</code> or <code>ALTER</code> <code>INDEX</code> <code>REBUILD</code>.</p>
</li>
<li>
<p>If a domain index is created on an column of object type which contains a <code>REF</code> attribute, do not dereference the <code>REF</code>s while building your index. Dereferencing a <code>REF</code> fetches data from a different table instance. If the data in the other table is modified, the domain index becomes incorrect. Note that the user is not notified.</p>
</li>
<li>
<p>The <a href="#i78714">ODCIIndexCreate()</a> method is invoked twice for the creation of system managed local domain indexes and the only valid return codes are <code>ODCIConst.Success</code>, <code>ODCIConst.Warning</code> or <code>ODCIConst.Error</code>. <code>ODCIConst.Fatal</code> can be returned by the first call and results in the <code>CREATE INDEX</code> statement being rolled back by the server. The number of partitions is passed in as an argument <code>ODCIIndexInfo.IndexPartitionTotal</code>. The first call should create all the index storage tables. All the index storage tables should preferably be system partitioned to get the benefits of local domain indexes. Also:</p>
<ul>
<li>
<p>These tables must have the same number of partitions as the base table</p>
</li>
<li>
<p>The users should generate the create table statement with both object and partition level attributes</p>
</li>
</ul>
</li>
<li>
<p>Note that the object level create routine only passes in the object level parameter string. However, to construct the storage attributes for all the partitions, it needs the partition level parameter strings. The cartridge indexing code must obtain them by querying the <code>*_ind_partitions</code> views on the dictionary tables. The system partitioned tables should not be populated in this phase. The user should wait for the subsequent calls <a href="#i76608">ODCIIndexAlter()</a> to populate the partitions. Also, it is recommended that the users should derive the names of the storage tables and its partitions from the index name and the index partition names. In this case, the user should fetch the index partition names from the <code>*_ind_partitions</code> view and construct the partition names for the storage table.</p>
</li>
<li>
<p>In the second <a href="#i78714">ODCIIndexCreate()</a> call, the user can create domain index storage table dependent objects, such as indexes, constraints, and triggers. These can be created as before by directly using the SQL callbacks. However, for system partitioned storage tables, the following types of indexes are disallowed:</p>
<ul>
<li>
<p>non-partitioned index</p>
</li>
<li>
<p>globally partitioned index</p>
</li>
</ul>
</li>
<li>
<p>Sequence numbers and synonyms can be created using callbacks and they are assumed to be partition-independent. The set of objects created for non-partitioned domain index is identical to that of a local partitioned index and these objects are not impacted when a table or partition maintenance operation is done. It is the users responsibility to drop these objects when the index is dropped.</p>
</li>
<li>
<p>Other (transient) objects needed for temporary use can be created using callbacks as before. It is the responsibility of user-supplied code to drop them by the end of the create call.</p>
</li>
<li>
<p>Temporary tables can be created for holding intermediate data. The server does not perform maintenance operations on these tables.</p>
</li>
<li>
<p>External Objects, such as files, can be created for temporary use.</p>
</li>
<li>
<p>All the tables left after the invocation of <a href="#i78714">ODCIIndexCreate()</a> or <a href="#i76608">ODCIIndexAlter()</a> are supposed to be system-managed, and the server takes appropriate actions on them during drop, truncate, or the partition maintenance operations.</p>
</li>
<li>
<p>Since this routine handles multiple things, such as creation of a non-partitioned index or creation of a local index, you must take special care to code it appropriately.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i76734"></a><a id="ADDCI5041"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexDelete()</h3>
<p>Invoked when a row is deleted from a table that has a domain index defined on one or more of its columns.</p>
<p class="subhead1"><a id="ADDCI5042"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexDelete(
   ia ODCIIndexInfo, 
   rid VARCHAR2, 
   oldval <span class="italic">icoltype</span>, 
   env ODCIEnv) 
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t8">Parameter</th>
<th class="cellalignment1247" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t8" headers="r1c1-t8">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t8 r1c2-t8">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t8" headers="r1c1-t8">
<pre>
rid
</pre></td>
<td class="cellalignment1243" headers="r3c1-t8 r1c2-t8">The row identifier of the deleted row</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t8" headers="r1c1-t8">
<pre>
oldval
</pre></td>
<td class="cellalignment1243" headers="r4c1-t8 r1c2-t8">The value of the indexed column in the deleted row. The data type is identical to that of the indexed column.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t8" headers="r1c1-t8">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r5c1-t8 r1c2-t8">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5043"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success, or <code>ODCIConst.Error</code> on error.</p>
<p class="subhead1"><a id="ADDCI5044"></a>Usage Notes</p>
<ul>
<li>
<p>This function should be implemented as a <code>STATIC</code> type method.</p>
</li>
<li>
<p>This method should delete index data corresponding to the deleted row from the appropriate tables or files storing index data.</p>
</li>
<li>
<p>Note that the index partition object identifier <code>ODCIIndexInfo.IndexPartitionIden</code> and the base table partition physical identifier <code>ODCIIndexInfo.IndexCols(1).TablePartitionIden</code> is passed in for local domain index. The indextype must use the new DML syntax using the partition number and the provided <code>SYS_OP_DOBJTOPNUM</code> function to delete data from the storage system partitioned table:</p>
<pre>
DELETE FROM SP PARTITION (
   SYS_OP_DOBJTOPNUM(
       base_table_name,
      :tab_physical_partid))
   VALUES(&hellip;) 
   WHERE rowid = :rowid;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i79038"></a><a id="ADDCI5045"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexDrop()</h3>
<p>The <a href="#i79038">ODCIIndexDrop()</a> procedure is invoked when a domain index is dropped explicitly using a <code>DROP</code> <code>INDEX</code> statement, or implicitly through a <code>DROP</code> <code>TABLE</code> or <code>DROP</code> <code>USER</code> statement.</p>
<p class="subhead1"><a id="ADDCI5046"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexDrop(
   ia ODCIIndexInfo, 
   env ODCIEnv) 
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t9">Parameter</th>
<th class="cellalignment1247" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t9" headers="r1c1-t9">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t9 r1c2-t9">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t9" headers="r1c1-t9">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r3c1-t9 r1c2-t9">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5047"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success, or <code>ODCIConst.Error</code> on error, or <code>ODCIConst.Warning</code>.</p>
<p class="subhead1"><a id="ADDCI5048"></a>Usage Notes</p>
<ul>
<li>
<p>This method should be implemented as a static type method.</p>
</li>
<li>
<p>This method should drop the tables storing the domain index data.</p>
</li>
<li>
<p>For both a non-partitioned domain index and system managed local domain index, the <a href="#i79038">ODCIIndexDrop()</a> method is invoked only one time. The user need not drop the index storage tables if the system-managed approach is used. This is done automatically by the kernel after the call is completed.</p>
</li>
<li>
<p>Since it is possible that the domain index is marked <code>FAILED</code> (due to abnormal termination of some DDL routine), the <a href="#i79038">ODCIIndexDrop()</a> routine should be capable of cleaning up partially created domain indexes. When the <a href="#i79038">ODCIIndexDrop()</a> routine is being executed, the domain index is marked <code>LOADING</code>.</p>
</li>
<li>
<p>Note that if the <a href="#i79038">ODCIIndexDrop()</a> routine returns with an <code>ODCIConst.Error</code> or exception, the <code>DROP</code> <code>INDEX</code> statement fails and the index is marked <code>FAILED</code>. In that case, there is no mechanism to get rid of the domain index except by using the <code>FORCE</code> option. If the <a href="#i79038">ODCIIndexDrop()</a> routine returns with <code>ODCIConst</code>.<code>Warning</code> in the case of an explicit <code>DROP</code> <code>INDEX</code> statement, the operation succeeds but a warning message is returned to the user.</p>
</li>
<li>
<p>Every SQL statement executed by <a href="#i79038">ODCIIndexDrop()</a> is treated as an independent operation. The changes made by <a href="#i79038">ODCIIndexDrop()</a> are not guaranteed to be atomic.</p>
</li>
<li>
<p>For both a non-partitioned domain index and system managed local domain index, the <a href="#i79038">ODCIIndexDrop()</a> method is invoked only one time. With the system-managed approach, the index storage tables don't have to be dropped. This is done automatically by the kernel after the call is completed.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i78919"></a><a id="ADDCI5049"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexExchangePartition()</h3>
<p>This method is invoked when an <code>ALTER TABLE EXCHANGE PARTITION...INCLUDING INDEXES</code> command is issued on a partitioned table that has a defined local domain index.</p>
<p class="subhead1"><a id="ADDCI5050"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexExchangePartition( 
   ia ODCIIndexInfo, 
   ia1 ODCIIndexInfo, 
   env ODCIEnv) 
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t10">Parameter</th>
<th class="cellalignment1247" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t10" headers="r1c1-t10">ia</td>
<td class="cellalignment1243" headers="r2c1-t10 r1c2-t10">Contains information about the domain index partition to exchange.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t10" headers="r1c1-t10">ia1</td>
<td class="cellalignment1243" headers="r3c1-t10 r1c2-t10">Contains information about the non-partitioned domain index.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t10" headers="r1c1-t10">env</td>
<td class="cellalignment1243" headers="r4c1-t10 r1c2-t10">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5051"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success, or <code>ODCIConst.Error</code> on error, or <code>ODCIConst.Warning</code>.</p>
<p class="subhead1"><a id="ADDCI5052"></a>Usage Notes</p>
<ul>
<li>
<p>The function should be implemented as a <code>STATIC</code> type method.</p>
</li>
<li>
<p>This method should handle both converting a partition of a domain index into a non-partitioned domain index and converting a non-partitioned index to a partition of a partitioned domain index.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i76798"></a><a id="ADDCI5053"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexFetch()</h3>
<p>This procedure is invoked repeatedly to retrieve the rows satisfying the operator predicate.</p>
<p class="subhead1"><a id="ADDCI5054"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexFetch(
   self IN [OUT] <span class="italic">impltype</span>, 
   nrows IN NUMBER, 
   rids OUT ODCIRidList, 
   env ODCIEnv) 
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t11">Parameter</th>
<th class="cellalignment1247" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t11" headers="r1c1-t11">
<pre>
self(IN)
</pre></td>
<td class="cellalignment1243" headers="r2c1-t11 r1c2-t11">Is the value of the context returned by the previous call (to <code>ODCIIndexFetch</code> or to <a href="#i78634">ODCIIndexStart()</a> if this is the first time fetch is being called for this operator instance</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t11" headers="r1c1-t11">
<pre>
self(OUT)
</pre></td>
<td class="cellalignment1243" headers="r3c1-t11 r1c2-t11">The context that is passed to the next query-time call. Note that this parameter does not have to be defined as <code>OUT</code> if the value is not modified in this routine.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t11" headers="r1c1-t11">
<pre>
nrows
</pre></td>
<td class="cellalignment1243" headers="r4c1-t11 r1c2-t11">Is the maximum number of result rows that can be returned to Oracle in this call</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t11" headers="r1c1-t11">
<pre>
rids
</pre></td>
<td class="cellalignment1243" headers="r5c1-t11 r1c2-t11">Is the array of row identifiers for the result rows being returned by this call</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t11" headers="r1c1-t11">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r6c1-t11 r1c2-t11">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5055"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success, or <code>ODCIConst.Error</code> on error.</p>
<p class="subhead1"><a id="ADDCI5056"></a>Usage Notes</p>
<ul>
<li>
<p><a href="#i76798">ODCIIndexFetch()</a> returns rows satisfying the operator predicate. That is, it returns the row identifiers of all the rows for which the operator return value falls within the specified bounds.</p>
</li>
<li>
<p>Each call to <a href="#i76798">ODCIIndexFetch()</a> can return a maximum of <span class="italic">nrows</span> number of rows. The value of <span class="italic">nrows</span> passed in is decided by Oracle based on some internal factors. However, the <a href="#i76798">ODCIIndexFetch()</a> routine can return lesser than <span class="italic">nrows</span> number of rows. The row identifiers are returned through the output <code>rids</code> array. A <code>NULL</code> <code>ROWID</code> (as an element of the <code>rids</code> array) indicates that all satisfying rows have been returned.</p>
<p>Assume that there are <code>3000</code> rows which satisfy the operator predicate, and that the value of <code>nrows</code> <code>= 2000</code>. The first invocation of <a href="#i76798">ODCIIndexFetch()</a> can return the first <code>2000</code> rows. The second invocation can return a <code>rid</code> list consisting of the remaining <code>1000</code> rows followed by a <code>NULL</code> element. The <code>NULL</code> value in <code>rid</code> list indicates that all satisfying rows have now been returned.</p>
</li>
<li>
<p>If the context value is changed within this call, the new value is passed in to subsequent query-time calls.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i76838"></a><a id="ADDCI5057"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexGetMetadata()</h3>
<p>Returns a series of strings of PL/SQL code that comprise the non-dictionary metadata associated with the index in <code>ia</code>. The routine can pass whatever information is required at import time. For example, policy, version, preferences, and so on. This method is optional unless implementation-specific metadata is required.</p>
<p class="subhead1"><a id="ADDCI5058"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexGetMetadata(
   ia IN ODCIIndexInfo, 
   version IN VARCHAR2, 
   new_block OUT PLS_INTEGER,
   env ODCIEnv) 
RETURN VARCHAR2;
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t12">Parameter</th>
<th class="cellalignment1247" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t12" headers="r1c1-t12">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t12 r1c2-t12">Specifies the index on which export is currently working</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t12" headers="r1c1-t12">
<pre>
version
</pre></td>
<td class="cellalignment1243" headers="r3c1-t12 r1c2-t12">Version of export making the call in the form <code>11.2.0.1.00</code></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t12" headers="r1c1-t12">
<pre>
new_block
</pre></td>
<td class="cellalignment1243" headers="r4c1-t12 r1c2-t12">Non-zero (<code>TRUE</code>): Returned string starts a new PL/SQL block. Export terminates the current block (if any) with <code>END</code>; and open a new block with <code>BEGIN</code> before writing strings to the dump file. The routine is called again.
<p><code>0</code> (<code>FALSE</code>): Returned string continues current block. Export writes only the returned string to the dump file then calls the routine again.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t12" headers="r1c1-t12">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r5c1-t12 r1c2-t12">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5059"></a>Returns</p>
<ul>
<li>
<p>A null-terminated string containing a piece of an opaque block of PL/SQL code</p>
</li>
<li>
<p>A zero-length string indicates no more data; export stops calling the routine</p>
</li>
</ul>
<p class="subhead1"><a id="ADDCI5060"></a>Usage Notes</p>
<ul>
<li>
<p>This function should be implemented as a static type method.</p>
</li>
<li>
<p>The routine is called repeatedly until the return string length is 0. If an index has no metadata to be exported using PL/SQL, it should return an empty string upon first call.</p>
</li>
<li>
<p>This routine can be used to build one or more blocks of anonymous PL/SQL code for execution by import. Each returned block is invoked independently by import. That is, if a block fails for any reason at import time, subsequent blocks are still invoked. Therefore any dependent code should be incorporated within a single block. The size of an individual block of PL/SQL code is limited only by the size of import's read buffer controlled by its <code>BUFFER</code> parameter.</p>
</li>
<li>
<p>The execution of these PL/SQL blocks at import time is considered part of the associated domain index's creation. Therefore, their execution is dependent upon the successful import of the index's underlying base table and user's setting of import's <code>INDEXES=Y/N</code> parameter, as is the creation of the index.</p>
</li>
<li>
<p>The routine should not pass back the <code>BEGIN</code>/<code>END</code> strings that open and close the individual blocks of PL/SQL code; export adds these to mark the individual units of execution.</p>
</li>
<li>
<p>The parameter <code>version</code> is the version number of the currently executing export client. Since export and import can be used to downgrade a database to the previous functional point release, it also represents the minimum server version you can expect to find at import time; it may be higher, but never lower.</p>
</li>
<li>
<p>The cartridge developer can use this information to determine what version of information should be written to the dump file. For example, assume the current server version is <code>11.2.0.1.0</code>, but the export version handed in is <code>11.1.0.1.0</code>. If a cartridge's metadata changed formats these version, it would know to write the data to the dump file in 11.1 format, anticipating an import into an 11.2 system.</p>
</li>
<li>
<p>The data contained within the strings handed back to export must be completely platform-independent. That is, they should contain no binary information that may reflect the endian nature of the export platform, which may be different from the import platform. Binary information may be passed as hex strings and converted through <code>RAWTOHEX</code> and <code>HEXTORAW</code>.</p>
</li>
<li>
<p>The strings are translated from the export server to export client character set and are written to the dump file as such. At import time, they are translated from export client character set to import client character set, then from import client char set to import server character set when handed over the UPI interface.</p>
</li>
<li>
<p>Specifying a target schema in the execution of any of the PL/SQL blocks must be avoided because it frequently causes an error if you use import's <code>FROMUSER</code> -&gt; <code>TOUSER</code> schema replication feature. For example, a procedure prototype such as:</p>
<pre>
PROCEDURE AQ_CREATE ( schema IN VARCHAR2, que_name IN VARCHAR2) ...
</pre>
<p>should be avoided becuase it fails if you have remapped schema A to schema B on import. You can assume at import time that you are connected to the target schema.</p>
</li>
<li>
<p>Export dump files from a particular version must be importable into all future versions. This means that all PL/SQL routines invoked within the anonymous PL/SQL blocks written to the dump file must be supported for all time. You may wish to encode some version information to assist with detecting when conversion may be required.</p>
</li>
<li>
<p>Export operates in a read-only transaction if its parameter <code>CONSISTENT=Y</code>. In this case, no writes are allowed from the export session. Therefore, this method must not write any database state.</p>
</li>
<li>
<p>You can attempt to import the same dump file multiple times, especially when using import's <code>IGNORE=Y</code> parameter. Therefore, this method must produce PL/SQL code that is idempotent, or at least deterministic when executed multiple times.</p>
</li>
<li>
<p>Case on database object names must be preserved; that is, objects named '<code>Foo</code>' and '<code>FOO</code>' are distinct objects. Database object names should be enclosed within double quotes ("") to preserve case.</p>
</li>
</ul>
<p class="subhead1"><a id="ADDCI5061"></a>Error Handling</p>
<p>Any unrecoverable error should raise an exception allowing it to propagate back to <code>get_domain_index_metadata</code> and thence back to export. This causes export to terminate the creation of the current index's DDL in the dump file and to move on to the next index.</p>
<p>At import time, failure of the execution of any metadata PL/SQL block causes the associated index not to be created under the assumption that the metadata creation is an integral part of the index creation.</p>
</div>
<!-- class="sect2" -->
<a id="i76892"></a><a id="ADDCI025"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexInsert()</h3>
<p>Invoked when a row or a set of rows is inserted into a table that has a domain index defined on one or more of its columns.</p>
<div class="inftblinformal">
<table class="cellalignment1250" title="Syntax versions of the function" summary="Syntax versions and their purpose" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t13">Syntax</th>
<th class="cellalignment1247" id="r1c2-t13">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t13" headers="r1c1-t13">
<pre>
FUNCTION ODCIIndexInsert(
   ia ODCIIndexInfo, 
   rid VARCHAR2, 
   newval <span class="italic">icoltype</span>, 
   env ODCIEnv) 
RETURN NUMBER
</pre></td>
<td class="cellalignment1243" headers="r2c1-t13 r1c2-t13">Inserts a single row</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t13" headers="r1c1-t13">
<pre>
FUNCTION ODCIIndexInsert(
   ia ODCIIndexInfo,
   ridlist ODCIRidList,
   newvallist <span class="italic">varray_of_column_type</span>,
   env ODCIEnv) 
RETURN NUMBER
</pre></td>
<td class="cellalignment1243" headers="r3c1-t13 r1c2-t13">Inserts a set of rows</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t14">Parameter</th>
<th class="cellalignment1247" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t14" headers="r1c1-t14">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t14 r1c2-t14">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t14" headers="r1c1-t14">
<pre>
rid
</pre></td>
<td class="cellalignment1243" headers="r3c1-t14 r1c2-t14">The row identifier of the new row in the table</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t14" headers="r1c1-t14">
<pre>
newval
</pre></td>
<td class="cellalignment1243" headers="r4c1-t14 r1c2-t14">The value of the indexed column in the inserted row</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t14" headers="r1c1-t14">
<pre>
ridlist
</pre></td>
<td class="cellalignment1243" headers="r5c1-t14 r1c2-t14">A varray (maximum size <code>32767</code>) containing the list of rowids for the rows being inserted into the base table</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t14" headers="r1c1-t14">
<pre>
newvallist
</pre></td>
<td class="cellalignment1243" headers="r6c1-t14 r1c2-t14">A varray (maximum size <code>32767</code>) containing the list of values being inserted into the indexed column in the base table; these entries have a one-to-one correspondence with the entries in <code>ridlist</code></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t14" headers="r1c1-t14">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r7c1-t14 r1c2-t14">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5062"></a>Returns</p>
<p><code>ODCIConst</code><code>.Success</code> on success, or <code>ODCIConst.Error</code> on error.</p>
<p class="subhead1"><a id="ADDCI5063"></a>Usage Notes</p>
<ul>
<li>
<p>This function should be implemented as a <code>STATIC</code> type method.</p>
</li>
<li>
<p>This method should insert index data corresponding to the row or set of rows passed in into the appropriate tables or files storing index data. A <code>NULL</code> value in <code>ridlist</code> indicates the end of the varray.</p>
</li>
<li>
<p>If the indextype is defined <code>WITH ARRAY DML</code>, a batch of rows can be inserted into the table. In this case, <a href="#i76892">ODCIIndexInsert()</a> is invoked using the second of the two syntax synopses. Otherwise, the single-row syntax is used.</p>
</li>
<li>
<p>Note that the index partition object identifier <code>ODCIIndexInfo.IndexPartitionIden</code> and the base table partition physical identifier <code>ODCIIndexInfo.IndexCols(1).TablePartitionIden</code> is passed in for local domain index. The indextype must use the new DML syntax using the partition number and the provided <code>SYS_OP_DOBJTOPNUM</code> function to insert into the storage system partitioned table:</p>
<pre>
INSERT INTO SP PARTITION (
   SYS_OP_DOBJTOPNUM(
      base_table_name, 
      :tab_physical_partid))
VALUES(&hellip;);
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i78634"></a><a id="ADDCI5064"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexStart()</h3>
<p>Invoked to start the evaluation of an operator on an indexed column.</p>
<p class="subhead1"><a id="ADDCI5065"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexStart(
   sctx IN OUT &lt;impltype&gt;, 
   ia ODCIIndexInfo, 
   pi ODCIPredInfo, 
   qi ODCIQueryInfo, 
   strt &lt;opbndtype&gt;, 
   stop &lt;opbndtype&gt;, 
   &lt;valargs&gt;, 
   env ODCIEnv)
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t15">Parameter</th>
<th class="cellalignment1247" id="r1c2-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t15" headers="r1c1-t15">
<pre>
sctx(IN)
</pre></td>
<td class="cellalignment1243" headers="r2c1-t15 r1c2-t15">The value of the scan context returned by some previous related query-time call (such as the corresponding ancillary operator, if invoked before the primary operator); <code>NULL</code> otherwise</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t15" headers="r1c1-t15">
<pre>
sctx(OUT)
</pre></td>
<td class="cellalignment1243" headers="r3c1-t15 r1c2-t15">The context that is passed to the next query-time call; the next query-time call is to <a href="#i76798">ODCIIndexFetch()</a></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t15" headers="r1c1-t15">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r4c1-t15 r1c2-t15">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t15" headers="r1c1-t15">
<pre>
pi
</pre></td>
<td class="cellalignment1243" headers="r5c1-t15 r1c2-t15">Contains information about the operator predicate</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t15" headers="r1c1-t15">
<pre>
qi
</pre></td>
<td class="cellalignment1243" headers="r6c1-t15 r1c2-t15">Contains query information (hints plus list of ancillary operators referenced)</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t15" headers="r1c1-t15">
<pre>
strt
</pre></td>
<td class="cellalignment1243" headers="r7c1-t15 r1c2-t15">The start value of the bounds on the operator return value. The data type is identical to that of the operator's return value</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t15" headers="r1c1-t15">
<pre>
stop
</pre></td>
<td class="cellalignment1243" headers="r8c1-t15 r1c2-t15">The stop value of the bounds on the operator return value. The data type is identical to that of the operator's return value.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t15" headers="r1c1-t15">
<pre>
valargs
</pre></td>
<td class="cellalignment1243" headers="r9c1-t15 r1c2-t15">The value arguments of the operator invocation. The number and data types of these arguments are identical to those of the value arguments to the operator.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t15" headers="r1c1-t15">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r10c1-t15 r1c2-t15">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5066"></a>Returns</p>
<p><code>ODCIConst</code><code>.Success</code> on success, or <code>ODCIConst.Error</code> on error.</p>
<p class="subhead1"><a id="ADDCI5067"></a>Usage Notes</p>
<ul>
<li>
<p>The function should be implemented as a static method.</p>
</li>
<li>
<p><a href="#i78634">ODCIIndexStart()</a> is invoked to begin the evaluation of an operator on an indexed column. In particular, the following conditions hold:</p>
<ul>
<li>
<p>The first argument to the operator is a column which has a domain index defined on it.</p>
</li>
<li>
<p>The indextype of the domain index (specified in <code>ODCIIndexInfo</code> parameter) supports the current operator.</p>
</li>
<li>
<p>All other arguments to the operator are value arguments (literals) which are passed in through the <code>&lt;valargs&gt;</code> parameters.</p>
</li>
</ul>
</li>
<li>
<p>The <a href="#i78634">ODCIIndexStart()</a> method should initialize the index scan as needed (using the operator-related information in the <code>pi</code> argument) and prepare for the subsequent invocations of <a href="#i76798">ODCIIndexFetch()</a>.</p>
</li>
<li>
<p>The <code>strt</code> and <code>stop</code> parameters, with the <code>bndflg</code> value in <code>ODCIPredInfo</code> parameter, specify the range of values within which the operator return value should lie.</p>
</li>
<li>
<p>Bounds for operator return values are specified as follows:</p>
<ul>
<li>
<p>If the predicate to be evaluated is of the form <code>op</code> <code>LIKE</code> <code>val</code>, the <code>ODCIIndexPrefixMatch</code> flag is set. In this case, the start key contains the value <code>&lt;val&gt;</code> and the stop key value is irrelevant.</p>
</li>
<li>
<p>If the predicate to be evaluated is of the form <code>op</code> = <code>val</code>, the <code>ODCIIndexExactMatch</code> flag is set. In this case, the start key contains the value <code>&lt;val&gt;</code> and the stop key value is irrelevant.</p>
</li>
<li>
<p>If the predicate to be evaluated is of the form <code>op</code> &gt; <code>val</code>, <code>startkey</code> contains the value <code>&lt;val&gt;</code> and stop key value is set to <code>NULL</code>. If the predicate is of the form <code>op</code> &gt;= <code>&lt;val&gt;</code>, the flag <code>ODCIIndexIncludeStart</code> is also set.</p>
</li>
<li>
<p>If the predicate to be evaluated is of the form <code>op</code> <code>&lt; val</code>, stop key contains the value &lt;val&gt; and the start key value is set to <code>NULL</code>. If the predicate is of the form <code>op</code> <code>&lt;= val</code>, the flag <code>ODCIIndexIncludeStop</code> is also set.</p>
</li>
</ul>
</li>
<li>
<p>A context value can be returned to Oracle (through the <code>SELF</code> argument) which is then passed back to the next query-time call. The next call is to <a href="#i76798">ODCIIndexFetch()</a> if the evaluation continues, or to <a href="#i78634">ODCIIndexStart()</a> if the evaluation is restarted. The context value can be used to store the entire evaluation state or just a handle to the memory containing the state.</p>
</li>
<li>
<p>Note that if the same indextype supports multiple operators with different signatures, multiple <a href="#i78634">ODCIIndexStart()</a> methods must be implemented, one for each distinct combination of value argument data types. For example, if an indextype supports three operators:</p>
<ol>
<li>
<p><code>op1(number, number)</code></p>
</li>
<li>
<p><code>op1(varchar2, varchar2)</code></p>
</li>
<li>
<p><code>op2(number, number)</code></p>
</li>
</ol>
<p>two <code>ODCIIndexStart</code> routines must be implemented:</p>
<ul>
<li>
<p><code>ODCIIndexStart(...., NUMBER)</code>&mdash; handles cases (1) and (3) which has a <code>NUMBER</code> value argumen<code>t</code></p>
</li>
<li>
<p><code>ODCIIndexStart(...., VARCHAR2)</code>&mdash; handles case (2) which has a <code>VARCHAR2</code> value argument</p>
</li>
</ul>
</li>
<li>
<p>The query information in <code>qi</code> parameter can be used to optimize the domain index scan, if possible. The query information includes hints that have been specified for the query and the list of relevant ancillary operators referenced in the query block.</p>
</li>
<li>
<p>The index partition object identifier <code>ODCIIndexInfo.IndexPartitionIden</code> and the base table partition physical identifier <code>ODCIIndexInfo.IndexCols(1).TablePartitionIden</code> is passed in for local domain index. The indextype must use the new SQL syntax using the partition number and the provided <code>SYS_OP_DOBJTOPNUM</code> function to query the corresponding partition of the storage system partitioned table:</p>
<pre>
SELECT FROM SP PARTITION(
   SYS_OP_DOBJTOPNUM(
   base_table_name, 
   :tab_physical_partid)) 
WHERE ...;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i77033"></a><a id="ADDCI5068"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexUpdate()</h3>
<p>Invoked when a row is updated in a table that has a defined domain index on one or more of its columns.</p>
<p class="subhead1"><a id="ADDCI5069"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexUpdate( 
   ia ODCIIndexInfo, 
   rid VARCHAR2, 
   oldval <span class="italic">icoltype</span>, 
   newval <span class="italic">icoltype</span>, 
   env ODCIEnv)
RETURN NUMBER
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t16">Parameter</th>
<th class="cellalignment1247" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t16" headers="r1c1-t16">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t16 r1c2-t16">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t16" headers="r1c1-t16">
<pre>
rid
</pre></td>
<td class="cellalignment1243" headers="r3c1-t16 r1c2-t16">The row identifier of the updated row</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t16" headers="r1c1-t16">
<pre>
oldval
</pre></td>
<td class="cellalignment1243" headers="r4c1-t16 r1c2-t16">The value of the indexed column before the update. The data type is identical to that of the indexed column.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t16" headers="r1c1-t16">
<pre>
newval
</pre></td>
<td class="cellalignment1243" headers="r5c1-t16 r1c2-t16">The value of the indexed column after the update. The data type is identical to that of the indexed column.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t16" headers="r1c1-t16">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r6c1-t16 r1c2-t16">The environment handle passed to the routine</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5070"></a>Returns</p>
<p><code>ODCIConst.Success</code> on success, or <code>ODCIConst.Error</code> on error.</p>
<p class="subhead1"><a id="ADDCI5071"></a>Usage Notes</p>
<ul>
<li>
<p>The function should be implemented as a <code>static</code> type method.</p>
</li>
<li>
<p>This method should update the tables or files storing the index data for the updated row.</p>
</li>
<li>
<p>In addition to a SQL <code>UPDATE</code> statement, a LOB value can be updated through a variety of <code>WRITE</code> interfaces (see <a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>). If a domain index is defined on a <code>LOB</code> column or an object type containing a <code>LOB</code> attribute, the <code>ODCIIndexUpdate</code> routine is called when a LOB locator is implicitly or explicitly closed after one or more write operations.</p>
</li>
<li>
<p>The index partition object identifier, <code>ODCIIndexInfo.IndexPartitionIden</code>, and the base table partition physical identifier, <code>ODCIIndexInfo.IndexCols(1).TablePartitionIden</code>, is passed in for local domain indexes. The indextype must use the new DML syntax with the partition number, and the provided <code>DATAOBJ_TO_PARTITION()</code> function to update data in the storage system partitioned table:</p>
<pre>
UPDATE SP PARTITION 
   (DATAOBJ_TO_PARTITION(
      base_table_name, :tab_physical_partid)) 
   VALUES(&hellip;) SET val = :newval WHERE rowid + :rowid;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHEDHCCB"></a><a id="ADDCI5072"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">ODCIIndexUpdPartMetadata()</h3>
<p>Invoked during partition maintenance operations. Patches the indextype metadata tables to correctly reflect the partition maintenance operation.</p>
<p class="subhead1"><a id="ADDCI5073"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexUpdPartMetadata(
   ia ODCIIndexInfo,
   palist ODCIPartInfoList,
   env ODCIEnv) 
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t17">Parameter</th>
<th class="cellalignment1247" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t17" headers="r1c1-t17">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t17 r1c2-t17">The information about the domain index; does not contain partition-specific information</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t17" headers="r1c1-t17">
<pre>
palist
</pre></td>
<td class="cellalignment1243" headers="r3c1-t17 r1c2-t17">The information about the dropped or added partitions</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t17" headers="r1c1-t17">
<pre>
env
</pre></td>
<td class="cellalignment1243" headers="r4c1-t17 r1c2-t17">The environment handle</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5074"></a>Usage Notes</p>
<ul>
<li>
<p>This method should be implemented as a <code>STATIC</code> type method.</p>
</li>
<li>
<p>When an indextype is specified with the <code>SYSTEM MANAGED</code> approach, this method is invoked on the local domain index of this indextype during partition management operations.</p>
</li>
<li>
<p>SQL DDLs are not allowed in this method.</p>
</li>
<li>
<p>The indextype should update its metadata mapping specific to the partitions, if any.</p>
</li>
<li>
<p>The <code>palist</code> argument contains a list of partitions that should be dropped or added. For example, if the base table operation is <code>ALTER TABLE SPLIT PARTITTION P1 INTO P11 AND P12</code>, then the <code>palist</code> would have information about <code>3</code> partitions: <code>P1</code> (drop), <code>P11</code>(add) and <code>P12</code>(add), along with their index partition names and index partition object identifiers.</p>
</li>
<li>
<p>If the <a href="#CHEDHCCB">ODCIIndexUpdPartMetadata()</a> call raises or returns an error, then the partition management operation on the base table is rolled back.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDBJBBB"></a><a id="ADDCI5075"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexUtilCleanup()</h3>
<p>Cleans up temporary states created by <a href="#CHDGJAGF">ODCIIndexUtilGetTableNames()</a>. See <a href="#CHDGJAGF">ODCIIndexUtilGetTableNames()</a> for further information.</p>
<p class="subhead1"><a id="ADDCI5076"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexUtilCleanup (
   context  PLS_INTEGER)
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t18">Parameter</th>
<th class="cellalignment1247" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t18" headers="r1c1-t18">
<pre>
context
</pre></td>
<td class="cellalignment1243" headers="r2c1-t18 r1c2-t18">The number created by <a href="#CHDGJAGF">ODCIIndexUtilGetTableNames()</a>that uniquely identifies state information for a particular index.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5077"></a>Usage Notes</p>
<ul>
<li>
<p>The procedure should be implemented as a static type method.</p>
</li>
<li>
<p><a href="#CHDBJBBB">ODCIIndexUtilCleanup()</a> deletes any temporary state associated with the parameter context.</p>
</li>
<li>
<p>Exceptions raised by <a href="#CHDBJBBB">ODCIIndexUtilCleanup()</a> are ignored by its caller.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDGJAGF"></a><a id="ADDCI5078"></a>
<div class="sect2">
<h3 class="sect2">ODCIIndexUtilGetTableNames()</h3>
<p>Determines if the secondary tables of the domain index should be exported/imported. By default, secondary objects of the domain are not imported or exported. However, if this interface and <a href="#CHDBJBBB">ODCIIndexUtilCleanup()</a> are present, the system invokes them.</p>
<p>If this interface is implemented, your application can also invoke it for transportable tablespace operations.</p>
<p class="subhead1"><a id="ADDCI5079"></a>Syntax</p>
<pre>
FUNCTION ODCIIndexUtilGetTableNames(
   ia sys.odciindexinfo, 
   read_only PLS_INTEGER, 
   version varchar2, 
   context OUT PLS_INTEGER)
RETURN BOOLEAN
</pre>
<div class="inftblinformal">
<table class="cellalignment1250" title="parameter(s) of the function" summary="Parameters and their descriptions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t19">Parameter</th>
<th class="cellalignment1247" id="r1c2-t19">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t19" headers="r1c1-t19">
<pre>
ia
</pre></td>
<td class="cellalignment1243" headers="r2c1-t19 r1c2-t19">Contains information about the index and the indexed column</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t19" headers="r1c1-t19">
<pre>
read_only
</pre></td>
<td class="cellalignment1243" headers="r3c1-t19 r1c2-t19">Specify 1 if the encompassing transaction is read-only, meaning no writes allowed. Otherwise 0.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t19" headers="r1c1-t19">
<pre>
version
</pre></td>
<td class="cellalignment1243" headers="r4c1-t19 r1c2-t19">Version of export making the call.</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t19" headers="r1c1-t19">
<pre>
context
</pre></td>
<td class="cellalignment1243" headers="r5c1-t19 r1c2-t19">A unique number that is used by <a href="#CHDBJBBB">ODCIIndexUtilCleanup()</a> to facilitate the clean up of any state held open between <a href="#CHDGJAGF">ODCIIndexUtilGetTableNames()</a> and <a href="#CHDBJBBB">ODCIIndexUtilCleanup()</a></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead1"><a id="ADDCI5080"></a>Returns</p>
<p><code>TRUE</code> if the domain indexes' secondary tables should be exported/imported. Otherwise, the function returns <code>FALSE</code>.</p>
<p class="subhead1"><a id="ADDCI5081"></a>Usage Notes</p>
<ul>
<li>
<p>This function should be implemented as a static type method.</p>
</li>
<li>
<p>This function should return <code>TRUE</code> or <code>FALSE</code> based on whether the secondary tables should be exported/imported.</p>
</li>
<li>
<p>This function should return <code>TRUE</code> or <code>FALSE</code> based on whether the secondary tables should be transported. Secondary objects other than tables do not participate in transportable tablespaces. They must be recreated on the import side when the <a href="#i78714">ODCIIndexCreate()</a> method is invoked with the <code>ODCI_INDEX_TRANS_TBLSPC</code> bit set in the <code>ODCIIndexInfo.IndexInfoFlags</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1236">
<tr>
<td class="cellalignment1243">
<table class="cellalignment1241">
<tr>
<td class="cellalignment1240"><a href="ext_types_ref.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1240"><a href="ext_opt_ref.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1245">
<table class="cellalignment1239">
<tr>
<td class="cellalignment1240"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1240"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1240"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1240"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1240"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1240"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
