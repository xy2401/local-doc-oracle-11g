<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using Pipelined and Parallel Table Functions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2010-03-08T13:16:27Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Cartridge Developer's Guide" />
<meta name="dcterms.identifier" content="E10765-02" />
<meta name="dcterms.isVersionOf" content="ADDCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="cart_services.htm" title="Previous" type="text/html" />
<link rel="Next" href="cart_design.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10765.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">22/36</span> <!-- End Header --><a id="CECGHGFH"></a><a id="ADDCI2140"></a><a id="i1007118"></a>
<h1 class="chapter"><span class="secnum">13</span> Using Pipelined and Parallel Table Functions</h1>
<p>This chapter describes table functions. It also explains the generic data types <code>ANYTYPE</code>, <code>ANYDATA</code>, and <code>ANYDATASET</code>, which are likely to be used with table functions.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CHDIIFEG">Overview of Table Functions</a></p>
</li>
<li>
<p><a href="#CHDCIEJG">Table Function Concepts</a></p>
</li>
<li>
<p><a href="#CHDJEGHC">Pipelined Table Functions</a></p>
</li>
<li>
<p><a href="#i1004978">Parallel Table Functions</a></p>
</li>
<li>
<p><a href="#i1005103">Input Data Streaming for Table Functions</a></p>
</li>
<li>
<p><a href="#CHDEACJF">Creating Domain Indexes in Parallel</a></p>
</li>
<li>
<p><a href="#i1005159">Transient and Generic Types</a></p>
</li>
</ul>
<a id="CHDIIFEG"></a><a id="ADDCI4677"></a>
<div class="sect1">
<h2 class="sect1">Overview of Table Functions</h2>
<p><a id="ABC1009439"></a>Table functions are functions that produce a collection of rows (either a nested table or a varray) that can be queried like a physical database table. You use a table function like the name of a database table, in the <code>FROM</code> clause of a query.</p>
<p>A table function can take a collection of rows as input. An input collection parameter can be either a collection type or a <code>REF CURSOR</code>.</p>
<p>Execution of a table function can be parallelized, and returned rows can be streamed directly to the next process without intermediate staging. Rows from a collection returned by a table function can also be pipelined; this means that they are iteratively returned as they are produced, instead of being returned in a single batch after all processing of the table function's input is completed.</p>
<p>Streaming, pipelining, and parallel execution of table functions can improve performance in the followingmanner:</p>
<ul>
<li>
<p>By enabling multithreaded, concurrent execution of table functions</p>
</li>
<li>
<p>By eliminating intermediate staging between processes</p>
</li>
<li>
<p>By improving query response time: With non-pipelined table functions, the entire collection returned by a table function must be constructed and returned to the server before the query can return a single result row. Pipelining enables rows to be returned iteratively, as they are produced. This also reduces the memory that a table function requires, as the object cache does not have to materialize the entire collection.</p>
</li>
<li>
<p>By iteratively providing result rows from the collection returned by a table function as the rows are produced instead of waiting until the entire collection is staged in tables or memory and then returning the entire collection</p>
</li>
</ul>
<p><a href="#CIHHJFCF">Figure 13-1</a> shows a typical data-processing scenario in which data goes through several (in this case, three) transformations, implemented by table functions, before finally being loaded into a database. In this scenario, the table functions are not parallelized, and the entire result collection must be staged after each transformation.</p>
<div class="figure">
<p class="titleinfigure"><a id="CIHHJFCF"></a><a id="ADDCI4678"></a>Figure 13-1 Typical Data Processing with Unparallelized, Unpipelined Table Functions</p>
<img width="515" height="94" src="img/addci044.gif" alt="Description of Figure 13-1 follows" title="Description of Figure 13-1 follows" /><br />
<a id="sthref540" href="img_text/addci044.htm">Description of "Figure 13-1 Typical Data Processing with Unparallelized, Unpipelined Table Functions"</a><br />
<br /></div>
<!-- class="figure" -->
<p>By contrast, <a href="#i1006439">Figure 13-2</a> shows how streaming and parallel execution can streamline the same scenario.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006439"></a><a id="ADDCI4679"></a>Figure 13-2 Data Processing Using Pipelining and Parallel Execution</p>
<img width="509" height="114" src="img/addci045.gif" alt="Description of Figure 13-2 follows" title="Description of Figure 13-2 follows" /><br />
<a id="sthref541" href="img_text/addci045.htm">Description of "Figure 13-2 Data Processing Using Pipelining and Parallel Execution"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="CHDCIEJG"></a><a id="ADDCI4680"></a>
<div class="sect1">
<h2 class="sect1">Table Function Concepts</h2>
<p>This section describes table functions and introduces some concepts related to pipelining and parallel execution of table functions.</p>
<a id="ADDCI4681"></a>
<div class="sect2"><a id="sthref542"></a>
<h3 class="sect2">Table Functions</h3>
<p>Table functions return a collection type instance and can be queried like a table by calling the function in the <code>FROM</code> clause of a query. Table functions use the <code>TABLE</code> keyword.</p>
<p>The following example shows a table function <code>GetBooks</code> that takes a <code>CLOB</code> as input and returns an instance of the collection type <code>BookSet_t</code>. The <code>CLOB</code> column stores a catalog listing of books in some format (either proprietary or following a standard such as XML). The table function returns all the catalogs and their corresponding book listings. The collection type <code>BookSet_t</code> is defined in <a href="#CIHBGIFJ">Example 13-1</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHBGIFJ"></a><a id="ADDCI4682"></a>Example 13-1 Creating a Collection Type</p>
<pre>
CREATE TYPE Book_t AS OBJECT
( name VARCHAR2(100),
  author VARCHAR2(30),
  abstract VARCHAR2(1000));

CREATE TYPE BookSet_t AS TABLE OF Book_t;
</pre></div>
<!-- class="example" -->
<p>The <code>CLOB</code>s are stored in a table <code>Catalogs</code>, as demonstrated in <a href="#CIHECFFI">Example 13-2</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHECFFI"></a><a id="ADDCI4683"></a>Example 13-2 Storing a Clob in a Table</p>
<pre>
CREATE TABLE Catalogs
( name VARCHAR2(30), 
  cat CLOB);
</pre></div>
<!-- class="example" -->
<p>Function <code>GetBooks()</code> is defined in <a href="#CIHBIIEH">Example 13-3</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHBIIEH"></a><a id="ADDCI4684"></a>Example 13-3 Creating a Function that Returns a Collection Type</p>
<pre>
CREATE FUNCTION GetBooks(a CLOB) RETURN BookSet_t;
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#CIHEJHJB">Example 13-4</a> returns all the catalogs and their corresponding book listings.</p>
<div class="example">
<p class="titleinexample"><a id="CIHEJHJB"></a><a id="ADDCI4685"></a>Example 13-4 Using a Collection Type in a Query</p>
<pre>
SELECT c.name, Book.name, Book.author, Book.abstract
  FROM Catalogs c, TABLE(GetBooks(c.cat)) Book;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4686"></a>
<div class="sect2"><a id="sthref543"></a>
<h3 class="sect2">Pipelined Table Functions</h3>
<p>Data is said to be pipelined if it is consumed by a consumer (transformation) as soon as the producer (transformation) produces it, without being staged in tables or a cache before being input to the next transformation.</p>
<p>Pipelining enables a table function to return rows faster and can reduce the memory required to cache a table function's results.</p>
<p>A pipelined table function can return the table function's result collection in subsets. The returned collection behaves like a stream that can be fetched from on demand. This makes it possible to use a table function like a virtual table.</p>
<p>Pipelined table functions can be implemented in two ways:</p>
<ul>
<li>
<p>In the native PL/SQL approach, the consumer and producers can run on separate execution threads (either in the same or different process context) and communicate through a pipe or queuing mechanism. This approach is similar to co-routine execution.</p>
</li>
<li>
<p>In the interface approach, the consumer and producers run on the same execution thread. Producer explicitly returns the control back to the consumer after producing a set of results. In addition, the producer caches the current state so that it can resume where it left off when the consumer invokes it again.</p>
<p>The interface approach requires you to implement a set of well-defined interfaces in a procedural language.</p>
</li>
</ul>
<p>The co-routine execution model provides a simpler, native PL/SQL mechanism for implementing pipelined table functions, but this model cannot be used for table functions written in C or Java. The interface approach, on the other hand, can. The interface approach requires the producer to save the current state information in a context object before returning so that this state can be restored on the next invocation.</p>
<p>In the rest of this chapter, the term <span class="italic">table function</span> is used to refer to a <span class="italic">pipelined</span> table function&mdash; a table function that returns a collection in an iterative, pipelined way.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4687"></a>
<div class="sect2"><a id="sthref544"></a>
<h3 class="sect2">Pipelined Table Functions with REF CURSOR Arguments</h3>
<p>A <a id="sthref545"></a>pipelined table function can accept any argument that regular functions accept. A table function that accepts a <code><a id="sthref546"></a>REF CURSOR</code> as an argument can serve as a transformation function. That is, it can use the <code>REF CURSOR</code> to fetch the input rows, perform some transformation on them, and then pipeline the results out (using either the interface approach or the native PL/SQL approach).</p>
<p>For example, the following code sketches the declarations that define a <code>StockPivot</code> function. This function converts a row of the type (<code>Ticker, OpenPrice, ClosePrice</code>) into two rows of the form (<code>Ticker, PriceType, Price</code>). Calling <code>StockPivot</code> for the row (<code>"ORCL", 41, 42</code>) generates two rows: (<code>"ORCL", "O", 41</code>) and (<code>"ORCL", "C", 42</code>).</p>
<p>Input data for the table function might come from a source such as table <code>StockTable</code>:</p>
<pre>
CREATE TABLE StockTable (
  ticker VARCHAR(4),
  openprice NUMBER,
  closeprice NUMBER
);
</pre>
<p>The declarations are in <a href="#CIHEGADE">Example 13-5</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHEGADE"></a><a id="ADDCI4688"></a>Example 13-5 Declaring a Pipelined Table Function with REF CURSOR Arguments</p>
<pre>
-- Create the types for the table function's output collection 
-- and collection elements

CREATE TYPE TickerType AS OBJECT 
(
  ticker VARCHAR2(4),
  PriceType VARCHAR2(1),
  price NUMBER
);

CREATE TYPE TickerTypeSet AS TABLE OF TickerType;

-- Define the ref cursor type

CREATE PACKAGE refcur_pkg IS
  TYPE refcur_t IS REF CURSOR RETURN StockTable%ROWTYPE;
END refcur_pkg;
/

-- Create the table function

CREATE FUNCTION StockPivot(p refcur_pkg.refcur_t) RETURN TickerTypeSet
PIPELINED ... ;
/
</pre></div>
<!-- class="example" -->
<p><a href="#CIHIGGCC">Example 13-6</a> uses the <code>StockPivot</code> table function.</p>
<div class="example">
<p class="titleinexample"><a id="CIHIGGCC"></a><a id="ADDCI4689"></a>Example 13-6 Using a Pipelined Table Function with REF CURSOR Arguments</p>
<pre>
SELECT * FROM TABLE(StockPivot(CURSOR(SELECT * FROM StockTable)));
</pre></div>
<!-- class="example" -->
<p>In the preceding query, the pipelined table function <code>StockPivot</code> fetches rows from the <code>CURSOR</code> subquery <code>SELECT * FROM StockTable</code>, performs the transformation, and pipelines the results back to the user as a table. The function produces two output rows (collection elements) for each input row.</p>
<p>Note that when a <code>CURSOR</code> subquery is passed from SQL to a <code>REF CURSOR</code> function argument as in the preceding example, the referenced cursor is open when the function begins executing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pipelined_example.htm#CEGBCFJF">Chapter 17, "Pipelined Table Functions: Interface Approach Example"</a> for a complete implementation of this table function using the interface approach, in both C and Java.</div>
<a id="ADDCI4690"></a>
<div class="sect3"><a id="sthref547"></a>
<h4 class="sect3">Errors and Restrictions</h4>
<p>These cursor operations are not allowed for <code>REF CURSOR</code> variables based on table functions: <code>SELECT FOR UPDATE</code>, and <code>WHERE CURRENT OF</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4691"></a>
<div class="sect2"><a id="sthref548"></a>
<h3 class="sect2">Parallel Execution of Table Functions</h3>
<p>With <a id="sthref549"></a>parallel execution of a function that appears in the <code>SELECT</code> list, execution of the function is pushed down to and conducted by multiple slave scan processes. These each execute the function on a segment of the function's input data.</p>
<p>For example, the query</p>
<pre>
SELECT f(col1) FROM tab;
</pre>
<p>is parallelized if <code>f</code> is a pure function. The SQL executed by a slave scan process is similar to:</p>
<pre>
SELECT f(col1) FROM tab WHERE ROWID BETWEEN :b1 AND :b2;
</pre>
<p>Each slave scan operates on a range of rowids and applies function <code>f</code> to each contained row. Function <code>f</code> is then executed by the scan processes; it does not run independently of them.</p>
<p>Unlike a function that appears in the <code>SELECT</code> list, a table function is called in the <code>FROM</code> clause and returns a collection. This affects the way that table function input data is partitioned among slave scans because the partitioning approach must be appropriate for the operation that the table function performs. (For example, an <code>ORDER BY</code> operation requires input to be range-partitioned, whereas a <code>GROUP BY</code> operation requires input to be hash partitioned.)</p>
<p>A table function itself specifies in its declaration the partitioning approach that is appropriate for it, as described in <a href="#i1005017">"Input Data Partitioning"</a>. The function is then executed in a two-stage operation. First, one set of slave processes partitions the data as directed in the function's declaration; then a second set of slave scans executes the table function in parallel on the partitioned data. The table function in the following query has a <code>REF CURSOR</code> parameter:</p>
<pre>
SELECT * FROM TABLE(f(CURSOR(SELECT * FROM tab)));
</pre>
<p>The scan is performed by one set of slave processes, which redistributes the rows (based on the partitioning method specified in the function declaration) to a second set of slave processes that actually executes function <code>f</code> in parallel.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJEGHC"></a><a id="ADDCI4692"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Pipelined Table Functions</h2>
<p>This section discusses issues involved in implementing pipelined table functions.</p>
<a id="ADDCI4693"></a>
<div class="sect2"><a id="sthref550"></a>
<h3 class="sect2">Implementation Choices for Pipelined Table Functions</h3>
<p>As noted previously, two approaches are supported for implementing <a id="sthref551"></a>pipelined table functions: the interface approach and the PL/SQL approach.</p>
<p>The interface approach requires the user to supply a type that implements a predefined Oracle interface consisting of start, fetch, and close operations. The type is associated with the table function when the table function is created. During query execution, the <code>fetch</code> method is invoked repeatedly to iteratively retrieve the results. With the interface approach, the methods of the implementation type associated with the table function can be implemented in any of the supported internal or external languages (including PL/SQL, C/C++, and Java).</p>
<p>With the PL/SQL approach, a single PL/SQL function includes a special instruction to pipeline results (single elements of the collection) out of the function instead of returning the whole collection as a single value. The native PL/SQL approach is simpler to implement because it requires writing only one PL/SQL function.</p>
<p>The approach used to implement pipelined table functions does not affect the way they are used. Pipelined table functions are used in SQL statements in exactly the same way regardless of the approach used to implement them.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4694"></a>
<div class="sect2"><a id="sthref552"></a>
<h3 class="sect2">Declarations of Pipelined Table Functions</h3>
<p>You declare a pipelined table function by specifying the <code>PIPELINED</code> keyword. This keyword indicates that the function returns rows iteratively. The return type of the pipelined table function must be a collection type (a nested table or a varray).</p>
<p><a href="#CIHCGIAE">Example 13-7</a> shows declarations of pipelined table functions implemented using the interface approach. The interface routines for functions <code>GetBooks</code> and <code>StockPivot</code> have been implemented in the types <code>BookMethods</code> and <code>StockPivotImpl</code>, respectively.</p>
<div class="example">
<p class="titleinexample"><a id="CIHCGIAE"></a><a id="ADDCI4695"></a>Example 13-7 Declaring Pipelined Table Functions for the Interface Approach</p>
<pre>
CREATE FUNCTION GetBooks(cat CLOB) RETURN BookSet_t PIPELINED USING BookMethods;

CREATE FUNCTION StockPivot(p refcur_pkg.refcur_t) 
  RETURN TickerTypeSet PIPELINED USING StockPivotImpl;
</pre></div>
<!-- class="example" -->
<p><a href="#CIHEIAEC">Example 13-8</a> shows declarations of the same table functions implemented using the native PL/SQL approach:</p>
<div class="example">
<p class="titleinexample"><a id="CIHEIAEC"></a><a id="ADDCI4696"></a>Example 13-8 Declaring Pipelined Table Functions for the Native PL/SQL Approach</p>
<pre>
CREATE FUNCTION GetBooks(cat CLOB) RETURN BookSet_t <span class="bold">PIPELINED IS</span> ...;

CREATE FUNCTION StockPivot(p refcur_pkg.refcur_t) RETURN TickerTypeSet
<span class="bold">PIPELINED IS...</span>;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4697"></a>
<div class="sect2"><a id="sthref553"></a>
<h3 class="sect2">Implementing the Native PL/SQL Approach</h3>
<p>In PL/SQL, the <code>PIPE ROW</code> statement causes a table function to pipe a row and continue processing. The statement enables a PL/SQL table function to return rows as soon as they are produced. This is demonstrated in <a href="#CIHDGJAF">Example 13-9</a>. For performance reasons, the PL/SQL run-time system provides the rows to the consumer in batches.</p>
<div class="example">
<p class="titleinexample"><a id="CIHDGJAF"></a><a id="ADDCI4698"></a>Example 13-9 Implementing a Pipelined Table Function for the Native PL/SQL Approach</p>
<pre>
CREATE FUNCTION StockPivot(p refcur_pkg.refcur_t) RETURN TickerTypeSet
PIPELINED IS
  out_rec TickerType := TickerType(NULL,NULL,NULL);
  in_rec p%ROWTYPE;
BEGIN
  LOOP
    FETCH p INTO in_rec; 
    EXIT WHEN p%NOTFOUND;
    -- first row
    out_rec.ticker := in_rec.Ticker;
    out_rec.PriceType := 'O';
    out_rec.price := in_rec.OpenPrice;
    PIPE ROW(out_rec);
    -- second row
    out_rec.PriceType := 'C';   
    out_rec.Price := in_rec.ClosePrice;
    PIPE ROW(out_rec);
  END LOOP;
  CLOSE p;
  RETURN;
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHDGJAF">Example 13-9</a>, the <code>PIPE ROW(out_rec)</code> statement pipelines data out of the PL/SQL table function.</p>
<p>The <code>PIPE ROW</code> statement may be used only in the body of pipelined table functions; an error is raised if it is used anywhere else. The <code>PIPE ROW</code> statement can be omitted for a pipelined table function that returns no rows.</p>
<p>A pipelined table function must have a <code>RETURN</code> statement that does not return a value. The <code>RETURN</code> statement transfers the control back to the consumer and ensures that the next fetch gets a <code>NO_DATA_FOUND</code> exception.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4699"></a>
<div class="sect2"><a id="sthref554"></a>
<h3 class="sect2">Pipelining Between PL/SQL Table Functions</h3>
<p>With serial execution, results are <a id="sthref555"></a>pipelined from one PL/SQL table function to another using an approach similar to co-routine execution. <a href="#CIHBGDJD">Example 13-10</a> pipelines results from function <code>g</code> to function <code>f</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHBGDJD"></a><a id="ADDCI4700"></a>Example 13-10 Pipelining Function Results from One Function to Another</p>
<pre>
SELECT * FROM TABLE(f(CURSOR(SELECT * FROM TABLE(g()))));
</pre></div>
<!-- class="example" -->
<p>Parallel execution works similarly, except that each function executes in a different process or set of processes.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4701"></a>
<div class="sect2"><a id="sthref556"></a>
<h3 class="sect2"><a id="sthref557"></a>Combining PIPE ROW with AUTONOMOUS_TRANSACTION</h3>
<p>Because table functions pass control back and forth to a calling routine as rows are produced, there is a restriction on combining table functions and <code>PRAGMA AUTONOMOUS_TRANSACTION</code>s. If a table function is part of an autonomous transaction, it must <code>COMMIT</code> or <code>ROLLBACK</code> before each <code>PIPE ROW</code> statement, to avoid an error in the calling subprogram.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4702"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref558"></a>
<h3 class="sect2">Implementing the Interface Approach</h3>
<p>To use the interface approach, you must define an implementation type that implements the <code>ODCITable</code> interface. This interface consists of start, fetch, and close routines whose signatures are specified by Oracle and which you implement as methods of the type.</p>
<p>Oracle invokes the methods to perform the following steps in the execution of a query that contains a table function:</p>
<ol>
<li>
<p>Start by initializing the scan context parameter, using the <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> function.</p>
</li>
<li>
<p>Fetch to produce a subset of the rows in the result collection. The <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> method is invoked as many times as necessary to return the entire collection.</p>
</li>
<li>
<p>Close and clean up (release memory and so on) using <a href="pipe_paral_tbl_ref.htm#CHDEIDHJ">ODCITableClose()</a> after the last <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a>.</p>
</li>
</ol>
<p>The <code>ODCITable</code> interface also defines two optional routines, <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> and <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a>, that are invoked at compilation time:</p>
<ul>
<li>
<p><a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> determines the structure of the data type the table function returns, in situations where this cannot be defined in a static manner.</p>
</li>
<li>
<p><a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> initializes the scan context parameter. If this method is implemented, the scan context it prepares is passed to the <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> routine, and the context is maintained between restarts of the table function. It also provides projection information and supports the return of transient anonymous types.</p>
</li>
</ul>
<a id="ADDCI4703"></a>
<div class="sect3"><a id="sthref559"></a>
<h4 class="sect3">Scan Context</h4>
<p>For the fetch method to produce the next set of rows, a table function must be able to maintain context between successive invocations of the interface routines to fetch another set of rows. This context, called the scan context, is defined by the attributes of the implementation type. A table function preserves the scan context by modeling it in an object instance of the implementation type.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4704"></a>
<div class="sect3"><a id="sthref560"></a>
<h4 class="sect3">Start Routine</h4>
<p>The start routine <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> is the first routine that is invoked to begin retrieving rows from a table function. This routine typically performs the setup needed for the scan, creating the scan context (as an object instance <code>sctx</code>) and returning it to Oracle. However, if <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> is implemented, it creates the scan context, which is then passed to the <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> routine. The arguments to the table function, specified by the user in the <code>SELECT</code> statement, are passed in as parameters to this routine.</p>
<p>Note that any <code>REF CURSOR</code> arguments of a table function must be declared as <code>SYS_REFCURSOR</code> type in the declaration of the <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a>. Ordinary <code>REF CURSOR</code> types cannot be used as formal argument types in <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a>. Ordinary <code>REF CURSOR</code> types can only be declared in a package, and types defined in a package cannot be used as formal argument types in a type method. To use a <code>REF CURSOR</code> type in <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a>, you must use the system-defined <code>SYS_REFCURSOR</code> type.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4705"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref561"></a>
<h4 class="sect3">Fetch Routine</h4>
<p>The fetch routine <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> is invoked one or more times by Oracle to retrieve all the rows in the table function's result set. The scan context is passed in as a parameter. This routine returns the next subset of one or more rows.</p>
<p>The fetch routine is called by Oracle repeatedly until all the rows have been returned by the table function. Returning more rows in each invocation of <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> reduces the number of fetch calls that must be made and thus improves performance. The table function should return a null collection to indicate that all rows have been returned.</p>
<p>The <code>nrows</code> parameter indicates the number of rows that are required to satisfy the current OCI call. For example, if the current OCI call is an <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> that requested <code>100</code> rows, and <code>20</code> rows have been returned, then the <code>nrows</code> parameter is equal to <code>80</code>. The fetch function is allowed to return a different number of rows. The main purpose of this parameter is to prevent <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> from returning more rows than actually required. If <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> returns more rows than the value of this parameter, the rows are cached and returned in subsequent <a href="pipe_paral_tbl_ref.htm#CHDDEEIB">ODCITableFetch()</a> calls, or they are discarded if the OCI statement handle is closed before they are all fetched.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4706"></a>
<div class="sect3"><a id="sthref562"></a>
<h4 class="sect3">Close Routine</h4>
<p>The close routine <a href="pipe_paral_tbl_ref.htm#CHDEIDHJ">ODCITableClose()</a> is invoked by Oracle after the last fetch invocation. The scan context is passed in as a parameter. This routine performs the necessary cleanup operations.</p>
<div class="figure">
<p class="titleinfigure"><a id="ADDCI4707"></a><a id="sthref563"></a>Figure 13-3 Flowchart of Table Function Row Source Execution</p>
<img width="266" height="349" src="img/addci046.gif" alt="Description of Figure 13-3 follows" title="Description of Figure 13-3 follows" /><br />
<a id="sthref564" href="img_text/addci046.htm">Description of "Figure 13-3 Flowchart of Table Function Row Source Execution"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="ADDCI4708"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref565"></a>
<h4 class="sect3">Describe Method</h4>
<p>Sometimes it is not possible to define the structure of the return type from the table function statically. If the shape of the rows is different in different queries, it may depend on the actual arguments with which the table function is invoked. Such table functions can be declared to return <code>AnyDataSet</code>. <code>AnyDataSet</code> is a generic collection type. It can be used to model any collection (of any element type) and has an associated set of APIs (both PL/SQL and C) that enable you to construct <code>AnyDataSet</code> instances and access the elements.</p>
<p>The following example shows a table function declared to return an <code>AnyDataSet</code> collection whose structure is not fixed at function creation time:</p>
<pre>
CREATE FUNCTION AnyDocuments(VARCHAR2) RETURN ANYDATASET 
PIPELINED USING DocumentMethods;
</pre>
<p>You can implement a <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> routine to determine the format of the elements in the result collection when the format depends on the actual parameters to the table function. <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> is invoked by Oracle at query compilation time to retrieve the specific type information. Typically, the routine uses the user arguments to determine the shape of the return rows. The format of elements in the returned collection is conveyed to Oracle by returning an instance of <code>AnyType</code>.</p>
<p>The <code>AnyType</code> instance specifies the actual structure of the returned rows of the specific query. Like <code>AnyDataSet</code>, <code>AnyType</code> has an associated set of PL/SQL and C interfaces with which to construct and access the metadata information.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1005159">"Transient and Generic Types"</a> for information on <code>AnyDataSet</code> and <code>AnyType</code></div>
<p>The query in <a href="#CIHCGJII">Example 13-11</a>, for an <code>AnyDocuments</code> function, returns information on either books or magazines.</p>
<div class="example">
<p class="titleinexample"><a id="CIHCGJII"></a><a id="ADDCI4709"></a>Example 13-11 Querying for AnyType Data</p>
<pre>
SELECT * FROM 
  TABLE(AnyDocuments('http://.../documents.xml')) x
  WHERE x.Abstract like '%internet%';
</pre></div>
<!-- class="example" -->
<p><a href="#CIHCEHGC">Example 13-12</a> is an implementation of the <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> method, which consults the DTD of the XML documents at the specified location to return the appropriate <code>AnyType</code> value, either a book or a magazine. The <code>AnyType</code> instance is constructed by invoking the constructor APIs with the field name and data type information.</p>
<div class="example">
<p class="titleinexample"><a id="CIHCEHGC"></a><a id="ADDCI4710"></a>Example 13-12 Implementing the ODCITableDescribe() Method</p>
<pre>
CREATE TYPE Mag_t AS OBJECT
(   name VARCHAR2(100),
    publisher VARCHAR2(30),
    abstract VARCHAR2(1000)
);

STATIC FUNCTION ODCITableDescribe(rtype OUT ANYTYPE, 
                                        url VARCHAR2)
IS BEGIN    
    Contact specified web server and retrieve document...
    Check XML doc schema to determine if books or mags...
    IF books THEN
        rtype=AnyType.AnyTypeGetPersistent('SYS','BOOK_T');
    ELSE
        rtype=AnyType.AnyTypeGetPersistent('SYS','MAG_T');
    END IF;
END;
</pre></div>
<!-- class="example" -->
<p>When Oracle invokes <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a>, it uses the type information that is returned in the <code>AnyType</code> <code>OUT</code> argument to resolve references in the command line, such as the reference to the <code>x.Abstract</code> attribute in <a href="#CIHCEHGC">Example 13-12</a>. This functionality is applicable only when the returned type is a named type, and therefore has named attributes.</p>
<p>Another feature of <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> is its ability to describe <code>SELECT</code> list parameters, such as using OCI interfaces, when executing a <code>SELECT *</code> query. The information retrieved reflects one <code>SELECT</code> list item for each top-level attribute of the type returned by <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a>.</p>
<p>Because the <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> method is called at compile time, the table function should have at least one argument that has a value at compile time, like a constant. By using the table function with different arguments, you can get different return types from the function, as demonstrated in <a href="#CIHCHGAB">Example 13-13</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHCHGAB"></a><a id="ADDCI4711"></a>Example 13-13 Using Functions that Return AnyType</p>
<pre>
-- Issue a query for books
SELECT x.Name, x.Author
FROM TABLE(AnyDocuments('Books.xml')) x;

-- Issue a query for magazines
SELECT x.Name, x.Publisher
FROM TABLE(AnyDocuments('Magazines.xml')) x;
</pre></div>
<!-- class="example" -->
<p>The <a href="pipe_paral_tbl_ref.htm#CHDDDAEB">ODCITableDescribe()</a> functionality is available only if the table function is implemented using the interface approach. A native PL/SQL implementation of a table function that returns <code>ANYDATASET</code> returns rows whose structure is opaque to the server.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4712"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref566"></a>
<h4 class="sect3">Prepare Method</h4>
<p><a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> is invoked at query compilation time. It generates and saves information to decrease the execution time of the query.</p>
<p>If you do not implement <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a>, <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> initializes the context each time it is called. However, if you do implement <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a>, it initializes the scan context, which is passed to the <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> when the query is executed, reducing startup time. In addition, when <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> is implemented, <a href="pipe_paral_tbl_ref.htm#CHDEIDHJ">ODCITableClose()</a> is called only one time during the query, rather than each time the table function is restarted. This has the following benefits:</p>
<ul>
<li>
<p>It decreases execution time by reducing the number of calls to <a href="pipe_paral_tbl_ref.htm#CHDEIDHJ">ODCITableClose()</a>.</p>
</li>
<li>
<p>It allows the scan context to be maintained between table function restarts.</p>
</li>
</ul>
<p><a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> also provides projection information to the table function. If you do not implement <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> for table functions that return collections of user-defined types (UDTs), your table function must set every attribute of the UDT of each element, because it has no way of knowing which attributes are used. In contrast, selecting from a regular table fetches only the required columns, which is naturally faster in most cases. However, if you do implement <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a>, it can build an array of attribute positions, record the return type information in an argument of type <code>ODCITabFuncInfo</code>, and save this information in the scan context, as described in <a href="#CIHEHBAJ">Example 13-14</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHEHBAJ"></a><a id="ADDCI4713"></a>Example 13-14 Building an Array of Attribute Positions and Save it in a Scan Context</p>
<pre>
CREATE TYPE SYS.ODCITabFuncInto AS OBJECT (
  Attrs SYS.ODCINumberList,
  RetType SYS.AnyType
);
</pre></div>
<!-- class="example" -->
<p>Implementing <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> also allows your table function to return transient anonymous types. <a href="pipe_paral_tbl_ref.htm#CHDDEFAB">ODCITablePrepare()</a> is called at the end of query compilation, so it can be passed the table descriptor object (TDO) built by the describe method. The describe method can build and return a transient anonymous TDO. Oracle transforms this TDO so that it can be used during query execution, and passes the transformed TDO to the prepare method in the <code>RetType</code> attribute. If the describe method returns a TDO for a type that is not anonymous, that TDO is identical to the transformed TDO. Thus, if a table function returns:</p>
<ul>
<li>
<p>A named collection type, the <code>RetType</code> attribute contains the TDO of this type.</p>
</li>
<li>
<p><code>AnyDataSet</code>, and the describe method returns a named type, the <code>RetType</code> attribute contains the TDO of the named type.</p>
</li>
<li>
<p><code>AnyDataSet</code>, and the describe method returns an anonymous type, Oracle transforms this type, and <code>RetType</code> contains the transformed TDO.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4714"></a>
<div class="sect2"><a id="sthref567"></a>
<h3 class="sect2">Querying Table Functions</h3>
<p>Pipelined <a id="sthref568"></a>table functions are used in the <code>FROM</code> clause of <code>SELECT</code> statements independently from implementation, either in native PL/SQL or through the interface approach. The result rows are retrieved by Oracle iteratively from the table function implementation, as demonstrated in <a href="#CIHJCECB">Example 13-15</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHJCECB"></a><a id="ADDCI4715"></a>Example 13-15 Using a Table Function to Iteratively Retrieve Rows</p>
<pre>
SELECT x.Ticker, x.Price 
FROM TABLE(StockPivot(CURSOR(SELECT * FROM StockTable))) x
WHERE x.PriceType='C';
</pre></div>
<!-- class="example" -->
<a id="ADDCI4716"></a>
<div class="sect3"><a id="sthref569"></a>
<h4 class="sect3">Multiple Calls to Table Functions</h4>
<p>Multiple invocations of a table function, either within the same query or in separate queries result in multiple executions of the underlying implementation. That is, in general, there is no buffering or reuse of rows, as demonstrated in <a href="#CIHJAEHD">Example 13-16</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHJAEHD"></a><a id="ADDCI4717"></a>Example 13-16 Using Multiple Invokations of a Table Function</p>
<pre>
SELECT * FROM TABLE(f(...)) t1, TABLE(f(...)) t2 
  WHERE t1.id = t2.id;
  
SELECT * FROM TABLE(f());

SELECT * FROM TABLE(f());
</pre></div>
<!-- class="example" -->
<p>However, if the output of a table function is determined solely by the values passed into it as arguments, such that the function always produces exactly the same result value for each respective combination of values passed in, you can declare the function <code>DETERMINISTIC</code>, and Oracle automatically buffers rows for it. Note, though, that the database has no way of knowing whether a function marked <code>DETERMINISTIC</code> really is <code>DETERMINISTIC</code>, and if one is not, results are unpredictable.</p>
</div>
<!-- class="sect3" -->
<a id="ADDCI4718"></a>
<div class="sect3"><a id="sthref570"></a>
<h4 class="sect3">PL/SQL</h4>
<p>PL/SQL <code>REF CURSOR</code> variables can be defined for queries over table functions, as demonstrated in <a href="#CIHJBDCA">Example 13-17</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHJBDCA"></a><a id="ADDCI4719"></a>Example 13-17 Defining REF CURSOR Variables for Table Function Queries</p>
<pre>
OPEN c FOR SELECT * FROM TABLE(f(...));
</pre></div>
<!-- class="example" -->
<p>Cursors over table functions have the same fetch semantics as ordinary cursors. <code>REF CURSOR</code> assignments based on table functions do not have special semantics.</p>
<p>However, the SQL optimizer does not optimize across PL/SQL statements; therefore, <a href="#CIHICDCB">Example 13-19</a> runs better than <a href="#CIHEAJDG">Example 13-18</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHEAJDG"></a><a id="ADDCI4720"></a>Example 13-18 Using a REF CURSOR Variable</p>
<pre>
BEGIN
    OPEN r FOR SELECT * FROM TABLE(f(CURSOR(SELECT * FROM tab)));
    SELECT * BULK COLLECT INTO rec_tab FROM TABLE(g(r));
END;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="CIHICDCB"></a><a id="ADDCI4721"></a>Example 13-19 Using a REF CURSOR Variable More Effectively</p>
<pre>
SELECT * FROM TABLE(g(CURSOR(SELECT * FROM
  TABLE(f(CURSOR(SELECT * FROM tab))))));
</pre></div>
<!-- class="example" -->
<pre>
</pre>
<p>Additionally, <a href="#CIHEAJDG">Example 13-18</a> is slower because of the overhead associated with executing two SQL statements, and because it does not take advantage of efficiencies realized by pipelining results between two functions, as <a href="#CIHICDCB">Example 13-19</a> does.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4722"></a>
<div class="sect2"><a id="sthref571"></a>
<h3 class="sect2">Performing DML Operations Inside Table Functions</h3>
<p>A table function must be declared with the autonomous transaction pragma in order for the function to execute DML statements. This pragma causes the function to execute in an autonomous transaction not shared by other processes, as demonstrated in <a href="#CIHIFFDH">Example 13-20</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHIFFDH"></a><a id="ADDCI4723"></a>Example 13-20 Declaring a Table Function with Autonomous Transaction Pragma</p>
<pre>
CREATE FUNCTION f(p SYS_REFCURSOR) return CollType PIPELINED IS
    PRAGMA AUTONOMOUS_TRANSACTION; 
BEGIN ... END;
</pre></div>
<!-- class="example" -->
<p>During parallel execution, each instance of the table function creates an independent transaction.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4724"></a>
<div class="sect2"><a id="sthref572"></a>
<h3 class="sect2">Performing DML Operations on Table Functions</h3>
<p>Table functions cannot be the target table in <code>UPDATE</code>, <code>INSERT</code>, or <code>DELETE</code> statements. For example, the following statements raise an error:</p>
<pre>
UPDATE F(CURSOR(SELECT * FROM tab)) SET col = value; 
INSERT INTO f(...) VALUES ('any', 'thing'); 
</pre>
<p>However, you can create a view over a table function and use <code>INSTEAD OF</code> triggers to update it, as in <a href="#CIHIEICC">Example 13-21</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHIEICC"></a><a id="ADDCI4725"></a>Example 13-21 Creating a View over a Table</p>
<pre>
CREATE VIEW BookTable AS 
  SELECT x.Name, x.Author
  FROM TABLE(GetBooks('data.txt')) x;
</pre></div>
<!-- class="example" -->
<p><a href="#CIHDDHDG">Example 13-22</a> demonstrates how an <code>INSTEAD OF</code> trigger is fired when the user inserts a row into the <code>BookTable</code> view:.</p>
<div class="example">
<p class="titleinexample"><a id="CIHDDHDG"></a><a id="ADDCI4726"></a>Example 13-22 How an INSTEAD OF Trigger is Fired when a Row is Inserted into a View</p>
<pre>
CREATE TRIGGER BookTable_insert
INSTEAD OF INSERT ON BookTable
REFERENCING NEW AS n
FOR EACH ROW
BEGIN
  ...
END;
INSERT INTO BookTable VALUES (...);
</pre></div>
<!-- class="example" -->
<p><code>INSTEAD OF</code> triggers can be defined for all DML operations on a view built on a table function.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4727"></a>
<div class="sect2"><a id="sthref573"></a>
<h3 class="sect2">Handling Exceptions in Table Functions</h3>
<p>Exception handling in table functions works just as it does with ordinary user-defined functions.</p>
<p>Some languages, such as C and Java, provide a mechanism for user-supplied exception handling. If an exception raised within a table function is handled, the table function executes the exception handler and continues processing. Exiting the exception handler takes control to the enclosing scope. If the exception is cleared, execution proceeds normally.</p>
<p>An unhandled exception in a table function causes the parent transaction to roll back.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1004978"></a><a id="ADDCI4728"></a>
<div class="sect1">
<h2 class="sect1">Parallel Table Functions</h2>
<p>For a <a id="sthref574"></a>table function to be executed in parallel, it must have a partitioned input parameter. Parallelism is turned on for a table function if, and only if, both the following conditions are met:</p>
<ul>
<li>
<p>The function has a <code>PARALLEL_ENABLE</code> clause in its declaration.</p>
</li>
<li>
<p>Exactly one <code>REF CURSOR</code> is specified with a <code>PARTITION BY</code> clause.</p>
<p>If the <code>PARTITION BY</code> clause is not specified for any input <code>REF CURSOR</code> as part of the <code>PARALLEL_ENABLE</code> clause, the SQL compiler cannot determine how to partition the data correctly.</p>
</li>
</ul>
<a id="ADDCI4729"></a>
<div class="sect2"><a id="sthref575"></a>
<h3 class="sect2">Inputting Data with Cursor Variables</h3>
<p>You can pass a set of rows to a PL/SQL function in a <code>REF CURSOR</code> parameter, as demonstrated in <a href="#CIHBBFBA">Example 13-23</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHBBFBA"></a><a id="ADDCI4730"></a>Example 13-23 Passing a Set of Rows to a PL/SQL Function in a REF CURSOR</p>
<pre>
FUNCTION f(p1 IN SYS_REFCURSOR) RETURN ... ;
</pre></div>
<!-- class="example" -->
<p>Results of a subquery can be passed to a function directly, as demonstrated in <a href="#CIHJHBGA">Example 13-24</a>. The <code>CURSOR</code> keyword is required to indicate that the results of a subquery should be passed as a <code>REF CURSOR</code> parameter.</p>
<div class="example">
<p class="titleinexample"><a id="CIHJHBGA"></a><a id="ADDCI4731"></a>Example 13-24 Directly Passing Results from a Subquery to a Function</p>
<pre>
SELECT * FROM TABLE(f(CURSOR(SELECT empno FROM tab)));
</pre></div>
<!-- class="example" -->
<a id="ADDCI4732"></a>
<div class="sect3"><a id="sthref576"></a>
<h4 class="sect3">Using Multiple REF CURSOR Input Variables</h4>
<p>PL/SQL functions can accept multiple <code>REF CURSOR</code> input variables, as demonstrated in <a href="#CIHIFIJG">Example 13-25</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHIFIJG"></a><a id="ADDCI4733"></a>Example 13-25 Passing a Set of Rows to a PL/SQL Function Through REF CURSOR</p>
<pre>
CREATE FUNCTION g(p1 pkg.refcur_t1, p2 pkg.refcur_t2) RETURN...
  PIPELINED ... ;
</pre></div>
<!-- class="example" -->
<p>Function <code>g</code> can be invoked as demonstrated in <a href="#CIHFJFEH">Example 13-26</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHFJFEH"></a><a id="ADDCI4734"></a>Example 13-26 Invoking a Function that Uses Several REF CURSOR Parameters</p>
<pre>
SELECT * FROM TABLE(g(CURSOR(SELECT empno FROM tab),
  CURSOR(SELECT * FROM emp));
</pre></div>
<!-- class="example" -->
<p>You can pass table function return values to other table functions by creating a <code>REF CURSOR</code> that iterates over the returned data, as demonstrated in <a href="#CIHEEJBG">Example 13-27</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHEEJBG"></a><a id="ADDCI4735"></a>Example 13-27 Using REF CURSOR to Pass Return Values Between Table Functions</p>
<pre>
SELECT * FROM TABLE(f(CURSOR(SELECT * FROM TABLE(g(...)))));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4736"></a>
<div class="sect3"><a id="sthref577"></a>
<h4 class="sect3">Explicitly Opening a REF CURSOR for a Query</h4>
<p>You can explicitly open a <code>REF CURSOR</code> for a query and pass it as a parameter to a table function, as demonstrated in <a href="#CIHJGDDE">Example 13-28</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHJGDDE"></a><a id="ADDCI4737"></a>Example 13-28 Explicitly Using a Query REF CURSOR as Table Function Parameter</p>
<pre>
BEGIN
  OPEN r FOR SELECT * FROM TABLE(f(...));
  -- Must return a single row result set.
  SELECT * INTO rec FROM TABLE(g(r));
END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4738"></a>
<div class="sect3"><a id="sthref578"></a>
<h4 class="sect3">PL/SQL REF CURSOR Arguments to Java and C/C++ Functions</h4>
<p>Parallel and pipelined table functions may be written in C/C++, Java, or PL/SQL. Unlike PL/SQL, C/C++ and Java do not support the <code>REF CURSOR</code> type, but you can still pass a <code>REF CURSOR</code> argument to C/C++ and Java functions.</p>
<p>If a table function is implemented as a C callout, then an <code>IN REF CURSOR</code> argument passed to the callout is automatically available as an executed OCI statement handle. You can use this handle like any other executed statement handle.</p>
<p>A <code>REF CURSOR</code> argument to a callout passed as an <code>IN OUT</code> parameter is converted to an executed statement handle on the way in to the callout, and the statement handle is converted back to a <code>REF CURSOR</code> on the way out. (The inbound and outbound statement handles may be different.)</p>
<p>If a <code>REF CURSOR</code> type is used as an <code>OUT</code> argument or a return type to a callout, then the callout must return the statement handle, which are converted to a <code>REF&nbsp;CURSOR</code> for the caller, as demonstrated in <a href="#CIHJGDDE">Example 13-28</a>.</p>
<div class="example">
<p class="titleinexample"><a id="ADDCI4739"></a><a id="sthref579"></a>Example 13-29 Using a REF CURSOR in a Callout</p>
<pre>
CREATE OR replace PACKAGE p1 AS 
  TYPE rc IS REF cursor; 
  END; 

CREATE OR REPLACE LIBRARY MYLIB AS 'mylib.so'; 

CREATE OR REPLACE FUNCTION MyCallout (stmthp p1.rc) 
  RETURN binary_integer AS LANGUAGE C LIBRARY MYLIB 
  WITH CONTEXT 
  PARAMETERS (context, stmthp ocirefcursor, RETURN sb4); 

sb4 MyCallout (OCIExtProcContext *ctx, OCIStmt ** stmthp) 
  OCIEnv *envhp;                /* env. handle */ 
  OCISvcCtx *svchp;             /* service handle */ 
  OCIError *errhp;              /* error handle */ 
  OCISession *usrhp;            /* user handle */ 

  int errnum = 29400;           /* choose some oracle error number */ 
  char errmsg[512];             /* error message buffer */ 
  size_t errmsglen;             /* Length of error message */ 
  OCIDefine *defn1p = (OCIDefine *) 0; 
  OCINumber *val=(OCINumber *)0; 

  OCINumber *rval = (OCINumber *)0; 
  sword status =  0; 
  double num=0; 
  val = (OCINumber*) OCIExtProcAllocCallMemory(ctx, sizeof(OCINumber)); 
  /* Get OCI handles */ 
  if (GetHandles(ctx, &amp;envhp, &amp;svchp, &amp;errhp, &amp;usrhp,&amp;rval)) 
    return -1; 
  /* Define the fetch buffer */ 
  psdro_checkerr(NULL, errhp, OCIDefineByPos(*stmthp, &amp;defn1p, errhp, (ub4) 1, 
                                            (dvoid *) &amp;num, (sb4) sizeof(num), 
                                            SQLT_FLT, (dvoid *) 0, (ub2 *)0, 
                                            (ub2 *)0, (ub4) OCI_DEFAULT)); 

  /* Fetch loop */ 
  while ((status = OCIStmtFetch(*stmthp, errhp, (ub4) 1,  (ub4) OCI_FETCH_NEXT, 
                                (ub4) OCI_DEFAULT)) == OCI_SUCCESS || 
         status == OCI_SUCCESS_WITH_INFO) 
  { 
    printf("val=%lf\n",num); 
  } 
  return 0; 
} 
</pre></div>
<!-- class="example" -->
<p>If the function is written as a Java callout, the <code>IN REF CURSOR</code> argument is automatically converted to an instance of the Java <code>ResultSet</code> class. The <code>IN REF CURSOR</code> to <code>ResultSet</code> mapping is available only if you use a fat JDBC driver based on OCI. This mapping is not available for a thin JDBC driver. As with an executed statement handle in a C callout, when a <code>REF CURSOR</code> is either an <code>IN OUT</code> argument, an <code>OUT</code> argument, or a return type for the function, a Java <code>ResultSet</code> is converted back to a PL/SQL <code>REF CURSOR</code> on its way out to the caller.</p>
<p>A predefined weak <code>REF CURSOR</code> type, <code>SYS_REFCURSOR</code>, is also supported. With <code>SYS_REFCURSOR</code>, you do not have to first create a <code>REF CURSOR</code> type in a package before you can use it. This weak <code>REF CURSOR</code> type can be used in the <a href="pipe_paral_tbl_ref.htm#CHDIJIJJ">ODCITableStart()</a> method, which, as a type method, cannot accept a package type.</p>
<p>To use a strong <code>REF CURSOR</code> type, you still must create a PL/SQL package and declare a strong <code>REF CURSOR</code> type in it. Also, if you are using a strong <code>REF CURSOR</code> type as an argument to a table function, then the actual type of the <code>REF CURSOR</code> argument must match the column type, or an error is generated.</p>
<p>To partition a weak <code>REF CURSOR</code> argument, you must partition by <code>ANY</code>, because a weak <code>REF CURSOR</code> argument cannot be partitioned by <code>RANGE</code> or <code>HASH</code>. Oracle recommends that you not use weak <code>REF CURSOR</code> arguments to table functions.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005017"></a><a id="ADDCI4740"></a>
<div class="sect2">
<h3 class="sect2">Input Data Partitioning</h3>
<p>The <a id="sthref580"></a>table function declaration can specify data partitioning for exactly one <code>REF CURSOR</code> parameter, as demonstrated in <a href="#CIHGECED">Example 13-30</a>. The <code>PARTITION&nbsp;BY</code> phrase in the <code>PARALLEL_ENABLE</code> clause specifies which one of the input cursors to partition, and what columns to use for partitioning.</p>
<div class="example">
<p class="titleinexample"><a id="CIHGECED"></a><a id="ADDCI4741"></a>Example 13-30 Specifying Data Partitioning for a REF CURSOR Parameter</p>
<pre>
CREATE FUNCTION f(p <span class="italic">ref_cursor_type</span>) RETURN rec_tab_type PIPELINED
  PARALLEL_ENABLE(PARTITION p BY [{HASH | RANGE} (<span class="italic">column_list</span>) | ANY ]) IS
BEGIN ... END;
</pre></div>
<!-- class="example" -->
<p>When explicit column names are specified in the column list, the partitioning method can be <code>RANGE</code> or <code>HASH</code>. The input rows are hash- or range-partitioned on the specified columns.</p>
<p>The <code>ANY</code> keyword enables you to indicate that the function behavior is independent of the partitioning of the input data. When this keyword is used, the run-time system randomly partitions the data among the slaves. This keyword is appropriate for use with functions that take in one row, manipulate its columns, and generate output row(s) based on the columns of this row only.</p>
<p>For example, the pivot-like function <code>StockPivot()</code> in <a href="#CIHEDEFF">Example 13-31</a> takes as input a row of the type <code>(Ticker&nbsp;varchar(4), OpenPrice&nbsp;number, ClosePrice&nbsp;number)</code>, and generates rows of the type <code>(Ticker varchar(4), PriceType varchar(1), Price number)</code>. In this manner, the row (<code>"ORCL",&nbsp;41,&nbsp;42</code>) generates two rows (<code>"ORCL",&nbsp;"O",&nbsp;41</code>) and (<code>"ORCL",&nbsp;"C",&nbsp;42</code>).</p>
<div class="example">
<p class="titleinexample"><a id="CIHEDEFF"></a><a id="ADDCI4742"></a>Example 13-31 Implementing the StockPivot() Function</p>
<pre>
CREATE FUNCTION StockPivot(p refcur_pkg.refcur_t) RETURN rec_tab_type PIPELINED
    PARALLEL_ENABLE(PARTITION p BY ANY) IS
  ret_rec rec_type;
BEGIN
  FOR rec IN p LOOP
    ret_rec.Ticker := rec.Ticker;
    ret_rec.PriceType := "O";
    ret_rec.Price := rec.OpenPrice;
    PIPE ROW(ret_rec);

    ret_rec.Ticker := rec.Ticker;   -- Redundant; not required
    ret_rec.PriceType := "C";
    ret_rec.Price := rec.ClosePrice;
    PIPE ROW ret_rec;
  END LOOP;
  RETURN;
END;
</pre></div>
<!-- class="example" -->
<p>The function <code>f()</code> can be used to generate another table from <code>Stocks</code> table, as shown in <a href="#CIHCCJBG">Example 13-32</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHCCJBG"></a><a id="ADDCI4743"></a>Example 13-32 Using a REF CURSOR to Generate a Table from Another Table</p>
<pre>
INSERT INTO AlternateStockTable
  SELECT * FROM 
  TABLE(StockPivot(CURSOR(SELECT * FROM StockTable)));
</pre></div>
<!-- class="example" -->
<p>If <code>StockTable</code> is scanned in parallel and partitioned on <code>OpenPrice</code>, then the function <code>StockPivot()</code> is combined with the data-flow operator that scans <code>StockTable</code> and therefore sees the same partitioning.</p>
<p>If <code>StockTable</code> is not partitioned, and the scan on it does not execute in parallel, the insert into <code>AlternateStockTable</code> also runs sequentially, as demonstrated in <a href="#CIHGIDHB">Example 13-33</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHGIDHB"></a><a id="ADDCI4744"></a>Example 13-33 Using a REF CURSOR to Scan and Insert</p>
<pre>
CREATE FUNCTION g(p refcur_pkg.refcur_t) RETURN ... PIPELINED
  PARALLEL_ENABLE (PARTITION p BY ANY)
BEGIN 
  ... 
END;

INSERT INTO AlternateStockTable
  SELECT * FROM TABLE(f(CURSOR(SELECT * FROM Stocks))), TABLE(g(CURSOR( ... )))
    WHERE <span class="italic">join_condition</span>;
</pre></div>
<!-- class="example" -->
<p>If function <code>g()</code> runs in parallel and is partitioned by <code>ANY</code>, then the parallel insert can belong in the same data-flow operator as <code>g()</code>.</p>
<p>Whenever the <code>ANY</code> keyword is specified, the data is partitioned randomly among the slaves. This effectively means that the function is executed in the same slave set which does the scan associated with the input parameter.</p>
<p>No redistribution or repartitioning of the data is required here. In the case when the cursor <code>p</code> itself is not parallelized, the incoming data is randomly partitioned on the columns in the column list. The round-robin table queue is used for this partitioning.</p>
</div>
<!-- class="sect2" -->
<a id="ADDCI4745"></a>
<div class="sect2"><a id="sthref581"></a>
<h3 class="sect2">Parallel Execution of Leaf-level Table Functions</h3>
<p>To use <a id="sthref582"></a>parallel execution with a leaf-level table function, a function to perform a unitary operation that does not involve a <code>REF CURSOR</code>, there must be a requirements for a <code>REF CURSOR</code>.</p>
<p>Consider a function for reading a set of external files in parallel, and returning the records they contain. To provide work for a <code>REF CURSOR</code>, you might first create a table and populate it with the filenames. A <code>REF CURSOR</code> over this table can then be passed as a parameter to the table function <code>readfiles()</code>, as demonstrated by <a href="#CIHCAJGD">Example 13-34</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHCAJGD"></a><a id="ADDCI4746"></a>Example 13-34 Using a REF CURSOR to Read a Set of External FIles</p>
<pre>
CREATE TABLE filetab(filename VARCHAR(20));

INSERT INTO filetab VALUES('file0');   
INSERT INTO filetab VALUES('file1');  
...
INSERT INTO filetab VALUES('fileN');

SELECT * FROM TABLE(readfiles(CURSOR(SELECT filename FROM filetab)));

CREATE FUNCTION readfiles(p pkg.rc_t) RETURN coll_type
  PARALLEL_ENABLE(PARTITION p BY ANY) IS
  ret_rec rec_type;
BEGIN
  FOR rec IN p LOOP
    done := FALSE;
    WHILE (done = FALSE) LOOP
         done := readfilerecord(rec.filename, ret_rec);
         PIPE ROW(ret_rec);
    END LOOP;
  END LOOP;
  RETURN;
END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005103"></a><a id="ADDCI4747"></a>
<div class="sect1">
<h2 class="sect1">Input Data Streaming for Table Functions</h2>
<p>Data streaming is the manner in which a table function orders or clusters rows that it fetches from cursor arguments. A function can stream its input data in any of the following ways:</p>
<ul>
<li>
<p>Place no restriction on the ordering of the incoming rows.</p>
</li>
<li>
<p>Order them on a particular key column or columns.</p>
</li>
<li>
<p>Cluster them on a particular key .</p>
</li>
</ul>
<p>Clustering causes rows that have the same key values to appear next to one another, but it does not otherwise do any ordering of rows.</p>
<p>To control the behavior of the input stream, use the syntax in <a href="#CIHECDFJ">Example 13-35</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHECDFJ"></a><a id="ADDCI4748"></a>Example 13-35 Controlling Input Data Streaming</p>
<pre>
FUNCTION f(p <span class="italic">ref_cursor_type</span>) RETURN <span class="italic">tab_rec_type</span> [PIPELINED]
         {[ORDER | CLUSTER] BY <span class="italic">column_list</span>}
         PARALLEL_ENABLE({PARTITION p BY 
           [ANY | (HASH | RANGE) <span class="italic">column_list</span>]} )
IS
BEGIN 
  ...
END;
</pre></div>
<!-- class="example" -->
<p>Input streaming may be specified for either sequential or parallel execution of a function.</p>
<p>If an <code>ORDER BY</code> or <code>CLUSTER BY</code> clause is not specified, rows are input in a random order. The semantics of <code>ORDER BY</code> are different for parallel execution from the semantics of the <code>ORDER BY</code> clause in a SQL statement. In a SQL statement, the <code>ORDER BY</code> clause globally orders the entire data set. In a table function, the <code>ORDER BY</code> clause orders the respective rows local to each instance of the table function running on a slave.</p>
<p><a href="#CIHGDIBD">Example 13-36</a> illustrates the syntax for ordering the input stream. In the example, function <code>f()</code> takes in rows of the kind <code>(Region, Sales)</code> and returns rows of the form <code>(Region, AvgSales)</code>, showing average sales for each region.</p>
<div class="example">
<p class="titleinexample"><a id="CIHGDIBD"></a><a id="ADDCI4749"></a>Example 13-36 Ordering the Input Stream</p>
<pre>
CREATE FUNCTION f(p <span class="italic">ref_cursor_type</span>) RETURN tab_rec_type PIPELINED
  CLUSTER BY Region 
  PARALLEL_ENABLE(PARTITION p BY Region) IS
  ret_rec rec_type;
  cnt number;
  sum number;
BEGIN
  FOR rec IN p LOOP
    IF (first rec in the group) THEN
        cnt := 1;
        sum := rec.Sales;
    ELSIF (last rec in the group) THEN
      IF (cnt &lt;&gt; 0) THEN
        ret_rec.Region := rec.Region;
          ret_rec.AvgSales := sum/cnt;
          PIPE ROW(ret_rec);
        END IF;
    ELSE
       cnt := cnt + 1;
      sum := sum + rec.Sales;
    END IF;
  END LOOP;
  RETURN;
END;
</pre></div>
<!-- class="example" -->
<a id="ADDCI4750"></a>
<div class="sect2"><a id="sthref583"></a>
<h3 class="sect2">Parallel Execution: Partitioning and Clustering</h3>
<p>Partitioning and clustering are easily confused, but they do different things. Sometimes partitioning can be sufficient without clustering in parallel execution.</p>
<p>Consider a function <code>SmallAggr</code> that performs in-memory aggregation of salary for each <code>department_id</code>, where <code>department_id</code> can be either <code>1</code>, <code>2</code>, or <code>3</code>. The input rows to the function can be partitioned by <code>HASH</code> on <code>department_id</code> so that all rows with <code>department_id</code> equal to <code>1</code> go to one slave, all rows with <code>department_id</code> equal to <code>2</code> go to another slave, and so on.</p>
<p>The input rows do not have to be clustered on <code>department_id</code> to perform the aggregation in the function. Each slave could have a <code>1</code> by <code>3</code> array <code>SmallSum[1..3]</code>, in which the aggregate sum for each <code>department_id</code> is added in memory into <code>SmallSum[department_id]</code>. On the other hand, if the number of unique values of <code>department_id</code> were very large, you would want to use clustering to compute department aggregates and write them to disk one <code>department_id</code> at a time.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEACJF"></a><a id="ADDCI4751"></a>
<div class="sect1">
<h2 class="sect1">Creating Domain Indexes in Parallel</h2>
<p>Creating a <a id="sthref584"></a>domain index can be a lengthy process because of the large amount of data that a domain index typically handles. You can exploit the parallel-processing capabilities of table functions to alleviate this bottleneck by using table functions to create domain indexes in parallel.</p>
<p>Typically, the <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> routine performs the following steps:</p>
<ol>
<li>
<p>Creates tables for storing the index data</p>
</li>
<li>
<p><a id="CIHFGIID"></a>Fetches the relevant data, such as <code>keycols</code> and <code>rowid</code>, from the base table, transforms it, and inserts relevant transformed data into the table created for storing the index data.</p>
</li>
<li>
<p>Builds secondary indexes on the tables that store the index data, for faster access at query time.</p>
</li>
</ol>
<p>Step <a href="#CIHFGIID">2</a> is the bottleneck in creating domain indexes. You can speed up this step by encapsulating these operations in a parallel table function and invoking the function from the <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> function. In <a href="#CIHDDFGE">Example 13-37</a>, a table function <code>IndexLoad()</code> is defined to do just that.</p>
<div class="example">
<p class="titleinexample"><a id="CIHDDFGE"></a><a id="ADDCI4752"></a>Example 13-37 Loading a Domain Index in Parallel</p>
<pre>
CREATE FUNCTION IndexLoad(ia ODCIIndexInfo, parms VARCHAR2,
                          p refcur-type)
RETURN status_code_type
PARALLEL_ENABLE(PARTITION p BY ANY)  
PRAGMA AUTONOMOUS_TRANSACTION
IS
BEGIN
  FOR rec IN p LOOP
    - process each rec and determine the index entry
    - derive name of index storage table from parameter ia
    - insert into table created in ODCIIndexCreate
  END LOOP;
  COMMIT; -- explicitly commit the autonomous txn
  RETURN ODCIConst.Success;
END;
</pre></div>
<!-- class="example" -->
<p>where <code>p</code> is a cursor of the form:</p>
<pre>
SELECT /*+ PARALLEL (<span class="italic">base_table</span>, <span class="italic">par_degree</span>) */ keycols ,rowid 
  FROM <span class="italic">base_table</span>
</pre>
<p>The <code><span class="codeinlineitalic">par_degree</span></code> value can be explicitly specified; otherwise, it is derived from the parallel degree of the base table.</p>
<p>The function <code>IndexMerge()</code>, defined in <a href="#CIHGHDIB">Example 13-38</a>, is needed to merge the results from the several instances of <code>IndexLoad()</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHGHDIB"></a><a id="ADDCI4753"></a>Example 13-38 Merging the Results from Parallel Domain Index Loads</p>
<pre>
CREATE FUNCTION IndexMerge(p refcur-type) 
RETURN NUMBER
IS
BEGIN
  FOR rec IN p LOOP
    IF (rec != ODCIConst.Success)
      RETURN Error;
  END LOOP;
  RETURN Success; 
END;
</pre></div>
<!-- class="example" -->
<p>The new steps in <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> would be:</p>
<ol>
<li>
<p>Create metadata structures for the index (tables to store the index data).</p>
</li>
<li>
<p>Explicitly commit the transaction so that the <code>IndexLoad()</code> function can access the committed data.</p>
</li>
<li>
<p>Invoke <code>IndexLoad()</code> in parallel, as shown in <a href="#CIHDIJDI">Example 13-39</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIHDIJDI"></a><a id="ADDCI4754"></a>Example 13-39 Invoking the Merging of Parallel Domain Index Loads</p>
<pre>
status := ODCIIndexMerge(CURSOR(
  SELECT * FROM TABLE(ODCIIndexLoad(ia, parms, CURSOR(
    SELECT <span class="italic">key_cols</span>, ROWID FROM <span class="italic">basetable</span>)))))
</pre></div>
<!-- class="example" --></li>
<li>
<p>Create secondary index structures.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1005159"></a><a id="ADDCI4755"></a>
<div class="sect1">
<h2 class="sect1">Transient and Generic Types</h2>
<p><a href="#CIHDHEEI">Table 13-1</a> lists Oracle's three special SQL data types that enable you to <a id="sthref585"></a>dynamically encapsulate and access type descriptions, data instances, and sets of data instances of any other SQL type, including object and collection types. You can also use these three special types to create anonymous, or unnamed, types, including anonymous collection types.</p>
<p>The three SQL types are implemented as opaque types; the internal structure of these types is not known to the database: their data can be queried only by implementing functions, typically 3GL routines. Oracle provides both an OCI and a PL/SQL API for implementing such functions.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4756"></a><a id="sthref586"></a><a id="CIHDHEEI"></a>Table 13-1 Generic SQL Types</p>
<table class="cellalignment1246" title="Generic SQL Types" summary="Type and its description" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t4">Type</th>
<th class="cellalignment1247" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t4" headers="r1c1-t4">
<p><code>SYS.ANYTYPE</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c2-t4">
<p>A type description type. A <code>SYS.ANYTYPE</code> can contain a type description of any SQL type, named or unnamed, including object types and collection types.</p>
<p>An <code>ANYTYPE</code> can contain a type description of a persistent type, but an <code>ANYTYPE</code> itself is transient: the value in an <code>ANYTYPE</code> itself is not automatically stored in the database. To create a persistent type, use a <code>CREATE TYPE</code> statement from SQL.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t4" headers="r1c1-t4">
<p><code>SYS.<a id="sthref587"></a>ANYDATA</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c2-t4">
<p>A self-describing data instance type. A <code>SYS.ANYDATA</code> contains an instance of a given type, with data, plus a description of the type. In this sense, a <code>SYS.ANYDATA</code> is self-describing. An <code>ANYDATA</code> can be persistently stored in the database.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t4" headers="r1c1-t4">
<p><code>SYS.<a id="sthref588"></a>ANYDATASET</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c2-t4">
<p>A self-describing data set type. A <code>SYS.ANYDATASET</code> type contains a description of a given type plus a set of data instances of that type. An <code>ANYDATASET</code> can be persistently stored in the database.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Each of these three types can be used with any built-in type native to the database with object types and collection types, both named and unnamed. The types provide a generic way to work dynamically with type descriptions, lone instances, and sets of instances of other types. Using the APIs, you can create a transient <code>ANYTYPE</code> description of any kind of type. Similarly, you can create or convert (cast) a data value of any SQL type to an <code>ANYDATA</code> and can convert an <code>ANYDATA</code> (back) to a SQL type. And similarly again with sets of values and <code>ANYDATASET</code>.</p>
<p>The generic types simplify working with stored procedures. You can use the generic types to encapsulate descriptions and data of standard types and pass the encapsulated information into parameters of the generic types. In the body of the procedure, you can detail how to handle the encapsulated data and type descriptions of whatever type.</p>
<p>You can also store encapsulated data of a variety of underlying types in one table column of type <code>ANYDATA</code> or <code>ANYDATASET</code>. For example, you can use <code>ANYDATA</code> with advanced queuing to model queues of heterogeneous types of data. You can query the data of the underlying data types like any other data.</p>
<p>Corresponding to the three generic SQL types are three OCI types that model them. Each has a set of functions for creating and accessing the respective type:</p>
<ul>
<li>
<p><code>OCIType</code>, corresponding to <code>SYS.ANYTYPE</code></p>
</li>
<li>
<p><code>OCIAnyData</code>, corresponding to <code>SYS.ANYDATA</code></p>
</li>
<li>
<p><code>OCIAnyDataSet</code>, <a id="sthref589"></a>corresponding to <code>SYS.ANYDATASET</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for the <code>OCIType</code>, <code>OCIAnyData</code>, and <code>OCIAnyDataSet</code> APIs and details on how to use them</p>
</li>
<li>
<p><a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the interfaces to the <code>ANYTYPE</code>, <code>ANYDATA</code>, and <code>ANYDATASET</code> types and about the <code>DBMS_TYPES</code> package, which defines constants for built-in and user-defined types, for use with <code>ANYTYPE</code>, <code>ANYDATA</code>, and <code>ANYDATASET</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1236">
<tr>
<td class="cellalignment1243">
<table class="cellalignment1241">
<tr>
<td class="cellalignment1240"><a href="cart_services.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1240"><a href="cart_design.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1245">
<table class="cellalignment1239">
<tr>
<td class="cellalignment1240"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1240"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1240"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1240"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1240"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1240"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
