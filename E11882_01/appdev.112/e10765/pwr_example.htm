<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Power Demand Cartridge Example</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2010-03-08T13:16:28Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Data Cartridge Developer's Guide" />
<meta name="dcterms.identifier" content="E10765-02" />
<meta name="dcterms.isVersionOf" content="ADDCI" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part3.htm" title="Previous" type="text/html" />
<link rel="Next" href="psbtree_example.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10765.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">25/36</span> <!-- End Header --><a id="BABEIEIE"></a><a id="ADDCI3150"></a>
<h1 class="chapter"><span class="secnum">15</span> Power Demand Cartridge Example</h1>
<p><a id="sthref601"></a><a id="sthref602"></a>This chapter explains the power demand sample data cartridge that is discussed throughout this book. The power demand cartridge includes a user-defined object type, extensible indexing, and optimization. The entire cartridge definition is available online in file <code>extdemo1.sql</code> in the Oracle demo directory.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1004634">Feature Requirements</a></p>
</li>
<li>
<p><a href="#i1004952">Modeling the Application</a></p>
</li>
<li>
<p><a href="#i1005257">Queries and Extensible Indexing</a></p>
</li>
<li>
<p><a href="#i1005282">Creating the Domain Index</a></p>
</li>
<li>
<p><a href="#CHDGBBAG">Defining a Type and Methods for Extensible Optimizing</a></p>
</li>
<li>
<p><a href="#i1007059">Testing the Domain Index</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="dom_idx.htm#BHADJHIF">Chapter 8, "Building Domain Indexes"</a> for information about extensible query optimization</p>
</li>
<li>
<p><a href="ext_optimizer.htm#BABEDGGD">Chapter 10, "Using Extensible Optimizer"</a> for information about extensible indexing</p>
</li>
<li>
<p><a href="cart_services.htm#CHDJCGBG">Chapter 12, "Using Cartridge Services"</a> for information about cartridge services</p>
</li>
</ul>
</div>
<a id="i1004634"></a><a id="ADDCI4778"></a>
<div class="sect1">
<h2 class="sect1">Feature Requirements</h2>
<p><a id="sthref603"></a><a id="sthref604"></a><a id="sthref605"></a><a id="sthref606"></a>A power utility, <span class="italic">Power-To-The-People</span>, develops a sophisticated model to decide how to deploy its resources. The region served by the utility is represented by a grid laid over a geographic area. This grid is illustrated in <a href="#BABJAIIE">Figure 15-1</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABJAIIE"></a><a id="ADDCI4779"></a>Figure 15-1 Region Served by the Power Utility</p>
<img width="407" height="407" src="img/addci004.gif" alt="Description of Figure 15-1 follows" title="Description of Figure 15-1 follows" /><br />
<a id="sthref607" href="img_text/addci004.htm">Description of "Figure 15-1 Region Served by the Power Utility"</a><br />
<br /></div>
<!-- class="figure" -->
<p>This region may be surrounded by other regions some of whose power needs are supplied by other utilities. As pictured, every region is composed of geographic quadrants, called cells, on a 10x10 grid. There are several ways of identifying cells &mdash; by spatial coordinates (longitude/latitude), by a matrix numbering (1,1; 1,2;...), and by numbering them sequentially, as illustrated in <a href="#BABEHDCE">Figure 15-2</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABEHDCE"></a><a id="ADDCI4780"></a>Figure 15-2 Regional Grid Cells in Numbered Sequence</p>
<img width="409" height="409" src="img/addci006.gif" alt="Description of Figure 15-2 follows" title="Description of Figure 15-2 follows" /><br />
<a id="sthref608" href="img_text/addci006.htm">Description of "Figure 15-2 Regional Grid Cells in Numbered Sequence"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Within the area represented by each cell, the power used by consumers in that area is recorded each hour. For example, the power demand readings for a particular hour might be represented by <a href="#BGEGFJDE">Table 15-1</a> (cells here represented on a matrix).</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4781"></a><a id="sthref609"></a><a id="BGEGFJDE"></a>Table 15-1 Sample Power Demand Readings for an Hour</p>
<table class="cellalignment1246" title="Sample Power Demand Readings for an Hour" summary="Lists sample power demand readings for a given hour" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t3">-</th>
<th class="cellalignment1247" id="r1c2-t3"><span class="bold">1</span></th>
<th class="cellalignment1247" id="r1c3-t3"><span class="bold">2</span></th>
<th class="cellalignment1247" id="r1c4-t3"><span class="bold">3</span></th>
<th class="cellalignment1247" id="r1c5-t3"><span class="bold">4</span></th>
<th class="cellalignment1247" id="r1c6-t3"><span class="bold">5</span></th>
<th class="cellalignment1247" id="r1c7-t3"><span class="bold">6</span></th>
<th class="cellalignment1247" id="r1c8-t3"><span class="bold">7</span></th>
<th class="cellalignment1247" id="r1c9-t3"><span class="bold">8</span></th>
<th class="cellalignment1247" id="r1c10-t3"><span class="bold">9</span></th>
<th class="cellalignment1247" id="r1c11-t3"><span class="bold">10</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t3" headers="r1c1-t3">
<p><span class="bold">1</span></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c2-t3">
<p><code>23</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c3-t3">
<p><code>21</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c4-t3">
<p><code>25</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c5-t3">
<p><code>23</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c6-t3">
<p><code>24</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c7-t3">
<p><code>25</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c8-t3">
<p><code>27</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c9-t3">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c10-t3">
<p><code>31</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t3 r1c11-t3">
<p><code>30</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t3" headers="r1c1-t3">
<p><span class="bold">2</span></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c2-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c3-t3">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c4-t3">
<p><code>31</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c5-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c6-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c7-t3">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c8-t3">
<p><code>23</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c9-t3">
<p><code>22</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c10-t3">
<p><code>21</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t3 r1c11-t3">
<p><code>34</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t3" headers="r1c1-t3">
<p><span class="bold">3</span></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c2-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c3-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c4-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c5-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c6-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c7-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c8-t3">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c9-t3">
<p><code>41</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c10-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t3 r1c11-t3">
<p><code>46</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t3" headers="r1c1-t3">
<p><span class="bold">4</span></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c2-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c3-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c4-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c5-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c6-t3">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c7-t3">
<p><code>26</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c8-t3">
<p><code>19</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c9-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c10-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t3 r1c11-t3">
<p><code>43</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t3" headers="r1c1-t3">
<p><span class="bold">5</span></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c2-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c3-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c4-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c5-t3">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c6-t3">
<p><code>41</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c7-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c8-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c9-t3">
<p><code>46</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c10-t3">
<p><code>47</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t3 r1c11-t3">
<p><code>44</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t3" headers="r1c1-t3">
<p><span class="bold">6</span></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c2-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c3-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c4-t3">
<p><code>98</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c5-t3">
<p><code>55</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c6-t3">
<p><code>54</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c7-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c8-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c9-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c10-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t3 r1c11-t3">
<p><code>44</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t3" headers="r1c1-t3">
<p><span class="bold">7</span></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c2-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c3-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c4-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c5-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c6-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c7-t3">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c8-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c9-t3">
<p><code>55</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c10-t3">
<p><code>46</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t3 r1c11-t3">
<p><code>34</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t3" headers="r1c1-t3">
<p><span class="bold">8</span></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c2-t3">
<p><code>87</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c3-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c4-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c5-t3">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c6-t3">
<p><code>31</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c7-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c8-t3">
<p><code>35</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c9-t3">
<p><code>38</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c10-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t3 r1c11-t3">
<p><code>39</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t3" headers="r1c1-t3">
<p><span class="bold">9</span></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c2-t3">
<p><code>30</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c3-t3">
<p><code>40</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c4-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c5-t3">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c6-t3">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c7-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c8-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c9-t3">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c10-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t3 r1c11-t3">
<p><code>46</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t3" headers="r1c1-t3">
<p><span class="bold">10</span></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c2-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c3-t3">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c4-t3">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c5-t3">
<p><code>12</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c6-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c7-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c8-t3">
<p><code>48</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c9-t3">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c10-t3">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t3 r1c11-t3">
<p><code>32</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The power stations also receives reports from two other sources:</p>
<ul>
<li>
<p><span class="italic">Sensors</span> on the ground provide temperature readings for every cell</p>
<p>By analyzing the correlation between historical power demand from cells and the temperature readings for those regions, the utility is able to determine with a close approximation the expected demand, given specific temperatures.</p>
</li>
<li>
<p><span class="italic">Satellite cameras</span> provide images regarding current conditions that are converted into grayscale images that match the grid illustrated in <a href="#BABICABD">Figure 15-3</a>.</p>
</li>
</ul>
<div class="figure">
<p class="titleinfigure"><a id="BABICABD"></a><a id="ADDCI4782"></a>Figure 15-3 Grayscale Representation of Satellite Image</p>
<img width="409" height="408" src="img/addci025.gif" alt="Description of Figure 15-3 follows" title="Description of Figure 15-3 follows" /><br />
<a id="sthref610" href="img_text/addci025.htm">Description of "Figure 15-3 Grayscale Representation of Satellite Image "</a><br />
<br /></div>
<!-- class="figure" -->
<p>These images are designed so that lighter is colder. Thus, the image shows a cold front moving into the region from the south-west. By correlating the data provided by the grayscale images with temperature readings taken at the same time, the utility has been able to determine what the power demand is given weather conditions viewed from the stratosphere.</p>
<p>The reason that this is important is that a crucial part of this modeling has to do with noting the rapidity and degree of change in the incoming reports as weather changes and power is deployed. The following diagram shows same cold front at a second recording, illustrated in <a href="#BABIDHGD">Figure 15-4</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABIDHGD"></a><a id="ADDCI4783"></a>Figure 15-4 Grayscale Representation of Weather Conditions at Second Recording</p>
<img width="409" height="408" src="img/addci026.gif" alt="Description of Figure 15-4 follows" title="Description of Figure 15-4 follows" /><br />
<a id="sthref611" href="img_text/addci026.htm">Description of "Figure 15-4 Grayscale Representation of Weather Conditions at Second Recording"</a><br />
<br /></div>
<!-- class="figure" -->
<p>By analyzing the extent and speed of the cold front, the utility is able to project what the conditions are likely to be in the short and medium term, as in <a href="#BABHCAIH">Figure 15-5</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABHCAIH"></a><a id="ADDCI4784"></a>Figure 15-5 Grayscale Representation of Conditions as Projected</p>
<img width="409" height="408" src="img/addci041.gif" alt="Description of Figure 15-5 follows" title="Description of Figure 15-5 follows" /><br />
<a id="sthref612" href="img_text/addci041.htm">Description of "Figure 15-5 Grayscale Representation of Conditions as Projected "</a><br />
<br /></div>
<!-- class="figure" -->
<p>By combing the data about these conditions and other anomalous situations (such as the failure of a substation), the utility must be able to organize the most optimal deployment of its resources. <a href="#BABFCGBC">Figure 15-6</a> reflects the distribution of substations across the region.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABFCGBC"></a><a id="ADDCI4785"></a>Figure 15-6 Distribution of Power Stations Across the Region</p>
<img width="407" height="407" src="img/addci020.gif" alt="Description of Figure 15-6 follows" title="Description of Figure 15-6 follows" /><br />
<a id="sthref613" href="img_text/addci020.htm">Description of "Figure 15-6 Distribution of Power Stations Across the Region"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The distribution of power stations means that the utility can redirect its deployment of electricity to the areas of greatest need. <a href="#BABBHACJ">Figure 15-7</a> gives a pictorial representation of the overlap between three stations.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABBHACJ"></a><a id="ADDCI4786"></a>Figure 15-7 Areas Served by Three Power Stations</p>
<img width="410" height="409" src="img/addci021.gif" alt="Description of Figure 15-7 follows" title="Description of Figure 15-7 follows" /><br />
<a id="sthref614" href="img_text/addci021.htm">Description of "Figure 15-7 Areas Served by Three Power Stations"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Depending on fluctuating requirements, the utility must be able to decide how to deploy its resources, and even whether to purchase power from another utility in the event of shortfall.</p>
</div>
<!-- class="sect1" -->
<a id="i1004952"></a><a id="ADDCI4787"></a>
<div class="sect1">
<h2 class="sect1">Modeling the Application</h2>
<p>This section includes a technical and business scenario. The Class Diagram in <a href="#BABGCEHD">Figure 15-8</a> describes the application objects using the Unified Modelling Language (UML) notation.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABGCEHD"></a><a id="ADDCI4788"></a>Figure 15-8 Application Object Model of the Power Demand Cartridge</p>
<img width="524" height="533" src="img/addci029.gif" alt="Description of Figure 15-8 follows" title="Description of Figure 15-8 follows" /><br />
<a id="sthref615" href="img_text/addci029.htm">Description of "Figure 15-8 Application Object Model of the Power Demand Cartridge"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="ADDCI4789"></a>
<div class="sect2"><a id="sthref616"></a>
<h3 class="sect2">Sample Queries</h3>
<p>Modelling the application in this way, makes possible the following specific queries:</p>
<ul>
<li>
<p>Find the cell (geographic quadrant) with the highest demand for a specified time-period.</p>
</li>
<li>
<p>Find the time-period with the highest total demand.</p>
</li>
<li>
<p>Find all cells where demand is greater than some specified value.</p>
</li>
<li>
<p>Find any cell at any time where the demand equals some specified value.</p>
</li>
<li>
<p>Find any time period for which 3 or more cells have a demand greater than some specified.</p>
</li>
<li>
<p>Find the time-period for which there was the greatest disparity (difference) between the cell with the minimum demand and the cell with the maximum demand.</p>
</li>
<li>
<p>Find the times for which 10 or more cells had demand not less than some specified value.</p>
</li>
<li>
<p>Find the times for which the average cell demand was greater than some specified value.</p>
<p>Note that it is assumed that the average is easily computable through <code>TotalPowerDemand/100</code>.</p>
</li>
<li>
<p>Find the time-periods for which the median cell demand was greater than some specified value.</p>
<p>Note that we assume that the median value is not easily computable.</p>
</li>
<li>
<p>Find all time-periods for which the total demand rose 10 percent or more over the preceding time's total demand.</p>
</li>
</ul>
<p>These queries are, of course, only a short list of the possible information that could be gleaned from the system. For instance, it is obvious that the developer of such an application would want to build queries that are based on the information derived from prior queries:</p>
<ul>
<li>
<p>What is the percentage change in demand for a particular cell as compared to a previous time-period?</p>
</li>
<li>
<p>Which cells demonstrate rapid increase or decrease in demand measured as percentages that are greater or less than specified values?</p>
</li>
</ul>
<p><a href="#BABJEFDG">Figure 15-9</a> describes and illustrates the Power Demand cartridge, as implemented.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABJEFDG"></a><a id="ADDCI4790"></a>Figure 15-9 Implementation Model of the Power Demand Cartridge</p>
<img width="524" height="488" src="img/addci028.gif" alt="Description of Figure 15-9 follows" title="Description of Figure 15-9 follows" /><br />
<a id="sthref617" href="img_text/addci028.htm">Description of "Figure 15-9 Implementation Model of the Power Demand Cartridge"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The utility receives ongoing reports from weather centers about current conditions and from power stations about ongoing power utilization for specific geographical areas (represented by cells on a 10x10 grid). It then compares this information to historical data so it may predict demand for power in the different geographic areas for given time periods.</p>
<p>Each service area for the utility is considered as a 10x10 grid of cells, where each cell's boundaries are associated with spatial coordinates (longitude/latitude). The geographical areas represented by the cells can be uniform or can have different shapes and sizes. Within the area represented by each cell, the power used by consumers in that area is recorded each hour. For example, the power demand readings for a particular hour might be represented by <a href="#g1012310">Table 15-2</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4791"></a><a id="sthref618"></a><a id="g1012310"></a>Table 15-2 Sample Power Demand Readings for an Hour</p>
<table class="cellalignment1246" title="Sample Power Demand Readings for an Hour" summary="Lists sample power demand readings for a different hour than a previous table" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t4">-</th>
<th class="cellalignment1247" id="r1c2-t4"><span class="bold">1</span></th>
<th class="cellalignment1247" id="r1c3-t4"><span class="bold">2</span></th>
<th class="cellalignment1247" id="r1c4-t4"><span class="bold">3</span></th>
<th class="cellalignment1247" id="r1c5-t4"><span class="bold">4</span></th>
<th class="cellalignment1247" id="r1c6-t4"><span class="bold">5</span></th>
<th class="cellalignment1247" id="r1c7-t4"><span class="bold">6</span></th>
<th class="cellalignment1247" id="r1c8-t4"><span class="bold">7</span></th>
<th class="cellalignment1247" id="r1c9-t4"><span class="bold">8</span></th>
<th class="cellalignment1247" id="r1c10-t4"><span class="bold">9</span></th>
<th class="cellalignment1247" id="r1c11-t4"><span class="bold">10</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t4" headers="r1c1-t4">
<p><span class="bold">1</span></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c2-t4">
<p><code>23</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c3-t4">
<p><code>21</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c4-t4">
<p><code>25</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c5-t4">
<p><code>23</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c6-t4">
<p><code>24</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c7-t4">
<p><code>25</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c8-t4">
<p><code>27</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c9-t4">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c10-t4">
<p><code>31</code></p>
</td>
<td class="cellalignment1243" headers="r2c1-t4 r1c11-t4">
<p><code>30</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t4" headers="r1c1-t4">
<p><span class="bold">2</span></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c2-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c3-t4">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c4-t4">
<p><code>31</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c5-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c6-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c7-t4">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c8-t4">
<p><code>23</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c9-t4">
<p><code>22</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c10-t4">
<p><code>21</code></p>
</td>
<td class="cellalignment1243" headers="r3c1-t4 r1c11-t4">
<p><code>34</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t4" headers="r1c1-t4">
<p><span class="bold">3</span></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c2-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c3-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c4-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c5-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c6-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c7-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c8-t4">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c9-t4">
<p><code>41</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c10-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r4c1-t4 r1c11-t4">
<p><code>46</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t4" headers="r1c1-t4">
<p><span class="bold">4</span></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c2-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c3-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c4-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c5-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c6-t4">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c7-t4">
<p><code>26</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c8-t4">
<p><code>19</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c9-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c10-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r5c1-t4 r1c11-t4">
<p><code>43</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t4" headers="r1c1-t4">
<p><span class="bold">5</span></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c2-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c3-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c4-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c5-t4">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c6-t4">
<p><code>41</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c7-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c8-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c9-t4">
<p><code>46</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c10-t4">
<p><code>47</code></p>
</td>
<td class="cellalignment1243" headers="r6c1-t4 r1c11-t4">
<p><code>44</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t4" headers="r1c1-t4">
<p><span class="bold">6</span></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c2-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c3-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c4-t4">
<p><code>98</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c5-t4">
<p><code>55</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c6-t4">
<p><code>54</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c7-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c8-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c9-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c10-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r7c1-t4 r1c11-t4">
<p><code>44</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t4" headers="r1c1-t4">
<p><span class="bold">7</span></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c2-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c3-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c4-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c5-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c6-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c7-t4">
<p><code>44</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c8-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c9-t4">
<p><code>55</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c10-t4">
<p><code>46</code></p>
</td>
<td class="cellalignment1243" headers="r8c1-t4 r1c11-t4">
<p><code>34</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t4" headers="r1c1-t4">
<p><span class="bold">8</span></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c2-t4">
<p><code>87</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c3-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c4-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c5-t4">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c6-t4">
<p><code>31</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c7-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c8-t4">
<p><code>35</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c9-t4">
<p><code>38</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c10-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r9c1-t4 r1c11-t4">
<p><code>39</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t4" headers="r1c1-t4">
<p><span class="bold">9</span></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c2-t4">
<p><code>30</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c3-t4">
<p><code>40</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c4-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c5-t4">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c6-t4">
<p><code>33</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c7-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c8-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c9-t4">
<p><code>32</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c10-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r10c1-t4 r1c11-t4">
<p><code>46</code></p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t4" headers="r1c1-t4">
<p><span class="bold">10</span></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c2-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c3-t4">
<p><code>42</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c4-t4">
<p><code>34</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c5-t4">
<p><code>12</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c6-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c7-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c8-t4">
<p><code>48</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c9-t4">
<p><code>45</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c10-t4">
<p><code>43</code></p>
</td>
<td class="cellalignment1243" headers="r11c1-t4 r1c11-t4">
<p><code>32</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The numbers in each cell reflect power demand (in some unit of measurement determined by the electric utility) for the hour for that area. For example, the demand for the first cell (1,1) was 23, the demand for the second cell (1,2) was 21, and so on. The demand for the last cell (10, 10) was 32.</p>
<p>The utility uses this data for many monitoring and analytical applications. Readings for individual cells are monitored for unusual surges or decreases in demand. For example, the readings of 98 for (6,3) and 87 for (8,1) might be unusually high, and the readings of 19 for (4,7) and 12 for (10,4) might be unusually low. Trends are also analyzed, such as significant increases or decreases in demand for each neighborhood, for each station, and overall, over time.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005257"></a><a id="ADDCI4792"></a>
<div class="sect1">
<h2 class="sect1">Queries and Extensible Indexing</h2>
<p>This section describes kinds of queries that benefit from domain indexes. Using extensible indexing depends on whether queries run as efficiently with a standard Oracle index, or with no index at all.</p>
<a id="ADDCI4793"></a>
<div class="sect2"><a id="sthref619"></a>
<h3 class="sect2">Queries Not Benefiting from Extensible Indexing</h3>
<p><a id="sthref620"></a><a id="sthref621"></a>A query does not require a domain index if both of the following are true:</p>
<ul>
<li>
<p>The desired information can be made an attribute (column) of the table and a standard index can be defined on that column.</p>
</li>
<li>
<p>The operations in queries on the data are limited to those operations supported by the standard index, such as <code>equals</code>, <code>lessthan</code>, <code>greaterthan</code>, <code>max</code>, and <code>min</code> for a b-tree index.</p>
</li>
</ul>
<p>In the <code>PowerDemand_Typ</code> object type cartridge example, the values for three columns (<code>TotGridDemand</code>, <code>MaxCellDemand</code>, and <code>MinCellDemand</code>) are set by functions, after which the values do not change. (For example, the total grid power demand for 13:00 on 01-Jan-1998 does not change after it has been computed.) For queries that use these columns, a standard b-tree index on each column is sufficient and recommended for operations like <code>equals</code>, <code>lessthan</code>, <code>greaterthan</code>, <code>max</code>, and <code>min</code>.</p>
<p>Examples of queries that would not benefit from extensible indexing (using the power demand cartridge) include:</p>
<ul>
<li>
<p>Find the cell with the highest power demand for a specific time.</p>
</li>
<li>
<p>Find the time when the total grid power demand was highest.</p>
</li>
<li>
<p>Find all cells where the power demand is greater than a specified value.</p>
</li>
<li>
<p>Find the times for which the average cell demand or the median cell demand was greater than a specified value.</p>
<p>To make this query run efficiently, define two additional columns in the <code>PowerDemand_Typ</code> object type (<code>AverageCellDemand</code> and <code>MedianCellDemand</code>), and create functions to set the values of these columns. (For example, <code>AverageCellDemand</code> is <code>TotGridDemand</code> divided by 100.) Then, create b-tree indexes on the <code>AverageCellDemand</code> and <code>MedianCellDemand</code> columns.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="ADDCI4794"></a>
<div class="sect2"><a id="sthref622"></a>
<h3 class="sect2">Queries Benefiting from Extensible Indexing</h3>
<p><a id="sthref623"></a><a id="sthref624"></a>A query benefits from a domain index if the data being queried against cannot be made a simple attribute of a table or if the operation to be performed on the data is not one of the standard operations supported by Oracle indexes.</p>
<p>Examples of queries that would benefit from extensible indexing (using the power demand cartridge) include:</p>
<ul>
<li>
<p>Find the first cell for a specified time where the power demand was equal to a specified value.</p>
<p>By asking for the first cell, the query goes beyond a simple true-false check (such as finding out whether <span class="italic">any</span> cell for a specified time had a demand equal to a specified value), and thus benefits from a domain index.</p>
</li>
<li>
<p>Find the time for which there was the greatest disparity, or difference between the cell with the minimum demand and the cell with the maximum demand.</p>
</li>
<li>
<p>Find all times for which <code>3</code> or more cells had a demand greater than a specified value.</p>
</li>
<li>
<p>Find all times for which 10 or more cells had a demand not less than a specified value.</p>
</li>
<li>
<p>Find all times for which the total grid demand rose 10 percent or more over the preceding time's total grid demand.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005282"></a><a id="ADDCI4795"></a>
<div class="sect1">
<h2 class="sect1">Creating the Domain Index</h2>
<p><a id="sthref625"></a><a id="sthref626"></a>This section explains the parts of the power demand cartridge as they relate to extensible indexing. Explanatory text and code segments are mixed.</p>
<p><a id="sthref627"></a><a id="sthref628"></a><a id="sthref629"></a>The entire cartridge definition is available online as extdemo1.sql in the standard Oracle demo directory (location is platform-dependent).</p>
<a id="ADDCI4796"></a>
<div class="sect2"><a id="sthref630"></a>
<h3 class="sect2">Creating the Schema to Own the Index</h3>
<p>Before you create a domain index, create a database user, or schema. to own the index. In the power demand example, the user <code>PowerCartUser</code> is created and granted the appropriate privileges. All database structures related to the cartridge are created under this user (that is, while the cartridge developer or DBA is connected to the database as <code>PowerCartUser</code>), as demonstrated in <a href="#CIAEDEHD">Example 15-1</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEDEHD"></a><a id="ADDCI4797"></a>Example 15-1 Creating a Database User for the Power Demand Cartridge</p>
<pre>
set echo on
connect sys/knl_test7 as sysdba;
drop user PowerCartUser cascade;
create user PowerCartUser identified by PowerCartUser;

-------------------------------------------------------------------
-- INITIAL SET-UP
-------------------------------------------------------------------
-- grant privileges --
grant connect, resource to PowerCartUser;
grant create operator to PowerCartUser;
grant create indextype to PowerCartUser;
grant create table to PowerCartUser;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4798"></a>
<div class="sect2"><a id="sthref631"></a>
<h3 class="sect2">Creating the Object Type PowerDemand_Typ</h3>
<p>The object type <code>PowerDemand_Typ</code> is used to store the hourly power grid readings. This type is used to define a column in the table in which the readings are stored.</p>
<p>First, two types are defined for later use, as demonstrated in <a href="#CIABCEDC">Example 15-2</a>.</p>
<ul>
<li>
<p><code>PowerGrid_Typ</code>, to define the cells in <code>PowerDemand_Typ</code></p>
</li>
<li>
<p><code>NumTab_Typ</code>, to be used in the table in which the index entries are stored</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="CIABCEDC"></a><a id="ADDCI4799"></a>Example 15-2 Creating PowerGrid_Typ and NumTab_Typ Types for Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE TYPE PowerGrid_Typ as VARRAY(100) of NUMBER;
CREATE OR REPLACE TYPE NumTab_Typ as TABLE of NUMBER;
</pre></div>
<!-- class="example" -->
<p>The <code>PowerDemand_Typ</code> type, as demonstrated in <a href="#CIAJAEDB">Example 15-3</a>, includes:</p>
<ul>
<li>
<p>Three attributes (<code>TotGridDemand</code>, <code>MaxCellDemand</code>, <code>MinCellDemand</code>) that are set by three member procedures</p>
</li>
<li>
<p>Power demand readings (<code>100</code> cells in a grid)</p>
</li>
<li>
<p>The date/time of the power demand readings. (Every hour, <code>100</code> areas transmit their power demand readings.)</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="CIAJAEDB"></a><a id="ADDCI4800"></a>Example 15-3 Creating PowerDemand_Typ Type for Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE TYPE PowerDemand_Typ AS OBJECT (
  -- Total power demand for the grid
  TotGridDemand NUMBER,
  -- Cell with maximum/minimum power demand for the grid
  MaxCellDemand NUMBER,
  MinCellDemand NUMBER,
  -- Power grid: 10X10 array represented as Varray(100)
  -- using previously defined PowerGrid_Typ
  CellDemandValues PowerGrid_Typ,
  -- Date/time for power-demand samplings: Every hour,
  -- 100 areas transmit their power demand readings.
  SampleTime DATE,
  --
  -- Methods (Set...) for this type:
  -- Total demand for the entire power grid for a
  -- SampleTime: sets the value of TotGridDemand.
  Member Procedure SetTotalDemand,
  -- Maximum demand for the entire power grid for a
  -- SampleTime: sets the value of MaxCellDemand.
  Member Procedure SetMaxDemand,
  -- Minimum demand for the entire power grid for a
  -- SampleTime: sets the value of MinCellDemand.
  Member Procedure SetMinDemand
);
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4801"></a>
<div class="sect2"><a id="sthref632"></a>
<h3 class="sect2">Defining the Object Type Methods</h3>
<p>The <code>PowerDemand_Typ</code> object type has methods that set the first three attributes in the type definition:</p>
<ul>
<li>
<p><code>TotGridDemand</code>, the total demand for the entire power grid for the hour in question (identified by <code>SampleTime</code>)</p>
</li>
<li>
<p><code>MaxCellDemand</code>, the highest power demand value for all cells for the <code>SampleTime</code></p>
</li>
<li>
<p><code>MinCellDemand</code>, the lowest power demand value for all cells for the <code>SampleTime</code></p>
</li>
</ul>
<p>The logic for each procedure is not complicated. <code>SetTotDemand</code> loops through the cell values and creates a running total. <code>SetMaxDemand</code> compares the first two cell values and saves the higher as the current highest value; it then examines each successive cell, comparing it against the current highest value and saving the higher of the two as the current highest value, until it reaches the end of the cell values. <code>SetMinDemand</code> uses the same approach as <code>SetMaxDemand</code>, but it continually saves the lower value in comparisons to derive the lowest value overall, as demonstrated in <a href="#CIAEIAFE">Example 15-4</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEIAFE"></a><a id="ADDCI4802"></a>Example 15-4 Implementing PowerDemand_Typ Type for Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE TYPE BODY PowerDemand_Typ 
IS
  --
  -- Methods (Set...) for this type:
  -- Total demand for the entire power grid for a
  -- SampleTime: sets the value of TotGridDemand.
  Member Procedure SetTotalDemand 
  IS
  I BINARY_INTEGER;
  Total NUMBER;
  BEGIN
    Total :=0;
    I := CellDemandValues.FIRST;   
    WHILE I IS NOT NULL LOOP
   Total := Total + CellDemandValues(I);
        I := CellDemandValues.NEXT(I);
    END LOOP;
    TotGridDemand := Total;
  END;

  -- Maximum demand for the entire power grid for a
  -- SampleTime: sets the value of MaxCellDemand.
  Member Procedure SetMaxDemand 
  IS
  I BINARY_INTEGER;
  Temp NUMBER;
  BEGIN
    I := CellDemandValues.FIRST;   
    Temp := CellDemandValues(I);
    WHILE I IS NOT NULL LOOP
   IF Temp &lt; CellDemandValues(I) THEN
      Temp := CellDemandValues(I);
   END IF;
        I := CellDemandValues.NEXT(I);
    END LOOP;
    MaxCellDemand := Temp;
  END;

  -- Minimum demand for the entire power grid for a
  -- SampleTime: sets the value of MinCellDemand.
  Member Procedure SetMinDemand 
  IS
  I BINARY_INTEGER;
  Temp NUMBER;
  BEGIN
    I := CellDemandValues.FIRST;   
    Temp := CellDemandValues(I);
    WHILE I IS NOT NULL LOOP
   IF Temp &gt; CellDemandValues(I) THEN
      Temp := CellDemandValues(I);
   END IF;
        I := CellDemandValues.NEXT(I);
    END LOOP;
    MinCellDemand := Temp;
  END;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4803"></a>
<div class="sect2"><a id="sthref633"></a>
<h3 class="sect2">Creating the Functions and Operators</h3>
<p>The power demand cartridge is designed so that users can query the power grid for relationships of <code>equality</code>, <code>greaterthan</code>, or <code>lessthan</code>. However, because of the way the cell demand data is stored, the standard operators (<code>=</code>, <code>&gt;</code>, <code>&lt;</code>) cannot be used. Instead, new operators must be created, and a function must be created to define the implementation for each new operator (that is, how the operator is to be interpreted by Oracle).</p>
<p>For this cartridge, each of the three relationships can be checked in two ways:</p>
<ul>
<li>
<p>Whether a specific cell in the grid satisfies the relationship. For example, are there grids where cell <code>(3,7)</code> has demand equal to <code>25</code>?</p>
<p>These operators have names in the form <code>Power_XxxxxSpecific()</code>, such as <code>Power_EqualsSpecific()</code>, and the implementing functions have names in the form <code>Power_XxxxxSpecific_Func()</code>.</p>
</li>
<li>
<p>Whether any cell in the grid satisfies the relationship. For example, are there grids where any cell has demand equal to <code>25</code>?</p>
<p>These operators have names in the form <code>Power_XxxxxAny()</code>, such as <code>Power_EqualsAny()</code>, and the implementing functions have names in the form <code>Power_XxxxxAny_Func()</code>.</p>
</li>
</ul>
<p>For each operator-function pair, the function is defined first and then the operator as using the function. The function is the implementation that would be used if there were no index defined. This implementation must be specified so that the Oracle optimizer can determine costs, decide whether the index should be used, and create an execution plan.</p>
<p><a href="#g1012446">Table 15-3</a> shows the operators and implementing functions:</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4804"></a><a id="sthref634"></a><a id="g1012446"></a>Table 15-3 Operators and Implementing Functions</p>
<table class="cellalignment1246" title="Operators and Implementing Functions" summary="Lists operators defined for the Power Demand cartridge example along with their implementing functions" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t5">Operator</th>
<th class="cellalignment1247" id="r1c2-t5">Implementing Function</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t5" headers="r1c1-t5">
<pre>
Power_EqualsSpecific()
</pre></td>
<td class="cellalignment1243" headers="r2c1-t5 r1c2-t5">
<pre>
Power_EqualsSpecific_Func()
</pre></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t5" headers="r1c1-t5">
<pre>
Power_EqualsAny()
</pre></td>
<td class="cellalignment1243" headers="r3c1-t5 r1c2-t5">
<pre>
Power_EqualsAny_Func()
</pre></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t5" headers="r1c1-t5">
<pre>
Power_LessThanSpecific()
</pre></td>
<td class="cellalignment1243" headers="r4c1-t5 r1c2-t5">
<pre>
Power_LessThanSpecific_Func()
</pre></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t5" headers="r1c1-t5">
<pre>
Power_LessThanAny()
</pre></td>
<td class="cellalignment1243" headers="r5c1-t5 r1c2-t5">
<pre>
Power_LessThanAny_Func()
</pre></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t5" headers="r1c1-t5">
<pre>
Power_GreaterThanSpecific()
</pre></td>
<td class="cellalignment1243" headers="r6c1-t5 r1c2-t5">
<pre>
Power_GreaterThanSpecific_Func()
</pre></td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t5" headers="r1c1-t5">
<pre>
Power_GreaterThanAny()
</pre></td>
<td class="cellalignment1243" headers="r7c1-t5 r1c2-t5">
<pre>
Power_GreaterThanAny_Func()
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Each function and operator returns a numeric value of <code>1</code> if the condition is true (for example, if the specified cell is equal to the specified value), <code>0</code> if the condition is not true, or <code>null</code> if the specified cell number is invalid.</p>
<p>The statements in <a href="#CIAFCFJD">Example 15-5</a> create the implementing functions, <code>Power_xxx_Func()</code>, first the <code>specific</code> and then the <code>any</code> implementations.</p>
<div class="example">
<p class="titleinexample"><a id="CIAFCFJD"></a><a id="ADDCI4805"></a>Example 15-5 Implementing Power_XXX_Func() Functions for Power Demand Cartridge</p>
<pre>
CREATE FUNCTION Power_EqualsSpecific_Func(
  object PowerDemand_Typ, cell NUMBER, value NUMBER)
RETURN NUMBER AS
  BEGIN
  IF cell &lt;= object.CellDemandValues.LAST
  THEN
     IF (object.CellDemandValues(cell) = value) THEN
   RETURN 1;
     ELSE
   RETURN 0;
     END IF;
  ELSE
     RETURN NULL;
  END IF;
  END;
/
CREATE FUNCTION Power_GreaterThanSpecific_Func(
  object PowerDemand_Typ, cell NUMBER, value NUMBER)
RETURN NUMBER AS
  BEGIN
  IF cell &lt;= object.CellDemandValues.LAST
  THEN
     IF (object.CellDemandValues(cell) &gt; value) THEN
   RETURN 1;
     ELSE
   RETURN 0;
     END IF;
  ELSE
     RETURN NULL;
  END IF;
  END;
/
CREATE FUNCTION Power_LessThanSpecific_Func(
  object PowerDemand_Typ, cell NUMBER, value NUMBER)
RETURN NUMBER AS
  BEGIN
  IF cell &lt;= object.CellDemandValues.LAST
  THEN
     IF (object.CellDemandValues(cell) &lt; value) THEN
   RETURN 1;
     ELSE
   RETURN 0;
     END IF;
  ELSE
     RETURN NULL;
  END IF;
  END;
/
CREATE FUNCTION Power_EqualsAny_Func(
  object PowerDemand_Typ, value NUMBER)
RETURN NUMBER AS
   idx NUMBER;
  BEGIN
    FOR idx IN object.CellDemandValues.FIRST..object.CellDemandValues.LAST LOOP
      IF (object.CellDemandValues(idx) = value) THEN
   RETURN 1;
      END IF;
    END LOOP;
   RETURN 0;
  END;
/
CREATE FUNCTION Power_GreaterThanAny_Func(
  object PowerDemand_Typ, value NUMBER)
RETURN NUMBER AS
   idx NUMBER;
  BEGIN
    FOR idx IN object.CellDemandValues.FIRST..object.CellDemandValues.LAST LOOP
      IF (object.CellDemandValues(idx) &gt; value) THEN
   RETURN 1;
      END IF;
    END LOOP;
   RETURN 0;
  END;
/
CREATE FUNCTION Power_LessThanAny_Func(
  object PowerDemand_Typ, value NUMBER)
RETURN NUMBER AS
   idx NUMBER;
  BEGIN
    FOR idx IN object.CellDemandValues.FIRST..object.CellDemandValues.LAST LOOP
      IF (object.CellDemandValues(idx) &lt; value) THEN
   RETURN 1;
      END IF;
    END LOOP;
   RETURN 0;
  END;
/
</pre></div>
<!-- class="example" -->
<p>The statements in <a href="#CIADJEDC">Example 15-6</a> create the operators (<code>Power_xxx</code>). Each statement specifies an implementing function.</p>
<div class="example">
<p class="titleinexample"><a id="CIADJEDC"></a><a id="ADDCI4806"></a>Example 15-6 Implementing Power_XXX() Functions for Power Demand Cartridge</p>
<pre>
CREATE OPERATOR Power_Equals BINDING(PowerDemand_Typ, NUMBER, NUMBER)
  RETURN NUMBER USING Power_EqualsSpecific_Func;
CREATE OPERATOR Power_GreaterThan BINDING(PowerDemand_Typ, NUMBER, NUMBER)
  RETURN NUMBER USING Power_GreaterThanSpecific_Func;
CREATE OPERATOR Power_LessThan BINDING(PowerDemand_Typ, NUMBER, NUMBER)
  RETURN NUMBER USING Power_LessThanSpecific_Func;
  
CREATE OPERATOR Power_EqualsAny BINDING(PowerDemand_Typ, NUMBER)
  RETURN NUMBER USING Power_EqualsAny_Func;
CREATE OPERATOR Power_GreaterThanAny BINDING(PowerDemand_Typ, NUMBER)
  RETURN NUMBER USING Power_GreaterThanAny_Func;
CREATE OPERATOR Power_LessThanAny BINDING(PowerDemand_Typ, NUMBER)
  RETURN NUMBER USING Power_LessThanAny_Func;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4807"></a>
<div class="sect2"><a id="sthref635"></a>
<h3 class="sect2">Creating the Indextype Implementation Methods</h3>
<p><a id="sthref636"></a>The power demand cartridge creates an object type for the indextype that specifies methods for the domain index. These methods are part of the <code>ODCIIndex</code> (Oracle Data Cartridge Interface Index) interface, and they collectively define the behavior of the index in terms of the methods for defining, manipulating, scanning, and exporting the index.</p>
<p><a href="#g1012471">Table 15-4</a> shows the method functions (all but one starting with <code>ODCIIndex</code>) created for the power demand cartridge.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4808"></a><a id="sthref637"></a><a id="g1012471"></a>Table 15-4 Indextype Methods</p>
<table class="cellalignment1246" title="Indextype Methods" summary="Lists the method functions created for the Power Demand cartridge example and describes each" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t6">Method</th>
<th class="cellalignment1247" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#BJEJEIJD">ODCIGetInterfaces()</a></p>
</td>
<td class="cellalignment1243" headers="r2c1-t6 r1c2-t6">
<p>Returns the list interface names implemented by the type.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a></p>
</td>
<td class="cellalignment1243" headers="r3c1-t6 r1c2-t6">
<p>Creates a table to store index data. If the base table containing data to be indexed is not empty, this method builds the index for existing data.</p>
<p>This method is called when a <code>CREATE</code> <code>INDEX</code> statement is issued that refers to the indextype. Upon invocation, any parameters specified in the <code>PARAMETERS</code> clause are passed in along with a description of the index.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a></p>
</td>
<td class="cellalignment1243" headers="r4c1-t6 r1c2-t6">
<p>Drops the table that stores the index data. This method is called when a <code>DROP</code> <code>INDEX</code> statement specifies the index.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a></p>
</td>
<td class="cellalignment1243" headers="r5c1-t6 r1c2-t6">
<p>Initializes the scan of the index for the operator predicate. This method is invoked when a query is submitted involving an operator that can be executed using the domain index.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a></p>
</td>
<td class="cellalignment1243" headers="r6c1-t6 r1c2-t6">
<p>Returns the <code>ROWID</code> of each row that satisfies the operator predicate.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a></p>
</td>
<td class="cellalignment1243" headers="r7c1-t6 r1c2-t6">
<p>Ends the current use of the index. This method can perform any necessary clean-up.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r8c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a></p>
</td>
<td class="cellalignment1243" headers="r8c1-t6 r1c2-t6">
<p>Maintains the index structure when a record is inserted in a table that contains columns or object attributes indexed by the indextype.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r9c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a></p>
</td>
<td class="cellalignment1243" headers="r9c1-t6 r1c2-t6">
<p>Maintains the index structure when a record is deleted from a table that contains columns or object attributes indexed by the indextype.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r10c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a></p>
</td>
<td class="cellalignment1243" headers="r10c1-t6 r1c2-t6">
<p>Maintains the index structure when a record is updated (modified) in a table that contains columns or object attributes indexed by the indextype.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r11c1-t6" headers="r1c1-t6">
<p><a href="ext_idx_ref.htm#i76838">ODCIIndexGetMetadata()</a></p>
</td>
<td class="cellalignment1243" headers="r11c1-t6 r1c2-t6">
<p>Allows the export and import of implementation-specific metadata associated with the index.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="ADDCI4809"></a>
<div class="sect3"><a id="sthref638"></a>
<h4 class="sect3">Type Definition</h4>
<p><a href="#CIAFGJIC">Example 15-7</a> creates the <code>power_idxtype_im</code> object type. The methods of this type are the ODCI methods to define, manipulate, and scan the domain index. The <code>curnum</code> attribute is the cursor number used as context for the scan routines <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a>, <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a>, and <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAFGJIC"></a><a id="ADDCI4810"></a>Example 15-7 Creating power_idxtype_im Object Type for Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE TYPE power_idxtype_im AS OBJECT
(
  curnum NUMBER,
  STATIC FUNCTION ODCIGetInterfaces(ifclist OUT sys.ODCIObjectList)
     RETURN NUMBER,
  STATIC FUNCTION ODCIIndexCreate (ia sys.ODCIIndexInfo, parms VARCHAR2, 
     env sys.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexDrop(ia sys.ODCIIndexInfo, env sys.ODCIEnv)
     RETURN NUMBER,
  STATIC FUNCTION ODCIIndexStart(sctx IN OUT power_idxtype_im,
                                 ia sys.ODCIIndexInfo,
                                 op sys.ODCIPredInfo, qi sys.ODCIQueryInfo,
                                 strt NUMBER, stop NUMBER,
                                 cmppos NUMBER, cmpval NUMBER, env sys.ODCIEnv) 
     RETURN NUMBER,
  STATIC FUNCTION ODCIIndexStart(sctx IN OUT power_idxtype_im,
                                 ia sys.ODCIIndexInfo,
                                 op sys.ODCIPredInfo, qi sys.ODCIQueryInfo,
                                 strt NUMBER, stop NUMBER,
                                 cmpval NUMBER, env sys.ODCIEnv)
     RETURN NUMBER,
  MEMBER FUNCTION ODCIIndexFetch(nrows NUMBER, rids OUT sys.ODCIRidList, 
     env sys.ODCIEnv) RETURN NUMBER,
  MEMBER FUNCTION ODCIIndexClose (env sys.ODCIEnv) RETURN NUMBER,
  STATIC FUNCTION ODCIIndexInsert(ia sys.ODCIIndexInfo, rid VARCHAR2,
                                  newval PowerDemand_Typ, env sys.ODCIEnv)
     RETURN NUMBER,
  STATIC FUNCTION ODCIIndexDelete(ia sys.ODCIIndexInfo, rid VARCHAR2,
                                  oldval PowerDemand_Typ, env sys.ODCIEnv)
     RETURN NUMBER,
  STATIC FUNCTION ODCIIndexUpdate(ia sys.ODCIIndexInfo, rid VARCHAR2,
                                  oldval PowerDemand_Typ, 
                                  newval PowerDemand_Typ, env sys.ODCIEnv) 
     RETURN NUMBER,
  STATIC FUNCTION ODCIIndexGetMetadata(ia sys.ODCIIndexInfo, 
                                       expversion VARCHAR2, 
                                       newblock OUT PLS_INTEGER, 
                                       env sys.ODCIEnv) 
     RETURN VARCHAR2
);
/
</pre></div>
<!-- class="example" -->
<p>The <code>CREATE</code> <code>TYPE</code> statement is followed by a <code>CREATE</code> <code>TYPE</code> <code>BODY</code> statement that specifies the implementation for each member function:</p>
<pre>
CREATE OR REPLACE TYPE BODY power_idxtype_im 
IS
...
</pre>
<p>Each type method is described in a separate section, but the method definitions (except for <a href="ext_idx_ref.htm#i76838">ODCIIndexGetMetadata()</a>, which returns a <code>VARCHAR2</code> string) have the following general form:</p>
<pre>
  STATIC FUNCTION function-name (...) 
    RETURN NUMBER
  IS
  ...
  END;
</pre></div>
<!-- class="sect3" -->
<a id="CIHGIJEG"></a><a id="ADDCI4811"></a>
<div class="sect3">
<h4 class="sect3">ODCIGetInterfaces() Method</h4>
<p><a id="sthref639"></a>The <a href="ext_idx_ref.htm#BJEJEIJD">ODCIGetInterfaces()</a> function returns the list of names of the interfaces implemented by the type. To specify the current version of these interfaces, the <a href="ext_idx_ref.htm#BJEJEIJD">ODCIGetInterfaces()</a> routine must return<code>'SYS.ODCIINDEX2'</code> in the <code>OUT</code> parameter, as demonstrated in <a href="#CIAIHJBJ">Example 15-8</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAIHJBJ"></a><a id="ADDCI4812"></a>Example 15-8 Registering Interface and Index Functions in Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIGetInterfaces(
  ifclist OUT sys.ODCIObjectList)
RETURN NUMBER IS
BEGIN
  ifclist := sys.ODCIObjectList(sys.ODCIObject('SYS','ODCIINDEX2'));
  return ODCIConst.Success;
END ODCIGetInterfaces;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4813"></a>
<div class="sect3"><a id="sthref640"></a>
<h4 class="sect3">ODCIIndexCreate() Method</h4>
<p><a id="sthref641"></a>The <a href="ext_idx_ref.htm#i78714">ODCIIndexCreate()</a> function creates the table to store index data. If the base table containing data to be indexed is not empty, this method inserts the index data entries for existing data.</p>
<p>The function takes the index information as an object parameter whose type is <code>SYS</code>.<code>ODCIINDEXINFO</code>. The type attributes include the index name, owner name, and so forth. The <code>PARAMETERS</code> string specified in the <code>CREATE</code> <code>INDEX</code> statement is also passed in as a parameter to the function, as demonstrated in <a href="#CIAFJFEH">Example 15-9</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAFJFEH"></a><a id="ADDCI4814"></a>Example 15-9 Registering ODCIIndexCreate() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexCreate (
  ia sys.ODCIIndexInfo,
  parms VARCHAR2,
  env sys.ODCIEnv)
RETURN NUMBER IS
  i INTEGER;
  r ROWID;
  p NUMBER;
  v NUMBER;
  stmt1 VARCHAR2(1000);
  stmt2 VARCHAR2(1000);
  stmt3 VARCHAR2(1000);
  cnum1 INTEGER;
  cnum2 INTEGER;
  cnum3 INTEGER;
junk NUMBER;
</pre>
<p>The SQL statement to create the table for the index data is constructed and executed. The table includes the <code>ROWID</code> of the base table, <code>r</code>, the cell position number (<code>cpos</code>) in the grid from 1 to 100, and the power demand value in that cell (<code>cval</code>).</p>
<pre>
BEGIN
  -- Construct the SQL statement.
  stmt1 := 'CREATE TABLE ' || ia.IndexSchema || '.' || ia.IndexName ||'_pidx' ||
      '( r ROWID, cpos NUMBER, cval NUMBER)';

  -- Dump the SQL statement.
  dbms_output.put_line('ODCIIndexCreate&gt;&gt;&gt;&gt;&gt;');
  sys.ODCIIndexInfoDump(ia);
  dbms_output.put_line('ODCIIndexCreate&gt;&gt;&gt;&gt;&gt;'||stmt1);

  -- Execute the statement.
  cnum1 := dbms_sql.open_cursor;
  dbms_sql.parse(cnum1, stmt1, dbms_sql.native);
  junk := dbms_sql.execute(cnum1);
  dbms_sql.close_cursor(cnum1);
</pre>
<p>The function populates the index by inserting rows into the table. The function "unnests" the <code>VARRAY</code> attribute and inserts a row for each cell into the table. Thus, each 10 X 10 grid (10 rows, 10 values for each row) becomes 100 rows in the table (one row for each cell).</p>
<pre>
  -- Now populate the table.
  stmt2 := ' INSERT INTO '|| ia.IndexSchema || '.' || ia.IndexName || '_pidx' ||
      ' SELECT :rr, ROWNUM, column_value FROM THE' || ' (SELECT CAST (P.'||
      ia.IndexCols(1).ColName||'.CellDemandValues AS NumTab_Typ)'|| ' FROM ' ||
      ia.IndexCols(1).TableSchema || '.' || ia.IndexCols(1).TableName || ' P' ||
      ' WHERE P.ROWID = :rr)';
 
  -- Execute the statement.
  dbms_output.put_line('ODCIIndexCreate&gt;&gt;&gt;&gt;&gt;'||stmt2);
 
  -- Parse the statement.
  cnum2 := dbms_sql.open_cursor;
  dbms_sql.parse(cnum2, stmt2, dbms_sql.native);
 
  stmt3 := 'SELECT ROWID FROM '|| ia.IndexCols(1).TableSchema || '.' ||
      ia.IndexCols(1).TableName;
  dbms_output.put_line('ODCIIndexCreate&gt;&gt;&gt;&gt;&gt;'||stmt3);
  cnum3 := dbms_sql.open_cursor;
  dbms_sql.parse(cnum3, stmt3, dbms_sql.native);
  dbms_sql.define_column_rowid(cnum3, 1, r);   
  junk := dbms_sql.execute(cnum3);
 
   WHILE dbms_sql.fetch_rows(cnum3) &gt; 0 LOOP
    -- Get column values of the row. --
    dbms_sql.column_value_rowid(cnum3, 1, r);
    -- Bind the row into the cursor for the next insert. --
    dbms_sql.bind_variable_rowid(cnum2, ':rr', r);
    junk := dbms_sql.execute(cnum2);
  END LOOP;
</pre>
<p>The function concludes by closing the cursors and returning a success status.</p>
<pre>
  dbms_sql.close_cursor(cnum2);
  dbms_sql.close_cursor(cnum3);
  RETURN ODCICONST.SUCCESS;
END ODCIInexCreate;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4815"></a>
<div class="sect3"><a id="sthref642"></a>
<h4 class="sect3">ODCIIndexDrop() Method</h4>
<p><a id="sthref643"></a>The <a href="ext_idx_ref.htm#i79038">ODCIIndexDrop()</a> function drops the table that stores the index data, as demonstrated in <a href="#CIADADCD">Example 15-10</a>. This method is called when a <code>DROP</code> <code>INDEX</code> statement is issued.</p>
<div class="example">
<p class="titleinexample"><a id="CIADADCD"></a><a id="ADDCI4816"></a>Example 15-10 Registering ODCIIndexDrop() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexDrop(ia sys.ODCIIndexInfo, env sys.ODCIEnv)
RETURN NUMBER IS
  stmt VARCHAR2(1000);
  cnum INTEGER;
  junk INTEGER;
BEGIN
  -- Construct the SQL statement.
  stmt := 'drop table ' || ia.IndexSchema || '.' || ia.IndexName || '_pidx';
  
  dbms_output.put_line('ODCIIndexDrop&gt;&gt;&gt;&gt;&gt;');
  sys.ODCIIndexInfoDump(ia);
  dbms_output.put_line('ODCIIndexDrop&gt;&gt;&gt;&gt;&gt;'||stmt);
  
  -- Execute the statement.
  cnum := dbms_sql.open_cursor;
  dbms_sql.parse(cnum, stmt, dbms_sql.native);
  junk := dbms_sql.execute(cnum);
  dbms_sql.close_cursor(cnum);
  
  RETURN ODCICONST.SUCCESS;
END ODCIIndexDrop;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIAJCCCC"></a><a id="ADDCI4817"></a>
<div class="sect3">
<h4 class="sect3">ODCIIndexStart() Method for <span class="bold">Specific</span> Queries</h4>
<p><a id="sthref644"></a>The first definition of the <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> function initializes the scan of the index to return all rows that satisfy the operator predicate. For example, if a query asks for all instances where cell <code>(3,7)</code> has a value equal to <code>25</code>, the function initializes the scan to return all rows in the index-organized table for which that cell has that value. This definition of <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> differs from the definition in the section <a href="#CIADIABA">"ODCIIndexStart() Method for <span class="bold">Any</span> Queries"</a> in that it includes the <code>cmppos</code> parameter for the position of the cell.</p>
<p>The <code>self</code> parameter is the context that is shared with the <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> and <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> functions. The <code>ia</code> parameter contains the index information as an object instance of type <code>SYS</code>.<code>ODCIINDEXINFO</code>, and the <code>op</code> parameter contains the operator information as an object instance of type <code>SYS</code>.<code>ODCIOPERINFO</code>. The <code>strt</code> and <code>stop</code> parameters are the lower and upper boundary points for the operator return value. The <code>cmppos</code> parameter is the cell position and <code>cmpval</code> is the value in the cell specified by the operator <code>Power_XxxxxSpecific()</code>. This is demonstrated in <a href="#CIAEHIJB">Example 15-11</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEHIJB"></a><a id="ADDCI4818"></a>Example 15-11 Registering ODCIIndexStart() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexStart(
  sctx IN OUT power_idxtype_im, 
  ia sys.ODCIIndexInfo,
  op sys.ODCIPredInfo, 
  qi sys.ODCIQueryInfo,
  strt NUMBER, stop NUMBER,
  cmppos NUMBER, 
  cmpval NUMBER, 
  env sys.ODCIEnv ) 
RETURN NUMBER IS
  cnum INTEGER;
  rid ROWID;
  nrows INTEGER;
  relop VARCHAR2(2);
  stmt VARCHAR2(1000);
BEGIN
  dbms_output.put_line('ODCIIndexStart&gt;&gt;&gt;&gt;&gt;');
  sys.ODCIIndexInfoDump(ia);
  sys.ODCIPredInfoDump(op);
  dbms_output.put_line('start key : '||strt);
  dbms_output.put_line('stop key : '||stop);
  dbms_output.put_line('compare position : '||cmppos);
  dbms_output.put_line('compare value : '||cmpval);
</pre>
<p>The function checks for errors in the predicate.</p>
<pre>
  -- Take care of some error cases.
  -- The only predicates in which btree operators can appear are
  --    op() = 1     OR    op() = 0
  if (strt != 1) and (strt != 0) then
    raise_application_error(-20101, 'Incorrect predicate for operator');
  END if;
 
  if (stop != 1) and (stop != 0) then
    raise_application_error(-20101, 'Incorrect predicate for operator');
  END if;
</pre>
<p>The function generates the SQL statement to be executed. It determines the operator name and the lower and upper index value bounds (the start and stop keys). The start and stop keys can both be 1 (= <code>TRUE</code>) or both be 0 (= <code>FALSE</code>).</p>
<pre>
  -- Generate the SQL statement to be executed.
  -- First, figure out the relational operator needed for the statement.
  -- Take into account the operator name and the start and stop keys. For now, 
  -- the start and stop keys can both be 1 (= TRUE) or both be 0 (= FALSE).
  if op.ObjectName = 'POWER_EQUALS' then
    if strt = 1 then 
      relop := '=';
    else
      relop := '!=';
    end if;
  elsif op.ObjectName = 'POWER_LESSTHAN' then
    if strt = 1 then 
      relop := '&lt;';
    else
      relop := '&gt;=';
    end if;
  elsif op.ObjectName = 'POWER_GREATERTHAN' then
    if strt = 1 then 
      relop := '&gt;';
    else
      relop := '&lt;=';
    end if;
  else
    raise_application_error(-20101, 'Unsupported operator');
  end if;
 
  stmt := 'select r from '||ia.IndexSchema||'.'||ia.IndexName||'_pidx'||
      ' where cpos '|| '=' ||''''||cmppos||''''|| ' and cval ' ||relop||''''||
      cmpval||'''';
 
  dbms_output.put_line('ODCIIndexStart&gt;&gt;&gt;&gt;&gt;' || stmt);
   cnum := dbms_sql.open_cursor;
  dbms_sql.parse(cnum, stmt, dbms_sql.native);
  dbms_sql.define_column_rowid(cnum, 1, rid);   
  nrows := dbms_sql.execute(cnum);
</pre>
<p>The function stores the cursor number in the context, which is used by the <code>ODCIIndexFetch</code> function, and sets a success return status.</p>
<pre>
  -- Set context as the cursor number.
  stcx := power_idxtype_im(cnum);
 
  -- Return success.
  RETURN ODCICONST.SUCCESS;
END ODCIIndexStart;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIADIABA"></a><a id="ADDCI4819"></a>
<div class="sect3">
<h4 class="sect3">ODCIIndexStart() Method for <span class="bold">Any</span> Queries</h4>
<p><a id="sthref645"></a>This definition of the <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> function initializes the scan of the index to return all rows that satisfy the operator predicate. For example, if a query asks for all instances where any cell has a value equal to <code>25</code>, the function initializes the scan to return all rows in the index-organized table for which that cell has that value. This definition of <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> differs from the definition insection <a href="#CIAJCCCC">"ODCIIndexStart() Method for <span class="bold">Specific</span> Queries"</a> in that it does not include the <code>cmppos</code> parameter.</p>
<p>The <code>self</code> parameter is the context that is shared with the <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> and <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> functions. The <code>ia</code> parameter contains the index information as an object instance of type <code>SYS</code>.<code>ODCIINDEXINFO</code>, and the <code>op</code> parameter contains the operator information as an object instance of type <code>SYS</code>.<code>ODCIOPERINFO</code>. The <code>strt</code> and <code>stop</code> parameters are the lower and upper boundary points for the operator return value. The <code>cmpval</code> parameter is the value in the cell specified by the operator <code>Power_Xxxx()</code>.</p>
<div class="example">
<p class="titleinexample"><a id="ADDCI4820"></a><a id="sthref646"></a>Example 15-12 Registering ODCIIndexStart() for Any Queries for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexStart(
  sctx IN OUT power_idxtype_im, 
  ia sys.ODCIIndexInfo,
  op sys.ODCIPredInfo, 
  qi sys.ODCIQueryInfo,
  strt NUMBER, 
  stop NUMBER,
  cmpval NUMBER, 
  env sys.ODCIEnv ) 
RETURN NUMBER IS
  cnum INTEGER;
  rid ROWID;
  nrows INTEGER;
  relop VARCHAR2(2);
  stmt VARCHAR2(1000);
BEGIN
  dbms_output.put_line('ODCIIndexStart&gt;&gt;&gt;&gt;&gt;');
  sys.ODCIIndexInfoDump(ia);
  sys.ODCIPredInfoDump(op);
  dbms_output.put_line('start key : '||strt);
  dbms_output.put_line('stop key : '||stop);
  dbms_output.put_line('compare value : '||cmpval);
</pre>
<p>The function checks for errors in the predicate.</p>
<pre>
  -- Take care of some error cases.
  -- The only predicates in which btree operators can appear are
  --    op() = 1     OR    op() = 0
  if (strt != 1) and (strt != 0) then
    raise_application_error(-20101, 'Incorrect predicate for operator');
  END if;
 
  if (stop != 1) and (stop != 0) then
    raise_application_error(-20101, 'Incorrect predicate for operator');
  END if;
</pre>
<p>The function generates the SQL statement to be executed. It determines the operator name and the lower and upper index value bounds (the start and stop keys). The start and stop keys can both be 1 (= <code>TRUE</code>) or both be 0 (= <code>FALSE</code>).</p>
<pre>
  -- Generate the SQL statement to be executed.
  -- First, figure out the relational operator needed for the statement.
  -- Take into account the operator name and the start and stop keys. For now, 
  -- the start and stop keys can both be 1 (= TRUE) or both be 0 (= FALSE).
  if op.ObjectName = 'POWER_EQUALSANY' then
    relop := '=';
  elsif op.ObjectName = 'POWER_LESSTHANANY' then
    relop := '&lt;';
  elsif op.ObjectName = 'POWER_GREATERTHANANY' then
    relop := '&gt;';
  else
    raise_application_error(-20101, 'Unsupported operator');
  end if;
 
  -- This statement returns the qualifying rows for the TRUE case.
  stmt := 'select distinct r from '||ia.IndexSchema||'.'||ia.IndexName||'_pidx'||'
      where cval '||relop||''''||cmpval||'''';
  -- In the FALSE case, we must find the  complement of the rows.
  if (strt = 0) then
    stmt := 'select distinct r from '||ia.IndexSchema||'.'||ia.IndexName||
          '_pidx'||' minus '||stmt;
  end if;
 
  dbms_output.put_line('ODCIIndexStart&gt;&gt;&gt;&gt;&gt;' || stmt);
  cnum := dbms_sql.open_cursor;
  dbms_sql.parse(cnum, stmt, dbms_sql.native);
  dbms_sql.define_column_rowid(cnum, 1, rid);   
  nrows := dbms_sql.execute(cnum);
</pre>
<p>The function stores the cursor number in the context, which is used by the <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> function, and sets a success return status.</p>
<pre>
  -- Set context as the cursor number.
  self := power_idxtype_im(cnum);
 
  -- Return success.
  RETURN ODCICONST.SUCCESS;
END ODCIIndexStart;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIAJECGA"></a><a id="ADDCI4821"></a>
<div class="sect3">
<h4 class="sect3">ODCIIndexFetch() Method</h4>
<p><a id="sthref647"></a>The <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> function, demonstrated in <a href="#CIAGGBBD">Example 15-13</a> returns a batch of <code>ROWIDs</code> for the rows that satisfy the operator predicate. Each time <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> is invoked, it returns the next batch of rows (<code>rids</code> parameter, a collection of type <code>SYS</code>.<code>ODCIRIDLIST</code>) that satisfy the operator predicate. The maximum number of rows that can be returned on each invocation is specified by the <code>nrows</code> parameter.</p>
<p>Oracle invokes <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> repeatedly until all rows that satisfy the operator predicate have been returned.</p>
<div class="example">
<p class="titleinexample"><a id="CIAGGBBD"></a><a id="ADDCI4822"></a>Example 15-13 Registering ODCIIndexFetch() for Power Demand Cartridge</p>
<pre>
MEMBER FUNCTION ODCIIndexFetch(
  nrows NUMBER, 
  rids OUT sys.ODCIRidList, 
  env sys.ODCIEnv)
RETURN NUMBER IS
  cnum INTEGER;
  idx INTEGER := 1;
  rlist sys.ODCIRidList := sys.ODCIRidList();
  done boolean := FALSE;
</pre>
<p>The function loops through the collection of rows selected by the <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> function, using the same cursor number, <code>cnum</code>, as in the <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> function, and returns the <code>ROWIDs</code>.</p>
<pre>
BEGIN
  dbms_output.put_line('ODCIIndexFetch&gt;&gt;&gt;&gt;&gt;');
  dbms_output.put_line('Nrows : '||round(nrows));
 
  cnum := self.curnum;
 
  WHILE not done LOOP
    if idx &gt; nrows then
       done := TRUE;
    else
      rlist.extEND;
      if dbms_sql.fetch_rows(cnum) &gt; 0 then
        dbms_sql.column_value_rowid(cnum, 1, rlist(idx));
        idx := idx + 1;
      else
        rlist(idx) := null;
        done := TRUE;
      END if;
    END if;   
  END LOOP;
 
  rids := rlist;
  RETURN ODCICONST.SUCCESS;
END ODCIIndexFetch;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4823"></a>
<div class="sect3"><a id="sthref648"></a>
<h4 class="sect3">ODCIIndexClose() Method</h4>
<p><a id="sthref649"></a>The <a href="ext_idx_ref.htm#i77457">ODCIIndexClose()</a> function, demonstrated in <a href="#CIAEJGFH">Example 15-14</a>, closes the cursor used by the <a href="ext_idx_ref.htm#i78634">ODCIIndexStart()</a> and <a href="ext_idx_ref.htm#i76798">ODCIIndexFetch()</a> functions.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEJGFH"></a><a id="ADDCI4824"></a>Example 15-14 Registering ODCIIndexStart() for Power Demand Cartridge</p>
<pre>
MEMBER FUNCTION ODCIIndexClose (env sys.ODCIEnv) 
RETURN NUMBER IS 
  cnum INTEGER;
BEGIN
  dbms_output.put_line('ODCIIndexClose&gt;&gt;&gt;&gt;&gt;');
 
  cnum := self.curnum;
  dbms_sql.close_cursor(cnum);
  RETURN ODCICONST.SUCCESS;
END ODCIIndexClose;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4825"></a>
<div class="sect3"><a id="sthref650"></a>
<h4 class="sect3">ODCIIndexInsert() Method</h4>
<p><a id="sthref651"></a>The <a href="ext_idx_ref.htm#i76892">ODCIIndexInsert()</a> function, demonstrated in <a href="#CIAGGDAC">Example 15-15</a>, is called when a record is inserted in a table that contains columns or <code>OBJECT</code> attributes indexed by the indextype. The new values in the indexed columns are passed in as arguments along with the corresponding row identifier.</p>
<div class="example">
<p class="titleinexample"><a id="CIAGGDAC"></a><a id="ADDCI4826"></a>Example 15-15 Registering ODCIIndexInsert() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexInsert(
  ia sys.ODCIIndexInfo, 
  rid VARCHAR2, 
  newval PowerDemand_Typ, 
  env sys.ODCIEnv) 
RETURN NUMBER AS 
  cid INTEGER; 
  i BINARY_INTEGER;
  nrows INTEGER;
  stmt VARCHAR2(1000);
BEGIN 
  dbms_output.put_line(' ');
  dbms_output.put_line('ODCIIndexInsert&gt;&gt;&gt;&gt;&gt;'||' TotGridDemand= '||
      newval.TotGridDemand ||' MaxCellDemand= '||newval.MaxCellDemand ||
      ' MinCellDemand= '||newval.MinCellDemand) ;
  sys.ODCIIndexInfoDump(ia); 
      
  -- Construct the statement.
  stmt := ' INSERT INTO '|| ia.IndexSchema || '.' || ia.IndexName || '_pidx' ||
      ' VALUES (:rr, :pos, :val)';
  
  -- Execute the statement.
  dbms_output.put_line('ODCIIndexInsert&gt;&gt;&gt;&gt;&gt;'||stmt);
  -- Parse the statement.
  cid := dbms_sql.open_cursor;
  dbms_sql.parse(cid, stmt, dbms_sql.native);
  dbms_sql.bind_variable_rowid(cid, ':rr', rid);
      
  -- Iterate over the rows of the Varray and insert them.
  i := newval.CellDemandValues.FIRST;   
  WHILE i IS NOT NULL LOOP
    -- Bind the row into the cursor for insert.
    dbms_sql.bind_variable(cid, ':pos', i);   
    dbms_sql.bind_variable(cid, ':val', newval.CellDemandValues(i));
    -- Execute.
    nrows := dbms_sql.execute(cid);
    dbms_output.put_line('ODCIIndexInsert&gt;&gt;&gt;&gt;&gt;('||'RID'||' , '||i|| ' , '||
           newval.CellDemandValues(i)|| ')');
    i := newval.CellDemandValues.NEXT(i);
  END LOOP;

  dbms_sql.close_cursor(cid);
  RETURN ODCICONST.SUCCESS;
END ODCIIndexInsert;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4827"></a>
<div class="sect3"><a id="sthref652"></a>
<h4 class="sect3">ODCIIndexDelete() Method</h4>
<p><a id="sthref653"></a>The <a href="ext_idx_ref.htm#i76734">ODCIIndexDelete()</a> function, demonstrated in <a href="#CIAIGHCB">Example 15-16</a>, is called when a record is deleted from a table that contains columns or object attributes indexed by the indextype. The old values in the indexed columns are passed in as arguments along with the corresponding row identifier.</p>
<div class="example">
<p class="titleinexample"><a id="CIAIGHCB"></a><a id="ADDCI4828"></a>Example 15-16 Registering ODCIIndexDelete() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexDelete(
  ia sys.ODCIIndexInfo, 
  rid VARCHAR2,
  oldval PowerDemand_Typ,
  env sys.ODCIEnv) 
RETURN NUMBER AS 
  cid INTEGER; 
  stmt VARCHAR2(1000);
  nrows INTEGER; 
BEGIN 
  dbms_output.put_line(' ');
  dbms_output.put_line('ODCIIndexDelete&gt;&gt;&gt;&gt;&gt;'||' TotGridDemand= '||
      oldval.TotGridDemand ||' MaxCellDemand= '||oldval.MaxCellDemand ||
      ' MinCellDemand= '||oldval.MinCellDemand) ;
  sys.ODCIIndexInfoDump(ia); 
 
  -- Construct the statement.
  stmt := ' DELETE FROM '|| ia.IndexSchema || '.' ||ia.IndexName|| '_pidx' || 
      ' WHERE r=:rr';
  dbms_output.put_line('ODCIIndexDelete&gt;&gt;&gt;&gt;&gt;'||stmt);
 
  -- Parse and execute the statement.
  cid := dbms_sql.open_cursor;
  dbms_sql.parse(cid, stmt, dbms_sql.native);
  dbms_sql.bind_variable_rowid(cid, ':rr', rid);
  nrows := dbms_sql.execute(cid);     
  dbms_sql.close_cursor(cid);
 
  RETURN ODCICONST.SUCCESS;
END ODCIIndexDelete;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4829"></a>
<div class="sect3"><a id="sthref654"></a>
<h4 class="sect3">ODCIIndexUpdate() Method</h4>
<p><a id="sthref655"></a>The <a href="ext_idx_ref.htm#i77033">ODCIIndexUpdate()</a> function, demonstrated in <a href="#CIAJDCEC">Example 15-17</a>, is called when a record is updated in a table that contains columns or object attributes indexed by the indextype. The old and new values in the indexed columns are passed in as arguments along with the row identifier.</p>
<div class="example">
<p class="titleinexample"><a id="CIAJDCEC"></a><a id="ADDCI4830"></a>Example 15-17 Registering ODCIIndexUpdate() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexUpdate(
  ia sys.ODCIIndexInfo, 
  rid VARCHAR2, 
  oldval PowerDemand_Typ, 
  newval PowerDemand_Typ, 
  env sys.ODCIEnv) 
RETURN NUMBER AS 
  cid INTEGER; 
  cid2 INTEGER; 
  stmt VARCHAR2(1000);
  stmt2 VARCHAR2(1000);
  nrows INTEGER; 
  i NUMBER;
BEGIN 
  dbms_output.put_line(' ');
  dbms_output.put_line('ODCIIndexUpdate&gt;&gt;&gt;&gt;&gt; Old'||' TotGridDemand= '||
      oldval.TotGridDemand||' MaxCellDemand= '||oldval.MaxCellDemand ||
      ' MinCellDemand= '||oldval.MinCellDemand) ;
  dbms_output.put_line('ODCIIndexUpdate&gt;&gt;&gt;&gt;&gt; New'||' TotGridDemand= '||
      newval.TotGridDemand ||' MaxCellDemand= '||newval.MaxCellDemand ||
      ' MinCellDemand= '||newval.MinCellDemand) ;
  sys.ODCIIndexInfoDump(ia); 

  -- Delete old entries.
  stmt := ' DELETE FROM '||ia.IndexSchema ||'.'||ia.IndexName||'_pidx'|| 
      ' WHERE r=:rr';
  dbms_output.put_line('ODCIIndexUpdate&gt;&gt;&gt;&gt;&gt;'||stmt);
  
  -- Parse and execute the statement.
  cid := dbms_sql.open_cursor;
  dbms_sql.parse(cid, stmt, dbms_sql.native);
  dbms_sql.bind_variable_rowid(cid, ':rr', rid);
  nrows := dbms_sql.execute(cid);     
  dbms_sql.close_cursor(cid);
 
  -- Insert new entries.
  stmt2 := ' INSERT INTO '||ia.IndexSchema||'.'||ia.IndexName||'_pidx'||
      ' VALUES (:rr, :pos, :val)';
  dbms_output.put_line('ODCIIndexUpdate&gt;&gt;&gt;&gt;&gt;'||stmt2);
 
  -- Parse and execute the statement.
  cid2 := dbms_sql.open_cursor;
  dbms_sql.parse(cid2, stmt2, dbms_sql.native);
  dbms_sql.bind_variable_rowid(cid2, ':rr', rid);
     
  -- Iterate over the rows of the Varray and insert them.
  i := newval.CellDemandValues.FIRST;   
  WHILE i IS NOT NULL LOOP
    -- Bind the row into the cursor for insert.
    dbms_sql.bind_variable(cid2, ':pos', i);   
    dbms_sql.bind_variable(cid2, ':val', newval.CellDemandValues(i));
    nrows := dbms_sql.execute(cid2);
    dbms_output.put_line('ODCIIndexUpdate&gt;&gt;&gt;&gt;&gt;('||'RID'||' , '||i ||' , '||
         newval.CellDemandValues(i)|| ')');
    i := newval.CellDemandValues.NEXT(i);
  END LOOP;
  dbms_sql.close_cursor(cid2);
 
  RETURN ODCICONST.SUCCESS;
END ODCIIndexUpdate;
</pre>
<p><code>ODCIIndexUpdate</code> is the last method defined in the <code>CREATE</code> <code>TYPE</code> <code>BODY</code> statement, which ends as follows:</p>
<pre>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4831"></a>
<div class="sect3"><a id="sthref656"></a>
<h4 class="sect3">ODCIIndexGetMetadata() Method</h4>
<p><a id="sthref657"></a><a id="sthref658"></a><a id="sthref659"></a>The optional <code>ODCIIndexGetMetadata()</code> function, as demonstrated in <a href="#CIABBAEG">Example 15-18</a>, if present, is called by the Export utility to write implementation-specific metadata (which is not stored in the system catalogs) into the export dump file. This metadata might be policy information, version information, user settings, and so on. This metadata is written to the dump file as anonymous PL/SQL blocks that are executed at import time, immediately before the associated index is created.</p>
<p>This method returns strings to the Export utility that comprise the code of the PL/SQL blocks. The Export utility repeatedly calls this method until a zero-length string is returned, thus allowing the creation of any number of PL/SQL blocks of arbitrary complexity. Normally, this method calls functions within a PL/SQL package to make use of package-level variables, such as cursors and iteration counters, that maintain state across multiple calls by Export.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL" href="../../server.112/e22490/toc.htm"><span class="variable">Oracle Database Utilities</span></a> for information about the Export and Import utilities</div>
<p>In the power demand cartridge, the only metadata that is passed is a version string of <code>V1.0</code>, identifying the current format of the index-organized table that underlies the domain index. The <code>power_pkg</code>.<code>getversion</code> function generates a call to the <code>power_pkg</code>.<code>checkversion</code> procedure, to be executed at import time to check that the version string is <code>V1.0</code>.</p>
<div class="example">
<p class="titleinexample"><a id="CIABBAEG"></a><a id="ADDCI4832"></a>Example 15-18 Registering ODCIIndexGetMetadata() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIIndexGetMetadata(
  ia sys.ODCIIndexInfo, 
  expversion VARCHAR2, 
  newblock OUT PLS_INTEGER, 
  env sys.ODCIEnv) 
RETURN VARCHAR2 IS 
 
BEGIN 
  -- Let getversion do all the work since it has to maintain state across calls. 
 
  RETURN power_pkg.getversion (ia.IndexSchema, ia.IndexName, newblock); 
 
  EXCEPTION 
    WHEN OTHERS THEN 
      RAISE; 
 
END ODCIIndexGetMetaData; 
 
</pre></div>
<!-- class="example" -->
<p>The <code>power_pkg</code> package is defined as follows:</p>
<div class="example">
<p class="titleinexample"><a id="ADDCI4833"></a><a id="sthref660"></a>Example 15-19 Creating Package power_pkg for the Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE PACKAGE power_pkg AS  
  FUNCTION getversion(
    idxschema IN VARCHAR2, 
    idxname IN VARCHAR2,
    newblock OUT PLS_INTEGER) 
  RETURN VARCHAR2; 

  PROCEDURE checkversion (
  version IN VARCHAR2);  
END power_pkg; 
/ 
SHOW ERRORS; 
 
CREATE OR REPLACE PACKAGE BODY power_pkg AS  
  -- iterate is a package-level variable used to maintain state across calls 
  -- by Export in this session. 
  
  iterate NUMBER := 0;  
  
  FUNCTION getversion(
    idxschema IN VARCHAR2, 
    idxname IN VARCHAR2,  
    newblock OUT PLS_INTEGER) 
  RETURN VARCHAR2 IS  
  
  BEGIN  
  
  -- We are generating only one PL/SQL block consisting of one line of code.
    newblock := 1; 
  
    IF iterate = 0 THEN  
      -- Increment iterate so we'll know we're done next time we're called. 
      iterate := iterate + 1;  
  
      -- Return a string that calls checkversion with a version 'V1.0' 
      -- Note that export adds the surrounding BEGIN/END pair to form the anon. 
      -- block... we don't have to. 
  
      RETURN 'power_pkg.checkversion(''V1.0'');';  
    ELSE  
      -- reset iterate for next index  
      iterate := 0;  
      -- Return a 0-length string; we won't be called again for this index. 
      RETURN '';  
    END IF;  
  END getversion;  
  
  PROCEDURE checkversion (version IN VARCHAR2) 
  IS  
    wrong_version EXCEPTION; 
 
  BEGIN  
    IF version != 'V1.0' THEN 
      RAISE wrong_version; 
    END IF; 
  END checkversion;  

END power_pkg;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4834"></a>
<div class="sect2"><a id="sthref661"></a>
<h3 class="sect2">Creating the Indextype</h3>
<p>The power demand cartridge creates the indextype for the domain index. The specification, in <a href="#CIAHDCFE">Example 15-20</a>, includes the list of operators supported by the indextype. It also identifies the implementation type containing the OCDI index routines.</p>
<div class="example">
<p class="titleinexample"><a id="CIAHDCFE"></a><a id="ADDCI4835"></a>Example 15-20 Creating Indextype power_idxtype for Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE INDEXTYPE power_idxtype
FOR
  Power_Equals(PowerDemand_Typ, NUMBER, NUMBER),
  Power_GreaterThan(PowerDemand_Typ, NUMBER, NUMBER),
  Power_LessThan(PowerDemand_Typ, NUMBER, NUMBER),
  Power_EqualsAny(PowerDemand_Typ, NUMBER),
  Power_GreaterThanAny(PowerDemand_Typ, NUMBER),
  Power_LessThanAny(PowerDemand_Typ, NUMBER)
USING power_idxtype_im;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDGBBAG"></a><a id="ADDCI4836"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Defining a Type and Methods for Extensible Optimizing</h2>
<p>This section explains the parts of the power demand cartridge as they relate to extensible optimization. Explanatory text and code segments are mixed.</p>
<a id="ADDCI4837"></a>
<div class="sect2"><a id="sthref662"></a>
<h3 class="sect2"><a id="sthref663"></a>Creating the Statistics Table, PowerCartUserStats</h3>
<p>The table <code>PowerCartUserStats</code>, demonstrated in <a href="#CIAGEBIC">Example 15-21</a>, stores statistics about the hourly power grid readings. The method <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> uses these statistics to estimate the selectivity of operator predicates. Because of the types of statistics collected, it is more convenient to use a separate table instead of letting Oracle store the statistics.</p>
<p>The <code>PowerCartUserStats</code> table contains the following columns:</p>
<ul>
<li>
<p>The table and column for which statistics are collected</p>
</li>
<li>
<p>The cell for which the statistics are collected</p>
</li>
<li>
<p>The minimum and maximum power demand for the given cell over all power grid readings</p>
</li>
<li>
<p>The number of non-<code>null</code> readings for the given cell over all power grid reading</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="CIAGEBIC"></a><a id="ADDCI4838"></a>Example 15-21 Creating Statistics Table PowerCartUserStats for Power Demand Cartridge</p>
<pre>
CREATE TABLE PowerCartUserStats (
  -- Table for which statistics are collected
  tab VARCHAR2(30),
  -- Column for which statistics are collected
  col VARCHAR2(30),
  -- Cell position
  cpos NUMBER,
  -- Minimum power demand for the given cell
  lo NUMBER,
  -- Maximum power demand for the given cell
  hi NUMBER,
  -- Number of (non-null) power demands for the given cell
  nrows NUMBER
);
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4839"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref664"></a>
<h3 class="sect2">Creating the Extensible Optimizer Methods</h3>
<p>The power demand cartridge creates an object type that specifies methods used by the extensible optimizer. These methods are part of the <code>ODCIStats</code> interface and they collectively define the methods that are called by the methods of <code>DBMS_STATS</code> package, or when the optimizer is deciding on the best execution plan for a query.</p>
<p><a href="#g1012516">Table 15-5</a> shows the method functions created for the power demand cartridge. Names of all but one of the functions begin with the string <code>ODCIStats</code>.</p>
<div class="tblformal">
<p class="titleintable"><a id="ADDCI4840"></a><a id="sthref665"></a><a id="g1012516"></a>Table 15-5 Extensible Optimizer Methods</p>
<table class="cellalignment1246" title="Extensible Optimizer Methods" summary="Lists methods to be used by the extensible optimizer that were created for the Power Demand cartridge example and describes each" dir="ltr">
<thead>
<tr class="cellalignment1237">
<th class="cellalignment1247" id="r1c1-t8">Method</th>
<th class="cellalignment1247" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r2c1-t8" headers="r1c1-t8">
<p><a href="ext_opt_ref.htm#CHEDBEFB">ODCIGetInterfaces()</a></p>
</td>
<td class="cellalignment1243" headers="r2c1-t8 r1c2-t8">
<p>Returns the list of names of the interfaces implemented by the type.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r3c1-t8" headers="r1c1-t8">
<p><a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a></p>
</td>
<td class="cellalignment1243" headers="r3c1-t8 r1c2-t8">
<p>Collects statistics for columns of type PowerDemand_Typ or domain indexes of indextype power_idxtype.</p>
<p>This method is called when a statement that refers either to a column of the <code>PowerDemand_Typ</code> type or to an index of the <code>power_idxtype</code> indextype is issued. Upon invocation, any specified options are passed in along with a description of the column or index.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r4c1-t8" headers="r1c1-t8">
<p><a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a></p>
</td>
<td class="cellalignment1243" headers="r4c1-t8 r1c2-t8">
<p>Deletes statistics for columns of type <code>PowerDemand_Typ</code> or domain indexes of indextype <code>power_idxtype</code>.</p>
<p>This method is called when a statement to delete statistics for a column of the appropriate type or an index of the appropriate indextype is issued.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r5c1-t8" headers="r1c1-t8">
<p><a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a></p>
</td>
<td class="cellalignment1243" headers="r5c1-t8 r1c2-t8">
<p>Computes the selectivity of a predicate involving an operator or its functional implementation.</p>
<p>Called by the optimizer when a predicate of the appropriate type appears in the <code>WHERE</code> clause of a query.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r6c1-t8" headers="r1c1-t8">
<p><a href="ext_opt_ref.htm#CHEHFCIG">ODCIStatsIndexCost()</a></p>
</td>
<td class="cellalignment1243" headers="r6c1-t8 r1c2-t8">
<p>Computes the cost of a domain index access path.</p>
<p>Called by the optimizer to get the cost of a domain index access path, assuming the index can be used for the query.</p>
</td>
</tr>
<tr class="cellalignment1237">
<td class="cellalignment1243" id="r7c1-t8" headers="r1c1-t8">
<p><a href="ext_opt_ref.htm#CHEBBEGF">ODCIStatsFunctionCost()</a></p>
</td>
<td class="cellalignment1243" headers="r7c1-t8 r1c2-t8">
<p>Computes the cost of a function.</p>
<p>Ccalled by the optimizer to get the cost of executing a function. The function need not necessarily be an implementation of an operator.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="ADDCI4841"></a>
<div class="sect3"><a id="sthref666"></a>
<h4 class="sect3">Type Definition</h4>
<p><a href="#CIAHBGBI">Example 15-22</a> creates the <code>power_statistics</code> object type. This object type's ODCI methods are used to collect and delete statistics about columns and indexes, compute selectivities of predicates with operators or functions, and to compute costs of domain indexes and functions. The <code>curnum</code> attribute is not used.</p>
<div class="example">
<p class="titleinexample"><a id="CIAHBGBI"></a><a id="ADDCI4842"></a>Example 15-22 Creating power_statistics Object Type Definition for Power Demand Cartridge</p>
<pre>
CREATE OR REPLACE TYPE power_statistics AS OBJECT
(
  curnum NUMBER,
  STATIC FUNCTION ODCIGetInterfaces(ifclist OUT sys.ODCIObjectList) 
    RETURN NUMBER,
  STATIC FUNCTION ODCIStatsCollect(col sys.ODCIColInfo, 
      options sys.ODCIStatsOptions, rawstats OUT RAW, env sys.ODCIEnv) 
    RETURN NUMBER,
  STATIC FUNCTION ODCIStatsDelete(col sys.ODCIColInfo, env sys.ODCIEnv) 
      RETURN NUMBER,
  STATIC FUNCTION ODCIStatsCollect(ia sys.ODCIIndexInfo,
      options sys.ODCIStatsOptions, rawstats OUT RAW, env sys.ODCIEnv) 
    RETURN NUMBER,
  STATIC FUNCTION ODCIStatsDelete(ia sys.ODCIIndexInfo, env sys.ODCIEnv) 
      RETURN NUMBER,
  STATIC FUNCTION ODCIStatsSelectivity(pred sys.ODCIPredInfo,
      sel OUT NUMBER, args sys.ODCIArgDescList, strt NUMBER, stop NUMBER,
      object PowerDemand_Typ, cell NUMBER, value NUMBER, env sys.ODCIEnv) 
    RETURN NUMBER,
  PRAGMA restrict_references(ODCIStatsSelectivity, WNDS, WNPS),
  STATIC FUNCTION ODCIStatsSelectivity(pred sys.ODCIPredInfo, sel OUT NUMBER, 
      args sys.ODCIArgDescList, strt NUMBER, stop NUMBER, object PowerDemand_Typ,
      value NUMBER, env sys.ODCIEnv) 
    RETURN NUMBER,
  PRAGMA restrict_references(ODCIStatsSelectivity, WNDS, WNPS),
  STATIC FUNCTION ODCIStatsIndexCost(ia sys.ODCIIndexInfo, sel NUMBER, 
      cost OUT sys.ODCICost, qi sys.ODCIQueryInfo, pred sys.ODCIPredInfo, 
      args sys.ODCIArgDescList, strt NUMBER, stop NUMBER, cmppos NUMBER, 
      cmpval NUMBER, env sys.ODCIEnv)
    RETURN NUMBER,
  PRAGMA restrict_references(ODCIStatsIndexCost, WNDS, WNPS),
  STATIC FUNCTION ODCIStatsIndexCost(ia sys.ODCIIndexInfo, sel NUMBER, 
      cost OUT sys.ODCICost, qi sys.ODCIQueryInfo, pred sys.ODCIPredInfo, 
      args sys.ODCIArgDescList, strt NUMBER, stop NUMBER, cmpval NUMBER, 
      env sys.ODCIEnv) 
    RETURN NUMBER,
  PRAGMA restrict_references(ODCIStatsIndexCost, WNDS, WNPS),
  STATIC FUNCTION ODCIStatsFunctionCost(func sys.ODCIFuncInfo, 
      cost OUT sys.ODCICost, args sys.ODCIArgDescList, object PowerDemand_Typ,
      cell NUMBER, value NUMBER, env sys.ODCIEnv) 
    RETURN NUMBER,
  PRAGMA restrict_references(ODCIStatsFunctionCost, WNDS, WNPS),
  STATIC FUNCTION ODCIStatsFunctionCost(func sys.ODCIFuncInfo,
      cost OUT sys.ODCICost, args sys.ODCIArgDescList, object PowerDemand_Typ,
      value NUMBER, env sys.ODCIEnv) 
    RETURN NUMBER,
  PRAGMA restrict_references(ODCIStatsFunctionCost, WNDS, WNPS)
  STATIC FUNCTION ODCIStatsFunctionCost(func sys.ODCIFuncInfo,
      cost OUT sys.ODCICost, args sys.ODCIArgDescList, object PowerDemand_Typ,
      cell NUMBER, value NUMBER, env sys.ODCIEnv)
    RETURN NUMBER
);
/
</pre></div>
<!-- class="example" -->
<p>The <code>CREATE TYPE</code> statement is followed by a <code>CREATE TYPE BODY</code> statement that specifies the implementation for each member function:</p>
<pre>
CREATE OR REPLACE TYPE BODY power_statistics
IS
...
</pre>
<p>Each member function is described in a separate section, but the function definitions have the following general form:</p>
<pre>
    STATIC FUNCTION function-name (...)
      BEGIN
        RETURN NUMBER IS
      END;
</pre></div>
<!-- class="sect3" -->
<a id="ADDCI4843"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref667"></a>
<h4 class="sect3">ODCIGetInterfaces() Method</h4>
<p>The <a href="ext_opt_ref.htm#CHEDBEFB">ODCIGetInterfaces()</a> function, demonstrated in <a href="#CIAJCGEJ">Example 15-23</a>, returns the list of names of the interfaces implemented by the type. There is only one set of the extensible optimizer interface routines, called <code>SYS.ODCISTATS</code>, but the server supports multiple versions of them for backward compatibility. To specify the current version of the routines, function <a href="ext_opt_ref.htm#CHEDBEFB">ODCIGetInterfaces()</a> must specify <code>SYS.ODCISTATS2</code> in the <code>OUT</code>, <code>ODCIObjectList</code> parameter.</p>
<div class="example">
<p class="titleinexample"><a id="CIAJCGEJ"></a><a id="ADDCI4844"></a>Example 15-23 Registering interfaces and Statistics Functions for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIGetInterfaces(
  ifclist OUT sys.ODCIObjectList)
RETURN NUMBER IS
BEGIN
  ifclist := sys.ODCIObjectList(sys.ODCIObject('SYS','ODCISTATS2'));
  RETURN ODCIConst.Success;
END ODCIGetInterfaces;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4845"></a>
<div class="sect3"><a id="sthref668"></a>
<h4 class="sect3">ODCIStatsCollect() Method for <span class="bold">PowerDemand_Typ</span> Columns</h4>
<p>The <a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a> function, demonstrated in <a href="#CIAFECHD">Example 15-24</a>, collects statistics for columns whose data type is the <code>PowerDemand_Typ</code> object type. The statistics are collected for each cell in the column over all power grid readings. For a given cell, the statistics collected are the minimum and maximum power grid readings, and the number of non-null readings.</p>
<p>The function takes the column information as an object parameter whose type is <code>SYS.ODCICOLINFO</code>. The type attributes include the table name, column name, and so on. Options specified in the <code>DBMS_STATS</code> package command used to collect the column statistics are also passed in as parameters. Since the power demand cartridge uses a table to store the statistics, the output parameter <code>rawstats</code> is not used in this cartridge.</p>
<div class="example">
<p class="titleinexample"><a id="CIAFECHD"></a><a id="ADDCI4846"></a>Example 15-24 Registering ODCIStatsCollect() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIStatsCollect(
  col sys.ODCIColInfo,
  options sys.ODCIStatsOptions,
  rawstats OUT RAW, 
  env sys.ODCIEnv)
RETURN NUMBER IS
  cnum                INTEGER;
  stmt                VARCHAR2(1000);
  junk                INTEGER;
  cval                NUMBER;
  colname             VARCHAR2(30) := rtrim(ltrim(col.colName, '"'), '"');
  statsexists         BOOLEAN := FALSE;
  pdemands            PowerDemand_Tab%ROWTYPE;
  user_defined_stats  PowerCartUserStats%ROWTYPE;

  CURSOR c1(tname VARCHAR2, cname VARCHAR2) IS
    SELECT * FROM PowerCartUserStats
    WHERE tab = tname AND col = cname;
  CURSOR c2 IS
    SELECT * FROM PowerDemand_Tab;

  BEGIN
    sys.ODCIColInfoDump(col);
    sys.ODCIStatsOptionsDump(options);

    IF (col.TableSchema IS NULL OR col.TableName IS NULL OR col.ColName IS NULL)
    THEN
      RETURN ODCIConst.Error;
    END IF;

    dbms_output.put_line('ODCIStatsCollect&gt;&gt;&gt;&gt;&gt;');
    dbms_output.put_line('**** Analyzing column '||col.TableSchema|| '.' ||
        col.TableName|| '.' || col.ColName);

    -- Check if statistics exist for this column
    FOR user_defined_stats IN c1(col.TableName, colname) LOOP
      statsexists := TRUE;
      EXIT;
    END LOOP;
</pre>
<p>The function checks whether statistics for this column exist. If so, it initializes them to <code>NULL</code>; otherwise, it creates statistics for each of the 100 cells and initializes them to <code>NULL</code>.</p>
<pre>
    IF not statsexists THEN
      -- column statistics don't exist; create entries for each of the 100 cells
      cnum := dbms_sql.open_cursor;
      FOR i in 1..100 LOOP
        stmt := 'INSERT INTO PowerCartUserStats VALUES( '||''''|| col.TableName ||
            ''', '||''''||colname||''', '||to_char(i)||', '||'NULL, NULL, NULL)';
        dbms_sql.parse(cnum, stmt, dbms_sql.native);
        junk := dbms_sql.execute(cnum);
      END LOOP;
      dbms_sql.close_cursor(cnum);
    ELSE
      -- column statistics exist; initialize to NULL
      cnum := dbms_sql.open_cursor;
      stmt := 'UPDATE PowerCartUserStats'||
          ' SET lo = NULL, hi = NULL, nrows = NULL'||' WHERE tab = '||
          col.TableName||' AND col = '||colname;
      dbms_sql.parse(cnum, stmt, dbms_sql.native);
      junk := dbms_sql.execute(cnum);
      dbms_sql.close_cursor(cnum);
    END IF;
</pre>
<p>The function collects statistics for the column by reading rows from the table that is being analyzed. This is done by constructing and executing a SQL statement.</p>
<pre>
    -- For each cell position, the following statistics are collected:
    --   maximum value
    --   minimum value
    --   number of rows (excluding NULLs)
    cnum := dbms_sql.open_cursor;
    FOR i in 1..100 LOOP
      FOR pdemands IN c2 LOOP
        IF i BETWEEN pdemands.sample.CellDemandValues.FIRST AND
            pdemands.sample.CellDemandValues.LAST THEN
          cval := pdemands.sample.CellDemandValues(i);
          stmt := 'UPDATE PowerCartUserStats SET '|| 'lo = least(' || 'NVL(' ||
              to_char(cval)||', lo), '||'NVL('||'lo, '||to_char(cval)||')), '||
              'hi = greatest('||'NVL('||to_char(cval)||', hi), '||'NVL('||
              'hi, '||to_char(cval)||')), '||
              'nrows = decode(nrows, NULL, decode('||to_char(cval)||
              ', NULL, NULL, 1), decode('||to_char(cval)|| 
              ', NULL, nrows, nrows+1)) '||'WHERE cpos = '||to_char(i)||
              ' AND tab = '''||col.TableName||''''||' AND col = '''||colname||
              '''';
          dbms_sql.parse(cnum, stmt, dbms_sql.native);
          junk := dbms_sql.execute(cnum);
        END IF;
      END LOOP;
    END LOOP;
</pre>
<p>The function concludes by closing the cursor and returning a success status.</p>
<pre>
    dbms_sql.close_cursor(cnum);
    rawstats := NULL;
    return ODCIConst.Success;

  END ODCIStatsCollect;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4847"></a>
<div class="sect3"><a id="sthref669"></a>
<h4 class="sect3">ODCIStatsDelete() Method for <span class="bold">PowerDemand_Typ</span> Columns</h4>
<p>The <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a> function, demonstrated in <a href="#CIACJEIF">Example 15-25</a>, deletes statistics of columns whose data type is the <code>PowerDemand_Typ</code> object type. The function takes the column information as an object parameter whose type is <code>SYS.ODCICOLINFO</code>. The type attributes include the table name, column name, and so on.</p>
<div class="example">
<p class="titleinexample"><a id="CIACJEIF"></a><a id="ADDCI4848"></a>Example 15-25 Registering ODCIStatsDelete() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIStatsDelete(
  col sys.ODCIColInfo, 
  env sys.ODCIEnv)
RETURN NUMBER IS
  cnum                INTEGER;
  stmt                VARCHAR2(1000);
  junk                INTEGER;
  colname             VARCHAR2(30) := rtrim(ltrim(col.colName, '"'), '"');
  statsexists         BOOLEAN := FALSE;
  user_defined_stats  PowerCartUserStats%ROWTYPE;

  CURSOR c1(tname VARCHAR2, cname VARCHAR2) IS
    SELECT * FROM PowerCartUserStats
    WHERE tab = tname AND col = cname;
  BEGIN
  sys.ODCIColInfoDump(col);

  IF (col.TableSchema IS NULL OR col.TableName IS NULL OR col.ColName IS NULL)
  THEN
    RETURN ODCIConst.Error;
  END IF;

  dbms_output.put_line('ODCIStatsDelete&gt;&gt;&gt;&gt;&gt;');
  dbms_output.put_line('**** Analyzing (delete) column '|| col.TableSchema|| 
      '.' ||col.TableName||'.'||col.ColName);
</pre></div>
<!-- class="example" -->
<p>The function verifies that statistics for the column exist by checking the statistics table. If statistics were not collected, then there is nothing to be done. If, however, statistics are present, it constructs and executes a SQL statement to delete the relevant rows from the statistics table.</p>
<pre>
  -- Check if statistics exist for this column
  FOR user_defined_stats IN c1(col.TableName, colname) LOOP
    statsexists := TRUE;
    EXIT;
  END LOOP;

  -- If user-defined statistics exist, delete them
  IF statsexists THEN
    stmt := 'DELETE FROM PowerCartUserStats'||' WHERE tab = '''||col.TableName||
        ''''|| ' AND col = ''' || colname || '''';
    cnum := dbms_sql.open_cursor;
    dbms_output.put_line('ODCIStatsDelete&gt;&gt;&gt;&gt;&gt;');
    dbms_output.put_line('ODCIStatsDelete&gt;&gt;&gt;&gt;&gt;' || stmt);
    dbms_sql.parse(cnum, stmt, dbms_sql.native);
    junk := dbms_sql.execute(cnum);
    dbms_sql.close_cursor(cnum);
  END IF;

  RETURN ODCIConst.Success;
END ODCStatsDelete;
</pre></div>
<!-- class="sect3" -->
<a id="ADDCI4849"></a>
<div class="sect3"><a id="sthref670"></a>
<h4 class="sect3">ODCIStatsCollect() Method for <span class="bold">power_idxtype</span> Domain Indexes</h4>
<p>The <a href="ext_opt_ref.htm#i77265">ODCIStatsCollect()</a> function, demonstrated in <a href="#CIAECBHC">Example 15-26</a>, collects statistics for domain indexes whose indextype is <code>power_idxtype</code>. In the power demand cartridge, this function simply analyzes the index-organized table that stores the index data.</p>
<p>The function takes the index information as an object parameter whose type is <code>SYS.ODCIINDEXINFO</code>. The type attributes include the index name, owner name, and so on. Options specified by the <code>DBMS_STATS</code> package are used to collect the index statistics are also passed in as parameters. The output parameter <code>rawstats</code> is not used.</p>
<div class="example">
<p class="titleinexample"><a id="CIAECBHC"></a><a id="ADDCI4850"></a>Example 15-26 Registering ODCIStatsCollect() for Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIStatsCollect (
  ia sys.ODCIIndexInfo,
  options sys.ODCIStatsOptions, 
  rawstats OUT RAW, 
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt                VARCHAR2(1000);
 
BEGIN
  -- To analyze a domain index, analyze the table that implements the index
  sys.ODCIIndexInfoDump(ia);
  sys.ODCIStatsOptionsDump(options);

  stmt := 'dbms_stats.gather_table_stats('
         || '''' || ia.IndexSchema || ''', '
         || '''' || ia.IndexName || '_pidx' || ''');';
  dbms_output.put_line('**** Analyzing index '
         || ia.IndexSchema || '.' || ia.IndexName);
  dbms_output.put_line('SQL Statement: ' || stmt); 
  EXECUTE IMMEDIATE 'BEGIN ' || stmt || ' END;';
  rawstats := NULL;

  RETURN ODCIConst.Success;
END ODCIStatsCollect;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4851"></a>
<div class="sect3"><a id="sthref671"></a>
<h4 class="sect3">ODCIStatsDelete() Method for <span class="bold">power_idxtype</span> Domain Indexes</h4>
<p>The <a href="ext_opt_ref.htm#CHEDFDDJ">ODCIStatsDelete()</a> function, demonstrated in <a href="#CIAJIAAI">Example 15-27</a>, deletes statistics for domain indexes whose indextype is <code>power_idxtype</code>. In the power demand cartridge, this function simply deletes the statistics of the index-organized table that stores the index data.</p>
<p>The function takes the index information as an object parameter whose type is <code>SYS.ODCIINDEXINFO</code>. The type attributes include the index name, owner name, and so on.</p>
<div class="example">
<p class="titleinexample"><a id="CIAJIAAI"></a><a id="ADDCI4852"></a>Example 15-27 Registering ODCIStatsDelete() for Domain Indexes in Power Demand Cartridge</p>
<pre>
STATIC FUNCTION ODCIStatsDelete(
  ia sys.ODCIIndexInfo,
  env sys.ODCIEnv)
RETURN NUMBER IS
  stmt                VARCHAR2(1000);
BEGIN
  -- To delete statistics for a domain index, delete the statistics for the
  -- table implementing the index
  sys.ODCIIndexInfoDump(ia);
  stmt := 'dbms_stats.delete_table_stats('|| '''' || ia.IndexSchema || ''', '
      || '''' || ia.IndexName || '_pidx' || ''');';
  dbms_output.put_line('**** Analyzing (delete) index '||ia.IndexSchema||'.'||
      ia.IndexName);
  dbms_output.put_line('SQL Statement: ' || stmt);

  EXECUTE IMMEDIATE 'BEGIN ' || stmt || ' END;';
  RETURN ODCIConst.Success;
END ODCIStatsDelete;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4853"></a>
<div class="sect3"><a id="sthref672"></a>
<h4 class="sect3">ODCIStatsSelectivity() Method for <span class="bold">Specific</span> Queries</h4>
<p>The first definition of the <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> function estimates the selectivity of operator or function predicates for <code>Specific</code> queries. For example, if a query asks for all instances where cell <code>(3,7)</code> has a value equal to <code>25</code>, the function estimates the percentage of rows in which the given cell has the specified value.</p>
<p>The <code>pred</code> parameter contains the function information (the functional implementation of an operator in an operator predicate); this parameter is an object instance of type <code>SYS.ODCIPREDINFO</code>. The selectivity is returned as a percentage in the <code>sel</code> output parameter. The <code>args</code> parameter (an object instance of type <code>SYS.ODCIARGDESCLIST</code>) contains a descriptor for each argument of the function, and the start and stop values of the function. For example, if an argument is a column, the argument descriptor contains the table name, column name, and so on. The <code>strt</code> and <code>stop</code> parameters are the lower and upper boundary points for the function return value. If the function in a predicate contains a literal of type <code>PowerDemand_Typ</code>, the <code>object</code> parameter contains the value in the form of an object constructor. The <code>cell</code> parameter is the cell position and the <code>value</code> parameter is the value in the cell specified by the function (<code>PowerXxxxxSpecific_Func</code>).</p>
<p>The selectivity is estimated by using a technique similar to that used for simple range predicates. For example, a simple estimate for the selectivity of a predicate like</p>
<pre>
  c &gt; v
</pre>
<p>is <code>(M-v)/(M-m)</code> where <code>m</code> and <code>M</code> are the minimum and maximum values, respectively, for the column <code>c</code> (as determined from the column statistics), provided the value <code>v</code> lies between <code>m</code> and <code>M</code>.</p>
<p>The <code>get_selectivity</code> function, demonstrated in <a href="#CIAJJJFC">Example 15-28</a>, computes the selectivity of a simple range predicate given the minimum and maximum values of the column in the predicate. It assumes that the column values in the table are uniformly distributed between the minimum and maximum values.</p>
<div class="example">
<p class="titleinexample"><a id="CIAJJJFC"></a><a id="ADDCI4854"></a>Example 15-28 Implementing Selectivity Function for Power Demand Cartridge</p>
<pre>
CREATE FUNCTION get_selectivity(relop VARCHAR2, value NUMBER,
                                lo NUMBER, hi NUMBER, ndv NUMBER)
  RETURN NUMBER AS
  sel NUMBER := NULL;
  ndv NUMBER;
BEGIN
  -- This function computes the selectivity (as a percentage)
  -- of a predicate
  --             col &lt;relop&gt; &lt;value&gt;
  -- where &lt;relop&gt; is one of: =, !=, &lt;, &lt;=, &gt;, &gt;=
  --       &lt;value&gt; is one of: 0, 1
  -- lo and hi are the minimum and maximum values of the column in
  -- the table. This function performs a simplistic estimation of the
  -- selectivity by assuming that the range of distinct values of
  -- the column is distributed uniformly in the range lo..hi and that
  -- each distinct value occurs nrows/(hi-lo+1) times (where nrows is
  -- the number of rows).

  IF ndv IS NULL OR ndv &lt;= 0 THEN
    RETURN 0;
  END IF;

  -- col != &lt;value&gt;
  IF relop = '!=' THEN
    IF value between lo and hi THEN
      sel := 1 - 1/ndv;
    ELSE
      sel := 1;
    END IF;

  -- col = &lt;value&gt;
  ELSIF relop = '=' THEN
    IF value between lo and hi THEN
      sel := 1/ndv;
    ELSE
      sel := 0;
    END IF;

  -- col &gt;= &lt;value&gt;
  ELSIF relop = '&gt;=' THEN
    IF lo = hi THEN
      IF value &lt;= lo THEN
        sel := 1;
      ELSE
        sel := 0;
      END IF;
    ELSIF value between lo and hi THEN
      sel := (hi-value)/(hi-lo) + 1/ndv;
    ELSIF value &lt; lo THEN
      sel := 1;
    ELSE
      sel := 0;
    END IF;

  -- col &lt; &lt;value&gt;
  ELSIF relop = '&lt;' THEN
    IF lo = hi THEN
      IF value &gt; lo THEN
        sel := 1;
      ELSE
        sel := 0;
      END IF;
    ELSIF value between lo and hi THEN
      sel := (value-lo)/(hi-lo);
    ELSIF value &lt; lo THEN
      sel := 0;
    ELSE
      sel := 1;
    END IF;

  -- col &lt;= &lt;value&gt;
  ELSIF relop = '&lt;=' THEN
    IF lo = hi THEN
      IF value &gt;= lo THEN
        sel := 1;
      ELSE
        sel := 0;
      END IF;
    ELSIF value between lo and hi THEN
      sel := (value-lo)/(hi-lo) + 1/ndv;
    ELSIF value &lt; lo THEN
      sel := 0;
    ELSE
      sel := 1;
    END IF;

  -- col &gt; &lt;value&gt;
  ELSIF relop = '&gt;' THEN
    IF lo = hi THEN
      IF value &lt; lo THEN
        sel := 1;
      ELSE
        sel := 0;
      END IF;
    ELSIF value between lo and hi THEN
      sel := (hi-value)/(hi-lo);
    ELSIF value &lt; lo THEN
      sel := 1;
    ELSE
      sel := 0;
    END IF;

  END IF;

  RETURN least(100, ceil(100*sel));

END;
/
</pre></div>
<!-- class="example" -->
<p>The <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> function, demonstrated in <a href="#CIAJECAH">Example 15-29</a>, estimates the selectivity for function predicates which have constant start and stop values. Further, the first argument of the function in the predicate must be a column of type <code>PowerDemand_Typ</code> and the remaining arguments must be constants.</p>
<div class="example">
<p class="titleinexample"><a id="CIAJECAH"></a><a id="ADDCI4855"></a>Example 15-29 Registering ODCIStatsSelectivity() for Queries for Power Demand Cartridge</p>
<pre>
  STATIC FUNCTION ODCIStatsSelectivity(pred sys.ODCIPredInfo,
     sel OUT NUMBER, args sys.ODCIArgDescList, strt NUMBER, stop NUMBER,
     object PowerDemand_Typ, cell NUMBER, value NUMBER, env sys.ODCIEnv)
     RETURN NUMBER IS
     fname               varchar2(30);
     relop               varchar2(2);
     lo                  NUMBER;
     hi                  NUMBER;
     nrows               NUMBER;
     colname             VARCHAR2(30);
     statsexists         BOOLEAN := FALSE;
     stats               PowerCartUserStats%ROWTYPE;
     CURSOR c1(cell NUMBER, tname VARCHAR2, cname VARCHAR2) IS
       SELECT * FROM PowerCartUserStats
       WHERE cpos = cell
         AND tab = tname
         AND col = cname;
  BEGIN
    -- compute selectivity only when predicate is of the form:
    --      fn(col, &lt;cell&gt;, &lt;value&gt;) &lt;relop&gt; &lt;val&gt;
    -- In all other cases, return an error and let the optimizer
    -- make a guess. We also assume that the function "fn" has
    -- a return value of 0, 1, or NULL.

    -- start value
    IF (args(1).ArgType != ODCIConst.ArgLit AND
        args(1).ArgType != ODCIConst.ArgNull) THEN
      RETURN ODCIConst.Error;
    END IF;

    -- stop value
    IF (args(2).ArgType != ODCIConst.ArgLit AND
        args(2).ArgType != ODCIConst.ArgNull) THEN
      RETURN ODCIConst.Error;
    END IF;

    -- first argument of function
    IF (args(3).ArgType != ODCIConst.ArgCol) THEN
      RETURN ODCIConst.Error;
    END IF;

    -- second argument of function
    IF (args(4).ArgType != ODCIConst.ArgLit AND
        args(4).ArgType != ODCIConst.ArgNull) THEN
      RETURN ODCIConst.Error;
    END IF;

    -- third argument of function
    IF (args(5).ArgType != ODCIConst.ArgLit AND
        args(5).ArgType != ODCIConst.ArgNull) THEN
      RETURN ODCIConst.Error;
    END IF;

    colname := rtrim(ltrim(args(3).colName, '"'), '"');
</pre>
<p>The first (column) argument of the function in the predicate must have statistics collected for it. If statistics have not been collected, <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> returns an error status.</p>
<pre>
    -- Check if the statistics table exists (we are using a
    -- user-defined table to store the user-defined statistics).
    -- Get user-defined statistics: MIN, MAX, NROWS
    FOR stats IN c1(cell, args(3).TableName, colname) LOOP
      -- Get user-defined statistics: MIN, MAX, NROWS
      lo := stats.lo;
      hi := stats.hi;
      nrows := stats.nrows;
      statsexists := TRUE;
      EXIT;
    END LOOP;

    -- If no user-defined statistics were collected, return error
    IF not statsexists THEN
      RETURN ODCIConst.Error;
    END IF;
</pre>
<p>Each <code>Specific</code> function predicate corresponds to an equivalent range predicate. For example, the predicate <code>Power_EqualsSpecific_Func(col, 21, 25) = 0</code>, which checks that the reading in cell <code>21</code> is not equal to <code>25</code>, corresponds to the equivalent range predicate <code>col[21] != 25</code>.</p>
<p>The <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> function finds the corresponding range predicates for each <code>Specific</code> function predicate. There are several boundary cases where the selectivity can be immediately determined.</p>
<pre>
    -- selectivity is 0 for "fn(col, &lt;cell&gt;, &lt;value&gt;) &lt; 0"
    IF (stop = 0 AND
        bitand(pred.Flags, ODCIConst.PredIncludeStop) = 0) THEN
      sel := 0;
      RETURN ODCIConst.Success;
    END IF;

    -- selectivity is 0 for "fn(col, &lt;cell&gt;, &lt;value&gt;) &gt; 1"
    IF (strt = 1 AND
        bitand(pred.Flags, ODCIConst.PredIncludeStart) = 0) THEN
      sel := 0;
      RETURN ODCIConst.Success;
    END IF;

    -- selectivity is 100% for "fn(col, &lt;cell&gt;, &lt;value&gt;) &gt;= 0"
    IF (strt = 0 AND
        bitand(pred.Flags, ODCIConst.PredExactMatch) = 0 AND
        bitand(pred.Flags, ODCIConst.PredIncludeStart) &gt; 0) THEN
      sel := 100;
      RETURN ODCIConst.Success;
    END IF;

    -- selectivity is 100% for "fn(col, &lt;cell&gt;, &lt;value&gt;) &lt;= 1"
    IF (stop = 1 AND
        bitand(pred.Flags, ODCIConst.PredExactMatch) = 0 AND
        bitand(pred.Flags, ODCIConst.PredIncludeStop) &gt; 0) THEN
      sel := 100;
      RETURN ODCIConst.Success;
    END IF;

    -- get function name
    IF bitand(pred.Flags, ODCIConst.PredObjectFunc) &gt; 0 THEN
      fname := pred.ObjectName;
    ELSE
      fname := pred.MethodName;
    END IF;

    -- convert prefix relational operator to infix:
    -- "Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 1"
    -- becomes "col[&lt;cell&gt;] = &lt;value&gt;"

    --   Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 0
    --   Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &lt;= 0
    --   Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &lt; 1
    -- can be transformed to
    --   col[&lt;cell&gt;] != &lt;value&gt;
    IF (fname LIKE upper('Power_Equals%') AND
        (stop = 0 OR
         (stop = 1 AND
          bitand(pred.Flags, ODCIConst.PredIncludeStop) = 0))) THEN
      relop := '!=';

    --   Power_LessThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 0
    --   Power_LessThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &lt;= 0
    --   Power_LessThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &lt; 1
    -- can be transformed to
    --   col[&lt;cell&gt;] &gt;= &lt;value&gt;
    ELSIF (fname LIKE upper('Power_LessThan%') AND
           (stop = 0 OR
            (stop = 1 AND
             bitand(pred.Flags, ODCIConst.PredIncludeStop) = 0))) THEN
      relop := '&gt;=';

    --   Power_GreaterThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 0
    --   Power_GreaterThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &lt;= 0
    --   Power_GreaterThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &lt; 1
    -- can be transformed to
    --   col[&lt;cell&gt;] &lt;= &lt;value&gt;
    ELSIF (fname LIKE upper('Power_GreaterThan%') AND
           (stop = 0 OR
            (stop = 1 AND
             bitand(pred.Flags, ODCIConst.PredIncludeStop) = 0))) THEN
      relop := '&lt;=';

    --   Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 1
    --   Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &gt;= 1
    --   Power_EqualsSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &gt; 0
    -- can be transformed to
    --   col[&lt;cell&gt;] = &lt;value&gt;
    ELSIF (fname LIKE upper('Power_Equals%') AND
           (strt = 1 OR
            (strt = 0 AND
             bitand(pred.Flags, ODCIConst.PredIncludeStart) = 0))) THEN
      relop := '=';

    --   Power_LessThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 1
    --   Power_LessThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &gt;= 1
    --   Power_LessThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &gt; 0
    -- can be transformed to
    --   col[&lt;cell&gt;] &lt; &lt;value&gt;
    ELSIF (fname LIKE upper('Power_LessThan%') AND
           (strt = 1 OR
            (strt = 0 AND
             bitand(pred.Flags, ODCIConst.PredIncludeStart) = 0))) THEN
      relop := '&lt;';

    --   Power_GreaterThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) = 1
    --   Power_GreaterThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &gt;= 1
    --   Power_GreaterThanSpecific_Func(col, &lt;cell&gt;, &lt;value&gt;) &gt; 0
    -- can be transformed to
    --   col[&lt;cell&gt;] &gt; &lt;value&gt;
    ELSIF (fname LIKE upper('Power_GreaterThan%') AND
           (strt = 1 OR
            (strt = 0 AND
             bitand(pred.Flags, ODCIConst.PredIncludeStart) = 0))) THEN
      relop := '&gt;';

    ELSE
      RETURN ODCIConst.Error;

    END IF;
</pre>
<p>After the <code>Specific</code> function predicate is transformed into a simple range predicate, <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> calls <code>get_selectivity</code> to compute the selectivity for the range predicate (and thus, equivalently, for the <code>Specific</code> function predicate). It returns with a success status.</p>
<pre>
    sel := get_selectivity(relop, value, lo, hi, nrows);
    RETURN ODCIConst.Success;
  END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIAECHIB"></a><a id="ADDCI4856"></a>
<div class="sect3">
<h4 class="sect3">ODCIStatsIndexCost() Method for <span class="bold">Specific</span> Queries</h4>
<p>The first definition of the <a href="ext_opt_ref.htm#CHEHFCIG">ODCIStatsIndexCost()</a> function, demonstrated in <a href="#CIABCJAG">Example 15-30</a>, estimates the cost of the domain index for <code>Specific</code> queries. For example, if a query asks for all instances where cell <code>(3,7)</code> has a value equal to <code>25</code>, the function estimates the cost of the domain index access path to evaluate this query. This definition of <a href="ext_opt_ref.htm#CHEHFCIG">ODCIStatsIndexCost()</a> differs from the definition insection <a href="#CIAJJHEJ">"ODCIStatsIndexCost() Method for <span class="bold">Any</span> Queries"</a> in that it includes the <code>cmppos</code> parameter for the position of the cell.</p>
<p>The <code>ia</code> parameter contains the index information as an object instance of type <code>SYS.ODCIINDEXINFO</code>. The <code>sel</code> parameter is the selectivity of the operator predicate as estimated by the <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> function for <code>Specific</code> queries. The estimated cost is returned in the <code>cost</code> output parameter. The <code>qi</code> parameter contains some information about the query and its environment, such as whether the <code>ALL_ROWS</code> or <code>FIRST_ROWS</code> optimizer mode is being used. The <code>pred</code> parameter contains the operator information as an object instance of type <code>SYS.ODCIPREDINFO</code>. The <code>args</code> parameter contains descriptors of the value arguments of the operator, and the start and stop values of the operator. The <code>strt</code> and <code>stop</code> parameters are the lower and upper boundary points for the operator return value. The <code>cmppos</code> parameter is the cell position and <code>cmpval</code> is the value in the cell specified by the operator <code>Power_XxxxxSpecific()</code>.</p>
<p>In the power demand cartridge, the domain index cost for <code>Specific</code> queries is identical to the domain index cost for <code>Any</code> queries, so this version of the <a href="ext_opt_ref.htm#CHEHFCIG">ODCIStatsIndexCost()</a> function simply calls the second definition of the function, described in section <a href="#CIAJJHEJ">"ODCIStatsIndexCost() Method for <span class="bold">Any</span> Queries"</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIABCJAG"></a><a id="ADDCI4857"></a>Example 15-30 Registering ODCISIndexCost() for Queries for Power Demand Cartridge</p>
<pre>
  STATIC FUNCTION ODCIStatsIndexCost(ia sys.ODCIIndexInfo,
     sel NUMBER, cost OUT sys.ODCICost, qi sys.ODCIQueryInfo,
     pred sys.ODCIPredInfo, args sys.ODCIArgDescList,
     strt NUMBER, stop NUMBER, cmppos NUMBER, cmpval NUMBER, env sys.ODCIEnv)
     RETURN NUMBER IS
  BEGIN
    -- This is the cost for queries on a specific cell; simply
    -- use the cost for queries on any cell.
    RETURN ODCIStatsIndexCost(ia, sel, cost, qi, pred, args,
                              strt, stop, cmpval, env);
  END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIAJJHEJ"></a><a id="ADDCI4858"></a>
<div class="sect3">
<h4 class="sect3">ODCIStatsIndexCost() Method for <span class="bold">Any</span> Queries</h4>
<p>The second definition of the <a href="ext_opt_ref.htm#CHEHFCIG">ODCIStatsIndexCost()</a> function, demonstrated in <a href="#CIAEDEIG">Example 15-31</a>, estimates the cost of the domain index for <code>Any</code> queries. For example, if a query asks for all instances where any cell has a value equal to 25, the function estimates the cost of the domain index access path to evaluate this query. This definition of <a href="ext_opt_ref.htm#CHEHFCIG">ODCIStatsIndexCost()</a> differs from the definition in section<a href="#CIAECHIB">"ODCIStatsIndexCost() Method for <span class="bold">Specific</span> Queries"</a> in that it does not include the <code>cmppos</code> parameter.</p>
<p>The <code>ia</code> parameter contains the index information as an object instance of type <code>SYS.ODCIINDEXINFO</code>. The <code>sel</code> parameter is the selectivity of the operator predicate as estimated by the <a href="ext_opt_ref.htm#CHEDEDGJ">ODCIStatsSelectivity()</a> function for <code>Any</code> queries. The estimated cost is returned in the <code>cost</code> output parameter. The <code>qi</code> parameter contains some information about the query and its environment , such as whether the <code>ALL_ROWS</code> or <code>FIRST_ROWS</code> optimizer mode is being used. The <code>pred</code> parameter contains the operator information as an object instance of type <code>SYS.ODCIPREDINFO</code>. The <code>args</code> parameter contains descriptors of the value arguments of the operator, and the start and stop values of the operator. The <code>strt</code> and <code>stop</code> parameters are the lower and upper boundary points for the operator return value. The <code>cmpval</code> parameter is the value in the cell specified by the operator <code>Power_XxxxxAny()</code>.</p>
<p>The index cost is estimated as the number of blocks in the index-organized table implementing the index multiplied by the selectivity of the operator predicate times a constant factor.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEDEIG"></a><a id="ADDCI4859"></a>Example 15-31 Registering ODCIStatsIndexCost() for Any Queries for Power Demand Cartridge</p>
<pre>
  STATIC FUNCTION ODCIStatsIndexCost(ia sys.ODCIIndexInfo,
     sel NUMBER, cost OUT sys.ODCICost, qi sys.ODCIQueryInfo,
     pred sys.ODCIPredInfo, args sys.ODCIArgDescList,
     strt NUMBER, stop NUMBER, cmpval NUMBER, env sys.ODCIEnv)
     RETURN NUMBER IS
     ixtable             VARCHAR2(40);
     numblocks           NUMBER := NULL;
     get_table           user_tables%ROWTYPE;
     CURSOR c1(tab VARCHAR2) IS
       SELECT * FROM user_tables WHERE table_name = tab;
  BEGIN
    -- This is the cost for queries on any cell.

    -- To compute the cost of a domain index, multiply the
    -- number of blocks in the table implementing the index
    -- with the selectivity

    -- Return if we don't have predicate selectivity
    IF sel IS NULL THEN
      RETURN ODCIConst.Error;
    END IF;

    cost := sys.ODCICost(NULL, NULL, NULL, NULL);

    -- Get name of table implementing the domain index
    ixtable := ia.IndexName || '_pidx';

    -- Get number of blocks in domain index
    FOR get_table IN c1(upper(ixtable)) LOOP
      numblocks := get_table.blocks;
      EXIT;
    END LOOP;

    IF numblocks IS NULL THEN
      -- Exit if there are no user-defined statistics for the index
      RETURN ODCIConst.Error;
    END IF;

    cost.CPUCost := ceil(400*(sel/100)*numblocks);
    cost.IOCost := ceil(1.5*(sel/100)*numblocks);
    RETURN ODCIConst.Success;
  END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="ADDCI4860"></a>
<div class="sect3"><a id="sthref673"></a>
<h4 class="sect3">ODCIStatsFunctionCost() Method</h4>
<p>The <a href="ext_opt_ref.htm#CHEBBEGF">ODCIStatsFunctionCost()</a> function, demonstrated in <a href="#CIAHHBJG">Example 15-32</a>, estimates the cost of evaluating a function <code>Power_XxxxxSpecific_Func()</code> or <code>Power_XxxxxAny_Func()</code>.</p>
<p>The <code>func</code> parameter contains the function information; this parameter is an object instance of type <code>SYS.ODCIFUNCINFO</code>. The estimated cost is returned in the output <code>cost</code> parameter. The <code>args</code> parameter as an object instance of type <code>SYS.ODCIARGDESCLIST</code> contains a descriptor for each argument of the function. If the function contains a literal of type <code>PowerDemand_Typ</code> as its first argument, the <code>object</code> parameter contains the value in the form of an object constructor. The <code>value</code> parameter is the value in the cell specified by the function <code>PowerXxxxxSpecific_Func()</code> or <code>Power_XxxxxAny_Func()</code>.</p>
<p>The function cost is simply estimated as some default value depending on the function name. Since the functions do not read any data from disk, the I/O cost is set to zero.</p>
<div class="example">
<p class="titleinexample"><a id="CIAHHBJG"></a><a id="ADDCI4861"></a>Example 15-32 Registering ODCIStatsFunctionCost() for Power Demand Cartridge</p>
<pre>
  STATIC FUNCTION ODCIStatsFunctionCost(func sys.ODCIFuncInfo,
     cost OUT sys.ODCICost, args sys.ODCIArgDescList,
     object PowerDemand_Typ, value NUMBER, env sys.ODCIEnv)
     RETURN NUMBER IS
     fname               VARCHAR2(30);
  BEGIN
    cost := sys.ODCICost(NULL, NULL, NULL, NULL);

    -- Get function name
    IF  bitand(func.Flags, ODCIConst.ObjectFunc) &gt; 0 THEN
      fname := func.ObjectName;
    ELSE
      fname := func.MethodName;
    END IF;

    IF fname LIKE upper('Power_LessThan%') THEN
      cost.CPUCost := 5000;
      cost.IOCost := 0;
      RETURN ODCIConst.Success;
    ELSIF fname LIKE upper('Power_Equals%') THEN
      cost.CPUCost := 7000;
      cost.IOCost := 0;
      RETURN ODCIConst.Success;
    ELSIF fname LIKE upper('Power_GreaterThan%') THEN
      cost.CPUCost := 5000;
      cost.IOCost := 0;
      RETURN ODCIConst.Success;
    ELSE
      RETURN ODCIConst.Error;
    END IF;
  END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="ADDCI4862"></a>
<div class="sect2"><a id="sthref674"></a>
<h3 class="sect2"><a id="sthref675"></a>Associating the Extensible Optimizer Methods with Database Objects</h3>
<p>In order for the optimizer to use the methods defined in the <code>power_statistics</code> object type, they have to be associated with the appropriate database objects, as demonstrated in <a href="#CIAFGDIF">Example 15-33</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAFGDIF"></a><a id="ADDCI4863"></a>Example 15-33 Using Statistics Methods with Database Objects for Power Demand Cartridge</p>
<pre>
  Associate statistics type with types, indextypes, and functions
ASSOCIATE STATISTICS WITH TYPES PowerDemand_Typ USING power_statistics;
ASSOCIATE STATISTICS WITH INDEXTYPES power_idxtype USING power_statistics
  WITH SYSTEM MANAGED STORAGE TABLES;
ASSOCIATE STATISTICS WITH FUNCTIONS
  Power_EqualsSpecific_Func,
  Power_GreaterThanSpecific_Func,
  Power_LessThanSpecific_Func,
  Power_EqualsAny_Func,
  Power_GreaterThanAny_Func,
  Power_LessThanAny_Func
  USING power_statistics;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4864"></a>
<div class="sect2"><a id="sthref676"></a>
<h3 class="sect2">Analyzing the Database Objects</h3>
<p>Analyzing tables, columns, and indexes ensures that the optimizer has the relevant statistics to estimate accurate costs for various access paths and choose a good plan. Further, the selectivity and cost functions defined in the <code>power_statistics</code> object type rely on the presence of statistics. <a href="#CIABDGID">Example 15-34</a> demonstrates statements that analyze the database objects and verify that statistics were indeed collected.</p>
<div class="example">
<p class="titleinexample"><a id="CIABDGID"></a><a id="ADDCI4865"></a>Example 15-34 Analyzing Database Objects for the Power Demand Cartridge</p>
<pre>
-- Analyze the table
EXECUTE dbms_stats.gather_table_stats(
    'POWERCARTUSER', 'POWERDEMAND_TAB', cascade =&gt; TRUE);

-- Verify that user-defined statistics were collected
SELECT tab tablename, col colname, cpos, lo, hi, nrows
FROM PowerCartUserStats
WHERE nrows IS NOT NULL
ORDER BY cpos;

-- Delete the statistics
EXECUTE dbms_stats.delete_table_stats('POWERCARTUSER', 'POWERDEMAND_TAB');

-- Verify that user-defined statistics were deleted
SELECT tab tablename, col colname, cpos, lo, hi, nrows
FROM PowerCartUserStats
WHERE nrows IS NOT NULL
ORDER BY cpos;

-- Re-analyze the table
EXECUTE dbms_stats.gather_table_stats(
   'POWERCARTUSER', 'POWERDEMAND_TAB',cascade =&gt; TRUE);

-- Verify that user-defined statistics were re-collected
SELECT tab tablename, col colname, cpos, lo, hi, nrows
FROM PowerCartUserStats
WHERE nrows IS NOT NULL
ORDER BY cpos;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007059"></a><a id="ADDCI4866"></a>
<div class="sect1">
<h2 class="sect1">Testing the Domain Index</h2>
<p>This section explains the parts of the power demand example that perform some simple tests of the domain index, and how to test the domain index and see if it is causing more efficient execution of queries than would occur without an index. These tests consist of:</p>
<ul>
<li>
<p>Creating the power demand table (<code>PowerDemand_Tab</code>) and populating it with a small amount of data</p>
</li>
<li>
<p>Executing some queries before the index is created (and showing the execution plans without an index being used)</p>
<p>The execution plans show that a full table scan is performed in each case.</p>
</li>
<li>
<p>Creating the index on the grid</p>
</li>
<li>
<p>Executing the same queries after the index is created (and showing the execution plans with the index being used)</p>
<p>The execution plans show that Oracle is using the index and not performing full table scans, thus resulting in more efficient execution.</p>
</li>
</ul>
<p>The statements in this section are available online in the example file (tkqxpwr.sql).</p>
<a id="i1007069"></a><a id="ADDCI4867"></a>
<div class="sect2">
<h3 class="sect2">Creating and Populating the Power Demand Table</h3>
<p>The power demand table, as demonstrated in <a href="#CIABEGBC">Example 15-35</a>, is created with two columns:</p>
<ul>
<li>
<p><code>region</code> allows the electric utility to use the grid scheme in multiple areas or states. Each region, such as New York, New Jersey, Pennsylvania, and so on, is represented by a <code>10x10</code> grid.</p>
</li>
<li>
<p><code>sample</code> is a collection of samplings, or power demand readings from each cell in the grid, defined using the <code>PowerDemand_Typ</code> object type.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="CIABEGBC"></a><a id="ADDCI4868"></a>Example 15-35 Creating PowerDemand_Tab Table for Power Demand Cartridge</p>
<pre>
CREATE TABLE PowerDemand_Tab (
  -- Region for which these power demand readings apply
  region NUMBER,
  -- Values for each "sampling" time (for a given hour)
  sample PowerDemand_Typ
);
</pre></div>
<!-- class="example" -->
<p>Several rows are inserted, representing power demand data for two regions, <code>1</code> and <code>2</code>, for several hourly timestamps. For simplicity, values are inserted only into the first <code>5</code> positions of each grid; the remaining <code>95</code> values are set to <code>null</code>, as demonstrated in <a href="#CIAGCGBE">Example 15-36</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAGCGBE"></a><a id="ADDCI4869"></a>Example 15-36 Populating PowerDemand_Tab Table for Power Demand Cartridge</p>
<pre>
-- The next INSERT statements "cheats" by supplying only 5 grid values
  
-- First 5 INSERT statements are for region 1 (1 AM to 5 AM on 01-Feb-1998).
 
INSERT INTO PowerDemand_Tab VALUES(1,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(55,8,13,9,5),
   to_date('02-01-1998 01','MM-DD-YYYY HH'))
);
 
INSERT INTO PowerDemand_Tab VALUES(1,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(56,8,13,9,3),
   to_date('02-01-1998 02','MM-DD-YYYY HH'))
);
 
INSERT INTO PowerDemand_Tab VALUES(1,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(55,8,13,9,3),
   to_date('02-01-1998 03','MM-DD-YYYY HH'))
);
  
INSERT INTO PowerDemand_Tab VALUES(1,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(54,8,13,9,3),
   to_date('02-01-1998 04','MM-DD-YYYY HH'))
);
 
INSERT INTO PowerDemand_Tab VALUES(1,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(54,8,12,9,3),
   to_date('02-01-1998 05','MM-DD-YYYY HH'))
);
 
-- Also insert some rows for region 2.
 
INSERT INTO PowerDemand_Tab VALUES(2,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(9,8,11,16,5),
   to_date('02-01-1998 01','MM-DD-YYYY HH'))
);
  
INSERT INTO PowerDemand_Tab VALUES(2,
   PowerDemand_Typ(NULL, NULL, NULL, PowerGrid_Typ(9,8,11,20,5),
   to_date('02-01-1998 02','MM-DD-YYYY HH'))
);
</pre></div>
<!-- class="example" -->
<p>Finally, the values for <code>TotGridDemand</code>, <code>MaxCellDemand</code>, and <code>MinCellDemand</code> are computed and set for each of the newly inserted rows, and these values are displayed, as demonstrated in <a href="#CIAEFDEB">Example 15-37</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEFDEB"></a><a id="ADDCI4870"></a>Example 15-37 Computing Grid and Cell Demands for Power Demand Cartridge</p>
<pre>
DECLARE
CURSOR c1 IS SELECT Sample, Region FROM PowerDemand_Tab FOR UPDATE;
s PowerDemand_Typ;
r NUMBER;
BEGIN
  OPEN c1;
  LOOP
     FETCH c1 INTO s,r;
     EXIT WHEN c1%NOTFOUND;
     s.SetTotalDemand;
     s.SetMaxDemand;
     s.SetMinDemand;
     dbms_output.put_line(s.TotGridDemand);
     dbms_output.put_line(s.MaxCellDemand);
     dbms_output.put_line(s.MinCellDemand);
     UPDATE PowerDemand_Tab SET Sample = s WHERE CURRENT OF c1;
  END LOOP;
  CLOSE c1;
END;
/

-- Examine the values. 
SELECT region, P.Sample.TotGridDemand, P.Sample.MaxCellDemand,
   P.Sample.MinCellDemand,
   to_char(P.sample.sampletime, 'MM-DD-YYYY HH') 
 FROM PowerDemand_Tab P;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1007154"></a><a id="ADDCI4871"></a>
<div class="sect2">
<h3 class="sect2">Querying Without the Index</h3>
<p>The queries is this section are executed by applying the underlying function <code>PowerEqualsSpecific_Func()</code> for every row in the table, because the index has not yet been defined.</p>
<p>The example file includes queries that check, both for a specific cell number and for any cell number, for values equal to, greater than, and less than a specified value. For example, the equality queries are demonstrated in <a href="#CIAEIGFE">Example 15-38</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAEIGFE"></a><a id="ADDCI4872"></a>Example 15-38 Making Equality Queries for Power Demand Cartridge</p>
<pre>
SET SERVEROUTPUT ON
-------------------------------------------------------------------
-- Query, referencing the operators (without index)
-------------------------------------------------------------------
explain plan for
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_Equals(P.Sample,2,10) = 1;
@tkoqxpll
 
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_Equals(P.Sample,2,10) = 1;

explain plan for
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand,
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_Equals(P.Sample,1,25) = 1;
@tkoqxpll

SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand,
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_Equals(P.Sample,1,25) = 1;
 
explain plan for
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_Equals(P.Sample,2,8) = 1;
@tkoqxpll
 
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_Equals(P.Sample,2,8) = 1;
 
explain plan for
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_EqualsAny(P.Sample,9) = 1;
@tkoqxpll
 
SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     P.Sample.MinCellDemand
   FROM PowerDemand_Tab P
   WHERE Power_EqualsAny(P.Sample,9) = 1;
</pre></div>
<!-- class="example" -->
<p>The execution plans show that a full table scan is performed in each case:</p>
<pre>
OPERATIONS       OPTIONS         OBJECT_NAME    
---------------  --------------- ---------------
SELECT STATEMENT                                
TABLE ACCESS     FULL            POWERDEMAND_TAB
</pre></div>
<!-- class="sect2" -->
<a id="ADDCI4873"></a>
<div class="sect2"><a id="sthref677"></a>
<h3 class="sect2">Creating the Index</h3>
<p>The index is created on the <code>Sample</code> column in the power demand table, as demonstrated in <a href="#CIAGHACH">Example 15-39</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAGHACH"></a><a id="ADDCI4874"></a>Example 15-39 Creating an Index in PowerDemand_Tab Table for Power Demand Cartridge</p>
<pre>
CREATE INDEX PowerIndex ON PowerDemand_Tab(Sample) 
   INDEXTYPE IS power_idxtype;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="ADDCI4875"></a>
<div class="sect2"><a id="sthref678"></a>
<h3 class="sect2">Querying with the Index</h3>
<p>The queries in this section are identical to those in <a href="#i1007154">"Querying Without the Index"</a>, but this time the index is used.</p>
<p>The execution plans show that Oracle is using the domain index and not performing full table scans, thus resulting in more efficient execution, as demonstrated in <a href="#CIAIIFAC">Example 15-40</a>.</p>
<div class="example">
<p class="titleinexample"><a id="CIAIIFAC"></a><a id="ADDCI4876"></a>Example 15-40 Making Equality Queries with Index for Power Demand Cartridge</p>
<pre>
SQLPLUS&gt; -------------------------------------------------------------------
SQLPLUS&gt; -- Query, referencing the operators (with index)
SQLPLUS&gt; -------------------------------------------------------------------
SQLPLUS&gt; explain plan for
     2&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     3&gt;      P.Sample.MinCellDemand
     4&gt;    FROM PowerDemand_Tab P
     5&gt;    WHERE Power_Equals(P.Sample,2,10) = 1;
Statement processed.
SQLPLUS&gt; @tkoqxpll
SQLPLUS&gt; set echo off
Echo                            OFF
Charwidth                       15
OPERATIONS      OPTIONS         OBJECT_NAME    
--------------- --------------- ---------------
SELECT STATEMEN                                
TABLE ACCESS    BY ROWID        POWERDEMAND_TAB
DOMAIN INDEX                    POWERINDEX     
3 rows selected.
Statement processed.
Echo                            ON
SQLPLUS&gt;  
SQLPLUS&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     2&gt;      P.Sample.MinCellDemand
     3&gt;    FROM PowerDemand_Tab P
     4&gt;    WHERE Power_Equals(P.Sample,2,10) = 1;
REGION     SAMPLE.TOT SAMPLE.MAX SAMPLE.MIN
---------- ---------- ---------- ----------
0 rows selected.
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;
ODCIIndexInfo
Index owner : POWERCARTUSER
Index name : POWERINDEX
Table owner : POWERCARTUSER
Table name : POWERDEMAND_TAB
Indexed column : "SAMPLE"
Indexed column type :POWERDEMAND_TYP
Indexed column type schema:POWERCARTUSER
ODCIPredInfo
Object owner : POWERCARTUSER
Object name : POWER_EQUALS
Method name : 
Predicate bounds flag :
     Exact Match
     Include Start Key
     Include Stop Key
start key : 1
stop key : 1
compare position : 2
compare value : 10
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;select r from POWERCARTUSER.POWERINDEX_pidx where cpos ='2' and cval ='10'
ODCIIndexFetch&gt;&gt;&gt;&gt;&gt;
Nrows : 2000
ODCIIndexClose&gt;&gt;&gt;&gt;&gt;
SQLPLUS&gt;  
SQLPLUS&gt; explain plan for
     2&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     3&gt;      P.Sample.MinCellDemand
     4&gt;    FROM PowerDemand_Tab P
     5&gt;    WHERE Power_Equals(P.Sample,2,8) = 1;
Statement processed.
SQLPLUS&gt; @tkoqxpll
SQLPLUS&gt; set echo off
Echo                            OFF
Charwidth                       15
OPERATIONS      OPTIONS         OBJECT_NAME    
--------------- --------------- ---------------
SELECT STATEMEN                                
TABLE ACCESS    BY ROWID        POWERDEMAND_TAB
DOMAIN INDEX                    POWERINDEX     
3 rows selected.
Statement processed.
Echo                            ON
SQLPLUS&gt;  
SQLPLUS&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     2&gt;      P.Sample.MinCellDemand
     3&gt;    FROM PowerDemand_Tab P
     4&gt;    WHERE Power_Equals(P.Sample,2,8) = 1;
REGION     SAMPLE.TOT SAMPLE.MAX SAMPLE.MIN
---------- ---------- ---------- ----------
         1         90         55          5
         1         89         56          3
         1         88         55          3
         1         87         54          3
         1         86         54          3
         2         49         16          5
         2         53         20          5
7 rows selected.
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;
ODCIIndexInfo
Index owner : POWERCARTUSER
Index name : POWERINDEX
Table owner : POWERCARTUSER
Table name : POWERDEMAND_TAB
Indexed column : "SAMPLE"
Indexed column type :POWERDEMAND_TYP
Indexed column type schema:POWERCARTUSER
ODCIPredInfo
Object owner : POWERCARTUSER
Object name : POWER_EQUALS
Method name : 
Predicate bounds flag :
     Exact Match
     Include Start Key
     Include Stop Key
start key : 1
stop key : 1
compare position : 2
compare value : 8
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;select r from POWERCARTUSER.POWERINDEX_pidx where cpos ='2' and cval ='8'
ODCIIndexFetch&gt;&gt;&gt;&gt;&gt;
Nrows : 2000
ODCIIndexClose&gt;&gt;&gt;&gt;&gt;
SQLPLUS&gt;  
SQLPLUS&gt; explain plan for
     2&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     3&gt;      P.Sample.MinCellDemand
     4&gt;    FROM PowerDemand_Tab P
     5&gt;    WHERE Power_EqualsAny(P.Sample,9) = 1;
Statement processed.
SQLPLUS&gt; @tkoqxpll
SQLPLUS&gt; set echo off
Echo                            OFF
Charwidth                       15
OPERATIONS      OPTIONS         OBJECT_NAME    
--------------- --------------- ---------------
SELECT STATEMEN                                
TABLE ACCESS    BY ROWID        POWERDEMAND_TAB
DOMAIN INDEX                    POWERINDEX     
3 rows selected.
Statement processed.
Echo                            ON
SQLPLUS&gt;  
SQLPLUS&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand, 
     2&gt;      P.Sample.MinCellDemand
     3&gt;    FROM PowerDemand_Tab P
     4&gt;    WHERE Power_EqualsAny(P.Sample,9) = 1;
REGION     SAMPLE.TOT SAMPLE.MAX SAMPLE.MIN
---------- ---------- ---------- ----------
         1         90         55          5
         1         89         56          3
         1         88         55          3
         1         87         54          3
         1         86         54          3
         2         49         16          5
         2         53         20          5
7 rows selected.
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;
ODCIIndexInfo
Index owner : POWERCARTUSER
Index name : POWERINDEX
Table owner : POWERCARTUSER
Table name : POWERDEMAND_TAB
Indexed column : "SAMPLE"
Indexed column type :POWERDEMAND_TYP
Indexed column type schema:POWERCARTUSER
ODCIPredInfo
Object owner : POWERCARTUSER
Object name : POWER_EQUALSANY
Method name : 
Predicate bounds flag :
     Exact Match
     Include Start Key
     Include Stop Key
start key : 1
stop key : 1
compare value : 9
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;select distinct r from POWERCARTUSER.POWERINDEX_pidx where cval ='9'
ODCIIndexFetch&gt;&gt;&gt;&gt;&gt;
Nrows : 2000
ODCIIndexClose&gt;&gt;&gt;&gt;&gt;
SQLPLUS&gt;
SQLPLUS&gt; explain plan for
     2&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand,
     3&gt;      P.Sample.MinCellDemand
     4&gt;    FROM PowerDemand_Tab P
     5&gt;    WHERE Power_GreaterThanAny(P.Sample,50) = 1;
Statement processed.
SQLPLUS&gt; @tkoqxpll
SQLPLUS&gt; set echo off
Echo                            OFF
Charwidth                       15
OPERATIONS      OPTIONS         OBJECT_NAME    
--------------- --------------- ---------------
SELECT STATEMEN                                
TABLE ACCESS    BY ROWID        POWERDEMAND_TAB
DOMAIN INDEX                    POWERINDEX     
3 rows selected.
Statement processed.
Echo                            ON
SQLPLUS&gt;
SQLPLUS&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand,
     2&gt;      P.Sample.MinCellDemand
     3&gt;    FROM PowerDemand_Tab P
     4&gt;    WHERE Power_GreaterThanAny(P.Sample,50) = 1;
REGION     SAMPLE.TOT SAMPLE.MAX SAMPLE.MIN
---------- ---------- ---------- ----------
         1         90         55          5
         1         89         56          3
         1         88         55          3
         1         87         54          3
         1         86         54          3
5 rows selected.
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;
ODCIIndexInfo
Index owner : POWERCARTUSER
Index name : POWERINDEX
Table owner : POWERCARTUSER
Table name : POWERDEMAND_TAB
Indexed column : "SAMPLE"
Indexed column type :POWERDEMAND_TYP
Indexed column type schema:POWERCARTUSER
ODCIPredInfo
Object owner : POWERCARTUSER
Object name : POWER_GREATERTHANANY
Method name :
Predicate bounds flag :
     Exact Match
     Include Start Key
     Include Stop Key
start key : 1
stop key : 1
compare value : 50
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;select distinct r from POWERCARTUSER.POWERINDEX_pidx where cv
al &gt;'50'
ODCIIndexFetch&gt;&gt;&gt;&gt;&gt;
Nrows : 2000
ODCIIndexClose&gt;&gt;&gt;&gt;&gt;
SQLPLUS&gt;
SQLPLUS&gt; explain plan for
     2&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand,
     3&gt;      P.Sample.MinCellDemand
     4&gt;    FROM PowerDemand_Tab P
     5&gt;    WHERE Power_LessThanAny(P.Sample,50) = 0;
Statement processed.
SQLPLUS&gt; @tkoqxpll
SQLPLUS&gt; set echo off
Echo                            OFF
Charwidth                       15
OPERATIONS      OPTIONS         OBJECT_NAME    
--------------- --------------- ---------------
SELECT STATEMEN                                
TABLE ACCESS    BY ROWID        POWERDEMAND_TAB
DOMAIN INDEX                    POWERINDEX     
3 rows selected.
Statement processed.
Echo                            ON
SQLPLUS&gt;
SQLPLUS&gt; SELECT P.Region, P.Sample.TotGridDemand ,P.Sample.MaxCellDemand,
     2&gt;      P.Sample.MinCellDemand
     3&gt;    FROM PowerDemand_Tab P
     4&gt;    WHERE Power_LessThanAny(P.Sample,50) = 0;
REGION     SAMPLE.TOT SAMPLE.MAX SAMPLE.MIN
---------- ---------- ---------- ----------
0 rows selected.
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;
ODCIIndexInfo
Index owner : POWERCARTUSER
Index name : POWERINDEX
Table owner : POWERCARTUSER
Table name : POWERDEMAND_TAB
Indexed column : "SAMPLE"
Indexed column type :POWERDEMAND_TYP
Indexed column type schema:POWERCARTUSER
ODCIPredInfo
Object owner : POWERCARTUSER
Object name : POWER_LESSTHANANY
Method name :
Predicate bounds flag :
     Exact Match
     Include Start Key
     Include Stop Key
start key : 0
stop key : 0
compare value : 50
ODCIIndexStart&gt;&gt;&gt;&gt;&gt;select distinct r from POWERCARTUSER.POWERINDEX_pidx minus se
lect distinct r from POWERCARTUSER.POWERINDEX_pidx where cval &lt;'50'
ODCIIndexFetch&gt;&gt;&gt;&gt;&gt;
Nrows : 2000
ODCIIndexClose&gt;&gt;&gt;&gt;&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1236">
<tr>
<td class="cellalignment1243">
<table class="cellalignment1241">
<tr>
<td class="cellalignment1240"><a href="part3.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1240"><a href="psbtree_example.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2010,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1245">
<table class="cellalignment1239">
<tr>
<td class="cellalignment1240"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1240"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1240"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1240"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1240"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1240"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
