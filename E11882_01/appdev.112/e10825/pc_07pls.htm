<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Embedded PL/SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2009-08-01T13:29:57Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide" />
<meta name="dcterms.identifier" content="E10825-01" />
<meta name="dcterms.isVersionOf" content="LNPCC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="pc_06sql.htm" title="Previous" type="text/html" />
<link rel="Next" href="pc_08arr.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10825.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/36</span> <!-- End Header --><a id="g27962"></a><a id="i10150"></a>
<h1 class="chapter"><span class="secnum">7</span> Embedded PL/SQL</h1>
<p>This chapter shows you how to improve performance by embedding PL/SQL transaction processing blocks in your program. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i7520">Advantages of PL/SQL</a></p>
</li>
<li>
<p><a href="#i2332">Embedded PL/SQL Blocks</a></p>
</li>
<li>
<p><a href="#i2336">Host Variables</a></p>
</li>
<li>
<p><a href="#i2340">Indicator Variables</a></p>
</li>
<li>
<p><a href="#i2344">Host Arrays</a></p>
</li>
<li>
<p><a href="#i2348">Cursor Usage in Embedded PL/SQL</a></p>
</li>
<li>
<p><a href="#i8702">Stored PL/SQL and Java Subprograms</a></p>
</li>
<li>
<p><a href="#i8054">External Procedures</a></p>
</li>
<li>
<p><a href="#i6535">Using Dynamic SQL</a></p>
</li>
</ul>
<a id="i7520"></a>
<div class="sect1">
<h2 class="sect1">Advantages of PL/SQL</h2>
<p>This section looks at some of the features and benefits offered by PL/SQL, such as:</p>
<ul>
<li>
<p><a href="#i2360">Better Performance</a></p>
</li>
<li>
<p><a href="#i2364">Integration with Oracle</a></p>
</li>
<li>
<p><a href="#i2368">Cursor FOR Loops</a></p>
</li>
<li>
<p><a href="#i2372">Procedures and Functions</a></p>
</li>
<li>
<p><a href="#i2376">Packages</a></p>
</li>
<li>
<p><a href="#i2380">PL/SQL Tables</a></p>
</li>
<li>
<p><a href="#i2384">User-Defined Records</a></p>
</li>
</ul>
<p>For more information about PL/SQL, see <a class="olink LNPLS" href="../e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<a id="i2360"></a>
<div class="sect2">
<h3 class="sect2">Better Performance</h3>
<p>PL/SQL can help you reduce overhead, improve performance, and increase productivity. For example, without PL/SQL, Oracle must process SQL statements one at a time. Each SQL statement results in another call to the Server and higher overhead. However, with PL/SQL, you can send an entire block of SQL statements to the Server. This minimizes communication between your application and Oracle.<a id="sthref989"></a></p>
</div>
<!-- class="sect2" -->
<a id="i2364"></a>
<div class="sect2">
<h3 class="sect2">Integration with Oracle</h3>
<p>PL/SQL is tightly integrated with the Oracle Server. For example, most PL/SQL datatypes are native to the Oracle data dictionary. Furthermore, you can use the %TYPE attribute to base variable declarations on column definitions stored in the data dictionary, as the following example shows:<a id="sthref990"></a><a id="sthref991"></a><a id="sthref992"></a></p>
<pre>
job_title  emp.job%TYPE; 
</pre>
<p>That way, you need not know the exact datatype of the column. Furthermore, if a column definition changes, the variable declaration changes accordingly and automatically. This provides data independence, reduces maintenance costs, and allows programs to adapt as the database changes.</p>
</div>
<!-- class="sect2" -->
<a id="i2368"></a>
<div class="sect2">
<h3 class="sect2">Cursor FOR Loops</h3>
<p>With PL/SQL, you need not use the DECLARE, OPEN, FETCH, and CLOSE statements to define and manipulate a cursor. Instead, you can use a cursor FOR loop, which implicitly declares its loop index as a record, opens the cursor associated with a given query, repeatedly fetches data from the cursor into the record, then closes the cursor. An example follows:<a id="sthref993"></a><a id="sthref994"></a></p>
<pre>
DECLARE 
... 
BEGIN 
   FOR emprec IN (SELECT empno, sal, comm FROM emp) LOOP 
   IF emprec.comm / emprec.sal &gt; 0.25 THEN ... 
   ... 
END LOOP; 
END; 
</pre>
<p>Notice that you use dot notation to reference components in the record.</p>
</div>
<!-- class="sect2" -->
<a id="i2372"></a>
<div class="sect2">
<h3 class="sect2">Procedures and Functions</h3>
<p>PL/SQL has two types of subprograms called <span class="italic">procedures</span> and <span class="italic">functions</span>, which aid application development by letting you isolate operations. Generally, you use a procedure to perform an action and a function to compute a value.<a id="sthref995"></a><a id="sthref996"></a></p>
<p>Procedures and functions provide <span class="italic">extensibility</span>. That is, they let you tailor the PL/SQL language to suit your needs. For example, if you need a procedure that creates a new department, just write your own as follows:</p>
<pre>
PROCEDURE create_dept 
  (new_dname  IN CHAR(14), 
   new_loc    IN CHAR(13), 
   new_deptno OUT NUMBER(2)) IS 
BEGIN 
   SELECT deptno_seq.NEXTVAL INTO new_deptno FROM dual; 
   INSERT INTO dept VALUES (new_deptno, new_dname, new_loc); 
END create_dept; 
</pre>
<p>When called, this procedure accepts a new department name and location, selects the next value in a department-number database sequence, inserts the new number, name, and location into the <span class="italic">dept</span> table, then returns the new number to the caller.</p>
<p>You use <span class="italic">parameter modes</span> to define the behavior of formal parameters. There are three parameter modes: IN (the default), OUT, and IN OUT. An IN parameter lets you pass values to the subprogram being called. An OUT parameter lets you return values to the caller of a subprogram. An IN OUT parameter lets you pass initial values to the subprogram being called and return updated values to the caller.<a id="sthref997"></a><a id="sthref998"></a><a id="sthref999"></a><a id="sthref1000"></a><a id="sthref1001"></a></p>
<p>The datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. <a href="#CHDDCCFE">Table 7-1</a> shows the legal conversions between datatypes.</p>
</div>
<!-- class="sect2" -->
<a id="i2376"></a>
<div class="sect2">
<h3 class="sect2">Packages</h3>
<p>PL/SQL lets you bundle logically related types, program objects, and subprograms into a <span class="italic">package</span>. With the Procedural Database Extension, packages can be compiled and stored in an Oracle database, where their contents can be shared by many applications.<a id="sthref1002"></a><a id="sthref1003"></a><a id="sthref1004"></a></p>
<p>Packages usually have two parts: a specification and a body. The <span class="italic">specification</span> is the interface to your applications; it declares the types, constants, variables, exceptions, cursors, and subprograms available for use. The <span class="italic">body</span> defines cursors and subprograms; it implements the specification. In the following example, you "package" two employment procedures:</p>
<pre>
PACKAGE emp_actions IS  -- package specification 
  PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...); 
 
  PROCEDURE fire_employee (emp_id NUMBER); 
END emp_actions; 
 
PACKAGE BODY emp_actions IS  -- package body 
  PROCEDURE hire_employee (empno NUMBER, ename CHAR, ...) IS 
  BEGIN 
    INSERT INTO emp VALUES (empno, ename, ...); 
  END hire_employee; 
 
  PROCEDURE fire_employee (emp_id NUMBER) IS 
  BEGIN 
    DELETE FROM emp WHERE empno = emp_id; 
  END fire_employee; 
END emp_actions; 
</pre>
<p>Only the declarations in the package specification are visible and accessible to applications. Implementation details in the package body are hidden and inaccessible.</p>
</div>
<!-- class="sect2" -->
<a id="i2380"></a>
<div class="sect2">
<h3 class="sect2">PL/SQL Tables</h3>
<p>PL/SQL provides a composite datatype named TABLE. Objects of type TABLE are called <span class="italic">PL/SQL tables</span>, which are modeled as (but not the same as) database tables. PL/SQL tables have only one column and use a primary key to give you array-like access to rows. The column can belong to any scalar type (such as CHAR, DATE, or NUMBER), but the primary key must belong to type BINARY_INTEGER, PLS_INTEGER or VARCHAR2.<a id="sthref1005"></a><a id="sthref1006"></a></p>
<p>You can declare PL/SQL table types in the declarative part of any block, procedure, function, or package. In the following example, you declare a TABLE type called <span class="italic">NumTabTyp</span>:</p>
<pre>
... 
DECLARE 
   TYPE NumTabTyp IS TABLE OF NUMBER 
      INDEX BY BINARY_INTEGER; 
... 
BEGIN 
   ... 
END; 
... 
</pre>
<p>Once you define type <span class="italic">NumTabTyp</span>, you can declare PL/SQL tables of that type, as the next example shows:</p>
<pre>
num_tab  NumTabTyp; 
</pre>
<p>The identifier <span class="italic">num_tab</span> represents an entire PL/SQL table.</p>
<p>You reference rows in a PL/SQL table using array-like syntax to specify the primary key value. For example, you reference the ninth row in the PL/SQL table named <span class="italic">num_tab</span> as follows:</p>
<pre>
num_tab(9) ... 
</pre></div>
<!-- class="sect2" -->
<a id="i2384"></a>
<div class="sect2">
<h3 class="sect2">User-Defined Records</h3>
<p>You can use the %ROWTYPE attribute to declare a record that represents a row in a table or a row fetched by a cursor. However, you cannot specify the datatypes of components in the record or define components of your own. The composite datatype RECORD lifts those restrictions.<a id="sthref1007"></a><a id="sthref1008"></a><a id="sthref1009"></a><a id="sthref1010"></a></p>
<p>Objects of type RECORD are called <span class="italic">records</span>. Unlike PL/SQL tables, records have uniquely named components, which can belong to different datatypes. For example, suppose you have different kinds of data about an employee such as name, salary, hire date, and so on. This data is dissimilar in type but logically related. A record that contains such components as the name, salary, and hire date of an employee would let you treat the data as a logical unit.</p>
<p>You can declare record types and objects in the declarative part of any block, procedure, function, or package. In the following example, you declare a RECORD type called <span class="italic">DeptRecTyp</span>:</p>
<pre>
DECLARE 
TYPE DeptRecTyp IS RECORD 
    (deptno  NUMBER(4) NOT NULL, -- default is NULL allowed 
    dname   CHAR(9), 
    loc     CHAR(14)); 
</pre>
<p>Notice that the component declarations are like variable declarations. Each component has a unique name and specific datatype. You can add the NOT NULL option to any component declaration and so prevent the assigning of NULLs to that component.</p>
<p>Once you define type <span class="italic">DeptRecTyp</span>, you can declare records of that type, as the next example shows:</p>
<pre>
dept_rec  DeptRecTyp; 
</pre>
<p>The identifier <span class="italic">dept_rec</span> represents an entire record.</p>
<p>You use dot notation to reference individual components in a record. For example, you reference the <span class="italic">dname</span> component in the <span class="italic">dept_rec</span> record as follows:</p>
<pre>
dept_rec.dname ... 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2332"></a>
<div class="sect1">
<h2 class="sect1">Embedded PL/SQL Blocks</h2>
<p>The Pro*C/C++ Precompiler treats a PL/SQL block like a single embedded SQL statement. So, you can place a PL/SQL block anywhere in a program that you can place a SQL statement.<a id="sthref1011"></a><a id="sthref1012"></a></p>
<p>To embed a PL/SQL block in your Pro*C/C++ program, simply bracket the PL/SQL block with the keywords EXEC SQL EXECUTE and END-EXEC as follows:</p>
<pre>
EXEC SQL EXECUTE
DECLARE
... 
BEGIN 
   ... 
END; 
END-EXEC; 
</pre>
<p>The keyword END-EXEC must be followed by a semicolon.<a id="sthref1013"></a></p>
<p>After writing your program, you precompile the source file in the usual way.</p>
<p>When the program contains embedded PL/SQL, you must use the SQLCHECK=SEMANTICS command-line option, since the PL/SQL must be parsed by the Oracle Server. SQLCHECK=SEMANTICS requires the USERID option also, to connect to a server.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i5560">"Using the Precompiler Options"</a>.<a id="sthref1014"></a></div>
</div>
<!-- class="sect1" -->
<a id="i2336"></a>
<div class="sect1">
<h2 class="sect1">Host Variables</h2>
<p>Host variables are the key to communication between a host language and a PL/SQL block. Host variables can be shared with PL/SQL, meaning that PL/SQL can set and reference host variables.</p>
<p>For example, you can prompt a user for information and use host variables to pass that information to a PL/SQL block. Then, PL/SQL can access the database and use host variables to pass the results back to your host program.<a id="sthref1015"></a></p>
<p>Inside a PL/SQL block, host variables are treated as global to the entire block and can be used anywhere a PL/SQL variable is allowed. Like host variables in a SQL statement, host variables in a PL/SQL block must be prefixed with a colon. The colon sets host variables apart from PL/SQL variables and database objects.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To use VARCHAR, CHARZ, or STRING types as output host variables in PL/SQL blocks, you must initialize the length <span class="italic">before</span> entering the block. Set the length to the declared (maximum) length of the VARCHAR, CHARZ, or STRING.</div>
<div class="sect2"><a id="sthref1016"></a>
<h3 class="sect2">Example: Using Host Variables with PL/SQL</h3>
<p>The following example illustrates the use of host variables with PL/SQL. The program prompts the user for an employee number, then displays the job title, hire date, and salary of that employee.<a id="sthref1017"></a></p>
<pre>
char username[100], password[20]; 
char job_title[20], hire_date[9], temp[32]; 
int emp_number; 
float salary; 
 
#include &lt;sqlca.h&gt; 
 
printf("Username? \n"); 
gets(username); 
printf("Password? \n"); 
gets(password); 
 
EXEC SQL WHENEVER SQLERROR GOTO sql_error; 
 
EXEC SQL CONNECT :username IDENTIFIED BY :password; 
printf("Connected to Oracle\n"); 
for (;;) 
{
   printf("Employee Number (0 to end)? "); 
   gets(temp);
   emp_number = atoi(temp); 
 
   if (emp_number == 0) 
   { 
      EXEC SQL COMMIT WORK RELEASE; 
      printf("Exiting program\n"); 
      break; 
   } 
/*-------------- begin PL/SQL block -----------------*/ 
   EXEC SQL EXECUTE 
   BEGIN 
      SELECT job, hiredate, sal 
         INTO :job_title, :hire_date, :salary 
         FROM emp 
         WHERE empno = :emp_number; 
   END; 
   END-EXEC; 
/*-------------- end PL/SQL block -----------------*/ 
 
   printf("Number  Job Title  Hire Date  Salary\n"); 
   printf("------------------------------------\n"); 
   printf("%6d  %8.8s  %9.9s  %6.2f\n", 
   emp_number, job_title, hire_date, salary); 
} 
... 
exit(0); 
 
sql_error: 
EXEC SQL WHENEVER SQLERROR CONTINUE; 
EXEC SQL ROLLBACK WORK RELEASE; 
printf("Processing error\n"); 
exit(1); 
</pre>
<p>Notice that the host variable <span class="italic">emp_number</span> is set before the PL/SQL block is entered, and the host variables <span class="italic">job_title</span>, <span class="italic">hire_date</span>, and <span class="italic">salary</span> are set inside the block.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1018"></a>
<h3 class="sect2">Complex Example</h3>
<p>In the example later, you prompt the user for a bank account number, transaction type, and transaction amount, then debit or credit the account. If the account does not exist, you raise an exception. When the transaction is complete, you display its status.<a id="sthref1019"></a></p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;

char username[20];
char password[20];
char status[80]; 
char temp[32];
int  acct_num; 
double trans_amt; 
void sql_error();



main()
{
   char trans_type;

   strcpy(password, "TIGER");
   strcpy(username, "SCOTT");

   EXEC SQL WHENEVER SQLERROR DO sql_error(); 
   EXEC SQL CONNECT :username IDENTIFIED BY :password; 
   printf("Connected to Oracle\n"); 

   for (;;) 
   { 
      printf("Account Number (0 to end)? "); 
      gets(temp);
      acct_num = atoi(temp); 

      if(acct_num == 0) 
      { 
         EXEC SQL COMMIT WORK RELEASE; 
         printf("Exiting program\n"); 
         break; 
      } 
 
      printf("Transaction Type - D)ebit or C)redit? "); 
      gets(temp);
      trans_type = temp[0];
 
      printf("Transaction Amount? "); 
      gets(temp);
      trans_amt = atof(temp); 

/*----------------- begin PL/SQL block -------------------*/ 
      EXEC SQL EXECUTE 
      DECLARE 
         old_bal      NUMBER(9,2); 
         err_msg      CHAR(70); 
         nonexistent  EXCEPTION; 

      BEGIN 
         :trans_type := UPPER(:trans_type); 
         IF :trans_type = 'C' THEN       -- credit the account 
            UPDATE accts SET bal = bal + :trans_amt 
            WHERE acctid = :acct_num; 
            IF SQL%ROWCOUNT = 0 THEN    -- no rows affected 
               RAISE nonexistent; 
            ELSE 
               :status := 'Credit applied'; 
            END IF; 
         ELSIF :trans_type = 'D' THEN    -- debit the account 
            SELECT bal INTO old_bal FROM accts 
               WHERE acctid = :acct_num; 
            IF old_bal &gt;= :trans_amt THEN   -- enough funds 
               UPDATE accts SET bal = bal - :trans_amt 
                  WHERE acctid = :acct_num; 
               :status := 'Debit applied'; 
            ELSE 
               :status := 'Insufficient funds'; 
            END IF; 
         ELSE 
            :status := 'Invalid type: ' || :trans_type; 
         END IF; 
         COMMIT; 
      EXCEPTION 
         WHEN NO_DATA_FOUND OR nonexistent THEN 
            :status := 'Nonexistent account'; 
         WHEN OTHERS THEN 
            err_msg := SUBSTR(SQLERRM, 1, 70); 
            :status := 'Error: ' || err_msg; 
      END; 
      END-EXEC; 
/*----------------- end PL/SQL block ----------------------- */
 
      printf("\nStatus: %s\n", status); 
   } 
   exit(0); 
}


void
sql_error() 
{ 
    EXEC SQL WHENEVER SQLERROR CONTINUE; 
    EXEC SQL ROLLBACK WORK RELEASE; 
    printf("Processing error\n"); 
    exit(1); 
}
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1020"></a>
<h3 class="sect2">VARCHAR Pseudotype</h3>
<p>You can use the VARCHAR datatype to declare variable-length character strings. If the VARCHAR is an input host variable, you must tell Oracle what length to expect. Therefore, set the length component to the actual length of the value stored in the string component.</p>
<p>If the VARCHAR is an output host variable, Oracle automatically sets the length component. However, to use a VARCHAR (as well as CHARZ and STRING) output host variable in your PL/SQL block, you must initialize the length component <span class="italic">before</span> entering the block. So, set the length component to the declared (maximum) length of the VARCHAR, as shown here:<a id="sthref1021"></a><a id="sthref1022"></a></p>
<pre>
int     emp_number; 
varchar emp_name[10]; 
float   salary; 
... 
emp_name.len = 10;   /* initialize length component */ 
 
EXEC SQL EXECUTE 
  BEGIN 
    SELECT ename, sal INTO :emp_name, :salary 
        FROM emp 
        WHERE empno = :emp_number; 
    ... 
  END; 
END-EXEC; 
... 
</pre></div>
<!-- class="sect2" -->
<a id="i2299"></a>
<div class="sect2">
<h3 class="sect2">Restriction</h3>
<p>Do not use C pointer or array syntax in PL/SQL blocks. The PL/SQL compiler does not understand C host-variable expressions and is, therefore, unable to parse them. For example, the following is <span class="italic">invalid</span>:</p>
<pre>
EXEC SQL EXECUTE
    BEGIN
        :x[5].name := 'SCOTT';
        ...
    END;
END-EXEC;
</pre>
<p>To avoid syntax errors, use a place-holder (a temporary variable), to hold the address of the structure field to populate structures as shown in the following <span class="italic">valid</span> example:</p>
<pre>
name = x[5].name ;
EXEC SQL EXECUTE
    BEGIN
        :name := ...;
        ...
    END;
END-EXEC;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2340"></a>
<div class="sect1">
<h2 class="sect1">Indicator Variables</h2>
<p>PL/SQL does not need indicator variables because it can manipulate NULLs. For example, within PL/SQL, you can use the IS NULL operator to test for NULLs, as follows:<a id="sthref1023"></a></p>
<pre>
IF variable IS NULL THEN ... 
</pre>
<p>And, you can use the assignment operator (:=) to assign NULLs, as follows:</p>
<pre>
variable := NULL; 
</pre>
<p>However, a host language such as C needs indicator variables because it cannot manipulate NULLs. Embedded PL/SQL meets this need by letting you use indicator variables to</p>
<ul>
<li>
<p>Accept NULLs input from a host program</p>
</li>
<li>
<p>Output NULLs or truncated values to a host program</p>
</li>
</ul>
<p>When used in a PL/SQL block, indicator variables are subject to the following rules:</p>
<ul>
<li>
<p>You cannot refer to an indicator variable by itself; it must be appended to its associated host variable.</p>
</li>
<li>
<p>If you refer to a host variable with its indicator variable, you must always refer to it that way in the same block.</p>
</li>
</ul>
<p>In the following example, the indicator variable <span class="italic">ind_comm</span> appears with its host variable <span class="italic">commission</span> in the SELECT statement, so it must appear that way in the IF statement:</p>
<pre>
... 
EXEC SQL EXECUTE 
BEGIN 
    SELECT ename, comm 
        INTO :emp_name, :commission :ind_comm 
        FROM emp 
        WHERE empno = :emp_number; 
    IF :commission :ind_comm IS NULL THEN ... 
    ... 
END; 
END-EXEC; 
</pre>
<p>Notice that PL/SQL treats <span class="italic">:commission :ind_comm</span> like any other simple variable. Though you cannot refer directly to an indicator variable inside a PL/SQL block, PL/SQL checks the value of the indicator variable when entering the block and sets the value correctly when exiting the block.</p>
<div class="sect2"><a id="sthref1024"></a>
<h3 class="sect2">NULLs Handling</h3>
<p>When entering a block, if an indicator variable has a value of -1, PL/SQL automatically assigns a NULL to the host variable. When exiting the block, if a host variable is NULL, PL/SQL automatically assigns a value of -1 to the indicator variable. In the next example, if <span class="italic">ind_sal</span> had a value of -1 before the PL/SQL block was entered, the <span class="italic">salary_missing</span> exception is raised. An <span class="italic">exception</span> is a named error condition.<a id="sthref1025"></a></p>
<pre>
... 
EXEC SQL EXECUTE 
BEGIN 
    IF :salary :ind_sal IS NULL THEN 
    RAISE salary_missing; 
END IF; 
... 
END; 
END-EXEC; 
...
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1026"></a>
<h3 class="sect2">Truncated Values</h3>
<p>PL/SQL does not raise an exception when a truncated string value is assigned to a host variable. However, if you use an indicator variable, PL/SQL sets it to the original length of the string. In the following example, the host program will be able to tell, by checking the value of <span class="italic">ind_name</span>, if a truncated value was assigned to <span class="italic">emp_name</span>:<a id="sthref1027"></a></p>
<pre>
... 
EXEC SQL EXECUTE 
DECLARE 
... 
new_name  CHAR(10); 
BEGIN 
    ... 
    :emp_name:ind_name := new_name; 
    ... 
END; 
END-EXEC; 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2344"></a>
<div class="sect1">
<h2 class="sect1">Host Arrays</h2>
<p>You can pass input host arrays and indicator arrays to a PL/SQL block. They can be indexed by a PL/SQL variable of type BINARY_INTEGER or PLS_INTEGER; VARCHAR2 key types are not permitted. Normally, the entire host array is passed to PL/SQL, but you can use the ARRAYLEN statement (discussed later) to specify a smaller array dimension.</p>
<p>Furthermore, you can use a procedure call to assign all the values in a host array to rows in a PL/SQL table. Given that the array subscript range is <span class="italic">m</span> .. <span class="italic">n</span>, the corresponding PL/SQL table index range is always 1 .. <span class="italic">n</span> - <span class="italic">m</span> + 1. For example, if the array subscript range is 5 .. 10, the corresponding PL/SQL table index range is 1 .. (10 - 5 + 1) or 1 .. 6.</p>
<p>In the following example, you pass an array named <span class="italic">salary</span> to a PL/SQL block, which uses the array in a function call. The function is named <span class="italic">median</span> because it finds the middle value in a series of numbers. Its formal parameters include a PL/SQL table named <span class="italic">num_tab</span>. The function call assigns all the values in the actual parameter <span class="italic">salary</span> to rows in the formal parameter <span class="italic">num_tab</span>.</p>
<pre>
... 
float salary[100]; 
 
/* populate the host array */ 
 
EXEC SQL EXECUTE 
  DECLARE 
    TYPE NumTabTyp IS TABLE OF REAL 
        INDEX BY BINARY_INTEGER; 
    median_salary  REAL; 
    n  BINARY_INTEGER; 
... 
  FUNCTION median (num_tab NumTabTyp, n INTEGER) 
    RETURN REAL IS 
  BEGIN 
    -- compute median 
  END; 
  BEGIN 
    n := 100; 
    median_salary := median(:salary, n); 
    ... 
  END; 
END-EXEC; 
... 
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
In dynamic SQL Method 4, you cannot bind a host array to a PL/SQL procedure with a parameter of type "table." See also<a href="pc_13dyn.htm#i2160">"Using Method 4"</a>.</div>
<p>You can also use a procedure call to assign all row values in a PL/SQL table to corresponding elements in a host array.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i8702">"Stored PL/SQL and Java Subprograms"</a> for an example.</div>
<p><a href="#CHDDCCFE">Table 7-1</a> shows the legal conversions between row values in a PL/SQL table and elements in a host array. For example, a host array of type LONG is compatible with a PL/SQL table of type VARCHAR2, LONG, RAW, or LONG RAW. Notably, it is not compatible with a PL/SQL table of type CHAR.</p>
<div class="tblhruleformal">
<p class="titleintable"><a id="sthref1028"></a><a id="CHDDCCFE"></a>Table 7-1 Legal Datatype Conversions</p>
<table class="cellalignment833" title="Legal Datatype Conversions" summary="Legal Datatype Conversions" dir="ltr">
<thead>
<tr class="cellalignment824">
<th class="cellalignment831" id="r1c1-t6"><span class="bold">PL/SQL Table-&gt;</span><span class="bold">Host Array</span></th>
<th class="cellalignment831" id="r1c2-t6"><span class="bold">CHAR</span></th>
<th class="cellalignment831" id="r1c3-t6"><span class="bold">DATE</span></th>
<th class="cellalignment831" id="r1c4-t6"><span class="bold">LONG</span></th>
<th class="cellalignment831" id="r1c5-t6"><span class="bold">LONG RAW</span></th>
<th class="cellalignment831" id="r1c6-t6"><span class="bold">NUMBER</span></th>
<th class="cellalignment831" id="r1c7-t6"><span class="bold">RAW</span></th>
<th class="cellalignment831" id="r1c8-t6"><span class="bold">ROWID</span></th>
<th class="cellalignment831" id="r1c9-t6"><span class="bold">VARCHAR2</span></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment824">
<td class="cellalignment832" id="r2c1-t6" headers="r1c1-t6">
<p>CHARF</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c2-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r2c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r3c1-t6" headers="r1c1-t6">
<p>CHARZ</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c2-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r3c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r4c1-t6" headers="r1c1-t6">
<p>DATE</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c3-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r4c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r5c1-t6" headers="r1c1-t6">
<p>DECIMAL</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r5c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r6c1-t6" headers="r1c1-t6">
<p>DISPLAY</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r6c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r7c1-t6" headers="r1c1-t6">
<p>FLOAT</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r7c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r8c1-t6" headers="r1c1-t6">
<p>INTEGER</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r8c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r9c1-t6" headers="r1c1-t6">
<p>LONG</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c2-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c4-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r9c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r10c1-t6" headers="r1c1-t6">
<p>LONG VARCHAR</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c4-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r10c1-t6 r1c9-t6">
<p>X</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r11c1-t6" headers="r1c1-t6">
<p>LONG VARRAW</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r11c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r12c1-t6" headers="r1c1-t6">
<p>NUMBER</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r12c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r13c1-t6" headers="r1c1-t6">
<p>RAW</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r13c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r14c1-t6" headers="r1c1-t6">
<p>ROWID</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c8-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r14c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r15c1-t6" headers="r1c1-t6">
<p>STRING</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c4-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r15c1-t6 r1c9-t6">
<p>X</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r16c1-t6" headers="r1c1-t6">
<p>UNSIGNED</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r16c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r17c1-t6" headers="r1c1-t6">
<p>VARCHAR</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c4-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r17c1-t6 r1c9-t6">
<p>X</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r18c1-t6" headers="r1c1-t6">
<p>VARCHAR2</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c4-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r18c1-t6 r1c9-t6">
<p>X</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r19c1-t6" headers="r1c1-t6">
<p>VARNUM</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c5-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c6-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c7-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r19c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r20c1-t6" headers="r1c1-t6">
<p>VARRAW</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c2-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c3-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c4-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c5-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c6-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c7-t6">
<p>X</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c8-t6">
<p>-</p>
</td>
<td class="cellalignment832" headers="r20c1-t6 r1c9-t6">
<p>-</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The Pro*C/C++ Precompiler does not check your usage of host arrays. For instance, no index range-checking is done.</div>
<div class="sect2"><a id="sthref1029"></a>
<h3 class="sect2">ARRAYLEN Statement</h3>
<p>Suppose you must pass an input host array to a PL/SQL block for processing. By default, when binding such a host array, the Pro*C/C++ Precompiler uses its declared dimension. However, you might not want to process the entire array. In that case, you can use the ARRAYLEN statement to specify a smaller array dimension. ARRAYLEN associates the host array with a host variable, which stores the smaller dimension. The statement syntax is<a id="sthref1030"></a></p>
<pre>
EXEC SQL ARRAYLEN host_array (dimension) [EXECUTE]; 
</pre>
<p>where <span class="italic">dimension</span> is a 4-byte integer host variable, <span class="italic">not</span> a literal or expression.</p>
<p>EXECUTE is an optional keyword.</p>
<p>The ARRAYLEN statement must appear along with, but somewhere after, the declarations of <span class="italic">host_array</span> and <span class="italic">dimension</span>. You cannot specify an offset into the host array. However, you might be able to use C features for that purpose. The following example uses ARRAYLEN to override the default dimension of a C host array named <span class="italic">bonus</span>:</p>
<pre>
float bonus[100]; 
int dimension; 
EXEC SQL ARRAYLEN bonus (dimension); 
/* populate the host array */ 
... 
dimension = 25;  /* set smaller array dimension */ 
EXEC SQL EXECUTE 
DECLARE 
    TYPE NumTabTyp IS TABLE OF REAL 
    INDEX BY BINARY_INTEGER; 
    median_bonus  REAL; 
    FUNCTION median (num_tab NumTabTyp, n INTEGER) 
        RETURN REAL IS 
  BEGIN 
    -- compute median 
  END; 
  BEGIN 
    median_bonus := median(:bonus, :dimension); 
    ... 
  END; 
END-EXEC; 
</pre>
<p>Only 25 array elements are passed to the PL/SQL block because ARRAYLEN reduces the array from 100 to 25 elements. As a result, when the PL/SQL block is sent to Oracle for execution, a much smaller host array is sent along. This saves time and, in a networked environment, reduces network traffic.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1031"></a>
<h3 class="sect2">Optional Keyword <a id="sthref1032"></a>EXECUTE</h3>
<p>Host arrays used in a dynamic SQL method 2 EXEC SQL EXECUTE statement may have two different interpretations based on the presence or absence of the optional keyword EXECUTE.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_13dyn.htm#i2337">"Using Method 2"</a></div>
<p>By default (if the EXECUTE keyword is absent on an ARRAYLEN statement):</p>
<ul>
<li>
<p>The host array is considered when determining the number of times a PL/SQL block will be executed. (The minimum array dimension is used.)</p>
</li>
<li>
<p>The host array must not be bound to a PL/SQL index table.</p>
</li>
</ul>
<p>If the keyword EXECUTE is present:</p>
<ul>
<li>
<p>The host array must be bound to an index table.</p>
</li>
<li>
<p>The PL/SQL block will be executed one time.</p>
</li>
<li>
<p>All host variables specified in the EXEC SQL EXECUTE statement must either</p>
<ul>
<li>
<p>Be specified in an ARRAYLEN ... EXECUTE statement</p>
</li>
<li>
<p>Be scalar.</p>
</li>
</ul>
</li>
</ul>
<p>For example, given the following PL/SQL procedure:</p>
<pre>
   CREATE OR REPLACE PACKAGE pkg AS 
          TYPE tab IS TABLE OF NUMBER(5) INDEX BY BINARY_INTEGER; 
          PROCEDURE proc1 (parm1 tab, parm2 NUMBER, parm3 tab); 
   END; 
 
</pre>
<p>The following Pro*C/C++ function demonstrates how host arrays can be used to determine how many times a given PL/SQL block is executed. In this case, the PL/SQL block will be executed 3 times resulting in 3 new rows in the <code>emp</code> table.</p>
<pre>
func1() 
{ 
  int empno_arr[5] = {1111, 2222, 3333, 4444, 5555}; 
  char *ename_arr[3] = {"MICKEY", "MINNIE", "GOOFY"}; 
  char *stmt1 = "BEGIN INSERT INTO emp(empno, ename) VALUES :b1, :b2; END;"; 
  
  EXEC SQL PREPARE s1 FROM :stmt1; 
  EXEC SQL EXECUTE s1 USING :empno_arr, :ename_arr; 
}  
 
</pre>
<p>The following Pro*C/C++ function demonstrates how to bind a host array to a PL/SQL index table through dynamic method 2. Note the presence of the ARRAYLEN...EXECUTE statement for all host arrays specified in the EXEC SQL EXECUTE statement.</p>
<pre>
func2() 
{ 
  int ii = 2; 
  int int_tab[3] = {1,2,3}; 
  int dim = 3; 
  EXEC SQL ARRAYLEN int_tab (dim) EXECUTE;  
 
  char *stmt2 = "begin pkg.proc1(:v1, :v2, :v3); end; "; 
 
  EXEC SQL PREPARE s2 FROM :stmt2; 
  EXEC SQL EXECUTE s2 USING :int_tab, :ii, :int_tab;  
} 
 
</pre>
<p>However the following Pro*C/C++ function will result in a precompile-time warning because there is no ARRAYLEN...EXECUTE statement for <code>int_arr</code>.</p>
<pre>
func3() 
{ 
  int int_arr[3]; 
  int int_tab[3] = {1,2,3}; 
  int dim = 3; 
  EXEC SQL ARRAYLEN int_tab (dim) EXECUTE;  
 
  char *stmt3 = "begin pkg.proc1(:v1, :v2, :v3); end; "; 
 
  EXEC SQL PREPARE s3 FROM :stmt3; 
  EXEC SQL EXECUTE s3 USING :int_tab, :int_arr, :int_tab;  
} 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_08arr.htm#g20885">Chapter 8, "Host Arrays"</a> for a complete discussion of using arrays.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2348"></a>
<div class="sect1">
<h2 class="sect1">Cursor Usage in Embedded PL/SQL</h2>
<p>The maximum number of cursors your program can use simultaneously is determined by the database initialization parameter OPEN_CURSORS. While executing an embedded PL/SQL block, one cursor. the parent cursor, is associated with the entire block and one cursor, the child cursor, is associated with each SQL statement in the embedded PL/SQL block. Both parent and child cursors count toward the <code>OPEN_CURSORS</code> limit.</p>
<p>The following calculation shows how to determine the maximum number of cursors used. The sum of the cursors used must not exceed <code>OPEN_CURSORS</code>.</p>
<pre>
   SQL statement cursors
   PL/SQL parent cursors
   PL/SQL child cursors
+  6 cursors for overhead
--------------------------
   Sum of cursors in use
</pre>
<p>If your program exceeds the limit imposed by <code>OPEN_CURSORS</code>, Oracle gives you an error.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_actun.htm#CHEGEAFA">"Embedded PL/SQL Considerations"</a></div>
</div>
<!-- class="sect1" -->
<a id="i8702"></a>
<div class="sect1">
<h2 class="sect1">Stored PL/SQL and Java Subprograms</h2>
<p>Unlike anonymous blocks, PL/SQL subprograms (procedures and functions) and Java methods can be compiled separately, stored in an Oracle database, and invoked.</p>
<p>For more information about creating Java methods, see <span class="italic"><a class="olink JJDEV" href="../../java.112/e10588/toc.htm">Oracle Database Java Developer's Guide</a></span></p>
<p>A subprogram explicitly created using an Oracle tool such as SQL*Plus is called a <span class="italic">stored</span> subprogram. Once compiled and stored in the data dictionary, it is a database object, which can be re-executed without being recompiled.<a id="sthref1033"></a></p>
<p>When a subprogram within a PL/SQL block or stored procedure is sent to Oracle by your application, it is called an <span class="italic">inline</span> subprogram. Oracle compiles the inline subprogram and caches it in the System Global Area (SGA) but does not store the source or object code in the data dictionary.<a id="sthref1034"></a></p>
<p>Subprograms defined within a package are considered part of the package, and thus are called <span class="italic">packaged</span> subprograms. Stored subprograms not defined within a package are called <span class="italic">standalone</span> subprograms.<a id="sthref1035"></a></p>
<a id="i2324"></a>
<div class="sect2">
<h3 class="sect2">Creating Stored Subprograms</h3>
<p>You can embed the SQL statements CREATE FUNCTION, CREATE PROCEDURE, and CREATE PACKAGE in a host program, as the following example shows:<a id="sthref1036"></a><a id="sthref1037"></a></p>
<pre>
EXEC SQL CREATE 
FUNCTION sal_ok (salary REAL, title CHAR) 
RETURN BOOLEAN AS 
min_sal  REAL; 
max_sal  REAL; 
  BEGIN 
    SELECT losal, hisal INTO min_sal, max_sal 
        FROM sals 
        WHERE job = title; 
    RETURN (salary &gt;= min_sal) AND 
           (salary &lt;= max_sal); 
  END sal_ok; 
END-EXEC; 
</pre>
<p>Notice that the embedded CREATE {FUNCTION | PROCEDURE | PACKAGE} statement is a hybrid. Like all other embedded CREATE statements, it begins with the keywords EXEC SQL (not EXEC SQL EXECUTE). But, unlike other embedded CREATE statements, it ends with the PL/SQL terminator END-EXEC.</p>
<p>In the example later, you create a package that contains a procedure named <span class="italic">get_employees</span>, which fetches a batch of rows from the EMP table. The batch size is determined by the caller of the procedure, which might be another stored subprogram or a client application.</p>
<p>The procedure declares three PL/SQL tables as OUT formal parameters, then fetches a batch of employee data into the PL/SQL tables. The matching actual parameters are host arrays. When the procedure finishes, it automatically assigns all row values in the PL/SQL tables to corresponding elements in the host arrays.</p>
<pre>
EXEC SQL CREATE OR REPLACE PACKAGE emp_actions AS 
    TYPE CharArrayTyp IS TABLE OF VARCHAR2(10) 
        INDEX BY BINARY_INTEGER; 
    TYPE NumArrayTyp IS TABLE OF FLOAT 
        INDEX BY BINARY_INTEGER; 
  PROCEDURE get_employees( 
    dept_number IN     INTEGER, 
    batch_size  IN     INTEGER, 
    found       IN OUT INTEGER, 
    done_fetch  OUT    INTEGER, 
    emp_name    OUT    CharArrayTyp, 
    job_title   OUT    CharArrayTyp, 
    salary      OUT    NumArrayTyp); 
  END emp_actions; 
END-EXEC;
EXEC SQL CREATE OR REPLACE PACKAGE BODY emp_actions AS 
 
    CURSOR get_emp (dept_number IN INTEGER) IS 
        SELECT ename, job, sal FROM emp 
            WHERE deptno = dept_number; 
 
  PROCEDURE get_employees( 
    dept_number IN     INTEGER, 
    batch_size  IN     INTEGER, 
    found       IN OUT INTEGER, 
    done_fetch  OUT    INTEGER, 
    emp_name    OUT    CharArrayTyp, 
    job_title   OUT    CharArrayTyp, 
    salary      OUT    NumArrayTyp) IS 
 
  BEGIN 
    IF NOT get_emp%ISOPEN THEN 
        OPEN get_emp(dept_number); 
    END IF; 
    done_fetch := 0; 
    found := 0; 
    FOR i IN 1..batch_size LOOP 
        FETCH get_emp INTO emp_name(i), 
        job_title(i), salary(i); 
        IF get_emp%NOTFOUND THEN 
            CLOSE get_emp; 
            done_fetch := 1; 
            EXIT; 
        ELSE 
            found := found + 1; 
        END IF; 
    END LOOP; 
  END get_employees; 
END emp_actions; 
END-EXEC; 
</pre>
<p>You specify the REPLACE clause in the CREATE statement to redefine an existing package without having to drop the package, re-create it, and re-grant privileges on it. For the full syntax of the CREATE statement see <a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>If an embedded CREATE {FUNCTION | PROCEDURE | PACKAGE} statement fails, Oracle generates a warning, not an error.</p>
</div>
<!-- class="sect2" -->
<a id="i2113"></a>
<div class="sect2">
<h3 class="sect2">Calling a Stored PL/SQL or Java Subprogram</h3>
<p>To call a stored subprogram from your host program, you can use either an anonymous PL/SQL block, or the CALL embedded SQL statement.</p>
<div class="sect3"><a id="sthref1038"></a>
<h4 class="sect3">Anonymous PL/SQL Block</h4>
<p>In the following example, you call a standalone procedure named <span class="italic">raise_salary</span>:<a id="sthref1039"></a></p>
<pre>
EXEC SQL EXECUTE 
  BEGIN 
    raise_salary(:emp_id, :increase); 
  END; 
END-EXEC; 
</pre>
<p>Notice that stored subprograms can take parameters. In this example, the actual parameters <span class="italic">emp_id</span> and <span class="italic">increase</span> are C host variables.</p>
<p>In the next example, the procedure <span class="italic">raise_salary</span> is stored in a package named <span class="italic">emp_actions</span>, so you must use dot notation to fully qualify the procedure call:</p>
<pre>
EXEC SQL EXECUTE 
BEGIN 
    emp_actions.raise_salary(:emp_id, :increase); 
END; 
END-EXEC; 
</pre>
<p>An actual IN parameter can be a literal, scalar host variable, host array, PL/SQL constant or variable, PL/SQL table, PL/SQL user-defined record, procedure call, or expression. However, an actual OUT parameter cannot be a literal, procedure call, or expression.</p>
<p>You must use precompiler option SQLCHECK=SEMANTICS with an embedded PL/SQL block.</p>
<p>In the following example, three of the formal parameters are PL/SQL tables, and the corresponding actual parameters are host arrays. The program calls the stored procedure <span class="italic">get_employees</span> repeatedly, displaying each batch of employee data, until no more data is found. This program is available on-line in the <code>demo</code> directory, in the file <code>sample9.pc</code>. A SQL script to create the CALLDEMO stored package is available in the file <code>calldemo.sql</code>.<a id="sthref1040"></a><a id="sthref1041"></a><a id="sthref1042"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i2324">"Creating Stored Subprograms"</a></div>
<pre>
/*************************************************************
Sample Program 9:  Calling a stored procedure

This program connects to ORACLE using the SCOTT/TIGER
account.  The program declares several host arrays, then
calls a PL/SQL stored procedure (GET_EMPLOYEES in the
CALLDEMO package) that fills the table OUT parameters.  The
PL/SQL procedure returns up to ASIZE values.

Sample9 keeps calling GET_EMPLOYEES, getting ASIZE arrays
each time, and printing the values, until all rows have been
retrieved.  GET_EMPLOYEES sets the done_flag to indicate "no
more data."
*************************************************************/
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

EXEC SQL INCLUDE sqlca.h;


typedef char asciz[20];
typedef char vc2_arr[11];

EXEC SQL BEGIN DECLARE SECTION;
/* User-defined type for null-terminated strings */
EXEC SQL TYPE asciz  IS STRING(20) REFERENCE;

/* User-defined type for a VARCHAR array element. */
EXEC SQL TYPE vc2_arr IS VARCHAR2(11) REFERENCE;

asciz     username;
asciz     password;
int       dept_no;              /* which department to query? */
vc2_arr   emp_name[10];            /* array of returned names */
vc2_arr   job[10];
float     salary[10];
int       done_flag;
int       array_size;
int       num_ret;                 /* number of rows returned */
EXEC SQL END DECLARE SECTION;

long      SQLCODE;



void print_rows();            /* produces program output      */
void sql_error();             /* handles unrecoverable errors */



main()
{
   int   i;
   char  temp_buf[32];

/* Connect to ORACLE. */
   EXEC SQL WHENEVER SQLERROR DO sql_error();
   strcpy(username, "scott");
   strcpy(password, "tiger");
   EXEC SQL CONNECT :username IDENTIFIED BY :password;
   printf("\nConnected to ORACLE as user: %s\n\n", username);
   printf("Enter department number: ");
   gets(temp_buf);
   dept_no = atoi(temp_buf);/* Print column headers. */
   printf("\n\n");
   printf("%-10.10s%-10.10s%s\n", "Employee", "Job", "Salary");
   printf("%-10.10s%-10.10s%s\n", "--------", "---", "------");

/* Set the array size. */
   array_size = 10;

   done_flag = 0;
   num_ret = 0;

/*  Array fetch loop.
 *  The loop continues until the OUT parameter done_flag is set.
 *  Pass in the department number, and the array size--
 *  get names, jobs, and salaries back.
 */
   for (;;)
   {
      EXEC SQL EXECUTE 
         BEGIN calldemo.get_employees
            (:dept_no, :array_size, :num_ret, :done_flag,
             :emp_name, :job, :salary);
         END;
      END-EXEC;

      print_rows(num_ret);

      if (done_flag)
         break;
   }

/* Disconnect from the database. */
   EXEC SQL COMMIT WORK RELEASE;
   exit(0);
}
void
print_rows(n)
int n;
{
   int i;

    if (n == 0)
    {
        printf("No rows retrieved.\n");
        return;
    }

    for (i = 0; i &lt; n; i++)
        printf("%10.10s%10.10s%6.2f\n",
               emp_name[i], job[i], salary[i]);
}

/* Handle errors. Exit on any error. */
void
sql_error()
{
   char msg[512];
   int buf_len, msg_len;


   EXEC SQL WHENEVER SQLERROR CONTINUE;

   buf_len = sizeof(msg);
   sqlglm(msg, &amp;buf_len, &amp;msg_len);

   printf("\nORACLE error detected:");
   printf("\n%.*s \n", msg_len, msg);

   EXEC SQL ROLLBACK WORK RELEASE;
   exit(1);
}
</pre>
<p>Remember, the datatype of each actual parameter must be convertible to the datatype of its corresponding formal parameter. Also, before a stored procedure is exited, all OUT formal parameters must be assigned values. Otherwise, the values of corresponding actual parameters are indeterminate.</p>
<p>SQLCHECK=SEMANTICS is required when using an anonymous PL/SQL block.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1043"></a>
<h4 class="sect3">Remote Access</h4>
<p>PL/SQL lets you access remote databases using <span class="italic">database links</span>. Typically, database links are established by your DBA and stored in the Oracle data dictionary. A database link tells Oracle where the remote database is located, the path to it, and what Oracle username and password to use. In the following example, you use the database link <span class="italic">dallas</span> to call the <span class="italic">raise_salary</span> procedure:</p>
<pre>
EXEC SQL EXECUTE 
BEGIN 
    raise_salary@dallas(:emp_id, :increase); 
END; 
END-EXEC; 
</pre>
<p>You can create synonyms to provide location transparency for remote subprograms, as the following example shows:</p>
<pre>
CREATE PUBLIC SYNONYM raise_salary 
FOR raise_salary@dallas; 
</pre></div>
<!-- class="sect3" -->
<a id="i17977"></a>
<div class="sect3">
<h4 class="sect3"><a id="sthref1044"></a><a id="sthref1045"></a>The CALL Statement</h4>
<p>The concepts presented earlier for the embedded PL/SQL block also hold true for the CALL statement. The CALL embedded SQL statement has the form:</p>
<pre>
EXEC SQL 
   CALL [schema.] [package.]stored_proc[@db_link](arg1, ...) 
   [INTO :ret_var [[INDICATOR]:ret_ind]] ;
</pre>
<p>where</p>
<p>schema</p>
<p>the schema containing the procedure</p>
<p>package</p>
<p>the package containing the procedure</p>
<p>stored_proc</p>
<p>is the Java or PL/SQL stored procedure to be called</p>
<p>db_link</p>
<p>is the optional remote database link</p>
<p>arg1...</p>
<p>is the list of arguments (variables, literals, or expressions) passed,</p>
<p>ret_var</p>
<p>is the optional host variable which receives the result</p>
<p>ind_var</p>
<p>the optional indicator variable for ret_var.</p>
<p>You can use either SQLCHECK=SYNTAX, or SEMANTICS with the CALL statement.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1046"></a>
<h4 class="sect3">CALL Example<a id="sthref1047"></a></h4>
<p>If you have created a PL/SQL function <code>fact</code> (stored in the package <code>mathpkg</code>) that takes an integer as input and returns its factorial in an integer:</p>
<pre>
     EXEC SQL CREATE OR REPLACE PACKAGE BODY mathpkg as 
       function fact(n IN INTEGER) RETURN INTEGER AS
         BEGIN
           IF (n &lt;= 0) then return 1;
           ELSE return n * fact(n - 1);
           END IF;
         END fact;
       END mathpkge;
     END-EXEC.
</pre>
<p>then to use <code>fact</code> in a Pro*C/C++ application using the CALL statement:</p>
<pre>
 ...
int num, fact;
...
EXEC SQL CALL mathpkge.fact(:num) INTO :fact ;
...
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_afemb.htm#CHEGGGJH">"CALL (Executable Embedded SQL)"</a> for more information about the CALL statement.</p>
</li>
<li>
<p><a class="olink ADFNS" href="../e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>, for a complete explanation of passing arguments and other issues.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1048"></a>
<h3 class="sect2">Getting Information about Stored Subprograms</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Logon Data Area (LDA) is <span class="italic">no longer supported</span> in Oracle. The ability to embed OCI Release 7 calls in your Pro*C/C++ program will be phased out by the next major Oracle release.</div>
<p><a href="pc_04dat.htm#g52211">Chapter 4, "Datatypes and Host Variables"</a> described how to embed OCI calls in your host program. After calling the library routine SQLLDA to set up the LDA, use the OCI call <span class="italic">odessp</span> to get useful information about a stored subprogram. When you call <span class="italic">odessp</span>, you must pass it a valid LDA and the name of the subprogram. For packaged subprograms, you must also pass the name of the package. <span class="italic">odessp</span> returns information about each subprogram parameter such as its datatype, size, position, and so on. For details, see <a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a>.</p>
<p>You can also use the DESCRIBE_PROCEDURE stored procedure, in the DBMS_DESCRIBE package. See <span class="italic"><a class="olink ADFNS" href="../e41502/toc.htm">Oracle Database Advanced Application Developer's Guide</a> f</span>or more information about this procedure.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i8054"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref1049"></a><a id="sthref1050"></a>External Procedures</h2>
<p>PL/SQL can call C functions which are external procedures. External procedures (also known as external procedures) are stored in dynamic link libraries (DLL) or, for example, in <span class="italic">.so</span> libraries under Solaris.</p>
<p>If the external procedure executes on the server-side, it can call back into the server to execute SQL and PL/SQL in the same transaction. External procedures on the server execute faster than on the client and can interface the database server with external systems and data sources.</p>
<p>In order to execute a server-side external C function, the REGISTER CONNECT embedded SQL statement must be used inside that function. The syntax of the statement is:</p>
<pre>
EXEC SQL REGISTER CONNECT USING :epctx [RETURNING :host_context] ;
</pre>
<p>where <code>epctx</code> is the external procedure context (of type pointer to <code>OCIExtProcContext</code>). <code>epctx</code> is passed to the procedure by PL/SQL.</p>
<p><code>host_context</code> is a runtime context returned by the external procedure. Currently, it is the default (global) context.</p>
<p>The REGISTER CONNECT statement will return the set of OCI handles (OCIEnv, OCISvcCtx, and OCIError) that are associated with the current Oracle connection and transaction. These handles are then used to define the Pro*C/C++ default unnamed connection for the global SQLLIB runtime context. The REGISTER CONNECT statement is therefore used <span class="italic">instead</span> of a CONNECT statement.</p>
<p>Subsequent embedded SQL statements will use this set of OCI handles. They execute against the global SQLLIB runtime context and the unnamed connection, even those that are in separately precompiled units. Uncommitted changes are not seen. In the future, a (nondefault) runtime context can be returned in the optional RETURNING clause.</p>
<p>There cannot already be any active default connection for the global runtime context. A runtime error is returned if you try to use REGISTER CONNECT when a connection already exists.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information about OCI functions.</div>
<p>In real-world cases, the external procedure should be one that you can reuse from many different applications.</p>
<a id="i9161"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref1051"></a>Restrictions on External Procedures</h3>
<p>Follow these rules for external procedures:</p>
<ul>
<li>
<p>External procedures can only be in C. C++ external procedures are not supported.</p>
</li>
<li>
<p>When you are connected to the external procedure context, any additional connection is not permitted and results in a runtime error.</p>
</li>
<li>
<p>Multithreaded external procedures are not supported. Executing an EXEC SQL ENABLE THREADS statement is not permitted and will return a runtime error. Pro*C/C++ does support multithreading in an application not using the external procedure method we are describing.</p>
</li>
<li>
<p>You cannot use DDL statements. They result in runtime errors.</p>
</li>
<li>
<p>You cannot use transaction control statements, such as EXEC SQL COMMIT, and EXEC SQL ROLLBACK.</p>
</li>
<li>
<p>You cannot use object navigation statements such as EXEC SQL OBJECT ... .</p>
</li>
<li>
<p>You cannot use polling EXEC SQL LOB statements.</p>
</li>
<li>
<p>You cannot use EXEC TOOLS statements. They will result in runtime errors.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i8052"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref1052"></a>Creating the External Procedure</h3>
<p>Here is a simple example to create the external procedure <code>extp1</code>.</p>
<p>To store an external C procedure, compile and link the code to a library such as a DLL.</p>
<p>Then use the following SQL command once to register the external procedure <code>extp1</code>:</p>
<pre>
CREATE OR REPLACE PROCEDURE extp1
AS EXTERNAL NAME "extp1"
LIBRARY mylib
WITH CONTEXT
PARAMETERS(CONTEXT) ;
</pre>
<p>Where <span class="italic">mylib</span> is the name of the library storing procedure <span class="italic">extp1</span>. WITH CONTEXT means to implicitly call this procedure with argument of type <code>OCIExtProcContext*</code>. The context is omitted in your call, but is passed to the procedure anyway. The keyword CONTEXT appears in the CREATE statement, however, as a place marker.</p>
<p>This context parameter is the one referenced in the EXEC SQL REGISTER CONNECT statement inside <code>extp1</code>.</p>
<p>For more background on calling external procedures, see <span class="italic"><a class="olink LNPLS" href="../e25519/toc.htm">Oracle Database PL/SQL Language Reference</a></span></p>
<p>The external procedure is called from SQL*Plus this way:</p>
<pre>
SQL&gt;
BEGIN
  INSERT INTO emp VALUES(9999,'JOHNSON','SALESMAN',7782, sysdate, 1200,150,10);
  extp1;
END;
</pre>
<p><a id="sthref1053"></a>Here is the listing of <code>extp1.pc</code>:</p>
<pre>
void extp1 (epctx)
OCIExtProcContext *epctx;
{
char name[15];
        EXEC SQL REGISTER CONNECT USING :epctx;
        EXEC SQL WHENEVER SQLERROR goto err;
        EXEC SQL SELECT ename INTO :name FROM emp WHERE empno = 9999;
        return;
err: SQLExtProcError(SQL_SINGLE_RCTX,sqlca.sqlerrm.sqlerrmc,sqlca.sqlerrm.sqlerrml);
        return;
}
</pre></div>
<!-- class="sect2" -->
<a id="i9112"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref1054"></a><a id="sthref1055"></a><a id="sthref1056"></a>SQLExtProcError()</h3>
<p>The SQLLIB function <code>SQLExtProcError()</code> provides the ability to return control to PL/SQL when an error occurs in an external C procedure. The function and its arguments are:</p>
<p>SQLExtProcError (ctx, msg, msglen)</p>
<p>where:</p>
<p>ctx (IN) sql_context *</p>
<p>This is the target SQLLIB runtime context of the REGISTER CONNECT statement, which has to be executed before this function is invoked. Only the global runtime context is supported now.</p>
<p>msg (OUT) char *</p>
<p>The text of the error message.</p>
<p>msglen (OUT) size_t</p>
<p>The length in bytes of the message.</p>
<p>SQLLIB calls the OCI service function OCIExtProcRaiseExcpWithMsg when this function is executed.</p>
<p>The message is from the structure <code>sqlerrm</code> in the SQLCA. For a discussion of the structure of the SQLCA and <code>sqlerrm</code>, see <a href="pc_09err.htm#i12497">"SQLCA Structure"</a>.</p>
<p>Here is an example showing use of <code>SQLExtProcError()</code>:</p>
<pre>
void extp1 (epctx)
OCIExtProcContext *epctx;
{
   char name[15];
   EXEC SQL REGISTER CONNECT USING :epctx;
   EXEC SQL WHENEVER SQLERROR goto err;
   EXEC SQL SELECT ename INTO :name FROM emp WHERE smpno = 9999;
   return;
 err:
   SQLExtProcError (SQL_SINGLE_RCTX, sqlca.sqlerrm.sqlerrmc,
      sqlca.sqlerrm.sqlerrml);
   printf("\n%*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
   return;
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i6535"></a>
<div class="sect1">
<h2 class="sect1">Using Dynamic SQL</h2>
<p>Recall that the precompiler treats an entire PL/SQL block like a single SQL statement. Therefore, you can store a PL/SQL block in a string host variable. Then, if the block contains no host variables, you can use dynamic SQL Method 1 to EXECUTE the PL/SQL string. Or, if the block contains a known number of host variables, you can use dynamic SQL Method 2 to PREPARE and EXECUTE the PL/SQL string. If the block contains an unknown number of host variables, you must use dynamic SQL Method 4.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_13dyn.htm#g19220">Chapter 13, "Oracle Dynamic SQL"</a></p>
</li>
<li>
<p><a href="pc_14ady.htm#i1011699">Chapter 14, " ANSI Dynamic SQL"</a></p>
</li>
<li>
<p><a href="pc_15ody.htm#i22863">Chapter 15, "Oracle Dynamic SQL: Method 4"</a><a id="sthref1057"></a></p>
</li>
</ul>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
In dynamic SQL Method 4, you cannot bind a host array to a PL/SQL procedure with a parameter of type "table." See also <a href="pc_13dyn.htm#i2160">"Using Method 4"</a>.</div>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment823">
<tr>
<td class="cellalignment832">
<table class="cellalignment828">
<tr>
<td class="cellalignment827"><a href="pc_06sql.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment827"><a href="pc_08arr.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment835">
<table class="cellalignment826">
<tr>
<td class="cellalignment827"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment827"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment827"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment827"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment827"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment827"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
