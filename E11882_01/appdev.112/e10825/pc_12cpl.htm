<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>C++ Applications</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2009-08-01T13:30:10Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Pro*C/C++ Programmer's Guide" />
<meta name="dcterms.identifier" content="E10825-01" />
<meta name="dcterms.isVersionOf" content="LNPCC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="partpage2.htm" title="Previous" type="text/html" />
<link rel="Next" href="pc_13dyn.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10825.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">18/36</span> <!-- End Header --><a id="g12549"></a><a id="i9041"></a>
<h1 class="chapter"><span class="secnum">12</span> <a id="LNPCC012"></a>C++ Applications</h1>
<p>This chapter describes how you can use the Pro*C/C++ Precompiler to precompile your C++ embedded SQL application, and how Pro*C/C++ generates C++ compatible code. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i971">Understanding C++ Support</a></p>
</li>
<li>
<p><a href="#i917">Precompiling for C++</a></p>
</li>
<li>
<p><a href="#i980">Example Programs</a> <a id="sthref1879"></a></p>
</li>
</ul>
<a id="i971"></a>
<div class="sect1">
<h2 class="sect1">Understanding C++ Support</h2>
<p>To understand how Pro*C/C++ supports C++, you must understand the basic functional capabilities of Pro*C/C++. In particular, you must be aware of how Pro*C/C++ differs from Pro*C Version 1.</p>
<p>The basic capabilities of Pro*C/C++ are:</p>
<ul>
<li>
<p>Full C preprocessor support. You can use <code>#define</code>, <code>#include</code>, <code>#ifdef</code>, and other preprocessor directives in your Pro*C/C++ program, to handle constructs that the precompiler itself must process.</p>
</li>
<li>
<p>Use of native C structures as host variables, including the ability to pass structs (or pointers to structs) as host variables to functions, and write functions that return host structures or struct pointers.</p>
</li>
</ul>
<p>To support its C preprocessor capabilities and to enable host variables to be declared outside a special Declare Section, Pro*C/C++ incorporates a complete C parser. The Pro*C/C++ parser is a C parser; it cannot parse C++ code.</p>
<p>This means that for C++ support, you must be able to disable the C parser, or at least partially disable it. To disable the C parser, the Pro*C/C++ Precompiler includes command-line options to give you control over the extent of C parsing that Pro*C/C++ performs on your source code.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="pc_04dat.htm#i15971">"Oracle Datatypes"</a></p>
</li>
<li>
<p><a href="pc_04dat.htm#i13390">"Structure Pointers"</a></p>
</li>
<li>
<p><a href="#i917">"Precompiling for C++"</a></p>
</li>
</ul>
</div>
<div class="sect2"><a id="sthref1880"></a>
<h3 class="sect2">No Special Macro Processing</h3>
<p>Using C++ with Pro*C/C++ does not require any special preprocessing or special macro processors that are external to Pro*C/C++. There is no need to run a macro processor on the output of the precompiler to achieve C++ compatibility.</p>
<p>If you are a user of a release of Pro*C/C++ Precompiler before this one, and you did use macro processors on the precompiler output, you should be able to precompile your C++ applications using Pro*C/C++ with no changes to your code.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i917"></a>
<div class="sect1">
<h2 class="sect1">Precompiling for C++</h2>
<p>To control precompilation so that it accommodates C++, there are four considerations:</p>
<ul>
<li>
<p>Code emission by the precompiler</p>
</li>
<li>
<p>Parsing capability</p>
</li>
<li>
<p>The output filename extension</p>
</li>
<li>
<p>The location of system header files</p>
</li>
</ul>
<a id="i3860"></a>
<div class="sect2">
<h3 class="sect2">Code Generation</h3>
<p>You must be able to specify what kind of code, C compatible code or C++ compatible code, the precompiler generates. Pro*C/C++ by default generates C code. C++ is not a perfect superset of C. Some changes are required in generated code so that it can be compiled by a C++ compiler.</p>
<p>For example, in addition to emitting your application code, the precompiler interposes calls to its runtime library, SQLLIB. The functions in SQLLIB are C functions. There is no special C++ version of SQLLIB. For this reason, if you want to compile the generated code using a C++ compiler, Pro*C/C++ must declare the functions called in SQLLIB as C functions.</p>
<p>For C output, the precompiler would generate a prototype such as</p>
<pre>
void sqlora(unsigned long *, void *);
</pre>
<p>But for C++ compatible code, the precompiler must generate</p>
<pre>
extern "C" {
void sqlora(unsigned long *, void *);
};
</pre>
<p>You control the kind of code Pro*C/C++ generates using the precompiler option CODE. There are three values for this option: CPP, KR_C, and ANSI_C. The differences between these options can be illustrated by considering how the declaration of the SQLLIB function <span class="italic">sqlora</span> differs among the three values for the CODE option:</p>
<pre>
void sqlora( /*_ unsigned long *, void * _*/);  /* K&amp;R C */

void sqlora(unsigned long *, void *);           /* ANSI C */

extern "C" {                                    /* CPP */
void sqlora(unsigned long *, void *);
};
</pre>
<p>When you specify CODE=CPP, the precompiler <a id="sthref1881"></a></p>
<ul>
<li>
<p>Generates C++ compilable code.</p>
</li>
<li>
<p>Gives the output file a platform-specific file extension (suffix), such as ".C" or ".cc", rather than the standard ".c" extension. (You can override this by using the CPP_SUFFIX option.)</p>
</li>
<li>
<p>Causes the value of the PARSE option to default to PARTIAL. You can also specify PARSE=NONE. If you specify PARSE=FULL, an error is issued at precompile time.</p>
</li>
<li>
<p>Allows the use of the C++ style // Comments in your code. This style of Commenting is also permitted inside SQL statements and PL/SQL blocks when CODE=CPP.</p>
</li>
<li>
<p>Pro*C/C++ recognizes SQL optimizer hints that begin with //+. <a id="sthref1882"></a></p>
</li>
<li>
<p>Requires that header files generated by OTT (Object Type Translator) must be included inside a declare section.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="pc_10opt.htm#i10030">"CODE"</a> for information about the KR_C and ANSI_C values for the CODE option.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i864"></a>
<div class="sect2">
<h3 class="sect2">Parsing Code</h3>
<p>You must be able to control the effect of the Pro*C/C++ C parser on your code. You do this by using the PARSE precompiler option, which controls how the precompiler's C parser treats your code.</p>
<p>The values and effects of the PARSE option are:</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref1883"></a><a id="sthref1884"></a>Table 12-1 Values and Effects of the PARSE Option</p>
<table class="cellalignment830" title="Values and Effects of the PARSE Option" summary="Values and Effects of the PARSE Option" dir="ltr">
<thead>
<tr class="cellalignment824">
<th class="cellalignment831" id="r1c1-t4">Values</th>
<th class="cellalignment831" id="r1c2-t4">Effects</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment824">
<td class="cellalignment832" id="r2c1-t4" headers="r1c1-t4">
<p>PARSE=NONE</p>
</td>
<td class="cellalignment832" headers="r2c1-t4 r1c2-t4">
<p>The value NONE has the following effects:</p>
<ul>
<li>
<p>C preprocessor directives are understood only inside a declare section.</p>
</li>
<li>
<p>You must declare all host variables inside a Declare Section.</p>
</li>
<li>
<p>Precompiler release 1.x behavior</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r3c1-t4" headers="r1c1-t4">
<p>PARSE=PARTIAL</p>
</td>
<td class="cellalignment832" headers="r3c1-t4 r1c2-t4">
<p>The value PARTIAL has the following effects:</p>
<ul>
<li>
<p>All preprocessor directives are understood</p>
</li>
<li>
<p>You must declare all host variables inside a Declare Section</p>
</li>
</ul>
<p>This option value is the default if CODE=CPP</p>
</td>
</tr>
<tr class="cellalignment824">
<td class="cellalignment832" id="r4c1-t4" headers="r1c1-t4">
<p>PARSE=FULL</p>
</td>
<td class="cellalignment832" headers="r4c1-t4 r1c2-t4">
<p>The value FULL has the following effects:</p>
<ul>
<li>
<p>The precompiler C parser runs on your code.</p>
</li>
<li>
<p>All Preprocessor directives are understood.</p>
</li>
<li>
<p>You can declare host variables at any place that they can be declared legally in C.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>This option value is the default if the value of the CODE option is anything other than CPP. It is an error to specify PARSE=FULL when CODE=CPP.</p>
<p>To generate C++ compatible code, the PARSE option must be either NONE or PARTIAL. If PARSE=FULL, the C parser runs, and it does not understand C++ constructs in your code, such as classes.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1885"></a>
<h3 class="sect2">Output Filename Extension</h3>
<p>Most C compilers expect a default extension of ".c" for their input files. Different C++ compilers, however, can expect different filename extensions. The CPP_SUFFIX option provides the ability to specify the filename extension that the precompiler generates. The value of this option is a string, without the quotes or the period. For example, CPP_SUFFIX=cc, or CPP_SUFFIX=C. <a id="sthref1886"></a></p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1887"></a>
<h3 class="sect2">System Header Files</h3>
<p><a id="sthref1888"></a>Pro*C/C++ searches for standard system header files, such as <code>stdio.h</code>, in standard locations that are platform specific. Pro*C/C++ does not search for header files with extensions such as <code>hpp</code> or <code>h</code>++. For example, on almost all UNIX systems, the file <code>stdio.h</code> has the full path name <code>/usr/include/stdio.h</code>.</p>
<p>But a C++ compiler has its own version of <code>stdio.h</code> that is not in the standard system location. When you are precompiling for C++, you must use the SYS_INCLUDE precompiler option to specify the directory paths that Pro*C/C++ searches to look for system header files. For example:<a id="sthref1889"></a></p>
<pre>
SYS_INCLUDE=(/usr/lang/SC2.0.1/include,/usr/lang/SC2.1.1/include)
</pre>
<p>Use the INCLUDE precompiler option to specify the location of non-system header files. The directories specified by the SYS_INCLUDE option are searched before directories specified by the INCLUDE option. See also: <a href="pc_10opt.htm#i4754">"INCLUDE"</a>.</p>
<p>If PARSE=NONE, the values specified in SYS_INCLUDE and INCLUDE for system files are not relevant, since there is no need for Pro*C/C++ to include system header files. (You can, of course, still include Pro*C/C++-specific headers, such <code>sqlca.h</code>, using the EXEC SQL INCLUDE statement.)</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i980"></a>
<div class="sect1">
<h2 class="sect1">Example Programs</h2>
<p>This section includes three example Pro*C/C++ programs that include C++ constructs. Each of these programs is available on-line, in your <code>demo</code> directory.</p>
<div class="sect2"><a id="sthref1890"></a>
<h3 class="sect2">cppdemo1.pc<a id="sthref1891"></a></h3>
<pre>
/*  cppdemo1.pc
 *
 *  Prompts the user for an employee number, then queries the 
 *  emp table for the employee's name, salary and commission.
 *  Uses indicator variables (in an indicator struct) to 
 *  determine if the commission is NULL.
 */

#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// Parse=partial by default when code=cpp,
// so preprocessor directives are recognized and parsed fully.
#define     UNAME_LEN      20
#define     PWD_LEN        40

// Declare section is required when CODE=CPP or
// PARSE={PARTIAL|NONE} or both.
EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR username[UNAME_LEN];  // VARCHAR is an ORACLE pseudotype
  varchar password[PWD_LEN];    // can be in lower case also

  // Define a host structure for the output values
  // of a SELECT statement
  struct empdat {
      VARCHAR   emp_name[UNAME_LEN];
      float     salary;
      float     commission;
  } emprec;

  // Define an indicator struct to correspond to the
  // host output struct
  struct empind {
      short     emp_name_ind;
      short     sal_ind;
      short     comm_ind;
  } emprec_ind;


  // Input host variables
  int   emp_number;
  int   total_queried;
EXEC SQL END DECLARE SECTION;

// Define a C++ class object to match the desired
// struct from the preceding declare section.
class emp {
  char  ename[UNAME_LEN];
  float salary;
  float commission;
public:
  // Define a constructor for this C++ object that
  // takes ordinary C objects.
  emp(empdat&amp;, empind&amp;);
  friend ostream&amp; operator&lt;&lt;(ostream&amp;, emp&amp;);
};

emp::emp(empdat&amp; dat, empind&amp; ind)
{
  strncpy(ename, (char *)dat.emp_name.arr, dat.emp_name.len);
  ename[dat.emp_name.len] = '\0';
  this-&gt;salary = dat.salary;
  this-&gt;commission = (ind.comm_ind &lt; 0) ? 0 : dat.commission;
}

ostream&amp; operator&lt;&lt;(ostream&amp; s, emp&amp; e)
{
  return s &lt;&lt; e.ename &lt;&lt; " earns " &lt;&lt; e.salary &lt;&lt; 
              " plus " &lt;&lt; e.commission &lt;&lt; " commission." 
           &lt;&lt; endl &lt;&lt; endl;
}

// Include the SQL Communications Area
// You can use #include or EXEC SQL INCLUDE
#include &lt;sqlca.h&gt;

// Declare error handling function
void sql_error(char *msg);

main()
{
  char temp_char[32];

  // Register sql_error() as the error handler
  EXEC SQL WHENEVER SQLERROR DO sql_error("ORACLE error:");

  // Connect to ORACLE.  Program calls sql_error()
  // if an error occurs
  // when connecting to the default database.
  // Note the (char *) cast when
  // copying into the VARCHAR array buffer.
  username.len = strlen(strcpy((char *)username.arr, "SCOTT"));
  password.len = strlen(strcpy((char *)password.arr, "TIGER"));
  
  EXEC SQL CONNECT :username IDENTIFIED BY :password;

  // Here again, note the (char *) cast when using VARCHARs
  cout &lt;&lt; "\nConnected to ORACLE as user: "
       &lt;&lt; (char *)username.arr &lt;&lt; endl &lt;&lt; endl;

  // Loop, selecting individual employee's results
  total_queried = 0;
  while (1)
  {
      emp_number = 0;
      printf("Enter employee number (0 to quit): ");
      gets(temp_char);
      emp_number = atoi(temp_char);
      if (emp_number == 0)
        break;

      // Branch to the notfound label when the 
      // 1403 ("No data found") condition occurs
      EXEC SQL WHENEVER NOT FOUND GOTO notfound;

      EXEC SQL SELECT ename, sal, comm
         INTO :emprec INDICATOR :emprec_ind // You can also use 
                                            // C++ style
         FROM EMP                  // Comments in SQL statemtents.
         WHERE EMPNO = :emp_number;

      {
        // Basic idea is to pass C objects to
        // C++ constructors thus
        // creating equivalent C++ objects used in the
        // usual C++ way
        emp e(emprec, emprec_ind);
        cout &lt;&lt; e;
      }

      total_queried++;
      continue;
notfound:
      cout &lt;&lt; "Not a valid employee number - try again." 
           &lt;&lt; endl &lt;&lt; endl;
  } // end while(1)

  cout &lt;&lt; endl &lt;&lt; "Total rows returned was " 
       &lt;&lt; total_queried &lt;&lt; endl;
  cout &lt;&lt; "Have a nice day!" &lt;&lt; endl &lt;&lt; endl;

  // Disconnect from ORACLE
  EXEC SQL COMMIT WORK RELEASE;
  exit(0);
}


void sql_error(char *msg)
{
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    cout &lt;&lt; endl &lt;&lt; msg &lt;&lt; endl;
    cout &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;
    EXEC SQL ROLLBACK RELEASE;
    exit(1);
}
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1892"></a>
<h3 class="sect2">cppdemo2.pc</h3>
<p>The next application is a simple modular example. First, execute the following SQL script, <code>cppdemo2.sql</code>, in SQL*Plus:</p>
<pre>
<a id="sthref1893"></a>Rem  This is the SQL script that accompanies the cppdemo2 C++ Demo
Rem  Program.  Run this prior to Precompiling the empclass.pc file.
/
CONNECT SCOTT/TIGER
/
CREATE OR REPLACE VIEW emp_view AS SELECT ename, empno FROM EMP
/
CREATE OR REPLACE PACKAGE emp_package AS
  TYPE emp_cursor_type IS REF CURSOR RETURN emp_view%ROWTYPE;
  PROCEDURE open_cursor(curs IN OUT emp_cursor_type);
END emp_package;
/
CREATE OR REPLACE PACKAGE BODY emp_package AS
  PROCEDURE open_cursor(curs IN OUT emp_cursor_type) IS
  BEGIN
    OPEN curs FOR SELECT ename, empno FROM emp_view ORDER BY ename ASC;
  END;
END emp_package;
/
EXIT
/
</pre>
<p>The header file <code>empclass.h</code> defines the class <code>emp</code>:</p>
<pre>
// This class definition may be included in a Pro*C/C++ application
// program using the EXEC SQL INCLUDE directive only.  Because it
// contains EXEC SQL syntax, it may not be included using a #include
// directive.  Any program that includes this header must be
// precompiled with the CODE=CPP option.  This emp class definition
// is used when building the cppdemo2 C++ Demo Program.

class emp
{
  public:
    emp();   // Constructor: ALLOCATE Cursor Variable
    ~emp();  // Desctructor: FREE Cursor Variable

    void open();              // Open Cursor
    void fetch() throw (int); // Fetch (throw NOT FOUND condition)
    void close();             // Close Cursor

    void emp_error();         // Error Handler

    EXEC SQL BEGIN DECLARE SECTION;
      // When included using EXEC SQL INCLUDE, class variables have 
      // global scope and are thus basically treated as ordinary
      // global variables by Pro*C/C++ during precompilation.
      char ename[10];
      int empno;
    EXEC SQL END DECLARE SECTION;

  private:
    EXEC SQL BEGIN DECLARE SECTION;
      // Pro*C/C++ treats this as a simple global variable also.
      SQL_CURSOR emp_cursor;
    EXEC SQL END DECLARE SECTION;
};
</pre>
<p>The code in <code>empclass.pc</code> contains the <code>emp</code> methods:</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// This example uses a single (global) SQLCA that is shared by the
// emp class implementation as well as the main program for this
// application.
#define SQLCA_STORAGE_CLASS extern
#include &lt;sqlca.h&gt;

// Include the emp class specification in the implementation of the
// class body as well as the application program that makes use of it.
EXEC SQL INCLUDE empclass.h;

emp::emp()
{
  // The scope of this WHENEVER statement spans the entire module.
  // Note that the error handler function is really a member function
  // of the emp class.
  EXEC SQL WHENEVER SQLERROR DO emp_error();
  EXEC SQL ALLOCATE :emp_cursor;  // Constructor - ALLOCATE Cursor.
}

emp::~emp()
{
  EXEC SQL FREE :emp_cursor;      // Destructor - FREE Cursor.
}

void emp::open()
{
  EXEC SQL EXECUTE
    BEGIN
      emp_package.open_cursor(:emp_cursor);
    END;
  END-EXEC;
}

void emp::close()
{
  EXEC SQL CLOSE :emp_cursor;
}

void emp::fetch() throw (int)
{
  EXEC SQL FETCH :emp_cursor INTO :ename, :empno;
  if (sqlca.sqlcode == 1403)
    throw sqlca.sqlcode;     // Like a WHENEVER NOT FOUND statement.
}

void emp::emp_error()
{
  printf("%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);
}
</pre>
<p>The main program, <code>cppdemo2.pc</code>, uses the cursor variable:</p>
<pre>
// Pro*C/C++ sample program demonstrating a simple use of Cursor Variables
// implemented within a C++ class framework.  Build this program as follows
//
//   1. Execute the cppdemo2.sql script within SQL*Plus
//   2. Precompile the empclass.pc program as follows
//      &gt; proc code=cpp sqlcheck=full user=scott/tiger lines=yes empclass
//   3. Precompile the cppdemo2.pc program as follows
//      &gt; proc code=cpp lines=yes cppdemo2
//   4. Compile and Link
//
// Note that you may have to specify various include directories using the
// include option when precompiling.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sqlca.h&gt;

static void sql_error()
{
  printf("%.*s\n", sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK RELEASE;
  exit(1);  
}

// Physically include the emp class definition in this module.
EXEC SQL INCLUDE empclass.h;

int main()
{
  EXEC SQL BEGIN DECLARE SECTION;
    char *uid = "scott/tiger";
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR DO sql_error();
  EXEC SQL CONNECT :uid;

  emp *e = new emp(); // Invoke Constructor - ALLOCATE Cursor Variable.

  e-&gt;open();          // Open the Cursor.

  while (1)
    {
      // Fetch from the Cursor, catching the NOT FOUND condition
      // thrown by the fetch() member function.
      try { e-&gt;fetch(); } catch (int code)  
        { if (code == 1403) break; }
      printf("Employee:  %s[%d]\n", e-&gt;ename, e-&gt;empno);
    }

  e-&gt;close();         // Close the Cursor.

  delete e;           // Invoke Destructor - FREE Cursor Variable.

  EXEC SQL ROLLBACK WORK RELEASE;
  return (0);
}
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref1894"></a>
<h3 class="sect2">cppdemo3.pc <a id="sthref1895"></a></h3>
<pre>
/*
 * cppdemo3.pc : An example of C++ Inheritance
 *
 * This program finds all salesman and prints their names
 * followed by how much they earn in total (ie; including 
 * any commissions).
 */
 
#include &lt;iostream.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sqlca.h&gt;
#include &lt;string.h&gt;

#define NAMELEN 10

class employee {    // Base class is a simple employee
public:
  char ename[NAMELEN];
  int sal;
  employee(char *, int);
};

employee::employee(char *ename, int sal)
{
  strcpy(this-&gt;ename, ename);
  this-&gt;sal = sal;
}

// A salesman is a kind of employee
class salesman : public employee
{
  int comm;
public:
  salesman(char *, int, int);
  friend ostream&amp; operator&lt;&lt;(ostream&amp;, salesman&amp;);
};

// Inherits employee attributes
salesman::salesman(char *ename, int sal, int comm)
  : employee(ename, sal), comm(comm) {}  

ostream&amp; operator&lt;&lt;(ostream&amp; s, salesman&amp; m)
{
  return s &lt;&lt; m.ename &lt;&lt; m.sal + m.comm &lt;&lt; endl;  
}

void print(char *ename, int sal, int comm)
{
  salesman man(ename, sal, comm);
  cout &lt;&lt; man;
}

main()
{
  EXEC SQL BEGIN DECLARE SECTION;
    char *uid = "scott/tiger";
    char  ename[NAMELEN];
    int   sal, comm;
    short comm_ind;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL WHENEVER SQLERROR GOTO error;

  EXEC SQL CONNECT :uid;
  EXEC SQL DECLARE c CURSOR FOR
    SELECT ename, sal, comm FROM emp WHERE job = 'SALESMAN'
      ORDER BY ename;
  EXEC SQL OPEN c;

  cout &lt;&lt; "Name    Salary" &lt;&lt; endl &lt;&lt; "------  ------" &lt;&lt; endl;

  EXEC SQL WHENEVER NOT FOUND DO break;
  while(1)
   {
     EXEC SQL FETCH c INTO :ename, :sal, :comm:comm_ind;
     print(ename, sal, (comm_ind &lt; 0) ? 0 : comm);
   }
  EXEC SQL CLOSE c;
  exit(0);

error:
  cout &lt;&lt; endl &lt;&lt; sqlca.sqlerrm.sqlerrmc &lt;&lt; endl;
  exit(1);
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment823">
<tr>
<td class="cellalignment832">
<table class="cellalignment828">
<tr>
<td class="cellalignment827"><a href="partpage2.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment827"><a href="pc_13dyn.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment835">
<table class="cellalignment826">
<tr>
<td class="cellalignment827"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment827"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment827"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment827"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment827"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment827"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
