<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Accessing Stored Procedures</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2009-08-02T18:45:30Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="SQL*Module for Ada Programmer's Guide" />
<meta name="dcterms.identifier" content="E10827-01" />
<meta name="dcterms.isVersionOf" content="ZZMOD" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ch_two.htm" title="Previous" type="text/html" />
<link rel="Next" href="ch_four.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10827.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">6/15</span> <!-- End Header --><a id="g1011747"></a><a id="i1007254"></a>
<h1 class="chapter"><span class="secnum">3</span> Accessing Stored Procedures</h1>
<p>This chapter describes how to use SQL*Module to generate interface procedures to call stored procedures. It covers the following topics:</p>
<ul>
<li>
<p><a href="#i1007305">PL/SQL</a></p>
</li>
<li>
<p><a href="#i1007364">Stored Procedures</a></p>
</li>
<li>
<p><a href="#i1007379">Stored Packages</a></p>
</li>
<li>
<p><a href="#i1007396">Accessing Stored Procedures</a></p>
</li>
<li>
<p><a href="#i1007412">Case of Package and Procedure Names</a></p>
</li>
<li>
<p><a href="#i1007434">Early and Late Binding</a></p>
</li>
<li>
<p><a href="#i1007497">Cursor Variables</a></p>
</li>
<li>
<p><a href="#i1007611">Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i1007621">The WITH INTERFACE Clause</a></p>
</li>
<li>
<p><a href="#i1007932">Storing Module Language Procedures</a></p>
</li>
<li>
<p><a href="#i1007983">Connecting to a Database</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The examples in this chapter use the tables defined in <a href="ch_six.htm#i1009402">Chapter 6, "Demonstration Programs"</a>.</div>
<a id="i1007305"></a>
<div class="sect1">
<h2 class="sect1">PL/SQL<a id="sthref115"></a></h2>
<p>This section contains a brief overview of PL/SQL, Oracle's procedural language extension to SQL. PL/SQL is a modern block-structured language that enables you to</p>
<ul>
<li>
<p>declare constants and variables</p>
</li>
<li>
<p>control execution flow, using IF ... THEN ... ELSE, EXIT, GOTO, and other procedural constructs</p>
</li>
<li>
<p>create loops, using WHILE ... LOOP and FOR ... LOOP</p>
</li>
<li>
<p>assign constant or variable expressions to a variable</p>
</li>
<li>
<p>issue SQL Data Manipulation Language and Transaction Control statements</p>
</li>
<li>
<p>define exceptions, handle them using WHEN EXCEPTION_NAME THEN ..., and raise them using RAISE EXCEPTION_NAME</p>
</li>
</ul>
<p>See the <a class="olink LNPLS" href="../e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information about the PL/SQL language.</p>
<a id="i1007323"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref116"></a><a id="sthref117"></a>Procedures</h3>
<p>A PL/SQL procedure is a named PL/SQL block. Unlike an anonymous block, a procedure can</p>
<ul>
<li>
<p>take parameters</p>
</li>
<li>
<p>be invoked from a separate application</p>
</li>
<li>
<p>be compiled once, but invoked many times</p>
</li>
<li>
<p>be stored in compiled form in a database, independent of the shared SQL cache</p>
</li>
</ul>
<p>A procedure contains one or more PL/SQL blocks. The following example computes the grade point average. The student ID number is passed as a parameter to the procedure, and the computed grade point average is returned by the procedure.</p>
<pre>
<a id="i1007331"></a>
PROCEDURE get_gpa( 
             student_id IN NUMBER,
             gpa        OUT NUMBER) IS 
    n                NUMBER; 
    grade_temp       NUMBER; 
    gpa_temp         NUMBER; -- needed because PL/SQL cannot read
                             -- an OUT parameter like GPA
    CURSOR c1(sid) IS 
        SELECT grade FROM enrollment
            WHERE student_id = sid;

    BEGIN
        n := 0;
        gpa := 0;
        OPEN c1(student_id);
        LOOP 
            FETCH c1 INTO grade_temp; 
            EXIT WHEN c1%NOTFOUND;     -- c1%NOTFOUND is TRUE 
                                       -- when no more data found 
            gpa_temp := gpa_temp + grade_temp; 
            n := n + 1; 
        END LOOP; 
        IF n &gt; 0 THEN 
            gpa := gpa_temp / n; 
        END IF; 
        CLOSE c1; 
    END; 
END PROCEDURE get_gpa; 
</pre>
<p>The procedure declaration adds a parameter list to the PL/SQL block. In this example, student_id is a parameter whose mode is IN. The mode of a parameter indicates whether the parameter passes data to a procedure (IN), returns data from a procedure (OUT), or can do both (IN OUT). The parameter gpa is an OUT parameter. It returns a value, but you cannot use it to pass a value to the procedure. Nor can you read its value inside the procedure, even after a value has been assigned to it. <a id="sthref118"></a><a id="sthref119"></a></p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007364"></a>
<div class="sect1">
<h2 class="sect1">Stored Procedures<a id="sthref120"></a><a id="sthref121"></a><a id="sthref122"></a></h2>
<p>You can store PL/SQL procedures in the database, and call these stored procedures from Oracle applications. Storing a procedure in the database offers many advantages. Only one copy of the procedure needs to be maintained; it is in the database, and it can be accessed by many different applications. This considerably reduces maintenance requirements for large applications. A stored procedure is not recompiled each time it is called.</p>
<p>You can store procedures in the database by using Oracle tools such as SQL*Plus. You create the source for the procedure using your text editor, and execute the source using SQL*Plus (for example, with the @ operator). When you input the source, use the CREATE PROCEDURE command. (You can also use CREATE OR REPLACE PROCEDURE, to replace an already stored procedure of the same name.)<a id="sthref123"></a><a id="sthref124"></a></p>
<p>See the <span class="italic">Oracle Database Reference</span> for complete information about the CREATE PROCEDURE command.</p>
</div>
<!-- class="sect1" -->
<a id="i1007379"></a>
<div class="sect1">
<h2 class="sect1">Stored Packages<a id="sthref125"></a><a id="sthref126"></a></h2>
<p>The examples of stored procedures shown so far in this chapter involve standalone procedures (sometimes called top-level procedures). These are useful in small applications. However, to gain the full power of stored procedures, you should use packages.<a id="sthref127"></a><a id="sthref128"></a><a id="sthref129"></a><a id="sthref130"></a></p>
<p>A package encapsulates procedures, as well as other PL/SQL objects. Stored packages that are used with Ada applications have two parts: a package specification and a package body. The specification is the (exposed) interface to the host application; it declares the procedures that are called by the application. A complete PL/SQL package specification can also declare functions, as well as other PL/SQL objects such as constants, variables, and exceptions. However, an Ada application using SQL*Module cannot access or reference PL/SQL objects other than subprograms. The package body contains the PL/SQL code that defines the procedures and other objects that are declared in the package specification.</p>
<p>Although an Ada application can only access public subprograms, a called subprogram can in turn call private subprograms, and can access public and private variables and constants in the package.</p>
<p>For complete information about stored packages, see the <a class="olink LNPLS" href="../e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1007396"></a>
<div class="sect1">
<h2 class="sect1">Accessing Stored Procedures</h2>
<p>You can use SQL*Module to provide a bridge that enables your host application to access procedures stored in the database. A host application written in Ada cannot call a stored database subprogram directly. But you can use SQL*Module to construct an interface procedure ("stub'') that calls the stored database subprogram. shows, in schematic form, how this process works.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1007402"></a><a id="CIHJCAEH"></a>Figure 3-1 Accessing a Stored Procedure</p>
<img width="600" height="630" src="img/sqa80005.gif" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" /><br />
<a id="sthref131" href="img_text/sqa80005.htm">Description of "Figure 3-1 Accessing a Stored Procedure"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In this example, there is a procedure stored in the database called enroll. The PL/SQL source code that created the procedure is shown in the right-hand box. The WITH INTERFACE clause in the procedure is described in the section <a href="#i1007621">"The WITH INTERFACE Clause"</a>. The procedure has two database parameters: class_no and student_id. The SQLCODE error return parameter is added in the interfacing clause.</p>
</div>
<!-- class="sect1" -->
<a id="i1007412"></a>
<div class="sect1"><a id="CIHBEJGA"></a>
<h2 class="sect1">Case of Package and Procedure Names <a id="sthref132"></a></h2>
<p>The Oracle Server always translates the names of database objects to uppercase when they are inserted into the database. This includes the names of packages and procedures. For example, if you are loading a package into the database in the SCOTT schema, and have a PL/SQL source file that contains the line</p>
<pre>
CREATE PACKAGE school_records AS ...
</pre>
<p>then Oracle inserts the name into the schema as SCHOOL_RECORDS, not the lowercase ''school_records''. The following SQL*Module command (in UNIX)</p>
<pre>
modada rpc_generate=yes pname=school_records userid=scott
</pre>
<p>generates an error, since there is no package named ''school_records'' in the schema.</p>
<p>If you prefer to have your package and procedure names stored in lowercase in the database, you must quote all references to the name in the PL/SQL source file, or as you insert them into the database using SQL*Plus. So, you would code</p>
<pre>
CREATE PACKAGE "school_records" AS ...
</pre>
<p>Note also that SQL*Module preserves the case of subprogram names when creating interface procedure files. <a id="sthref133"></a></p>
<p>However, if you really do want uppercase names, some operating systems (OPEN VMS is an example) require that you quote the name when you specify it on the command line. So, you would enter the command as</p>
<pre>
modada rpc_generate=yes pname="SCHOOL_RECORDS" user=scott
</pre>
<p><a id="i1007430"></a>See your system-specific Oracle documentation, and your operating system documentation, for additional information on case conventions for command lines that are in effect for your operating system. <a id="sthref134"></a><a id="sthref135"></a></p>
</div>
<!-- class="sect1" -->
<a id="i1007434"></a>
<div class="sect1">
<h2 class="sect1">Early and Late Binding<a id="sthref136"></a><a id="sthref137"></a><a id="sthref138"></a><a id="sthref139"></a><a id="sthref140"></a></h2>
<p>When you generate RPCs (remote procedure calls) using SQL*Module, you have a choice of early binding or late binding. Your choice of early or late binding is controlled by the BINDING option.</p>
<p>When you choose early binding, SQL*Module generates a call to the procedure stored in the database, and also uses a time stamp that is associated with the call. The time stamp records the date and time (to the nearest second) that the stored procedure was last compiled. The time stamp is created by the Oracle database. If a host application calls the stored procedure through the interface procedure, and the time stamp recorded with the interface procedure is earlier than the time stamp on the stored procedure recorded in the database, an error is returned to the host application in the SQLCODE or SQLSTATE status parameter. The SQLCODE error is 4062 "time stamp of name has been changed".</p>
<p>The late binding option, on the other hand, does not use a time stamp. If your application calls a stored procedure that has been recompiled since SQL*Module generated the interface procedure, no error is returned to the application.</p>
<p>With late binding, SQL*Module generates the call to the stored procedure using an anonymous PL/SQL block. The following example shows a specification for a stored procedure that is part of a package in the SCOTT schema:</p>
<pre>
PACKAGE emppkg IS 
 
     PROCEDURE get_sal_comm (emp_num     IN   NUMBER, 
                             salary      OUT  NUMBER, 
                             commission  OUT  NUMBER) 
     WITH INTERFACE
     PROCEDURE get_sal_emp  ( 
                              emp_num     INTEGER, 
                              salary      REAL, 
                              commission  REAL INDICATOR comm_ind, 
                              comm_ind    SMALLINT, 
                              SQLCODE); 
END emppkg; 
</pre>
<p>If you generate an RPC interface procedures output file for the package using the command</p>
<pre>
modada pname=EMPPKG rpc_generate=yes binding=late userid=scott/tiger 
</pre>
<p>SQL*Module generates a call in the output file, as follows:</p>
<pre>
With Oracle_Sqllib; use Oracle_Sqllib;
with SQL_STANDARD;
Package EMPPKG is
 
procedure GET_SAL_EMP(EMPNUM: in sql_standard.int;
 SALARY: out sql_standard.real;
 COMMISION: out sql_standard.real;
 COMM_IND: out sql_standard.smallint;
 SQLCODE: out sql_standard.sqlcode_type);
sql_001 : constant string :=
"begin ""EMPPKG.SCOTT""." &amp;
    """GET_SAL_COMM""(:EMPNUM, :SALARY, :COMMISION:COMM_IND); end;";
 
end EMPPKG;
... 
</pre>
<p>In other words, the call to the stored procedure get_sal_comm is performed using an anonymous PL/SQL block. This is the way stored procedures are called from an Oracle precompiler or Oracle Call Interface application.<a id="sthref141"></a><a id="sthref142"></a><a id="sthref143"></a></p>
<p>The advantages of late binding are</p>
<ul>
<li>
<p>greater flexibility</p>
</li>
<li>
<p>changes in the stored procedure(s) are transparent to the user</p>
</li>
<li>
<p>gives behavior similar to interactive SQL (for example, SQL*PLus)</p>
</li>
</ul>
<p>The disadvantages of late binding are</p>
<ul>
<li>
<p>There might be additional performance overhead at runtime, due to the necessity of compiling the PL/SQL anonymous block.</p>
</li>
<li>
<p>It is difficult to detect runtime PL/SQL compilation errors in the host application. For example, if the anonymous block that calls the late-bound procedure fails at runtime, there is no convenient way for the host application to determine the cause of the error.</p>
</li>
<li>
<p>The lack of time-stamp capability means that changes, perhaps radical changes, in the stored procedure could be made after the host application was built, and the application would have no way of detecting this.</p>
</li>
</ul>
<p>Use the BINDING={EARLY | LATE} command line option to select early or late binding when generating RPC interface procedures. See <a href="ch_five.htm#g1018019">Chapter 5, "Running SQL*Module"</a> for a description of this and other command line options.<a id="sthref144"></a><a id="sthref145"></a></p>
</div>
<!-- class="sect1" -->
<a id="i1007497"></a>
<div class="sect1">
<h2 class="sect1">Cursor Variables <a id="sthref146"></a></h2>
<p>You can use cursor variables in your application. A cursor variable is a reference to a cursor that is defined and opened on the Oracle Database version 8 server. See the <a class="olink LNPLS" href="../e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for complete information about cursor types. <a id="sthref147"></a></p>
<p>The advantages of cursor variables are</p>
<ul>
<li>
<p>Encapsulation: queries are centralized, placed in the stored procedure that opens the cursor variable. The logic is hidden from the user.</p>
</li>
<li>
<p>Ease of maintenance: if you need to change the cursor, you only need to make the change in one place: the stored procedure. There is no need to change each application.</p>
</li>
<li>
<p>Convenient security: the user of the application is the username used when the application connects to the server. The user must have execute permission on the stored procedure that opens the cursor. But the user does not need to have read permission on the tables used in the query. This capability can be used to limit access to the columns and rows in the table.</p>
</li>
</ul>
<div class="sect2"><a id="sthref148"></a>
<h3 class="sect2"><a id="sthref149"></a>Cursor Variable Parameters</h3>
<p>You define a cursor variable parameter in your module by using the type SQL_CURSOR. For example:</p>
<pre>
PROCEDURE alloc_cursor (
        SQLCODE,
        :curs SQL_CURSOR);
</pre>
<p>In this example, the parameter curs has the type SQL_CURSOR.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref150"></a>
<h3 class="sect2"><a id="sthref151"></a>Allocating a Cursor Variable</h3>
<p>You must allocate the cursor variable by using the Module Language command ALLOCATE. For example, to allocate the SQL_CURSOR curs that is the formal parameter in the example, you write the statement:</p>
<pre>
ALLOCATE :curs;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You use the ALLOCATE command only for cursor variables. You do not need to use it for standard cursors.</div>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref152"></a>
<h3 class="sect2"><a id="sthref153"></a>Opening a Cursor Variable<a id="sthref154"></a></h3>
<p>You must open a cursor variable on the Oracle Server. You cannot use the OPEN command that you use to open a standard cursor to open a cursor variable. You open a cursor variable by calling a PL/SQL stored procedure that opens the cursor (and defines it in the same statement).</p>
<p>For example, consider the following PL/SQL package, stored in the database:</p>
<pre>
CONNECT scott/tiger
 
CREATE OR REPLACE PACKAGE cursor_var_pkg AS
 
    TYPE emp_record_type IS RECORD (ename EMP.ename%TYPE;); 
    TYPE curtype IS REF CURSOR RETURN emp_record_type;
 
    PROCEDURE OPEN1(cur1 IN OUT curtype)
    WITH INTERFACE
    PROCEDURE 
           OPEN1 (SQLCODE integer, cur1 SQL_CURSOR);
 
end cursor_var_pkg;
 
CREATE OR REPLACE PACKAGE BODY cursor_var_pkg AS
 
    PROCEDURE OPEN1(cur1 IN OUT curtype) IS
    BEGIN
        OPEN cur1 FOR SELECT ename FROM emp_view;
    END;
END cursor_var_pkg;
 
COMMIT;
</pre>
<p>After you have stored this package, and you have generated the interface procedures, you can open the cursor curs by calling the OPEN1 stored procedure from your Ada driver program. You can then call module procedures that FETCH the next row from the opened cursor. For example:</p>
<pre>
PROCEDURE fetch_from_cursor (
    SQLCODE,
    :curs SQL_CURSOR,
    :emp_name VARCHAR2(11));
 
  FETCH :curs INTO :emp_name;
</pre>
<p>In your driver program, you call this procedure to fetch each row from the result defined by the cursor. When there is no more data, the value +100 is returned in SQLCODE.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use SQL*Module to create the interface procedure to call the stored procedure that opens the cursor variable, you must specify BINDING=LATE. Early binding is not supported for cursor variables in this release. <a id="sthref155"></a></div>
<div class="sect3"><a id="sthref156"></a>
<h4 class="sect3"><a id="sthref157"></a>Opening in a Stand-alone Stored Procedure</h4>
<p>In the example, a cursor type was defined inside a package, and the cursor was opened in a procedure in that package. But it is not always necessary to define a cursor type inside the package that contains the procedures that open the cursor.</p>
<p>If you need to open a cursor inside a standalone stored procedure, you can define the cursor in a separate package, then reference that package in the standalone stored procedure that opens the cursor. Here is an example:</p>
<pre>
PACKAGE dummy IS
    TYPE EmpName IS RECORD (name VARCHAR2(10));
    TYPE emp_cursor_type IS REF CURSOR RETURN EmpName;
END;
-- and then define a standalone procedure:
PROCEDURE open_emp_curs (
      emp_cursor IN OUT dummy.emp_cursor_type;
      dept_num   IN     NUMBER) IS
    BEGIN
        OPEN emp_cursor FOR
            SELECT ename FROM emp WHERE deptno = dept_num;
    END;
END;
</pre></div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref158"></a>
<h4 class="sect3"><a id="sthref159"></a>Return Types</h4>
<p>When you define a reference cursor in a PL/SQL stored procedure, you must declare the type that the cursor returns. See the Oracle Database PL/SQL Language Reference for complete information on the reference cursor type and its return types.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref160"></a>
<h3 class="sect2"><a id="sthref161"></a>Closing a Cursor Variable</h3>
<p>Use the Module Language CLOSE command to close a cursor variable. For example, to close the emp_cursor cursor variable that was OPENed in the examples, use the statement</p>
<pre>
CLOSE :emp_cursor;
</pre>
<p>Note that the cursor variable is a parameter, and so you must precede it with a colon.</p>
<p>You can reuse ALLOCATEd cursor variables. You can OPEN, FETCH, and CLOSE as many times as needed for your application. However, if you disconnect from the server, then reconnect, you must reallocate cursor variables.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref162"></a>
<h3 class="sect2"><a id="sthref163"></a>Restrictions on Cursor Variables</h3>
<p>The following restrictions apply to the use of cursor variables:</p>
<p>1. You can only use cursor variables with the commands:</p>
<ul>
<li>
<p>ALLOCATE</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>CLOSE</p>
</li>
</ul>
<p>2. The DECLARE CURSOR command does not apply to cursor variables.</p>
<ul>
<li>
<p>You cannot FETCH from a CLOSEd cursor variable.</p>
</li>
<li>
<p>You cannot FETCH from a non-ALLOCATEd cursor variable.</p>
</li>
<li>
<p>Cursor variables cannot be stored in columns in the database.</p>
</li>
<li>
<p>A cursor variable itself cannot be declared in a package specification. Only the type of the cursor variable can be declared in the package specification.</p>
</li>
<li>
<p>A cursor variable cannot be a component of a PL/SQL record.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007611"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref164"></a>Dynamic SQL</h2>
<p>Dynamic SQL is the capability of executing SQL commands that are stored in character string variables. The package DBMS_SQL parses data definition language (DDL) and Data Manipulation (DML) statements at runtime. DBMS_SQL has functions such as OPEN_CURSOR, PARSE, DEFINE_COLUMN, EXECUTE, FETCH_ROWS, COLUMN_VALUE, and so on. Use these functions in your program to open a cursor, parse the statement, and so on.</p>
<p>For more details on this package, see Oracle Database Advanced Application Developer's Guide</p>
</div>
<!-- class="sect1" -->
<a id="i1007621"></a>
<div class="sect1">
<h2 class="sect1">The WITH INTERFACE Clause<a id="sthref165"></a></h2>
<p>The stored procedure format in the previous section can be used for stored procedures that are to be called from applications written using Oracle tools. For example, a SQL*Plus script can call the GET_GPA procedure in <a href="#i1007323">"Procedures"</a> just as it is written.</p>
<p>You can code a WITH INTERFACE clause, or you can let SQL*Module generate a default WITH INTERFACE clause for stored procedures that have been stored without this clause.</p>
<p>This clause, when added to a procedure declaration in the package specification, lets you add parameters that are essential to perform an RPC to a PL/SQL procedure, through a calling interface procedure in the output file. In addition, the WITH INTERFACE clause uses SQL datatypes, not the PL/SQL datatypes that are used in the stored procedure definition. The additional features of the WITH INTERFACE clause are <a id="sthref166"></a><a id="sthref167"></a><a id="sthref168"></a></p>
<ul>
<li>
<p>use of SQL datatypes<a id="sthref169"></a></p>
</li>
<li>
<p>optional indicator parameters<a id="sthref170"></a></p>
</li>
<li>
<p>use of the SQLSTATE and SQLCODE status parameters<a id="sthref171"></a><a id="sthref172"></a><a id="sthref173"></a><a id="sthref174"></a></p>
</li>
</ul>
<p>Note: The procedures names that you code in WITH INTERFACE clauses must be unique within the entire application. If you let SQL*Module generate default WITH INTERFACE, then overloaded procedure names are resolved using an algorithm described in <a href="ch_five.htm#i1012769">"MAPPING"</a>.</p>
<p>Arrays are not allowed in WITH INTERFACE clauses.</p>
<a id="i1007647"></a>
<div class="sect2">
<h3 class="sect2">Examples</h3>
<p>The following package declaration shows how you use the WITH INTERFACE clause to map PL/SQL datatypes to SQL datatypes, and add the SQLCODE or SQLSTATE status parameters. Status parameters are filled in automatically as the procedure executes. They are not directly accessible within the procedure body.</p>
<pre>
CREATE or REPLACE PACKAGE gpa_pkg AS 
  PROCEDURE get_gpa (student_id  IN  NUMBER, 
                     gpa         OUT NUMBER) 
  WITH INTERFACE
  PROCEDURE get_gpa_if 
                     (student_id  INTEGER, 
                      gpa         REAL, 
                      SQLCODE     INTEGER 
                      SQLSTATE    CHARACTER(6)); 
... 
</pre>
<p>The interface procedure name specified in the WITH INTERFACE clause can be the same as the name of the procedure itself, or, as in this example, it can be different. However, the name specified in the WITH INTERFACE clause is the name that must be used when you invoke the stored procedure from your host application.</p>
<p>In the example, the datatypes in the WITH INTERFACE clause are SQL datatypes (INTEGER and REAL). These types are compatible with the PL/SQL datatype NUMBER.</p>
<p>You must include either a SQLCODE or a SQLSTATE parameter in the parameter list of the WITH INTERFACE clause. You can include both. SQLSTATE is the recommended parameter; SQLCODE is provided for compatibility with the SQL89 standard.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Parameters in the PL/SQL procedure specification cannot be constrained. Parameters in the WITH INTERFACE clause must be constrained where required.</div>
<p>The following package definition shows an example of the WITH INTERFACE clause:</p>
<pre>
CREATE OR REPLACE PACKAGE gpa_pkg AS 
 
  PROCEDURE get_gpa(student_id        IN     NUMBER, 
                    student_last_name IN OUT CHARACTER, 
                    gpa               OUT    NUMBER) 
  WITH INTERFACE
  PROCEDURE get_gpa_if 
                   (student_id        INTEGER, 
                    student_last_name CHARACTER(15) 
                                      INDICATOR sname_ind, 
                    sname_ind         SMALLINT, 
                    gpa               REAL, 
                    SQLSTATE          CHARACTER(6), 
                    SQLCODE           INTEGER); 
END; 
</pre>
<p>In the example, the student_last_name parameter is a CHARACTER, which is both a PL/SQL and a SQL datatype. In the PL/SQL part of the procedure definition, the parameter must be unconstrained, following the syntax of PL/SQL. But in the WITH INTERFACE clause, you must specify the length of the parameter.</p>
<p>The student_last_name parameter also takes an indicator parameter, using the syntax shown. See Appendix B for the formal syntax of the WITH INTERFACE clause.</p>
</div>
<!-- class="sect2" -->
<a id="i1007684"></a>
<div class="sect2">
<h3 class="sect2">SQL Datatypes</h3>
<p>The SQL datatypes that you can use in the WITH INTERFACE clause are listed in , along with their compatible PL/SQL datatypes.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref175"></a><a id="sthref176"></a>Table 3-1 SQL Datatypes</p>
<table class="cellalignment845" title="SQL Datatypes" summary="table" dir="ltr">
<thead>
<tr class="cellalignment839">
<th class="cellalignment846" id="r1c1-t6">SQL Datatypes</th>
<th class="cellalignment846" id="r1c2-t6">Range or Size</th>
<th class="cellalignment846" id="r1c3-t6">SQL Meaning</th>
<th class="cellalignment846" id="r1c4-t6">Compatible PL/SQL Datatypes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment839">
<td class="cellalignment847" id="r2c1-t6" headers="r1c1-t6">
<p>CHARACTER (N) OR CHAR (N)</p>
</td>
<td class="cellalignment847" headers="r2c1-t6 r1c2-t6">
<p>1 &lt; N &lt; 32500 bytes</p>
</td>
<td class="cellalignment847" headers="r2c1-t6 r1c3-t6">
<p>String of length N (if N is omitted, N is effectively 1)</p>
</td>
<td class="cellalignment847" headers="r2c1-t6 r1c4-t6">
<p>VARCHAR2(N), CHAR(N), DATE</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r3c1-t6" headers="r1c1-t6">
<p>DOUBLE PRECISION</p>
</td>
<td class="cellalignment847" headers="r3c1-t6 r1c2-t6">
<p>Implicit precision 38</p>
</td>
<td class="cellalignment847" headers="r3c1-t6 r1c3-t6">
<p>Approximate numeric type</p>
</td>
<td class="cellalignment847" headers="r3c1-t6 r1c4-t6">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r4c1-t6" headers="r1c1-t6">
<p>INTEGER</p>
<p>or INT</p>
</td>
<td class="cellalignment847" headers="r4c1-t6 r1c2-t6">
<p>System specific</p>
</td>
<td class="cellalignment847" headers="r4c1-t6 r1c3-t6">
<p>Integer type</p>
</td>
<td class="cellalignment847" headers="r4c1-t6 r1c4-t6">
<p>NUMBER, BINARY_INTEGER</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r5c1-t6" headers="r1c1-t6">
<p>SMALLINT</p>
</td>
<td class="cellalignment847" headers="r5c1-t6 r1c2-t6">
<p>System specific</p>
</td>
<td class="cellalignment847" headers="r5c1-t6 r1c3-t6">
<p>Small (or short) integer type</p>
</td>
<td class="cellalignment847" headers="r5c1-t6 r1c4-t6">
<p>NUMBER, BINARY_INTEGER</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r6c1-t6" headers="r1c1-t6">
<p>REAL</p>
</td>
<td class="cellalignment847" headers="r6c1-t6 r1c2-t6">
<p>System-specific</p>
</td>
<td class="cellalignment847" headers="r6c1-t6 r1c3-t6">
<p>Approximate numeric type</p>
</td>
<td class="cellalignment847" headers="r6c1-t6 r1c4-t6">
<p>NUMBER</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r7c1-t6" headers="r1c1-t6">
<p>VARCHAR2(N)</p>
</td>
<td class="cellalignment847" headers="r7c1-t6 r1c2-t6">
<p>1 &lt; N &lt;32500 bytes</p>
</td>
<td class="cellalignment847" headers="r7c1-t6 r1c3-t6">
<p>Character array of length N</p>
</td>
<td class="cellalignment847" headers="r7c1-t6 r1c4-t6">
<p>VARCHAR2(N),</p>
<p>CHAR(N),DATE</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r8c1-t6" headers="r1c1-t6">
<p>SQL_CURSOR</p>
</td>
<td class="cellalignment847" headers="r8c1-t6 r1c2-t6">&nbsp;</td>
<td class="cellalignment847" headers="r8c1-t6 r1c3-t6">
<p>Cursor variable type</p>
</td>
<td class="cellalignment847" headers="r8c1-t6 r1c4-t6">
<p>REF cursor</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL datatypes compatible with NUMBER are also compatible with types derived from NUMBER, such as REAL.
<p>The size of integer and small integer types is system specific. For many systems, integers are 32 bits wide and small integers are 16 bits, but check your system documentation for the size on your system.</p>
</div>
<a id="i1007779"></a>
<div class="sect3">
<h4 class="sect3">DATE Datatype</h4>
<p>SQL*Module does not directly support the Oracle DATE datatype. You can, however, use character strings when you fetch, select, update, or insert DATE values. Oracle does the conversion between internal DATEs and character strings. See the Oracle Database Reference for more information about the DATE datatype, and conversion between DATEs and character strings.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007787"></a>
<div class="sect2">
<h3 class="sect2">The Default WITH INTERFACE Clause</h3>
<p>If a package has already been defined in the database with no WITH INTERFACE clauses for the subprograms, you can still generate interface procedures to call the subprograms. The default WITH INTERFACE clause that is generated by SQL*Module when there is no WITH INTERFACE clause in the package or procedure gives you all the features of the standard WITH INTERFACE clause:</p>
<ul>
<li>
<p>the SQLCODE error handling parameter</p>
</li>
<li>
<p>the SQLSTATE error handling parameter</p>
</li>
<li>
<p>indicator parameters</p>
</li>
<li>
<p>datatype mapping between PL/SQL base and derived datatypes and SQL types</p>
</li>
</ul>
<div class="sect3"><a id="sthref177"></a>
<h4 class="sect3">Procedures</h4>
<p>When SQL*Module generates an interface procedure with a default WITH INTERFACE clause, it generates a SQLCODE parameter in the first parameter position, and a SQLSTATE parameter in the second position. Then, for each actual parameter in the stored procedure or stored function, a parameter is generated with the appropriate mapped host language datatype. Each parameter is followed by an indicator parameter, mapped to the correct host language type from the SQL datatype SMALLINT.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref178"></a>
<h4 class="sect3">Functions</h4>
<p>If SQL*Module is generating a default WITH INTERFACE clause for functions in a package, then the WITH INTERFACE clause is generated as if the function were a procedure, with the return value and its indicator parameter as the last two parameters in the clause.</p>
<p><a href="#CIHGGFDG">Table 3-2</a> shows how predefined, or base, PL/SQL datatypes are mapped to SQL datatypes, and then to host language datatypes. PL/SQL subtypes that are derived from the base types are also supported, and are mapped as indicated for the base type.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref179"></a><a id="CIHGGFDG"></a>Table 3-2 Mapping PL/SQL Datatypes to SQL Datatypes</p>
<table class="cellalignment845" title="Mapping PL/SQL Datatypes to SQL Datatypes" summary="table" dir="ltr">
<thead>
<tr class="cellalignment839">
<th class="cellalignment846" id="r1c1-t8">PL/SQL Datatype</th>
<th class="cellalignment846" id="r1c2-t8">Ada Language Datatype</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment839">
<td class="cellalignment847" id="r2c1-t8" headers="r1c1-t8">
<p>BINARY INTEGER</p>
</td>
<td class="cellalignment847" headers="r2c1-t8 r1c2-t8">
<p>SQL_STANDARD.INT</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r3c1-t8" headers="r1c1-t8">
<p>NUMBER</p>
<p>NUMBER(P,S)</p>
</td>
<td class="cellalignment847" headers="r3c1-t8 r1c2-t8">
<p>SQL_STANDARD.</p>
<p>DOUBLE_PRECISION</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r4c1-t8" headers="r1c1-t8">
<p>RAW</p>
<p>LONG RAW</p>
</td>
<td class="cellalignment847" headers="r4c1-t8 r1c2-t8">
<p>STRING</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r5c1-t8" headers="r1c1-t8">
<p>LONG</p>
</td>
<td class="cellalignment847" headers="r5c1-t8 r1c2-t8">
<p>STRING</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r6c1-t8" headers="r1c1-t8">
<p>BOOLEAN</p>
</td>
<td class="cellalignment847" headers="r6c1-t8 r1c2-t8">
<p>SQL_STANDARD.INT</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r7c1-t8" headers="r1c1-t8">
<p>CHAR</p>
</td>
<td class="cellalignment847" headers="r7c1-t8 r1c2-t8">
<p>SQL_STANDARD.CHAR</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r8c1-t8" headers="r1c1-t8">
<p>VARCHAR2</p>
</td>
<td class="cellalignment847" headers="r8c1-t8 r1c2-t8">
<p>STRING</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r9c1-t8" headers="r1c1-t8">
<p>DATE</p>
</td>
<td class="cellalignment847" headers="r9c1-t8 r1c2-t8">
<p>SQL_STANDARD.CHAR</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r10c1-t8" headers="r1c1-t8">
<p>ROWID</p>
</td>
<td class="cellalignment847" headers="r10c1-t8 r1c2-t8">
<p>STRING</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r11c1-t8" headers="r1c1-t8">
<p>CURSOR</p>
</td>
<td class="cellalignment847" headers="r11c1-t8 r1c2-t8">
<p>ORACLE_SQLLIB.SQL_CURSOR</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The maximum length for the following data types are:
<ul>
<li>
<p>For STRING is 32500 bytes</p>
</li>
<li>
<p>For DATE is 2048 bytes</p>
</li>
<li>
<p>For ROWID and MLSLABEL is 256 bytes</p>
</li>
</ul>
</div>
<p>Suppose, for example, that a procedure stored in the SCOTT schema has the parameter list</p>
<pre>
PROCEDURE proc1 (
        PARAM1 IN     NUMBER,
        PARAM2 IN OUT DATE,
        PARAM3    OUT DOUBLE PRECISION,
        PARAM4        CHARACTER,
        PARAM5        BINARY_INTEGER)
</pre>
<p>If you run the module compiler, modada, as follows:</p>
<pre>
modada pname=PROC1 rpc_generate=yes user=scott/tiger oname=proc1
</pre>
<p>then the Ada procedure specification in the generated output file proc1_.a would be created by SQL*Module as follows:</p>
<pre>
procedure PROC1(SQLCODE: in out sql_standard.sqlcode_type;
 sqlstate: in out sql_standard.sqlstate_type;
 PARAM1: in sql_standard.double_precision;
 PARAM1_ind: in sql_standard.smallint;
 PARAM2: in out oracle_sqllib.sql_date;
 PARAM2_ind: in out sql_standard.smallint;
 PARAM3: out sql_standard.double_precision;
 PARAM3_ind: out sql_standard.smallint;
 PARAM4: in string;
 PARAM4_ind: in sql_standard.smallint;
 PARAM5: in sql_standard.int;
 PARAM5_ind: in sql_standard.smallint);
</pre>
<p>Function calls are generated as procedures with the last two parameters in the generated prototype being the return parameter and the indicator variable for the return parameter. For example: <a id="sthref180"></a></p>
<pre>
FUNCTION func1 (
        PARAM1 IN NUMBER) RETURN VARCHAR2
</pre>
<p>would have the Ada prototype:</p>
<pre>
procedure FUNC1(SQLCODE: in out sql_standard.sqlcode_type;
 sqlstate: in out sql_standard.sqlstate_type;
 PARAM1: in sql_standard.double_precision;
 PARAM1_ind: in sql_standard.smallint;
 mod_func_return: out string;
 mod_func_return_ind: out sql_standard.smallint) is
begin
  . . .
 
end FUNC1;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007932"></a>
<div class="sect1">
<h2 class="sect1">Storing Module Language Procedures<a id="sthref181"></a></h2>
<p>You can also use SQL*Module to create a stored package in the database from Module Language procedures. By specifying the module file in the INAME command line option (see <a href="ch_five.htm#g1018019">Chapter 5, "Running SQL*Module"</a> for details), and setting the option STORE_PACKAGE=YES, the procedures in the module file are stored in a package in the database, using the module name as the default package name. (The default name can be overridden using the PNAME option. See <a href="ch_five.htm#g1018019">Chapter 5, "Running SQL*Module"</a> for details.)</p>
<p>For example, the following module file:</p>
<pre>
MODULE        test_sp 
AUTHORIZATION scott
 
PROCEDURE get_emp ( 
        :empname    CHAR(10),
        :empnumber  INTEGER, 
         SQLCODE); 
    SELECT ename INTO :empname 
        FROM emp 
        WHERE empno = :empnumber; 
 
PROCEDURE put_emp ( 
        :empname    CHAR(10), 
        :empnumber  INTEGER, 
        :deptnumber INTEGER, 
        SQLCODE); 
    INSERT INTO emp (ename, empno, deptno) VALUES 
                    (:empname, :empnumber, :deptnumber); 
</pre>
<p>when stored as a package in the database would produce the following PL/SQL code for the package specification:</p>
<pre>
package test_sp is 
procedure get_emp 
    (empname out char, 
    empnumber in number) 
  with interface procedure get_emp 
    (empname char(11),
    empnumber integer, 
    sqlcode integer); 
procedure put_emp 
    (empname in char, 
    empno in number, 
    deptno in number) 
  with interface procedure put_emp 
    (empname char(11), 
    empnumber integer, 
    deptnumber integer, 
    sqlcode integer); 
end test_sp; 
</pre>
<p>Note: You cannot store module procedures that contain the ALLOCATE statement, nor statements CONNECT, DISCONNECT, ENABLE THREADS, CONTEXT, nor FETCH and CLOSE statements that refer to cursor variables.</p>
</div>
<!-- class="sect1" -->
<a id="i1007983"></a>
<div class="sect1">
<h2 class="sect1">Connecting to a Database<a id="sthref182"></a></h2>
<p>When you write an Ada program that calls RPC interface procedures that were generated from stored procedures, you need a way to connect to a database at runtime. The steps you can take to do this are</p>
<ul>
<li>
<p>Write a module that contains connect and disconnect procedures. See <a href="ch_two.htm#i1007024">"CONNECT Statement"</a> for the syntax of these procedures. See also the examples in the demomod sample in <a href="ch_six.htm#i1009402">Chapter 6, "Demonstration Programs"</a>.</p>
</li>
<li>
<p>Compile the module using SQL*Module.</p>
</li>
</ul>
<p>Add a with clause to the host application file referencing the generated specification name.</p>
<ul>
<li>
<p>Compile the specification file.</p>
</li>
<li>
<p>Compile the source output file.</p>
</li>
<li>
<p>Link your main application.</p>
</li>
</ul>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment838">
<tr>
<td class="cellalignment847">
<table class="cellalignment843">
<tr>
<td class="cellalignment842"><a href="ch_two.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment842"><a href="ch_four.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment849">
<table class="cellalignment841">
<tr>
<td class="cellalignment842"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment842"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment842"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment842"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment842"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment842"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
