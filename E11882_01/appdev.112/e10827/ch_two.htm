<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Module Language</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2009-08-02T18:45:29Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="SQL*Module for Ada Programmer's Guide" />
<meta name="dcterms.identifier" content="E10827-01" />
<meta name="dcterms.isVersionOf" content="ZZMOD" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ch_one.htm" title="Previous" type="text/html" />
<link rel="Next" href="ch_three.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10827.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">5/15</span> <!-- End Header --><a id="g1019029"></a><a id="i1007261"></a>
<h1 class="chapter"><span class="secnum">2</span> Module Language</h1>
<p>This chapter describes SQL standard Module Language, including Oracle's extensions to standard Module Language. It discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1006435">The Module</a></p>
</li>
<li>
<p><a href="#i1006686">Structure of a Module</a></p>
</li>
<li>
<p><a href="#i1006810">SQL Datatypes</a></p>
</li>
<li>
<p><a href="#i1006889">SQL Commands</a></p>
</li>
<li>
<p><a href="#i1006913">Text in a Module</a></p>
</li>
<li>
<p><a href="#i1006938">Indicator Parameters</a></p>
</li>
<li>
<p><a href="#i1007001">Status Parameters</a></p>
</li>
<li>
<p><a href="#i1007024">CONNECT Statement</a></p>
</li>
<li>
<p><a href="#i1007074">DISCONNECT Statement</a></p>
</li>
<li>
<p><a href="#i1007102">Multi-tasking</a></p>
</li>
<li>
<p><a href="#i1007139">Multi-tasking Example</a></p>
</li>
</ul>
<p>This chapter does <span class="italic">not</span> cover the use of SQL*Module to provide interfaces to stored procedures. See <a href="ch_three.htm#g1011747">Chapter 3, "Accessing Stored Procedures"</a> for information about calling stored procedures from a host application.</p>
<a id="i1006435"></a>
<div class="sect1">
<h2 class="sect1">The Module<a id="sthref32"></a></h2>
<p>A <span class="italic">module</span> is a single file that contains</p>
<ul>
<li>
<p>introductory material, in a <span class="italic">preamble</span><a id="sthref33"></a><a id="sthref34"></a></p>
</li>
<li>
<p>optional <span class="italic">cursor declarations</span> for use by queries that can return multiple rows of data <a id="sthref35"></a><a id="sthref36"></a><a id="sthref37"></a></p>
</li>
<li>
<p>definitions of <span class="italic">procedures</span> to be called by the host application <a id="sthref38"></a><a id="sthref39"></a></p>
</li>
</ul>
<p>The easiest way to see how a module is constructed is to look at an example. The small module contains a cursor declaration, procedures that open and close the cursor, and a procedure that uses the cursor to fetch data from the familiar EMP table. Two consecutive dashes (- -) begin a comment, which continues to the end of the line. Case is not significant.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a class="olink DBSEG50053" href="../../network.112/e36292/app_devs.htm#DBSEG50053"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.</div>
<a id="i1006450"></a>
<div class="sect2">
<h3 class="sect2">An Example Module<a id="sthref40"></a></h3>
<pre>
-- the preamble (contains three clauses) 
-- 
MODULE     EXAMPLE1_MOD    -- Define a module named example1_mod. 
LANGUAGE   Ada             -- The procedures are compiled into
                           -- Ada, and called from an
                           -- Ada application.

AUTHORIZATION SCOTT/TIGER  -- Use Scott's tables. 
                           -- His password is "tiger" 
                           -- (the password does not have to 
                           -- be specified in the module file). 


-- Declare a cursor for a SELECT statement that 
-- fetches four columns from the EMP table.
-- dept_number will be specified 
-- in the procedure that opens the cursor. 

DECLARE cursor1 CURSOR FOR 
    SELECT ename, empno, sal, comm
       FROM emp 
       WHERE deptno = :dept_number


-- Define a procedure named "open_cursor1" to open the cursor. 
-- After the procedure name is a comma separated parameter list 
-- enclosed in ()'s. 
PROCEDURE open_cursor1 (
         :dept_number   INTEGER,
         SQLCODE);
   
    OPEN cursor1;


-- The "fetch_emp_data" procedure gets data from the cursor. 
-- SQLCODE will return as 100 when there 
-- is no more data. 
PROCEDURE fetch_emp_data ( 
         :empno         INTEGER, 
         :empname       VARCHAR2(10), 
         :sal           REAL, 
         :commission    REAL,
         :comm_ind      SMALLINT,
         SQLCODE); 

-- the SQL command is a FETCH on the cursor 
    FETCH cursor1 
        INTO :empname,
             :empno, 
             :sal,
             :commission INDICATOR :comm_ind;

-- Define a procedure to close the cursor. 
PROCEDURE close_cursor1 (SQLCODE); 
    CLOSE cursor1; 


-- Connect to a database
PROCEDURE do_connect (
        :dbname         VARCHAR2(12),
        :username       VARCHAR2(12),
        :passwd         VARCHAR2(12),
        SQLCODE);

    CONNECT TO :dbname USER :username USING :passwd;


-- Disconnect
PROCEDURE do_disconnect (SQLCODE);

    DISCONNECT CURRENT;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are familiar with the syntax of SQL89 Module Language, you should note that the newer SQL92 syntax is used in this example. This includes parentheses around a comma separated parameter list, colons before parameters, and use of the INDICATOR keyword. This syntax is supported by the current release of SQL*Module, and is used throughout this Guide.</div>
<p>In this example, the LANGUAGE clause (in the second line of the module) specifies "Ada". This module will be compiled into Ada code. For SQL*Module, this clause is optional. When present, it is, in effect, a comment.</p>
<p>When SQL*Module compiles this module, it transforms the procedures into Ada language procedures that open the cursor and call library routines to fetch the data. SQL*Module also generates a package specification file, which must be compiled into the Ada library and referenced in the host application using a <span class="bold">with</span> context clause. See <a href="ch_five.htm#g1018019">Chapter 5, "Running SQL*Module"</a> in this Guide for information on running SQL*Module, and <a href="ch_six.htm#i1009402">Chapter 6, "Demonstration Programs"</a> for information about Ada specification files.<a id="sthref41"></a><a id="sthref42"></a></p>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref43"></a>
<h3 class="sect2">A Short Example Program in Ada</h3>
<p>To complete the example, a short Ada program that calls the procedures defined in the module file in <a href="#i1006450">"An Example Module"</a> follows.</p>
<pre>
-- Include TEXT_IO,SQL_STANDARD and EXAMPLE1_MOD package specs.

with
     SQL_STANDARD,
     TEXT_IO,
     EXAMPLE1_MOD;
use
     SQL_STANDARD;


-- Define the main procedure.

procedure EXAMPLE1_DRV is


-- Instantiate new packages for I/O on SQL_STANDARD datatypes.
    package STD_INT_IO is
        new text_io.integer_io(SQL_STANDARD.INT);
    use STD_INT_IO;

    package SQLCODE_IO is
        new text_io.integer_io(SQL_STANDARD.SQLCODE_TYPE);
    use SQLCODE_IO;

    package STD_FLOAT_IO is
        new text_io.float_io(SQL_STANDARD.REAL);
    use STD_FLOAT_IO;


-- Begin with declarations of all program variables, 
-- including parameters for the module procedures.
    SERVICE_NAME         : string(1..12)
                               := "INST1_ALIAS ";
    USERNAME             : string(1..12)
                               := "SCOTT       ";
    PASSWORD             : string(1..12)
                               := "TIGER       ";

    DEPT_NUMBER          : SQL_STANDARD.INT;
    EMPLOYEE_NUMBER      : SQL_STANDARD.INT; 
    EMPLOYEE_NAME        : string(1..10); 
    SALARY               : SQL_STANDARD.REAL; 
    COMMISSION           : SQL_STANDARD.REAL;
    COMM_IND             : SQL_STANDARD.SMALLINT;
    SQLCODE              : SQL_STANDARD.SQLCODE_TYPE; 
    LENGTH               : integer;

    CONNECT_ERROR        : exception;
    SQLCODE_ERROR        : exception; 
    
begin 

-- Call a module procedure to connect
-- to the Oracle server.
    EXAMPLE1_MOD.DO_CONNECT
        (SERVICE_NAME, USERNAME, PASSWORD, SQLCODE);

-- Test SQLCODE to see if the connect succeeded.
    if SQLCODE /= 0 then
        raise CONNECT_ERROR;
    end if;

    TEXT_IO.NEW_LINE(2);

-- Get an input value from user to use
-- in opening the cursor.
    TEXT_IO.PUT("Enter department number: ");
    STD_INT_IO.GET(DEPT_NUMBER);
    TEXT_IO.NEW_LINE;

-- Call the module procedure to open the cursor.
-- You open the cursor using the input parameter (dept_number).
    EXAMPLE1_MOD.OPEN_CURSOR1(DEPT_NUMBER, SQLCODE); 
-- If SQLCODE indicates error, call exception handler.
    if SQLCODE &lt; 0 then
        raise SQLCODE_ERROR;
    end if;

    TEXT_IO.PUT_LINE("Employee  ID Number   Salary  Commission");
    TEXT_IO.PUT("----------------------------------------");

-- Call the FETCH procedure in a loop, to get
-- the employee data.
    loop
        EXAMPLE1_MOD.FETCH_EMP_DATA
               (EMPLOYEE_NUMBER, 
                EMPLOYEE_NAME, 
                SALARY, 
                COMMISSION,
                COMM_IND,
                SQLCODE);

        TEXT_IO.NEW_LINE;    

-- When SQLCODE = 100, no more rows to fetch.
        exit when SQLCODE = 100;

-- When SQLCODE less than 0, an error occurred.
        if SQLCODE &lt; 0 then
            raise SQLCODE_ERROR;
        end if;

        TEXT_IO.PUT(string(EMPLOYEE_NAME));
        STD_INT_IO.PUT(EMPLOYEE_NUMBER, WIDTH =&gt; 9); 
        STD_FLOAT_IO.PUT(SALARY, FORE =&gt; 6, AFT =&gt; 2, EXP =&gt; 0); 

        if COMM_IND = 0 then
            STD_FLOAT_IO.PUT(COMMISSION, FORE =&gt; 9, AFT =&gt; 2, EXP =&gt; 0);
        else
            TEXT_IO.PUT("        Null");
        end if;
    end loop;

    TEXT_IO.NEW_LINE(2);

-- Call the procedure to close the cursor.
    EXAMPLE1_MOD.CLOSE_CURSOR1(SQLCODE);

-- Call the procedure to disconnect.
    EXAMPLE1_MOD.DO_DISCONNECT(SQLCODE);

-- Handle the error exception.

exception 
     when SQLCODE_ERROR =&gt; 
          TEXT_IO.NEW_LINE(2);
          TEXT_IO.PUT("Error fetching data, SQLCODE returns "); 
          PUT(SQLCODE); 
          TEXT_IO.NEW_LINE(2);

     when CONNECT_ERROR =&gt;
          TEXT_IO.PUT("Connect failure to " &amp; 
                       string(SERVICE_NAME));
          TEXT_IO.NEW_LINE(2);

end EXAMPLE1_DRV; 

</pre>
<p>This example demonstrates several important points about SQL*Module:</p>
<p>The types of the parameters in the module procedures are SQL datatypes, for example SMALLINT and REAL, not Ada datatypes.</p>
<ul>
<li>
<p>Parameters are passed to the generated output code procedures in the normal way. Refer to <a href="ch_six.htm#i1009402">Chapter 6, "Demonstration Programs"</a> for specific information concerning parameter passing conventions.</p>
</li>
<li>
<p>The error status of a call is returned in the SQLCODE or SQLSTATE parameter. There must be a SQLCODE or SQLSTATE status parameter somewhere in the parameter list of each Module Language procedure. See the section <a href="#i1007001">"Status Parameters"</a> for more information.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006686"></a>
<div class="sect1">
<h2 class="sect1">Structure of a Module<a id="sthref44"></a></h2>
<p>This section is an informal guide to Module Language syntax, including Oracle's extensions to the language. See Appendix B to this Guide for a formal description of Module Language syntax.</p>
<p>A module is contained in a single file and consists of</p>
<ul>
<li>
<p>a preamble</p>
</li>
<li>
<p>zero or more cursor declarations</p>
</li>
<li>
<p>one or more procedure definitions</p>
</li>
</ul>
<div class="sect2"><a id="sthref45"></a>
<h3 class="sect2"><a id="sthref46"></a>Preamble</h3>
<p>The preamble is a set of clauses at the beginning of a module file that describes the module. The clauses are</p>
<ul>
<li>
<p>MODULE</p>
</li>
<li>
<p>LANGUAGE</p>
</li>
<li>
<p>AUTHORIZATION</p>
</li>
</ul>
<div class="sect3"><a id="sthref47"></a>
<h4 class="sect3"><a id="sthref48"></a>MODULE Clause</h4>
<p>The MODULE clause provides a name to the module. The argument is the module name, which must be a legal SQL identifier.<a id="sthref49"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A SQL identifier is a string containing only the 26 letters A through Z, the digits 0 through 9, and the underscore ("_"). The identifier must start with a letter, and cannot be longer than 30 characters (18 characters to comply with the SQL89 standard). You can use lowercase letters (a..z), but a SQL identifier is not case sensitive. So, the identifiers "THIS_IDENTIFIER" and "this_identifier" are equivalent. The characters'$' and'#' are also allowed in a SQL identifier, but you should avoid using them, as they have special meaning in many languages and operating systems.</div>
<p>The module name must be supplied. The module name must be the same as the name of the Ada library unit that you use when you store the Ada-compiled output in your Ada library.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref50"></a>
<h4 class="sect3"><a id="sthref51"></a>LANGUAGE Clause</h4>
<p>The LANGUAGE clause specifies the target language. It takes one argument &mdash; the language name, which must be Ada (case is not significant).</p>
<p>The LANGUAGE clause is optional in SQL*Module. See <a href="ch_five.htm#g1018019">Chapter 5, "Running SQL*Module"</a> for more information about running SQL*Module.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref52"></a>
<h4 class="sect3"><a id="sthref53"></a>AUTHORIZATION Clause</h4>
<p>The AUTHORIZATION clause can determine, or help to determine, the database and schema that SQL*Module uses at compile time.</p>
<p>The argument to the AUTHORIZATION clause can take any one of the following four forms:</p>
<ul>
<li>
<p>the username<a id="sthref54"></a>: scott</p>
</li>
</ul>
<pre>
- scott <a id="sthref55"></a>
</pre>
<ul>
<li>
<p>the username plus a password, the two separated by a slash: scott/tiger</p>
</li>
</ul>
<pre>
- scott/tiger
</pre>
<ul>
<li>
<p>the username plus a database to connect to:</p>
</li>
</ul>
<pre>
scott@{instance_alias | net8_connection_string}
}<a id="sthref56"></a>
</pre>
<ul>
<li>
<p>a full specification, consisting of the username, a password, and the database to connect to: scott/tiger@{instance_alias | net8_connection_string}</p>
</li>
</ul>
<pre>
- scott/tiger@{instance_alias | net8_connection_string}
</pre>
<p>The instance_alias is an alias containing a database name defined in the tnsnames.ora file. For more information, talk to your database administrator, or see the manual <a class="olink NETAG" href="../../network.112/e41945/toc.htm"><span class="italic">Oracle Database Net Services Administrator's Guide</span></a>.</p>
<p>If you do not include the password in the AUTHORIZATION clause, you can specify it when you run SQL*Module, using the USERID command line option. If you do not specify a USERID value that contains a password, SQL*Module prompts you for a password. If a database name is not supplied, SQL*Module connects using the default database for the specified user.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For security reasons, omit the password in the SQL*Module or in any configuration file. You will be prompted for the password at runtime.<a id="sthref57"></a></div>
<p>An application that calls module procedures is in effect submitting SQL cursor declarations and SQL statements to Oracle for processing at runtime. The application runs with the privileges of the user <span class="italic">executing</span> the application, not the schema specified either in the AUTHORIZATION clause or at runtime, when the Module Language code was compiled by SQL*Module. <a id="sthref58"></a><a id="sthref59"></a></p>
<p>So, when the application is executed, the user must be able to connect to the database using the same schema as that specified when the modules were compiled, in order to guarantee access to all database objects referenced in the modules.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref60"></a>
<h3 class="sect2"><a id="sthref61"></a>Cursor Declarations</h3>
<p>When a query can return multiple rows of data, you must declare a cursor for the statement. There are two different kinds of cursor that you can use in Module Language. You can declare an ANSI-standard cursor in your module file, and write module language procedures to OPEN the cursor, FETCH from it, and CLOSE it. Or, you can use a <span class="italic">cursor variable</span>. Cursor variables are described in <a href="ch_three.htm#i1007497">"Cursor Variables"</a>.<a id="sthref62"></a></p>
<p>Using a cursor, you retrieve data one row at a time using the SQL FETCH command. Standard cursors are established in Module Language using the DECLARE CURSOR statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The cursor name is a SQL identifier; it is not a procedure name. So, the cursor name does not need to be a valid Ada identifier.<a id="sthref63"></a><a id="sthref64"></a></div>
<p>The SQL statement in a DECLARE CURSOR clause must not include an INTO clause. The INTO clause is used in the FETCH command in the procedure that references the cursor.</p>
<p>You cannot use parameters when you <span class="italic">declare</span> a standard cursor. A placeholder is used instead. Placeholders in a cursor declaration must correspond by name to the parameters in the procedure that opens the cursor.</p>
<p>Note the way the variable <span class="italic">dept_number</span> is used in the following module fragment, taken from the example used earlier in this chapter:</p>
<pre>
DECLARE cursor1 CURSOR FOR 
     SELECT ename, empno, sal, comm 
     FROM emp 
     WHERE deptno = :dept_number 
 
PROCEDURE open_cursor1 (:dept_number INTEGER, SQLCODE); 
     OPEN cursor1; 
</pre>
<p>The cursor <span class="italic">declaration</span> is <span class="italic">NOT</span> terminated with a semicolon. If it is, SQL*Module generates a syntax error. <a id="sthref65"></a></p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
If the application consists of several modules, a cursor cannot be declared in one module, then referenced in another. Nevertheless, cursor names must be unique across all modules in the application.<a id="sthref66"></a></div>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref67"></a>
<h3 class="sect2"><a id="sthref68"></a>Procedure Definitions</h3>
<p>A procedure definition consists of a</p>
<ul>
<li>
<p>procedure name</p>
</li>
<li>
<p>parameter list</p>
</li>
<li>
<p>single SQL statement</p>
</li>
</ul>
<div class="sect3"><a id="sthref69"></a>
<h4 class="sect3"><a id="sthref70"></a>Procedure Name</h4>
<p>The procedure name is a SQL identifier, and should also be a legal Ada identifier. Procedure names must be unique in the application.</p>
<p>Each procedure in a module must have a distinct name. The procedure name space extends over all modules of an application, so when the application uses more than one module, each procedure must still have a distinct name.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref71"></a>
<h4 class="sect3"><a id="sthref72"></a>Parameter List</h4>
<p>The parameter list contains one or more formal parameters. Each parameter must have a distinct name, which is a SQL identifier. One of the parameters must be a status parameter: SQLSTATE or SQLCODE. It can appear anywhere in the parameter list. You can include both. See <a href="#i1007001">"Status Parameters"</a> for more information about status parameters.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref73"></a>
<h4 class="sect3"><a id="sthref74"></a>SQL92 Syntax</h4>
<p>In SQL89 Module Language, you defined a procedure using the syntax</p>
<pre>
PROCEDURE proc_name 
        &lt;param_1&gt;    &lt;datatype_1&gt; 
        &lt;param_2&gt;    &lt;datatype_2&gt; 
        SQLCODE; 
    &lt;sql_statement&gt;; 
</pre>
<p>where &lt;param_n&gt; is a formal parameter name and &lt;datatype_n&gt; is a SQL datatype. Following the SQL92 standard, SQL*Module allows the syntax</p>
<pre>
PROCEDURE proc_name ( 
        :&lt;param_1&gt;    &lt;datatype_1&gt;, 
        :&lt;param_2&gt;    &lt;datatype_2&gt;, 
        SQLSTATE | SQLCODE );
    &lt;sql_statement&gt;; 
</pre>
<p>where the parameter list is surrounded by parentheses, and parameters are separated by commas.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot mix SQL89 and SQL92 syntax. If you separate the elements of the parameter list using commas, you must also place parentheses around the parameter list.</div>
<p>When SQL*Module generates the output procedures, the formal parameters appear with the same names, and in the same order, as they appear in the module procedure. You can use the parameter access conventions appropriate for the Ada language when calling the output procedure from the application. Thus, Ada programmers can use named parameter association in place of, or in addition to, positional parameter association.<a id="sthref75"></a><a id="sthref76"></a><a id="sthref77"></a><a id="sthref78"></a></p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006810"></a>
<div class="sect1">
<h2 class="sect1">SQL Datatypes<a id="sthref79"></a><a id="sthref80"></a></h2>
<p>The following table lists the SQL and Oracle datatypes that you can use in a module parameter list. For more information about arrays, see <a href="ch_four.htm#i1008382">"Arrays as Procedure Arguments"</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref81"></a><a id="sthref82"></a>Table 2-1 Datatypes</p>
<table class="cellalignment845" title="Datatypes" summary="table" dir="ltr">
<thead>
<tr class="cellalignment839">
<th class="cellalignment846" id="r1c1-t9">SQL Datatype</th>
<th class="cellalignment846" id="r1c2-t9">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment839">
<td class="cellalignment847" id="r2c1-t9" headers="r1c1-t9">
<p>CHARACTER</p>
</td>
<td class="cellalignment847" headers="r2c1-t9 r1c2-t9">
<p>single character</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r3c1-t9" headers="r1c1-t9">
<p>CHARACTER(L)</p>
</td>
<td class="cellalignment847" headers="r3c1-t9 r1c2-t9">
<p>character string of length L bytes</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r4c1-t9" headers="r1c1-t9">
<p>DOUBLE PRECISION</p>
</td>
<td class="cellalignment847" headers="r4c1-t9 r1c2-t9">
<p>approximate numeric</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r5c1-t9" headers="r1c1-t9">
<p>INTEGER</p>
</td>
<td class="cellalignment847" headers="r5c1-t9 r1c2-t9">
<p>exact numeric, no fractional part</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r6c1-t9" headers="r1c1-t9">
<p>REAL</p>
</td>
<td class="cellalignment847" headers="r6c1-t9 r1c2-t9">
<p>approximate numeric</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r7c1-t9" headers="r1c1-t9">
<p>SMALLINT</p>
</td>
<td class="cellalignment847" headers="r7c1-t9 r1c2-t9">
<p>exact numeric, no fractional part, equal to or smaller in range than INTEGER</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r8c1-t9" headers="r1c1-t9">
<p>Oracle Datatype</p>
</td>
<td class="cellalignment847" headers="r8c1-t9 r1c2-t9">&nbsp;</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r9c1-t9" headers="r1c1-t9">
<p>VARCHAR2(L)</p>
</td>
<td class="cellalignment847" headers="r9c1-t9 r1c2-t9">
<p>variable-length character string of length L bytes</p>
</td>
</tr>
<tr class="cellalignment839">
<td class="cellalignment847" id="r10c1-t9" headers="r1c1-t9">
<p>SQL*Module Datatypes:</p>
<p>SQL_CURSOR</p>
<p>SQL_CONTEXT</p>
<p>ARRAY(N) OF SQL_CURSOR</p>
<p>ARRAY(N) OF CHARACTER</p>
<p>ARRAY(N) OF CHARACTER(L)</p>
<p>ARRAY(N) OF DOUBLE PRECISION</p>
<p>ARRAY(N) OF INTEGER</p>
<p>ARRAY(N) OF REAL</p>
<p>ARRAY(N) OF SMALLINT</p>
<p>ARRAY(N) OF VARCHAR2(L)</p>
</td>
<td class="cellalignment847" headers="r10c1-t9 r1c2-t9">
<p>cursor variable type</p>
<p>task context</p>
<p>Arrays of SQL Datatypes shown. N is the number of elements.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
CHARACTER can be abbreviated CHAR. INTEGER can be abbreviated INT.</div>
<p>The SQL standard for Module Language allows the use of only a subset of the SQL datatypes for Ada.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
All parameters for Module Language procedures must be scalars, arrays, or strings. Records and access types are not supported.</div>
</div>
<!-- class="sect1" -->
<a id="i1006889"></a>
<div class="sect1">
<h2 class="sect1">SQL Commands<a id="sthref83"></a><a id="sthref84"></a></h2>
<p>Module Language supports the following SQL statements:</p>
<ul>
<li>
<p>ALLOCATE</p>
</li>
<li>
<p>CLOSE</p>
</li>
<li>
<p>COMMIT</p>
</li>
<li>
<p>CONNECT TOs</p>
</li>
<li>
<p>CONTEXT ALLOCATE</p>
</li>
<li>
<p>CONTEXT FREE</p>
</li>
<li>
<p>DELETE</p>
</li>
<li>
<p>DISCONNECT</p>
</li>
<li>
<p>ENABLE THREADS</p>
</li>
<li>
<p>FETCH</p>
</li>
<li>
<p>INSERT</p>
</li>
<li>
<p>OPEN</p>
</li>
<li>
<p>ROLLBACK</p>
</li>
<li>
<p>SELECT</p>
</li>
<li>
<p>SET CONNECTION</p>
</li>
<li>
<p>UPDATE</p>
</li>
</ul>
<p>The DELETE and UPDATE commands may be either searched (the normal mode) or positioned (using the WHERE CURRENT OF &lt;cursor_name&gt; clause). You can use the OPEN command only for ANSI-standard cursors. You must open cursor variables on the Oracle Server, using PL/SQL code. <a id="sthref85"></a><a id="sthref86"></a></p>
</div>
<!-- class="sect1" -->
<a id="i1006913"></a>
<div class="sect1">
<h2 class="sect1">Text in a Module<a id="sthref87"></a><a id="sthref88"></a></h2>
<p>In general, Module Language is not case sensitive. You can enter keywords and identifiers in any mixture of uppercase and lowercase. However, case is significant in character string literals.</p>
<p>Text in a module file is free form. White space (spaces, tabs, and new lines) can be placed anywhere in the file to improve readability. The only exception to this is that identifiers, keywords, and string literals cannot be continued to a new line. <a id="sthref89"></a></p>
<p>The maximum length of a line in a module is 512 characters.</p>
<div class="sect2"><a id="sthref90"></a>
<h3 class="sect2"><a id="sthref91"></a>Comments</h3>
<p>SQL*Module allows comments in a module file. You can place comments anywhere that white space can appear, except in string literals.</p>
<p>There are two comment styles: SQL-style comments and C-style comments. A SQL-style comment starts with two consecutive dashes, which can appear anywhere on a line, and ends at the end of the line. For example:<a id="sthref92"></a></p>
<pre>
-- This is a SQL(or Ada)style comment. 
-- For multiline comments, you must place the comment 
-- dashes on each line. 
</pre>
<p>A C-style comment begins with a slash immediately followed by an asterisk (/*), and ends at the next occurrence of an asterisk immediately followed by a slash (*/). C-style comments can span more than one line. C-style comments cannot be nested.<a id="sthref93"></a></p>
<p>The following example demonstrates the C-style comment:</p>
<pre>
/* 
 *  This comment style is often used to 
 *  introduce a procedure. 
 */ 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006938"></a>
<div class="sect1">
<h2 class="sect1">Indicator Parameters<a id="sthref94"></a></h2>
<p>You use indicator parameters to set the null/not null status of another (associated) parameter, or to "indicate" if a column value retrieved on a query was null. In the module procedure parameter list, an indicator parameter always has a SMALLINT type. In the SQL statement, the indicator parameter follows the associated parameter, with no comma separation. The SQL92 standard allows the keyword INDICATOR to be used to separate the indicator parameter and its associated parameter.</p>
<p>In the following example, <span class="italic">grade_indic</span> is an indicator parameter:</p>
<pre>
PROCEDURE get_grade ( 
        :grade          REAL,
        :grade_indic    SMALLINT, 
        :class_number   INTEGER, 
        :student_id     INTEGER, 
        SQLCODE); 
    SELECT grade 
        INTO :grade INDICATOR :grade_indic 
        FROM enrollment
        WHERE class_no = :class_number AND student_id = :student_id; 
</pre>
<p>Following the SQL89 standard, the SELECT statement would be written without the INDICATOR keyword, as follows:</p>
<pre>
     SELECT grade
         INTO :grade :grade_indic 
         FROM enrollment
         WHERE class_no = :class_number AND student_id = :student_id; 
</pre>
<p>SQL*Module allows both uses of indicator parameters.</p>
<p>When an indicator parameter is returned from a procedure (an OUT parameter), as in the query example, its returned value has the following meanings:</p>
<p>-1</p>
<p>The Oracle column or expression is null. The value of the associated parameter (<span class="italic">grade</span> in this example) is indeterminate.</p>
<p>0</p>
<p>Oracle assigned a column or expression value to the associated parameter.</p>
<p>&gt; 0</p>
<p>For character data, Oracle passes a truncated column value in the associated parameter. The value of the indicator parameter shows the original length of the value in the database column. <a id="sthref95"></a></p>
<p>When indicator parameters are passed as IN parameters, you must set the value in your Ada program. A value of -1 means that Oracle will assign null to the column (regardless of the value of the associated parameter), and a value of zero or greater means that Oracle will use the value of the associated parameter in the UPDATE or INSERT command. Positive values greater than zero have no special meaning; they are equivalent to zero.</p>
<div class="infoboxnotewarn">
<p class="notep1">Caution:</p>
If you try to assign a null to a database column that has the NOT NULL constraint, an Oracle error is returned at runtime.</div>
<p>The following code fragment shows an Ada driver that calls a Module Language procedure with a null indicator parameter value: <a id="sthref96"></a><a id="sthref97"></a></p>
<pre>
with SQL_STANDARD; 
procedure DRV is 
  SQLCODE    : SQL_STANDARD.SQLCODE_TYPE; 
  EMPLOYEE   : string(1..10) := "SCOTT     "; 
  COMMISSION : SQL_STANDARD.REAL := 2000.0; 
  COMM_IND   : SQL_STANDARD.SMALLINT := -1; 
begin 
  . . . 
 
  UPDATE_COMMISSION(EMPLOYEE, COMMISSION, COMM_IND, SQLCODE); 
   
  . . . 
end; 
  
</pre>
<p>The corresponding Module Language procedure is:</p>
<pre>
PROCEDURE update_commission ( 
  :employee_name VARCHAR2(10), 
  :commission REAL, 
  :comm_ind SMALLINT, 
  SQLCODE); 
   
  UPDATE emp SET comm = :commission INDICATOR :comm_ind 
     WHERE ename = :employee_name; 
</pre>
<p>In this example, the parameter <span class="italic">commission</span> with a value of 2000.0 is passed to the <span class="italic">update_commission</span> procedure. But, since the indicator parameter is set to -1, employee Scott's commission is set to null in the EMP table.</p>
</div>
<!-- class="sect1" -->
<a id="i1007001"></a>
<div class="sect1">
<h2 class="sect1">Status Parameters <a id="sthref98"></a><a id="sthref99"></a><a id="sthref100"></a></h2>
<p>There are two special status parameters: SQLSTATE and SQLCODE. The status parameters return values to the calling Ada application that show if</p>
<ul>
<li>
<p>the procedure completed without error</p>
</li>
<li>
<p>an exception occurred, such as ''no data found''</p>
</li>
<li>
<p>an error occurred</p>
</li>
</ul>
<p>You can place either one or both of the status parameters anywhere in the parameter list. They are always shown last in this Guide, but that is just an informal coding convention. The status parameters are not preceded by a colon, and they do not take a datatype specification. You cannot directly access the status parameters in the SQL statement in the procedure; they are set by SQL*Module.</p>
<p>SQLSTATE is the preferred status parameter; SQLCODE is retained for compatibility with older standards.</p>
<p>For more information about the status parameters and the values they return, see <a href="ch_four.htm#i1008067">"Error Handling"</a>.</p>
<div class="sect2"><a id="sthref101"></a>
<h3 class="sect2"><a id="sthref102"></a>Error Messages</h3>
<p>SQL*Module compile time error messages have the MOD prefix. The codes and messages are listed in <a class="olink ERRMG" href="../../server.112/e17766/toc.htm"><span class="italic">Oracle Database Error Messages</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007024"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref103"></a>CONNECT Statement</h2>
<p>The connect statement associates a program with a database, and sets the <span class="italic">current connection.</span> The syntax of the command is shown in the following syntax diagram. Key words, which you must spell exactly as shown, are in upper case; tokens you supply are in lower case. If a clause is optional, it is shown off the main path, which flows to from left to right. For a more complete discussion of syntax diagrams, see <a href="appb.htm#g635096">Appendix B, "Module Language Syntax"</a>.</p>
<img width="600" height="77" src="img/adaconn.gif" alt="Description of adaconn.gif follows" title="Description of adaconn.gif follows" /><br />
<a id="sthref104" href="img_text/adaconn.htm">Description of the illustration adaconn.gif</a><br />
<br />
<p>A <span class="italic">db-env</span> (database environment) is a Oracle Net connect string or instance-alias. The <span class="italic">conn-name</span> (connection name) is optional. For multiple connections, you must specify the connection names. You can omit it if you will only use a single connection. The USING clause is optional. A <span class="italic">passwd is the password.</span></p>
<p>Connecting as DEFAULT results in a connection to Oracle by using either TWO_TASK (if it applies to your operating system) or ORACLE_SID and the account specified by the parameter <span class="italic">os_authent_prefix</span> in your file <span class="italic">init.ora</span>. The optional token <span class="italic">passwd</span> is the password.</p>
<p>The ANSI SQL92 standard does not allow <span class="italic">db-env</span> to be optional. This is an Oracle extension (which will be flagged by the FIPS option) which enables a connection to the default server as a specific user.</p>
<p>You must use Oracle Net in SQL*Module applications. Note that <span class="italic">passwd</span> can only be a variable and not a character string literal. All other variables can be either a character string literal or a variable previously defined, preceded by ":".</p>
<p>Here is a illustrative code fragment from a module named <span class="italic">demo.mad</span>, which contains the following procedure to do a connect:</p>
<pre>
...
PROCEDURE ora_connect (:dbid   VARCHAR2(14),
                       :dbname VARCHAR2(14),
                       :uid    VARCHAR2(14),
                       :pwd    VARCHAR2(14),
                       SQLCODE);
CONNECT TO :dbid AS :dbname USER :uid USING :pwd;
...

An Ada application can contain these statements to do the connect:
...
pwd : constant string := "tiger";
...
DEMO.ORA_CONNECT("inst1","RMT1","scott",PWD,SQLCODE);
if SQLCODE /= 0 then
...
</pre>
<p>For more information, see the <a class="olink NETAG" href="../../network.112/e41945/toc.htm"><span class="italic">Oracle Database Net Services Administrator's Guide</span></a>.</p>
<a id="i1007069"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref105"></a>SET CONNECTION Statement</h3>
<p>The <span class="italic">set connection</span> statement sets the current connection. Its syntax is:</p>
<p>SET CONNECTION { connection-name | DEFAULT }</p>
<p><span class="italic">DEFAULT</span> is a special case of the connection-name, '/', at the current ORACLE_SID.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007074"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref106"></a>DISCONNECT Statement</h2>
<p>The disconnect command ends an association between an application and a database environment. It can be summarized as:</p>
<p>DISCONNECT { connection-name | ALL | CURRENT | DEFAULT}</p>
<p>The full ANSI semantics are not followed. Instead of raising an exception condition if the connection has an active transaction, the transaction is (implicitly) rolled back and the connection(s) disconnected.</p>
<p>DISCONNECT ALL only disconnects connections which are established by SQLLIB (that is, by SQL*Module).</p>
<p>DISCONNECT DEFAULT and DISCONNECT <span class="italic">connection-name</span> terminate only the specified connection.</p>
<p>DISCONNECT CURRENT terminates the connection regarded by SQLLIB as the "current connection" (either the last connection established or the last connection specified in a SET CONNECTION statement).</p>
<p>After the current connection is disconnected, you must execute a set connection or a connect statement to establish a new current connection. Then you can execute any statement that requires a valid database connection.</p>
<p>You must explicitly commit or roll back the current transaction before disconnecting. If you do not commit the transaction before disconnecting, or if the program exits before committing, the current transaction is automatically rolled back.</p>
<p>Here is an example of two procedures from the module demo.mad illustrating the disconnect command:</p>
<pre>
 ...
PROCEDURE ora_disconnect (:dbname VARCHAR2(14),
                           SQLCODE) ;
   DISCONNECT :dbname;

...
PROCEDURE ora_commit(SQLCODE);
   COMMIT WORK;

these procedures are called from your application as follows:
...
DEMO.ORA_COMMIT(SQLCODE);
DEMO.ORA_DISCONNECT("RMT1", SQLCODE);
...
</pre>
<p>A required commit command was executed using the procedure ora_commit (which is also in the file demo.mad) just before the disconnect.</p>
</div>
<!-- class="sect1" -->
<a id="i1007102"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref107"></a>Multi-tasking</h2>
<p>Starting with release 8.0, multi-tasking Ada programs are supported by SQL*Module. The new commands that you use in a multi-tasking program are described in the following sections:</p>
<a id="i1007107"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref108"></a>ENABLE THREADS</h3>
<p>This command initializes the process for later use with Ada tasks. It must be called prior to the creation of any Ada tasks. It is:</p>
<pre>
ENABLE THREADS;
</pre></div>
<!-- class="sect2" -->
<a id="i1007112"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref109"></a>SQL_CONTEXT Datatype</h3>
<p>The datatype <span class="italic">SQL_CONTEXT</span> is used to support multi-tasking applications. It points to SQLLIB's runtime context. You pass the context as a parameter to SQL*Module procedures. If it is passed, then it indicates which SQLLIB runtime context will be used for execution. If no SQL_CONTEXT parameter is passed, then SQL*Module uses the global runtime context of SQLLIB.</p>
<p>For example, here is a procedure that uses <span class="italic">SQL_CONTEXT</span>:</p>
<pre>
PROCEDURE seldept (:ctx SQL_CONTEXT,
                   :dno INTEGER,
                    SQLCODE); 
    SELECT deptno INTO :dno FROM emp WHERE dname = 'SALES';
</pre>
<p>In this example, the select statement will use the runtime context pointed to by the variable <span class="italic">ctx</span>. <span class="italic">ctx</span> must have been previously allocated in a CONTEXT ALLOCATE statement. Note that you never reference the SQL_CONTEXT variable directly. It appears only in the code that SQL*Module generates.</p>
</div>
<!-- class="sect2" -->
<a id="i1007123"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref110"></a>CONTEXT ALLOCATE</h3>
<p>This command allocates storage in memory for a SQLLIB runtime context that is used to support multi-tasking. An example is:</p>
<pre>
CONTEXT ALLOCATE :ctxvar;
</pre>
<p><span class="italic">ctxvar</span> is of type SQL_CONTEXT. If sufficient storage is available, <span class="italic">ctxvar</span> will contain the address of the runtime context. Otherwise, <span class="italic">ctxvar</span> will be zero and an error will be returned in the provided status variables.</p>
</div>
<!-- class="sect2" -->
<a id="i1007130"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref111"></a>CONTEXT FREE</h3>
<p>CONTEXT FREE frees all storage associated with the SQLLIB runtime context. It does not disconnect any active connection. Prior to deallocating the runtime context, you must execute the DISCONNECT command for each active connection.</p>
<p>The CONTEXT FREE statement always succeeds and <span class="italic">ctxvar</span> is zero after execution. If the context is <span class="italic">ctxvar</span>, then, an example is:</p>
<pre>
CONTEXT FREE :ctxvar;
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref112"></a>
<h3 class="sect2"><a id="sthref113"></a>Multi-tasking Restrictions</h3>
<ul>
<li>
<p>All database connections must be established prior to task activation.</p>
</li>
<li>
<p>Multi-tasking applications cannot be used to access database stored procedures.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007139"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref114"></a>Multi-tasking Example</h2>
<p>Here is part of a module, adademo.mad:</p>
<pre>
PROCEDURE enable_threads (SQLCODE);
    ENABLE THREADS;
PROCEDURE allocate_context (:ctx SQL_CONTEXT, SQLCODE);
    CONTEXT ALLOCATE :ctx;
PROCEDURE free_context (:ctx SQL_CONTEXT, SQLCODE);
    CONTEXT FREE :ctx;
PROCEDURE disconn_db (:ctx SQL_CONTEXT,
                      :dbname VARCHAR2(14),
                      SQLCODE);
   DISCONNECT :dbname;

these procedures are called as follows:
with ADADEMO;
-- Declare contexts CTX1, CTX2
...
ADADEMO.ENABLE_THREADS(SQLCODE):

ADADEMO.ALLOCATE_CONTEXT(CTX1, SQLCODE);
ADADEMO.ALLOCATE_CONTEXT(CTX2, SQLCODE);
-- Spawn tasks that process data:
...

An example of explicitly disconnecting and freeing contexts is:
-- After processing data:
...
ADADEMO.DISCONN_DB(CTX1, DBNAM1);
ADADEMO.DISCONN_DB(CTX2, DBNAM2);
ADADEMO.FREE_CONTEXT(CTX1);
ADADEMO.FREE_CONTEXT(CTX2);

</pre></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment838">
<tr>
<td class="cellalignment847">
<table class="cellalignment843">
<tr>
<td class="cellalignment842"><a href="ch_one.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment842"><a href="ch_three.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment849">
<table class="cellalignment841">
<tr>
<td class="cellalignment842"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment842"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment842"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment842"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment842"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment842"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
