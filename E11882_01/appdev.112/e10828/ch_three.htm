<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Sample Programs</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2009-07-31T20:52:2Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Pro*FORTRAN&reg; Supplement to the Oracle Precompilers Guide" />
<meta name="dcterms.identifier" content="E10828-01" />
<meta name="dcterms.isVersionOf" content="ZZFOR" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1994, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Prev" href="ch_two.htm" title="Previous" type="text/html" />
<link rel="Next" href="ch_four.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10828.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">6/8</span> <!-- End Header --><a id="BACFGFGE"></a>
<h1 class="chapter"><span class="secnum">3</span> Sample Programs</h1>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#BABEFEAJ">Sample Program 1: Simple Query</a></p>
</li>
<li>
<p><a href="#BABCBFJC">Sample Program 2: Cursor Operations</a></p>
</li>
<li>
<p><a href="#BABGGACI">Sample Program 3: Fetching in Batches</a></p>
</li>
<li>
<p><a href="#BABHDAJD">Sample Program 4: Datatype Equivalencing</a></p>
</li>
<li>
<p><a href="#BABJCEFG">Sample Program 5: Oracle Forms User Exit</a></p>
</li>
<li>
<p><a href="#BABEBHGE">Sample Program 6: Dynamic SQL Method 1</a></p>
</li>
<li>
<p><a href="#BABBBDCC">Sample Program 7: Dynamic SQL Method 2</a></p>
</li>
<li>
<p><a href="#BABJEFEE">Sample Program 8: Dynamic SQL Method 3</a></p>
</li>
<li>
<p><a href="#BABHFAAA">Sample Program 9: Calling a Stored Procedure</a></p>
</li>
</ul>
<p>This chapter provides several embedded SQL programs to guide you in writing your own. These programs illustrate the key concepts and features of Pro*FORTRAN programming and demonstrate techniques that let you take full advantage of SQL's power and flexibility.</p>
<p>Each sample program in this chapter is available online. <a href="#CHDJECCG">Table 3-1</a> shows the usual filenames of the sample programs. However, the exact filenames are system-dependent. For specific filenames, see your Oracle system-specific documentation.</p>
<div class="tblhruleformalwide">
<p class="titleintable"><a id="sthref112"></a><a id="CHDJECCG"></a>Table 3-1 Pro*FORTAN Sample Programs</p>
<table class="cellalignment925" title="Pro*FORTAN Sample Programs" summary="filenames of sample files" dir="ltr">
<thead>
<tr class="cellalignment914">
<th class="cellalignment926" id="r1c1-t2">Filename</th>
<th class="cellalignment926" id="r1c2-t2">Demonstrates...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment914">
<td class="cellalignment920" id="r2c1-t2" headers="r1c1-t2">
<p>SAMPLE1.PFO</p>
</td>
<td class="cellalignment920" headers="r2c1-t2 r1c2-t2">
<p>a simple query</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r3c1-t2" headers="r1c1-t2">
<p>SAMPLE2.PFO</p>
</td>
<td class="cellalignment920" headers="r3c1-t2 r1c2-t2">
<p>cursor operations</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r4c1-t2" headers="r1c1-t2">
<p>SAMPLE3.PFO</p>
</td>
<td class="cellalignment920" headers="r4c1-t2 r1c2-t2">
<p>array fetches</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r5c1-t2" headers="r1c1-t2">
<p>SAMPLE4.PFO</p>
</td>
<td class="cellalignment920" headers="r5c1-t2 r1c2-t2">
<p>datatype equivalencing</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r6c1-t2" headers="r1c1-t2">
<p>SAMPLE5.PFO</p>
</td>
<td class="cellalignment920" headers="r6c1-t2 r1c2-t2">
<p>an Oracle Forms user exit</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r7c1-t2" headers="r1c1-t2">
<p>SAMPLE6.PFO</p>
</td>
<td class="cellalignment920" headers="r7c1-t2 r1c2-t2">
<p>dynamic SQL Method 1</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r8c1-t2" headers="r1c1-t2">
<p>SAMPLE7.PFO</p>
</td>
<td class="cellalignment920" headers="r8c1-t2 r1c2-t2">
<p>dynamic SQL Method 2</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r9c1-t2" headers="r1c1-t2">
<p>SAMPLE8.PFO</p>
</td>
<td class="cellalignment920" headers="r9c1-t2 r1c2-t2">
<p>dynamic SQL Method 3</p>
</td>
</tr>
<tr class="cellalignment914">
<td class="cellalignment920" id="r10c1-t2" headers="r1c1-t2">
<p>SAMPLE9.PFO</p>
</td>
<td class="cellalignment920" headers="r10c1-t2 r1c2-t2">
<p>calling a stored procedure</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<a id="BABEFEAJ"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 1: Simple Query</h2>
<p>This program connects to Oracle, prompts the user for an employee number, queries the database for the employee's name, salary, and commission, then displays the result. The program ends when the user enters a zero employee number.</p>
<pre>
PROGRAM QUERY

 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 INTEGER EMPNO
 CHARACTER*10 ENAME
 REAL SAL
 REAL COMM
 INTEGER*2 ICOMM
 EXEC SQL END DECLARE SECTION

 INTEGER TOTAL

 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

* LOG ON TO ORACLE.
 UID = 'SCOTT'
 PWD = 'TIGER'
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT *, 'CONNECTED TO ORACLE AS USER: ', UID

* QUERY LOOP REPEATS UNTIL THE USER ENTERS A 0
 TOTAL = 0
2000 CONTINUE

 PRINT *, '\NENTER EMPLOYEE NUMBER (0 TO QUIT): '
 READ '(I10)', EMPNO
 IF (EMPNO .EQ. 0) CALL SIGNOFF (TOTAL)

 EXEC SQL WHENEVER NOT FOUND GOTO 7000
 EXEC SQL SELECT ENAME, SAL, COMM
 1 INTO :ENAME, :SAL, :COMM:ICOMM
 2 FROM EMP
 3 WHERE EMPNO = :EMPNO

 PRINT *, 'EMPLOYEE SALARY COMMISSION\N',
 +'---------- ------- ----------'

 
IF (ICOMM .EQ. -1) THEN
 PRINT '(A10, 2X, F7.2, A12)', ENAME, SAL, ' NULL'
 ELSE
 PRINT '(A10, 2X, F7.2, 5X, F7.2)', ENAME, SAL, COMM
 END IF

 TOTAL = TOTAL + 1
 GOTO 2000

7000 CONTINUE

 PRINT *, 'NOT A VALID EMPLOYEE NUMBER - TRY AGAIN.'
 GOTO 2000
 END

 SUBROUTINE SIGNOFF (NUMQ)
 INTEGER NUMQ
 EXEC SQL INCLUDE SQLCA
 PRINT *, 'TOTAL NUMBER QUERIED WAS: ', NUMQ
 PRINT *, 'HAVE A GOOD DAY.'
 EXEC SQL COMMIT WORK RELEASE 
 STOP
 END

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT *, 'ORACLE ERROR DETECTED:'
 PRINT '(70A1)', SQLEMC
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABCBFJC"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 2: Cursor Operations</h2>
<p>This program connects to Oracle, declares and opens a cursor, fetches the names, salaries, and commissions of all salespeople, displays the results, then closes the cursor.</p>
<pre>
PROGRAM CURSOR

 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 CHARACTER*10 ENAME
 REAL SAL
 REAL COMM
 EXEC SQL END DECLARE SECTION

 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

* LOG ON TO ORACLE.
 UID = 'SCOTT'
 PWD = 'TIGER'
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT *, 'CONNECTED TO ORACLE AS USER:', UID

* DECLARE THE CURSOR.
 EXEC SQL DECLARE SALESPEOPLE CURSOR FOR
 1 SELECT ENAME, SAL, COMM
 2 FROM EMP
 3 WHERE JOB LIKE 'SALES%'
 EXEC SQL OPEN SALESPEOPLE

 PRINT *, 'SALESPERSON SALARY COMMISSION\N',
 +'----------- ------- ----------'

* LOOP, FETCHING ALL SALESPERSON'S STATISTICS
 EXEC SQL WHENEVER NOT FOUND DO CALL SIGNOFF
3000 EXEC SQL FETCH SALESPEOPLE INTO :ENAME, :SAL, :COMM
 PRINT '(1X, A10, 3X, F7.2, 5X, F7.2)', ENAME, SAL, COMM
 GOTO 3000
 END

 SUBROUTINE SIGNOFF
 EXEC SQL INCLUDE SQLCA
 EXEC SQL CLOSE SALESPEOPLE
 PRINT *, 'HAVE A GOOD DAY.'
 EXEC SQL COMMIT WORK RELEASE 
 STOP
 END

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT *, 'ORACLE ERROR DETECTED:'
 PRINT '(70A1)', SQLEMC
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABGGACI"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 3: Fetching in Batches</h2>
<p>This program logs on to Oracle, declares and opens a cursor, fetches in batches using arrays, and prints the results using the subroutine PRTRES.</p>
<pre>
PROGRAM ARRAYS

 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 CHARACTER*10 ENAME(5)
 INTEGER EMPNO(5)
 REAL SAL(5)
 EXEC SQL END DECLARE SECTION

* NUMBER OF ROWS RETURNED, AND NUMBER TO PRINT
 INTEGER NUMRET
 INTEGER NUMP
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

* LOG ON TO ORACLE.
 UID = 'SCOTT'
 PWD = 'TIGER'
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT *, 'CONNECTED TO ORACLE AS USER: ', UID

* DECLARE THE CURSOR, THEN OPEN IT.
 EXEC SQL DECLARE C1 CURSOR FOR
 1 SELECT EMPNO, ENAME, SAL
 2 FROM EMP
 EXEC SQL OPEN C1
 NUMRET = 0

* LOOP, FETCHING AND PRINTING BATCHES,
* UNTIL NOT FOUND BECOMES TRUE.
 EXEC SQL WHENEVER NOT FOUND GOTO 3000
2000 EXEC SQL FETCH C1 INTO :EMPNO, :ENAME, :SAL
 NUMP = SQLERD(3) - NUMRET
 CALL PRTRES (NUMP, EMPNO, ENAME, SAL)
 NUMRET = SQLERD(3)
 GOTO 2000

* PRINT FINAL SET OF ROWS, IF ANY.
3000 NUMP = SQLERD(3) - NUMRET
 IF (NUMP .GT. 0) CALL PRTRES (NUMP, EMPNO, ENAME, SAL)
 CALL SIGNOFF
 END
 SUBROUTINE PRTRES (NUMP, EMPNO, ENAME, SAL)
 INTEGER NUMP
 INTEGER EMPNO(NUMP)
 CHARACTER*10 ENAME(NUMP)
 REAL SAL(NUMP)

* PRINT HEADER.
 PRINT *, 'EMPLOYEE NUMBER EMPLOYEE NAME SALARY\N',
 +'--------------- ------------- -------'

* PRINT BATCH OF ROWS.
 DO 7000 I = 1, NUMP
 PRINT '(1X, I4, 13X, A10, 5X, F7.2)',
 + EMPNO(I), ENAME(I), SAL(I)
7000 CONTINUE
 RETURN
 END

 SUBROUTINE SIGNOFF
 EXEC SQL INCLUDE SQLCA
 EXEC SQL CLOSE C1
 PRINT *, 'HAVE A GOOD DAY.'
 EXEC SQL COMMIT WORK RELEASE 
 STOP
 END

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT *, 'ORACLE ERROR DETECTED:'
 PRINT '(70A1)', SQLEMC
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABHDAJD"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 4: Datatype Equivalencing</h2>
<p>After connecting to Oracle, this program creates a database table named IMAGE in the SCOTT account, then simulates the insertion of bitmap images of employee numbers into the table. Datatype equivalencing lets the program use the Oracle external datatype LONG RAW to represent the images. Later, when the user enters an employee number, the number's "bitmap" is selected from the IMAGE table and pseudo-displayed on the terminal screen.</p>
<pre>
PROGRAM DTYEQV
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 INTEGER EMPNO
 CHARACTER*10 ENAME
 REAL SAL
 REAL COMM
 CHARACTER*8192 BUFFER
 EXEC SQL VAR BUFFER IS LONG RAW
 INTEGER SELECTION
 EXEC SQL END DECLARE SECTION

 CHARACTER*10 REPLY

 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

* LOG ON TO ORACLE.
 UID = 'SCOTT'
 PWD = 'TIGER'
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT *, 'CONNECTED TO ORACLE AS USER: ', UID

 PRINT *, 'PROGRAM IS ABOUT TO DROP THE IMAGE ',
 +'TABLE - OK [Y/N]? '
 READ '(A10)', REPLY
 IF ((REPLY(1:1) .NE. 'Y') .AND. (REPLY(1:1) .NE. 'Y'))
 1 CALL SIGNOFF

 EXEC SQL WHENEVER SQLERROR CONTINUE
 EXEC SQL DROP TABLE IMAGE
 IF (SQLCDE .EQ. 0) THEN
 PRINT *, 'TABLE IMAGE HAS BEEN DROPPED - ',
 + 'CREATING NEW TABLE.'
 ELSE IF (SQLCDE .EQ. -942) THEN
 PRINT *, 'TABLE IMAGE DOES NOT EXIST - ',
 + 'CREATING NEW TABLE.'
 
ELSE
 CALL SQLERR
 END IF

 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR
 EXEC SQL CREATE TABLE IMAGE
 1 (EMPNO NUMBER(4) NOT NULL, BITMAP LONG RAW)
 EXEC SQL DECLARE EMPCUR CURSOR FOR
 1 SELECT EMPNO, ENAME FROM EMP
 EXEC SQL OPEN EMPCUR
 PRINT *, 'INSERTING BITMAPS INTO IMAGE FOR ALL EMPLOYEES...'

7000 CONTINUE
 EXEC SQL WHENEVER NOT FOUND GOTO 10000
 EXEC SQL FETCH EMPCUR INTO :EMPNO, :ENAME
 CALL GETIMG (EMPNO, BUFFER)
 EXEC SQL INSERT INTO IMAGE VALUES (:EMPNO, :BUFFER)
 PRINT *, 'EMPLOYEE ', ENAME, '.......... IS DONE!'
 GOTO 7000

10000 EXEC SQL CLOSE EMPCUR
 EXEC SQL COMMIT WORK
 PRINT *, 'DONE INSERTING BITMAPS. NEXT, LETS DISPLAY SOME.'

* BEGINNING OF DISPLAY LOOP
12000 SELECTION = 0
 PRINT *, '\NENTER EMPLOYEE NUMBER (0 TO QUIT):'
 READ '(I10)', SELECTION
 IF (SELECTION .EQ. 0) CALL SIGNOFF
 EXEC SQL WHENEVER NOT FOUND GOTO 16000

 EXEC SQL SELECT EMP.EMPNO, ENAME, SAL, NVL(COMM,0), BITMAP
 1 INTO :EMPNO, :ENAME, :SAL, :COMM, :BUFFER
 2 FROM EMP, IMAGE
 3 WHERE EMP.EMPNO = :SELECTION
 4 AND EMP.EMPNO = IMAGE.EMPNO
 CALL SHWIMG (BUFFER)

 PRINT *, '\NEMPLOYEE ', ENAME, ' HAS SALARY ', SAL,
 + ' AND COMMISSION ', COMM
 GOTO 12000

16000 PRINT *, 'NOT A VALID EMPLOYEE NUMBER - TRY AGAIN.'
 GOTO 12000
 END

 
 SUBROUTINE GETIMG (ENUM, BUF)
 INTEGER ENUM
 CHARACTER*8192 BUF
 INTEGER I

 DO 18000 I = 1, 8192
 BUF(I:I) = '*'
18000 CONTINUE
 END

 SUBROUTINE SHWIMG (BUF)
 CHARACTER*8192 BUF
 INTEGER I

 PRINT *, ' ***************************'
 DO 22000 I = 1, 9
 PRINT *, ' ***************************'
22000 CONTINUE
 END

 SUBROUTINE SIGNOFF
 EXEC SQL INCLUDE SQLCA
 PRINT *, 'HAVE A GOOD DAY.'
 EXEC SQL COMMIT WORK RELEASE 
 STOP
 END

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT *, 'ORACLE ERROR DETECTED:'
 PRINT '(70A1)', SQLEMC
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABJCEFG"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 5: Oracle Forms User Exit</h2>
<p>This user exit concatenates form fields. To call the user exit from a Oracle Forms trigger, use the syntax</p>
<pre>
&lt;user_exit&gt;('CONCAT &lt;field1&gt;, &lt;field2&gt;, ..., &lt;result_field&gt;');
</pre>
<p>where <span class="italic">user_exit</span> is a packaged procedure supplied with Oracle Forms and CONCAT is the name of the user exit. A sample CONCAT form invokes the user exit. For more information about Oracle Forms user exits, see Chapter 11 of the <span class="italic"><a class="olink ZZPRE" href="../e10830/toc.htm">Programmer's Guide to the Oracle Precompilers</a></span>.</p>
<p><span class="bold">Note</span>: The sample code listed is for a Oracle*Forms user exit and is not intended to be compiled in the same manner as the other sample programs listed in this chapter.</p>
<pre>
INTEGER FUNCTION CONCAT (CMD,CMDL,ERR,ERRL,INQRY)

 EXEC SQL BEGIN DECLARE SECTION
 LOGICAL*1 VALUE(81)
 LOGICAL*1 FINAL(241)
 LOGICAL*1 FIELD(81)
 EXEC SQL END DECLARE SECTION

 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR GO TO 999

 LOGICAL*1 CMD(80)
 LOGICAL*1 ERR(80)
 INTEGER*2 CMDL, ERRL, INQRY

* CERR IS A DYNAMICALLY BUILT ERROR MESSAGE RETURNED
* TO SQL*FORMS.

 LOGICAL*1 CERR(80)

* TEMPORARY VARIABLES TO DO STRING MANIPULATIONS.

 INTEGER*2 CMDCNT
 INTEGER*2 FLDCNT
 INTEGER*2 FNLCNT

* INITIALIZE VARIABLES.

 DO 1 I = 1, 81
 FIELD(I) = ' '
1 VALUE(I) = ' '
 DO 2 I = 1, 241
2 FINAL(I) = ' '
 FNLCNT = 0
* STRIP CONCAT FROM COMMAND LINE.

 CMDCNT = 7
 I = 1

* LOOP UNTIL END OF COMMAND LINE.

 DO WHILE (CMDCNT .LE. CMDL)

* PARSE EACH FIELD DELIMITED BY A COMMA.

 FLDCNT = 0
 DO WHILE ((CMD(CMDCNT) .NE. ',').AND.(CMDCNT .LE. CMDL))
 FLDCNT = FLDCNT + 1
 FIELD(FLDCNT) = CMD(CMDCNT)
 CMDCNT = CMDCNT + 1
 END DO
 IF (CMDCNT .LT. CMDL) THEN

* WE HAVE FIELD1...FIELDN. THESE ARE NAMES OF
* SQL*FORMS FIELDS; GET THE VALUE.

 EXEC TOOLS GET :FIELD INTO :VALUE

* REINITIALIZE FIELD NAME.

 DO 20 K = 1, FLDCNT
20 FIELD(K) = ' '

* MOVE VALUE RETRIEVED FROM FIELD TO A CHARACTER
* TO FIND LENGTH.

 DO WHILE (VALUE(I) .NE. ' ')
 FNLCNT = FNLCNT + 1
 FINAL(FNLCNT) = VALUE(I)
 I = I + 1
 END DO
 I = 1
 CMDCNT = CMDCNT + 1
 ELSE

* WE HAVE RESULT_FIELD; STORE IN SQL*FORMS FIELD.

 EXEC TOOLS SET :FIELD VALUES (:FINAL)
 END IF
 END DO

* ALL OK. RETURN SUCCESS CODE.

 CONCAT = IAPSUC
 RETURN

* ERROR OCCURRED. PREFIX NAME OF USER EXIT TO ORACLE
* ERROR MESSAGE, SET FAILURE RETURN CODE, AND EXIT.

999 CERR(1) = 'C'
 CERR(2) = 'O'
 CERR(3) = 'N'
 CERR(4) = 'C'
 CERR(5) = 'A'
 CERR(6) = 'T'
 CERR(7) = ':'
 CERR(8) = ' '
 DO 1000 J = 1, 70
 CERR(J + 8) = SQLEMC(J)
1000 CONTINUE
 ERRL = 78
 CALL TOOLS MESSAGE (CERR, ERRL)
 CONCAT = IAPFAI
 RETURN
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABEBHGE"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 6: Dynamic SQL Method 1</h2>
<p>This program uses dynamic SQL Method 1 to create a table, insert a row, commit the insert, then drop the table.</p>
<pre>
PROGRAM DYN1

 EXEC SQL INCLUDE SQLCA
 EXEC SQL INCLUDE ORACA
 EXEC ORACLE OPTION (ORACA=YES)
 EXEC ORACLE OPTION (RELEASE_CURSOR=YES)

 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 USERNAME
 CHARACTER*10 PASSWORD
 CHARACTER*80 DYNSTM
 EXEC SQL END DECLARE SECTION

 EXEC SQL WHENEVER SQLERROR GOTO 9000

 ORATXF = 1

 USERNAME = 'SCOTT'
 PASSWORD = 'TIGER'
 EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD
 PRINT *, 'CONNECTED TO ORACLE.'

 PRINT *, 'CREATE TABLE DYN1 (COL1 CHAR(4))'
 EXEC SQL EXECUTE IMMEDIATE
 1 'CREATE TABLE DYN1 (COL1 CHAR(4))'

 DYNSTM = 'INSERT INTO DYN1 VALUES (''TEST'')'
 PRINT *, DYNSTM
 EXEC SQL EXECUTE IMMEDIATE :DYNSTM
 EXEC SQL COMMIT WORK

 DYNSTM = 'DROP TABLE DYN1'
 PRINT *, DYNSTM
 EXEC SQL EXECUTE IMMEDIATE :DYNSTM
 EXEC SQL COMMIT RELEASE

 PRINT *, 'HAVE A GOOD DAY!'
 GOTO 9999

9000 PRINT *, '\N-- ORACLE ERROR:'
 PRINT '(70A)', SQLEMC
 PRINT '(3A, 70A)', 'IN ', ORATXC
 PRINT *, 'ON LINE', ORASLN
 PRINT '(3A, 70A)', 'OF ', ORAFNC
 EXEC SQL WHENEVER SQLERROR CONTINUE
 EXEC SQL ROLLBACK RELEASE

9999 CONTINUE
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABBBDCC"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 7: Dynamic SQL Method 2</h2>
<p>This program uses dynamic SQL Method 2 to insert two rows into the EMP table, then delete them.</p>
<pre>
PROGRAM DYN2

 EXEC SQL INCLUDE SQLCA

 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 USERNAME
 CHARACTER*10 PASSWORD
 CHARACTER*80 DYNSTM
 INTEGER*2 EMPNO
 INTEGER*2 DEPTNO1
 INTEGER*2 DEPTNO2
 EXEC SQL END DECLARE SECTION

 EXEC SQL WHENEVER SQLERROR GOTO 9000

 USERNAME = 'SCOTT'
 PASSWORD = 'TIGER'
 EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD
 PRINT *, 'CONNECTED TO ORACLE.'

 DYNSTM = 'INSERT INTO EMP (EMPNO,DEPTNO) VALUES(:V1, :V2)'
 PRINT *, DYNSTM
 EMPNO = 1234
 DEPTNO1 = 97
 PRINT *, 'V1 = ', EMPNO
 PRINT *, 'V2 = ', DEPTNO1
 EXEC SQL PREPARE S FROM :DYNSTM
 EXEC SQL EXECUTE S USING :EMPNO, :DEPTNO1
 PRINT *, 'INSERT STATEMENT EXECUTED.\N'

 EMPNO = EMPNO + 1
 DEPTNO2 = 99
 PRINT *, 'CHANGED BIND VARIABLES V1 AND V2\NV1 = ', EMPNO
 PRINT *, 'V2 = ', DEPTNO2
 PRINT *, 'EXECUTING STATEMENT AGAIN WITH NEW BIND ',
 + 'VARIABLES.'
 EXEC SQL EXECUTE S USING :EMPNO, :DEPTNO2
 PRINT *, 'DONE, NOW DELETING...\N'

 DYNSTM = 
 + 'DELETE FROM EMP WHERE DEPTNO = :V1 OR DEPTNO = :V2'

 
 PRINT *, DYNSTM
 PRINT *, 'V1 = ', DEPTNO1
 PRINT *, 'V2 = ', DEPTNO2
 EXEC SQL PREPARE S FROM :DYNSTM
 EXEC SQL EXECUTE S USING :DEPTNO1, :DEPTNO2

 EXEC SQL COMMIT RELEASE
 PRINT *, 'HAVE A GOOD DAY!'
 GOTO 9999

9000 PRINT '(70A1)', SQLEMC
 EXEC SQL WHENEVER SQLERROR CONTINUE
 EXEC SQL ROLLBACK RELEASE

9999 CONTINUE
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABJEFEE"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 8: Dynamic SQL Method 3</h2>
<p>This program uses dynamic SQL Method 3 to retrieve the names of all employees in a given department from the EMP table.</p>
<pre>
PROGRAM DYN3

 EXEC SQL INCLUDE SQLCA
 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 USERNAME
 CHARACTER*10 PASSWORD
 CHARACTER*80 DYNSTM
 CHARACTER*10 ENAME
 INTEGER*2 DEPTNO
 EXEC SQL END DECLARE SECTION
 EXEC SQL WHENEVER SQLERROR GOTO 9000

 USERNAME = 'SCOTT'
 PASSWORD = 'TIGER'
 EXEC SQL CONNECT :USERNAME IDENTIFIED BY :PASSWORD
 PRINT *, 'CONNECTED TO ORACLE.\N'

 DYNSTM = 'SELECT ENAME FROM EMP WHERE DEPTNO = :V1'
 PRINT *, DYNSTM
 DEPTNO = 10
 PRINT *, 'V1 = ', DEPTNO
 EXEC SQL PREPARE S FROM :DYNSTM
 EXEC SQL DECLARE C CURSOR FOR S
 EXEC SQL OPEN C USING :DEPTNO
 EXEC SQL WHENEVER NOT FOUND GOTO 110

 PRINT *, '\NEMPLOYEE NAME\N-------------'
100 EXEC SQL FETCH C INTO :ENAME
 PRINT *, ENAME
 GOTO 100

110 PRINT *, '\NQUERY RETURNED', SQLERD(3), ' ROWS.'
 EXEC SQL CLOSE C
 EXEC SQL COMMIT RELEASE
 PRINT *, '\NHAVE A GOOD DAY.'
 GOTO 9999

9000 PRINT '(70A1)', SQLEMC
 EXEC SQL WHENEVER SQLERROR CONTINUE
 EXEC SQL CLOSE C
 EXEC SQL ROLLBACK RELEASE

9999 CONTINUE
 END
</pre></div>
<!-- class="sect1" -->
<a id="BABHFAAA"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample Program 9: Calling a Stored Procedure</h2>
<p>Before trying the sample program, you must create a PL/SQL package named <span class="italic">calldemo</span>, by running a script named CALLDEMO.SQL, which is supplied with Pro*FORTRAN and shown in the following example. The script can be found in the Pro*FORTRAN demo library. Check your Oracle system-specific documentation for exact spelling of the script.</p>
<pre>
CREATE OR REPLACE PACKAGE calldemo AS

 TYPE name_array IS TABLE OF emp.ename%type
 INDEX BY BINARY_INTEGER;
 TYPE job_array IS TABLE OF emp.job%type
 INDEX BY BINARY_INTEGER;
 TYPE sal_array IS TABLE OF emp.sal%type
 INDEX BY BINARY_INTEGER;

 PROCEDURE get_employees(
 dept_number IN number, -- department to query
 batch_size IN INTEGER, -- rows at a time
 found IN OUT INTEGER, -- rows actually returned
 done_fetch OUT INTEGER, -- all done flag
 emp_name OUT name_array,
 job OUT job_array,
 sal OUT sal_array);

END calldemo;
/

CREATE OR REPLACE PACKAGE BODY calldemo AS

 CURSOR get_emp (dept_number IN number) IS
 SELECT ename, job, sal FROM emp
 WHERE deptno = dept_number;

 -- Procedure "get_employees" fetches a batch of employee
 -- rows (batch size is determined by the client/caller
 -- of the procedure). It can be called from other
 -- stored procedures or client application programs.
 -- The procedure opens the cursor if it is not
 -- already open, fetches a batch of rows, and
 -- returns the number of rows actually retrieved. At
 -- end of fetch, the procedure closes the cursor.

 PROCEDURE get_employees(
 dept_number IN number,
 batch_size IN INTEGER,
 found IN OUT INTEGER,
 done_fetch OUT INTEGER,
 emp_name OUT name_array,
 job OUT job_array,
 sal OUT sal_array) IS

 BEGIN
 IF NOT get_emp%ISOPEN THEN -- open the cursor if
 OPEN get_emp(dept_number); -- not already open
 END IF;

 -- Fetch up to "batch_size" rows into PL/SQL table,
 -- tallying rows found as they are retrieved. When all
 -- rows have been fetched, close the cursor and exit
 -- the loop, returning only the last set of rows found.

 done_fetch := 0; -- set the done flag FALSE
 found := 0;

 FOR i IN 1..batch_size LOOP
 FETCH get_emp INTO emp_name(i), job(i), sal(i);
 IF get_emp%NOTFOUND THEN -- if no row was found
 CLOSE get_emp;
 done_fetch := 1; -- indicate all done
 EXIT;
 ELSE
 found := found + 1; -- count row
 END IF;
 END LOOP;
 END;
END;
/
</pre>
<p>The following sample program connects to Oracle, prompts the user for a department number, then calls a PL/SQL procedure named <span class="italic">get_employees</span>, which is stored in package <span class="italic">calldemo</span>. The procedure declares three PL/SQL tables as OUT formal parameters, then fetches a batch of employee data into the PL/SQL tables. The matching actual parameters are host tables. When the procedure finishes, row values in the PL/SQL tables are automatically assigned to the corresponding elements in the host tables. The program calls the procedure repeatedly, displaying each batch of employee data, until no more data is found.</p>
<pre>
PROGRAM CALLSP

 EXEC SQL BEGIN DECLARE SECTION
 CHARACTER*10 UID
 CHARACTER*10 PWD
 INTEGER DEPTNO
 CHARACTER*10 ENAME(10)
 CHARACTER*10 JOB(10)
 REAL SAL(10)
 INTEGER ENDFLG
 INTEGER ARYSIZ
 INTEGER NUMRET
 INTEGER*4 SQLCOD
 EXEC SQL END DECLARE SECTION

 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR DO CALL SQLERR

 UID = 'SCOTT'
 PWD = 'TIGER'
 EXEC SQL CONNECT :UID IDENTIFIED BY :PWD
 PRINT *, 'CONNECTED TO ORACLE AS USER ', UID

 PRINT *, 'ENTER DEPARTMENT NUMBER: '
 READ '(I10)', DEPTNO

* INITIALIZE VARIABLES AND ARRAYS.
 ENDFLG = 0
 ARYSIZ = 10
 NUMRET = 0
 DO 4000 I = 1, ARYSIZ
 ENAME(I) = ' '
 JOB(I) = ' '
 SAL(I) = 0
4000 CONTINUE

* DISPLAY HEADER.
 PRINT *, 'EMPLOYEE NAME JOB TITLE SALARY\N',
 +'------------- --------- ------'

* LOOP, FETCHING AND PRINTING BATCHES UNTIL END-FLAG IS SET.
6000 EXEC SQL EXECUTE
 1 BEGIN
 2 CALLDEMO.GET_EMPLOYEES (:DEPTNO, :ARYSIZ,
 3 :NUMRET, :ENDFLG, :ENAME, :JOB, :SAL);
 4 END;
 5 END-EXEC

 CALL PBATCH (NUMRET, ENAME, JOB, SAL)
 IF (ENDFLG .EQ. 0) GOTO 6000
 CALL SIGNOFF
 END

*********************** SUBROUTINES *********************
* DISPLAY A BATCH OF ROWS.

 SUBROUTINE PBATCH (ROWS, ENAME, JOB, SAL)
 INTEGER ROWS
 CHARACTER*10 ENAME(ROWS)
 CHARACTER*10 JOB(ROWS)
 REAL SAL(ROWS)

 DO 8000 I = 1, ROWS
 PRINT '(1X, A10, 5X, A10, 1X, F7.2)', ENAME(I), JOB(I), SAL(I)
8000 CONTINUE
 RETURN
 END

* LOG OFF ORACLE.

 SUBROUTINE SIGNOFF
 EXEC SQL INCLUDE SQLCA
 PRINT *, 'HAVE A GOOD DAY.'
 EXEC SQL COMMIT WORK RELEASE 
 STOP
 END

* HANDLE SQL ERRORS.

 SUBROUTINE SQLERR
 EXEC SQL INCLUDE SQLCA
 EXEC SQL WHENEVER SQLERROR CONTINUE
 PRINT *, 'ORACLE ERROR DETECTED:'
 PRINT '(70A1)', SQLEMC
 EXEC SQL ROLLBACK WORK RELEASE
 STOP
 END
</pre></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment913">
<tr>
<td class="cellalignment920">
<table class="cellalignment924">
<tr>
<td class="cellalignment917"><a href="ch_two.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment917"><a href="ch_four.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1994, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment922">
<table class="cellalignment923">
<tr>
<td class="cellalignment917"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment917"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment917"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment917"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment917"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
