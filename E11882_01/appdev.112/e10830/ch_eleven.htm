<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Writing User Exits</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1" />
<meta name="dcterms.created" content="2009-07-31T19:59:55Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Programmer's Guide to the Oracle Precompilers" />
<meta name="dcterms.identifier" content="E10830-01" />
<meta name="dcterms.isVersionOf" content="ZZPRE" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ch_ten.htm" title="Previous" type="text/html" />
<link rel="Next" href="appa.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10830.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/20</span> <!-- End Header --><a id="CHDGFJHF"></a>
<h1 class="chapter"><span class="secnum">11</span> Writing User Exits</h1>
<p>This chapter contains the following:</p>
<ul>
<li>
<p><a href="#BIHIACAC">What Is a User Exit?</a></p>
</li>
<li>
<p><a href="#BIHHGDDG">Why Write a User Exit?</a></p>
</li>
<li>
<p><a href="#BIHCBFFD">Developing a User Exit</a></p>
</li>
<li>
<p><a href="#BIHFEAGE">Writing a User Exit</a></p>
</li>
<li>
<p><a href="#BIHFJHBI">Calling a User Exit</a></p>
</li>
<li>
<p><a href="#BIHBBCIB">Passing Parameters to a User Exit</a></p>
</li>
<li>
<p><a href="#BIHBBBCI">Returning Values to a Form</a></p>
</li>
<li>
<p><a href="#BIHJIHEF">An Example</a></p>
</li>
<li>
<p><a href="#BIHFEAFG">Precompiling and Compiling a User Exit</a></p>
</li>
<li>
<p><a href="#BIHBFDIE">Using the GENXTB Utility</a></p>
</li>
<li>
<p><a href="#BIHHDBAF">Linking a User Exit into SQL*Forms</a></p>
</li>
<li>
<p><a href="#BIHGGIBH">Guidelines for SQL*Forms User Exits</a></p>
</li>
<li>
<p><a href="#BIHGFBFC">EXEC TOOLS Statements</a></p>
</li>
</ul>
<p>This chapter focuses on writing user exits for your SQL*Forms and Oracle Forms applications. First, you learn the EXEC IAF statements that allow a SQL*Forms application to interface with user exits. Then, you learn how to write and link a SQL*Forms user exit. You also learn how to use EXEC TOOLS statements with Oracle Forms. (SQL*Forms does not support EXEC TOOLS.) That way, you can use EXEC IAF statements to enhance your existing applications and EXEC TOOLS statements to build new applications. The following topics are covered:</p>
<ul>
<li>
<p>Common uses for user exits</p>
</li>
<li>
<p>Writing a user exit</p>
</li>
<li>
<p>Passing values between SQL*Forms and a user exit</p>
</li>
<li>
<p>Implementing a user exit</p>
</li>
<li>
<p>Calling a user exit</p>
</li>
<li>
<p>Guidelines for SQL*Forms user exits</p>
</li>
<li>
<p>Using EXEC TOOLS statements with Oracle Forms</p>
</li>
</ul>
<p>This chapter is supplemental. For more information about user exits, see the <span class="italic">SQL*Forms Designer's Reference</span>, the <span class="italic">Oracle Forms Reference Manual, Vol. 2</span>, and your system-specific Oracle manuals.</p>
<a id="BIHIACAC"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">What Is a User Exit?</h2>
<p><a id="sthref1663"></a>A <span class="italic">user exit</span> is a host-language subroutine written by you and called by SQL*Forms to do special-purpose processing. You can embed SQL commands and PL/SQL blocks in your user exit, then precompile it as you would a host program.</p>
<p>When called by a SQL*Forms trigger, the user exit runs, then returns a status code to SQL*Forms (refer to <a href="#CHDHCGFF">Figure 11-1</a>). Your user exit can display messages on the <a id="sthref1664"></a>SQL*Forms status line, get and put field values, manipulate Oracle data, do high-speed computations and table lookups -- even log on to different databases.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDHCGFF"></a>Figure 11-1 SQL*Forms</p>
<img width="536" height="447" src="img/image014.gif" alt="SQL*Forms" title="SQL*Forms" /><br />
<a id="sthref1665" href="img_text/image014.htm">Description of "Figure 11-1 SQL*Forms "</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="BIHHGDDG"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Why Write a User Exit?</h2>
<p>SQL*Forms Version 3 enables use PL/SQL blocks in triggers. So, in most cases, instead of calling a user exit, you can use the procedural power of PL/SQL. If the need arises, you can call user exits from a PL/SQL block with the <code>USER_EXIT</code> function.</p>
<p>User exits are harder to write and implement than SQL, PL/SQL, or SQL*Forms commands. So, you will probably use them only to do processing that is beyond the scope of SQL, PL/SQL, and SQL*Forms. Some <a id="sthref1666"></a>common uses follow:</p>
<ul>
<li>
<p>Operations more quickly or easily performed in third generation languages like C and FORTRAN (for example, numeric integration)</p>
</li>
<li>
<p>Controlling real time devices or processes (for example, issuing a sequence of instructions to a printer or graphics device)</p>
</li>
<li>
<p>Data manipulations that need extended procedural capabilities (for example, recursive sorting)</p>
</li>
<li>
<p>Special file I/O operations</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BIHCBFFD"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1667"></a>Developing a User Exit</h2>
<p>This section outlines the way to develop a SQL*Forms user exit; later sections go into more detail. For information about EXEC TOOLS statements, which are available with Oracle Forms, see <a href="#BIHGFBFC">EXEC TOOLS Statements</a>''</p>
<p>To incorporate a user exit into a form, you take the following steps:</p>
<p>1. Write the user exit in a supported host language.</p>
<p>2. Precompile the source code.</p>
<p>3. Compile the modified source code.</p>
<p>4. Use the GENXTB utility to create a database table, IAPXTB.</p>
<p>5. Use the GENXTB form in SQL*Forms to insert your user exit information into the database table.</p>
<p>6. Use the GENXTB utility to read the information from the table and create an IAPXIT source module. Then, compile the source module.</p>
<p>7. Create a new IAP (the SQL*Forms component that runs a form) by linking the standard IAP object modules, your user exit object module, and the IAPXIT object module created in step 6.</p>
<p>8. In the form, define a trigger to call the user exit.</p>
<p>9. Instruct operators to use the new IAP when running the form. This is unnecessary if the new IAP replaces the standard one. For details, refer to your system-specific Oracle manuals.</p>
</div>
<!-- class="sect1" -->
<a id="BIHFEAGE"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Writing a User Exit</h2>
<p><a id="sthref1668"></a>You can use the following kinds of statements to write your SQL*Forms user exit:</p>
<ul>
<li>
<p>host-language</p>
</li>
<li>
<p>EXEC SQL</p>
</li>
<li>
<p>EXEC ORACLE</p>
</li>
<li>
<p>EXEC IAF GET</p>
</li>
<li>
<p>EXEC IAF PUT</p>
</li>
</ul>
<p>This section focuses on the EXEC IAF <code>GET</code> and <code>PUT</code> statements, which let you pass values between SQL*Forms and a user exit.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1669"></a>
<h3 class="sect2"><a id="sthref1670"></a>Requirements for Variables</h3>
<p><a id="sthref1671"></a>The variables used in EXEC IAF statements must correspond to field names used in the form definition. If a field reference is ambiguous because you did not specify a block name, you get an error. An invalid or ambiguous reference to a form field generates an error.</p>
<p>Host variables must be named in the user exit Declare Section and must be prefixed with a colon (:) in EXEC IAF statements.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
: Indicator variables are <span class="italic">not</span> allowed in EXEC IAF <code>GET</code> and <code>PUT</code> statements.</div>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1672"></a>
<h3 class="sect2">The <a id="sthref1673"></a>IAF GET Statement</h3>
<p><a id="sthref1674"></a>This statement allows your user exit to "get" values from fields on a form and assign them to host variables. The user exit can then use the values in calculations, data manipulations, updates, and so on. The syntax of the <code>GET</code> statement follows:</p>
<pre>
EXEC IAF GET field_name1, field_name2, ...
 INTO :host_variable1, :host_variable2, ...;
</pre>
<p>where <span class="italic">field_name</span> can be any of the following SQL*Forms variables:</p>
<ul>
<li>
<p>field</p>
</li>
<li>
<p>block.field</p>
</li>
<li>
<p>system variable</p>
</li>
<li>
<p>global variable</p>
</li>
<li>
<p>host variable (prefixed with a colon) containing the value of a field, block.field, system variable, or global variable</p>
</li>
</ul>
<p>If <span class="italic">field_name</span> is not qualified, it must be unique.</p>
<p><a id="sthref1675"></a>The following example shows how a user exit GETs a field value and assigns it to a host variable:</p>
<pre>
EXEC IAF GET employee.job INTO :new_job;
</pre>
<p>All field values are character strings. If it can, <code>GET</code> converts a field value to the datatype of the corresponding host variable. If an illegal or unsupported datatype conversion is attempted, an error is generated.</p>
<p><a id="sthref1676"></a>In the last example, a constant is used to specify <span class="italic">block.field</span>. You can also use a host string to specify block and field names, as follows:</p>
<pre>
set blkfld = 'employee.job';
EXEC IAF GET :blkfld INTO :new_job;
</pre>
<p>Unless the field is unique, the host string must contain the full <span class="italic">block.field</span> reference with intervening period. For example, the following usage is <span class="italic">invalid</span>:</p>
<pre>
set blk = 'employee';
set fld = 'job';
EXEC IAF GET :blk.:fld INTO :new_job;
</pre>
<p>You can mix explicit and stored field names in a <code>GET</code> statement field list, but not in a single field reference. For example, the following usage is <span class="italic">invalid</span>:</p>
<pre>
set fld = 'job';
EXEC IAF GET employee.:fld INTO :new_job;
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1677"></a>
<h3 class="sect2">The IAF PUT Statement</h3>
<p><a id="sthref1678"></a>This statement allows your user exit to put the values of constants and host variables into fields on a form. Thus, the user exit can display on the SQL*Forms screen any value or message you like. The syntax of the <code>PUT</code> statement follows:</p>
<pre>
EXEC IAF PUT field_name1, field_name2, ...
 VALUES (:host_variable1, :host_variable2, ...);
</pre>
<p>where <span class="italic">field_name</span> can be any of the following SQL*Forms variables:</p>
<ul>
<li>
<p>field</p>
</li>
<li>
<p>block.field</p>
</li>
<li>
<p>system variable</p>
</li>
<li>
<p>global variable</p>
</li>
<li>
<p>host variable (prefixed with a colon) containing the value of a field, block.field, system variable, or global variable</p>
</li>
</ul>
<p><a id="sthref1679"></a>The following example shows how a user exit PUTs the values of a numeric constant, string constant, and host variable into fields on a form:</p>
<pre>
EXEC IAF PUT employee.number, employee.name, employee.job
 VALUES (7934, 'MILLER', :new_job);
</pre>
<p><a id="sthref1680"></a>Like <code>GET</code>, <code>PUT</code> lets you use a host string to specify block and field names, as follows:</p>
<pre>
set blkfld = 'employee.job';
EXEC IAF PUT :blkfld VALUES (:new_job);
</pre>
<p>On character-mode terminals, a value <code>PUT</code> into a field is displayed when the user exit returns, rather than when the assignment is made, provided the field is on the current display page. On block-mode terminals, the value is displayed the next time a field is read from the device.</p>
<p>If a user exit changes the value of a field several times, only the last change takes effect.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BIHFJHBI"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Calling <a id="sthref1681"></a>a User Exit</h2>
<p>You call a user exit from a SQL*Forms trigger using a packaged procedure named <code>USER_EXIT</code> (supplied with SQL*Forms). The syntax you use is</p>
<pre>
USER_EXIT(user_exit_string [, error_string]);
</pre>
<p>where <span class="italic">user_exit_string</span> contains the name of the user exit plus optional parameters and <span class="italic">error_string</span> contains an error message issued by SQL*Forms if the user exit fails. For example, the following trigger command calls a user exit named <code>LOOKUP</code>:</p>
<pre>
USER_EXIT('LOOKUP');
</pre>
<p>Notice that the user exit string is enclosed by single (not double) quotes.</p>
</div>
<!-- class="sect1" -->
<a id="BIHBBCIB"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1682"></a>Passing Parameters to a User Exit</h2>
<p>When you call a user exit, SQL*Forms passes it the following parameters automatically:</p>
<p>Command Line is the user exit string.</p>
<p>Command Line Length is the length (in characters) of the user exit string.</p>
<p>Error Message is the error string (failure message) if one is defined.</p>
<p>Error Message Length is the length of the error string.</p>
<p>In-Query is a Boolean value indicating whether the exit was called in normal or query mode.</p>
<p>However, the user exit string enables pass additional parameters to the user exit. For example, the following trigger command passes two parameters and an error message to the user exit <code>LOOKUP</code>:</p>
<pre>
USER_EXIT('LOOKUP 2025 A', 'Lookup failed');
</pre>
<p>You can use this feature to pass field names to the user exit, as the following example shows:</p>
<pre>
USER_EXIT('CONCAT firstname, lastname, address');
</pre>
<p>However, it is up to the user exit, not SQL*Forms, to parse the user exit string.</p>
</div>
<!-- class="sect1" -->
<a id="BIHBBBCI"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1683"></a>Returning Values to a Form</h2>
<p><a id="sthref1684"></a>When a user exit returns control to SQL*Forms, it must also return a code indicating whether it succeeded, failed, or suffered an irrecoverable error. The return code is an integer <a id="sthref1685"></a>constant generated by precompiler (refer to this section: <a href="#BIHJIHEF">An Example</a>). The three results have the following meanings:</p>
<p>Success: The user exit encountered no errors. SQL*Forms proceeds to the <span class="italic">success</span> label or the next step, unless the <a id="sthref1686"></a>Reverse Return Code switch is set by the calling trigger step.</p>
<p>Failure: The user exit detected an error, such as an invalid value in a field. An optional message passed by the exit appears on the message line at the bottom of the <a id="sthref1687"></a>SQL*Forms screen and on the Display Error screen. SQL*Forms responds as it does to a SQL statement that affects no rows.</p>
<p>Fatal error: The user exit detected a condition that makes further processing impossible, such as an execution error in a SQL statement. An optional error message passed by the exit appears on the SQL*Forms Display Error screen. SQL*Forms responds as it does to an irrecoverable SQL error.</p>
<p>If a user exit changes the value of a field, then returns a <span class="italic">failure</span> or <span class="italic">fatal error</span> code, SQL*Forms does <span class="italic">not</span> discard the change. Nor does SQL*Forms discard changes when the Reverse Return Code switch is set and a <span class="italic">success</span> code is returned.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1688"></a>
<h3 class="sect2">The <a id="sthref1689"></a>IAP Constants</h3>
<p>The precompiler generates three symbolic constants for use as return codes. They are prefixed with IAP. For example, the three constants might be IAPSUCC, IAPFAIL, and IAPFTL.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1690"></a>
<h3 class="sect2">Using <a id="sthref1691"></a>the SQLIEM Function</h3>
<p>By calling the function SQLIEM, your user exit can specify an error message that SQL*Forms will display on the message line if the trigger step fails or on the Display Error screen if the step causes an irrecoverable error. The specified message replaces any message defined for the step.</p>
<p>The syntax of the SQLIEM function call is</p>
<pre>
SQLIEM (error_message, message_length);
</pre>
<p>where <span class="italic">error_message</span> and <span class="italic">message_length</span> are character and integer variables, respectively. The Oracle Precompilers generate the appropriate external function declaration for you. You pass both parameters by reference; that is, you pass their addresses, not their values. SQLIEM is a SQL*Forms function; it cannot be called from other Oracle tools.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1692"></a>
<h3 class="sect2"><a id="sthref1693"></a>Using WHENEVER</h3>
<p>You can use the <code>WHENEVER</code> statement in an exit to detect invalid datatype conversions (SQLERROR), truncated values <code>PUT</code> into form fields (SQLWARNING), and queries that return no rows (<code>NOT</code> <code>FOUND</code>).</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BIHJIHEF"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">An <a id="sthref1694"></a>Example</h2>
<p>The following example shows how a typical user exit is coded. Notice that, like a host program, the user exit has a Declare Section and a SQLCA.</p>
<pre>
-- subroutine MYEXIT
EXEC SQL BEGIN DECLARE SECTION;
 field1 CHARACTER(20);
 field2 CHARACTER(20);
 value1 CHARACTER(20);
 value2 CHARACTER(20);
 result_val CHARACTER(20);
EXEC SQL END DECLARE SECTION;
 errmsg CHARACTER(80);
 errlen INTEGER;
EXEC SQL INCLUDE SQLCA;
EXEC SQL WHENEVER SQLERROR GOTO sqlerror;
-- get field values from form
EXEC IAF GET :field1, :field2 INTO :value1, :value2;
-- manipulate values to obtain result_val
-- put result_val into form field
EXEC IAF PUT result VALUES (:result_val);
return(IAPSUCC); -- trigger step succeeded
sqlerror:
 set errmsg = CONCAT('MYEXIT: ', sqlca.sqlerrm.sqlerrmc);
 set errlen = LENGTH(errmsg);
 sqliem(errmsg, errlen); -- pass error message to SQL*Forms
 return(IAPFAIL); -- trigger step failed
</pre>
<p>For a complete host-language example, see your host -language supplement.</p>
</div>
<!-- class="sect1" -->
<a id="BIHFEAFG"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Precompiling and Compiling a User Exit</h2>
<p>User exits are precompiled like standalone host programs. Refer to <a href="ch_six.htm#BABDDACC">Chapter 6, "Running the Oracle Precompilers"</a></p>
<p>For instructions on compiling a user exit, see your system-specific Oracle manuals.</p>
</div>
<!-- class="sect1" -->
<a id="BIHBFDIE"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Us<a id="sthref1695"></a>ing the GENXTB Utility</h2>
<p><a id="sthref1696"></a>The IAP program table IAPXTB in module IAPXIT contains an entry for each user exit linked into IAP. IAPXTB tells IAP the name, location, and host language of each user exit. When you add a new user exit to IAP, you must add a corresponding entry to IAPXTB.</p>
<p>IAPXTB is derived from a database table, also named IAPXTB. You can modify the database table by running the GENXTB form on the operating system command line, as follows:</p>
<pre>
RUNFORM GENXTB username/password
</pre>
<p>A form is displayed that enables you to enter the following information for each user exit you define:</p>
<ul>
<li>
<p>exit name</p>
</li>
<li>
<p>host-language code (<code>COB</code>, <code>FOR</code>, <code>PAS</code>, or <code>PLI</code>)</p>
</li>
<li>
<p>date created</p>
</li>
<li>
<p>date last modified</p>
</li>
<li>
<p>comments</p>
</li>
</ul>
<p>After modifying the IAPXTB database table, use the GENXTB utility to read the table and create an Assembler or C source program that defines the module IAPXIT and the IAPXTB program table it contains. The source language used depends on your operating system. The syntax you use to run the GENXTB utility is</p>
<pre>
GENXTB username/password outfile
</pre>
<p>where <span class="italic">outfile</span> is the name you give the Assembler or source program that GENXTB creates.</p>
</div>
<!-- class="sect1" -->
<a id="BIHHDBAF"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1697"></a>Linking a User Exit into SQL*Forms</h2>
<p>Before running a form that calls a user exit, you must link the user exit into IAP. The user exit can be linked into your standard version of IAP or into a special version for those forms that call the exit.</p>
<p>To produce a new executable copy of <a id="sthref1698"></a>IAP, link your user exit object module, the standard IAP modules, the IAPXIT module, and any modules needed from the Oracle and host-language link libraries. The details of linking are system-dependent, so check your system-specific Oracle manuals.</p>
</div>
<!-- class="sect1" -->
<a id="BIHGGIBH"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1699"></a>Guidelines for SQL*Forms User Exits</h2>
<p><a id="sthref1700"></a>The guidelines in this section will help you avoid some common pitfalls.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1701"></a>
<h3 class="sect2"><a id="sthref1702"></a>Naming the Exit</h3>
<p><a id="sthref1703"></a>The name of your user exit cannot be an Oracle reserved word. Also avoid using names that conflict with the names of SQL*Forms commands, function codes, and externally defined names used by SQL*Forms.</p>
<p>SQL*Forms converts the name of a user exit to upper case before searching for the exit. Therefore, the exit name must be in upper case in your source code if your host language is case-sensitive.</p>
<p>The name of the user exit entry point in the source code becomes the name of the user exit itself. The exit name must be a valid file name for your host language and operating system.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1704"></a>
<h3 class="sect2">Connecting to Oracle</h3>
<p>User exits communicate with Oracle through the connection made by SQL*Forms. However, a user exit can establish additional connections to any database through SQL*Net. For more information, refer to <a href="ch_three.htm#BABCBHAA">Concurrent Logons</a>".</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1705"></a>
<h3 class="sect2">Issuing I/O Calls</h3>
<p>SQL*Forms I/O routines might conflict with host-language printer I/O routines. If they do, your user exit will be unable to issue printer I/O calls. File I/O is supported but screen I/O is not.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1706"></a>
<h3 class="sect2">Using Host Variables</h3>
<p>Restrictions on the use of host variables in a standalone program also apply to user exits. Host variables must be named in the user exit Declare Section and must be prefixed with a colon in EXEC SQL and EXEC IAF statements. However, the use of host arrays is not allowed in EXEC IAF statements.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1707"></a>
<h3 class="sect2">Updating Tables</h3>
<p>Generally, a user exit should not <code>UPDATE</code> database tables associated with a form. For example, suppose an operator updates a record in the SQL*Forms work space, then a user exit <code>UPDATEs</code> the corresponding row in the associated database table. When the transaction is <code>COMMITted</code>, the record in the SQL*Forms work space is applied to the table, overwriting the user exit <code>UPDATE</code>.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1708"></a>
<h3 class="sect2">Issuing Commands</h3>
<p>Avoid issuing a <code>COMMIT</code> or <code>ROLLBACK</code> command from your user exit because Oracle will commit or roll back work begun by the SQL*Forms operator, not just work done by the user exit. Instead, issue the <code>COMMIT</code> or <code>ROLLBACK</code> from the SQL*Forms trigger. This also applies to data definition commands (such as <code>ALTER</code> <code>and CREATE</code>) because they issue an implicit <code>COMMIT</code> before and after executing.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BIHGFBFC"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1709"></a>EXEC TOOLS<a id="sthref1710"></a> Statements</h2>
<p><a id="sthref1711"></a>EXEC <code>TOOLS</code> statements support the basic <a id="sthref1712"></a>Oracle Toolset (<a id="sthref1713"></a>Oracle Forms, Oracle Reports, and Oracle Graphics) by providing a generic way to handle get, set, and exception callbacks from user exits. The following discussion focuses on Oracle Forms but the same concepts apply to Oracle Reports and Oracle Graphics.</p>
<p>Besides EXEC SQL, EXEC ORACLE, and host language statements, you can use the following EXEC TOOLS statements to write an Oracle Forms user exit:</p>
<ul>
<li>
<p><code>SET</code></p>
</li>
<li>
<p><code>GET</code></p>
</li>
<li>
<p><code>SET CONTEXT</code></p>
</li>
<li>
<p><code>GET CONTEXT</code></p>
</li>
<li>
<p><code>MESSAGE</code></p>
</li>
</ul>
<p>The EXEC <code>TOOLS</code> <code>GET</code> and <code>SET</code> statements replace the EXEC IAF <code>GET</code> and <code>PUT</code> statements used with SQL*Forms. Unlike IAF GET and <code>PUT</code>, <code>TOOLS</code> <code>GET</code> and <code>SET</code> <a id="sthref1714"></a>accept indicator variables. The EXEC <code>TOOLS</code> <code>MESSAGE</code> statement replaces the message-handling function SQLIEM. The EXEC <code>TOOLS</code> <code>SET</code> <code>CONTEXT</code> and <code>GET</code> <code>CONTEXT</code> statements are new and not available with SQL*Forms, Version 3.</p>
<div class="infoboxnotealso">
<p class="notep1">Note:</p>
COBOL and FORTRAN do not have a pointer datatype, so you cannot use the <code>SET</code> <code>CONTEXT</code> and <code>GET</code> <code>CONTEXT</code> statements in a Pro*COBOL or Pro*FORTRAN program.</div>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1715"></a>
<h3 class="sect2">EXEC TOOLS SET<a id="sthref1716"></a></h3>
<p><a id="sthref1717"></a>The EXEC <code>TOOLS</code> <code>SET</code> statement passes values from your user exit to Oracle Forms. Specifically, it assigns the values of host variables and constants to Oracle Forms variables and items. The values are displayed after the user exit returns control to the form.</p>
<p>To code the EXEC <code>TOOLS</code> <code>SET</code> statement, you use the syntax</p>
<pre>
EXEC TOOLS SET form_variable[, ...]
 VALUES ({:host_variable[:indicator] | constant}[, ...]);
</pre>
<p>where <span class="italic">form_variable</span> is an Oracle Forms field, parameter, system variable, or global variable, or a host variable (prefixed with a colon) containing the name of one of the foregoing items.</p>
<p>In the following Pro*C example, your user exit passes an employee name (with optional indicator) to Oracle Forms:</p>
<pre>
EXEC SQL BEGIN DECLARE SECTION;
 ...
 char ename[20];
 short ename_ind;
EXEC SQL END DECLARE SECTION;
...
strcpy(ename, "MILLER");
ename_ind = 0;
EXEC TOOLS SET emp.ename VALUES (:ename:ename_ind);
</pre>
<p>In this example, <span class="italic">emp.ename</span> is an Oracle Forms block.field.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1718"></a>
<h3 class="sect2">EXEC TOOLS GET<a id="sthref1719"></a></h3>
<p>The EXEC <code>TOOLS</code> <code>GET</code> statement passes values from Oracle Forms to your user exit. Specifically, it assigns the values of Oracle Forms variables and items to host variables. As soon as the values are passed, the user exit can use them for any purpose.</p>
<p>To code the EXEC <code>TOOLS</code> <code>GET</code> statement, you use the syntax</p>
<pre>
EXEC TOOLS GET form_variable[, ...]
 INTO :host_variable[:indicator][, ...];
</pre>
<p>where <span class="italic">form_variable</span> is an Oracle Forms field, parameter, system variable, or global variable, or a host variable containing the name of one of the foregoing items.</p>
<p>In the following example, Oracle Forms passes an employee name from the block.field <span class="italic">emp.ename</span> to your user exit:</p>
<pre>
EXEC SQL BEGIN DECLARE SECTION;
 ...
 char ename[20];
EXEC SQL END DECLARE SECTION;
...
EXEC TOOLS GET emp.ename INTO :ename;
</pre></div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1720"></a>
<h3 class="sect2">EXEC TOOLS SET CONTEXT<a id="sthref1721"></a></h3>
<p>The EXEC <code>TOOLS</code> <code>SE</code>T <code>CONTEXT</code> statement lets you save context information from one user exit call to another. <code>SET</code> <code>CONTEXT</code> names a host-language pointer variable that you can reference later in an EXEC <code>TOOLS</code> <code>GET</code> <code>CONTEXT</code> statement. The pointer variable points to the block of memory in which the context information is stored. With the <code>SET</code> <code>CONTEXT</code> statement, you need not declare a global variable to hold the information.</p>
<p>To code the EXEC <code>TOOLS</code> <code>SET</code> <code>CONTEXT</code> statement, use the syntax</p>
<pre>
EXEC TOOLS SET CONTEXT :host_pointer_variable
 [IDENTIFIED] BY context_name;
</pre>
<p>where the optional keyword IDENTIFIED can be used to improve readability and <span class="italic">context_name</span> is an undeclared identifier or a character host variable that names the context area.</p>
<p>In the following example, your user exit saves context information for later use:</p>
<pre>
EXEC SQL BEGIN DECLARE SECTION;
 ...
 char context1[30];
EXEC SQL END DECLARE SECTION;
...
strcpy(context1, "This is context1");
EXEC TOOLS SET CONTEXT :context1 BY my_app1;
</pre>
<p>In this example, the context name <span class="italic">my_app1</span> is an undeclared identifier. Note that in C, when a char array is used as an argument, the array name is synonymous with a pointer to that array.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1722"></a>
<h3 class="sect2">EXEC TOOLS GET CONTEXT<a id="sthref1723"></a></h3>
<p>The EXEC <code>TOOLS</code> <code>GET</code> <code>CONTEXT</code> statement retrieves the value of a host-language pointer variable into your user exit. The pointer variable points to a block of memory in which context information is stored.</p>
<p>To code the EXEC <code>TOOLS</code> <code>GET</code> <code>CONTEXT</code> statement, use the syntax</p>
<pre>
EXEC TOOLS GET CONTEXT context_name INTO :host_pointer_variable;
</pre>
<p>where <span class="italic">context_name</span> is an undeclared identifier or a character host variable that names the context area.</p>
<p>In the following Pro*C example, your user exit retrieves a pointer to context information saved earlier:</p>
<pre>
EXEC SQL BEGIN DECLARE SECTION;
 ...
 char *ctx_ptr;
EXEC SQL END DECLARE SECTION;
...
EXEC TOOLS GET CONTEXT my_app1 INTO :ctx_ptr;
</pre>
<p>In this example, the context name <span class="italic">my_app1</span> is an undeclared identifier.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1724"></a>
<h3 class="sect2">EXEC TOOLS MESSAGE<a id="sthref1725"></a></h3>
<p>The EXEC <code>TOOLS</code> <code>MESSAGE</code> statement passes a message from your user exit to Oracle Forms. The message is displayed on the Oracle Forms message line after the user exit returns control to the form.</p>
<p>To code the EXEC <code>TOOLS</code> <code>MESSAGE</code> statement, you use the syntax</p>
<pre>
EXEC TOOLS MESSAGE message_text [severity_code];
</pre>
<p>where <span class="italic">message_text</span> is a quoted string or a character host variable, and the optional <span class="italic">severity_code</span> is an integer constant or host variable. The <code>MESSAGE</code> statement does <span class="italic">not</span> accept indicator variables.</p>
<p>In the following Pro*C example, your user exit passes an error message and severity code to Oracle Forms:</p>
<pre>
EXEC TOOLS MESSAGE 'Bad field name! Please reenter.' 15;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1112">
<tr>
<td class="cellalignment1121">
<table class="cellalignment1117">
<tr>
<td class="cellalignment1116"><a href="ch_ten.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1116"><a href="appa.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1123">
<table class="cellalignment1115">
<tr>
<td class="cellalignment1116"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1116"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1116"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1116"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1116"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1116"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
