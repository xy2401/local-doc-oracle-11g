<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Network Data Model Overview</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1023" />
<meta name="description" content="Provides usage and reference information about the Topology Data Model and Network Data Model Graph features of Oracle Spatial and Graph." />
<meta name="dcterms.created" content="2014-07-09T11:54:32Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Spatial Topology and Network Data Models Developer's Guide" />
<meta name="dcterms.identifier" content="E11831-07" />
<meta name="dcterms.isVersionOf" content="TOPOL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2003, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="sdo_prtnet.htm" title="Previous" type="text/html" />
<link rel="Next" href="sdo_net_ref.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e11831.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/17</span> <!-- End Header -->
<div id="TOPOL700" class="chapter"><a id="CIHHEDAC"></a>
<h1 class="chapter"><span class="secnum">5</span> Network <a id="sthref720"></a>Data Model Overview</h1>
<p>This chapter explains the concepts and operations related to the Oracle Spatial network data model. It assumes that you are familiar with the main Oracle Spatial concepts, data types, and operations, as documented in <a class="olink SPATL" href="../e11830/toc.htm"><span class="italic">Oracle Spatial Developer's Guide</span></a>:</p>
<p>Although this chapter discusses some network-related terms as they relate to Oracle Spatial, it assumes that you are familiar with basic network data modeling concepts.</p>
<p>This chapter contains the following major sections:</p>
<ul>
<li>
<p><a href="#CIHIHCHB">Section 5.1, "Introduction to Network Modeling"</a></p>
</li>
<li>
<p><a href="#CIHECEEF">Section 5.2, "Main Steps in Using the Network Data Model"</a></p>
</li>
<li>
<p><a href="#CIHFIHFB">Section 5.3, "Network Data Model Concepts"</a></p>
</li>
<li>
<p><a href="#CIHFBAFJ">Section 5.4, "Network Applications"</a></p>
</li>
<li>
<p><a href="#CIHDHHGB">Section 5.5, "Network Hierarchy"</a></p>
</li>
<li>
<p><a href="#CIHJFIIG">Section 5.6, "Network Constraints"</a></p>
</li>
<li>
<p><a href="#CIHFHAID">Section 5.7, "Network Analysis Using Load on Demand"</a></p>
</li>
<li>
<p><a href="#CIHBJBFI">Section 5.8, "Network Editing and Analysis Using the In-Memory Approach"</a></p>
</li>
<li>
<p><a href="#CIHEDHIF">Section 5.9, "Network Data Model Tables"</a></p>
</li>
<li>
<p><a href="#CIHIAIJC">Section 5.10, "Network Data Model Metadata Views"</a></p>
</li>
<li>
<p><a href="#CIHBHIGC">Section 5.11, "Network Data Model Application Programming Interface"</a></p>
</li>
<li>
<p><a href="#CIHCBJGB">Section 5.12, "Cross-Schema Network Access"</a></p>
</li>
<li>
<p><a href="#CIHDIBDE">Section 5.13, "Network Examples"</a></p>
</li>
<li>
<p><a href="#CIHDIHEA">Section 5.14, "Network Data Model Tutorial and Other Resources"</a></p>
</li>
<li>
<p><a href="#CIHHDBHJ">Section 5.15, "README File for Spatial and Related Features"</a></p>
</li>
</ul>
<a id="CIHIHCHB"></a>
<div id="TOPOL888" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.1</span> Introduction to Network Modeling</h2>
<p>In many applications, capabilities or objects are modeled as nodes and links in a network. The network model contains logical information such as connectivity relationships among nodes and links, directions of links, and costs of nodes and links. With logical network information, you can analyze a network and answer questions, many of them related to path computing and tracing. For example, for a biochemical pathway, you can find all possible reaction paths between two chemical compounds; or for a road network, you can find the following information:</p>
<ul>
<li>
<p>What is the shortest (distance) or fastest (travel time) path between two cities?</p>
</li>
<li>
<p>What is the closest hotel to a specific airport, and how can I get there?</p>
</li>
</ul>
<p>In addition to logical network information, spatial information such as node locations and link geometries can be associated with the network. This information can help you to model the logical information (such as the cost of a route, because its physical length can be directly computed from its spatial representation).</p>
<p><a id="sthref721"></a>The Spatial network data model can be used for large, complex networks. For example, <a href="#CIHJIIID">Figure 5-1</a> shows New York City nodes and links, which have been defined using the network data model, displayed using the Network Editor demo tool (described in <a href="#CIHDIHEA">Section 5.14</a>).</p>
<div id="TOPOL889" class="figure">
<p class="titleinfigure"><a id="CIHJIIID"></a>Figure 5-1 New York City Nodes and Links</p>
<img width="499" height="480" src="img/ndm_nyc.gif" alt="Description of Figure 5-1 follows" /><br />
<a id="sthref722" href="img_text/ndm_nyc.htm">Description of "Figure 5-1 New York City Nodes and Links"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The generic data model and network analysis capability can model and analyze many kinds of network applications in addition to traditional geographical information systems (GIS). For example, in biochemistry, applications may need to model reaction pathway networks for living organisms; and in the pharmaceutical industry, applications that model the drug discovery process may need to model protein-protein interaction.</p>
<p>The network modeling capabilities of Spatial include schema objects and an application programming interface (API). The schema objects include metadata and network tables. The API includes a server-side PL/SQL API (the SDO_NET and SDO_NET_MEM packages) for creating, managing, editing, and analyzing networks in the database, and a middle-tier (or client-side) Java API for network editing and analysis.</p>
</div>
<!-- class="sect1" -->
<a id="CIHECEEF"></a>
<div id="TOPOL890" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.2</span> <a id="sthref723"></a>Main Steps in Using the Network Data Model</h2>
<p>This section summarizes the main steps for working with the network data model in Oracle Spatial. It refers to important concepts, structures, and operations that are described in detail in other sections.</p>
<p>There are two basic approaches to creating a network:</p>
<ul>
<li>
<p>Let Spatial perform most operations, using procedures with names in the form CREATE_<span class="italic">&lt;network-type&gt;</span>_NETWORK. (See <a href="#CIHHAGGD">Section 5.2.1</a>.)</p>
</li>
<li>
<p>Perform the operations yourself: create the necessary network tables and update the network metadata. (See <a href="#CIHGDJJH">Section 5.2.2</a>.)</p>
</li>
</ul>
<p>With each approach, you must insert the network data into the network tables. You can then use the network data model PL/SQL and Java application programming interfaces (APIs) to update the network and perform other operations. (The PL/SQL and Java APIs are described in <a href="#CIHBHIGC">Section 5.11</a>.)</p>
<a id="CIHHAGGD"></a>
<div id="TOPOL891" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.2.1</span> Letting Spatial Perform Most Operations</h3>
<p>To create a network by letting Spatial perform most of the necessary operations, follow these steps:</p>
<ol>
<li>
<p>Create the network using a procedure with a name in the form CREATE_<span class="italic">&lt;network-type&gt;</span>_NETWORK, where <span class="italic">&lt;network-type&gt;</span> reflects the type of network that you want to create:</p>
<ul>
<li>
<p><a href="sdo_net_ref.htm#CHDIBGFF">SDO_NET.CREATE_SDO_NETWORK</a> for a spatial network with non-LRS SDO_GEOMETRY objects</p>
</li>
<li>
<p><a href="sdo_net_ref.htm#CHDJADJI">SDO_NET.CREATE_LRS_NETWORK</a> for a spatial network with LRS SDO_GEOMETRY objects</p>
</li>
<li>
<p><a href="sdo_net_ref.htm#CHDJFHAF">SDO_NET.CREATE_TOPO_NETWORK</a> for a spatial network with topology geometry (SDO_TOPO_GEOMETRY) objects</p>
</li>
<li>
<p><a href="sdo_net_ref.htm#CHDFGEAI">SDO_NET.CREATE_LOGICAL_NETWORK</a> for a logical network that does not contain spatial information</p>
</li>
</ul>
<p>Each of these procedures creates the necessary network data model tables (described in <a href="#CIHEDHIF">Section 5.9</a>) and inserts a row with the appropriate network metadata information into the xxx_SDO_NETWORK_METADATA views (described in <a href="#CIHGBCAI">Section 5.10.1</a>).</p>
<p>Each procedure has two formats: one format creates all network data model tables using default names for the tables and certain columns, and other format lets you specify names for the tables and certain columns. The default names for the network data model tables are <span class="italic">&lt;network-name&gt;</span>_NODE$, <span class="italic">&lt;network-name&gt;</span>_LINK$, <span class="italic">&lt;network-name&gt;</span>_PATH$, and <span class="italic">&lt;network-name&gt;</span>_PLINK$. The default name for cost columns in the network data model tables is COST, and the default name for geometry columns is GEOMETRY.</p>
</li>
<li>
<p>Insert data into the node and link tables, and if necessary into the path and path-link tables. (The node, link, path, and path-link tables are described in <a href="#CIHEDHIF">Section 5.9</a>.)</p>
</li>
<li>
<p>Validate the network, using the <a href="sdo_net_ref.htm#CHDCFEFH">SDO_NET.VALIDATE_NETWORK</a> function.</p>
</li>
<li>
<p>For a spatial (SDO or LRS) network, insert the appropriate information into the USER_SDO_GEOM_METADATA view, and create spatial indexes on the geometry columns.</p>
<p>If you plan to use a view as a node, link, or path table, you must specify the view name for the TABLE_NAME column value when you insert information about the node, link, or path table in the USER_SDO_GEOM_METADATA view.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CIHGDJJH"></a>
<div id="TOPOL892" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.2.2</span> Performing the Operations Yourself</h3>
<p>To create a network by performing the necessary operations yourself, follow these steps:</p>
<ol>
<li>
<p>Create the node table, using the <a href="sdo_net_ref.htm#CHDECBDE">SDO_NET.CREATE_NODE_TABLE</a> procedure. (The node table is described in <a href="#CIHHHDJE">Section 5.9.1</a>.)</p>
</li>
<li>
<p>Insert data into the node table.</p>
</li>
<li>
<p>Create the link table, using the <a href="sdo_net_ref.htm#CHDFIFJF">SDO_NET.CREATE_LINK_TABLE</a> procedure. (The link table is described in <a href="#CIHIFBFJ">Section 5.9.2</a>).</p>
</li>
<li>
<p>Insert data into the link table.</p>
</li>
<li>
<p>Optionally, create the path table, using the <a href="sdo_net_ref.htm#CHDHCIJD">SDO_NET.CREATE_PATH_TABLE</a> procedure. (The path table is described in <a href="#CIHHJIEI">Section 5.9.3</a>).</p>
</li>
<li>
<p>If you created the path table, create the path-link table, using the <a href="sdo_net_ref.htm#CHDBDHID">SDO_NET.CREATE_PATH_LINK_TABLE</a> procedure. (The path-link table is described in <a href="#CIHCBCJC">Section 5.9.4</a>).</p>
</li>
<li>
<p>If you created the path table and if you want to create paths, insert data into the table.</p>
</li>
<li>
<p>If you inserted data into the path table, insert the appropriate rows into the path-link table.</p>
</li>
<li>
<p>Insert a row into the USER_SDO_NETWORK_METADATA view with information about the network. (The USER_SDO_NETWORK_METADATA view is described in <a href="#CIHGBCAI">Section 5.10.1</a>.)</p>
<p>If you plan to use a view as a node, link, path, or path-link table, you must specify the view name for the relevant columns when you insert information about the network in the USER_SDO_NETWORK_METADATA view.</p>
</li>
<li>
<p>For a spatial (SDO or LRS) network, insert the appropriate information into the USER_SDO_GEOM_METADATA view, and create spatial indexes on the geometry columns.</p>
<p>If you plan to use a view as a node, link, or path table, you must specify the view name for the TABLE_NAME column value when you insert information about the node, link, or path table in the USER_SDO_GEOM_METADATA view.</p>
</li>
<li>
<p>Validate the network, using the <a href="sdo_net_ref.htm#CHDCFEFH">SDO_NET.VALIDATE_NETWORK</a> function.</p>
</li>
</ol>
<p>You can change the sequence of some of these steps. For example, you can create both the node and link tables first, and then insert data into each one; and you can insert the row into the USER_SDO_NETWORK_METADATA view before you create the node and link tables.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHFIHFB"></a>
<div id="TOPOL893" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.3</span> <a id="sthref724"></a>Network Data Model Concepts</h2>
<p>A network is a type of mathematical graph that captures relationships between objects using connectivity. The connectivity may or may not be based on spatial proximity. For example, if two towns are on opposite sides of a lake, the shortest path based on spatial proximity (a straight line across the middle of the lake) is not relevant if you want to drive from one town to the other. Instead, to find the shortest driving distance, you need connectivity information about roads and intersections and about the "cost" of individual links.</p>
<p>A network consists of a set of nodes and links. Each link (sometimes also called an edge or a segment) specifies two nodes.</p>
<p><a id="sthref725"></a><a id="sthref726"></a><a id="sthref727"></a><a id="sthref728"></a>A network can be <span class="bold">directed</span> (that is, by default, the start and end nodes determine link direction) or <span class="bold">undirected</span> (that is, links can be traversed in either direction).</p>
<p>The following are some key terms related to the network data model:</p>
<ul>
<li>
<p>A <span class="bold"><a id="sthref729"></a><a id="sthref730"></a>node</span>, also called a vertex, is a point where links can join each other. An <a id="sthref731"></a><a id="sthref732"></a><span class="bold">isolated node</span> is a node that is not included in any links. (A non-isolated node will become isolated if all links that include that node are deleted.)</p>
</li>
<li>
<p>A <span class="bold"><a id="sthref733"></a><a id="sthref734"></a><a id="sthref735"></a><a id="sthref736"></a><a id="sthref737"></a><a id="sthref738"></a>link</span> represents a relationship between two nodes. Within a directed network, any link can be <span class="bold">undirected</span> (that is, able to be traversed either from the start node to the end node or from the end node to the start node) or <span class="bold">directed</span> (that is, able to be traversed only from the start node to the end node). Within an undirected network, all links are undirected.</p>
</li>
<li>
<p>A <span class="bold"><a id="sthref739"></a><a id="sthref740"></a>path</span> is an alternating sequence of nodes and links, beginning and ending with nodes, and usually with no nodes and links appearing more than once. (Repeating nodes and links within a path are permitted, but are rare in most network applications.)</p>
</li>
<li>
<p>A <span class="bold">subpath</span> is a partial path along a path, created either as a result of a network analysis operation or explicitly by a user. Subpaths are explained and illustrated in <a href="#CIHJBFCF">Section 5.3.1</a>.</p>
</li>
<li>
<p>A <a id="sthref741"></a><a id="sthref742"></a><span class="bold">logical network</span> contains connectivity information but no geometric information. This is the model used for network analysis. A logical network can be treated as a directed graph or undirected graph, depending on the application.</p>
</li>
<li>
<p>A <a id="sthref743"></a><a id="sthref744"></a><a id="sthref745"></a><a id="sthref746"></a><a id="sthref747"></a><span class="bold">spatial network</span> contains both connectivity information and geometric information. In a spatial network, the nodes and links are SDO_GEOMETRY geometry objects without LRS information (an <span class="bold">SDO network</span>) or with LRS information (an <span class="bold">LRS network</span>), or SDO_TOPO_GEOMETRY objects (a <span class="bold">topology geometry network</span>).</p>
<p>In an LRS network, each node includes a geometry ID value and a measure value, and each link includes a geometry ID value and start and end measure values; and the geometry ID value in each case refers to an SDO_GEOMETRY object with LRS information. A spatial network can be directed or undirected, depending on the application.</p>
</li>
<li>
<p>A <a id="sthref748"></a><span class="bold">feature</span> is an object of interest in a network application that is associated with a node or link. For example, in a transportation network, features include exits and intersections (mapped to nodes), and highways and streets (mapped to links).</p>
</li>
<li>
<p><span class="bold"><a id="sthref749"></a>Cost</span> is a non-negative numeric attribute that can be associated with links or nodes for computing the <span class="bold"><a id="sthref750"></a><a id="sthref751"></a>minimum cost path</span>, which is the path that has the minimum total cost from a start node to an end node. You can specify a single cost factor, such as driving time or driving distance for links, in the network metadata, and network analytical functions that examine cost will use this specified cost factor.</p>
</li>
<li>
<p><span class="bold"><a id="sthref752"></a>Duration</span> is a non-negative numeric attribute that can be associated with links or nodes to specify a duration value for the link or node. The duration value can indicate a number of minutes or any other user-determined significance. You can specify a single duration factor, such as driving time for links, in the network metadata; however, if you use duration instead of cost to indicate elapsed time, network analytical functions that examine cost will not consider the specified duration factor.</p>
</li>
<li>
<p><span class="bold"><a id="sthref753"></a><a id="sthref754"></a><a id="sthref755"></a><a id="sthref756"></a><a id="sthref757"></a>State</span> is a string attribute, either <code>ACTIVE</code> or <code>INACTIVE</code> (or, <code>TRUE</code> or <code>FALSE</code>, respectively, in the SDO_NET_MEM subprograms) that is associated with links or nodes to specify whether or not a link or node will be considered by network analysis functions. For example, if the state of a node is <code>INACTIVE</code>, any links from or to that node are ignored in the computation of the shortest path between two nodes. The state is <code>ACTIVE</code> by default when a link or node is created, but you can set the state <code>INACTIVE</code>.</p>
</li>
<li>
<p><span class="bold"><a id="sthref758"></a>Type</span> is a string attribute that can be associated with links or nodes to specify a user-defined value for the type of a link or a node.</p>
</li>
<li>
<p><span class="bold"><a id="sthref759"></a><a id="sthref760"></a><a id="sthref761"></a><a id="sthref762"></a><a id="sthref763"></a><a id="sthref764"></a>Temporary</span> links, nodes, and paths exist only in a network memory object, and are not written to the database when the network memory object is written. For example, during a network analysis and editing session you might create temporary nodes to represent street addresses for shortest-path computations, but not save these temporary nodes when you save the results of editing operations.</p>
</li>
<li>
<p><span class="bold"><a id="sthref765"></a><a id="sthref766"></a><a id="sthref767"></a><a id="sthref768"></a>Reachable nodes</span> are all nodes that can be reached from a given node. <span class="bold">Reaching nodes</span> are all nodes that can reach a given node.</p>
</li>
<li>
<p>The <span class="bold"><a id="sthref769"></a><a id="sthref770"></a>degree</span> of a node is the number of links to (that is, incident upon) the node. The <span class="bold"><a id="sthref771"></a><a id="sthref772"></a>in-degree</span> is the number of inbound links, and the <span class="bold"><a id="sthref773"></a><a id="sthref774"></a>out-degree</span> is the number of outbound links.</p>
</li>
<li>
<p>A <a id="sthref775"></a><span class="bold">connected component</span> is a group of network nodes that are directly or indirectly connected. If node A can reach node B, they must belong to the same connected component. If two nodes are not connected, it is concluded that there is no possible path between them. This information can be used as a filter to avoid unnecessary path computations.</p>
</li>
<li>
<p>A <a id="sthref776"></a><span class="bold">spanning tree</span> of a connected graph is a tree (that is, a graph with no cycles) that connects all nodes of the graph. (The directions of links are ignored in a spanning tree.) The <span class="bold"><a id="sthref777"></a><a id="sthref778"></a>minimum cost spanning tree</span> is the spanning tree that connects all nodes and has the minimum total cost.</p>
</li>
<li>
<p>A <span class="bold"><a id="sthref779"></a><a id="sthref780"></a>partitioned network</span> is a network that contains multiple partitions. Partitioning a large network enables only the necessary partitions to be loaded on demand into memory, thus providing better overall performance.</p>
<p>Network partitions are sub-networks, each covering a subset of nodes and links of the entire network. Network partitions are the basic processing units for load on demand analysis. They are created by assigning every node in the network to only one partition ID. Network partition information is stored in a partition table.</p>
</li>
<li>
<p><span class="bold"><a id="sthref781"></a>Load on demand</span> (load on demand analysis) is an approach that divides large networks into manageable partitions and only loads needed partitions during analysis, thus removing memory limitation as a consideration and providing better overall performance.</p>
</li>
<li>
<p><span class="bold"><a id="sthref782"></a>Partition BLOBs</span> are binary representations for network partitions. They provide faster partition loading time. They are stored in a partition BLOB table.</p>
</li>
<li>
<p>The load on demand <span class="bold"><a id="sthref783"></a>partition cache</span> is an in-memory placeholder for network partitions loaded into memory during network analysis. You can configure the partition cache.</p>
</li>
<li>
<p><span class="bold"><a id="sthref784"></a>User-defined data</span> is the information (not related to connectivity) that users want to associate with a network representation. User-defined data can be defined at the node, link, path, and subpath level, and is stored in columns in the node, link, path, and subpath tables.</p>
</li>
</ul>
<a id="CIHJBFCF"></a>
<div id="TOPOL894" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.3.1</span> Subpaths</h3>
<p>A <span class="bold"><a id="sthref785"></a><a id="sthref786"></a>subpath</span> is a partial path along a path, created either as a result of a network analysis operation or explicitly by a user. The start and end points of a subpath are defined as link indexes and the percentage of the distance from the previous node in the path, as shown in <a href="#CIHDJIGI">Figure 5-2</a>.</p>
<div id="TOPOL895" class="figure">
<p class="titleinfigure"><a id="CIHDJIGI"></a>Figure 5-2 Path and Subpaths</p>
<img width="507" height="136" src="img/subpaths.gif" alt="Description of Figure 5-2 follows" /><br />
<a id="sthref787" href="img_text/subpaths.htm">Description of "Figure 5-2 Path and Subpaths"</a><br />
<br /></div>
<!-- class="figure" -->
<p>A subpath refers to an existing path (the <span class="bold"><a id="sthref788"></a>reference path</span>) using the following parameters:</p>
<ul>
<li>
<p>Reference path ID: the path ID of the reference path.</p>
</li>
<li>
<p>Start link index: the start link index on the reference path. (Link index 0 refers to the link between the first and second nodes on the path.) In <a href="#CIHDJIGI">Figure 5-2</a>, link index 0 is the start link index.</p>
</li>
<li>
<p>Start percentage: the percentage of the distance along the start link for the start node of the subpath. In <a href="#CIHDJIGI">Figure 5-2</a>, the subpath starts at 65 percent of the distance between the start and end of link index 0.</p>
</li>
<li>
<p>End link index: the end link index on the reference path. In <a href="#CIHDJIGI">Figure 5-2</a>, link index 6 is the end link index.</p>
</li>
<li>
<p>End percentage: the percentage of the distance along the end link for the end node of the subpath. In <a href="#CIHDJIGI">Figure 5-2</a>, the subpath ends at 50 percent of the distance between the start and end of link index 6.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHFBAFJ"></a>
<div id="TOPOL896" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.4</span> Network Applications</h2>
<p>Networks are used in applications to find how different objects are connected to each other. The connectivity is often expressed in terms of adjacency and path relationships. Two nodes are adjacent if they are connected by a link. There are often several paths between any two given nodes, and you may want to find the path with the minimum cost.</p>
<p>This section describes some typical examples of different kinds of network applications.</p>
<div id="TOPOL897" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref789"></a>
<h3 class="sect2"><span class="secnum">5.4.1</span> Road Network Example</h3>
<p>In a typical road network, the intersections of roads are nodes and the road segments between two intersections are links. The spatial representation of a road is not inherently related to the nodes and links in the network. For example, a shape point in the spatial representation of a road (reflecting a sharp turn in the road) is not a node in the network if that shape point is not associated with an intersection; and a single spatial object may make up several links in a network (such as a straight segment intersected by three crossing roads). An important operation with a road network is to find the path from a start point to an end point, minimizing either the travel time or distance. There may be additional constraints on the path computation, such as having the path go through a particular landmark or avoid a particular intersection.</p>
</div>
<!-- class="sect2" -->
<div id="TOPOL898" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref790"></a>
<h3 class="sect2"><span class="secnum">5.4.2</span> Train (Subway) Network Example</h3>
<p>The subway network of any major city is probably best modeled as a logical network, assuming that precise spatial representation of the stops and track lines is unimportant. In such a network, all stops on the system constitute the nodes of the network, and a link is the connection between two stops if a train travels directly between these two stops. Important operations with a train network include finding all stations that can be reached from a specified station, finding the number of stops between two specified stations, and finding the travel time between two stations.</p>
</div>
<!-- class="sect2" -->
<div id="TOPOL899" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref791"></a>
<h3 class="sect2"><span class="secnum">5.4.3</span> Utility Network Example</h3>
<p>Utility networks, such as power line or cable networks, must often be configured to minimize the cost. An important operation with a utility network is to determine the connections among nodes, using minimum cost spanning tree algorithms, to provide the required quality of service at the minimum cost. Another important operation is reachability analysis, so that, for example, if a station in a water network is shut down, you know which areas will be affected.</p>
</div>
<!-- class="sect2" -->
<div id="TOPOL900" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref792"></a>
<h3 class="sect2"><span class="secnum">5.4.4</span> Biochemical Network Example</h3>
<p>Biochemical processes can be modeled as biochemical networks to represent reactions and regulations in living organisms. For example, metabolic pathways are networks involved in enzymatic reactions, while regulatory pathways represent protein-protein interactions. In this example, a pathway is a network; genes, proteins, and chemical compounds are nodes; and reactions among nodes are links. Important operations for a biochemical network include computing paths and the degrees of nodes.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHDHHGB"></a>
<div id="TOPOL901" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.5</span> <a id="sthref793"></a><a id="sthref794"></a>Network Hierarchy</h2>
<p>Some network applications require representations at different levels of abstraction. For example, two major processes might be represented as nodes with a link between them at the highest level of abstraction, and each major process might have several subordinate processes that are represented as nodes and links at the next level down.</p>
<p>A <span class="bold">network hierarchy</span> enables you to represent a network with multiple levels of abstraction by assigning a hierarchy level to each node. (Links are not assigned a hierarchy level, and links can be between nodes in the same hierarchy level or in different levels.) The lowest (most detailed) level in the hierarchy is level 1, and successive higher levels are numbered 2, 3, and so on.</p>
<p><a id="sthref795"></a><a id="sthref796"></a><a id="sthref797"></a>Nodes at adjacent levels of a network hierarchy have parent-child relationships. Each node at the higher level can be the <span class="bold">parent node</span> for one or more nodes at the lower level. Each node at the lower level can be a <span class="bold">child node</span> of one node at the higher level. <span class="bold">Sibling nodes</span> are nodes that have the same parent node.</p>
<p>Links can also have parent-child relationships. However, because links are not assigned to a hierarchy level, there is not necessarily a relationship between link parent-child relationships and network hierarchy levels. <a id="sthref798"></a><span class="bold">Sibling links</span> are links that have the same parent link.</p>
<p><a href="#CIHJJIEJ">Figure 5-3</a> shows a simple hierarchical network, in which there are two levels.</p>
<div id="TOPOL902" class="figure">
<p class="titleinfigure"><a id="CIHJJIEJ"></a>Figure 5-3 Network Hierarchy</p>
<img width="459" height="280" src="img/net_hier.gif" alt="Description of Figure 5-3 follows" /><br />
<a id="sthref799" href="img_text/net_hier.htm">Description of "Figure 5-3 Network Hierarchy"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As shown in <a href="#CIHJJIEJ">Figure 5-3</a>:</p>
<ul>
<li>
<p>The top level (level 2) contains two nodes. Each node is the parent node of several nodes in the bottom level. The link between the nodes in the top level is the parent link of two links between nodes in the bottom level.</p>
</li>
<li>
<p>The bottom level (level 1) shows the nodes that make up each node in the top level. It also shows the links between nodes that are child nodes of each parent node in the top level, and two links between nodes that have different parent nodes.</p>
</li>
<li>
<p>The links between nodes in the bottom level that have different parent nodes are shown with dark connecting lines. These links are child links of the single link between the nodes in the top level in the hierarchy. (However, these two links in the bottom level could also be defined as not being child links of any parent link between nodes in a higher level.)</p>
</li>
<li>
<p>The parent-child relationships between each parent node and link and its child nodes and links are shown with dashed lines with arrowheads at both ends.</p>
</li>
</ul>
<p>Although it is not shown in <a href="#CIHJJIEJ">Figure 5-3</a>, links can cross hierarchy levels. For example, a link could be defined between a node in the top level and any node in the bottom level. In this case, there would not be a parent-child relationship between the links.</p>
</div>
<!-- class="sect1" -->
<a id="CIHJFIIG"></a>
<div id="TOPOL903" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.6</span> <a id="sthref800"></a><a id="sthref801"></a>Network Constraints</h2>
<p><span class="bold">Network constraints</span> are restrictions defined on network analysis computations. For example, a network constraint might list a series of prohibited turns in a roads network due to one-way streets and "No Left Turn" signs, with each prohibited turn represented as a pair of links (a start link and an end link onto which a turn cannot be made from the start link). As another example, a network constraint might require that driving routes must not include toll roads or must not include expressways.</p>
<p>To create a network constraint, you must create a Java class that implements the constraint, and you must register the constraint by using the <a href="sdo_net_ref.htm#CACCJIEB">SDO_NET.REGISTER_CONSTRAINT</a> procedure. To apply a network constraint to a network analysis operation, specify the constraint using the <code>constraint</code> parameter with the appropriate SDO_NET_MEM subprogram.</p>
<p>Examples of Java classes to implement network constraints are provided in the network data model demo files, which are described in <a href="#CIHDIHEA">Section 5.14</a>. For example, the <code>ProhibitedTurns.java</code> file creates a network constraint that defines a series of prohibited turns, and it then returns the shortest path between two nodes, first without applying the constraint and then applying the constraint.</p>
</div>
<!-- class="sect1" -->
<a id="CIHFHAID"></a>
<div id="TOPOL708" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.7</span> <a id="sthref802"></a><a id="sthref803"></a><a id="sthref804"></a>Network Analysis Using Load on Demand</h2>
<p><span class="bold">Load on demand</span> means that during network analysis, a network partition is not loaded into memory until the analysis has reached this partition while exploring the network. With load on demand, Oracle Spatial performs most partitioning and loading operations automatically, and this usually results in more efficient memory utilization with very large networks.</p>
<p>Load on demand analysis involves the following major steps: network creation, network partition, partition cache configuration, and network analysis.</p>
<ol>
<li>
<p>Create the network, using one of the approaches described in <a href="#CIHECEEF">Section 5.2</a>.</p>
</li>
<li>
<p>Partition the network using the <a href="sdo_net_ref.htm#CACHHCJE">SDO_NET.SPATIAL_PARTITION</a> procedure, as explained in <a href="#CIHCBJBG">Section 5.7.1</a>.</p>
</li>
<li>
<p>Optionally, generate partition BLOBs, as explained in <a href="#CIHCIFBI">Section 5.7.2</a>.</p>
</li>
<li>
<p>Configure the load on demand environment, including the partition cache, as explained in <a href="#CIHCAFFD">Section 5.7.3</a>.</p>
</li>
<li>
<p>Analyze the network, as explained in <a href="#CIHCGJCF">Section 5.7.4</a>.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
Load on demand analysis also works with nonpartitioned networks by treating the entire network as one partition. For a small network, there may be no performance benefit in partitioning it, in which case you can skip the partitioning but still use load on demand APIs.</div>
<p>For examples of performing load on demand network analysis and configuring the partition cache, see <a href="#CIHDEJFG">Section 5.13.5</a>.</p>
<p>Additional examples of partitioning and load on demand analysis are included on the Oracle Database Examples media (see <a class="olink EXMPL" href="../../install.112/e24501/toc.htm"><span class="italic">Oracle Database Examples Installation Guide</span></a>). For more information about network data model example and demo files, see <a href="#CIHDIHEA">Section 5.14</a>.</p>
<a id="CIHCBJBG"></a>
<div id="TOPOL904" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.7.1</span> Partitioning a Network</h3>
<p>You can partition a network using the <a href="sdo_net_ref.htm#CACHHCJE">SDO_NET.SPATIAL_PARTITION</a> procedure, specifying the maximum number of nodes in each partition. The partition result is stored in a partition table, which is automatically generated, and partition metadata information is inserted into the network metadata. (As an alternative to using the procedure, you can partition a network by creating and populating a partition table.) You can use other SDO_NET subprograms to query the partitioning metadata.</p>
<p>A good partition strategy is to minimize the number of links between partitions, which reduces the number of partitions that need to be loaded and the probable number of times that the same partitions need to be reloaded. Moreover, partitions that are too small require excessive loading and unloading of partitions during analysis.</p>
<p>The recommended maximum number of nodes per partition, assuming 1 GB of memory, is between 5,000 and 10,000. You can tune the number and see what is best for your applications, considering the available memory, type of analysis, and network size. You should also consider configuring the partition caching size.</p>
</div>
<!-- class="sect2" -->
<a id="CIHCIFBI"></a>
<div id="TOPOL905" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.7.2</span> <a id="sthref805"></a>Generating Partition BLOBs</h3>
<p>To enhance the performance of network loading, you can optionally store partitions as BLOBs in a network partition BLOB table. This information needs to be stored in the network metadata view in order to take advantage of faster partition loading time. Note that if a network or partition information is updated, the partition BLOBs need to be regenerated as well.</p>
<p>A <span class="bold">partition BLOB</span> is a binary stream of data containing the network partition information, such as number of nodes, number of links, properties of each node, properties of each link, and so on. If a partition BLOB exists, Spatial uses it to read information during the load operation, rather than performing time-consuming database queries.</p>
<p>To generate partition BLOBs, use the <a href="sdo_net_ref.htm#CACIHEGB">SDO_NET.GENERATE_PARTITION_BLOBS</a> procedure. The partition BLOBs and their metadata are stored in the partition BLOB table, which is described in <a href="#CIHCHCAB">Section 5.9.7</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHCAFFD"></a>
<div id="TOPOL906" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.7.3</span> <a id="sthref806"></a><a id="sthref807"></a><a id="sthref808"></a>Configuring the Partition Cache</h3>
<p>Before you perform network analysis, you can configure the network partition cache to optimize performance, by modifying an XML configuration file to override the default configuration. You can specify the following:</p>
<ul>
<li>
<p>Cache size: the maximum number of nodes in partition cache</p>
</li>
<li>
<p>Partitions source: from network tables or partition BLOBs</p>
</li>
<li>
<p><a id="sthref809"></a><a id="sthref810"></a>Resident partitions: IDs of partitions that will not be flushed out of the cache, but will stay in memory once they are loaded</p>
</li>
<li>
<p>Cache flushing policy: class name of the <code>CachingHandler</code> implementation</p>
<p>The default caching policy is <code>LeastRecentlyUsed</code>, which flushes out the oldest partition out of memory when the cache is full. You can specify other caching policies by implementing the <code>CachingHandler</code> interface.</p>
</li>
</ul>
<p>A copy of the default load on demand configuration file is included in the supplementary documentation, described in <a href="#CIHDIHEA">Section 5.14</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHCGJCF"></a>
<div id="TOPOL907" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.7.4</span> Analyzing the Network</h3>
<p>After you have created and partitioned the network, and optionally configured the partition cache, you can issue analysis queries. Analysis results are returned in Java representation or XML responses, depending on whether you used the Java or XML API. For details, see the load on demand (LOD) Javadoc and XML schemas (the latter described in <a href="#CIHDIHEA">Section 5.14</a>).</p>
<p>You can write the analysis results to the database using the load on demand Java API.</p>
</div>
<!-- class="sect2" -->
<div id="TOPOL908" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref811"></a>
<h3 class="sect2"><span class="secnum">5.7.5</span> <a id="sthref812"></a>Using Link Levels for Priority Modeling</h3>
<p>Although the load on demand approach reduces the effect of memory limitations in analyzing large networks, analysis operations still can sometimes be very slow. For example, shortest path analysis of two nodes diagonally across the entire network is likely to require traversing almost every link in the network, and this will take a significant amount of time for a network with more than, for example, two million nodes.</p>
<p>To further reduce network analysis time, you can perform analysis on different link levels. <span class="bold">Link level</span> is a positive integer assigned to a link indicating the level of preference of this link. The higher the link level, the higher the preference. For example, a road network may consist of two link levels, level 1 for local roads and level 2 for highways. During network analysis, highways are preferred to local roads, and the minimum link level is 1. (If no link level is assigned to a link, the default link level of 1 is used for the link.)</p>
<p>Link levels have an implicit inheritance property, which means that a network at higher link levels must be a subnetwork of a network at a lower link level. That is, link level 2 is a subnetwork of link level 1, link level 3 is a subnetwork of link level 2, and so on.</p>
<p>You can specify a link level when you load a network or a partition, which causes links at that level and higher levels to be loaded. Using the road network example, with link level 1 for local roads and link level 2 for highways, specifying link level 1 on a load operation loads links at link levels 1 and 2 (that is, local roads and highways), but specifying link level 2 on a load operation loads only the highways links. If you wanted to perform analysis using only highways links, you could optimize the performance by specifying link level 2 for the load operation.</p>
</div>
<!-- class="sect2" -->
<a id="CIHEGBJB"></a>
<div id="TOPOL909" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.7.6</span> <a id="sthref813"></a>Precomputed Analysis Results</h3>
<p>Some analysis operations, such as connected component analysis, can be time consuming. To improve run-time performance, you can call the <a href="sdo_net_ref.htm#CACCFCAB">SDO_NET.FIND_CONNECTED_COMPONENTS</a> procedure, which computes the connected components in the network and stores the results in the connected component table, which is described <a href="#CIHCCGEF">Section 5.9.8</a>.</p>
<p>At runtime, before calling shortest path analysis or reachability analysis, you can check whether the nodes of interest belong to the same connected component by querying the connected component table. If precomputed component information does not exist, it may take a long time for shortest path and reachability analysis to discover that two nodes are, in fact, not connected.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHBJBFI"></a>
<div id="TOPOL910" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.8</span> Network <a id="sthref814"></a><a id="sthref815"></a><a id="sthref816"></a>Editing <a id="sthref817"></a><a id="sthref818"></a><a id="sthref819"></a>and Analysis Using the In-Memory Approach</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
The in-memory approach will be deprecated in the next release of Spatial, and future development will enhance the load on demand approach, which is described in <a href="#CIHFHAID">Section 5.7</a>. You are encouraged use the load on demand approach whenever possible.</div>
<p>This section describes how to perform network editing and analysis operations using a <span class="bold">network memory object</span>, which is a cache in virtual memory. You can load a network or a hierarchy level in a network into a network memory object, perform operations on network objects in the memory object, and then either discard any changes or write the changes to the network in the database.</p>
<p>Multiple network memory objects can exist at a time for a specified network, but only one can be updatable; any others must be read-only. For better performance, if you plan to use the network memory object only to retrieve information or to perform network analysis operations, make the network memory object read-only (that is, specify <code>allow_updates=&gt;'FALSE'</code> with the <a href="sdo_net_mem_ref.htm#CACBIAEI">SDO_NET_MEM.NETWORK_MANAGER.READ_NETWORK</a> procedure).</p>
<p>To work with a network memory object, you can use either the PL/SQL API (specifically, the SDO_NET_MEM package) or the Java API. Both APIs are introduced in <a href="#CIHBHIGC">Section 5.11</a>.</p>
<p>In the network data model PL/SQL API, the subprograms in the SDO_NET package operate on the network in the database, and the subprograms in the SDO_NET_MEM package operate on the network memory object in the cache. For some network editing operations (such as adding a node, link, or path), you can use either an SDO_NET or SDO_NET_MEM procedure; however, if you are performing a large number of editing operations, using the cache (SDO_NET_MEM procedures) offers better performance. Most network operations, though, can be performed only by a subprogram in the SDO_NET or SDO_NET_MEM package, and in these cases your decision about whether to use a network memory object depends on your specific needs.</p>
<p><a href="#CIHJGDBF">Example 5-1</a> uses a network memory object to add a new node and a new link to an existing network, perform a shortest path analysis, print the analysis results, and save the changes and analysis results in the database. These steps assume that a logical network named XYZ_NETWORK has already been created and populated using the statements shown in <a href="#CIHCJAIG">Example 5-5</a> in <a href="#CIHIJJEA">Section 5.13.4</a>.</p>
<div id="TOPOL911" class="example">
<p class="titleinexample"><a id="CIHJGDBF"></a>Example 5-1 Using a Network Memory Object for Editing and Analysis (PL/SQL)</p>
<pre>
DECLARE
  path_id     NUMBER;
  res_numeric NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN 
-- Create a network memory object in the user session for the 
-- logical network named XYZ_NETWORK. This creates a network 
-- object and reads all metadata, nodes, links, and paths in 
-- the network, and it allows for updates to be performed.
sdo_net_mem.network_manager.read_network(net_mem=&gt;'XYZ_NETWORK', 
  allow_updates=&gt;'TRUE');
 
-- Add a node with ID=901, and set its name to N901 and cost to 5.
sdo_net_mem.network.add_node(net_mem=&gt;'XYZ_NETWORK', node_id=&gt;901,
  node_name=&gt;'N901', external_network_id=&gt;0, external_node_id=&gt;0);
sdo_net_mem.node.set_cost(net_mem=&gt;'XYZ_NETWORK', node_id=&gt;901, cost=&gt;5);
 
-- Add a link with ID=9901, name=N901N1, cost=20 from node N901 to node N1.
sdo_net_mem.network.add_link(net_mem=&gt;'XYZ_NETWORK', link_id=&gt;9901, 
  link_name=&gt;'N901N1', start_node_id=&gt;901, end_node_id=&gt;101, cost=&gt;20);
 
-- Perform a shortest path analysis from node N1 to node N5.
path_id := sdo_net_mem.network_manager.shortest_path('XYZ_NETWORK', 101, 105);
DBMS_OUTPUT.PUT_LINE('The ID of the shortest path from N1 to N5 is: ' || path_id);
 
-- List the properties of the path: cost, nodes, and links.
res_numeric := sdo_net_mem.path.get_cost('XYZ_NETWORK', path_id);
DBMS_OUTPUT.PUT_LINE('The cost of this path is: ' || res_numeric);
res_array:= sdo_net_mem.path.get_node_ids('XYZ_NETWORK', path_id);
DBMS_OUTPUT.PUT('This path has the following nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
res_array:= sdo_net_mem.path.get_link_ids('XYZ_NETWORK', path_id);
DBMS_OUTPUT.PUT('This path has the following links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- Add the path to the network memory object.
sdo_net_mem.network.add_path(net_mem=&gt;'XYZ_NETWORK', path_id=&gt;path_id);
 
-- Write changes to the database and commit changes.
sdo_net_mem.network_manager.write_network(net_mem=&gt;'XYZ_NETWORK');
 
-- Drop the network memory object.
sdo_net_mem.network_manager.drop_network(net_mem=&gt;'XYZ_NETWORK');
 
END;
/
The ID of the shortest path from N1 to N5 is: 1
The cost of this path is: 50
This path has the following nodes: 101 103 104 105
This path has the following links: 1102 1104 1105
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CIHEDHIF"></a>
<div id="TOPOL912" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.9</span> <a id="sthref820"></a>Network Data Model Tables</h2>
<p>The connectivity information for a spatial network is stored in two tables: a node table and a link table. In addition, path information can be stored in a path table and a path-link table. You can have Spatial create these tables automatically when you create the network using a CREATE_<span class="italic">&lt;network-type&gt;</span>_NETWORK procedure; or you can create these tables using the <a href="sdo_net_ref.htm#CHDECBDE">SDO_NET.CREATE_NODE_TABLE</a>, <a href="sdo_net_ref.htm#CHDFIFJF">SDO_NET.CREATE_LINK_TABLE</a>, <a href="sdo_net_ref.htm#CHDHCIJD">SDO_NET.CREATE_PATH_TABLE</a>, and <a href="sdo_net_ref.htm#CHDBDHID">SDO_NET.CREATE_PATH_LINK_TABLE</a> procedures.</p>
<p>These tables contain columns with predefined names, and you must not change any of the predefined column names; however, you can add columns to the tables by using the ALTER TABLE statement with the ADD COLUMN clause. For example, although each link and path table is created with a single COST column, you can create additional columns and associate them with other comparable attributes. Thus, to assign a driving time, scenic appeal rating, and a danger rating to each link, you could use the COST column for driving time, add columns for SCENIC_APPEAL and DANGER to the link table, and populate all three columns with values to be interpreted by applications.</p>
<p><a id="sthref821"></a>The following considerations apply to schema, table, and column names that are stored in any Oracle Spatial metadata views. For example, these considerations apply to the names of node, link, path, and path-link tables, and to the names of any columns in these tables that are stored in the network metadata views described in <a href="#CIHIAIJC">Section 5.10</a>.</p>
<ul>
<li>
<p>The name must contain only letters, numbers, and underscores. For example, the name cannot contain a space ( ), an apostrophe (<code>'</code>), a quotation mark (<code>"</code>), or a comma (<code>,</code>).</p>
</li>
<li>
<p>All letters in the names are converted to uppercase before the names are stored in metadata views or before the tables are accessed. This conversion also applies to any schema name specified with the table name.</p>
</li>
</ul>
<a id="CIHHHDJE"></a>
<div id="TOPOL913" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.1</span> <a id="sthref822"></a>Node Table</h3>
<p>Each network has a node table that can contain the columns described in <a href="#CIHJHEGB">Table 5-1</a>. (The specific columns depend on the network type and whether the network is hierarchical or not.)</p>
<div id="TOPOL914" class="tblformal">
<p class="titleintable"><a id="sthref823"></a><a id="CIHJHEGB"></a>Table 5-1 Node Table Columns</p>
<table class="cellalignment789" title="Node Table Columns" summary="Node Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t4">Column Name</th>
<th class="cellalignment790" id="r1c2-t4">Data Type</th>
<th class="cellalignment790" id="r1c3-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t4" headers="r1c1-t4">
<p>NODE_ID</p>
</td>
<td class="cellalignment785" headers="r2c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t4 r1c3-t4">
<p>ID number that uniquely identifies this node within the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t4" headers="r1c1-t4">
<p>NODE_NAME</p>
</td>
<td class="cellalignment785" headers="r3c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r3c1-t4 r1c3-t4">
<p>Name of the node</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t4" headers="r1c1-t4">
<p>NODE_TYPE</p>
</td>
<td class="cellalignment785" headers="r4c1-t4 r1c2-t4">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r4c1-t4 r1c3-t4">
<p>User-defined string to identify the node type</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t4" headers="r1c1-t4">
<p><a id="sthref824"></a>ACTIVE</p>
</td>
<td class="cellalignment785" headers="r5c1-t4 r1c2-t4">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r5c1-t4 r1c3-t4">
<p>Contains <code>Y</code> if the node is active (visible in the network), or <code>N</code> if the node is not active.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t4" headers="r1c1-t4">
<p>PARTITION_ID</p>
</td>
<td class="cellalignment785" headers="r6c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r6c1-t4 r1c3-t4">
<p>(Not used. Instead, node and partition relationships are stored in the partition table, which is described in <a href="#CIHIDACD">Section 5.9.6</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t4" headers="r1c1-t4">
<p><span class="italic">&lt;node_geometry_column&gt;</span>, or GEOM_ID and MEASURE</p>
</td>
<td class="cellalignment785" headers="r7c1-t4 r1c2-t4">
<p>SDO_GEOMETRY, or SDO_TOPO_GEOMETRY, or NUMBER</p>
</td>
<td class="cellalignment785" headers="r7c1-t4 r1c3-t4">
<p>For a spatial (SDO, non-LRS) network, the SDO_GEOMETRY object associated with the node</p>
<p>For a spatial topology network, the SDO_TOPO_GEOMETRY object associated with the node</p>
<p>For a spatial LRS network, GEOM_ID and MEASURE column values (both of type NUMBER) for the geometry objects associated with the node</p>
<p>For a logical network, this column is not used.</p>
<p>For a spatial SDO or topology network, the actual column name is either a default name or what you specified as the <code>geom_column</code> parameter value in the call to the <a href="sdo_net_ref.htm#CHDECBDE">SDO_NET.CREATE_NODE_TABLE</a> procedure.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t4" headers="r1c1-t4">
<p><span class="italic">&lt;node_cost_column&gt;</span></p>
</td>
<td class="cellalignment785" headers="r8c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r8c1-t4 r1c3-t4">
<p>Cost value to be associated with the node, for use by applications that use the network. The actual column name is either a default name or what you specified as the <code>cost_column</code> parameter value in the call to the <a href="sdo_net_ref.htm#CHDECBDE">SDO_NET.CREATE_NODE_TABLE</a> procedure. The cost value can represent anything you want, for example, the toll to be paid at a toll booth.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r9c1-t4" headers="r1c1-t4">
<p>HIERARCHY_LEVEL</p>
</td>
<td class="cellalignment785" headers="r9c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r9c1-t4 r1c3-t4">
<p>For hierarchical networks only: number indicating the level in the network hierarchy for this node. (<a href="#CIHDHHGB">Section 5.5</a> explains network hierarchy.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r10c1-t4" headers="r1c1-t4">
<p>PARENT_NODE_ID</p>
</td>
<td class="cellalignment785" headers="r10c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r10c1-t4 r1c3-t4">
<p>For hierarchical networks only: node ID of the parent node of this node. (<a href="#CIHDHHGB">Section 5.5</a> explains network hierarchy.)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHIFBFJ"></a>
<div id="TOPOL915" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.2</span> <a id="sthref825"></a>Link Table</h3>
<p>Each network has a link table that contains the columns described in <a href="#CIHJCABE">Table 5-2</a>.</p>
<div id="TOPOL916" class="tblformal">
<p class="titleintable"><a id="sthref826"></a><a id="CIHJCABE"></a>Table 5-2 Link Table Columns</p>
<table class="cellalignment789" title="Link Table Columns" summary="Link Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t5">Column Name</th>
<th class="cellalignment790" id="r1c2-t5">Data Type</th>
<th class="cellalignment790" id="r1c3-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t5" headers="r1c1-t5">
<p>LINK_ID</p>
</td>
<td class="cellalignment785" headers="r2c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t5 r1c3-t5">
<p>ID number that uniquely identifies this link within the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t5" headers="r1c1-t5">
<p>LINK_NAME</p>
</td>
<td class="cellalignment785" headers="r3c1-t5 r1c2-t5">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r3c1-t5 r1c3-t5">
<p>Name of the link</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t5" headers="r1c1-t5">
<p>START_NODE_ID</p>
</td>
<td class="cellalignment785" headers="r4c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r4c1-t5 r1c3-t5">
<p>Node ID of the node that starts the link</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t5" headers="r1c1-t5">
<p>END_NODE_ID</p>
</td>
<td class="cellalignment785" headers="r5c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r5c1-t5 r1c3-t5">
<p>Node ID of the node that ends the link</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t5" headers="r1c1-t5">
<p>LINK_TYPE</p>
</td>
<td class="cellalignment785" headers="r6c1-t5 r1c2-t5">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r6c1-t5 r1c3-t5">
<p>User-defined string to identify the link type</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t5" headers="r1c1-t5">
<p><a id="sthref827"></a>ACTIVE</p>
</td>
<td class="cellalignment785" headers="r7c1-t5 r1c2-t5">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r7c1-t5 r1c3-t5">
<p>Contains <code>Y</code> if the link is active (visible in the network), or <code>N</code> if the link is not active.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t5" headers="r1c1-t5">
<p>LINK_LEVEL</p>
</td>
<td class="cellalignment785" headers="r8c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r8c1-t5 r1c3-t5">
<p>Priority level for the link; used for network analysis, so that links with higher priority levels can be considered first in computing a path</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r9c1-t5" headers="r1c1-t5">
<p><span class="italic">&lt;link_geometry_column&gt;</span>; or GEOM_ID, START_MEASURE, and END_MEASURE</p>
</td>
<td class="cellalignment785" headers="r9c1-t5 r1c2-t5">
<p>SDO_GEOMETRY, or SDO_TOPO_GEOMETRY, or NUMBER</p>
</td>
<td class="cellalignment785" headers="r9c1-t5 r1c3-t5">
<p>For a spatial (SDO, non-LRS) network, the SDO_GEOMETRY object associated with the link</p>
<p>For a spatial topology network, the SDO_TOPO_GEOMETRY object associated with the link</p>
<p>For a spatial LRS network, GEOM_ID, START_MEASURE, and END_MEASURE column values (all of type NUMBER) for the geometry objects associated with the link</p>
<p>For a logical network, this column is not used.</p>
<p>For a spatial SDO or topology network, the actual column name is either a default name or what you specified as the <code>geom_column</code> parameter value in the call to the <a href="sdo_net_ref.htm#CHDFIFJF">SDO_NET.CREATE_LINK_TABLE</a> procedure.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r10c1-t5" headers="r1c1-t5">
<p><span class="italic">&lt;link_cost_column&gt;</span></p>
</td>
<td class="cellalignment785" headers="r10c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r10c1-t5 r1c3-t5">
<p>Cost value to be associated with the link, for use by applications that use the network. The actual column name is either a default name or what you specified as the <code>cost_column</code> parameter value in the call to the <a href="sdo_net_ref.htm#CHDFIFJF">SDO_NET.CREATE_LINK_TABLE</a> procedure. The cost value can represent anything you want, for example, the estimated driving time for the link.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r11c1-t5" headers="r1c1-t5">
<p>PARENT_LINK_ID</p>
</td>
<td class="cellalignment785" headers="r11c1-t5 r1c2-t5">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r11c1-t5 r1c3-t5">
<p>For hierarchical networks only: link ID of the parent link of this link. (<a href="#CIHDHHGB">Section 5.5</a> explains parent-child relationships in a network hierarchy.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r12c1-t5" headers="r1c1-t5">
<p>BIDIRECTED</p>
</td>
<td class="cellalignment785" headers="r12c1-t5 r1c2-t5">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r12c1-t5 r1c3-t5">
<p>For directed networks only: contains <code>Y</code> if the link is undirected (that is, can be traversed either from the start node to the end node or from the end node to the start node), or <code>N</code> if the link is directed (in one direction only, from the start node to the end node).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHHJIEI"></a>
<div id="TOPOL917" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.3</span> <a id="sthref828"></a>Path Table</h3>
<p>Each network can have a path table. A path is an ordered sequence of links, and is usually created as a result of network analysis. A path table provides a way to store the result of this analysis. For each path table, you must create an associated path-link table (described in <a href="#CIHCBCJC">Section 5.9.4</a>). Each path table contains the columns described in <a href="#CIHFAECF">Table 5-3</a>.</p>
<div id="TOPOL918" class="tblformal">
<p class="titleintable"><a id="sthref829"></a><a id="CIHFAECF"></a>Table 5-3 Path Table Columns</p>
<table class="cellalignment789" title="Path Table Columns" summary="Path Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t6">Column Name</th>
<th class="cellalignment790" id="r1c2-t6">Data Type</th>
<th class="cellalignment790" id="r1c3-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t6" headers="r1c1-t6">
<p>PATH_ID</p>
</td>
<td class="cellalignment785" headers="r2c1-t6 r1c2-t6">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t6 r1c3-t6">
<p>ID number that uniquely identifies this path within the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t6" headers="r1c1-t6">
<p>PATH_NAME</p>
</td>
<td class="cellalignment785" headers="r3c1-t6 r1c2-t6">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r3c1-t6 r1c3-t6">
<p>Name of the path</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t6" headers="r1c1-t6">
<p>PATH_TYPE</p>
</td>
<td class="cellalignment785" headers="r4c1-t6 r1c2-t6">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r4c1-t6 r1c3-t6">
<p>User-defined string to identify the path type</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t6" headers="r1c1-t6">
<p>START_NODE_ID</p>
</td>
<td class="cellalignment785" headers="r5c1-t6 r1c2-t6">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r5c1-t6 r1c3-t6">
<p>Node ID of the node that starts the first link in the path</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t6" headers="r1c1-t6">
<p>END_NODE_ID</p>
</td>
<td class="cellalignment785" headers="r6c1-t6 r1c2-t6">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r6c1-t6 r1c3-t6">
<p>Node ID of the node that ends the last link in the path</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t6" headers="r1c1-t6">
<p>COST</p>
</td>
<td class="cellalignment785" headers="r7c1-t6 r1c2-t6">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r7c1-t6 r1c3-t6">
<p>Cost value to be associated with the path, for use by applications that use the network. The cost value can represent anything you want, for example, the estimated driving time for the path.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t6" headers="r1c1-t6">
<p>SIMPLE</p>
</td>
<td class="cellalignment785" headers="r8c1-t6 r1c2-t6">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r8c1-t6 r1c3-t6">
<p><a id="sthref830"></a><a id="sthref831"></a><a id="sthref832"></a><a id="sthref833"></a>Contains <code>Y</code> if the path is a simple path, or <code>N</code> if the path is a complex path. In a simple path, the links form an ordered list that can be traversed from the start node to the end node with each link visited once. In a complex path, there are multiple options for going from the start node to the end node.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r9c1-t6" headers="r1c1-t6">
<p><span class="italic">&lt;path_geometry_column&gt;</span></p>
</td>
<td class="cellalignment785" headers="r9c1-t6 r1c2-t6">
<p>SDO_GEOMETRY</p>
</td>
<td class="cellalignment785" headers="r9c1-t6 r1c3-t6">
<p>For all network types except logical, the geometry object associated with the path. The actual column name is either a default name or what you specified as the <code>geom_column</code> parameter value in the call to the <a href="sdo_net_ref.htm#CHDHCIJD">SDO_NET.CREATE_PATH_TABLE</a> procedure.</p>
<p>For a logical network, this column is not used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHCBCJC"></a>
<div id="TOPOL919" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.4</span> <a id="sthref834"></a>Path-Link Table</h3>
<p>For each path table (described in <a href="#CIHHJIEI">Section 5.9.3</a>), you must create a path-link table. Each row in the path-link table uniquely identifies a link within a path in a network; that is, each combination of PATH_ID, LINK_ID, and SEQ_NO values must be unique within the network. The order of rows in the path-link table is not significant. Each path-link table contains the columns described in <a href="#CIHCFEJA">Table 5-4</a>.</p>
<div id="TOPOL920" class="tblformal">
<p class="titleintable"><a id="sthref835"></a><a id="CIHCFEJA"></a>Table 5-4 Path-Link Table Columns</p>
<table class="cellalignment789" title="Path-Link Table Columns" summary="Path-Link Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t7">Column Name</th>
<th class="cellalignment790" id="r1c2-t7">Data Type</th>
<th class="cellalignment790" id="r1c3-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t7" headers="r1c1-t7">
<p>PATH_ID</p>
</td>
<td class="cellalignment785" headers="r2c1-t7 r1c2-t7">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t7 r1c3-t7">
<p>ID number of the path in the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t7" headers="r1c1-t7">
<p>LINK_ID</p>
</td>
<td class="cellalignment785" headers="r3c1-t7 r1c2-t7">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r3c1-t7 r1c3-t7">
<p>ID number of the link in the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t7" headers="r1c1-t7">
<p>SEQ_NO</p>
</td>
<td class="cellalignment785" headers="r4c1-t7 r1c2-t7">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r4c1-t7 r1c3-t7">
<p>Unique sequence number of the link in the path. (The sequence numbers start at 1.) Sequence numbers allow paths to contain repeating nodes and links.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHHIJFA"></a>
<div id="TOPOL921" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.5</span> <a id="sthref836"></a><a id="sthref837"></a>Subpath Table</h3>
<p>Each path can have one or more associated subpaths, and information about all subpaths in a network is stored in the subpath table. A subpath is a partial path along a path, as explained in <a href="#CIHFIHFB">Section 5.3</a>. The subpath table contains the columns described in <a href="#CIHCBGDC">Table 5-5</a>.</p>
<div id="TOPOL922" class="tblformal">
<p class="titleintable"><a id="sthref838"></a><a id="CIHCBGDC"></a>Table 5-5 Subpath Table Columns</p>
<table class="cellalignment789" title="Subpath Table Columns" summary="Path Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t8">Column Name</th>
<th class="cellalignment790" id="r1c2-t8">Data Type</th>
<th class="cellalignment790" id="r1c3-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t8" headers="r1c1-t8">
<p>SUBPATH_ID</p>
</td>
<td class="cellalignment785" headers="r2c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t8 r1c3-t8">
<p>ID number that uniquely identifies this subpath within the reference path</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t8" headers="r1c1-t8">
<p>SUBPATH_NAME</p>
</td>
<td class="cellalignment785" headers="r3c1-t8 r1c2-t8">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r3c1-t8 r1c3-t8">
<p>Name of the subpath</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t8" headers="r1c1-t8">
<p>SUBPATH_TYPE</p>
</td>
<td class="cellalignment785" headers="r4c1-t8 r1c2-t8">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r4c1-t8 r1c3-t8">
<p>User-defined string to identify the subpath type</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t8" headers="r1c1-t8">
<p>REFERENCE_PATH_ID</p>
</td>
<td class="cellalignment785" headers="r5c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r5c1-t8 r1c3-t8">
<p>Path ID number of the path that contains this subpath</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t8" headers="r1c1-t8">
<p>START_LINK_INDEX</p>
</td>
<td class="cellalignment785" headers="r6c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r6c1-t8 r1c3-t8">
<p>Link ID of the link used to define the start of the subpath. For example, in <a href="#CIHDJIGI">Figure 5-2</a> in <a href="#CIHFIHFB">Section 5.3</a>, the START_LINK_INDEX is 0, and the START_PERCENTAGE is 0.65.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t8" headers="r1c1-t8">
<p>END_LINK_INDEX</p>
</td>
<td class="cellalignment785" headers="r7c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r7c1-t8 r1c3-t8">
<p>Link ID of the link used to define the end of the subpath. For example, in <a href="#CIHDJIGI">Figure 5-2</a> in <a href="#CIHFIHFB">Section 5.3</a>, the END_LINK_INDEX is 6, and the END_PERCENTAGE is 0.5.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t8" headers="r1c1-t8">
<p>START_PERCENTAGE</p>
</td>
<td class="cellalignment785" headers="r8c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r8c1-t8 r1c3-t8">
<p>Percentage of the distance between START_LINK_INDEX and the next link in the path, representing the start point of the subpath. Can be a positive or negative number. For example, in <a href="#CIHDJIGI">Figure 5-2</a> in <a href="#CIHFIHFB">Section 5.3</a>, the START_LINK_INDEX is 0, and the START_PERCENTAGE is 0.65. ("Percentage" values in this case are expressed as between 0 and 1.0, so 0.65 is 65 percent.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r9c1-t8" headers="r1c1-t8">
<p>END_PERCENTAGE</p>
</td>
<td class="cellalignment785" headers="r9c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r9c1-t8 r1c3-t8">
<p>Percentage of the distance between END_LINK_INDEX and the next link in the path, representing the end point of the subpath. Can be a positive or negative number. For example, in <a href="#CIHDJIGI">Figure 5-2</a> in <a href="#CIHFIHFB">Section 5.3</a>, the END_LINK_INDEX is 6, and the END_PERCENTAGE is 0.5. ("Percentage" values in this case are expressed as between 0 and 1.0, so 0.5 is 50 percent.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r10c1-t8" headers="r1c1-t8">
<p>COST</p>
</td>
<td class="cellalignment785" headers="r10c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r10c1-t8 r1c3-t8">
<p>Cost value to be associated with the subpath, for use by applications that use the network. The cost value can represent anything you want, for example, the estimated driving time for the path.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r11c1-t8" headers="r1c1-t8">
<p>GEOM</p>
</td>
<td class="cellalignment785" headers="r11c1-t8 r1c2-t8">
<p>SDO_GEOMETRY</p>
</td>
<td class="cellalignment785" headers="r11c1-t8 r1c3-t8">
<p>For all network types except logical, the geometry object associated with the subpath. The actual column name is either a default name or what you specified as the <code>geom_column</code> parameter value in the call to the <a href="sdo_net_ref.htm#CACIHFHI">SDO_NET.CREATE_SUBPATH_TABLE</a> procedure.</p>
<p>For a logical network, this column is not used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHIDACD"></a>
<div id="TOPOL923" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.6</span> <a id="sthref839"></a><a id="sthref840"></a>Partition Table</h3>
<p>Each partitioned network has a partition table. For information about partitioned networks, see <a href="#CIHFHAID">Section 5.7</a>. Each partition table contains the columns described in <a href="#CIHEHHEI">Table 5-6</a>.</p>
<div id="TOPOL924" class="tblformal">
<p class="titleintable"><a id="sthref841"></a><a id="CIHEHHEI"></a>Table 5-6 Partition Table Columns</p>
<table class="cellalignment789" title="Partition Table Columns" summary="Path Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t9">Column Name</th>
<th class="cellalignment790" id="r1c2-t9">Data Type</th>
<th class="cellalignment790" id="r1c3-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t9" headers="r1c1-t9">
<p>NODE_ID</p>
</td>
<td class="cellalignment785" headers="r2c1-t9 r1c2-t9">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t9 r1c3-t9">
<p>ID number of the node</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t9" headers="r1c1-t9">
<p>PARTITION_ID</p>
</td>
<td class="cellalignment785" headers="r3c1-t9 r1c2-t9">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r3c1-t9 r1c3-t9">
<p>ID number of the partition. Must be unique within the network.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t9" headers="r1c1-t9">
<p>LINK_LEVEL</p>
</td>
<td class="cellalignment785" headers="r4c1-t9 r1c2-t9">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r4c1-t9 r1c3-t9">
<p>Link level (Link level reflects the priority level for the link, and is used for network analysis, so that links with higher priority levels can be considered first in computing a path.)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHCHCAB"></a>
<div id="TOPOL925" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.7</span> <a id="sthref842"></a><a id="sthref843"></a>Partition BLOB Table</h3>
<p>Each partitioned network can have a partition BLOB table, which stores binary large object (BLOB) representations for each combination of link level and partition ID in the network. Having BLOB representations of partitions enables better performance for network load on demand analysis operations. To create the partition BLOB table, use the <a href="sdo_net_ref.htm#CACIHEGB">SDO_NET.GENERATE_PARTITION_BLOBS</a> procedure, where you specify the partition BLOB table name as one of the parameters. For information about partitioned networks, see <a href="#CIHFHAID">Section 5.7</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You should never directly modify the partition BLOB table. This table is automatically updated as a result of calls to the <a href="sdo_net_ref.htm#CACIHEGB">SDO_NET.GENERATE_PARTITION_BLOBS</a> and <a href="sdo_net_ref.htm#CACFHGAE">SDO_NET.GENERATE_PARTITION_BLOB</a> procedures.</div>
<p>Each partition table contains the columns described in <a href="#CIHFEBBE">Table 5-7</a>.</p>
<div id="TOPOL926" class="tblformal">
<p class="titleintable"><a id="sthref844"></a><a id="CIHFEBBE"></a>Table 5-7 Partition BLOB Table Columns</p>
<table class="cellalignment789" title="Partition BLOB Table Columns" summary="Path Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t11">Column Name</th>
<th class="cellalignment790" id="r1c2-t11">Data Type</th>
<th class="cellalignment790" id="r1c3-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t11" headers="r1c1-t11">
<p>LINK_LEVEL</p>
</td>
<td class="cellalignment785" headers="r2c1-t11 r1c2-t11">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r2c1-t11 r1c3-t11">
<p>Link level (Link level reflects the priority level for the link, and is used for network analysis, so that links with higher priority levels can be considered first in computing a path.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t11" headers="r1c1-t11">
<p>PARTITION_ID</p>
</td>
<td class="cellalignment785" headers="r3c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r3c1-t11 r1c3-t11">
<p>ID number of the partition</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t11" headers="r1c1-t11">
<p>BLOB</p>
</td>
<td class="cellalignment785" headers="r4c1-t11 r1c2-t11">
<p>BLOB</p>
</td>
<td class="cellalignment785" headers="r4c1-t11 r1c3-t11">
<p>Binary large object (BLOB) representing the specified link level within the specified partition</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t11" headers="r1c1-t11">
<p>NUM_INODES</p>
</td>
<td class="cellalignment785" headers="r5c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r5c1-t11 r1c3-t11">
<p>Number of internal nodes in the BLOB (that is, total number of nodes in the BLOB)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t11" headers="r1c1-t11">
<p>NUM_ENODES</p>
</td>
<td class="cellalignment785" headers="r6c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r6c1-t11 r1c3-t11">
<p>Number of external nodes. An external node is a node that is outside the BLOB, but is one end of a link in which the other node is inside the BLOB.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t11" headers="r1c1-t11">
<p>NUM_ILINKS</p>
</td>
<td class="cellalignment785" headers="r7c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r7c1-t11 r1c3-t11">
<p>Number of internal links in the BLOB (that is, links completely inside the BLOB)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t11" headers="r1c1-t11">
<p>NUM_ELINKS</p>
</td>
<td class="cellalignment785" headers="r8c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r8c1-t11 r1c3-t11">
<p>Number of external links. An external link is a link in which one node is internal (inside the BLOB) and one node is external (outside the BLOB).</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r9c1-t11" headers="r1c1-t11">
<p>NUM_INLINKS</p>
</td>
<td class="cellalignment785" headers="r9c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r9c1-t11 r1c3-t11">
<p>Number of incoming links. An incoming link is an external link in which the start node is outside the BLOB and the end node is inside the BLOB.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r10c1-t11" headers="r1c1-t11">
<p>NUM_OUTLINKS</p>
</td>
<td class="cellalignment785" headers="r10c1-t11 r1c2-t11">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r10c1-t11 r1c3-t11">
<p>Number of outgoing links. An outgoing link is an external link in which the start node is inside the BLOB and the end node is outside the BLOB.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r11c1-t11" headers="r1c1-t11">
<p>USER_DATA_INCLUDED</p>
</td>
<td class="cellalignment785" headers="r11c1-t11 r1c2-t11">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r11c1-t11 r1c3-t11">
<p>Contains <code>Y</code> if the BLOB can include user data, or <code>N</code> if the BLOB cannot include user data.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHCCGEF"></a>
<div id="TOPOL927" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.9.8</span> <a id="sthref845"></a><a id="sthref846"></a>Connected Component Table</h3>
<p>Each network can have a connected component table, which stores the component ID for each node. Nodes of the same connected component have the same component ID. Having this information in the table enables better performance for many network analysis operations. To create the connected component table, and to update the contents of the table at any time afterwards, use the <a href="sdo_net_ref.htm#CACCFCAB">SDO_NET.FIND_CONNECTED_COMPONENTS</a> procedure, where you specify the connected component table name as one of the parameters. For more information about using the precomputed information about connected components, see <a href="#CIHEGBJB">Section 5.7.6</a>.</p>
<p>Each connected component table contains the columns described in <a href="#CIHJGGDE">Table 5-8</a>.</p>
<div id="TOPOL928" class="tblformal">
<p class="titleintable"><a id="sthref847"></a><a id="CIHJGGDE"></a>Table 5-8 Connected Component Table Columns</p>
<table class="cellalignment789" title="Connected Component Table Columns" summary="Path Table Columns" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t12">Column Name</th>
<th class="cellalignment790" id="r1c2-t12">Data Type</th>
<th class="cellalignment790" id="r1c3-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t12" headers="r1c1-t12">
<p>LINK_LEVEL</p>
</td>
<td class="cellalignment785" headers="r2c1-t12 r1c2-t12">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r2c1-t12 r1c3-t12">
<p>Link level of the component assignment. (Link level reflects the priority level for the link, and is used for network analysis, so that links with higher priority levels can be considered first in computing a path.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t12" headers="r1c1-t12">
<p>NODE_ID</p>
</td>
<td class="cellalignment785" headers="r3c1-t12 r1c2-t12">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r3c1-t12 r1c3-t12">
<p>ID number of the node from which to compute all other components that are reachable.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t12" headers="r1c1-t12">
<p>COMPONENT_ID</p>
</td>
<td class="cellalignment785" headers="r4c1-t12 r1c2-t12">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r4c1-t12 r1c3-t12">
<p>ID number of a component that is reachable from the specified node.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHIAIJC"></a>
<div id="TOPOL929" class="sect1">
<h2 class="sect1"><span class="secnum">5.10</span> Network Data Model Metadata Views</h2>
<p>There is a set of network metadata views for each schema (user): xxx_SDO_NETWORK_METADATA, where <span class="italic">xxx</span> can be USER or ALL. These views are created by Spatial.</p>
<a id="CIHGBCAI"></a>
<div id="TOPOL930" class="sect2">
<h3 class="sect2"><span class="secnum">5.10.1</span> xxx_SDO_NETWORK_METADATA Views</h3>
<p>The following views contain information about networks:</p>
<ul>
<li>
<p><a id="sthref848"></a>USER_SDO_NETWORK_METADATA contains information about all networks owned by the user.</p>
</li>
<li>
<p><a id="sthref849"></a>ALL_SDO_NETWORK_METADATA contains information about all networks on which the user has SELECT permission.</p>
</li>
</ul>
<p>If you create a network using one of the CREATE_<span class="italic">&lt;network-type&gt;</span>_NETWORK procedures, the information in these views is automatically updated to reflect the new network; otherwise, you must insert information about the network into the USER_SDO_NETWORK_METADATA view.</p>
<p>The USER_SDO_NETWORK_METADATA and ALL_SDO_NETWORK_METADATA views contain the same columns, as shown <a href="#CIHFCDFC">Table 5-9</a>, except that the USER_SDO_NETWORK_METADATA view does not contain the OWNER column. (The columns are listed in their order in the view definition.)</p>
<div id="TOPOL931" class="tblformal">
<p class="titleintable"><a id="sthref850"></a><a id="CIHFCDFC"></a>Table 5-9 Columns in the xxx_SDO_NETWORK_METADATA Views</p>
<table class="cellalignment789" title="Columns in the xxx_SDO_NETWORK_METADATA Views" summary="Columns in the xxx_SDO_NETWORK_METADATA Views" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t13">Column Name</th>
<th class="cellalignment790" id="r1c2-t13">Data Type</th>
<th class="cellalignment790" id="r1c3-t13">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t13" headers="r1c1-t13">
<p>OWNER</p>
</td>
<td class="cellalignment785" headers="r2c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r2c1-t13 r1c3-t13">
<p>Owner of the network (ALL_SDO_NETWORK_METADATA view only)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t13" headers="r1c1-t13">
<p>NETWORK</p>
</td>
<td class="cellalignment785" headers="r3c1-t13 r1c2-t13">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r3c1-t13 r1c3-t13">
<p>Name of the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t13" headers="r1c1-t13">
<p>NETWORK_ID</p>
</td>
<td class="cellalignment785" headers="r4c1-t13 r1c2-t13">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r4c1-t13 r1c3-t13">
<p>ID number of the network; assigned by Spatial</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t13" headers="r1c1-t13">
<p>NETWORK_CATEGORY</p>
</td>
<td class="cellalignment785" headers="r5c1-t13 r1c2-t13">
<p>VARCHAR2(12)</p>
</td>
<td class="cellalignment785" headers="r5c1-t13 r1c3-t13">
<p>Contains <code>SPATIAL</code> if the network nodes and links are associated with spatial geometries; contains <code>LOGICAL</code> if the network nodes and links are not associated with spatial geometries. A value of <code>LOGICAL</code> causes the network data model PL/SQL and Java APIs to ignore any spatial attributes of nodes, links, and paths.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t13" headers="r1c1-t13">
<p>GEOMETRY_TYPE</p>
</td>
<td class="cellalignment785" headers="r6c1-t13 r1c2-t13">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r6c1-t13 r1c3-t13">
<p>If <code>NETWORK_CATEGORY</code> is <code>SPATI</code><code>AL</code>, contains a value indicating the geometry type of nodes and links: <code>SDO_GEOMETRY</code> for non-LRS SDO_GEOMETRY objects, <code>LRS_GEOMETRY</code> for LRS SDO_GEOMETRY objects, <code>TOPO_GEOMETRY</code> for SDO_TOPO_GEOMETRY objects.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t13" headers="r1c1-t13">
<p>NETWORK_TYPE</p>
</td>
<td class="cellalignment785" headers="r7c1-t13 r1c2-t13">
<p>VARCHAR2(24)</p>
</td>
<td class="cellalignment785" headers="r7c1-t13 r1c3-t13">
<p>User-defined string to identify the network type.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t13" headers="r1c1-t13">
<p>NO_OF_HIERARCHY_LEVELS</p>
</td>
<td class="cellalignment785" headers="r8c1-t13 r1c2-t13">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r8c1-t13 r1c3-t13">
<p>Number of levels in the network hierarchy. Contains 1 if there is no hierarchy. (See <a href="#CIHDHHGB">Section 5.5</a> for information about network hierarchy.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r9c1-t13" headers="r1c1-t13">
<p>NO_OF_PARTITIONS</p>
</td>
<td class="cellalignment785" headers="r9c1-t13 r1c2-t13">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r9c1-t13 r1c3-t13">
<p>(Not currently used)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r10c1-t13" headers="r1c1-t13">
<p>LRS_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r10c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r10c1-t13 r1c3-t13">
<p>If <code>GEOMETRY_TYPE</code> is <code>SDO_GEOMETRY</code>, contains the name of the table containing geometries associated with nodes.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r11c1-t13" headers="r1c1-t13">
<p>LRS_GEOM_COLUMN</p>
</td>
<td class="cellalignment785" headers="r11c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r11c1-t13 r1c3-t13">
<p>If <code>LRS_TABLE_NAME</code> contains a table name, identifies the geometry column in that table.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r12c1-t13" headers="r1c1-t13">
<p>NODE_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r12c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r12c1-t13 r1c3-t13">
<p>If <code>GEOMETRY_TYPE</code> is <code>SDO_GEOMETRY</code>, contains the name of the table containing geometries associated with nodes. (The node table is described in <a href="#CIHHHDJE">Section 5.9.1</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r13c1-t13" headers="r1c1-t13">
<p>NODE_GEOM_COLUMN</p>
</td>
<td class="cellalignment785" headers="r13c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r13c1-t13 r1c3-t13">
<p>If <code>NODE_TABLE_NAME</code> contains a table name, identifies the geometry column in that table.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r14c1-t13" headers="r1c1-t13">
<p><a id="sthref851"></a>NODE_COST_COLUMN</p>
</td>
<td class="cellalignment785" headers="r14c1-t13 r1c2-t13">
<p>VARCHAR2(1024)</p>
</td>
<td class="cellalignment785" headers="r14c1-t13 r1c3-t13">
<p>If <code>NODE_TABLE_NAME</code> contains a table name, identifies the cost column in that table, or a PL/SQL function to compute the cost value.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r15c1-t13" headers="r1c1-t13">
<p>NODE_PARTITION_COLUMN</p>
</td>
<td class="cellalignment785" headers="r15c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r15c1-t13 r1c3-t13">
<p>(Not currently used).</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r16c1-t13" headers="r1c1-t13">
<p><a id="sthref852"></a>NODE_DURATION_COLUMN</p>
</td>
<td class="cellalignment785" headers="r16c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r16c1-t13 r1c3-t13">
<p>If <code>NODE_TABLE_NAME</code> contains a table name, identifies the optional duration column in that table. This column can contain a numeric value that has any user-defined significance, such as a number of minutes associated with the node.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r17c1-t13" headers="r1c1-t13">
<p>LINK_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r17c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r17c1-t13 r1c3-t13">
<p>If <code>GEOMETRY_TYPE</code> is <code>SDO_GEOMETRY</code>, contains the name of the table containing geometries associated with links. (The link table is described in <a href="#CIHIFBFJ">Section 5.9.2</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r18c1-t13" headers="r1c1-t13">
<p>LINK_GEOM_COLUMN</p>
</td>
<td class="cellalignment785" headers="r18c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r18c1-t13 r1c3-t13">
<p>If <code>LINK_TABLE_NAME</code> contains a table name, identifies the geometry column in that table.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r19c1-t13" headers="r1c1-t13">
<p>LINK_DIRECTION</p>
</td>
<td class="cellalignment785" headers="r19c1-t13 r1c2-t13">
<p>VARCHAR2(12)</p>
</td>
<td class="cellalignment785" headers="r19c1-t13 r1c3-t13">
<p>Contains a value indicating the type for all links in the network: <code>UNDIRECTED</code> or <code>DIRECTED</code>.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r20c1-t13" headers="r1c1-t13">
<p><a id="sthref853"></a>LINK_COST_COLUMN</p>
</td>
<td class="cellalignment785" headers="r20c1-t13 r1c2-t13">
<p>VARCHAR2(1024)</p>
</td>
<td class="cellalignment785" headers="r20c1-t13 r1c3-t13">
<p>If <code>LINK_TABLE_NAME</code> contains a table name, identifies the optional numeric column containing a cost value for each link, or a PL/SQL function to compute the cost value.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r21c1-t13" headers="r1c1-t13">
<p>LINK_PARTITION_COLUMN</p>
</td>
<td class="cellalignment785" headers="r21c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r21c1-t13 r1c3-t13">
<p>(Not currently used)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r22c1-t13" headers="r1c1-t13">
<p><a id="sthref854"></a>LINK_DURATION_COLUMN</p>
</td>
<td class="cellalignment785" headers="r22c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r22c1-t13 r1c3-t13">
<p>If <code>LINK_TABLE_NAME</code> contains a table name, identifies the optional duration column in that table. This column can contain a numeric value that has any user-defined significance, such as a number of minutes associated with the link.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r23c1-t13" headers="r1c1-t13">
<p>PATH_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r23c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r23c1-t13 r1c3-t13">
<p>Contains the name of an optional table containing information about paths. (The path table is described in <a href="#CIHHJIEI">Section 5.9.3</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r24c1-t13" headers="r1c1-t13">
<p>PATH_GEOM_COLUMN</p>
</td>
<td class="cellalignment785" headers="r24c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r24c1-t13 r1c3-t13">
<p>If <code>PATH_TABLE_NAME</code> is associated with a spatial network, identifies the geometry column in that table.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r25c1-t13" headers="r1c1-t13">
<p>PATH_LINK_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r25c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r25c1-t13 r1c3-t13">
<p>Contains the name of an optional table containing information about links for each path. (The path-link table is described in <a href="#CIHCBCJC">Section 5.9.4</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r26c1-t13" headers="r1c1-t13">
<p>SUBPATH_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r26c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r26c1-t13 r1c3-t13">
<p>Contains the name of an optional table containing information about subpaths. (The subpath table is described in <a href="#CIHHIJFA">Section 5.9.5</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r27c1-t13" headers="r1c1-t13">
<p>SUBPATH_GEOM_COLUMN</p>
</td>
<td class="cellalignment785" headers="r27c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r27c1-t13 r1c3-t13">
<p>If <code>SUBPATH_TABLE_NAME</code> is associated with a spatial network, identifies the geometry column in that table.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r28c1-t13" headers="r1c1-t13">
<p>PARTITION_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r28c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r28c1-t13 r1c3-t13">
<p>For a partitioned network: the name of the partition table. (The partition table is described in <a href="#CIHIDACD">Section 5.9.6</a>.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r29c1-t13" headers="r1c1-t13">
<p>PARTITION_BLOB_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r29c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r29c1-t13 r1c3-t13">
<p>For a partitioned network for which any partition BLOBs have been generated: the name of the partition BLOB table. (The partition BLOB table is described in <a href="#CIHCHCAB">Section 5.9.7</a>.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r30c1-t13" headers="r1c1-t13">
<p>COMPONENT_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r30c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r30c1-t13 r1c3-t13">
<p>The name of the table containing information about precomputed connected components, as explained in <a href="#CIHEGBJB">Section 5.7.6</a>. (The connected component table is described in <a href="#CIHCCGEF">Section 5.9.8</a>.)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r31c1-t13" headers="r1c1-t13">
<p>NODE_LEVEL_TABLE_NAME</p>
</td>
<td class="cellalignment785" headers="r31c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r31c1-t13 r1c3-t13">
<p>The name of the table containing information about node levels in a hierarchical network. Specify this table as the <code>node_level_table_name</code> parameter with the <a href="sdo_net_ref.htm#CACGIJFD">SDO_NET.GENERATE_NODE_LEVELS</a> procedure.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r32c1-t13" headers="r1c1-t13">
<p>TOPOLOGY</p>
</td>
<td class="cellalignment785" headers="r32c1-t13 r1c2-t13">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r32c1-t13 r1c3-t13">
<p>For a spatial network containing SDO_TOPO_GEOMETRY objects (creating using the <a href="sdo_net_ref.htm#CHDJFHAF">SDO_NET.CREATE_TOPO_NETWORK</a> procedure), contains the name of the topology.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r33c1-t13" headers="r1c1-t13">
<p>USER_DEFINED_DATA</p>
</td>
<td class="cellalignment785" headers="r33c1-t13 r1c2-t13">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r33c1-t13 r1c3-t13">
<p>Contains Y if the network contains user-defined data; contains N if the network does not contain user-defined data.</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r34c1-t13" headers="r1c1-t13">
<p>EXTERNAL_REFERENCES</p>
</td>
<td class="cellalignment785" headers="r34c1-t13 r1c2-t13">
<p>VARCHAR2(1)</p>
</td>
<td class="cellalignment785" headers="r34c1-t13 r1c3-t13">
<p>(Not currently used)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHJFCBA"></a>
<div id="TOPOL932" class="sect2">
<h3 class="sect2"><span class="secnum">5.10.2</span> xxx_SDO_NETWORK_CONSTRAINTS Views</h3>
<p>The following views contain information about network constraints (described in <a href="#CIHJFIIG">Section 5.6</a>):</p>
<ul>
<li>
<p><a id="sthref855"></a><a id="sthref856"></a>USER_SDO_NETWORK_CONSTRAINTS contains information about all network constraints owned by the user.</p>
</li>
<li>
<p><a id="sthref857"></a><a id="sthref858"></a>ALL_SDO_NETWORK_CONSTRAINTS contains information about all network constraints on which the user has SELECT permission.</p>
</li>
</ul>
<p>These views are automatically maintained by the <a href="sdo_net_ref.htm#CACCJIEB">SDO_NET.REGISTER_CONSTRAINT</a> and <a href="sdo_net_ref.htm#CACDGBCJ">SDO_NET.DEREGISTER_CONSTRAINT</a> procedures. You should not directly modify the contents of these views.</p>
<p>The USER_SDO_NETWORK_CONSTRAINTS and ALL_SDO_NETWORK_CONSTRAINTS views contain the same columns, as shown <a href="#CIHFAHFE">Table 5-10</a>, except that the USER_SDO_NETWORK_CONSTRAINTS view does not contain the OWNER column. (The columns are listed in their order in the view definition.)</p>
<div id="TOPOL933" class="tblformal">
<p class="titleintable"><a id="sthref859"></a><a id="CIHFAHFE"></a>Table 5-10 Columns in the xxx_SDO_NETWORK_CONSTRAINTS Views</p>
<table class="cellalignment789" title="Columns in the xxx_SDO_NETWORK_CONSTRAINTS Views" summary="Columns in the xxx_SDO_NETWORK_METADATA Views" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t14">Column Name</th>
<th class="cellalignment790" id="r1c2-t14">Data Type</th>
<th class="cellalignment790" id="r1c3-t14">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t14" headers="r1c1-t14">
<p>OWNER</p>
</td>
<td class="cellalignment785" headers="r2c1-t14 r1c2-t14">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r2c1-t14 r1c3-t14">
<p>Owner of the network constraint (ALL_SDO_NETWORK_CONSTRAINTS view only)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t14" headers="r1c1-t14">
<p>CONSTRAINT</p>
</td>
<td class="cellalignment785" headers="r3c1-t14 r1c2-t14">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r3c1-t14 r1c3-t14">
<p>Name of the network constraint</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t14" headers="r1c1-t14">
<p>DESCRIPTION</p>
</td>
<td class="cellalignment785" headers="r4c1-t14 r1c2-t14">
<p>VARCHAR2(200)</p>
</td>
<td class="cellalignment785" headers="r4c1-t14 r1c3-t14">
<p>Descriptive information about the network constraint, such as its purpose and any usage notes</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t14" headers="r1c1-t14">
<p>CLASS_NAME</p>
</td>
<td class="cellalignment785" headers="r5c1-t14 r1c2-t14">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment785" headers="r5c1-t14 r1c3-t14">
<p>Name of the Java class that implements the network constraint</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t14" headers="r1c1-t14">
<p>CLASS</p>
</td>
<td class="cellalignment785" headers="r6c1-t14 r1c2-t14">
<p>BINARY FILE LOB</p>
</td>
<td class="cellalignment785" headers="r6c1-t14 r1c3-t14">
<p>The Java class that implements the network constraint</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHJFJFD"></a>
<div id="TOPOL934" class="sect2">
<h3 class="sect2"><span class="secnum">5.10.3</span> xxx_SDO_NETWORK_USER_DATA Views</h3>
<p>The following views contain information about network user-defined data, which is the information (not related to connectivity) that users want to associate with a network representation:</p>
<ul>
<li>
<p><a id="sthref860"></a><a id="sthref861"></a>USER_SDO_NETWORK_USER_DATA contains information about all network user-defined data owned by the user.</p>
</li>
<li>
<p><a id="sthref862"></a><a id="sthref863"></a>ALL_SDO_NETWORK_USER_DATA contains information about all network user-defined data on which the user has SELECT permission.</p>
</li>
</ul>
<p>The USER_SDO_NETWORK_USER_DATA and ALL_SDO_NETWORK_USER_DATA views contain the same columns, as shown <a href="#CIHFAHFE">Table 5-10</a>, except that the USER_SDO_NETWORK_USER_DATA view does not contain the OWNER column. (The columns are listed in their order in the view definition.)</p>
<div id="TOPOL935" class="tblformal">
<p class="titleintable"><a id="sthref864"></a><a id="sthref865"></a>Table 5-11 Columns in the xxx_SDO_NETWORK_USER_DATA Views</p>
<table class="cellalignment789" title="Columns in the xxx_SDO_NETWORK_USER_DATA Views" summary="Columns in the xxx_SDO_NETWORK_METADATA Views" dir="ltr">
<thead>
<tr class="cellalignment779">
<th class="cellalignment790" id="r1c1-t15">Column Name</th>
<th class="cellalignment790" id="r1c2-t15">Data Type</th>
<th class="cellalignment790" id="r1c3-t15">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment779">
<td class="cellalignment785" id="r2c1-t15" headers="r1c1-t15">
<p>OWNER</p>
</td>
<td class="cellalignment785" headers="r2c1-t15 r1c2-t15">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r2c1-t15 r1c3-t15">
<p>Owner of the network constraint (ALL_SDO_NETWORK_CONSTRAINTS view only)</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r3c1-t15" headers="r1c1-t15">
<p>NETWORK</p>
</td>
<td class="cellalignment785" headers="r3c1-t15 r1c2-t15">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r3c1-t15 r1c3-t15">
<p>Name of the network</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r4c1-t15" headers="r1c1-t15">
<p>TABLE_TYPE</p>
</td>
<td class="cellalignment785" headers="r4c1-t15 r1c2-t15">
<p>VARCHAR2(12)</p>
</td>
<td class="cellalignment785" headers="r4c1-t15 r1c3-t15">
<p>Type of the table containing the user-defined data: <code>NODE</code>, <code>LINK</code>, <code>PATH</code>, or <code>SUBPATH</code></p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r5c1-t15" headers="r1c1-t15">
<p>DATA_NAME</p>
</td>
<td class="cellalignment785" headers="r5c1-t15 r1c2-t15">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment785" headers="r5c1-t15 r1c3-t15">
<p>Name of column containing the user-defined data</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r6c1-t15" headers="r1c1-t15">
<p>DATA_TYPE</p>
</td>
<td class="cellalignment785" headers="r6c1-t15 r1c2-t15">
<p>VARCHAR2(12)</p>
</td>
<td class="cellalignment785" headers="r6c1-t15 r1c3-t15">
<p>Data type of the user-defined data: <code>VARCHAR2</code>, <code>INTEGER</code>, <code>NUMBER</code>, <code>DATE</code>, <code>TIMESTAMP</code>, or <code>SDO_GEOMETRY</code></p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r7c1-t15" headers="r1c1-t15">
<p>DATA_LENGTH</p>
</td>
<td class="cellalignment785" headers="r7c1-t15 r1c2-t15">
<p>NUMBER(38)</p>
</td>
<td class="cellalignment785" headers="r7c1-t15 r1c3-t15">
<p>If DATA_TYPE is <code>VARCHAR2</code>, the length of the user-defined data</p>
</td>
</tr>
<tr class="cellalignment779">
<td class="cellalignment785" id="r8c1-t15" headers="r1c1-t15">
<p>CATEGORY_ID</p>
</td>
<td class="cellalignment785" headers="r8c1-t15 r1c2-t15">
<p>NUMBER</p>
</td>
<td class="cellalignment785" headers="r8c1-t15 r1c3-t15">
<p>User data category ID (non-negative number, default 0). The category ID allows for grouping of user data for different applications. Category 0 is reserved for general-purpose user data that is useful for all applications. User data for different purposes can be grouped into different categories, so that during network analysis, only the relevant user data categories are loaded into memory, reducing memory consumption at runtime.</p>
<p>For example, for a road network, category 0 user data can include the speed limit and function class of links, and the x, y coordinates of nodes; trucking-related user data might belong to category 1; and traffic-related user data might belong to category 2.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>To use user-defined data, you must set the USER_DEFINED_DATA column value to <code>Y</code> in the appropriate xxx_SDO_NETWORK_METADATA views (described in <a href="#CIHGBCAI">Section 5.10.1</a>).</p>
<p>For an example of using user-defined data, see <a href="#CIHEGBED">Section 5.13.6</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHBHIGC"></a>
<div id="TOPOL936" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.11</span> <a id="sthref866"></a><a id="sthref867"></a><a id="sthref868"></a>Network Data Model Application Programming Interface</h2>
<p>The Oracle Spatial network data model includes two client application programming interfaces (APIs): a PL/SQL interface provided by the SDO_NET and SDO_NET_MEM packages and a Java interface. Both interfaces let you create and update network data, and perform network analysis. It is recommended that you use only PL/SQL or SQL to populate network tables and to create indexes, and that you use either PL/SQL or Java for application development.</p>
<p><a id="sthref869"></a><a id="sthref870"></a><a id="sthref871"></a><a id="sthref872"></a>The following performance considerations apply to the PL/SQL and Java APIs:</p>
<ul>
<li>
<p>If you plan to analyze or edit only nonspatial aspects of a spatial network, you can get better performance by setting the NETWORK_CATEGORY column value to <code>LOGICAL</code> in the USER_SDO_NETWORK_METADATA view (described in <a href="#CIHGBCAI">Section 5.10.1</a>) before performing the analysis or editing, and then changing the value back to <code>SPATIAL</code> afterward.</p>
<p>For example, you could use this technique when finding the shortest path between two nodes, because the shortest-path computation considers cost values. However, you could not use this technique when setting the spatial geometry object or the end measure value for a link.</p>
</li>
<li>
<p>If you do not plan to modify any network objects (that is, if you plan to perform only network analysis operations or to retrieve network information), you can get better performance by creating the network memory object as read-only (that is, by specifying that updates are not allowed).</p>
</li>
</ul>
<a id="CIHBICII"></a>
<div id="TOPOL937" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.11.1</span> Network Data Model PL/SQL Interface</h3>
<p>The SDO_NET package provides subprograms for creating, accessing, and managing networks on a database server. The SDO_NET_MEM package, which implements capabilities available through the Java API, provides subprograms for editing network objects and performing network analysis using a cache object called a network memory object. <a href="#CIHGEADB">Example 5-4</a> in <a href="#CIHDIBDE">Section 5.13</a> shows the use of SDO_NET functions and procedures. <a href="#CIHBJBFI">Section 5.8</a> explains how to use a network memory object, and it contains <a href="#CIHJGDBF">Example 5-1</a>, which uses SDO_NET_MEM functions and procedures.</p>
<p>The SDO_NET subprograms can be grouped into the following logical categories:</p>
<ul>
<li>
<p>Creating networks:</p>
<p><a href="sdo_net_ref.htm#CHDIBGFF">SDO_NET.CREATE_SDO_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDJADJI">SDO_NET.CREATE_LRS_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDJFHAF">SDO_NET.CREATE_TOPO_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDFGEAI">SDO_NET.CREATE_LOGICAL_NETWORK</a></p>
</li>
<li>
<p>Copying and deleting networks:</p>
<p><a href="sdo_net_ref.htm#CHDBIGAF">SDO_NET.COPY_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDIEAIB">SDO_NET.DROP_NETWORK</a></p>
</li>
<li>
<p>Creating network tables:</p>
<p><a href="sdo_net_ref.htm#CHDECBDE">SDO_NET.CREATE_NODE_TABLE</a></p>
<p><a href="sdo_net_ref.htm#CHDFIFJF">SDO_NET.CREATE_LINK_TABLE</a></p>
<p><a href="sdo_net_ref.htm#CHDHCIJD">SDO_NET.CREATE_PATH_TABLE</a></p>
<p><a href="sdo_net_ref.htm#CHDBDHID">SDO_NET.CREATE_PATH_LINK_TABLE</a></p>
<p><a href="sdo_net_ref.htm#CHDBIBAA">SDO_NET.CREATE_LRS_TABLE</a></p>
</li>
<li>
<p>Validating network objects:</p>
<p><a href="sdo_net_ref.htm#CHDCFEFH">SDO_NET.VALIDATE_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDBFCJB">SDO_NET.VALIDATE_NODE_SCHEMA</a></p>
<p><a href="sdo_net_ref.htm#CHDCGIIH">SDO_NET.VALIDATE_LINK_SCHEMA</a></p>
<p><a href="sdo_net_ref.htm#CHDIFFHJ">SDO_NET.VALIDATE_PATH_SCHEMA</a></p>
<p><a href="sdo_net_ref.htm#CHDHABJA">SDO_NET.VALIDATE_LRS_SCHEMA</a></p>
</li>
<li>
<p>Retrieving information (getting information about the network, checking for a characteristic):</p>
<p><a href="sdo_net_ref.htm#CHDIFBBC">SDO_NET.GET_CHILD_LINKS</a></p>
<p><a href="sdo_net_ref.htm#CHDFDCIB">SDO_NET.GET_CHILD_NODES</a></p>
<p><a href="sdo_net_ref.htm#CHDHGHGF">SDO_NET.GET_GEOMETRY_TYPE</a></p>
<p><a href="sdo_net_ref.htm#CHDDHAFG">SDO_NET.GET_IN_LINKS</a></p>
<p><a href="sdo_net_ref.htm#CHDGCIHI">SDO_NET.GET_LINK_COST_COLUMN</a></p>
<p><a href="sdo_net_ref.htm#CHDCEIJA">SDO_NET.GET_LINK_DIRECTION</a></p>
<p><a href="sdo_net_ref.htm#CHDFEAFF">SDO_NET.GET_LINK_GEOM_COLUMN</a></p>
<p><a href="sdo_net_ref.htm#CHDCCHBF">SDO_NET.GET_LINK_GEOMETRY</a></p>
<p><a href="sdo_net_ref.htm#CHDBEFAD">SDO_NET.GET_LINK_TABLE_NAME</a></p>
<p><a href="sdo_net_ref.htm#CHDJJHJI">SDO_NET.GET_LRS_GEOM_COLUMN</a></p>
<p><a href="sdo_net_ref.htm#CHDJCCID">SDO_NET.GET_LRS_LINK_GEOMETRY</a></p>
<p><a href="sdo_net_ref.htm#CHDDDEHB">SDO_NET.GET_LRS_NODE_GEOMETRY</a></p>
<p><a href="sdo_net_ref.htm#CHDDABGE">SDO_NET.GET_LRS_TABLE_NAME</a></p>
<p><a href="sdo_net_ref.htm#CHDEAEIH">SDO_NET.GET_NETWORK_TYPE</a></p>
<p><a href="sdo_net_ref.htm#CHDFGIFI">SDO_NET.GET_NO_OF_HIERARCHY_LEVELS</a></p>
<p><a href="sdo_net_ref.htm#CHDIHIGC">SDO_NET.GET_NO_OF_LINKS</a></p>
<p><a href="sdo_net_ref.htm#CHDCEHAJ">SDO_NET.GET_NO_OF_NODES</a></p>
<p><a href="sdo_net_ref.htm#CHDBDJEA">SDO_NET.GET_NODE_DEGREE</a></p>
<p><a href="sdo_net_ref.htm#CHDFDDEG">SDO_NET.GET_NODE_GEOM_COLUMN</a></p>
<p><a href="sdo_net_ref.htm#CHDIIDGA">SDO_NET.GET_NODE_GEOMETRY</a></p>
<p><a href="sdo_net_ref.htm#CHDFIDFH">SDO_NET.GET_NODE_IN_DEGREE</a></p>
<p><a href="sdo_net_ref.htm#CHDEABCJ">SDO_NET.GET_NODE_OUT_DEGREE</a></p>
<p><a href="sdo_net_ref.htm#CHDJGDAJ">SDO_NET.GET_NODE_TABLE_NAME</a></p>
<p><a href="sdo_net_ref.htm#CHDJDBEE">SDO_NET.GET_OUT_LINKS</a></p>
<p><a href="sdo_net_ref.htm#CHDJCGBG">SDO_NET.GET_PATH_GEOM_COLUMN</a></p>
<p><a href="sdo_net_ref.htm#CHDIICJI">SDO_NET.GET_PATH_TABLE_NAME</a></p>
<p><a href="sdo_net_ref.htm#CHDFHHAI">SDO_NET.IS_HIERARCHICAL</a></p>
<p><a href="sdo_net_ref.htm#CHDJCEEC">SDO_NET.IS_LOGICAL</a></p>
<p><a href="sdo_net_ref.htm#CHDDDFBH">SDO_NET.IS_SPATIAL</a></p>
<p><a href="sdo_net_ref.htm#CHDEAIFJ">SDO_NET.LRS_GEOMETRY_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDDHDGI">SDO_NET.NETWORK_EXISTS</a></p>
<p><a href="sdo_net_ref.htm#CHDDCACC">SDO_NET.SDO_GEOMETRY_NETWORK</a></p>
<p><a href="sdo_net_ref.htm#CHDBAGBJ">SDO_NET.TOPO_GEOMETRY_NETWORK</a></p>
</li>
</ul>
<p>For reference information about each SDO_NET function and procedure, see <a href="sdo_net_ref.htm#CHDDAHAF">Chapter 6</a>.</p>
<p>The SDO_NET_MEM subprograms are grouped according to their associated object-related class in the oracle.spatial.network interface or class. You must specify a prefix after SDO_NET_MEM for each program, depending on its associated class (for example, SDO_NET_MEM.NETWORK_MANAGER.CREATE_LOGICAL_NETWORK, SDO_NET_MEM.NETWORK.ADD_NODE, and SDO_NET_MEM.NODE.GET_COST).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although this manual refers to "the SDO_NET_MEM package," all subprograms except one are actually implemented as methods of several object types. Thus, they are not listed by the statement <code>DESCRIBE SDO_NET_MEM</code>. Instead, you can use the DESCRIBE statements listed in <a href="sdo_net_mem_ref.htm#CHDIBCCD">Table 7-1</a> in <a href="sdo_net_mem_ref.htm#CHDCIHII">Chapter 7</a> to see the subprograms in each grouping; however, because they are member functions and procedures in an object type, the subprograms in each grouping will not be listed in alphabetical order in the DESCRIBE statement output.</div>
<p>The SDO_NET_MEM subprogram groupings are as follows:</p>
<ul>
<li>
<p>SDO_NET_MEM.NETWORK_MANAGER subprograms are related to the <code>oracle.spatial.network.NetworkManager</code> Java class. They enable you to create and drop network memory objects and to perform network analysis.</p>
</li>
<li>
<p>SDO_NET_MEM.NETWORK subprograms are related to the <code>oracle.spatial.network.Network</code> Java interface. They enable you to add and delete nodes, links, and paths.</p>
</li>
<li>
<p>SDO_NET_MEM.NODE subprograms are related to the <code>oracle.spatial.network.Node</code> Java interface. They enable you to get and set attributes for nodes.</p>
</li>
<li>
<p>SDO_NET_MEM.LINK subprograms are related to the <code>oracle.spatial.network.Link</code> Java interface. They enable you to get and set attributes for links.</p>
</li>
<li>
<p>SDO_NET_MEM.PATH subprograms are related to the <code>oracle.spatial.network.Path</code> Java interface. They enable you to get and set attributes for paths.</p>
</li>
</ul>
<p>The associations between SDO_NET_MEM subprograms and methods of the Java API are not necessarily exact. In some cases, a PL/SQL subprogram may combine operations and options from several methods. In addition, some Java methods do not have PL/SQL counterparts. Thus, the Usage Notes for subprograms state only that the function or procedure is analogous to a specific Java method, to indicate a logical relationship between the two. For detailed information about a specific Java method and others that may be related, see the Javadoc-generated API documentation (briefly explained in <a href="#CIHFFBBH">Section 5.11.2</a>).</p>
<p>For reference information about each SDO_NET_MEM function and procedure, see <a href="sdo_net_mem_ref.htm#CHDCIHII">Chapter 7</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHFFBBH"></a>
<div id="TOPOL938" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.11.2</span> <a id="sthref873"></a><a id="sthref874"></a>Network Data Model Java Interface</h3>
<p>The network data model Java interface includes the in-memory interface and the load on demand interface. Complete reference information about these interfaces is provided in <a class="olink SPAJV" href="../e11829/toc.htm"><span class="italic">Oracle Spatial Java API Reference</span></a>. The classes of the in-memory Java interface are in the <code>oracle.spatial.network package</code>. The classes of the load on demand Java interface are in the <code>oracle.spatial.network.lod</code> package and its subpackages.</p>
<p>The Spatial Java class libraries are in .jar files under the <code>&lt;ORACLE_HOME&gt;/md/jlib/</code> directory.</p>
<div id="TOPOL939" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref875"></a>
<h4 class="sect3"><span class="secnum">5.11.2.1</span> Network Metadata and Data Management</h4>
<p>You can use the Java API to perform network metadata and data management operations such as the following:</p>
<ul>
<li>
<p>Insert, delete, and modify node and link data</p>
</li>
<li>
<p>Load a network from a database</p>
</li>
<li>
<p>Store a network in a database</p>
</li>
<li>
<p>Store network metadata in a database</p>
</li>
<li>
<p>Modify network metadata attributes</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="TOPOL940" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref876"></a>
<h4 class="sect3"><span class="secnum">5.11.2.2</span> Network Analysis Using the In-Memory Approach</h4>
<p>You can use the <code>oracle.spatial.network.NetworkManager</code> class to perform network analysis operations, such as the following, using the in-memory approach:</p>
<ul>
<li>
<p>Shortest path: typical transitive closure problems in graph theory. Given a start and an end node, find the shortest path.</p>
</li>
<li>
<p>Minimum cost spanning tree: Given an undirected graph, find the minimum cost tree that connects all nodes.</p>
</li>
<li>
<p>Reachability: Given a node, find all nodes that can reach that node, or find all nodes that can be reached by that node.</p>
</li>
<li>
<p>Within-cost analysis: Given a target node and a cost, find all nodes that can be reached by the target node within the given cost.</p>
</li>
<li>
<p>Nearest-neighbors analysis: Given a target node and number of neighbors, find the neighbor nodes and their costs to go to the given target node.</p>
</li>
<li>
<p>All paths between two nodes: Given two nodes, find all possible paths between them.</p>
</li>
<li>
<p>TSP ("traveling salesman problem" or "traveling salesperson problem") analysis: Given a set of nodes, find the most efficient (lowest-cost or shortest distance) path that visits all nodes, and optionally require that the start and end nodes be the same.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="TOPOL941" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref877"></a>
<h4 class="sect3"><span class="secnum">5.11.2.3</span> Network Analysis Using the Load on Demand Approach</h4>
<p>You can use the <code>oracle.spatial.network.lod.NetworkAnalyst</code> class to perform network analysis operations, such as the following, using the load on demand approach:</p>
<ul>
<li>
<p>Shortest path: typical transitive closure problems in graph theory. Given a start and an end node, find the shortest path.</p>
</li>
<li>
<p>Reachability: Given a node, find all nodes that can reach that node, or find all nodes that can be reached by that node.</p>
</li>
<li>
<p>Within-cost analysis: Given a target node and a cost, find all nodes that can be reached by the target node within the given cost.</p>
</li>
<li>
<p>Nearest-neighbors analysis: Given a target node and number of neighbors, find the neighbor nodes and their costs to go to the given target node.</p>
</li>
<li>
<p>Dynamic data input: Create and use a <code>NetworkUpdate</code> object with network update information.</p>
</li>
<li>
<p>User-defined link and node cost calculators: Define the method for computing the cost of a link or a node.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHCBJGB"></a>
<div id="TOPOL942" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.12</span> Cross-Schema Network Access</h2>
<p>If database users other than the network owner need to read a network into memory, you need to do one of the following:</p>
<ul>
<li>
<p>For each non-owner user, qualify the network tables with the schema of the network owner in the USER_SDO_NETWORK_METADATA view, as explained in <a href="#CIHFGDBD">Section 5.12.1</a>.</p>
</li>
<li>
<p>For each non-owner user, create views on the network data model tables and update the USER_SDO_NETWORK_METADATA view, as explained in <a href="#CIHGCGIG">Section 5.12.2</a>.</p>
</li>
</ul>
<p>The second approach requires the extra step of creating views, but the views provide you with flexibility in controlling the parts of the network that are accessible. Each view can provide access to all of the network, or it can use a WHERE clause to provide access to just one or more parts (for example, <code>WHERE STATE_CODE='NY'</code> to restrict the view users to rows for New York) .</p>
<p>Consider the following example scenario:</p>
<ul>
<li>
<p>User1 creates (and thus owns) Network1.</p>
</li>
<li>
<p>User2 attempts to call the <a href="sdo_net_mem_ref.htm#CACBIAEI">SDO_NET_MEM.NETWORK_MANAGER.READ_NETWORK</a> procedure to read Network1, but receives an error. The error occurs even though User2 has the appropriate privileges on the network data model tables for Network1.</p>
</li>
</ul>
<p>To work around this problem, you must use the approach in either <a href="#CIHFGDBD">Section 5.12.1, "Cross-Schema Access by Specifying Owner in Network Metadata"</a> or <a href="#CIHGCGIG">Section 5.12.2, "Cross-Schema Access by Using Views"</a>.</p>
<a id="CIHFGDBD"></a>
<div id="TOPOL943" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.12.1</span> Cross-Schema Access by Specifying Owner in Network Metadata</h3>
<p>To enable a non-owner user (with suitable privileges) to access a network, you can specify the network owner in the network metadata. For each non-owner user that will be permitted to access the network, follow these steps:</p>
<ol>
<li>
<p>Ensure that the user has SELECT access to the necessary network data model tables. If the user does not have this access, connect as the network owner and grant it. For example, connect as User1 and execute the following statements:</p>
<pre>
GRANT select ON network1_node$ TO user2;
GRANT select ON network1_link$ TO user2;
GRANT select ON network1_path$ TO user2;
GRANT select ON network1_plink$ TO user2;
</pre></li>
<li>
<p>Connect as the non-owner user. For example, connect as User2.</p>
</li>
<li>
<p>Use the schema name of the network owner to qualify the network data model tables for the network in the USER_SDO_NETWORK_METADATA view (explained in <a href="#CIHGBCAI">Section 5.10.1</a>). For example, if the network is not already defined in this view, enter the following while connected as User2:</p>
<pre>
INSERT INTO user_sdo_network_metadata 
  (network, network_category, geometry_type, 
   node_table_name,node_geom_column,
   link_table_name, link_geom_column, link_direction,
   path_table_name, path_geom_column,
   path_link_table_name)
VALUES
  ('NETWORK1','SPATIAL', 'SDO_GEOMETRY',
   'USER1.NETWORK1_NODE$', 'GEOMETRY',
   'USER1.NETWORK1_LINK$', 'GEOMETRY', 'DIRECTED',
   'USER1.NETWORK1_PATH$', 'GEOMETRY',
   'USER1.NETWORK1_PLINK$');
</pre>
<p>If the network is already defined in this view, update the definition to qualify each table name with the schema name. For example:</p>
<pre>
UPDATE USER_SDO_NETWORK_METADATA
  SET node_table_name = 'USER1.NETWORK1_NODE$',
      link_table_name = 'USER1.NETWORK1_LINK$',
      path_table_name = 'USER1.NETWORK1_PATH$',
      path_link_table_name = 'USER1.NETWORK1_PLINK$'
  WHERE network = 'NETWORK1';
</pre></li>
</ol>
<p>In this scenario, User2 can now read NETWORK1 into memory.</p>
</div>
<!-- class="sect2" -->
<a id="CIHGCGIG"></a>
<div id="TOPOL944" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.12.2</span> Cross-Schema Access by Using Views</h3>
<p>To enable a non-owner user (with suitable privileges) to access a network, or specific parts of a network, you can create views. For each non-owner user that will be permitted to access the network, follow these steps:</p>
<ol>
<li>
<p>Ensure that the user has SELECT access to the necessary network data model tables. If the user does not have this access, connect as the network owner and grant it. For example, connect as User1 and execute the following statements:</p>
<pre>
GRANT select ON network1_node$ TO user2;
GRANT select ON network1_link$ TO user2;
GRANT select ON network1_path$ TO user2;
GRANT select ON network1_plink$ TO user2;
</pre></li>
<li>
<p>Connect as the non-owner user. For example, connect as User2.</p>
</li>
<li>
<p>Create a view on each of the necessary network data model nodes, with each view selecting all columns in the associated table. Qualify the table name with the schema name of the network owner. For example, while connected as User2:</p>
<pre>
CREATE VIEW network1_node$ AS select * from user1.network1_node$;
CREATE VIEW network1_link$ AS select * from user1.network1_link$;
CREATE VIEW network1_path$ AS select * from user1.network1_path$;
CREATE VIEW network1_plink$ AS select * from user1.network1_plink$;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although this example shows views that include all data in the underlying tables, you can restrict the parts of the network that are available by using a WHERE clause in each view definition (for example, <code>WHERE STATE_CODE='NY'</code>).</div>
</li>
<li>
<p>Add a row specifying the newly created views to the USER_SDO_NETWORK_METADATA view (explained in <a href="#CIHGBCAI">Section 5.10.1</a>). For example, while connected as User2:</p>
<pre>
INSERT INTO user_sdo_network_metadata 
  (network, network_category, geometry_type, 
   node_table_name,node_geom_column,
   link_table_name, link_geom_column, link_direction,
   path_table_name, path_geom_column,
   path_link_table_name)
VALUES
  ('NETWORK1','SPATIAL', 'SDO_GEOMETRY',
   'NETWORK1_NODE$', 'GEOMETRY',
   'NETWORK1_LINK$', 'GEOMETRY', 'DIRECTED',
   'NETWORK1_PATH$', 'GEOMETRY',
   'NETWORK1_PLINK$');
</pre></li>
</ol>
<p>In this scenario, User2 can now read into memory those parts of NETWORK1 that are available through the views that were created.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHDIBDE"></a>
<div id="TOPOL712" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.13</span> Network Examples</h2>
<p><a id="sthref878"></a><a id="sthref879"></a><a id="sthref880"></a>This section presents several network data model examples. Most are simplified examples. All examples use the PL/SQL API, and some also use other APIs. This section includes the following subsections:</p>
<ul>
<li>
<p><a href="#CIHGEBBE">Section 5.13.1, "Simple Spatial (SDO) Network Example (PL/SQL)"</a></p>
</li>
<li>
<p><a href="#CIHEHDGI">Section 5.13.2, "Simple Logical Network Example (PL/SQL)"</a></p>
</li>
<li>
<p><a href="#CIHHDGHI">Section 5.13.3, "Spatial (LRS) Network Example (PL/SQL)"</a></p>
</li>
<li>
<p><a href="#CIHIJJEA">Section 5.13.4, "Logical Hierarchical Network Example (PL/SQL)"</a></p>
</li>
<li>
<p><a href="#CIHDEJFG">Section 5.13.5, "Partitioning and Load on Demand Analysis Examples (PL/SQL, XML, and Java)"</a></p>
</li>
<li>
<p><a href="#CIHEGBED">Section 5.13.6, "User-Defined Data Example (PL/SQL and Java)"</a></p>
</li>
</ul>
<p>The examples refer to concepts that are explained in this chapter, and they use PL/SQL functions and procedures documented in <a href="sdo_net_ref.htm#CHDDAHAF">Chapter 6</a>.</p>
<a id="CIHGEBBE"></a>
<div id="TOPOL945" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.13.1</span> Simple Spatial (SDO) Network Example (PL/SQL)</h3>
<p>This section presents an example of a very simple spatial (SDO, not LRS) network that contains three nodes and a link between each node. The network is illustrated in <a href="#CIHECIDG">Figure 5-4</a>.</p>
<div id="TOPOL946" class="figure">
<p class="titleinfigure"><a id="CIHECIDG"></a>Figure 5-4 Simple Spatial (SDO) Network</p>
<img width="297" height="122" src="img/net_sdo.gif" alt="Description of Figure 5-4 follows" /><br />
<a id="sthref881" href="img_text/net_sdo.htm">Description of "Figure 5-4 Simple Spatial (SDO) Network"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As shown in <a href="#CIHECIDG">Figure 5-4</a>, node <code>N1</code> is at point 1,1, node <code>N2</code> is at point 15,1, and node <code>N3</code> is at point 9,4. Link <code>L1</code> is a straight line connecting nodes <code>N1</code> and <code>N2</code>, link <code>L2</code> is a straight line connecting nodes <code>N2</code> and <code>N3</code>, and link <code>L3</code> is a straight line connecting nodes <code>N3</code> and <code>N1</code>. There are no other nodes or shape points on any of the links.</p>
<p><a href="#CIHBAFID">Example 5-2</a> does the following:</p>
<ul>
<li>
<p>In a call to the <a href="sdo_net_ref.htm#CHDIBGFF">SDO_NET.CREATE_SDO_NETWORK</a> procedure, creates the <code>SDO_NET1</code> directed network; creates the SDO_NET1_NODE$, SDO_NET1_LINK$, SDO_NET1_PATH$, and SDO_NET1_PLINK$ tables; and updates the xxx_SDO_NETWORK_METADATA views. All geometry columns are named GEOMETRY. Both the node and link tables contain a cost column named COST.</p>
</li>
<li>
<p>Populates the node, link, path, and path-link tables. It inserts three rows into the node table, three rows into the link table, two rows into the path table, and four rows into the path-link table.</p>
</li>
<li>
<p>Updates the Oracle Spatial metadata, and creates spatial indexes on the GEOMETRY columns of the node and link tables. (These actions are not specifically related to network management, but that are necessary if applications are to benefit from spatial indexing on these geometry columns.)</p>
</li>
</ul>
<p><a href="#CIHBAFID">Example 5-2</a> does not show the use of many SDO_NET functions and procedures; these are included in <a href="#CIHGEADB">Example 5-4</a> in <a href="#CIHHDGHI">Section 5.13.3</a>.</p>
<div id="TOPOL947" class="example">
<p class="titleinexample"><a id="CIHBAFID"></a>Example 5-2 Simple Spatial (SDO) Network Example (PL/SQL)</p>
<pre>
-- Create the SDO_NET1 directed network. Also creates the SDO_NET1_NODE$, 
-- SDO_NET1_LINK$, SDO_NET1_PATH$, SDO_NET1_PLINK$ tables, and updates 
-- USER_SDO_NETWORK_METADATA. All geometry columns are named GEOMETRY. 
-- Both the node and link tables contain a cost column named COST. 
EXECUTE SDO_NET.CREATE_SDO_NETWORK('SDO_NET1', 1, TRUE, TRUE);
 
-- Populate the SDO_NET1_NODE$ table.
-- N1
INSERT INTO sdo_net1_node$ (node_id, node_name, active, geometry, cost)
  VALUES(1, 'N1', 'Y',
    SDO_GEOMETRY(2001, NULL, SDO_POINT_TYPE(1,1,NULL), NULL, NULL),
    5);
-- N2
INSERT INTO sdo_net1_node$ (node_id, node_name, active, geometry, cost)
  VALUES(2, 'N2', 'Y',
    SDO_GEOMETRY(2001, NULL, SDO_POINT_TYPE(15,1,NULL), NULL, NULL),
    8);
-- N3
INSERT INTO sdo_net1_node$ (node_id, node_name, active, geometry, cost)
  VALUES(3, 'N3', 'Y',
    SDO_GEOMETRY(2001, NULL, SDO_POINT_TYPE(9,4,NULL), NULL, NULL),
    4);
 
-- Populate the SDO_NET1_LINK$ table.
-- L1
INSERT INTO sdo_net1_link$ (link_id, link_name, start_node_id, end_node_id,
     active, geometry, cost, bidirected)
  VALUES(1, 'L1', 1, 2, 'Y',
    SDO_GEOMETRY(2002, NULL, NULL, 
      SDO_ELEM_INFO_ARRAY(1,2,1), 
        SDO_ORDINATE_ARRAY(1,1, 15,1)),
    14, 'Y');
-- L2
INSERT INTO sdo_net1_link$ (link_id, link_name, start_node_id, end_node_id,
     active, geometry, cost, bidirected)
   VALUES(2, 'L2', 2, 3, 'Y',
    SDO_GEOMETRY(2002, NULL, NULL, 
      SDO_ELEM_INFO_ARRAY(1,2,1), 
        SDO_ORDINATE_ARRAY(15,1, 9,4)),
    10, 'Y');
-- L3
INSERT INTO sdo_net1_link$ (link_id, link_name, start_node_id, end_node_id,
     active, geometry, cost, bidirected)
  VALUES(3, 'L3', 3, 1, 'Y',
    SDO_GEOMETRY(2002, NULL, NULL, 
      SDO_ELEM_INFO_ARRAY(1,2,1), 
        SDO_ORDINATE_ARRAY(9,4, 1,1)),
    10, 'Y');
 
-- Do not populate the SDO_NET1_PATH$ and SDO_NET1_PLINK$ tables now.
-- Do this only when you need to create any paths.
 
---------------------------------------------------------------------------
-- REMAINING STEPS NEEDED TO USE SPATIAL INDEXES --
---------------------------------------------------------------------------
-- Update the USER_SDO_GEOM_METADATA view. This is required before the
-- spatial index can be created. Do this only once for each layer
-- (that is, table-column combination).

INSERT INTO user_sdo_geom_metadata
    (TABLE_NAME,
     COLUMN_NAME,
     DIMINFO,
     SRID)
  VALUES (
    'SDO_NET1_NODE$',
    'GEOMETRY',
    SDO_DIM_ARRAY(   -- 20X20 grid
      SDO_DIM_ELEMENT('X', 0, 20, 0.005),
      SDO_DIM_ELEMENT('Y', 0, 20, 0.005)
       ),
    NULL   -- SRID (spatial reference system, also called coordinate system)
  );
INSERT INTO user_sdo_geom_metadata
    (TABLE_NAME,
     COLUMN_NAME,
     DIMINFO,
     SRID)
  VALUES (
    'SDO_NET1_LINK$',
    'GEOMETRY',
    SDO_DIM_ARRAY(   -- 20X20 grid
      SDO_DIM_ELEMENT('X', 0, 20, 0.005),
      SDO_DIM_ELEMENT('Y', 0, 20, 0.005)
       ),
    NULL   -- SRID (spatial reference system, also called coordinate system)
  );
 
-- Create the spatial indexes
CREATE INDEX sdo_net1_nodes_idx ON sdo_net1_node$(geometry)
  INDEXTYPE IS MDSYS.SPATIAL_INDEX;
CREATE INDEX sdo_net1_links_idx ON sdo_net1_link$(geometry)
  INDEXTYPE IS MDSYS.SPATIAL_INDEX;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHEHDGI"></a>
<div id="TOPOL948" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.13.2</span> Simple Logical Network Example (PL/SQL)</h3>
<p>This section presents an example of a very simple logical network that contains three nodes and a link between the nodes. The network is illustrated in <a href="#CIHGJJDF">Figure 5-5</a>.</p>
<div id="TOPOL949" class="figure">
<p class="titleinfigure"><a id="CIHGJJDF"></a>Figure 5-5 Simple Logical Network</p>
<img width="267" height="78" src="img/net_log_simple.gif" alt="Description of Figure 5-5 follows" /><br />
<a id="sthref882" href="img_text/net_log_simple.htm">Description of "Figure 5-5 Simple Logical Network"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As shown in <a href="#CIHGJJDF">Figure 5-5</a>, link <code>L1</code> is a straight line connecting nodes <code>N1</code> and <code>N2</code>, link <code>L2</code> is a straight line connecting nodes <code>N2</code> and <code>N3</code>, and link <code>L3</code> is a straight line connecting nodes <code>N3</code> and <code>N1</code>. There are no other nodes on any of the links.</p>
<p><a href="#CIHJFFJA">Example 5-3</a> calls the <a href="sdo_net_ref.htm#CHDFGEAI">SDO_NET.CREATE_LOGICAL_NETWORK</a> procedure, which does the following: creates the <code>LOG_NET1</code> directed network; creates the LOG_NET1_NODE$, LOG_NET1_LINK$, LOG_NET1_PATH$, and LOG_NET1_PLINK$ tables; and updates the xxx_SDO_NETWORK_METADATA views. Both the node and link tables contain a cost column named COST. (Because this is a logical network, there are no geometry columns.) The example also populates the node and link tables.</p>
<p><a href="#CIHJFFJA">Example 5-3</a> does not show the use of many SDO_NET functions and procedures; these are included in the logical hierarchical network example (<a href="#CIHCJAIG">Example 5-5</a>) in <a href="#CIHIJJEA">Section 5.13.4</a>.</p>
<div id="TOPOL950" class="example">
<p class="titleinexample"><a id="CIHJFFJA"></a>Example 5-3 Simple Logical Network Example (PL/SQL)</p>
<pre>
-- Creates the LOG_NET1 directed logical network. Also creates the
-- LOG_NET1_NODE$, LOG_NET1_LINK$, LOG_NET1_PATH$,
-- and LOG_NET1_PLINK$ tables, and updates USER_SDO_NETWORK_METADATA.
-- Both the node and link tables contain a cost column named COST. 
EXECUTE SDO_NET.CREATE_LOGICAL_NETWORK('LOG_NET1', 1, TRUE, TRUE);
 
-- Populate the LOG_NET1_NODE$ table.
-- N1
INSERT INTO log_net1_node$ (node_id, node_name, active, cost)
  VALUES (1, 'N1', 'Y', 2);
-- N2
INSERT INTO log_net1_node$ (node_id, node_name, active, cost)
  VALUES (2, 'N2', 'Y', 3);
-- N3
INSERT INTO log_net1_node$ (node_id, node_name, active, cost)
  VALUES (3, 'N3', 'Y', 2);
 
-- Populate the LOG_NET1_LINK$ table.
-- L1
INSERT INTO log_net1_link$ (link_id, link_name, start_node_id, end_node_id,
     active, link_level, cost)
  VALUES (1, 'L1', 1, 2, 'Y', 1, 10);
-- L2
INSERT INTO log_net1_link$ (link_id, link_name, start_node_id, end_node_id,
     active, link_level, cost)
  VALUES (2, 'L2', 2, 3, 'Y', 1, 7);
-- L3
INSERT INTO log_net1_link$ (link_id, link_name, start_node_id, end_node_id,
     active, link_level, cost)
  VALUES (3, 'L3', 3, 1, 'Y', 1, 8);
 
-- Do not populate the LOG_NET1_PATH$ and LOG_NET1_PLINK$ tables now.
-- Do this only when you need to create any paths.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHHDGHI"></a>
<div id="TOPOL951" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.13.3</span> Spatial (LRS) Network Example (PL/SQL)</h3>
<p>This section presents an example of a spatial (LRS) network that uses the roads (routes) illustrated in <a href="#i888413">Figure 5-6</a>. Each road is built from individual line segments (associated with links) taken from one or more road segment geometries, which are also shown in the figure.</p>
<div id="TOPOL952" class="figure">
<p class="titleinfigure"><a id="i888413"></a>Figure 5-6 Roads and Road Segments for Spatial (LRS) Network Example</p>
<img width="566" height="303" src="img/net_roads.gif" alt="Description of Figure 5-6 follows" /><br />
<a id="sthref883" href="img_text/net_roads.htm">Description of "Figure 5-6 Roads and Road Segments for Spatial (LRS) Network Example"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As shown in <a href="#i888413">Figure 5-6</a>:</p>
<ul>
<li>
<p><code>Route1</code> starts at point 2,2 and ends at point 5,14. It has the following nodes: <code>N1</code>, <code>N2</code>, <code>N3</code>, <code>N4</code>, <code>N5</code>, <code>N6</code>, and <code>N7</code>. It has the following links: <code>R1L1</code>, <code>R1L2</code>, <code>R1L3</code>, <code>R1L4</code>, <code>R1L5</code>, and <code>R1L6</code>.</p>
</li>
<li>
<p><code>Route2</code> starts at point 8,4 and ends at point 8,13. It has the following nodes: <code>N3</code>, <code>N6</code>, and <code>N8</code>. It has the following links: <code>R2L1</code> and <code>R2L2</code>.</p>
</li>
<li>
<p><code>Route3</code> starts at point 12,10 and ends at point 5,14. It has the following nodes: <code>N5</code>, <code>N8</code>, and <code>N7</code>. It has the following links: <code>R3L1</code> and <code>R3L2</code>.</p>
</li>
<li>
<p>The four road segment geometries are shown individually on the right side of the figure. (The points on each segment are labeled with their associated node names, to clarify how each segment geometry fits into the illustration on the left side.)</p>
</li>
</ul>
<p><a href="#CIHGEADB">Example 5-4</a> does the following:</p>
<ul>
<li>
<p>Creates a table to hold the road segment geometries.</p>
</li>
<li>
<p>Inserts four road segment geometries into the table.</p>
</li>
<li>
<p>Inserts the spatial metadata into the USER_SDO_GEOM_METADATA view.</p>
</li>
<li>
<p>Creates a spatial index on the geometry column in the ROAD_SEGMENTS table.</p>
</li>
<li>
<p>Creates and populates the node table.</p>
</li>
<li>
<p>Creates and populates the link table.</p>
</li>
<li>
<p>Creates and populates the path table and path-link table, for possible future use. (Before an application can use paths, you must populate these two tables.)</p>
</li>
<li>
<p>Inserts network metadata into the USER_SDO_NETWORK_METADATA view.</p>
</li>
<li>
<p>Uses various SDO_NET and SDO_NET_MEM functions and procedures.</p>
</li>
</ul>
<div id="TOPOL953" class="example">
<p class="titleinexample"><a id="CIHGEADB"></a>Example 5-4 Spatial (LRS) Network Example (PL/SQL)</p>
<pre>
---------------------------------------------------------------------------
-- CREATE AND POPULATE TABLE --
---------------------------------------------------------------------------
-- Create a table for road segments. Use LRS.
CREATE TABLE road_segments (
  segment_id  NUMBER PRIMARY KEY,
  segment_name  VARCHAR2(32),
  segment_geom  SDO_GEOMETRY, 
  geom_id NUMBER);
 
-- Populate the table with road segments.
INSERT INTO road_segments VALUES(
  1,
  'Segment1',
  SDO_GEOMETRY(
    3302,  -- line string, 3 dimensions (X,Y,M), 3rd is measure dimension
    NULL,
    NULL,
    SDO_ELEM_INFO_ARRAY(1,2,1), -- one line string, straight segments
    SDO_ORDINATE_ARRAY(
      2,2,0,   -- Starting point - Node1; 0 is measure from start.
      2,4,2,   -- Node2; 2 is measure from start. 
      8,4,8,   -- Node3; 8 is measure from start. 
      12,4,12) -- Node4; 12 is measure from start. 
  ), 1001
);
 
INSERT INTO road_segments VALUES(
  2,
  'Segment2',
  SDO_GEOMETRY(
    3302,  -- line string, 3 dimensions (X,Y,M), 3rd is measure dimension
    NULL,
    NULL,
    SDO_ELEM_INFO_ARRAY(1,2,1), -- one line string, straight segments
    SDO_ORDINATE_ARRAY(
      8,4,0,   -- Node3; 0 is measure from start. 
      8,10,6,  -- Node6; 6 is measure from start. 
      8,13,9)  -- Ending point - Node8; 9 is measure from start.
  ), 1002
);
 
INSERT INTO road_segments VALUES(
  3,
  'Segment3',
  SDO_GEOMETRY(
    3302,  -- line string, 3 dimensions (X,Y,M), 3rd is measure dimension
    NULL,
    NULL,
    SDO_ELEM_INFO_ARRAY(1,2,1), -- one line string, straight segments
    SDO_ORDINATE_ARRAY(
      12,4,0,     -- Node4; 0 is measure from start.
      12,10,6,    -- Node5; 6 is measure from start. 
      8,13,11,    -- Node8; 11 is measure from start. 
      5,14,14.16) -- Ending point - Node7; 14.16 is measure from start.
  ), 1003
);
 
INSERT INTO road_segments VALUES(
  4,
  'Segment4',
  SDO_GEOMETRY(
    3302,  -- line string, 3 dimensions (X,Y,M), 3rd is measure dimension
    NULL,
    NULL,
    SDO_ELEM_INFO_ARRAY(1,2,1), -- one line string, straight segments
    SDO_ORDINATE_ARRAY(
      12,10,0, -- Node5; 0 is measure from start.
      8,10,4,  -- Node6; 4 is measure from start.  
      5,14,9)  -- Ending point - Node7; 9 is measure from start.
  ), 1004
);
 
---------------------------------------------------------------------------
-- UPDATE THE SPATIAL METADATA --
---------------------------------------------------------------------------
-- Update the USER_SDO_GEOM_METADATA view. This is required before the
-- spatial index can be created. Do this only once for each layer
-- (that is, table-column combination; here: road_segment and segment_geom).
INSERT INTO user_sdo_geom_metadata
    (TABLE_NAME,
     COLUMN_NAME,
     DIMINFO,
     SRID)
  VALUES (
  'ROAD_SEGMENTS',
  'SEGMENT_GEOM',
  SDO_DIM_ARRAY(   -- 20X20 grid
    SDO_DIM_ELEMENT('X', 0, 20, 0.005),
    SDO_DIM_ELEMENT('Y', 0, 20, 0.005),
    SDO_DIM_ELEMENT('M', 0, 20, 0.005) -- Measure dimension
     ),
  NULL   -- SRID (spatial reference system, also called coordinate system)
);
 
-------------------------------------------------------------------
-- CREATE THE SPATIAL INDEX --
-------------------------------------------------------------------
CREATE INDEX road_segments_idx ON road_segments(segment_geom)
  INDEXTYPE IS MDSYS.SPATIAL_INDEX;
  
--------------------------------
-- USE SDO_NET SUBPROGRAMS
--------------------------------
 
-- This procedure does not use the CREATE_LRS_NETWORK procedure. Instead,
-- the user creates the network tables and populates the network metadata view.
-- Basic steps:
-- 1. Create and populate the node table.
-- 2. Create and populate the link table.
-- 3. Create the path table and paths and links table (for possible 
--    future use, before which they will need to be populated).
-- 4. Populate the network metadata (USER_SDO_NETWORK_METADATA).
--    Note: Can be done before or after Steps 1-3.
-- 5. Use various SDO_NET functions and procedures.
-- 6. Use SDO_NET_MEM functions and procedures for analysis and editing.
 
-- 1. Create and populate the node table.
EXECUTE SDO_NET.CREATE_NODE_TABLE('ROADS_NODES', 'LRS_GEOMETRY', 'NODE_GEOMETRY', 'COST', 1);
 
-- Populate the node table.
 
-- N1
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure) 
  VALUES (1, 'N1', 'Y', 1001, 0);
 
-- N2
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (2, 'N2', 'Y', 1001, 2);
 
-- N3
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (3, 'N3', 'Y', 1001, 8);
 
-- N4
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (4, 'N4', 'Y', 1001, 12);
 
-- N5
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (5, 'N5', 'Y', 1004, 0);
 
-- N6
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (6, 'N6', 'Y', 1002, 6);
 
-- N7
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (7, 'N7', 'Y', 1004, 9);
 
-- N8
INSERT INTO roads_nodes (node_id, node_name, active, geom_id, measure)
  VALUES (8, 'N8', 'Y', 1002, 9);
 
-- 2. Create and populate the link table.
EXECUTE SDO_NET.CREATE_LINK_TABLE('ROADS_LINKS', 'LRS_GEOMETRY', 'LINK_GEOMETRY', 'COST', 1);
 
-- Populate the link table.
 
-- Route1, Link1
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active, 
   cost, geom_id, start_measure, end_measure)
VALUES (101, 'R1L1', 1, 2, 'Y', 3, 1001, 0, 2);
 
-- Route1, Link2
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active, 
   cost, geom_id, start_measure, end_measure)
VALUES (102, 'R1L2', 2, 3, 'Y', 15, 1001, 2, 8);
 
 -- Route1, Link3
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (103, 'R1L3', 3, 4, 'Y', 10, 1001, 8, 12);
 
-- Route1, Link4
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (104, 'R1L4', 4, 5, 'Y', 15, 1003, 0, 6);
 
-- Route1, Link5
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (105, 'R1L5', 5, 6, 'Y', 10, 1004, 0, 4);
 
-- Route1, Link6
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (106, 'R1L6', 6, 7, 'Y', 7, 1004, 4, 9);
 
-- Route2, Link1 (cost = 30, a slow drive)
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (201, 'R2L1', 3, 6, 'Y', 30, 1002, 0, 6);
 
-- Route2, Link2
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (202, 'R2L2', 6, 8, 'Y', 5, 1002, 6, 9);
 
-- Route3, Link1
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (301, 'R3L1', 5, 8, 'Y', 5, 1003, 6, 11);
 
-- Route3, Link2
INSERT INTO roads_links (link_id, link_name, start_node_id, end_node_id, active,
   cost, geom_id, start_measure, end_measure)
VALUES (302, 'R3L2', 8, 7, 'Y', 5, 1003, 11, 14.16);
 
-- 3. Create the path table (to store created paths) and the path-link 
--    table (to store links for each path) for possible future use,
--    before which they will need to be populated.
EXECUTE SDO_NET.CREATE_PATH_TABLE('ROADS_PATHS', 'PATH_GEOMETRY');
EXECUTE SDO_NET.CREATE_PATH_LINK_TABLE('ROADS_PATHS_LINKS');
 
-- 4. Populate the network metadata (USER_SDO_NETWORK_METADATA).
 
INSERT INTO user_sdo_network_metadata 
    (NETWORK,
     NETWORK_CATEGORY,
     GEOMETRY_TYPE,
     NETWORK_TYPE,
     NO_OF_HIERARCHY_LEVELS,
     NO_OF_PARTITIONS,
     LRS_TABLE_NAME,
     LRS_GEOM_COLUMN,
     NODE_TABLE_NAME,
     NODE_GEOM_COLUMN,
     NODE_COST_COLUMN,
     LINK_TABLE_NAME,
     LINK_GEOM_COLUMN,
     LINK_DIRECTION,
     LINK_COST_COLUMN,
     PATH_TABLE_NAME,
     PATH_GEOM_COLUMN,
     PATH_LINK_TABLE_NAME)
  VALUES (
    'ROADS_NETWORK',  -- Network name
    'SPATIAL',  -- Network category
    'LRS_GEOMETRY',  -- Geometry type
    'Roadways',  -- Network type (user-defined)
    1,  -- No. of levels in hierarchy
    1,  -- No. of partitions
    'ROAD_SEGMENTS',   -- LRS table name
    'SEGMENT_GEOM' ,  -- LRS geometry column
    'ROADS_NODES',  -- Node table name
    'NODE_GEOMETRY',  -- Node geometry column
    'COST',  -- Node cost column
    'ROADS_LINKS',  -- Link table name
    'LINK_GEOMETRY',  -- Link geometry column
    'DIRECTED',  -- Link direction
    'COST',  -- Link cost column
    'ROADS_PATHS',  -- Path table name
    'PATH_GEOMETRY',  -- Path geometry column
    'ROADS_PATHS_LINKS'  -- Paths and links table
    );
 
-- 5. Use various SDO_NET functions and procedures.
 
-- Validate the network.
SELECT SDO_NET.VALIDATE_NETWORK('ROADS_NETWORK') FROM DUAL;
 
-- Validate parts or aspects of the network.
SELECT SDO_NET.VALIDATE_LINK_SCHEMA('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.VALIDATE_LRS_SCHEMA('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.VALIDATE_NODE_SCHEMA('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.VALIDATE_PATH_SCHEMA('ROADS_NETWORK') FROM DUAL;
 
-- Retrieve various information (GET_xxx and some other functions).
SELECT SDO_NET.GET_CHILD_LINKS('ROADS_NETWORK', 101) FROM DUAL;
SELECT SDO_NET.GET_CHILD_NODES('ROADS_NETWORK', 1) FROM DUAL;
SELECT SDO_NET.GET_GEOMETRY_TYPE('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_IN_LINKS('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_INVALID_LINKS('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_INVALID_NODES('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_INVALID_PATHS('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_ISOLATED_NODES('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LINK_COST_COLUMN('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LINK_DIRECTION('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LINK_GEOM_COLUMN('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LINK_GEOMETRY('ROADS_NETWORK', 103) FROM DUAL;
SELECT SDO_NET.GET_LINK_TABLE_NAME('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LRS_GEOM_COLUMN('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LRS_LINK_GEOMETRY('ROADS_NETWORK', 103) FROM DUAL;
SELECT SDO_NET.GET_LRS_NODE_GEOMETRY('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_LRS_TABLE_NAME('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NETWORK_CATEGORY('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NETWORK_ID('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NETWORK_NAME(3) FROM DUAL;
SELECT SDO_NET.GET_NETWORK_TYPE('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NO_OF_HIERARCHY_LEVELS('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NO_OF_LINKS('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NO_OF_NODES('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NODE_DEGREE('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_NODE_GEOM_COLUMN('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NODE_GEOMETRY('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_NODE_IN_DEGREE('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_NODE_OUT_DEGREE('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_NODE_TABLE_NAME('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NODE_COST_COLUMN('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NODE_HIERARCHY_LEVEL('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_OUT_LINKS('ROADS_NETWORK', 3) FROM DUAL;
SELECT SDO_NET.GET_PATH_GEOM_COLUMN('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_PATH_TABLE_NAME('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_COMPLEX('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_HIERARCHICAL('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_LOGICAL('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_SIMPLE('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_SPATIAL('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.LRS_GEOMETRY_NETWORK('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.NETWORK_EXISTS('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.SDO_GEOMETRY_NETWORK('ROADS_NETWORK') FROM DUAL;
SELECT SDO_NET.TOPO_GEOMETRY_NETWORK('ROADS_NETWORK') FROM DUAL;
 
-- Copy a network.
EXECUTE SDO_NET.COPY_NETWORK('ROADS_NETWORK', 'ROADS_NETWORK2');
 
-- Create a trigger.
EXECUTE SDO_NET.CREATE_DELETE_TRIGGER('ROADS_NETWORK');
 
-- 6. Use SDO_NET_MEM functions and procedures for analysis and editing.
 
-- Network analysis and other operations (SDO_NET_MEM.NETWORK_MANAGER)
 
DECLARE
  net_mem    VARCHAR2(100);
  res_string VARCHAR2(1000);
 
  cost        NUMBER;
  res_numeric NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
  indx1        NUMBER;
  var1_numeric NUMBER;
  var1_array   SDO_NUMBER_ARRAY;
 
BEGIN
 
net_mem := 'ROADS_NETWORK';
  
-- Read in the network.
SDO_NET_MEM.NETWORK_MANAGER.READ_NETWORK(net_mem, 'TRUE');
 
-- Validate the network.
res_string := SDO_NET_MEM.NETWORK_MANAGER.VALIDATE_NETWORK_SCHEMA(net_mem);
DBMS_OUTPUT.PUT_LINE('Is network ' || net_mem || ' valid? ' || res_string);
  
res_string := SDO_NET_MEM.NETWORK_MANAGER.LIST_NETWORKS;
DBMS_OUTPUT.PUT_LINE('The current in-memory network(s) is/are: ' || res_string);
 
res_numeric := SDO_NET_MEM.NETWORK_MANAGER.FIND_CONNECTED_COMPONENTS(net_mem);
DBMS_OUTPUT.PUT_LINE('The number of connected components is: ' || res_numeric);
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.MCST_LINK(net_mem);
DBMS_OUTPUT.PUT('Network ' || net_mem || ' has the following MCST links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.FIND_REACHABLE_NODES(net_mem,1);
DBMS_OUTPUT.PUT_LINE('Reachable nodes from 1: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.NEAREST_NEIGHBORS(net_mem,6,3);
DBMS_OUTPUT.PUT_LINE('Path IDs to the nearest 3 neighbors of node 6 are: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ', which contains links: ');
  var1_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, res_numeric);
    FOR indx1 IN var1_array.FIRST..var1_array.LAST
    LOOP
      var1_numeric := var1_array(indx1);
      DBMS_OUTPUT.PUT(var1_numeric || ' ');
    END LOOP;
    DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' '); 
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.NEAREST_NEIGHBORS(net_mem,6,3);
DBMS_OUTPUT.PUT_LINE('Path IDs to the nearest 3 neighbors of node 6 are: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ', whose end node is: ');
  var1_numeric := SDO_NET_MEM.PATH.GET_END_NODE_ID(net_mem, res_numeric);
  DBMS_OUTPUT.PUT(var1_numeric);
  DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' '); 
  
res_string := SDO_NET_MEM.NETWORK_MANAGER.IS_REACHABLE(net_mem,1,5);
DBMS_OUTPUT.PUT_LINE('Can node 1 reach node 5? ' || res_string);
  
res_array := SDO_NET_MEM.NETWORK_MANAGER.ALL_PATHS(net_mem,1,5,10,200,5);
DBMS_OUTPUT.PUT_LINE('For each path from node 1 to node 5: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric ||
                       ' has the following properties: ');
  cost := SDO_NET_MEM.PATH.GET_COST(net_mem, res_numeric);
  DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric || ' cost: ' || cost);
  res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, res_array(indx));  
  DBMS_OUTPUT.PUT_LINE('Is path ' || res_numeric || ' closed? ' || res_string);       
END LOOP;
   
DBMS_OUTPUT.PUT_LINE(' ');
res_numeric := SDO_NET_MEM.NETWORK_MANAGER.SHORTEST_PATH(net_mem,1,5);
DBMS_OUTPUT.PUT_LINE('The shortest path from node 1 to node 5 is path ID: ' || res_numeric);
 
DBMS_OUTPUT.PUT_LINE('The following are characteristics of this shortest path: ');
cost := SDO_NET_MEM.PATH.GET_COST(net_mem, res_numeric);
DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric || ' has cost: ' || cost);
res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, res_numeric);  
DBMS_OUTPUT.PUT_LINE('Is path ' || res_numeric || ' closed? ' || res_string);  
 
DBMS_OUTPUT.PUT_LINE(' ');
res_numeric := SDO_NET_MEM.NETWORK_MANAGER.SHORTEST_PATH_DIJKSTRA(net_mem,1,5);
DBMS_OUTPUT.PUT_LINE('The shortest Dijkstra path from node 1 to node 5 is ' || res_numeric);
 
DBMS_OUTPUT.PUT_LINE('The following are characteristics of this shortest path: ');
cost := SDO_NET_MEM.PATH.GET_COST(net_mem, res_numeric);
DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric || ' cost: ' || cost);
res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, res_numeric);  
DBMS_OUTPUT.PUT_LINE('Is path ' || res_numeric || ' closed? ' || res_string);  
    
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, res_numeric);   
DBMS_OUTPUT.PUT('Path ' || res_numeric || ' has links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
  
res_array := SDO_NET_MEM.PATH.GET_NODE_IDS(net_mem, res_numeric);   
DBMS_OUTPUT.PUT('Path ' || res_numeric || ' has nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.WITHIN_COST(net_mem,2,20);
DBMS_OUTPUT.PUT('Path IDs to nodes within cost of 40 from node 2: ');
DBMS_OUTPUT.PUT_LINE(' ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ', whose end node is: ');
  var1_numeric := SDO_NET_MEM.PATH.GET_END_NODE_ID(net_mem, res_numeric);
  DBMS_OUTPUT.PUT(var1_numeric);
  DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' '); 
 
END;  
/
 
-- Link editing (SDO_NET_MEM.LINK)
 
DECLARE
  net_mem     VARCHAR2(32);
  res_string  VARCHAR2(100);
  res_numeric NUMBER;
  res_geom    SDO_GEOMETRY;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN
 
net_mem := 'ROADS_NETWORK';
  
-- GET_COST
res_numeric := SDO_NET_MEM.LINK.GET_COST(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The cost of link 104 is: ' || res_numeric);
 
-- GET_END_MEASURE
res_numeric := SDO_NET_MEM.LINK.GET_END_MEASURE(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The end measure of link 104 is: ' || res_numeric);
 
-- GET_END_NODE_ID
res_numeric := SDO_NET_MEM.LINK.GET_END_NODE_ID(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The end node of link 104 is: ' || res_numeric);
 
-- GET_GEOM_ID
res_numeric := SDO_NET_MEM.LINK.GET_GEOM_ID(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The geometry ID of link 104 is: ' || res_numeric);
 
-- GET_GEOMETRY
res_geom := SDO_NET_MEM.LINK.GET_GEOMETRY(net_mem, 104);
 
-- GET_NAME
res_string := SDO_NET_MEM.LINK.GET_NAME(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The name of link 104 is: ' || res_string);
 
-- GET_START_MEASURE
res_numeric := SDO_NET_MEM.LINK.GET_START_MEASURE(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The start measure of link 104 is: ' || res_numeric);
 
-- GET_START_NODE_ID
res_numeric := SDO_NET_MEM.LINK.GET_START_NODE_ID(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The start node of link 104 is: ' || res_numeric);
 
-- GET_STATE
res_string := SDO_NET_MEM.LINK.GET_STATE(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('The state of link 104 is: ' || res_string);
 
-- IS_ACTIVE
res_string := SDO_NET_MEM.LINK.IS_ACTIVE(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('Is link 104 active?: ' || res_string);
 
-- IS_LOGICAL
res_string := SDO_NET_MEM.LINK.IS_LOGICAL(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('Is link 104 a logical link?: ' || res_string);
 
-- IS_TEMPORARY
res_string := SDO_NET_MEM.LINK.IS_TEMPORARY(net_mem, 104);
DBMS_OUTPUT.PUT_LINE('Is link 104 temporary?: ' || res_string);
 
-- SET_COST
-- Set the cost of link 302 to 6.
SDO_NET_MEM.LINK.SET_COST(net_mem, 302, 6);
 
-- SET_MEASURE
-- Set the measure value of link 302 as from 111 to 114.16.
SDO_NET_MEM.LINK.SET_MEASURE(net_mem, 302, 111, 114.16);
 
-- SET_NAME
-- Set the name of link 302 to 'My favorite link'.
SDO_NET_MEM.LINK.SET_NAME(net_mem, 302, 'My favorite link');
 
-- SET_STATE
-- Set the state of link 302 to 'FALSE'.
SDO_NET_MEM.LINK.SET_STATE(net_mem, 302, 'FALSE');
-- GET_STATE
res_string := SDO_NET_MEM.LINK.GET_STATE(net_mem, 302);
DBMS_OUTPUT.PUT_LINE('The state of link 302 is: ' || res_string);
 
-- SET_TYPE
-- Set the type of link 302 to 'Normal street'.
SDO_NET_MEM.LINK.SET_TYPE(net_mem, 302, 'Normal street');
-- GET_TYPE
res_string := SDO_NET_MEM.LINK.GET_TYPE(net_mem, 302);
DBMS_OUTPUT.PUT_LINE('The type of link 302 is: ' || res_string);
 
END;  
/
 
-- Node editing (SDO_NET_MEM.NODE)
 
DECLARE
  net_mem     VARCHAR2(32);
  res_string  VARCHAR2(100);
  res_numeric NUMBER;
  res_geom    SDO_GEOMETRY;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN
 
net_mem := 'ROADS_NETWORK';
  
-- GET_COMPONENT_NO
res_numeric := SDO_NET_MEM.NODE.GET_COMPONENT_NO(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('The component number of node 3 is: ' || res_numeric);
 
-- GET_COST
res_numeric := SDO_NET_MEM.NODE.GET_COST(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('The cost of node 3 is: ' || res_numeric);
 
-- GET_GEOM_ID
res_numeric := SDO_NET_MEM.NODE.GET_GEOM_ID(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('The geometry ID of node 3 is: ' || res_numeric);
 
-- GET_GEOMETRY
res_geom := SDO_NET_MEM.NODE.GET_GEOMETRY(net_mem, 3);
 
-- GET_IN_LINK_IDS
res_array := SDO_NET_MEM.NODE.GET_IN_LINK_IDS(net_mem, 3);
DBMS_OUTPUT.PUT('Node 3 has the following inbound links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_INCIDENT_LINK_IDS
res_array := SDO_NET_MEM.NODE.GET_INCIDENT_LINK_IDS(net_mem, 3);
DBMS_OUTPUT.PUT('Node 3 has the following incident links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_MEASURE
res_numeric := SDO_NET_MEM.NODE.GET_MEASURE(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('The measure value of node 3 is: ' || res_numeric);
 
-- GET_NAME
res_string := SDO_NET_MEM.NODE.GET_NAME(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('The name of node 3 is: ' || res_string);
 
-- GET_OUT_LINK_IDS
res_array := SDO_NET_MEM.NODE.GET_OUT_LINK_IDS(net_mem, 3);
DBMS_OUTPUT.PUT('Node 3 has the following outbound links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_STATE
res_string := SDO_NET_MEM.NODE.GET_STATE(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('The state of node 3 is: ' || res_string);
 
-- IS_ACTIVE
res_string := SDO_NET_MEM.NODE.IS_ACTIVE(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('Is node 3 active?: ' || res_string);
 
-- IS_LOGICAL
res_string := SDO_NET_MEM.NODE.IS_LOGICAL(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('Is node 3 a logical node?: ' || res_string);
 
-- IS_TEMPORARY
res_string := SDO_NET_MEM.NODE.IS_TEMPORARY(net_mem, 3);
DBMS_OUTPUT.PUT_LINE('Is node 3 temporary?: ' || res_string);
 
-- LINK_EXISTS
res_string := SDO_NET_MEM.NODE.LINK_EXISTS(net_mem, 3, 4);
DBMS_OUTPUT.PUT_LINE('Does a link exist between nodes 3 and 4?: ' || res_string);
 
-- MAKE_TEMPORARY
-- Make node 7 temporary.
SDO_NET_MEM.NODE.MAKE_TEMPORARY(net_mem, 7);
 
-- SET_COMPONENT_NO
-- Set the component number of node 7 to 987.
SDO_NET_MEM.NODE.SET_COMPONENT_NO(net_mem, 7, 987);
 
-- SET_COST
-- Set the cost of node 7 to 40.
SDO_NET_MEM.NODE.SET_COST(net_mem, 7, 40);
 
-- SET_GEOM_ID
-- Set the geometry ID of node 7 to 99.
SDO_NET_MEM.NODE.SET_GEOM_ID(net_mem, 7, 99);
 
-- SET_MEASURE
-- Set the measure value of node 7 to 30.
SDO_NET_MEM.NODE.SET_MEASURE(net_mem, 7, 30);
 
-- SET_NAME
-- Set the name of node 7 to 'My favorite node'.
SDO_NET_MEM.NODE.SET_NAME(net_mem, 7, 'My favorite node');
-- GET_NAME
res_string := SDO_NET_MEM.NODE.GET_NAME(net_mem, 7);
DBMS_OUTPUT.PUT_LINE('The name of node 7 is: ' || res_string);
 
-- SET_STATE
-- Set the state of node 7 to 'FALSE'.
SDO_NET_MEM.NODE.SET_STATE(net_mem, 7, 'FALSE');
-- GET_STATE
res_string := SDO_NET_MEM.NODE.GET_STATE(net_mem, 7);
DBMS_OUTPUT.PUT_LINE('The state of node 7 is: ' || res_string);
 
-- SET_TYPE
-- Set the type of node 7 to 'Historic site'.
SDO_NET_MEM.NODE.SET_TYPE(net_mem, 7, 'Historic site');
-- GET_TYPE
res_string := SDO_NET_MEM.NODE.GET_TYPE(net_mem, 7);
DBMS_OUTPUT.PUT_LINE('The type of node 7 is: ' || res_string);
 
END;  
/
 
-- Path editing (SDO_NET_MEM.PATH)
 
DECLARE
  net_mem     VARCHAR2(32);
  res_string  VARCHAR2(100);
  res_numeric NUMBER;
  res_geom    SDO_GEOMETRY;
  path_id     NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN
 
net_mem := 'ROADS_NETWORK';
  
-- Create a path for use with subsequent statements. Here, it is
-- the shortest path between nodes 1 (N1) and 5 (N5).
path_id := SDO_NET_MEM.NETWORK_MANAGER.SHORTEST_PATH(net_mem,1,5);
DBMS_OUTPUT.PUT_LINE('The shortest path between nodes 1 and 5 is: ' || path_id);
 
-- GET_LINK_IDS
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Path ' || path_id || ' has the following links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_COST
res_numeric := SDO_NET_MEM.PATH.GET_COST(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The cost of path ' || path_id || ' is: ' || res_numeric);
 
-- GET_END_NODE_ID
res_numeric := SDO_NET_MEM.PATH.GET_END_NODE_ID(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The end node ID of path ' || path_id || ' is: ' || res_numeric);
 
-- GET_GEOMETRY
res_geom := SDO_NET_MEM.PATH.GET_GEOMETRY(net_mem, path_id);
-- doesn't work DBMS_OUTPUT.PUT_LINE('The geometry of path ' || path_id || ' is: ' || res_geom);
 
-- GET_LINK_IDS
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Path ' || path_id || ' has the following links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_NAME
res_string := SDO_NET_MEM.PATH.GET_NAME(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The name of path ' || path_id || ' is: ' || res_string);
 
-- GET_NO_OF_LINKS
res_numeric := SDO_NET_MEM.PATH.GET_NO_OF_LINKS(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The number of links in path ' || path_id || ' is: ' || res_numeric);
 
-- GET_NODE_IDS
res_array := SDO_NET_MEM.PATH.GET_NODE_IDS(net_mem, path_id);
DBMS_OUTPUT.PUT('Path ' || path_id || ' has the following nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_START_NODE_ID
res_numeric := SDO_NET_MEM.PATH.GET_START_NODE_ID(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The start node ID of path ' || path_id || ' is: ' || res_numeric);
 
-- IS_ACTIVE
res_string := SDO_NET_MEM.PATH.IS_ACTIVE(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' active?: ' || res_string);
 
-- IS_CLOSED
res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' closed?: ' || res_string);
 
-- IS_CONNECTED
res_string := SDO_NET_MEM.PATH.IS_CONNECTED(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' connected?: ' || res_string);
 
-- IS_LOGICAL
res_string := SDO_NET_MEM.PATH.IS_LOGICAL(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' a logical path?: ' || res_string);
 
-- IS_SIMPLE
res_string := SDO_NET_MEM.PATH.IS_SIMPLE(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' a simple path?: ' || res_string);
 
-- IS_TEMPORARY
res_string := SDO_NET_MEM.PATH.IS_TEMPORARY(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' temporary?: ' || res_string);
 
-- SET_NAME
-- Set the name of path to 'My favorite path'.
SDO_NET_MEM.PATH.SET_NAME(net_mem, path_id, 'My favorite path');
-- GET_NAME
res_string := SDO_NET_MEM.PATH.GET_NAME(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The name of path ' || path_id || ' is: ' || res_string);
 
-- SET_TYPE
-- Set the type of the path to 'Scenic'.
SDO_NET_MEM.PATH.SET_TYPE(net_mem, path_id, 'Scenic');
-- GET_TYPE
res_string := SDO_NET_MEM.PATH.GET_TYPE(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The type of path ' || path_id || ' is: ' || res_string);
 
-- SET_PATH_ID
-- Set (change) the path ID of the path to 6789.
SDO_NET_MEM.PATH.SET_PATH_ID(net_mem, path_id, 6789);
 
END;  
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHIJJEA"></a>
<div id="TOPOL954" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.13.4</span> Logical Hierarchical Network Example (PL/SQL)</h3>
<p>This section presents an example of a logical network that contains the nodes and links illustrated in <a href="#CIHICBBJ">Figure 5-7</a>. Because it is a logical network, there are no spatial geometries associated with it. (<a href="#CIHICBBJ">Figure 5-7</a> is essentially the same as <a href="#CIHJJIEJ">Figure 5-3</a> in <a href="#CIHDHHGB">Section 5.5</a>, but with the nodes and links labeled.)</p>
<div id="TOPOL955" class="figure">
<p class="titleinfigure"><a id="CIHICBBJ"></a>Figure 5-7 Nodes and Links for Logical Network Example</p>
<img width="459" height="280" src="img/net_hier2.gif" alt="Description of Figure 5-7 follows" /><br />
<a id="sthref884" href="img_text/net_hier2.htm">Description of "Figure 5-7 Nodes and Links for Logical Network Example"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As shown in <a href="#CIHICBBJ">Figure 5-7</a>:</p>
<ul>
<li>
<p>The network is hierarchical, with two levels. The top level (level 2) consists of two nodes (<code>HN1</code> and <code>HN2</code>), and the remaining nodes and links are in the bottom level (level 1) of the hierarchy.</p>
</li>
<li>
<p>Each node in level 1 is a child node of one of the nodes in level 2. Node <code>HN1</code> has the following child nodes: <code>N1</code>, <code>N2</code>, <code>N3</code>, <code>N4</code>, <code>N5</code>, and <code>N6</code>. Node <code>HN2</code> has the following child nodes: <code>N7</code>, <code>N8</code>, <code>N9</code>, <code>N10</code>, <code>N11</code>, <code>N12</code>, <code>N13</code>, and <code>N14</code>.</p>
</li>
<li>
<p>One link (<code>HN1HN2</code>) links nodes <code>HN1</code> and <code>HN2</code>, and two links (<code>N5N8</code> and <code>N6N7</code>) are child links of parent link <code>HN1HN2</code>. Note, however, that links are not associated with a specific network hierarchy level.</p>
</li>
</ul>
<p><a href="#CIHCJAIG">Example 5-5</a> does the following:</p>
<ul>
<li>
<p>Creates and populates the node table.</p>
</li>
<li>
<p>Creates and populates the link table.</p>
</li>
<li>
<p>Creates and populates the path table and path-link table, for possible future use. (Before an application can use paths, you must populate these two tables.)</p>
</li>
<li>
<p>Inserts network metadata into the USER_SDO_NETWORK_METADATA view.</p>
</li>
<li>
<p>Uses various SDO_NET functions and procedures.</p>
</li>
<li>
<p>Uses SDO_NET_MEM functions and procedures for analysis and editing.</p>
</li>
</ul>
<div id="TOPOL956" class="example">
<p class="titleinexample"><a id="CIHCJAIG"></a>Example 5-5 Logical Network Example (PL/SQL)</p>
<pre>
-- Basic steps:
-- 1. Create and populate the node table.
-- 2. Create and populate the link table.
-- 3. Create the path table and paths and links table (for possible 
--    future use, before which they will need to be populated).
-- 4. Populate the network metadata (USER_SDO_NETWORK_METADATA).
--    Note: Can be done before or after Steps 1-3.
-- 5. Use various SDO_NET functions and procedures.
-- 6. Use SDO_NET_MEM functions and procedures for analysis and editing.
 
-- 1. Create and populate the node table.
EXECUTE SDO_NET.CREATE_NODE_TABLE('XYZ_NODES', NULL, NULL, NULL, 2);
 
-- Populate the node table, starting with the highest level in the hierarchy.
 
-- HN1 (Hierarchy level=2, highest in this network)
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level)
  VALUES (1, 'HN1', 'Y', 2);
 
-- HN2 (Hierarchy level=2, highest in this network)
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level)
  VALUES (2, 'HN2', 'Y', 2);
 
-- N1 (Hierarchy level 1, parent node ID = 1 for N1 through N6)
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (101, 'N1', 'Y', 1, 1);
 
-- N2 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (102, 'N2', 'Y', 1, 1);
 
-- N3 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (103, 'N3', 'Y', 1, 1);
 
-- N4 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (104, 'N4', 'Y', 1, 1);
 
-- N5 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (105, 'N5', 'Y', 1, 1);
 
-- N6 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (106, 'N6', 'Y', 1, 1);
 
-- N7 (Hierarchy level 1, parent node ID = 2 for N7 through N14)
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (107, 'N7', 'Y', 1, 2);
 
-- N8 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (108, 'N8', 'Y', 1, 2);
 
-- N9 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (109, 'N9', 'Y', 1, 2);
 
-- N10 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (110, 'N10', 'Y', 1, 2);
 
-- N11 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (111, 'N11', 'Y', 1, 2);
 
-- N12 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (112, 'N12', 'Y', 1, 2);
 
-- N13 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (113, 'N13', 'Y', 1, 2);
 
-- N14 
INSERT INTO xyz_nodes (node_id, node_name, active, hierarchy_level, 
     parent_node_id)
  VALUES (114, 'N14', 'Y', 1, 2);
 
-- 2. Create and populate the link table.
EXECUTE SDO_NET.CREATE_LINK_TABLE('XYZ_LINKS', NULL, NULL, 'COST', 2);
 
-- Populate the link table.
 
-- HN1HN2 (single link in highest hierarchy level: link level = 2)
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level)
  VALUES (1001, 'HN1HN2', 1, 2, 'Y', 2);
 
-- For remaining links, link level = 1 and cost (10, 20, or 30) varies among links.
-- N1N2
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1101, 'N1N2', 101, 102, 'Y', 1, 10);
 
-- N1N3
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1102, 'N1N3', 101, 103, 'Y', 1, 20);
 
-- N2N3
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1103, 'N2N3', 102, 103, 'Y', 1, 30);
 
-- N3N4
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1104, 'N3N4', 103, 104, 'Y', 1, 10);
 
-- N4N5
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1105, 'N4N5', 104, 105, 'Y', 1, 20);
 
-- N4N6
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1106, 'N4N6', 104, 106, 'Y', 1, 30);
 
-- N5N6
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1107, 'N5N6', 105, 106, 'Y', 1, 10);
 
-- N5N8 (child of the higher-level link: parent ID = 1001)
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost, parent_link_id)
  VALUES (1108, 'N5N8', 105, 108, 'Y', 1, 20, 1001);
 
-- N6N7 (child of the higher-level link: parent ID = 1001)
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost, parent_link_id)
  VALUES (1109, 'N6N7', 106, 107, 'Y', 1, 30, 1001);
 
-- N7N8
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1110, 'N7N8', 107, 108, 'Y', 1, 10);
 
-- N7N9
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1111, 'N7N9', 107, 109, 'Y', 1, 20);
 
-- N8N9
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1112, 'N8N9', 108, 109, 'Y', 1, 30);
 
-- N9N10
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1113, 'N9N10', 109, 110, 'Y', 1, 30);
 
-- N9N13
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1114, 'N9N13', 109, 113, 'Y', 1, 10);
 
-- N10N11
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1115, 'N10N11', 110, 111, 'Y', 1, 20);
 
-- N11N12
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1116, 'N11N12', 111, 112, 'Y', 1, 30);
 
-- N12N13
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1117, 'N12N13', 112, 113, 'Y', 1, 10);
 
-- N12N14
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1118, 'N12N14', 112, 114, 'Y', 1, 20);
 
-- N13N14
INSERT INTO xyz_links (link_id, link_name, start_node_id, end_node_id, active, 
     link_level, cost)
  VALUES (1119, 'N13N14', 113, 114, 'Y', 1, 30);
 
-- 3. Create the path table (to store created paths) and the path-link 
--    table (to store links for each path) for possible future use,
--    before which they will need to be populated.
EXECUTE SDO_NET.CREATE_PATH_TABLE('XYZ_PATHS', NULL);
EXECUTE SDO_NET.CREATE_PATH_LINK_TABLE('XYZ_PATHS_LINKS');
 
-- 4. Populate the network metadata (USER_SDO_NETWORK_METADATA).
 
INSERT INTO user_sdo_network_metadata 
    (NETWORK,
     NETWORK_CATEGORY,
     NO_OF_HIERARCHY_LEVELS,
     NO_OF_PARTITIONS,
     NODE_TABLE_NAME,
     LINK_TABLE_NAME,
     LINK_DIRECTION,
     LINK_COST_COLUMN,
     PATH_TABLE_NAME,
     PATH_LINK_TABLE_NAME)
  VALUES (
    'XYZ_NETWORK',  -- Network name
    'LOGICAL',   -- Network category
    2,  -- No. of levels in hierarchy
    1,  -- No. of partitions
    'XYZ_NODES',  -- Node table name
    'XYZ_LINKS',  -- Link table name
    'BIDIRECTED',  -- Link direction
    'COST',  -- Link cost column
    'XYZ_PATHS',  -- Path table name
    'XYZ_PATHS_LINKS'  -- Path-link table name
  );
 
-- 5. Use various SDO_NET functions and procedures.
 
-- Validate the network.
SELECT SDO_NET.VALIDATE_NETWORK('XYZ_NETWORK') FROM DUAL;
 
-- Validate parts or aspects of the network.
SELECT SDO_NET.VALIDATE_LINK_SCHEMA('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.VALIDATE_LRS_SCHEMA('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.VALIDATE_NODE_SCHEMA('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.VALIDATE_PATH_SCHEMA('XYZ_NETWORK') FROM DUAL;
 
-- Retrieve various information (GET_xxx and some other functions).
SELECT SDO_NET.GET_CHILD_LINKS('XYZ_NETWORK', 1001) FROM DUAL;
SELECT SDO_NET.GET_CHILD_NODES('XYZ_NETWORK', 1) FROM DUAL;
SELECT SDO_NET.GET_CHILD_NODES('XYZ_NETWORK', 2) FROM DUAL;
SELECT SDO_NET.GET_IN_LINKS('XYZ_NETWORK', 104) FROM DUAL;
SELECT SDO_NET.GET_LINK_COST_COLUMN('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LINK_DIRECTION('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_LINK_TABLE_NAME('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NETWORK_TYPE('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NO_OF_HIERARCHY_LEVELS('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NO_OF_LINKS('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NO_OF_NODES('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.GET_NODE_DEGREE('XYZ_NETWORK', 104) FROM DUAL;
SELECT SDO_NET.GET_NODE_IN_DEGREE('XYZ_NETWORK', 104) FROM DUAL;
SELECT SDO_NET.GET_NODE_OUT_DEGREE('XYZ_NETWORK', 104) FROM DUAL;
SELECT SDO_NET.GET_OUT_LINKS('XYZ_NETWORK', 104) FROM DUAL;
SELECT SDO_NET.GET_PATH_TABLE_NAME('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_HIERARCHICAL('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_LOGICAL('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.IS_SPATIAL('XYZ_NETWORK') FROM DUAL;
SELECT SDO_NET.NETWORK_EXISTS('XYZ_NETWORK') FROM DUAL;
 
-- Copy a network.
EXECUTE SDO_NET.COPY_NETWORK('XYZ_NETWORK', 'XYZ_NETWORK2');
 
-- Create a trigger.
EXECUTE SDO_NET.CREATE_DELETE_TRIGGER('XYZ_NETWORK');
 
-- 6. Use SDO_NET_MEM functions and procedures for analysis and editing.
 
-- Network analysis and other operations (SDO_NET_MEM.NETWORK_MANAGER)
 
DECLARE
  net_mem    VARCHAR2(100);
  res_string VARCHAR2(1000);
 
  cost        NUMBER;
  res_numeric NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
  indx1        NUMBER;
  var1_numeric NUMBER;
  var1_array   SDO_NUMBER_ARRAY;
 
BEGIN
 
net_mem := 'XYZ_NETWORK';
  
-- Read in the network.
SDO_NET_MEM.NETWORK_MANAGER.READ_NETWORK(net_mem, 'TRUE');
 
-- Validate the network.
res_string := SDO_NET_MEM.NETWORK_MANAGER.VALIDATE_NETWORK_SCHEMA(net_mem);
DBMS_OUTPUT.PUT_LINE('Is network ' || net_mem || ' valid? ' || res_string);
  
res_string := SDO_NET_MEM.NETWORK_MANAGER.LIST_NETWORKS;
DBMS_OUTPUT.PUT_LINE('The current in-memory network(s) is/are: ' || res_string);
 
res_numeric := SDO_NET_MEM.NETWORK_MANAGER.FIND_CONNECTED_COMPONENTS(net_mem);
DBMS_OUTPUT.PUT_LINE('The number of connected components is: ' || res_numeric);
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.MCST_LINK(net_mem);
DBMS_OUTPUT.PUT('Network ' || net_mem || ' has the following MCST links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.FIND_REACHABLE_NODES(net_mem,101);
DBMS_OUTPUT.PUT_LINE('Reachable nodes from 101: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.FIND_REACHING_NODES(net_mem,101);
DBMS_OUTPUT.PUT_LINE('Nodes from which 101 can be reached: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
  
res_array := SDO_NET_MEM.NETWORK_MANAGER.NEAREST_NEIGHBORS(net_mem,101,3);
DBMS_OUTPUT.PUT_LINE('Path IDs to the nearest 3 neighbors of node 101 are: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ', which contains links: ');
  var1_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, res_numeric);
    FOR indx1 IN var1_array.FIRST..var1_array.LAST
    LOOP
      var1_numeric := var1_array(indx1);
      DBMS_OUTPUT.PUT(var1_numeric || ' ');
    END LOOP;
    DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' '); 
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.NEAREST_NEIGHBORS(net_mem,101,3);
DBMS_OUTPUT.PUT_LINE('Path IDs to the nearest 3 neighbors of node 101 are: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ', whose end node is: ');
  var1_numeric := SDO_NET_MEM.PATH.GET_END_NODE_ID(net_mem, res_numeric);
  DBMS_OUTPUT.PUT(var1_numeric);
  DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' '); 
  
res_string := SDO_NET_MEM.NETWORK_MANAGER.IS_REACHABLE(net_mem,101,105);
DBMS_OUTPUT.PUT_LINE('Can node 101 reach node 105? ' || res_string);
  
res_array := SDO_NET_MEM.NETWORK_MANAGER.ALL_PATHS(net_mem,101,105,10,200,5);
DBMS_OUTPUT.PUT_LINE('For each path from node 101 to node 105: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric ||
                       ' has the following properties: ');
  cost := SDO_NET_MEM.PATH.GET_COST(net_mem, res_numeric);
  DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric || ' cost: ' || cost);
  res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, res_array(indx));  
  DBMS_OUTPUT.PUT_LINE('Is path ' || res_numeric || ' closed? ' || res_string);       
END LOOP;
   
DBMS_OUTPUT.PUT_LINE(' ');
res_numeric := SDO_NET_MEM.NETWORK_MANAGER.SHORTEST_PATH(net_mem,101,105);
DBMS_OUTPUT.PUT_LINE('The shortest path from node 101 to node 105 is path ID: ' || res_numeric);
 
DBMS_OUTPUT.PUT_LINE('The following are characteristics of this shortest path: ');
cost := SDO_NET_MEM.PATH.GET_COST(net_mem, res_numeric);
DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric || ' has cost: ' || cost);
res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, res_numeric);  
DBMS_OUTPUT.PUT_LINE('Is path ' || res_numeric || ' closed? ' || res_string);  
 
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, res_numeric);   
DBMS_OUTPUT.PUT('Path ' || res_numeric || ' has links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
DBMS_OUTPUT.PUT_LINE(' ');
res_numeric := SDO_NET_MEM.NETWORK_MANAGER.SHORTEST_PATH_DIJKSTRA(net_mem,101,105);
DBMS_OUTPUT.PUT_LINE('The shortest Dijkstra path from node 101 to node 105 is ' || res_numeric);
 
DBMS_OUTPUT.PUT_LINE('The following are characteristics of this shortest path: ');
cost := SDO_NET_MEM.PATH.GET_COST(net_mem, res_numeric);
DBMS_OUTPUT.PUT_LINE('Path ' || res_numeric || ' cost: ' || cost);
res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, res_numeric);  
DBMS_OUTPUT.PUT_LINE('Is path ' || res_numeric || ' closed? ' || res_string);  
 
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, res_numeric);   
DBMS_OUTPUT.PUT('Path ' || res_numeric || ' has links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
  
res_array := SDO_NET_MEM.PATH.GET_NODE_IDS(net_mem, res_numeric);   
DBMS_OUTPUT.PUT('Path ' || res_numeric || ' has nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
res_array := SDO_NET_MEM.NETWORK_MANAGER.WITHIN_COST(net_mem,102,100);
DBMS_OUTPUT.PUT('Shortest path IDs to nodes within cost of 100 from node 102: ');
DBMS_OUTPUT.PUT_LINE(' ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  res_numeric := res_array(indx);
  DBMS_OUTPUT.PUT(res_numeric || ', whose end node is: ');
  var1_numeric := SDO_NET_MEM.PATH.GET_END_NODE_ID(net_mem, res_numeric);
  DBMS_OUTPUT.PUT(var1_numeric);
  DBMS_OUTPUT.PUT_LINE(' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' '); 
 
END;  
/
 
-- Link editing (SDO_NET_MEM.LINK)
 
DECLARE
  net_mem     VARCHAR2(32);
  res_string  VARCHAR2(100);
  res_numeric NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN
 
net_mem := 'XYZ_NETWORK';
  
-- Read in the network.
-- SDO_NET_MEM.NETWORK_MANAGER.READ_NETWORK(net_mem, 'TRUE');
 
-- GET_CHILD_LINKS
res_array := SDO_NET_MEM.LINK.GET_CHILD_LINKS(net_mem, 1001);
DBMS_OUTPUT.PUT('Link 1001 has the following child links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_COST
res_numeric := SDO_NET_MEM.LINK.GET_COST(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('The cost of link 1104 is: ' || res_numeric);
 
-- GET_END_NODE_ID
res_numeric := SDO_NET_MEM.LINK.GET_END_NODE_ID(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('The end node of link 1104 is: ' || res_numeric);
 
-- GET_LEVEL
res_numeric := SDO_NET_MEM.LINK.GET_LEVEL(net_mem, 1001);
DBMS_OUTPUT.PUT_LINE('The hierarchy level of link 1001 is: ' || res_numeric);
 
-- GET_NAME
res_string := SDO_NET_MEM.LINK.GET_NAME(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('The name of link 1104 is: ' || res_string);
 
-- GET_PARENT_LINK_ID
res_numeric := SDO_NET_MEM.LINK.GET_PARENT_LINK_ID(net_mem, 1108);
DBMS_OUTPUT.PUT_LINE('The parent link of link 1108 is: ' || res_numeric);
 
-- GET_SIBLING_LINK_IDS
res_array := SDO_NET_MEM.LINK.GET_SIBLING_LINK_IDS(net_mem, 1108);
DBMS_OUTPUT.PUT('Link 1108 has the following sibling links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');

-- GET_START_NODE_ID
res_numeric := SDO_NET_MEM.LINK.GET_START_NODE_ID(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('The start node of link 1104 is: ' || res_numeric);
 
-- GET_STATE
res_string := SDO_NET_MEM.LINK.GET_STATE(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('The state of link 1104 is: ' || res_string);
 
-- IS_ACTIVE
res_string := SDO_NET_MEM.LINK.IS_ACTIVE(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('Is link 1104 active?: ' || res_string);
 
-- IS_LOGICAL
res_string := SDO_NET_MEM.LINK.IS_LOGICAL(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('Is link 1104 a logical link?: ' || res_string);
 
-- IS_TEMPORARY
res_string := SDO_NET_MEM.LINK.IS_TEMPORARY(net_mem, 1104);
DBMS_OUTPUT.PUT_LINE('Is link 1104 temporary?: ' || res_string);
 
-- SET_COST
-- Set the cost of link 1119 to 40.
SDO_NET_MEM.LINK.SET_COST(net_mem, 1119, 40);
 
-- SET_END_NODE
-- Set the end node of link 1119 to 109 (N9).
SDO_NET_MEM.LINK.SET_END_NODE(net_mem, 1119, 109);
 
-- SET_LEVEL
-- Set the hierarchy level of link 1119 to 2.
SDO_NET_MEM.LINK.SET_LEVEL(net_mem, 1119, 2);
 
-- SET_NAME
-- Set the name of link 1119 to 'My favorite link'.
SDO_NET_MEM.LINK.SET_NAME(net_mem, 1119, 'My favorite link');
 
-- SET_PARENT_LINK
-- Make link 1001 the parent of link 1119.
SDO_NET_MEM.LINK.SET_PARENT_LINK(net_mem, 1119, 1001);
 
-- SET_START_NODE
-- Set the start node of link 1119 to 110 (N10).
SDO_NET_MEM.LINK.SET_START_NODE(net_mem, 1119, 110);
 
-- SET_STATE
-- Set the state of link 1119 to 'FALSE'.
SDO_NET_MEM.LINK.SET_STATE(net_mem, 1119, 'FALSE');
-- GET_STATE
res_string := SDO_NET_MEM.LINK.GET_STATE(net_mem, 1119);
DBMS_OUTPUT.PUT_LINE('The state of link 1119 is: ' || res_string);
 
-- SET_TYPE
-- Set the type of link 1119 to 'Associative'.
SDO_NET_MEM.LINK.SET_TYPE(net_mem, 1119, 'Associative');
-- GET_TYPE
res_string := SDO_NET_MEM.LINK.GET_TYPE(net_mem, 1119);
DBMS_OUTPUT.PUT_LINE('The type of link 1119 is: ' || res_string);
 
END;  
/
 
-- Node editing (SDO_NET_MEM.NODE)
 
DECLARE
  net_mem     VARCHAR2(32);
  res_string  VARCHAR2(100);
  res_numeric NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN
 
net_mem := 'XYZ_NETWORK';
  
-- GET_ADJACENT_NODE_IDS
res_array := SDO_NET_MEM.NODE.GET_ADJACENT_NODE_IDS(net_mem, 103);
DBMS_OUTPUT.PUT('Node 103 has the following adjacent nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');

-- GET_CHILD_NODE_IDS
res_array := SDO_NET_MEM.NODE.GET_CHILD_NODE_IDS(net_mem, 1);
DBMS_OUTPUT.PUT('Node 1 has the following child nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_COMPONENT_NO
res_numeric := SDO_NET_MEM.NODE.GET_COMPONENT_NO(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('The component number of node 103 is: ' || res_numeric);
 
-- GET_COST
res_numeric := SDO_NET_MEM.NODE.GET_COST(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('The cost of node 103 is: ' || res_numeric);
 
-- GET_HIERARCHY_LEVEL
res_numeric := SDO_NET_MEM.NODE.GET_HIERARCHY_LEVEL(net_mem, 1);
DBMS_OUTPUT.PUT_LINE('The hierarchy level of node 1 is: ' || res_numeric);
 
-- GET_IN_LINK_IDS
res_array := SDO_NET_MEM.NODE.GET_IN_LINK_IDS(net_mem, 103);
DBMS_OUTPUT.PUT('Node 103 has the following inbound links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_INCIDENT_LINK_IDS
res_array := SDO_NET_MEM.NODE.GET_INCIDENT_LINK_IDS(net_mem, 103);
DBMS_OUTPUT.PUT('Node 103 has the following incident links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_NAME
res_string := SDO_NET_MEM.NODE.GET_NAME(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('The name of node 103 is: ' || res_string);
 
-- GET_OUT_LINK_IDS
res_array := SDO_NET_MEM.NODE.GET_OUT_LINK_IDS(net_mem, 103);
DBMS_OUTPUT.PUT('Node 103 has the following outbound links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_PARENT_NODE_ID
res_numeric := SDO_NET_MEM.NODE.GET_PARENT_NODE_ID(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('The parent node of node 103 is: ' || res_numeric);
 
-- GET_SIBLING_NODE_IDS
res_array := SDO_NET_MEM.NODE.GET_SIBLING_NODE_IDS(net_mem, 103);
DBMS_OUTPUT.PUT('Node 103 has the following sibling nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');

-- GET_STATE
res_string := SDO_NET_MEM.NODE.GET_STATE(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('The state of node 103 is: ' || res_string);
 
-- IS_ACTIVE
res_string := SDO_NET_MEM.NODE.IS_ACTIVE(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('Is node 103 active?: ' || res_string);
 
-- IS_LOGICAL
res_string := SDO_NET_MEM.NODE.IS_LOGICAL(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('Is node 103 a logical node?: ' || res_string);
 
-- IS_TEMPORARY
res_string := SDO_NET_MEM.NODE.IS_TEMPORARY(net_mem, 103);
DBMS_OUTPUT.PUT_LINE('Is node 103 temporary?: ' || res_string);
 
-- LINK_EXISTS
res_string := SDO_NET_MEM.NODE.LINK_EXISTS(net_mem, 103, 104);
DBMS_OUTPUT.PUT_LINE('Does a link exist between nodes 103 and 104?: ' || res_string);
 
-- MAKE_TEMPORARY
-- Make node 114 temporary.
SDO_NET_MEM.NODE.MAKE_TEMPORARY(net_mem, 114);
 
-- SET_COMPONENT_NO
-- Set the component number of node 114 to 987.
SDO_NET_MEM.NODE.SET_COMPONENT_NO(net_mem, 114, 987);
 
-- SET_COST
-- Set the cost of node 114 to 40.
SDO_NET_MEM.NODE.SET_COST(net_mem, 114, 40);
 
-- SET_HIERARCHY_LEVEL
-- Set the hierarchy level of node 1 to 2.
SDO_NET_MEM.NODE.SET_HIERARCHY_LEVEL(net_mem, 1, 2);
 
-- SET_NAME
-- Set the name of node 114 to 'My favorite node'.
SDO_NET_MEM.NODE.SET_NAME(net_mem, 114, 'My favorite node');
-- GET_NAME
res_string := SDO_NET_MEM.NODE.GET_NAME(net_mem, 114);
DBMS_OUTPUT.PUT_LINE('The name of node 114 is: ' || res_string);
 
-- SET_PARENT_NODE
-- Make node 1 the parent of node 114.
SDO_NET_MEM.NODE.SET_PARENT_NODE(net_mem, 114, 1);
 
-- SET_STATE
-- Set the state of node 111 to 'FALSE'.
SDO_NET_MEM.NODE.SET_STATE(net_mem, 111, 'FALSE');
-- GET_STATE
res_string := SDO_NET_MEM.NODE.GET_STATE(net_mem, 111);
DBMS_OUTPUT.PUT_LINE('The state of node 111 is: ' || res_string);
 
-- SET_TYPE
-- Set the type of node 114 to 'Research'.
SDO_NET_MEM.NODE.SET_TYPE(net_mem, 114, 'Research');
-- GET_TYPE
res_string := SDO_NET_MEM.NODE.GET_TYPE(net_mem, 114);
DBMS_OUTPUT.PUT_LINE('The type of node 114 is: ' || res_string);
 
END;  
/
 
-- Path editing (SDO_NET_MEM.PATH)
 
DECLARE
  net_mem     VARCHAR2(32);
  res_string  VARCHAR2(100);
  res_numeric NUMBER;
  path_id     NUMBER;
  res_array   SDO_NUMBER_ARRAY;
  indx        NUMBER;
 
BEGIN
 
net_mem := 'XYZ_NETWORK';
  
-- Create a path for use with subsequent statements. Here, it is
-- the shortest path between nodes 101 (N1) and 105 (N5).
path_id := SDO_NET_MEM.NETWORK_MANAGER.SHORTEST_PATH(net_mem,101,105);
DBMS_OUTPUT.PUT_LINE('The shortest path between nodes 101 and 105 is: ' || path_id);
 
-- GET_LINK_IDS
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Path ' || path_id || ' has the following links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_COST
res_numeric := SDO_NET_MEM.PATH.GET_COST(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The cost of path ' || path_id || ' is: ' || res_numeric);
 
-- GET_END_NODE_ID
res_numeric := SDO_NET_MEM.PATH.GET_END_NODE_ID(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The end node ID of path ' || path_id || ' is: ' || res_numeric);
 
-- GET_LINK_IDS
res_array := SDO_NET_MEM.PATH.GET_LINK_IDS(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Path ' || path_id || ' has the following links: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_NO_OF_LINKS
res_numeric := SDO_NET_MEM.PATH.GET_NO_OF_LINKS(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The number of links in path ' || path_id || ' is: ' || res_numeric);
 
-- GET_NODE_IDS
res_array := SDO_NET_MEM.PATH.GET_NODE_IDS(net_mem, path_id);
DBMS_OUTPUT.PUT('Path ' || path_id || ' has the following nodes: ');
FOR indx IN res_array.FIRST..res_array.LAST
LOOP
  DBMS_OUTPUT.PUT(res_array(indx) || ' ');
END LOOP;
DBMS_OUTPUT.PUT_LINE(' ');
 
-- GET_START_NODE_ID
res_numeric := SDO_NET_MEM.PATH.GET_START_NODE_ID(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The start node ID of path ' || path_id || ' is: ' || res_numeric);
 
-- IS_ACTIVE
res_string := SDO_NET_MEM.PATH.IS_ACTIVE(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' active?: ' || res_string);
 
-- IS_CLOSED
res_string := SDO_NET_MEM.PATH.IS_CLOSED(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' closed?: ' || res_string);
 
-- IS_CONNECTED
res_string := SDO_NET_MEM.PATH.IS_CONNECTED(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' connected?: ' || res_string);
 
-- IS_LOGICAL
res_string := SDO_NET_MEM.PATH.IS_LOGICAL(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' a logical path?: ' || res_string);
 
-- IS_SIMPLE
res_string := SDO_NET_MEM.PATH.IS_SIMPLE(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' a simple path?: ' || res_string);
 
-- IS_TEMPORARY
res_string := SDO_NET_MEM.PATH.IS_TEMPORARY(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('Is path ' || path_id || ' temporary?: ' || res_string);
 
-- SET_NAME
-- Set the name of path to 'My favorite path'.
SDO_NET_MEM.PATH.SET_NAME(net_mem, path_id, 'My favorite path');
-- GET_NAME
res_string := SDO_NET_MEM.PATH.GET_NAME(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The name of path ' || path_id || ' is: ' || res_string);
 
-- SET_TYPE
-- Set the type of the path to 'Logical connections'.
SDO_NET_MEM.PATH.SET_TYPE(net_mem, path_id, 'Logical connections');
-- GET_TYPE
res_string := SDO_NET_MEM.PATH.GET_TYPE(net_mem, path_id);
DBMS_OUTPUT.PUT_LINE('The type of path ' || path_id || ' is: ' || res_string);
 
-- SET_PATH_ID
-- Set (change) the path ID of the path to 6789.
SDO_NET_MEM.PATH.SET_PATH_ID(net_mem, path_id, 6789);
 
-- Get maximum link, node, path, subpath IDs.
SELECT SDO_NET_MEM.NETWORK.GET_MAX_LINK_ID(net_mem) 
  INTO res_numeric FROM DUAL;
DBMS_OUTPUT.PUT_LINE('Maximum link ID = ' || res_numeric);
SELECT SDO_NET_MEM.NETWORK.GET_MAX_NODE_ID(net_mem)   
  INTO res_numeric FROM DUAL;
DBMS_OUTPUT.PUT_LINE('Maximum node ID = ' || res_numeric);
SELECT SDO_NET_MEM.NETWORK.GET_MAX_PATH_ID(net_mem)
  INTO res_numeric FROM DUAL;
DBMS_OUTPUT.PUT_LINE('Maximum path ID = ' || res_numeric);
SELECT SDO_NET_MEM.NETWORK.GET_MAX_SUBPATH_ID(net_mem)
  INTO res_numeric FROM DUAL;
DBMS_OUTPUT.PUT_LINE('Maximum subpath ID = ' || res_numeric);

END;  
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHDEJFG"></a>
<div id="TOPOL957" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.13.5</span> Partitioning and Load on Demand Analysis Examples (PL/SQL, XML, and Java)</h3>
<p>This section presents examples of partitioning a network, including related operations, and performing load on demand network analysis. The examples illustrate concepts and techniques explained in <a href="#CIHFHAID">Section 5.7</a>.</p>
<p><a href="#CIHGIFCH">Example 5-6</a> partitions a spatial network named <code>NYC_NET</code>. (Assume that this network already exists and its metadata, node, and link tables are populated.)</p>
<div id="TOPOL958" class="example">
<p class="titleinexample"><a id="CIHGIFCH"></a>Example 5-6 Partitioning a Spatial Network</p>
<pre>
exec sdo_net.spatial_partition(
  network-&gt;'NYC_NET', -- network name
  partition_table_name-&gt;'NYC_PART$', -- partition table name
  max_num_nodes-&gt;5000, -- max. number of nodes per partition
  log_loc-&gt;'MDDIR', -- partition log directory
  log_file-&gt;'nyc_part.log', --partition log file name
  open_mode-&gt;'w', -- partition log file open mode
  link_level-&gt;1); -- link level
</pre></div>
<!-- class="example" -->
<p><a href="#CIHGGFAD">Example 5-7</a> generates partition BLOBs for the network.</p>
<div id="TOPOL959" class="example">
<p class="titleinexample"><a id="CIHGGFAD"></a>Example 5-7 Generating Partition BLOBs</p>
<pre>
exec sdo_net.generate_partition_blobs(
  network-&gt;'NYC_NET', ,-- network name
  link_level -&gt;1, -- link level
  partition_blob_table_name-&gt;'NYC_PBLOB$', -- partition blob table name
  includeUserdata-&gt;FALSE, -- include user data in partition blobs?
  log_loc-&gt;'MYDIR',  -- partition log directory
  log_file-&gt;'nyc_part.log', --partition log file name
  open_mode-&gt;'a'); -- partition log file open mode
</pre></div>
<!-- class="example" -->
<p><a href="#CIHGIFCH">Example 5-6</a> and <a href="#CIHGGFAD">Example 5-7</a> generate the necessary partition tables for the <code>NYC_NET</code> network. After executing these examples, you can check the .log file for the current status or any errors encountered during partitioning or BLOB generation.</p>
<p><a href="#CIHHGJHI">Example 5-8</a> shows the XML for configuring the load on demand environment, including the partition cache.</p>
<div id="TOPOL960" class="example">
<p class="titleinexample"><a id="CIHHGJHI"></a>Example 5-8 Configuring the Load on Demand Environment, Including Partition Cache</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;LODConfigs xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.oracle.com/spatial/network/lodLODConfigs.xsd"
     xmlns="http://www.oracle.com/spatial/network/lod/"&gt;
  <span class="bold">&lt;!-- default configuration for networks not configured --&gt;</span>
  &lt;defaultLODConfig&gt;
    &lt;LODConfig&gt;
      &lt;readPartitionFromBlob&gt;false&lt;/readPartitionFromBlob&gt;
      &lt;partitionBlobTranslator&gt;oracle.spatial.network.lod.PartitionBlobTranslator11g&lt;/partitionBlobTranslator&gt;
      &lt;userDataIO&gt;oracle.spatial.network.lod.LODUserDataIOSDO&lt;/userDataIO&gt;
      &lt;cachingPolicy&gt;
        &lt;linkLevelCachingPolicy&gt;
          &lt;linkLevel&gt;1&lt;/linkLevel&gt;
          &lt;maxNodes&gt;500000&lt;/maxNodes&gt;
          &lt;residentPartitions&gt;-1&lt;/residentPartitions&gt;
          &lt;flushRule&gt;oracle.spatial.network.lod.LRUCachingHandler&lt;/flushRule&gt;
        &lt;/linkLevelCachingPolicy&gt;
      &lt;/cachingPolicy&gt;
    &lt;/LODConfig&gt;
  &lt;/defaultLODConfig&gt;
  &hellip;
  &lt;networkLODConfig&gt;
    <span class="bold">&lt;!-- network to be configured --&gt;</span>
    &lt;networkName&gt; NYC_NET &lt;/networkName&gt;
    &lt;LODConfig&gt;
       <span class="bold">&lt;!- read partitions from partition table or from partition blob table --&gt;</span>
      &lt;readPartitionFromBlob&gt;true&lt;/readPartitionFromBlob&gt;
      &lt;partitionBlobTranslator&gt;oracle.spatial.network.lod.PartitionBlobTranslator11g&lt;/partitionBlobTranslator&gt;
      &lt;userDataIO&gt;oracle.spatial.network.lod.LODUserDataIOSDO&lt;/userDataIO&gt;
      &lt;cachingPolicy&gt;
        &lt;linkLevelCachingPolicy&gt;
          &lt;linkLevel&gt;1&lt;/linkLevel&gt;
          <span class="bold">&lt;!-- Maximum number of nodes allowed in cache --&gt;</span>
          &lt;maxNodes&gt;500000&lt;/maxNodes&gt;
          <span class="bold">&lt;!-- resident partitions --&gt;</span>
          &lt;residentPartitions&gt;-1&lt;/residentPartitions&gt;
          &lt;flushRule&gt;oracle.spatial.network.lod.LRUCachingHandler&lt;/flushRule&gt;
        &lt;/linkLevelCachingPolicy&gt;
        &lt;linkLevelCachingPolicy&gt;
          &lt;linkLevel&gt;2&lt;/linkLevel&gt;
          &lt;maxNodes&gt;500000&lt;/maxNodes&gt;
          &lt;residentPartitions&gt;*&lt;/residentPartitions&gt;
          &lt;flushRule&gt;oracle.spatial.network.lod.LRUCachingHandler&lt;/flushRule&gt;
        &lt;/linkLevelCachingPolicy&gt;
      &lt;/cachingPolicy&gt;
    &lt;/LODConfig&gt;
  &lt;/networkLODConfig&gt;
&lt;/LODConfigs&gt;
</pre></div>
<!-- class="example" -->
<p><a href="#CIHFCGDC">Example 5-9</a> and <a href="#CIHFFBHD">Example 5-10</a> show the Java and PL/SQL APIs, respectively, for reloading the load on demand configuration.</p>
<div id="TOPOL961" class="example">
<p class="titleinexample"><a id="CIHFCGDC"></a>Example 5-9 Reloading the Load on Demand Configuration (Java API)</p>
<pre>
InputStream config = ClassLoader.getSystemResourceAsStream(
                     "netlodcfg.xml");
LODNetworkManager.getConfigManager().loadConfig(config);
</pre></div>
<!-- class="example" -->
<div id="TOPOL962" class="example">
<p class="titleinexample"><a id="CIHFFBHD"></a>Example 5-10 Reloading the Load on Demand Configuration (PL/SQL API)</p>
<pre>
EXECUTE SDO_NET.LOAD_CONFIG('WORK_DIR', 'netlodcfg.xml');
</pre></div>
<!-- class="example" -->
<p><a href="#CIHEAJCA">Example 5-11</a> returns the estimated size in bytes for a specified network partition.</p>
<div id="TOPOL963" class="example">
<p class="titleinexample"><a id="CIHEAJCA"></a>Example 5-11 Getting Estimated Partition Size</p>
<pre>
SELECT SDO_NET.GET_PARTITION_SIZE (
  NETWORK-&gt;'NYC_NET',
  PARTITION_ID-&gt;1,
  LINK_LEVEL -&gt;1,
  INCLUDE_USER_DATA-&gt;'FALSE',
  INCLUDE_SPATIAL_DATA-&gt;'TRUE') FROM DUAL;
</pre></div>
<!-- class="example" -->
<p><a href="#CIHHFDFG">Example 5-12</a> uses the load on demand Java API (oracle.spatial.network.lod) to issue a shortest-path query on a network.</p>
<div id="TOPOL964" class="example">
<p class="titleinexample"><a id="CIHHFDFG"></a>Example 5-12 Network Analysis: Shortest Path (LOD Java API)</p>
<pre>
Connection conn = LODNetworkManager.getConnection(dbUrl, dbUser, dbPassword);
// get LOD network IO Adapter
String networkName = "NYC_NET";
NetworkIO reader = LODNetworkManager.getCachedNetworkIO(conn, networkName, networkName, null);
// get analysis module
NetworkAnalyst analyst = LODNetworkManager.getNetworkAnalyst(reader);
// compute the shortest path
LogicalSubPath path = analyst.shortestPathDijkstra(new PointOnNet(startNodeId),
      new PointOnNet(endNodeId), null);
// print path result
PrintUtility.print(System.out, path, false, 0, 0);
. . .
</pre></div>
<!-- class="example" -->
<p><a href="#CIHHGGBF">Example 5-13</a> uses the XML API (oracle.spatial.network.xml) to issue a shortest-path query on a network. It includes the request and the response.</p>
<div id="TOPOL965" class="example">
<p class="titleinexample"><a id="CIHHGGBF"></a>Example 5-13 Network Analysis: Shortest Path (XML API)</p>
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
<span class="bold">&lt;ndm:networkAnalysisRequest</span>
    xmlns:ndm="http://xmlns.oracle.com/spatial/network"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:gml="http://www.opengis.net/gml"&gt;
  &lt;ndm:networkName&gt;NYC_NET&lt;/ndm:networkName&gt;
  &lt;ndm:shortestPath&gt;
    &lt;ndm:startPoint&gt;
      &lt;ndm:nodeID&gt;65&lt;/ndm:nodeID&gt;
    &lt;/ndm:startPoint&gt;
    &lt;ndm:endPoint&gt;
      &lt;ndm:nodeID&gt;115&lt;/ndm:nodeID&gt;
    &lt;/ndm:endPoint&gt;
    &lt;ndm:subPathRequestParameter&gt;
      &lt;ndm:isFullPath&gt; true &lt;/ndm:isFullPath&gt;
      &lt;ndm:startLinkIndex&gt; true &lt;/ndm:startLinkIndex&gt;
      &lt;ndm:startPercentage&gt; true &lt;/ndm:startPercentage&gt;
      &lt;ndm:endLinkIndex&gt; true &lt;/ndm:endLinkIndex&gt;
      &lt;ndm:endPercentage&gt; true &lt;/ndm:endPercentage&gt;
      &lt;ndm:geometry&gt;false&lt;/ndm:geometry&gt;
    &lt;ndm:pathRequestParameter&gt;
      &lt;ndm:cost&gt; true &lt;/ndm:cost&gt;
      &lt;ndm:isSimple&gt; true &lt;/ndm:isSimple&gt;
      &lt;ndm:startNodeID&gt;true&lt;/ndm:startNodeID&gt;
      &lt;ndm:endNodeID&gt;true&lt;/ndm:endNodeID&gt;
      &lt;ndm:noOfLinks&gt;true&lt;/ndm:noOfLinks&gt;
      &lt;ndm:linksRequestParameter&gt;
        &lt;ndm:onlyLinkID&gt;true&lt;/ndm:onlyLinkID&gt;
      &lt;/ndm:linksRequestParameter&gt;
      &lt;ndm:nodesRequestParameter&gt;
        &lt;ndm:onlyNodeID&gt;true&lt;/ndm:onlyNodeID&gt;
      &lt;/ndm:nodesRequestParameter&gt;
      &lt;ndm:geometry&gt;true&lt;/ndm:geometry&gt;
    &lt;/ndm:pathRequestParameter&gt;
    &lt;/ndm:subPathRequestParameter&gt;
  &lt;/ndm:shortestPath&gt;
<span class="bold">&lt;/ndm:networkAnalysisRequest&gt;</span>
 
&lt;?xml version = '1.0' encoding = 'UTF-8'?&gt;
<span class="bold">&lt;ndm:networkAnalysisResponse</span> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ndm="http://xmlns.oracle.com/spatial/network" xmlns:gml="http://www.opengis.net/gml"&gt;
  &lt;ndm:networkName&gt;NYC_NET&lt;/ndm:networkName&gt;
  &lt;ndm:shortestPath&gt;
    &lt;ndm:subPathResponse&gt;
      &lt;ndm:isFullPath&gt;true&lt;/ndm:isFullPath&gt;
      &lt;ndm:startLinkIndex&gt;0&lt;/ndm:startLinkIndex&gt;
      &lt;ndm:startPercentage&gt;0.0&lt;/ndm:startPercentage&gt;
      &lt;ndm:endLinkIndex&gt;17&lt;/ndm:endLinkIndex&gt;
      &lt;ndm:endPercentage&gt;1.0&lt;/ndm:endPercentage&gt;
      &lt;ndm:pathResponse&gt;
        &lt;ndm:cost&gt;6173.212694405703&lt;/ndm:cost&gt;
        &lt;ndm:isSimple&gt;true&lt;/ndm:isSimple&gt;
        &lt;ndm:startNodeID&gt;65&lt;/ndm:startNodeID&gt;
        &lt;ndm:endNodeID&gt;115&lt;/ndm:endNodeID&gt;
        &lt;ndm:noOfLinks&gt;18&lt;/ndm:noOfLinks&gt;
        &lt;ndm:linkIDs&gt;145477046 145477044 145477042 145477039 145476926 145476930 145480892 145480891 145476873 145476871 145477023 145489019 145489020 145476851 145488986 145488987 145476913 145476905         
        &lt;/ndm:linkIDs&gt;
        &lt;ndm:nodeIDs&gt;65 64 60 57 58 61 71 70 73 87 97 95 91 101 102 104 117 120 115 
        &lt;/ndm:nodeIDs&gt;
        &lt;ndm:geometry&gt;
          &lt;gml:LineString&gt;
            &lt;gml:coordinates&gt;-71.707462,43.555262 -71.707521,43.555601&hellip;
            &lt;/gml:coordinates&gt;
          &lt;/gml:LineString&gt;
        &lt;/ndm:geometry&gt;
      &lt;/ndm:pathResponse&gt;
    &lt;/ndm:subPathResponse&gt;
  &lt;/ndm:shortestPath&gt;
<span class="bold">&lt;/ndm:networkAnalysisResponse&gt;</span>
</pre></div>
<!-- class="example" -->
<p>Additional examples of using load on demand analysis with partitioned networks are included in the demo files, described in <a href="#CIHDIHEA">Section 5.14</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHEGBED"></a>
<div id="TOPOL966" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.13.6</span> User-Defined Data Example (PL/SQL and Java)</h3>
<p>This section presents an example of using network user-defined data, which is the information (not related to connectivity) that users want to associate with a network representation. The USER_SDO_NETWORK_USER_DATA and ALL_SDO_NETWORK_USER_DATA metadata views (described in <a href="#CIHJFJFD">Section 5.10.3</a>) contain information about user-defined data.</p>
<p>To use user-defined data, you must set the USER_DEFINED_DATA column value to <code>Y</code> in the appropriate xxx_SDO_NETWORK_METADATA views (described in <a href="#CIHGBCAI">Section 5.10.1</a>).</p>
<p><a href="#CIHEDJIC">Example 5-14</a> inserts link-related user-defined data into the network metadata.</p>
<div id="TOPOL967" class="example">
<p class="titleinexample"><a id="CIHEDJIC"></a>Example 5-14 Inserting User-Defined Data into Network Metadata</p>
<pre>
-- Insert link user data named 'interaction' of
-- type varchar2 (50) in network 'bi_test'.
--'interaction' is a column of type varchar2(50) in the link table of network 'bi_
test'.
insert into user_sdo_network_user_data 
         (network,table_type, data_name, data_type, data_length, category_id) 
          values ('bi_test', 'LINK', 'interaction', 'VARCHAR2', 50, 0) ;
-- insert link user data named 'PROB' of type Number.
--'PROB' is a column of type NUMBER in the link table of network 'bi_test'.
insert into user_sdo_network_user_data 
         (network,table_type,data_name,data_type, category_id)
          values ('bi_test','LINK','PROB','NUMBER', 0) ;
</pre></div>
<!-- class="example" -->
<p>After a network or network partition is loaded, user-defined data is available in Java representations. You can access user-defined data through the <code>getUserData</code> and <code>setUserData</code> methods for the <code>Node</code>, <code>Link</code>, <code>Path</code>, and <code>SubPath</code> interfaces. For example:</p>
<pre>
String interaction = (String)link.getUserData("interaction");
double prob = ((Double)link.getUserData("Prob")).doubleValue();
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHDIHEA"></a>
<div id="TOPOL713" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.14</span> <a id="sthref885"></a><a id="sthref886"></a>Network Data Model Tutorial and Other Resources</h2>
<p><code><a href="http://www.oracle.com/technetwork/database-options/spatialandgraph/">http://www.oracle.com/technetwork/database-options/spatialandgraph</a></code> on the Oracle Technology Network provides links to valuable resources to help you get started with Oracle Spatial technologies, including the Network Data Model. The Network Data Model resources include the following:</p>
<ul>
<li>
<p>A <span class="bold">Network Data Model tutorial</span> (<code>ndm_tutorial.zip</code> on <code><a href="http://www.oracle.com/technetwork/indexes/samplecode/spatial-1433316.html">http://www.oracle.com/technetwork/indexes/samplecode/spatial-1433316.html</a></code>) outlines the steps to set up and configure a network, and to conduct the analysis. It also includes sample code and a web application that demonstrates how to use Oracle Maps to display analysis results.</p>
</li>
<li>
<p>An <span class="bold">NDM white paper</span> ("A Load-On-Demand Approach to Handling Large Networks in the Oracle Spatial and Graph Network Data Model Graph") provides detailed explanations and examples.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CIHHDBHJ"></a>
<div id="TOPOL971" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.15</span> README File for Spatial and Related Features</h2>
<p><a id="sthref887"></a>A <code>README.txt</code> file supplements the information in the following manuals: <a class="olink SPATL" href="../e11830/toc.htm"><span class="italic">Oracle Spatial Developer's Guide</span></a>, <a class="olink GEORS" href="../e11827/toc.htm"><span class="italic">Oracle Spatial GeoRaster Developer's Guide</span></a>, and <span class="italic">Oracle Spatial Topology and Network Data Models Developer's Guide</span> (this manual). This file is located at:</p>
<pre>
<span class="italic">$ORACLE_HOME</span>/md/doc/README.txt
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment778">
<tr>
<td class="cellalignment785">
<table class="cellalignment783">
<tr>
<td class="cellalignment782"><a href="sdo_prtnet.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment782"><a href="sdo_net_ref.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2003, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment787">
<table class="cellalignment781">
<tr>
<td class="cellalignment782"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment782"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment782"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment782"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment782"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment782"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
