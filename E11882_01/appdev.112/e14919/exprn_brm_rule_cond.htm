<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Rule Conditions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 033" />
<meta name="dcterms.created" content="2011-08-16T11:52:3Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Rules Manager and Expression Filter Developer's Guide" />
<meta name="dcterms.identifier" content="E14919-04" />
<meta name="dcterms.isVersionOf" content="EXPRN" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2003, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="exprn_brm_evnt_rcconfig.htm" title="Previous" type="text/html" />
<link rel="Next" href="exprn_brm_mtier.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e14919.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/36</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='exprn_brm_rule_cond'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="CIHEBAID"></a><a id="EXPRN4472"></a>
<h1 class="chapter"><span class="secnum">5</span> Rule Conditions</h1>
<p>Rules Manager rule conditions use the SQL <code>WHERE</code> clause format and the attributes of the event structure to define the rule condition. For the travel services example, you express the rule condition using the attributes: <code>Airline</code>, <code>ToCity</code>, <code>Return</code>, and <code>Depart</code>. Rule conditions<a id="sthref100"></a><a id="sthref101"></a><a id="sthref102"></a> you define on primitive event structures correspond directly to the SQL <code>WHERE</code> clause format:</p>
<pre>
&lt;condition&gt;
   Airline = 'Abcair' and ToCity = 'Orlando' and Return - Depart &gt;=7 
&lt;/condition&gt;
</pre>
<p>Note that you embed all rule conditions within XML <code>&lt;condition&gt;</code> tags. Rules Manager provides additional XML tags to support incremental evaluation of rule conditions for composite events (which are composed of two or more primitive events).</p>
<p>You may recall that evaluating a condition based on a primitive event is atomic, implying that the values for all attributes of that event structure are available atomically. Thus, when you define a rule condition on a primitive event, it evaluates to true or false instantaneously. In contrast, when you define a rule condition on a composite event, it may have intermediate states, depending on the subset of the primitive events that are available. For example, when you define a rule on a composite event constructed from three primitive events, you can define it to fire if any two of the three primitive event conditions are true.</p>
<a id="CIHJGEID"></a><a id="EXPRN090"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.1</span> Support for Incremental Evaluation of Rules</h2>
<p>To support rule conditions on composite events, you can use additional XML tags<a id="sthref103"></a><a id="sthref104"></a> within the <code>&lt;condition&gt;</code> tags. These tags extend the basic <code>WHERE</code> clause functionality, supporting joins between composite events, and incremental evaluation of the primitive event instances that comprise the composite event structure.</p>
<p>For example, the conditional expression (<code>Flt.Airline = 'Abcair' and Flt.ToCity = 'Orlando' and Flt.CustId = Car.CustId and Car.CarType = 'Luxury'</code>) in the travel services rule has three parts, as follows:</p>
<ul>
<li>
<p>Predicates defined on the primitive event AddFlight (<code>Flt.Airline = 'Abcair' and Flt.ToCity = 'Orlando'</code>)</p>
</li>
<li>
<p>A predicate defined on the primitive event AddRentalCar (<code>Car.CarType = 'Luxury'</code>)</p>
</li>
<li>
<p>A join predicate between the two primitive events (<code>Flt.CustId = Car.CustId</code>)</p>
</li>
</ul>
<p>Rules Manager provides XML tags to identify various parts of a complex conditional expression and support additional semantics. For example, you can represent the previous rule condition using XML tags as follows<a id="sthref105" href="#sthref105" onclick='footdisplay(1,"For simplicity, the examples in this document are shown without the XML entity references for &lt; (\u003ccode\u003e&amp;lt\u003c/code\u003e;), \u003e (\u003ccode\u003e&amp;gt\u003c/code\u003e;), and \x27(\u003ccode\u003e&amp;apos\u003c/code\u003e;) symbols. Within a rule condition, less than is the only symbol that you must specify using an entity reference \u003ccode\u003e(&amp;lt\u003c/code\u003e;) or use within a XML CDATA section. Although it is not mandatory to use entity references for other symbols, they are recommended for compatibility reasons. Following the SQL naming convention, all the values specified for XML attributes and elements are case-insensitive. Case is preserved only if a value appears within quotes.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a>:</p>
<pre>
&lt;condition&gt;
  &lt;and join="<span class="codeinlinebold">Flt.CustId = Car.CustId</span>"&gt;
    &lt;object name="Flt"&gt; <span class="codeinlinebold">Airline='Abcair' and ToCity='Orlando'</span> &lt;/object&gt;
    &lt;object name="Car"&gt; <span class="codeinlinebold">CarType = 'Luxury'</span> &lt;/object&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>In this representation, the <code>&lt;object&gt;</code> elements capture the predicates specified for individual primitive events and one join attribute of the <code>&lt;and&gt;</code> element captures the join predicate behavior between two primitive events. You can insert the rule condition in this format into the <code>rlm$rulecond</code> column of the corresponding rule class table. Rules Manager provides XML tags to support more complex rule constructs. <a href="#CIHJEIFI">Figure 5-1</a> and <a href="#CIHBJDCB">Table 5-1</a> summarizes these tags and <a href="#CIHGBIID">Section 5.2</a> through <a href="#CIHIIGHD">Section 5.5</a> describe these tags in more detail.</p>
<p>The previous example illustrates the combination of <span class="bold">and</span> with a <span class="bold">join</span>, which evaluates to true when all the primitive event conditions evaluated to true with the corresponding events, which also satisfy the rule's join condition. Other constructs, such as <span class="bold">any</span>, enable complex conditions to be specified that evaluate to true if a subset of the primitive event conditions are true.</p>
<p>The most common join predicate used to form composite events is an equality predicate, as is the case with SQL queries that join multiple tables. Usually, one or more attributes from each primitive event are compared with one or more attributes from the other events for equality. Rules Manager uses a convenient syntax to specify the equality join predicates in the rule conditions and also provides a mechanism to enforce this join predicate for all the rules in a rule class (Section 3.5).</p>
<p>The following are examples of commonly used rule constructs defined on composite events.</p>
<ul>
<li>
<p>Count based subsets of primitive events. Specify by using the <span class="bold">any</span> operator.</p>
<ul>
<li>
<p>The operator <span class="bold">any</span> evaluates to true if any of the primitive event conditions evaluate to true.</p>
</li>
<li>
<p>The operator <span class="bold">any 2</span> evaluates to true if any 2 or more of the primitive event conditions evaluate to true.</p>
<p>In general, the <span class="bold">any</span> operator is parameterized with a <span class="bold">count</span> argument, which evaluates to true if <span class="bold">any count</span> of the primitive event conditions evaluate to true.</p>
</li>
</ul>
</li>
<li>
<p>Sequenced subsets of primitive events. Specify these in a number of ways:</p>
<ul>
<li>
<p>Use a <span class="bold">Join</span> with a time constraint. Use the time constraint to impose a partial order over the event instances.</p>
</li>
<li>
<p>Use combinations of <span class="bold">and</span> with a <span class="bold">sequence</span> tag.</p>
<p>The sequence tag requires a specific ordering of primitive events.</p>
</li>
<li>
<p>Use combinations of <span class="bold">any count</span> with a <span class="bold">sequence</span> tag.</p>
</li>
</ul>
</li>
<li>
<p>Detecting if one primitive event does not occur within a certain time interval of another primitive event. Specify this using the <span class="bold">by</span> option of the <span class="bold">not</span> or <span class="bold">notany</span> tag:</p>
<ul>
<li>
<p>Use the <span class="bold">not by</span> tag with a timestamp parameter to detect the non-occurrence of a primitive event within a specific time interval.</p>
</li>
<li>
<p>Use the <span class="bold">notany by</span> tag in a similar fashion.</p>
</li>
</ul>
</li>
</ul>
<p><a href="#CIHJEIFI">Figure 5-1</a> describes a hierarchical view of the supported XML tag elements and their attributes for the rule condition XML schema definition that is described in detail in the Rule Condition section in <a href="exprn_app_f.htm#BABCGJCH">Appendix F</a>. <a href="#CIHBJDCB">Table 5-1</a> shows a relational view of the same supported XML tag extensions showing the XPath and some notes about the elements and attributes<a id="sthref106"></a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="CIHJEIFI"></a><a id="EXPRN510"></a>Figure 5-1 Hierarchical View of the XML Tag Extensions</p>
<img width="444" height="605" src="img/hierarchyview.gif" alt="Description of Figure 5-1 follows" /><br />
<a id="sthref107" href="img_text/hierarchyview.htm">Description of "Figure 5-1 Hierarchical View of the XML Tag Extensions"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="tblformalwide">
<p class="titleintable"><a id="EXPRN511"></a><a id="sthref108"></a><a id="CIHBJDCB"></a>Table 5-1 Relational View of the XML Tag Extensions</p>
<table class="cellalignment998" title="Relational View of the XML Tag Extensions" summary="This four column table (read from right to left) lists XML tag name, its type (element or attribute), who its parent is, and any additional pertinent notes of interest about the XML tag" >
<thead>
<tr class="cellalignment989">
<th class="cellalignment999" id="r1c1-t2">XML Tag</th>
<th class="cellalignment999" id="r1c2-t2">Type</th>
<th class="cellalignment999" id="r1c3-t2">Parent</th>
<th class="cellalignment999" id="r1c4-t2">XPath</th>
<th class="cellalignment999" id="r1c5-t2">Number of Occurrences Allowed within Its Parent</th>
<th class="cellalignment999" id="r1c6-t2">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment989">
<td class="cellalignment995" id="r2c1-t2" headers="r1c1-t2">
<p><code>condition</code></p>
</td>
<td class="cellalignment995" headers="r2c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r2c1-t2 r1c3-t2">
<p>None</p>
</td>
<td class="cellalignment995" headers="r2c1-t2 r1c4-t2">
<p><code>condition</code></p>
</td>
<td class="cellalignment995" headers="r2c1-t2 r1c5-t2">
<p>---</p>
</td>
<td class="cellalignment995" headers="r2c1-t2 r1c6-t2">
<p>Denotes a conditional expression</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r3c1-t2" headers="r1c1-t2">
<p><code>and</code></p>
</td>
<td class="cellalignment995" headers="r3c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r3c1-t2 r1c3-t2">
<p><code>condition</code></p>
</td>
<td class="cellalignment995" headers="r3c1-t2 r1c4-t2">
<p><code>condition/and</code></p>
</td>
<td class="cellalignment995" headers="r3c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r3c1-t2 r1c6-t2">
<p>Combines predicates</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r4c1-t2" headers="r1c1-t2">
<p><code>any</code></p>
</td>
<td class="cellalignment995" headers="r4c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r4c1-t2 r1c3-t2">
<p><code>condition</code></p>
</td>
<td class="cellalignment995" headers="r4c1-t2 r1c4-t2">
<p><code>condition/any</code></p>
</td>
<td class="cellalignment995" headers="r4c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r4c1-t2 r1c6-t2">
<p>A substitute for "or"; true if any condition is met</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r5c1-t2" headers="r1c1-t2">
<p><code>not</code></p>
</td>
<td class="cellalignment995" headers="r5c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r5c1-t2 r1c3-t2">
<p><code>and</code></p>
</td>
<td class="cellalignment995" headers="r5c1-t2 r1c4-t2">
<p><code>and/not</code></p>
</td>
<td class="cellalignment995" headers="r5c1-t2 r1c5-t2">
<p>One, as last child element</p>
</td>
<td class="cellalignment995" headers="r5c1-t2 r1c6-t2">
<p>Logical negation</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r6c1-t2" headers="r1c1-t2">
<p><code>notany</code></p>
</td>
<td class="cellalignment995" headers="r6c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r6c1-t2 r1c3-t2">
<p><code>and</code></p>
</td>
<td class="cellalignment995" headers="r6c1-t2 r1c4-t2">
<p><code>and/notany</code></p>
</td>
<td class="cellalignment995" headers="r6c1-t2 r1c5-t2">
<p>One, as last child element</p>
</td>
<td class="cellalignment995" headers="r6c1-t2 r1c6-t2">
<p>Logical negation; detects non-occurrence</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r7c1-t2" headers="r1c1-t2">
<p><code>object</code></p>
</td>
<td class="cellalignment995" headers="r7c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r7c1-t2 r1c3-t2">
<p><code>condition</code></p>
<p><code>and</code></p>
<p><code>any</code></p>
<p><code>not</code></p>
<p><code>notany</code></p>
</td>
<td class="cellalignment995" headers="r7c1-t2 r1c4-t2">
<p><code>condition/object</code></p>
<p><code>and/object</code></p>
<p><code>any/object</code></p>
<p><code>not/object</code></p>
<p><code>notany/object</code></p>
</td>
<td class="cellalignment995" headers="r7c1-t2 r1c5-t2">
<p>One</p>
<p>Two or more objects</p>
<p>Two or more objects</p>
<p>One object</p>
<p>Two or more objects</p>
</td>
<td class="cellalignment995" headers="r7c1-t2 r1c6-t2">
<p>Primitive event</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r8c1-t2" headers="r1c1-t2">
<p><code>collection</code></p>
</td>
<td class="cellalignment995" headers="r8c1-t2 r1c2-t2">
<p>Element</p>
</td>
<td class="cellalignment995" headers="r8c1-t2 r1c3-t2">
<p><code>condition</code></p>
<p><code>and</code></p>
</td>
<td class="cellalignment995" headers="r8c1-t2 r1c4-t2">
<p><code>condition/collection</code></p>
<p><code>and/collection</code></p>
</td>
<td class="cellalignment995" headers="r8c1-t2 r1c5-t2">
<p>One</p>
<p>Two or more in combination with object</p>
</td>
<td class="cellalignment995" headers="r8c1-t2 r1c6-t2">
<p>Collection event</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r9c1-t2" headers="r1c1-t2">
<p><code>join</code></p>
</td>
<td class="cellalignment995" headers="r9c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r9c1-t2 r1c3-t2">
<p><code>and</code></p>
<p><code>any</code></p>
<p><code>not</code></p>
<p><code>notany</code></p>
</td>
<td class="cellalignment995" headers="r9c1-t2 r1c4-t2">
<p><code>and/@join</code></p>
<p><code>any/@join</code></p>
<p><code>not/@join</code></p>
<p><code>notany/@join</code></p>
</td>
<td class="cellalignment995" headers="r9c1-t2 r1c5-t2">
<p>One</p>
<p>One</p>
<p>One</p>
<p>One</p>
</td>
<td class="cellalignment995" headers="r9c1-t2 r1c6-t2">
<p>Joins predicates</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r10c1-t2" headers="r1c1-t2">
<p><code>sequence</code></p>
</td>
<td class="cellalignment995" headers="r10c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r10c1-t2 r1c3-t2">
<p><code>and</code></p>
<p><code>any</code></p>
</td>
<td class="cellalignment995" headers="r10c1-t2 r1c4-t2">
<p><code>and/@sequence</code></p>
<p><code>any/@sequence</code></p>
</td>
<td class="cellalignment995" headers="r10c1-t2 r1c5-t2">
<p>One</p>
<p>One</p>
</td>
<td class="cellalignment995" headers="r10c1-t2 r1c6-t2">
<p>Specifies an ordered sequence</p>
<p>Specifies any ordered sequence</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r11c1-t2" headers="r1c1-t2">
<p><code>equal</code></p>
</td>
<td class="cellalignment995" headers="r11c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r11c1-t2 r1c3-t2">
<p><code>and</code></p>
<p><code>any</code></p>
</td>
<td class="cellalignment995" headers="r11c1-t2 r1c4-t2">
<p><code>and/@equal</code></p>
<p><code>any/@equal</code></p>
</td>
<td class="cellalignment995" headers="r11c1-t2 r1c5-t2">
<p>One</p>
<p>One</p>
</td>
<td class="cellalignment995" headers="r11c1-t2 r1c6-t2">
<p>Joins predicates</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r12c1-t2" headers="r1c1-t2">
<p><code>count</code></p>
</td>
<td class="cellalignment995" headers="r12c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r12c1-t2 r1c3-t2">
<p><code>any</code></p>
<p><code>notany</code></p>
</td>
<td class="cellalignment995" headers="r12c1-t2 r1c4-t2">
<p><code>any/@count</code></p>
<p><code>notany/@count</code></p>
</td>
<td class="cellalignment995" headers="r12c1-t2 r1c5-t2">
<p>One</p>
<p>One</p>
</td>
<td class="cellalignment995" headers="r12c1-t2 r1c6-t2">
<p>Any <span class="italic">n</span> semantics</p>
<p>Any <span class="italic">n</span> semantics</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r13c1-t2" headers="r1c1-t2">
<p><code>by</code></p>
</td>
<td class="cellalignment995" headers="r13c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r13c1-t2 r1c3-t2">
<p><code>not</code></p>
<p><code>notany</code></p>
</td>
<td class="cellalignment995" headers="r13c1-t2 r1c4-t2">
<p><code>not/@by</code></p>
<p><code>notany/@by</code></p>
</td>
<td class="cellalignment995" headers="r13c1-t2 r1c5-t2">
<p>One</p>
<p>One</p>
</td>
<td class="cellalignment995" headers="r13c1-t2 r1c6-t2">
<p>Deadline for non-occurrence</p>
<p>Deadline for non-occurrence</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r14c1-t2" headers="r1c1-t2">
<p><code>name</code></p>
</td>
<td class="cellalignment995" headers="r14c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r14c1-t2 r1c3-t2">
<p><code>object</code></p>
</td>
<td class="cellalignment995" headers="r14c1-t2 r1c4-t2">
<p><code>object/@name</code></p>
</td>
<td class="cellalignment995" headers="r14c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r14c1-t2 r1c6-t2">
<p>Object name</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r15c1-t2" headers="r1c1-t2">&nbsp;</td>
<td class="cellalignment995" headers="r15c1-t2 r1c2-t2">&nbsp;</td>
<td class="cellalignment995" headers="r15c1-t2 r1c3-t2">
<p><code>collection</code></p>
</td>
<td class="cellalignment995" headers="r15c1-t2 r1c4-t2">
<p><code>collection/@name</code></p>
</td>
<td class="cellalignment995" headers="r15c1-t2 r1c5-t2">&nbsp;</td>
<td class="cellalignment995" headers="r15c1-t2 r1c6-t2">
<p>Collection name</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r16c1-t2" headers="r1c1-t2">
<p><code>ref</code></p>
</td>
<td class="cellalignment995" headers="r16c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r16c1-t2 r1c3-t2">
<p><code>object</code></p>
</td>
<td class="cellalignment995" headers="r16c1-t2 r1c4-t2">
<p><code>object/@ref</code></p>
</td>
<td class="cellalignment995" headers="r16c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r16c1-t2 r1c6-t2">
<p>Reference to a shared condition</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r17c1-t2" headers="r1c1-t2">
<p><code>groupby</code></p>
</td>
<td class="cellalignment995" headers="r17c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r17c1-t2 r1c3-t2">
<p><code>collection</code></p>
</td>
<td class="cellalignment995" headers="r17c1-t2 r1c4-t2">
<p><code>collection/@groupby</code></p>
</td>
<td class="cellalignment995" headers="r17c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r17c1-t2 r1c6-t2">
<p>Group by specification for the collection</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r18c1-t2" headers="r1c1-t2">
<p><code>having</code></p>
</td>
<td class="cellalignment995" headers="r18c1-t2 r1c2-t2">
<p>Attribute</p>
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r18c1-t2 r1c3-t2">
<p><code>collection</code></p>
<p><code>and</code></p>
</td>
<td class="cellalignment995" headers="r18c1-t2 r1c4-t2">
<p><code>collection/@having</code></p>
<p><code>and/@having</code></p>
</td>
<td class="cellalignment995" headers="r18c1-t2 r1c5-t2">
<p>One</p>
<p>One</p>
</td>
<td class="cellalignment995" headers="r18c1-t2 r1c6-t2">
<p>Having clause for the collection</p>
<p>Having clause joining multiple collections</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r19c1-t2" headers="r1c1-t2">
<p><code>compute</code></p>
</td>
<td class="cellalignment995" headers="r19c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r19c1-t2 r1c3-t2">
<p><code>collection</code></p>
</td>
<td class="cellalignment995" headers="r19c1-t2 r1c4-t2">
<p><code>collection/@compute</code></p>
</td>
<td class="cellalignment995" headers="r19c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r19c1-t2 r1c6-t2">
<p>Additional aggregate function to compute for the collection</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r20c1-t2" headers="r1c1-t2">
<p><code>windowlen</code></p>
</td>
<td class="cellalignment995" headers="r20c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r20c1-t2 r1c3-t2">
<p><code>collection</code></p>
</td>
<td class="cellalignment995" headers="r20c1-t2 r1c4-t2">
<p><code>collection/@windowlen</code></p>
</td>
<td class="cellalignment995" headers="r20c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r20c1-t2 r1c6-t2">
<p>Moving window spec for collection</p>
</td>
</tr>
<tr class="cellalignment989">
<td class="cellalignment995" id="r21c1-t2" headers="r1c1-t2">
<p><code>windowsize</code></p>
</td>
<td class="cellalignment995" headers="r21c1-t2 r1c2-t2">
<p>Attribute</p>
</td>
<td class="cellalignment995" headers="r21c1-t2 r1c3-t2">
<p><code>collection</code></p>
</td>
<td class="cellalignment995" headers="r21c1-t2 r1c4-t2">
<p><code>collection/@windowsize</code></p>
</td>
<td class="cellalignment995" headers="r21c1-t2 r1c5-t2">
<p>One</p>
</td>
<td class="cellalignment995" headers="r21c1-t2 r1c6-t2">
<p>Moving window spec for collection</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect1" -->
<a id="CIHGBIID"></a><a id="EXPRN091"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.2</span> Rule Conditions with Sequencing</h2>
<p>The rules you define for a composite event (consisting of two or more primitive events) may specify a condition on the order in which the primitive events should occur. This is called sequencing<a id="sthref109"></a><a id="sthref110"></a> and it can be partial on a subset of primitive events, or it can be complete based on all the primitive events. Sequencing in rule applications uses the implicit timestamp attribute (<code>rlm$crtTime</code>) that is included in each primitive event participating in a composite event.</p>
<p>Rules Manager uses the event creation times in the primitive events to enforce and detect sequencing in rule applications. For example, consider the rule in the travel services application. You can specify an additional predicate to offer the promotion only if the <code>AddRentalCar</code> event is generated after the <code>AddFlight</code> event. You can extend the rule condition to include this sequencing predicate, as follows:</p>
<pre>
&lt;condition&gt;
  &lt;and join="Flt.CustId = Car.CustId" <span class="codeinlinebold">sequence="yes"</span>&gt;
    &lt;object name="Flt"&gt; Airline='Abcair' and ToCity='Orlando' &lt;/object&gt;
    &lt;object name="Car"&gt; CarType = 'Luxury' &lt;/object&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The sequence attribute in the preceding example ensures that the rule condition evaluates to true only if the matching primitive events occur in the order in which they are specified within the <code>&lt;and&gt;</code> element. You can replace the sequence attribute with a join predicate on the corresponding event creation times, shown as follows:</p>
<pre>
&lt;condition&gt;
  &lt;and join="Flt.CustId = Car.CustId <span class="codeinlinebold">and Car.rlm$CrtTime &gt;= Flt.rlm$CrtTime</span>"&gt;
    &lt;object name="Flt"&gt; Airline='Abcair' and ToCity='Orlando' &lt;/object&gt;
    &lt;object name="Car""&gt; CarType = 'Luxury' &lt;/object&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>You can use sequencing to detect partial ordering among primitive events (for example, using a join predicate on only two primitive events when there are three of them in the composite event). You can also use the <code>rlm$CrtTime</code> attribute in the primitive event type to apply additional time constrains in the rule conditions. For example, the travel services rule may be valid only when the car reservations is made within 24 hours of making the flight reservation. The boldfaced text of the following example indicates where the value <code>1</code> means one day. See <a class="olink ADFNS" href="../e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information about performing date or timestamp arithmetic.</p>
<pre>
&lt;condition&gt;
  &lt;and join="Flt.CustId = Car.CustId and
                                 <span class="codeinlinebold">Flt.rlm$CrtTime &gt;= (Car.rlm$CrtTime - 1)</span>"
                                 sequence="Yes"&gt;
    &lt;object name="Flt"&gt; Airline='Abcair' and ToCity='Orlando' &lt;/object&gt;
    &lt;object name="Car"&gt; CarType = 'Luxury' &lt;/object&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>Optionally, the call to the <code>DBMS_RLMGR.PROCESS_RULES</code> procedure may pass an event with a specific event creation time. Within a primitive event, Rules Manager treats the <code>rlm$CrtTime</code> attribute as any other attribute in the event structure. However, when you do not specify a value for this attribute, it is assigned a default value of <code>SYSTIMESTAMP</code> (in the database). If an application is sensitive to the difference between the times at which the events are detected (in the application layer) and the times at which they are added to Rules Manager, it may choose to set the values for event creation times and add fully specified events to the rule class.</p>
</div>
<!-- class="sect1" -->
<a id="BABBGBAJ"></a><a id="EXPRN092"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.3</span> Rule Conditions with Negation</h2>
<p>Typically, you use rules with negation<a id="sthref111"></a><a id="sthref112"></a> in their conditions to raise exceptions in business processes. For example, a rule using negation could be "If an order is placed by a Gold customer and the items are not shipped within 24 hours of the order placement, alert the representative". In this case, you define the rule for a composite event consisting of two primitive events <code>PlaceOrder</code> and <code>ShipOrder</code> and the type created for the composite event structure is shown as follows:</p>
<pre>
CREATE or REPLACE TYPE OrderTrack AS OBJECT (
                order PlaceOrder, -- primitive event type --
                ship ShipOrder); -- primitive event type --
</pre>
<p>For a composite event, a rule defined with negation evaluates to true when one of the primitive events does not happen within a time delay of the other. So, negation always accompanies a time delay that is relative to the other primitive event or events in the composite event. For example, you can express the rule condition for the order tracking rule as shown in the following example. The boldfaced text, "sysdate +1", means by the end of the next day because the SQL datetime function <code>SYSDATE</code> returns the current date and time of the operating system on which the database resides (taking into account the time zone of the database server's operating system that was in effect when the database was started).</p>
<pre>
&lt;condition&gt;
  &lt;and equal="order.orderId, ship.orderId"&gt;
    &lt;object name="order"&gt; Type = 'Gold' &lt;/object&gt;
    <span class="codeinlinebold">&lt;not by="sysdate+1"&gt;</span> 
      &lt;object name="ship"/&gt; -- empty elem: no conditions on the primitive event --
    &lt;/not&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The <code>&lt;not&gt;</code> XML element in the rule condition has the following semantics:</p>
<ul>
<li>
<p>There can be only one <code>&lt;not&gt;</code> element in a rule condition.</p>
</li>
<li>
<p>The <code>&lt;not&gt;</code> element can only appear within an <code>&lt;and&gt;</code> element (as a conjunction to other primitive events) and it should be the last element within the <code>&lt;and&gt;</code> element.</p>
</li>
<li>
<p>The <code>&lt;not&gt;</code> element is activated only when all the other primitive events in the composite events are detected.</p>
</li>
<li>
<p>The <code>&lt;not&gt;</code> element can contain only one &lt;object&gt; element that represents a primitive event.</p>
</li>
<li>
<p>Use the <code>&lt;notany&gt;</code> element in place of the <code>&lt;not&gt;</code> element to support a notion of disjunction within the negation rule.</p>
</li>
<li>
<p>At the time of activation, Rules Manager executes the <code>by</code> attribute of the <code>&lt;not&gt;</code> element to compute the deadline for the primitive events in the <code>&lt;not&gt;</code> element. You can express the value for the <code>by</code> attribute using the (database) <code>SYSTIMESTAMP</code> (to be set to the time of activation) or any date attribute in the other primitive events (including the event creation time attributes discussed in <a href="#CIHGBIID">Section 5.2</a>), or both. The SQL datetime function <code>SYSTIMESTAMP</code> returns the system date including fractional seconds and time zone of the system on which the database resides. So, you can also express the rule condition in the preceding example as follows:</p>
<pre>
&lt;condition&gt;
  &lt;and equal="order.orderId, ship.orderId"&gt;
    &lt;object name="order"&gt; Type = 'Gold' &lt;/object&gt;
    &lt;not by="<span class="codeinlinebold">order.rlm$CrtTime+1</span>"&gt;
      &lt;object name="ship"/&gt;
    &lt;/not&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>Another variant of the preceding rule is one that uses a user-supplied date in the deadline computation. For example, a <code>ShipBy</code> attribute in the <code>PlaceOrder</code> event can hold the time by which you expect the shipment and the deadline can be computed using this attribute, such as shown here:</p>
<pre>
&lt;condition&gt;
  &lt;and equal="order.orderId, ship.orderId"&gt;
    &lt;object name="order"&gt; Type = 'Gold' &lt;/object&gt;
    &lt;not by="<span class="codeinlinebold">order.ShipBy-1</span>"&gt;
      &lt;object name="ship"/&gt;
    &lt;/not&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre></li>
</ul>
<p>Rules with negation involving a deadline other than <code>SYSTIMESTAMP</code> are not allowed in a rule class with the <code>AUTOCOMMIT</code> property turned off (see <a href="exprn_brm_eventpolicies.htm#CIHHHAEE">Section 3.6</a>). This also includes the rule classes configured for <code>DMLEVENTS</code> (see <a href="exprn_brm_eventpolicies.htm#CIHCFFGF">Section 3.7</a>).</p>
<p>You can use rules involving negation constructs to raise alerts (in corresponding rule actions) when a set of primitive events are generated out of order. In applications such as Workflow, rules are often used to enforce sequencing among various business events. The action of such rules is to raise an exception (alert an agent) when the events are detected out of order. You can use a <code>&lt;not&gt;</code> element without a hard deadline (no <code>by</code> attribute) to define such rules.</p>
<p>Consider a composite event with three primitive events: <code>PlaceOrder</code>, <code>PaymentReceived</code>, and <code>ShipOrder</code>. You can use a rule to alert an agent (action) if the <code>ShipOrder</code> event is generated before the <code>PaymentReceived</code> event is detected. (Note that there are alternate ways to model this application in a Workflow system, but this approach is used to explain the negation concept). For this example, you can represent the composite event structure and the rule condition as follows:</p>
<pre>
CREATE or REPLACE TYPE OrderTrack AS OBJECT (
                  order PlaceOrder, -- primitive event type &ndash;-
                  pay PaymentReceived, -- primitive event type --
                  ship ShipOrder); -- primitive event type --

&lt;condition&gt;
  &lt;and equal="order.OrderId, pay.OrderId, ship.OrderId"&gt;
    &lt;object name="order"/&gt; -- no conditions on the primitive events --
    &lt;object name="ship"/&gt;
    <span class="codeinlinebold">&lt;not&gt;</span>
      &lt;object name="pay"/&gt;
    <span class="codeinlinebold">&lt;/not&gt;</span>
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The previous example uses a <code>&lt;not&gt;</code> element with no deadline specification (<code>by</code> attribute) and thus this value defaults to <code>SYSTIMESTAMP</code> (the time at which all other primitive events in the rule condition are detected). You can use the sequence="yes" (<a href="#CIHGBIID">Section 5.2</a>) property, such as shown in the following example, to ensure ordering among the detected events.</p>
<pre>
&lt;condition&gt;
  &lt;and equal="order.OrderId, pay.OrderId, ship.OrderId" <span class="codeinlinebold">sequence="yes"</span>&gt;
    &lt;object name="order"/&gt; -- no conditions on the primitive events --
    &lt;object name="ship"/&gt;
    <span class="codeinlinebold">&lt;not&gt;</span>
      &lt;object name="pay"/&gt;
    <span class="codeinlinebold">&lt;/not&gt;</span>
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>In the previous rule condition, you determine the deadline for the <code>PaymentReceived</code> event by the occurrence of the <code>ShipOrder</code> event, which follows the corresponding <code>PlaceOrder</code> event. In effect, if the <code>ShipOrder</code> event is detected before the <code>PaymentReceived</code> event for a particular order, the rule application executes the action associated with the preceding rule condition.</p>
<p>You can often use the negation construct to detect the non-occurrence of two or more primitive events. For example, a rule such as "If an order is placed by a Gold customer and the items are not shipped within 24 hours of the order placement or if the order is not cancelled, alert the representative" uses negation on the two events, <code>ShipOrder</code> and <code>CancelOrder</code>. You can express such rule conditions using a <code>&lt;notany&gt;</code> element in the place of the <code>&lt;not&gt;</code> element as shown in the following example:</p>
<pre>
&lt;condition&gt;
  &lt;and equal="order.orderId, ship.orderId, cancel.orderId"&gt;
    &lt;object name="order"&gt; Type = 'Gold' &lt;/object&gt;
    <span class="codeinlinebold">&lt;notany count=1</span> by="order.rlm$CrtTime+1"&gt;
       &lt;object name="ship"/&gt;
       &lt;object name="cancel"/&gt; -- assuming a CancelOrder event --
    <span class="codeinlinebold">&lt;/notany&gt;</span>
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The primitive events appearing within the <code>&lt;not&gt;</code> or <code>&lt;notany&gt;</code> element should not be referenced in the <code>join</code> attribute specification of the <code>&lt;and&gt;</code> element. However, you can use primitive events within the <code>EQUAL</code> property specifications. If there is a need to specify a join condition (other than those already captured by the <code>EQUAL</code> property specifications), you can use the <code>join</code> attribute for the <code>&lt;not&gt;</code> element. The conditional expression specified for this <code>join</code> attribute can reference all the primitive events that appear in the rule condition, including those appearing within the <code>&lt;not&gt;</code> element, such as shown in the following example:</p>
<pre>
&lt;condition&gt;
  &lt;and equal="order.orderId, ship.orderId"&gt;
    &lt;object name="order"&gt; Type = 'Gold' &lt;/object&gt;
    &lt;not by="order.rlm$CrtTime+1"
        <span class="codeinlinebold">join="order.Address_zipcode = ship.Address_zipcode"</span>&gt;
      &lt;object name="ship"/&gt;
    &lt;/not&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The rule condition with a negation is considered true only if the join condition in the <code>&lt;and&gt;</code> element evaluates to true and the join condition in the not condition evaluates to false (or there is no event that matches this criteria within specified deadline).</p>
</div>
<!-- class="sect1" -->
<a id="CIHJGEGJ"></a><a id="EXPRN093"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.4</span> Rule Conditions with Set Semantics</h2>
<p>In some applications, the primitive events that constitute a composite event can be the same structure. For example, <code>AddItem</code> could be a primitive event that is generated when a customer adds an item to his shopping cart. You can define rules to monitor multiple items added to the shopping cart and suggest new items based on the past customer experiences (association rules generated by a data mining tools).</p>
<p>Consider an electronics Web store that sells accessories for camcorders. A typical rule in their application could be "If a customer adds a camcorder lens worth more than $100, a lens filter, and a IR light to the shopping cart, suggest a tripod to him". This rule consists of three simple conditions to be checked on every <code>AddItem</code> event generated in the system, such as shown in the following example:</p>
<pre>
Accessory = 'Lens' and Price &gt; 100
Accessory = 'Lens Filter'
Accessory = 'IR Light'
</pre>
<p>To support the application described previously, you model the composite event structure as an object type with multiple embedded types of the same primitive event type (<code>AddItem</code>) as shown in the example that follows. If required, the same composite event structure may also include other primitive event types.</p>
<pre>
CREATE or REPLACE TYPE AddItem AS OBJECT (
                  Accessory VARCHAR(30),
                  Make VARCHAR(20),
                  Price NUMBER);
CREATE or REPLACE TYPE CrossSellEvent AS OBJECT (
                  Item1 AddItem,
                  Item2 AddItem,
                  Item3 AddItem,
                  Item4 AddItem,
                  Item5 AddItem);
</pre>
<p>The preceding composite event <a id="sthref113"></a><a id="sthref114"></a>is created to accommodate rules that are monitoring at most five primitive events in the shopping cart. (Note that the shopping cart may still contain more than 5 items.) In this rule application, you can configure the events for <code>SESSION</code> duration (see <a href="exprn_brm_eventpolicies.htm#CJAEGECB">Section 3.3</a>) such that only the primitive events generated within a user session are considered for rule matches. Using the composite event rule condition syntax, you can express the preceding condition as follows:</p>
<pre>
&lt;condition&gt;
  &lt;and&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>Note that you use the element names <code>Item1</code>, <code>Item2</code>, and <code>Item3</code> to assign the matching events to appropriate attributes of the <code>CrossSellEvent</code> instance. Also, this assignment allows (join) predicates across primitive events in a rule condition as follows:</p>
<pre>
&lt;condition&gt;
  &lt;and join=<span class="codeinlinebold">"Item1.Price+Item2.Price+Item3.Price &gt; 300"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The maximum number of primitive events allowed in a composite event limits the total number of primitive events you can consider in a rule condition with set semantics. Also, following standard SQL semantics, you cannot use aggregate operators in the join conditions to relate multiple events. For rule-based applications involving aggregate operators over a finite, but potentially large number of primitive events, you should configure the rule class for collection events and the rule conditions should specify predicates on these collections.</p>
</div>
<!-- class="sect1" -->
<a id="CIHIIGHD"></a><a id="EXPRN094"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.5</span> Rule Conditions with Any n Semantics</h2>
<p>The examples discussed so far use rules that match all the primitive events specified in a rule condition. You achieve this with the use of an <code>&lt;and&gt;</code> element as the parent of all the primitive event conditions. Some rule applications require rules that could match a subset of primitive events specified in the rule condition. For example, consider a composite event<a id="sthref115"></a><a id="sthref116"></a> <code>CE1</code> consisting of three primitive events <code>PE1</code>, <code>PE2</code>, and <code>PE3</code>. Now, a rule condition you define for the composite event may need to match only one of the three primitive events. For this example, you represent the composite event structure and the rule condition as follows:</p>
<pre>
-- Composite event structure --
CREATE or REPLACE TYPE CE1 AS OBJECT (
              pe1Inst PE1,
              pe2Inst PE2,
              pe3Inst PE3);
-- Sample Rule condition --
&lt;condition&gt;
  <span class="codeinlinebold">&lt;any&gt;</span>
    &lt;object name="pe1Inst"/&gt;
    &lt;object name="pe2Inst"/&gt;
    &lt;object name="pe3Inst"/&gt;
  <span class="codeinlinebold">&lt;/any&gt;</span>
&lt;/condition&gt;
</pre>
<p>When the rule condition should match any two of the three primitive events, use the <code>count</code> attribute of the <code>&lt;any&gt;</code> element, as shown in the example that follows. By default, the <code>count</code> attribute has a value of 1, which is equivalent to a disjunction (OR) of all the primitive events specified within the <code>&lt;any&gt;</code> element.</p>
<pre>
&lt;condition&gt;
  <span class="codeinlinebold">&lt;any count=2&gt;</span>
    &lt;object name="pe1Inst"/&gt;
    &lt;object name="pe2Inst"/&gt;
    &lt;object name="pe3Inst"/&gt;
  <span class="codeinlinebold">&lt;/any&gt;</span>
&lt;/condition&gt;
</pre>
<p>The Any <span class="italic">n</span> semantics in the rule conditions are very common in applications using set semantics. The rule considered in the cross-selling application of <a href="#CIHJGEGJ">Section 5.4</a> can be extended to suggest the tripod to the customer if the shopping cart has any two of the three items specified. You can represent the condition for this rule using the Any <span class="italic">n</span> syntax as follows:</p>
<pre>
&lt;condition&gt;
  <span class="codeinlinebold">&lt;any count=2&gt;</span>
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/any&gt;
&lt;/condition&gt;
</pre>
<p>In a rule condition, some of the primitive events specified within an <code>&lt;any&gt;</code> list may be mandatory for the condition to evaluate to true. For example, in the preceding rule condition, the Lens (Item1) may be mandatory and it should always count for one item in two items matched with the <code>&lt;any count=2&gt;</code> specification. You can represent this new rule condition using the join attribute of the <code>&lt;any&gt;</code> element as follows:</p>
<pre>
&lt;condition&gt;
  &lt;any count=2 <span class="codeinlinebold">join="Item1 IS NOT NULL"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/any&gt;
&lt;/condition&gt;
</pre>
<p>Within an <code>&lt;any&gt;</code> list, often there is a need to correlate the primitive events that occur. For example, you can extend the preceding rule to suggest the tripod to the customer only if the <code>Make</code> attribute of the two items matched is same. When using an <code>&lt;and&gt;</code> element (to match all three items), you can pose this as a <code>join</code> predicate on the <code>Make</code> attribute of each primitive event, such as shown in the following example:</p>
<pre>
&lt;condition&gt;
  &lt;and join<span class="codeinlinebold">="Item1.Make=Item2.Make and Item2.Make=Item3.Make"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/any&gt;
&lt;/condition&gt;
</pre>
<p>However, you cannot use similar join predicates to correlate primitive events in an <code>&lt;any&gt;</code> list because the missing primitive events (the one left out in 2 out of 3) are represented as NULLs and any predicate (other than IS NULL) on a NULL value is always false. For this purpose, when using the <code>&lt;any count=2&gt;</code> specification, the rule should use the following join condition:</p>
<pre>
(Item1.Make is null and Item2.Make = Item3.Make) or
  (Item2.Make is null and Item1.Make = Item3.Make) or
    (Item3.Make is null and Item1.Make = Item2.Make)
</pre>
<p>Within an <code>&lt;any&gt;</code> element, you can represent the preceding join condition in an abbreviated form using an equal clause. With this syntax, the join condition works well with any value assigned to the count attribute of the <code>&lt;any&gt;</code> element, such as shown in the following example:</p>
<pre>
&lt;condition&gt;
  &lt;any count=2 <span class="codeinlinebold">equal="Item1.Make, Item2.Make, Item3.Make"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/any&gt;
&lt;/condition&gt;
</pre>
<p>The equality joins among primitive events of a composite event are very common and thus supports this abbreviated syntax for <code>&lt;and&gt;</code> element as well, as shown in the following example:</p>
<pre>
&lt;condition&gt;
  &lt;and <span class="codeinlinebold">equal="Item1.Make, Item2.Make, Item3.Make"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
&lt;/condition&gt;
</pre>
<p>When you use both <code>equal</code> and <code>join</code> attributes in an <code>&lt;and&gt;</code> or an <code>&lt;any&gt;</code> element, the join predicates represented by the equal specification are combined (using logical AND) with the join predicates listed with the <code>join</code> attribute. For example, the following condition matches any two specified items which are of same make and whose total value is greater than 300. (Note the use of NVL functions in the join predicates).</p>
<pre>
&lt;condition&gt;
  &lt;any count=2 <span class="codeinlinebold">equal="Item1.Make, Item2.Make, Item3.Make"</span>
       join<span class="codeinlinebold">="NVL(Item1.Price,0) + NVL(Item2.Price,0) + NVL(Item3.Price,0) &gt; 300"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/any&gt;
&lt;/condition&gt;
</pre>
<p>The use of equal attribute at the rule class level (instead of each rule) is discussed in <a href="exprn_brm_eventpolicies.htm#CIHHIEFE">Section 3.4</a>.You can use the <code>sequence</code> attribute (<a href="#CIHGBIID">Section 5.2</a>) in an <code>&lt;any&gt;</code> element to ensure that the matching primitive events happen in the specified order for the rule condition to evaluate to true, shown as follows.</p>
<pre>
&lt;condition&gt;
  &lt;any count=2 <span class="codeinlinebold">sequence="yes"</span>&gt;
    &lt;object name="Item1"&gt; Accessory = 'Lens' and Price &gt; 100 &lt;/object&gt;
    &lt;object name="Item2"&gt; Accessory = 'Lens Filter' &lt;/object&gt;
    &lt;object name="Item3"&gt; Accessory = 'IR Light' &lt;/object&gt;
  &lt;/any&gt;
&lt;/condition&gt;
</pre></div>
<!-- class="sect1" -->
<a id="BEIFEFAH"></a><a id="EXPRN512"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.6</span> Rule Conditions with Collection Events</h2>
<p>A collection is an event instance formed by grouping a set of primitive events based on some common properties. The common properties shared by the primitive events could be the equality of certain attributes (for example, all the events in a collection have the same identifier) and they can also include some predicates on the content of the primitive events (for example, all primitive event in the collection satisfy the predicate <code>tranType = 'Withdrawal'</code>).</p>
<p>Consider a rule class configured for three types of primitive events, BankTransaction, Transportation and FieldReport out of which the BankTransaction events are enabled for collection (see <a href="exprn_brm_evnt_rcconfig.htm#CJAGFIDJ">Section 4.8</a>). The rule class can now include rule conditions that test some aggregate predicates on bank transaction events - specifically, bank transaction collection events. For example, the following rule condition makes use of the collection element within the rule condition syntax to test some aggregate predicates.</p>
<pre>
&lt;condition&gt;
   &lt;collection name="bank" groupby="subjectId"
               having="SUM(amount) &gt; 10000"&gt;
         tranType = "Withdrawal" and amount &gt; 1000
   &lt;/collection&gt;
&lt;/condition&gt;
</pre>
<p>With the preceding rule condition, you can consider for collection all the primitive events that match the criteria specified as the collection element's text value (<code>tranType = "Withdrawal" and amount &gt; 1000</code>). The rule condition uses the value specified for the <code>groupby</code> attribute of the <code>&lt;collection&gt;</code> element to create multiple collection events, one for each unique subject identifier (<code>subjectId</code>). The collection event maintains the summaries of the primitive events that formed it and looses the identities of the individual events. It uses these summaries to compute the aggregate values necessary to evaluate the predicates specified in the <code>having</code> clause (value assigned to the <code>having</code> attribute) of the <code>&lt;collection&gt;</code> element. As new primitive events occur, it computes necessary aggregate values incrementally and the predicates in the <code>having</code> clause are evaluated. When the condition specified in the <code>having</code> clause evaluates to true, it considers the rule condition as true and the action associated with the rule is executed. By default, Rules Manager executes the action (or invokes the action callback procedure) synchronously with the last event (time ordered) in the collection. For each new event in the group that keeps the condition in the <code>having</code> clause true, Rules Manager executes the rule action once. Alternately, you can reset the collection after executing the action by using <code>EXCLUSIVE</code> or <code>RULE</code> consumption polices (see <a href="exprn_brm_evnt_rcconfig.htm#CJAGFIDJ">Section 4.8</a>).</p>
<p>The conditional expression you specify for the <code>having</code> clause of the rule condition is in SQL <code>HAVING</code> clause format with one or more predicates joined by conjunctions and disjunctions. You form the predicates in the <code>having</code> clause using one of the five aggregate operators, <code>COUNT</code>, <code>SUM</code>, <code>AVG</code>, <code>MIN</code>, and <code>MAX</code>, each operating on one of the attributes from the corresponding event structure. Some sample forms of SQL <code>HAVING</code> clause specification are as follows.</p>
<pre>
SUM(amount) &gt; 10000 and AVG(amount) &gt;= 1000
SUM(amount) &gt; 10000 and (AVG(amount) &gt;= 1000 or COUNT(*) &lt; 10)
MAX(amount) &gt; 5000 or MIN(amount) &gt; 1000
</pre>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref117"></a>
<h3 class="sect2"><span class="secnum">5.6.1</span> Setting a Fixed Window Size or Length to Restrict the Number of Primitive Events</h3>
<p>With the previous rule condition syntax, the number of primitive events participating in the collection is monotonically increasing until the collection is reset (by consuming the collection event). Optionally, you can restrict the number of primitive events participating in a collection by using one of the two moving window semantics:</p>
<ul>
<li>
<p>Fixed window size</p>
</li>
<li>
<p>Fixed window length</p>
</li>
</ul>
<p>The fixed window size specification for collection events enforces a maximum limit on the number of primitive events in a collection by dropping the oldest event with the addition of a new event. For example, you can enhance the previous rule condition to keep summaries for only the last 100 events (time ordered from the last event occurring) in each collection shown as follows.</p>
<pre>
&lt;condition&gt;
   &lt;collection name="bank" groupby="subjectId"
               having="SUM(amount) &gt; 10000"
               windowsize="100"&gt;
         tranType = "Withdrawal" and amount &gt; 1000
   &lt;/collection&gt;
&lt;/condition&gt;
</pre>
<p>Alternately, a rule condition can restrict the primitive events in a collection by using a fixed time window, which ends with the last primitive event added to the collection. For example, you can write the previous rule condition to consider only the events occurring in the past 24 hours, shown as follows. You express the window length specification as a fraction of a day.</p>
<pre>
&lt;condition&gt;
   &lt;collection name="bank" groupby="subjectId"
               having="SUM(amount) &gt; 10000"
               windowlen="1"&gt;
         tranType = "Withdrawal" and amount &gt; 1000
   &lt;/collection&gt;
&lt;/condition&gt;
</pre>
<p>When a rule condition with collection constructs evaluates to true, a reference to the collection event instance representing a set of primitive events is returned for action execution (in the action callback procedure or the results view). The collection event is of the same type (BankTransaction in previous examples) as the primitive events of which it consists. However, in the collection event, Rules Manager only initializes the attributes on which the primitive events are grouped (native attributes from the collections's <code>group by</code> clause), while the rest are each set to <code>NULL</code>. For example, the collection event created for the previous rule condition is a BankTransaction event with just the <code>subjectId</code> attribute initialized. The rest of the attributes, potentially being different for each primitive event in the collection, are each set to <code>NULL</code>.</p>
<p>For each collection event that is made available to the action logic, you can obtain the aggregate values computed for the collection by using the collection event identifier and the <code>DBMS_RLMGR.GET_AGGREGATE_VALUE</code> call (see <a href="exprn_brm_evnt_rcconfig.htm#CJAGFIDJ">Section 4.8</a>). If the action logic relies on more aggregate values than those that are computed for applying predicates, you can specify them using the <code>compute</code> attribute of the <code>&lt;collection&gt;</code> element. For example, the following rule condition computes the minimum amount value within each collection (in addition to the sum of amounts), which can be fetched into the application at the time of action execution. Each collection event in a rule condition can maintain a total of 5 aggregate values.</p>
<pre>
&lt;condition&gt;
   &lt;collection name="bank" groupby="subjectId"
               having="SUM(amount) &gt; 10000"
               <span class="codeinlinebold">compute="MIN(amount)"</span>
               windowlen="1"&gt;
         tranType = "Withdrawal" and amount &gt; 1000
   &lt;/collection&gt;
&lt;/condition&gt;
</pre>
<p>You can use the rule condition syntax for composite events to relate a collection event with another collection event or a primitive event. For example, you can relate a collection event representing a set of bank transactions to a transportation event to form a rule such as "if a subject withdraws over $10,000 in a day and he rents a truck one-way into a restricted area, add him to the NYPD watch list."</p>
<pre>
ON
  BankTransaction(subjectId, amount, tranType, ..) bank,
  Transport(subjectId, vesselType, locFrom, locTo, ..) transport
IF 
  &lt;condition&gt;
    &lt;and equal="transport.subjectId, bank.subjectId"&gt;
      &lt;collection name="bank" groupby="subjectId"
                  having="SUM(amount) &gt; 10000"
                  <span class="codeinlinebold">windowlen="1"</span>&gt;
             tranType = "Withdrawal" 
      &lt;/collection&gt;
      &lt;object name="transport"&gt;
         vesselType = 'TRUCK' and locTo != locFrom and IsRestrictedArea(locTo) = 1
      &lt;/object&gt;
    &lt;/and&gt;
  &lt;/condition&gt;
THEN 
  PerformAction('ADD2WATCHLIST','NYPD',subjectId)
</pre>
<p>While relating a collection event with other collections or individual (non-collection) events or both, the attributes listed in its <code>groupby</code> clause can be used to form join predicates (<code>join</code> and <code>equal</code> clauses) across events. For example, a collection event formed with the previous rule has its <code>subjectId</code> attribute initialized to the subject identifier that is common across all the primitive events in the collection (owing to the collection's <code>group by</code> clause) and this attribute can be used to join the collection event (bank) with the other events.</p>
<p>The rule application executes the action associated with the previous rule when a bank transaction collection event and a transportation event, both meeting their corresponding criteria, match on their <code>subjectId</code> attribute. Depending on the order in which the primitive events occur, it executes the action for this rule synchronously either with the following:</p>
<ul>
<li>
<p>The last bank transaction event in the collection that satisfies the <code>having</code> clause when there is already a transportation event that matches the other criteria, or</p>
</li>
<li>
<p>The transportation event that satisfies its criteria and bears the same subject identifier as a bank transaction collection event that satisfied its <code>having</code> clause.</p>
</li>
</ul>
<p>The <code>having</code> attribute in the <code>&lt;collection&gt;</code> element can only include predicates involving a single collection. If the conditional expression in the <code>having</code> clause should relate multiple collections or one collection with other events, you should use the <code>having</code> attribute of the <code>&lt;and&gt;</code> element. For example, in the following rule condition managing items in a crate (both considered to be radio-frequency ID (RFID) read events), Rules Manager groups the item primitive events based on their <code>crateid</code> attribute and compares the aggregate value computed with the <code>capacity</code> attribute of the crate.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref118"></a>
<h3 class="sect2"><span class="secnum">5.6.2</span> More About Using the Having Clause</h3>
<pre>
&lt;condition&gt;
    &lt;and equal="crate.id, item.crateid"
         having=<span class="codeinlinebold">"COUNT(item.*) &gt; crate.capacity*0.8"</span>&gt;
       &lt;object name="crate"/&gt;
       &lt;collection name="item" groupby="crateid"/&gt;
    &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>The <code>having</code> clause specified with the <code>&lt;and&gt;</code> element can refer to any collection or object you define within the <code>&lt;and&gt;</code> element using extended names (such as <code>item.*</code> and <code>crate.capacity</code>). In such conditions, the <code>having</code> clause acts as the join condition between collections and other primitive events. This combines the aggregate predicate acting as join conditions with the aggregate predicates on specific collections. However, Rules Manager only optimizes for faster evaluation the aggregate predicates you specify with the <code>having</code> attribute of a <code>&lt;collection&gt;</code> element. For example, you can extend the previous rule condition to include a predicate on the minimum number of items in a crate, shown as follows, and with this rule, you can consider a collection event for further evaluation only when it has over 50 individual events.</p>
<pre>
&lt;condition&gt;
    &lt;and equal="crate.id, item.crateid"
         having="count(item.*) &gt; crate.capacity*0.8"&gt;
       &lt;object name="crate"/&gt;
       &lt;collection name="item" groupby="crateid"
                               having=<span class="codeinlinebold">"COUNT(*) &gt; 50"</span>/&gt;
    &lt;/and&gt;
&lt;/condition&gt;
</pre>
<p>You can also use the ability to specify aggregate predicates in the <code>having</code> clause of the <code>&lt;and&gt;</code> element to relate multiple collections. For example, you can compare two collections of primitive events, one representing the withdrawals and the other representing the deposits, to check the trend on a back account over a period of time.</p>
<pre>
ON 
  Deposits (subjectId, amount, ..) dep,
  Withdrawals (subjectId, amount, ..) wdr
IF 
  &lt;condition&gt;
     &lt;and equal ="dep.subjectId, wdr.subjectId"
          having = <span class="codeinlinebold">"SUM(wdr.amount) &gt; SUM(dep.amount)"</span>&gt;   
        &lt;collection name="wdr" groupby="subjectId" windowlen="30"/&gt;
        &lt;collection name="dep" groupby="subjectId" windowlen="30"/&gt;
     &lt;/and&gt;
  &lt;/condition&gt;
THEN
   Alert (dep.accountId, 'Negative Trend');
</pre>
<p>In current release, you cannot combine collection constructs in a rule condition with rule conditions with Negation (see <a href="#BABBGBAJ">Section 5.3</a>) or Any constructs (see <a href="#CIHIIGHD">Section 5.5</a>).</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;For simplicity, the examples in this document are shown without the XML entity references for &lt; (<code>&amp;lt</code>;), &gt; (<code>&amp;gt</code>;), and '(<code>&amp;apos</code>;) symbols. Within a rule condition, less than is the only symbol that you must specify using an entity reference <code>(&amp;lt</code>;) or use within a XML CDATA section. Although it is not mandatory to use entity references for other symbols, they are recommended for compatibility reasons. Following the SQL naming convention, all the values specified for XML attributes and elements are case-insensitive. Case is preserved only if a value appears within quotes.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment988">
<tr>
<td class="cellalignment995">
<table class="cellalignment993">
<tr>
<td class="cellalignment992"><a href="exprn_brm_evnt_rcconfig.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment992"><a href="exprn_brm_mtier.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2003, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment997">
<table class="cellalignment991">
<tr>
<td class="cellalignment992"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment992"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment992"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment992"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment992"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment992"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
