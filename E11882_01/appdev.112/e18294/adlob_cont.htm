<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>DBFS Content API</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 737" />
<meta name="dcterms.created" content="2013-07-18T13:32:41Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database SecureFiles and Large Objects Developer's Guide" />
<meta name="dcterms.identifier" content="E18294-04" />
<meta name="dcterms.isVersionOf" content="ADLOB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adlob_client.htm" title="Previous" type="text/html" />
<link rel="Next" href="adlob_sfstore.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e18294.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/37</span> <!-- End Header -->
<div id="ADLOB007" class="chapter"><a id="g1009"></a><a id="i1060"></a>
<h1 class="chapter"><span class="secnum">7</span> DBFS Content API</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CHDFICII">Overview of DBFS Content API</a></p>
</li>
<li>
<p><a href="#CHDBHBFC">Stores and Package DBMS_DBFS_CONTENT</a></p>
</li>
</ul>
<a id="CHDFICII"></a>
<div id="ADLOB46017" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of DBFS <a id="sthref199"></a>Content API</h2>
<p>The DBFS Content API is a collection of methods that provide a file system-like abstraction. It is backed by one or more DBFS Store Providers. The "Content" in the DBFS Content API is file plus metadata and it can either map to a SecureFiles <code>BLOB</code> (and other columns) in a table or be dynamically created by user-written plug-ins in Java or PL/SQL that run inside the database. This latter form is what is referred to as a "provider."</p>
<p>DBFS Content API comes with a SecureFiles-based store provider implementation (<code>DBMS_DBFS_SFS</code>) to allow creation of SecureFiles LOB-based file systems. Additionally, applications can read and write content that is stored in other (third party) stores through the standard DBFS Content API interface.</p>
<p>Examples of possible providers include:</p>
<ul>
<li>
<p>Content applications like Content DB.</p>
</li>
<li>
<p>Packaged applications that want to surface data through files.</p>
</li>
<li>
<p>Custom applications that want to leverage the file system interface. For example, an application that stores medical images.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDBHBFC"></a>
<div id="ADLOB46018" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref200"></a>Stores and Package DBMS_DBFS_CONTENT</h2>
<p>A store is a collection of documents, each identified by a unique absolute path name, represented as a '<code>/</code>' followed by one or more component names that are separated by a '<code>/</code>'. Some stores may implement only a flat namespace, others might implement directories or folders implicitly, while still others may implement a comprehensive file system-like collection of entities. These may include hierarchical directories, files, symbolic links, hard links, references, and so on. They often include a rich set of metadata associated with documents, and a rich set of behaviors with respect to security, access control, locking, versioning, content addressing, retention control, and so on.</p>
<p>Because stores are typically designed and evolve independently of each other, applications that use a specific store are either written and packaged by the developers of the store, or else require the user to employ a store-specific API. This often requires a detailed knowledge of the schema of the database tables that are used to implement the store itself.</p>
<p>The DBFS Content API is a client-side programmatic API package, <code>DBMS_DBFS_CONTENT</code>, that abstracts out the common features of various stores into a simple and minimalist interface that can be used to build portable client applications while being insulated from store-specific libraries and implementations.</p>
<p>The DBFS Content API aggregates the path namespace of one or more stores into a single unified namespace, using the first component of the path name to disambiguate, and presents this namespace to client applications. This allows clients to access the underlying documents using either a full absolute path name represented by a single string (<code>/</code><code><span class="codeinlineitalic">store_name</span></code><code>/</code><code><span class="codeinlineitalic">store_specific_path_name</span></code>), or a store-qualified path name represented by a string tuple (<code><span class="codeinlineitalic">store_name</span></code><code>, /</code><code><span class="codeinlineitalic">store_specific_path_name</span></code>).</p>
<p>The DBFS Content API then takes care of correctly dispatching various operations on path names to the appropriate stores, and integrating the results back into the client-desired namespace.</p>
<p>Store providers must conform to the service provider interface (SPI) as declared by the package <code>DBMS_DBFS_CONTENT_SPI</code>. The SPI is not a client-side API and serves as a private contract between the implementation of the DBFS Content API and various stores that have to be plugged into it.</p>
<p>The DBFS Content API defines client-visible behavior, both normal and exceptional, of various store operations, while allowing different stores to implement as rich a set of features as they choose. The API allows stores to self-describe their capabilities and allows intelligent client applications to tune their behavior based on these capabilities rather than hard-code logic specific to stores identified by name or by implementation.</p>
<p>See <a class="olink ARPLS235" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS235"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> package</p>
<div id="ADLOB46019" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref201"></a>
<h3 class="sect2">Getting Started with DBMS_DBFS_CONTENT Package</h3>
<p><code>DBMS_DBFS_CONTENT</code> is part of the Oracle Database, starting with Oracle Database 11g Release 2, and does not have to be installed.</p>
<p>See <a class="olink ARPLS72775" href="../../appdev.112/e40758/t_content.htm#ARPLS72775"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information.</p>
<div id="ADLOB46020" class="sect3"><a id="sthref202"></a>
<h4 class="sect3">DBFS Content API Role</h4>
<p>Access to the Content operational and administrative API (packages, types, tables, and so on) is available through <code>dbfs_role</code>. This role can be granted to all users as needed.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46021" class="sect3"><a id="sthref203"></a>
<h4 class="sect3">Path Name Constants and Types</h4>
<p><code>PATH_MAX</code> is the maximum length of an absolute path name visible to clients. <code>NAME_MAX</code> is the maximum length of any individual component of an absolute path name visible to clients. These constants are modeled after their SecureFiles LOB Store counterparts.</p>
<p>PL/SQL types <code>path_t</code> and <code>name_t</code> are portable aliases for strings that can represent path names and component names.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46022" class="sect3"><a id="sthref204"></a>
<h4 class="sect3">Content Properties</h4>
<p>Every path name in a store is associated with a set of properties. For simplicity and generality, each property is identified by a string name, has a string value, possibly <code>null</code> if not set or undefined or unsupported by a specific store implementation, and a value typecode, a numeric discriminant for the actual type of value held in the value string.</p>
<p>Coercing property values to strings has the advantage of making the various interfaces uniform and compact, and can even simplify implementation of the underlying stores. However, this has the disadvantage of the potential for information loss during conversions to and from strings.</p>
<ul>
<li>
<p>It is expected that clients and stores use well-defined database conventions for these conversions, and use the <code>typecode</code> field as appropriate.</p>
</li>
<li>
<p><code>PROPNAME_MAX</code> is the maximum length of a property name, and <code>PROPVAL_MAX</code> is the maximum length of the string value of a property.</p>
</li>
<li>
<p>PL/SQL types <code>propname_t</code> and <code>propval_t</code> are portable aliases for strings that can represent property names and values. A typecode is a numeric value (see the various constants defined in <code>dbms_types</code>) representing the true type of a string-coerced property value. Not all typecodes defined in <code>dbms_types</code> are necessarily even supportable in stores. Simple scalar types (numbers, dates, timestamps, and so on) can be depended upon by clients and must be implemented by stores.</p>
</li>
</ul>
<p>Because standard RDBMS typecodes are positive integers, the DBFS Content API allows negative integers to represent client-defined types by negative typecodes. These typecodes do not conflict with standard typecodes, and are made persistent and returned to the client as needed, but need not be interpreted by the DBFS Content API or any particular store. Portable client applications must not use user-defined typecodes as a back-door way of passing information to specific stores.</p>
<ul>
<li>
<p>The <code>dbms_dbfs_content_property_t</code> object type describes a single (name, value, typecode) property tuple. All properties: standard, optional, and user-defined, are described through such tuples.</p>
</li>
<li>
<p><code>dbms_dbfs_content_properties_t</code> is a variable-sized array of property tuples. These two types are used by both the client-facing APIs and by the store providers for the DBFS Content API.</p>
</li>
</ul>
<p>See <a class="olink ARPLS72484" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72484"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and properties, and <a class="olink ARPLS72484" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72484"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT_PROPERTY_T</code> package.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46023" class="sect3"><a id="sthref205"></a>
<h4 class="sect3">Path Name Types</h4>
<p>Stores can store and provide access to four types of entities:</p>
<ul>
<li>
<p><code>type_file</code> is a regular file that stores content as a logically linear sequence of bytes accessed as a <code>BLOB</code>.</p>
</li>
<li>
<p><code>type_directory</code> is a container of other path name types, including file types.</p>
</li>
<li>
<p><code>type_link</code> is a symbolic link that is an uninterpreted string value associated with a path name. Because symbolic links may represent path names that fall outside the scope of any given store, or even the entire aggregation of stores managed by the DBFS Content API, or may not even represent path names, clients must be careful in creating symbolic links and stores must be careful in trying to resolve these links internally.</p>
</li>
<li>
<p><code>type_reference</code> is a hard link, always a valid path name alias, to content.</p>
</li>
</ul>
<p>Not all stores must implement all directories, links, or references. See <a href="#CHDDAGDA">"Store Features"</a>, and <a class="olink ARPLS72486" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72486"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and path name types.</p>
</div>
<!-- class="sect3" -->
<a id="CHDDAGDA"></a>
<div id="ADLOB46024" class="sect3">
<h4 class="sect3">Store Features</h4>
<p>In order to provide a common programmatic interface to as many different types of stores as possible, the DBFS Content API leaves some of the behavior of various operations to individual store providers to define and implement. However, it is still important to provide client-side programmers with an API that is sufficiently rich and conducive to portable applications.</p>
<p>The DBFS Content API achieves this by allowing different store providers (and different stores) to describe themselves as a feature set (a bit mask indicating which features they support and which ones they do not).</p>
<p>Using the feature set, it is possible, although tricky, for client applications to compensate for the feature deficiencies of specific stores by implementing additional logic on the client side, and deferring complex operations to stores capable of supporting them.</p>
<ul>
<li>
<p><code>feature_folders</code> is set if the store supports folders (or directories) as part of hierarchical path names.</p>
</li>
<li>
<p><code>feature_foiat</code> is set if implicit folder operations within the store (performed as part of a client-requested operation) runs inside autonomous transactions. In general, the use of autonomous transactions is a compromise between simplicity in the implementation and client-controlled transaction scope for all operations, at the cost of greatly reduced concurrency (<code>feature_foiat</code> not set), and more complex implementation and smaller client-controlled transaction scope, at the benefit of greatly increased concurrency (<code>feature_foiat</code> set).</p>
<p>Access to read-only or read-mostly stores should not be greatly affected by this feature.</p>
</li>
<li>
<p><code>feature_acls</code> is set if the store supports access control lists (ACLs) and internal authorization and checking based on these ACLs. ACLs are standard properties, but a store may do nothing more than store and retrieve the ACLs without interpreting them in any way.</p>
</li>
<li>
<p><code>feature_links</code> or <code>feature_link_deref</code> are set if the store supports symbolic links, and if certain types of symbolic links, such as specifically non-absolute path names, can be internally resolved by the store itself.</p>
</li>
<li>
<p><code>feature_references</code> is set if the store supports hard links.</p>
</li>
<li>
<p><code>feature_locking</code> is set if the store supports user-level locks, read-only, write-only, or read-write, that can be applied on various items of the store, and if the store uses these lock settings to control various types of accesses to the locked items. User-level locks are orthogonal to transaction locks and persist beyond the scope of any specific transaction, session, or connection. This implies that the store itself may not be able to clean up after dangling locks, and client-applications must perform any garbage collection.</p>
</li>
<li>
<p><code>feature_lock_hierarchy</code> is set if the store allows a user-lock to control access to the entire sub-tree under the locked path name. A simpler locking model would have locking semantics that apply only to a specific path name, and depend on the locks placed on its parents or children, unless the requested operation implicitly modifies these parents or children.</p>
</li>
<li>
<p><code>feature_lock_convert</code> is set if the store supports upgrade and downgrade of locks from one mode to another.</p>
</li>
<li>
<p><code>feature_versioning</code> is set if the store supports at least a linear versioning and version management. Different versions of the same path name are identified by monotonic version numbers, with a version-nonqualified path name representing the latest version.</p>
</li>
<li>
<p><code>feature_version_path</code> is set if the store supports a hierarchical namespace for different versions of a path name.</p>
</li>
<li>
<p><code>feature_soft_deletes</code> is set if the store supports a soft-delete, deleting a path name and making it invisible to normal operations, but retaining the ability to restore the path name at a later time if it has not been overwritten by a new create operation. The store also supports purging soft-deleted path names, making them truly deleted, and navigation modes that show soft-deleted items.</p>
</li>
<li>
<p><code>feature_hashing</code> is set if the store automatically computes and maintains some type of a secure hash of the contents of a path name, typically a <code>type_file</code> path.</p>
</li>
<li>
<p><code>feature_hash_lookup</code> is set if the store allows content-based addressing, or the ability to locate a content item based not on its path name but on its content hash.</p>
</li>
<li>
<p><code>feature_filtering</code> is set if the store allows clients to pass a filter function, a PL/SQL function that conforms to a specific function signature, that returns a logical boolean indicating if a given store item satisfies a selection predicate. Stores that support filtering may be able to more efficiently perform item listing, directory navigation, and deletions by embedding the filtering logic inside their implementation. If filtering is not supported, clients can retrieve more items than necessary and perform the filtering checks themselves, although less efficiently.</p>
<p>A filter predicate is a function with the following signature:</p>
<pre>
function filterFunction(
    path        in      varchar2,
    store_name  in      varchar2,
    opcode      in      integer,
    item_type   in      integer,
    properties  in      dbms_dbfs_content_properties_t,
    content     in      blob)
    return  integer;
</pre>
<p>Any PL/SQL function conforming to this signature can examine the contents and properties of a store item, and decide if the item satisfies the selection criterion for the current operation. A return value of <code>true</code> (non-zero) results in the DBFS Content API processing the item as part of the current operation; a return value of <code>false</code> (zero or <code>null</code>) results in the item being skipped entirely from processing.</p>
</li>
<li>
<p><code>feature_searching</code> is set if the store allows clients to pass a text-search filter query to locate <code>type_file</code> path names based on their content. Stores that support searching may use indexes to accelerate such searches; otherwise, clients must build their own indexes, or else search a potentially larger set of items to locate the ones of interest for the current search.</p>
</li>
<li>
<p><code>feature_asof</code> is set if the store allows clients to use a flashback timestamp in query operations (non-mutating <code>getPath()</code>, list, search).</p>
</li>
<li>
<p><code>feature_provider_props</code> is set if the store allows per-operation properties (that control the behavior of the store with respect to the current operation, as opposed to properties associated with individual items).</p>
</li>
</ul>
<p><a class="olink ARPLS72488" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72488"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT Constants - Store Features</code>.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46025" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref206"></a>
<h4 class="sect3">Lock Types</h4>
<p>Stores that support locking should implement three types of locks: <code>lock_read_only</code>, <code>lock_write_only</code>, <code>lock_read_write</code>.</p>
<p>User locks (one of the three types) can be associated with a user-supplied <code>lock_data</code>. This is not interpreted by the store, but can be used by client applications for their own purposes (for example, the user data could indicate the time at which the lock was placed, assuming some part of the client application is interested in later using this information to control its actions, for example, garbage collecting stale locks or explicitly break locks).</p>
<p>In the simplest locking model, a <code>lock_read_only</code> prevents all explicit modifications to a path name (but allows implicit modifications, and changes to parent/child path names). A <code>lock_write_only</code> prevents all explicit reads to the path name (but allows implicit reads, and reads to parent/child path names). A <code>lock_read_write</code> allows both.</p>
<p>All locks are associated with a principal user who performs the locking operation; stores that support locking are expected to preserve this information, and use it to perform read/write lock checking (see <code>opt_locker</code>).</p>
<p>More complex lock models: multiple read-locks, lock-scoping across path name hierarchies, lock conversions, group-locking, and so on, are possible but currently not defined by the DBFS Content API.</p>
<p>See <a class="olink ARPLS72489" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72489"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and lock types.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46026" class="sect3"><a id="sthref207"></a>
<h4 class="sect3">Standard Properties</h4>
<p>Standard properties are well-defined, mandatory properties associated with all content path names that all stores must support, in the manner described by the DBFS Content API, with some concessions such as a read-only store need not implement a <code>modification_time</code> or <code>creation_time</code>; stores created against tables with a fixed schema may choose reasonable defaults for as many of these properties as needed, and so on.</p>
<p>All standard properties informally use the <code>std:</code> namespace. Clients and stores should avoid using this namespace to define their own properties because this may cause conflicts in the future.</p>
<p>The menu of the following standard properties is expected to be fairly stable over time.</p>
<ul>
<li>
<p><code>std_access_time</code> (<code>TYPECODE_TIMESTAMP</code> in UTC)</p>
<p>The time of last access of the contents of a path name.</p>
</li>
<li>
<p><code>std_acl</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>The access control list (in standard ACL syntax) associated with the path name.</p>
</li>
<li>
<p><code>std_canonical_path</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>The canonical store-specific path name of an item, suitably cleaned up (leading/, trailing <code>/</code> collapsed, trimmed, and so on).</p>
</li>
<li>
<p><code>std_change_time</code> (<code>TYPECODE_TIMESTAMP</code> in UTC)</p>
<p>The time of last change to the metadata of a path name.</p>
</li>
<li>
<p><code>std_children</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>The number of child directories or folders a directory or folder path has (this property should be available in providers that support <code>feature_folders</code>).</p>
</li>
<li>
<p><code>std_content_type</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>The client-supplied mime-type(s) (in standard RFC syntax) describing the (typically <code>type_file</code>) path name. The content type is not necessarily interpreted by the store.</p>
</li>
<li>
<p><code>std_creation_time</code> (<code>TYPECODE_TIMESTAMP</code> in UTC)</p>
<p>The time at which the item was created (once set, this value never changes for the lifetime of the path name).</p>
</li>
<li>
<p><code>std_deleted</code> (<code>TYPECODE_NUMBER</code> as a <code>boolean</code>)</p>
<p>Set to a non-zero number if the path name has been soft-deleted (see above for this feature), but not yet purged.</p>
</li>
<li>
<p><code>std_guid</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>A store-specific unique identifier for a path name. Clients must not depend on the GUID being unique across different stores, but a given (<code><span class="codeinlineitalic">store-name</span></code>, <code><span class="codeinlineitalic">store-specific-pathname</span></code>) has a stable and unique GUID for its lifetime.</p>
</li>
<li>
<p><code>std_length</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>The length of the content (<code>BLOB</code>) of a <code>type_file</code> or <code>type_reference</code> path, or the length of the referent of a <code>type_link</code> symbolic link. Directories do not have a well-defined length and stores are free to set this property to zero, <code>null</code>, or any other value they choose.</p>
</li>
<li>
<p><code>std_modification_time</code> (<code>TYPECODE_TIMESTAMP</code> in UTC)</p>
<p>The time of last change to the data associated with a path name. Change to the content of a <code>type_file</code> or <code>type_reference</code> path, the referent of the <code>type_link</code> path, and addition or deletion of immediate children in a <code>type_directory</code> path, all constitute data changes.</p>
</li>
<li>
<p><code>std_owner</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>A client-supplied (or implicit) owner name for the path name. The owner name may be used along with the current principal for access checks by stores that support ACLs and or locking.</p>
</li>
<li>
<p><code>std_parent_guid</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>A store-specific unique identifier for the parent of a path name. Clients must not depend on the GUID being unique across different stores, but a given (<code><span class="codeinlineitalic">store-name</span></code>, <code><span class="codeinlineitalic">store-specific-pathname</span></code>) has a stable and unique GUID for its lifetime.</p>
</li>
<li>
<p><code>std_parent_guid</code> (<code>pathname</code> == <code>std_guid</code>(<code>parent</code>(<code>pathname</code>)))</p>
</li>
<li>
<p><code>std_referent</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>The content of the symbolic link of a <code>type_link</code> path; <code>null</code> otherwise. As mentioned before, the <code>std_referent</code> can be an arbitrary string and must not necessarily be interpreted as path name by clients (or such interpretation should be done with great care).</p>
</li>
</ul>
<p>See <a class="olink ARPLS72492" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72492"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and standard properties.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46027" class="sect3"><a id="sthref208"></a>
<h4 class="sect3">Optional Properties</h4>
<p>Optional properties are well-defined but non-mandatory properties associated with all content path names that all stores are free to support (but only in the manner described by the DBFS Content API). Clients should be prepared to deal with stores that support none of the optional properties.</p>
<p>All optional properties informally use the <code>opt</code> namespace. Clients and stores must avoid using this namespace to define their own properties because this can cause conflicts in the future.</p>
<p>The menu of the following optional properties is expected to be expand over time.</p>
<ul>
<li>
<p><code>opt_hash_type</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>The type of hash provided in the <code>opt_hash_value</code> property; see <code>dbms_crypto</code> for possible options.</p>
</li>
<li>
<p><code>opt_hash_value</code> (<code>TYPECODE_RAW</code>)</p>
<p>The hash value of type <code>opt_hash_type</code> describing the content of the path name.</p>
</li>
<li>
<p><code>opt_lock_count</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>The number of (compatible) locks placed on a path name. If different principals are allowed to place compatible (read) locks on a path, the <code>opt_locker</code> must specify all lockers (with repeats so that lock counts can be correctly maintained).</p>
</li>
<li>
<p><code>opt_lock_data</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>The client-supplied user-data associated with a user lock, uninterpreted by the store.</p>
</li>
<li>
<p><code>opt_locker</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>The implicit or client-specified principal(s) that applied a user lock on a path name.</p>
</li>
<li>
<p><code>opt_lock_status</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>One of the values (<code>lock_read_only</code>, <code>lock_write_only</code>, <code>lock_read_write</code>) describing the type of lock currently applied on a path name.</p>
</li>
<li>
<p><code>opt_version</code> (<code>TYPECODE_NUMBER</code>)</p>
<p>A sequence number for linear versioning of a path name.</p>
</li>
<li>
<p><code>opt_version_path</code> (<code>TYPECODE_VARCHAR2</code>)</p>
<p>A version path name for hierarchical versioning of a path name.</p>
</li>
</ul>
<p><a class="olink ARPLS72494" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72494"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and optional properties.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46028" class="sect3"><a id="sthref209"></a>
<h4 class="sect3">Property Access Flags</h4>
<p>DBFS Content API methods to get and set properties can use combinations of property access flags to fetch properties from different namespaces in a single API call.</p>
<ul>
<li>
<p><code>prop_none</code></p>
<p>Used when the client is not interested in any properties, and is invoking the content access method for other reasons, such as path name existence, lockability validation, data access, and so on.</p>
</li>
<li>
<p><code>prop_std</code></p>
<p>Used when the client is interested in the standard properties; all standard properties are retrieved if this flag is specified.</p>
</li>
<li>
<p><code>prop_opt</code></p>
<p>Used when the client is interested in the optional properties; all optional properties are retrieved if this flag is specified.</p>
</li>
<li>
<p><code>prop_usr</code></p>
<p>Used when the client is interested in the user-defined properties; all user-defined properties are retrieved if this flag is specified.</p>
</li>
<li>
<p><code>prop_all</code></p>
<p>An alias for the combination of all standard, optional, and user-defined properties.</p>
</li>
<li>
<p><code>prop_data</code></p>
<p>Used when the client is interested only in data access, and does not care about properties.</p>
</li>
<li>
<p><code>prop_spc</code></p>
<p>Used when the client is interested in a mix-and-match of different subsets of various property namespaces; the names of the specific properties to fetch are passed into the DBFS Content API method call as arguments, and only these property values are fetched and returned to the client. This is useful in cases where there are a very large number of properties potentially accessible, but the client is interested in only a small number of them, and knows the names of those properties beforehand.</p>
<p><code>prop_spc</code> is applicable only to the various <code>getPath()</code> operations. Other operations that specify properties simply ignore <code>prop_spc</code> specifications.</p>
</li>
</ul>
<p>See <a class="olink ARPLS72495" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72495"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and property access flags.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46029" class="sect3"><a id="sthref210"></a>
<h4 class="sect3">Exceptions</h4>
<p>DBFS Content API operations can raise any one of the following top-level exceptions.</p>
<p>Clients can program against these specific exceptions in their error handlers without worrying about the specific store implementations of the underlying error signalling code.</p>
<p>Store service providers, for their part, should do their best to trap and wrap any internal exceptions into one of the following exception types, as appropriate.</p>
<p><a class="olink ARPLS72497" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72497"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> constants and optional codes.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46030" class="sect3"><a id="sthref211"></a>
<h4 class="sect3">Property Bundles</h4>
<ul>
<li>
<p>The <code>property_t</code> record type describes a single (value, typecode) property value tuple; the property name is implied (see <code>properties_t</code> in the next code snippet).</p>
</li>
<li>
<p><code>properties_t</code> is a name-indexed hash table of property tuples. The implicit hash-table association between the index and the value allows the client to build up the full <code>dbms_dbfs_content_property_t</code> tuples for a <code>properties_t</code>.</p>
</li>
</ul>
<p>There is an approximate correspondence between <code>dbms_dbfs_content_property_t</code> and <code>property_t</code>. The former is a SQL object type that describes the full property tuple, while the latter is a PL/SQL record type that describes only the property value component.</p>
<p>There is an approximate correspondence between <code>dbms_dbfs_content_properties_t</code> and <code>properties_t</code>. The former is a SQL nested table type, while the latter is a PL/SQL hash table type.</p>
<p>Dynamic SQL calling conventions force the use of SQL types, but PL/SQL code may be implemented more conveniently in terms of the hash-table types.</p>
<p>DBFS Content API provides convenient utility functions to convert between <code>dbms_dbfs_content_properties_t</code> and <code>properties_t</code> (see next code snippet).</p>
<p>See <a class="olink ARPLS72522" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72522"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>PROPERTY_T</code> record type.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB46031" class="sect3"><a id="sthref212"></a>
<h4 class="sect3">Store Descriptors</h4>
<ul>
<li>
<p>A <code>store_t</code> is a record that describes a store registered with, and managed by the DBFS Content API (see the Administrative APIs in the next section).</p>
</li>
<li>
<p>A <code>mount_t</code> is a record that describes a store mount point and its properties.</p>
</li>
</ul>
<p>Clients can query the DBFS Content API for the list of available stores, determine which store handles accesses to a given path name, and determine the feature set for the store.</p>
<p>See <a class="olink ARPLS72524" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72524"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>STORE_T</code> record type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADLOB46032" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref213"></a>
<h3 class="sect2">Administrative and Query APIs</h3>
<p>Administrative clients and content providers are expected to register content stores with the DBFS Content API. Additionally, administrative clients are expected to mount stores into the top-level namespace of their choice.</p>
<p>The registration and unregistration of a store is separated from the mount and unmount of a store because it is possible for the same store to be mounted multiple times at different mount points (and this is under client control).</p>
<p>The administrative methods in <code>DBMS_DBFS_CONTENT</code> are merely wrappers that delegate to the matching methods in <code>DBMS_DBFS_CONTENT_ADMIN</code>. Clients can use the methods in either package to perform administrative operation.</p>
<p>See <a class="olink ARPLS72472" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72472"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for the summary of <code>DBMS_DBFS_CONTENT</code> package methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46033" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref214"></a>
<h3 class="sect2">Registering a Content Store</h3>
<p>Procedure <code>REGISTERSTORE()</code> registers a new store backed by a provider that uses <code>provider_package</code> as the store service provider (conforming to the <code>DBMS_DBFS_CONTENT_SPI</code> package signature).</p>
<p>This method is designed for use by service providers after they have created a new store. Store names must be unique.</p>
<p>See <a class="olink ARPLS72622" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72622"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>REGISTERSTORE()</code> method.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46034" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref215"></a>
<h3 class="sect2">Unregistering A Content Store</h3>
<p>Procedure <code>UNREGISTERSTORE()</code> unregisters a previously registered store, invalidating all mount points associated with it. Once unregistered, all access to the store and its mount points are not guaranteed to work, although consistent read may provide a temporary illusion of continued access.</p>
<p>If the <code>ignore_unknown</code> argument is <code>true</code>, attempts to unregister unknown stores does not raise an exception.</p>
<p>See <a class="olink ARPLS72660" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72660"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>UNREGISTERSTORE()</code> method.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46035" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref216"></a>
<h3 class="sect2">Mounting a Registered Store</h3>
<p>Procedure <code>MOUNTSTORE()</code> mounts a registered store and binds it to the mount point.</p>
<p>Once mounted, access to path names of the form /<code><span class="codeinlineitalic">store_mount</span></code>/<code>xyz</code> is redirected to <code><span class="codeinlineitalic">store_name</span></code> and its content provider.</p>
<p>Store mount points must be unique, and a syntactically valid path name component (that is, a <code>name_t</code> with no embedded <code>/</code>).</p>
<p>If a mount point is not specified (that is, is <code>null</code>), the DBFS Content API attempts to use the store name itself as the mount point name (subject to the uniqueness and syntactic constraints).</p>
<p>A special empty mount point is available for single stores, that is, a scenario where the DBFS Content API manages a single back-end store. In such cases, the client can directly deal with full path names of the form <code>/xyz</code> because there is no ambiguity in how to redirect these accesses.</p>
<p>Single mount points are indicated by the <code>singleton</code> boolean argument, and the <code>store_mount</code> argument is ignored.</p>
<p>The same store can be mounted multiple times, obviously at different mount points.</p>
<p>Mount properties can be used to specify the DBFS Content API execution environment, that is, default values of the principal, owner, <code>ACL</code>, and <code>asof</code>, for a particular mount point. Mount properties can also be used to specify a read-only store.</p>
<p>See <a class="olink ARPLS72598" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72598"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>MOUNTSTORE()</code> method.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46036" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref217"></a>
<h3 class="sect2">Unmounting a Previously Mounted Store</h3>
<p>Procedure <code>UNMOUNTSTORE()</code> unmounts a previously mounted store, either by name or by mount point. Single stores can be unmounted only by store name because they have no mount points. Attempting to unmount a store by name unmounts all mount points associated with the store.</p>
<p>Once unmounted, all access to the store or mount-point is not guaranteed to work although consistent read may provide a temporary illusion of continued access. If the <code>ignore_unknown</code> argument is <code>true</code>, attempts to unregister unknown stores or mounts does not raise an exception.</p>
<p>See <a class="olink ARPLS72658" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72658"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>UNMOUNTSTORE</code> mehtod.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46037" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref218"></a>
<h3 class="sect2">List all Available Stores and Their Features</h3>
<p>The <code>LISTSTORE()</code> function lists all the available stores. The <code>store_mount</code> field of the returned records is set to <code>null</code> because mount points are separate from stores themselves</p>
<p>See <a class="olink ARPLS72595" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72595"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>LISTSTORES</code> Function.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46038" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref219"></a>
<h3 class="sect2">List all Available Mount Points</h3>
<p>Function <code>LISTMOUNTS()</code> lists all available mount points, their backing stores, and the store features. A single mount results in a single returned row, with its <code>store_mount</code> field set to <code>null</code>.</p>
<p>See <a class="olink ARPLS72594" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72594"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>LISTMOUNTS()</code> method.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46039" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref220"></a>
<h3 class="sect2">Look-up Specific Stores and Their Features</h3>
<p>The <code>GETSTOREBY</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>GETFEATUREBY</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> functions look up the path name, store name, or mount point of the store.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46040" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref221"></a>
<h3 class="sect2">DBFS Content API Space Usage</h3>
<p>Clients can query file system space usage statistics using the <code>SPACEUSAGE()</code> method. Providers are expected to support this method for their stores, and to make a best effort determination of space usage, especially if the store consists of multiple tables, indexes, LOBs, and so on</p>
<ul>
<li>
<p><code>blksize</code> is the natural tablespace block size that holds the store; if multiple tablespaces with different block sizes are used, any valid block size is acceptable.</p>
</li>
<li>
<p><code>tbytes</code> is the total size of the store in bytes, and <code>fbytes</code> is the free or unused size of the store in bytes. These values are computed over all segments that comprise the store.</p>
</li>
<li>
<p><code>nfile</code>, <code>ndir</code>, <code>nlink</code>, and <code>nref</code> count the number of currently available files, directories, links, and references in the store.</p>
</li>
</ul>
<p>Because database objects can grow dynamically, it is not easy to estimate the division between free space and used space.</p>
<p>A space usage query on the top level root directory returns a combined summary of the space usage of all available distinct stores under it (if the same store is mounted multiple times, it is counted only once).</p>
<p>See <a class="olink ARPLS72648" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72648"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>SPACEUSAGE()</code> method.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46041" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref222"></a>
<h3 class="sect2">DBFS Content API Session Defaults</h3>
<p>Normal client access to the DBFS Content API executes with an implicit context that consists of:</p>
<ul>
<li>
<p>the <code>principal</code> invoking the current operation,</p>
</li>
<li>
<p>the <code>owner</code> for all new elements created (implicitly or explicitly) by the current operation,</p>
</li>
<li>
<p>the <code>ACL</code> for all new elements created (implicitly or explicitly) by the current operation,</p>
</li>
<li>
<p>the <code>ASOF</code> timestamp at which the underlying read-only operation (or its read-only sub-components) execute.</p>
</li>
</ul>
<p>All of this information can be passed in explicitly through arguments to the various DBFS Content API method calls, allowing the client fine-grained control over individual operations.</p>
<p>The DBFS Content API also allows clients to set session duration defaults for the context that is automatically inherited by all operations for which the defaults are not explicitly overridden.</p>
<p>All of the context defaults start out as <code>null</code>, and can be cleared by setting them to <code>null</code>.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46042" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref223"></a>
<h3 class="sect2">DBFS Content API Interface Versioning</h3>
<p>To allow for the DBFS Content API itself to evolve, an internal numeric API version increases with each change to the public API.</p>
<p>See <a class="olink ARPLS72589" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72589"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>GETVERSION()</code> method.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46043" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref224"></a>
<h3 class="sect2">DBFS Content API Notes on Path Names</h3>
<p>Clients of the DBFS Content API refer to store items through absolute path names. These path names may be full (a single string of the form <code>/</code><code><span class="codeinlineitalic">mount_point</span></code><code>/</code><code><span class="codeinlineitalic">pathname</span></code>), or store-qualified (a tuple of the form <code>(</code><code><span class="codeinlineitalic">store_name</span></code><code>,</code> <code><span class="codeinlineitalic">pathname</span></code><code>)</code>, where the path name is rooted within the store namespace).</p>
<p>Clients may use either naming scheme as it suits them, and can use both naming methods within their programs.</p>
<p>If path names are returned by DBFS Content API calls, the exact values being returned depend on the naming scheme used by the client in the call. For example, a listing or search on a fully qualified directory name returns items with their fully qualified path names, while a listing or search on a store-qualified directory name returns items whose path names are store-specific, and the store-qualification is implied.</p>
<p>The implementation of the DBFS Content API internally manages the normalization and inter-conversion between these two naming schemes.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46044" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref225"></a>
<h3 class="sect2">DBFS Content API Creation Operations</h3>
<p>The DBFS Content API allows clients to create directory, file, link, and reference elements (subject to store feature support).</p>
<p>All of the creation methods require a valid path name, and can optionally specify properties to be associated with the path name as it is created. It is also possible for clients to fetch back item properties after the creation completes, so that automatically generated properties, such as <code>std_creation_time</code>, are immediately available to clients. The exact set of properties fetched back is controlled by the various <code>prop_</code><code><span class="codeinlineitalic">xxx</span></code> bit masks in <code>prop_flags</code>.</p>
<p>Links and references require an additional path name to associate with the primary path name. File path names can optionally specify a <code>BLOB</code> value to use to initially populate the underlying file content, the provided <code>BLOB</code> may be any valid LOB, either temporary or permanent. On creation, the underlying <code>LOB</code> is returned to the client if <code>prop_data</code> is specified in <code>prop_flags</code>.</p>
<p>Non-directory path names require that their parent directory be created first. Directory path names themselves can be recursively created. This means that the path name hierarchy leading up to a directory can be created in one call.</p>
<p>Attempts to create paths that exist produces an error; the one exception is path names that are soft-deleted. In these cases, the soft-deleted item is implicitly purged, and the new item creation is attempted.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT()</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46045" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref226"></a>
<h3 class="sect2">DBFS Content API Deletion Operations</h3>
<p>The DBFS Content API allows clients to delete directory, file, link, and reference elements, subject to store feature support.</p>
<p>By default, the deletions are permanent, and remove successfully deleted items on transaction commit. However, repositories may also support soft-delete features. If requested by the client, soft-deleted items are retained by the store. They are not, however, typically visible in normal listings or searches. Soft-deleted items may be restored, or explicitly purged.</p>
<p>Directory path names may be recursively deleted; the path name hierarchy below a directory may be deleted in one call. Non-recursive deletions can be performed only on empty directories. Recursive soft-deletions apply the soft-delete to all of the items being deleted.</p>
<p>Individual path names or all soft-deleted path names under a directory may be restored or purged using the <code>RESTORE</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>PURGE</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods.</p>
<p>Providers that support filtering can use the provider filter to identify subsets of items to delete; this makes most sense for bulk operations such as <code>deleteDirectory()</code>, <code>RESTOREALL()</code>, and <code>PURGEALL()</code>, but all of the deletion-related operations accept a filter argument.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46046" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref227"></a>
<h3 class="sect2">DBFS Content API Path Get and Put Operations</h3>
<p>Existing path items may be accessed for query or for update, and modified by simple <code>GET</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> and <code>PUT</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> methods.</p>
<p>All path names allow their metadata to be read and modified. On completion of the call, the client can request that specific properties are fetched through <code>prop_flags</code>.</p>
<p>File path names allow their data to be read and modified. On completion of the call, the client can request a new <code>BLOB</code> locator through the <code>prop_data</code> bit masks in <code>prop_flags</code>; these may be used to continue data access.</p>
<p>Files can also be read and written without using <code>BLOB</code> locators, by explicitly specifying logical offsets, buffer amounts and a suitably sized buffer.</p>
<p>Update accesses must specify the <code>forUpdate</code> flag. Access to link path names may be implicitly and internally dereferenced by stores, subject to feature support, if the <code>deref</code> flag is specified. Oracle does not recommend this practice because symbolic links are not guaranteed to resolve.</p>
<p>The read method <code>GETPATH()</code> where <code>forUpdate</code> is <code>false</code> accepts a valid <code>asof</code> timestamp parameter that can be used by stores to implement flashback-style queries.</p>
<p>Mutating versions of the <code>GETPATH()</code> and the <code>PUTPATH()</code> methods do not support <code>asof</code> modes of operation.</p>
<p>The DBFS Content API does not have an explicit <code>COPY()</code> operation because a copy is easily implemented as a combination of a <code>GETPATH()</code> followed by a <code>CREATE</code><code><span class="codeinlineitalic">XXX</span></code><code>()</code> with appropriate data or metadata transfer across the calls. This allows copies across stores, while an internalized copy operation cannot provide this facility.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46047" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref228"></a>
<h3 class="sect2">DBFS Content API Rename and Move Operations</h3>
<p>Path names can be renamed or moved, possibly across directory hierarchies and mount points, but only within the same store.</p>
<p>Non-directory path names previously accessible by <code>oldPath</code> are renamed as a single item subsequently accessible by <code>newPath</code>, assuming that <code>newPath</code> does not exist.</p>
<p>If <code>newPath</code> exists and is not a directory, the rename implicitly deletes the existing item before renaming <code>oldPath</code>. If <code>newPath</code> exists and is a directory, oldPath is moved into the target directory.</p>
<p>Directory path names previously accessible by <code>oldPath</code> are renamed by moving the directory and all of its children to <code>newPath</code> (if it does not exist) or as children of <code>newPath</code> (if it exists and is a directory).</p>
<p>Because the semantics of rename and move with respect to non-existent or existent and non-directory or directory targets is complex, clients may choose to implement complex rename and move operation as a sequence of simpler moves or copies.</p>
<p>See <a class="olink ARPLS72624" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72624"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT.RENAMEPATH()</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46048" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref229"></a>
<h3 class="sect2">Directory Listings</h3>
<ul>
<li>
<p>A <code>list_item_t</code> is a (path name, component name, type) tuple representing a single element in a directory listing.</p>
</li>
<li>
<p>A <code>path_item_t</code> is a tuple describing a (store, mount) qualified path in a content store, with all standard and optional properties associated with it.</p>
</li>
<li>
<p>A <code>prop_item_t</code> is a tuple describing a (store, mount) qualified path in a content store, with all user-defined properties associated with it, expanded out into individual (name, value, type) tuples.</p>
</li>
</ul>
<p>See <a class="olink ARPLS72513" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72513"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of data structures.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46049" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref230"></a>
<h3 class="sect2">DBFS Content API Directory Navigation and Search</h3>
<p>Clients of the DBFS Content API can list or search the contents of directory path names, optionally recursively in sub-directories, optionally seeing soft-deleted items, optionally using flashback <code>asof</code> a provided timestamp, and optionally filtering items in and out within the store based on list or search predicates.</p>
<p>The DBFS Content API currently returns only list items; the client is expected to explicitly use one of the <code>getPath()</code> methods to access the properties or content associated with an item, as appropriate.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46050" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref231"></a>
<h3 class="sect2">DBFS Content API Locking Operations</h3>
<p>Clients of the DBFS Content API can apply user-level locks to any valid path name, subject to store feature support, associate the lock with user data, and subsequently unlock these path names. The status of locked items is available through various optional properties.</p>
<p>It is the responsibility of the store, assuming it supports user-defined lock checking, to ensure that lock and unlock operations are performed in a consistent manner.</p>
<p><a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46051" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref232"></a>
<h3 class="sect2">DBFS Content API Abstract Operations</h3>
<p>All of the operations in the DBFS Content API are represented as abstract <code>opcodes</code>. Clients can use these <code>opcodes</code> to directly and explicitly invoke the <code>CHECKACCESS()</code> method to verify if a particular operation can be invoked by a given principal on a particular path name.</p>
<p>An <code>op_acl()</code> is an implicit operation invoked during an <code>op_create()</code> or <code>op_put()</code> call, which specifies a <code>std_acl</code> property. The operation tests to see if the principal is allowed to set or change the <code>ACL</code> of a store item.</p>
<p>Soft-deletion, purge, and restore operations are all represented by <code>op_delete()</code>.</p>
<p>The source and destination operations of a rename or move operation are separated, although stores are free to unify these <code>opcode</code>s and to also treat a rename as a combination of delete and create.</p>
<p><code>op_store</code> is a catch-all category for miscellaneous store operations that do not fall under any of the other operational APIs.</p>
<p>See <a href="#CHDEJFBF">"DBFS Content API Access Checks"</a> and <a class="olink ARPLS72498" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72498"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> Constants - Operation Codes.</p>
</div>
<!-- class="sect2" -->
<a id="CHDEJFBF"></a>
<div id="ADLOB46052" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DBFS Content API Access Checks</h3>
<p>Function <code>CHECKACCESS()</code> checks if a given path name (<code>path</code>, <code>pathtype</code>, <code>store_name</code>) can be manipulated by an operation, such as the various <code>op_</code><code><span class="codeinlineitalic">xxx</span></code> opcodes) by <code>principal</code>.</p>
<p>This is a convenience function for the client; a store that supports access control still internally performs these checks to guarantee security.</p>
<p>See <a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46053" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref233"></a>
<h3 class="sect2">DBFS Content API Path Normalization</h3>
<p>Function <code>NORMALIZEPATH()</code> performs the following steps:</p>
<ol>
<li>
<p>Verifies that the path name is absolute (starts with a <code>/</code>).</p>
</li>
<li>
<p>Collapses multiple consecutive <code>/</code>s into a single <code>/</code>.</p>
</li>
<li>
<p>Strips trailing <code>/</code>s.</p>
</li>
<li>
<p>Breaks store-specific normalized path names into two components: the parent path name and the trailing component name.</p>
</li>
<li>
<p>Breaks fully qualified normalized path names into three components: store name, parent path name, and trailing component name.</p>
</li>
</ol>
<p>Note that the root path <code>/</code> is special: its parent path name is also <code>/</code>, and its component name is <code>null</code>. In fully qualified mode, it has a <code>null</code> store name unless a singleton mount has been created, in which case the appropriate store name is returned.</p>
<p>The return value is always the completely normalized store-specific or fully qualified path name.</p>
<p>See <a class="olink ARPLS72624" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72624"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT.RENAMEPATH()</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46054" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref234"></a>
<h3 class="sect2">DBFS Content API Statistics Support</h3>
<p>DBFS Content API statistics are expensive to collect and maintain persistently. DBFS has support for buffering statistics in memory for a maximum of <code>flush_time</code> centiseconds or a maximum of <code>flush_count</code> operations, whichever limit is reached first), at which time the buffers are implicitly flushed to disk.</p>
<p>Clients can also explicitly invoke a flush using <code>flushStats</code>. An implicit flush also occurs when statistics collection is disabled.</p>
<p><code>setStats</code> is used to enable and disable statistics collection; the client can optionally control the flush settings by specifying non-<code>null</code> values for the time and count parameters.</p>
<p><a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46055" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref235"></a>
<h3 class="sect2">DBFS Content API Tracing Support</h3>
<p>DBFS Content API tracing is a generic tracing facility that may be used by any DBFS Content API user (both clients and providers). The DBFS Content API dispatcher itself uses the tracing facility.</p>
<p>Trace information is written to the foreground trace file, with varying levels of detail as specified by the trace level arguments. The global trace level consists of two components: <code>severity</code> and <code>detail</code>. These can be thought of as additive bit masks.</p>
<p>The <code>severity</code> allows the separation of top-level as compared to low-level tracing of different components, and allows the amount of tracing to be increased as needed. There are no semantics associated with different levels, and users are free to set the trace level at any severity they choose, although a good rule of thumb would be to use severity 1 for top-level API entry and exit traces, severity 2 for internal operations, and severity 3 or greater for very low-level traces.</p>
<p>The <code>detail</code> controls how much additional information the trace reports with each trace record: timestamps, short-stack, and so on. <a href="#CHDBDGJJ">Example 7-1</a> demonstrates how to enable tracing using the DBFS Content APIs.</p>
<div id="ADLOB46155" class="example">
<p class="titleinexample"><a id="CHDBDGJJ"></a>Example 7-1 DBFS Content Tracing</p>
<pre>
function    getTrace
        return  integer;
    procedure   setTrace(
        trclvl      in              integer);
    function    traceEnabled(
        sev         in              integer)
        return  integer;
    procedure   trace(
        sev         in              integer,
        msg0        in              varchar2,
        msg1        in              varchar     default '',
        msg2        in              varchar     default '',
        msg3        in              varchar     default '',
        msg4        in              varchar     default '',
        msg5        in              varchar     default '',
        msg6        in              varchar     default '',
        msg7        in              varchar     default '',
        msg8        in              varchar     default '',
        msg9        in              varchar     default '',
        msg10       in              varchar     default '');
</pre></div>
<!-- class="example" -->
<p>See<a class="olink ARPLS72532" href="../../appdev.112/e40758/d_dbfs_content.htm#ARPLS72532"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details of the <code>DBMS_DBFS_CONTENT</code> methods.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB46056" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref236"></a>
<h3 class="sect2">Resource and Property Views</h3>
<p>The following views describe the structure and properties of Content API.</p>
<ul>
<li>
<p>The <code>DBFS_CONTENT</code> views; see <a class="olink REFRN29148" href="../../server.112/e40402/statviews_5113.htm#REFRN29148"><span class="italic">Oracle Database Reference</span></a></p>
</li>
<li>
<p>The <code>DBFS_CONTENT_PROPERTIES</code> views; see <a class="olink REFRN29149" href="../../server.112/e40402/statviews_5114.htm#REFRN29149"><span class="italic">Oracle Database Reference</span></a></p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment898">
<tr>
<td class="cellalignment907">
<table class="cellalignment903">
<tr>
<td class="cellalignment902"><a href="adlob_client.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment902"><a href="adlob_sfstore.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment909">
<table class="cellalignment901">
<tr>
<td class="cellalignment902"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment902"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment902"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment902"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment902"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment902"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
