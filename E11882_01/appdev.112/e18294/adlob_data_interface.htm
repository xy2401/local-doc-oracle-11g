<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Data Interface for Persistent LOBs</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 737" />
<meta name="dcterms.created" content="2013-07-18T13:32:42Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database SecureFiles and Large Objects Developer's Guide" />
<meta name="dcterms.identifier" content="E18294-04" />
<meta name="dcterms.isVersionOf" content="ADLOB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adlob_creating.htm" title="Previous" type="text/html" />
<link rel="Next" href="adlob_bfile_ops.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e18294.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">32/37</span> <!-- End Header -->
<div id="ADLOB1300" class="chapter"><a id="g1029381"></a><a id="i1008680"></a>
<h1 class="chapter"><span class="secnum">20</span> Data Interface for Persistent LOBs</h1>
<p><a id="sthref938"></a>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1012542">Overview of the Data Interface for Persistent LOBs</a></p>
</li>
<li>
<p><a href="#i1012578">Benefits of Using the Data Interface for Persistent LOBs</a></p>
</li>
<li>
<p><a href="#i1012579">Using the Data Interface for Persistent LOBs in PL/SQL</a></p>
</li>
<li>
<p><a href="#i1012580">Using the Data Interface for Persistent LOBs in OCI</a></p>
</li>
<li>
<p><a href="#CIAIHGBB">Using the Data Interface for Persistent LOBs in Java</a></p>
</li>
<li>
<p><a href="#CACIFCJF">Using the Data Interface with Remote LOBs</a></p>
</li>
</ul>
<a id="i1012542"></a>
<div id="ADLOB45642" class="sect1">
<h2 class="sect1">Overview of the Data Interface for Persistent LOBs</h2>
<p>The data interface for persistent LOBs includes a set of Java, PL/SQL, and OCI APIs that are extended to work with LOB data types. These APIs, originally designed for use with legacy data types such as <code>LONG</code>, <code>LONG</code> <code>RAW</code>, and <code>VARCHAR2</code>, can also be used with the corresponding LOB data types shown in <a href="#g1020364">Table 20-1</a> and <a href="#g1020324">Table 20-2</a>. These tables show the legacy data types in the "bind or define type" column and the corresponding supported LOB data type in the "LOB column type" column. You can use the data interface for LOBs to store and manipulate character data and binary data in a LOB column just as if it were stored in the corresponding legacy datatype.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The data interface works for LOB columns and LOBs that are attributes of objects. In this chapter "LOB columns" means LOB columns and LOB attributes.
<p>You can use array bind and define interfaces to insert and select multiple rows in one round trip.</p>
</div>
<p><a id="i1015311"></a>For simplicity, this chapter focuses on character datatypes; however, the same concepts apply to the full set of character and binary datatypes listed in <a href="#g1020364">Table 20-1</a> and <a href="#g1020324">Table 20-2</a>. <code>CLOB</code> also means <code>NCLOB</code> in these tables.</p>
<div id="ADLOB45643" class="tblformal">
<p class="titleintable"><a id="sthref939"></a><a id="g1020364"></a>Table 20-1 Corresponding LONG and LOB Datatypes in SQL and PL/SQL</p>
<table class="cellalignment905" title="Corresponding LONG and LOB Datatypes in SQL and PL/SQL" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment899">
<th class="cellalignment906" id="r1c1-t3">Bind or Define Type</th>
<th class="cellalignment906" id="r1c2-t3">LOB Column Type</th>
<th class="cellalignment906" id="r1c3-t3">Used For Storing</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment899">
<td class="cellalignment907" id="r2c1-t3" headers="r1c1-t3">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c2-t3">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c3-t3">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r3c1-t3" headers="r1c1-t3">
<p><code>LONG</code></p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c2-t3">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c3-t3">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r4c1-t3" headers="r1c1-t3">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c2-t3">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c3-t3">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r5c1-t3" headers="r1c1-t3">
<p><code>LONG RAW</code></p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c2-t3">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c3-t3">
<p>Binary data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r6c1-t3" headers="r1c1-t3">
<p><code>RAW</code></p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c2-t3">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c3-t3">
<p>Binary data</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="ADLOB45644" class="tblformal">
<p class="titleintable"><a id="sthref940"></a><a id="g1020324"></a>Table 20-2 Corresponding LONG and LOB Datatypes in OCI</p>
<table class="cellalignment905" title="Corresponding LONG and LOB Datatypes in OCI" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment899">
<th class="cellalignment906" id="r1c1-t4">Bind or Define Type</th>
<th class="cellalignment906" id="r1c2-t4">LOB Column Type</th>
<th class="cellalignment906" id="r1c3-t4">Used For Storing</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment899">
<td class="cellalignment907" id="r2c1-t4" headers="r1c1-t4">
<p><code>SQLT_AFC(n)</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t4 r1c2-t4">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t4 r1c3-t4">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r3c1-t4" headers="r1c1-t4">
<p><code>SQLT_CHR</code></p>
</td>
<td class="cellalignment907" headers="r3c1-t4 r1c2-t4">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r3c1-t4 r1c3-t4">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r4c1-t4" headers="r1c1-t4">
<p><code>SQLT_LNG</code></p>
</td>
<td class="cellalignment907" headers="r4c1-t4 r1c2-t4">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r4c1-t4 r1c3-t4">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r5c1-t4" headers="r1c1-t4">
<p><code>SQLT_VCS</code></p>
</td>
<td class="cellalignment907" headers="r5c1-t4 r1c2-t4">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment907" headers="r5c1-t4 r1c3-t4">
<p>Character data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r6c1-t4" headers="r1c1-t4">
<p><code>SQLT_BIN</code></p>
</td>
<td class="cellalignment907" headers="r6c1-t4 r1c2-t4">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment907" headers="r6c1-t4 r1c3-t4">
<p>Binary data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r7c1-t4" headers="r1c1-t4">
<p><code>SQLT_LBI</code></p>
</td>
<td class="cellalignment907" headers="r7c1-t4 r1c2-t4">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment907" headers="r7c1-t4 r1c3-t4">
<p>Binary data</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r8c1-t4" headers="r1c1-t4">
<p><code>SQLT_LVB</code></p>
</td>
<td class="cellalignment907" headers="r8c1-t4 r1c2-t4">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment907" headers="r8c1-t4 r1c3-t4">
<p>Binary data</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect1" -->
<a id="i1012578"></a>
<div id="ADLOB45645" class="sect1">
<h2 class="sect1">Benefits of Using the Data Interface for Persistent LOBs</h2>
<p>Using the data interface for persistent LOBs has the following benefits:</p>
<ul>
<li>
<p>If your application uses <code>LONG</code> datatypes, then you can use the same application with LOB datatypes with little or no modification of your existing application required. To do so, just convert <code>LONG</code> datatype columns in your tables to LOB datatype columns as discussed in <a href="adlob_long_lob.htm#g1029181">Chapter 18, "Migrating Columns from LONGs to LOBs"</a>.</p>
</li>
<li>
<p>Performance is better for OCI applications that use sequential access techniques. A piecewise <code>INSERT</code> or fetch using the data interface has comparable performance to using OCI functions like <code>OCILobRead2()</code> and <code>OCILobWrite2()</code>. Because the data interface allows more than 4K bytes of data to be inserted into a LOB in a single OCI call, a round-trip to the server is saved.</p>
</li>
<li>
<p>You can read LOB data in one <code>OCIStmtFetch()</code> call, instead of fetching the LOB locator first and then calling <code>OCILobRead2()</code>. This improves performance when you want to read LOB data starting at the beginning.</p>
</li>
<li>
<p>You can use array bind and define interfaces to insert and select multiple rows with LOBs in one round trip.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1012579"></a>
<div id="ADLOB45646" class="sect1">
<h2 class="sect1">Using the Data Interface for Persistent LOBs in PL/SQL</h2>
<p>The data interface enables you to use <code>LONG</code> and LOB datatypes listed in <a href="#g1020364">Table 20-1</a> to perform the following operations in PL/SQL:</p>
<ul>
<li>
<p><code>INSERT</code> or <code>UPDATE</code> character data stored in datatypes such as <code>VARCHAR2</code>, <code>CHAR</code>, or <code>LONG</code> into a <code>CLOB</code> column.</p>
</li>
<li>
<p><code>INSERT</code> or <code>UPDATE</code> binary data stored in datatypes such as <code>RAW</code> or <code>LONG</code> <code>RAW</code> into a <code>BLOB</code> column.</p>
</li>
<li>
<p>Use the <code>SELECT</code> statement on <code>CLOB</code> columns to select data into a character buffer variable such as <code>CHAR</code>, <code>LONG</code>, or <code>VARCHAR2</code>.</p>
</li>
<li>
<p>Use the <code>SELECT</code> statement on <code>BLOB</code> columns to select data into a binary buffer variable such as <code>RAW</code> and <code>LONG</code> <code>RAW</code>.</p>
</li>
<li>
<p>Make cross-type assignments (implicit type conversions) between <code>CLOB</code> and <code>VARCHAR2</code>, <code>CHAR</code>, or <code>LONG</code> variables.</p>
</li>
<li>
<p>Make cross-type assignments (implicit type conversions) between <code>BLOB</code> and <code>RAW</code> or <code>LONG</code> <code>RAW</code> variables.</p>
</li>
<li>
<p>Pass LOB datatypes to functions defined to accept <code>LONG</code> datatypes or pass <code>LONG</code> datatypes to functions defined to accept LOB datatypes. For example, you can pass a <code>CLOB</code> instance to a function defined to accept another character type, such as <code>VARCHAR2</code>, <code>CHAR</code>, or <code>LONG</code>.</p>
</li>
<li>
<p>Use <code>CLOB</code>s with other PL/SQL functions and operators that accept <code>VARCHAR2</code> arguments such as <code>INSTR</code> and <code>SUBSTR</code>. See <a href="#i1011697">"Passing CLOBs to SQL and PL/SQL Built-In Functions"</a> for a complete list.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When using the data interface for LOBs with the <code>SELECT</code> statement in PL/SQL, you cannot specify the amount you want to read. You can only specify the buffer length of your buffer. If your buffer length is smaller than the LOB data length, then the database throws an exception.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adlob_sql_semantics.htm#BABBFDDF">Chapter 16, "SQL Semantics and LOBs"</a> for details on LOB support in SQL statements</p>
</li>
<li>
<p><a href="adlob_long_lob.htm#i1007059">"Some Implicit Conversions Are Not Supported for LOB Data Types"</a></p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i1011073"></a>
<div id="ADLOB45647" class="sect2">
<h3 class="sect2">Guidelines for Accessing LOB Columns Using the Data Interface in SQL and PL/SQL</h3>
<p>This section describes techniques you use to access LOB columns or attributes using the data interface for persistent LOBs.</p>
<p>Data from <code>CLOB</code> and <code>BLOB</code> columns or attributes can be referenced by regular SQL statements, such as <code>INSERT</code>, <code>UPDATE</code>, and <code>SELECT</code>.</p>
<p>There is no piecewise <code>INSERT</code>, <code>UPDATE</code>, or fetch routine in PL/SQL. Therefore, the amount of data that can be accessed from a LOB column or attribute is limited by the maximum character buffer size. PL/SQL supports character buffer sizes up to 32KB - 1 (32767 bytes). For this reason, only LOBs less than 32K bytes in size can be accessed by PL/SQL applications using the data interface for persistent LOBs.</p>
<p>If you must access more than 32KB -1 using the data interface, then you must make OCI calls from the PL/SQL code to use the APIs for piece-wise insert and fetch.</p>
<p>Use he following are guidelines for using the data interface to access LOB columns or attributes:</p>
<ul>
<li>
<p>INSERT operations</p>
<p>You can <code>INSERT</code> into tables containing LOB columns or attributes using regular <code>INSERT</code> statements in the <code>VALUES</code> clause. The field of the LOB column can be a literal, a character datatype, a binary datatype, or a LOB locator.</p>
</li>
<li>
<p><code>UPDATE</code> operations</p>
<p>LOB columns or attributes can be updated as a whole by <code>UPDATE</code>... <code>SET</code> statements. In the <code>SET</code> clause, the new value can be a literal, a character datatype, a binary datatype, or a LOB locator.</p>
</li>
<li>
<p>4000 byte limit on hexadecimal to raw and raw to hexadecimal conversions</p>
<p>The database does not do implicit hexadecimal to <code>RAW</code> or <code>RAW</code> to hexadecimal conversions on data that is more than 4000 bytes in size. You cannot bind a buffer of character data to a binary datatype column, and you cannot bind a buffer of binary data to a character datatype column if the buffer is over 4000 bytes in size. Attempting to do so results in your column data being truncated at 4000 bytes.</p>
<p>For example, you cannot bind a <code>VARCHAR2</code> buffer to a <code>LONG</code> <code>RAW</code> or a <code>BLOB</code> column if the buffer is more than 4000 bytes in size. Similarly, you cannot bind a <code>RAW</code> buffer to a <code>LONG</code> or a <code>CLOB</code> column if the buffer is more than 4000 bytes in size.</p>
</li>
<li>
<p><code>SELECT</code> operations</p>
<p>LOB columns or attributes can be selected into character or binary buffers in PL/SQL. If the LOB column or attribute is longer than the buffer size, then an exception is raised without filling the buffer with any data. LOB columns or attributes can also be selected into LOB locators.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1011120"></a>
<div id="ADLOB45648" class="sect2">
<h3 class="sect2">Implicit Assignment and Parameter Passing</h3>
<p><a id="sthref941"></a>Implicit assignment and parameter passing are supported for LOB columns. For the datatypes listed in <a href="#g1020364">Table 20-1</a> and <a href="#g1020324">Table 20-2</a>, you can pass or assign: any character type to any other character type, or any binary type to any other binary type using the data interface for persistent LOBs.</p>
<p>Implicit assignment works for variables declared explicitly and for variables declared by referencing an existing column type using the <code>%TYPE</code> attribute as show in the following example. This example assumes that column <code>long_col</code> in table <code>t</code> has been migrated from a <code>LONG</code> to a <code>CLOB</code> column.</p>
<pre>
CREATE TABLE t (long_col LONG); -- Alter this table to change LONG column to LOB
DECLARE
   a VARCHAR2(100);
   b t.long_col%type; -- This variable changes from LONG to CLOB
BEGIN
   SELECT * INTO b FROM t;
   a := b;  -- This changes from "VARCHAR2 := LONG to VARCHAR2 := CLOB
   b := a;  -- This changes from "LONG := VARCHAR2 to CLOB := VARCHAR2 
END;
</pre>
<p>Implicit parameter passing is allowed between functions and procedures. For example, you can pass a <code>CLOB</code> to a function or procedure where the formal parameter is defined as a <code>VARCHAR2</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The assigning a <code>VARCHAR2</code> buffer to a LOB variable is somewhat less efficient than assigning a <code>VARCHAR2</code> to a <code>LONG</code> variable because the former involves creating a temporary LOB. Therefore, PL/SQL users experience a slight deterioration in the performance of their applications.</div>
</div>
<!-- class="sect2" -->
<a id="i1011697"></a>
<div id="ADLOB45649" class="sect2">
<h3 class="sect2">Passing CLOBs to SQL and PL/SQL Built-In Functions</h3>
<p>Implicit parameter passing is also supported for built-in PL/SQL functions that accept character data. For example, <code>INSTR</code> can accept a <code>CLOB</code> and other character data.</p>
<p>Any SQL or PL/SQL built-in function that accepts a <code>VARCHAR2</code> can accept a <code>CLOB</code> as an argument. Similarly, a <code>VARCHAR2</code> variable can be passed to any <code>DBMS_LOB</code> API for any parameter that takes a LOB locator.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adlob_sql_semantics.htm#BABBFDDF">Chapter 16, "SQL Semantics and LOBs"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADLOB45650" class="sect2"><a id="sthref942"></a>
<h3 class="sect2">Explicit Conversion Functions</h3>
<p>In PL/SQL, the following explicit conversion functions convert other data types to <code>CLOB</code> and <code>BLOB</code> datatypes as follows:</p>
<ul>
<li>
<p><code>TO_CLOB()</code> converts <code>LONG</code>, <code>VARCHAR2</code>, and <code>CHAR</code> to <code>CLOB</code></p>
</li>
<li>
<p><code>TO_BLOB()</code> converts <code>LONG RAW</code> and <code>RAW</code> to <code>BLOB</code></p>
</li>
</ul>
<p>Also note that the conversion function <code>TO_CHAR()</code> can convert a <code>CLOB</code> to a <code>CHAR</code> type.</p>
</div>
<!-- class="sect2" -->
<a id="i1011774"></a>
<div id="ADLOB45651" class="sect2">
<h3 class="sect2">Calling PL/SQL and C Procedures from SQL</h3>
<p>When a PL/SQL or C procedure is called from SQL, buffers with more than 4000 bytes of data are not allowed.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB45652" class="sect2"><a id="sthref943"></a>
<h3 class="sect2">Calling PL/SQL and C Procedures from PL/SQL</h3>
<p>You can call a PL/SQL or C procedure from PL/SQL. You can pass a <code>CLOB</code> as an actual parameter where <code>CHR</code> is the formal parameter, or vice versa. The same holds for <code>BLOB</code>s and <code>RAW</code>s.</p>
<p>One example of when these cases can arise is when either the formal or the actual parameter is an anchored type, that is, the variable is declared using the <code><span class="codeinlineitalic">table_name.column_name</span></code><code>%type</code> syntax.</p>
<p>PL/SQL procedures or functions can accept a <code>CLOB</code> or a <code>VARCHAR2</code> as a formal parameter. For example the PL/SQL procedure could be one of the following:</p>
<ul>
<li>
<p><span class="bolditalic">When the formal parameter is a CLOB:</span></p>
<pre>
CREATE OR REPLACE PROCEDURE get_lob(table_name IN VARCHAR2, lob INOUT
CLOB) AS
   ...
BEGIN
  ...
END;
/
</pre></li>
<li>
<p><span class="bolditalic">When the formal parameter is a VARCHAR2:</span></p>
<pre>
CREATE OR REPLACE PROCEDURE get_lob(table_name IN VARCHAR2, lob INOUT
VARCHAR2) AS
   ...
BEGIN
  ...
END;
/
</pre></li>
</ul>
<p>The calling function could be of any of the following types:</p>
<ul>
<li>
<p><span class="bolditalic">When the actual parameter is a CHR:</span></p>
<pre>
create procedure ...
declare 
c VARCHAR2[200];
BEGIN
  get_lob('table_name', c);
END;
 
</pre></li>
<li>
<p><span class="bolditalic">When the actual parameter is a CLOB:</span></p>
<pre>
create procedure ...
declare 
c CLOB; 
BEGIN
  get_lob('table_name', c);
END;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1011826"></a>
<div id="ADLOB45653" class="sect2"><a id="g1023176"></a>
<h3 class="sect2">Binds of All Sizes in <a id="sthref944"></a><a id="sthref945"></a>INSERT and UPDATE Operations</h3>
<p>Binds of all sizes are supported for <code>INSERT</code> and <code>UPDATE</code> operations on LOB columns. Multiple binds of any size are allowed in a single <code>INSERT</code> or <code>UPDATE</code> statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you create a table, the length of the default value you specify for any LOB column is restricted to 4000 bytes.</div>
</div>
<!-- class="sect2" -->
<div id="ADLOB45654" class="sect2"><a id="sthref946"></a>
<h3 class="sect2">4000 Byte Limit on Results of a SQL Operator</h3>
<p>If you bind more than 4000 bytes of data to a <code>BLOB</code> or a <code>CLOB</code>, and the data consists of a SQL operator, then Oracle Database limits the size of the result to at most 4000 bytes.</p>
<p>The following statement inserts only 4000 bytes because the result of <code>LPAD</code> is limited to 4000 bytes:</p>
<pre>
INSERT INTO print_media (ad_sourcetext) VALUES (lpad('a', 5000, 'a'));
</pre>
<p>The following statement inserts only 2000 bytes because the result of <code>LPAD</code> is limited to 4000 bytes, and the implicit hexadecimal to raw conversion converts it to 2000 bytes of <code>RAW</code> data:</p>
<pre>
INSERT INTO print_media (ad_photo) VALUES (lpad('a', 5000, 'a'));  
</pre></div>
<!-- class="sect2" -->
<a id="i1013420"></a>
<div id="ADLOB45655" class="sect2">
<h3 class="sect2">Example of 4000 Byte Result Limit of a SQL Operator</h3>
<p>The following example illustrates how the result for SQL operators is limited to 4000 bytes.</p>
<pre>
/* The following command inserts only 4000 bytes because the result of
 * LPAD is limited to 4000 bytes */
INSERT INTO print_media(product_id, ad_id, ad_sourcetext)
  VALUES (2004, 5, lpad('a', 5000, 'a'));
SELECT LENGTH(ad_sourcetext) FROM print_media 
  WHERE product_id=2004 AND ad_id=5;
ROLLBACK;

/* The following command inserts only 2000 bytes because the result of
 * LPAD is limited to 4000 bytes, and the implicit hex to raw conversion
 * converts it to 2000 bytes of RAW data. */
INSERT INTO print_media(product_id, ad_id, ad_composite)
  VALUES (2004, 5, lpad('a', 5000, 'a'));
SELECT LENGTH(ad_composite) from print_media 
  WHERE product_id=2004 AND ad_id=5;
ROLLBAACK;
</pre></div>
<!-- class="sect2" -->
<a id="i1011898"></a>
<div id="ADLOB45656" class="sect2">
<h3 class="sect2">Restrictions on Binds of More Than 4000 Bytes <a id="sthref947"></a></h3>
<p>The following lists the restrictions for binds of more than 4000 bytes:</p>
<ul>
<li>
<p>If a table has both <code>LONG</code> and LOB columns, then you can bind more than 4000 bytes of data to either the <code>LONG</code> or LOB columns, but not both in the same statement.</p>
</li>
<li>
<p>In an <code>INSERT</code> <code>AS</code> <code>SELECT</code> operation, binding of any length data to LOB columns is not allowed.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIAHEJED"></a>
<div id="ADLOB1306" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref948"></a>Parallel DML Support for LOBs</h3>
<p>Parallel execution of the following DML operations on tables with LOB columns is supported. These operations run in parallel execution mode only when performed on a partitioned table. DML statements on non-partitioned tables with LOB columns continue to execute in serial execution mode.</p>
<ul>
<li>
<p><code>INSERT AS SELECT</code></p>
</li>
<li>
<p><code>CREATE TABLE AS SELECT</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>MERGE</code> (conditional <code>UPDATE</code> and <code>INSERT</code>)</p>
</li>
<li>
<p>Multi-table <code>INSERT</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../../server.112/e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> section "Managing Processes for Parallel SQL Execution"</div>
</div>
<!-- class="sect2" -->
<a id="i1013339"></a>
<div id="ADLOB45657" class="sect2">
<h3 class="sect2">Example: PL/SQL - Using Binds of More Than 4000 Bytes in INSERT and UPDATE</h3>
<pre>
DECLARE
  bigtext VARCHAR2(32767);
  smalltext VARCHAR2(2000);
  bigraw RAW (32767);
BEGIN
  bigtext := LPAD('a', 32767, 'a');
  smalltext := LPAD('a', 2000, 'a');
  bigraw := utl_raw.cast_to_raw (bigtext);

  /* Multiple long binds for LOB columns are allowed for INSERT: */
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext, ad_composite)
    VALUES (2004, 1, bigtext, bigraw);

  /* Single long bind for LOB columns is allowed for INSERT: */
  INSERT INTO print_media (product_id, ad_id, ad_sourcetext)
    VALUES (2005, 2, smalltext);  

  bigtext := LPAD('b', 32767, 'b');
  smalltext := LPAD('b', 20, 'a');
  bigraw := utl_raw.cast_to_raw (bigtext);

  /* Multiple long binds for LOB columns are allowed for UPDATE: */
  UPDATE print_media SET ad_sourcetext = bigtext, ad_composite = bigraw,
    ad_finaltext = smalltext;

  /* Single long bind for LOB columns is allowed for UPDATE: */
  UPDATE print_media SET ad_sourcetext = smalltext, ad_finaltext = bigtext;

  /* The following is NOT allowed because we are trying to insert more than
     4000 bytes of data in a LONG and a LOB column: */
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext, press_release)
    VALUES (2030, 3, bigtext, bigtext);
  
  /* Insert of data into LOB attribute is allowed */
  INSERT INTO print_media(product_id, ad_id, ad_header)
     VALUES (2049, 4, adheader_typ(null, null, null, bigraw));

  /* The following is not allowed because we try to perform INSERT AS
     SELECT data INTO LOB */
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext)
    SELECT 2056, 5, bigtext FROM dual;

END;
/
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45658" class="sect2"><a id="sthref949"></a>
<h3 class="sect2">Using the Data Interface for LOBs with INSERT, UPDATE, and SELECT Operations</h3>
<p><code>INSERT</code> and <code>UPDATE</code> statements on LOBs are used in the same way as on <code>LONG</code>s. For example:</p>
<pre>
DECLARE
  ad_buffer VARCHAR2(100);
BEGIN
  INSERT INTO print_media(product_id, ad_id, ad_sourcetext)
    VALUES(2004, 5, 'Source for advertisement 1');
  UPDATE print_media SET ad_sourcetext= 'Source for advertisement 2'
    WHERE product_id=2004 AND ad_id=5;
  /* This retrieves the LOB column if it is up to 100 bytes, otherwise it
   * raises an exception */
  SELECT ad_sourcetext INTO ad_buffer FROM print_media 
    WHERE product_id=2004 AND ad_id=5;
END;
/
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45659" class="sect2"><a id="sthref950"></a>
<h3 class="sect2">Using the Data Interface for LOBs in Assignments and Parameter Passing</h3>
<p>The data interface for LOBs enables implicit assignment and parameter passing as shown in the following example:</p>
<pre>
CREATE TABLE t (clob_col CLOB, blob_col BLOB);
INSERT INTO t VALUES('abcdefg', 'aaaaaa');

DECLARE
  var_buf VARCHAR2(100);
  clob_buf CLOB;
  raw_buf RAW(100);
  blob_buf BLOB;
BEGIN
  SELECT * INTO clob_buf, blob_buf FROM t;
  var_buf := clob_buf;
  clob_buf:= var_buf;
  raw_buf := blob_buf;
  blob_buf := raw_buf;
END;
/

CREATE OR REPLACE PROCEDURE FOO ( a IN OUT CLOB) IS
BEGIN
  -- Any procedure body
  a := 'abc';
END;
/

CREATE OR REPLACE PROCEDURE BAR (b IN OUT VARCHAR2) IS
BEGIN
  -- Any procedure body
  b := 'xyz';
END;
/

DECLARE
  a VARCHAR2(100) := '1234567';
  b CLOB;
BEGIN
  FOO(a);
  SELECT clob_col INTO b FROM t;
  BAR(b);
END;
/
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45660" class="sect2"><a id="sthref951"></a>
<h3 class="sect2">Using the Data Interface for LOBs with PL/SQL Built-In Functions</h3>
<p>This example illustrates the use of <code>CLOB</code>s in PL/SQL built-in functions, using the data interface for LOBs:</p>
<pre>
DECLARE
  my_ad CLOB;
  revised_ad CLOB;
  myGist VARCHAR2(100):= 'This is my gist.';
  revisedGist VARCHAR2(100);
BEGIN
  INSERT INTO print_media (product_id, ad_id, ad_sourcetext)
    VALUES (2004, 5, 'Source for advertisement 1');  

  -- select a CLOB column into a CLOB variable
  SELECT ad_sourcetext INTO my_ad FROM print_media 
    WHERE product_id=2004 AND ad_id=5;

  -- perform VARCHAR2 operations on a CLOB variable
  revised_ad := UPPER(SUBSTR(my_ad, 1, 20));
 
  -- revised_ad is a temporary LOB
  -- Concat a VARCHAR2 at the end of a CLOB
  revised_ad := revised_ad || myGist;

  -- The following statement raises an error if my_ad is
  -- longer than 100 bytes
  myGist := my_ad;
END;
/
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1012580"></a>
<div id="ADLOB45661" class="sect1">
<h2 class="sect1">Using the Data Interface for Persistent LOBs in OCI</h2>
<p>This section discusses OCI functions included in the data interface for persistent LOBs. These OCI functions work for LOB datatypes exactly the same way as they do for <code>LONG</code> datatypes. Using these functions, you can perform <code>INSERT</code>, <code>UPDATE</code>, fetch, bind, and define operations in OCI on LOBs using the same techniques you would use on other datatypes that store character or binary data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use array bind and define interfaces to insert and select multiple rows with LOBs in one round trip.</div>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink LNOCI059" href="../../appdev.112/e10646/oci05bnd.htm#LNOCI059"><span class="italic">Oracle Call Interface Programmer's Guide</span></a><span class="italic">,</span> section "Runtime Data Allocation and Piecewise Operations in OCI"</div>
<div id="ADLOB45662" class="sect2"><a id="sthref952"></a>
<h3 class="sect2">Binding LOB Datatypes in OCI</h3>
<p>You can bind LOB datatypes in the following operations:</p>
<ul>
<li>
<p>Regular, piecewise, and callback binds for <code>INSERT</code> and <code>UPDATE</code> operations</p>
</li>
<li>
<p>Array binds for <code>INSERT</code> and <code>UPDATE</code> operations</p>
</li>
<li>
<p>Parameter passing across PL/SQL and OCI boundaries</p>
</li>
</ul>
<p>Piecewise operations can be performed by polling or by providing a callback. To support these operations, the following OCI functions accept the <code>LONG</code> and LOB datatypes listed in <a href="#g1020324">Table 20-2</a>.</p>
<ul>
<li>
<p><code>OCIBindByName()</code> and <code>OCIBindByPos()</code></p>
<p>These functions create an association between a program variable and a placeholder in the SQL statement or a PL/SQL block for <code>INSERT</code> and <code>UPDATE</code> operations.</p>
</li>
<li>
<p><code>OCIBindDynamic()</code></p>
<p>You use this call to register callbacks for dynamic data allocation for <code>INSERT</code> and <code>UPDATE</code> operations</p>
</li>
<li>
<p><code>OCIStmtGetPieceInfo()</code> and <code>OCIStmtSetPieceInfo()</code></p>
<p>These calls are used to get or set piece information for piecewise operations.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADLOB45663" class="sect2"><a id="sthref953"></a>
<h3 class="sect2">Defining LOB Datatypes in OCI</h3>
<p>The data interface for persistent LOBs allows the following OCI functions to accept the LONG and LOB datatypes listed in <a href="#g1020324">Table 20-2</a>.</p>
<ul>
<li>
<p><code>OCIDefineByPos()</code></p>
<p>This call associates an item in a <code>SELECT</code> list with the type and output data buffer.</p>
</li>
<li>
<p><code>OCIDefineDynamic()</code></p>
<p>This call registers user callbacks for <code>SELECT</code> operations if the <code>OCI_DYNAMIC_FETCH</code> mode was selected in <code>OCIDefineByPos()</code> function call.</p>
</li>
</ul>
<p>When you use these functions with LOB types, the LOB data, and not the locator, is selected into your buffer. Note that in OCI, you cannot specify the amount you want to read using the data interface for LOBs. You can only specify the buffer length of your buffer. The database only reads whatever amount fits into your buffer and the data is truncated.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB45664" class="sect2"><a id="sthref954"></a>
<h3 class="sect2"><a id="sthref955"></a><a id="sthref956"></a><a id="sthref957"></a>Using Multibyte Character Sets in OCI with the Data Interface for LOBs</h3>
<p>When the client character set is in a multibyte format, functions included in the data interface operate the same way with LOB datatypes as they do for LONG datatypes as follows:</p>
<ul>
<li>
<p>For a <span class="italic">piecewise</span> fetch in a multibyte character set, a multibyte character could be cut in the middle, with some bytes at the end of one buffer and remaining bytes in the next buffer.</p>
</li>
<li>
<p>For a <span class="italic">regular</span> fetch, if the buffer cannot hold all bytes of the last character, then Oracle returns as many bytes as fit into the buffer, hence returning partial characters.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1007050"></a>
<div id="ADLOB45665" class="sect2">
<h3 class="sect2">Using OCI Functions to Perform INSERT or UPDATE on LOB Columns</h3>
<p>This section discusses the various techniques you can use to perform <code>INSERT</code> or <code>UPDATE</code> operations on LOB columns or attributes using the data interface. The operations described in this section assume that you have initialized the OCI environment and allocated all necessary handles.</p>
<div id="ADLOB45666" class="sect3"><a id="sthref958"></a>
<h4 class="sect3">Simple INSERTs or UPDATEs in One Piece</h4>
<p>To perform simple <code>INSERT</code> or <code>UPDATE</code> operations in one piece using the data interface for persistent LOBs, perform the following steps:</p>
<ol>
<li>
<p>Call <code>OCIStmtPrepare()</code> to prepare the statement in <code>OCI_DEFAULT</code> mode.</p>
</li>
<li>
<p>Call <code>OCIBindByName()</code> or <code>OCIBindbyPos()</code> in <code>OCI_DEFAULT</code> mode to bind a placeholder for LOB as character data or binary data.</p>
</li>
<li>
<p>Call <code>OCIStmtExecute()</code> to do the actual <code>INSERT</code> or <code>UPDATE</code> operation.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADLOB45667" class="sect3"><a id="sthref959"></a>
<h4 class="sect3">Using Piecewise INSERTs and UPDATEs with Polling</h4>
<p>To perform piecewise <code>INSERT</code> or <code>UPDATE</code> operations with polling using the data interface for persistent LOBs, do the following steps:</p>
<ol>
<li>
<p>Call <code>OCIStmtPrepare()</code> to prepare the statement in <code>OCI_DEFAULT</code> mode.</p>
</li>
<li>
<p>Call <code>OCIBindByName()</code> or <code>OCIBindbyPos()</code> in <code>OCI_DATA_AT_EXEC</code> mode to bind a LOB as character data or binary data.</p>
</li>
<li>
<p>Call <code>OCIStmtExecute()</code> in default mode. Do each of the following in a loop while the value returned from <code>OCIStmtExecute()</code> is <code>OCI_NEED_DATA</code>. Terminate your loop when the value returned from <code>OCIStmtExecute()</code> is <code>OCI_SUCCESS</code>.</p>
<ul>
<li>
<p>Call <code>OCIStmtGetPieceInfo()</code> to retrieve information about the piece to be inserted.</p>
</li>
<li>
<p>Call <code>OCIStmtSetPieceInfo()</code> to set information about piece to be inserted.</p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADLOB45668" class="sect3"><a id="sthref960"></a>
<h4 class="sect3">Piecewise INSERTs and UPDATEs with Callback</h4>
<p>To perform piecewise <code>INSERT</code> or <code>UPDATE</code> operations with callback using the data interface for persistent LOBs, do the following steps:</p>
<ol>
<li>
<p>Call <code>OCIStmtPrepare()</code> to prepare the statement in <code>OCI_DEFAULT</code> mode.</p>
</li>
<li>
<p>Call <code>OCIBindByName()</code> or <code>OCIBindbyPos()</code> in <code>OCI_DATA_AT_EXEC</code> mode to bind a placeholder for the LOB column as character data or binary data.</p>
</li>
<li>
<p>Call <code>OCIBindDynamic()</code> to specify the callback.</p>
</li>
<li>
<p>Call <code>OCIStmtExecute()</code> in default mode.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADLOB45669" class="sect3"><a id="sthref961"></a>
<h4 class="sect3">Array INSERT and UPDATE Operations</h4>
<p>To perform array <code>INSERT</code> or <code>UPDATE</code> operations using the data interface for persistent LOBs, use any of the techniques discussed in this section in conjunction with <code>OCIBindArrayOfStruct()</code>, or by specifying the number of iterations (<code><span class="codeinlineitalic">iter</span></code>), with <code><span class="codeinlineitalic">iter</span></code> value greater than 1, in the <code>OCIStmtExecute()</code> call.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007084"></a>
<div id="ADLOB45670" class="sect2">
<h3 class="sect2">Using the Data Interface to Fetch LOB Data in OCI</h3>
<p>This section discusses techniques you can use to fetch data from LOB columns or attributes in OCI using the data interface for persistent LOBs.</p>
<div id="ADLOB45671" class="sect3"><a id="sthref962"></a>
<h4 class="sect3">Simple Fetch in One Piece</h4>
<p>To perform a simple fetch operation on LOBs in one piece using the data interface for persistent LOBs, do the following:</p>
<ol>
<li>
<p>Call <code>OCIStmtPrepare()</code> to prepare the <code>SELECT</code> statement in <code>OCI_DEFAULT</code> mode.</p>
</li>
<li>
<p>Call <code>OCIDefineByPos()</code> to define a select list position in <code>OCI_DEFAULT</code> mode to define a LOB as character data or binary data.</p>
</li>
<li>
<p>Call <code>OCIStmtExecute()</code> to run the <code>SELECT</code> statement.</p>
</li>
<li>
<p>Call <code>OCIStmtFetch()</code> to do the actual fetch.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADLOB45672" class="sect3"><a id="sthref963"></a>
<h4 class="sect3">Piecewise Fetch with Polling</h4>
<p>To perform a piecewise fetch operation on a LOB column with polling using the data interface for LOBs, do the following steps:</p>
<ol>
<li>
<p>Call <code>OCIStmtPrepare()</code> to prepare the <code>SELECT</code> statement in <code>OCI_DEFAULT</code> mode.</p>
</li>
<li>
<p>Call <code>OCIDefinebyPos()</code> to define a select list position in <code>OCI_DYNAMIC_FETCH</code> mode to define the LOB column as character data or binary data.</p>
</li>
<li>
<p>Call <code>OCIStmtExecute()</code> to run the <code>SELECT</code> statement.</p>
</li>
<li>
<p>Call <code>OCIStmtFetch()</code> in default mode. Do each of the following in a loop while the value returned from <code>OCIStmtFetch()</code> is <code>OCI_NEED_DATA.</code> Terminate your loop when the value returned from <code>OCIStmtFetch()</code> is <code>OCI_SUCCESS</code>.</p>
<ul>
<li>
<p>Call <code>OCIStmtGetPieceInfo()</code> to retrieve information about the piece to be fetched.</p>
</li>
<li>
<p>Call <code>OCIStmtSetPieceInfo()</code> to set information about piece to be fetched.</p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADLOB45673" class="sect3"><a id="sthref964"></a>
<h4 class="sect3">Piecewise with Callback</h4>
<p>To perform a piecewise fetch operation on a LOB column with callback using the data interface for persistent LOBs, do the following:</p>
<ol>
<li>
<p>Call <code>OCIStmtPrepare()</code> to prepare the statement in <code>OCI_DEFAULT</code> mode.</p>
</li>
<li>
<p>Call <code>OCIDefinebyPos()</code> to define a select list position in <code>OCI_DYNAMIC_FETCH</code> mode to define the LOB column as character data or binary data.</p>
</li>
<li>
<p>Call <code>OCIStmtExecute()</code> to run the <code>SELECT</code> statement.</p>
</li>
<li>
<p>Call <code>OCIDefineDynamic()</code> to specify the callback.</p>
</li>
<li>
<p>Call <code>OCIStmtFetch()</code> in default mode.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADLOB45674" class="sect3"><a id="sthref965"></a>
<h4 class="sect3">Array Fetch</h4>
<p>To perform an array fetch in OCI using the data interface for persistent LOBs, use any of the techniques discussed in this section in conjunction with <code>OCIDefineArrayOfStruct()</code>, or by specifying the number of iterations (<code><span class="codeinlineitalic">iter</span></code>), with the value of <code><span class="codeinlineitalic">iter</span></code> greater than 1, in the <code>OCIStmtExecute()</code> call.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007219"></a>
<div id="ADLOB45675" class="sect2">
<h3 class="sect2">PL/SQL and C Binds from OCI</h3>
<p>When you call a PL/SQL procedure from OCI, and have an <code>IN</code> or <code>OUT</code> or <code>IN OUT</code> bind, you should be able to:</p>
<ul>
<li>
<p>Bind a variable as <code>SQLT_CHR</code> or <code>SQLT_LNG</code> where the formal parameter of the PL/SQL procedure is <code>SQLT_CLOB</code>, or</p>
</li>
<li>
<p>Bind a variable as <code>SQLT_BIN</code> or <code>SQLT_LBI</code> where the formal parameter is <code>SQLT_BLOB</code></p>
</li>
</ul>
<p>The following two cases work:</p>
<div id="ADLOB45676" class="sect3"><a id="sthref966"></a>
<h4 class="sect3">Calling PL/SQL Out-binds in the "begin foo(:1); end;" Manner</h4>
<p>Here is an example of calling PL/SQL out-binds in the "begin foo(:1); end;" Manner:</p>
<pre>
text *sqlstmt = (text *)"BEGIN get_lob(:c); END; " ;
</pre></div>
<!-- class="sect3" -->
<div id="ADLOB45677" class="sect3"><a id="sthref967"></a>
<h4 class="sect3">Calling PL/SQL Out-binds in the "call foo(:1);" Manner</h4>
<p>Here is an example of calling PL/SQL out-binds in the "call foo(:1);" manner:</p>
<pre>
text *sqlstmt = (text *)"CALL get_lob(:c);" ;
</pre>
<p>In both these cases, the rest of the program has these statements:</p>
<pre>
OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
               (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   curlen = 0;
OCIBindByName(stmthp, &amp;bndhp[3], errhp,
        (text *) ":c", (sb4) strlen((char *) ":c"),
        (dvoid *) buf5, (sb4) LONGLEN, SQLT_CHR,
        (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
        (ub4) 1, (ub4 *) &amp;curlen, (ub4) OCI_DATA_AT_EXEC);
</pre>
<p>The PL/SQL procedure, <code>get_lob()</code>, is as follows:</p>
<pre>
procedure get_lob(c INOUT CLOB) is  -- This might have been column%type 
  BEGIN
  ... /* The procedure body could be in PL/SQL or C*/
  END;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1012009"></a>
<div id="ADLOB45678" class="sect2">
<h3 class="sect2">Example: C (OCI) - Binds of More than 4000 Bytes for INSERT and UPDATE</h3>
<pre>
void insert3() 
{ 
/* Insert of data into LOB attributes is allowed. */
   ub1 buffer[8000]; 
   text *insert_sql = (text *)"INSERT INTO Print_media (ad_header) \
               VALUES (adheader_typ(NULL, NULL, NULL,:1))"; 
   OCIStmtPrepare(stmthp, errhp, insert_sql, strlen((char*)insert_sql),  
            (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT); 
   OCIBindByPos(stmthp, &amp;bindhp[0], errhp, 1, (dvoid *)buffer, 2000,  
             SQLT_LNG, 0, 0, 0, 0, 0, (ub4) OCI_DEFAULT); 
   OCIStmtExecute(svchp, stmthp, errhp, 1, 0, (const OCISnapshot*) 0, 
                  (OCISnapshot*)0, OCI_DEFAULT); 
}
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45679" class="sect2"><a id="sthref968"></a>
<h3 class="sect2">Using the Data Interface for LOBs in PL/SQL Binds from OCI on LOBs</h3>
<p>The data interface for LOBs allows LOB PL/SQL binds from OCI to work as follows. When you call a PL/SQL procedure from OCI, and have an <code>IN</code> or <code>OUT</code> or <code>IN OUT</code> bind, you should be able to bind a variable as <code>SQLT_CHR</code>, where the formal parameter of the PL/SQL procedure is <code>SQLT_CLOB</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
C procedures are wrapped inside a PL/SQL stub, so the OCI application always calls the PL/SQL stub.</div>
<p>For the OCI calling program, the following are likely cases:</p>
<div id="ADLOB45680" class="sect3"><a id="sthref969"></a>
<h4 class="sect3">Calling PL/SQL Out-binds in the "begin foo(:1); end;" Manner</h4>
<p>For example:</p>
<pre>
text *sqlstmt = (text *)"BEGIN PKG1.P5 (:c); END; " ;
</pre></div>
<!-- class="sect3" -->
<div id="ADLOB45681" class="sect3"><a id="sthref970"></a>
<h4 class="sect3">Calling PL/SQL Out-binds in the "call foo(:1);" Manner</h4>
<p>For example:</p>
<pre>
text *sqlstmt = (text *)"CALL PKG1.P5( :c );" ;
</pre>
<p>In both these cases, the rest of the program is as follows:</p>
<pre>
   OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
            (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
   curlen = 0;

   OCIBindByName(stmthp, &amp;bndhp[3], errhp,
            (text *) ":c4", (sb4) strlen((char *) ":c"),
            (dvoid *) buf5, (sb4) LONGLEN, SQLT_CHR,
            (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
            (ub4) 1, (ub4 *) &amp;curlen, (ub4) OCI_DATA_AT_EXEC);

    OCIStmtExecute(svchp, stmthp, errhp,(ub4) 0,(ub4) 0, (const OCISnapshot*) 0,
            (OCISnapshot*) 0,(ub4) OCI_DEFAULT);
</pre>
<p>The PL/SQL procedure <code>PKG1.P5</code> is as follows:</p>
<pre>
   CREATE OR REPLACE PACKAGE BODY pkg1 AS
     ...
   procedure p5 (c OUT CLOB) is
     -- This might have been table%rowtype (so it   is CLOB now)
   BEGIN
     ...
   END p5;

END pkg1;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1013504"></a>
<div id="ADLOB45682" class="sect2">
<h3 class="sect2">Binding LONG Data for LOB Columns in Binds Greater Than 4000 Bytes</h3>
<p>The following example illustrates binding character data for a LOB column:</p>
<pre>
void simple_insert()
{
  word buflen;
  text buf[5000];
  text *insstmt = (text *) "INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (2004, 1, :SRCTXT)";
 
  OCIStmtPrepare(stmthp, errhp, insstmt, (ub4)strlen((char *)insstmt), 
                (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  
  OCIBindByName(stmthp, &amp;bndhp[0], errhp,
                (text *) ":SRCTXT", (sb4) strlen((char *) ":SRCTXT"),
                (dvoid *) buf, (sb4) sizeof(buf), SQLT_CHR,
                (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  memset((void *)buf, (int)'A', (size_t)5000);
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT);
}
</pre></div>
<!-- class="sect2" -->
<a id="i1013550"></a>
<div id="ADLOB45683" class="sect2">
<h3 class="sect2">Binding LONG Data to LOB Columns Using Piecewise INSERT with Polling</h3>
<p>The following example illustrates using piecewise <code>INSERT</code> with polling using the data interface for LOBs.</p>
<pre>
void piecewise_insert()
{
  text *sqlstmt = (text *)"INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (:1, :2, :3)";
  ub2 rcode;
  ub1 piece, i;
  word product_id = 2004;
  word ad_id = 2;
  ub4 buflen;
  char buf[5000];
 
  OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt), 
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[0], errhp, (ub4) 1,
               (dvoid *) &amp;product_id, (sb4) sizeof(product_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[1], errhp, (ub4) 2,
               (dvoid *) &amp;ad_id, (sb4) sizeof(ad_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[2], errhp, (ub4) 3,
               (dvoid *) 0, (sb4) 15000, SQLT_LNG,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC);
 
  i = 0;
  while (1)
  {
    i++;
    retval = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                            (CONST OCISnapshot*) 0, (OCISnapshot*) 0,
                            (ub4) OCI_DEFAULT);
    switch(retval)
    {
    case OCI_NEED_DATA:
      memset((void *)buf, (int)'A'+i, (size_t)5000);
      buflen = 5000;
      if (i == 1) piece = OCI_FIRST_PIECE;
      else if (i == 3) piece = OCI_LAST_PIECE;
      else piece = OCI_NEXT_PIECE;
 
      if (OCIStmtSetPieceInfo((dvoid *)bndhp[2],
                              (ub4)OCI_HTYPE_BIND, errhp, (dvoid *)buf,
                              &amp;buflen, piece, (dvoid *) 0, &amp;rcode))
        {
          printf("ERROR: OCIStmtSetPieceInfo: %d \n", retval);
          break;
        }
      
      break;
    case OCI_SUCCESS:
      break;
    default:
      printf( "oci exec returned %d \n", retval);
      report_error(errhp);
      retval = OCI_SUCCESS;
    } /* end switch */
    if (retval == OCI_SUCCESS) 
      break;
  } /* end while(1) */
}
</pre></div>
<!-- class="sect2" -->
<a id="i1013609"></a>
<div id="ADLOB45684" class="sect2">
<h3 class="sect2">Binding LONG Data to LOB Columns Using Piecewise INSERT with Callback</h3>
<p>The following example illustrates binding <code>LONG</code> data to LOB columns using a piecewise <code>INSERT</code> with callback:</p>
<pre>
void callback_insert()
{
  word buflen = 15000;
  word product_id = 2004;
  word ad_id = 3;
  text *sqlstmt = (text *) "INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (:1, :2, :3)";
  word pos = 3;
 
  OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT)
 
  OCIBindByPos(stmthp, &amp;bndhp[0], errhp, (ub4) 1,
               (dvoid *) &amp;product_id, (sb4) sizeof(product_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[1], errhp, (ub4) 2,
               (dvoid *) &amp;ad_id, (sb4) sizeof(ad_id), SQLT_INT,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
  OCIBindByPos(stmthp, &amp;bndhp[2], errhp, (ub4) 3,
               (dvoid *) 0, (sb4) buflen, SQLT_CHR,
               (dvoid *) 0, (ub2 *)0, (ub2 *)0,
               (ub4) 0, (ub4 *) 0, (ub4) OCI_DATA_AT_EXEC);
 
  OCIBindDynamic(bndhp[2], errhp, (dvoid *) (dvoid *) &amp;pos,
                 insert_cbk, (dvoid *) 0, (OCICallbackOutBind) 0);
 
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0,
                 (ub4) OCI_DEFAULT);
} /* end insert_data() */
 
/* Inbind callback to specify input data. */
static sb4 insert_cbk(dvoid *ctxp, OCIBind *bindp, ub4 iter, ub4 index,
                       dvoid **bufpp, ub4 *alenpp, ub1 *piecep, dvoid **indpp)
{
  static int a = 0;
  word   j;
  ub4    inpos = *((ub4 *)ctxp);
  char   buf[5000];
 
  switch(inpos)
  {
  case 3:
    memset((void *)buf, (int) 'A'+a, (size_t) 5000);
    *bufpp = (dvoid *) buf;
    *alenpp = 5000 ;
    a++;
    break;
  default: printf("ERROR: invalid position number: %d\n", inpos);
  }
 
  *indpp = (dvoid *) 0;
  *piecep = OCI_ONE_PIECE;
  if (inpos == 3)
  {
    if (a&lt;=1)
    {
      *piecep = OCI_FIRST_PIECE;
      printf("Insert callback: 1st piece\n");
    }
    else if (a&lt;3)
    {
      *piecep = OCI_NEXT_PIECE;
      printf("Insert callback: %d'th piece\n", a);
    }
    else {
      *piecep = OCI_LAST_PIECE;
      printf("Insert callback: %d'th piece\n", a);
      a = 0;
    }
  }
  return OCI_CONTINUE;
}
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45685" class="sect2"><a id="sthref971"></a>
<h3 class="sect2">Binding LONG Data to LOB Columns Using an Array INSERT</h3>
<p>The following example illustrates binding character data for LOB columns using an array <code>INSERT</code> operation:</p>
<pre>
void array_insert()
{
  ub4 i;
  word buflen;
  word arrbuf1[5];
  word arrbuf2[5];
  text arrbuf3[5][5000];
  text *insstmt = (text *)"INSERT INTO Print_media(Product_id, Ad_id,\
                  Ad_sourcetext) VALUES (:PID, :AID, :SRCTXT)";
 
  OCIStmtPrepare(stmthp, errhp, insstmt,
                 (ub4)strlen((char *)insstmt), (ub4) OCI_NTV_SYNTAX,
                 (ub4) OCI_DEFAULT);
 
  OCIBindByName(stmthp, &amp;bndhp[0], errhp,
                (text *) ":PID", (sb4) strlen((char *) ":PID"),
                (dvoid *) &amp;arrbuf1[0], (sb4) sizeof(arrbuf1[0]), SQLT_INT,
                (dvoid *) 0, (ub2 *)0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  OCIBindByName(stmthp, &amp;bndhp[1], errhp,
                (text *) ":AID", (sb4) strlen((char *) ":AID"),
                (dvoid *) &amp;arrbuf2[0], (sb4) sizeof(arrbuf2[0]), SQLT_INT,
                (dvoid *) 0, (ub2 *)0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  OCIBindByName(stmthp, &amp;bndhp[2], errhp,
                (text *) ":SRCTXT", (sb4) strlen((char *) ":SRCTXT"),
                (dvoid *) arrbuf3[0], (sb4) sizeof(arrbuf3[0]), SQLT_CHR,
                (dvoid *) 0, (ub2 *) 0, (ub2 *) 0,
                (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT);
 
  OCIBindArrayOfStruct(bndhp[0], errhp sizeof(arrbuf1[0]),
                       indsk, rlsk, rcsk);
  OCIBindArrayOfStruct(bndhp[1], errhp, sizeof(arrbuf2[0]),
                       indsk, rlsk, rcsk);
  OCIBindArrayOfStruct(bndhp[2], errhp, sizeof(arrbuf3[0]),
                       indsk, rlsk, rcsk);
 
  for (i=0; i&lt;5; i++)
  {
    arrbuf1[i] = 2004;
    arrbuf2[i] = i+4;
    memset((void *)arrbuf3[i], (int)'A'+i, (size_t)5000);
  }
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 5, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0,
                 (ub4) OCI_DEFAULT);
 
}
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45686" class="sect2"><a id="sthref972"></a>
<h3 class="sect2">Selecting a LOB Column into a LONG Buffer Using a Simple Fetch</h3>
<p>The following example illustrates selecting a LOB column using a simple fetch:</p>
<pre>
void simple_fetch()
{
  word retval;
  text buf[15000];
  text *selstmt = (text *) "SELECT Ad_sourcetext FROM Print_media WHERE\
                  Product_id = 2004";
 
  OCIStmtPrepare(stmthp, errhp, selstmt, (ub4)strlen((char *)selstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
 
  retval = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 0, (ub4) 0,
                          (const OCISnapshot*) 0, (OCISnapshot*) 0,
                          (ub4) OCI_DEFAULT);
  while (retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO)
  {
    OCIDefineByPos(stmthp, &amp;defhp, errhp, (ub4) 1, (dvoid *) buf,
                   (sb4) sizeof(buf), (ub2) SQLT_CHR, (dvoid *) 0,
                   (ub2 *) 0, (ub2 *) 0, (ub4) OCI_DEFAULT);
    retval = OCIStmtFetch(stmthp, errhp, (ub4) 1,
                          (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
    if (retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO)
      printf("buf = %.*s\n", 15000, buf);
  }
}
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45687" class="sect2"><a id="sthref973"></a>
<h3 class="sect2">Selecting a LOB Column into a LONG Buffer Using Piecewise Fetch with Polling</h3>
<p>The following example illustrates selecting a LOB column into a <code>LONG</code> buffer using a piecewise fetch with polling:</p>
<pre>
void piecewise_fetch()
{
  text buf[15000];
  ub4 buflen=5000;
  word retval;
  text *selstmt = (text *) "SELECT Ad_sourcetext FROM Print_media
                  WHERE Product_id = 2004 AND Ad_id = 2";
 
  OCIStmtPrepare(stmthp, errhp, selstmt,
                 (ub4) strlen((char *)selstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
 
  OCIDefineByPos(stmthp, &amp;dfnhp, errhp, (ub4) 1,
                 (dvoid *) NULL, (sb4) 100000, SQLT_LNG,
                 (dvoid *) 0, (ub2 *) 0,
                 (ub2 *) 0, (ub4) OCI_DYNAMIC_FETCH);
 
  retval = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 0, (ub4) 0,
                          (CONST OCISnapshot*) 0, (OCISnapshot*) 0,
                          (ub4) OCI_DEFAULT);
 
  retval = OCIStmtFetch(stmthp, errhp, (ub4) 1 ,
                        (ub2) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
 
  while (retval != OCI_NO_DATA &amp;&amp; retval != OCI_SUCCESS)
  {
    ub1 piece;
    ub4 iter;
    ub4 idx;
  
    genclr((void *)buf, 5000);
    switch(retval)
    {
    case OCI_NEED_DATA:
      OCIStmtGetPieceInfo(stmthp, errhp, &amp;hdlptr, &amp;hdltype,
                          &amp;in_out, &amp;iter, &amp;idx, &amp;piece);
      buflen = 5000;
      OCIStmtSetPieceInfo(hdlptr, hdltype, errhp,
                          (dvoid *) buf, &amp;buflen, piece,
                          (CONST dvoid *) &amp;indp1, (ub2 *) 0);
      retval = OCI_NEED_DATA;
      break;
    default:
      printf("ERROR: piece-wise fetching, %d\n", retval);
      return;
    } /* end switch */
    retval = OCIStmtFetch(stmthp, errhp, (ub4) 1 ,
                          (ub2) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
    printf("Data : %.5000s\n", buf);
  } /* end while */
}
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45688" class="sect2"><a id="sthref974"></a>
<h3 class="sect2">Selecting a LOB Column into a LONG Buffer Using Piecewise Fetch with Callback</h3>
<p>The following example illustrates selecting a <code>LONG</code> column into a LOB buffer when using a piecewise fetch with callback:</p>
<pre>
char buf[5000];
void callback_fetch()
{
  word outpos = 1;
  text *sqlstmt = (text *) "SELECT Ad_sourcetext FROM Print_media WHERE
                  Product_id = 2004 AND Ad_id = 3";
  
  OCIStmtPrepare(stmthp, errhp, sqlstmt, (ub4)strlen((char *)sqlstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  OCIDefineByPos(stmthp, &amp;dfnhp[0], errhp, (ub4) 1,
                 (dvoid *) 0, (sb4)3 * sizeof(buf), SQLT_CHR,
                 (dvoid *) 0, (ub2 *)0, (ub2 *)0,
                 (ub4) OCI_DYNAMIC_FETCH);
  
  OCIDefineDynamic(dfnhp[0], errhp, (dvoid *) &amp;outpos,
                   (OCICallbackDefine) fetch_cbk);
 
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0,
                 (ub4) OCI_DEFAULT);
  buf[ 4999 ] = '\0';
  printf("Select callback: Last piece: %s\n", buf);
}
 
/* -------------------------------------------------------------- */
/* Fetch callback to specify buffers. */
/* -------------------------------------------------------------- */
static sb4 fetch_cbk(dvoid *ctxp, OCIDefine *dfnhp, ub4 iter, dvoid **bufpp, 
                      ub4 **alenpp, ub1 *piecep, dvoid **indpp, ub2 **rcpp)
{
  static int a = 0;
  ub4 outpos = *((ub4 *)ctxp);
  ub4 len = 5000;
  switch(outpos)
  {
  case 1:
    a ++;
    *bufpp = (dvoid *) buf;
    *alenpp = &amp;len;
    break;
  default:
    *bufpp = (dvoid *) 0;
    *alenpp = (ub4 *) 0;
    printf("ERROR: invalid position number: %d\n", outpos);
  }
  *indpp = (dvoid *) 0;
  *rcpp = (ub2 *) 0;
 
  buf[len] = '\0';
  if (a&lt;=1)
  {
    *piecep = OCI_FIRST_PIECE;
    printf("Select callback: 0th piece\n");
  }
  else if (a&lt;3)
  {
    *piecep = OCI_NEXT_PIECE;
    printf("Select callback: %d'th piece: %s\n", a-1, buf);
  }
  else {
    *piecep = OCI_LAST_PIECE;
    printf("Select callback: %d'th piece: %s\n", a-1, buf);
    a = 0;
  }
  return OCI_CONTINUE;
}
</pre></div>
<!-- class="sect2" -->
<div id="ADLOB45689" class="sect2"><a id="sthref975"></a>
<h3 class="sect2">Selecting a LOB Column into a LONG Buffer Using an Array Fetch</h3>
<p>The following example illustrates selecting a LOB column into a <code>LONG</code> buffer using an array fetch:</p>
<pre>
void array_fetch()
{
  word i;
  text arrbuf[5][5000];
  text *selstmt = (text *) "SELECT Ad_sourcetext FROM Print_media WHERE
                  Product_id = 2004 AND Ad_id &gt;=4";
 
  OCIStmtPrepare(stmthp, errhp, selstmt, (ub4)strlen((char *)selstmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
 
  OCIStmtExecute(svchp, stmthp, errhp, (ub4) 0, (ub4) 0,
                 (const OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT);
 
  OCIDefineByPos(stmthp, &amp;defhp1, errhp, (ub4) 1,
                   (dvoid *) arrbuf[0], (sb4) sizeof(arrbuf[0]),
                   (ub2) SQLT_CHR, (dvoid *) 0,
                   (ub2 *) 0, (ub2 *) 0, (ub4) OCI_DEFAULT);
 
  OCIDefineArrayOfStruct(dfnhp1, errhp, sizeof(arrbuf[0]), indsk,
                         rlsk, rcsk);
 
  retval = OCIStmtFetch(stmthp, errhp, (ub4) 5,
                        (ub4) OCI_FETCH_NEXT, (ub4) OCI_DEFAULT);
  if (retval == OCI_SUCCESS || retval == OCI_SUCCESS_WITH_INFO)
  {
     printf("%.5000s\n", arrbuf[0]);
     printf("%.5000s\n", arrbuf[1]);
     printf("%.5000s\n", arrbuf[2]);
     printf("%.5000s\n", arrbuf[3]);
     printf("%.5000s\n", arrbuf[4]);
  }
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIAIHGBB"></a>
<div id="ADLOB45690" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref976"></a><a id="sthref977"></a>Using the Data Interface for Persistent LOBs in Java</h2>
<p>You can also read and write <code>CLOB</code> and <code>BLOB</code> data using the same streaming mechanism as for <code>LONG</code> and <code>LONG</code> <code>RAW</code> data. To read, use <code>defineColumnType(nn, Types.LONGVARCHAR)</code> or <code>defineColumnType(nn, Types.LONGVARBINARY)</code> on the column. This produces a direct stream on the data as if it is a <code>LONG</code> or <code>LONG</code> <code>RAW</code> column. For input in a <code>PreparedStatement</code>, you may use <code>setBinaryStream()</code>, <code>setCharacterStream()</code>, or <code>setAsciiStream()</code> for a parameter which is a <code>BLOB</code> or <code>CLOB</code>. These methods use the stream interface to create a LOB in the database from the data in the stream. Both of these techniques reduce database round trips and may result in improved performance in some cases. See the Javadoc on stream data for the significant restrictions which apply, at <code><a href="http://www.oracle.com/technology/">http://www.oracle.com/technology/</a></code>.</p>
<p>Refer to the following in the <span class="italic">JDBC Developer's Guide and Reference</span>:</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a>, "Working with LOBs and BFILEs", section "Data Interface for LOBs"</p>
</li>
<li>
<p><a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a>, "JDBC Standards Support"</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CACIFCJF"></a>
<div id="ADLOB1323" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref978"></a><a id="sthref979"></a>Using the Data Interface with Remote LOBs</h2>
<p>The data interface for insert, update, and select of remote LOBs (access over a <code>dblink</code>) is supported after Oracle Database 10<span class="italic">g</span> Release 2. The examples in the following sections are for the <code>print_media</code> table created in two schemas: <code>dbs1</code> and <code>dbs2</code>. The <code>CLOB</code> column of that table used in the examples shown is <code>ad_finaltext</code>. The examples to be given for PL/SQL, OCI, and Java use binds and defines for this one column, but multiple columns can also be accessed. Here is the functionality supported and its limitations:</p>
<ul>
<li>
<p>You can define a <code>CLOB</code> as <code>CHAR</code> or <code>NCHAR</code> and an <code>NCLOB</code> as CHAR or NCHAR. <code>CLOB</code> and <code>NCLOB</code> can be defined as a <code>LONG</code>. A <code>BLOB</code> can be defined as a <code>RAW</code> or a <code>LONG</code> <code>RAW</code>.</p>
</li>
<li>
<p>Array binds and defines are supported.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CACCFEHH">"Remote Data Interface Example in PL/SQL"</a> and the sections following it.</div>
<div id="ADLOB45691" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref980"></a>
<h3 class="sect2">Non-Supported Syntax</h3>
<ul>
<li>
<p>Queries involving more than one database are not supported:</p>
<pre>
SELECT t1.lobcol, a2.lobcol FROM t1, t2.lobcol@dbs2 a2 WHERE 
LENGTH(t1.lobcol) = LENGTH(a2.lobcol);
</pre>
<p>Neither is this query (in a PL/SQL block):</p>
<pre>
SELECT t1.lobcol INTO varchar_buf1 FROM t1@dbs1
UNION ALL
SELECT t2.lobcol INTO varchar_buf2 FROM t2@dbs2;
</pre></li>
<li>
<p>Only binds and defines for data going into remote persistent LOB columns are supported, so that parameter passing in PL/SQL where <code>CHAR</code> data is bound or defined for remote LOBs is not allowed because this could produce a remote temporary LOB, which are not supported. These statements all produce errors:</p>
<pre>
SELECT foo() INTO varchar_buf FROM table1@dbs2; -- foo returns a LOB

SELECT foo()@dbs INTO char_val FROM DUAL; -- foo returns a LOB

SELECT XMLType().getclobval INTO varchar_buf FROM table1@dbs2;
</pre></li>
<li>
<p>If the remote object is a view such as</p>
<pre>
CREATE VIEW v AS SELECT foo() a FROM ... ; -- foo returns a LOB
/* The local database then tries to get the CLOB data and returns an error */
SELECT a INTO varchar_buf FROM v@dbs2;
</pre>
<p>This returns an error because it produces a remote temporary LOB, which is not supported.</p>
</li>
<li>
<p><code>RETURNING</code> <code>INTO</code> does not support implicit conversions between <code>CHAR</code> and <code>CLOB</code>.</p>
</li>
<li>
<p>PL/SQL parameter passing is not allowed where the actual argument is a LOB type and the remote argument is a <code>VARCHAR2</code>, <code>NVARCHAR2</code>, <code>CHAR</code>, <code>NCHAR</code>, or <code>RAW</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACCFEHH"></a>
<div id="ADLOB45692" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Remote Data Interface Example in PL/SQL</h3>
<p>The data interface only supports data of size less than 32KB in PL/SQL. The following snippet shows a PL/SQL example:</p>
<pre>
CONNECT pm
declare
  my_ad <span class="bold">varchar(6000)</span> := lpad('b', 6000, 'b');
BEGIN
  INSERT INTO <span class="bold">print_media@dbs2</span>(product_id, ad_id, ad_finaltext) 
       VALUES (10000, 10, my_ad);
  -- Reset the buffer value
  my_ad := 'a';
  SELECT ad_finaltext INTO my_ad FROM <span class="bold">print_media@dbs2</span> 
       WHERE product_id = 10000;
END;
/
</pre>
<p>If <code>ad_finaltext</code> were a <code>BLOB</code> column instead of a <code>CLOB</code>, <code>my_ad</code> has to be of type <code>RAW</code>. If the LOB is greater than 32KB - 1 in size, then PL/SQL raises a truncation error and the contents of the buffer are undefined.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB45693" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref981"></a>
<h3 class="sect2">Remote Data Interface Example in OCI</h3>
<p>The data interface only supports data of size less than <code>2 GBytes</code> (the maximum value possible of a variable declared as <code>sb4</code>) for OCI. The following pseudocode can be enhanced to be a part of an OCI program:</p>
<pre>
...
text *sql = (text *)"insert into <span class="bold">print_media@dbs2</span>
                    (product_id, ad_id, ad_finaltext) 
                    values (:1, :2, :3)";
OCIStmtPrepare(...);
OCIBindByPos(...); /* Bind data for positions 1 and 2
                     * which are independent of LOB */
OCIBindByPos(stmthp, &amp;bndhp[2], errhp, (ub4) 3, 
             (dvoid *) charbuf1, (sb4) len_charbuf1, <span class="bold">SQLT_CHR</span>, 
             (dvoid *) 0, (ub2 *)0, (ub2 *)0, 0, 0, OCI_DEFAULT);
OCIStmtExecute(...);

...

text *sql = (text *)"select ad_finaltext from <span class="bold">print_media@dbs2</span>
                    where product_id = 10000";
OCIStmtPrepare(...);
OCIDefineByPos(stmthp, &amp;dfnhp[2], errhp, (ub4) 1, 
             (dvoid *) charbuf2, (sb4) len_charbuf2, <span class="bold">SQLT_CHR</span>, 
             (dvoid *) 0, (ub2 *)0, (ub2 *)0, OCI_DEFAULT);
OCIStmtExecute(...);
...
</pre>
<p>If <code>ad_finaltext</code> were a <code>BLOB</code> instead of a <code>CLOB</code>, then you bind and define using type <code>SQLT_BIN</code>. If the LOB is greater than 2GB - 1 in size, then OCI raises a truncation error and the contents of the buffer are undefined.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB45694" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref982"></a>
<h3 class="sect2">Remote Data Interface Examples in JDBC</h3>
<p>The following code snippets works with all three JDBC drivers (OCI, Thin, and <code>kprb</code> in the database):</p>
<p><span class="bold">Bind:</span></p>
<p>This is for the non-streaming mode:</p>
<pre>
...
String sql = "insert into <span class="bold">print_media@dbs2</span> (product_id, ad_id, ad_final_text)" +
             " values (:1, :2, :3)";
    PreparedStatement pstmt = conn.prepareStatement(sql);
    pstmt.setInt( 1, 2 );
    pstmt.setInt( 2, 20);
    <span class="bold">pstmt.setString( 3, "Java string" );</span>
    int rows = pstmt.executeUpdate();
...
</pre>
<p>For the streaming mode, the same code as the preceding works, except that the <code>setString()</code> statement is replaced by one of the following:</p>
<pre>
pstmt.setCharacterStream( 3, new LabeledReader(), 1000000 );
pstmt.setAsciiStream( 3, new LabeledAsciiInputStream(), 1000000 );
</pre>
<p>Here, <code>LabeledReader()</code> and <code>LabeledAsciiInputStream()</code> produce character and ASCII streams respectively. If <code>ad_finaltext</code> were a <code>BLOB</code> column instead of a <code>CLOB</code>, then the preceding example works if the bind is of type <code>RAW</code>:</p>
<pre>
pstmt.setBytes( 3, &lt;some byte[] array&gt; );

pstmt.setBinaryStream( 3, new LabeledInputStream(), 1000000 );
</pre>
<p>Here, <code>LabeledInputStream()</code> produces a binary stream.</p>
<p><span class="bold">Define:</span></p>
<p>For non-streaming mode:</p>
<pre>
OracleStatement stmt = (OracleStatement)(conn.createStatement());
  stmt.defineColumnType( 1, Types.<span class="bold">VARCHAR</span> );
  ResultSet rst = stmt.executeQuery("select ad_finaltext from print_media@dbs2" );
  while( rst.next() )
     {
       String s = rst.getString( 1 );
       System.out.println( s );
     }
</pre>
<p>For streaming mode:</p>
<pre>
OracleStatement stmt = (OracleStatement)(conn.createStatement());
  stmt.defineColumnType( 1, Types.<span class="bold">LONGVARCHAR</span> );
  ResultSet rst = stmt.executeQuery("select ad_finaltext from print_media@dbs2" );
  while( rst.next() )
     {
       Reader reader = rst.getCharacterStream( 1 );
       while( reader.ready() )
       {
         System.out.print( (char)(reader.next()) );
       }
       System.out.println();
     }
</pre>
<p>If <code>ad_finaltext</code> were a <code>BLOB</code> column instead of a <code>CLOB</code>, then the preceding examples work if the define is of type <code>LONGVARBINARY</code>:</p>
<pre>
...
   OracleStatement stmt = (OracleStatement)conn.createStatement();
 
   stmt.defineColumnType( 1, Types.INTEGER );
   stmt.defineColumnType( 2, Types.LONGVARBINARY );
 
   ResultSet rset = stmt.executeQuery("SELECT ID, LOBCOL FROM LOBTAB@MYSELF");
 
   while(rset.next())
    {
     /* using getBytes() */
     /*
     byte[] b = rset.getBytes("LOBCOL");
     System.out.println("ID: " + rset.getInt("ID") + "  length: " + b.length);
     */
 
        /* using getBinaryStream() */
        InputStream byte_stream = rset.getBinaryStream("LOBCOL");
        byte [] b = new byte [100000];
        int b_len = byte_stream.read(b);
        System.out.println("ID: " + rset.getInt("ID") + "  length: " + b_len);
 
        byte_stream.close();
    }
...
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a>, "Working with LOBs and BFILEs", section "Shortcuts for Inserting and Retrieving CLOB Data"</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment898">
<tr>
<td class="cellalignment907">
<table class="cellalignment903">
<tr>
<td class="cellalignment902"><a href="adlob_creating.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment902"><a href="adlob_bfile_ops.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment909">
<table class="cellalignment901">
<tr>
<td class="cellalignment902"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment902"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment902"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment902"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment902"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment902"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
