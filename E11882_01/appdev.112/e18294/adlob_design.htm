<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Advanced Design Considerations</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 737" />
<meta name="dcterms.created" content="2013-07-18T13:32:41Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database SecureFiles and Large Objects Developer's Guide" />
<meta name="dcterms.identifier" content="E18294-04" />
<meta name="dcterms.isVersionOf" content="ADLOB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adlob_tables.htm" title="Previous" type="text/html" />
<link rel="Next" href="adlob_api_overview.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e18294.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">22/37</span> <!-- End Header -->
<div id="ADLOB45318" class="chapter"><a id="g1027057"></a><a id="i1012133"></a>
<h1 class="chapter"><span class="secnum">12</span> Advanced Design Considerations</h1>
<p>This chapter describes design considerations for more advanced application development issues.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1006095">LOB Buffering Subsystem</a></p>
</li>
<li>
<p><a href="#i1006373">Opening Persistent LOBs with the OPEN and CLOSE Interfaces</a></p>
</li>
<li>
<p><a href="#CJHJBBIF">Read-Consistent Locators</a></p>
</li>
<li>
<p><a href="#i1006915">LOB Locators and Transaction Boundaries</a></p>
</li>
<li>
<p><a href="#i1006997">LOBs in the Object Cache</a></p>
</li>
<li>
<p><a href="#i1012747">Terabyte-Size LOB Support</a></p>
</li>
<li>
<p><a href="#i1012602">Guidelines for Creating Gigabyte LOBs</a></p>
</li>
</ul>
<a id="i1006095"></a>
<div id="ADLOB45319" class="sect1">
<h2 class="sect1"><a id="sthref346"></a>LOB Buffering Subsystem</h2>
<p>The database provides a <a id="sthref347"></a>LOB buffering subsystem (LBS) for advanced OCI-based applications such as Data Cartridges, Web servers, and other client-based applications that must buffer the contents of one or more LOBs in the client address space. The client-side memory requirement for the buffering subsystem during its maximum usage is <code>512</code> KBytes. It is also the maximum amount that you can specify for a single read or write operation on a LOB that has been enabled for buffered access.</p>
<a id="i1006099"></a>
<div id="ADLOB45320" class="sect2">
<h3 class="sect2">Advantages of LOB Buffering</h3>
<p>The advantages of <a id="sthref348"></a>buffering, especially for client applications that perform a series of small reads and writes (often repeatedly) to specific regions of the LOB, are:</p>
<ul>
<li>
<p>Buffering enables deferred writes to the server. You can buffer up several writes in the LOB buffer in the client address space and eventually<a id="sthref349"></a><a id="sthref350"></a><a id="sthref351"></a> <span class="italic">flush</span> the buffer to the server. This reduces the number of network <a id="sthref352"></a>round-trips from your client application to the server, and hence, makes for better overall performance for LOB updates.</p>
</li>
<li>
<p>Buffering reduces the overall number of LOB updates on the server, thereby reducing the number of LOB versions and amount of logging. This results in better overall LOB performance and disk space usage.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006108"></a>
<div id="ADLOB45321" class="sect2">
<h3 class="sect2">Guidelines for <a id="sthref353"></a>Using LOB Buffering</h3>
<p>The following caveats apply to buffered LOB operations:</p>
<ul>
<li>
<p><span class="bolditalic">Explicitly flush LOB buffer contents.</span> The LOB buffering subsystem is not a cache. The contents of a LOB buffer are not always the same as the LOB value in the server. Unless you explicitly flush the contents of a LOB buffer, you do not see the results of your buffered writes reflected in the actual LOB on the server.</p>
</li>
<li>
<p><span class="bolditalic">Error recovery for buffered</span> <span class="bolditalic">LOB</span> <span class="bolditalic">operations is your responsibility.</span> Owing to the deferred nature of the actual LOB update, error reporting for a particular buffered read or write operation is deferred until the next access to the server based LOB.</p>
</li>
<li>
<p><span class="bolditalic">LOB Buffering is Single User, Single Threaded.</span> Transactions involving buffered LOB operations cannot migrate across user sessions &mdash; the LBS is a single user, single threaded system.</p>
</li>
<li>
<p><span class="bolditalic">Maintain logical savepoints to rollback to.</span> Oracle does not guarantee transactional support for buffered LOB operations. To ensure transactional <span class="italic">semantics</span> for buffered LOB updates, you must maintain logical savepoints in your application to rollback all the changes made to the buffered LOB in the event of an error. You should always wrap your buffered LOB updates within a logical savepoint (see <a href="#i1006238">"OCI Example of LOB Buffering"</a>).</p>
</li>
<li>
<p><span class="bolditalic">Ensure LOB is not updated by another bypassing transaction.</span> In any given transaction, once you have begun updating a LOB using buffered writes, it is your responsibility to ensure that the same LOB is not updated through any other operation within the scope of the same transaction <span class="italic">that bypasses the buffering subsystem</span>.</p>
<p>You could potentially do this by using an SQL statement to update the server-based LOB. Oracle cannot distinguish, and hence prevent, such an operation. This seriously affects the correctness and integrity of your application.</p>
</li>
<li>
<p><span class="bolditalic">Updating buffer-enabled LOB locators.</span> Buffered operations on a LOB are done through its locator, just as in the conventional case. A locator that is enabled for buffering provides a consistent read version of the LOB, until you perform a write operation on the LOB through that locator. See also, <a href="#CJHJBBIF">"Read-Consistent Locators"</a>.</p>
<p>Once the locator becomes an updated locator by virtue of its being used for a buffered write, it always provides access to the most up-to-date version of the LOB <span class="italic">as seen through the buffering subsystem.</span> Buffering also imposes an additional significance to this updated locator; all further buffered writes to the LOB can be done <span class="italic">only through this updated locator</span>. Oracle returns an error if you attempt to write to the LOB through other locators enabled for buffering. See also, <a href="#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
</li>
<li>
<p><span class="bolditalic">Passing a buffer-enabled LOB locator an IN OUT or OUT parameter.</span> You can pass an updated locator that was enabled for buffering as an <code>IN</code> parameter to a PL/SQL procedure. However, passing an <code>IN</code> <code>OUT</code> or an <code>OUT</code> parameter, or an attempt to return an updated locator, produces an error.</p>
</li>
<li>
<p><span class="bolditalic">You cannot assign an updated locator that was enabled for buffering to another locator.</span> There are different ways that assignment of locators may occur: through <code><a id="sthref354"></a>OCILobAssign()</code>, through assignment of PL/SQL variables, through <code>OCIObjectCopy()</code> where the object contains the LOB attribute, and so on. Assigning a consistent read locator that was enabled for buffering to a locator that did not have buffering enabled, turns buffering on for the target locator. By the same token, assigning a locator that was not enabled for buffering to a locator that did have buffering enabled, turns buffering off for the target locator.</p>
<p>Similarly, if you <code>SELECT</code> into a locator for which buffering was originally enabled, then the locator becomes overwritten with the new locator value, thereby turning buffering off.</p>
</li>
<li>
<p><span class="bolditalic">When two or more locators point to the same LOB do not enable both for buffering.</span> If two or more different locators point to the same LOB, then it is your responsibility to make sure that you do not enable both the locators for buffering. Otherwise Oracle does not guarantee the contents of the LOB.</p>
</li>
<li>
<p><span class="bolditalic">Buffer-enable LOBs do not support appends that create zero-byte fillers or spaces.</span> Appending to the LOB value using buffered write(s) is allowed, but only if the starting offset of these write(s) is exactly one byte (or character) past the end of the <code>BLOB</code> (or <code>CLOB</code>/<code>NCLOB</code>). In other words, the buffering subsystem does not support appends that involve creation of zero-byte fillers or spaces in the server based LOB.</p>
</li>
<li>
<p><span class="bolditalic">For</span> <span class="bolditalic">CLOB</span><span class="bolditalic">s, Oracle requires the client side character set form for the locator bind variable be the same as that of the</span> <span class="bolditalic">LOB</span> <span class="bolditalic">in the server.</span> This is usually the case in most OCI LOB programs. The exception is when the locator is selected from a <span class="italic">remote</span> database, which may have a different character set form from the database which is currently being accessed by the <code>OCI</code> program. In such a case, an error is returned. If there is no character set form input by the user, then Oracle assumes it is <code>SQLCS_IMPLICIT</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006147"></a>
<div id="ADLOB45322" class="sect2">
<h3 class="sect2"><a id="sthref355"></a><a id="sthref356"></a>LOB Buffering Subsystem <a id="sthref357"></a>Usage</h3>
<p>Here are some details of the LOB buffering subsystem:</p>
<div id="ADLOB45323" class="sect3"><a id="sthref358"></a>
<h4 class="sect3">LOB Buffer <a id="sthref359"></a>Physical Structure</h4>
<p>Each user <span class="italic">session</span> has the following structure:</p>
<ul>
<li>
<p>Fixed page pool of 16 pages, shared by all LOBs accessed in buffering mode from that session.</p>
</li>
<li>
<p>Each <span class="italic">page</span> has a fixed size of up to 32K bytes (not characters) where page size = n x <code>CHUNK</code> ~= 32K.</p>
</li>
</ul>
<p>A LOB buffer consists of one or more of these pages, up to a maximum of 16 in each session. The maximum amount that you ought to specify for any given buffered read or write operation is 512K bytes, remembering that under different circumstances the maximum amount you may read/write could be smaller.</p>
</div>
<!-- class="sect3" -->
<div id="ADLOB45324" class="sect3"><a id="sthref360"></a>
<h4 class="sect3"><a id="sthref361"></a><a id="sthref362"></a><a id="sthref363"></a>LOB Buffering Subsystem Usage Scenario</h4>
<p>Consider that a LOB is divided into fixed-size, logical regions. Each page is mapped to one of these fixed size regions, and is in essence, their in-memory copy. Depending on the input <code>offset</code> and <code>amount</code> specified for a read or write operation, the database allocates one or more of the free pages in the page pool to the LOB buffer. A <span class="italic">free page</span> is one that has not been read or written by a buffered read or write operation.</p>
<p>For example, assuming a page size of 32KBytes:</p>
<ul>
<li>
<p>For an input offset of 1000 and a specified read/write amount of 30000, Oracle reads the first 32K byte region of the LOB into a page in the LOB buffer.</p>
</li>
<li>
<p>For an input offset of 33000 and a read/write amount of 30000, the second 32K region of the LOB is read into a page.</p>
</li>
<li>
<p>For an input offset of 1000, and a read/write amount of 35000, the LOB buffer contains <span class="italic">two</span> pages &mdash; the first mapped to the region 1 &mdash; 32K, and the second to the region 32K+1 &mdash; 64K of the LOB.</p>
</li>
</ul>
<p>This mapping between a page and the LOB region is temporary until Oracle maps another region to the page. When you attempt to access a region of the LOB that is not available in full in the LOB buffer, Oracle allocates any available free page(s) from the page pool to the LOB buffer. If there are no free pages available in the page pool, then Oracle reallocates the pages as follows. It ages out the <span class="italic">least recently used</span> page among the <span class="italic">unmodified</span> pages in the LOB buffer and reallocates it for the current operation.</p>
<p>If no such page is available in the LOB buffer, then it ages out the least recently used page among the <span class="italic">unmodified</span> pages of <span class="italic">other</span> buffered LOBs in the same session. Again, if no such page is available, then it implies that all the pages in the page pool are <span class="italic">modified</span>, and either the currently accessed LOB, or one of the other LOBs, must be flushed. Oracle notifies this condition to the user as an error. Oracle <span class="italic">never</span> flushes and reallocates a modified page implicitly. You can either flush them explicitly, or discard them by disabling buffering on the LOB.</p>
<p>To illustrate the preceding discussion, consider two LOBs being accessed in buffered mode &mdash; L1 and L2, each with buffers of size 8 pages. Assume that 6 of the 8 pages in the L1 buffer are dirty, with the remaining 2 containing unmodified data read in from the server. Assume similar conditions in the L2 buffer. Now, for the next buffered operation on L1, Oracle reallocates the least recently used page from the two unmodified pages in the <span class="italic">L1 buffer</span>. Once all the 8 pages in the L1 buffer are used up for LOB writes, Oracle can service two more operations on L1 by allocating the two unmodified pages from the <span class="italic">L2 buffer</span> using the least recently used policy. But for any further buffered operations on L1 or L2, Oracle returns an error.</p>
<p>If all the buffers are dirty and you attempt another read from or write to a buffered LOB, then you receive the following error:</p>
<pre>
Error 22280: no more buffers available for operation
</pre>
<p>There are two possible causes:</p>
<ol>
<li>
<p>All buffers in the buffer pool have been used up by previous operations.</p>
<p>In this case, flush the LOBs through the locator that is being used to update the LOB.</p>
</li>
<li>
<p>You are trying to flush a LOB without any previous buffered update operations.</p>
<p>In this case, write to the LOB through a locator enabled for buffering before attempting to flush buffers.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADLOB45325" class="sect2"><a id="sthref364"></a>
<h3 class="sect2"><a id="sthref365"></a>Flushing the LOB <a id="sthref366"></a><a id="sthref367"></a>Buffer <a id="sthref368"></a><a id="sthref369"></a></h3>
<p>The term <span class="italic">flush</span> refers to a set of processes. Writing data to the LOB in the buffer through the locator transforms the locator into an <span class="italic">updated locator</span>. After you have updated the LOB data in the buffer through the updated locator, a flush call performs the following actions:</p>
<ul>
<li>
<p>Writes the dirty pages in the LOB buffer to the server-based LOB, thereby updating the LOB value.</p>
</li>
<li>
<p>Resets the updated locator to be a read-consistent locator.</p>
</li>
<li>
<p>Frees the flushed buffers or turns the status of the buffer pages back from dirty to unmodified.</p>
</li>
</ul>
<p>After the flush, the locator becomes a read-consistent locator and can be assigned to another locator (<code>L2 := L1</code>).</p>
<p>For instance, suppose you have two locators, <code>L1</code> and <code>L2</code>. Let us say that they are both <span class="italic">read-consistent</span> <span class="italic">locators</span> and consistent with the state of the LOB data in the server. If you then update the LOB by writing to the buffer, <code>L1</code> becomes an updated locator. <code>L1</code> and <code>L2</code> now refer to different versions of the LOB value. If you want to update the LOB in the server, then you must use <code>L1</code> to retain the read-consistent state captured in <code>L2</code>. The flush operation writes a new snapshot environment into the locator used for the flush. The important point to remember is that you must use the updated locator (<code>L1</code>), when you flush the LOB buffer. Trying to flush a <a id="sthref370"></a><a id="sthref371"></a>read-consistent locator generates an error.</p>
<p>The technique you use to flush the LOB buffer determines whether data in the buffer is cleared and has performance implications as follows:</p>
<ul>
<li>
<p>In the default mode, data is retained in the pages that were modified when the flush operation occurs. In this case, when you read or write to the same range of bytes, <a id="sthref372"></a>no round-trip to the server is necessary. Note that flushing the buffer, in this context, does not clear the data in the buffer. It also does not return the memory occupied by the flushed buffer to the client address space.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Unmodified pages may now be aged out if necessary.</div>
</li>
<li>
<p>In the second case, you set the flag parameter in <code><a id="sthref373"></a><a id="sthref374"></a>OCILobFlushBuffer()</code> to <code>OCI_LOB_BUFFER_FREE</code> to free the buffer pages, and so return the memory to the client address space. Flushing the buffer using this technique updates the LOB value on the server, returns a read-consistent locator, and frees the buffer pages.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADLOB45326" class="sect2"><a id="sthref375"></a>
<h3 class="sect2"><a id="sthref376"></a>Flushing the <a id="sthref377"></a><a id="sthref378"></a>Updated LOB</h3>
<p>It is very important to note that you must flush a LOB that has been updated through the LOB buffering subsystem in the following situations:</p>
<ul>
<li>
<p>Before committing the transaction</p>
</li>
<li>
<p>Before migrating from the current <a id="sthref379"></a>transaction to another</p>
</li>
<li>
<p>Before disabling buffering operations on a LOB</p>
</li>
<li>
<p><a id="sthref380"></a>Before returning from an external callout execution into the calling function, procedure, or method in PL/SQL</p>
<p>Note that when the external callout is called from a PL/SQL block and the locator is passed as a parameter, all buffering operations, including the enable call, should be made within the callout itself. In other words, adhere to the following sequence:</p>
<ul>
<li>
<p>Call the external callout</p>
</li>
<li>
<p>Enable the locator for buffering</p>
</li>
<li>
<p>Read or write using the locator</p>
</li>
<li>
<p>Flush the LOB</p>
</li>
<li>
<p>Disable the locator for buffering</p>
</li>
<li>
<p>Return to the calling function, procedure, or method in PL/SQL</p>
</li>
</ul>
<p>Remember that the database never implicitly flushes the LOB buffer.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADLOB45327" class="sect2"><a id="sthref381"></a>
<h3 class="sect2"><a id="sthref382"></a><a id="sthref383"></a>Using Buffer-Enabled Locators</h3>
<p>Note that there are several cases in which you can use buffer-enabled locators and others in which you cannot.</p>
<ul>
<li>
<p><span class="bolditalic">When it is OK to Use Buffer-Enabled Locators:</span></p>
<ul>
<li>
<p><span class="bolditalic">OCI &mdash;</span> A locator that is enabled for buffering can only be used with the following OCI APIs:</p>
<p><code>OCILobRead2(), OCILobWrite2(), OCILobAssign(), OCILobIsEqual(), OCILobLocatorIsInit(), OCILobCharSetId(), OCILobCharSetForm()</code></p>
<pre>
</pre></li>
</ul>
</li>
<li>
<p><span class="bolditalic">When it is Not OK to Use Buffer-Enabled Locators:</span> The following OCI APIs return errors if used with a locator enabled for buffering:</p>
<ul>
<li>
<p><span class="bolditalic">OCI &mdash;</span> <code>OCILobCopy2(), OCILobAppend(), OCILobErase2(), OCILobGetLength2(), OCILobTrim2(), OCILobWriteAppend2()</code></p>
<p>These APIs also return errors when used with a locator which has not been enabled for buffering, but the LOB that the locator represents is being accessed in buffered mode through some other locator.</p>
</li>
<li>
<p><span class="bolditalic">PL/SQL (DBMS_LOB)</span> &mdash; An error is returned from <code>DBMS_LOB</code> APIs if the input lob locator has buffering enabled.</p>
</li>
<li>
<p>As in the case of all other locators, buffer-enabled locators cannot span transactions.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADLOB45328" class="sect2"><a id="sthref384"></a>
<h3 class="sect2">Saving <a id="sthref385"></a><a id="sthref386"></a>Locator State to Avoid a Reselect</h3>
<p>Suppose you want to save the current state of the LOB before further writing to the LOB buffer. In performing updates while using LOB buffering, writing to an existing buffer does not make a round-trip to the server, and so does not refresh the snapshot environment in the locator. This would not be the case if you were updating the LOB directly without using LOB buffering. In that case, every update would involve a round-trip to the server, and so would refresh the snapshot in the locator.</p>
<p>Therefore to save the state of a LOB that has been written through the LOB buffer, follow these steps:</p>
<ol>
<li>
<p>Flush the LOB, thereby updating the LOB and the snapshot environment in the locator (L1). At this point, the state of the locator (L1) and the LOB are the same.</p>
</li>
<li>
<p>Assign the locator (L1) used for flushing and updating to another locator (L2). At this point, the states of the two locators (L1 and L2), and the LOB are all identical.</p>
</li>
</ol>
<p>L2 now becomes a <a id="sthref387"></a><a id="sthref388"></a>read-consistent locator with which you are able to access the changes made through L1 up until the time of the flush, but not after. This assignment <a id="sthref389"></a>avoids incurring a round-trip to the server to reselect the locator into L2.</p>
</div>
<!-- class="sect2" -->
<a id="i1006238"></a>
<div id="ADLOB45329" class="sect2">
<h3 class="sect2"><a id="sthref390"></a>OCI Example of LOB <a id="sthref391"></a><a id="sthref392"></a>Buffering</h3>
<p>The following OCI pseudocode example is based on the PM schema included with the Oracle Database Sample Schemas.</p>
<pre>
OCI_BLOB_buffering_program()
{
   int            amount;
   int            offset;
   OCILobLocator  lbs_loc1, lbs_loc2, lbs_loc3;
   void          *buffer;
   int            bufl;

   -- Standard OCI initialization operations - logging on to
   -- server, creating and initializing bind variables...

   init_OCI();

   -- Establish a savepoint before start of LOB buffering subsystem
   -- operations
   exec_statement("savepoint lbs_savepoint");

   -- Initialize bind variable to BLOB columns from buffered
   -- access:
   exec_statement("select ad_composite into lbs_loc1 from Print_media
       where ad_id = 12001");
   exec_statement("select ad_composite into lbs_loc2 from Print_media
       where ad_id = 12001 for update");
   exec_statement("select ad_composite into lbs_loc2 from Print_media
       where ad_id = 12001 for update");

   -- Enable locators for buffered mode access to LOB:
   OCILobEnableBuffering(..., lbs_loc1);
   OCILobEnableBuffering(..., lbs_loc2);
   OCILobEnableBuffering(..., lbs_loc3);

   -- Read 4K bytes through lbs_loc1 starting from offset 1:
   amount = 4096; offset = 1; bufl = 4096;
   OCILobRead2(.., lbs_loc1, &amp;amount, 0, offset, buffer, bufl, ...);
      if (exception)
          goto exception_handler;
          -- This reads the first 32K bytes of the LOB from
          -- the server into a page (call it page_A) in the LOB
          -- client-side buffer.
          -- lbs_loc1 is a read-consistent locator.

          -- Write 4K of the LOB throgh lbs_loc2 starting from
          -- offset 1:
          amount = 4096; offset = 1; bufl = 4096;
          buffer = populate_buffer(4096);
          OCILobWrite2(.., lbs_loc2, &amp;amount, 0, offset, buffer, bufl, ..);

      if (exception)
          goto exception_handler;
          -- This reads the first 32K bytes of the LOB from
          -- the server into a new page (call it page_B) in the
          -- LOB buffer, and modify the contents of this page
          -- with input buffer contents.
          -- lbs_loc2 is an updated locator.

          -- Read 20K bytes through lbs_loc1 starting from
          -- offset 10K
          amount = 20480; offset = 10240;
          OCILobRead2(.., lbs_loc1, &amp;amount, 0, offset, buffer, bufl, ..);

      if (exception)
        goto exception_handler;
          -- Read directly from page_A into the user buffer.
          -- There is no round-trip to the server because the
          -- data is in the client-side buffer.

          -- Write 20K bytes through lbs_loc2 starting from offset
          -- 10K
          amount = 20480; offset = 10240; bufl = 20480;
          buffer = populate_buffer(20480);
          OCILobWrite2(.., lbs_loc2, &amp;amount, 0, offset, buffer, bufl, ..);

      if (exception)
          goto exception_handler;
          -- The contents of the user buffer are now written
          -- into page_B without involving a round-trip to the
          -- server.  This avoids making a new LOB version on the
          -- server and writing redo to the log.

          -- The following write through lbs_loc3 also
          -- results in an error:
          amount = 20000; offset = 1000; bufl = 20000;
          buffer = populate_buffer(20000);
          OCILobWrite2(.., lbs_loc3, amount, 0, offset,buffer, bufl, ..);

      if (exception)
          goto exception_handler;
          -- No two locators can be used to update a buffered LOB
          -- through the buffering subsystem

      -- The following update through lbs_loc3 also
      -- results in an error
      OCILobFileCopy(.., lbs_loc3, lbs_loc2, ..);

      if (exception)
          goto exception_handler;
          -- Locators enabled for buffering cannot be used with
          -- operations like Append, Copy, Trim and so on
          -- When done, flush the LOB buffer to the server:
      OCILobFlushBuffer(.., lbs_loc2, OCI_LOB_BUFFER_NOFREE);

      if (exception)
         goto exception_handler;
         -- This flushes all the modified pages in the LOB buffer,
         -- and resets lbs_loc2 from updated to read-consistent
         -- locator. The modified pages remain in the buffer
         -- without freeing memory.  These pages can be aged
         -- out if necessary.

      -- Disable locators for buffered mode access to LOB */
      OCILobDisableBuffering(..., lbs_loc1);
      OCILobDisableBuffering(..., lbs_loc2);
      OCILobDisableBuffering(..., lbs_loc3);

      if (exception)
         goto exception_handler;
         -- This disables the three locators for buffered access,
         -- and frees up the LOB buffer resources.
        exception_handler:
      handle_exception_reporting();
      exec_statement("rollback to savepoint lbs_savepoint");
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006373"></a>
<div id="ADLOB1002" class="sect1">
<h2 class="sect1">Opening Persistent LOBs with the OPEN and CLOSE Interfaces</h2>
<p>The OPEN and CLOSE interfaces enable you to explicitly open a persistent LOB instance. When you open a LOB instance with the OPEN interface, the instance remains open until you explicitly close the LOB using the CLOSE interface. The ISOPEN interface enables you to determine whether a persistent LOB is open.</p>
<p>Note that the open state of a LOB is associated with the LOB instance, not the LOB locator. The locator does not save any information indicating whether the LOB instance that it points to is open.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adlob_working.htm#i1010200">"Opening and Closing LOBs"</a>.</div>
<div id="ADLOB45330" class="sect2"><a id="sthref393"></a>
<h3 class="sect2">Index Performance Benefits of Explicitly Opening a LOB</h3>
<p>Explicitly opening a LOB instance can benefit performance of a persistent LOB in an indexed column.</p>
<p>If you do not explicitly open the LOB instance, then every modification to the LOB implicitly opens and closes the LOB instance. Any triggers on a domain index are fired each time the LOB is closed. Note that in this case, any domain indexes on the LOB are updated as soon as any modification to the LOB instance is made; the domain index is always valid and can be used at any time.</p>
<p>When you explicitly open a LOB instance, index triggers do not fire until you explicitly close the LOB. Using this technique can increase performance on index columns by eliminating unneeded indexing events until you explicitly close the LOB. Note that any index on the LOB column is not valid until you explicitly close the LOB.</p>
</div>
<!-- class="sect2" -->
<a id="i1006386"></a>
<div id="ADLOB45331" class="sect2">
<h3 class="sect2">Working with Explicitly Open LOB Instances</h3>
<p>If you explicitly open a LOB instance, then you must close the LOB before you commit the transaction.</p>
<p>Committing a transaction on the open LOB instance causes an error. When this error occurs, the LOB instance is closed implicitly, any modifications to the LOB instance are saved, and the transaction is committed, but any indexes on the LOB column are not updated. In this situation, you must rebuild your indexes on the LOB column.</p>
<p>If you subsequently rollback the transaction, then the LOB instance is rolled back to its previous state, but the LOB instance is no longer explicitly open.</p>
<p>You must close any LOB instance that you explicitly open:</p>
<ul>
<li>
<p>Between DML statements that start a transaction, including <code>SELECT</code> ... <code>FOR</code> <code>UPDATE</code> and <code>COMMIT</code></p>
</li>
<li>
<p>Within an autonomous transaction block</p>
</li>
<li>
<p>Before the end of a session (when there is no transaction involved)</p>
<p>If you do not explicitly close the LOB instance, then it is implicitly closed at the end of the session and no index triggers are fired.</p>
</li>
</ul>
<p>Keep track of the open or closed state of LOBs that you explicitly open. The following actions cause an error:</p>
<ul>
<li>
<p>Explicitly opening a LOB instance that has been explicitly open earlier.</p>
</li>
<li>
<p>Explicitly closing a LOB instance that is has been explicitly closed earlier.</p>
</li>
</ul>
<p>This occurs whether you access the LOB instance using the same locator or different locators.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJHJBBIF"></a>
<div id="ADLOB45332" class="sect1">
<h2 class="sect1">Read-Consistent Locators<a id="sthref394"></a></h2>
<p>Oracle Database provides the same read consistency mechanisms for LOBs as for all other database reads and updates of scalar quantities. Refer to <a class="olink CNCPT" href="../../server.112/e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> for general information about read consistency. Read consistency has some special applications to LOB locators that you must understand. These applications are described in the following sections.</p>
<a id="i1006462"></a>
<div id="ADLOB45333" class="sect2">
<h3 class="sect2">A Selected Locator Becomes a Read-Consistent Locator</h3>
<p><a id="sthref395"></a><a id="sthref396"></a><a id="sthref397"></a><a id="sthref398"></a><a id="sthref399"></a><a id="sthref400"></a>A selected locator, regardless of the existence of the <code>FOR</code> <code>UPDATE</code> clause, becomes a <span class="italic">read-consistent locator,</span> and remains a read-consistent locator until the LOB value is <a id="sthref401"></a><a id="sthref402"></a>updated through that locator. A read-consistent locator contains the snapshot environment as of the point in time of the <code>SELECT</code> operation.</p>
<p>This has some complex implications. Suppose you have created a read-consistent locator (<code>L1</code>) by way of a <code>SELECT</code> operation. In reading the value of the persistent LOB through <code>L1</code>, note the following:</p>
<ul>
<li>
<p>The LOB is read as of the point in time of the <code>SELECT</code> statement even if the <code>SELECT</code> statement includes a <code>FOR</code> <code>UPDATE</code>.</p>
</li>
<li>
<p>If the LOB value is updated through a different locator (<code>L2</code>) in the same transaction, then <code>L1</code> does not see the <code>L2</code> updates.</p>
</li>
<li>
<p>L1 does not see committed updates made to the LOB through <span class="italic">another</span> transaction.</p>
</li>
<li>
<p>If the <a id="sthref403"></a><a id="sthref404"></a>read-consistent locator <code>L1</code> is copied to another locator <code>L2</code> (for example, by a PL/SQL assignment of two locator variables &mdash; <code>L2:= L1</code>), then <code>L2</code> becomes a read-consistent locator along with L1 and any data read is read <span class="italic">as of the point in&nbsp;time of the</span> <code><span class="codeinlineitalic">SELECT</span></code> <span class="italic">for L1</span>.</p>
</li>
</ul>
<p>You can use the existence of <a id="sthref405"></a>multiple locators to access different transformations of the LOB value. However, in doing so, you must keep track of the different values accessed by different locators.</p>
</div>
<!-- class="sect2" -->
<a id="i1006480"></a>
<div id="ADLOB45334" class="sect2">
<h3 class="sect2">Example of Updating LOBs and Read-Consistency</h3>
<p>Read-consistent locators provide the same LOB value regardless of when the <code>SELECT</code> occurs.</p>
<p>The following example demonstrates the relationship between read-consistency and updating in a simple example. Using the <code>Print_media</code> table and PL/SQL, three <code>CLOB</code> instances are created as potential locators: <code>clob_selected</code>, <code>clob_update</code>, and <code>clob_copied</code>.</p>
<p>Observe these progressions in the code, from times t1 through t6:</p>
<ul>
<li>
<p>At the time of the first <code>SELECT</code> <code>INTO</code> (at <code>t1</code>), the value in <code>ad_sourcetext</code> is associated with the locator <code>clob_selected</code><span class="italic">.</span></p>
</li>
<li>
<p>In the second operation (at <code>t2</code>), the value in <code>ad_sourcetext</code> is associated with the locator <code>clob_updated</code><span class="italic">.</span> Because there has been no change in the value of <code>ad_sourcetext</code> between <code>t1</code> and <code>t2</code>, both <code>clob_selected</code> and <code>clob_updated</code> are read-consistent locators that effectively have the same value even though they reflect snapshots taken at different moments in time.</p>
</li>
<li>
<p>The third operation (at <code>t3</code>) copies the value in <code>clob_selected</code> to <code>clob_copied</code>. At this juncture, all three locators see the same value. The example demonstrates this with a series of <code>DBMS_LOB</code>.<code>READ()</code> calls.</p>
</li>
<li>
<p>At time t4, the program uses <code>DBMS_LOB</code>.<code>WRITE()</code> to alter the value in <code>clob_updated</code>, and a <code>DBMS_LOB</code>.<code>READ()</code> reveals a new value.</p>
</li>
<li>
<p>However, a <code>DBMS_LOB</code>.<code>READ()</code> of the value through <code>clob_selected</code> (at <code>t5</code>) reveals that it is a read-consistent locator, continuing to refer to the same value as of the time of its <code>SELECT</code>.</p>
</li>
<li>
<p>Likewise, a <code>DBMS_LOB</code>.<code>READ()</code> of the value through <code>clob_copied</code> (at <code>t6</code>) reveals that it is a read-consistent locator, continuing to refer to the same value as <code>clob_selected</code>.</p>
</li>
</ul>
<pre>
INSERT INTO PRINT_MEDIA VALUES (2056, 20020, EMPTY_BLOB(), 
    'abcd', EMPTY_CLOB(), EMPTY_CLOB(), NULL, NULL, NULL, NULL);

COMMIT;

DECLARE
  num_var           INTEGER;
  clob_selected     CLOB;
  clob_updated      CLOB;
  clob_copied       CLOB;
  read_amount       INTEGER;
  read_offset       INTEGER;
  write_amount      INTEGER;
  write_offset      INTEGER;
  buffer            VARCHAR2(20);

BEGIN
  -- At time t1:
  SELECT ad_sourcetext INTO clob_selected
     FROM Print_media
     WHERE ad_id = 20020;

  -- At time t2:
  SELECT ad_sourcetext INTO clob_updated
     FROM Print_media
     WHERE ad_id = 20020
     FOR UPDATE;

  -- At time t3:
  clob_copied := clob_selected;
  -- After the assignment, both the clob_copied and the
  -- clob_selected have the same snapshot as of the point in time
  -- of the SELECT into clob_selected

  -- Reading from the clob_selected and the clob_copied does
  -- return the same LOB value. clob_updated also sees the same
  -- LOB value as of its select:
  read_amount := 10;
  read_offset := 1;
  dbms_lob.read(clob_selected, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_selected value: ' || buffer);
  -- Produces the output 'abcd'

  read_amount := 10;
  dbms_lob.read(clob_copied, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_copied value: ' || buffer);
  -- Produces the output 'abcd'

  read_amount := 10;
  dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_updated value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t4:
  write_amount := 3;
  write_offset := 5;
  buffer := 'efg';
  dbms_lob.write(clob_updated, write_amount, write_offset, buffer);

  read_amount := 10;
  dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_updated value: ' || buffer);
  -- Produces the output 'abcdefg'

  -- At time t5:
  read_amount := 10;
  dbms_lob.read(clob_selected, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_selected value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t6:
  read_amount := 10;
  dbms_lob.read(clob_copied, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_copied value: ' || buffer);
  -- Produces the output 'abcd'
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="i1006580"></a>
<div id="ADLOB45335" class="sect2">
<h3 class="sect2"><a id="sthref406"></a><a id="sthref407"></a>Example of Updating LOBs Through Updated Locators</h3>
<p><a id="sthref408"></a>When you update the value of the persistent LOB through the LOB locator (<code>L1</code>), <code>L1</code> (that is, the locator itself) is updated to contain the current snapshot environment <span class="italic">as of the ime after the operation was completed</span> on the LOB value through locator <code>L1</code>. <code>L1</code> is then termed an <span class="italic">updated locator</span>. This operation enables you to see your own changes to the LOB value on the next read through the same locator, <code>L1</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The snapshot environment in the locator is <span class="italic">not</span> updated if the locator is used to merely read the LOB value. It is only updated <span class="italic">when you</span> <span class="italic">modify</span> the LOB value through the locator using the PL/SQL <code>DBMS_LOB</code> package or the OCI LOB APIs.</div>
<p>Any committed updates made by a different transaction are seen by L1 only if your transaction is a read-committed transaction and if you use L1 to update the LOB value after the other transaction committed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you update a persistent LOB value, the modification is always made to the most current LOB value.</div>
<p>Updating the value of the persistent LOB through any of the available methods, such as OCI LOB APIs or PL/SQL <code>DBMS_LOB</code> package, updates the LOB value <span class="italic">and then reselects</span> the locator that refers to the new LOB value.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Once you have selected out a LOB locator by whatever means, you can read from the locator but not write into it.
<p>Note that updating the LOB value through SQL is merely an <code>UPDATE</code> statement. It is up to you to do the reselect of the LOB locator or use the <code>RETURNING</code> clause in the <code>UPDATE</code> statement so that the locator can see the changes made by the <code>UPDATE</code> statement. Unless you reselect the LOB locator or use the <code>RETURNING</code> clause, you may think you are reading the latest value when this is not the case. For this reason you should <span class="bolditalic">avoid mixing SQL DML with OCI and</span> <span class="bolditalic">DBMS_LOB</span> <span class="bolditalic"><a id="sthref409"></a> piecewise operations</span>.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS" href="../e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1006609"></a>
<div id="ADLOB45336" class="sect2">
<h3 class="sect2"><a id="sthref410"></a><a id="sthref411"></a>Example of Updating a LOB Using SQL DML and DBMS_LOB</h3>
<p>Using table <code>Print_media</code> in the following example, a <code>CLOB</code> locator is created as <code>clob_selected</code>. Note the following progressions in the example, from times t1 through t3:</p>
<ul>
<li>
<p>At the time of the first <code>SELECT</code> <code>INTO</code> (at <code>t1</code>), the value in <code>ad_sourcetext</code> is associated with the locator <code>clob_selected</code>.</p>
</li>
<li>
<p>In the second operation (at <code>t2</code>), the value in <code>ad_sourcetext</code> is modified through the <code>SQL</code> <code>UPDATE</code> statement, without affecting the <code>clob_selected</code> locator. The locator still sees the value of the LOB as of the point in time of the original <code>SELECT</code>. In other words, the locator does not see the update made using the SQL <code>UPDATE</code> statement. This is illustrated by the subsequent <code>DBMS_LOB</code>.<code>READ()</code> call.</p>
</li>
<li>
<p>The third operation (at <code>t3</code>) re-selects the LOB value into the locator <code>clob_selected</code>. The locator is thus updated with the latest snapshot environment which allows the locator to see the change made by the previous SQL <code>UPDATE</code> statement. Therefore, in the next <code>DBMS_LOB</code>.<code>READ()</code>, an error is returned because the LOB value is empty, that is, it does not contain any data.</p>
</li>
</ul>
<pre>
INSERT INTO Print_media VALUES (3247, 20010, EMPTY_BLOB(), 
    'abcd', EMPTY_CLOB(), EMPTY_CLOB(), NULL, NULL, NULL, NULL);

COMMIT;

DECLARE
  num_var           INTEGER;
  clob_selected     CLOB;
  read_amount       INTEGER;
  read_offset       INTEGER;
  buffer            VARCHAR2(20);

BEGIN

  -- At time t1:
  SELECT ad_sourcetext INTO clob_selected
  FROM Print_media
  WHERE ad_id = 20010;

  read_amount := 10;
  read_offset := 1;
  dbms_lob.read(clob_selected, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_selected value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t2:
  UPDATE Print_media SET ad_sourcetext = empty_clob()
      WHERE ad_id = 20010;
  -- although the most current LOB value is now empty,
  -- clob_selected still sees the LOB value as of the point
  -- in time of the SELECT

  read_amount := 10;
  dbms_lob.read(clob_selected, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_selected value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t3:
  SELECT ad_sourcetext INTO clob_selected FROM Print_media WHERE
       ad_id = 20010;
  -- the SELECT allows clob_selected to see the most current
  -- LOB value

  read_amount := 10;
  dbms_lob.read(clob_selected, read_amount, read_offset, buffer);
  -- ERROR: ORA-01403: no data found
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="i1006671"></a>
<div id="ADLOB45337" class="sect2">
<h3 class="sect2"><a id="sthref412"></a><a id="sthref413"></a>Example of Using One Locator to Update the Same LOB Value</h3>
<div class="infoboxnotewarn">
<p class="notep1">Note:</p>
<span class="bolditalic">Avoid <a id="sthref414"></a>updating the same</span> <span class="bolditalic">LOB</span> <span class="bolditalic">with different locators.</span> You may avoid many pitfalls if you use only one locator to update a given LOB value.</div>
<p>In the following example, using table <code>Print_media</code>, two <code>CLOB</code>s are created as potential locators: clob_updated and clob_copied.</p>
<p>Note these progressions in the example at times t1 through t5:</p>
<ul>
<li>
<p>At the time of the first <code>SELECT</code> <code>INTO</code> (at <code>t1</code>), the value in <code>ad_sourcetext</code> is associated with the locator <code>clob_updated</code>.</p>
</li>
<li>
<p>The second operation (at time <code>t2</code>) copies the value in <code>clob_updated</code> to <code>clob_copied</code>. At this time, both locators see the same value. The example demonstrates this with a series of <code>DBMS_LOB</code>.<code>READ()</code> calls.</p>
</li>
<li>
<p>At time <code>t3</code>, the program uses <code>DBMS_LOB</code>.<code>WRITE()</code> to alter the value in <code>clob_updated</code>, and a <code>DBMS_LOB.READ()</code> reveals a new value.</p>
</li>
<li>
<p>However, a <code>DBMS_LOB</code>.<code>READ()</code> of the value through <code>clob_copied</code> (at time <code>t4</code>) reveals that it still sees the value of the LOB as of the point in time of the assignment from <code>clob_updated</code> (at <code>t2</code>).</p>
</li>
<li>
<p>It is not until <code>clob_updated</code> is assigned to <code>clob_copied</code> (<code>t5</code>) that <code>clob_copied</code> sees the modification made by <code>clob_updated</code>.</p>
</li>
</ul>
<pre>
INSERT INTO PRINT_MEDIA VALUES (2049, 20030, EMPTY_BLOB(), 
    'abcd', EMPTY_CLOB(), EMPTY_CLOB(), NULL, NULL, NULL, NULL);

COMMIT;

DECLARE
  num_var          INTEGER;
  clob_updated     CLOB;
  clob_copied      CLOB;
  read_amount      INTEGER;
  read_offset      INTEGER;
  write_amount     INTEGER;
  write_offset     INTEGER;
  buffer           VARCHAR2(20);
BEGIN

-- At time t1:
  SELECT ad_sourcetext INTO clob_updated FROM PRINT_MEDIA
      WHERE ad_id = 20030
      FOR UPDATE;

  -- At time t2:
  clob_copied := clob_updated;
  -- after the assign, clob_copied and clob_updated see the same
  -- LOB value

  read_amount := 10;
  read_offset := 1;
  dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_updated value: ' || buffer);
  -- Produces the output 'abcd'

  read_amount := 10;
  dbms_lob.read(clob_copied, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_copied value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t3:
  write_amount := 3;
  write_offset := 5;
  buffer := 'efg';
  dbms_lob.write(clob_updated, write_amount, write_offset,
        buffer);

  read_amount := 10;
  dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_updated value: ' || buffer);
  -- Produces the output 'abcdefg'


  -- At time t4:
  read_amount := 10;
  dbms_lob.read(clob_copied, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_copied value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t5:
  clob_copied := clob_updated;

  read_amount := 10;
  dbms_lob.read(clob_copied, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_copied value: ' || buffer);
  -- Produces the output 'abcdefg'
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="i1006757"></a>
<div id="ADLOB45338" class="sect2">
<h3 class="sect2"><a id="sthref415"></a><a id="sthref416"></a><a id="sthref417"></a>Example of <a id="sthref418"></a><a id="sthref419"></a>Updating a LOB with a PL/SQL (DBMS_LOB) Bind Variable</h3>
<p>When a LOB locator is used as the source to update another persistent LOB (as in a SQL <code>INSERT</code> or <code>UPDATE</code> statement, the <code>DBMS_LOB</code>.<code>COPY</code> routine, and so on), the snapshot environment in the source LOB locator determines the LOB value that is used as the source. If the source locator (for example <code>L1</code>) is a <a id="sthref420"></a><a id="sthref421"></a>read-consistent locator, then the LOB value as of the time of the <code>SELECT</code> of L1 is used. If the source locator (for example <code>L2</code>) is an updated locator, then the LOB value associated with the <code>L2</code> snapshot environment at the time of the operation is used.</p>
<p>In the following example, using the table <code>Print_media</code>, three <code>CLOB</code>s are created as potential locators: <code>clob_selected</code>, clob_updated, and clob_copied.</p>
<p>Note these progressions in the example at times <code>t1</code> through <code>t5</code>:</p>
<ul>
<li>
<p>At the time of the first <code>SELECT</code> <code>INTO</code> (at <code>t1</code>), the value in <code>ad_sourcetext</code> is associated with the locator <code>clob_updated</code>.</p>
</li>
<li>
<p>The second operation (at <code>t2</code>) copies the value in <code>clob_updated</code> to <code>clob_copied</code>. At this juncture, both locators see the same value.</p>
</li>
<li>
<p>Then (at <code>t3</code>), the program uses <code>DBMS_LOB</code>.<code>WRITE()</code> to alter the value in <code>clob_updated</code><span class="italic">,</span> and a <code>DBMS_LOB</code>.<code>READ()</code> reveals a new value.</p>
</li>
<li>
<p>However, a <code>DBMS_LOB</code>.<code>READ()</code> of the value through <code>clob_copied</code> (at <code>t4</code>) reveals that <code>clob_copied</code> does not see the change made by <code>clob_updated</code>.</p>
</li>
<li>
<p>Therefore (at <code>t5</code>), when <code>clob_copied</code> is used as the source for the value of the <code>INSERT</code> statement, the value associated with <code>clob_copied</code> (for example, without the new changes made by <code>clob_updated</code>) is inserted. This is demonstrated by the subsequent <code>DBMS_LOB</code>.<code>READ()</code> of the value just inserted.</p>
</li>
</ul>
<pre>
INSERT INTO PRINT_MEDIA VALUES (2056, 20020, EMPTY_BLOB(), 
    'abcd', EMPTY_CLOB(), EMPTY_CLOB(), NULL, NULL, NULL, NULL);

COMMIT;

DECLARE
  num_var           INTEGER;
  clob_selected     CLOB;
  clob_updated      CLOB;
  clob_copied       CLOB;
  read_amount       INTEGER;
  read_offset       INTEGER;
  write_amount      INTEGER;
  write_offset      INTEGER;
  buffer            VARCHAR2(20);
BEGIN

  -- At time t1:
  SELECT ad_sourcetext INTO clob_updated FROM PRINT_MEDIA
      WHERE ad_id = 20020
      FOR UPDATE;

  read_amount := 10;
  read_offset := 1;
  dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_updated value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t2:
  clob_copied := clob_updated;


  -- At time t3:
  write_amount := 3;
  write_offset := 5;
  buffer := 'efg';
  dbms_lob.write(clob_updated, write_amount, write_offset, buffer);

  read_amount := 10;
  dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_updated value: ' || buffer);
  -- Produces the output 'abcdefg'
  -- note that clob_copied does not see the write made before
  -- clob_updated


  -- At time t4:
  read_amount := 10;
  dbms_lob.read(clob_copied, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_copied value: ' || buffer);
  -- Produces the output 'abcd'

  -- At time t5:
  -- the insert uses clob_copied view of the LOB value which does
  -- not include clob_updated changes
  INSERT INTO PRINT_MEDIA VALUES (2056, 20022, EMPTY_BLOB(), 
    clob_copied, EMPTY_CLOB(), EMPTY_CLOB(), NULL, NULL, NULL, NULL)
    RETURNING ad_sourcetext INTO clob_selected;

  read_amount := 10;
  dbms_lob.read(clob_selected, read_amount, read_offset, buffer);
  dbms_output.put_line('clob_selected value: ' || buffer);
  -- Produces the output 'abcd'
END;
/
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006915"></a>
<div id="ADLOB45339" class="sect1">
<h2 class="sect1">LOB Locators and <a id="sthref422"></a><a id="sthref423"></a>Transaction Boundaries</h2>
<p>This section discusses the use of LOB locators in transactions and transaction IDs. A basic description of LOB locators and their operations is given in <a href="adlob_working.htm#i1007838">"LOB Locators and BFILE Locators"</a>.</p>
<p>Note the following regarding LOB locators and transactions:</p>
<ul>
<li>
<p>Locators contain <a id="sthref424"></a>transaction IDs when:</p>
<p><span class="italic">You Begin the Transaction, Then Select Locator.</span> If you begin a transaction and subsequently select a locator, then the locator contains the transaction ID. Note that you can implicitly be in a transaction without explicitly beginning one. For example, <code>SELECT</code>... <code>FOR</code> <code>UPDATE</code> implicitly begins a transaction. In such a case, the locator contains a transaction ID.</p>
</li>
<li>
<p><span class="bolditalic">Locators Do Not Contain Transaction IDs When..</span>.</p>
<ul>
<li>
<p><span class="italic">You are Outside the Transaction, Then Select Locator.</span> By contrast, if you select a locator outside of a transaction, then the locator does not contain a transaction ID.</p>
</li>
<li>
<p><span class="italic">When Selected Prior to DML Statement Execution.</span> A transaction ID is not assigned until the first DML statement executes. Therefore, locators that are selected prior to such a DML statement do not contain a transaction ID.</p>
</li>
</ul>
</li>
</ul>
<div id="ADLOB45340" class="sect2"><a id="sthref425"></a>
<h3 class="sect2"><a id="sthref426"></a><a id="sthref427"></a>Reading and Writing to a LOB Using Locators</h3>
<p>You can always read the LOB data using the locator irrespective of whether the locator contains a transaction ID.</p>
<ul>
<li>
<p><span class="italic">Cannot Write Using Locator</span>: If the locator contains a transaction ID, then you cannot write to the LOB outside of that particular transaction.</p>
</li>
<li>
<p><span class="italic">Can Write Using Locator</span>: If the locator <span class="italic">does not</span> contain a transaction ID, then you can write to the LOB after beginning a transaction either explicitly or implicitly.</p>
</li>
<li>
<p><span class="italic">Cannot Read or Write Using Locator With Serializable <a id="sthref428"></a>Transactions</span>: If the locator contains a transaction ID of an older transaction, and the current transaction is serializable, then you cannot read or write using that locator.</p>
</li>
<li>
<p><span class="italic">Can Read, Not Write Using Locator With Non-Serializable <a id="sthref429"></a>Transactions</span>: If the transaction is non-serializable, then you can read, but not write outside of that transaction.</p>
</li>
</ul>
<p>The following examples show the relationship between locators and <span class="italic">non-serializable</span> transactions</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB45341" class="sect2"><a id="sthref430"></a>
<h3 class="sect2"><a id="sthref431"></a>Selecting the Locator Outside of the Transaction Boundary</h3>
<p>The following scenarios describe techniques for using locators in non-serializable transactions when the locator is selected outside of a transaction.</p>
<p class="subhead1"><a id="ADLOB45342"></a>First Scenario:</p>
<ol>
<li>
<p>Select the locator with no current transaction. At this point, the locator does not contain a transaction id.</p>
</li>
<li>
<p>Begin the transaction.</p>
</li>
<li>
<p>Use the locator to read data from the LOB.</p>
</li>
<li>
<p>Commit or rollback the transaction.</p>
</li>
<li>
<p>Use the locator to read data from the LOB.</p>
</li>
<li>
<p>Begin a transaction. The locator does not contain a transaction id.</p>
</li>
<li>
<p>Use the locator to write data to the LOB. This operation is valid because the locator did not contain a transaction id prior to the write. After this call, the locator contains a transaction id.</p>
</li>
</ol>
<p class="subhead1"><a id="ADLOB45343"></a>Second Scenario:</p>
<ol>
<li>
<p>Select the locator with no current transaction. At this point, the locator does not contain a transaction id.</p>
</li>
<li>
<p>Begin the transaction. The locator does not contain a transaction id.</p>
</li>
<li>
<p>Use the locator to read data from the LOB. The locator does not contain a transaction id.</p>
</li>
<li>
<p>Use the locator to write data to the LOB. This operation is valid because the locator did not contain a transaction id prior to the write. After this call, the locator contains a transaction id. You can continue to read from or write to the LOB.</p>
</li>
<li>
<p>Commit or rollback the transaction. The locator continues to contain the transaction id.</p>
</li>
<li>
<p>Use the locator to read data from the LOB. This is a valid operation.</p>
</li>
<li>
<p>Begin a transaction. The locator contains the previous transaction id.</p>
</li>
<li>
<p>Use the locator to write data to the LOB. This write operation fails because the locator does not contain the transaction id that matches the current transaction.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="ADLOB45344" class="sect2"><a id="sthref432"></a>
<h3 class="sect2"><a id="sthref433"></a>Selecting the Locator Within a Transaction Boundary</h3>
<p>The following scenarios describe techniques for using locators in non-serializable transactions when the locator is selected within a transaction.</p>
<p class="subhead1"><a id="ADLOB45345"></a>Scenario 1:</p>
<ol>
<li>
<p>Select the locator within a transaction. At this point, the locator contains the transaction id.</p>
</li>
<li>
<p>Begin the transaction. The locator contains the previous transaction id.</p>
</li>
<li>
<p>Use the locator to read data from the LOB. This operation is valid even though the transaction id in the locator does not match the current transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJHJBBIF">"Read-Consistent Locators"</a> for more information about using the locator to read LOB data.</div>
</li>
<li>
<p>Use the locator to write data to the LOB. This operation fails because the transaction id in the locator does not match the current transaction.</p>
</li>
</ol>
<p class="subhead1"><a id="ADLOB45346"></a>Scenario 2:</p>
<ol>
<li>
<p>Begin a transaction.</p>
</li>
<li>
<p>Select the locator. The locator contains the transaction id because it was selected within a transaction.</p>
</li>
<li>
<p>Use the locator to read from or write to the LOB. These operations are valid.</p>
</li>
<li>
<p>Commit or rollback the transaction. The locator continues to contain the transaction id.</p>
</li>
<li>
<p>Use the locator to read data from the LOB. This operation is valid even though there is a transaction id in the locator and the transaction was previously committed or rolled back.</p>
</li>
<li>
<p>Use the locator to write data to the LOB. This operation fails because the transaction id in the locator is for a transaction that was previously committed or rolled back.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1012754"></a>
<div id="ADLOB45347" class="sect2">
<h3 class="sect2">LOB Locators Cannot Span <a id="sthref434"></a><a id="sthref435"></a>Transactions</h3>
<p><a id="sthref436"></a><a id="sthref437"></a>Modifying a persistent LOB value through the LOB locator using <code>DBMS_LOB</code>, OCI, or SQL <code>INSERT</code> or <code>UPDATE</code> statements changes the locator from a <a id="sthref438"></a><a id="sthref439"></a>read-consistent locator to an updated locator. The <code>INSERT</code> or <code>UPDATE</code> statement automatically starts a transaction and locks the row. Once this has occurred, the locator cannot be used outside the current transaction to modify the LOB value. In other words, LOB locators that are used to write data cannot span transactions. However, the locator can be used to read the LOB value unless you are in a serializable transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006915">"LOB Locators and Transaction Boundaries"</a>, for more information about the relationship between LOBs and transaction boundaries.</div>
<p>In the following example, a <code>CLOB</code> locator is created: <code>clob_updated</code></p>
<ul>
<li>
<p>At the time of the first <code>SELECT</code> <code>INTO</code> (at t1), the value in <code>ad_sourcetext</code> is associated with the locator <code>clob_updated</code>.</p>
</li>
<li>
<p>The second operation (at t2), uses the <code>DBMS_LOB</code>.<code>WRITE</code> function to alter the value in <code>clob_updated</code>, and a <code>DBMS_LOB</code>.<code>READ</code> reveals a new value.</p>
</li>
<li>
<p>The <code>commit</code> statement (at t3) ends the current transaction.</p>
</li>
<li>
<p>Therefore (at t4), the subsequent <code>DBMS_LOB</code>.<code>WRITE</code> operation fails because the <code>clob_updated</code> locator refers to a different (already committed) transaction. This is noted by the error returned. You must re-select the LOB locator before using it in further <code>DBMS_LOB</code> (and OCI) modify operations.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADLOB45348" class="sect2"><a id="sthref440"></a>
<h3 class="sect2">Example of Locator Not Spanning a Transaction</h3>
<pre>
INSERT INTO PRINT_MEDIA VALUES (2056, 20010, EMPTY_BLOB(), 
    'abcd', EMPTY_CLOB(), EMPTY_CLOB(), NULL, NULL, NULL, NULL);

COMMIT;

DECLARE
  num_var          INTEGER;
  clob_updated     CLOB;
  read_amount      INTEGER;
  read_offset      INTEGER;
  write_amount     INTEGER;
  write_offset     INTEGER;
  buffer           VARCHAR2(20);

BEGIN
          -- At time t1:
     SELECT      ad_sourcetext
     INTO        clob_updated
     FROM        PRINT_MEDIA
     WHERE       ad_id = 20010
     FOR UPDATE;
     read_amount := 10;
     read_offset := 1;
     dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
     dbms_output.put_line('clob_updated value: ' || buffer);
     -- This produces the output 'abcd'

     -- At time t2:
     write_amount := 3;
     write_offset := 5;
     buffer := 'efg';
     dbms_lob.write(clob_updated, write_amount, write_offset, buffer);
     read_amount := 10;
     dbms_lob.read(clob_updated, read_amount, read_offset, buffer);
     dbms_output.put_line('clob_updated value: ' || buffer);
     -- This produces the output 'abcdefg'

    -- At time t3:
    COMMIT;

     -- At time t4:
    dbms_lob.write(clob_updated , write_amount, write_offset, buffer);
    -- ERROR: ORA-22990: LOB locators cannot span transactions
END;
/
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006997"></a>
<div id="ADLOB45349" class="sect1">
<h2 class="sect1"><a id="sthref441"></a><a id="sthref442"></a>LOBs in the <a id="sthref443"></a><a id="sthref444"></a><a id="sthref445"></a><a id="sthref446"></a>Object Cache</h2>
<p>Consider these object cache issues for internal and external LOB attributes:</p>
<ul>
<li>
<p>Persistent LOB attributes: Creating an object in object cache, sets the LOB attribute to empty. <a id="sthref447"></a><a id="sthref448"></a><a id="sthref449"></a></p>
<p>When you create an object in the object cache that contains a persistent LOB attribute, the LOB attribute is implicitly set to empty. You may not use this empty LOB locator to write data to the LOB. You must first flush the object, thereby inserting a row into the table and creating an empty LOB &mdash; that is, a LOB with 0 length. Once the object is refreshed in the object cache (use <code>OCI_PIN_LATEST</code>), the real LOB locator is read into the attribute, and you can then call the OCI LOB API to write data to the LOB.</p>
</li>
<li>
<p>External LOB (<code>BFILE</code>) attributes: Creating an object in object cache, sets the <code>BFILE</code> attribute to <code>NULL</code>.</p>
<p>When creating an object with an external LOB (<code>BFILE)</code> attribute, the <code>BFILE</code> is set to <code>NULL</code>. It must be updated with a valid directory object name and file name before reading from the <code>BFILE</code>.</p>
</li>
</ul>
<p>When you copy one object to another in the object cache with a LOB locator attribute, only the LOB <span class="italic">locator</span> is copied. This means that the LOB attribute in these two different objects contain exactly the same locator which refers to <span class="italic">one and the same</span> LOB <span class="italic">value</span>. Only when the target object is flushed is a separate, physical copy of the LOB value made, which is distinct from the source LOB value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006480">"Example of Updating LOBs and Read-Consistency"</a> for a description of what version of the LOB value is seen by each object if a write is performed through one of the locators.</div>
<p>Therefore, in cases where you want to modify the LOB that was the target of the copy, <span class="bolditalic">you must flush the target object, refresh the target object, and then</span> write to the LOB through the locator attribute.</p>
</div>
<!-- class="sect1" -->
<a id="i1012747"></a>
<div id="ADLOB102" class="sect1">
<h2 class="sect1">Terabyte-Size LOB Support</h2>
<p><a id="sthref450"></a><a id="sthref451"></a><a id="sthref452"></a>Terabyte-size LOBs&mdash;LOBs up to a maximum size of 8 to 128 terabytes depending on your database block size&mdash;are supported by the following APIs:</p>
<ul>
<li>
<p>Java using JDBC (Java Database Connectivity)</p>
</li>
<li>
<p>PL/SQL using the DBMS_LOB Package</p>
</li>
<li>
<p>C using OCI (Oracle Call Interface)</p>
</li>
</ul>
<p>You cannot create and use LOB instances of size greater than 4 gigabytes "terabyte-size LOBs"&mdash; in the following programmatic environments:</p>
<ul>
<li>
<p>COBOL using the Pro*COBOL Precompiler</p>
</li>
<li>
<p>C or C++ using the Pro*C/C++ Precompiler</p>
</li>
<li>
<p>Visual Basic using OO4O (Oracle Objects for OLE)</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database does not support <code><a id="sthref453"></a><a id="sthref454"></a>BFILE</code>s larger than 2^64-1 bytes (<code>UB8MAXVAL</code> in OCI) in any programmatic environment. Any additional file size limit imposed by your operating system also applies to <code>BFILE</code>s.</div>
<a id="i1013006"></a>
<div id="ADLOB45350" class="sect2">
<h3 class="sect2">Maximum Storage Limit for Terabyte-Size LOBs</h3>
<p>In supported environments, you can create and manipulate LOBs that are up to the maximum storage size limit for your database configuration.</p>
<p>Oracle Database lets you create tablespaces with block sizes different from the database block size, and the maximum size of a LOB depends on the size of the tablespace blocks. <code><a id="sthref455"></a>CHUNK</code> is a parameter of LOB storage whose value is controlled by the block size of the tablespace in which the LOB is stored.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>CHUNK</code> parameter does not apply to SecureFiles LOBs. It is only used for BasicFiles LOBs.</div>
<p>When you create a LOB column, you can specify a value for <code>CHUNK</code>, which is the number of bytes to be allocated for LOB manipulation. The value must be a multiple of the tablespace block size, or Oracle Database rounds up to the next multiple. (If the tablespace block size is the same as the database block size, then <code>CHUNK</code> is also a multiple of the database block size.)</p>
<p>The maximum allowable storage limit for your configuration depends on the tablespace block size setting, and is calculated as (4 gigabytes - 1) times the value obtained from <a id="sthref456"></a><code>DBMS_LOB.GETCHUNKSIZE</code> or <a id="sthref457"></a><code>OCILobGetChunkSize()</code>. This value, in number of bytes for <code>BLOB</code>s or number of characters for <code>CLOB</code>s, is actually less than the size of the <code>CHUNK</code> parameter due to internal storage overhead. With the current allowable range for the tablespace block size from 2K to 32K, the storage limit ranges from 8 terabytes to 128 terabytes.</p>
<p>For example, suppose your database block size is 32K bytes and you create a tablespace with a nonstandard block size of 8K. Further suppose that you create a table with a LOB column and specify a CHUNK size of 16K (which is a multiple of the 8K tablespace block size). Then the maximum size of a LOB in this column is (4 gigabytes - 1) * 16K.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN" href="../../server.112/e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for details on the initialization parameter setting for your database installation.</p>
</li>
<li>
<p><a href="adlob_tables.htm#i1006587">"CHUNK"</a></p>
</li>
</ul>
</div>
<p>This storage limit applies to all LOB types in environments that support terabyte-size LOBs. However, note that <code>CLOB</code> and <code>NCLOB</code> types are sized in characters, while the <code>BLOB</code> type is sized in bytes.</p>
</div>
<!-- class="sect2" -->
<div id="ADLOB45351" class="sect2"><a id="sthref458"></a>
<h3 class="sect2">Using Terabyte-Size LOBs with JDBC</h3>
<p>You can use the LOB APIs included in the Oracle JDBC classes to access terabyte-size LOBs.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adlob_api_overview.htm#i1009032">"Using Java (JDBC) to Work With LOBs"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADLOB45352" class="sect2"><a id="sthref459"></a>
<h3 class="sect2">Using Terabyte-Size LOBs with the DBMS_LOB Package</h3>
<p>You can access terabyte-size LOBs with all APIs in the DBMS_LOB PL/SQL package. Use <code>DBMS_LOB.GETCHUNKSIZE</code> to obtain the value to be used in reading and writing LOBs. The number of bytes stored in a chunk is actually less than the size of the <code>CHUNK</code> parameter due to internal storage overhead. The <a id="sthref460"></a><code>DBMS_LOB.GET_STORAGE_LIMIT</code> function returns the storage limit for your database configuration. This is the maximum allowable size for LOBs. <code>BLOB</code>s are sized in bytes, while <code>CLOB</code>s and <code>NCLOB</code>s are sized in characters.</p>
<div class="infobox-note">
<p class="notep1">See Also:</p>
<a class="olink ARPLS601" href="../../appdev.112/e40758/d_lob.htm#ARPLS601"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details on the initialization parameter setting for your database installation.</div>
</div>
<!-- class="sect2" -->
<div id="ADLOB45353" class="sect2"><a id="sthref461"></a>
<h3 class="sect2">Using Terabyte-Size LOBs with OCI</h3>
<p>The Oracle Call Interface API provides a set of functions for operations on LOBs of all sizes. <code><a id="sthref462"></a>OCILobGetChunkSize()</code> returns the value, in bytes for <code>BLOB</code>s, or in characters for <code>CLOB</code>s, to be used in reading and writing LOBs. For varying-width character sets, the value is the number of Unicode characters that fit. The number of bytes stored in a chunk is actually less than the size of the <code>CHUNK</code> parameter due to internal storage overhead. The function <code><a id="sthref463"></a>OCILobGetStorageLimit()</code> returns the maximum allowable size, in bytes, of internal LOBs in the current database installation. If streaming mode is used, where the whole LOB is read, there is no requirement to get the chunk size.</p>
<div class="infobox-note">
<p class="notep1">See Also:</p>
<a class="olink LNOCI070" href="../../appdev.112/e10646/oci07lob.htm#LNOCI070"><span class="italic">Oracle Call Interface Programmer's Guide,</span></a> the chapter "LOB and BFILE Operations", section "Using LOBs of Size Greater than 4GB" for details on OCI functions that support LOBs.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1012602"></a>
<div id="ADLOB45354" class="sect1">
<h2 class="sect1">Guidelines for Creating Gigabyte LOBs</h2>
<p>To create gigabyte LOBs in supported environments, use the following guidelines to make use of all available space in the tablespace for LOB storage:</p>
<ul>
<li>
<p><span class="bolditalic">Single Data File Size Restrictions</span>: There are restrictions on the size of a single data file for each operating system. For example, Solaris 2.5 only allows operating system files of up to 2 gigabytes. Hence, add more data files to the tablespace when the LOB grows larger than the maximum allowed file size of the operating system on which your Oracle Database runs.</p>
</li>
<li>
<p><span class="bolditalic">Set PCT INCREASE Parameter to Zero</span>: <code>PCTINCREASE</code> parameter in the LOB storage clause specifies the percent growth of the new extent size. When a LOB is being filled up piece by piece in a tablespace, numerous new extents get created in the process. If the extent sizes keep increasing by the default value of 50 percent every time, then extents become unmanageable and eventually waste space in the tablespace. Therefore, the <code>PCTINCREASE</code> parameter should be set to zero or a small value.</p>
</li>
<li>
<p><span class="bolditalic">Set MAXEXTENTS to a Suitable Value or UNLIMITED</span>: The <code>MAXEXTENTS</code> parameter limits the number of extents allowed for the LOB column. A large number of extents are created incrementally as the LOB size grows. Therefore, the parameter should be set to a value that is large enough to hold all the LOBs for the column. Alternatively, you could set it to <code>UNLIMITED</code>.</p>
</li>
<li>
<p><span class="bolditalic">Use a Large Extent Size:</span> For every new extent created, Oracle generates undo information for the header and other metadata for the extent. If the number of extents is large, then the rollback segment can be saturated. To get around this, choose a large extent size, say 100 megabytes, to reduce the frequency of extent creation, or commit the transaction more often to reuse the space in the rollback segment.</p>
</li>
</ul>
<a id="i1007028"></a>
<div id="ADLOB45355" class="sect2">
<h3 class="sect2">Creating a Tablespace and Table to Store Gigabyte LOBs</h3>
<p>The following example illustrates how to create a tablespace and table to store gigabyte LOBs.</p>
<pre>
CREATE TABLESPACE lobtbs1 DATAFILE '/your/own/data/directory/lobtbs_1.dat'
SIZE 2000M REUSE ONLINE NOLOGGING DEFAULT STORAGE (MAXEXTENTS UNLIMITED);
ALTER TABLESPACE lobtbs1 ADD DATAFILE
'/your/own/data/directory/lobtbs_2.dat' SIZE 2000M REUSE;

CREATE TABLE print_media_backup
  (product_id NUMBER(6), 
   ad_id NUMBER(6), 
   ad_composite BLOB, 
   ad_sourcetext CLOB, 
   ad_finaltext CLOB, 
   ad_fltextn NCLOB, 
   ad_textdocs_ntab textdoc_tab, 
   ad_photo BLOB, 
   ad_graphic BLOB, 
   ad_header adheader_typ)
   NESTED TABLE ad_textdocs_ntab STORE AS textdocs_nestedtab5 
   LOB(ad_sourcetext) STORE AS (TABLESPACE lobtbs1 CHUNK 32768 PCTVERSION 0 
                                NOCACHE NOLOGGING
                                STORAGE(INITIAL 100M NEXT 100M MAXEXTENTS 
                                UNLIMITED PCTINCREASE 0));
</pre>
<p>Note the following with respect to this example:</p>
<ul>
<li>
<p>The storage clause in this example is specified in the <code>CREATE TABLESPACE</code> statement.</p>
</li>
<li>
<p>You can specify the storage clause in the <code>CREATE TABLE</code> statement as an alternative.</p>
</li>
<li>
<p>The storage clause is not allowed in the <code>CREATE TEMPORARY TABLESPACE</code> statement.</p>
</li>
<li>
<p>Setting the <code><a id="sthref464"></a>PCTINCREASE</code> parameter to 0 is recommended for gigabyte LOBs. For small, or medium size lobs, the default <code>PCTINCREASE</code> value of 50 is recommended as it reduces the number of extent allocations.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment898">
<tr>
<td class="cellalignment907">
<table class="cellalignment903">
<tr>
<td class="cellalignment902"><a href="adlob_tables.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment902"><a href="adlob_api_overview.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment909">
<table class="cellalignment901">
<tr>
<td class="cellalignment902"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment902"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment902"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment902"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment902"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment902"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
