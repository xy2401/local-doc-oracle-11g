<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using LOB APIs</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 737" />
<meta name="dcterms.created" content="2013-07-18T13:32:42Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database SecureFiles and Large Objects Developer's Guide" />
<meta name="dcterms.identifier" content="E18294-04" />
<meta name="dcterms.isVersionOf" content="ADLOB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adlob_bfile_ops.htm" title="Previous" type="text/html" />
<link rel="Next" href="adlob_demo.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e18294.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">34/37</span> <!-- End Header -->
<div id="ADLOB1400" class="chapter"><a id="g1113588"></a><a id="i1021392"></a>
<h1 class="chapter"><span class="secnum">22</span> Using LOB APIs</h1>
<p>This chapter describes APIs that perform operations on <code>BLOB</code>, <code>CLOB</code>, and <code>NCLOB</code> data types. The operations given in this chapter can be used with either persistent or temporary LOB instances. Note that operations in this chapter do not apply to <code>BFILE</code>s. APIs covered in this chapter are listed in <a href="#g1098343">Table 22-1</a>.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a href="adlob_creating.htm#g1009782">Chapter 19, "Operations Specific to Persistent and Temporary LOBs"</a> for information on how to create temporary and persistent LOB instances and other operations specific to temporary or persistent LOBs.</p>
</li>
<li>
<p><a href="adlob_bfile_ops.htm#g1088337">Chapter 21, "LOB APIs for BFILE Operations"</a> for information on operations specific to <code>BFILE</code> instances.</p>
</li>
</ul>
</div>
<p>The following information is given for each operation described in this chapter:</p>
<ul>
<li>
<p><span class="bolditalic">Preconditions</span> describe dependencies that must be met and conditions that must exist before calling each operation.</p>
</li>
<li>
<p><span class="bolditalic">Usage Notes</span> provide implementation guidelines such as information specific to a given programmatic environment or data type.</p>
</li>
<li>
<p><span class="bolditalic">Syntax</span> refers you to the syntax reference documentation for each supported programmatic environment.</p>
</li>
<li>
<p><span class="bolditalic">Examples</span> describe any setup tasks necessary to run the examples given. Demonstration files listed are available in subdirectories under <code>$ORACLE_HOME/rdbms/demo/lobs/</code> named <code>plsql</code>, <code>oci</code>, <code>vb</code>, and <code>java</code>. The driver program <code>lobdemo.sql</code> is in <code>/plsql</code> and the driver program <code>lobdemo.c</code> is in <code>/oci</code>.</p>
</li>
</ul>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1062590">Supported Environments</a></p>
</li>
<li>
<p><a href="#i1046863">Appending One LOB to Another</a></p>
</li>
<li>
<p><a href="#i1038288">Determining Character Set Form</a></p>
</li>
<li>
<p><a href="#i1010103">Determining Character Set ID</a></p>
</li>
<li>
<p><a href="#i1010377">Loading a LOB with Data from a BFILE</a></p>
</li>
<li>
<p><a href="#i1010559">Loading a BLOB with Data from a BFILE</a></p>
</li>
<li>
<p><a href="#i1010659">Loading a CLOB or NCLOB with Data from a BFILE</a></p>
</li>
<li>
<p><a href="#i1011313">Determining Whether a LOB is Open</a></p>
</li>
<li>
<p><a href="#i1011921">Displaying LOB Data</a></p>
</li>
<li>
<p><a href="#i1024873">Reading Data from a LOB</a></p>
</li>
<li>
<p><a href="#BACGDAJF">LOB Array Read</a></p>
</li>
<li>
<p><a href="#i1013268">Reading a Portion of a LOB (SUBSTR)</a></p>
</li>
<li>
<p><a href="#i1013752">Comparing All or Part of Two LOBs</a></p>
</li>
<li>
<p><a href="#i1063011">Patterns: Checking for Patterns in a LOB Using INSTR</a></p>
</li>
<li>
<p><a href="#i1014690">Length: Determining the Length of a LOB</a></p>
</li>
<li>
<p><a href="#i1015201">Copying All or Part of One LOB to Another LOB</a></p>
</li>
<li>
<p><a href="#i1015853">Copying a LOB Locator</a></p>
</li>
<li>
<p><a href="#i1016375">Equality: Checking If One LOB Locator Is Equal to Another</a></p>
</li>
<li>
<p><a href="#i1016989">Determining Whether LOB Locator Is Initialized</a></p>
</li>
<li>
<p><a href="#i1017313">Appending to a LOB</a></p>
</li>
<li>
<p><a href="#i1017877">Writing Data to a LOB</a></p>
</li>
<li>
<p><a href="#BACIEIJB">LOB Array Write</a></p>
</li>
<li>
<p><a href="#i1028365">Trimming LOB Data</a></p>
</li>
<li>
<p><a href="#i1019599">Erasing Part of a LOB</a></p>
</li>
<li>
<p><a href="#i1020156">Enabling LOB Buffering</a></p>
</li>
<li>
<p><a href="#i1020542">Flushing the Buffer</a></p>
</li>
<li>
<p><a href="#i1020912">Disabling LOB Buffering</a></p>
</li>
<li>
<p><a href="#i1021396">Determining Whether a LOB instance Is Temporary</a></p>
</li>
<li>
<p><a href="#i1065193">Converting a BLOB to a CLOB</a></p>
</li>
<li>
<p><a href="#i1065206">Converting a CLOB to a BLOB</a></p>
</li>
<li>
<p><a href="#BACEDAEH">Ensuring Read Consistency</a></p>
</li>
</ul>
<a id="i1062590"></a>
<div id="ADLOB45695" class="sect1">
<h2 class="sect1">Supported Environments</h2>
<p><a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a> indicates which programmatic environments are supported for the APIs discussed in this chapter. The first column describes the operation that the API performs. The remaining columns indicate with "Yes" or "No" whether the API is supported in PL/SQL, OCI, OCCI, COBOL, Pro*C/C++, COM, and JDBC.</p>
<div id="ADLOB45696" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref1067"></a><a id="g1098343"></a>Table 22-1 Environments Supported for LOB APIs</p>
<table class="cellalignment910" title="Environments Supported for LOB APIs " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment899">
<th class="cellalignment906" id="r1c1-t3">Operation</th>
<th class="cellalignment906" id="r1c2-t3">PL/SQL</th>
<th class="cellalignment906" id="r1c3-t3">OCI</th>
<th class="cellalignment906" id="r1c4-t3">OCCI</th>
<th class="cellalignment906" id="r1c5-t3">COBOL</th>
<th class="cellalignment906" id="r1c6-t3">Pro*C/C++</th>
<th class="cellalignment906" id="r1c7-t3">COM</th>
<th class="cellalignment906" id="r1c8-t3">JDBC</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment899">
<td class="cellalignment907" id="r2c1-t3" headers="r1c1-t3">
<p><a href="#i1046863">Appending One LOB to Another</a></p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r2c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r3c1-t3" headers="r1c1-t3">
<p><a href="#i1038288">Determining Character Set Form</a></p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r3c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r4c1-t3" headers="r1c1-t3">
<p><a href="#i1010103">Determining Character Set ID</a></p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r4c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r5c1-t3" headers="r1c1-t3">
<p>Determining Chunk Size, See: <a href="#i1017877">Writing Data to a LOB</a></p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r5c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r6c1-t3" headers="r1c1-t3">
<p><a href="#i1013752">Comparing All or Part of Two LOBs</a></p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r6c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r7c1-t3" headers="r1c1-t3">
<p><a href="#i1065193">Converting a BLOB to a CLOB</a></p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r7c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r8c1-t3" headers="r1c1-t3">
<p><a href="#i1065206">Converting a CLOB to a BLOB</a></p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r8c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r9c1-t3" headers="r1c1-t3">
<p><a href="#i1015853">Copying a LOB Locator</a></p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r9c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r10c1-t3" headers="r1c1-t3">
<p><a href="#i1015201">Copying All or Part of One LOB to Another LOB</a></p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r10c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r11c1-t3" headers="r1c1-t3">
<p><a href="#i1020912">Disabling LOB Buffering</a></p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r11c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r12c1-t3" headers="r1c1-t3">
<p><a href="#i1011921">Displaying LOB Data</a></p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r12c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r13c1-t3" headers="r1c1-t3">
<p><a href="#i1020156">Enabling LOB Buffering</a></p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r13c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r14c1-t3" headers="r1c1-t3">
<p><a href="#i1016375">Equality: Checking If One LOB Locator Is Equal to Another</a></p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r14c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r15c1-t3" headers="r1c1-t3">
<p><a href="#i1019599">Erasing Part of a LOB</a></p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r15c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r16c1-t3" headers="r1c1-t3">
<p><a href="#i1020542">Flushing the Buffer</a></p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r16c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r17c1-t3" headers="r1c1-t3">
<p><a href="#i1016989">Determining Whether LOB Locator Is Initialized</a></p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r17c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r18c1-t3" headers="r1c1-t3">
<p><a href="#i1014690">Length: Determining the Length of a LOB</a></p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r18c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r19c1-t3" headers="r1c1-t3">
<p><a href="#i1010377">Loading a LOB with Data from a BFILE</a></p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r19c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r20c1-t3" headers="r1c1-t3">
<p><a href="#i1010559">Loading a BLOB with Data from a BFILE</a></p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r20c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r21c1-t3" headers="r1c1-t3">
<p><a href="#i1010659">Loading a CLOB or NCLOB with Data from a BFILE</a></p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r21c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r22c1-t3" headers="r1c1-t3">
<p><a href="#BACGDAJF">LOB Array Read</a></p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r22c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r23c1-t3" headers="r1c1-t3">
<p><a href="#BACIEIJB">LOB Array Write</a></p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r23c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r24c1-t3" headers="r1c1-t3">
<p><a href="adlob_design.htm#i1006373">Opening Persistent LOBs with the OPEN and CLOSE Interfaces</a></p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r24c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r25c1-t3" headers="r1c1-t3">
<p>Open: <a href="#i1011313">Determining Whether a LOB is Open</a></p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r25c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r26c1-t3" headers="r1c1-t3">
<p><a href="#i1063011">Patterns: Checking for Patterns in a LOB Using INSTR</a></p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r26c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r27c1-t3" headers="r1c1-t3">
<p><a href="#i1013268">Reading a Portion of a LOB (SUBSTR)</a></p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r27c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r28c1-t3" headers="r1c1-t3">
<p><a href="#i1024873">Reading Data from a LOB</a></p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r28c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r29c1-t3" headers="r1c1-t3">
<p>Storage Limit, Determining: <a href="adlob_design.htm#i1013006">Maximum Storage Limit for Terabyte-Size LOBs</a></p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r29c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r30c1-t3" headers="r1c1-t3">
<p><a href="#i1028365">Trimming LOB Data</a></p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r30c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r31c1-t3" headers="r1c1-t3">
<p>WriteNoAppend, see <a href="#i1017313">Appending to a LOB</a> .</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c2-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c4-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c5-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c6-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c7-t3">
<p>No</p>
</td>
<td class="cellalignment907" headers="r31c1-t3 r1c8-t3">
<p>No</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r32c1-t3" headers="r1c1-t3">
<p><a href="#i1017877">Writing Data to a LOB</a></p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c2-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c5-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c6-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c7-t3">
<p>Yes</p>
</td>
<td class="cellalignment907" headers="r32c1-t3 r1c8-t3">
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect1" -->
<a id="i1046863"></a>
<div id="ADLOB1001" class="sect1">
<h2 class="sect1">Appending One LOB to Another</h2>
<p>This operation appends one LOB instance to another.</p>
<p class="subhead1"><a id="ADLOB45697"></a>Preconditions</p>
<p>Before you can append one LOB to another, the following conditions must be met:</p>
<ul>
<li>
<p>Two LOB instances must exist.</p>
</li>
<li>
<p>Both instances must be of the same type, for example both <code>BLOB</code> or both <code>CLOB</code> types.</p>
</li>
<li>
<p>You can pass any combination of persistent or temporary LOB instances to this operation.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45698"></a>Usage Notes</p>
<p><span class="bold">Persistent LOBs:</span> You must lock the row you are selecting the LOB from prior to <a id="sthref1068"></a>updating <a id="sthref1069"></a>a LOB value if you are using the PL/SQL <code>DBMS_LOB</code> Package or OCI. While the SQL <code>INSERT</code> and <code>UPDATE</code> statements implicitly lock the row, locking the row can be done explicitly using the SQL <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement in SQL and PL/SQL programs, or by using an OCI <code>pin</code> or <code>lock</code> function in OCI programs. For more details on the state of the locator after an update, refer to <a href="adlob_design.htm#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
<p class="subhead1"><a id="ADLOB45699"></a>Syntax</p>
<p>See the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" <span class="italic">&mdash;</span> APPEND</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobAppend()</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; LOB APPEND.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> for information on embedded SQL statements and directives &mdash; LOB APPEND</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> for information on creating and populating LOB columns in Java.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45700"></a>Examples</p>
<p>To run the following examples, you must create two LOB instances and pass them when you call the given append operation. Creating a LOB instance is described in <a href="adlob_creating.htm#g1009782">Chapter 19, "Operations Specific to Persistent and Temporary LOBs"</a>.</p>
<p>Examples for this use case are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lappend.sql</code></p>
</li>
<li>
<p>OCI: <code>lappend.c</code></p>
</li>
<li>
<p>COM (OO4O): <code>lappend.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lappend.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1038288"></a>
<div id="ADLOB45701" class="sect1">
<h2 class="sect1">Determining Character Set Form</h2>
<p>This section describes how to get the character set form of a LOB instance.</p>
<p class="subhead1"><a id="ADLOB45702"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): There is no applicable syntax reference for this operation.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobCharSetForm()</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL): There is no applicable syntax reference for this operation</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): There is no applicable syntax reference for this operation.</p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this operation.</p>
</li>
<li>
<p>Java (JDBC): There is no applicable syntax reference for this operation.</p>
</li>
</ul>
<p class="subhead1"><a id="i1010019"></a><a id="ADLOB45703"></a>Example</p>
<p>The example demonstrates how to determine the character set form of the foreign language text (<code>ad_fltextn</code>).</p>
<p>This functionality is currently available only in OCI:</p>
<ul>
<li>
<p>OCI: <code>lgetchfm.c</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1010103"></a>
<div id="ADLOB45704" class="sect1">
<h2 class="sect1"><a id="sthref1070"></a>Determining Character Set ID</h2>
<p>This section describes how to determine the character set ID.</p>
<p class="subhead1"><a id="ADLOB45705"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): There is no applicable syntax reference for this operation.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "Relational Functions" &mdash; LOB Functions, OCILobCharSetId()</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL): There is no applicable syntax reference for this operation.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): There is no applicable syntax reference for this operation</p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this operation.</p>
</li>
<li>
<p>Java (JDBC): There is no applicable syntax reference for this operation.</p>
</li>
</ul>
<p class="subhead1"><a id="i1010134"></a><a id="ADLOB45706"></a>Example</p>
<p>This functionality is currently available only in OCI:</p>
<ul>
<li>
<p>OCI: <code>lgetchar.c</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1010377"></a>
<div id="ADLOB45707" class="sect1">
<h2 class="sect1">Loading a <a id="sthref1071"></a>LOB with Data from a BFILE</h2>
<p>This operation loads a LOB with data from a <code>BFILE</code>. This procedure can be used to load data into any persistent or temporary LOB instance of any LOB data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>The <code>LOADBLOBFROMFILE</code> and <code>LOADCLOBFROMFILE</code> procedures implement the functionality of this procedure and provide improved features for loading binary data and character data. (These improved procedures are available in the PL/SQL environment only.) When possible, using one of the improved procedures is recommended. See <a href="#i1010559">"Loading a BLOB with Data from a BFILE"</a> and <a href="#i1010659">"Loading a CLOB or NCLOB with Data from a BFILE"</a> for more information.</p>
</li>
<li>
<p>As an alternative to this operation, you can use SQL*Loader to load persistent LOBs with data directly from a file in the file system. See <a href="adlob_managing.htm#i1006100">"Using SQL*Loader to Load LOBs"</a> for more information.</p>
</li>
</ul>
</div>
<p class="subhead1"><a id="ADLOB45708"></a>Preconditions</p>
<p>Before you can load a LOB with data from a <code>BFILE</code>, the following conditions must be met:</p>
<ul>
<li>
<p>The <code>BFILE</code> must exist.</p>
</li>
<li>
<p>The target LOB instance must exist.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45709"></a>Usage Notes</p>
<p>Note the following issues regarding this operation.</p>
<p class="subhead2"><a id="ADLOB45710"></a>Use LOADCLOBFROMFILE When Loading Character Data</p>
<p>When you use the <code>DBMS_LOB.LOADFROMFILE</code> procedure to load a <code>CLOB</code> or <code>NCLOB</code> instance, you are loading the LOB with binary data from the <code>BFILE</code> and no implicit character set conversion is performed. For this reason, using the <code>DBMS_LOB.LOADCLOBFROMFILE</code> procedure is recommended when loading character data, see <a href="#i1010659">Loading a CLOB or NCLOB with Data from a BFILE</a> for more information.</p>
<p class="subhead2"><a id="ADLOB45711"></a>Specifying Amount of BFILE Data to Load</p>
<p>The value you pass for the amount parameter to functions listed in <a href="#g1098617">Table 22-2</a> must be one of the following:</p>
<ul>
<li>
<p>An amount less than or equal to the actual size (in bytes) of the <code>BFILE</code> you are loading.</p>
</li>
<li>
<p>The maximum allowable LOB size (in bytes). Passing this value, loads the entire <code>BFILE</code>. You can use this technique to load the entire <code>BFILE</code> without determining the size of the <code>BFILE</code> before loading. To get the maximum allowable LOB size, use the technique described in <a href="#g1098617">Table 22-2</a>.</p>
</li>
</ul>
<div id="ADLOB45712" class="tblformal">
<p class="titleintable"><a id="sthref1072"></a><a id="g1098617"></a>Table 22-2 Maximum LOB Size for Load from File Operations</p>
<table class="cellalignment905" title="Maximum LOB Size for Load from File Operations" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment899">
<th class="cellalignment906" id="r1c1-t5">Environment</th>
<th class="cellalignment906" id="r1c2-t5">Function</th>
<th class="cellalignment906" id="r1c3-t5">To pass maximum LOB size, get value of:</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment899">
<td class="cellalignment907" id="r2c1-t5" headers="r1c1-t5">
<p class="synopsis"><code>DBMS_LOB</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t5 r1c2-t5">
<p class="synopsis"><code>DBMS_LOB.LOADBLOBFROMFILE</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t5 r1c3-t5">
<p class="synopsis"><code>DBMS_LOB.LOBMAXSIZE</code></p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r3c1-t5" headers="r1c1-t5">
<p class="synopsis"><code>DBMS_LOB</code></p>
</td>
<td class="cellalignment907" headers="r3c1-t5 r1c2-t5">
<p class="synopsis"><code>DBMS_LOB.LOADCLOBFROMFILE</code></p>
</td>
<td class="cellalignment907" headers="r3c1-t5 r1c3-t5">
<p class="synopsis"><code>DBMS_LOB.LOBMAXSIZE</code></p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r4c1-t5" headers="r1c1-t5">
<p class="synopsis"><code>OCI</code></p>
</td>
<td class="cellalignment907" headers="r4c1-t5 r1c2-t5">
<p class="synopsis"><code>OCILobLoadFromFile2()</code></p>
<p class="synopsis">(For LOBs of any size.)</p>
</td>
<td class="cellalignment907" headers="r4c1-t5 r1c3-t5">
<p class="synopsis"><code>UB8MAXVAL</code></p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r5c1-t5" headers="r1c1-t5">
<p class="synopsis"><code>OCI</code></p>
</td>
<td class="cellalignment907" headers="r5c1-t5 r1c2-t5">
<p class="synopsis"><code>OCILobLoadFromFile()</code></p>
<p class="synopsis">(For LOBs less than 4 gigabytes in size.)</p>
</td>
<td class="cellalignment907" headers="r5c1-t5 r1c3-t5">
<p class="synopsis"><code>UB4MAXVAL</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead1"><a id="ADLOB45713"></a>Syntax</p>
<p>See the following syntax references for details on using this operation in each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" <span class="italic">&mdash;</span> LOADFROMFILE.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobLoadFromFile().</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; <code>LOB LOAD</code>, <code>LOB OPEN</code>, <code>LOB CLOSE</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; <code>LOB LOAD</code></p>
</li>
<li>
<p>COM (OO4O) <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45714"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lloaddat.sql</code></p>
</li>
<li>
<p>OCI: <code>lloaddat.c</code></p>
</li>
<li>
<p>COM (OO4O): <code>lloaddat.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lloaddat.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1010559"></a>
<div id="ADLOB1100" class="sect1">
<h2 class="sect1">Loading a BLOB with Data from a BFILE</h2>
<p>This procedure loads a <code>BLOB</code> with data from a <code>BFILE</code>. This procedure can be used to load data into any persistent or temporary <code>BLOB</code> instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1010377">"Loading a LOB with Data from a BFILE"</a></p>
</li>
<li>
<p>To load character data, use <code>DBMS_LOB.LOADCLOBFROMFILE</code>. See <a href="#i1010659">"Loading a CLOB or NCLOB with Data from a BFILE"</a> for more information.</p>
</li>
<li>
<p>As an alternative to this operation, you can use SQL*Loader to load persistent LOBs with data directly from a file in the file system. See <a href="adlob_managing.htm#i1006100">"Using SQL*Loader to Load LOBs"</a> for more information.</p>
</li>
</ul>
</div>
<p class="subhead1"><a id="ADLOB45715"></a>Preconditions</p>
<p>The following conditions must be met before calling this procedure:</p>
<ul>
<li>
<p>The target <code>BLOB</code> instance must exist.</p>
</li>
<li>
<p>The source <code>BFILE</code> must exist.</p>
</li>
<li>
<p>You must open the <code>BFILE</code>. (After calling this procedure, you must close the <code>BFILE</code> at some point.)</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45716"></a>Usage Notes</p>
<p>Note the following with respect to this operation:</p>
<p class="subhead2"><a id="ADLOB45717"></a>New Offsets Returned</p>
<p>Using <code>DBMS_LOB.LOADBLOBFROMFILE</code> to load binary data into a <code>BLOB</code> achieves the same result as using <code>DBMS_LOB.LOADFROMFILE</code>, but also returns the new offsets of BLOB.</p>
<p class="subhead2"><a id="ADLOB45718"></a>Specifying Amount of BFILE Data to Load</p>
<p>The value you pass for the amount parameter to the <code>DBMS_LOB.LOADBLOBFROMFILE</code> function must be one of the following:</p>
<ul>
<li>
<p>An amount less than or equal to the actual size (in bytes) of the <code>BFILE</code> you are loading.</p>
</li>
<li>
<p>The maximum allowable LOB size: <code>DBMS_LOB.LOBMAXSIZE</code><code>.</code> Passing this value causes the function to load the entire <code>BFILE</code>. This is a useful technique for loading the entire <code>BFILE</code> without introspecting the size of the <code>BFILE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098617">Table 22-2, "Maximum LOB Size for Load from File Operations"</a></div>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45719"></a>Syntax</p>
<p>See <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, "DBMS_LOB" &mdash; LOADBLOBFROMFILE procedure for syntax details on this procedure.</p>
<p class="subhead1"><a id="ADLOB45720"></a>Examples</p>
<p>This example is available in PL/SQL only. This API is not provided in other programmatic environments. The online file is <code>lldblobf.sql</code>. This example illustrates:</p>
<ul>
<li>
<p>How to use <code>LOADBLOBFROMFILE</code> to load the entire <code>BFILE</code> without getting its length first.</p>
</li>
<li>
<p>How to use the return value of the offsets to calculate the actual amount loaded.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1010659"></a>
<div id="ADLOB1017" class="sect1">
<h2 class="sect1">Loading a CLOB or NCLOB with Data from a BFILE</h2>
<p>This procedure loads a <code>CLOB</code> or <code>NCLOB</code> with character data from a <code>BFILE</code>. This procedure can be used to load data into a persistent or temporary <code>CLOB</code> or <code>NCLOB</code> instance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1010377">"Loading a LOB with Data from a BFILE"</a></p>
</li>
<li>
<p>To load binary data, use <code>DBMS_LOB.LOADBLOBFROMFILE</code>. See <a href="#i1010559">"Loading a BLOB with Data from a BFILE"</a> for more information.</p>
</li>
<li>
<p>As an alternative to this operation, you can use SQL*Loader to load persistent LOBs with data directly from a file in the file system. See <a href="adlob_managing.htm#i1006100">"Using SQL*Loader to Load LOBs"</a> for more information.</p>
</li>
</ul>
</div>
<p class="subhead1"><a id="ADLOB45721"></a>Preconditions</p>
<p>The following conditions must be met before calling this procedure:</p>
<ul>
<li>
<p>The target <code>CLOB</code> or <code>NCLOB</code> instance must exist.</p>
</li>
<li>
<p>The source <code>BFILE</code> must exist.</p>
</li>
<li>
<p>You must open the <code>BFILE</code>. (After calling this procedure, you must close the <code>BFILE</code> at some point.)</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45722"></a>Usage Notes</p>
<p>You can specify the character set id of the <code>BFILE</code> when calling this procedure. Doing so, ensures that the character set is properly converted from the <code>BFILE</code> data character set to the destination <code>CLOB</code> or <code>NCLOB</code> character set.</p>
<p class="subhead2"><a id="ADLOB45723"></a>Specifying Amount of BFILE Data to Load</p>
<p>The value you pass for the amount parameter to the <code>DBMS_LOB.LOADCLOBFROMFILE</code> function must be one of the following:</p>
<ul>
<li>
<p>An amount less than or equal to the actual size (in characters) of the <code>BFILE</code> data you are loading.</p>
</li>
<li>
<p>The maximum allowable LOB size: <code>DBMS_LOB.LOBMAXSIZE</code></p>
<p>Passing this value causes the function to load the entire <code>BFILE</code>. This is a useful technique for loading the entire <code>BFILE</code> without introspecting the size of the <code>BFILE</code>.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45724"></a>Syntax</p>
<p>See <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, "DBMS_LOB" &mdash; <code>LOADCLOBFROMFILE</code> procedure for syntax details on this procedure.</p>
<p class="subhead1"><a id="ADLOB45725"></a>Examples</p>
<p>The following examples illustrate different techniques for using this API:</p>
<ul>
<li>
<p><a href="#i1010719">"PL/SQL: Loading Character Data from a BFILE into a LOB"</a></p>
</li>
<li>
<p><a href="#i1010763">"PL/SQL: Loading Segments of Character Data into Different LOBs"</a></p>
</li>
</ul>
<a id="i1010719"></a>
<div id="ADLOB45726" class="sect2">
<h3 class="sect2">PL/SQL: Loading Character Data from a BFILE into a LOB</h3>
<p>The following example illustrates:</p>
<ul>
<li>
<p>How to use default csid (<code>0</code>).</p>
</li>
<li>
<p>How to load the entire file without calling <code>getlength</code> for the <code>BFILE</code>.</p>
</li>
<li>
<p>How to find out the actual amount loaded using return offsets.</p>
</li>
</ul>
<p>This example assumes that <code>ad_source</code> is a <code>BFILE</code> in <code>UTF8</code> character set format and the database character set is <code>UTF8</code>. The online file is <code>lldclobf.sql</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i1010763"></a>
<div id="ADLOB45727" class="sect2">
<h3 class="sect2">PL/SQL: Loading Segments of Character Data into Different LOBs</h3>
<p>The following example illustrates:</p>
<ul>
<li>
<p>How to get the character set ID from the character set name using the <code>NLS_CHARSET_ID</code> function.</p>
</li>
<li>
<p>How to load a stream of data from a single <code>BFILE</code> into different LOBs using the returned offset value and the language context <code>lang_ctx</code>.</p>
</li>
<li>
<p>How to read a warning message.</p>
</li>
</ul>
<p>This example assumes that <code>ad_file_ext_01</code> is a <code>BFILE</code> in <code>JA16TSTSET</code> format and the database national character set is <code>AL16UTF16</code>. The online file is <code>lldclobs.sql</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1011313"></a>
<div id="ADLOB1014" class="sect1">
<h2 class="sect1">Determining Whether <a id="sthref1073"></a>a LOB is Open</h2>
<p>This operation determines whether a LOB is open.</p>
<p class="subhead1"><a id="ADLOB45728"></a>Preconditions</p>
<p>The LOB instance must exist before executing this procedure.</p>
<p class="subhead1"><a id="ADLOB45729"></a>Usage Notes</p>
<p>When a LOB is open, it must be closed at some point later in the session.</p>
<p class="subhead1"><a id="ADLOB45730"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" <span class="italic">&mdash;</span> <code>OPEN</code>, <code>ISOPEN</code>.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobIsOpen()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; LOB DESCRIBE.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; <code>LOB DESCRIBE</code> ... <code>ISOPEN</code> ...</p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45731"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lisopen.sql</code></p>
</li>
<li>
<p>OCI: <code>lisopen.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): No example is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): <code>lisopen.java</code></p>
</li>
</ul>
<a id="i1011577"></a>
<div id="ADLOB45732" class="sect2">
<h3 class="sect2">Java (JDBC): Checking If a LOB Is Open</h3>
<p>Here is how to check a <code>BLOB</code> or a <code>CLOB</code>.</p>
<div id="ADLOB45733" class="sect3"><a id="sthref1074"></a>
<h4 class="sect3">Checking If a CLOB Is Open</h4>
<p>To see if a <code>CLOB</code> is open, your JDBC application can use the <code>isOpen</code> method defined in <code>oracle.sql.CLOB</code>. The return Boolean value indicates whether the <code>CLOB</code> has been previously opened or not. The <code>isOpen</code> method is defined as follows:</p>
<pre>
/** 
  * Check whether the CLOB is opened. 
  * @return true if the LOB is opened. 
  */ 
public boolean isOpen () throws SQLException
</pre>
<p>The usage example is:</p>
<pre>
CLOB clob = ... 
 // See if the CLOB is opened 
 boolean isOpen = clob.isOpen ();
...
</pre></div>
<!-- class="sect3" -->
<div id="ADLOB45734" class="sect3"><a id="sthref1075"></a>
<h4 class="sect3">Checking If a BLOB Is Open</h4>
<p>To see if a <code>BLOB</code> is open, your JDBC application can use the <code>isOpen</code> method defined in <code>oracle.sql.BLOB</code>. The return Boolean value indicates whether the <code>BLOB</code> has been previously opened or not. The <code>isOpen</code> method is defined as follows:</p>
<pre>
/** 
 * Check whether the BLOB is opened. 
 * @return true if the LOB is opened. 
 */ 
 public boolean isOpen () throws SQLException
</pre>
<p>The usage example is:</p>
<pre>
BLOB blob = ... 
// See if the BLOB is opened 
boolean isOpen = blob.isOpen ();
...
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1011921"></a>
<div id="ADLOB45735" class="sect1">
<h2 class="sect1">Displaying <a id="sthref1076"></a>LOB Data</h2>
<p>This section describes APIs that allow you to read LOB data. You can use this operation to read LOB data into a buffer. This is useful if your application requires displaying large amounts of LOB data or streaming data operations.</p>
<p class="subhead1"><a id="ADLOB45736"></a>Usage Notes</p>
<p>Note the following when using these APIs.</p>
<p class="subhead2"><a id="ADLOB45737"></a>Streaming Mechanism</p>
<p>The most efficient way to read large amounts of LOB data is to use <code><a id="sthref1077"></a><a id="sthref1078"></a>OCILobRead2</code>() with the streaming mechanism enabled.</p>
<p class="subhead2"><a id="ADLOB45738"></a>Amount Parameter</p>
<p>The value you pass for the amount parameter is restricted for the APIs described in <a href="#g1136086">Table 22-3</a>.</p>
<div id="ADLOB45739" class="tblformal">
<p class="titleintable"><a id="sthref1079"></a><a id="g1136086"></a>Table 22-3 Maximum LOB Size for Amount Parameter</p>
<table class="cellalignment905" title="Maximum LOB Size for Amount Parameter" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment899">
<th class="cellalignment906" id="r1c1-t9">Environment</th>
<th class="cellalignment906" id="r1c2-t9">Function</th>
<th class="cellalignment906" id="r1c3-t9">Value of amount parameter is limited to:</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment899">
<td class="cellalignment907" id="r2c1-t9" headers="r1c1-t9">
<p class="synopsis">DBMS_LOB</p>
</td>
<td class="cellalignment907" headers="r2c1-t9 r1c2-t9">
<p class="synopsis"><code>DBMS_LOB.READ</code></p>
</td>
<td class="cellalignment907" headers="r2c1-t9 r1c3-t9">
<p class="synopsis">The size of the buffer, 32Kbytes.</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r3c1-t9" headers="r1c1-t9">
<p class="synopsis">OCI</p>
</td>
<td class="cellalignment907" headers="r3c1-t9 r1c2-t9">
<p class="synopsis"><code>OCILobRead()</code></p>
<p class="synopsis">(For LOBs less than 4 gigabytes in size.)</p>
</td>
<td class="cellalignment907" headers="r3c1-t9 r1c3-t9">
<p class="synopsis"><code>UB4MAXVAL</code></p>
<p class="synopsis">Specifying this amount reads the entire file.</p>
</td>
</tr>
<tr class="cellalignment899">
<td class="cellalignment907" id="r4c1-t9" headers="r1c1-t9">
<p class="synopsis">OCI</p>
</td>
<td class="cellalignment907" headers="r4c1-t9 r1c2-t9">
<p class="synopsis"><code>OCILobRead2()</code></p>
<p class="synopsis">(For LOBs of any size.)</p>
</td>
<td class="cellalignment907" headers="r4c1-t9 r1c3-t9">
<p class="synopsis"><code>UB8MAXVAL</code></p>
<p class="synopsis">Specifying this amount reads the entire file.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead1"><a id="ADLOB45740"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" <span class="italic">&mdash;</span> OPEN, READ, CLOSE.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash;, OCILobOpen(), OCILobRead2(), OCILobClose().</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; LOB READ.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; <code>LOB READ</code></p>
</li>
<li>
<p>COM (OO4O) (Oracle Objects for OLE (OO4O) <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1011995"></a><a id="ADLOB45741"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>ldisplay.sql</code></p>
</li>
<li>
<p>OCI: <code>ldisplay.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided in this release.</p>
</li>
<li>
<p>COM (OO4O): <code>ldisplay.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>ldisplay.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1024873"></a>
<div id="ADLOB1018" class="sect1">
<h2 class="sect1">Reading <a id="sthref1080"></a>Data from a LOB</h2>
<p>This section describes how to read data from LOBs using <code>OCILobRead2()</code>.</p>
<p class="subhead1"><a id="ADLOB45742"></a>Usage Notes</p>
<p>Note the following when using this operation.</p>
<p class="subhead2"><a id="i1038677"></a><a id="ADLOB45743"></a>Streaming Read in OCI</p>
<p>The most efficient way to read large amounts of LOB data is to use <code><a id="sthref1081"></a>OCILobRead2()</code> with the streaming mechanism enabled using polling or callback. To do so, specify the starting point of the read using the <code>offset</code> parameter as follows:</p>
<pre>
ub8  char_amt =  0;
ub8  byte_amt =  0;
ub4  offset = 1000;

OCILobRead2(svchp, errhp, locp, &amp;byte_amt, &amp;char_amt, offset, bufp, bufl,
            OCI_ONE_PIECE, 0, 0, 0, 0);
</pre>
<p>When using <span class="italic"><a id="sthref1082"></a>polling mode</span>, be sure to look at the value of the <code>byte_amt</code> parameter after each <code>OCILobRead2()</code> call to see how many bytes were read into the buffer because the buffer may not be entirely full.</p>
<p>When using <span class="italic"><a id="sthref1083"></a>callbacks</span>, the <code>lenp</code> parameter, which is input to the callback, indicates how many bytes are filled in the buffer. Be sure to check the <code>lenp</code> parameter during your callback processing because the entire buffer may not be filled with data (see the <a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a><span class="italic">.</span>)</p>
<p class="subhead2"><a id="ADLOB45744"></a><a id="sthref1084"></a>Chunk Size</p>
<p>A chunk is one or more Oracle blocks. You can specify the chunk size for the BasicFiles LOB when creating the table that contains the LOB. This corresponds to the data size used by Oracle Database when accessing or modifying the LOB value. Part of the chunk is used to store system-related information and the rest stores the LOB value. The API you are using has a function that returns the amount of space used in the LOB chunk to store the LOB value. In PL/SQL use <code>DBMS_LOB.GETCHUNKSIZE</code>. In OCI, use <code>OCILobGetChunkSize()</code>. For SecureFiles, <code>CHUNK</code> is an advisory size and is provided for backward compatibility purposes.</p>
<p>To improve performance, you may run <code>write</code> requests using a multiple of the value returned by one of these functions. The reason for this is that you are using the same unit that the Oracle database uses when reading data from disk. If it is appropriate for your application, then you should batch reads until you have enough for an entire chunk instead of issuing several LOB read calls that operate on the same LOB chunk.</p>
<p class="subhead1"><a id="ADLOB45745"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" <span class="italic">&mdash;</span> <code>OPEN</code>, <code>GETCHUNKSIZE</code>, <code>READ</code>, <code>CLOSE</code>.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobOpen()</code>, <code>OCILobRead2()</code>, <code>OCILobClose()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; <code>LOB READ</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB READ</p>
</li>
<li>
<p>COM (OO4O) <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1012676"></a><a id="ADLOB45746"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lread.sql</code></p>
</li>
<li>
<p>OCI: <code>lread.c</code></p>
</li>
<li>
<p>COM (OO4O): <code>lread.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lread.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BACGDAJF"></a>
<div id="ADLOB45747" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1085"></a><a id="sthref1086"></a>LOB Array Read</h2>
<p>This section describes how to read LOB data for multiple locators in one round trip, using <code>OCILobArrayRead()</code>.</p>
<p class="subhead1"><a id="ADLOB45748"></a>Usage Notes</p>
<p>This function improves performance in reading LOBs in the size range less than about 512 Kilobytes. For an OCI application example, assume that the program has a prepared SQL statement such as:</p>
<pre>
SELECT lob1 FROM lob_table for UPDATE;
</pre>
<p>where <code>lob1</code> is the LOB column and <code>lob_array</code> is an array of define variables corresponding to a LOB column:</p>
<pre>
OCILobLocator * lob_array[10];

...
 for (i=0; i&lt;10, i++)        /* initialize array of locators */
    lob_array[i] = OCIDescriptorAlloc(..., OCI_DTYPE_LOB, ...);
 
...
 
OCIDefineByPos(..., 1, (dvoid *) lob_array, ... SQLT_CLOB, ...);
 
/* Execute the statement with iters = 10 to do an array fetch of 10 locators. */
OCIStmtExecute ( &lt;service context&gt;, &lt;statement handle&gt;, &lt;error handle&gt;,
                 10,    /* iters  */ 
                 0,     /* row offset */
                 NULL,  /* snapshot IN */
                 NULL,  /* snapshot out */
                 OCI_DEFAULT /* mode */);
...
 
  ub4 array_iter = 10;
  char  *bufp[10];
  oraub8 bufl[10];
  oraub8 char_amtp[10];
  oraub8 offset[10];  
 
 for (i=0; i&lt;10; i++)
  {
    bufp[i] = (char *)malloc(1000);
    bufl[i] = 1000;
    offset[i] = 1;
    char_amtp[i] = 1000;  /* Single byte fixed width char set. */
  } 
 
/* Read the 1st 1000 characters for all 10 locators in one
 * round trip. Note that offset and amount need not be 
 * same for all the locators. */
 
OCILobArrayRead(&lt;service context&gt;, &lt;error handle&gt;,
                &amp;array_iter, /* array size */
                lob_array,   /* array of locators */
                NULL,        /* array of byte amounts */
                char_amtp,   /* array of char amounts */
                offset,      /* array of offsets */
       (void **)bufp,        /* array of read buffers */
                bufl,        /* array of buffer lengths */
                OCI_ONE_PIECE,  /* piece information */
                NULL,           /* callback context */
                NULL,           /* callback function */
                0,              /* character set ID - default */
                SQLCS_IMPLICIT);/* character set form */
 
 ...
 
for (i=0; i&lt;10; i++)
  {
    /* Fill bufp[i] buffers with data to be written */
    strncpy (bufp[i], "Test Data------", 15);
    bufl[i] = 1000;
    offset[i] = 50;
    char_amtp[i] = 15;  /* Single byte fixed width char set. */
  } 
 
/* Write the 15 characters from offset 50 to all 10 
 * locators in one round trip. Note that offset and
 * amount need not be same for all the locators. */
 */
 
OCILobArrayWrite(&lt;service context&gt;, &lt;error handle&gt;,
                  &amp;array_iter, /* array size */
                  lob_array,   /* array of locators */
                  NULL,        /* array of byte amounts */
                  char_amtp,   /* array of char amounts */
                  offset,      /* array of offsets */
             (void **)bufp,    /* array of read buffers */
                  bufl,        /* array of buffer lengths */
                  OCI_ONE_PIECE,  /* piece information */
                  NULL,           /* callback context */
                  NULL,           /* callback function */
                  0,              /* character set ID - default */
                  SQLCS_IMPLICIT);/* character set form */
...
</pre>
<p class="subhead2"><a id="ADLOB45749"></a>Streaming Support</p>
<p>LOB array APIs can be used to read/write LOB data in multiple pieces. This can be done by using polling method or a callback function.Here data is read/written in multiple pieces sequentially for the array of locators. For polling, the API would return to the application after reading/writing each piece with the <code>array_iter</code> parameter (OUT) indicating the index of the locator for which data is read/written. With a callback, the function is called after reading/writing each piece with <code>array_iter</code> as IN parameter.</p>
<p>Note that:</p>
<ul>
<li>
<p>It is possible to read/write data for a few of the locators in one piece and read/write data for other locators in multiple pieces. Data is read/written in one piece for locators which have sufficient buffer lengths to accommodate the whole data to be read/written.</p>
</li>
<li>
<p>Your application can use different amount value and buffer lengths for each locator.</p>
</li>
<li>
<p>Your application can pass zero as the amount value for one or more locators indicating pure streaming for those locators. In the case of reading, LOB data is read to the end for those locators. For writing, data is written until <code>OCI_LAST_PIECE</code> is specified for those locators.</p>
</li>
</ul>
<p class="subhead2"><a id="ADLOB45750"></a>LOB Array Read in Polling Mode</p>
<p>The following example reads 10Kbytes of data for each of 10 locators with 1Kbyte buffer size. Each locator needs 10 pieces to read the complete data. <code>OCILobArrayRead()</code> must be called 100 (10*10) times to fetch all the data.First we call <code>OCILobArrayRead()</code> with <code>OCI_FIRST_PIECE</code> as <code>piece</code> parameter. This call returns the first 1K piece for the first locator.Next <code>OCILobArrayRead()</code> is called in a loop until the application finishes reading all the pieces for the locators and returns <code>OCI_SUCCESS</code>. In this example it loops 99 times returning the pieces for the locators sequentially.</p>
<pre>
/* Fetch the locators */ 
...
 
     /* array_iter parameter indicates the number of locators in the array read.
      * It is an IN parameter for the 1st call in polling and is ignored as IN
      * parameter for subsequent calls. As OUT parameter it indicates the locator
      * index for which the piece is read.
      */
 
     ub4    array_iter = 10;
     char  *bufp[10];
     oraub8 bufl[10];
     oraub8 char_amtp[10];
     oraub8 offset[10];
     sword  st;  
 
     for (i=0; i&lt;10; i++)
     {
       bufp[i] = (char *)malloc(1000);
       bufl[i] = 1000;
       offset[i] = 1;
       char_amtp[i] = 10000;       /* Single byte fixed width char set. */
     } 
 
     st =  OCILobArrayRead(&lt;service context&gt;, &lt;error handle&gt;,
                         &amp;array_iter, /* array size */
                         lob_array, /* array of locators */
                         NULL,      /* array of byte amounts */
                         char_amtp, /* array of char amounts */
                         offset,    /* array of offsets */
                (void **)bufp,      /* array of read buffers */
                         bufl,      /* array of buffer lengths */
                         OCI_FIRST_PIECE, /* piece information */
                         NULL,           /* callback context */
                         NULL,           /* callback function */
                         0,              /* character set ID - default */
                         SQLCS_IMPLICIT); /* character set form */
 
     /* First piece for the first locator is read here. 
      * bufp[0]          =&gt; Buffer pointer into which data is read.
      * char_amtp[0 ]    =&gt; Number of characters read in current buffer
      *
      */ 
 
     While ( st == OCI_NEED_DATA)
     {  
          st =  OCILobArrayRead(&lt;service context&gt;, &lt;error handle&gt;,
                          &amp;array_iter, /* array size */
                          lob_array, /* array of locators */
                          NULL,      /* array of byte amounts */
                          char_amtp, /* array of char amounts */
                          offset,    /* array of offsets */
                 (void **)bufp,      /* array of read buffers */
                          bufl,      /* array of buffer lengths */
                          OCI_NEXT_PIECE, /* piece information */
                          NULL,           /* callback context */
                          NULL,           /* callback function */
                          0,              /* character set ID - default */
                          SQLCS_IMPLICIT);
 
       /* array_iter returns the index of the current array element for which 
        * data is read. for example, aray_iter = 1 implies first locator,
        * array_iter = 2 implies second locator and so on.
        *
        * lob_array[ array_iter - 1]=&gt; Lob locator for which data is read. 
        * bufp[array_iter - 1]      =&gt; Buffer pointer into which data is read.
        * char_amtp[array_iter - 1] =&gt; Number of characters read in current buffer
        */
 
...
        /* Consume the data here */
...
     }
</pre>
<p class="subhead2"><a id="ADLOB45751"></a>LOB Array Read with Callback</p>
<p>The following example reads 10Kbytes of data for each of 10 locators with 1Kbyte buffer size. Each locator needs 10 pieces to read all the data. The callback function is called 100 (10*10) times to return the pieces sequentially.</p>
<pre>
/* Fetch the locators */ 
...
     ub4    array_iter = 10;
     char  *bufp[10];
     oraub8 bufl[10];
     oraub8 char_amtp[10];
     oraub8 offset[10];
     sword  st;  

     for (i=0; i&lt;10; i++)
     {
       bufp[i] = (char *)malloc(1000);
       bufl[i] = 1000;
       offset[i] = 1;
       char_amtp[i] = 10000;       /* Single byte fixed width char set. */
      }

      st =  OCILobArrayRead(&lt;service context&gt;, &lt;error handle&gt;,
                        &amp;array_iter, /* array size */
                        lob_array,   /* array of locators */
                        NULL,        /* array of byte amounts */
                        char_amtp,   /* array of char amounts */
                        offset,      /* array of offsets */
               (void **)bufp,        /* array of read buffers */
                        bufl,        /* array of buffer lengths */
                        OCI_FIRST_PIECE,  /* piece information */
                        ctx,              /* callback context */
                        cbk_read_lob,     /* callback function */
                        0,                /* character set ID - default */
                        SQLCS_IMPLICIT);
...
/* Callback function for LOB array read. */
sb4 cbk_read_lob(dvoid *ctxp, ub4 array_iter, CONST dvoid *bufxp, oraub8 len,
                 ub1 piece, dvoid **changed_bufpp, oraub8 *changed_lenp)
{  
   static ub4 piece_count = 0;
   piece_count++;  
   switch (piece)
   {
    case OCI_LAST_PIECE: 
      /*--- buffer processing code goes here ---*/ 
(void) printf("callback read the %d th piece(last piece) for %dth locator \n\n",
                piece_count, array_iter ); 
      piece_count = 0; 
      break; 
    case OCI_FIRST_PIECE: 
      /*--- buffer processing code goes here ---*/ 
      (void) printf("callback read the 1st piece for %dth locator\n",
                    array_iter); 
    /* --Optional code to set changed_bufpp and changed_lenp if the buffer needs
         to be changed dynamically --*/ 
      break; 
    case OCI_NEXT_PIECE: 
      /*--- buffer processing code goes here ---*/ 
      (void) printf("callback read the %d th piece for %dth locator\n",
                    piece_count, array_iter); 
      /* --Optional code to set changed_bufpp and changed_lenp if the  buffer
           must be changed dynamically --*/ 
      break; 
      default:
      (void) printf("callback read error: unkown piece = %d.\n", piece); 
      return OCI_ERROR; 
   } 
    return OCI_CONTINUE;
}
...
</pre>
<p class="subhead2"><a id="ADLOB45752"></a>Polling LOB Array Read</p>
<p>The next example is polling LOB data in <code>OCILobArrayRead()</code> with variable <code>amtp</code>, <code>bufl</code>, and <code>offset</code>.</p>
<pre>
/* Fetch the locators */ 
...
 
     ub4    array_iter = 10;
     char  *bufp[10];
     oraub8 bufl[10];
     oraub8 char_amtp[10];
     oraub8 offset[10];
     sword  st;  
 
     for (i=0; i&lt;10; i++)
     {
       bufp[i] = (char *)malloc(1000);
       bufl[i] = 1000;
       offset[i] = 1;
       char_amtp[i] = 10000;       /* Single byte fixed width char set. */
     }
 
     /* For 3rd locator read data in 500 bytes piece from offset 101. Amount
      * is 2000, that is, total number of pieces is 2000/500 = 4.
      */
     offset[2] = 101; bufl[2] = 500; char_amtp[2] = 2000;
     
     /* For 6th locator read data in 100 bytes piece from offset 51. Amount
      * is 0 indicating pure polling, that is, data is read till the end of
      * the LOB is reached.
      */
     offset[5] = 51;  bufl[5] = 100; char_amtp[5] = 0;
 
     /* For 8th locator read 100 bytes of data in one piece. Note amount 
      * is less than buffer length indicating single piece read.
      */ 
     offset[7] = 61;  bufl[7] = 200; char_amtp[7] = 100; 
 
     st =  OCILobArrayRead(&lt;service context&gt;, &lt;error handle&gt;,
                         &amp;array_iter, /* array size */
                         lob_array, /* array of locators */
                         NULL,      /* array of byte amounts */
                         char_amtp, /* array of char amounts */
                         offset,    /* array of offsets */
                (void **)bufp,      /* array of read buffers */
                         bufl,      /* array of buffer lengths */
                         OCI_FIRST_PIECE, /* piece information */
                         NULL,           /* callback context */
                         NULL,           /* callback function */
                         0,              /* character set ID - default */
                         SQLCS_IMPLICIT); /* character set form */
 
     /* First piece for the first locator is read here. 
      * bufp[0]          =&gt; Buffer pointer into which data is read.
      * char_amtp[0 ]    =&gt; Number of characters read in current buffer
      *
      */ 
 
     while ( st == OCI_NEED_DATA)
     {  
          st =  OCILobArrayRead(&lt;service context&gt;, &lt;error handle&gt;,
                          &amp;array_iter, /* array size */
                          lob_array, /* array of locators */
                          NULL,      /* array of byte amounts */
                          char_amtp, /* array of char amounts */
                          offset,    /* array of offsets */
                 (void **)bufp,      /* array of read buffers */
                          bufl,      /* array of buffer lengths */
                          OCI_NEXT_PIECE, /* piece information */
                          NULL,           /* callback context */
                          NULL,           /* callback function */
                          0,              /* character set ID - default */
                          SQLCS_IMPLICIT);
 
       /* array_iter returns the index of the current array element for which 
        * data is read. for example, aray_iter = 1 implies first locator,
        * array_iter = 2 implies second locator and so on.
        *
        * lob_array[ array_iter - 1]=&gt; Lob locator for which data is read. 
        * bufp[array_iter - 1]      =&gt; Buffer pointer into which data is read.
        * char_amtp[array_iter - 1]=&gt;Number of characters read in current buffer
        */
 
...
        /* Consume the data here */
...
     }
</pre>
<p class="subhead1"><a id="ADLOB45753"></a>Syntax</p>
<p>Use the following syntax references for the OCI programmatic environment:</p>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobArrayRead()</code>.</p>
<p class="subhead1"><a id="ADLOB45754"></a>Example</p>
<p>An example is provided in the following programmatic environment:</p>
<p>OCI: lreadarr.c</p>
</div>
<!-- class="sect1" -->
<a id="i1013268"></a>
<div id="ADLOB1019" class="sect1">
<h2 class="sect1">Reading a <a id="sthref1087"></a>Portion of a LOB (SUBSTR)</h2>
<p>This section describes how to read a portion of a LOB using SUBSTR.</p>
<p class="subhead1"><a id="ADLOB45755"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; SUBSTR, OPEN, CLOSE</p>
</li>
<li>
<p>C (OCI): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; <code>ALLOCATE, LOB OPEN, LOB READ, LOB CLOSE</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB READ. See PL/SQL <code>DBMS_LOB.SUBSTR</code>.</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1013330"></a><a id="ADLOB45756"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lsubstr.sql</code></p>
</li>
<li>
<p>OCI: No example is provided with this release.</p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>lsubstr.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lsubstr.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1013752"></a>
<div id="ADLOB1003" class="sect1">
<h2 class="sect1">Comparing <a id="sthref1088"></a>All or Part of Two LOBs</h2>
<p>This section describes how to compare all or part of two LOBs.</p>
<p class="subhead1"><a id="ADLOB45757"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; COMPARE.</p>
</li>
<li>
<p>C (OCI): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> or information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; EXECUTE. Also reference PL/SQL DBMS_LOB.COMPARE.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; EXECUTE. Also reference PL/SQL <code>DBMS_LOB.COMPARE</code>.</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1013814"></a><a id="ADLOB45758"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lcompare.sql</code></p>
</li>
<li>
<p>C (OCI): No example is provided with this release.</p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>lcompare.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lcompare.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1063011"></a>
<div id="ADLOB45759" class="sect1">
<h2 class="sect1"><a id="sthref1089"></a>Patterns: Checking for Patterns in a LOB Using INSTR</h2>
<p>This section describes how to see if a pattern exists in a LOB using <code>INSTR</code>.</p>
<p class="subhead1"><a id="ADLOB45760"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; INSTR.</p>
</li>
<li>
<p>C (OCI): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; EXECUTE. Also reference PL/SQL <code>DBMS_LOB.INSTR</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; EXECUTE. Also reference PL/SQL <code>DBMS_LOB.INSTR</code>.</p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1014312"></a><a id="ADLOB45761"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>linstr.sql</code></p>
</li>
<li>
<p>C (OCI): No example is provided with this release.</p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): No example is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): <code>linstr.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1014690"></a>
<div id="ADLOB1074" class="sect1">
<h2 class="sect1">Length: Determining the <a id="sthref1090"></a>Length of a LOB</h2>
<p>This section describes how to determine the length of a LOB.</p>
<p class="subhead1"><a id="ADLOB45762"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; GETLENGTH</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobGetLength2()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; LOB DESCRIBE.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB DESCRIBE ... GET LENGTH...</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1014757"></a><a id="ADLOB45763"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package) <code>llength.sql</code></p>
</li>
<li>
<p>OCI: <code>llength.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>llength.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>llength.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1015201"></a>
<div id="ADLOB1004" class="sect1">
<h2 class="sect1">Copying <a id="sthref1091"></a>All or Part of One LOB to Another LOB</h2>
<p>This section describes how to copy all or part of a LOB to another LOB. These APIs copy an amount of data you specify from a source LOB to a destination LOB.</p>
<p class="subhead1"><a id="ADLOB45764"></a>Usage Notes</p>
<p>Note the following issues when using this API.</p>
<p class="subhead2"><a id="ADLOB45765"></a>Specifying Amount of Data to Copy</p>
<p>The value you pass for the <code>amount</code> parameter to the <code>DBMS_LOB.COPY</code> function must be one of the following:</p>
<ul>
<li>
<p>An amount less than or equal to the actual size of the data you are loading.</p>
</li>
<li>
<p>The maximum allowable LOB size: <code>DBMS_LOB.LOBMAXSIZE</code><code>.</code>Passing this value causes the function to read the entire LOB. This is a useful technique for reading the entire LOB without introspecting the size of the LOB.</p>
</li>
</ul>
<p>Note that for character data, the amount is specified in characters, while for binary data, the amount is specified in bytes.</p>
<p class="subhead2"><a id="ADLOB45766"></a>Locking the Row Prior to <a id="sthref1092"></a>Updating</p>
<p>If you plan to update a LOB value, then you must lock the row containing the LOB prior to updating. <a id="sthref1093"></a>While the SQL <code>INSERT</code> and <code>UPDATE</code> statements implicitly lock the row, locking is done explicitly by means of a SQL <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement in SQL and PL/SQL programs, or by using an <code>OCI</code> <code>pin</code> or <code>lock</code> function in OCI programs.</p>
<p>For more details on the state of the locator after an update, refer to <a href="adlob_design.htm#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
<p class="subhead1"><a id="ADLOB45767"></a>Syntax</p>
<p>See the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; COPY</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobCopy2</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; <code>LOB COPY</code>. Also reference PL/SQL <code>DBMS_LOB.COPY</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> for information on embedded SQL statements and directives &mdash; <code>LOB COPY</code></p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1015281"></a><a id="ADLOB45768"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lcopy.sql</code></p>
</li>
<li>
<p>OCI: <code>lcopy.c</code></p>
</li>
<li>
<p>COM (OO4O): <code>lcopy.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lcopy.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1015853"></a>
<div id="ADLOB45769" class="sect1">
<h2 class="sect1">Copying a <a id="sthref1094"></a>LOB Locator</h2>
<p>This section describes how to copy a LOB locator. Note that different locators may point to the same or different data, or to current or outdated data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To assign one LOB to another using PL/SQL, use the <code>:=</code> operator. This is discussed in more detail in <a href="adlob_design.htm#CJHJBBIF">"Read-Consistent Locators"</a>.</div>
<p class="subhead1"><a id="ADLOB45770"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): Refer to <a href="adlob_design.htm#CJHJBBIF">"Read-Consistent Locators"</a> for information on assigning one lob locator to another.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobAssign()</code>, <code>OCILobIsEqual()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB Statements, and embedded SQL and precompiler directives &mdash; ALLOCATE, LOB ASSIGN.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; SELECT, LOB ASSIGN</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1015921"></a><a id="ADLOB45771"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lcopyloc.sql</code></p>
</li>
<li>
<p>OCI: <code>lcopyloc.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>lcopyloc.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lcopyloc.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1016375"></a>
<div id="ADLOB45772" class="sect1">
<h2 class="sect1">Equality: Checking If <a id="sthref1095"></a>One LOB Locator Is Equal to Another</h2>
<p>This section describes how to determine whether one LOB locator is equal to another. If two locators are equal, then this means that they refer to the same version of the LOB data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></p>
</li>
<li>
<p><a href="adlob_design.htm#CJHJBBIF">"Read-Consistent Locators"</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="ADLOB45773"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobAssign()</code>, <code>OCILobIsEqual()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; <code>LOB ASSIGN</code></p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1016439"></a><a id="ADLOB45774"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL: No example is provided with this release.</p>
</li>
<li>
<p>OCI: <code>lequal.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): No example is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): <code>lequal.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1016989"></a>
<div id="ADLOB45775" class="sect1">
<h2 class="sect1">Determining Whether LOB <a id="sthref1096"></a>Locator Is Initialized</h2>
<p>This section describes how to determine whether a LOB locator is initialized.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45776"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobLocatorIsInit()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++) <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives". See C(OCI), <code>OCILobLocatorIsInit()</code>.</p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>Java (JDBC): There is no applicable syntax reference for this use case.</p>
</li>
</ul>
<p class="subhead1"><a id="i1017041"></a><a id="ADLOB45777"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): No example is provided with this release.</p>
</li>
<li>
<p>OCI: <code>linit.c</code></p>
</li>
<li>
<p>C (OCCI)): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): No example is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): No example is provided with this release.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1017313"></a>
<div id="ADLOB1021" class="sect1">
<h2 class="sect1">Appending to <a id="sthref1097"></a>a LOB</h2>
<p>This section describes how to write-append the contents of a buffer to a LOB.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45778"></a>Usage Notes</p>
<p>Note the following issues regarding usage of this API.</p>
<p class="subhead2"><a id="ADLOB45779"></a><a id="sthref1098"></a>Writing Singly or Piecewise</p>
<p>The <code>writeappend</code> operation writes a buffer to the end of a LOB.</p>
<p>For OCI, the buffer can be written to the LOB in a single piece with this call; alternatively, it can be rendered piecewise using callbacks or a standard polling method.</p>
<p class="subhead2"><a id="ADLOB45780"></a>Writing Piecewise: When to Use <a id="sthref1099"></a>Callbacks or <a id="sthref1100"></a>Polling</p>
<p>If the value of the piece parameter is <code>OCI_FIRST_PIECE</code>, then data must be provided through callbacks or polling.</p>
<ul>
<li>
<p>If a callback function is defined in the <code>cbfp</code> parameter, then this callback function is called to get the next piece after a piece is written to the pipe. Each piece is written from <code>bufp</code>.</p>
</li>
<li>
<p>If no callback function is defined, then <code><a id="sthref1101"></a>OCILobWriteAppend2</code>() returns the <code>OCI_NEED_DATA</code> error code. The application must call <code>OCILobWriteAppend2</code>() again to write more pieces of the LOB. In this mode, the buffer pointer and the length can be different in each call if the pieces are of different sizes and from different locations. A piece value of <code>OCI_LAST_PIECE</code> terminates the piecewise write.</p>
</li>
</ul>
<p><a id="ADLOB45781"></a><span class="subhead3">Locking the Row Prior to Updating&nbsp;</span><a id="sthref1102"></a>Prior to updating a LOB value using the PL/SQL <code>DBMS_LOB</code> package or the OCI, you must lock the row containing the LOB. While the SQL <code>INSERT</code> and <code>UPDATE</code> statements implicitly lock the row, locking is done explicitly by means of an SQL <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement in SQL and PL/SQL programs, or by using an <code>OCI</code> <code>pin</code> or <code>lock</code> function in OCI programs.</p>
<p>For more details on the state of the locator after an update, refer to <a href="adlob_design.htm#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
<p class="subhead1"><a id="ADLOB45782"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> <span class="italic">"DBMS_LOB"</span> <span class="italic">&mdash;</span> <code>WRITEAPPEND</code></p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobWriteAppend2()</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; <code>LOB WRITE APPEND</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB WRITE APPEND</p>
</li>
<li>
<p>COM (OO4O): No syntax reference is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1017408"></a><a id="ADLOB45783"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lwriteap.sql</code></p>
</li>
<li>
<p>OCI: <code>lwriteap.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): No example is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): <code>lwriteap.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1017877"></a>
<div id="ADLOB1013" class="sect1">
<h2 class="sect1">Writing <a id="sthref1103"></a>Data to a LOB</h2>
<p>This section describes how to write the contents of a buffer to a LOB.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></p>
</li>
<li>
<p><a href="#i1024873">Reading Data from a LOB</a></p>
</li>
</ul>
</div>
<p class="subhead1"><a id="ADLOB45784"></a>Usage Notes</p>
<p>Note the following issues regarding usage of this API.</p>
<p class="subhead2"><a id="ADLOB45785"></a><a id="sthref1104"></a>Stream Write</p>
<p>The most efficient way to write large amounts of LOB data is to use <code>OCILobWrite2</code>() with the streaming mechanism enabled, and using polling or a callback. If you know how much data is written to the LOB, then specify that amount when calling <code>OCILobWrite2()</code>. This ensures that LOB data on the disk is contiguous. Apart from being spatially efficient, the contiguous structure of the LOB data makes reads and writes in subsequent operations faster.</p>
<p class="subhead2"><a id="ADLOB45786"></a><a id="sthref1105"></a>Chunk Size</p>
<p>A chunk is one or more Oracle blocks. You can specify the chunk size for the LOB when creating the table that contains the LOB. This corresponds to the data size used by Oracle Database when accessing or modifying the LOB value. Part of the chunk is used to store system-related information and the rest stores the LOB value. The API you are using has a function that returns the amount of space used in the LOB chunk to store the LOB value. In PL/SQL use <code>DBMS_LOB.GETCHUNKSIZE</code>. In OCI, use <code>OCILobGetChunkSize()</code>.</p>
<p class="subhead2"><a id="ADLOB45787"></a>Use a Multiple of the Returned Value to Improve Write Performance</p>
<p>To improve performance, run write requests using a multiple of the value returned by one of these functions. The reason for this is that the LOB chunk is versioned for every <code>write</code> operation. If all <code>writes</code> are done on a chunk basis, then no extra or excess versioning is incurred or duplicated. If it is appropriate for your application, then you should batch writes until you have enough for an entire chunk instead of issuing several LOB write calls that operate on the same LOB chunk.</p>
<p class="subhead2"><a id="ADLOB45788"></a>Locking the Row Prior to Updating</p>
<p><a id="sthref1106"></a>Prior to updating a LOB value using the PL/SQL <code>DBMS_LOB</code> Package or OCI, you must lock the row containing the LOB. While the SQL <code>INSERT</code> and <code>UPDATE</code> statements implicitly lock the row, locking is done explicitly by means of a SQL <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement in SQL and PL/SQL programs, or by using an <code>OCI</code> <code>pin</code> or <code>lock</code> function in OCI programs.</p>
<p>For more details on the state of the locator after an update, refer to <a href="adlob_design.htm#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
<p class="subhead2"><a id="i1017920"></a><a id="ADLOB45789"></a>Using <a id="sthref1107"></a>DBMS_LOB.WRITE to Write Data to a BLOB</p>
<p>When you are passing a <a id="sthref1108"></a>hexadecimal string to <a id="sthref1109"></a>DBMS_LOB.WRITE() to write data to a BLOB, use the following guidelines:</p>
<ul>
<li>
<p>The <code>amount</code> parameter should be &lt;= the buffer <code>length</code> parameter</p>
</li>
<li>
<p>The <code>length</code> of the buffer should be ((<code>amount</code>*2) - 1). This guideline exists because the two characters of the string are seen as one hexadecimal character (and an implicit hexadecimal-to-raw conversion takes place), that is, every two bytes of the string are converted to one raw byte.</p>
</li>
</ul>
<p>The following example is <span class="italic">correct</span>:</p>
<pre>
declare
   blob_loc  BLOB;
   rawbuf RAW(10);
   an_offset INTEGER := 1;
   an_amount BINARY_INTEGER := 10;
BEGIN
   select blob_col into blob_loc from a_table
where id = 1;
   rawbuf := '1234567890123456789';
   dbms_lob.write(blob_loc, an_amount, an_offset,
rawbuf);
   commit;
END;
</pre>
<pre>
</pre>
<p>Replacing the value for <code>an_amount</code> in the previous example with the following values, yields error message, ora_21560:</p>
<pre>
    an_amount BINARY_INTEGER := 11;
</pre>
<p>or</p>
<pre>
    an_amount BINARY_INTEGER := 19;
</pre>
<p class="subhead1"><a id="ADLOB45790"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> <span class="italic">"DBMS_LOB"</span> &mdash; WRITE</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobWrite2().</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; <code>LOB WRITE</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; <code>LOB</code> WRITE</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1017997"></a><a id="ADLOB45791"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lwrite.sql</code></p>
</li>
<li>
<p>OCI: <code>lwrite.c</code></p>
</li>
<li>
<p>COM (OO4O): <code>lwrite.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lwrite.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BACIEIJB"></a>
<div id="ADLOB45792" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref1110"></a><a id="sthref1111"></a>LOB Array Write</h2>
<p>This section describes how to write LOB data for multiple locators in one round trip, using <code>OCILobArrayWrite()</code>.</p>
<p class="subhead1"><a id="ADLOB45793"></a>Usage Notes</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BACGDAJF">"LOB Array Read"</a> for examples of array read/write.</div>
<p class="subhead2"><a id="ADLOB45794"></a>LOB Array Write in Polling Mode</p>
<p>The following example writes 10Kbytes of data for each of <code>10</code> locators with a 1K buffer size. <code>OCILobArrayWrite()</code> has to be called <code>100</code> (<code>10</code> times <code>10</code>) times to write all the data. The function is used in a similar manner to <code>OCILobWrite2()</code>.</p>
<pre>
/* Fetch the locators */
...
 
/* array_iter parameter indicates the number of locators in the array read.
 * It is an IN parameter for the 1st call in polling and is ignored as IN
 * parameter for subsequent calls. As an OUT parameter it indicates the locator
 * index for which the piece is written.
 */
 
ub4    array_iter = 10;
char  *bufp[10];
oraub8 bufl[10];
oraub8 char_amtp[10];
oraub8 offset[10];
sword  st;
int    i, j; 
 
for (i=0; i&lt;10; i++)
{
  bufp[i] = (char *)malloc(1000);
  bufl[i] = 1000;
  /* Fill bufp here. */
...
  offset[i] = 1;
  char_amtp[i] = 10000;       /* Single byte fixed width char set. */  
}
 
for (i  = 1; i &lt;= 10; i++)
{
 /* Fill up bufp[i-1] here.  The first piece for ith locator would be written from
    bufp[i-1] */
...
    st =  <span class="bold">OCILobArrayWrite</span>(&lt;service context&gt;, &lt;error handle&gt;,
                      &amp;array_iter, /* array size */
                      lob_array,   /* array of locators */
                      NULL,        /* array of byte amounts */
                      char_amtp,   /* array of char amounts */
                      offset,      /* array of offsets */
             (void **)bufp,        /* array of write buffers */
                      bufl,        /* array of buffer lengths */
                      OCI_FIRST_PIECE, /* piece information */
                      NULL,            /* callback context */
                      NULL,            /* callback function */
                      0,               /* character set ID - default */
                      SQLCS_IMPLICIT); /* character set form */
 
 for ( j = 2; j &lt; 10; j++) 
 {
 /* Fill up bufp[i-1] here.  The jth piece for ith locator would be written from
    bufp[i-1] */
...
 st =  <span class="bold">OCILobArrayWrite</span>(&lt;service context&gt;, &lt;error handle&gt;,
                        &amp;array_iter, /* array size */
                        lob_array,   /* array of locators */
                        NULL,        /* array of byte amounts */
                        char_amtp,   /* array of char amounts */
                        offset,      /* array of offsets */
               (void **)bufp,        /* array of write buffers */
                        bufl,        /* array of buffer lengths */
                        <span class="bold">OCI_NEXT_PIECE</span>, /* piece information */
                        NULL,           /* callback context */
                        NULL,           /* callback function */
                        0,              /* character set ID - default */
                        SQLCS_IMPLICIT);
 
    /* array_iter returns the index of the current array element for which
     * data is being written. for example, aray_iter = 1 implies first locator,
     * array_iter = 2 implies second locator and so on. Here i = array_iter.
     *
     * lob_array[ array_iter - 1] =&gt; Lob locator for which data is written.
     * bufp[array_iter - 1]       =&gt; Buffer pointer from which data is written.
     * char_amtp[ array_iter - 1] =&gt; Number of characters written in
     * the piece just written
     */
}

/* Fill up bufp[i-1] here.  The last piece for ith locator would be written from
   bufp[i -1] */
...       
 st =  OCILobArrayWrite(&lt;service context&gt;, &lt;error handle&gt;,
                        &amp;array_iter, /* array size */
                        lob_array,   /* array of locators */
                        NULL,        /* array of byte amounts */
                        char_amtp,   /* array of char amounts */
                        offset,      /* array of offsets */
               (void **)bufp,        /* array of write buffers */
                        bufl,        /* array of buffer lengths */
                        <span class="bold">OCI_LAST_PIECE</span>,  /* piece information */
                        NULL,            /* callback context */
                        NULL,            /* callback function */
                        0,               /* character set ID - default */
                        SQLCS_IMPLICIT);
}

...
</pre>
<p class="subhead2"><a id="ADLOB45795"></a>LOB Array Write with Callback</p>
<p>The following example writes 10Kbytes of data for each of 10 locators with a 1K buffer size. A total of 100 pieces must be written (10 pieces for each locator). The first piece is provided by the <code>OCILobArrayWrite()</code> call. The callback function is called 99 times to get the data for subsequent pieces to be written.</p>
<pre>
/* Fetch the locators */
...

    ub4    array_iter = 10;
    char  *bufp[10];
    oraub8 bufl[10];
    oraub8 char_amtp[10];
    oraub8 offset[10];
    sword  st; 
 
    for (i=0; i&lt;10; i++)
    {
      bufp[i] = (char *)malloc(1000);
      bufl[i] = 1000;
      offset[i] = 1;
      char_amtp[i] = 10000;       /* Single byte fixed width char set. */
    }
 
 st =  <span class="bold">OCILobArrayWrite</span>(&lt;service context&gt;, &lt;error handle&gt;,
                        &amp;array_iter, /* array size */
                        lob_array,   /* array of locators */
                        NULL,        /* array of byte amounts */
                        char_amtp,   /* array of char amounts */
                        offset,      /* array of offsets */
               (void **)bufp,        /* array of write buffers */
                        bufl,        /* array of buffer lengths */
                        <span class="bold">OCI_FIRST_PIECE</span>,  /* piece information */
                        ctx,              /* callback context */
                        cbk_write_lob     /* callback function */
                        0,                /* character set ID - default */
                        SQLCS_IMPLICIT);

...

/* Callback function for LOB array write. */
sb4 cbk_write_lob(dvoid *ctxp, <span class="bold">ub4 array_iter</span>, dvoid *bufxp, oraub8 *lenp,
                  ub1 *piecep, ub1 *changed_bufpp, oraub8 *changed_lenp)
{
 static ub4 piece_count = 0;
 piece_count++; 

 printf (" %dth piece written  for <span class="bold">%dth locator</span> \n\n", piece_count, <span class="bold">array_iter</span>);

 /*-- code to fill bufxp with data goes here. *lenp should reflect the  size and
  *   should be less than or equal to MAXBUFLEN -- */
 /* --Optional code to set changed_bufpp and changed_lenp if the buffer must
  *   be changed dynamically --*/

  if (this is the last data buffer for current locator)
     *piecep = <span class="bold">OCI_LAST_PIECE</span>;     
  else if (this is the first data buffer for the next locator)
     *piecep = <span class="bold">OCI_FIRST_PIECE</span>;
     piece_count = 0;
  else
     *piecep = <span class="bold">OCI_NEXT_PIECE</span>;
 
     return OCI_CONTINUE;
    }
...
</pre>
<p class="subhead2"><a id="ADLOB45796"></a>Polling LOB Data in Array Write</p>
<p>The next example is polling LOB data in <code>OCILobArrayWrite()</code> with variable <code>amtp</code>, <code>bufl</code>, and <code>offset</code>.</p>
<pre>
/* Fetch the locators */
...
 
ub4    array_iter = 10;
char  *bufp[10];
oraub8 bufl[10];
oraub8 char_amtp[10];
oraub8 offset[10];
sword  st;
int    i, j;
int piece_count; 
 
for (i=0; i&lt;10; i++)
{
  bufp[i] = (char *)malloc(1000);
  bufl[i] = 1000;
  /* Fill bufp here. */
...
  offset[i] = 1;
  char_amtp[i] = 10000;       /* Single byte fixed width char set. */  
}
 
     /* For 3rd locator write data in 500 bytes piece from offset 101. Amount
      * is 2000, that is, total number of pieces is 2000/500 = 4.
      */
     offset[2] = 101; bufl[2] = 500; char_amtp[2] = 2000;
     
     /* For 6th locator write data in 100 bytes piece from offset 51. Amount
      * is 0 indicating pure polling, that is, data is written 
      * till OCI_LAST_PIECE
      */
     offset[5] = 51;  bufl[5] = 100; char_amtp[5] = 0;
 
     /* For 8th locator write 100 bytes of data in one piece. Note amount 
      * is less than buffer length indicating single piece write.
      */ 
     offset[7] = 61;  bufl[7] = 200; char_amtp[7] = 100;
 
for (i  = 1; i &lt;= 10; i++)
{
 /* Fill up bufp[i-1] here.  The first piece for ith locator would be written from
    bufp[i-1] */
...
    /* Calculate number of pieces that must be written */
    piece_count = char_amtp[i-1]/bufl[i-1];
 
    /* Single piece case */
    if (char_amtp[i-1] &lt;= bufl[i-1])
      piece_count = 1;
 
    /* Zero amount indicates pure polling. So we can write as many
     * pieces as needed. Let us write 50 pieces.
     */
    if (char_amtp[i-1] == 0)
      piece_count = 50;
 
    st =  OCILobArrayWrite(&lt;service context&gt;, &lt;error handle&gt;,
                      &amp;array_iter, /* array size */
                      lob_array,   /* array of locators */
                      NULL,        /* array of byte amounts */
                      char_amtp,   /* array of char amounts */
                      offset,      /* array of offsets */
             (void **)bufp,        /* array of write buffers */
                      bufl,        /* array of buffer lengths */
                      OCI_FIRST_PIECE, /* piece information */
                      NULL,            /* callback context */
                      NULL,            /* callback function */
                      0,               /* character set ID - default */
                      SQLCS_IMPLICIT); /* character set form */
 
 for ( j = 2; j &lt; piece_count; j++) 
 {
   /* Fill up bufp[i-1] here. The jth piece for ith locator would be written
    * from bufp[i-1] */
...
   st =  OCILobArrayWrite(&lt;service context&gt;, &lt;error handle&gt;,
                          &amp;array_iter, /* array size */
                          lob_array,   /* array of locators */
                          NULL,        /* array of byte amounts */
                          char_amtp,   /* array of char amounts */
                          offset,      /* array of offsets */
                 (void **)bufp,        /* array of write buffers */
                          bufl,        /* array of buffer lengths */
                          OCI_NEXT_PIECE, /* piece information */
                          NULL,           /* callback context */
                          NULL,           /* callback function */
                          0,              /* character set ID - default */
                          SQLCS_IMPLICIT);
 
    /* array_iter returns the index of the current array element for which
     * data is being written. for example, aray_iter = 1 implies first locator,
     * array_iter = 2 implies second locator and so on. Here i = array_iter.
     *
     * lob_array[ array_iter - 1] =&gt; Lob locator for which data is written.
     * bufp[array_iter - 1]       =&gt; Buffer pointer from which data is written.
     * char_amtp[ array_iter - 1] =&gt; Number of characters written in
     * the piece just written
     */
}
 
/* Fill up bufp[i-1] here.  The last piece for ith locator would be written from
 * bufp[i -1] */
...
 
/* If piece_count is 1 it is a single piece write. */
if (piece_count[i] != 1)
  st =  OCILobArrayWrite(&lt;service context&gt;, &lt;error handle&gt;,
                          &amp;array_iter, /* array size */
                          lob_array,   /* array of locators */
                          NULL,        /* array of byte amounts */
                          char_amtp,   /* array of char amounts */
                          offset,      /* array of offsets */
                 (void **)bufp,        /* array of write buffers */
                          bufl,        /* array of buffer lengths */
                          OCI_LAST_PIECE,  /* piece information */
                          NULL,            /* callback context */
                          NULL,            /* callback function */
                          0,               /* character set ID - default */
                          SQLCS_IMPLICIT);
}
 
...
</pre>
<p class="subhead1"><a id="ADLOB45797"></a>Syntax</p>
<p>Use the following syntax references for the OCI programmatic environment:</p>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobArrayWrite()</code>.</p>
<p class="subhead1"><a id="ADLOB45798"></a>Example</p>
<p>An example is provided in the following programmatic environment:</p>
<p>OCI: lwritearr.c</p>
</div>
<!-- class="sect1" -->
<a id="i1028365"></a>
<div id="ADLOB1020" class="sect1">
<h2 class="sect1">Trimming <a id="sthref1112"></a>LOB Data</h2>
<p>This section describes how to trim a LOB to the size you specify.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45799"></a>Usage Notes</p>
<p>Note the following issues regarding usage of this API.</p>
<p class="subhead2"><a id="ADLOB45800"></a>Locking the Row Prior to <a id="sthref1113"></a>Updating</p>
<p><a id="sthref1114"></a>Prior to updating a LOB value using the PL/SQL <code>DBMS_LOB</code> Package, or OCI, you must lock the row containing the LOB. While the SQL <code>INSERT</code> and <code>UPDATE</code> statements implicitly lock the row, locking is done explicitly by means of:</p>
<ul>
<li>
<p>A <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement in SQL and PL/SQL programs.</p>
</li>
<li>
<p>An <code>OCI</code> <code>pin</code> or <code>lock</code> function in OCI programs.</p>
</li>
</ul>
<p>For more details on the state of the locator after an update, refer to <a href="adlob_design.htm#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
<p class="subhead1"><a id="ADLOB45801"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> <span class="italic">"DBMS_LOB"</span> &mdash; <code>TRIM</code></p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobTrim2().</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; <code>LOB TRIM</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL and Precompiler Directives" &mdash; <code>LOB TRIM</code></p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a> Chapter 7, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="ADLOB45802"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>ltrim.sql</code></p>
</li>
<li>
<p>OCI: <code>ltrim.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>ltrim.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>ltrim.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1019599"></a>
<div id="ADLOB1006" class="sect1">
<h2 class="sect1">Erasing <a id="sthref1115"></a>Part of a LOB</h2>
<p>This section describes how to erase part of a LOB.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45803"></a>Usage Notes</p>
<p>Note the following issues regarding usage of this API.</p>
<p class="subhead2"><a id="ADLOB45804"></a>Locking the Row Prior to <a id="sthref1116"></a>Updating</p>
<p><a id="sthref1117"></a>Prior to updating a LOB value using the PL/SQL <code>DBMS_LOB</code> Package or OCI, you must lock the row containing the LOB. While <code>INSERT</code> and <code>UPDATE</code> statements implicitly lock the row, locking is done explicitly by means of a <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement in SQL and PL/SQL programs, or by using the <code>OCI</code> <code>pin</code> or <code>lock</code> function in OCI programs.</p>
<p>For more details on the state of the locator after an update, refer to<a href="adlob_design.htm#i1006580">"Example of Updating LOBs Through Updated Locators"</a>.</p>
<p class="subhead1"><a id="ADLOB45805"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; ERASE</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCILobErase2()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; <code>LOB ERASE</code>.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL and Precompiler Directives" &mdash; <code>LOB ERASE</code></p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference,</span></a> "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1019679"></a><a id="ADLOB45806"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>lerase.sql</code></p>
</li>
<li>
<p>OCI: <code>lerase.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>lerase.bas</code></p>
</li>
<li>
<p>Java (JDBC): <code>lerase.java</code></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1020156"></a>
<div id="ADLOB45807" class="sect1">
<h2 class="sect1">Enabling <a id="sthref1118"></a>LOB Buffering</h2>
<p>This section describes how to enable LOB buffering.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45808"></a>Usage Notes</p>
<p>Enable LOB buffering when you are performing a <a id="sthref1119"></a><a id="sthref1120"></a>small read or write of data. Once you have completed these tasks, you must disable buffering before you can continue with any other LOB operations.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>You must flush the buffer in order to make your modifications persistent.</p>
</li>
<li>
<p>Do not enable buffering for the <a id="sthref1121"></a>stream read and write involved in checkin and checkout.</p>
</li>
</ul>
</div>
<p>For more information, refer to <a href="adlob_design.htm#i1006095">"LOB Buffering Subsystem"</a>.</p>
<p class="subhead1"><a id="ADLOB45809"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL: This API is not available in any supplied PL/SQL packages.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCIEnableLobBuffering()</code>, <code>OCIDisableLobBuffering()</code>, <code>OCIFlushBuffer()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; LOB ENABLE BUFFERING.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL and Precompiler Directives" &mdash; <code>LOB ENABLE BUFFERING</code></p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): There is no applicable syntax reference for this use case.</p>
</li>
</ul>
<p class="subhead1"><a id="i1020227"></a><a id="ADLOB45810"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL: No example is provided.</p>
</li>
<li>
<p>C (OCI): No example is provided with this release. Using this API is similar to that described in the example, <a href="#i1020912">"Disabling LOB Buffering"</a>.</p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>lenbuf.bas</code></p>
</li>
<li>
<p>Java (JDBC): No example provided.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1020542"></a>
<div id="ADLOB45811" class="sect1">
<h2 class="sect1">Flu<a id="sthref1122"></a>shing the Buffer</h2>
<p>This section describes how to flush the LOB buffer.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45812"></a>Usage Notes</p>
<p>Enable buffering when performing a small read or write of data. Once you have completed these tasks, you must disable buffering before you can continue with any other LOB operations.</p>
<div class="infobox-note">
<p class="notep1">Notes:</p>
<ul>
<li>
<p>You must flush the buffer in order to make your modifications persistent.</p>
</li>
<li>
<p>Do not enable buffering for the stream read and write involved in checkin and checkout.</p>
</li>
</ul>
</div>
<p>For more information, refer to <a href="adlob_design.htm#i1006095">"LOB Buffering Subsystem"</a>.</p>
<p class="subhead1"><a id="ADLOB45813"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCIEnableLobBuffering(), OCIDisableLobBuffering(), OCIFlushBuffer().</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; LOB FLUSH BUFFER.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB FLUSH BUFFER.</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): There is no applicable syntax reference for this use case.</p>
</li>
</ul>
<p class="subhead1"><a id="i1020611"></a><a id="ADLOB45814"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): No example is provided with this release.</p>
</li>
<li>
<p>C (OCI): No example is provided with this release. Using this API is similar to that described in the example, <a href="#i1020912">"Disabling LOB Buffering"</a>.</p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): No example is provided with this release.</p>
</li>
<li>
<p>Java (JDBC): No example is provided with this release.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1020912"></a>
<div id="ADLOB45815" class="sect1">
<h2 class="sect1">Disabling <a id="sthref1123"></a>LOB Buffering</h2>
<p>This section describes how to disable LOB buffering.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45816"></a>Usage Notes</p>
<p>Enable buffering when performing a small read or write of data. Once you have completed these tasks, you must disable buffering before you can continue with any other LOB operations.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>You must flush the buffer in order to make your modifications persistent.</p>
</li>
<li>
<p>Do not enable buffering for the stream read and write involved in checkin and checkout.</p>
</li>
</ul>
</div>
<p>For more information, refer to <a href="adlob_design.htm#i1006095">"LOB Buffering Subsystem"</a></p>
<p class="subhead1"><a id="ADLOB45817"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package)<span class="italic">:</span> There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; <code>OCIEnableLobBuffering()</code>, <code>OCIDisableLobBuffering()</code>, <code>OCIFlushBuffer()</code>.</p>
</li>
<li>
<p>C++ (OCCI): <a class="olink LNCPP" href="../e10764/toc.htm"><span class="italic">Oracle C++ Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; LOB DISABLE BUFFER.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC" href="../../appdev.112/e10825/toc.htm"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB DISABLE BUFFER</p>
</li>
<li>
<p>COM (OO4O): <a class="olink OOFOL" href="../../win.112/e17727/toc.htm"><span class="italic">Oracle Objects for OLE Developer's Guide</span></a></p>
</li>
<li>
<p>Java (JDBC): There is no applicable syntax reference for this use case.</p>
</li>
</ul>
<p class="subhead1"><a id="i1020986"></a><a id="ADLOB45818"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): No example is provided with this release.</p>
</li>
<li>
<p>OCI: <code>ldisbuf.c</code></p>
</li>
<li>
<p>C++ (OCCI): No example is provided with this release.</p>
</li>
<li>
<p>COM (OO4O): <code>ldisbuf.bas</code></p>
</li>
<li>
<p>Java (JDBC): No example is provided with this release.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1021396"></a>
<div id="ADLOB1015" class="sect1">
<h2 class="sect1">Determining Whether a <a id="sthref1124"></a>LOB instance Is Temporary</h2>
<p>This section describes how to determine whether a LOB instance is temporary.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1098343">Table 22-1, "Environments Supported for LOB APIs"</a></div>
<p class="subhead1"><a id="ADLOB45819"></a>Syntax</p>
<p>Use the following syntax references for each programmatic environment:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB): <a class="olink ARPLS600" href="../../appdev.112/e40758/d_lob.htm#ARPLS600"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> "DBMS_LOB" &mdash; ISTEMPORARY, FREETEMPORARY</p>
</li>
<li>
<p>C (OCI): <a class="olink LNOCI160" href="../../appdev.112/e10646/oci17msc.htm#LNOCI160"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> "LOB Functions" &mdash; OCILobIsTemporary().</p>
</li>
<li>
<p>COBOL (Pro*COBOL) <a class="olink LNPCB" href="../../appdev.112/e10826/toc.htm"><span class="italic">Pro*COBOL Programmer's Guide</span></a> for information on LOBs, usage notes on LOB statements, and embedded SQL and precompiler directives &mdash; LOB DESCRIBE, ISTEMPORARY.</p>
</li>
<li>
<p>C/C++ (Pro*C/C++): <a class="olink LNPCC02012" href="../../appdev.112/e10825/pc_afemb.htm#LNPCC02012"><span class="italic">Pro*C/C++ Programmer's Guide</span></a> Appendix F, "Embedded SQL Statements and Directives" &mdash; LOB DESCRIBE...ISTEMPORARY</p>
</li>
<li>
<p>COM (OO4O): There is no applicable syntax reference for this use case.</p>
</li>
<li>
<p>Java (JDBC): <a class="olink JJDBC15000" href="../../java.112/e16548/oralob.htm#JJDBC15000"><span class="italic">Oracle Database JDBC Developer's Guide and Reference</span></a>, "Working With LOBs" &mdash; Creating and Populating a <code>BLOB</code> or <code>CLOB</code> Column.</p>
</li>
</ul>
<p class="subhead1"><a id="i1021463"></a><a id="ADLOB45820"></a>Examples</p>
<p>Examples are provided in the following programmatic environments:</p>
<ul>
<li>
<p>PL/SQL (DBMS_LOB Package): <code>listemp.sql</code></p>
</li>
<li>
<p>OCI: <code>listemp.c</code></p>
</li>
<li>
<p>COM (OO4O): No example is provided.</p>
</li>
</ul>
<div id="ADLOB45821" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1125"></a>
<h3 class="sect2">Java (JDBC): <a id="sthref1126"></a><a id="sthref1127"></a>Determining Whether a BLOB Is Temporary</h3>
<p>To see if a <code>BLOB</code> is temporary, the JDBC application can either use the <code>isTemporary</code> instance method to determine whether the current <code>BLOB</code> object is temporary, or pass the <code>BLOB</code> object to the static <code>isTemporary</code> method to determine whether the specified <code>BLOB</code> object is temporary. These two methods are defined in<code>listempb.java</code>.</p>
<p>This JDBC API replaces previous work-arounds that use <code><a id="sthref1128"></a>DBMS_LOB.isTemporary().</code></p>
<p>To determine whether a <code>CLOB</code> is temporary, the JDBC application can either use the <code>isTemporary</code> instance method to determine whether the current <code>CLOB</code> object is temporary, or pass the <code>CLOB</code> object to the static isTemporary method. These two methods are defined in <code>listempc.java</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1065193"></a>
<div id="ADLOB45822" class="sect1">
<h2 class="sect1">Converting a BLOB to a CLOB</h2>
<p>You can convert a <code>BLOB</code> instance to a <code>CLOB</code> using the PL/SQL procedure <code>DBMS_LOB.CONVERTTOCLOB</code>. This technique is convenient if you have character data stored in binary format that you want to store in a <code>CLOB</code>. You specify the character set of the binary data when calling this procedure. See <a class="olink ARPLS602" href="../../appdev.112/e40758/d_lob.htm#ARPLS602"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details on syntax and usage of this procedure.</p>
</div>
<!-- class="sect1" -->
<a id="i1065206"></a>
<div id="ADLOB45823" class="sect1">
<h2 class="sect1">Converting a CLOB to a BLOB</h2>
<p>You can convert a <code>CLOB</code> instance to a <code>BLOB</code> instance using the PL/SQL procedure <code>DBMS_LOB.CONVERTTOBLOB</code>. This technique is a convenient way to convert character data to binary data using LOB APIs. See <a class="olink ARPLS603" href="../../appdev.112/e40758/d_lob.htm#ARPLS603"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details on syntax and usage of this procedure.</p>
</div>
<!-- class="sect1" -->
<a id="BACEDAEH"></a>
<div id="ADLOB45824" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Ensuring Read Consistency</h2>
<p>This script can be used to ensure that hot backups can be taken of tables that have <code>NOLOGGING</code> or <code>FILESYSTEM_LIKE_LOGGING</code> LOBs and have a known recovery point with no read inconsistencies:</p>
<pre>
ALTER DATABASE FORCE LOGGING;
SELECT CHECKPOINT_CHANGE# FROM V$DATABASE;  --Start SCN
</pre>
<pre>
</pre>
<p>SCN (System Change Number) is a stamp that defines a version of the database at the time that a transaction is committed.</p>
<p>Perform the backup.</p>
<p>Run the next script:</p>
<pre>
ALTER SYSTEM CHECKPOINT GLOBAL;
SELECT CHECKPOINT_CHANGE# FROM V$DATABASE;  --End SCN
ALTER DATABASE NO FORCE LOGGING;
</pre>
<p>Back up the archive logs generated by the database. At the minimum, archive logs between start SCN and end SCN (including both SCN points) must be backed up.</p>
<p>To restore to a point with no read inconsistency, restore to end SCN as your incomplete recovery point. If recovery is done to an SCN after end SCN, there can be read inconsistency in the <code>NOLOGGING</code> LOBs.</p>
<p>For SecureFiles, if a read inconsistency is found during media recovery, the database treats the inconsistent blocks as holes and fills <code>BLOB</code>s with <code>0</code>'s and <code>CLOB</code>s with fill characters.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment898">
<tr>
<td class="cellalignment907">
<table class="cellalignment903">
<tr>
<td class="cellalignment902"><a href="adlob_bfile_ops.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment902"><a href="adlob_demo.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment909">
<table class="cellalignment901">
<tr>
<td class="cellalignment902"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment902"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment902"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment902"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment902"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment902"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
