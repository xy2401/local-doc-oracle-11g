<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using Oracle XML&nbsp;DB</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:11Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="xdb02rep.htm" title="Previous" type="text/html" />
<link rel="Next" href="partpg2.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='xdb03usg'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADXDB0300" class="chapter"><a id="g1055369"></a>
<h1 class="chapter"><span class="secnum">3</span> Using Oracle XML&nbsp;DB</h1>
<p>This chapter is an overview of how to use Oracle XML&nbsp;DB. The examples presented here illustrate techniques for accessing and managing XML content in purchase-order documents. Purchase orders are highly structured documents, but you can use the techniques shown here to also work with XML documents that have little structure.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#BABEHIJG">Storing XML Data as XMLType</a></p>
</li>
<li>
<p><a href="#CEGDFBAJ">Creating XMLType Tables and Columns</a></p>
</li>
<li>
<p><a href="#CHDJHDBI">Partitioning or Constraining Binary XML Data using Virtual Columns</a></p>
</li>
<li>
<p><a href="#BABIFADB">Loading XML Content into Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#CHDCJDEH">Character Sets of XML Documents</a></p>
</li>
<li>
<p><a href="#i1040530">Overview of the W3C XML Schema Recommendation</a></p>
</li>
<li>
<p><a href="#BABDADEB">Using XML Schema with Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BABBGBDA">Identifying XML Schema Instance Documents</a></p>
</li>
<li>
<p><a href="#BABECCBG">Enforcing XML Data Integrity using the Database</a></p>
</li>
<li>
<p><a href="#BABIEGGG">DML Operations on XML Content using Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BABDGDJG">Querying XML Content Stored in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BABFCJHC">Accessing XML Data in Oracle XML&nbsp;DB using Relational Views</a></p>
</li>
<li>
<p><a href="#BABBEDFD">Updating XML Content Stored in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BABJCAAJ">Namespace Support in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BABDBEFG">How Oracle XML&nbsp;DB Processes XMLType Methods and SQL Functions</a></p>
</li>
<li>
<p><a href="#BABFACEG">Generating XML Data from Relational Data</a></p>
</li>
<li>
<p><a href="#BABDIDHA">XSL Transformation and Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BABEDIHI">Using Oracle XML&nbsp;DB Repository</a></p>
</li>
<li>
<p><a href="#BABCEEHI">Viewing Relational Data as XML From a Browser</a></p>
</li>
<li>
<p><a href="#BABCBECF">XSL Transformation using DBUri Servlet</a></p>
</li>
</ul>
<a id="BABEHIJG"></a>
<div id="ADXDB4040" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Storing XML Data as XMLType</h2>
<p>Before the introduction of Oracle XML&nbsp;DB, there were two ways to store XML content in Oracle Database:</p>
<ul>
<li>
<p>Use Oracle XML Developer's Kit (XDK) to parse the XML document outside Oracle Database, and store the extracted XML data as rows in one or more tables in the database.</p>
</li>
<li>
<p>Store the XML document in Oracle Database using a Character Large Object (<code>CLOB</code>), Binary Large Object (<code>BLOB</code>), Binary File (<code>BFILE</code>), or <code>VARCHAR</code> column.</p>
</li>
</ul>
<p>In both cases, Oracle Database is unaware that it is managing XML content.</p>
<p>Oracle XML&nbsp;DB and the <code>XMLType</code> abstract data type make Oracle Database XML-aware. Storing XML data as an <code>XMLType</code> column or table lets the database perform XML-specific operations on the content. This includes XML validation and optimization. <code>XMLType</code> storage allows highly efficient processing of XML content in the database.</p>
<div id="ADXDB4041" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref164"></a>
<h3 class="sect2">What is XMLType?</h3>
<p><code>XMLType</code> is an abstract data type for native handling of XML data in the database.</p>
<ul>
<li>
<p><code>XMLType</code> has built-in methods to create, extract, and index database XML data.</p>
</li>
<li>
<p><code>XMLType</code> provides SQL access to XML data.</p>
</li>
<li>
<p><code>XMLType</code> functionality is also available through a set of Application Program Interfaces (APIs) provided in PL/SQL and Java. <code>XMLType</code> can be used in PL/SQL stored procedures for parameters, return values, and variables.</p>
</li>
</ul>
<p>Using <code>XMLType</code>, SQL developers can leverage the power of the relational database while working in the context of XML. XML developers can leverage the power of XML standards while working in the context of a relational database.</p>
<p><code>XMLType</code> can be used as the data type of columns in tables and views. <code>XMLType</code> variables can be used in PL/SQL stored procedures as parameters and return values. You can also use <code>XMLType</code> in SQL, PL/SQL, C, Java (through JDBC), and Oracle Data Provider for .NET (ODP.NET).</p>
<p>The <code>XMLType</code> API provides several useful methods that operate on XML content. For example, method <code>extract()</code> extracts one or more nodes from an <code>XMLType</code> instance.</p>
<p>Oracle XML&nbsp;DB functionality is based on the Oracle XML Developer's Kit C implementations of the relevant XML standards such as XML Parser, XML DOM, and XML Schema Validator.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb01int.htm#BABCCCJI">"XMLType Data Type"</a></p>
</li>
<li>
<p><a href="xdb01int.htm#BABECDCF">"XMLType Storage Models"</a> for the available <code>XMLType</code> storage options and their relative advantages</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4042" class="sect2"><a id="sthref165"></a>
<h3 class="sect2">Benefits of <a id="sthref166"></a>XMLType Data Type and API</h3>
<p>The <code>XMLType</code> data type and application programming interface (API) enable SQL operations on XML content and XML operations on SQL content:</p>
<ul>
<li>
<p>Versatile API &ndash; <code>XMLType</code> has a versatile API for application development that includes built-in functions, indexing, and navigation support.</p>
</li>
<li>
<p><code>XMLType</code> and SQL &ndash; You can use <code>XMLType</code> in SQL statements, combined with other data types. For example, you can query <code>XMLType</code> columns and join the result of the extraction with a relational column. Oracle Database determines an optimal way to run such queries.</p>
</li>
<li>
<p><a id="sthref167"></a>Indexing &ndash; You can created several kinds of indexes to improve the performance of queries on XML data.</p>
<ul>
<li>
<p>For structured storage of <code>XMLType</code> data, you can create B-tree indexes and function-based indexes on the object-relational tables that underlie <code>XMLType</code> tables and columns. Create function-based indexes only on scalar data, that is, columns that represent singleton elements or attributes.</p>
</li>
<li>
<p>For unstructured and binary XML storage of <code>XMLType</code> data, you can create an <code>XMLIndex</code> index, which specifically targets the XML structure of a document.</p>
</li>
<li>
<p>You can index the textual content of XML data with an Oracle Text <code>CONTEXT</code> index, for use in full-text search. This applies to all <code>XMLType</code> storage models.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CEGDFBAJ"></a>
<div id="ADXDB4044" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Creating XMLType Tables and Columns</h2>
<p><code>XMLType</code> is an abstract data type, so it is straightforward to create an <code>XMLType</code> table or column. The basic <code><a id="sthref168"></a><a id="sthref169"></a>CREATE TABLE</code> statement, specifying no storage options and no XML schema, stores <code>XMLType</code> data as binary XML.<a id="sthref170" href="#sthref170" onclick='footdisplay(1,"The \u003ccode\u003eXMLType\u003c/code\u003e storage model for XML schema-based data is whatever was specified during registration of the referenced XML schema. If no storage model was specified during registration, then binary XML storage is used.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
<p><a href="#BJFCFCDG">Example 3-1</a> creates an <code>XMLType</code> column, and <a href="#BJFJACCB">Example 3-2</a> creates an <code>XMLType</code> table.</p>
<div id="ADXDB5801" class="example">
<p class="titleinexample"><a id="BJFCFCDG"></a>Example 3-1 Creating a Table with an XMLType Column</p>
<pre>
CREATE TABLE mytable1 (key_column VARCHAR2(10) PRIMARY KEY, xml_column <span class="bold">XMLType</span>);
</pre></div>
<!-- class="example" -->
<div id="ADXDB5802" class="example">
<p class="titleinexample"><a id="BJFJACCB"></a>Example 3-2 Creating a Table of XMLType</p>
<pre>
CREATE TABLE mytable2 OF <span class="bold">XMLType</span>;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb05sto.htm#i1042421">"Creating XMLType Tables and Columns Based on XML Schemas"</a></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create an <code>XMLType</code> table in a different database schema from your own, you must have not only privilege <code>CREATE ANY TABLE</code> but also privilege <code>CREATE ANY INDEX</code>. This is because a unique index is created on column <code>OBJECT_ID</code> when you create the table. Column <code>OBJECT_ID</code> stores a system-generated object identifier.</div>
</div>
<!-- class="sect1" -->
<a id="CHDJHDBI"></a>
<div id="ADXDB0310" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Partitioning or <a id="sthref171"></a>Constraining Binary XML Data using Virtual Columns</h2>
<p>XML data has its own structure, which, except for object-relational storage of <code>XMLType</code>, is not reflected directly in database data structure. That is, individual XML elements and attributes are not mapped to individual database columns or tables.</p>
<p>Therefore, to constrain or partition XML data according to the values of individual elements or attributes, the standard approach for relational data does not apply. Instead, you must create <span class="italic">virtual columns</span> that represent the XML data of interest, and then use those virtual columns to define the constraints or partitions that you need.</p>
<p>This approach applies only to XML data that is stored as <span class="italic">binary XML</span>. For XML data that uses unstructured storage, the database has no knowledge of the XML structure&thinsp;&mdash;the data is treated as flat text, but for binary XML storage that structure is known. You can exploit this structural knowledge to create virtual columns, which the database can then use with constraints or partitions.</p>
<p>The technique is as follows:</p>
<ol>
<li>
<p>Define virtual columns that correspond to the XML data that you are interested in.</p>
</li>
<li>
<p>Use those columns to partition or constrain the <code>XMLType</code> data as a whole.</p>
</li>
</ol>
<p>You create virtual columns on <code>XMLType</code> data as you would create virtual columns using any other type of data, but using a slightly different syntax. In particular, you cannot specify any constraints in association with the column definition.</p>
<p>Because <code>XMLType</code> is an abstract data type, if you create virtual columns on an <code>XMLType</code> table then those columns are <span class="italic">hidden</span>. They do not show up in <code>DESCRIBE</code> statements, for example. This hiding enables tools that use operations such as <code>DESCRIBE</code> to function normally and not be misled by the virtual columns.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Partitioning of binary XML tables is supported starting with 11g Release 2 (11.2). It is supported only if the database compatibility (parameter <code>compatible</code> in file <code>init.ora</code>) is 11.2 or higher.</p>
</li>
<li>
<p>Range, hash, and list partitioning are supported.</p>
</li>
<li>
<p>You can partition an <code>XMLType</code> <span class="italic">table</span> using a virtual column. You cannot partition a relational table that has an <code>XMLType</code> <span class="italic">column</span>, using that column to define virtual columns of XML data.</p>
</li>
</ul>
</div>
<p>You create a virtual column based on an XML element or attribute by defining it in terms of a SQL expression that involves that element or attribute. The column is thus function-based. You use SQL/XML functions <code>XMLCast</code> and <code>XMLQuery</code> to do this, as shown in <a href="#CHDDCBHA">Example 3-3</a>. The XQuery expression argument to function <code>XMLQuery</code> must be a simple XPath expression that uses only the child and attribute axes.</p>
<div id="ADXDB4047" class="example">
<p class="titleinexample"><a id="CHDDCBHA"></a>Example 3-3 Partitioning a Binary XML Table using Virtual Columns</p>
<pre>
CREATE TABLE po_binaryxml OF XMLType
  XMLTYPE STORE AS BINARY XML
  VIRTUAL COLUMNS
    (DATE_COL AS (XMLCast(XMLQuery('/PurchaseOrder/@orderDate'
                                   PASSING OBJECT_VALUE RETURNING CONTENT)
                          AS DATE)))
  PARTITION BY RANGE (DATE_COL)
    (PARTITION orders2001 VALUES LESS THAN (to_date('01-JAN-2002')),
     PARTITION orders2002 VALUES LESS THAN (MAXVALUE));
</pre></div>
<!-- class="example" -->
<p><a href="#CHDDCBHA">Example 3-3</a> partitions an <code>XMLType</code> table using a virtual column, <code>DATE_COL</code>, which targets the <code>orderDate</code> element in a purchase-order document.</p>
<p>To use a virtual column for partitioning, its data type must be constant. In the case where the <code>XMLType</code> data in the column or table is mixed, some documents being encoded using an XML schema and others being encoded without using any schema, you must cast the functional expression, to ensure that the same data type is used for all rows in the virtual column.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For best performance, choose, as the partitioning key, an XPath expression whose target occurs within 32 K bytes of the beginning of the XML document.</div>
<p>You define constraints on binary XML data similarly. See <a href="#CHDGIABF">Example 3-20</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_indexing.htm#CHDBBCEF">"XMLIndex Partitioning and Parallelism"</a></p>
</li>
<li>
<p><a href="#CHDIGJDE">"Enforcing Referential Integrity using SQL Constraints"</a></p>
</li>
<li>
<p><a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about creating tables with virtual columns</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="BABIFADB"></a>
<div id="ADXDB4048" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Loading XML Content into Oracle XML&nbsp;DB</h2>
<p>You can load XML content into Oracle XML&nbsp;DB using these techniques:</p>
<ul>
<li>
<p>Table-based loading:</p>
<ul>
<li>
<p><a href="#CEGDJEEI">Loading XML Content using SQL or PL/SQL</a></p>
</li>
<li>
<p><a href="#CEGFECFH">Loading XML Content using Java</a></p>
</li>
<li>
<p><a href="#CEGIDCHD">Loading XML Content using C</a></p>
</li>
<li>
<p><a href="#CEGGJHCH">Loading Large XML Files that Contain Small XML Documents</a></p>
</li>
<li>
<p><a href="#CEGDFBIJ">Loading Large XML Files using SQL*Loader</a></p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>Path-based repository loading techniques:</p>
<ul>
<li>
<p><a href="#BABFFDAE">Loading XML Documents into the Repository using DBMS_XDB</a></p>
</li>
<li>
<p><a href="#BABJHBJI">Loading Documents into the Repository using Protocols</a></p>
</li>
</ul>
</li>
</ul>
<a id="CEGDJEEI"></a>
<div id="ADXDB4049" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading XML Content using SQL or PL/SQL</h3>
<p>You can use a simple <code>INSERT</code> operation in SQL or PL/SQL to load an XML document into the database. Before the document can be stored as an <code>XMLType</code> column or table, you must convert it into an <code>XMLType</code> instance using one of the <code>XMLType</code> constructors.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb04cre.htm#g1050045">Chapter 4, "XMLType Operations"</a></p>
</li>
<li>
<p><a href="xdb01int.htm#CHDCDBFI">"APIs for XML"</a></p>
</li>
<li>
<p><a class="olink ARPLS369" href="../../appdev.112/e40758/t_xml.htm#ARPLS369"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for a description of the <code>XMLType</code> constructors</p>
</li>
</ul>
</div>
<p><code>XMLType</code> <span class="glossaryterm"><a id="sthref172"></a>constructors</span> allow an <code>XMLType</code> instance to be created from different sources, including <code>VARCHAR</code>, <code>CLOB</code>, and <code>BFILE</code> values. The constructors accept additional arguments that reduce the amount of processing associated with <code>XMLType</code> creation. For example, if you are sure that a given source XML document is valid, you can provide an argument to the constructor that disables the type-checking that is otherwise performed.</p>
<p>In addition, if the source data is not encoded in the database character set, an <code>XMLType</code> instance can be constructed using a <code>BFILE</code> or <code>BLOB</code> value. The encoding of the source data is specified through the character set id (<code>csid</code>) argument of the constructor.</p>
<p><a href="#BABBBGBB">Example 3-5</a> shows how to insert XML content into an <code>XMLType</code> table. Before making this insertion, you must create a database directory object that points to the directory containing the file to be processed. To do this, you must have the <code>CREATE ANY DIRECTORY</code> privilege.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>, Chapter 18, under <code>GRANT</code></div>
<div id="ADXDB5988" class="example">
<p class="titleinexample"><a id="sthref173"></a>Example 3-4 Creating a Database Directory</p>
<pre>
CREATE DIRECTORY xmldir AS <span class="italic">path_to_folder_containing_XML_file</span>;
</pre></div>
<!-- class="example" -->
<div id="ADXDB4051" class="example">
<p class="titleinexample"><a id="BABBBGBB"></a>Example 3-5 Inserting XML Content into an XMLType Table</p>
<pre>
INSERT INTO mytable2 VALUES (XMLType(bfilename('XMLDIR', 'purchaseOrder.xml'),
                                     nls_charset_id('AL32UTF8')));
</pre>
<p>The value passed to <code>nls_charset_id</code> indicates that the encoding for the file to be read is UTF-8.</p>
</div>
<!-- class="example" -->
<p>When you use SQL <code>INSERT</code> to insert a large document containing collections into <code>XMLType</code> tables (but not into <code>XMLType</code> columns), Oracle XML&nbsp;DB optimizes load time and memory usage.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb06stt.htm#BHAGACHJ">"Loading and Retrieving Large Documents with Collections"</a></div>
</div>
<!-- class="sect2" -->
<a id="CEGFECFH"></a>
<div id="ADXDB4052" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading XML Content using Java</h3>
<p><a href="#BABIEIAD">Example 3-6</a> shows how to load XML content into Oracle XML&nbsp;DB by first creating an <code>XMLType</code> instance in Java, given a Document Object Model (<a class="olink ADXDK9548" href="../../appdev.112/e23582/glossary.htm#ADXDK9548">DOM</a>).</p>
<div id="ADXDB4053" class="example">
<p class="titleinexample"><a id="BABIEIAD"></a>Example 3-6 Inserting Content into an XMLType Table using Java</p>
<pre>
public void doInsert(Connection conn, Document doc)
throws Exception
{
   String SQLTEXT = "<span class="bold">INSERT INTO purchaseorder VALUES (?)</span>";
   XMLType xml = null;
   xml = <span class="bold">XMLType.createXML</span>(conn,doc);
   OraclePreparedStatement sqlStatement = null;
   sqlStatement = (OraclePreparedStatement) conn.prepareStatement(SQLTEXT);
   sqlStatement.setObject(1,xml);
   sqlStatement.execute();
}
</pre></div>
<!-- class="example" -->
<p>A simple bulk loader application is available on the Oracle Technology Network (OTN) site at <code><a href="http://www.oracle.com/technetwork/database-features/xmldb/overview/index.html">http://www.oracle.com/technetwork/database-features/xmldb/overview/index.html</a></code>. It shows how to load a directory of XML files into Oracle XML&nbsp;DB using Java Database Connectivity (JDBC). JDBC is a set of Java interfaces to Oracle Database.</p>
</div>
<!-- class="sect2" -->
<a id="CEGIDCHD"></a>
<div id="ADXDB4054" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading XML Content using C</h3>
<p><a href="#BJFGHJDC">Example 3-7</a> shows how to insert XML content into an <code>XMLType</code> table using C code, by creating an <code>XMLType</code> instance given a <a class="olink ADXDK9548" href="../../appdev.112/e23582/glossary.htm#ADXDK9548">DOM</a>.</p>
<div id="ADXDB4055" class="example">
<p class="titleinexample"><a id="BJFGHJDC"></a>Example 3-7 Inserting Content into an XMLType Table using C</p>
<pre>
#include "stdio.h"
#include &lt;xml.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;<span class="bold">ocixmldb.h</span>&gt;
OCIEnv *envhp;
OCIError *errhp;
OCISvcCtx *svchp;
OCIStmt *stmthp;
OCIServer *srvhp;
OCIDuration dur;
OCISession *sesshp;
oratext *username = "QUINE";
oratext *password = "************";         /* Replace with the real password. */
oratext *filename = "AMCEWEN-20021009123336171PDT.xml";
oratext *schemaloc = "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd";
 
/*--------------------------------------------------------*/
/* Execute a SQL statement that binds XML data            */
/*--------------------------------------------------------*/
 
sword exec_bind_xml(OCISvcCtx *svchp, OCIError *errhp, OCIStmt *stmthp,
                    void *xml,        OCIType *xmltdo, OraText *sqlstmt)
{
  OCIBind *bndhp1 = (OCIBind *) 0;
  sword  status = 0;
  OCIInd ind = OCI_IND_NOTNULL;
  OCIInd *indp = &amp;ind;
  if(status = OCIStmtPrepare(stmthp, errhp, (OraText *)sqlstmt,
                             (ub4)strlen((const char *)sqlstmt),
                             (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT))
    return OCI_ERROR;
  if(status = OCIBindByPos(stmthp, &amp;bndhp1, errhp, (ub4) 1, (dvoid *) 0,
                           (sb4) 0, SQLT_NTY, (dvoid *) 0, (ub2 *)0,
                           (ub2 *)0, (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT))
    return OCI_ERROR;
  if(status = OCIBindObject(bndhp1, errhp, (CONST OCIType *) xmltdo,
                            (dvoid **) &amp;xml, (ub4 *) 0,
                            (dvoid **) &amp;indp, (ub4 *) 0))
    return OCI_ERROR;
  if(status = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                             (CONST OCISnapshot*) 0, (OCISnapshot*) 0,
                             (ub4) OCI_DEFAULT))
    return OCI_ERROR;
  return OCI_SUCCESS;
}
 
/*--------------------------------------------------------*/
/* Initialize OCI handles, and connect                    */
/*--------------------------------------------------------*/
 
sword init_oci_connect()
{
<span class="bold">. . .</span>
}
 
/*--------------------------------------------------------*/
/* Free OCI handles, and disconnect                       */
/*--------------------------------------------------------*/
 
void free_oci()
{
<span class="bold">. . .</span>
}
 
void main()
{
  OCIType *xmltdo;
  xmldocnode  *doc;
  ocixmldbparam params[1];
  xmlerr       err;
  xmlctx  *xctx;
  oratext *ins_stmt;
  sword    status;
  xmlnode *root;
  oratext buf[10000];
 
  /* Initialize envhp, svchp, errhp, dur, stmthp */
  init_oci_connect();
 
  /* Get an XML context */
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;dur;
  xctx = <span class="bold">OCIXmlDbInitXmlCtx</span>(envhp, svchp, errhp, params, 1);
  if (!(doc = XmlLoadDom(xctx, &amp;err, "file", filename,
                         "schema_location", schemaloc, NULL)))
    {
      printf("Parse failed.\n");
      return;
    }
  else
    printf("Parse succeeded.\n");
  root = <span class="bold">XmlDomGetDocElem</span>(xctx, doc);
  printf("The xml document is :\n");
  XmlSaveDom(xctx, &amp;err, (xmlnode *)doc, "buffer", buf, "buffer_length", 10000, NULL);
  printf("%s\n", buf);
 
  /* Insert the document into my_table */
  ins_stmt = (oratext *)"insert into purchaseorder values (:1)";
  status = OCITypeByName(envhp, errhp, svchp, (const text *) "SYS",
                         (ub4) strlen((const char *)"SYS"), (const text *) "XMLTYPE",
                         (ub4) strlen((const char *)"XMLTYPE"), (CONST text *) 0,
                         (ub4) 0, OCI_DURATION_SESSION, OCI_TYPEGET_HEADER,
                         (OCIType **) &amp;xmltdo);
  if (status == OCI_SUCCESS)
    {
      status = exec_bind_xml(svchp, errhp, stmthp, (void *)doc,
                             xmltdo, ins_stmt);
    }
  if (status == OCI_SUCCESS)
    printf ("Insert successful\n");
  else
    printf ("Insert failed\n");
 
  /* Free XML instances */
  if (doc)
    XmlFreeDocument((xmlctx *)xctx, (xmldocnode *)doc);
  /* Free XML CTX */
  <span class="bold">OCIXmlDbFreeXmlCtx</span>(xctx);
  free_oci();
}
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For simplicity in demonstrating this feature, this example does not perform the password management techniques that a deployed system normally uses. In a production environment, follow the Oracle Database password management guidelines, and disable any sample accounts. See <a class="olink DBSEG50053" href="../../network.112/e36292/app_devs.htm#DBSEG50053"><span class="italic">Oracle Database Security Guide</span></a> for password management guidelines and other security recommendations.</div>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1031">
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028">
<p class="notep1">See Also:</p>
<a href="apphxdb.htm#g648966">Appendix A, "Oracle-Supplied XML Schemas and Examples"</a> for a complete listing of this example</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
</div>
<!-- class="sect2" -->
<a id="CEGGJHCH"></a>
<div id="ADXDB4056" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading Large XML Files that Contain Small XML Documents</h3>
<p>When loading large XML files consisting of a collection of smaller XML documents, it is often more efficient to use Simple API for XML (SAX) parsing to break the file into a set of smaller documents, and then insert those documents. SAX is an XML standard interface provided by XML parsers for event-based applications.</p>
<p>You can use SAX to load a database table from very large XML files in the order of 30 MB or larger, by creating individual documents from a collection of nodes. You can also bulk load XML files.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><code><a href="http://www.saxproject.org/">http://www.saxproject.org/</a></code> for information about SAX</p>
</li>
<li>
<p><code><a href="http://www.oracle.com/technetwork/database-features/xmldb/overview/index.html">http://www.oracle.com/technetwork/database-features/xmldb/overview/index.html</a></code>, for an application example that loads large files using SAX</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CEGDFBIJ"></a>
<div id="ADXDB4057" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading Large XML Files using SQL*Loader</h3>
<p>Use SQL*Loader to load large amounts of XML data into Oracle Database. SQL*Loader loads in one of two modes, conventional or direct path. <a href="#BJFJFHIF">Table 3-1</a> compares these modes.</p>
<div id="ADXDB4058" class="tblhruleformal">
<p class="titleintable"><a id="sthref174"></a><a id="BJFJFHIF"></a>Table 3-1 SQL*Loader &ndash; Conventional and Direct-Path Load Modes</p>
<table class="cellalignment1032" title="SQL*Loader &ndash; Conventional and Direct-Path Load Modes" summary="Comparison of SQL*Loader Conventional and Direct Load Modes" >
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t14">Conventional Load Mode</th>
<th class="cellalignment1027" id="r1c2-t14">Direct-Path Load Mode</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t14" headers="r1c1-t14">
<p>Uses SQL to load data into Oracle Database. This is the <span class="italic">default</span> mode.</p>
</td>
<td class="cellalignment1028" headers="r2c1-t14 r1c2-t14">
<p>Bypasses SQL and streams the data directly into Oracle Database.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t14" headers="r1c1-t14">
<p><span class="italic">Advantage:</span> Follows SQL semantics. For example triggers are fired and constraints are checked.</p>
</td>
<td class="cellalignment1028" headers="r3c1-t14 r1c2-t14">
<p><span class="italic">Advantage:</span> This loads data much faster than the conventional load mode.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t14" headers="r1c1-t14">
<p><span class="italic">Disadvantage:</span> This loads data slower than with the direct load mode.</p>
</td>
<td class="cellalignment1028" headers="r4c1-t14 r1c2-t14">
<p><span class="italic">Disadvantage:</span> SQL semantics is not obeyed. For example triggers are not fired and constraints are not checked.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>When loading LOBs with SQL*Loader direct-path load, much memory can be used. If the message <code>SQL*Loader 700 (out of memory)</code> appears, then it is likely that more rows are being included in each load call than can be handled by your operating system and process memory. <span class="italic">Workaround:</span> use the <code>ROWS</code> option to read a smaller number of rows in each data save.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb25loa.htm#g1026738">Chapter 35, "Loading XML Data using SQL*Loader"</a></div>
</div>
<!-- class="sect2" -->
<a id="BABFFDAE"></a>
<div id="ADXDB4059" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading XML Documents into the Repository using DBMS_XDB</h3>
<p>You can also store XML documents in Oracle XML&nbsp;DB Repository, and access these documents using path-based rather than table-based techniques. To load an XML document into the repository under a given path, use PL/SQL function <code><a id="sthref175"></a><a id="sthref176"></a>DBMS_XDB.createResource</code>. <a href="#BJFICDCH">Example 3-8</a> illustrates this.</p>
<div id="ADXDB4060" class="example">
<p class="titleinexample"><a id="BJFICDCH"></a>Example 3-8 Inserting XML Content into the Repository using CREATERESOURCE</p>
<pre>
DECLARE
  res BOOLEAN;
BEGIN
  res := DBMS_XDB.createResource('/home/QUINE/purchaseOrder.xml',
                                 bfilename('XMLDIR', 'purchaseOrder.xml'),
                                 nls_charset_id('AL32UTF8'));
END;/
</pre></div>
<!-- class="example" -->
<p>Many operations for configuring and using Oracle XML&nbsp;DB are based on processing one or more XML documents. Examples include registering an XML schema and performing an XSL transformation. The easiest way to make these XML documents available to Oracle Database is to load them into Oracle XML&nbsp;DB Repository.</p>
</div>
<!-- class="sect2" -->
<a id="BABJHBJI"></a>
<div id="ADXDB4061" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Loading Documents into the Repository using Protocols</h3>
<p>Oracle XML&nbsp;DB Repository can store XML documents that are either XML schema-based or non-schema-based. It can also store content that is not XML data, such as HTML files, image files, and Microsoft Word documents.</p>
<p>You can load XML documents from a local file system into Oracle XML&nbsp;DB Repository using protocols such as WebDAV, from Windows Explorer or other tools that support WebDAV. <a href="#CHDHJDAE">Figure 3-1</a> shows a simple drag and drop operation for copying the contents of the <code>SCOTT</code> folder from the local hard drive to folder <code>poSource</code> in the Oracle XML&nbsp;DB Repository.</p>
<div id="ADXDB4062" class="figure">
<p class="titleinfigure"><a id="CHDHJDAE"></a>Figure 3-1 Loading Content into the Repository using Windows Explorer</p>
<img width="713" height="349" src="img/repo_load.gif" alt="Description of Figure 3-1 follows" /><br />
<a id="sthref177" href="img_text/repo_load.htm">Description of "Figure 3-1 Loading Content into the Repository using Windows Explorer"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The copied folder might contain, for example, an XML schema document, an HTML page, and some XSLT style sheets.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCJDEH"></a>
<div id="ADXDB4063" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Character Sets of XML Documents</h2>
<p>This section describes how character sets of XML documents are determined.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<span class="italic">AL32UTF8</span> is the Oracle Database character set that is appropriate for <code>XMLType</code> data. It is equivalent to the IANA registered standard UTF-8 encoding, which supports all valid XML characters.
<p>Do not confuse Oracle Database database character set UTF8 (no hyphen) with database character set AL32UTF8 or with character <span class="italic">encoding</span> UTF-8. Database character set UTF8 has been <span class="italic">superseded</span> by AL32UTF8. Do <span class="italic">not</span> use UTF8 for XML data. Character set UTF8 supports only Unicode version 3.1 and earlier. It does not support all valid XML characters. AL32UTF8 has no such limitation.</p>
<p>Using database character set UTF8 for XML data could potentially <span class="italic">stop a system or affect security negatively</span>. If a character that is not supported by the database character set appears in an input-document element name, a replacement character (usually "<code>?</code>") is substituted for it. This terminates parsing and raises an exception. It can cause an irrecoverable error.</p>
</div>
<div id="ADXDB4064" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref178"></a>
<h3 class="sect2">XML Encoding Declaration</h3>
<p>Each XML document is composed of units called entities. Each entity in an XML document may use a different encoding for its characters. Entities that are stored in an encoding other than UTF-8 or UTF-16 must begin with an XML declaration containing an encoding specification indicating the character encoding in use. For example:</p>
<pre>
&lt;?xml version='1.0' encoding='EUC-JP' ?&gt;
</pre>
<p>Entities encoded in UTF-16 must begin with the Byte Order Mark (BOM), as described in Appendix F of the XML 1.0 Reference. For example, on big-endian platforms, the BOM required of a UTF-16 data stream is <code>#xFEFF</code>.</p>
<p>In the absence of both the encoding declaration and the BOM, the XML entity is assumed to be encoded in UTF-8. Because ASCII is a subset of UTF-8, ASCII entities do not require an encoding declaration.</p>
<p>In many cases, external sources of information are available, besides the XML data, to provide the character encoding in use. For example, the encoding of the data can be obtained from the <code>charset</code> parameter of the <code>Content-Type</code> field in an HTTP(S) request as follows:</p>
<pre>
Content-Type: text/xml; charset=ISO-8859-4
</pre></div>
<!-- class="sect2" -->
<div id="ADXDB4065" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref179"></a>
<h3 class="sect2">Character-Set Determination When Loading XML Documents into the Database</h3>
<p>In releases prior to Oracle Database&nbsp;10<span class="italic">g</span> release 1, all XML documents were assumed to be in the <span class="italic">database</span> character set, regardless of the document encoding declaration. Starting with Oracle Database&nbsp;10<span class="italic">g</span> release 1, the document encoding is detected from the encoding declaration when the document is loaded into the database.</p>
<p>However, if the XML data is obtained from a <code>CLOB</code> or <code>VARCHAR</code> value, then the encoding declaration is <span class="italic">ignored,</span> because these two data types are always encoded in the database character set.</p>
<p>In addition, when loading data into Oracle XML&nbsp;DB, either through programmatic APIs or transfer protocols, you can provide external encoding to override the document encoding declaration. An error is raised if you try to load a schema-based XML document that contains characters that are not legal in the determined encoding.</p>
<p>The following examples show different ways to specify external encoding:</p>
<ul>
<li>
<p>Using PL/SQL function <code>DBMS_XDB.createResource</code> to create a file resource from a <code>BFILE</code>, you can specify the file encoding with the <code><span class="codeinlineitalic">CSID</span></code> argument. If a zero <code><span class="codeinlineitalic">CSID</span></code> is specified then the file encoding is auto-detected from the document encoding declaration.</p>
<pre>
CREATE DIRECTORY xmldir AS '/private/xmldir';
CREATE OR REPLACE PROCEDURE loadXML(filename VARCHAR2, file_csid NUMBER) IS
  xbfile  BFILE;
  RET     BOOLEAN;
BEGIN
  xbfile := bfilename('XMLDIR', filename);
  ret := DBMS_XDB.createResource('/public/mypurchaseorder.xml', 
                                 xbfile,
                                 file_csid);
END;/
</pre></li>
<li>
<p>Use the FTP protocol to load documents into Oracle XML&nbsp;DB. Use the <code>quote set_charset</code> FTP command to indicate the encoding of the files to be loaded.</p>
<pre>
ftp&gt; quote set_charset Shift_JIS  
ftp&gt; put mypurchaseorder.xml
</pre></li>
<li>
<p>Use the HTTP(S) protocol to load documents into Oracle XML&nbsp;DB. Specify the encoding of the data to be transmitted to Oracle XML&nbsp;DB in the request header.</p>
<pre>
Content-Type: text/xml; charset= EUC-JP
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4066" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref180"></a>
<h3 class="sect2">Character-Set Determination When Retrieving XML Documents from the Database</h3>
<p>XML documents stored in Oracle XML&nbsp;DB can be retrieved using a SQL client, programmatic APIs, or transfer protocols. You can specify the encoding of the retrieved data (except in Oracle Database releases prior to 10<span class="italic">g</span>, where XML data is retrieved only in the database character set).</p>
<p>When XML data is stored as a <code>CLOB</code> or <code>VARCHAR2</code> value, the encoding declaration, if present, is always ignored for retrieval, just as for storage. The encoding of a retrieved document can thus be different from the encoding explicitly declared in that document.</p>
<p>The character set for an XML document retrieved from the database is determined in the following ways:</p>
<ul>
<li>
<p>SQL client &ndash; If a SQL client (such as SQL*Plus) is used to retrieve XML data, then the character set is determined by the client-side environment variable <code>NLS_LANG</code>. In particular, this setting overrides any explicit character-set declarations in the XML data itself.</p>
<p>For example, if you set the client side <code>NLS_LANG</code> variable to <code>AMERICAN_AMERICA.AL32UTF8</code> and then retrieve an XML document with encoding <code>EUC_JP</code> provided by declaration <code>&lt;?xml version="1.0" encoding="EUC-JP"?&gt;</code>, the character set of the retrieved document is <code>AL32UTF8</code>, <span class="italic">not</span> <code>EUC_JP</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG" href="../../server.112/e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about <code>NLS_LANG</code></div>
</li>
<li>
<p>PL/SQL and APIs &ndash; Using PL/SQL or programmatic APIs, you can retrieve XML data into <code>VARCHAR</code>, <code>CLOB</code>, or <code>XMLType</code> data types. As for SQL clients, you can control the encoding of the retrieved data by setting <code>NLS_LANG</code>.</p>
<p>You can also retrieve XML data into a <code>BLOB</code> value using <code>XMLType</code> and <code>URIType</code> methods. These let you specify the character set of the returned <code>BLOB</code> value. Here is an example:</p>
<pre>
CREATE OR REPLACE FUNCTION getXML(pathname VARCHAR2, charset VARCHAR2) 
  RETURN BLOB IS
  xblob BLOB;
BEGIN
  SELECT XMLSERIALIZE(DOCUMENT e.RES AS BLOB ENCODING charset) INTO xblob
    FROM RESOURCE_VIEW e WHERE equals_path(e.RES, pathname) = 1;
  RETURN xblob;
END;
/
</pre></li>
<li>
<p>FTP &ndash; You can use the FTP <code>quote set_nls_locale</code> command to set the character set:</p>
<pre>
ftp&gt; quote set_nls_locale EUC-JP
ftp&gt; get mypurchaseorder.xml
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb22pro.htm#CEGIDHCC">FTP Quote Methods</a></div>
</li>
<li>
<p>HTTP(S) &ndash; You can use the <code>Accept-Charset</code> parameter in an HTTP(S) request:</p>
<pre>
/httptest/mypurchaseorder.xml  1.1 HTTP/Host: localhost:2345
Accept: text/*
Accept-Charset:  iso-8859-1, utf-8
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb22pro.htm#CEGBABDI">Controlling Character Sets for HTTP(S)</a></div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1040530"></a>
<div id="ADXDB4067" class="sect1">
<h2 class="sect1">Overview of the W3C XML Schema Recommendation<a id="sthref181"></a></h2>
<p>The W3C XML Schema Recommendation defines a standardized language for specifying the structure, content, and certain semantics of a set of XML documents. An XML schema can be considered the metadata that describes a class of XML documents. The XML Schema Recommendation is described at: <code><a href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</a></code></p>
<div id="ADXDB4068" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref182"></a>
<h3 class="sect2">XML Instance Documents</h3>
<p>Documents conforming to a given XML schema can be considered as members or instances of the class defined by that XML schema. Consequently the term <span class="italic">instance document</span> is often used to describe an XML document that conforms to a given XML schema. The most common use of an XML schema is to validate that a given instance document conforms to the rules defined by the XML schema.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB4069" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref183"></a>
<h3 class="sect2">XML Schema for Schemas</h3>
<p>The W3C Schema working group publishes an XML schema, often referred to as the "Schema for Schemas". This XML schema provides the definition, or vocabulary, of the XML Schema language. All valid XML schemas can be considered to be members of the class defined by this XML schema. An XML schema is thus an XML document that conforms to the class defined by the XML schema published at <code><a href="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</a></code>.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB4070" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref184"></a>
<h3 class="sect2">Editing XML Schemas</h3>
<p>XML schemas can be authored and edited using any of the following:</p>
<ul>
<li>
<p>A simple text editor, such as emacs or vi</p>
</li>
<li>
<p>An XML schema-aware editor, such as the XML editor included with Oracle JDeveloper</p>
</li>
<li>
<p>An explicit XML schema-authoring tool, such as XMLSpy from Altova Corporation</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4071" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref185"></a>
<h3 class="sect2">XML Schema Features</h3>
<p>The XML Schema language defines 47 scalar data types. This provides for strong typing of elements and attributes. The W3C XML Schema Recommendation also supports object-oriented techniques such as inheritance and extension, hence you can design XML schema with complex objects from base data types defined by the XML Schema language. The vocabulary includes constructs for defining and ordering, default values, mandatory content, nesting, repeated sets, and redefines. Oracle XML&nbsp;DB supports all the constructs, except for redefines.</p>
<div id="ADXDB4072" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref186"></a>
<h4 class="sect3">Text Representation of the Purchase Order XML Schema</h4>
<p><a href="#CHDJFCCA">Example 3-9</a> shows the purchase order XML schema as an XML file, <code>purchaseOrder.xsd</code>.</p>
<div id="ADXDB4073" class="example">
<p class="titleinexample"><a id="CHDJFCCA"></a>Example 3-9 <a id="sthref187"></a>Purchase-Order XML Schema, purchaseOrder.xsd</p>
<pre>
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" version="1.0"&gt;
  &lt;xs:element name="PurchaseOrder" type="PurchaseOrderType"/&gt;
  &lt;xs:complexType name="PurchaseOrderType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Reference" type="ReferenceType"/&gt;
      &lt;xs:element name="Actions" type="ActionsType"/&gt;
      &lt;xs:element name="Reject" type="RejectionType" minOccurs="0"/&gt;
      &lt;xs:element name="Requestor" type="RequestorType"/&gt;
      &lt;xs:element name="User" type="UserType"/&gt;
      &lt;xs:element name="CostCenter" type="CostCenterType"/&gt;
      &lt;xs:element name="ShippingInstructions" type="ShippingInstructionsType"/&gt;
      &lt;xs:element name="SpecialInstructions" type="SpecialInstructionsType"/&gt;
      &lt;xs:element name="LineItems" type="LineItemsType"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="LineItemsType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="LineItem" type="LineItemType" maxOccurs="unbounded"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="LineItemType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Description" type="DescriptionType"/&gt;
      &lt;xs:element name="Part" type="PartType"/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ItemNumber" type="xs:integer"/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="PartType"&gt;
    &lt;xs:attribute name="Id"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
          &lt;xs:minLength value="10"/&gt;
          &lt;xs:maxLength value="14"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:attribute&gt;
    &lt;xs:attribute name="Quantity" type="moneyType"/&gt;
    &lt;xs:attribute name="UnitPrice" type="quantityType"/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:simpleType name="ReferenceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="18"/&gt;
      &lt;xs:maxLength value="30"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:complexType name="ActionsType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Action" maxOccurs="4"&gt;
        &lt;xs:complexType&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name="User" type="UserType"/&gt;
            &lt;xs:element name="Date" type="DateType" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="RejectionType"&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="User" type="UserType" minOccurs="0"/&gt;
      &lt;xs:element name="Date" type="DateType" minOccurs="0"/&gt;
      &lt;xs:element name="Comments" type="CommentsType" minOccurs="0"/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="ShippingInstructionsType"&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="name" type="NameType" minOccurs="0"/&gt;
      &lt;xs:element name="address" type="AddressType" minOccurs="0"/&gt;
      &lt;xs:element name="telephone" type="TelephoneType" minOccurs="0"/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:simpleType name="moneyType"&gt;
    &lt;xs:restriction base="xs:decimal"&gt;
      &lt;xs:fractionDigits value="2"/&gt;
      &lt;xs:totalDigits value="12"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="quantityType"&gt;
    &lt;xs:restriction base="xs:decimal"&gt;
      &lt;xs:fractionDigits value="4"/&gt;
      &lt;xs:totalDigits value="8"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="UserType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="10"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="RequestorType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="128"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="CostCenterType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="4"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="VendorType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="20"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="PurchaseOrderNumberType"&gt;
    &lt;xs:restriction base="xs:integer"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="SpecialInstructionsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="2048"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="NameType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="20"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="AddressType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="256"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="TelephoneType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="24"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="DateType"&gt;
    &lt;xs:restriction base="xs:date"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="CommentsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="2048"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="DescriptionType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="256"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt; 
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABBGIED">Example 3-10, "Annotated Purchase-Order XML Schema, purchaseOrder.xsd"</a></div>
</div>
<!-- class="sect3" -->
<div id="ADXDB4074" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref188"></a>
<h4 class="sect3">Graphical Representation of the <a id="sthref189"></a>Purchase-Order XML Schema</h4>
<p><a href="#BABJFFEG">Figure 3-2</a> shows the purchase-order XML schema displayed using XMLSpy. XMLSpy is a graphical and user-friendly tool from Altova Corporation for creating and editing XML schema and XML documents. See <code><a href="http://www.altova.com">http://www.altova.com</a></code> for details. XMLSpy also supports WebDAV and FTP protocols hence can directly access and edit content stored in Oracle XML&nbsp;DB Repository.</p>
<div id="ADXDB4075" class="figure">
<p class="titleinfigure"><a id="BABJFFEG"></a>Figure 3-2 XMLSpy Graphical Representation of the PurchaseOrder XML Schema</p>
<img width="874" height="690" src="img/po_spy.gif" alt="Description of Figure 3-2 follows" /><br />
<a id="sthref190" href="img_text/po_spy.htm">Description of "Figure 3-2 XMLSpy Graphical Representation of the PurchaseOrder XML Schema"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The purchase order XML schema demonstrates some key features of a typical XML document:</p>
<ul>
<li>
<p>Global element <code>PurchaseOrder</code> is an instance of the <code>complexType</code> <code>PurchaseOrderType</code></p>
</li>
<li>
<p><code>PurchaseOrderType</code> defines the set of nodes that make up a <code>PurchaseOrder</code> element</p>
</li>
<li>
<p><code>LineItems</code> element consists of a collection of <code>LineItem</code> elements</p>
</li>
<li>
<p>Each <code>LineItem</code> element consists of two elements: <code>Description</code> and <code>Part</code></p>
</li>
<li>
<p><code>Part</code> element has attributes <code>Id</code>, <code>Quantity</code>, and <code>UnitPrice</code></p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDADEB"></a>
<div id="ADXDB4076" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using XML Schema with Oracle XML&nbsp;DB</h2>
<p>This section describes the use of XML Schema with Oracle XML&nbsp;DB.</p>
<div id="ADXDB4077" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref191"></a>
<h3 class="sect2">Why Use XML Schema with Oracle XML&nbsp;DB?</h3>
<p>The following paragraphs describe the main reasons for using XML schema with Oracle XML&nbsp;DB.</p>
<div id="ADXDB4078" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref192"></a>
<h4 class="sect3">Validating Instance Documents with XML Schema</h4>
<p>The most common usage of XML Schema is as a mechanism for validating that instance documents conform to a given XML schema. The <code>XMLType</code> methods <code>isSchemaValid()</code> and <code>schemaValidate()</code> validate the contents of an instance document stored as <code>XMLType</code>.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4079" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref193"></a>
<h4 class="sect3">Constraining Instance Documents for Business Rules or Format Compliance</h4>
<p>An XML schema can also be used as a constraint when creating tables or columns of <code>XMLType</code>. For example, the <code>XMLType</code> is constrained to storing XML documents compliant with one of the global elements defined by the XML schema.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4080" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref194"></a>
<h4 class="sect3">Defining How XMLType Contents Must be Stored in the Database</h4>
<p>Oracle XML&nbsp;DB also uses XML Schema as a mechanism for defining how the contents of an <code>XMLType</code> instance should be stored inside the database. All storage models support the use of XML Schema: binary XML, structured, unstructured, and hybrid (a combination of structured and unstructured). See <a href="xdb01int.htm#BABECDCF">"XMLType Storage Models"</a> for information on the available storage models for <code>XMLType</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDAGHH"></a>
<div id="ADXDB4081" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Structured Storage of XML Documents</h3>
<p>Structured storage of XML documents is based on decomposing the content of the document into a set of SQL objects. These SQL objects are based on the SQL 1999 Type framework. When an XML schema is registered with Oracle XML&nbsp;DB, the required SQL type definitions are automatically generated from the XML schema.</p>
<p>A SQL type definition is generated from each <code>complexType</code> defined by the XML schema. Each element or attribute defined by the <code>complexType</code> becomes a SQL attribute in the corresponding SQL type. Oracle XML&nbsp;DB automatically maps the 47 scalar data types defined by the XML Schema Recommendation to the 19 scalar data types supported by SQL. A varray type is generated for each element and this can occur multiple times.</p>
<p>The generated SQL types allow XML content, compliant with the XML schema, to be decomposed and stored in the database as a set of objects without any loss of information. When the document is ingested the constructs defined by the XML schema are mapped directly to the equivalent SQL types. This lets Oracle XML&nbsp;DB leverage the full power of Oracle Database when managing XML and can lead to significant reductions in the amount of space required to store the document. It can also reduce the amount of memory required to query and update XML content.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB4082" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref195"></a>
<h3 class="sect2">Annotating an <a id="sthref196"></a><a id="sthref197"></a>XML Schema to Control Naming, Mapping, and Storage</h3>
<p>The W3C XML Schema Recommendation defines an annotation mechanism that lets vendor-specific information be added to an XML schema. Oracle XML&nbsp;DB uses this mechanism to control the mapping between the XML schema and database features.</p>
<p>You can use XML schema annotations to do the following:</p>
<ul>
<li>
<p>Specify which database tables are used to store the XML data.</p>
</li>
<li>
<p>Override the default mapping between XML Schema data types and SQL data types, for structured storage.</p>
</li>
<li>
<p>Name the database objects and attributes that are created to store XML data (for structured storage).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDGFDFA"></a>
<div id="ADXDB4083" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Controlling How Collections Are Stored for Object-Relational XMLType Storage</h3>
<p>When you register an XML schema for data that is stored object-relationally and you set registration parameter <code>GENTABLES</code> to <code>TRUE</code>, default tables are created automatically to store the associated XML instance documents.</p>
<p>Order is preserved among XML collection elements when they are stored. The result is an <span class="glossaryterm"><a id="sthref198"></a>ordered collection</span>.<a id="sthref199" href="#sthref199" onclick='footdisplay(2,"If you use XML schema annotation \u003ccode\u003emaintainOrder = \"false\"\u003c/code\u003e, then an unordered collection is used instead of an ordered collection. Oracle recommends that you use ordered collections (\u003ccode\u003emaintainOrder = \"true\"\u003c/code\u003e) for XML data, to preserve document order. By default, attribute \u003ccode\u003emaintainOrder\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e.")'><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a> You can store data in an ordered collection in these ways:</p>
<ul>
<li>
<p><span class="glossaryterm"><a id="sthref200"></a>Varray in a table</span>. Each element in the collection is mapped to a SQL object. The collection of SQL objects is stored as a set of rows in a table, called an <a id="sthref201"></a><a id="sthref202"></a><span class="glossaryterm">ordered collection table</span> (<span class="glossaryterm">OCT</span>). By default, all collections are stored in OCTs. This default behavior corresponds to the XML schema annotation <code>xdb:storeVarrayAsTable = "true"</code> (default value).</p>
</li>
<li>
<p><span class="glossaryterm"><a id="sthref203"></a>Varray in a LOB</span>. Each element in the collection is mapped to a SQL object. The entire collection of SQL objects is serialized as a varray and stored in a LOB column. To store a given collection as a varray in a LOB, use XML schema annotation <code>xdb:storeVarrayAsTable = "false"</code>.</p>
</li>
</ul>
<p>You can also use out-of-line storage for an ordered collection. This corresponds to XML schema annotation <code>SQLInline = "false"</code>, and it means that a varray of <code>REF</code>s in the collection table or LOB tracks the collection content, which is stored out of line.</p>
<p>There is no requirement to annotate an XML schema before using it. Oracle XML&nbsp;DB uses a set of default assumptions when processing an XML schema that contains no annotations.</p>
<p>If you do not supply any of the annotations mentioned in this section, then Oracle XML&nbsp;DB stores a collection as a <span class="italic">heap-based</span> OCT. You can force OCTs to be stored as <a id="sthref204"></a><a id="sthref205"></a><span class="glossaryterm">index-organized tables</span> (<span class="glossaryterm">IOTs</span>) instead, by passing <code><span class="codeinlinebold"><a id="sthref206"></a><a id="sthref207"></a>REGISTER_NT_AS_IOT</span></code> in the <code>OPTIONS</code> parameter of <code>DBMS_XMLSCHEMA.registerSchema</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use heap-based OCTs, <span class="italic">not</span> IOTs, unless you are explicitly advised by Oracle to use IOTs. IOT storage has these significant limitations:
<ul>
<li>
<p>It disables partitioning of the collection tables (IOTs).</p>
</li>
<li>
<p>It supports only document-level Oracle Text indexes. It disables indexes that are element-specific or attribute-specific.</p>
</li>
</ul>
<p>See also: <a href="xdb09sea.htm#i1006756">Chapter 12, "Full-Text Search Over XML Data"</a> for information about using Oracle Text with XML data.</p>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
In releases prior to Oracle Database&nbsp;11g Release 1:
<ul>
<li>
<p>OCTs were stored as IOTs by default.</p>
</li>
<li>
<p>The default value for <code>xdb:storeVarrayAsTable</code> was <code>false</code>.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb05sto.htm#BJFGEHAJ">"Structured Storage of XML Schema-Based Data"</a> for information about collection storage when you create <code>XMLType</code> tables and columns manually using structured storage</p>
</li>
<li>
<p><a href="xdb05sto.htm#g1070409">Chapter 7, "XML Schema Storage and Query: Basic"</a></p>
</li>
<li>
<p><a href="xdb06stt.htm#BABBHHAJ">"Setting Annotation Attribute SQLInline to false for Out-Of-Line Storage"</a></p>
</li>
<li>
<p><a href="xdb06stt.htm#BHAFCACA">Partitioning XMLType Tables and Columns Stored Object-Relationally</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4084" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref208"></a>
<h3 class="sect2">Declaring the Oracle XML&nbsp;DB Namespace</h3>
<p>Before annotating an XML schema you must first declare the Oracle XML&nbsp;DB namespace. The Oracle XML&nbsp;DB namespace is defined as:</p>
<p><code>http://xmlns.oracle.com/xdb</code></p>
<p>The namespace is declared in the XML schema by adding a namespace declaration such as the following to the root element of the XML schema:</p>
<p><code>xmlns:xdb="http://xmlns.oracle.com/xdb"</code></p>
<p>Note the use of a namespace prefix (<code>xdb</code>). This makes it possible to abbreviate the namespace to <code>xdb</code> when adding annotations.</p>
<p><a href="#BABBGIED">Example 3-10</a> shows the beginning of the <code>PurchaseOrder</code> XML schema with annotations. See <a href="apphxdb.htm#BABDAGBF">Example A-1</a> for the complete schema listing.</p>
<div id="ADXDB4085" class="example">
<p class="titleinexample"><a id="BABBGIED"></a>Example 3-10 Annotated <a id="sthref209"></a>Purchase-Order XML Schema, purchaseOrder.xsd</p>
<pre>
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           <span class="bold">xmlns:xdb="http://xmlns.oracle.com/xdb"</span>
           version="1.0"
           <span class="bold">xdb:storeVarrayAsTable="true"</span>&gt;
  &lt;xs:element name="PurchaseOrder" type="PurchaseOrderType" <span class="bold">xdb:defaultTable="PURCHASEORDER"</span>/&gt;
  &lt;xs:complexType name="PurchaseOrderType" <span class="bold">xdb:SQLType="PURCHASEORDER_T"</span>&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Reference" type="ReferenceType" minOccurs="1" <span class="bold">xdb:SQLName="REFERENCE"</span>/&gt;
      &lt;xs:element name="Actions" type="ActionsType" <span class="bold">xdb:SQLName="ACTIONS"</span>/&gt;
      &lt;xs:element name="Reject" type="RejectionType" minOccurs="0" <span class="bold">xdb:SQLName="REJECTION"</span>/&gt;
      &lt;xs:element name="Requestor" type="RequestorType" <span class="bold">xdb:SQLName="REQUESTOR"</span>/&gt;
      &lt;xs:element name="User" type="UserType" minOccurs="1" <span class="bold">xdb:SQLName="USERID"</span>/&gt;
      &lt;xs:element name="CostCenter" type="CostCenterType" <span class="bold">xdb:SQLName="COST_CENTER"</span>/&gt;
      &lt;xs:element name="ShippingInstructions" type="ShippingInstructionsType" 
                  <span class="bold">xdb:SQLName="SHIPPING_INSTRUCTIONS"</span>/&gt;
      &lt;xs:element name="SpecialInstructions" type="SpecialInstructionsType" 
                  <span class="bold">xdb:SQLName="SPECIAL_INSTRUCTIONS"</span>/&gt;
      &lt;xs:element name="LineItems" type="LineItemsType" <span class="bold">xdb:SQLName="LINEITEMS"</span>/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="LineItemsType" <span class="bold">xdb:SQLType="LINEITEMS_T"</span>&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="LineItem" type="LineItemType" maxOccurs="unbounded" 
                  <span class="bold">xdb:SQLName="LINEITEM"</span> <span class="bold">xdb:SQLCollType="LINEITEM_V"</span>/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="LineItemType" <span class="bold">xdb:SQLType="LINEITEM_T"</span>&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Description" type="DescriptionType" 
                  <span class="bold">xdb:SQLName="DESCRIPTION"</span>/&gt;
      &lt;xs:element name="Part" type="PartType" <span class="bold">xdb:SQLName="PART"</span>/&gt;
    &lt;/xs:sequence&gt;
    &lt;xs:attribute name="ItemNumber" type="xs:integer" <span class="bold">xdb:SQLName="ITEMNUMBER"</span> 
                  <span class="bold">xdb:SQLType="NUMBER"</span>/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="PartType" <span class="bold">xdb:SQLType="PART_T"</span>&gt;
    &lt;xs:attribute name="Id" <span class="bold">xdb:SQLName="PART_NUMBER"</span> <span class="bold">xdb:SQLType="VARCHAR2"</span>&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"&gt;
          &lt;xs:minLength value="10"/&gt;
          &lt;xs:maxLength value="14"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:attribute&gt;
    &lt;xs:attribute name="Quantity" type="moneyType" <span class="bold">xdb:SQLName="QUANTITY"</span>/&gt;
    &lt;xs:attribute name="UnitPrice" type="quantityType" <span class="bold">xdb:SQLName="UNITPRICE"</span>/&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:simpleType name="ReferenceType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="18"/&gt;
      &lt;xs:maxLength value="30"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:complexType name="ActionsType" <span class="bold">xdb:SQLType="ACTIONS_T"</span>&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="Action" maxOccurs="4" <span class="bold">xdb:SQLName="ACTION"</span> <span class="bold">xdb:SQLCollType="ACTION_V"</span>&gt;
        &lt;xs:complexType <span class="bold">xdb:SQLType="ACTION_T"</span>&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element name="User" type="UserType" <span class="bold">xdb:SQLName="ACTIONED_BY"</span>/&gt;
            &lt;xs:element name="Date" type="DateType" minOccurs="0" <span class="bold">xdb:SQLName="DATE_ACTIONED"</span>/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
      &lt;/xs:element&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="RejectionType" <span class="bold">xdb:SQLType="REJECTION_T"</span>&gt;
    &lt;xs:all&gt;
      &lt;xs:element name="User" type="UserType" minOccurs="0" <span class="bold">xdb:SQLName="REJECTED_BY"</span>/&gt;
      &lt;xs:element name="Date" type="DateType" minOccurs="0" <span class="bold">xdb:SQLName="DATE_REJECTED"</span>/&gt;
      &lt;xs:element name="Comments" type="CommentsType" minOccurs="0" <span class="bold">xdb:SQLName="REASON_REJECTED"</span>/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:complexType name="ShippingInstructionsType" <span class="bold">xdb:SQLType="SHIPPING_INSTRUCTIONS_T"</span>&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name="name" type="NameType" minOccurs="0" <span class="bold">xdb:SQLName="SHIP_TO_NAME"</span>/&gt;
      &lt;xs:element name="address" type="AddressType" minOccurs="0" <span class="bold">xdb:SQLName="SHIP_TO_ADDRESS"</span>/&gt;
      &lt;xs:element name="telephone" type="TelephoneType" minOccurs="0" <span class="bold">xdb:SQLName="SHIP_TO_PHONE"</span>/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
  &lt;xs:simpleType name="moneyType"&gt;
    &lt;xs:restriction base="xs:decimal"&gt;
      &lt;xs:fractionDigits value="2"/&gt;
      &lt;xs:totalDigits value="12"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="quantityType"&gt;
    &lt;xs:restriction base="xs:decimal"&gt;
      &lt;xs:fractionDigits value="4"/&gt;
      &lt;xs:totalDigits value="8"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="UserType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="10"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="RequestorType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="128"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="CostCenterType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="4"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="VendorType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="20"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="PurchaseOrderNumberType"&gt;
    &lt;xs:restriction base="xs:integer"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="SpecialInstructionsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="0"/&gt;
      &lt;xs:maxLength value="2048"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="NameType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="20"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="AddressType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="256"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="TelephoneType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="24"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="DateType"&gt;
    &lt;xs:restriction base="xs:date"/&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="CommentsType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="2048"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  &lt;xs:simpleType name="DescriptionType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
      &lt;xs:maxLength value="256"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;
</pre></div>
<!-- class="example" -->
<p>The <code>PurchaseOrder</code> XML schema defines the following two <span class="italic">namespaces</span>:</p>
<ul>
<li>
<p><code>http://www.w3c.org/2001/XMLSchema</code>. This is reserved by W3C for the Schema for Schemas.</p>
</li>
<li>
<p><code>http://xmlns.oracle.com/xdb</code>. This is reserved by Oracle for the Oracle XML&nbsp;DB schema annotations.</p>
</li>
</ul>
<p>The <code>PurchaseOrder</code> schema uses several <span class="italic">annotations</span>, including the following:</p>
<ul>
<li>
<p><code>defaultTable</code> annotation in the <code>PurchaseOrder</code> element. This specifies that XML documents, compliant with this XML schema are stored in a database table called <code>purchaseorder</code>.</p>
</li>
<li>
<p><code>SQLType</code> annotation.</p>
<p>The first occurrence of <code>SQLType</code> specifies that the name of the SQL type generated from <code>complexType</code> element <code>PurchaseOrderType</code> is <code>purchaseorder_t</code>.</p>
<p>The second occurrence of <code>SQLType</code> specifies that the name of the SQL type generated from the <code>complexType</code> element <code>LineItemType</code> is <code>lineitem_t</code> and the SQL type that manages the collection of <code>LineItem</code> elements is <code>lineitem_v</code>.</p>
</li>
<li>
<p><code>SQLName</code> annotation. This provides an explicit name for each SQL attribute of <code>purchaseorder_t</code>.</p>
</li>
</ul>
<p><a href="#BABGFHBJ">Figure 3-3</a> shows the XMLSpy Oracle tab, which facilitates adding Oracle XML&nbsp;DB schema annotations to an XML schema while working in the graphical editor.</p>
<div id="ADXDB4086" class="figure">
<p class="titleinfigure"><a id="BABGFHBJ"></a>Figure 3-3 XMLSpy Showing Support for Oracle XML&nbsp;DB Schema Annotations</p>
<img width="874" height="690" src="img/annot_spy.gif" alt="Description of Figure 3-3 follows" /><br />
<a id="sthref210" href="img_text/annot_spy.htm">Description of "Figure 3-3 XMLSpy Showing Support for Oracle XML&nbsp;DB Schema Annotations"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CHDEJGGH"></a>
<div id="ADXDB4087" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Registering an XML Schema with Oracle XML&nbsp;DB</h3>
<p>For an XML schema to be useful to Oracle XML&nbsp;DB you must first register it with Oracle XML&nbsp;DB. After it has been registered, it can be used for validating XML documents and for creating <code>XMLType</code> tables and columns bound to the XML schema.</p>
<p>Two items are required to register an XML schema with Oracle XML&nbsp;DB:</p>
<ul>
<li>
<p>The XML schema document</p>
</li>
<li>
<p>A string that can be used as a unique identifier for the XML schema, after it is registered with Oracle Database. Instance documents use this unique identifier to identify themselves as members of the class defined by the XML schema. The identifier is typically in the form of a URL, and is often referred to as the <span class="glossaryterm"><a id="sthref211"></a>schema location hint</span> or <span class="glossaryterm"><a id="sthref212"></a>document location hint</span>.</p>
</li>
</ul>
<p>You register an XML schema using PL/SQL procedure <code>DBMS_XMLSCHEMA.registerSchema</code>. <a href="#BABBIEAH">Example 3-11</a> illustrates this. By default, when an XML schema is registered, Oracle XML&nbsp;DB automatically generates all of the SQL object types and <code>XMLType</code> tables required to manage the instance documents. An XML schema can be registered as global or local.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb05sto.htm#CHDFAGFF">"Delete and Reload Documents Before Registering Their XML Schema"</a> for considerations to keep in mind when you register an XML schema</p>
</li>
<li>
<p><a href="xdb05sto.htm#BJFFCACF">"Local and Global XML Schemas"</a></p>
</li>
<li>
<p><a class="olink ARPLS377" href="../../appdev.112/e40758/d_xmlsch.htm#ARPLS377"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code>DBMS_XMLSCHEMA.registerSchema</code></p>
</li>
</ul>
</div>
<div id="ADXDB4088" class="example">
<p class="titleinexample"><a id="BABBIEAH"></a>Example 3-11 Registering an XML Schema using DBMS_XMLSCHEMA.REGISTERSCHEMA</p>
<pre>
BEGIN
  DBMS_XMLSCHEMA.registerSchema(
    SCHEMAURL =&gt; '<span class="bold">http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd</span>',
    SCHEMADOC =&gt; XDBURIType(<span class="bold">'/source/schemas/poSource/xsd/purchaseOrder.xs</span>d').getCLOB(),
    LOCAL     =&gt; <span class="bold">TRUE</span>,
    GENTYPES  =&gt; <span class="bold">TRUE</span>, 
    GENTABLES =&gt; TRUE);
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABBIEAH">Example 3-11</a>, the unique identifier for the XML schema is:</p>
<pre>
http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd
</pre>
<p>The XML schema document was previously loaded into Oracle XML&nbsp;DB Repository at this path: <code>/source/schemas/poSource/xsd/purchaseOrder.xsd</code>.</p>
<p>During XML schema registration, an <code>XDBURIType</code> accesses the content of the XML schema document, based on its location in the repository. Options passed to procedure <code>registerSchema</code> specify that the schema in <a href="#BABBIEAH">Example 3-11</a> is to be registered as a local XML schema, and that SQL objects, and that tables are to be generated during the registration process.</p>
<p>PL/SQL procedure <code>DBMS_XMLSCHEMA.registerSchema</code> performs the following operations:</p>
<ul>
<li>
<p>Parses and validates the XML schema.</p>
</li>
<li>
<p>Creates a set of entries in Oracle Data Dictionary that describe the XML schema.</p>
</li>
<li>
<p>Creates a set of SQL object definitions, based on <code>complexType</code> elements defined in the XML schema.</p>
</li>
<li>
<p>Creates an <code>XMLType</code> table for each global element defined by the XML schema.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb05sto.htm#BJFFCACF">"Local and Global XML Schemas"</a></div>
<div id="ADXDB4089" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref213"></a>
<h4 class="sect3">SQL Types and Tables Created During XML Schema Registration</h4>
<p><a href="#BABCFIIC">Example 3-12</a> illustrates the creation of object types during XML schema registration with Oracle XML&nbsp;DB.</p>
<div id="ADXDB4090" class="example">
<p class="titleinexample"><a id="BABCFIIC"></a>Example 3-12 Objects Created During XML Schema Registration</p>
<pre>
DESCRIBE purchaseorder_t
 purchaseorder_t is NOT FINAL
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 SYS_XDBPD$                                         XDB.XDB$RAW_LIST_T
 REFERENCE                                          VARCHAR2(30 CHAR)
 ACTIONS                                            ACTIONS_T
 REJECTION                                          REJECTION_T
 REQUESTOR                                          VARCHAR2(128 CHAR)
 USERID                                             VARCHAR2(10 CHAR)
 COST_CENTER                                        VARCHAR2(4 CHAR)
 SHIPPING_INSTRUCTIONS                              SHIPPING_INSTRUCTIONS_T
 SPECIAL_INSTRUCTIONS                               VARCHAR2(2048 CHAR)
 LINEITEMS                                          LINEITEMS_T
 
DESCRIBE lineitems_t
 lineitems_t is NOT FINAL
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 SYS_XDBPD$                                         XDB.XDB$RAW_LIST_T
 LINEITEM                                           LINEITEM_V
 
DESCRIBE lineitem_v
 lineitem_v VARRAY(2147483647) OF LINEITEM_T
 LINEITEM_T is NOT FINAL
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 SYS_XDBPD$                                         XDB.XDB$RAW_LIST_T
 ITEMNUMBER                                         NUMBER(38)
 DESCRIPTION                                        VARCHAR2(256 CHAR)
 PART                                               PART_T
</pre></div>
<!-- class="example" -->
<p>This example shows that SQL type definitions were created when the XML schema was registered with Oracle XML&nbsp;DB. These SQL type definitions include:</p>
<ul>
<li>
<p><code>purchaseorder_t</code>. This type is used to persist the SQL objects generated from a <code>PurchaseOrder</code> element. When an XML document containing a <code>PurchaseOrder</code> element is stored in Oracle XML&nbsp;DB the document is broken up, and the contents of the document are stored as an instance of <code>purchaseorder_t</code>.</p>
</li>
<li>
<p><code>lineitems_t</code>, <code>lineitem_v</code>, and <code>lineitem_t</code>. These types manage the collection of <code>LineItem</code> elements that may be present in a <code>PurchaseOrder</code> document. Type <code>lineitems_t</code> consists of a single attribute <code>lineitem</code>, defined as an instance of type <code>lineitem_v</code>. Type <code>lineitem_v</code> is defined as a varray of <code>linteitem_t</code> objects. There is one instance of the <code>lineitem_t</code> object for each <code>LineItem</code> element in the document.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BJFIBHAG"></a>
<div id="ADXDB4091" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Working with Large XML Schemas</h4>
<p>Several issues can arise when working with large, complex XML schemas. Sometimes, you encounter one of these errors when you register an XML schema or you create a table that is based on a global element defined by an XML schema:</p>
<ul>
<li>
<p><code>ORA-01792: maximum number of columns in a table or view is 1000</code></p>
</li>
<li>
<p><code>ORA-04031: unable to allocate</code> <code><span class="codeinlineitalic">string</span></code> <code>bytes of shared memory ("</code><code><span class="codeinlineitalic">string</span></code><code>","</code><code><span class="codeinlineitalic">string</span></code><code>","</code><code><span class="codeinlineitalic">string</span></code><code>","</code><code><span class="codeinlineitalic">string</span></code>"<code>)</code></p>
</li>
</ul>
<p>These errors are raised when an attempt is made to create an <code>XMLType</code> table or column based on a global element and the global element is defined as a <code>complexType</code> that contains a very large number of element and attribute definitions.The errors are raised only when creating an <code>XMLType</code> table or column that uses object-relational storage. In this case, the table or column is persisted using a SQL type, and each object attribute defined by the SQL type counts as one column in the underlying table. If the SQL type contains object attributes that are based on other SQL types, then the attributes defined by those types also count as columns in the underlying table.</p>
<p>If the total number of object attributes in all of the SQL types exceeds the Oracle Database limit of 1000 columns in a table, then the storage table cannot be created. When the total number of elements and attributes defined by a <code>complexType</code> reaches 1000, it is not possible to create a single table that can manage the SQL objects that are generated when an instance of that type is stored in the database.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
You can use the following query to determine the number of columns for a given <code>XMLType</code> table stored object-relationally:
<pre>
SELECT count(*) FROM USER_TAB_COLS WHERE TABLE_NAME = '<span class="italic">&lt;the table&gt;</span>'
</pre>
<p>where <code><span class="codeinlineitalic">&lt;the table&gt;</span></code> is the table you want to check.</p>
</div>
<p>Error <code>ORA-01792</code> reports that the 1000-column limit has been exceeded. Error <code>ORA-04031</code> reports that memory is insufficient during the processing of a large number of element and attribute definitions.To resolve this problem of having too many element and attribute definitions, you must reduce the total number of object attributes in the SQL types that are used to create the storage tables.</p>
<p>There are two ways to achieve this reduction:</p>
<ul>
<li>
<p>Use a top-down technique, with <span class="italic">multiple</span> <code>XMLType</code> <span class="italic">tables</span> that manage the XML documents. This reduces the number of SQL attributes in the SQL type hierarchy for a given storage table. As long as none of the tables need to manage more than 1000 object attributes, the problem is resolved.</p>
</li>
<li>
<p>Use a bottom-up technique, which reduces the number of SQL attributes in the SQL type hierarchy, <span class="italic">collapsing some elements and attributes</span> defined by the XML schema so that they are stored as a single <code>CLOB</code> value.</p>
</li>
</ul>
<p>Both techniques rely on annotating the XML schema to define how a particular <code>complexType</code> is stored in the database.</p>
<p>For the top-down technique, annotations <code>SQLInline = "false"</code> and <code>defaultTable</code> force some subelements in the XML document to be stored as rows in a separate <code>XMLType</code> table. Oracle XML&nbsp;DB maintains the relationship between the two tables using a <code>REF</code> of <code>XMLType</code>. Good candidates for this approach are XML schemas that do either of the following:</p>
<ul>
<li>
<p>Define a <span class="italic">choice</span>, where each element within the choice is defined as a <code>complexType</code></p>
</li>
<li>
<p>Define an element based on a <code>complexType</code> that contains a <span class="italic">large number of element and attribute definitions</span></p>
</li>
</ul>
<p>The bottom-up technique involves reducing the total number of attributes in the SQL object types by choosing to store some of the lower-level <code>complexType</code> elements as <code>CLOB</code> values, rather than as objects. This is achieved by annotating the <code>complexType</code> or the usage of the <code>complexType</code> with <code>SQLType = "CLOB"</code>.</p>
<p>Which technique you use depends on the application and the type of queries and updates to be performed against the data.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4092" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref214"></a>
<h4 class="sect3">Working with Global Elements</h4>
<p>By default, when an XML schema is registered with the database, Oracle XML&nbsp;DB generates a <span class="italic">default table for each global element</span> defined by the XML schema.</p>
<p>You can use attribute <code>xdb:defaultTable</code> to specify the name of the default table for a given global element. Each <code>xdb:defaultTable</code> attribute value you provide must be <span class="italic">unique</span> among <span class="italic">all schemas</span> registered by a given database user. If you do <span class="italic">not</span> supply a nonempty default table name for some element, then a unique name is provided automatically.</p>
<p>In practice, however, you do <span class="italic">not</span> want to create a default table for most global elements. Elements that never serve as the root element for an XML instance document do not need default tables&thinsp;&mdash;&thinsp;such tables are never used. Creating default tables for all global elements can lead to significant overhead in processor time and space used, especially if an XML schema contains a large number of global element definitions.</p>
<p>As a general rule, then, you want to prevent the creation of a default table for any global element (or any local element stored out of line) that you are sure will <span class="italic">not</span> be used as a root element in any document. You can do this in one of the following ways:</p>
<ul>
<li>
<p>Add the annotation <code>xdb:defaultTable =</code> <code><span class="codeinlinebold">""</span></code> (empty string) to the definition of <span class="italic">each</span> global element that will <span class="italic">not</span> appear as the root element of an XML instance document. Using this approach, you allow automatic default-table creation, in general, and you prohibit it explicitly where needed, using <code>xdb:defaultTable = ""</code>.</p>
</li>
<li>
<p>Set parameter <code>GENTABLES</code> to <code>FALSE</code> when registering the XML schema, and then <span class="italic">manually create the default table</span> for each global element that can legally appear as the root element of an instance document. Using this approach, you inhibit automatic default-table creation, and you create only the tables that are needed, by hand.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIGIEF"></a>
<div id="ADXDB4093" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating XML <a id="sthref215"></a>Schema-Based XMLType Columns and Tables</h3>
<p>After an XML schema has been registered with Oracle XML&nbsp;DB, it can be referenced when defining tables that contain <code>XMLType</code> columns or creating <code>XMLType</code> tables.</p>
<p>If you specify no storage model when creating an XMLType table or column for XML schema-based data, then the storage model used is that specified during registration of the referenced XML schema. If no storage model was specified for the XML schema registration, then object-relational storage is used.</p>
<p><a href="#CHDDIACH">Example 3-13</a> shows how to manually create table <code>purchaseorder</code>, the default table for <code>PurchaseOrder</code> elements.</p>
<div id="ADXDB4094" class="example">
<p class="titleinexample"><a id="CHDDIACH"></a>Example 3-13 Creating an XMLType Table that Conforms to an XML Schema</p>
<pre>
CREATE TABLE purchaseorder OF XMLType
  XMLSCHEMA "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"
  ELEMENT "PurchaseOrder"
  VARRAY "XMLDATA"."ACTIONS"."ACTION"
    STORE AS TABLE <span class="bold">action_table</span> 
                   ((PRIMARY KEY (<span class="bold">NESTED_TABLE_ID</span>, <span class="bold">SYS_NC_ARRAY_INDEX$</span>)))
  VARRAY "XMLDATA"."LINEITEMS"."LINEITEM"
    STORE AS TABLE <span class="bold">lineitem_table</span> 
                   ((PRIMARY KEY (<span class="bold">NESTED_TABLE_ID</span>, <span class="bold">SYS_NC_ARRAY_INDEX$</span>)));
</pre></div>
<!-- class="example" -->
<p>Each member of the varray that manages the collection of <code>Action</code> elements is stored in the ordered collection table <code>action_table</code>. Each member of the varray that manages the collection of <code>LineItem</code> elements is stored as a row in ordered collection table <code>lineitem_table</code>. The ordered collection tables are heap-based. Because of the <code>PRIMARY KEY</code> specification, they automatically contain pseudocolumn <a id="sthref216"></a><code>NESTED_TABLE_ID</code> and column <a id="sthref217"></a><code>SYS_NC_ARRAY_INDEX$</code>, which are required to link them back to the parent column.</p>
<p>This <code>CREATE TABLE</code> statement is equivalent to the <code>CREATE TABLE</code> statement that is generated automatically by Oracle XML&nbsp;DB when you set parameter <code>GENTABLES</code> to <code>TRUE</code> during XML schema registration. By default, the value of XML schema annotation <code>storeVarrayAsTable</code> is <code>true</code>, which automatically generates ordered collection tables (OCTs) for collections during XML schema registration. These OCTs are given system-generated names, which can be difficult to work with. You can give them more meaningful names using the SQL statement <code>RENAME TABLE</code>.</p>
<p>The <code>CREATE TABLE</code> statement in <a href="#CHDDIACH">Example 3-13</a> corresponds to a purchase-order document with a single level of nesting: The varray that manages the collection of <code>LineItem</code> elements is ordered collection table <code>lineitem_table</code>.</p>
<p>What if you had a different XML schema that had, say, a collection of <code>Shipment</code> elements inside a <code>Shipments</code> element that was, in turn, inside a <code>LineItem</code> element? In that case, you could create the table manually as shown in <a href="#CHDDAAFD">Example 3-14</a>.</p>
<div id="ADXDB4095" class="example">
<p class="titleinexample"><a id="CHDDAAFD"></a>Example 3-14 Creating an XMLType Table for <a id="sthref218"></a>Nested Collections</p>
<pre>
CREATE TABLE purchaseorder OF XMLType
  XMLSCHEMA "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"
  ELEMENT "PurchaseOrder"
  VARRAY "XMLDATA"."ACTIONS"."ACTION"
    STORE AS TABLE action_table 
                   ((PRIMARY KEY (NESTED_TABLE_ID, SYS_NC_ARRAY_INDEX$)))
                   <span class="bold">VARRAY "XMLDATA"."LINEITEMS"."LINEITEM"</span>
    STORE AS TABLE <span class="bold">lineitem_table</span> 
                   ((PRIMARY KEY (NESTED_TABLE_ID, SYS_NC_ARRAY_INDEX$))
                    <span class="bold">VARRAY "SHIPMENTS"."SHIPMENT"</span>
                      STORE AS TABLE <span class="bold">shipments_table</span>
                                     ((PRIMARY KEY (NESTED_TABLE_ID,
                                                    SYS_NC_ARRAY_INDEX$))));
</pre></div>
<!-- class="example" -->
<p>A SQL*Plus <code>DESCRIBE</code> statement can be used to view information about an <code>XMLType</code> table, as shown in <a href="#BJFCCIGE">Example 3-15</a>.</p>
<div id="ADXDB4096" class="example">
<p class="titleinexample"><a id="BJFCCIGE"></a>Example 3-15 Using DESCRIBE with an XML Schema-Based XMLType Table</p>
<pre>
DESCRIBE purchaseorder
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
TABLE of SYS.XMLTYPE(XMLSchema
"http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"
Element "PurchaseOrder") STORAGE Object-relational TYPE "PURCHASEORDER_T"
</pre></div>
<!-- class="example" -->
<p>The output of the <code>DESCRIBE</code> statement of <a href="#BJFCCIGE">Example 3-15</a> shows the following information about table <code>purchaseorder</code>:</p>
<ul>
<li>
<p>The table is an <code>XMLType</code> table</p>
</li>
<li>
<p>The table is constrained to storing <code>PurchaseOrder</code> documents as defined by the <code>PurchaseOrder</code> XML schema</p>
</li>
<li>
<p>Rows in this table are stored as a set of objects in the database</p>
</li>
<li>
<p>SQL type <code>purchaseorder_t</code> is the base object for this table</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4097" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref219"></a>
<h3 class="sect2">Default Tables</h3>
<p>The XML schema in <a href="#CHDDIACH">Example 3-13</a> specifies that the <code>PurchaseOrder</code> table is the default table for <code>PurchaseOrder</code> elements. When an XML document compliant with the XML schema is inserted into Oracle XML&nbsp;DB Repository using protocols or PL/SQL, the content of the XML document is stored as a row in the <code>purchaseorder</code> table.</p>
<p>When an XML schema is registered as a global schema, you must grant the appropriate access rights on the default table to all other users of the database, before they can work with instance documents that conform to the globally registered XML schema.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb05sto.htm#BJFFCACF">"Local and Global XML Schemas"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBGBDA"></a>
<div id="ADXDB4098" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Identifying XML Schema Instance Documents</h2>
<p>Before an XML document can be inserted into an XML schema-based <code>XMLType</code> table or column the document must identify the associated XML schema. There are two ways to do this:</p>
<ul>
<li>
<p>Explicitly identify the XML schema when creating the <code>XMLType</code>. This can be done by passing the name of the XML schema to the <code>XMLType</code> constructor, or by invoking <code>XMLType</code> method <code>createSchemaBasedXML()</code>.</p>
</li>
<li>
<p>Use the <code>XMLSchema-instance</code> mechanism to explicitly provide the required information in the XML document. This option can be used when working with Oracle XML&nbsp;DB.</p>
</li>
</ul>
<p>The advantage of the <code>XMLSchema-instance</code> mechanism is that it lets the Oracle XML&nbsp;DB protocol servers recognize that an XML document inserted into Oracle XML&nbsp;DB Repository is an instance of a registered XML schema. The content of the instance document is automatically stored in the default table specified by that XML schema.</p>
<p>The <code>XMLSchema-instance</code> mechanism is defined by the W3C XML Schema working group. It is based on adding attributes that identify the target XML schema to the root element of the instance document. These attributes are defined by the <code>XMLSchema-instance</code> namespace.</p>
<p>To identify an instance document as a member of the class defined by a particular XML schema you must declare the <code>XMLSchema-instance</code> namespace by adding a namespace declaration to the root element of the instance document. For example:</p>
<p><code>xmlns:xsi = http://www.w3.org/2001/XMLSchema-instance</code></p>
<p>Once the <code>XMLSchema-instance</code> namespace has been declared and given a <code>namespace</code> prefix, attributes that identify the XML schema can be added to the root element of the instance document. In the preceding example, the namespace prefix for the <code>XMLSchema-instance</code> namespace was defined as <code>xsi</code>. This prefix can then be used when adding the <code>XMLSchema-instance</code> attributes to the root element of the instance document.</p>
<p>Which attributes must be added depends on several factors. There are two possibilities, <code>noNamespaceSchemaLocation</code> and <code>schemaLocation</code>. Depending on the XML schema, one or both of these attributes is required to identify the XML schemas that the instance document is associated with.</p>
<div id="ADXDB4099" class="sect2"><a id="sthref220"></a>
<h3 class="sect2">Attributes noNamespaceSchemaLocation and schemaLocation</h3>
<p>If the target XML schema does not declare a target namespace, the <code>noNamespaceSchemaLocation</code> attribute is used to identify the XML schema. The value of the attribute is the <span class="italic">schema location hint</span>. This is the unique identifier passed to PL/SQL procedure <code>DBMS_XMLSCHEMA.registerSchema</code> when the XML schema is registered with the database.</p>
<p>For XML schema <code>purchaseOrder.xsd</code>, the correct definition of the root element of the instance document would read as follows:</p>
<pre>
&lt;PurchaseOrder
  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
  xsi:noNamespaceSchemaLocation=
    "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"&gt;
</pre>
<p>If the target XML schema declares a target namespace, then the <code>schemaLocation</code> attribute is used to identify the XML schema. The value of this attribute is a pair of values separated by a space:</p>
<ul>
<li>
<p>the value of the <span class="italic">target namespace</span> declared in the XML schema</p>
</li>
<li>
<p>the <span class="italic">schema location hint</span>, the unique identifier passed to procedure <code>DBMS_XMLSCHEMA.registerSchema</code> when the schema is registered with the database</p>
</li>
</ul>
<p>For example, assume that the <code>PurchaseOrder</code> XML schema includes a target namespace declaration. The root element of the schema would look like this:</p>
<pre>
&lt;xs:schema <span class="bold">targetNamespace="http://demo.oracle.com/xdb/purchaseOrder"</span>
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:xdb="http://xmlns.oracle.com/xdb"
           version="1.0" xdb:storeVarrayAsTable="true"&gt;
   &lt;xs:element name="PurchaseOrder" type="PurchaseOrderType"
               xdb:defaultTable="PURCHASEORDER"/&gt;
</pre>
<p>In this case, the correct form of the root element of the instance document would read as follows:</p>
<pre>
&lt;PurchaseOrder
    xnlns="http://demo.oracle.com/xdb/purchaseOrder"
    xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
    <span class="bold">xsi:schemaLocation=</span>
      "<span class="bold">http://demo.oracle.com/xdb/purchaseOrder</span>
       <span class="bold">http://mdrake-lap:8080/source/schemas/poSource/xsd/purchaseOrder.xsd</span>"&gt;
</pre></div>
<!-- class="sect2" -->
<div id="ADXDB4100" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref221"></a>
<h3 class="sect2">Dealing with Multiple Namespaces</h3>
<p>When the XML schema includes elements defined in multiple namespaces, an entry must occur in the <code>schemaLocation</code> attribute for each of the XML schemas. Each entry consists of the namespace declaration and the <span class="italic">schema location hint</span>. The entries are separated from each other by one or more whitespace characters. If the primary XML schema does not declare a target namespace, then the instance document also needs to include a <code>noNamespaceSchemaLocation</code> attribute that provides the <span class="italic">schema location hint</span> for the primary XML schema.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABECCBG"></a>
<div id="ADXDB0345" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Enforcing XML Data Integrity using the Database</h2>
<p>One advantage of using Oracle XML&nbsp;DB to manage XML content is that SQL can be used to supplement the functionality provided by XML schema. Combining the power of SQL and XML with the ability of the database to enforce rules makes the database a powerful framework for managing XML content.</p>
<p>Only well-formed XML documents can be stored in <code>XMLType</code> tables or columns. A <span class="glossaryterm">well-formed<a id="sthref222"></a></span> XML document is one that conforms to the syntax of the XML version declared in its XML declaration. This includes having a single root element, properly nested tags, and so forth. Additionally, if the <code>XMLType</code> table or column is constrained to an XML schema, only documents that conform to that XML schema can be stored in that table or column. Any attempt to store or insert any other kind of XML document in an XML schema-based <code>XMLType</code> raises an error. <a href="#BABCBCJJ">Example 3-16</a> illustrates this.</p>
<div id="ADXDB4101" class="example">
<p class="titleinexample"><a id="BABCBCJJ"></a>Example 3-16 Error From Attempting to Insert an Incorrect XML Document</p>
<pre>
INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'Invoice.xml'), nls_charset_id('AL32UTF8')))
  VALUES (XMLType(bfilename('XMLDIR', 'Invoice.xml'), nls_charset_id('AL32UTF8')))
          *
ERROR at line 2:
ORA-19007: Schema - does not match expected
http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd.
</pre></div>
<!-- class="example" -->
<p>Such an error only occurs when content is inserted directly into an <code>XMLType</code> table. It indicates that Oracle XML&nbsp;DB did not recognize the document as a member of the class defined by the XML schema. For a document to be recognized as a member of the class defined by the schema, the following conditions must be true:</p>
<ul>
<li>
<p>The name of the XML document root element must match the name of global element used to define the <code>XMLType</code> table or column.</p>
</li>
<li>
<p>The XML document must include the appropriate attributes from the <code>XMLSchema-instance</code> namespace, or the XML document must be explicitly associated with the XML schema using the <code>XMLType</code> constructor or <code>XMLType</code> method <code>createSchemaBasedXML()</code>.</p>
</li>
</ul>
<p>If the constraining XML schema declares a <code>targetNamespace</code>, then the instance documents must contain the appropriate namespace declarations to place the root element of the document in the <code>targetNamespace</code> defined by the XML schema.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
XML constraints are enforced only within individual XML documents. Database (SQL) constraints are enforced across sets of XML documents.</div>
<a id="CEGGEFGF"></a>
<div id="ADXDB4102" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Comparing Partial to Full XML Schema Validation</h3>
<p>This section describes the differences between partial and full XML schema validation used when inserting XML documents into the database.</p>
<a id="CHDCEAEA"></a>
<div id="ADXDB4103" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Partial Validation</h4>
<p>For binary XML storage, Oracle XML&nbsp;DB performs a full validation whenever an XML document is inserted into an XML schema-based <code>XMLType</code> table or column. For all other models of XML storage, Oracle XML&nbsp;DB performs only a partial validation of the document. This is because, except for binary XML storage, complete XML schema validation is quite costly, in terms of performance.</p>
<p><span class="bold"><a id="sthref223"></a><a id="sthref224"></a>Partial validation</span> ensures only that all of the mandatory elements and attributes are present, and that there are no unexpected elements or attributes in the document. That is, it ensures only that the structure of the XML document conforms to the SQL data type definitions that were derived from the XML schema. Partial validation does not ensure that the instance document is fully compliant with the XML schema.</p>
<p><a href="#BABFEGDC">Example 3-17</a> provides an example of failing partial validation while inserting an XML document into table <code>PurchaseOrder</code>, which is stored object-relationally.</p>
<div id="ADXDB4104" class="example">
<p class="titleinexample"><a id="BABFEGDC"></a>Example 3-17 Error When Inserting Incorrect XML Document (Partial Validation)</p>
<pre>
INSERT INTO purchaseorder
  VALUES(XMLType(bfilename('XMLDIR', 'InvalidElement.xml'),
                 nls_charset_id('AL32UTF8')));
  VALUES(XMLType(bfilename('XMLDIR', 'InvalidElement.xml'),
         *
ERROR at line 2:
ORA-30937: No schema definition for 'UserName' (namespace '##local') in parent
'/PurchaseOrder'
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADXDB4105" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref225"></a>
<h4 class="sect3">Full Validation</h4>
<p>Loading XML data into XML schema-based binary XML storage causes full validation against the target XML schemas. Otherwise, regardless of storage model, you can force full validation of XML instance documents against an XML schema at any time, using either of the following:</p>
<ul>
<li>
<p>Table level <code>CHECK</code> constraint</p>
</li>
<li>
<p>PL/SQL <code>BEFORE INSERT</code> trigger</p>
</li>
</ul>
<p>Both approaches ensure that only valid XML documents can be stored in the <code>XMLType</code> table.</p>
<p>The advantage of a <code>TABLE CHECK</code> constraint is that it is easy to code. The disadvantage is that it is based on Oracle SQL function <code>XMLisValid</code>, so it can only indicate whether or not the XML document is valid. If an XML document is invalid, a <code>TABLE CHECK</code> constraint cannot provide any information as to <span class="italic">why</span> it is invalid.</p>
<p>A <code>BEFORE INSERT</code> trigger requires slightly more code. The trigger validates the XML document by invoking <code>XMLType</code> method <code>schemaValidate()</code>. The advantage of using <code>schemaValidate()</code> is that the exception raised provides additional information about what was wrong with the instance document. Using a <code>BEFORE INSERT</code> trigger also makes it possible to attempt corrective action when an invalid document is encountered.</p>
<div id="ADXDB4106" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref226"></a>
<h5 class="sect4">Full XML Schema Validation Costs Processing Time and Memory Usage</h5>
<p>Unless you are using binary XML storage, full XML schema validation costs processing time and memory. You should thus perform full XML schema validation only when necessary. If you can rely on your application to validate an XML document, you can obtain higher overall throughput with non-binary XML storage, by avoiding the overhead associated with full validation. If you cannot be sure about the validity of incoming XML documents, you can rely on the database to ensure that an <code>XMLType</code> table or column contains only schema-valid XML documents.</p>
<p><a href="#BABHIFBH">Example 3-18</a> shows how to force a full XML schema validation by adding a <code>CHECK</code> constraint to an <code>XMLType</code> table. In <a href="#BABHIFBH">Example 3-18</a>, the XML document <code>InvalidReference</code> is a not valid with respect to the XML schema. The XML schema defines a minimum length of 18 characters for the text node associated with the <code>Reference</code> element. In this document, the node contains the value <code>SBELL-20021009</code>, which is only 14 characters long. Partial validation would not catch this error. Unless the constraint or trigger is present, attempts to insert this document into the database would succeed.</p>
<div id="ADXDB4107" class="example">
<p class="titleinexample"><a id="BABHIFBH"></a>Example 3-18 Forcing Full XML Schema Validation using a <a id="sthref227"></a><a id="sthref228"></a><a id="sthref229"></a>CHECK Constraint</p>
<pre>
ALTER TABLE purchaseorder
  ADD CONSTRAINT validate_purchaseorder
  <span class="bold">CHECK (XMLIsValid(OBJECT_VALUE) = 1);</span>
 
Table altered.
 
INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'InvalidReference.xml'),
                  nls_charset_id('AL32UTF8')));

INSERT INTO purchaseorder
*
 
ERROR at line 1:
ORA-02290: check constraint (QUINE.VALIDATE_PURCHASEORDER) violated
</pre>
<p>Pseudocolumn <code>OBJECT_VALUE</code> can be used to access the content of an <code>XMLType</code> table from within a trigger. <a href="#BABDJDHC">Example 3-19</a> illustrates this, showing how to use a <code>BEFORE INSERT</code> trigger to validate that the data being inserted into the <code>XMLType</code> table conforms to the specified XML schema.</p>
</div>
<!-- class="example" -->
<div id="ADXDB4108" class="example">
<p class="titleinexample"><a id="BABDJDHC"></a>Example 3-19 Enforcing Full XML Schema Validation using a BEFORE INSERT Trigger</p>
<pre>
CREATE OR REPLACE TRIGGER validate_purchaseorder
   BEFORE INSERT ON purchaseorder
   FOR EACH ROW
BEGIN
  IF (:new.OBJECT_VALUE IS NOT NULL) THEN :new.<span class="bold">OBJECT_VALUE.schemavalidate</span>();
  END IF;
END;
/

INSERT INTO purchaseorder  VALUES (XMLType(bfilename('XMLDIR', 'InvalidReference.xml'),
                  nls_charset_id('AL32UTF8')));
  VALUES (XMLType( bfilename('XMLDIR', 'InvalidReference.xml'),
          *
ERROR at line 2:
ORA-31154: invalid XML document
ORA-19202: Error occurred in XML processing
LSX-00221: "SBELL-20021009" is too short (minimum length is 18)
ORA-06512: at "SYS.XMLTYPE", line 354
ORA-06512: at "QUINE.VALIDATE_PURCHASEORDER", line 3
ORA-04088: error during execution of trigger 'QUINE.VALIDATE_PURCHASEORDER'
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIGJDE"></a>
<div id="ADXDB4109" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Enforcing Referential Integrity using SQL Constraints</h3>
<p>The W3C XML Schema Recommendation defines a powerful language for defining the contents of an XML document. However, there are some simple data management concepts that are not currently addressed by the W3C XML Schema Recommendation. These include the ability to ensure that the value of an element or attribute has either of these properties:</p>
<ul>
<li>
<p>It is unique across a set of XML documents (a <code>UNIQUE</code> constraint).</p>
</li>
<li>
<p>It exists in a particular data source that is outside of the current document (<code>FOREIGN KEY</code> constraint).</p>
</li>
</ul>
<p>With Oracle XML&nbsp;DB, however, you can enforce such constraints. The mechanisms that you use to enforce integrity on XML data are the same mechanisms that you use to enforce integrity on relational data. Simple rules, such as uniqueness and foreign-key relationships, can be enforced by specifying constraints. More complex rules can be enforced by specifying database triggers.</p>
<p>Oracle XML&nbsp;DB lets you use the database to enforce business rules on XML content, in addition to enforcing rules that can be specified using XML Schema constructs. The database enforces these business rules regardless of whether XML is inserted directly into a table or uploaded using one of the protocols supported by Oracle XML&nbsp;DB Repository.</p>
<p><a href="#CHDGIABF">Example 3-20</a>, <a href="#BABGHJIA">Example 3-21</a>, and <a href="#BABHEHEG">Example 3-22</a> illustrate how you can use SQL constraints to enforce referential integrity. <a href="#CHDGIABF">Example 3-20</a> defines a uniqueness constraint on an <code>XMLType</code> table that is stored as binary XML. It defines a virtual column, using the <code>Reference</code> element in a purchase-order document. The uniqueness constraint <code>reference_is_unique</code> ensures that the value of node <code>/PurchaseOrder/Reference/text()</code> is unique across all documents that are stored in the table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDJHDBI">"Partitioning or Constraining Binary XML Data using Virtual Columns"</a></div>
<div id="ADXDB4110" class="example">
<p class="titleinexample"><a id="CHDGIABF"></a>Example 3-20 Constraining a Binary XML Table using a Virtual Column</p>
<pre>
CREATE TABLE po_binaryxml OF XMLType
  XMLTYPE STORE AS BINARY XML
  <span class="bold">VIRTUAL COLUMNS</span>
    (<span class="bold">c_reference</span> AS (XMLCast(XMLQuery('/PurchaseOrder/Reference'
                                      PASSING OBJECT_VALUE RETURNING CONTENT)
                             AS VARCHAR2(32))));
 
INSERT INTO po_binaryxml SELECT OBJECT_VALUE FROM OE.purchaseorder;

132 rows created.
 
ALTER TABLE po_binaryxml ADD CONSTRAINT reference_is_unique UNIQUE (<span class="bold">c_reference</span>);
 
INSERT INTO po_binaryxml
  VALUES (XMLType(bfilename('XMLDIR', 'DuplicateReference.xml'),
                  nls_charset_id('AL32UTF8')));
INSERT INTO po_binaryxml
*
ERROR at line 1:
ORA-00001: unique constraint (OE.REFERENCE_IS_UNIQUE) violated
 
</pre></div>
<!-- class="example" -->
<p><a href="#BABGHJIA">Example 3-21</a> defines a uniqueness constraint similar to that of <a href="#CHDGIABF">Example 3-20</a>, but on <code>XMLType</code> table <code>purchaseorder</code> in standard database schema <code>OE</code>. In addition, it defines a foreign-key constraint that requires the <code>User</code> element of each purchase-order document to be the e-mail address of an employee that is in standard database table <code>HR.employees</code>. For XML data that is stored object-relationally, such as that in table <code>OE.purchaseorder</code>, constraints must be specified in terms of object attributes of the SQL data types that are used to manage the XML content.</p>
<div id="ADXDB4111" class="example">
<p class="titleinexample"><a id="BABGHJIA"></a>Example 3-21 Integrity Constraints and Triggers for an XMLType Table Stored Object-Relationally</p>
<pre>
ALTER TABLE purchaseorder
  ADD CONSTRAINT reference_is_unique
  UNIQUE (<span class="bold">XMLDATA."REFERENCE"</span>);
 
ALTER TABLE purchaseorder
  ADD CONSTRAINT user_is_valid
  FOREIGN KEY (<span class="bold">XMLDATA."USERID"</span>) REFERENCES hr.employees(email);
 
INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'purchaseOrder.xml'),
                  nls_charset_id('AL32UTF8')));
 
INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'DuplicateReference.xml'),
                  nls_charset_id('AL32UTF8')));

INSERT INTO purchaseorder
*
ERROR at line 1:
ORA-00001: unique constraint (QUINE.REFERENCE_IS_UNIQUE) violated
 
INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'InvalidUser.xml'),
                  nls_charset_id('AL32UTF8')));

INSERT INTO purchaseorder
*
ERROR at line 1:
ORA-02291: integrity constraint (QUINE.USER_IS_VALID) violated - parent key not
 found
</pre></div>
<!-- class="example" -->
<p>Just as for <a href="#CHDGIABF">Example 3-20</a>, the uniqueness constraint <code>reference_is_unique</code> of <a href="#BABGHJIA">Example 3-21</a> ensures the uniqueness of the purchase-order <code>Reference</code> element across all documents stored in the table. The foreign key constraint <code>user_is_valid</code> here ensures that the value of element <code>User</code> corresponds to a value in column <code>email</code> of table <code>employees</code>.</p>
<p>The text node associated with the <code>Reference</code> element in the XML document <code>DuplicateRefernce.xml</code> contains the same value as the corresponding node in XML document <code>PurchaseOrder.xml</code>. Attempting to store both documents in Oracle XML&nbsp;DB thus violates the constraint <code>reference_is_unique</code>.</p>
<p>The text node associated with the <code>User</code> element in XML document <code>InvalidUser.xml</code> contains the value <code>HACKER</code>. There is no entry in the <code>employees</code> table where the value of column <code>email</code> is <code>HACKER</code>. Attempting to store this document in Oracle XML&nbsp;DB violates the constraint <code>user_is_valid</code>.</p>
<p>Integrity rules defined using constraints and triggers are also enforced when XML schema-based XML content is loaded into Oracle XML&nbsp;DB Repository. <a href="#BABHEHEG">Example 3-22</a> illustrates this. It shows that database integrity is also enforced when a protocol, such as FTP, is used to upload XML schema-based XML content into Oracle XML&nbsp;DB Repository.</p>
<div id="ADXDB4112" class="example">
<p class="titleinexample"><a id="BABHEHEG"></a>Example 3-22 Enforcing Database Integrity When Loading XML using FTP</p>
<pre>
$ ftp localhost 2100
Connected to localhost.
220 mdrake-sun FTP Server (Oracle XML DB/Oracle Database 10g Enterprise Edition
Release 10.1.0.0.0 - Beta) ready.
Name (localhost:oracle10): QUINE
331 Password required for QUINE
Password: <span class="italic">password</span>
230 QUINE logged in
ftp&gt; cd /source/schemas
250 CWD Command successful
ftp&gt; put InvalidReference.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-00604: error occurred at recursive SQL level 1
ORA-31154: invalid XML document
ORA-19202: Error occurred in XML processing
LSX-00221: "SBELL-20021009" is too short (minimum length is 18)
ORA-06512: at "SYS.XMLTYPE", line 333
ORA-06512: at "QUINE.VALIDATE_PURCHASEORDER", line 3
ORA-04088: error during execution of trigger 'QUINE.VALIDATE_PURCHASEORDER'
550 End Error Response
ftp&gt; put InvalidElement.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-30937: No schema definition for 'UserName' (namespace '##local') in parent
'PurchaseOrder'
550 End Error Response
ftp&gt; put DuplicateReference.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-00604: error occurred at recursive SQL level 1
ORA-00001: unique constraint (QUINE.REFERENCE_IS_UNIQUE) violated
550 End Error Response
ftp&gt; put InvalidUser.xml
200 PORT Command successful
150 ASCII Data Connection
550- Error Response
ORA-00604: error occurred at recursive SQL level 1
ORA-02291: integrity constraint (QUINE.USER_IS_VALID) violated - parent key not
 found
550 End Error Response
</pre></div>
<!-- class="example" -->
<p>When an error occurs while a document is being uploaded with a protocol, Oracle XML&nbsp;DB provides the client with the full SQL error trace. How the error is interpreted and reported to you is determined by the error-handling built into the client application. Some clients, such as the command line FTP tool, reports the error returned by Oracle XML&nbsp;DB, while others, such as Microsoft Windows Explorer, report a generic error message.</p>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1031">
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028">
<p class="notep1">See also:</p>
<ul>
<li>
<p><a href="xdb05sto.htm#CHDGJGIB">"Specifying Relational Constraints on XMLType Tables and Columns"</a></p>
</li>
<li>
<p><a class="olink ERRMG" href="../../server.112/e17766/toc.htm"><span class="italic">Oracle Database Error Messages</span></a></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIEGGG"></a>
<div id="ADXDB4114" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">DML Operations on XML Content using Oracle XML&nbsp;DB</h2>
<p>Another major advantage of using Oracle XML&nbsp;DB to manage XML content is that it leverages the power of Oracle Database to deliver powerful, flexible capabilities for querying and updating XML content, including the following:</p>
<ul>
<li>
<p>Retrieving nodes and fragments within an XML document</p>
</li>
<li>
<p>Updating nodes and fragments within an XML document</p>
</li>
<li>
<p>Creating indexes on specific nodes within an XML document</p>
</li>
<li>
<p>Indexing the entire content of an XML document</p>
</li>
<li>
<p>Determining whether an XML document contains a particular node</p>
</li>
</ul>
<div id="ADXDB4115" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref230"></a>
<h3 class="sect2">XPath and Oracle XML</h3>
<p>Oracle XML&nbsp;DB includes <code>XMLType</code> methods and XML-specific SQL functions. With these, you can query and update XML content stored in Oracle Database. They use the W3C XPath Recommendation to identify the required node or nodes. Each node in an XML document can be uniquely identified by an XPath expression.</p>
<p>An XPath expression consists of a slash-separated list of element names, attributes names, and XPath functions. XPath expressions can contain positions and conditions that determine which branch of the tree is traversed in determining the target nodes.</p>
<p>By supporting XPath-based methods and functions, Oracle XML&nbsp;DB makes it possible for XML programmers to query and update XML documents in a familiar, standards-compliant manner.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle SQL functions and <code>XMLType</code> methods respect the W3C XPath recommendation, which states that if an XPath expression targets <span class="italic">no nodes</span> when applied to XML data, then an empty sequence must be returned. An error must <span class="italic">not</span> be raised in this case.
<p>The specific semantics of an Oracle SQL function or <code>XMLType</code> method that applies an XPath expression to XML data determines what is returned. For example, SQL/XML function <code>XMLQuery</code> returns <code>NULL</code> if its XPath-expression argument targets no nodes, and the updating SQL functions, such as <code>deleteXML</code>, return the input XML data unchanged. An error is never raised if no nodes are targeted, but updating SQL functions can raise an error if an XPath-expression argument targets inappropriate nodes, such as attribute nodes or text nodes.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDGDJG"></a>
<div id="ADXDB4116" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Querying XML Content Stored in Oracle XML&nbsp;DB</h2>
<p>This section describes techniques for querying Oracle XML&nbsp;DB and retrieving XML content. This section contains these topics:</p>
<ul>
<li>
<p><a href="#BABDFADC">PurchaseOrder XML Document</a></p>
</li>
<li>
<p><a href="#BABBIJAG">Retrieving the Content of an XML Document using Pseudocolumn OBJECT_VALUE</a></p>
</li>
<li>
<p><a href="#BABEAAJC">Accessing Fragments or Nodes of an XML Document using XMLQUERY</a></p>
</li>
<li>
<p><a href="#BABGDDDA">Accessing Text Nodes and Attribute Values using XMLCAST and XMLQUERY</a></p>
</li>
<li>
<p><a href="#BABBBJBE">Searching an XML Document using XMLEXISTS, XMLCast, and XMLQuery</a></p>
</li>
<li>
<p><a href="#BABFEHBD">Performing SQL Operations on XMLType Fragments using XMLTABLE</a></p>
</li>
</ul>
<a id="BABDFADC"></a>
<div id="ADXDB4117" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">PurchaseOrder XML Document</h3>
<p>Examples in this section are based on the <code>PurchaseOrder</code> XML document shown in <a href="#BJFDAFHE">Example 3-23</a>.</p>
<div id="ADXDB4118" class="example">
<p class="titleinexample"><a id="BJFDAFHE"></a>Example 3-23 PurchaseOrder XML Instance Document</p>
<pre>
&lt;PurchaseOrder 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation=
    "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"&gt;
  &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
  &lt;Actions&gt;
    &lt;Action&gt;
      &lt;User&gt;SVOLLMAN&lt;/User&gt;
    &lt;/Action&gt;
  &lt;/Actions&gt;
  &lt;Reject/&gt;
  &lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
  &lt;User&gt;SBELL&lt;/User&gt;
  &lt;CostCenter&gt;S30&lt;/CostCenter&gt;
  &lt;ShippingInstructions&gt;
    &lt;name&gt;Sarah J. Bell&lt;/name&gt;
    &lt;address&gt;400 Oracle Parkway
      Redwood Shores
      CA
      94065
      USA&lt;/address&gt;
    &lt;telephone&gt;650 506 7400&lt;/telephone&gt;
  &lt;/ShippingInstructions&gt;
  &lt;SpecialInstructions&gt;Air Mail&lt;/SpecialInstructions&gt;
  &lt;LineItems&gt;
    &lt;LineItem ItemNumber="1"&gt;
      &lt;Description&gt;A Night to Remember&lt;/Description&gt;
      &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="2"&gt;
      &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
      &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="3"&gt;
      &lt;Description&gt;Sisters&lt;/Description&gt;
      &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
    &lt;/LineItem&gt;
  &lt;/LineItems&gt;
&lt;/PurchaseOrder&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABBIJAG"></a>
<div id="ADXDB4119" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Retrieving the Content of an XML Document using Pseudocolumn OBJECT_VALUE</h3>
<p>Pseudocolumn <code>OBJECT_VALUE</code> can be used as an alias for the value of an object table. For an <code>XMLType</code> table that consists of a single column of <code>XMLType</code>, the entire XML document is retrieved. (<code>OBJECT_VALUE</code> replaces the <code>value(x)</code> and <code>SYS_NC_ROWINFO$</code> aliases used in releases prior to Oracle Database10g Release 1.)</p>
<p>In <a href="#BJFCECGJ">Example 3-24</a>, the SQL*Plus settings <code>PAGESIZE</code> and <code>LONG</code> are used to ensure that the entire document is printed correctly, without line breaks. (The output has been formatted for readability.)</p>
<div id="ADXDB4120" class="example">
<p class="titleinexample"><a id="BJFCECGJ"></a>Example 3-24 Retrieving an Entire XML Document using OBJECT_VALUE</p>
<pre>
SET LONG 10000
SET PAGESIZE 100

SELECT OBJECT_VALUE FROM purchaseorder;
 
OBJECT_VALUE
-----------------------------------------------------------------------
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="http://localhost:8080/source/schemas
/poSource/xsd/purchaseOrder.xsd"&gt;
  &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
  &lt;Actions&gt;
    &lt;Action&gt;
      &lt;User&gt;SVOLLMAN&lt;/User&gt;
    &lt;/Action&gt;
  &lt;/Actions&gt;
  &lt;Reject/&gt;
  &lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
  &lt;User&gt;SBELL&lt;/User&gt;
  &lt;CostCenter&gt;S30&lt;/CostCenter&gt;
  &lt;ShippingInstructions&gt;
    &lt;name&gt;Sarah J. Bell&lt;/name&gt;
    &lt;address&gt;400 Oracle Parkway
Redwood Shores
CA
94065
USA&lt;/address&gt;
    &lt;telephone&gt;650 506 7400&lt;/telephone&gt;
  &lt;/ShippingInstructions&gt;
  &lt;SpecialInstructions&gt;Air Mail&lt;/SpecialInstructions&gt;
  &lt;LineItems&gt;
    &lt;LineItem ItemNumber="1"&gt;
      &lt;Description&gt;A Night to Remember&lt;/Description&gt;
      &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="2"&gt;
      &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
      &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    &lt;LineItem ItemNumber="3"&gt;
      &lt;Description&gt;Sisters&lt;/Description&gt;
      &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
    &lt;/LineItem&gt;
  &lt;/LineItems&gt;
&lt;/PurchaseOrder&gt;
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABEAAJC"></a>
<div id="ADXDB4121" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Accessing Fragments or Nodes of an XML Document using XMLQUERY</h3>
<p>You can use SQL/XML function <code>XMLQuery</code> to extract the nodes that match an XPath expression. The result is returned as an instance of <code>XMLType</code>. <a href="#BABBGCHJ">Example 3-25</a> illustrates this with several queries.</p>
<div id="ADXDB4122" class="example">
<p class="titleinexample"><a id="BABBGCHJ"></a>Example 3-25 Accessing XML Fragments using XMLQUERY</p>
<p>The following query returns an <code>XMLType</code> instance containing the <code>Reference</code> element that matches the XPath expression.</p>
<pre>
SELECT XMLQuery('/PurchaseOrder/Reference' PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM purchaseorder;

XMLQUERY('/PURCHASEORDER/REFERENCE'PASSINGOBJECT_
-------------------------------------------------
&lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
 
1 row selected.
</pre>
<p>The following query returns an <code>XMLType</code> instance containing the first <code>LineItem</code> element in the <code>LineItems</code> collection:</p>
<pre>
SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem[1]'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM purchaseorder;

XMLQUERY('/PURCHASEORDER/LINEITEMS/LINEITEM[1]'PASSINGOBJECT_
-------------------------------------------------------------
&lt;LineItem ItemNumber="1"&gt;
  &lt;Description&gt;A Night to Remember&lt;/Description&gt;
  &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
&lt;/LineItem&gt;
 
1 row selected.
</pre>
<p>The following query returns an <code>XMLType</code> instance that contains the three <code>Description</code> elements that match the XPath expression. These elements are returned as nodes in a single <code>XMLType</code> instance. The <code>XMLType</code> instance does not have a single root node; it is an XML <span class="italic">fragment</span>.</p>
<pre>
SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem/Description'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM purchaseorder;

XMLQUERY('/PURCHASEORDER/LINEITEMS/LINEITEM/DESCRIPTION'PASSINGOBJECT_
----------------------------------------------------------------------
&lt;Description&gt;A Night to Remember&lt;/Description&gt;
&lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
&lt;Description&gt;Sisters&lt;/Description&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABFEHBD">"Performing SQL Operations on XMLType Fragments using XMLTABLE"</a></div>
</div>
<!-- class="sect2" -->
<a id="BABGDDDA"></a>
<div id="ADXDB4123" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Accessing Text Nodes and Attribute Values using XMLCAST and XMLQUERY</h3>
<p>You can access text node and attribute values using SQL/XML standard functions <code>XMLQuery</code> and <code>XMLCast</code>. To do this, the XPath expression passed to <code>XMLQuery</code> must uniquely identify a <span class="italic">single</span> text node or attribute value within the document &ndash; that is, a <span class="italic">leaf</span> node. <a href="#BJFCGHGB">Example 3-26</a> illustrates this using several queries.</p>
<div id="ADXDB4124" class="example">
<p class="titleinexample"><a id="BJFCGHGB"></a>Example 3-26 Accessing a Text Node Value using XMLCAST and XMLQuery</p>
<p>The following query returns the value of the text node associated with the <code>Reference</code> element that matches the target XPath expression. The value is returned as a <code>VARCHAR2</code> value.</p>
<pre>
SELECT  XMLCast(XMLQuery('$p/PurchaseOrder/Reference/text()'
                         PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
                AS VARCHAR2(30))
  FROM purchaseorder;
 
XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
SBELL-2002100912333601PDT
 
1 row selected.
</pre>
<p>The following query returns the value of the text node associated with a <code>Description</code> element contained in a <code>LineItem</code> element. The particular <code>LineItem</code> element is specified by its <code>Id</code> attribute value. The predicate that identifies the <code>LineItem</code> element is <code>[Part/@Id="715515011020"]</code>. The at-sign character (<code>@</code>) specifies that <code>Id</code> is an attribute rather than an element. The value is returned as a <code>VARCHAR2</code> value.</p>
<pre>
SELECT XMLCast(
         XMLQuery('$p/PurchaseOrder/LineItems/LineItem[Part/@Id="715515011020"]/Description/text()'
                  PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder;
 
XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
Sisters
 
1 row selected.
</pre>
<p>The following query returns the value of the text node associated with the <code>Description</code> element contained in the first <code>LineItem</code> element. The first <code>LineItem</code> element is indicated by the position predicate<code>[1]</code>.</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]/Description'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(4000))
  FROM purchaseorder;
 
XMLCAST(XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[1]/DESCRIPTION'PASSINGOBJECT_VALUEAS"P"
---------------------------------------------------------------------------------------------
A Night to Remember
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb04cre.htm#i1024833">"Querying XMLType Data using SQL/XML Functions XMLExists and XMLCast"</a> for information on SQL/XML function <code>XMLCast</code></p>
</li>
<li>
<p><a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a> for information on SQL/XML function <code>XMLQuery</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABBBJBE"></a>
<div id="ADXDB4125" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Searching an XML Document using XMLEXISTS, XMLCast, and XMLQuery</h3>
<p>SQL/XML standard function <code>XMLExists</code> evaluates whether or not a given document contains a node that matches a W3C XPath expression. Function <code>XMLExists</code> returns a Boolean value of <code>true</code> if the document contains the node specified by the XPath expression supplied to the function and a value of <code>false</code> if it does not. Since XPath expressions can contain predicates, <code>XMLExists</code> can determine whether or not a given node exists in the document, and whether or not a node with the specified value exists in the document.</p>
<p>Similarly, you can use SQL/XML functions <code>XMLCast</code> and <code>XMLQuery</code> in a SQL <code>WHERE</code> clause to limit the query results to documents that satisfy some property. <a href="#BJFJHBAE">Example 3-27</a> illustrates the use of <code>XMLExists</code>, <code>XMLCast</code>, and <code>XMLQuery</code> to search for documents.</p>
<div id="ADXDB4126" class="example">
<p class="titleinexample"><a id="BJFJHBAE"></a>Example 3-27 Searching XML Content using XMLExists, XMLCast, and XMLQuery</p>
<p>The following query uses <code>XMLExists</code> to check if the XML document contains an element named <code>Reference</code> that is a child of the root element <code>PurchaseOrder</code>:</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p");

  COUNT(*)
----------
       132

1 row selected.
</pre>
<p>The following query checks if the value of the text node associated with the <code>Reference</code> element is <code>SBELL-2002100912333601PDT</code>:</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder<span class="bold">[Reference="SBELL-2002100912333601PDT"]</span>'
                  PASSING OBJECT_VALUE AS "p");

  COUNT(*)
----------
         1
1 row selected.
</pre>
<p>This query checks whether the value of the text node associated with the <code>Reference</code> element is <code>SBELL-XXXXXXXXXXXXXXXXXX</code>:</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-XXXXXXXXXXXXXXXXXX"]'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
         0
 
1 row selected.
</pre>
<p>This query checks whether the XML document contains a root element <code>PurchaseOrder</code> that contains a <code>LineItems</code> element that contains a <code>LineItem</code> element that contains a <code>Part</code> element with an <code>Id</code> attribute.</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItems/LineItem/Part/<span class="bold">@Id</span>'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
       132
 
1 row selected.
</pre>
<p>The following query checks whether the XML document contains a root element <code>PurchaseOrder</code> that contains a <code>LineItems</code> element that contains a <code>LineItem</code> element that contains a <code>Part</code> element with <code>Id</code> attribute value <code>715515009058</code>.</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItems/<span class="bold">LineItem/Part[@Id="715515009058"]</span>'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
        21
</pre>
<p>The following query checks whether the XML document contains a root element <code>PurchaseOrder</code> that contains a <code>LineItems</code> element whose <span class="italic">third</span> <code>LineItem</code> element contains a <code>Part</code> element with <code>Id</code> attribute value <code>715515009058</code>.</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists(
          '$p/PurchaseOrder/LineItems/LineItem<span class="bold">[3]</span>/Part[@Id="715515009058"]'
          PASSING OBJECT_VALUE AS "p");

  COUNT(*)
----------
         1
1 row selected.
</pre>
<p>The following query limits the results of the <code>SELECT</code> statement to rows where the text node associated with element <code>User</code> starts with the letter <code>S</code>. XQuery does not include support for <code>LIKE</code>-based queries.</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder
  WHERE XMLCast(XMLQuery('$p/PurchaseOrder/<span class="bold">User</span>' PASSING OBJECT_VALUE AS "p"
                         RETURNING CONTENT)
                AS VARCHAR2(30))
        <span class="bold">LIKE 'S%'</span>;
 
XMLCAST(XMLQUERY('$P/PURCHASEORDER
----------------------------------
SBELL-20021009123336231PDT
SBELL-20021009123336331PDT
SKING-20021009123336321PDT
...
36 rows selected.
</pre>
<p>The following query performs a join based on the values of a node in an XML document and data in another table.</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder p, hr.employees e
  WHERE XMLCast(XMLQuery('$p/PurchaseOrder/<span class="bold">User</span>' PASSING OBJECT_VALUE AS "p"
                         RETURNING CONTENT)
                AS VARCHAR2(30)) = <span class="bold">e.email</span>
    AND e.employee_id = 100;
 
XMLCAST(XMLQUERY('$P/PURCHASEOREDER
-----------------------------------
SKING-20021009123336321PDT
SKING-20021009123337153PDT
SKING-20021009123335560PDT
SKING-20021009123336952PDT
SKING-20021009123336622PDT
SKING-20021009123336822PDT
SKING-20021009123336131PDT
SKING-20021009123336392PDT
SKING-20021009123337974PDT
SKING-20021009123338294PDT
SKING-20021009123337703PDT
SKING-20021009123337383PDT
SKING-20021009123337503PDT
 
13 rows selected.
</pre>
<p>The following query uses <code>XMLExists</code> to limit the results of a <code>SELECT</code> statement to rows where the text node of element <code>User</code> contains the value <code>SBELL</code>.</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30)) "Reference"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[User="<span class="bold">SBELL</span>"]' PASSING OBJECT_VALUE AS "p");

Reference
------------------------------
SBELL-20021009123336231PDT
SBELL-20021009123336331PDT
SBELL-20021009123337353PDT
SBELL-20021009123338304PDT
SBELL-20021009123338505PDT
SBELL-20021009123335771PDT
SBELL-20021009123335280PDT
SBELL-2002100912333763PDT
SBELL-2002100912333601PDT
SBELL-20021009123336362PDT
SBELL-20021009123336532PDT
SBELL-20021009123338204PDT
SBELL-20021009123337673PDT
 
13 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BJFEGIII">Example 3-28</a> uses SQL/XML functions <code>XMLQuery</code> and <code>XMLExists</code> to find the <code>Reference</code> element for any <code>PurchaseOrder</code> element whose first <code>LineItem</code> element contains an order for the item with <code>Id</code> <code>715515009058</code>. Function <code>XMLExists</code> is used in the <code>WHERE</code> clause to determine which rows are selected, and <code>XMLQuery</code> is used in the <code>SELECT</code> list to control which part of the selected documents appears in the result.</p>
<div id="ADXDB4129" class="example">
<p class="titleinexample"><a id="BJFEGIII"></a>Example 3-28 Finding the Reference for a Purchase Order using XMLQuery and XMLExists</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING OBJECT_VALUE AS "p"
                        RETURNING CONTENT)
               AS VARCHAR2(30)) "Reference"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItems/LineItem[1]/Part[@Id="715515009058"]'
                  PASSING OBJECT_VALUE AS "p");

Reference
-------------------------
SBELL-2002100912333601PDT
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb04cre.htm#i1024833">"Querying XMLType Data using SQL/XML Functions XMLExists and XMLCast"</a> for information on SQL/XML functions <code>XMLCast</code> and <code>XMLExists</code></p>
</li>
<li>
<p><a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a> for information on SQL/XML function <code>XMLQuery</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABFEHBD"></a>
<div id="ADXDB4130" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing SQL Operations on XMLType <a id="sthref231"></a><a id="sthref232"></a><a id="sthref233"></a>Fragments using XMLTABLE</h3>
<p><a href="#BABBGCHJ">Example 3-25</a> demonstrates how to extract an <code>XMLType</code> instance that contains the node or nodes that match an XPath expression. When the document contains <span class="italic">multiple</span> nodes that match the supplied XPath expression, such a query returns an XML <span class="italic">fragment</span> that contains all of the matching nodes. Unlike an XML document, an XML <span class="glossaryterm"><a id="sthref234"></a><a id="sthref235"></a>fragment</span> has no single element that is the <span class="italic">root</span> element.</p>
<p>This kind of result is common in these cases:</p>
<ul>
<li>
<p>When you retrieve the set of elements contained in a <span class="italic">collection</span>, in which case all nodes in the fragment are of the same type &ndash; see <a href="#CHDCFJAH">Example 3-29</a></p>
</li>
<li>
<p>When the target XPath expression ends in a <span class="italic">wildcard</span>, in which case the nodes in the fragment can be of different types &ndash; see <a href="#CHDDCCFA">Example 3-31</a></p>
</li>
</ul>
<p>You can use SQL/XML function <code>XMLTable</code> to break up an XML fragment contained in an <code>XMLType</code> instance, inserting the collection-element data into a new, virtual table, which you can then query using SQL&thinsp;&mdash;&thinsp;in a join expression, for example. In particular, converting an XML fragment into a virtual table makes it easier to process the result of evaluating an <code>XMLQuery</code> expression that returns multiple nodes.</p>
<p><a href="#CHDCFJAH">Example 3-29</a> shows how to access the text nodes for each <code>Description</code> element in the <code>PurchaseOrder</code> document. It breaks up the single XML Fragment output from <a href="#BABBGCHJ">Example 3-25</a> into multiple text nodes.</p>
<div id="ADXDB4131" class="example">
<p class="titleinexample"><a id="CHDCFJAH"></a>Example 3-29 Accessing Description Nodes using XMLTABLE</p>
<pre>
SELECT des.COLUMN_VALUE
  FROM purchaseorder p,
       XMLTable('/PurchaseOrder/LineItems/LineItem/Description'
                PASSING p.OBJECT_VALUE) des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
COLUMN_VALUE
------------
&lt;Description&gt;A Night to Remember&lt;/Description&gt;
&lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
&lt;Description&gt;Sisters&lt;/Description&gt;

<span class="bold">3 rows selected.</span>
</pre>
<p>To use SQL to process the contents of the text nodes, <a href="#CHDCFJAH">Example 3-29</a> converts the collection of <code>Description</code> nodes into a <span class="italic">virtual table</span>, using SQL/XML function <code>XMLTable</code>. The virtual table has three rows, each of which contains a single <code>XMLType</code> instance with a single <code>Description</code> element.</p>
<p>The XPath expression targets the <code>Description</code> elements. The <code>PASSING</code> clause says to use the contents (<code>OBJECT_VALUE</code>) of <code>XMLType</code> table <code>purchaseorder</code> as the context for evaluating the XPath expression.</p>
<p>The <code>XMLTable</code> expression thus <span class="italic">depends</span> on the <code>purchaseorder</code> table. This is a <span class="italic">left lateral join</span>. This correlated join ensures a one-to-many (1:N) relationship between the <code>purchaseorder</code> row accessed and the rows generated from it by <code>XMLTable</code>. Because of this correlated join, the <code>purchaseorder</code> table <span class="italic">must appear before</span> the <code>XMLTable</code> expression in the <code>FROM</code> list. This is a general requirement in any situation where the <code>PASSING</code> clause refers to a column of the table.</p>
<p>Each <code>XMLType</code> instance in the virtual table contains a single <code>Description</code> element. You can use the <code>COLUMNS</code> clause of <code>XMLTable</code> to break up the data targeted by the XPath expression <code>'Description'</code> into a column named <code>description</code> of SQL data type <code>VARCHAR2(256)</code>. The <code>'Description'</code> expression that defines this column is <span class="italic">relative</span> to the <span class="italic">context</span> XPath expression, <code>'/PurchaseOrder/LineItems/LineItem'</code>.</p>
<pre>
SELECT des.<span class="bold">description</span>
  FROM purchaseorder p,
       XMLTable('/PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE
                <span class="bold">COLUMNS description VARCHAR2(256) PATH 'Description'</span>) des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

DESCRIPTION
---------------------------------
A Night to Remember
The Unbearable Lightness Of Being
Sisters
 
3 rows selected.
</pre>
<p>The <code>COLUMNS</code> clause lets you specify precise SQL data types, which can make static type-checking more helpful. This example uses only a single column (<code>description</code>). To expose data that is contained at multiple levels in an <code>XMLType</code> table as individual rows in a relational view, apply <code>XMLTable</code> to each document level to be broken up and stored in relational columns. See <a href="#CHDEEIFD">Example 3-33</a> for an example.</p>
</div>
<!-- class="example" -->
<p><a href="#BJFIDFFJ">Example 3-30</a> counts the number of elements in a collection. It also shows how SQL keywords such as <code>ORDER BY</code> and <code>GROUP BY</code> can be applied to the virtual table data created by SQL/XML function <code>XMLTable</code>.</p>
<div id="ADXDB4132" class="example">
<p class="titleinexample"><a id="BJFIDFFJ"></a>Example 3-30 Counting the Number of Elements in a Collection using XMLTABLE</p>
<pre>
SELECT reference, count(*)
  FROM purchaseorder,
       XMLTable('/PurchaseOrder' PASSING OBJECT_VALUE
                COLUMNS <span class="bold">reference</span> VARCHAR2(32) PATH 'Reference',
                        <span class="bold">lineitem</span>  XMLType      PATH 'LineItems/LineItem'),
       XMLTable('LineItem' PASSING lineitem)
  WHERE XMLExists('$p/PurchaseOrder[User="SBELL"]'
                  PASSING OBJECT_VALUE AS "p")
  <span class="bold">GROUP BY</span> reference
  <span class="bold">ORDER BY</span> reference;

REFERENCE                    COUNT(*)
--------------------------   --------
SBELL-20021009123335280PDT         20
SBELL-20021009123335771PDT         21
SBELL-2002100912333601PDT           3
SBELL-20021009123336231PDT         25
SBELL-20021009123336331PDT         10
SBELL-20021009123336362PDT         15
SBELL-20021009123336532PDT         14
SBELL-20021009123337353PDT         10
SBELL-2002100912333763PDT          21
SBELL-20021009123337673PDT         10
SBELL-20021009123338204PDT         14
SBELL-20021009123338304PDT         24
SBELL-20021009123338505PDT         20

13 rows selected.
</pre>
<p>The query in <a href="#BJFIDFFJ">Example 3-30</a> locates the set of XML documents that match the XPath expression to SQL/XML function <code>XMLExists</code>. It generates a virtual table with two columns:</p>
<ul>
<li>
<p><code>reference</code>, containing the <code>Reference</code> node for each document selected</p>
</li>
<li>
<p><code>lineitem</code>, containing the set of <code>LineItem</code> nodes for each document selected</p>
</li>
</ul>
<p>It counts the number of <code>LineItem</code> nodes for each document. A correlated join ensures that the <code>GROUP BY</code> correctly determines which <code>LineItem</code> elements belong to which <code>PurchaseOrder</code> element.</p>
</div>
<!-- class="example" -->
<p><a href="#CHDDCCFA">Example 3-31</a> shows how to use SQL/XML function <code>XMLTable</code> to count the number of <span class="italic">child</span> elements of a given element. The XPath expression passed to <code>XMLTable</code> contains a wildcard (<code>*</code>) that matches all elements that are direct descendants of a <code>PurchaseOrder</code> element. Each row of the virtual table created by <code>XMLTable</code> contains a node that matches the XPath expression. Counting the number of rows in the virtual table provides the number of element children of element <code>PurchaseOrder</code>.</p>
<div id="ADXDB4133" class="example">
<p class="titleinexample"><a id="CHDDCCFA"></a>Example 3-31 Counting the Number of Child Elements in an Element using XMLTABLE</p>
<pre>
SELECT count(*)
  FROM purchaseorder p, XMLTable('/PurchaseOrder/<span class="bold">*</span>' PASSING p.OBJECT_VALUE)
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
  COUNT(*)
----------
         9

1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFCJHC"></a>
<div id="ADXDB4134" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Accessing XML Data in Oracle XML&nbsp;DB using Relational Views</h2>
<p>You can use the XML-specific functions and methods provided by Oracle XML&nbsp;DB to create conventional <span class="italic">relational views</span> that provide relational access to XML content. This lets programmers, tools, and applications that understand Oracle Database, but not XML, to work with XML content stored in the database.</p>
<p>The relational views can use XPath expressions and SQL/XML query and access functions such as <code>XMLTable</code> to define a mapping between columns in the view and nodes in the XML document. For performance reasons, this approach is recommended only when XML documents are stored using structured (object-relational) or binary XML storage, not when stored as <code>CLOB</code> instances.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb04cre.htm#g1050045">Chapter 4, "XMLType Operations"</a> for a description of <code>XMLType</code> data type and functions</p>
</li>
<li>
<p><code><a href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</a></code> for information about XPath 1.0</p>
</li>
<li>
<p><code><a href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</a></code> for information about XPath 2.0</p>
</li>
<li>
<p><code><a href="http://www.w3.org/TR/2002/NOTE-unicode-xml-20020218/">http://www.w3.org/TR/2002/NOTE-unicode-xml-20020218/</a></code> for information about using Unicode in XML</p>
</li>
</ul>
</div>
<div id="ADXDB4135" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref236"></a>
<h3 class="sect2">Breaking Up a Single Level of XML Data</h3>
<p>When you need to expose each document in an <code>XMLType</code> table as a row in a relational view, you can use this technique:</p>
<ol>
<li>
<p>Define the set of columns that make up the view, using <code>CREATE OR REPLACE VIEW</code>.</p>
</li>
<li>
<p>Map the nodes in the XML document to the columns defined by the view. You do this by extracting the nodes using SQL/XML function <code>XMLTable</code> with appropriate XPath expressions.</p>
</li>
</ol>
<p>This technique can be used whenever there is a one-to-<span class="italic">one</span> (1:1) relationship between documents in the <code>XMLType</code> table and the rows in the view.</p>
<p><a href="#BJFCIHJE">Example 3-32</a> shows how to create a simple relational view, <code>purchaseorder_master_view</code>, that exposes XML content. There is one row in the view for each row in <code>XMLType</code> table <code>purchaseorder</code>.</p>
<div id="ADXDB4136" class="example">
<p class="titleinexample"><a id="BJFCIHJE"></a>Example 3-32 Creating a Relational View of XML Content</p>
<pre>
CREATE OR REPLACE VIEW purchaseorder_master_view AS
  SELECT <span class="bold">po.*</span>
    FROM purchaseorder pur,
         XMLTable(
           '$p/PurchaseOrder' PASSING pur.OBJECT_VALUE as "p"
           COLUMNS
             reference       VARCHAR2(30)   PATH 'Reference',
             requestor       VARCHAR2(128)  PATH 'Requestor',
             userid          VARCHAR2(10)   PATH 'User',
             costcenter      VARCHAR2(4)    PATH 'CostCenter',
             ship_to_name    VARCHAR2(20)   PATH 'ShippingInstructions/name',
             ship_to_address VARCHAR2(256)  PATH 'ShippingInstructions/address',
             ship_to_phone   VARCHAR2(24)   PATH 'ShippingInstructions/telephone',
             instructions    VARCHAR2(2048) PATH 'SpecialInstructions') <span class="bold">po</span>;

View created.

DESCRIBE purchaseorder_master_view

Name            Null?    Type
--------------------------------------------
REFERENCE                VARCHAR2(30)
REQUESTOR                VARCHAR2(128)
USERID                   VARCHAR2(10)
COSTCENTER               VARCHAR2(4)
SHIP_TO_NAME             VARCHAR2(20)
SHIP_TO_ADDRESS          VARCHAR2(256)
SHIP_TO_PHONE            VARCHAR2(24)
INSTRUCTIONS             VARCHAR2(2048)
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDCAIBH"></a>
<div id="ADXDB4137" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Breaking Up <a id="sthref237"></a>Multiple Levels of XML Data</h3>
<p>When you need to expose data contained at multiple levels in an <code>XMLType</code> table as individual rows in a relational view, you use the same general approach as for breaking up a single level: 1) define the columns making up the view, and 2) map the XML nodes to the columns. However, in this case you apply <code>XMLTable</code>, to each document level that is to be broken up and stored in relational columns.</p>
<p>This technique can be used whenever there is a one-to-<span class="italic">many</span> (1:N) relationship between documents in the <code>XMLType</code> table and the rows in the view.</p>
<p>For example, each <code>PurchaseOrder</code> element contains a <code>LineItems</code> element, which in turn contains one or more <code>LineItem</code> elements. Each <code>LineItem</code> element has child elements, such as <code>Description</code>, and an <code>ItemNumber</code> attribute. To make such lower-level data accessible as a relational value, you must break up both the <code>PurchaseOrder</code> element and the <code>LineItem</code> collection. Each such decomposition is done with <code>XMLTable</code>. When element <code>PurchaseOrder</code> is broken up, the <code>LineItem</code> element is mapped to a relational column of type <code>XMLType</code>, which contains an XML fragment. That column is then passed to the second call to <code>XMLType</code>, to be broken into its various parts as multiple rows of relational values.</p>
<p><a href="#CHDEEIFD">Example 3-33</a> illustrates this. It shows how to use SQL/XML function <code>XMLTable</code> for a one-to-<span class="italic">many</span> (1:N) relationship between the documents in <code>XMLType</code> table <code>purchaseorder</code> and the view rows. The view provides access to the individual members of a <span class="italic">collection</span>, and exposes the collection members as a set of rows.</p>
<div id="ADXDB4138" class="example">
<p class="titleinexample"><a id="CHDEEIFD"></a>Example 3-33 Accessing Individual Members of a Collection using a View</p>
<pre>
CREATE OR REPLACE VIEW purchaseorder_detail_view AS
  SELECT po.reference, li.*
    FROM purchaseorder p,
         XMLTable('/PurchaseOrder' PASSING p.OBJECT_VALUE
                  COLUMNS
                    reference VARCHAR2(30) PATH 'Reference',
                    lineitem  XMLType      PATH 'LineItems/LineItem') po,
         XMLTable('/LineItem' PASSING po.lineitem
                  COLUMNS
                    itemno      NUMBER(38)    PATH '@ItemNumber',
                    description VARCHAR2(256) PATH 'Description',
                    partno      VARCHAR2(14)  PATH 'Part/@Id',
                    quantity    NUMBER(12, 2) PATH 'Part/@Quantity',
                    unitprice   NUMBER(8, 4)  PATH 'Part/@UnitPrice') li;

View created.

DESCRIBE purchaseorder_detail_view
Name           Null?    Type
----------------------------
REFERENCE               VARCHAR2(30)
ITEMNO                  NUMBER(38)
DESCRIPTION             VARCHAR2(256)
PARTNO                  VARCHAR2(14)
QUANTITY                NUMBER(12,2)
UNITPRICE               NUMBER(8,4)
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDEEIFD">Example 3-33</a>, there is one row in view <code>purchaseorder_detail_view</code> for each <code>LineItem</code> element in the XML documents stored in <code>XMLType</code> table <code>purchaseorder</code>.</p>
<p>The <code>CREATE OR REPLACE VIEW</code> statement defines the set of columns that make up the view. The <code>SELECT</code> statement passes the <code>purchaseorder</code> table as context to function <code>XMLTable</code>, to create the virtual table <code>p</code>, which has columns <code>reference</code> and <code>lineitem</code>. These columns contain the <code>Reference</code> and <code>LineItem</code> elements of the purchase-order documents, respectively.</p>
<p>Column <code>lineitem</code> contains a collection of <code>LineItem</code> elements, as an <code>XMLType</code> instance&thinsp;&mdash;&thinsp;one row for each <code>LineItem</code> element. These rows are in turn passed to a second <code>XMLTable</code> expression, to serve as its context. This second <code>XMLTable</code> expression creates a virtual table of line-item rows, with columns corresponding to various descendant nodes of element <code>LineItem</code>. Most of these descendants are attributes (<code>ItemNumber</code>, <code>Part/@Id</code>, and so on). One of the descendants is the <code>Description</code> child element.</p>
<p>The <code>Reference</code> element is included in view <code>purchaseorder_detail_view</code> as column <code>reference</code>. It provides a foreign key that can be used to joins rows in view <code>purchaseorder_detail_view</code> to the corresponding row in view <code>purchaseorder_master_view</code>. The correlated join in the <code>CREATE VIEW</code> statement ensures that the one-to-many (1:N) relationship between the <code>Reference</code> element and the associated <code>LineItem</code> elements is maintained whenever the view is accessed.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB4139" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref238"></a>
<h3 class="sect2">Querying XML Content As Relational Data</h3>
<p>The examples in this section show relational queries of XML data. They point out some of the benefits provided by creating relational views over <code>XMLType</code> tables and columns.</p>
<p><a href="#BJFCEJFA">Example 3-34</a> shows how to query master and detail relational views of XML data.</p>
<div id="ADXDB4140" class="example">
<p class="titleinexample"><a id="BJFCEJFA"></a>Example 3-34 Querying XML Data using Views</p>
<p>The following simple query against a master view uses a conventional <code>SELECT</code> statement to return the rows where the <code>userid</code> column starts with <code>S</code>.</p>
<pre>
SELECT reference, costcenter, ship_to_name
  FROM purchaseorder_master_view
  WHERE userid LIKE 'S%';
 
REFERENCE                      COST SHIP_TO_NAME
------------------------------ ---- --------------
SBELL-20021009123336231PDT     S30  Sarah J. Bell
SBELL-20021009123336331PDT     S30  Sarah J. Bell
SKING-20021009123336321PDT     A10  Steven A. King
...
36 rows selected.
</pre>
<p>The following query is based on a join between the master view and the detail view. A conventional <code>SELECT</code> statement finds the <code>purchaseorder_detail_view</code> rows where the value of column <code>itemno</code> is <code>1</code> and the corresponding <code>purchaseorder_master_view</code> row contains a <code>userid</code> column with the value <code>SBELL</code>.</p>
<pre>
SELECT d.reference, d.itemno, d.partno, d.description
  FROM purchaseorder_detail_view d, purchaseorder_master_view m
  WHERE m.reference = d.reference
    AND m.userid = 'SBELL'
    AND d.itemno = 1;

REFERENCE                          ITEMNO PARTNO         DESCRIPTION
------------------------------ ------------------------------------------------
SBELL-20021009123336231PDT              1 37429165829    Juliet of the Spirits
SBELL-20021009123336331PDT              1 715515009225   Salo
SBELL-20021009123337353PDT              1 37429141625    The Third Man
SBELL-20021009123338304PDT              1 715515009829   Nanook of the North
SBELL-20021009123338505PDT              1 37429122228    The 400 Blows
SBELL-20021009123335771PDT              1 37429139028    And the Ship Sails on
SBELL-20021009123335280PDT              1 715515011426   All That Heaven Allows
SBELL-2002100912333763PDT               1 715515010320   Life of Brian - Python
SBELL-2002100912333601PDT               1 715515009058   A Night to Remember
SBELL-20021009123336362PDT              1 715515012928   In the Mood for Love
SBELL-20021009123336532PDT              1 37429162422    Wild Strawberries
SBELL-20021009123338204PDT              1 37429168820    Red Beard
SBELL-20021009123337673PDT              1 37429156322    Cries and Whispers

13 rows selected.
</pre></div>
<!-- class="example" -->
<p>The views in <a href="#BJFCEJFA">Example 3-34</a> look and act like standard relational views. They can be queried using standard relational syntax. No XML-specific syntax is required in either the query or the generated result set.</p>
<p>By exposing XML content as relational data, Oracle XML&nbsp;DB lets you apply advanced database features, such as business intelligence and analytic capabilities, to XML content, even if such features themselves are not XML-aware.</p>
<p><a href="#BJFBEFDD">Example 3-35</a> shows how to use relational views over XML content to perform business-intelligence queries on XML documents. The example query selects <code>PurchaseOrder</code> documents that contain orders for titles identified by UPC codes <code>715515009058</code> and <code>715515009126</code>.</p>
<div id="ADXDB4141" class="example">
<p class="titleinexample"><a id="BJFBEFDD"></a>Example 3-35 Business-Intelligence Query of XML Data using a View</p>
<pre>
SELECT partno, count(*) "No of Orders", quantity "No of Copies"
  FROM purchaseorder_detail_view
  WHERE partno IN (715515009126, 715515009058)
  GROUP BY rollup(partno, quantity);
 
PARTNO         No of Orders No of Copies
-------------- ------------ ------------
715515009058              7            1
715515009058              9            2
715515009058              5            3
715515009058              2            4
715515009058             23
715515009126              4            1
715515009126              7            3
715515009126             11
                         34 
9 rows selected.
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BJFBEFDD">Example 3-35</a> determines the number of copies of each title that are ordered in each <code>PurchaseOrder</code> document. For part number <code>715515009126</code>, there are four <code>PurchaseOrder</code> documents where one copy of the item is ordered and seven <code>PurchaseOrder</code> documents where three copies of the item are ordered.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABBEDFD"></a>
<div id="ADXDB4142" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Updating XML Content Stored in Oracle XML&nbsp;DB</h2>
<p>Oracle XML&nbsp;DB lets update operations take place on XML content. Update operations can either replace the entire contents of a document or parts of a document. The ability to perform partial updates on XML documents is very powerful, particularly when you make small changes to large documents, as it can significantly reduce the amount of network traffic and disk input-output required to perform the update.</p>
<p>SQL function <code>updateXML</code> enables partial update of an XML document stored as an <code>XMLType</code> instance. It lets multiple changes be made to the document in a single operation. Each change consists of an XPath expression that identifies a node to be updated, and the new value for the node.</p>
<p><a href="#CHDBGCBG">Example 3-36</a> uses SQL function <code>updateXML</code> to update the text node associated with element <code>User</code>.</p>
<div id="ADXDB4143" class="example">
<p class="titleinexample"><a id="CHDBGCBG"></a>Example 3-36 Updating XML Content using UPDATEXML</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User' PASSING OBJECT_VALUE AS "p"
                                                RETURNING CONTENT)
               AS VARCHAR2(60))
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(XMLQUERY('$P/PURCHAS
----------------------------
SBELL
 
1 row selected.
 
UPDATE purchaseorder
SET OBJECT_VALUE =
    <span class="bold">updateXML</span>(OBJECT_VALUE, '/PurchaseOrder/User/text()', '<span class="bold">SKING</span>')
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User' PASSING OBJECT_VALUE AS "p"
                                                RETURNING CONTENT)
               AS VARCHAR2(60))
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(XMLQUERY('$P/PURCHAS
----------------------------
<span class="bold">SKING</span>

1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BJFGFDGD">Example 3-37</a> uses SQL function <code>updateXML</code> to replace an entire element within an XML document. The XPath expression references the element, and the replacement value is passed as an <code>XMLType</code> object.</p>
<div id="ADXDB4144" class="example">
<p class="titleinexample"><a id="BJFGFDGD"></a>Example 3-37 Replacing an Entire Element using UPDATEXML</p>
<pre>
SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]'
                PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLQUERY('$P/PURCHAS
--------------------
&lt;LineItem ItemNumber="1"&gt;
  &lt;Description&gt;A Night to Remember&lt;/Description&gt;
  &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
&lt;/LineItem&gt;
 
1 row selected.
 
UPDATE purchaseorder
  SET OBJECT_VALUE = 
        <span class="bold">updateXML</span>(
          OBJECT_VALUE,
          '/PurchaseOrder/LineItems/LineItem[1]',
          <span class="bold">XMLType('&lt;LineItem ItemNumber="1"&gt;</span>
                     <span class="bold">&lt;Description&gt;The Lady Vanishes&lt;/Description&gt;</span>
                     <span class="bold">&lt;Part Id="37429122129" UnitPrice="39.95" Quantity="1"/&gt;</span>
                   <span class="bold">&lt;/LineItem&gt;')</span>)
    WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                    PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]'
                PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHAS
--------------------
<span class="bold">&lt;LineItem ItemNumber="1"&gt;</span>
  <span class="bold">&lt;Description&gt;The Lady Vanishes&lt;/Description&gt;</span>
  <span class="bold">&lt;Part Id="37429122129" UnitPrice="39.95" Quantity="1"/&gt;</span>
<span class="bold">&lt;/LineItem&gt;</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BJFCFABB">Example 3-38</a> illustrates the common mistake of using SQL function <code>updateXML</code> to update a <span class="italic">node that occurs multiple times</span> in a collection. The <code>UPDATE</code> statement sets the value of the text node of a <code>Description</code> element to <code>The Wizard of Oz</code>, where the current value of the text node is <code>Sisters</code>. The statement includes an <code>XMLExists</code> expression in the <code>WHERE</code> clause that identifies the set of nodes to be updated.</p>
<div id="ADXDB4145" class="example">
<p class="titleinexample"><a id="BJFCFABB"></a>Example 3-38 Incorrectly Updating a Node That Occurs Multiple Times in a Collection</p>
<pre>
SELECT XMLCast(des.COLUMN_VALUE AS VARCHAR2(256))
  FROM purchaseorder,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem/Description'
                PASSING OBJECT_VALUE AS "p") des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(DES.COLUMN_VALUEASVARCHAR2(256))
----------------------------------------
The Lady Vanishes
The Unbearable Lightness Of Being
Sisters
 
3 rows selected.
 
UPDATE purchaseorder p
  SET p.OBJECT_VALUE =
        <span class="bold">updateXML</span>(p.OBJECT_VALUE,
                  '/PurchaseOrder/LineItems/LineItem/Description/text()',
                  'The Wizard of Oz')
    WHERE XMLExists('$p/PurchaseOrder/LineItems/LineItem[Description="Sisters"]'
                    PASSING OBJECT_VALUE AS "p")
      AND XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                    PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLCast(des.COLUMN_VALUE AS VARCHAR2(256))
  FROM purchaseorder,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem/Description'
                PASSING OBJECT_VALUE AS "p") des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(DES.COLUMN_VALUEASVARCHAR2(256))
----------------------------------------
The Wizard of Oz
The Wizard of Oz
The Wizard of Oz
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#BJFCFABB">Example 3-38</a>, instead of updating only the intended node, SQL function <code>updateXML</code> updates the values of <span class="italic">all</span> text nodes that belong to the <code>Description</code> element. This is the correct <code>updateXML</code> behavior, but it is not what was intended.</p>
<p><span class="italic">A</span> <code><span class="codeinlineitalic">WHERE</span></code> <span class="italic">clause can be used only to identify which</span> <span class="bolditalic">documents</span> <span class="italic">must be updated, not which</span> <span class="bolditalic">nodes</span> <span class="italic">within a document must be updated</span>.</p>
<p>After the document has been selected, the <span class="italic">XPath expression</span> passed to <code>updateXML</code> determines which <span class="italic">nodes</span> within the document must be updated. In this case, the XPath expression identifies all three <code>Description</code> nodes, so all three of the associated text nodes were updated.</p>
<p>To correctly use SQL function <code>updateXML</code> to update a node that occurs multiple times within a collection, use the XPath expression passed to <code>updateXML</code> to identify which nodes in the XML document to update. By introducing the appropriate predicate into the XPath expression, you can limit which nodes in the document are updated. <a href="#BABEJGHA">Example 3-39</a> illustrates the correct way to update one node within a collection.</p>
<div id="ADXDB4146" class="example">
<p class="titleinexample"><a id="BABEJGHA"></a>Example 3-39 Correctly Updating a Node That Occurs Multiple Times in a Collection</p>
<pre>
SELECT XMLCast(des.COLUMN_VALUE AS VARCHAR2(256))
  FROM purchaseorder,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem/Description'
                PASSING OBJECT_VALUE AS "p") des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(DES.COLUMN_VALUEASVARCHAR2(256))
----------------------------------------

A Night to Remember
The Unbearable Lightness Of Being
Sisters

3 rows selected.

UPDATE purchaseorder p
 SET p.OBJECT_VALUE = 
       updateXML(
         p.OBJECT_VALUE,
         '/PurchaseOrder/LineItems/LineItem/Description<span class="bold">[text()="Sisters"]</span>/text()',
         <span class="bold">'The Wizard of Oz'</span>)
 WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                 PASSING OBJECT_VALUE AS "p");

1 row updated.

SELECT XMLCast(des.COLUMN_VALUE AS VARCHAR2(256))
  FROM purchaseorder,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem/Description'
                PASSING OBJECT_VALUE AS "p") des
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLCAST(DES.COLUMN_VALUEASVARCHAR2(256))
----------------------------------------
A Night to Remember
The Unbearable Lightness Of Being
<span class="bold">The Wizard of Oz</span>
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p>SQL function <code>updateXML</code> lets multiple changes be made to the document in one statement. <a href="#BJFJGJAB">Example 3-40</a> shows how to change the values of text nodes belonging to the <code>User</code> and <code>SpecialInstructions</code> elements in one statement.</p>
<div id="ADXDB4147" class="example">
<p class="titleinexample"><a id="BJFJGJAB"></a>Example 3-40 Changing Text Node Values using UPDATEXML</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/CostCenter'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(4)) "Cost Center",
       XMLCast(XMLQuery('$p/PurchaseOrder/SpecialInstructions'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(2048)) "Instructions"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

Cost Center  Instructions
------------ ------------
S30          Air Mail
 
1 row selected.
</pre>
<p>The following single <code>UPDATE</code> SQL statement changes the <code>User</code> and <code>SpecialInstructions</code> element text node values:</p>
<pre>
UPDATE purchaseorder
  SET OBJECT_VALUE =
        updateXML(OBJECT_VALUE,
                  '/PurchaseOrder/<span class="bold">CostCenter/text()</span>',
                  <span class="bold">'B40'</span>,
                  '/PurchaseOrder/<span class="bold">SpecialInstructions/text()</span>',
                  <span class="bold">'Priority Overnight Service'</span>)
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
1 row updated.

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/CostCenter'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(4)) "Cost Center",
       XMLCast(XMLQuery('$p/PurchaseOrder/SpecialInstructions'
                        PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(2048)) "Instructions"
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
Cost Center  Instructions
------------ --------------------------
<span class="bold">B40</span>          <span class="bold">Priority Overnight Service</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<a id="CHDFIBEH"></a>
<div id="ADXDB4148" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Updating XML Schema-Based and Non-Schema-Based XML Documents</h3>
<p>The way SQL functions such as <code>updateXML</code> modify an XML document depends on how the XML document is stored and whether it is based on an XML schema:</p>
<ul>
<li>
<p>XML documents stored in <code>CLOB</code> values &ndash; When a SQL function such as <code>updateXML</code> modifies an XML document stored as a <code>CLOB</code> (whether or not it is XML schema-based), Oracle XML&nbsp;DB performs the update by creating a Document Object Model (DOM) from the document and using DOM API methods to modify the appropriate XML data. After modification, the updated DOM is returned back to the underlying <code>CLOB</code> value.</p>
</li>
<li>
<p>XML documents stored object-relationally &ndash; When a SQL function such as <code>updateXML</code> modifies an XML schema-based document that is stored object-relationally, Oracle XML&nbsp;DB can use XPath rewrite to modify the underlying objects in place. This is a partial update, which translates the XPath argument to the SQL function into an equivalent SQL operation. The SQL operation then directly modifies the attributes of underlying objects. Such a partial update can be much quicker than a DOM-based update. This can improve performance significantly when executing SQL code that applies a SQL function such as <code>updateXML</code> to a large number of documents.</p>
</li>
<li>
<p>XML documents stored as binary XML &ndash; When a SQL function such as <code>updateXML</code> is used on a binary XML column, Oracle XML&nbsp;DB often need not build a DOM. The exact portion of the document that must be updated is calculated using query evaluation techniques such as streaming and <code>XMLIndex</code>. The updated data is written to disk starting only where the first change occurs&thinsp;&mdash;&thinsp;anything before that is unchanged. In addition, if SecureFile LOBs are used for storing the data (the default behavior), then the change is applied in a sliding manner, without causing the rest of the LOB to be rewritten. That is, with SecureFile LOB storage of binary XML data, only the data that is actually changed is updated. This can significantly improve performance relative to unstructured storage. These optimizations apply to both non-schema-based and XML schema-based data.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb_rewrite.htm#BABHJECG">Chapter 8, "XPath Rewrite for Structured Storage"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJCAAJ"></a>
<div id="ADXDB4149" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Namespace Support in Oracle XML&nbsp;DB</h2>
<p>Namespace support is a key feature of the W3C XML Recommendations. Oracle XML&nbsp;DB fully supports the W3C Namespace Recommendation. All <code>XMLType</code> methods and XML-specific SQL functions work with XPath expressions that include namespace prefixes. All methods and functions accept an optional <code>namespace</code> argument that provides the namespace declarations for correctly resolving namespace prefixes used in XPath expressions. The <code>namespace</code> parameter is required whenever the provided XPath expression contains namespace prefixes. When parameter <code>namespace</code> is provided, it must provide an explicit declaration for the default namespace in addition to the prefixed namespaces, unless the default namespace is the <code>noNamespace</code> namespace. When parameter <code>namespace</code> is <span class="italic">not</span> provided, Oracle XML&nbsp;DB makes the following assumptions about the XPath expression:</p>
<ul>
<li>
<p>If the content of the <code>XMLType</code> instance is <span class="italic">not</span> based on a registered XML schema, then any term in the XPath expression that does include a namespace prefix is assumed to be in the <code>noNamespace</code> namespace.</p>
</li>
<li>
<p>If the content of the <code>XMLType</code> is based on a registered XML schema, then any term in the XPath expression that does not include a namespace prefix is assumed to be in the <code>targetNamespace</code> declared by the XML schema, if any. If the XML schema does not declare a <code>targetnamespace</code>, then names <code>noNamespace</code> is used.</p>
</li>
</ul>
<p>Failing to correctly define the namespaces required to resolve XPath expressions results in XPath-based operations not working as expected. When the namespace declarations are incorrect or missing, the result of the operation is normally <span class="italic">null</span>, rather than an error. To avoid confusion, whenever any namespaces other than <code>noNamespace</code> are present in either the XPath expression or the target XML document, pass the <span class="italic">complete set of namespace declarations</span>, including the declaration for the <span class="italic">default</span> namespace.</p>
</div>
<!-- class="sect1" -->
<a id="BABDBEFG"></a>
<div id="ADXDB4150" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">How Oracle XML&nbsp;DB Processes XMLType Methods and SQL Functions</h2>
<p>Oracle XML&nbsp;DB processes SQL/XML access and query functions such as <code>XMLQuery</code> and <code>XMLType</code> methods using DOM-based or SQL-based techniques:</p>
<ul>
<li>
<p>DOM-based <code>XMLType</code> processing &ndash; Oracle XML&nbsp;DB performs the required processing by constructing a DOM from the contents of the <code>XMLType</code> object. It uses methods provided by the DOM API to perform the required operation on the DOM. If the operation involves updating the DOM tree, then the entire XML document has to be written back to disk when the operation is completed. The process of using DOM-based operations on <code>XMLType</code> data is referred to as <span class="glossaryterm"><a id="sthref239"></a>functional evaluation</span>.</p>
<p>The advantage of functional evaluation is that it can be used regardless of the storage model (structured, binary XML, or unstructured) used for the <code>XMLType</code> instance. The disadvantage of functional evaluation is that it much more <span class="italic">expensive</span> than XPath rewrite, and <span class="italic">does not scale</span> across large numbers of XML documents.</p>
</li>
<li>
<p>SQL-based <code>XMLType</code> processing &ndash; Oracle XML&nbsp;DB constructs a SQL statement that performs the processing required to complete the function or method. The SQL statement works directly against the object-relational data structures that underlie a schema-based <code>XMLType</code>. This process is referred to as <span class="glossaryterm">XPath rewrite</span>. See <a href="xdb_rewrite.htm#BABHJECG">Chapter 8, "XPath Rewrite for Structured Storage"</a>.</p>
<p>The advantage of XPath rewrite is that it lets Oracle XML&nbsp;DB evaluate XPath-based SQL functions and methods at near <span class="italic">relational speeds</span>. This lets these operations scale across <span class="italic">large numbers of XML documents</span>. The disadvantage of XPath rewrite is that since it relies on direct access and updating the objects used to store the XML document, it can be used only when the <code>XMLType</code> instance is stored using XML <span class="italic">schema-based object-relational</span> storage techniques.</p>
</li>
<li>
<p>Streaming evaluation of binary XML data &ndash; If you use binary XML as the <code>XMLType</code> storage model, then XPath expressions used in SQL/XML access and query functions such as <code>XMLQuery</code> are evaluated in a streaming fashion, without recourse to building a DOM.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BABFACEG"></a>
<div id="ADXDB4163" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Generating XML Data from Relational Data</h2>
<p>This section presents examples of using Oracle XML&nbsp;DB to generate XML data from relational data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a></p>
</li>
<li>
<p><a href="xdb13gen.htm#g1047191">Chapter 18, "Generating XML Data from the Database"</a></p>
</li>
</ul>
</div>
<div id="ADXDB5803" class="sect2"><a id="sthref240"></a>
<h3 class="sect2">Generating XML Data from Relational Data using SQL/XML Functions</h3>
<p>You can use standard SQL/XML functions to generate one or more XML documents. SQL/XML function <code>XMLQuery</code> is the most general way to do this. Other SQL/XML functions that you can use for this are the following:</p>
<ul>
<li>
<p><code>XMLElement</code> creates a element</p>
</li>
<li>
<p><code>XMLAttributes</code> adds attributes to an element</p>
</li>
<li>
<p><code>XMLForest</code> creates forest of elements</p>
</li>
<li>
<p><code>XMLAgg</code> creates a single element from a collection of elements</p>
</li>
</ul>
<p>The query in <a href="#BJFJCFHF">Example 3-41</a> uses these functions to generate an XML document that contains information from the tables <code>departments</code>, <code>locations</code>, <code>countries</code>, <code>employees</code>, and <code>jobs</code>.</p>
<div id="ADXDB4164" class="example">
<p class="titleinexample"><a id="BJFJCFHF"></a>Example 3-41 Generating XML Data using SQL/XML Functions</p>
<pre>
SELECT XMLElement(
         "Department",
         XMLAttributes(d.Department_id AS "DepartmentId"),
         XMLForest(d.department_name AS "Name"),
         XMLElement(
           "Location",
           XMLForest(street_address AS "Address",
                     city AS "City",
                     state_province AS "State",
                     postal_code AS "Zip",
                     country_name AS "Country")),
           XMLElement(
             "EmployeeList",
             (SELECT XMLAgg(
                       XMLElement(
                         "Employee",
                         XMLAttributes(e.employee_id AS "employeeNumber"),
                         XMLForest(
                           e.first_name AS "FirstName", 
                           e.last_name AS "LastName",
                           e.email AS "EmailAddress",
                           e.phone_number AS "PHONE_NUMBER",
                           e.hire_date AS "StartDate",
                           j.job_title AS "JobTitle",
                           e.salary AS "Salary",
                           m.first_name || ' ' || m.last_name AS "Manager"),
                         XMLElement("Commission", e.commission_pct)))
                FROM hr.employees e, hr.employees m, hr.jobs j
                WHERE e.department_id = d.department_id
                  AND j.job_id = e.job_id
                  AND m.employee_id = e.manager_id)))
  AS XML
  FROM hr.departments d, hr.countries c, hr.locations l
  WHERE department_name = 'Executive'
    AND d.location_id = l.location_id
    AND l.country_id  = c.country_id;
</pre>
<p>The query returns the following XML:</p>
<pre>
XML
--------------------------------------------------------------------------------
&lt;Department DepartmentId="90"&gt;&lt;Name&gt;Executive&lt;/Name&gt;&lt;Location&gt;&lt;Address&gt;2004
 Charade Rd&lt;/Address&gt;&lt;City&gt;Seattle&lt;/City&gt;&lt;State&gt;Washingto
n&lt;/State&gt;&lt;Zip&gt;98199&lt;/Zip&gt;&lt;Country&gt;United States of
 America&lt;/Country&gt;&lt;/Location&gt;&lt;EmployeeList&gt;&lt;Employee
 employeeNumber="101"&gt;&lt;FirstNa
me&gt;Neena&lt;/FirstName&gt;&lt;LastName&gt;Kochhar&lt;/LastName&gt;&lt;EmailAddress&gt;NKOCHHAR&lt;/EmailAdd
ess&gt;&lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;&lt;Start
Date&gt;2005-09-21&lt;/StartDate&gt;&lt;JobTitle&gt;Administration Vice
 President&lt;/JobTitle&gt;&lt;Salary&gt;17000&lt;/Salary&gt;&lt;Manager&gt;Steven King&lt;/Manager&gt;&lt;Com
mission&gt;&lt;/Commission&gt;&lt;/Employee&gt;&lt;Employee
 employeeNumber="102"&gt;&lt;FirstName&gt;Lex&lt;/FirstName&gt;&lt;LastName&gt;De
 Haan&lt;/LastName&gt;&lt;EmailAddress&gt;L
DEHAAN&lt;/EmailAddress&gt;&lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE
NUMBER&gt;&lt;StartDate&gt;2001-01-13&lt;/StartDate&gt;&lt;JobTitle&gt;Administration Vice Presiden
t&lt;/JobTitle&gt;&lt;Salary&gt;17000&lt;/Salary&gt;&lt;Manager&gt;Steven
 King&lt;/Manager&gt;&lt;Commission&gt;&lt;/Commission&gt;&lt;/Employee&gt;&lt;/EmployeeList&gt;&lt;/Department&gt;
</pre>
<p>This query generates element <code>Department</code> for each row in the <code>departments</code> table.</p>
<ul>
<li>
<p>Each <code>Department</code> element contains attribute <code>DepartmentID</code>. The value of <code>DepartmentID</code> comes from the <code>department_id</code> column. The <code>Department</code> element contains sub-elements <code>Name</code>, <code>Location</code>, and <code>EmployeeList</code>.</p>
</li>
<li>
<p>The text node associated with the <code>Name</code> element comes from the <code>name</code> column in the <code>departments</code> table.</p>
</li>
<li>
<p>The <code>Location</code> element has child elements <code>Address</code>, <code>City</code>, <code>State</code>, <code>Zip</code>, and <code>Country</code>. These elements are constructed by creating a forest of named elements from columns in the <code>locations</code> and <code>countries</code> tables. The values in the columns become the text node for the named element.</p>
</li>
<li>
<p>The <code>EmployeeList</code> element contains an aggregation of <code>Employee</code> Elements. The content of the <code>EmployeeList</code> element is created by a subquery that returns the set of rows in the <code>employees</code> table that correspond to the current department. Each <code>Employee</code> element contains information about the employee. The contents of the elements and attributes for each <code>Employee</code> element is taken from tables <code>employees</code> and <code>jobs</code>.</p>
</li>
</ul>
<p>The output generated by SQL/XML functions is generally <span class="italic">not</span> <a id="sthref241"></a>pretty-printed. The only exception is function <code>XMLSerialize</code>&thinsp;&mdash;&thinsp;use <code>XMLSerialize</code> to pretty-print. This lets the other SQL/XML functions (1) avoid creating a full DOM when generating the required output, and (2) reduce the size of the generated document. This lack of pretty-printing by most SQL/XML functions does not matter to most applications. However, it makes verifying the generated output manually more difficult.</p>
</div>
<!-- class="example" -->
<div id="ADXDB4166" class="example">
<p class="titleinexample"><a id="BABGGAIA"></a>Example 3-42 Creating XMLType Views Over Conventional Relational Tables</p>
<pre>
CREATE OR REPLACE VIEW department_xml OF XMLType
  <span class="bold">WITH OBJECT ID (substr(</span>
                    <span class="bold">XMLCast(</span>
                      <span class="bold">XMLQuery('$p/Department/Name'</span>
                               <span class="bold">PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)</span>
                      <span class="bold">AS VARCHAR2(30)),</span>
                    <span class="bold">1,</span>
                    <span class="bold">128))</span>
  AS
  SELECT XMLElement(
           "Department",
           XMLAttributes(d.department_id AS "DepartmentId"),
           XMLForest(d.department_name AS "Name"),
           XMLElement("Location", XMLForest(street_address AS "Address",
                                            city AS "City",
                                            state_province AS "State",
                                            postal_code AS "Zip",
                                            country_name AS "Country")),
           XMLElement(
             "EmployeeList",
             (SELECT XMLAgg(
                       XMLElement(
                          "Employee",
                          XMLAttributes(e.employee_id AS "employeeNumber"),
                          XMLForest(e.first_name AS "FirstName",
                                    e.last_name AS "LastName",
                                    e.email AS "EmailAddress",
                                    e.phone_number AS "PHONE_NUMBER",
                                    e.hire_date AS "StartDate",
                                    j.job_title AS "JobTitle",
                                    e.salary AS "Salary",
                                    m.first_name || ' ' ||
                                    m.last_name AS "Manager"),
                          XMLElement("Commission", e.commission_pct)))
                FROM hr.employees e, hr.employees m, hr.jobs j
                WHERE e.department_id = d.department_id
                  AND j.job_id = e.job_id
                  AND m.employee_id = e.manager_id))).extract('/*')
    AS XML
    FROM hr.departments d, hr.countries c, hr.locations l
    WHERE d.location_id = l.location_id
      AND l.country_id  = c.country_id;

View created.
</pre>
<p>The <code>XMLType</code> view lets relational data be persisted as XML content. Rows in <code>XMLType</code> views can be persisted as documents in Oracle XML&nbsp;DB Repository. The contents of an <code>XMLType</code> view can be queried, as shown in <a href="#BABJGAEG">Example 3-43</a>.</p>
</div>
<!-- class="example" -->
<p><a href="#BABJGAEG">Example 3-43</a> shows a simple query against an <code>XMLType</code> view. The XPath expression passed to SQL/XML function <code>XMLExists</code> restricts the result set to the node that contains the <code>Executive</code> department information. The result is shown pretty-printed here for clarity.</p>
<div id="ADXDB4167" class="example">
<p class="titleinexample"><a id="BABJGAEG"></a>Example 3-43 Querying XMLType Views</p>
<pre>
SELECT OBJECT_VALUE FROM department_xml
  WHERE XMLExists('$p/Department[Name="Executive"]' PASSING OBJECT_VALUE AS "p");
 
OBJECT_VALUE
------------------------------------------------
&lt;Department DepartmentId="90"&gt;
  &lt;Name&gt;Executive&lt;/Name&gt;
  &lt;Location&gt;
    &lt;Address&gt;2004 Charade Rd&lt;/Address&gt;
    &lt;City&gt;Seattle&lt;/City&gt;
    &lt;State&gt;Washington&lt;/State&gt;
    &lt;Zip&gt;98199&lt;/Zip&gt;
    &lt;Country&gt;United States of America&lt;/Country&gt;
  &lt;/Location&gt;
  &lt;EmployeeList&gt;
    &lt;Employee employeeNumber="101"&gt;
      &lt;FirstName&gt;Neena&lt;/FirstName&gt;
      &lt;LastName&gt;Kochhar&lt;/LastName&gt;
      &lt;EmailAddress&gt;NKOCHHAR&lt;/EmailAddress&gt;
      &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
      &lt;StartDate&gt;2005-09-21&lt;/StartDate&gt;
      &lt;JobTitle&gt;Administration Vice President&lt;/JobTitle&gt;
      &lt;Salary&gt;17000&lt;/Salary&gt;
      &lt;Manager&gt;Steven King&lt;/Manager&gt;
      &lt;Commission/&gt;
    &lt;/Employee&gt;
    &lt;Employee employeeNumber="102"&gt;
      &lt;FirstName&gt;Lex&lt;/FirstName&gt;
      &lt;LastName&gt;De Haan&lt;/LastName&gt;
      &lt;EmailAddress&gt;LDEHAAN&lt;/EmailAddress&gt;
      &lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE_NUMBER&gt;
      &lt;StartDate&gt;2001-01-13&lt;/StartDate&gt;
      &lt;JobTitle&gt;Administration Vice President&lt;/JobTitle&gt;
      &lt;Salary&gt;17000&lt;/Salary&gt;
      &lt;Manager&gt;Steven King&lt;/Manager&gt;
      &lt;Commission/&gt;
    &lt;/Employee&gt;
  &lt;/EmployeeList&gt;
&lt;/Department&gt;
 
1 row selected.
</pre>
<p>As can be seen from the following execution plan output, Oracle XML&nbsp;DB is able to correctly rewrite the XPath-expression argument in the <code>XMLExists</code> expression into a <code>SELECT</code> statement on the underlying relational tables.</p>
<pre>
SELECT OBJECT_VALUE FROM department_xml
  WHERE XMLExists('$p/Department[Name="Executive"]' PASSING OBJECT_VALUE AS "p");

PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------------------------------
Plan hash value: 2414180351

----------------------------------------------------------------------------------------------------
| Id  | Operation                      | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT               |                   |     1 |    80 |     3   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE                |                   |     1 |   115 |            |          |
|*  2 |   HASH JOIN                    |                   |    10 |  1150 |     7  (15)| 00:00:01 |
|*  3 |    HASH JOIN                   |                   |    10 |   960 |     5  (20)| 00:00:01 |
|   4 |     TABLE ACCESS BY INDEX ROWID| EMPLOYEES         |    10 |   690 |     2   (0)| 00:00:01 |
|*  5 |      INDEX RANGE SCAN          | EMP_DEPARTMENT_IX |    10 |       |     1   (0)| 00:00:01 |
|   6 |     TABLE ACCESS FULL          | JOBS              |    19 |   513 |     2   (0)| 00:00:01 |
|   7 |    TABLE ACCESS FULL           | EMPLOYEES         |   107 |  2033 |     2   (0)| 00:00:01 |
|   8 |  NESTED LOOPS                  |                   |     1 |    80 |     3   (0)| 00:00:01 |
|   9 |   NESTED LOOPS                 |                   |     1 |    68 |     3   (0)| 00:00:01 |
|* 10 |    TABLE ACCESS FULL           | DEPARTMENTS       |     1 |    19 |     2   (0)| 00:00:01 |
|  11 |    TABLE ACCESS BY INDEX ROWID | LOCATIONS         |     1 |    49 |     1   (0)| 00:00:01 |
|* 12 |     INDEX UNIQUE SCAN          | LOC_ID_PK         |     1 |       |     0   (0)| 00:00:01 |
|* 13 |   INDEX UNIQUE SCAN            | COUNTRY_C_ID_PK   |     1 |    12 |     0   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("M"."EMPLOYEE_ID"="E"."MANAGER_ID")
   3 - access("J"."JOB_ID"="E"."JOB_ID")
   5 - access("E"."DEPARTMENT_ID"=:B1)
  10 - filter("D"."DEPARTMENT_NAME"='Executive')
  12 - access("D"."LOCATION_ID"="L"."LOCATION_ID")
  13 - access("L"."COUNTRY_ID"="C"."COUNTRY_ID")
 
30 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
XPath rewrite on XML expressions that operate on <code>XMLType</code> views is only supported when nodes referenced in the XPath expression are <span class="italic">not</span> descendants of an element created using SQL function <code>XMLAgg</code>.</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4168" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref242"></a>
<h3 class="sect2">Generating XML Data from Relational Data using DBURITYPE</h3>
<p>You can also generate XML from relational data using SQL function <code>DBURIType</code>. Function <code>DBURIType</code> exposes one or more rows in a given table or view as a single XML document. The name of the root element is derived from the name of the table or view. The root element contains a set of <code>ROW</code> elements. There is one <code>ROW</code> element for each row in the table or view. The children of each <code>ROW</code> element are derived from the columns in the table or view. Each child element contains a text node with the value of the column for the given row.</p>
<p><a href="#BABCGFBC">Example 3-44</a> shows how to use SQL function <code>DBURIType</code> to access the contents of table <code>departments</code> in database schema <code>HR</code>. It uses method <code>getXML()</code> to return the resulting document as an <code>XMLType</code> instance.</p>
<div id="ADXDB4169" class="example">
<p class="titleinexample"><a id="BABCGFBC"></a>Example 3-44 Generating XML Data from a Relational Table using DBURIType and getXML()</p>
<pre>
SELECT DBURIType('/HR/DEPARTMENTS').getXML() FROM DUAL;
 
DBURITYPE('/HR/DEPARTMENTS').GETXML()
------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;DEPARTMENTS&gt;
 &lt;ROW&gt;
  &lt;DEPARTMENT_ID&gt;10&lt;/DEPARTMENT_ID&gt;
  &lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMENT_NAME&gt;
  &lt;MANAGER_ID&gt;200&lt;/MANAGER_ID&gt;
  &lt;LOCATION_ID&gt;1700&lt;/LOCATION_ID&gt;
 &lt;/ROW&gt;
<span class="bold">...</span>
 &lt;ROW&gt;
  &lt;DEPARTMENT_ID&gt;20&lt;/DEPARTMENT_ID&gt;
  &lt;DEPARTMENT_NAME&gt;Marketing&lt;/DEPARTMENT_NAME&gt;
  &lt;MANAGER_ID&gt;201&lt;/MANAGER_ID&gt;
  &lt;LOCATION_ID&gt;1800&lt;/LOCATION_ID&gt;
 &lt;/ROW&gt;
&lt;/DEPARTMENTS&gt;
</pre></div>
<!-- class="example" -->
<p><a href="#BJFIFCCF">Example 3-45</a> shows how to use an XPath predicate to restrict the rows that are included in an XML document generated using <code>DBURIType</code>. The XPath expression in the example restricts the XML document to <code>DEPARTMENT_ID</code> columns with value <code>10</code>.</p>
<div id="ADXDB4170" class="example">
<p class="titleinexample"><a id="BJFIFCCF"></a>Example 3-45 Restricting Rows using an XPath Predicate</p>
<pre>
SELECT DBURIType('/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]').getXML()
  FROM DUAL;
 
DBURITYPE('/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]').GETXML()
------------------------------------------------------------------
&lt;?xml version="1.0"?&gt;
 &lt;ROW&gt;
  &lt;DEPARTMENT_ID&gt;10&lt;/DEPARTMENT_ID&gt;
  &lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMENT_NAME&gt;
  &lt;MANAGER_ID&gt;200&lt;/MANAGER_ID&gt;
  &lt;LOCATION_ID&gt;1700&lt;/LOCATION_ID&gt;
 &lt;/ROW&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<p>SQL function <code>DBURIType</code> provides a simple way to expose some or all rows in a relational table as one or more XML documents. The URL passed to function <code>DBURIType</code> can be extended to return a single column from the view or table, but in that case the URL must also include predicates that identify a single row in the target table or view.</p>
<p><a href="#BJFDCFGG">Example 3-46</a> illustrates this. The predicate <code>[DEPARTMENT_ID="10"]</code> causes the query to return the value of column <code>department_name</code> for the <code>departments</code> row where column <code>department_id</code> has the value <code>10</code>.</p>
<div id="ADXDB5804" class="example">
<p class="titleinexample"><a id="BJFDCFGG"></a>Example 3-46 Restricting Rows and Columns using an XPath Predicate</p>
<pre>
SELECT DBURIType(
         '/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]/<span class="bold">DEPARTMENT_NAME</span>').getXML()
  FROM DUAL;
 
DBURITYPE('/HR/DEPARTMENTS/ROW[DEPARTMENT_ID="10"]/DEPARTMENT_NAME').GETXML()
-----------------------------------------------------------------------------
&lt;?xml version="1.0"?&gt;
 &lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMENT_NAME&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>SQL function <code>DBURIType</code> is less flexible than the SQL/XML functions:</p>
<ul>
<li>
<p>It provides no way to control the shape of the generated document.</p>
</li>
<li>
<p>The data can come only from a single table or view.</p>
</li>
<li>
<p>The generated document consists of one or more <code>ROW</code> elements. Each <code>ROW</code> element contains a child for each column in the target table.</p>
</li>
<li>
<p>The names of the child elements are derived from the column names.</p>
</li>
</ul>
<p>To control the names of the XML elements, to include columns from more than one table, or to control which columns from a table appear in the generated document, create a relational view that exposes the desired set of columns as a single row, and then use function <code>DBURIType</code> to generate an XML document from the contents of that view.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDIDHA"></a>
<div id="ADXDB4171" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">XSL <a id="sthref243"></a>Transformation and Oracle XML&nbsp;DB</h2>
<p>The W3C XSLT Recommendation defines an XML language for specifying how to transform XML documents from one form to another. Transformation can include mapping from one XML schema to another or mapping from XML to some other format such as HTML or WML.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<code><a href="http://www.w3.org/XML/Schema">http://www.w3.org/XML/Schema</a></code> for information about the XSLT standard</div>
<p>XSL transformation is typically expensive in terms of the amount of memory and processing required. Both the source document and the style sheet must be parsed and loaded into memory structures that allow random access to different parts of the documents. Most XSL processors use DOM to provide the dynamic memory representation of both documents. The XSL processor then applies the style sheet to the source document, generating a third document.</p>
<p>Oracle XML&nbsp;DB includes an XSLT processor that lets XSL transformations be performed <span class="italic">inside the database</span>. In this way, Oracle XML&nbsp;DB can provide XML-specific memory optimizations that significantly reduce the memory required to perform the transformation. It can also eliminate overhead associated with parsing the documents. These optimizations are only available when the source for the transformation is a <span class="italic">schema-based</span> XML document, however.</p>
<p>Oracle XML provides three ways to invoke the XSL processor:</p>
<ul>
<li>
<p>SQL function <code>XMLtransform</code></p>
</li>
<li>
<p><code>XMLType</code> method <code>transform()</code></p>
</li>
<li>
<p>PL/SQL package <code>DBMS_XSLPROCESSOR</code></p>
</li>
</ul>
<p>Each of these XML transformation methods takes as input a source XML document and an XSL style sheet in the form of <code>XMLType</code> instances. For SQL function <code>XMLtransform</code> and <code>XMLType</code> method <code>transform()</code>, the result of the transformation can be an XML document or a non-XML document, such as HTML. However, for PL/SQL package <code>DBMS_XSLPROCESSOR</code>, the result of the transformation is expected to be a valid XML document. Any HTML generated by a transformation using package <code>DBMS_XSLPROCESSOR</code> is XHTML, which is both valid XML and valid HTML.</p>
<p><a href="#BJFCGIFJ">Example 3-47</a> shows <span class="italic">part</span> of an XSLT style sheet, <code>PurchaseOrder.xsl</code>. The complete style sheet is given in <a href="apphxdb.htm#i642411">"XSL Style Sheet Example, PurchaseOrder.xsl"</a>.</p>
<div id="ADXDB4172" class="example">
<p class="titleinexample"><a id="BJFCGIFJ"></a>Example 3-47 XSLT Style Sheet Example: PurchaseOrder.xsl</p>
<pre>
&lt;?xml version="1.0" encoding="WINDOWS-1252"?&gt;
&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xdb="http://xmlns.oracle.com/xdb" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;html&gt;
      &lt;head/&gt;
      &lt;body bgcolor="#003333" text="#FFFFCC" link="#FFCC00" vlink="#66CC99" alink="#669999"&gt;
        &lt;FONT FACE="Arial, Helvetica, sans-serif"&gt;
          &lt;xsl:for-each select="PurchaseOrder"/&gt;
          &lt;xsl:for-each select="PurchaseOrder"&gt;
            &lt;center&gt;
              &lt;span style="font-family:Arial; font-weight:bold"&gt;
                &lt;FONT COLOR="#FF0000"&gt;
                  &lt;B&gt;PurchaseOrder &lt;/B&gt;
                &lt;/FONT&gt;
              &lt;/span&gt;
            &lt;/center&gt;
            &lt;br/&gt;
            &lt;center&gt;
              &lt;xsl:for-each select="Reference"&gt;
                &lt;span style="font-family:Arial; font-weight:bold"&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/span&gt;
              &lt;/xsl:for-each&gt;
            &lt;/center&gt;
          &lt;/xsl:for-each&gt;
          &lt;P&gt;
            &lt;xsl:for-each select="PurchaseOrder"&gt;
              &lt;br/&gt;
            &lt;/xsl:for-each&gt;
            &lt;P/&gt;
            &lt;P&gt;
              &lt;xsl:for-each select="PurchaseOrder"&gt;
                &lt;br/&gt;
              &lt;/xsl:for-each&gt;
            &lt;/P&gt;
          &lt;/P&gt;
          &lt;xsl:for-each select="PurchaseOrder"/&gt;
          &lt;xsl:for-each select="PurchaseOrder"&gt;
            &lt;table border="0" width="100%" BGCOLOR="#000000"&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td WIDTH="296"&gt;
                    &lt;P&gt;
                      &lt;B&gt;
                        &lt;FONT SIZE="+1" COLOR="#FF0000" FACE="Arial, Helvetica, sans-serif"&gt;Internal&lt;/FONT&gt;
                      &lt;/B&gt;
                    &lt;/P&gt;

                    <span class="bold">...</span>

                  &lt;/td&gt;
                  &lt;td width="93"/&gt;
                  &lt;td valign="top" WIDTH="340"&gt;
                    &lt;B&gt;
                      &lt;FONT COLOR="#FF0000"&gt;
                        &lt;FONT SIZE="+1"&gt;Ship To&lt;/FONT&gt;
                      &lt;/FONT&gt;
                    &lt;/B&gt;
                    &lt;xsl:for-each select="ShippingInstructions"&gt;
                      &lt;xsl:if test="position()=1"/&gt;
                    &lt;/xsl:for-each&gt;
                    &lt;xsl:for-each select="ShippingInstructions"&gt;
                    &lt;/xsl:for-each&gt;
 
                      <span class="bold">...</span>
</pre></div>
<!-- class="example" -->
<p>These is nothing Oracle XML&nbsp;DB-specific about the style sheet of <a href="#BJFCGIFJ">Example 3-47</a>. A style sheet can be stored in an <code>XMLType</code> table or column or stored as non-schema-based XML data inside Oracle XML&nbsp;DB Repository.</p>
<p>Performing transformations inside the database lets Oracle XML&nbsp;DB optimize features such as memory usage, I/O operations, and network traffic. These optimizations are particularly effective when the transformation operates on a <span class="italic">small subset</span> of the nodes in the source document.</p>
<p>In traditional XSL processors, the entire source document must be parsed and loaded into memory before XSL processing can begin. This process requires significant amounts of memory and processor. When only a small part of the document is processed this is inefficient.</p>
<p>When Oracle XML&nbsp;DB performs XSL transformations on a <span class="italic">schema-based</span> XML document there is no need to parse the document before processing can begin. The lazily loaded virtual DOM eliminates the need to parse the document, by loading content directly from disk as the nodes are accessed. The lazy load also reduces the amount of memory required to perform the transformation, because only the parts of the document that are processed are loaded into memory.</p>
<p><a href="#BJFJJDIB">Example 3-48</a> shows how to use SQL function <code>XMLtransform</code> to apply an XSL style sheet to a document stored in an <code>XMLType</code> table, producing HTML code. SQL function <code>XDBURIType</code> reads the XSL style sheet from Oracle XML&nbsp;DB Repository.</p>
<p>In the interest of brevity, only part of the result of the transformation is shown in <a href="#BJFJJDIB">Example 3-48</a>. Omitted parts are indicated with an ellipsis (<code><span class="codeinlinebold">. . .</span></code>). <a href="#BABJGIGH">Figure 3-7</a> shows what the transformed result looks like in a Web browser.</p>
<div id="ADXDB4173" class="example">
<p class="titleinexample"><a id="BJFJJDIB"></a>Example 3-48 Applying a Style Sheet using TRANSFORM</p>
<pre>
SELECT
  <span class="bold">XMLtransform</span>(
    OBJECT_VALUE, 
    <span class="bold">XDBURIType</span>('/source/schemas/poSource/xsl/purchaseOrder.xsl').getXML())
  FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");
 
XMLTRANSFORM(OBJECT_VALUE, XDBURITYPE('/SOURCE/SCHEMAS/POSOURCE/XSL/PURCHASEORDER.XSL').GET
---------------------------------------------------------------------------------------------
&lt;html xmlns:xdb="http://xmlns.oracle.com/xdb"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;head/&gt;
  &lt;body bgcolor="#003333" text="#FFFFCC" link="#FFCC00" vlink="#66CC99" alink="#669999"&gt;
    &lt;FONT FACE="Arial, Helvetica, sans-serif"&gt;
      &lt;center&gt;
        &lt;span style="font-family:Arial; font-weight:bold"&gt;
          &lt;FONT COLOR="#FF0000"&gt;
            &lt;B&gt;PurchaseOrder &lt;/B&gt;
          &lt;/FONT&gt;
        &lt;/span&gt;
      &lt;/center&gt;
      &lt;br/&gt;
      &lt;center&gt;
        &lt;span style="font-family:Arial; font-weight:bold"&gt;SBELL-2002100912333601PDT&lt;/span&gt;
      &lt;/center&gt;
      &lt;P&gt;
        &lt;br/&gt;
        &lt;P/&gt;
        &lt;P&gt;
          &lt;br/&gt;
        &lt;/P&gt;
      &lt;/P&gt;
      &lt;table border="0" width="100%" BGCOLOR="#000000"&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td WIDTH="296"&gt;
              &lt;P&gt;
                &lt;B&gt;
                  &lt;FONT SIZE="+1" COLOR="#FF0000" FACE="Arial, Helvetica,
                        sans-serif"&gt;Internal&lt;/FONT&gt;
                &lt;/B&gt;
              &lt;/P&gt;
              &lt;table border="0" width="98%" BGCOLOR="#000099"&gt;
<span class="bold">                                                     . . .</span>
              &lt;/table&gt;
            &lt;/td&gt;
            &lt;td width="93"&gt;
            &lt;/td&gt;
            &lt;td valign="top" WIDTH="340"&gt;
              &lt;B&gt;
                &lt;FONT COLOR="#FF0000"&gt;
                  &lt;FONT SIZE="+1"&gt;Ship To&lt;/FONT&gt;
                &lt;/FONT&gt;
              &lt;/B&gt;
              &lt;table border="0" BGCOLOR="#999900"&gt;
                <span class="bold">. . .</span>
              &lt;/table&gt;
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
      &lt;br/&gt;
      &lt;B&gt;
        &lt;FONT COLOR="#FF0000" SIZE="+1"&gt;Items:&lt;/FONT&gt;
      &lt;/B&gt;
      &lt;br/&gt;
      &lt;br/&gt;
      &lt;table border="0"&gt;
        <span class="bold">. . .</span>
      &lt;/table&gt;
    &lt;/FONT&gt;
  &lt;/body&gt;
&lt;/html&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb08tra.htm#g1030361">Chapter 11, "Transforming and Validating XMLType Data"</a></div>
</div>
<!-- class="sect1" -->
<a id="BABEDIHI"></a>
<div id="ADXDB4174" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Oracle XML&nbsp;DB Repository</h2>
<p>Oracle XML&nbsp;DB Repository makes it possible to organize XML content using a file/folder metaphor. This lets you use a URL to uniquely identify XML documents stored in the database. This approach appeals to XML developers used to using constructs such as URLs and XPath expressions to identify content.</p>
<p>Oracle XML&nbsp;DB Repository is modelled on the DAV standard. The DAV standard uses the term <span class="glossaryterm">resource</span> to describe any file or folder managed by a WebDAV server. A resource consists of a combination of metadata and content. The DAV specification defines the set of (system-defined) metadata properties that a WebDAV server is expected to maintain for each resource and the set of XML documents that a DAV server and DAV-enabled client uses to exchange metadata.</p>
<p>Although Oracle XML&nbsp;DB Repository can manage any kind of content, it provides specialized capabilities and optimizations related to managing resources where the content is XML.</p>
<div id="ADXDB4175" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref244"></a>
<h3 class="sect2">Installing and Uninstalling Oracle XML&nbsp;DB Repository</h3>
<p>All of the metadata and content managed by Oracle XML&nbsp;DB Repository is stored using a set of tables in the database schema owned by database schema (user account) <code><a id="sthref245"></a><a id="sthref246"></a><a id="sthref247"></a>XDB</code>. User <code>XDB</code> is a locked account that is installed using DBCA or by running script <code>catqm.sql</code>. Script <code>catqm.sql</code> is located in the directory <code>ORACLE_HOME/rdbms/admin</code>. The repository can be uninstalled using DBCA or by running the script <code>catnoqm.sql</code>. Take great care when running <code>catnoqm.sql</code> as it <span class="italic">drops all content</span> stored in Oracle XML&nbsp;DB Repository and <span class="italic">invalidates</span> any <code>XMLType</code> tables or columns associated with registered XML schemas.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink TDPSG20030" href="../../server.112/e10575/tdpsg_user_accounts.htm#TDPSG20030"><span class="italic">Oracle Database 2 Day + Security Guide</span></a> for information about database schema <code>XDB</code></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4176" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref248"></a>
<h3 class="sect2">Oracle XML&nbsp;DB Provides Name-Level Locking</h3>
<p>When using a relational database to maintain hierarchical folder structures, ensuring a high degree of concurrency when adding and removing items in a folder is a challenge. In conventional file system there is no concept of a transaction. Each operation (add a file, create a subfolder, rename a file, delete a file, and so on) is treated as an atomic transaction. Once the operation has completed the change is immediately available to all other users of the file system.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As a consequence of transactional semantics enforced by the database, folders created using SQL statements are <span class="italic">not</span> visible to other database users until the transaction is committed. <span class="italic">Concurrent</span> access to Oracle XML&nbsp;DB Repository is controlled by the same mechanism used to control concurrency in Oracle Database. The integration of the repository with Oracle Database provides <span class="italic">strong management options for XML content</span>.</div>
<p>One key advantage of Oracle XML&nbsp;DB Repository is the ability to use SQL for repository operations in the context of a logical transaction. Applications can create long-running transactions that include updates to one or more folders. In this situation, a conventional locking strategy that takes an exclusive lock on each updated folder or directory tree would quickly result in significant concurrency problems.</p>
<p>Oracle XML&nbsp;DB solves this by providing for name-level locking rather than folder-level locking. Repository operations such as creating, renaming, moving, or deleting a sub-folder or file do not require that your operation be granted an exclusive write lock on the target folder. The repository manages concurrent folder operations by locking the name within the folder rather than the folder itself. The name and the modification type are put on a queue.</p>
<p>Only when the transaction is committed is the folder locked and its contents modified. Hence Oracle XML&nbsp;DB lets multiple applications perform concurrent updates on the contents of a folder. The queue is also used to manage folder concurrency by preventing two applications from creating objects with the same name.</p>
<p>Queuing folder modifications until commit time also minimizes I/O when a number of changes are made to a single folder in the same transaction.</p>
<p>This is useful when several applications generate files quickly in the same directory, for example when generating trace or log files, or when maintaining a spool directory for printing or e-mail delivery.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB4178" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref249"></a>
<h3 class="sect2">Use Protocols or SQL to Access and Process Repository Content</h3>
<p>You can work with content stored in Oracle XML&nbsp;DB Repository in these ways:</p>
<ul>
<li>
<p>Using industry standard protocols such as HTTP(S), WebDAV, and FTP to perform document-level operations such as insert, update, and delete.</p>
</li>
<li>
<p>By directly accessing Oracle XML&nbsp;DB Repository content at the table or row level, using SQL.</p>
</li>
<li>
<p>Using Oracle XML DB Content Connector&thinsp;&mdash;&thinsp;see <a href="xdb_jcr.htm#BABHGHCI">Chapter 31, "Using Oracle XML DB Content Connector"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4179" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref250"></a>
<h3 class="sect2">Storing and Retrieving Database Content using Standard Protocols</h3>
<p>Oracle XML&nbsp;DB supports industry-standard internet protocols such as HTTP(S), WebDav, and FTP. The combination of protocol support and URL-based access makes it possible to insert, retrieve, update, and delete content stored in Oracle Database from standard desktop applications such as Windows Explorer, Microsoft Word, and XMLSpy.</p>
<p><a href="#CEGGCEJC">Figure 3-4</a> shows Windows Explorer used to insert a folder from the local hard drive into Oracle Database. Windows Explorer includes support for the WebDAV protocol. WebDAV extends the HTTP standard, adding additional verbs that allow an HTTP server to act as a file server.</p>
<p>When a Windows Explorer copy operation or FTP input command is used to transfer a number of documents into Oracle XML&nbsp;DB Repository, each <code>put</code> or <code>post</code> command is treated as a separate atomic operation. This ensures that the client does not get confused if one of the file transfers fails. It also means that changes made to a document through a protocol are visible to other users as soon as the request has been processed.</p>
<div id="ADXDB4180" class="figure">
<p class="titleinfigure"><a id="CEGGCEJC"></a>Figure 3-4 Copying Files into Oracle XML&nbsp;DB Repository</p>
<img width="693" height="465" src="img/copy_sample.gif" alt="Description of Figure 3-4 follows" /><br />
<a id="sthref251" href="img_text/copy_sample.htm">Description of "Figure 3-4 Copying Files into Oracle XML&nbsp;DB Repository"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ADXDB4181" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref252"></a>
<h3 class="sect2">Uploading Content to Oracle XML&nbsp;DB using FTP</h3>
<p><a href="#BJFHDDHE">Example 3-49</a> shows commands issued and output generated when a standard command line FTP tool loads documents into Oracle XML&nbsp;DB Repository:</p>
<div id="ADXDB4182" class="example">
<p class="titleinexample"><a id="BJFHDDHE"></a>Example 3-49 Uploading Content to the Repository using FTP</p>
<pre>
$ ftp mdrake-sun 2100
Connected to mdrake-sun.
220 mdrake-sun FTP Server (Oracle XML DB/Oracle Database 10g Enterprise Edition
Release 10.1.0.1.0 - Beta) ready.
Name (mdrake-sun:oracle10): QUINE
331 Password required for QUINE
Password: <span class="italic">password</span>
230 QUINE logged in
ftp&gt; cd /source/schemas
250 CWD Command successful
ftp&gt; mkdir PurchaseOrders
257 MKD Command successful
ftp&gt; cd PurchaseOrders
250 CWD Command successful
ftp&gt; mkdir 2002
257 MKD Command successful
ftp&gt; cd 2002
250 CWD Command successful
ftp&gt; mkdir "Apr"
257 MKD Command successful
ftp&gt; put "Apr/AMCEWEN-20021009123336171PDT.xml"
"Apr/AMCEWEN-20021009123336171PDT.xml"
200 PORT Command successful
150 ASCII Data Connection
226 ASCII Transfer Complete
local: Apr/AMCEWEN-20021009123336171PDT.xml remote:
Apr/AMCEWEN-20021009123336171PDT.xml
4718 bytes sent in 0.0017 seconds (2683.41 Kbytes/s)
ftp&gt; put "Apr/AMCEWEN-20021009123336271PDT.xml"
"Apr/AMCEWEN-20021009123336271PDT.xml"
200 PORT Command successful
150 ASCII Data Connection
226 ASCII Transfer Complete
local: Apr/AMCEWEN-20021009123336271PDT.xml remote:
Apr/AMCEWEN-20021009123336271PDT.xml
4800 bytes sent in 0.0014 seconds (3357.81 Kbytes/s)
.....
ftp&gt; cd "Apr"
250 CWD Command successful
ftp&gt; ls -l
200 PORT Command successful
150 ASCII Data Connection
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 AMCEWEN-20021009123336171PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 AMCEWEN-20021009123336271PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 EABEL-20021009123336251PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 PTUCKER-20021009123336191PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 PTUCKER-20021009123336291PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 SBELL-20021009123336231PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 SBELL-20021009123336331PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 SKING-20021009123336321PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 SMCCAIN-20021009123336151PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 SMCCAIN-20021009123336341PDT.xml
-rw-r--r1 QUINE oracle 0 JUN 24 15:41 VJONES-20021009123336301PDT.xml
226 ASCII Transfer Complete
remote: -l
959 bytes received in 0.0027 seconds (349.45 Kbytes/s)
ftp&gt; cd ".."
250 CWD Command successful
....
ftp&gt; quit
221 QUIT Goodbye.
$
</pre></div>
<!-- class="example" -->
<p>The key point demonstrated by <a href="#CEGGCEJC">Figure 3-4</a> and <a href="#BJFHDDHE">Example 3-49</a> is that neither Windows Explorer nor an FTP tool is aware that it is working with Oracle XML&nbsp;DB. Since the tools and Oracle XML&nbsp;DB both support open Internet protocols they work with each other out of the box.</p>
<p>Any tool that understands the WebDAV or FTP protocol can be used to create content managed by Oracle XML&nbsp;DB Repository. No additional software has to installed on the client or the mid-tier.</p>
<p>When the contents of the folders are viewed using a tool such as Windows Explorer or FTP, the length of any schema-based XML documents contained in the folder is shown as zero (0) bytes. This was designed as such for two reasons:</p>
<ul>
<li>
<p>It is not clear what the size of the document should be. Is it the size of the <code>CLOB</code> instance generated by printing the document, or the number of bytes required to store the objects used to persist the document inside the database?</p>
</li>
<li>
<p>Regardless of which definition is chosen, calculating and maintaining this information is costly.</p>
</li>
</ul>
<p><a href="#CEGICACC">Figure 3-5</a> shows Internet Explorer using a URL and the HTTP protocol to view an XML document stored in the database.</p>
<div id="ADXDB4183" class="figure">
<p class="titleinfigure"><a id="CEGICACC"></a>Figure 3-5 Path-Based Access using HTTP and a URL</p>
<img width="665" height="551" src="img/path_based.gif" alt="Description of Figure 3-5 follows" /><br />
<a id="sthref253" href="img_text/path_based.htm">Description of "Figure 3-5 Path-Based Access using HTTP and a URL"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ADXDB4184" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref254"></a>
<h3 class="sect2">Accessing Oracle XML&nbsp;DB Repository Programmatically</h3>
<p>Oracle XML&nbsp;DB Repository can be accessed and updated directly from SQL. Thus, any application or programming language that can use SQL to interact with Oracle Database can also access and update content stored in the repository. Oracle XML&nbsp;DB includes PL/SQL package <code>DBMS_XDB</code>, which provides methods that allow resources to be created, modified, and deleted programmatically.</p>
<p><a href="#BJFFJBGA">Example 3-50</a> shows how to create a simple text document resource using PL/SQL function <code>DBMS_XDB.createResource</code>.</p>
<div id="ADXDB4185" class="example">
<p class="titleinexample"><a id="BJFFJBGA"></a>Example 3-50 Creating a Text Document Resource using CREATERESOURCE</p>
<pre>
DECLARE
  res BOOLEAN;
BEGIN
  res := DBMS_XDB.createResource('/home/QUINE/NurseryRhyme.txt',
                                 bfilename('XMLDIR', 'tdadxdb-03-01.txt'),
                                 nls_charset_id('AL32UTF8'));
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="ADXDB4186" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref255"></a>
<h3 class="sect2">Accessing and Updating XML Content in the Repository</h3>
<p>This section describes features for accessing and updating Oracle XML&nbsp;DB Repository content.</p>
<div id="ADXDB5989" class="sect3"><a id="sthref256"></a>
<h4 class="sect3">Accessing XML Documents using SQL</h4>
<p>Content stored in the repository can be accessed and updated from SQL and PL/SQL. You can interrogate the structure of the repository in complex ways. For example, you can query to determine how many files with extension <code>.xsl</code> are under a location other than <code>/home/mystylesheetdir</code>.</p>
<p>You can also mix path-based repository access with content-based access. You can, for example, ask "How many documents not under <code>/home/purchaseOrders</code> have a node identified by the XPath <code>/PurchaseOrder/User/text()</code> with a value of <code>KING</code>?"</p>
<p>All of the <span class="italic">metadata</span> for managing the repository is stored in a database schema owned by database schema (user account) <code><a id="sthref257"></a><a id="sthref258"></a><a id="sthref259"></a>XDB</code>. User <code>XDB</code> is created during Oracle XML&nbsp;DB installation. The primary table in this schema is an <code>XMLType</code> table called <code>XDB$RESOURCE</code>. This contains one row for each resource (file or folder) in the repository. Documents in this table are referred to as <span class="glossaryterm"><a id="sthref260"></a>resource documents</span>. The XML schema that defines the structure of an Oracle XML&nbsp;DB resource document is registered under URL, <code>"http://xmlns.oracle.com/xdb/XDBResource.xsd</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink TDPSG20030" href="../../server.112/e10575/tdpsg_user_accounts.htm#TDPSG20030"><span class="italic">Oracle Database 2 Day + Security Guide</span></a> for information about database schema <code>XDB</code></div>
</div>
<!-- class="sect3" -->
<div id="ADXDB5990" class="sect3"><a id="sthref261"></a>
<h4 class="sect3">Repository Content is Exposed Through RESOURCE_VIEW and PATH_VIEW</h4>
<p>Table <code>XDB$RESOURCE</code> is not directly exposed to SQL programmers. Instead, the contents of the repository are exposed through two public views, <code>RESOURCE_VIEW</code> and <code>PATH_VIEW</code>. Through these views, you can access and update both the metadata and the content of documents stored in the repository. Both views contain a virtual column, <code>RES</code>. Use <code>RES</code> to access and update resource documents with SQL statements using a path notation. Operations on the views use underlying tables in the repository.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB5991" class="sect3"><a id="sthref262"></a>
<h4 class="sect3">Use EXISTS_PATH and UNDER_PATH for Path-Based Predicates in a WHERE Clause</h4>
<p>Oracle XML&nbsp;DB includes two repository-specific SQL functions: <code>exists_path</code> and <code>under_path</code>. Use these functions to include path-based predicates in the <code>WHERE</code> clause of a SQL statement. SQL operations can select repository content based on the location of the content in the repository folder hierarchy. The hierarchical repository index ensures that path-based queries are executed efficiently.</p>
<p>When <span class="italic">XML schema-based</span> XML documents are stored in the repository, the document content is stored as an object in the default table identified by the XML schema. The repository contains only <span class="italic">metadata</span> about the document and a <span class="italic">pointer</span> (<code>REF</code> of <code>XMLType</code>) that identifies the row in the default table that contains the content.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB5992" class="sect3"><a id="sthref263"></a>
<h4 class="sect3">You Can Also Store Non-XML Documents in the Repository</h4>
<p>It is also possible to store other kinds of documents in the repository. When a document that is not XML or is not schema-based XML is stored in the repository, the document <span class="italic">content</span> is stored in a LOB along with the metadata about the document.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB5993" class="sect3"><a id="sthref264"></a>
<h4 class="sect3">PL/SQL Packages to Create, Delete, Rename, Move,... Folders and Documents</h4>
<p>Because you can access and update Oracle XML&nbsp;DB Repository using SQL, any application capable of calling a PL/SQL procedure can use the repository. All SQL and PL/SQL repository operations are transactional. Access to the repository and its contents is subject to both standard database security controls and repository access control lists (ACLs).</p>
<p>With supplied PL/SQL packages <code>DBMS_XDB</code>, <code>DBMS_XDBZ</code>, and <code>DBMS_XDB_VERSION</code>, you can create, delete, and rename documents and folders, move a file or folder within the folder hierarchy, set and change the access permissions on a file or folder, and initiate and manage versioning.</p>
<p><a href="#BJFGAHCE">Example 3-51</a> uses PL/SQL package <code>DBMS_XDB</code> to create a set of subfolders beneath folder <code>/public</code>.</p>
<div id="ADXDB4192" class="example">
<p class="titleinexample"><a id="BJFGAHCE"></a>Example 3-51 Creating Folders using PL/SQL Package DBMS_XDB</p>
<pre>
DECLARE
  RESULT BOOLEAN;
BEGIN
  IF (NOT DBMS_XDB.existsResource('/public/mysource')) THEN
     result := DBMS_XDB.createFolder('/public/mysource');
  END IF;
  IF (NOT DBMS_XDB.existsResource('/public/mysource/schemas')) THEN
     result := DBMS_XDB.createFolder('/public/mysource/schemas');
  END IF;
  IF (NOT DBMS_XDB.existsResource('/public/mysource/schemas/poSource')) THEN
     result := DBMS_XDB.createFolder('/public/mysource/schemas/poSource');
  END IF;
  IF (NOT DBMS_XDB.existsResource('/public/mysource/schemas/poSource/xsd')) THEN
     result := DBMS_XDB.createFolder('/public/mysource/schemas/poSource/xsd');
  END IF;
  IF (NOT DBMS_XDB.existsResource('/public/mysource/schemas/poSource/xsl')) THEN
     result := DBMS_XDB.createFolder('/public/mysource/schemas/poSource/xsl');
  END IF;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4193" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref265"></a>
<h3 class="sect2">Accessing the Content of Documents using SQL</h3>
<p>You can access the content of documents stored in Oracle XML&nbsp;DB Repository in several ways. The easiest way is to use <code>XDBURIType</code>. <code>XDBURIType</code> uses a URL to specify which resource to access. The URL passed to the <code>XDBURIType</code> is assumed to start at the root of the repository. Data type <code>XDBURIType</code> provides methods <code>getBLOB()</code>, <code>getCLOB()</code>, and <code>getXML()</code> to access the different kinds of content that can be associated with a resource.</p>
<p><a href="#BJFIEFDJ">Example 3-52</a> shows how to use <code>XDBURIType</code> to access the content of the text document:</p>
<div id="ADXDB4194" class="example">
<p class="titleinexample"><a id="BJFIEFDJ"></a>Example 3-52 Accessing a Text Document in the Repository using XDBURITYPE</p>
<pre>
SELECT XDBURIType('/home/QUINE/NurseryRhyme.txt').getCLOB() FROM DUAL;
 
XDBURITYPE('/HOME/QUINE/NURSERYRHYME.TXT').GETCLOB()
----------------------------------------------------
Mary had a little lamb
Its fleece was white as snow
and everywhere that Mary went
that lamb was sure to go
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>The contents of a document can also be accessed using the resource document. <a href="#BJFHICEA">Example 3-53</a> shows how to access the content of a text document:</p>
<div id="ADXDB4195" class="example">
<p class="titleinexample"><a id="BJFHICEA"></a>Example 3-53 Accessing Resource Content using RESOURCE_VIEW</p>
<pre>
SELECT CONTENT
  FROM RESOURCE_VIEW,
       XMLTable(XMLNAMESPACES (default 'http://xmlns.oracle.com/xdb/XDBResource.xsd'),
                '/Resource/Contents' PASSING RES
                COLUMNS content CLOB PATH 'text')
  WHERE equals_path(RES, '/home/QUINE/NurseryRhyme.txt') = 1;
 
CONTENT
-------
Mary had a little lamb
Its fleece was white as snow
and everywhere that Mary went
that lamb was sure to go
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>The content of non-schema-based and schema-based XML documents can also be accessed through a resource. <a href="#BJFGFIAD">Example 3-54</a> shows how to use an XPath expression that includes nodes from a resource document and nodes from an XML document to access the contents of a <code>PurchaseOrder</code> document using the resource.</p>
<div id="ADXDB4196" class="example">
<p class="titleinexample"><a id="BJFGFIAD"></a>Example 3-54 Accessing XML Documents using Resource and Namespace Prefixes</p>
<pre>
SELECT des.description
  FROM RESOURCE_VIEW rv,
       XMLTable(<span class="bold">XMLNAMESPACES ('http://xmlns.oracle.com/xdb/XDBResource.xsd' AS "r"</span>),
                '<span class="bold">/r:Resource/r:Contents/PurchaseOrder/LineItems/LineItem</span>'
                PASSING rv.RES
                COLUMNS description VARCHAR2(256) PATH 'Description') des
  WHERE 
    equals_path(rv.RES, '/home/QUINE/PurchaseOrders/2002/Mar/SBELL-2002100912333601PDT.xml') = 1;

DES.DESCRIPTION
---------------------------------
A Night to Remember
The Unbearable Lightness Of Being
The Wizard of Oz
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#BJFGFIAD">Example 3-54</a>, the namespace prefix, <code>r</code> identifies which nodes in the XPath expression are members of the resource namespace. Namespace prefix <code>r</code> is defined using the <code>XMLNAMESPACES</code> clause of SQL/XML function <code>XMLTable</code>. The namespace declaration is needed here because the purchase-order XML schema does not define a namespace, and it is not possible to apply a namespace prefix to nodes in the <code>PurchaseOrder</code> document.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a> for more information about the <code>XMLNAMESPACES</code> clause of <code>XMLTable</code></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4197" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref266"></a>
<h3 class="sect2">Accessing the Content of XML Schema-Based Documents</h3>
<p>The content of a schema-based XML document can be accessed in two ways.</p>
<ul>
<li>
<p>In the same manner as for non-schema-based XML documents, by using the resource document. This lets <code>RESOURCE_VIEW</code> be used to query different types of schema-based XML documents with a single SQL statement.</p>
</li>
<li>
<p>As a row in the default table that was defined when the XML schema was registered with Oracle XML&nbsp;DB.</p>
</li>
</ul>
<div id="ADXDB4198" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref267"></a>
<h4 class="sect3">Accessing Resource Content using Element XMLRef in Joins</h4>
<p>The <code>XMLRef</code> element in the resource document provides the join key required when a SQL statement needs to access or update metadata and content as part of a single operation.</p>
<p>The following queries use joins based on the value of element <code>XMLRef</code> to access resource content.</p>
<p><a href="#BJFBDEJE">Example 3-55</a> locates a row in the <code>defaultTable</code> based on a path in Oracle XML&nbsp;DB Repository. SQL function <code>ref</code> locates the target row in the default table, based on the value of the <code>XMLRef</code> element in the resource document, <code>RES</code>.</p>
<div id="ADXDB4199" class="example">
<p class="titleinexample"><a id="BJFBDEJE"></a>Example 3-55 Querying Repository Resource Data using SQL Function REF and Element XMLRef</p>
<pre>
SELECT des.description
  FROM RESOURCE_VIEW rv,
       purchaseorder p,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE AS "p"
                COLUMNS description VARCHAR2(256) PATH 'Description') des
  WHERE equals_path(rv.RES, '/home/QUINE/PurchaseOrders/2002/Mar/SBELL-2002100912333601PDT.xml')
        = 1
    AND <span class="bold">ref</span>(p) = XMLCast(XMLQuery('declare default element namespace
                                  "http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                                  fn:data(/Resource/<span class="bold">XMLRef</span>)' PASSING rv.RES RETURNING CONTENT)
                         AS REF XMLType);
 
DES.DESCRIPTION
---------------------------------
A Night to Remember
The Unbearable Lightness Of Being
The Wizard of Oz
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BJFFGBIB">Example 3-56</a> shows how to select fragments from XML documents based on metadata, path, and content. The query returns the value of element <code>Reference</code> for documents under <code>/home/QUINE/PurchaseOrders/2002/Mar</code> that contain orders for part number 715515009058.</p>
<div id="ADXDB4200" class="example">
<p class="titleinexample"><a id="BJFFGBIB"></a>Example 3-56 Selecting XML Document Fragments Based on Metadata, Path, and Content</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM RESOURCE_VIEW rv, purchaseorder po
  WHERE under_path(rv.RES, '/home/QUINE/PurchaseOrders/2002/Mar') = 1
    AND ref(po) = XMLCast(
                    XMLQuery('declare default element namespace
                              "http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                              fn:data(/Resource/XMLRef)'
                             PASSING rv.RES RETURNING CONTENT)
                          AS REF XMLType)
    AND XMLExists('$p/PurchaseOrder/LineItems/LineItem/Part[@Id="715515009058"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
CJOHNSON-20021009123335851PDT
LSMITH-2002100912333661PDT
SBELL-2002100912333601PDT
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p>In general, when accessing the content of schema-based XML documents, joining <code>RESOURCE_VIEW</code> or <code>PATH_VIEW</code> with the default table is more efficient than using <code>RESOURCE_VIEW</code> or <code>PATH_VIEW</code> on its own. An explicit join between the resource document and the default table tells Oracle XML&nbsp;DB that the SQL statement works on only one type of XML document. XPath rewrite can thus be used to optimize operations on the default table and the resource.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4201" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref268"></a>
<h3 class="sect2">Updating the Content of Documents Stored in the Repository</h3>
<p>You can update the content of documents stored in Oracle XML&nbsp;DB Repository using protocols or SQL.</p>
<div id="ADXDB4202" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref269"></a>
<h4 class="sect3">Updating Repository Content using Protocols</h4>
<p>The most popular content authoring tools support HTTP, FTP, and WebDAV protocols. These tools can use a URL and the HTTP verb <code>get</code> to access the content of a document, and the HTTP verb <code>put</code> to save the contents of a document. Hence, given the appropriate access permissions, a simple URL is all you need to access and edit content stored in Oracle XML&nbsp;DB Repository.</p>
<p><a href="#CHDGFBEC">Figure 3-6</a> shows how, with the WebDAV support included in Microsoft Word, you can use Microsoft Word to update and edit a document stored in Oracle XML&nbsp;DB Repository.</p>
<div id="ADXDB4203" class="figure">
<p class="titleinfigure"><a id="CHDGFBEC"></a>Figure 3-6 Updating and Editing Content Stored in Oracle XML&nbsp;DB using Microsoft Word</p>
<img width="862" height="678" src="img/word_po_update.gif" alt="Description of Figure 3-6 follows" /><br />
<a id="sthref270" href="img_text/word_po_update.htm">Description of "Figure 3-6 Updating and Editing Content Stored in Oracle XML&nbsp;DB using Microsoft Word"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When an editing application such as Microsoft Word updates an XML document that is stored in Oracle XML&nbsp;DB, the database receives an input stream containing the new content of the document. Unfortunately, applications such as Word do not provide Oracle XML&nbsp;DB with any way of identifying which changes have taken place in the document.Partial updates are thus impossible. It is necessary to parse the entire document again, replacing all of the objects derived from the original document with objects derived from the new content.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4204" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref271"></a>
<h4 class="sect3">Updating Repository Content using SQL</h4>
<p>SQL functions such as <code>updateXML</code> can be used to update the content of any document stored in Oracle XML&nbsp;DB Repository. The content of the document can be modified by updating the resource document or by updating the default table that holds the content of the document.</p>
<p><a href="#BJFEDJDH">Example 3-57</a> shows how to update the contents of a simple text document using a SQL <code>UPDATE</code> statement and SQL function <code>updateXML</code> on the resource document. An XPath expression is passed to <code>updateXML</code> as the target of the update operation, identifying the text node belonging to element <code>/Resource/Contents/text</code>.</p>
<div id="ADXDB4205" class="example">
<p class="titleinexample"><a id="BJFEDJDH"></a>Example 3-57 Updating a Document using UPDATE and UPDATEXML on the Resource</p>
<pre>
DECLARE
  file         BFILE;
  contents     CLOB;
  dest_offset  NUMBER := 1;
  src_offset   NUMBER := 1;
  lang_context NUMBER := 0;
  conv_warning NUMBER := 0;
BEGIN
  file := bfilename('XMLDIR', 'tdadxdb-03-02.txt');
  DBMS_LOB.createTemporary(contents, true, DBMS_LOB.SESSION);
  DBMS_LOB.fileopen(file, DBMS_LOB.file_readonly);
  DBMS_LOB.loadClobfromFile(contents,
                            file,
                            DBMS_LOB.getLength(file),
                            dest_offset,
                            src_offset,
                            nls_charset_id('AL32UTF8'),
                            lang_context,
                            conv_warning);
  DBMS_LOB.fileclose(file);
  UPDATE RESOURCE_VIEW
    SET res = <span class="bold">updateXML</span>(res,
                        <span class="bold">'/Resource/Contents/text/text()'</span>,
                        contents,
                        'xmlns="http://xmlns.oracle.com/xdb/XDBResource.xsd"')
      WHERE equals_path(res, '/home/QUINE/NurseryRhyme.txt') = 1;
  DBMS_LOB.freeTemporary(contents);
END;
/
</pre></div>
<!-- class="example" -->
<p>This technique for updating the content of a document by updating the associated resource has the advantage that it can be used to update any kind of document stored in Oracle XML&nbsp;DB Repository.</p>
<p><a href="#BJFEFBEC">Example 3-58</a> shows how to update a node in an XML document by performing an update on the resource document. Here, SQL function <code>updateXML</code> changes the value of the text node associated with element <code>User</code>.</p>
<div id="ADXDB4206" class="example">
<p class="titleinexample"><a id="BJFEFBEC"></a>Example 3-58 Updating a Node using UPDATE and UPDATEXML</p>
<pre>
UPDATE RESOURCE_VIEW
  SET res = <span class="bold">updateXML</span>(res,
                      '/r:Resource/r:Contents/PurchaseOrder/<span class="bold">User/text()</span>',
                      'SKING',
                      'xmlns:r="http://xmlns.oracle.com/xdb/XDBResource.xsd"')
  WHERE equals_path(
          res,
          '/home/QUINE/PurchaseOrders/2002/Mar/SBELL-2002100912333601PDT.xml')
        = 1;
 
1 row updated.

SELECT XMLCast(XMLQuery(
                 'declare namespace ns="http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                  $r/ns:Resource/ns:Contents/PurchaseOrder/<span class="bold">User/text()</span>'
                 PASSING RES AS "r" RETURNING CONTENT)
               AS VARCHAR2(32))
  FROM RESOURCE_VIEW
  WHERE equals_path(RES,
                    '/home/QUINE/PurchaseOrders/2002/Mar/SBELL-2002100912333601PDT.xml')
        = 1;
 
XMLCAST(XMLQUERY('DECLARENAMESPA
--------------------------------
<span class="bold">SKING</span>

1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADXDB4207" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref272"></a>
<h4 class="sect3">Updating XML Schema-Based Documents in the Repository</h4>
<p>You can update XML schema-based XML documents by performing the update operation directly on the default table that is used to manage the content of the document. If the document must be located by a <code>WHERE</code> clause that includes a path or conditions based on metadata, then the <code>UPDATE</code> statement must use a join between the resource and the default table.</p>
<p>In general, when updating the contents of XML schema-based XML documents, joining the <code>RESOURCE_VIEW</code> or <code>PATH_VIEW</code> with the default table is more efficient than using the <code>RESOURCE_VIEW</code> or <code>PATH_VIEW</code> on its own. The explicit join between the resource document and the default table tells Oracle XML&nbsp;DB that the SQL statement works on only one type of XML document. This lets a partial update be used on the default table and resource.</p>
<p>In <a href="#BJFDCAEH">Example 3-59</a>, SQL function <code>updateXML</code> operates on the default table, with the target row identified by a path. The row to be updated is identified by a <code>REF</code>. The <code>REF</code> is identified by a repository path using SQL function <code>equals_path</code>. This limits the update to the row corresponding to the resource identified by the specified path.</p>
<div id="ADXDB4208" class="example">
<p class="titleinexample"><a id="BJFDCAEH"></a>Example 3-59 Updating XML Schema-Based Documents in the Repository</p>
<pre>
UPDATE purchaseorder p
  SET p.OBJECT_VALUE = <span class="bold">updateXML</span>(p.OBJECT_VALUE, '/PurchaseOrder/<span class="bold">User/text()</span>', '<span class="bold">SBELL</span>')
    WHERE <span class="bold">ref(p)</span> =
      (SELECT XMLCast(XMLQuery('declare default element namespace
                                "http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                                fn:data(/Resource/XMLRef)' PASSING rv.RES RETURNING CONTENT)
                      AS REF XMLType)
         FROM RESOURCE_VIEW rv
         WHERE <span class="bold">equals_path</span>(rv.RES,
                           '/home/QUINE/PurchaseOrders/2002/Mar/SBELL-2002100912333601PDT.xml')
               = 1);

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/<span class="bold">User/text()</span>'
                        PASSING p.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(32))
  FROM purchaseorder p, RESOURCE_VIEW rv
  WHERE ref(p) = XMLCast(XMLQuery('declare default element namespace
                                "http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                                fn:data(/Resource/XMLRef)' PASSING rv.RES RETURNING CONTENT)
                      AS REF XMLType)
    AND equals_path(rv.RES, '/home/QUINE/PurchaseOrders/2002/Mar/SBELL-2002100912333601PDT.xml')
        = 1;

XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
<span class="bold">SBELL</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4209" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref273"></a>
<h3 class="sect2">Controlling Access to Repository Data</h3>
<p>You can control access to the resources in Oracle XML&nbsp;DB Repository by using access control lists (ACLs). An ACL is a list of access control entries (ACEs), each of which grants or denies a set of privileges to a specific principal. The principal can be a database user, a database role, an LDAP user, an LDAP group or the special principal <code>DAV::owner</code>, which refers to the owner of the resource. Each resource in the repository is protected by an ACL. The ACL determines what privileges, such as <code>read-properties</code> and <code>update</code>, a user has on the resource. Each repository operation includes a check of the ACL to determine if the current user is allowed to perform the operation. By default, a new resource inherits the ACL of its parent folder. But you can set the ACL of a resource using PL/SQL procedure <code>DBMS_XDB.setACL</code>. For more details on Oracle XML&nbsp;DB resource security, see <a href="xdb21sec.htm#g1040139">Chapter 27, "Repository Access Control"</a>.</p>
<p>In the following example, the current user is <code>QUINE</code>. The query gives the number of resources in the folder <code>/public</code>. Assume that there are only two resources in this folder: <code>f1</code> and <code>f2</code>. Also assume that the ACL on <code>f1</code> grants the <code>read-properties</code> privilege to <code>QUINE</code> while the ACL on <code>f2</code> does not grant <code>QUINE</code> any privileges. A user needs the <code>read-properties</code> privilege on a resource for it to be visible to the user. The result of the query is <code>1</code>, because only <code>f1</code> is visible to <code>QUINE</code>.</p>
<pre>
SELECT count(*) FROM RESOURCE_VIEW r WHERE under_path(r.res, '/public') = 1;
 
COUNT(*)
--------
       1
</pre></div>
<!-- class="sect2" -->
<div id="ADXDB4210" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref274"></a>
<h3 class="sect2">Oracle XML&nbsp;DB Transactional Semantics</h3>
<p>When working from SQL, normal transactional behavior is enforced. Multiple calls to SQL functions such as <code>updateXML</code> can be used within a single logical unit of work. Changes made through functions like <code>updateXML</code> are not visible to other database users until the transaction is committed. At any point, <code>ROLLBACK</code> can be used to back out the set of changes made since the last commit.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHEIJE"></a>
<div id="ADXDB4211" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Querying Metadata and the Folder Hierarchy</h3>
<p>In Oracle XML&nbsp;DB, the system-defined metadata for each resource is preserved as an XML document. The structure of these resource documents is defined by XML schema <code>XDBResource.xsd</code>. This schema is registered as a global XML schema at URL <code>http://xmlns.oracle.com/xdb/XDBResource.xsd</code>.</p>
<p>Oracle XML&nbsp;DB gives you access to metadata and information about the folder hierarchy using two public views, <code>RESOURCE_VIEW</code> and <code>PATH_VIEW</code>.</p>
<div id="ADXDB4212" class="sect3"><a id="sthref275"></a>
<h4 class="sect3">RESOURCE_VIEW and PATH_VIEW</h4>
<p><code>RESOURCE_VIEW</code> contains one entry for each file or folder stored in Oracle XML&nbsp;DB Repository. Column <code>RES</code> of <code>RESOURCE_VIEW</code> contains the resource, an XML document that manages the metadata properties associated with the resource content. Column <code>ANY_PATH</code> contains a valid URL that the current user can pass to <code>XDBURIType</code> to access the resource content. If this content is not binary data, then the resource itself also contains the content.</p>
<p>Oracle XML&nbsp;DB supports the concept of <span class="glossaryterm"><a id="sthref276"></a>linking</span>. Linking makes it possible to define multiple paths to a given document. A separate XML document, called the <a id="sthref277"></a><span class="glossaryterm">link-properties document</span>, maintains metadata properties that are specific to the path, rather than to the resource. Whenever a resource is created, an initial link is also created.</p>
<p><code>PATH_VIEW</code> exposes the link-properties documents. There is one entry in <code>PATH_VIEW</code> for each possible path to a document. Column <code>RES</code> of <code>PATH_VIEW</code> contains the resource document pointed to by this link. Column <code>PATH</code> contains the path that the link lets you use to access the resource. Column <code>LINK</code> contains the link-properties document (metadata) for this <code>PATH</code>.</p>
<p><a href="#BABFBABB">Example 3-60</a> shows the description of public views <code>RESOURCE_VIEW</code> and <code>PATH_VIEW</code>:</p>
<div id="ADXDB4213" class="example">
<p class="titleinexample"><a id="BABFBABB"></a>Example 3-60 Viewing RESOURCE_VIEW and PATH_VIEW Structures</p>
<pre>
DESCRIBE RESOURCE_VIEW

Name      Null?    Type
-------------------------------------------------------------
RES                SYS.XMLTYPE(XMLSchema 
                               "http://xmlns.oracle.com/xdb/XDBResource.xsd" 
                               Element 
                               "Resource")
ANY_PATH           VARCHAR2(4000)
RESID              RAW(16)


DESCRIBE PATH_VIEW

Name      Null?    Type
-------------------------------------------------------------
PATH               VARCHAR2(1024)
RES                SYS.XMLTYPE(XMLSchema
                               "http://xmlns.oracle.com/xdb/XDBResource.xsd" 
                               Element 
                               "Resource")
LINK               SYS.XMLTYPE
RESID              RAW(16)
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb18res.htm#g1034945">Chapter 25, "Accessing the Repository using RESOURCE_VIEW and PATH_VIEW"</a></p>
</li>
<li>
<p><a class="olink REFRN29079" href="../../server.112/e40402/statviews_5151.htm#REFRN29079"><span class="italic">Oracle Database Reference</span></a> for more information about view <code>PATH_VIEW</code></p>
</li>
<li>
<p><a class="olink REFRN29080" href="../../server.112/e40402/statviews_5169.htm#REFRN29080"><span class="italic">Oracle Database Reference</span></a> for more information about view <code>RESOURCE_VIEW</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADXDB4214" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref278"></a>
<h4 class="sect3">Querying Resources in RESOURCE_VIEW and PATH_VIEW</h4>
<p>Oracle XML&nbsp;DB provides two SQL functions, <code>equals_path</code> and <code>under_path</code>, that can be used to perform <span class="glossaryterm"><a id="sthref279"></a>folder-restricted queries</span>. Such queries limit SQL statements that operate on the <code>RESOURCE_VIEW</code> or <code>PATH_VIEW</code> to documents that are at a particular location in Oracle XML&nbsp;DB folder hierarchy. Function <code>equals_path</code> restricts the statement to a single document identified by the specified path. Function <code>under_path</code> restricts the statement to those documents that exist beneath a certain point in the hierarchy.</p>
<p>The following examples demonstrate simple folder-restricted queries against resource documents stored in <code>RESOURCE_VIEW</code> and <code>PATH_VIEW</code>.</p>
<p>The query in <a href="#CHDHIAJB">Example 3-61</a> uses SQL function <code>equals_path</code> and <code>RESOURCE_VIEW</code> to access the resource created in <a href="#BABFBABB">Example 3-60</a>.</p>
<div id="ADXDB4215" class="example">
<p class="titleinexample"><a id="CHDHIAJB"></a>Example 3-61 Accessing Resources using EQUALS_PATH and RESOURCE_VIEW</p>
<pre>
SELECT XMLSerialize(DOCUMENT r.res AS CLOB)
  FROM RESOURCE_VIEW r
  WHERE equals_path(res, '/home/QUINE/NurseryRhyme.txt') = 1;
 
XMLSERIALIZE(DOCUMENTR.RESASCLOB)
--------------------------------------------------------------------------------
&lt;Resource xmlns="http://xmlns.oracle.com/xdb/XDBResource.xsd" 
          Hidden="false" 
          Invalid="false" 
          Container="false" 
          CustomRslv="false" 
          VersionHistory="false" 
          StickyRef="true"&gt;
  &lt;CreationDate&gt;2005-06-13T13:19:20.566623&lt;/CreationDate&gt;
  &lt;ModificationDate&gt;2005-06-13T13:19:22.997831&lt;/ModificationDate&gt;
  &lt;DisplayName&gt;NurseryRhyme.txt&lt;/DisplayName&gt;
  &lt;Language&gt;en-US&lt;/Language&gt;
  &lt;CharacterSet&gt;UTF-8&lt;/CharacterSet&gt;
  &lt;ContentType&gt;text/plain&lt;/ContentType&gt;
  &lt;RefCount&gt;1&lt;/RefCount&gt;
  &lt;ACL&gt;
    &lt;acl description=
         "Private:All privileges to OWNER only and not accessible to others"
         xmlns="http://xmlns.oracle.com/xdb/acl.xsd" xmlns:dav="DAV:"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
         xsi:schemaLocation="http://xmlns.oracle.com/xdb/acl.xsd
         http://xmlns.oracle.com/xdb/acl.xsd"
         shared="true"&gt;
      &lt;ace&gt;
        &lt;grant&gt;true&lt;/grant&gt;
        &lt;principal&gt;dav:owner&lt;/principal&gt;
        &lt;privilege&gt;
          &lt;all/&gt;
        &lt;/privilege&gt;
      &lt;/ace&gt;
    &lt;/acl&gt;
  &lt;/ACL&gt;
  &lt;Owner&gt;QUINE&lt;/Owner&gt;
  &lt;Creator&gt;QUINE&lt;/Creator&gt;
  &lt;LastModifier&gt;QUINE&lt;/LastModifier&gt;
  &lt;SchemaElement&gt;http://xmlns.oracle.com/xdb/XDBSchema.xsd#text&lt;/SchemaElement&gt;
  &lt;Contents&gt;
    &lt;text&gt;Hickory Dickory Dock
The Mouse ran up the clock
The clock struck one
The Mouse ran down
Hickory Dickory Dock
    &lt;/text&gt;
  &lt;/Contents&gt;
&lt;/Resource&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>As <a href="#CHDHIAJB">Example 3-61</a> shows, a resource document is an XML document that captures the set of metadata defined by the DAV standard. The metadata includes information such as <code>CreationDate</code>, <code>Creator</code>, <code>Owner</code>, <code>ModificationDate</code>, and <code>DisplayName</code>. The content of the resource document can be queried and updated just like any other XML document, using SQL/XML access and query functions.</p>
<p>The query in <a href="#BJFBCHAC">Example 3-62</a> finds a path to each of the XSL style sheets stored in Oracle XML&nbsp;DB Repository. It performs a search based on the <code>DisplayName</code> ending in <code>.xsl</code>.</p>
<div id="ADXDB4216" class="example">
<p class="titleinexample"><a id="BJFBCHAC"></a>Example 3-62 Determining the Path to XSL Style Sheets Stored in the Repository</p>
<pre>
SELECT ANY_PATH FROM RESOURCE_VIEW
  WHERE XMLCast(XMLQuery(
                  'declare namespace ns="http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                   $r/ns:Resource/ns:DisplayName'
                  PASSING RES AS "r" RETURNING CONTENT)
                AS VARCHAR2(100))
        LIKE '%.xsl';
 
ANY_PATH
-------------------------------------------
/source/schemas/poSource/xsl/empdept.xsl
/source/schemas/poSource/xsl/purchaseOrder.xsl
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BJFGFGHC">Example 3-63</a> counts the number of resources (files and folders) under the path <code>/home/QUINE/PurchaseOrders</code>. Using <code>RESOURCE_VIEW</code> rather than <code>PATH_VIEW</code> ensures that any resources that are the target of multiple links are only counted once. SQL function <code>under_path</code> restricts the result set to documents that can be accessed using a path that starts from <code>/home/QUINE/PurchaseOrders</code>.</p>
<div id="ADXDB4217" class="example">
<p class="titleinexample"><a id="BJFGFGHC"></a>Example 3-63 Counting Resources Under a Path</p>
<pre>
SELECT count(*)
   FROM RESOURCE_VIEW
   WHERE under_path(RES, '/home/QUINE/PurchaseOrders') = 1;
 
  COUNT(*)
----------
       145

1 row selected.
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BJFFIEGC">Example 3-64</a> lists the contents of the folder identified by path <code>/home/QUINE/PurchaseOrders/2002/Apr</code>. This is effectively a directory listing of the folder.</p>
<div id="ADXDB4218" class="example">
<p class="titleinexample"><a id="BJFFIEGC"></a>Example 3-64 Listing the Folder Contents in a Path</p>
<pre>
SELECT PATH
  FROM PATH_VIEW
  WHERE under_path(RES, '/home/QUINE/PurchaseOrders/2002/Apr') = 1;
 
PATH
----------------------------------------------------------------------
/home/QUINE/PurchaseOrders/2002/Apr/AMCEWEN-20021009123336171PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/AMCEWEN-20021009123336271PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/EABEL-20021009123336251PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/PTUCKER-20021009123336191PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/PTUCKER-20021009123336291PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SBELL-20021009123336231PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SBELL-20021009123336331PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SKING-20021009123336321PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SMCCAIN-20021009123336151PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SMCCAIN-20021009123336341PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/VJONES-20021009123336301PDT.xml
 
11 rows selected.
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BJFEJJHH">Example 3-65</a> lists the set of links contained in the folder identified by the path <code>/home/QUINE/PurchaseOrders/2002/Apr</code> where the <code>DisplayName</code> element in the associated resource starts with <code>S</code>.</p>
<div id="ADXDB4219" class="example">
<p class="titleinexample"><a id="BJFEJJHH"></a>Example 3-65 Listing the Links Contained in a Folder</p>
<pre>
SELECT PATH
  FROM PATH_VIEW
  WHERE XMLCast(XMLQuery(
                  'declare namespace ns="http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                   $r/ns:Resource/ns:DisplayName'
                  PASSING RES AS "r" RETURNING CONTENT)
                AS VARCHAR2(100))
        LIKE 'S%'
    AND under_path(RES, '/home/QUINE/PurchaseOrders/2002/Apr') = 1;
 
PATH
----------------------------------------------------------------------
/home/QUINE/PurchaseOrders/2002/Apr/SBELL-20021009123336231PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SBELL-20021009123336331PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SKING-20021009123336321PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SMCCAIN-20021009123336151PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/SMCCAIN-20021009123336341PDT.xml
 
5 rows selected.
</pre></div>
<!-- class="example" -->
<p>The query in <a href="#BJFEFHEJ">Example 3-66</a> finds a path to each resource in Oracle XML&nbsp;DB Repository that contains a <code>PurchaseOrder</code> document. The documents are identified based on the metadata property <code>SchemaElement</code> that identifies the XML schema URL and global element for schema-based XML data stored in the repository.</p>
<div id="ADXDB4220" class="example">
<p class="titleinexample"><a id="BJFEFHEJ"></a>Example 3-66 Finding Paths to Resources that Contain Purchase-Order XML Documents</p>
<pre>
SELECT ANY_PATH
  FROM RESOURCE_VIEW
 WHERE XMLExists(
         'declare namespace ns="http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
          $r/ns:Resource[ns:SchemaElement=
          "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd#PurchaseOrder"]'
         PASSING RES AS "r");
</pre>
<p>The query returns the following paths, each of which contains a <code>PurchaseOrder</code> document:</p>
<pre>
ANY_PATH
-----------------------------------------------------------------------
/home/QUINE/PurchaseOrders/2002/Apr/AMCEWEN-20021009123336171PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/AMCEWEN-20021009123336271PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/EABEL-20021009123336251PDT.xml
/home/QUINE/PurchaseOrders/2002/Apr/PTUCKER-20021009123336191PDT.xml

<span class="bold">...</span>

132 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4221" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref280"></a>
<h3 class="sect2">Oracle XML&nbsp;DB Hierarchical Repository Index</h3>
<p>In a conventional relational database, path-based access and folder-restricted queries are implemented using <code>CONNECT BY</code> operations. Such queries are expensive, so path-based access and folder-restricted queries would become inefficient as the number of documents and depth of the folder hierarchy increase.</p>
<p>To address this issue, Oracle XML&nbsp;DB introduces a new index type, the <span class="glossaryterm"><a id="sthref281"></a><a id="sthref282"></a><a id="sthref283"></a>hierarchical repository index</span>. This lets the database resolve folder-restricted queries without relying on a <code>CONNECT BY</code> operation. Because of this, Oracle XML&nbsp;DB can execute path-based and folder-restricted queries efficiently. The hierarchical repository index is implemented as an Oracle domain index. This is the same technique used to add Oracle Text indexing support and many other advanced index types to the database.</p>
<p><a href="#BJFBDFAI">Example 3-67</a> shows the execution plan output generated for a folder-restricted query. As shown, the hierarchical repository index <code>XDBHI_IDX</code> is used to resolve the query.</p>
<div id="ADXDB4222" class="example">
<p class="titleinexample"><a id="BJFBDFAI"></a>Example 3-67 Execution Plan Output for a Folder-Restricted Query</p>
<pre>
SELECT PATH
  FROM PATH_VIEW
  WHERE XMLCast(
          XMLQuery(
            'declare namespace ns="http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
             $r/ns:Resource/ns:DisplayName'
            PASSING RES AS "r" RETURNING CONTENT)
          AS VARCHAR2(100))
        LIKE 'S%'
    AND under_path(RES, '/home/QUINE/PurchaseOrders/2002/Apr') = 1;
 
PLAN_TABLE_OUTPUT
------------------------------------------------------------------------------------------------------
Plan hash value: 2568289845
 
------------------------------------------------------------------------------------------------------
| Id  | Operation                            | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                     |               |    17 |  3111 |    34   (6)| 00:00:01 |
|   1 |  NESTED LOOPS                        |               |    17 |  3111 |    34   (6)| 00:00:01 |
|   2 |   NESTED LOOPS                       |               |    17 |  2822 |    34   (6)| 00:00:01 |
|   3 |    NESTED LOOPS                      |               |   466 | 63842 |    34   (6)| 00:00:01 |
|*  4 |     TABLE ACCESS BY INDEX ROWID      | XDB$RESOURCE  |     1 |   135 |     3   (0)| 00:00:01 |
|*  5 |      DOMAIN INDEX                    | <span class="bold">XDBHI_IDX</span>     |       |       |            |          |
|   6 |     COLLECTION ITERATOR PICKLER FETCH|               |       |       |            |          |
|*  7 |    INDEX UNIQUE SCAN                 | XDB_PK_H_LINK |     1 |    28 |     0   (0)| 00:00:01 |
|*  8 |   INDEX UNIQUE SCAN                  | SYS_C003900   |     1 |    17 |     0   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - filter(CAST("P"."SYS_NC00011$" AS VARCHAR2(100)) LIKE 'S%')
   5 - access("XDB"."UNDER_PATH"(SYS_MAKEXML('8758D485E6004793E034080020B242C6',734,"XMLEXTRA"
              ,"XMLDATA"),'/home/QUINE/PurchaseOrders/2002/Apr',9999)=1)
   7 - access("H"."PARENT_OID"=SYS_OP_ATG(VALUE(KOKBF$),3,4,2) AND
              "H"."NAME"=SYS_OP_ATG(VALUE(KOKBF$),2,3,2))
   8 - access("R2"."SYS_NC_OID$"=SYS_OP_ATG(VALUE(KOKBF$),3,4,2))
 
25 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDDIFHI"></a>
<div id="ADXDB4223" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">How Documents are Stored in the Repository</h3>
<p>Oracle XML&nbsp;DB provides special handling for XML documents. The rules for storing the contents of schema-based XML document are defined by the XML schema. The content of the document is stored in the default table associated with the global element definition.</p>
<p>Oracle XML&nbsp;DB Repository also stores files that do not contain XML data, such as JPEG images or Word documents. The XML schema for each resource defines which elements are allowed, and specifies whether the content of these files is to be stored as <code>BLOB</code> or <code>CLOB</code> instances. The content of a non-schema-based XML document is stored as a <code>CLOB</code> instance in the repository.</p>
<p>There is one resource and one link-properties document for each file or folder in the repository. If there are multiple access paths to a given document, there is a link-properties document for each possible link. Both the resource document and the link-properties are stored as XML documents. All these documents are stored in tables in the repository.</p>
<p>When an XML file is loaded into the repository, the following sequence of events takes place:</p>
<ol>
<li>
<p>Oracle XML&nbsp;DB examines the root element of the XML document to see if it is associated with a known (registered) XML schema. This involves looking to see if the document includes a namespace declaration for the <code>XMLSchema-instance</code> namespace, and then looking for a <code>schemaLocation</code> or <code>noNamespaceSchemaLocation</code> attribute that identifies which XML schema the document is associated with.</p>
</li>
<li>
<p>If the document is based on a known XML schema, then the metadata for the XML schema is loaded from the XML schema cache.</p>
</li>
<li>
<p>The XML document is parsed and decomposed into a set of SQL objects derived from the XML schema.</p>
</li>
<li>
<p>The SQL objects created from the XML file are stored in the default table defined when the XML schema was registered with the database.</p>
</li>
<li>
<p>A resource document is created for each document processed. This lets the content of the document be accessed using the repository. The resource document for an XML schema-based <code>XMLType</code> instance includes an <code>XMLRef</code> element. This element contains a <code>REF</code> of <code>XMLType</code> that can be used to locate the row in the default table containing the content associated with the resource.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCEEHI"></a>
<div id="ADXDB4224" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Viewing Relational Data as XML From a Browser</h2>
<p>The HTTP server built into Oracle XML&nbsp;DB makes it possible to use a browser to access any document stored in Oracle XML&nbsp;DB Repository. Since a resource can include a <code>REF</code> to a row in an <code>XMLType</code> table or view, it is possible to use a path to access this type of content.</p>
<a id="BABHBIJE"></a>
<div id="ADXDB4225" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Accessing a Table or View from a Browser using DBUri SERVLET</h3>
<p>Oracle XML&nbsp;DB includes the DBUri servlet, which makes it possible to access the content of any table or view directly from a browser. DBUri servlet uses the facilities of the <code>DBURIType</code> to generate a simple XML document from the contents of the table. The servlet is C language-based and installed in the Oracle XML&nbsp;DB HTTP server. By default, the servlet is installed under the virtual directory <code>/oradb</code>.</p>
<p>The URL passed to the <code>DBUri</code> Servlet is an extension of the URL passed to the <code>DBURIType</code>. The URL is extended with the address and port number of the Oracle XML&nbsp;DB HTTP server and the virtual root that directs HTTP(S) requests to the <code>DBUri</code> servlet. The default configuration for this is <code>/oradb</code>.</p>
<p>The URL <code>http://localhost:8080/oradb/HR/DEPARTMENTS</code> would thus return an XML document containing the contents of the <code>DEPARTMENTS</code> table in the <code>HR</code> database schema. This assumes that the Oracle XML&nbsp;DB HTTP server is running on port 8080, the virtual root for the DBUri servlet is <code>/oradb</code>, and that the user making the request has access to the <code>HR</code> database schema.</p>
<p><code>DBUri</code> servlet accepts parameters that allow you to specify the name of the <code>ROW</code> tag and MIME-type of the document that is returned to the client.</p>
<p>Content in <code>XMLType</code> table or view can also be accessed through the DBUri servlet. When the URL passed to the DBUri servlet references an <code>XMLType</code> table or <code>XMLType</code> view the URL can be extended with an XPath expression that can determine which documents in the table or row are returned. The XPath expression appended to the URL can reference any node in the document.</p>
<p>XML generated by DBUri servlet can be transformed using the XSLT processor built into Oracle XML&nbsp;DB. This lets XML that is generated by DBUri servlet be presented in a more legible format such as HTML.</p>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1031">
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028">
<p class="notep1">See Also:</p>
<a href="xdb15dbu.htm#i1025534">"DBUriServlet"</a></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<p><a id="sthref284"></a>Style sheet processing is initiated by specifying a transform parameter as part of the URL passed to DBUri servlet. The style sheet is specified using a URI that references the location of the style sheet within database. The URI can either be a <code>DBURIType</code> value that identifies a <code>XMLType</code> column in a table or view, or a path to a document stored in Oracle XML&nbsp;DB Repository. The style sheet is applied directly to the generated XML before it is returned to the client. When using DBUri servlet for XSLT processing, it is good practice to use the <code>contenttype</code> parameter to explicitly specify the MIME type of the generated output.</p>
<p>If the XML document being transformed is stored as an XML schema-based <code>XMLType</code> instance, then Oracle XML&nbsp;DB can reduce the overhead associated with XSL transformation by leveraging the capabilities of the lazily loaded virtual DOM.</p>
<p>The root of the URL is <code>/oradb</code>, so the URL is passed to the DBUri servlet that accesses the <code>purchaseorder</code> table in the <code>SCOTT</code> database schema, rather than as a resource in Oracle XML&nbsp;DB Repository. The URL includes an XPath expression that restricts the result set to those documents where node <code>/PurchaseOrder/Reference/text()</code> contains the value specified in the predicate. The <code>contenttype</code> parameter sets the MIME type of the generated document to <code>text/xml</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCBECF"></a>
<div id="ADXDB4226" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">XSL Transformation using <a id="sthref285"></a>DBUri Servlet</h2>
<p><a href="#BABJGIGH">Figure 3-7</a> shows how an XSL transformation can be applied to XML content generated by the DBUri servlet. In this example the URL passed to the DBUri includes the transform parameter. This causes the DBUri servlet to use Oracle SQL function <code>XMLtransform</code> to apply the style sheet <code>/home/SCOTT/xsl/purchaseOrder.xsl</code> to the <code>PurchaseOrder</code> document identified by the main URL, before returning the document to the browser. This style sheet transforms the XML document to a more user-friendly HTML page. The URL also uses <code>contentType</code> parameter to specify that the MIME-type of the final document is <code>text/html</code>.</p>
<div id="ADXDB4227" class="figure">
<p class="titleinfigure"><a id="BABJGIGH"></a>Figure 3-7 Database XSL Transformation of a PurchaseOrder using DBUri Servlet</p>
<img width="1024" height="768" src="img/xslt_po.gif" alt="Description of Figure 3-7 follows" /><br />
<a id="sthref286" href="img_text/xslt_po.htm">Description of "Figure 3-7 Database XSL Transformation of a PurchaseOrder using DBUri Servlet"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#CEGGCDJE">Figure 3-8</a> shows the <code>departments</code> table displayed as an HTML document. You need no code to achieve this, you only need an <code>XMLType</code> view, based on SQL/XML functions, an industry-standard XSL style sheet, and <code>DBUri</code> servlet.</p>
<div id="ADXDB4228" class="figure">
<p class="titleinfigure"><a id="CEGGCDJE"></a>Figure 3-8 Database XSL Transformation of Departments Table using DBUri Servlet</p>
<img width="892" height="632" src="img/dburi_emp.gif" alt="Description of Figure 3-8 follows" /><br />
<a id="sthref287" href="img_text/dburi_emp.htm">Description of "Figure 3-8 Database XSL Transformation of Departments Table using DBUri Servlet"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;The <code>XMLType</code> storage model for XML schema-based data is whatever was specified during registration of the referenced XML schema. If no storage model was specified during registration, then binary XML storage is used.<br />
Footnote&nbsp;2:&nbsp;If you use XML schema annotation <code>maintainOrder = "false"</code>, then an unordered collection is used instead of an ordered collection. Oracle recommends that you use ordered collections (<code>maintainOrder = "true"</code>) for XML data, to preserve document order. By default, attribute <code>maintainOrder</code> is <code>true</code>.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="xdb02rep.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="partpg2.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
