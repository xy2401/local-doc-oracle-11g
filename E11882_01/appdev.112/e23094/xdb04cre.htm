<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>XMLType Operations</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:12Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="partpg2.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb_xquery.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/54</span> <!-- End Header -->
<div id="ADXDB0400" class="chapter"><a id="g1050045"></a>
<h1 class="chapter"><span class="secnum">4</span> XMLType Operations</h1>
<p>This chapter describes <code>XMLType</code> operations for XML applications (XML schema-based and non-schema-based). It includes guidelines for creating, manipulating, updating, and querying <code>XMLType</code> columns and tables.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1024803">Selecting and Querying XML Data</a></p>
</li>
<li>
<p><a href="#i1032611">Updating XML Data</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb03usg.htm#g1055369">Chapter 3, "Using Oracle XML&nbsp;DB"</a> for <code>XMLType</code> storage recommendations</p>
</li>
<li>
<p><a href="xdb05sto.htm#g1070409">Chapter 7, "XML Schema Storage and Query: Basic"</a> for how to work with XML schema-based <code>XMLType</code> tables and columns</p>
</li>
</ul>
</div>
<a id="i1024803"></a>
<div id="ADXDB4230" class="sect1">
<h2 class="sect1">Selecting and Querying <a id="sthref288"></a><a id="sthref289"></a>XML Data</h2>
<p>You can query XML data from <code>XMLType</code> columns in the following ways:</p>
<ul>
<li>
<p>Select <code>XMLType</code> columns using SQL, PL/SQL, or Java.</p>
</li>
<li>
<p>Use the XQuery language. See <a href="xdb_xquery.htm#CBAIFJJJ">"Using XQuery with XMLType Data"</a>.</p>
</li>
<li>
<p>Query <code>XMLType</code> columns directly or using SQL/XML functions such as <code>XMLQuery</code>.</p>
</li>
<li>
<p>Use Oracle Text operators for full-text search. See <a href="xdb_indexing.htm#CHDEADIH">Chapter 6, "Indexing XMLType Data"</a> and <a href="xdb09sea.htm#i1006756">Chapter 12, "Full-Text Search Over XML Data"</a>.</p>
</li>
</ul>
<div id="ADXDB4232" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref290"></a>
<h3 class="sect2">Searching XML Documents using XPath Expressions</h3>
<p>The XPath language is a W3C Recommendation for navigating XML documents. It is a subset of the XQuery language, in the sense that an XPath expression is also an XQuery expression.</p>
<p>XPath models an XML document as a tree of nodes. It provides a rich set of operations that walk this tree and apply predicates and node-test functions. Applying an XPath expression to an XML document can result in a set of nodes. For example, the expression <code>/PO/PONO</code> selects all <code>PONO</code> child elements under the <code>PO</code> root element of the document.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle SQL functions and <code>XMLType</code> methods respect the W3C XPath recommendation, which states that if an XPath expression targets <span class="italic">no nodes</span> when applied to XML data, then an empty sequence must be returned. An error must <span class="italic">not</span> be raised in this case.
<p>The specific semantics of an Oracle SQL function or <code>XMLType</code> method that applies an XPath expression to XML data determines what is returned. For example, SQL/XML function <code>XMLQuery</code> returns <code>NULL</code> if its XPath-expression argument targets no nodes, and the updating SQL functions, such as <code>deleteXML</code>, return the input XML data unchanged. An error is never raised if no nodes are targeted, but updating SQL functions can raise an error if an XPath-expression argument targets inappropriate nodes, such as attribute nodes or text nodes.</p>
</div>
<p><a href="#CFHFHBIJ">Table 4-1</a> lists some common constructs used in XPath.</p>
<div id="ADXDB5805" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref291"></a><a id="CFHFHBIJ"></a>Table 4-1 <a id="sthref292"></a>Common XPath Constructs</p>
<table class="cellalignment1032" title="Common XPath Constructs" summary="This table describes five common XPath constructs." dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t4">XPath Construct</th>
<th class="cellalignment1027" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t4" headers="r1c1-t4">
<p><code>/</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t4 r1c2-t4">
<p>Denotes the root of the tree in an XPath expression. For example, <code>/PO</code> refers to the child of the root node whose name is <code>PO</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t4" headers="r1c1-t4">
<p><code>/</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t4 r1c2-t4">
<p>Also used as a path separator to identify the children node of any given node. For example, <code>/PurchaseOrder/Reference</code> identifies the purchase-order name element <code>Reference</code>, a child of the root element.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t4" headers="r1c1-t4">
<p><code>//</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t4 r1c2-t4">
<p>Used to identify all descendants of the current node. For example, <code>PurchaseOrder//ShippingInstructions</code> matches any <code>ShippingInstructions</code> element under the <code>PurchaseOrder</code> element.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t4" headers="r1c1-t4">
<p><code>*</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t4 r1c2-t4">
<p>Used as a wildcard to match any child node. For example, <code>/PO/*/STREET</code> matches any street element that is a grandchild of the <code>PO</code> element.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t4" headers="r1c1-t4">
<p><code>[ ]</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t4 r1c2-t4">
<p>Used to denote predicate expressions. XPath supports a rich list of binary operators such as <code>or</code>, <code>and</code>, and <code>not</code>. For example, <code>/PO[PONO = 20 and PNAME = "PO_2"]/SHIPADDR</code> selects the shipping address element of all purchase orders whose purchase-order number is <code>20</code> and whose purchase-order name is <code>PO_2</code>.</p>
<p>Brackets are also used to denote a position (index). For example, <code>/PO/PONO[2]</code> identifies the second purchase-order number element under the <code>PO</code> root element.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t4" headers="r1c1-t4">
<p>Functions</p>
</td>
<td class="cellalignment1028" headers="r7c1-t4 r1c2-t4">
<p>XPath and XQuery support a set of built-in functions such as <code>substring</code>, <code>round</code>, and <code>not</code>. In addition, these languages provide for extension functions through the use of namespaces. Oracle XQuery extension functions use the namespace prefix <code>ora</code>, for namespace <code>http://xmlns.oracle.com/xdb</code>. See <a href="xdb_xquery.htm#CBAJFJBH">"Oracle XQuery Extension Functions"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>The XPath must identify a single node, or a set of element, text, or attribute nodes. The result of the XPath cannot be a Boolean expression.</p>
<p>You can select <code>XMLType</code> data using PL/SQL, C, or Java. You can also use <code>XMLType</code> method <code><a id="sthref293"></a><a id="sthref294"></a><a id="sthref295"></a>getNumberVal()</code> to retrieve XML data as a <code>NUMBER</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i1024833"></a>
<div id="ADXDB4237" class="sect2">
<h3 class="sect2">Querying XMLType Data using SQL/XML Functions <a id="sthref296"></a>XMLExists and XMLCast</h3>
<p>You can query <code>XMLType</code> data and extract portions of it using SQL/XML standard functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>.</p>
<p>See <a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a> for more information about functions <code>XMLQuery</code> and <code>XMLTable</code>. Functions <code>XMLExists</code> and <code>XMLCast</code> are described in this section.</p>
<a id="CHDDDDAA"></a>
<div id="ADXDB4238" class="sect3">
<h4 class="sect3">XMLEXISTS <a id="sthref297"></a><a id="sthref298"></a>SQL/XML Function</h4>
<p><a href="#CFHIBEGB">Figure 4-1</a> describes the syntax for SQL/XML standard function <code>XMLExists</code>. This function checks whether a given XQuery expression returns a non-empty XQuery sequence. If so, the function returns <code>TRUE</code>. Otherwise, it returns <code>FALSE</code>.</p>
<div id="ADXDB4239" class="figure">
<p class="titleinfigure"><a id="CFHIBEGB"></a>Figure 4-1 XMLExists Syntax</p>
<img width="447" height="46" src="img/xmlexists.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref299" href="img_text/xmlexists.htm">Description of "Figure 4-1 XMLExists Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="subhead2"><a id="ADXDB4240"></a><span class="italic">XML_passing_clause ::=</span></p>
<img width="484" height="79" src="img/xml_passing_clause.gif" alt="Description of xml_passing_clause.gif follows" /><br />
<a id="sthref300" href="img_text/xml_passing_clause.htm">Description of the illustration xml_passing_clause.gif</a><br />
<br />
<ul>
<li>
<p><code><span class="codeinlineitalic">XQuery_string</span></code> is a complete XQuery expression, possibly including a prolog, as a literal string. It can contain XQuery variables that you bind using the XQuery <code>PASSING</code> clause (<code><span class="codeinlineitalic">XML_passing_clause</span></code> in the syntax diagram). The predefined namespace prefixes recognized for SQL/XML function <code>XMLQuery</code> are also recognized in <code><span class="codeinlineitalic">XQuery_string</span></code>&thinsp;&mdash;&thinsp;see <a href="xdb_xquery.htm#CBAJBDFA">"Predefined Namespaces and Prefixes"</a>.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">XML_passing_clause</span></code> is the keyword <code>PASSING</code> followed by one or more SQL expressions (<code><span class="codeinlineitalic">expr</span></code>) that each return an <code>XMLType</code> instance or an instance of a SQL scalar data type. All but possibly one of the expressions must each be followed by the keyword <code>AS</code> and an XQuery <code><span class="codeinlineitalic">identifier</span></code>. The result of evaluating each <code><span class="codeinlineitalic">expr</span></code> is bound to the corresponding <code><span class="codeinlineitalic">identifier</span></code> for the evaluation of <code><span class="codeinlineitalic">XQuery_string</span></code>. If there is an <code><span class="codeinlineitalic">expr</span></code> that is not followed by an <code>AS</code> clause, then the result of evaluating that <code><span class="codeinlineitalic">expr</span></code> is used as the <span class="italic">context</span> item for evaluating <code><span class="codeinlineitalic">XQuery_string</span></code>. Oracle XML&nbsp;DB supports only passing <code>BY VALUE</code>, not passing <code>BY REFERENCE</code>, so the clause <code>BY VALUE</code> is implicit and can be omitted.</p>
</li>
</ul>
<p>If an XQuery expression such as <code>/PurchaseOrder/Reference</code> or <code>/PurchaseOrder/Reference/text()</code> targets a single node, then <code>XMLExists</code> returns <code>true</code> for that expression. If <code>XMLExists</code> is called with an XQuery expression that locates no nodes, then <code>XMLExists</code> returns <code>false</code>.</p>
<p>Function <code>XMLExists</code> can be used in queries, and it can be used to create function-based indexes to speed up evaluation of queries.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle XML&nbsp;DB limits the use of <code>XMLExists</code> to a SQL <code>WHERE</code> clause or <code>CASE</code> expression. If you need to use <code>XMLExists</code> in a <code>SELECT</code> list, then wrap it in a <code>CASE</code> expression:
<pre>
CASE WHEN XMLExists(...) THEN 'TRUE' ELSE 'FALSE' END
</pre></div>
<p><a href="#CHDIJGAB">Example 4-1</a> uses SQL/XML standard function <code>XMLExists</code> to select rows with <code>SpecialInstructions</code> set to <code>Expedite</code>.</p>
<div id="ADXDB4241" class="example">
<p class="titleinexample"><a id="CHDIJGAB"></a>Example 4-1 Finding a Node using SQL/XML Function XMLExists</p>
<pre>
SELECT OBJECT_VALUE
  FROM purchaseorder
  WHERE XMLExists('/PurchaseOrder[SpecialInstructions="Expedite"]'
                  PASSING OBJECT_VALUE);
 
OBJECT_VALUE
--------------------------------------------------------------------
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 
13 rows selected.
</pre></div>
<!-- class="example" -->
<p>You can create function-based indexes using SQL/XML function <code>XMLExists</code> to speed up the execution. You can also create an <code>XMLIndex</code> index to help speed up arbitrary XQuery searching.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL function <code>existsNode</code> to do some of what can be done better using SQL/XML function <code>XMLExists</code>. Function <code>existsNode</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2. The two functions differ in these important ways:
<ul>
<li>
<p>Function <code>existsNode</code> returns <code>0</code> or <code>1</code>. Function <code>XMLExists</code> returns a Boolean value, <code>TRUE</code> or <code>FALSE</code>.</p>
</li>
<li>
<p>You can use <code>existsNode</code> in a query <code>SELECT</code> list. You cannot use <code>XMLExists</code> directly in a <code>SELECT</code> list, but you can use <code>XMLExists</code> within a <code>CASE</code> expression in a <code>SELECT</code> list.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_indexing.htm#CHDCIEJB">"Indexing XMLType Data Stored Object-Relationally"</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#CHDFCGGI">"XMLIndex"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDBIIJG"></a>
<div id="ADXDB4249" class="sect3">
<h4 class="sect3">XMLCAST <a id="sthref301"></a><a id="sthref302"></a>SQL/XML Function</h4>
<p><a href="#CFHFDHHJ">Figure 4-2</a> describes the syntax for SQL/XML standard function <code>XMLCast</code>.</p>
<div id="ADXDB4250" class="figure">
<p class="titleinfigure"><a id="CFHFDHHJ"></a>Figure 4-2 XMLCast Syntax</p>
<img width="383" height="27" src="img/xmlcast.gif" alt="Description of Figure 4-2 follows" /><br />
<a id="sthref303" href="img_text/xmlcast.htm">Description of "Figure 4-2 XMLCast Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>SQL/XML standard function <code>XMLCast</code> casts its first argument to the scalar SQL data type specified by its second argument. The first argument is a SQL expression that is evaluated. Any of the following SQL data types can be used as the second argument:</p>
<ul>
<li>
<p><code>NUMBER</code></p>
</li>
<li>
<p><code>VARCHAR2</code></p>
</li>
<li>
<p><code>CHAR</code></p>
</li>
<li>
<p><code>CLOB</code></p>
</li>
<li>
<p><code>BLOB</code></p>
</li>
<li>
<p><code>REF XMLTYPE</code></p>
</li>
<li>
<p>any SQL date or time data type</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Unlike the SQL/XML standard, Oracle XML&nbsp;DB limits the use of <code>XMLCast</code> to cast XML to a SQL scalar data type. Oracle XML&nbsp;DB does not support casting XML to XML or from a scalar SQL type to XML.</div>
<p>The result of evaluating the first <code>XMLCast</code> argument is an XML value. It is converted to the target SQL data type by using the XQuery atomization process and then casting the XQuery atomic values to the target data type. If this conversion fails, then an error is raised. If conversion succeeds, the result returned is an instance of the target data type.</p>
<p>The query in <a href="#CHDGFGBA">Example 4-2</a> extracts the scalar value of node <code>Reference</code>.</p>
<div id="ADXDB4251" class="example">
<p class="titleinexample"><a id="CHDGFGBA"></a>Example 4-2 Extracting the Scalar Value of an XML Fragment using XMLCAST</p>
<pre>
SELECT XMLCast(XMLQuery('/PurchaseOrder/Reference' PASSING OBJECT_VALUE
                                                   RETURNING CONTENT)
               AS VARCHAR2(100)) "REFERENCE"
  FROM purchaseorder
  WHERE XMLExists('/PurchaseOrder[SpecialInstructions="Expedite"]'
                  PASSING OBJECT_VALUE);
 
REFERENCE
----------------------------
AMCEWEN-20021009123336271PDT
SKING-20021009123336321PDT
AWALSH-20021009123337303PDT
JCHEN-20021009123337123PDT
AWALSH-20021009123336642PDT
SKING-20021009123336622PDT
SKING-20021009123336822PDT
AWALSH-20021009123336101PDT
WSMITH-20021009123336412PDT
AWALSH-20021009123337954PDT
SKING-20021009123338294PDT
WSMITH-20021009123338154PDT
TFOX-20021009123337463PDT
 
13 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL function <code>extractValue</code> to do some of what can be done better using SQL/XML functions <code>XMLQuery</code> and <code>XMLCast</code>. Function <code>extractValue</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2.</p>
</li>
<li>
<p>Function <code>extractValue</code> raises an error when its XPath expression argument matches multiple text nodes. <code>XMLCast</code> applied to an <code>XMLQuery</code> result returns the concatenation of the text nodes&thinsp;&mdash;&thinsp;it does <span class="italic">not</span> raise an error.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_indexing.htm#CHDCIEJB">"Indexing XMLType Data Stored Object-Relationally"</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#CHDFCGGI">"XMLIndex"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4259" class="sect2"><a id="sthref304"></a>
<h3 class="sect2">Examples of Querying XML Data using SQL/XML Functions</h3>
<p>The examples in this section illustrate ways you can use SQL to query XML data. <a href="#i1024901">Example 4-3</a> inserts two rows into table <code>purchaseorder</code>, then queries data in those rows using SQL/XML functions <code>XMLCast</code>, <code>XMLQuery</code>, and <code>XMLExists</code>.</p>
<div id="ADXDB4260" class="example">
<p class="titleinexample"><a id="i1024901"></a>Example 4-3 Querying XMLTYPE Data</p>
<pre>
INSERT INTO purchaseorder 
  VALUES (XMLType(bfilename('XMLDIR', 'SMCCAIN-2002091213000000PDT.xml'),
                  nls_charset_id('AL32UTF8')));
 
INSERT INTO purchaseorder
  VALUES (XMLType(bfilename('XMLDIR', 'VJONES-20020916140000000PDT.xml'),
                  nls_charset_id('AL32UTF8')));
 
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) reference,
       XMLCast(XMLQuery('$p/PurchaseOrder/*//User'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) userid,
       CASE
         WHEN XMLExists('$p/PurchaseOrder/Reject/Date'
                        PASSING po.OBJECT_VALUE AS "p")
           THEN 'Rejected'
           ELSE 'Accepted'
       END "STATUS",
       XMLCast(XMLQuery('$p//Date'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(12)) status_date
  FROM purchaseorder po
  WHERE XMLExists('$p//Date' PASSING po.OBJECT_VALUE AS "p")
  ORDER BY XMLCast(XMLQuery('$p//Date' PASSING po.OBJECT_VALUE AS "p"
                                       RETURNING CONTENT)
                   AS VARCHAR2(12));
 
REFERENCE                        USERID   STATUS   STATUS_DATE
-------------------------------- -------- -------- ------------
VJONES-20020916140000000PDT      SVOLLMAN Accepted 2002-10-11
SMCCAIN-2002091213000000PDT      SKING    Rejected 2002-10-12
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHDBHJFD">Example 4-4</a> uses a PL/SQL cursor to query XML data. It uses a local <code>XMLType</code> instance to store transient data.</p>
<div id="ADXDB4261" class="example">
<p class="titleinexample"><a id="CHDBHJFD"></a>Example 4-4 <a id="sthref305"></a> <a id="sthref306"></a><a id="sthref307"></a>Querying Transient XMLTYPE Data using a PL/SQL Cursor</p>
<pre>
DECLARE
  xNode      XMLType;
  vText      VARCHAR2(256);
  vReference VARCHAR2(32);
  CURSOR getPurchaseOrder(reference IN VARCHAR2) IS
           SELECT OBJECT_VALUE XML
             FROM purchaseorder
             WHERE XMLExists('$p/PurchaseOrder[Reference=$r]'
                             PASSING OBJECT_VALUE AS "p",
                                     reference    AS "r");
BEGIN
  vReference := 'EABEL-20021009123335791PDT';
  FOR c IN getPurchaseOrder(vReference) LOOP
    xNode := c.XML.extract('//Requestor');
    SELECT XMLSerialize(CONTENT
                        XMLQuery('//text()' PASSING xNode RETURNING CONTENT))
           INTO vText FROM DUAL;
    DBMS_OUTPUT.put_line('The Requestor for Reference '
                         || vReference || ' is '|| vText);
  END LOOP;
  vReference := 'PTUCKER-20021009123335430PDT';
  FOR c IN getPurchaseOrder(vReference) LOOP
    xNode := c.XML.extract('//LineItem[@ItemNumber="1"]/Description');
    SELECT XMLSerialize(CONTENT
                        XMLQuery('//text()' PASSING xNode RETURNING CONTENT))
           INTO vText FROM DUAL;
    DBMS_OUTPUT.put_line('The Description of LineItem[1] for Reference '
                         || vReference || ' is '|| vText);
  END LOOP;
END;
/
The Requestor for Reference EABEL-20021009123335791PDT is Ellen S. Abel
The Description of LineItem[1] for Reference PTUCKER-20021009123335430PDT is
 Picnic at
Hanging Rock
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p><a href="#CHDEDHCC">Example 4-5</a> uses SQL/XML function <code>XMLTable</code> to extract data from an XML purchase-order document, and then inserts that data into a relational table.</p>
<div id="ADXDB4262" class="example">
<p class="titleinexample"><a id="CHDEDHCC"></a>Example 4-5 <a id="sthref308"></a><a id="sthref309"></a>Extracting XML Data using XMLTABLE, and Inserting It into a Database Table</p>
<pre>
CREATE TABLE purchaseorder_table (reference           VARCHAR2(28) PRIMARY KEY,
                                  requestor           VARCHAR2(48),
                                  actions             XMLType,
                                  userid              VARCHAR2(32),
                                  costcenter          VARCHAR2(3),
                                  shiptoname          VARCHAR2(48),
                                  address             VARCHAR2(512),
                                  phone               VARCHAR2(32),
                                  rejectedby          VARCHAR2(32),
                                  daterejected        DATE,
                                  comments            VARCHAR2(2048),
                                  specialinstructions VARCHAR2(2048));
 
CREATE TABLE purchaseorder_lineitem (reference,
                                     FOREIGN KEY ("REFERENCE")
                                       REFERENCES "PURCHASEORDER_TABLE" ("REFERENCE") ON DELETE CASCADE,
                                     lineno      NUMBER(10), PRIMARY KEY ("REFERENCE", "LINENO"),
                                     upc         VARCHAR2(14),
                                     description VARCHAR2(128),
                                     quantity    NUMBER(10),
                                     unitprice   NUMBER(12,2));
 
INSERT INTO purchaseorder_table (reference, requestor, actions, userid, costcenter, shiptoname, address,
                                 phone, rejectedby, daterejected, comments, specialinstructions)
  SELECT t.reference, t.requestor, t.actions, t.userid, t.costcenter, t.shiptoname, t.address, 
          t.phone, t.rejectedby, t.daterejected, t.comments, t.specialinstructions
    FROM purchaseorder p,
         XMLTable('/PurchaseOrder' PASSING p.OBJECT_VALUE
                  COLUMNS reference           VARCHAR2(28)   PATH 'Reference',
                          requestor           VARCHAR2(48)   PATH 'Requestor',
                          actions             XMLType        PATH 'Actions',
                          userid              VARCHAR2(32)   PATH 'User',
                          costcenter          VARCHAR2(3)    PATH 'CostCenter',
                          shiptoname          VARCHAR2(48)   PATH 'ShippingInstructions/name',
                          address             VARCHAR2(512)  PATH 'ShippingInstructions/address',
                          phone               VARCHAR2(32)   PATH 'ShippingInstructions/telephone',
                          rejectedby          VARCHAR2(32)   PATH 'Reject/User',
                          daterejected        DATE           PATH 'Reject/Date',
                          comments            VARCHAR2(2048) PATH 'Reject/Comments',
                          specialinstructions VARCHAR2(2048) PATH 'SpecialInstructions') t
    WHERE t.reference = 'EABEL-20021009123336251PDT';
 
INSERT INTO purchaseorder_lineitem (reference, lineno, upc, description, quantity, unitprice)
  SELECT t.reference, li.lineno, li.upc, li.description, li.quantity, li.unitprice
    FROM purchaseorder p,
         XMLTable('/PurchaseOrder' PASSING p.OBJECT_VALUE
                  COLUMNS reference VARCHAR2(28) PATH 'Reference',
                          lineitem XMLType PATH 'LineItems/LineItem') t,
         XMLTable('LineItem' PASSING t.lineitem
                  COLUMNS lineno      NUMBER(10)    PATH '@ItemNumber',
                          upc         VARCHAR2(14)  PATH 'Part/@Id',
                          description VARCHAR2(128) PATH 'Description',
                          quantity    NUMBER(10)    PATH 'Part/@Quantity',
                          unitprice   NUMBER(12,2)  PATH 'Part/@UnitPrice') li
    WHERE t.reference = 'EABEL-20021009123336251PDT';
 
SELECT reference, userid, shiptoname, specialinstructions FROM purchaseorder_table;
 
REFERENCE                        USERID   SHIPTONAME                                       SPECIALINSTRUCTIONS
-------------------------------- -------- ------------------------------------------------ -------------------
EABEL-20021009123336251PDT       EABEL    Ellen S. Abel                                    Counter to Counter
 
SELECT reference, lineno, upc, description, quantity FROM purchaseorder_lineitem;
 
REFERENCE                            LINENO UPC            DESCRIPTION                          QUANTITY
-------------------------------- ---------- -------------- ---------------------------------- ----------
EABEL-20021009123336251PDT                1 37429125526    Samurai 2: Duel at Ichijoji Temple          3
EABEL-20021009123336251PDT                2 37429128220    The Red Shoes                               4
EABEL-20021009123336251PDT                3 715515009058   A Night to Remember                         1
</pre></div>
<!-- class="example" -->
<p><a href="#CHDDJAAD">Example 4-6</a> defines and uses a PL/SQL procedure to extract data from an XML purchase-order document and insert it into a relational table.</p>
<div id="ADXDB4263" class="example">
<p class="titleinexample"><a id="CHDDJAAD"></a>Example 4-6 Extracting XML Data and Inserting It into a Table using a PL/SQL Procedure</p>
<pre>
CREATE OR REPLACE PROCEDURE insertPurchaseOrder(purchaseorder XMLType) AS reference VARCHAR2(28);
BEGIN
  INSERT INTO purchaseorder_table (reference, requestor, actions, userid, costcenter, shiptoname, address,
                                   phone, rejectedby, daterejected, comments, specialinstructions)
    SELECT * FROM XMLTable('$p/PurchaseOrder' PASSING purchaseorder AS "p"
                           COLUMNS reference           VARCHAR2(28)   PATH 'Reference',
                                   requestor           VARCHAR2(48)   PATH 'Requestor',
                                   actions             XMLType        PATH 'Actions',
                                   userid              VARCHAR2(32)   PATH 'User',
                                   costcenter          VARCHAR2(3)    PATH 'CostCenter',
                                   shiptoname          VARCHAR2(48)   PATH 'ShippingInstructions/name',
                                   address             VARCHAR2(512)  PATH 'ShippingInstructions/address',
                                   phone               VARCHAR2(32)   PATH 'ShippingInstructions/telephone',
                                   rejectedby          VARCHAR2(32)   PATH 'Reject/User',
                                   daterejected        DATE           PATH 'Reject/Date',
                                   comments            VARCHAR2(2048) PATH 'Reject/Comments',
                                   specialinstructions VARCHAR2(2048) PATH 'SpecialInstructions');
 
  INSERT INTO purchaseorder_lineitem (reference, lineno, upc, description, quantity, unitprice)
    SELECT t.reference, li.lineno, li.upc, li.description, li.quantity, li.unitprice
    FROM XMLTable('$p/PurchaseOrder' PASSING purchaseorder AS "p"
                  COLUMNS reference VARCHAR2(28) PATH 'Reference',
                          lineitem XMLType PATH 'LineItems/LineItem') t,
         XMLTable('LineItem' PASSING t.lineitem
                  COLUMNS lineno NUMBER(10)    PATH '@ItemNumber',
                          upc VARCHAR2(14)  PATH 'Part/@Id',
                          description VARCHAR2(128) PATH 'Description',
                          quantity NUMBER(10)    PATH 'Part/@Quantity',
                          unitprice NUMBER(12,2)  PATH 'Part/@UnitPrice') li;
END;
CALL insertPurchaseOrder(XMLType(bfilename('XMLDIR', 'purchaseOrder.xml'), nls_charset_id('AL32UTF8')));
 
SELECT reference, userid, shiptoname, specialinstructions FROM purchaseorder_table;
 
REFERENCE                        USERID   SHIPTONAME                                       SPECIALINSTRUCTIONS
-------------------------------- -------- ------------------------------------------------ -------------------
SBELL-2002100912333601PDT        SBELL    Sarah J. Bell                                    Air Mail

 
SELECT reference, lineno, upc, description, quantity FROM purchaseorder_lineitem;
 
REFERENCE                 LINENO UPC          DESCRIPTION                        QUANTITY
------------------------- ------ ------------ ---------------------------------- --------
SBELL-2002100912333601PDT      1 715515009058 A Night to Remember                       2
SBELL-2002100912333601PDT      2 37429140222  The Unbearable Lightness Of Being         2
SBELL-2002100912333601PDT      3 715515011020 Sisters                                   4
</pre></div>
<!-- class="example" -->
<p><a href="#CHDEFAIG">Example 4-7</a> extracts the purchase-order name from XML element <code>PurchaseOrder</code> for customers with "<code>ll</code>" (double L) in their names and the word "<code>Shores</code>" in the shipping instructions. It uses Oracle XQuery extension function <code>ora:contains</code> to perform full-text search.</p>
<div id="ADXDB4265" class="example">
<p class="titleinexample"><a id="CHDEFAIG"></a>Example 4-7 Searching XML Data using SQL/XML Functions</p>
<pre>
SELECT <span class="bold">XMLCast</span>(<span class="bold">XMLQuery</span>('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(128)) name,
       count(*)
  FROM purchaseorder po
  WHERE
    <span class="bold">XMLExists</span>(
      'declare namespace ora="http://xmlns.oracle.com/xdb"; (: :)
       $p/PurchaseOrder/ShippingInstructions[ora:contains(address/text(), "Shores") &gt; 0]'
      PASSING po.OBJECT_VALUE AS "p")
    AND <span class="bold">XMLCast</span>(<span class="bold">XMLQuery</span>('$p/PurchaseOrder/Requestor/text()'
                         PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
                AS VARCHAR2(128))
        LIKE '%ll%'
  GROUP BY <span class="bold">XMLCast</span>(<span class="bold">XMLQuery</span>('$p/PurchaseOrder/Requestor'
                            PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
                   AS VARCHAR2(128));

NAME                   COUNT(*)
-------------------- ----------
Allan D. McEwen               9
Ellen S. Abel                 4
Sarah J. Bell                13
William M. Smith              7
</pre></div>
<!-- class="example" -->
<p><a href="#i1025061">Example 4-8</a> uses SQL/XML function <code>XMLQuery</code> to extract nodes identified by an XPath expression. The <code>XMLType</code> instance returned by <code>XMLQuery</code> can be a set of nodes, a singleton node, or a text value. <a href="#i1025061">Example 4-8</a> uses <code>XMLType</code> method <code>isFragment()</code> to determine whether the result is a fragment.</p>
<div id="ADXDB4266" class="example">
<p class="titleinexample"><a id="i1025061"></a>Example 4-8 Extracting Fragments from an XMLTYPE Instance using XMLQUERY</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING po.OBJECT_VALUE AS "p"
                                                     RETURNING CONTENT)
               AS VARCHAR2(30)) reference,
       count(*)
  FROM purchaseorder po, XMLTable('$p//LineItem[Part/@Id="37429148327"]' PASSING OBJECT_VALUE AS "p")
  WHERE <span class="bold">XMLQuery</span>('$p/PurchaseOrder/LineItems/LineItem[Part/@Id="37429148327"]'
                 PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT).<span class="bold">isFragment</span>() = 1
  GROUP BY XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
                   AS VARCHAR2(30))
  ORDER BY XMLCast(XMLQuery('$p/PurchaseOrder/Reference' PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
                   AS VARCHAR2(30));
 
REFERENCE                          COUNT(*)
-------------------------------- ----------
TFOX-20021009123337784PDT                 3
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot insert fragments into <code>XMLType</code> columns. You can use SQL function <code>sys_XMLGen</code> to convert a fragment into a well-formed document by adding an enclosing tag. See <a href="xdb13gen.htm#i1026349">"SYS_XMLGEN Oracle SQL Function"</a>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1032611"></a>
<div id="ADXDB0440" class="sect1">
<h2 class="sect1"><a id="sthref310"></a><a id="sthref311"></a>Updating XML Data</h2>
<p>This section covers updating XML data, both transient data and data stored in tables. It describes the use of the following SQL functions:</p>
<ul>
<li>
<p><code>updateXML</code></p>
</li>
<li>
<p><code>insertChildXML</code></p>
</li>
<li>
<p><code>insertChildXMLbefore</code></p>
</li>
<li>
<p><code>insertChildXMLafter</code></p>
</li>
<li>
<p><code>insertXMLbefore</code></p>
</li>
<li>
<p><code>insertXMLafter</code></p>
</li>
<li>
<p><code>appendChildXML</code></p>
</li>
<li>
<p><code>deleteXML</code></p>
</li>
</ul>
<div id="ADXDB4267" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref312"></a>
<h3 class="sect2">Updating an Entire XML Document</h3>
<p>For unstructured storage (<code>CLOB</code>), an update effectively replaces the entire document. To update an entire XML document, use a SQL <code>UPDATE</code> statement. The right side of the <code>UPDATE</code> statement <code>SET</code> clause must be an <code>XMLType</code> instance. This can be created in any of the following ways:</p>
<ul>
<li>
<p>Use SQL functions or XML constructors that return an XML instance.</p>
</li>
<li>
<p>Use the PL/SQL DOM APIs for <code>XMLType</code> that change and bind an existing XML instance.</p>
</li>
<li>
<p>Use the Java DOM API that changes and binds an existing XML instance.</p>
</li>
</ul>
<p>Updates for non-schema-based XML documents stored as <code>CLOB</code> values (unstructured storage) always update the entire XML document. Updates for non-schema-based documents stored as binary XML can be made in a piecewise manner. See <a href="xdb03usg.htm#CHDFIBEH">"Updating XML Schema-Based and Non-Schema-Based XML Documents"</a>.</p>
<p><a href="#CHDCHHJB">Example 4-9</a> updates an <code>XMLType</code> instance using a SQL <code>UPDATE</code> statement.</p>
<div id="ADXDB4268" class="example">
<p class="titleinexample"><a id="CHDCHHJB"></a>Example 4-9 Updating XMLType Data using a SQL UPDATE Statement</p>
<pre>
SELECT t.reference, li.lineno, li.description
  FROM purchaseorder po,
       XMLTable('$p/PurchaseOrder' PASSING po.OBJECT_VALUE AS "p"
                COLUMNS reference VARCHAR2(28) PATH 'Reference',
                        lineitem  XMLType      PATH 'LineItems/LineItem') t,
       XMLTable('$l/LineItem' PASSING t.lineitem AS "l"
                COLUMNS lineno      NUMBER(10)    PATH '@ItemNumber',
                        description VARCHAR2(128) PATH 'Description') li
  WHERE t.reference = 'DAUSTIN-20021009123335811PDT' AND ROWNUM &lt; 6;
 
REFERENCE                         LINENO DESCRIPTION
-------------------------------- ------- -----------------
DAUSTIN-20021009123335811PDT           1 Nights of Cabiria
DAUSTIN-20021009123335811PDT           2 For All Mankind
DAUSTIN-20021009123335811PDT           3 Dead Ringers
DAUSTIN-20021009123335811PDT           4 Hearts and Minds
DAUSTIN-20021009123335811PDT           5 Rushmore

UPDATE purchaseorder po
  SET po.OBJECT_VALUE = XMLType(bfilename('XMLDIR','NEW-DAUSTIN-20021009123335811PDT.xml'),
                                nls_charset_id('AL32UTF8'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="DAUSTIN-20021009123335811PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

SELECT t.reference, li.lineno, li.description
  FROM purchaseorder po,
       XMLTable('$p/PurchaseOrder' PASSING po.OBJECT_VALUE AS "p"
                COLUMNS reference VARCHAR2(28) PATH 'Reference',
                        lineitem  XMLType      PATH 'LineItems/LineItem') t,
       XMLTable('$l/LineItem' PASSING t.lineitem AS "l"
                COLUMNS lineno      NUMBER(10)    PATH '@ItemNumber',
                        description VARCHAR2(128) PATH 'Description') li
  WHERE t.reference = 'DAUSTIN-20021009123335811PDT';
 
REFERENCE                         LINENO DESCRIPTION
-------------------------------- ------- --------------------------------
DAUSTIN-20021009123335811PDT           1 Dead Ringers
DAUSTIN-20021009123335811PDT           2 Getrud
DAUSTIN-20021009123335811PDT           3 Branded to Kill
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="ADXDB4269" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref313"></a>
<h3 class="sect2">SQL Functions that Update XML Data</h3>
<p>There are several Oracle SQL functions that you can use to update XML data incrementally&thinsp;&mdash;&thinsp;that is, to replace, insert, or delete XML data without replacing the entire surrounding XML document. This is also called <span class="glossaryterm"><a id="sthref314"></a><a id="sthref315"></a>partial updating</span>. These Oracle SQL functions are described in the following sections:</p>
<ul>
<li>
<p><code>updateXML</code> &ndash; Replace XML nodes of any kind. See <a href="#CHDBIJCB">"UPDATEXML SQL Function"</a>.</p>
</li>
<li>
<p><code>insertChildXML</code> &ndash; Insert XML element or attribute nodes as children of a given element node. See <a href="#CHDIIACJ">"INSERTCHILDXML SQL Function"</a>.</p>
</li>
<li>
<p><code>insertChildXMLbefore</code> &ndash; Insert new collection elements immediately before a given collection element of the same type. See <a href="#CFHHAGBB">"INSERTCHILDXMLBEFORE SQL Function"</a>.</p>
</li>
<li>
<p><code>insertChildXMLafter</code> &ndash; Insert new collection elements immediately after a given collection element of the same type. See <a href="#CFHEGGCG">"INSERTCHILDXMLAFTER SQL Function"</a>.</p>
</li>
<li>
<p><code>insertXMLbefore</code> &ndash; Insert XML nodes of any kind immediately before a given node (other than an attribute node). See <a href="#CHDGFHAF">"INSERTXMLBEFORE SQL Function"</a>.</p>
</li>
<li>
<p><code>insertXMLafter</code> &ndash; Insert XML nodes of any kind immediately after a given node (other than an attribute node). See <a href="#CFHFEHFI">"INSERTXMLAFTER SQL Function"</a>.</p>
</li>
<li>
<p><code>appendChildXML</code> &ndash; Insert XML nodes of any kind as the last child nodes of a given element node. See <a href="#CHDFGJHH">"APPENDCHILDXML SQL Function"</a>.</p>
</li>
<li>
<p><code>deleteXML</code> &ndash; Delete XML nodes of any kind. See <a href="#CHDEGEDH">"DELETEXML SQL Function"</a>.</p>
</li>
</ul>
<p>Use functions <code>insertChildXML</code>, <code>insertChildXMLbefore</code>, <code>insertChildXMLafter</code>, <code>insertXMLbefore</code>, <code>insertXMLafter</code>, and <code>appendChildXML</code> to insert XML data. Use function <code>deleteXML</code> to delete XML data. Use function <code>updateXML</code> to replace XML data.</p>
<p>In particular, do <span class="italic">not</span> use function <code>updateXML</code> to insert or delete XML data by replacing a parent node in its entirety. That works, but it is less efficient than using one of the other functions, which perform more localized updates.</p>
<p>These Oracle SQL functions do <span class="italic">not</span>, by themselves, change database data &ndash; they are all pure functions, without side effect. Each applies an XPath-expression argument to input XML data and returns a modified <span class="italic">copy</span> of the input XML data. You can then use that result with SQL DML operator <code>UPDATE</code> to modify database data. This is no different from the way you use SQL function <code>upper</code> to convert database data to uppercase: you must use a SQL DML operator such as <code>UPDATE</code> to change the stored data.</p>
<p>Each of these functions can be used on XML documents that are either schema-based or non-schema-based. For XML schema-based data, these Oracle SQL functions perform partial validation on the result, and, where appropriate, argument values are also checked for compatibility with the XML schema.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle SQL functions and <code>XMLType</code> methods respect the W3C XPath recommendation, which states that if an XPath expression targets <span class="italic">no nodes</span> when applied to XML data, then an empty sequence must be returned. An error must <span class="italic">not</span> be raised in this case.
<p>The specific semantics of an Oracle SQL function or <code>XMLType</code> method that applies an XPath expression to XML data determines what is returned. For example, SQL/XML function <code>XMLQuery</code> returns <code>NULL</code> if its XPath-expression argument targets no nodes, and the updating Oracle SQL functions, such as <code>deleteXML</code>, return the input XML data unchanged. An error is never raised if no nodes are targeted, but updating SQL functions can raise an error if an XPath-expression argument targets inappropriate nodes, such as attribute nodes or text nodes.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb03usg.htm#CHDCEAEA">"Partial Validation"</a> for more information about partial validation against an XML schema</div>
<div id="ADXDB4270" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref316"></a>
<h4 class="sect3">Inserting XML Elements using SQL Functions</h4>
<p>There are several Oracle SQL functions for inserting XML nodes into (a copy of) existing XML data. Each can insert nodes at multiple locations that are referenced by an XPath expression. They differ in the placement of the new nodes and how the target XML data is referenced.</p>
<ul>
<li>
<p>Function <code>appendChildXML</code> appends nodes to the target elements. That is, for each target element, it inserts one or more nodes of any kind as the element's last children.</p>
</li>
<li>
<p>Function <code>insertChildXML</code> inserts new children (one or more elements of the same type or a single attribute) under target elements. The position of a new child element under its parent is not specified. If the target data is XML schema-based, then the schema can sometimes be used to determine the position. Otherwise, the position is arbitrary.</p>
</li>
<li>
<p>Function <code>insertXMLbefore</code> inserts one or more nodes of <span class="italic">any kind</span> immediately before a target node (which is not an attribute node).</p>
<p>Function <code>insertXMLafter</code> inserts a node similarly, but after the target, not before.</p>
</li>
<li>
<p>Function <code>insertChildXMLbefore</code> is similar to <code>insertChildXML</code>, except that the inserted node must be an element (not an attribute), and you specify the position of the new element among its siblings. It is similar to <code>insertXMLbefore</code>, except that it inserts only <span class="italic">collection</span> elements, not arbitrary elements. The insertion position specifies a successor collection member. The actual element to be inserted must correspond to the element type for the collection.</p>
<p>Function <code>insertChildXMLafter</code> inserts a node similarly, but after the target, not before.</p>
</li>
</ul>
<p>Though the effect of <code>insertChildXMLbefore</code> (-<code>after</code>) is similar to that of <code>insertXMLbefore</code> (-<code>after</code>), the target location is expressed differently. For the former, the target is the parent of the new child. For the latter, the target is the succeeding (or preceding) sibling. This difference is reflected in the function names (<code>Child</code>).</p>
<p>For example, to insert a new <code>LineItem</code> element before the third <code>LineItem</code> element under element <code>/PurchaseOrder/LineItems</code>, you can use <code>insertChildXMLbefore</code>, specifying the target parent as <code>/PurchaseOrder/LineItems</code> and the succeeding sibling as <code>LineItem[3]</code>. Or you can use <code>insertXMLbefore</code>, specifying the target succeeding sibling as <code>/PurchaseOrder/LineItems/LineItem[3]</code>. If you use <code>insertChildXML</code> for the insertion, then you cannot specify the position of the new element in the collection&thinsp;&mdash;&thinsp;the resulting position is indeterminate.</p>
<p>Another difference among these functions is that all of them <span class="italic">except</span> <code>insertXMLbefore</code>, <code>insertXMLafter</code>, and <code>appendChildXML</code>&thinsp;&mdash;are optimized for SQL <code>UPDATE</code> operations on <code>XMLType</code> tables and columns that are stored object-relationally or as binary XML.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CFHIIBDE">"Optimization of Oracle SQL Functions that Modify XML Data"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBIJCB"></a>
<div id="ADXDB4271" class="sect2">
<h3 class="sect2"><a id="sthref317"></a><a id="sthref318"></a>UPDATEXML SQL Function</h3>
<p>Oracle SQL function <code>updateXML</code> replaces XML nodes of any kind. The XML document that is the target of the update can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>updateXML</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data containing the target node to replace.</p>
</li>
<li>
<p>One or more <span class="italic">pairs</span> of <code><span class="codeinlineitalic">xpath</span></code> and <code><span class="codeinlineitalic">replacement</span></code> parameters:</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates the nodes within <code><span class="codeinlineitalic">target-data</span></code> to replace. <span class="italic">Each</span> targeted node is replaced by <code><span class="codeinlineitalic">replacement</span></code>. These can be nodes of any kind. If <code><span class="codeinlineitalic">xpath</span></code> matches an empty sequence of nodes then no replacement is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (and no error is raised).</p>
</li>
<li>
<p><code><span class="codeinlineboldital">replacement</span></code> (<code>XMLType</code> or <code>VARCHAR2</code>) &ndash; The XML data that replaces the data targeted by <code><span class="codeinlineitalic">xpath</span></code>. The data type of <code><span class="codeinlineitalic">replacement</span></code> must correspond to the data to be replaced. If <code><span class="codeinlineitalic">xpath</span></code> targets an element node for replacement, then the data type must be <code>XMLType</code>. If <code><span class="codeinlineitalic">xpath</span></code> targets an attribute node or a text node, then it must be <code>VARCHAR2</code>. For an attribute node, <code><span class="codeinlineitalic">replacement</span></code> is only the replacement <span class="italic">value</span> of the attribute (for example, 23), not the complete attribute node including the name (for example, <code>my_attribute="23"</code>).</p>
</li>
</ul>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<code>VARCHAR2</code>, <span class="italic">optional</span>) &ndash; The XML namespace for parameter <code><span class="codeinlineitalic">xpath</span></code>.</p>
</li>
</ul>
<p>Oracle SQL function <code>updateXML</code> can be used to <span class="italic">replace</span> existing elements, attributes, and other nodes with new values. It is <span class="italic">not</span> an efficient way to insert new nodes or delete existing ones. You can perform insertions and deletions with <code>updateXML</code> only by using it to replace the entire node that is the parent of the node to be inserted or deleted.</p>
<p>Function <code>updateXML</code> updates only the transient XML instance in memory. Use a SQL <code>UPDATE</code> statement to update data stored in tables.</p>
<p><a href="#i1037941">Figure 4-3</a> illustrates the syntax.</p>
<div id="ADXDB4272" class="figure">
<p class="titleinfigure"><a id="i1037941"></a>Figure 4-3 UPDATEXML Syntax</p>
<img width="754" height="58" src="img/updatexml.gif" alt="Description of Figure 4-3 follows" /><br />
<a id="sthref319" href="img_text/updatexml.htm">Description of "Figure 4-3 UPDATEXML Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#CHDEBGDD">Example 4-10</a> uses <code>updateXML</code> on the right side of an <code>UPDATE</code> statement to update the XML document in a table instead of creating a new document. The entire document is updated, not just the part that is selected.</p>
<div id="ADXDB4273" class="example">
<p class="titleinexample"><a id="CHDEBGDD"></a>Example 4-10 Updating XMLTYPE using UPDATE and UPDATEXML</p>
<pre>
SELECT XMLQuery('$p/PurchaseOrder/Actions/Action[1]' PASSING po.OBJECT_VALUE AS "p"
                                                     RETURNING CONTENT) action
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
ACTION
--------------------------------
&lt;Action&gt;
  &lt;User&gt;SVOLLMAN&lt;/User&gt;
&lt;/Action&gt;

UPDATE purchaseorder po
  SET po.OBJECT_VALUE = <span class="bold">updateXML</span>(po.OBJECT_VALUE, 
                                  '/PurchaseOrder/Actions/Action[1]/User/text()',
                                  '<span class="bold">SKING</span>')
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
SELECT XMLQuery('$p/PurchaseOrder/Actions/Action[1]' PASSING po.OBJECT_VALUE AS "p"
                                                     RETURNING CONTENT) action
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
ACTION
---------------------------------
&lt;Action&gt;
  &lt;User&gt;<span class="bold">SKING</span>&lt;/User&gt;
&lt;/Action&gt;
</pre></div>
<!-- class="example" -->
<p><a href="#CHDIIHCI">Example 4-11</a> updates multiple nodes using Oracle SQL function <code>updateXML</code>.</p>
<div id="ADXDB4274" class="example">
<p class="titleinexample"><a id="CHDIIHCI"></a>Example 4-11 Updating Multiple Text Nodes and Attribute Values using UPDATEXML</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) name,
       XMLQuery('$p/PurchaseOrder/LineItems'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT) lineitems
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
NAME             LINEITEMS
---------------- ------------------------------------------------------------------------
Sarah J. Bell    &lt;LineItems&gt;
                   &lt;LineItem ItemNumber="1"&gt;
                     &lt;Description&gt;A Night to Remember&lt;/Description&gt;
                     &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="2"&gt;
                     &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
                     &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="3"&gt;
                     &lt;Description&gt;Sisters&lt;/Description&gt;
                     &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
                   &lt;/LineItem&gt;
                 &lt;/LineItems&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = updateXML(OBJECT_VALUE,
                               '/PurchaseOrder/Requestor/text()','Stephen G. King',
                               '/PurchaseOrder/LineItems/LineItem[1]/Part/@Id','786936150421',
                               '/PurchaseOrder/LineItems/LineItem[1]/Description/text()','The Rock',
                               '/PurchaseOrder/LineItems/LineItem[3]',
                               XMLType('&lt;LineItem ItemNumber="99"&gt;
                                          &lt;Description&gt;Dead Ringers&lt;/Description&gt;
                                          &lt;Part Id="715515009249" UnitPrice="39.95" Quantity="2"/&gt;
                                        &lt;/LineItem&gt;'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) name,
       XMLQuery('$p/PurchaseOrder/LineItems'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT) lineitems
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
NAME             LINEITEMS
---------------- ------------------------------------------------------------------
Stephen G. King  &lt;LineItems&gt;
                   &lt;LineItem ItemNumber="1"&gt;
                     &lt;Description&gt;The Rock&lt;/Description&gt;
                     &lt;Part Id="786936150421" UnitPrice="39.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="2"&gt;
                     &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
                     &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="99"&gt;
                     &lt;Description&gt;Dead Ringers&lt;/Description&gt;
                     &lt;Part Id="715515009249" UnitPrice="39.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                 &lt;/LineItems&gt;
</pre></div>
<!-- class="example" -->
<p><a href="#CHDEJIJD">Example 4-12</a> uses SQL function <code>updateXML</code> to update selected nodes within a collection.</p>
<div id="ADXDB4275" class="example">
<p class="titleinexample"><a id="CHDEJIJD"></a>Example 4-12 Updating Selected Nodes within a Collection using UPDATEXML</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) name,
       XMLQuery('$p/PurchaseOrder/LineItems'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT) lineitems
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
NAME             LINEITEMS
---------------- ----------------------------------------------------------------
Sarah J. Bell    &lt;LineItems&gt;
                   &lt;LineItem ItemNumber="1"&gt;
                     &lt;Description&gt;A Night to Remember&lt;/Description&gt;
                     &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="2"&gt;
                     &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
                     &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="3"&gt;
                     &lt;Description&gt;Sisters&lt;/Description&gt;
                     &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
                   &lt;/LineItem&gt;
                 &lt;/LineItems&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = 
      updateXML(OBJECT_VALUE,
                '/PurchaseOrder/Requestor/text()','Stephen G. King',
                '/PurchaseOrder/LineItems/LineItem/Part[@Id="715515009058"]/@Quantity',
                25,
                '/PurchaseOrder/LineItems/LineItem[Description/text() =
                                                   "The Unbearable Lightness Of Being"]',
                XMLType('&lt;LineItem ItemNumber="99"&gt;
                           &lt;Part Id="786936150421" Quantity="5" UnitPrice="29.95"/&gt;
                           &lt;Description&gt;The Rock&lt;/Description&gt;
                         &lt;/LineItem&gt;'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) name,
       XMLQuery('$p/PurchaseOrder/LineItems'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT) lineitems
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
NAME             LINEITEMS
---------------- -------------------------------------------------------------
Stephen G. King  &lt;LineItems&gt;
                   &lt;LineItem ItemNumber="1"&gt;
                     &lt;Description&gt;A Night to Remember&lt;/Description&gt;
                     &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="25"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="99"&gt;
                     &lt;Part Id="786936150421" Quantity="5" UnitPrice="29.95"/&gt;
                     &lt;Description&gt;The Rock&lt;/Description&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="3"&gt;
                     &lt;Description&gt;Sisters&lt;/Description&gt;
                     &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
                   &lt;/LineItem&gt;
                 &lt;/LineItems&gt;
</pre></div>
<!-- class="example" -->
<div id="ADXDB4276" class="sect3"><a id="sthref320"></a>
<h4 class="sect3">UPDATEXML and NULL Values</h4>
<ul>
<li>
<p>If you update an XML <span class="italic">element</span> to <code>NULL</code>, the attributes and children of the element are removed, and the element becomes empty. The type and namespace properties of the element are retained. See <a href="#CHDBBEHI">Example 4-13</a>.</p>
</li>
<li>
<p>If you update an <span class="italic">attribute</span> value to <code>NULL</code>, the value appears as the empty string. See <a href="#CHDBBEHI">Example 4-13</a>.</p>
</li>
<li>
<p>If you update the <span class="italic">text</span> node of an element to <code>NULL</code>, the content (text) of the element is removed. The element itself remains, but it is empty.<code><a id="sthref321"></a></code> See <a href="#CHDDEBBJ">Example 4-14</a>.</p>
</li>
</ul>
<p><a href="#CHDBBEHI">Example 4-13</a> updates all of the following to <code>NULL</code>:</p>
<ul>
<li>
<p>The <code>Description</code> element and the <code>Quantity</code> attribute of the <code>LineItem</code> element whose <code>Part</code> element has attribute <code>Id</code> value 715515009058.</p>
</li>
<li>
<p>The <code>LineItem</code> element whose <code>Description</code> element has the content (text) "The Unbearable Lightness Of Being".</p>
</li>
</ul>
<div id="ADXDB4277" class="example">
<p class="titleinexample"><a id="CHDBBEHI"></a>Example 4-13 NULL Updates with UPDATEXML &ndash; Element and Attribute</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) name,
       XMLQuery('$p/PurchaseOrder/LineItems'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT) lineitems
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
NAME             LINEITEMS
---------------- -------------------------------------------------------------------
Sarah J. Bell    &lt;LineItems&gt;
                   &lt;LineItem ItemNumber="1"&gt;
                     &lt;Description&gt;A Night to Remember&lt;/Description&gt;
                     &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="2"&gt;
                     &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
                     &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
                   &lt;/LineItem&gt;
                   &lt;LineItem ItemNumber="3"&gt;
                     &lt;Description&gt;Sisters&lt;/Description&gt;
                     &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
                   &lt;/LineItem&gt;
                 &lt;/LineItems&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = 
      updateXML(
        OBJECT_VALUE,
        '/PurchaseOrder/LineItems/LineItem[Part/@Id="715515009058"]/Description', NULL,
             '/PurchaseOrder/LineItems/LineItem/Part[@Id="715515009058"]/@Quantity', NULL,
        '/PurchaseOrder/LineItems/LineItem[Description/text()=
                                           "The Unbearable Lightness Of Being"]', NULL)
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/Requestor'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30)) name,
       XMLQuery('$p/PurchaseOrder/LineItems'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT) lineitems
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 
NAME             LINEITEMS
---------------- ----------------------------------------------------------------
Sarah J. Bell    &lt;LineItems&gt;
                   &lt;LineItem ItemNumber="1"&gt;
                     <span class="bold">&lt;Description/&gt;</span>
                     &lt;Part Id="715515009058" UnitPrice="39.95" <span class="bold">Quantity=""</span>/&gt;
                   &lt;/LineItem&gt;
                   <span class="bold">&lt;LineItem/&gt;</span>
                   &lt;LineItem ItemNumber="3"&gt;
                     &lt;Description&gt;Sisters&lt;/Description&gt;
                     &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
                   &lt;/LineItem&gt;
                 &lt;/LineItems&gt;
</pre></div>
<!-- class="example" -->
<p><a href="#CHDDEBBJ">Example 4-14</a> updates the text node of a <code>Part</code> element whose <code>Description</code> attribute has value "<code>A Night to Remember</code>" to <code>NULL</code>. The XML data for this example corresponds to a different, revised purchase-order XML schema &ndash; see <a href="xdb07evo.htm#BCGEAFJC">"Scenario for Copy-Based Evolution"</a>. In that XML schema, <code>Description</code> is an attribute of the <code>Part</code> element, not a sibling element.</p>
<div id="ADXDB4278" class="example">
<p class="titleinexample"><a id="CHDDEBBJ"></a>Example 4-14 NULL Updates with UPDATEXML &ndash; Text Node</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/LineItems/LineItem/Part[@Description="A Night to Remember"]'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(128)) part
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[@Reference="SBELL-2003030912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

PART
----
&lt;Part Description="A Night to Remember" UnitCost="39.95"&gt;<span class="bold">715515009058</span>&lt;/Part&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = 
        updateXML(OBJECT_VALUE, 
                  '/PurchaseOrder/LineItems/LineItem/Part[@Description="A Night to Remember"]/<span class="bold">text()</span>', <span class="bold">NULL</span>)
  WHERE XMLExists('$p/PurchaseOrder[@Reference="SBELL-2003030912333601PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/LineItems/LineItem/Part[@Description="A Night to Remember"]'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(128)) part
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[@Reference="SBELL-2003030912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

PART
----
&lt;Part Description="A Night to Remember" UnitCost="39.95"/&gt;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb03usg.htm#CHDBGCBG">Example 3-36, "Updating XML Content using UPDATEXML"</a></div>
</div>
<!-- class="sect3" -->
<div id="ADXDB4279" class="sect3"><a id="sthref322"></a>
<h4 class="sect3">Updating the Same XML Node More Than Once</h4>
<p>You can <a id="sthref323"></a>update the same XML node more than once in an <code>updateXML</code> expression. For example, you can update both <code>/EMP[EMPNO=217]</code> and <code>/EMP[EMPNAME="Jane"]/EMPNO</code>, where the first XPath identifies the <code>EMPNO</code> node containing it as well. The order of updates is determined by the order of the XPath expressions in left-to-right order. Each successive XPath works on the result of the previous XPath update.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4280" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref324"></a>
<h4 class="sect3">Preserving DOM <a id="sthref325"></a><a id="sthref326"></a>Fidelity When using UPDATEXML</h4>
<p>Here are some guidelines for preserving DOM fidelity when using Oracle SQL function <code>updateXML</code>:</p>
<div id="ADXDB4281" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref327"></a>
<h5 class="sect4">When DOM Fidelity is Preserved</h5>
<p>When you update an element to <code>NULL</code>, you make that element appear <span class="italic">empty</span> in its parent, such as in <code>&lt;myElem/&gt;</code>.When you update a text node inside an element to <code>NULL</code>, you <span class="italic">remove</span> that text node from the element.When you update an attribute node to <code>NULL</code>, you make the value of the attribute become the <span class="italic">empty</span> string, for example, <code>myAttr=""</code>.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDB4282" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref328"></a>
<h5 class="sect4">When DOM Fidelity is Not Preserved</h5>
<p>When you update a <code>complexType</code> element to <code>NULL</code>, you make the element appear <span class="italic">empty</span> in its parent, for example, <code>&lt;myElem/&gt;</code>.When you update a SQL-inlined <code>simpleType</code> element to <code>NULL</code>, you make the element <span class="italic">disappear</span> from its parent.When you update a text node to <code>NULL</code>, you are doing the same thing as setting the parent <code>simpleType</code> element to <code>NULL</code>. Furthermore, text nodes can appear only inside <code>simpleType</code> elements when DOM fidelity is not preserved, since there is no positional descriptor with which to store mixed content.When you update an attribute node to <code>NULL</code>, you <span class="italic">remove</span> the attribute from the element.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDB4283" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref329"></a>
<h5 class="sect4">Determining Whether DOM Fidelity is Preserved</h5>
<p>You can determine whether or not DOM fidelity is preserved for particular parts of a given <code>XMLType</code> in a given XML schema by querying the schema metadata for attribute <code>maintainDOM</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb05sto.htm#BJFDCFII">"Querying a Registered XML Schema to Obtain Annotations"</a> for an example of querying a schema to retrieve DOM fidelity values</p>
</li>
<li>
<p><a href="xdb05sto.htm#i1036294">"DOM Fidelity"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CFHIIBDE"></a>
<div id="ADXDB4284" class="sect2">
<h3 class="sect2">Optimization of Oracle SQL <a id="sthref330"></a>Functions that Modify XML Data</h3>
<p>In most cases, the Oracle SQL functions that modify XML data materialize a copy of the entire input XML document in memory, then update the copy. However, functions <code>updateXML</code>, <code>insertChildXML</code>, <code>insertChildXMLbefore</code>, <code>insertChildXMLafter</code>, and <code>deleteXML</code>&thinsp;&mdash;that is, all <span class="italic">except</span> <code>insertXMLbefore</code>, <code>insertXMLafter</code>, and <code>appendChildXML</code>&thinsp;&mdash;are optimized for SQL <code>UPDATE</code> operations on <code>XMLType</code> tables and columns that are stored object-relationally or as binary XML.</p>
<p>For structured storage, if particular conditions are met, then the function call can be rewritten to update the object-relational columns directly with the values. For binary XML storage, data preceding the targeted update is not modified, and, if SecureFile LOBs are used (the default behavior), then sliding inserts are used to update only the portions of the data that need changing.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb03usg.htm#CHDFIBEH">"Updating XML Schema-Based and Non-Schema-Based XML Documents"</a> for more about piecewise updating</p>
</li>
<li>
<p><a href="xdb03usg.htm#g1055369">Chapter 3, "Using Oracle XML&nbsp;DB"</a> and <a href="xdb_rewrite.htm#BABHJECG">Chapter 8, "XPath Rewrite for Structured Storage"</a> for information about the conditions for XPath rewrite</p>
</li>
<li>
<p><a href="xdb_xquery.htm#CBACDEEC">"Performance Tuning for XQuery"</a></p>
</li>
</ul>
</div>
<p>As an example with object-relational storage, the XPath argument to <code>updateXML</code> in <a href="#CHDHFJHF">Example 4-15</a> is processed by Oracle XML&nbsp;DB and rewritten into equivalent object-relational SQL code, as illustrated in <a href="#CHDICCHC">Example 4-16</a>.</p>
<div id="ADXDB4285" class="example">
<p class="titleinexample"><a id="CHDHFJHF"></a>Example 4-15 XPath Expressions in UPDATEXML Expression</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User'
PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
       AS VARCHAR2(30))
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
  PASSING po.OBJECT_VALUE AS "p");
 
XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
SBELL

UPDATE purchaseorder
  SET OBJECT_VALUE = updateXML(OBJECT_VALUE, <span class="bold">'/PurchaseOrder/User/text()', 'SVOLLMAN'</span>)
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
  PASSING OBJECT_VALUE AS "p");

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User'
PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
       AS VARCHAR2(30))
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
  PASSING po.OBJECT_VALUE AS "p");
 
XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
<span class="bold">SVOLLMAN</span>
</pre></div>
<!-- class="example" -->
<div id="ADXDB4286" class="example">
<p class="titleinexample"><a id="CHDICCHC"></a>Example 4-16 Object Relational Equivalent of UPDATEXML Expression</p>
<pre>
SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
SBELL
 
UPDATE purchaseorder p
   SET p."XMLDATA"."<span class="bold">USERID</span>" = '<span class="bold">SVOLLMAN</span>'
   WHERE p."XMLDATA"."REFERENCE" = 'SBELL-2002100912333601PDT';

SELECT XMLCast(XMLQuery('$p/PurchaseOrder/User'
                        PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
               AS VARCHAR2(30))
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");
 

XMLCAST(XMLQUERY('$P/PURCHASEO
------------------------------
<span class="bold">SVOLLMAN</span>
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The use of <code>XMLDATA</code> for DML is shown here only as an illustration of internal Oracle XML&nbsp;DB behavior. Do <span class="italic">not</span> use <code>XMLDATA</code> yourself for DML operations. You can use <code>XMLDATA</code> directly only for DDL operations, never for DML operations.
<p>More generally, in your code, do not rely on the current mapping between the XML Schema object model and the SQL object model. This Oracle XML&nbsp;DB implementation mapping might change in the future.</p>
</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4287" class="sect2"><a id="sthref331"></a>
<h3 class="sect2">Creating XML Views using Oracle SQL Functions that Modify XML Data</h3>
<p>You can use the Oracle SQL functions that modify XML data (<code>updateXML</code>, <code>insertChildXML</code>, <code>insertChildXMLbefore</code>, <code>insertChildXMLafter</code>, <code>insertXMLbefore</code>, <code>insertXMLafter</code>, <code>appendChildXML</code>, and <code>deleteXML</code>) to create new views of XML data.</p>
<p><a href="#CHDFBHBF">Example 4-17</a> creates a view of table <code>purchaseorder</code> using Oracle SQL function <code>updateXML</code>.</p>
<div id="ADXDB4288" class="example">
<p class="titleinexample"><a id="CHDFBHBF"></a>Example 4-17 Creating a View using UPDATEXML</p>
<pre>
CREATE OR REPLACE VIEW purchaseorder_summary OF XMLType AS
  SELECT <span class="bold">updateXML</span>(OBJECT_VALUE,
                   '/PurchaseOrder/Actions', NULL,
                   '/PurchaseOrder/ShippingInstructions', NULL,
                   '/PurchaseOrder/LineItems', NULL) AS XML
  FROM purchaseorder p;

SELECT OBJECT_VALUE FROM purchaseorder_summary
  WHERE XMLExists('$p/PurchaseOrder[Reference="DAUSTIN-20021009123335811PDT"]'                  PASSING OBJECT_VALUE AS "p");
 
OBJECT_VALUE
---------------------------------------------------------------------------
&lt;PurchaseOrder
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation=
      "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"&gt;
  &lt;Reference&gt;DAUSTIN-20021009123335811PDT&lt;/Reference&gt;
  &lt;Actions/&gt;
  &lt;Reject/&gt;
  &lt;Requestor&gt;David L. Austin&lt;/Requestor&gt;
  &lt;User&gt;DAUSTIN&lt;/User&gt;
  &lt;CostCenter&gt;S30&lt;/CostCenter&gt;
  &lt;ShippingInstructions/&gt;
  &lt;SpecialInstructions&gt;Courier&lt;/SpecialInstructions&gt;
  &lt;LineItems/&gt;
&lt;/PurchaseOrder&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDIIACJ"></a>
<div id="ADXDB4289" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref332"></a><a id="sthref333"></a>INSERTCHILDXML SQL Function</h3>
<p>Oracle SQL function <code>insertChildXML</code> inserts new children (one or more elements of the same type or a single attribute) under parent XML elements. The XML document that is the target of the insertion can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>insertChildXML</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data containing the target parent element.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">parent-xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates the parent elements within <code><span class="codeinlineitalic">target-data</span></code>. The <code><span class="codeinlineitalic">child-data</span></code> is inserted under <span class="italic">each</span> parent element.</p>
<p>If <code><span class="codeinlineitalic">parent-xpath</span></code> matches an empty sequence of element nodes, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">parent-xpath</span></code> does not match a sequence of element nodes (in particular, if <code><span class="codeinlineitalic">parent-xpath</span></code> matches one or more <span class="italic">attribute</span> or <span class="italic">text</span> nodes), then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-name</span></code> (<code>VARCHAR2</code>) &ndash; The name of the child elements or attribute to insert. An attribute name is distinguished from an element name by having an at-sign (<code>@</code>) prefix as part of <code><span class="codeinlineitalic">child-name</span></code>, for example, <code>@my_attribute</code> versus <code>my_element</code>. (The at-sign is not part of the attribute name, but serves in the argument to indicate that <code><span class="codeinlineitalic">child-name</span></code> refers to an attribute.)</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-data</span></code> (<code>XMLType</code> or <code>VARCHAR2</code>) &ndash; The child XML data to insert:</p>
<ul>
<li>
<p>If one or more <span class="italic">elements</span> are being inserted, then this is of data type <code>XMLType</code>, and it contains element nodes. <span class="italic">Each</span> of the top-level element nodes in <code><span class="codeinlineitalic">child-data</span></code> must have the same name (tag) as <code><span class="codeinlineitalic">child-name</span></code> (or else an error is raised).</p>
</li>
<li>
<p>If an <span class="italic">attribute</span> is being inserted, then this is of data type <code>VARCHAR2</code>, and it represents the (scalar) attribute value. If an attribute of the same name already exists at the insertion location, then an error is raised.</p>
</li>
</ul>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<code>VARCHAR2</code>, <span class="italic">optional</span>) &ndash; The XML namespace for parameters <code><span class="codeinlineitalic">parent-xpath</span></code> and <code><span class="codeinlineitalic">child-data</span></code>.</p>
</li>
</ul>
<p>XML data <code><span class="codeinlineitalic">child-data</span></code> is inserted as one or more child elements, or a single child attribute, under <span class="italic">each</span> of the parent elements located at <code><span class="codeinlineitalic">parent-xpath</span></code>.</p>
<p>In order of decreasing precedence, function <code>insertChildXML</code> has the following behavior for <code>NULL</code> arguments:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">child-name</span></code> is <code>NULL</code>, then an error is raised.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">parent-xpath</span></code> is <code>NULL</code>, then <code>NULL</code> is returned.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">child-data</span></code> is <code>NULL</code>, then:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">child-name</span></code> names an element, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">child-name</span></code> names an attribute, then an empty attribute value is inserted, for example, <code>my_attribute&nbsp;=&nbsp;</code><code><span class="codeinlinebold">""</span></code>.</p>
</li>
</ul>
</li>
</ul>
<p><a href="#CHDFDCCI">Figure 4-4</a> shows the syntax.</p>
<div id="ADXDB4290" class="figure">
<p class="titleinfigure"><a id="CHDFDCCI"></a>Figure 4-4 INSERTCHILDXML Syntax</p>
<img width="735" height="103" src="img/insertchildxml.gif" alt="Description of Figure 4-4 follows" /><br />
<a id="sthref334" href="img_text/insertchildxml.htm">Description of "Figure 4-4 INSERTCHILDXML Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If <code><span class="codeinlineitalic">target-data</span></code> is XML <span class="italic">schema-based</span>, then the schema is consulted to determine the insertion positions. For example, if the schema constrains child elements named <code><span class="codeinlineitalic">child-name</span></code> to be the first child elements of a <code><span class="codeinlineitalic">parent-xpath</span></code>, then the insertion takes this into account. Similarly, if the <code><span class="codeinlineitalic">child-name</span></code> or <code><span class="codeinlineitalic">child-data</span></code> argument is inappropriate for an associated schema, then an error is raised.</p>
<p>If the parent element does <span class="italic">not</span> yet have a child corresponding in name and kind to <code><span class="codeinlineitalic">child-name</span></code> (and if such a child is permitted by the associated XML schema, if any), then <code><span class="codeinlineitalic">child-data</span></code> is inserted as new child elements, or a new attribute value, named <code><span class="codeinlineitalic">child-name</span></code>.</p>
<p>If the parent element already has a child <span class="italic">attribute</span> named <code><span class="codeinlineitalic">child-name</span></code> (without the at-sign), then an error is raised. If the parent element already has a child <span class="italic">element</span> named <code><span class="codeinlineitalic">child-name</span></code> (and if more than one child element is permitted by the associated XML schema, if any), then <code><span class="codeinlineitalic">child-data</span></code> is inserted so that its elements become child elements named <code><span class="codeinlineitalic">child-name</span></code>, but their positions in the sequence of children are unpredictable.</p>
<p>If you need to insert elements into an existing, non-empty collection of child elements, and the order is important to you, then use SQL/XML function <code>appendChildXML</code> or <code>insertXMLbefore</code>.</p>
<p><a href="#CHDEDCBF">Example 4-18</a> shows how to use a SQL <code>UPDATE</code> statement and Oracle SQL function <code>insertChildXML</code> to insert a new <code>LineItem</code> element as a child of element <code>LineItems</code>.</p>
<div id="ADXDB4291" class="example">
<p class="titleinexample"><a id="CHDEDCBF"></a>Example 4-18 Inserting a LineItem Element into a LineItems Element</p>
<pre>
SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[@ItemNumber=222]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[@ITEMNUMBER=222]'
---------------------------------------------------------------

1 row selected.

UPDATE purchaseorder
  SET OBJECT_VALUE = 
        <span class="bold">insertChildXML</span>(OBJECT_VALUE, 
                       '/PurchaseOrder/LineItems', 
                       'LineItem', 
                       XMLType('&lt;LineItem ItemNumber="222"&gt;
                                  &lt;Description&gt;The Harder They Come&lt;/Description&gt;
                                  &lt;Part Id="953562951413" 
                                        UnitPrice="22.95" 
                                        Quantity="1"/&gt;
                                &lt;/LineItem&gt;'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[@ItemNumber=222]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[@ITEMNUMBER=222]'
---------------------------------------------------------------
&lt;LineItem ItemNumber="222"&gt;
  &lt;Description&gt;The Harder They Come&lt;/Description&gt;
  &lt;Part Id="953562951413" UnitPrice="22.95" Quantity="1"/&gt;
&lt;/LineItem&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<p>If the XML data to be updated is XML schema-based and it refers to a namespace, then the data to be inserted must also refer to the same namespace. Otherwise, an error is raised because the inserted data does not conform to the XML schema.</p>
<p><a href="#CHDGAHJB">Example 4-19</a> is the same as <a href="#CHDEDCBF">Example 4-18</a>, except that the <code>LineItem</code> element to be inserted refers to a namespace. This assumes that the relevant XML schema requires a namespace for this element.</p>
<div id="ADXDB4292" class="example">
<p class="titleinexample"><a id="CHDGAHJB"></a>Example 4-19 Inserting an Element that Uses a Namespace</p>
<pre>
UPDATE purchaseorder
  SET OBJECT_VALUE = 
        insertChildXML(OBJECT_VALUE, 
                       '/PurchaseOrder/LineItems', 
                       'LineItem', 
                       XMLType('&lt;LineItem <span class="bold">xmlns="films.xsd"</span> ItemNumber="222"&gt;
                                  &lt;Description&gt;The Harder They Come&lt;/Description&gt;
                                  &lt;Part Id="953562951413" 
                                        UnitPrice="22.95" 
                                        Quantity="1"/&gt;
                                &lt;/LineItem&gt;'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING OBJECT_VALUE AS "p");
</pre></div>
<!-- class="example" -->
<p>Note that this use of namespaces is different from the use of a namespace <span class="italic">argument</span> to function <code>insertChildXML</code>. Namespaces supplied in that optional argument apply only to the XPath argument, not to the content to be inserted.</p>
</div>
<!-- class="sect2" -->
<a id="CFHHAGBB"></a>
<div id="ADXDB4293" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref335"></a><a id="sthref336"></a>INSERTCHILDXMLBEFORE SQL Function</h3>
<p>Oracle SQL function <code>insertChildXMLbefore</code> inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately before a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>insertChildXMLbefore</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data that is the target of the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">parent-xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates the parent elements within <code><span class="codeinlineitalic">target-data</span></code>. The <code><span class="codeinlineitalic">child-data</span></code> is inserted under <span class="italic">each</span> parent element.</p>
<p>If <code><span class="codeinlineitalic">parent-xpath</span></code> matches an empty sequence of element nodes, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">parent-xpath</span></code> does not match a sequence of element nodes (in particular, if <code><span class="codeinlineitalic">parent-xpath</span></code> matches one or more <span class="italic">attribute</span> or <span class="italic">text</span> nodes), then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-xpath</span></code> (<code>VARCHAR2</code>) &ndash; A relative XPath&nbsp;1.0 expression that locates the existing child that will become the successor of the inserted <code><span class="codeinlineitalic">child-data</span></code>. It must name a child element of the element indicated by <code><span class="codeinlineitalic">parent-xpath</span></code>, and it can include a predicate.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-data</span></code> (<code>XMLType</code>) &ndash; The child element XML data to insert. This is of data type <code>XMLType</code>, and it contains element nodes. <span class="italic">Each</span> of the top-level element nodes in <code><span class="codeinlineitalic">child-data</span></code> must have the same data type as the element indicated by <code><span class="codeinlineitalic">child-xpath</span></code> (or else an error is raised).</p>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<span class="italic">optional</span>, <code>VARCHAR2</code>) &ndash; The namespace for parameters <code><span class="codeinlineitalic">parent-xpath</span></code>, <code><span class="codeinlineitalic">child-xpath</span></code>, and <code><span class="codeinlineitalic">child-data</span></code>.</p>
</li>
</ul>
<p>XML data <code><span class="codeinlineitalic">child-data</span></code> is inserted as one or more child elements under <span class="italic">each</span> of the parent elements located at <code><span class="codeinlineitalic">parent-xpath</span></code>.</p>
<p>In order of decreasing precedence, function <code>insertChildXMLbefore</code> has the following behavior for <code>NULL</code> arguments:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">child-name</span></code> is <code>NULL</code>, then an error is raised.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">parent-xpath</span></code> is <code>NULL</code>, then <code>NULL</code> is returned.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">child-data</span></code> is <code>NULL</code>, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged.</p>
</li>
</ul>
<p><a href="#CFHCEGBC">Figure 4-5</a> shows the syntax.</p>
<div id="ADXDB4294" class="figure">
<p class="titleinfigure"><a id="CFHCEGBC"></a>Figure 4-5 INSERTCHILDXMLBEFORE Syntax</p>
<img width="735" height="103" src="img/insertchildxmlbefore.gif" alt="Description of Figure 4-5 follows" /><br />
<a id="sthref337" href="img_text/insertchildxmlbefore.htm">Description of "Figure 4-5 INSERTCHILDXMLBEFORE Syntax"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CFHEGGCG"></a>
<div id="ADXDB4295" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref338"></a><a id="sthref339"></a>INSERTCHILDXMLAFTER SQL Function</h3>
<p>Oracle SQL function <code>insertChildXMLafter</code> inserts one or more collection elements as children of target parent elements. The insertion for each target occurs immediately after a specified existing collection element. The existing XML document that is the target of the insertion can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>insertChildXMLafter</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data that is the target of the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">parent-xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates the parent elements within <code><span class="codeinlineitalic">target-data</span></code>. The <code><span class="codeinlineitalic">child-data</span></code> is inserted under <span class="italic">each</span> parent element.</p>
<p>If <code><span class="codeinlineitalic">parent-xpath</span></code> matches an empty sequence of element nodes, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">parent-xpath</span></code> does not match a sequence of element nodes (in particular, if <code><span class="codeinlineitalic">parent-xpath</span></code> matches one or more <span class="italic">attribute</span> or <span class="italic">text</span> nodes), then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-xpath</span></code> (<code>VARCHAR2</code>) &ndash; A relative XPath&nbsp;1.0 expression that locates the existing child that will become the predecessor of the inserted <code><span class="codeinlineitalic">child-data</span></code>. It must name a child element of the element indicated by <code><span class="codeinlineitalic">parent-xpath</span></code>, and it can include a predicate.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-data</span></code> (<code>XMLType</code>) &ndash; The child element XML data to insert. This is of data type <code>XMLType</code>, and it contains element nodes. <span class="italic">Each</span> of the top-level element nodes in <code><span class="codeinlineitalic">child-data</span></code> must have the same data type as the element indicated by <code><span class="codeinlineitalic">child-xpath</span></code> (or else an error is raised).</p>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<span class="italic">optional</span>, <code>VARCHAR2</code>) &ndash; The namespace for parameters <code><span class="codeinlineitalic">parent-xpath</span></code>, <code><span class="codeinlineitalic">child-xpath</span></code>, and <code><span class="codeinlineitalic">child-data</span></code>.</p>
</li>
</ul>
<p>XML data <code><span class="codeinlineitalic">child-data</span></code> is inserted as one or more child elements under <span class="italic">each</span> of the parent elements located at <code><span class="codeinlineitalic">parent-xpath</span></code>.</p>
<p>In order of decreasing precedence, function <code>insertChildXMLafter</code> has the following behavior for <code>NULL</code> arguments:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">child-name</span></code> is <code>NULL</code>, then an error is raised.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">parent-xpath</span></code> is <code>NULL</code>, then <code>NULL</code> is returned.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">child-data</span></code> is <code>NULL</code>, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged.</p>
</li>
</ul>
<p><a href="#CFHGFEJH">Figure 4-6</a> shows the syntax.</p>
<div id="ADXDB4296" class="figure">
<p class="titleinfigure"><a id="CFHGFEJH"></a>Figure 4-6 INSERTCHILDXMLAFTER Syntax</p>
<img width="735" height="103" src="img/insertchildxmlafter.gif" alt="Description of Figure 4-6 follows" /><br />
<a id="sthref340" href="img_text/insertchildxmlafter.htm">Description of "Figure 4-6 INSERTCHILDXMLAFTER Syntax"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CHDGFHAF"></a>
<div id="ADXDB4297" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref341"></a><a id="sthref342"></a>INSERTXMLBEFORE SQL Function</h3>
<p>Oracle SQL function <code>insertXMLbefore</code> inserts one or more nodes of any kind immediately before a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>insertXMLbefore</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data that is the target of the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">successor-xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates zero or more nodes in <code><span class="codeinlineitalic">target-data</span></code> of any kind <span class="italic">except</span> attribute nodes. <code><span class="codeinlineitalic">XML-data</span></code> is inserted immediately before <span class="italic">each</span> of these nodes. Thus, the nodes in <code><span class="codeinlineitalic">XML-data</span></code> become preceding siblings of each of the <code><span class="codeinlineitalic">successor-xpath</span></code> nodes.</p>
<p>If <code><span class="codeinlineitalic">successor-xpath</span></code> matches an empty sequence of nodes, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">successor-xpath</span></code> does not match a sequence of nodes that are not attribute nodes, then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">XML-data</span></code> (<code>XMLType</code>) &ndash; The XML data to be inserted: one or more nodes of <span class="italic">any kind</span>. The order of the nodes is preserved after the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<span class="italic">optional</span>, <code>VARCHAR2</code>) &ndash; The namespace for parameter <code><span class="codeinlineitalic">successor-xpath</span></code>.</p>
</li>
</ul>
<p>The <code><span class="codeinlineitalic">XML-data</span></code> nodes are inserted immediately before <span class="italic">each</span> of the non-attribute nodes located at <code><span class="codeinlineitalic">successor-xpath</span></code>.</p>
<p>Function <code>insertXMLbefore</code> has the following behavior for <code>NULL</code> arguments:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">parent-xpath</span></code> is <code>NULL</code>, then <code>NULL</code> is returned.</p>
</li>
<li>
<p>Otherwise, if <code><span class="codeinlineitalic">child-data</span></code> is <code>NULL</code>, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged.</p>
</li>
</ul>
<p><a href="#CFHDJDHA">Figure 4-7</a> shows the syntax.</p>
<div id="ADXDB5806" class="figure">
<p class="titleinfigure"><a id="CFHDJDHA"></a>Figure 4-7 INSERTXMLBEFORE Syntax</p>
<img width="767" height="46" src="img/insertxmlbefore.gif" alt="Description of Figure 4-7 follows" /><br />
<a id="sthref343" href="img_text/insertxmlbefore.htm">Description of "Figure 4-7 INSERTXMLBEFORE Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="ADXDB5807" class="example">
<p class="titleinexample"><a id="sthref344"></a>Example 4-20 Inserting a LineItem Element Before the First LineItem ELement</p>
<pre>
SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[1]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                   PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[1]'PASSINGPO.OBJECT_
------------------------------------------------------------------
&lt;LineItem ItemNumber="1"&gt;
  &lt;Description&gt;Salesman&lt;/Description&gt;
  &lt;Part Id="37429158920" UnitPrice="39.95" Quantity="2"/&gt;
&lt;/LineItem&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = 
      <span class="bold">insertXMLbefore</span>(OBJECT_VALUE, 
                      '/PurchaseOrder/LineItems/LineItem[1]', 
                      XMLType('<span class="bold">&lt;LineItem ItemNumber="314"&gt;</span>
                                 <span class="bold">&lt;Description&gt;Brazil&lt;/Description&gt;</span>
                                 <span class="bold">&lt;Part Id="314159265359"</span> 
                                       <span class="bold">UnitPrice="69.95"</span> 
                                       <span class="bold">Quantity="2"/&gt;</span>
                               <span class="bold">&lt;/LineItem&gt;</span>'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[<span class="bold">position() &lt;= 2</span>]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                   PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[POSITION()&lt;=2]'PASSINGPO.OBJECT_
------------------------------------------------------------------------------
<span class="bold">&lt;LineItem ItemNumber="314"&gt;</span>
  <span class="bold">&lt;Description&gt;Brazil&lt;/Description&gt;</span>
  <span class="bold">&lt;Part Id="314159265359" UnitPrice="69.95" Quantity="2"/&gt;</span>
<span class="bold">&lt;/LineItem&gt;</span>
&lt;LineItem ItemNumber="1"&gt;
  &lt;Description&gt;Salesman&lt;/Description&gt;
  &lt;Part Id="37429158920" UnitPrice="39.95" Quantity="2"/&gt;
&lt;/LineItem&gt;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Queries that use Oracle SQL function <code>insertXMLbefore</code> are <span class="italic">not</span> optimized. For this reason, Oracle recommends that you use function <code>insertChildXML</code>, <code>insertChildXMLbefore</code>, or <code>insertChildXMLafter</code> instead. See <a href="xdb_xquery.htm#CBACDEEC">"Performance Tuning for XQuery"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CFHFEHFI"></a>
<div id="ADXDB4300" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref345"></a><a id="sthref346"></a>INSERTXMLAFTER SQL Function</h3>
<p>Oracle SQL function <code>insertXMLafter</code> inserts one or more nodes of any kind immediately after a target node that is not an attribute node. The XML document that is the target of the insertion can be schema-based or non-schema-based. It is thus similar to <code>insertXMLbefore</code>, but it inserts after, not before, the target node.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>insertXMLafter</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data that is the target of the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">successor-xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates zero or more nodes in <code><span class="codeinlineitalic">target-data</span></code> of any kind <span class="italic">except</span> attribute nodes. <code><span class="codeinlineitalic">XML-data</span></code> is inserted immediately after <span class="italic">each</span> of these nodes. Thus, the nodes in <code><span class="codeinlineitalic">XML-data</span></code> become succeeding siblings of each of the <code><span class="codeinlineitalic">successor-xpath</span></code> nodes.</p>
<p>If <code><span class="codeinlineitalic">successor-xpath</span></code> matches an empty sequence of nodes, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">successor-xpath</span></code> does not match a sequence of nodes that are not attribute nodes, then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">XML-data</span></code> (<code>XMLType</code>) &ndash; The XML data to be inserted: one or more nodes of <span class="italic">any kind</span>. The order of the nodes is preserved after the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<span class="italic">optional</span>, <code>VARCHAR2</code>) &ndash; The namespace for parameter <code><span class="codeinlineitalic">successor-xpath</span></code>.</p>
</li>
</ul>
<p>The <code><span class="codeinlineitalic">XML-data</span></code> nodes are inserted immediately after <span class="italic">each</span> of the non-attribute nodes located at <code><span class="codeinlineitalic">successor-xpath</span></code>.</p>
<p>Function <code>insertXMLafter</code> has the following behavior for <code>NULL</code> arguments:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">parent-xpath</span></code> is <code>NULL</code>, then <code>NULL</code> is returned.</p>
</li>
<li>
<p>Otherwise, if <code><span class="codeinlineitalic">child-data</span></code> is <code>NULL</code>, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged.</p>
</li>
</ul>
<p><a href="#CFHHHJBG">Figure 4-8</a> shows the syntax.</p>
<div id="ADXDB5808" class="figure">
<p class="titleinfigure"><a id="CFHHHJBG"></a>Figure 4-8 INSERTXMLAFTER Syntax</p>
<img width="756" height="46" src="img/insertxmlafter.gif" alt="Description of Figure 4-8 follows" /><br />
<a id="sthref347" href="img_text/insertxmlafter.htm">Description of "Figure 4-8 INSERTXMLAFTER Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Queries that use Oracle SQL function <code>insertXMLafter</code> are <span class="italic">not</span> optimized. For this reason, Oracle recommends that you use function <code>insertChildXML</code>, <code>insertChildXMLbefore</code>, or <code>insertChildXMLafter</code> instead. See <a href="xdb_xquery.htm#CBACDEEC">"Performance Tuning for XQuery"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDFGJHH"></a>
<div id="ADXDB4302" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref348"></a><a id="sthref349"></a>APPENDCHILDXML SQL Function</h3>
<p>Oracle SQL function <code>appendChildXML</code> inserts one or more nodes of any kind as the last children of a given element node. The XML document that is the target of the insertion can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>appendChildXML</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>)&ndash; The XML data containing the target parent element.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">parent-xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates zero or more <span class="italic">element</span> nodes in <code><span class="codeinlineitalic">target-data</span></code> that are the targets of the insertion operation. The <code><span class="codeinlineitalic">child-data</span></code> is inserted as the last child or children of <span class="italic">each</span> of these parent elements.</p>
<p>If <code><span class="codeinlineitalic">parent-xpath</span></code> matches an empty sequence of element nodes, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">parent-xpath</span></code> does not match a sequence of element nodes (in particular, if <code><span class="codeinlineitalic">parent-xpath</span></code> matches one or more <span class="italic">attribute</span> or <span class="italic">text</span> nodes), then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">child-data</span></code> (<code>XMLType</code>) &ndash; Child data to be inserted: one or more nodes of <span class="italic">any kind</span>. The order of the nodes is preserved after the insertion.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<span class="italic">optional</span>, <code>VARCHAR2</code>) &ndash; The namespace for parameter <code><span class="codeinlineitalic">parent-xpath</span></code>.</p>
</li>
</ul>
<p>XML data <code><span class="codeinlineitalic">child-data</span></code> is inserted as the last child or children of <span class="italic">each</span> of the element nodes indicated by <code><span class="codeinlineitalic">parent-xpath</span></code>.</p>
<p>Function <code>appendChildXML</code> has the following behavior for <code>NULL</code> arguments:</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">parent-xpath</span></code> is <code>NULL</code>, then <code>NULL</code> is returned.</p>
</li>
<li>
<p>Otherwise, if <code><span class="codeinlineitalic">child-data</span></code> is <code>NULL</code>, then no insertion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged.</p>
</li>
</ul>
<p><a href="#CFHDCHBE">Figure 4-9</a> shows the syntax.</p>
<div id="ADXDB4303" class="figure">
<p class="titleinfigure"><a id="CFHDCHBE"></a>Figure 4-9 APPENDCHILDXML Syntax</p>
<img width="758" height="46" src="img/appendchildxml.gif" alt="Description of Figure 4-9 follows" /><br />
<a id="sthref350" href="img_text/appendchildxml.htm">Description of "Figure 4-9 APPENDCHILDXML Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="ADXDB4304" class="example">
<p class="titleinexample"><a id="sthref351"></a>Example 4-21 Inserting a Date Element as the Last Child of an Action Element</p>
<pre>
SELECT XMLQuery('$p/PurchaseOrder/Actions/Action[1]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/ACTIONS/ACTION[1]'PASSINGPO.OBJECT_VALUE
-------------------------------------------------------------------
&lt;Action&gt;
  &lt;User&gt;KPARTNER&lt;/User&gt;
&lt;/Action&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = 
      <span class="bold">appendChildXML</span>(OBJECT_VALUE, 
                     'PurchaseOrder/Actions/Action[1]', 
                     XMLType('<span class="bold">&lt;Date&gt;2002-11-04&lt;/Date&gt;</span>'))
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLQuery('$p/PurchaseOrder/Actions/Action[1]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/ACTIONS/ACTION[1]'PASSINGPO.OBJECT_VALUE
-------------------------------------------------------------------
&lt;Action&gt;
  &lt;User&gt;KPARTNER&lt;/User&gt;
  <span class="bold">&lt;Date&gt;2002-11-04&lt;/Date&gt;</span>
&lt;/Action&gt;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Queries that use Oracle SQL function <code>appendChildXML</code> are <span class="italic">not</span> optimized. For this reason, Oracle recommends that you use function <code>insertChildXML</code>, <code>insertChildXMLbefore</code>, or <code>insertChildXMLafter</code> instead. See <a href="xdb_xquery.htm#CBACDEEC">"Performance Tuning for XQuery"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEGEDH"></a>
<div id="ADXDB4305" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref352"></a><a id="sthref353"></a>DELETEXML SQL Function</h3>
<p>Oracle SQL function <code>deleteXML</code> deletes XML nodes of any kind. The XML document that is the target of the deletion can be schema-based or non-schema-based.</p>
<p>A <span class="italic">copy</span> of the input <code>XMLType</code> instance is modified and returned. The original data is unaffected. You can then use the returned data with SQL operation <code>UPDATE</code> to modify database data.</p>
<p>Function <code>deleteXML</code> has the following parameters (in order):</p>
<ul>
<li>
<p><code><span class="codeinlineboldital">target-data</span></code> (<code>XMLType</code>) &ndash; The XML data containing the target nodes (to be deleted).</p>
</li>
<li>
<p><code><span class="codeinlineboldital">xpath</span></code> (<code>VARCHAR2</code>) &ndash; An XPath&nbsp;1.0 expression that locates zero or more nodes in <code><span class="codeinlineitalic">target-data</span></code> that are the targets of the deletion operation. <span class="italic">Each</span> of these nodes is deleted.</p>
<p>If <code><span class="codeinlineitalic">xpath</span></code> matches an empty sequence of nodes, then no deletion is done, and <code><span class="codeinlineitalic">target-data</span></code> is returned unchanged (no error is raised). If <code><span class="codeinlineitalic">xpath</span></code> matches the top-level element node, then an error is raised.</p>
</li>
<li>
<p><code><span class="codeinlineboldital">namespace</span></code> (<span class="italic">optional</span>, <code>VARCHAR2</code>) &ndash; The namespace for parameter <code><span class="codeinlineitalic">xpath</span></code>.</p>
</li>
</ul>
<p>The XML nodes located at <code><span class="codeinlineitalic">xpath</span></code> are deleted from <code><span class="codeinlineitalic">target-data</span></code>. Function <code>deleteXML</code> returns <code>NULL</code> if <code><span class="codeinlineitalic">target-data</span></code> or <code><span class="codeinlineitalic">xpath</span></code> is <code>NULL</code>.</p>
<p><a href="#CFHDEBHA">Figure 4-10</a> shows the syntax.</p>
<div id="ADXDB4306" class="figure">
<p class="titleinfigure"><a id="CFHDEBHA"></a>Figure 4-10 DELETEXML Syntax</p>
<img width="610" height="46" src="img/deletexml.gif" alt="Description of Figure 4-10 follows" /><br />
<a id="sthref354" href="img_text/deletexml.htm">Description of "Figure 4-10 DELETEXML Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="ADXDB4307" class="example">
<p class="titleinexample"><a id="sthref355"></a>Example 4-22 Deleting LineItem Element Number 222</p>
<pre>
SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[@ItemNumber=222]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[@ITEMNUMBER=222]'PASSINGPO
------------------------------------------------------------------------
&lt;LineItem ItemNumber="222"&gt;
  &lt;Description&gt;The Harder They Come&lt;/Description&gt;
  &lt;Part Id="953562951413" UnitPrice="22.95" Quantity="1"/&gt;
&lt;/LineItem&gt;

UPDATE purchaseorder
  SET OBJECT_VALUE = 
      <span class="bold">deleteXML</span>(OBJECT_VALUE, 
                '/PurchaseOrder/LineItems/LineItem[@ItemNumber="222"]')
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING OBJECT_VALUE AS "p");

SELECT XMLQuery('$p/PurchaseOrder/LineItems/LineItem[@ItemNumber=222]'
                PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM purchaseorder po
  WHERE XMLExists('$p/PurchaseOrder[Reference="AMCEWEN-20021009123336171PDT"]'
                  PASSING po.OBJECT_VALUE AS "p");

XMLQUERY('$P/PURCHASEORDER/LINEITEMS/LINEITEM[@ITEMNUMBER=222]'PASSINGPO
------------------------------------------------------------------------
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="partpg2.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb_xquery.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
