<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL APIs for XMLType</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:15Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="partpg3.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb_dbmstore.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">23/54</span> <!-- End Header -->
<div id="ADXDB1100" class="chapter"><a id="g1056962"></a>
<h1 class="chapter"><span class="secnum">13</span> PL/SQL APIs for XMLType</h1>
<p>This chapter describes the use of the APIs for <code>XMLType</code> in PL/SQL.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1034249">Overview of PL/SQL APIs for XMLType</a></p>
</li>
<li>
<p><a href="#i1034250">PL/SQL DOM API for XMLType (DBMS_XMLDOM)</a></p>
</li>
<li>
<p><a href="#i1046197">PL/SQL Parser API for XMLType (DBMS_XMLPARSER)</a></p>
</li>
<li>
<p><a href="#i1043472">PL/SQL XSLT Processor for XMLType (DBMS_XSLPROCESSOR)</a></p>
</li>
<li>
<p><a href="#BEIIBEGB">PL/SQL Translation API for XMLType (DBMS_XMLTRANSLATIONS)</a></p>
</li>
</ul>
<a id="i1034249"></a>
<div id="ADXDB4870" class="sect1">
<h2 class="sect1"><a id="sthref1030"></a>Overview of <a id="sthref1031"></a><a id="sthref1032"></a>PL/SQL APIs for XMLType</h2>
<p>This chapter describes the PL/SQL Application Program Interfaces (APIs) for <code>XMLType</code>. These include the following:</p>
<ul>
<li>
<p>PL/SQL Document Object Model (DOM) API for <code>XMLType</code> (package <code>DBMS_XMLDOM</code>): For accessing <code>XMLType</code> objects. You can access both XML schema-based and non-schema-based documents. Before database startup, you must specify the read-from and write-to directories in file <code>initialization.ORA</code>. For example:</p>
<pre>
UTL_FILE_DIR=/mypath/insidemypath
</pre>
<p>The read-from and write-to files must be on the server file system.</p>
<p>A <span class="glossaryterm"><a id="sthref1033"></a>DOM</span> is a tree-based object representation of an XML document in dynamic memory. It enables programmatic access to its elements and attributes. The DOM object and its interface is a W3C recommendation. It specifies the Document Object Model of an XML document including APIs for programmatic access. DOM views the parsed document as a tree of objects.</p>
</li>
<li>
<p>PL/SQL XML Parser API for <code>XMLType</code> (package <code>DBMS_XMLPARSER</code>): For accessing the content and structure of XML documents.</p>
</li>
<li>
<p>PL/SQL XSLT Processor for <code>XMLType</code> (package <code>DBMS_XSLPROCESSOR</code>): For transforming XML documents to other formats using XSLT.</p>
</li>
</ul>
<div id="ADXDB4871" class="sect2"><a id="sthref1034"></a>
<h3 class="sect2">API Features</h3>
<p>The PL/SQL APIs for <code>XMLType</code> allow you to perform the following tasks:</p>
<ul>
<li>
<p>Create <code>XMLType</code> tables, columns, and views</p>
</li>
<li>
<p>Construct <code>XMLType</code> instances from data encoded in different character sets.</p>
</li>
<li>
<p>Access <code>XMLType</code> data</p>
</li>
<li>
<p>Manipulate <code>XMLType</code> data</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb01int.htm#i1047269">"Oracle XML&nbsp;DB Features"</a>, for an overview of the Oracle XML&nbsp;DB architecture and new features.</p>
</li>
<li>
<p><a href="xdb04cre.htm#g1050045">Chapter 4, "XMLType Operations"</a></p>
</li>
<li>
<p><a class="olink ARPLS377" href="../../appdev.112/e40758/d_xmlsch.htm#ARPLS377"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
</ul>
</div>
</li>
</ul>
<div id="ADXDB4872" class="sect3"><a id="sthref1035"></a>
<h4 class="sect3">Lazy Loading of XML Data (<a id="sthref1036"></a><a id="sthref1037"></a><a id="sthref1038"></a>Lazy Manifestation)</h4>
<p>Because <code>XMLType</code> provides a dynamic memory or virtual Document Object Model (DOM), it can use a memory conserving process called <span class="bold">lazy XML loading</span>, also sometimes referred to as <span class="bold">lazy manifestation</span>. This process optimizes memory usage by only loading rows of data when they are requested. It throws away previously-referenced sections of the document if memory usage grows too large. Lazy XML loading supports highly scalable applications that have many concurrent users needing to access large XML documents.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4873" class="sect3"><a id="sthref1039"></a>
<h4 class="sect3">XMLType Data Type Supports XML Schema</h4>
<p>The <code>XMLType</code> data type includes support for XML schemas. You can create an XML schema and annotate it with mappings from XML to object-relational storage. To take advantage of the PL/SQL DOM API, first create an XML schema and register it. Then, when you create <code>XMLType</code> tables and columns, you can specify that these conform to the registered XML schema.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4874" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1040"></a>
<h4 class="sect3">XMLType Supports Data in Different Character Sets</h4>
<p><code>XMLType</code> instances can be created from data encoded in any Oracle-supported character set by using the PL/SQL <code>XMLType</code> constructor or <code>XMLType</code> method <code><a id="sthref1041"></a><a id="sthref1042"></a><a id="sthref1043"></a>createXML()</code>. The source XML data must be supplied using data type <code>BFILE</code> or <code>BLOB</code>. The encoding of the data is specified through argument <code>csid</code>. When this argument is zero (<code>0</code>), the encoding of the source data is determined from the XML prolog, as specified in Appendix F of the XML 1.0 Reference.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<span class="italic">AL32UTF8</span> is the Oracle Database character set that is appropriate for <code>XMLType</code> data. It is equivalent to the IANA registered standard UTF-8 encoding, which supports all valid XML characters.
<p>Do not confuse Oracle Database database character set UTF8 (no hyphen) with database character set AL32UTF8 or with character <span class="italic">encoding</span> UTF-8. Database character set UTF8 has been <span class="italic">superseded</span> by AL32UTF8. Do <span class="italic">not</span> use UTF8 for XML data. Character set UTF8 supports only Unicode version 3.1 and earlier. It does not support all valid XML characters. AL32UTF8 has no such limitation.</p>
<p>Using database character set UTF8 for XML data could potentially <span class="italic">stop a system or affect security negatively</span>. If a character that is not supported by the database character set appears in an input-document element name, a replacement character (usually "<code>?</code>") is substituted for it. This terminates parsing and raises an exception. It could cause an irrecoverable error.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1034250"></a>
<div id="ADXDB4875" class="sect1">
<h2 class="sect1"><a id="sthref1044"></a><a id="sthref1045"></a>PL/SQL <a id="sthref1046"></a>DOM API for XMLType (<a id="sthref1047"></a>DBMS_XMLDOM)</h2>
<p>This section describes the PL/SQL DOM API for <code>XMLType</code>, <code>DBMS_XMLDOM</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS399" href="../../appdev.112/e40758/d_xmldom.htm#ARPLS399"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for descriptions of the individual <code>DBMS_XMLDOM</code> methods</div>
<div id="ADXDB4876" class="sect2"><a id="sthref1048"></a>
<h3 class="sect2">Overview of the W3C Document Object Model (<a id="sthref1049"></a>DOM) Recommendation</h3>
<p>Skip this section if you are familiar with the generic DOM specifications recommended by the World Wide Web Consortium (W3C).</p>
<p>The Document Object Model (DOM) recommended by the W3C is a universal API for accessing the structure of XML documents. It was originally developed to formalize Dynamic HTML, which is used for animation, interaction, and dynamic updating of Web pages. DOM provides a language-neutral and platform-neutral object model for Web pages and XML documents. DOM describes language-independent and platform-independent interfaces to access and operate on XML components and elements. It expresses the structure of an XML document in a universal, content-neutral way. Applications can be written to dynamically delete, add, and edit the content, attributes, and style of XML documents. DOM makes it possible to create applications that work properly on all browsers, servers, and platforms.</p>
<div id="ADXDB4877" class="sect3"><a id="sthref1050"></a>
<h4 class="sect3">Oracle XML Developer's Kit Extensions to the W3C DOM Standard</h4>
<p>Oracle XML Developer's Kit (XDK) extends the W3C DOM API in various ways. All of these extensions are supported by Oracle XML&nbsp;DB except those relating to client-side operations that are not applicable in the database. This type of procedural processing is available through the Simple API for XML (SAX) interface in the Oracle XML Developer's Kit Java and C components.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDK" href="../e23582/toc.htm"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a></div>
</div>
<!-- class="sect3" -->
<div id="ADXDB4878" class="sect3"><a id="sthref1051"></a>
<h4 class="sect3">Supported W3C DOM Recommendations</h4>
<p>All Oracle XML&nbsp;DB APIs for accessing and manipulating XML comply with standard XML processing requirements as approved by the W3C. The PL/SQL DOM supports Levels 1 and 2 from the W3C DOM specifications.</p>
<ul>
<li>
<p>In Oracle9<span class="italic">i</span> release 1 (9.0.1), Oracle XML Developer's Kit for PL/SQL implemented DOM Level 1.0 and parts of DOM Level 2.0.</p>
</li>
<li>
<p>In Oracle9<span class="italic">i</span> release 2 (9.2) and Oracle Database 10<span class="italic">g</span> release 1 (10.1), the PL/SQL API for <code>XMLType</code> implements DOM Levels 1.0 and Level 2.0 Core, and is fully integrated in the database through extensions to the <code>XMLType</code> API.</p>
</li>
</ul>
<p>The following briefly describes each level:</p>
<ul>
<li>
<p><span class="bold">DOM Level 1.0 &ndash;</span> The first formal Level of the DOM specifications, completed in October 1998. Level 1.0 defines support for XML 1.0 and HTML.</p>
</li>
<li>
<p><span class="bold">DOM Level 2.0 &ndash;</span> Completed in November 2000, Level 2.0 extends Level 1.0 with support for XML 1.0 with namespaces and adds support for Cascading Style Sheets (CSS) and events (user-interface events and tree manipulation events), and enhances tree manipulations (tree ranges and traversal mechanisms). CSS are a simple mechanism for adding style (fonts, colors, spacing, and so on) to Web documents.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADXDB4879" class="sect3"><a id="sthref1052"></a>
<h4 class="sect3"><a id="sthref1053"></a>Difference Between DOM and SAX</h4>
<p>The generic APIs for XML can be classified in two main categories:</p>
<ul>
<li>
<p>Tree-based. DOM is the primary generic tree-based API for XML<span class="italic">.</span></p>
</li>
<li>
<p>Event-based. SAX (Simple API for XML) is the primary generic event-based programming interface between an XML parser and an XML application.</p>
</li>
</ul>
<p>DOM works by creating objects. These objects have child objects and properties, and the child objects have child objects and properties, and so on. Objects are referenced either by moving down the object hierarchy or by explicitly giving an HTML element an ID attribute. For example:</p>
<pre>
&lt;img src="employee_jdoe.gif" ID="0123jdoe"&gt;
</pre>
<p>Examples of structural manipulations are:</p>
<ul>
<li>
<p>Reordering elements</p>
</li>
<li>
<p>Adding or deleting elements</p>
</li>
<li>
<p>Adding or deleting attributes</p>
</li>
<li>
<p>Renaming elements</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><code><a href="http://www.w3.org/DOM/">http://www.w3.org/DOM/</a></code> for information about DOM</p>
</li>
<li>
<p><code><a href="http://www.saxproject.org/">http://www.saxproject.org/</a></code> for information about SAX</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4880" class="sect2"><a id="sthref1054"></a>
<h3 class="sect2">PL/SQL DOM API for XMLType (DBMS_XMLDOM): Features</h3>
<p>Oracle XML&nbsp;DB extends the Oracle Database XML development platform beyond SQL support for storage and retrieval of XML data. It lets you operate on <code>XMLType</code> instances using DOM in PL/SQL, Java, and C.</p>
<p>The <span class="italic">default</span> action for the PL/SQL DOM API for <code>XMLType</code> (<code>DBMS_XMLDOM</code>) is to do the following:</p>
<ul>
<li>
<p>Produce a parse tree that can be accessed by DOM APIs.</p>
</li>
<li>
<p>Validate, if a DTD is found. Otherwise, do not validate.</p>
</li>
<li>
<p>Raise an application error if parsing fails.</p>
</li>
</ul>
<p>DTD validation occurs when the object document is manifested. If lazy manifestation is employed, then the document is validated when it is used.</p>
<p>The PL/SQL DOM API exploits a C-based representation of XML in the server and operates on XML schema-based XML instances. The PL/SQL, Java, and C DOM APIs for <code>XMLType</code> comply with the W3C DOM Recommendations to define and implement structured storage of XML data in relational or object-relational columns and as dynamic memory instances of <code>XMLType</code>. See <a href="#i1043032">"Preparing XML Data to Use the PL/SQL DOM API for XMLType"</a>, for a description of W3C DOM Recommendations.</p>
<div id="ADXDB6003" class="sect3"><a id="sthref1055"></a>
<h4 class="sect3">XML Schema Support</h4>
<p>The PL/SQL DOM API for <code>XMLType</code> supports XML schema. Oracle XML&nbsp;DB uses annotations within an XML schema as metadata to determine the structure of an XML document and the mapping of the document to a database schema.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
For backward compatibility and flexibility, the PL/SQL DOM supports both XML schema-based documents and non-schema-based documents.</div>
<p>After an XML schema is registered with Oracle XML&nbsp;DB, the PL/SQL DOM API for <code>XMLType</code> builds a tree representation of an associated XML document in dynamic memory as a hierarchy of node objects, each with its own specialized interfaces. Most node object types can have child node types, which in turn implement additional, more specialized interfaces. Nodes of some node types can have child nodes of various types, while nodes of other node types must be leaf nodes, which do not have child nodes.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4882" class="sect3"><a id="sthref1056"></a>
<h4 class="sect3">Enhanced Performance</h4>
<p>Oracle XML&nbsp;DB uses DOM to provide a standard way to translate data between XML and multiple back-end data sources. This eliminates the need to use separate XML translation techniques for the different data sources in your environment. Applications needing to exchange XML data can use a single native XML database to cache XML documents. Oracle XML&nbsp;DB can thus speed up application performance by acting as an intermediate cache between your Web applications and your back-end data sources, whether they are in relational databases or file systems.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb11jav.htm#g1039140">Chapter 15, "Java DOM API for XMLType"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4883" class="sect2"><a id="sthref1057"></a>
<h3 class="sect2">Designing End-to-End Applications using Oracle XML Developer's Kit and Oracle XML&nbsp;DB</h3>
<p>When you build applications based on Oracle XML&nbsp;DB, you do not need the additional components in Oracle XML Developer's Kit. However, you can use Oracle XML Developer's Kit components with Oracle XML&nbsp;DB to deploy a full suite of XML-enabled applications that run end-to-end. You can use features in Oracle XML Developer's Kit for:</p>
<ul>
<li>
<p>Simple API for XML (SAX) interface processing. SAX is an XML standard interface provided by XML parsers and used by procedural and event-based applications.</p>
</li>
<li>
<p>DOM interface processing, for structural and recursive object-based processing.</p>
</li>
</ul>
<p>Oracle XML Developer's Kit contain the basic building blocks for creating applications that run on a client, in a browser or a plug-in. Such applications typically read, manipulate, transform and view XML documents. To provide a broad variety of deployment options, Oracle XML Developer's Kit is available for Java, C, and C++. Oracle XML Developer's Kit is fully supported and comes with a commercial redistribution license.</p>
<p>Oracle XML Developer's Kit for Java consists of these components:</p>
<ul>
<li>
<p><span class="bold">XML Parsers &ndash;</span> Creates and parses XML using industry standard DOM and SAX interfaces. Supports Java, C, C++, and the Java API for XML Processing (JAXP).</p>
</li>
<li>
<p><span class="bold">XSL Processor &ndash;</span> Transforms or renders XML into other text-based formats such as HTML. Supports Java, C, and C++.</p>
</li>
<li>
<p><span class="bold">XML Schema Processor &ndash;</span> Uses XML simple and complex data types. Supports Java, C, and C++.</p>
</li>
<li>
<p><span class="bold">XML Class Generator, Oracle JAXB Class Generator &ndash;</span> Automatically generate C++ and Java classes, respectively, from DTDs and XML schemas, to send XML data from Web forms or applications. Class generators accept an input file and create a set of output classes that have corresponding functionality. For the XML Class Generator, the input file is a DTD, and the output is a series of classes that can be used to create XML documents conforming with the DTD.</p>
</li>
<li>
<p><span class="bold">XML SQL Utility &ndash;</span> Generates XML documents, DTDs, and XML schemas from SQL queries. Supports Java.</p>
</li>
<li>
<p><span class="bold">TransX Utility &ndash;</span> Loads data encapsulated in XML into the database. Has additional functionality useful for installations.</p>
</li>
<li>
<p><span class="bold">XML Pipeline Processor &ndash;</span> Invokes Java processes through XML control files.</p>
</li>
<li>
<p><span class="bold">XSLT VM and Compiler &ndash;</span> Provides a high-performance C-based XSLT transformation engine that uses compiled style sheets.</p>
</li>
<li>
<p><span class="bold">XML Java Beans &ndash;</span> Parses, transforms, compares, retrieves, and compresses XML documents using Java components.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDK" href="../e23582/toc.htm"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1043032"></a>
<div id="ADXDB4884" class="sect2">
<h3 class="sect2">Preparing XML Data to Use the PL/SQL DOM API for XMLType</h3>
<p>To prepare data for using PL/SQL DOM APIs in Oracle XML&nbsp;DB:</p>
<ol>
<li>
<p>Create a standard XML schema.</p>
</li>
<li>
<p>Annotate the XML schema with definitions for the SQL objects you use.</p>
</li>
<li>
<p>Register the XML schema, to generate the necessary database mappings.</p>
</li>
</ol>
<p>You can then do any of the following:</p>
<ul>
<li>
<p>Use <code>XMLType</code> views to wrap existing relational or object-relational data in XML formats, making it available to your applications in XML form. See <a href="#i1043091">"Wrapping Existing Data into XML with XMLType Views"</a>.</p>
</li>
<li>
<p>Insert XML data into <code>XMLType</code> columns.</p>
</li>
<li>
<p>Use Oracle XML&nbsp;DB PL/SQL and Java DOM APIs to manipulate XML data stored in <code>XMLType</code> columns and tables.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4885" class="sect2"><a id="sthref1058"></a>
<h3 class="sect2"><a id="sthref1059"></a>Defining an XML Schema Mapping to SQL Object Types</h3>
<p>An XML schema must be registered before it can be referenced by an XML document. When you register an XML schema, elements and attributes it declares are mapped to attributes of corresponding SQL object types within the database.</p>
<p>After XML schema registration, XML documents that conform to the XML schema and reference it can be managed by Oracle XML&nbsp;DB. Tables and columns for storing the conforming documents can be created for root elements defined by the XML schema.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb05sto.htm#g1070409">Chapter 7, "XML Schema Storage and Query: Basic"</a></div>
<p>An XML schema is registered by using PL/SQL package <code>DBMS_XMLSCHEMA</code> and by specifying the schema document and its <span class="italic">schema-location URL</span>. This URL is a name that uniquely identifies the registered schema within the databas. It need not correspond to any real location&thinsp;&mdash;&thinsp;in particular, it need not indicate where the schema document is located.</p>
<p>The <span class="italic">target namespace</span> of the schema is another URL used in the XML schema. It specifies a namespace for the XML-schema elements and types. An XML document should specify both the namespace of the root element and the schema-location URL identifying the schema that defines this element.</p>
<p>When documents are inserted into Oracle XML&nbsp;DB using path-based protocols such as HTTP(S) and FTP, the XML schema to which the document conforms is <span class="italic">registered implicitly</span>, provided its name and location are specified and it has not yet been registered.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS377" href="../../appdev.112/e40758/d_xmlsch.htm#ARPLS377"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> descriptions of the individual <code>DBMS_XMLSCHEMA</code> methods</div>
<div id="ADXDB4886" class="sect3"><a id="sthref1060"></a>
<h4 class="sect3">DOM <a id="sthref1061"></a><a id="sthref1062"></a>Fidelity for XML Schema Mapping</h4>
<p>Elements and attributes declared within the XML schema get mapped to separate attributes of the corresponding SQL object type. Other information encoded in an XML document, such as comments, processing instructions, namespace declarations and prefix definitions, and whitespace, is not represented directly.</p>
<p>To store this additional information, binary attribute <code>SYS_XDBPD$</code> is present in all generated SQL object types. This database attribute stores all information in the original XML document that is not stored using the other database attributes. Retaining this accessory information ensures <span class="italic">DOM fidelity</span> for XML documents stored in Oracle XML&nbsp;DB: an XML document retrieved from the database is identical to the original document that was stored.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this book, the <code>SYS_XDBPD$</code> attribute has been omitted from most examples, for simplicity. However, the attribute is always present in SQL object types generated by schema registration.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1043091"></a>
<div id="ADXDB4887" class="sect2">
<h3 class="sect2"><a id="sthref1063"></a>Wrapping Existing Data into XML with XMLType Views</h3>
<p>To make existing relational and object-relational data available to your XML applications, you can create <code>XMLType</code> views, wrapping the data in an XML format. You can then access this XML data using the PL/SQL DOM API.</p>
<p>After you register an XML schema containing annotations that represent the mapping between XML types and SQL object types, you can create an <code>XMLType</code> view that conforms to the XML schema.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb14vie.htm#CJIDAFJI">Chapter 19, "XMLType Views"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1046180"></a>
<div id="ADXDB4888" class="sect2">
<h3 class="sect2">DBMS_XMLDOM Methods Supported</h3>
<p>All <code>DBMS_XMLDOM</code> methods are supported by Oracle XML&nbsp;DB, with the <span class="italic">exception</span> of the following:</p>
<ul>
<li>
<p><code>writeExternalDTDToFile()</code></p>
</li>
<li>
<p><code>writeExternalDTDToBuffer()</code></p>
</li>
<li>
<p><code>writeExternalDTDToClob()</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS399" href="../../appdev.112/e40758/d_xmldom.htm#ARPLS399"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for descriptions of the individual <code>DBMS_XMLDOM</code> methods</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4889" class="sect2"><a id="sthref1064"></a>
<h3 class="sect2">PL/SQL DOM API for XMLType: Node Types</h3>
<p>In the DOM specification, the term "<span class="bold"><a id="sthref1065"></a><a id="sthref1066"></a>document</span>" is used to describe a container for many different kinds of information or data, which the DOM objectifies. The DOM specifies the way elements within an XML document container are used to create an object-based tree structure and to define and expose interfaces to manage and use the objects stored in XML documents. Additionally, the DOM supports storage of documents in diverse systems.</p>
<p>When a request such as <code>getNodeType(myNode)</code> is given, it returns <code>myNodeType</code>, which is the node type supported by the parent node. These constants represent the different types that a node can adopt:</p>
<ul>
<li>
<p><code>ELEMENT_NODE</code></p>
</li>
<li>
<p><code>ATTRIBUTE_NODE</code></p>
</li>
<li>
<p><code>TEXT_NODE</code></p>
</li>
<li>
<p><code>CDATA_SECTION_NODE</code></p>
</li>
<li>
<p><code>ENTITY_REFERENCE_NODE</code></p>
</li>
<li>
<p><code>ENTITY_NODE</code></p>
</li>
<li>
<p><code>PROCESSING_INSTRUCTION_NODE</code></p>
</li>
<li>
<p><code>COMMENT_NODE</code></p>
</li>
<li>
<p><code>DOCUMENT_NODE</code></p>
</li>
<li>
<p><code>DOCUMENT_TYPE_NODE</code></p>
</li>
<li>
<p><code>DOCUMENT_FRAGMENT_NODE</code></p>
</li>
<li>
<p><code>NOTATION_NODE</code></p>
</li>
</ul>
<p><a href="#g1047756">Table 13-1</a> shows the node types for XML and HTML and the allowed corresponding children node types.</p>
<div id="ADXDB4890" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref1067"></a><a id="g1047756"></a>Table 13-1 XML and HTML DOM Node Types and Their Child Node Types</p>
<table class="cellalignment1032" title="XML and HTML DOM Node Types and Their Child Node Types " summary="This table describes the XML and HTML DOM node types and children node types supported in DBMS_XMLDOM." dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t15">Node Type</th>
<th class="cellalignment1027" id="r1c2-t15">Children Node Types</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t15" headers="r1c1-t15">
<pre>
Document
</pre></td>
<td class="cellalignment1028" headers="r2c1-t15 r1c2-t15">
<p><code>Element</code> (maximum of one), <code>ProcessingInstruction</code>, <code>Comment</code>, <code>DocumentType</code> (maximum of one)</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t15" headers="r1c1-t15">
<pre>
DocumentFragment
</pre></td>
<td class="cellalignment1028" headers="r3c1-t15 r1c2-t15">
<p><code>Element</code>, <code>ProcessingInstruction</code>, <code>Comment</code>, <code>Text</code>, <code>CDATASection</code>, <code>EntityReference</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t15" headers="r1c1-t15">
<pre>
DocumentType
</pre></td>
<td class="cellalignment1028" headers="r4c1-t15 r1c2-t15">
<p>No children</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t15" headers="r1c1-t15">
<pre>
EntityReference
</pre></td>
<td class="cellalignment1028" headers="r5c1-t15 r1c2-t15">
<p><code>Element</code>, <code>ProcessingInstruction</code>, <code>Comment</code>, <code>Text</code>, <code>CDATASection</code>, <code>EntityReference</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t15" headers="r1c1-t15">
<pre>
Element
</pre></td>
<td class="cellalignment1028" headers="r6c1-t15 r1c2-t15">
<p><code>Element</code>, <code>Text</code>, <code>Comment</code>, <code>ProcessingInstruction</code>, <code>CDATASection</code>, <code>EntityReference</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t15" headers="r1c1-t15">
<pre>
Attr
</pre></td>
<td class="cellalignment1028" headers="r7c1-t15 r1c2-t15">
<p><code>Text</code>, <code>EntityReference</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t15" headers="r1c1-t15">
<pre>
ProcessingInstruction
</pre></td>
<td class="cellalignment1028" headers="r8c1-t15 r1c2-t15">
<p>No children</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t15" headers="r1c1-t15">
<pre>
Comment
</pre></td>
<td class="cellalignment1028" headers="r9c1-t15 r1c2-t15">
<p>No children</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t15" headers="r1c1-t15">
<pre>
Text
</pre></td>
<td class="cellalignment1028" headers="r10c1-t15 r1c2-t15">
<p>No children</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t15" headers="r1c1-t15">
<pre>
CDATASection
</pre></td>
<td class="cellalignment1028" headers="r11c1-t15 r1c2-t15">
<p>No children</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t15" headers="r1c1-t15">
<pre>
Entity
</pre></td>
<td class="cellalignment1028" headers="r12c1-t15 r1c2-t15">
<p><code>Element</code>, <code>ProcessingInstruction</code>, <code>Comment</code>, <code>Text</code>, <code>CDATASection</code>, <code>EntityReference</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r13c1-t15" headers="r1c1-t15">
<pre>
Notation
</pre></td>
<td class="cellalignment1028" headers="r13c1-t15 r1c2-t15">
<p>No children</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>Oracle XML&nbsp;DB DOM API for <code>XMLType</code> also specifies these interfaces:</p>
<ul>
<li>
<p><span class="bold">A</span> <span class="bold">NodeList</span> <span class="bold">interface</span> to handle ordered lists of Nodes, for example:</p>
<ul>
<li>
<p>The children of a Node</p>
</li>
<li>
<p>Elements returned by method <code>getElementsByTagName()</code> of the element interface</p>
</li>
</ul>
</li>
<li>
<p><span class="bold">A</span> <span class="bold">NamedNodeMap</span> <span class="bold">interface</span> to handle unordered sets of nodes, referenced by their name attribute, such as the attributes of an element.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4891" class="sect2"><a id="sthref1068"></a>
<h3 class="sect2">Working with XML Schema-Based Data</h3>
<p>Oracle Database has several extensions for character-set conversion and input and output to and from a file system. PL/SQL API for <code>XMLType</code> is optimized to operate on XML schema-based XML instances. Function <code><a id="sthref1069"></a>newDOMDocument</code> constructs a DOM document handle, given an <code>XMLType</code> value.</p>
<p>A typical usage scenario would be for a PL/SQL application to:</p>
<ol>
<li>
<p>Fetch or construct an <code>XMLType</code> instance</p>
</li>
<li>
<p>Construct a <code>DOMDocument</code> node over the <code>XMLType</code> instance</p>
</li>
<li>
<p>Use the DOM API to access and manipulate the XML data</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For <code>DOMDocument</code>, node types represent handles to XML fragments but do not represent the data itself.
<p>For example, if you copy a node value, <code>DOMDocument</code> clones the handle to the same underlying data. Any data modified by one of the handles is visible when accessed by the other handle. The <code>XMLType</code> value from which the <code>DOMDocument</code> handle is constructed is the data, and reflects the results of all DOM operations on it.</p>
</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="ADXDB4892" class="sect2"><a id="sthref1070"></a>
<h3 class="sect2"><a id="sthref1071"></a><a id="sthref1072"></a><a id="sthref1073"></a><a id="sthref1074"></a>DOM NodeList and NamedNodeMap Objects</h3>
<p>Changes to the underlying document structure are reflected in all relevant <code>NodeList</code> and <code>NamedNodeMap</code> objects.</p>
<p>For example, if a DOM user gets a <code>NodeList</code> object containing the children of an element, and then subsequently adds more children to that element (or removes children, or modifies them), then those changes are automatically propagated in the <code>NodeList</code>, without additional action from the user. Likewise, changes to a node in the tree are propagated throughout all references to that node in <code>NodeList</code> and <code>NamedNodeMap</code> objects.</p>
<p>The interfaces: <code>Text</code>, <code>Comment</code>, and <code>CDATASection,</code> all inherit from the <code><a id="sthref1075"></a>CharacterData</code> interface.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB4893" class="sect2"><a id="sthref1076"></a>
<h3 class="sect2">Using the PL/SQL DOM API for XMLType (DBMS_XMLDOM)</h3>
<p><a href="#i1043435">Figure 13-1</a> illustrates the use of PL/SQL DOM API for <code>XMLType</code> (<code>DBMS_XMLDOM</code>).</p>
<p>You can create a DOM document (<code>DOMDocument</code>) from an existing <code>XMLType</code> or as an empty document.</p>
<ol>
<li>
<p>The <code>newDOMDocument</code> procedure processes the <code>XMLType</code> instance or empty document. This creates a <code>DOMDocument</code> instance.</p>
</li>
<li>
<p>You can use DOM API PL/SQL methods such as <code>createElement()</code>, <code>createText()</code>, <code>createAttribute()</code>, and <code>createComment()</code> to traverse and extend the DOM tree.</p>
</li>
<li>
<p>The results of PL/SQL methods such as <code>DOMElement()</code> and <code>DOMText()</code> can also be passed to PL/SQL function <code>makeNode</code> to obtain the <code>DOMNode</code> interface.</p>
</li>
</ol>
<div id="ADXDB4894" class="figure">
<p class="titleinfigure"><a id="i1043435"></a>Figure 13-1 Using the PL/SQL DOM API for XMLType</p>
<img width="511" height="399" src="img/adxdb014.gif" alt="Description of Figure 13-1 follows" /><br />
<a id="sthref1077" href="img_text/adxdb014.htm">Description of "Figure 13-1 Using the PL/SQL DOM API for XMLType"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<div id="ADXDB4895" class="sect2"><a id="sthref1078"></a>
<h3 class="sect2"><a id="sthref1079"></a>PL/SQL DOM API for XMLType &ndash; Examples</h3>
<p>This section presents examples of using the PL/SQL DOM API for <code>XMLType</code>.</p>
<p>Remember to call procedure <code><a id="sthref1080"></a><a id="sthref1081"></a><a id="sthref1082"></a>freeDocument</code> for <span class="italic">each</span> <code>DOMDocument</code> instance, when you are through with the instance. This procedure frees the document and all of its nodes. You can still access <code>XMLType</code> instances on which <code>DOMDocument</code> instances were built, even after the <code>DOMDocument</code> instances have been freed.</p>
<p><a href="#CHDHAJEC">Example 13-1</a> creates a hierarchical, representation of an XML document in dynamic memory: a DOM document.</p>
<div id="ADXDB4896" class="example">
<p class="titleinexample"><a id="CHDHAJEC"></a>Example 13-1 Creating and Manipulating a DOM Document</p>
<pre>
CREATE TABLE person OF XMLType;

DECLARE 
  var       XMLType; 
  doc       DBMS_XMLDOM.DOMDocument; 
  ndoc      DBMS_XMLDOM.DOMNode; 
  docelem   DBMS_XMLDOM.DOMElement;
  node      DBMS_XMLDOM.DOMNode; 
  childnode DBMS_XMLDOM.DOMNode; 
  nodelist  DBMS_XMLDOM.DOMNodelist;
  buf       VARCHAR2(2000);
BEGIN 
  var := XMLType('&lt;PERSON&gt;&lt;NAME&gt;<span class="bold">ramesh</span>&lt;/NAME&gt;&lt;/PERSON&gt;');

  -- Create DOMDocument handle
  doc     := DBMS_XMLDOM.newDOMDocument(var); 
  ndoc    := DBMS_XMLDOM.makeNode(doc);

  DBMS_XMLDOM.writeToBuffer(ndoc, buf);
  DBMS_OUTPUT.put_line('<span class="bold">Before:</span>'||buf);

  docelem := DBMS_XMLDOM.getDocumentElement(doc);

  -- Access element
  nodelist := DBMS_XMLDOM.getElementsByTagName(docelem, '<span class="bold">NAME</span>');
  node := DBMS_XMLDOM.item(nodelist, 0);
  childnode := DBMS_XMLDOM.getFirstChild(node);

  -- Manipulate element
  DBMS_XMLDOM.setNodeValue(childnode, '<span class="bold">raj</span>');
  DBMS_XMLDOM.writeToBuffer(ndoc, buf);
  DBMS_OUTPUT.put_line('<span class="bold">After:</span>'||buf);
  DBMS_XMLDOM.freeDocument(doc);
  INSERT INTO person VALUES (var);
END;
/
</pre>
<p>This produces the following output:</p>
<pre>
Before:&lt;PERSON&gt;
  &lt;NAME&gt;<span class="bold">ramesh</span>&lt;/NAME&gt;
&lt;/PERSON&gt;
 
After:&lt;PERSON&gt;
  &lt;NAME&gt;<span class="bold">raj</span>&lt;/NAME&gt;
&lt;/PERSON&gt;
</pre>
<p>This query confirms that the data has changed:</p>
<pre>
SELECT * FROM person;
SYS_NC_ROWINFO$
---------------
&lt;PERSON&gt;
  &lt;NAME&gt;<span class="bold">raj</span>&lt;/NAME&gt;
&lt;/PERSON&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHDHAJEC">Example 13-1</a> uses a <span class="italic">handle</span> to the DOM document to manipulate it: print it, change part of it, and print it again after the change. Manipulating the DOM document by its handle also indirectly affects the XML data represented by the document, so that querying that data after the change shows the changed result.</p>
<p>The DOM document is created from an <code>XMLType</code> variable using PL/SQL function <code>newDOMDocument</code>. The handle to this document is created using function <code>makeNode</code>. The document is written to a <code>VARCHAR2</code> buffer using function <code>writeToBuffer</code>, and the buffer is printed using <code>DBMS_OUTPUT.put_line</code>.</p>
<p>After manipulating the document using various <code>DBMS_XMLDOM</code> procedures, the (changed) data in the <code>XMLType</code> variable is inserted into a table and queried, showing the change. It is only when the data is inserted into a database table that it becomes persistent. Until then, it exists in memory only. This persistence is demonstrated by the fact that the database query is made after the document (<code>DOMDocument</code> instance) has been freed from dynamic memory.</p>
<p><a href="#BEIDGEJC">Example 13-2</a> creates an empty DOM document, and then adds an element node (<code>&lt;ELEM&gt;</code>) to the document. <code>DBMS_XMLDOM</code> API node procedures are used to obtain the name (<code>&lt;ELEM&gt;</code>), value (<code>NULL</code>), and type (<code>1</code> = element node) of the element node.</p>
<div id="ADXDB4897" class="example">
<p class="titleinexample"><a id="BEIDGEJC"></a>Example 13-2 Creating an Element Node and Obtaining Information About It</p>
<pre>
DECLARE
  doc   DBMS_XMLDOM.DOMDocument;
  elem  DBMS_XMLDOM.DOMElement;
  nelem DBMS_XMLDOM.DOMNode;
BEGIN
  doc := DBMS_XMLDOM.newDOMDocument;
  elem := DBMS_XMLDOM.createElement(doc, 'ELEM');
  nelem := DBMS_XMLDOM.makeNode(elem);
  DBMS_OUTPUT.put_line('Node name = ' || DBMS_XMLDOM.getNodeName(nelem));
  DBMS_OUTPUT.put_line('Node value = '|| DBMS_XMLDOM.getNodeValue(nelem));
  DBMS_OUTPUT.put_line('Node type = ' || DBMS_XMLDOM.getNodeType(nelem));
  DBMS_XMLDOM.freeDocument(doc);
END;
/
</pre>
<p>This produces the following output:</p>
<pre>
Node name = ELEM
Node value =
Node type = 1
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDDHHEG"></a>
<div id="ADXDB4898" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1083"></a>Large <a id="sthref1084"></a>Node Handling using DBMS_XMLDOM</h3>
<p>Prior to Oracle Database 11g Release 1 (11.1), each text node or attribute value processed by Oracle XML&nbsp;DB was limited in size to 64 K bytes. Starting with release 11.1, this restriction no longer applies.</p>
<p>To overcome this size limitation and allow nodes to contain graphics files, PDF files, and multibyte character encodings, the following abstract streams are available. These abstract PL/SQL streams are analogous to the corresponding Java streams. Each input stream has an associated writer, or data producer, and each output stream has an associated reader, or data consumer.</p>
<ol>
<li>
<p><span class="bold">Binary Input Stream:</span> This provides the data consumer with read-only access to source data, as a sequential (non-array) linear space of bytes. The consumer has iterative read access to underlying source data (whatever representation) in binary format, that is, read access to source data in unconverted, "raw" format. The consumer sees a sequence of bytes as they exist in the node. There is no specification of the format or representation of the source data. In particular, there is no associated character set.</p>
</li>
<li>
<p><span class="bold">Binary Output Stream:</span> This provides the data producer with write-only access to target data as a sequential (non-array) linear space of bytes. The producer has iterative write access to target data in binary format, that is, write access to target data in pure binary format with no data semantics at all. The producer passes a sequence of bytes and the target data is replaced by these bytes. No data conversion occurs.</p>
</li>
<li>
<p><span class="bold">Character Input Stream:</span> This provides the data consumer iterative read-only access to source data as a sequential (non-array) linear space of characters, independent of the representation and format of the source data. Conversion of the source data may or may not occur.</p>
</li>
<li>
<p><span class="bold">Character Output Stream:</span> This provides the data producer with iterative write-only access to target data as a sequential (non-array) linear space of characters. The producer passes a sequence of characters and the target data is replaced by this sequence of characters. Conversion of the passed data may or may not occur.</p>
</li>
</ol>
<p>Each of the input streams has the following abstract methods: open, read, and close. Each of the output streams has the following abstract methods: open, write, flush, and close. For output streams, you must close the stream before any nodes are physically written.</p>
<p>There are four general node access models, for reading and writing. Each access model has both binary and character versions. Binary and character stream methods defined on data type <code>DOMNode</code> realize these access models. Each access model is described in a separate section, with an explanation of the PL/SQL functions and procedures in package <code>DBMS_XMLDOM</code> that operate on large nodes.</p>
<ul>
<li>
<p><a href="#BEIBEGIE">Get-Push Model</a></p>
</li>
<li>
<p><a href="#CHDBFJCG">Get-Pull Model</a></p>
</li>
<li>
<p><a href="#CIHFJDII">Set-Pull Model</a></p>
</li>
<li>
<p><a href="#CHDIIDCC">Set-Push Model</a></p>
</li>
</ul>
<p>For all except the get-push and set-pull access models (whether binary or character), Oracle supplies a concrete stream that you can use (implicitly). For get-push and set-pull, you must define a subtype of the abstract stream type that Oracle provides, and you must implement its access methods (open, close, and so on). For get-push and set-pull, you then instantiate your stream type and supply your stream as an argument to the access method. So, for example, you would use <code>my_node.getNodeValueAsCharacterStream(my-stream)</code> for get-push, but just <code>my_node.getNodeValueAsCharacterStream()</code> for get-pull. The latter requires no explicit stream argument, because the concrete stream supplied by Oracle is used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you access a character-data stream, the access method you use determines the apparent character set of the nodes accessed. If you use Java to access the stream, then the character set seen by your Java program is UCS2 (or an application-specified character set). If you use PL/SQL to access the stream, then the character set seen by your PL/SQL program is the database-session character set (or an application-specified character set). In all cases, however, the XML data is stored in the database in the database character set.
<p>In the following descriptions, C1 is the character set of the node as stored in the database, and C2 is the character set of the node as seen by your program.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb11jav.htm#CHDEBEFB">"Handling Large Nodes using Java"</a> for information on using Java with large nodes</p>
</li>
<li>
<p><a class="olink ARPLS399" href="../../appdev.112/e40758/d_xmldom.htm#ARPLS399"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> for information about Java functions for handling large nodes</p>
</li>
<li>
<p><a class="olink CAXML" href="../e10770/toc.htm"><span class="italic">Oracle Database XML C API Reference</span></a> for information about C functions for handling large nodes</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BEIBEGIE"></a>
<div id="ADXDB4899" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Get-Push Model</h3>
<p>To read a node value in this model, the application creates a binary output stream or character output stream and passes this to Oracle XML&nbsp;DB. In this case, the source data is the node value. Oracle XML&nbsp;DB populates the output stream by pushing node data into the stream. If the stream is a character output stream, then the character set, C2, is the session character set, and node data is converted, if necessary, from C1 to C2. Additionally, the data type of the node may be any supported by Oracle XML&nbsp;DB and, if the node data type is not character data then the node data is first converted to character data in C2. If a binary output stream, the data type of the node must be <code>RAW</code> or <code>BLOB</code>.</p>
<p>The procedures of the <code>DBMS_XMLDOM</code> package to be used for this case are:</p>
<pre>
PROCEDURE getNodeValueAsBinaryStream (n     IN DBMS_XMLDOM.domnode, 
                                      value IN SYS.utl_BinaryOutputStream);
</pre>
<p>The application passes an implementation of <code>SYS.utl_BinaryOutputStream</code> into which Oracle XML&nbsp;DB writes the contents of the node. The data type of the node must be <code>RAW</code> or <code>CLOB</code> or else an exception is raised.</p>
<pre>
PROCEDURE getNodeValueAsCharacterStream (n     IN DBMS_XMLDOM.domnode,
                                         value IN SYS.utl_CharacterOutputStream);
</pre>
<p>The node data is converted, as necessary, to the session character set and then "pushed" into the <code>SYS.utl_CharacterOutputStream</code>.</p>
<p>The following example fragments illustrate reading the node value as binary data and driving the write methods in a user-defined subtype of <code>SYS.utl_BinaryOutPutStream</code>, which is called <code>MyBinaryOutputStream</code>:</p>
<div id="ADXDB4900" class="example">
<p class="titleinexample"><a id="sthref1085"></a>Example 13-3 Creating a User-Defined Subtype of SYS.util_BinaryOutputStream()</p>
<pre>
CREATE TYPE MyBinaryOutputStream UNDER SYS.utl_BinaryOutputStream (
    CONSTRUCTOR FUNCTION MyBinaryOutputStream ()
    RETURN SELF AS RESULT,
    MEMBER FUNCTION  write (bytes IN RAW) RETURN INTEGER,
    MEMBER PROCEDURE write (bytes IN RAW, offset IN INTEGER, length IN OUT 
           INTEGER),
    MEMBER FUNCTION flush () RETURN BOOLEAN,
    MEMBER FUNCTION close () RETURN BOOLEAN);
);

-- Put code here that implements these methods
...
</pre></div>
<!-- class="example" -->
<div id="ADXDB4901" class="example">
<p class="titleinexample"><a id="sthref1086"></a>Example 13-4 Retrieving Node Value with a User-Defined Stream</p>
<pre>
DECLARE
  ostream     MyBinaryOutputStream = MyBinaryOutputStream ();
  node        DBMS_XMLDOM.domnode;
  ...
BEGIN
  ...
  -- This drives the write methods in MyBinaryOutputStream,
  -- flushes the data, and closes the stream after the value has been
  -- completely written.
  DBMS_XMLDOM.getNodeValueAsBinaryStream (node, ostream);
  ...
END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDBFJCG"></a>
<div id="ADXDB4902" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Get-Pull Model</h3>
<p>To read the value of a node in this model, Oracle XML&nbsp;DB creates a binary input stream or character input stream and returns this to the caller. The character set, C2, of the character input stream is the current session character set. Oracle XML&nbsp;DB populates the input stream as the caller pulls the node data from the stream so Oracle XML&nbsp;DB is again the producer of the data. If the stream is a character input stream, then the node data type may be any supported by Oracle XML&nbsp;DB and node data, if character, is converted, if necessary, from C1 to C2. If the node data is non-character, it is converted to character in C2. If a binary input stream, the data type of the node must be <code>RAW</code> or <code>BLOB</code>.</p>
<p>The functions of the <code>DBMS_XMLDOM</code> package to be used for this case are <code>getNodeValueAsBinaryStream</code> and <code>getNodeValueAsCharacterStream</code>.</p>
<pre>
FUNCTION getNodeValueAsBinaryStream(n IN DBMS_XMLDOM.domnode) 
         RETURN SYS.utl_BinaryInputStream;
</pre>
<p>This function returns an instance of the new PL/SQL <code>SYS.utl_BinaryInputStream</code> that can be read using defined methods as described in the section <a href="#CIHFJDII">"Set-Pull Model"</a>. The node data type must be <code>RAW</code> or <code>BLOB</code> or else an exception is raised.</p>
<pre>
FUNCTION getNodeValueAsCharacterStream (n IN DBMS_XMLDOM.domnode) 
         RETURN SYS.utl_CharacterInputStream;
</pre>
<p>This function returns an instance of the new PL/SQL <code>SYS.utl_CharacterInputStream</code> that can be read using defined methods. If the node data is character it is converted to the current session character set. If the node data is not character data, it is first converted to character data.</p>
<p><a href="#CHDBFEGJ">Example 13-5</a> illustrates reading a node value as binary data in 50-byte increments:</p>
<div id="ADXDB4903" class="example">
<p class="titleinexample"><a id="CHDBFEGJ"></a>Example 13-5 Get-Pull of Binary Data</p>
<pre>
DECLARE
  istream      SYS.utl_BinaryInputStream;
  node         DBMS_XMLDOM.domnode;
  buffer       raw(50);
  numBytes     pls_integer;
  ...
BEGIN
  ...
  istream := DBMS_XMLDOM.getNodeValueAsBinaryStream (node);
  -- Read stream in 50-byte chunks
  LOOP
    numBytes := 50;
    istream.read ( buffer, numBytes);
    if numBytes &lt;= 0 then
       exit;
    end if;
-- Process next 50 bytes of node value in buffer
END LOOP
...
END;
</pre></div>
<!-- class="example" -->
<p><a href="#CHDBIJAC">Example 13-6</a> illustrates reading a node value as character data in 50-character increments:</p>
<div id="ADXDB4904" class="example">
<p class="titleinexample"><a id="CHDBIJAC"></a>Example 13-6 Get-Pull of Character Data</p>
<pre>
DECLARE
  istream      SYS.utl_CharacterInputStream;
  node         DBMS_XMLDOM.domnode;
  buffer       varchar2(50);
  numChars     pls_integer;
  ...
BEGIN
  ...
  istream := DBMS_XMLDOM.getNodeValueAsCharacterStream (node);
-- Read stream in 50-character chunks
LOOP
   numChars := 50;
   istream.read ( buffer, numChars);
   IF numChars &lt;= 0 then
      exit;
   END IF;
-- Process next 50 characters of node value in buffer
END LOOP 
...
END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHFJDII"></a>
<div id="ADXDB4905" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Set-Pull Model</h3>
<p>To write a node value in this mode, the application creates a binary input stream or character input stream and passes this to Oracle XML&nbsp;DB. The character set of the character input stream, C2, is the session character set. Oracle XML&nbsp;DB pulls the data from the input stream and populates the node. If the stream is a character input stream, then the data type of the node may be any supported by Oracle XML&nbsp;DB. If the data type of the node is not character, the stream data is first converted to the node data type. If the node data type is character, then no conversion occurs, so the node data remains in character set C2. If the stream is a <code>binary input stream</code>, then the data type of the node must be <code>RAW</code> or <code>BLOB</code> and no conversion occurs.</p>
<p>The procedures of the <code>DBMS_XMLDOM</code> package to be used for this case are <code>setNodeValueAsBinaryStream</code> and <code>setNodeValueAsCharacterStream</code>.</p>
<pre>
PROCEDURE setNodeValueAsBinaryStream(<span class="italic">n</span> IN DBMS_XMLDOM.domnode,
          <span class="italic">value</span> IN SYS.utl_BinaryInputStream);
</pre>
<p>The application passes in an implementation of <code>SYS.utl_BinaryInputStream</code> from which Oracle XML&nbsp;DB reads data to populate the node. The data type of the node must be <code>RAW</code> or <code>BLOB</code> or else an exception is raised.</p>
<pre>
PROCEDURE setNodeValueAsCharacterStream (<span class="italic">n</span> IN DBMS_XMLDOM.domnode,
          <span class="italic">value</span> IN SYS.utl_CharacterInputStream);
</pre>
<p>The application passes in an implementation of <code>SYS.utl_CharacterInputStream</code> from which Oracle XML&nbsp;DB reads to populate the node. The data type of the node may be any valid type supported by Oracle XML&nbsp;DB. If it is a non-character data type, the character data read from the stream is converted to the data type of the node. If the data type of the node is either character or <code>CLOB</code>, then no conversion occurs and the character set of the node becomes the character set of the PL/SQL session.</p>
<p><a href="#CHDFDBIG">Example 13-7</a> illustrates setting the node value to binary data produced by the read methods defined in a user-defined subtype of <code>SYS.utl_BinaryInputStream</code>, which is called <code>MyBinaryInputStream</code>:</p>
<div id="ADXDB4906" class="example">
<p class="titleinexample"><a id="CHDFDBIG"></a>Example 13-7 Set-Pull of Binary Data</p>
<pre>
CREATE TYPE MyBinaryInputStream UNDER SYS.utl_BinaryInputStream (
    CONSTRUCTOR FUNCTION MyBinaryInputStream ()
    RETURN SELF AS RESULT,
  MEMBER FUNCTION read () RETURN RAW,
  MEMBER PROCEDURE read (bytes IN OUT RAW, numbytes IN OUT INTEGER),
  MEMBER PROCEDURE read (bytes IN OUT RAW,
                         offset IN INTEGER,
                         length IN OUT INTEGER),
  MEMBER FUNCTION close () RETURN BOOLEAN);
</pre></div>
<!-- class="example" -->
<p>You can use an object of type <code>MyBinaryInputStream</code> to set the value of a node as follows:</p>
<pre>
DECLARE
  istream     MyBinaryInputStream = MyBinaryInputStream ();
  node        DBMS_XMLDOM.domnode;
  ...
BEGIN
  ...
  -- This drives the read methods in MyBinaryInputStream
  DBMS_XMLDOM.setNodeValueAsBinaryStream (node, istream);
  ...
END;
</pre></div>
<!-- class="sect2" -->
<a id="CHDIIDCC"></a>
<div id="ADXDB4907" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Set-Push Model</h3>
<p>To write a new node value in this mode, Oracle XML&nbsp;DB creates a binary output stream or character output stream and returns this to the caller. The character set of the character output stream, C2, is the current session character set. The caller pushes data into the output stream and Oracle XML&nbsp;DB then writes this to the Oracle XML&nbsp;DB Node. If the stream is a character output stream, then the data type of the node may be any type supported by Oracle XML&nbsp;DB. In this case, the character data is converted to the node data type. If the node data type is character, then the character set, C1, is changed to C2. No data conversion occurs. If the stream is a binary input stream, and the data type of the node must be <code>RAW</code> or <code>BLOB</code>. In this case, the stream is read without data conversion.</p>
<p>The procedures of the <code>DBMS_XMLDOM</code> package to be used for this case are <code>setNodeValueAsBinaryStream</code> and <code>setNodeValueAsCharacterStream</code>.</p>
<pre>
FUNCTION setNodeValueAsBinaryStream(n IN DBMS_XMLDOM.domnode) 
         RETURN SYS.utl_BinaryOutputStream;
</pre>
<p>This function returns an instance of <code>SYS.utl_BinaryOutputStream</code> into which the caller can write the node value. The data type of the node must be <code>RAW</code> or <code>BLOB</code> or else an exception is raised.</p>
<pre>
FUNCTION setNodeValueAsCharacterStream (n IN DBMS_XMLDOM.domnode) 
         RETURN SYS.utl_CharacterOutputStream;
</pre>
<p>This function returns an instance of the PL/SQL <code>SYS.utl_CharacterOutputStream</code> type into which the caller can write the node value. The data type of the node can be any valid Oracle XML&nbsp;DB data type. If the type is not character or CLOB, the character data written to the stream is converted to the node data type. If the data type of the node is character or CLOB, then the character data written to the stream is converted from PL/SQL session character set to the character set of the node</p>
<p><a href="#CHDCEHBB">Example 13-8</a> illustrates setting the value of a node to binary data by writing 50-byte segments into the <code>SYS.utl_BinaryOutputStream</code>:</p>
<div id="ADXDB4908" class="example">
<p class="titleinexample"><a id="CHDCEHBB"></a>Example 13-8 Set-Push of Binary Data</p>
<pre>
DECLARE
  ostream      SYS.utl_BinaryOutputStream;
  node         DBMS_XMLDOM.domnode;
  buffer       raw(500);
  segment      raw(50);
  numBytes     pls_integer;
  offset       pls_integer;
  ...
BEGIN
  ...
  ostream := DBMS_XMLDOM.setNodeValueAsBinaryStream (node);
  offset := 0;
  length := 500;
  -- Write to stream in 50-byte chunks
  LOOP
    numBytes := 50;
    -- Get next 50 bytes of buffer
    ostream.write ( segment, offset, numBytes);
    length := length - numBytes;
    IF length  &lt;= 0 then
       exit;
    END IF;
  END LOOP
  ostream.close();
  ...
END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="ADXDB4909" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1087"></a>
<h3 class="sect2">Determining Binary Stream or Character Stream</h3>
<p>To determine whether to use a character stream or a binary stream to access the node value use the following method which is also included as part of the <code>DBMS_XMLDOM</code> package:</p>
<pre>
FUNCTION useBinaryStream (n IN DBMS_XMLDOM.domnode) RETURN BOOLEAN;
</pre>
<p>This function returns <code>TRUE</code> if the data type of the node is <code>RAW</code> or <code>BLOB</code>, so that the node value may be read or written using either a <code>SYS.utl_BinaryInputStream</code> or a <code>SYS.utl_BinaryOutputStream</code>. If a value of <code>FALSE</code> is returned, the node value can be accessed only using a <code>SYS.utl_CharacterInputStream</code> or a <code>SYS.utl_CharacterOutputStream</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1046197"></a>
<div id="ADXDB4910" class="sect1">
<h2 class="sect1"><a id="sthref1088"></a><a id="sthref1089"></a>PL/SQL Parser API for XMLType (<a id="sthref1090"></a>DBMS_XMLPARSER)</h2>
<p>XML documents are made up of storage units, called <span class="italic">entities</span>, that contain either parsed or unparsed data. Parsed data is made up of characters, some of which form character data and some of which form markup. Markup encodes a description of the document storage layout and logical structure. XML provides a mechanism for imposing constraints on the storage layout and logical structure.</p>
<p>A software module called an XML parser or processor reads XML documents and provides access to their content and structure. An XML parser usually does its work on behalf of another module, typically the application.</p>
<div id="ADXDB4911" class="sect2"><a id="sthref1091"></a>
<h3 class="sect2">Features of the PL/SQL Parser API for XMLType</h3>
<p>The PL/SQL Parser API for <code>XMLType</code> (<code>DBMS_XMLPARSER</code>) builds a result tree that can be accessed by PL/SQL APIs. If parsing fails, it raises an error.</p>
<p>Method <code>DBMS_XMLPARSER.setErrorLog()</code> is not supported.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS375" href="../../appdev.112/e40758/d_xmlpar.htm#ARPLS375"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for descriptions of individual <code>DBMS_XMLPARSER</code> methods</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4912" class="sect2"><a id="sthref1092"></a>
<h3 class="sect2">Using the PL/SQL Parser API for XMLType (DBMS_XMLPARSER)</h3>
<p><a href="#i1043623">Figure 13-2</a> illustrates how to use the PL/SQL Parser for <code>XMLType</code> (<code>DBMS_XMLPARSER</code>). These are the steps:</p>
<ol>
<li>
<p>Construct a parser instance using PL/SQL method <code>newParser()</code>.</p>
</li>
<li>
<p>Parse XML documents using PL/SQL methods such as <code>parseBuffer()</code>, <code>parseClob()</code>, and <code>parse(URI)</code>. An error is raised if the input is not a valid XML document.</p>
</li>
<li>
<p>Call PL/SQL function <code>getDocument</code> on the parser to obtain a <code>DOMDocument</code> interface.</p>
</li>
</ol>
<div id="ADXDB4913" class="figure">
<p class="titleinfigure"><a id="i1043623"></a>Figure 13-2 Using the PL/SQL Parser API for XMLType</p>
<img width="210" height="227" src="img/adxdb015.gif" alt="Description of Figure 13-2 follows" /><br />
<a id="sthref1093" href="img_text/adxdb015.htm">Description of "Figure 13-2 Using the PL/SQL Parser API for XMLType"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BEIGFDHI">Example 13-9</a> parses a simple XML document. It creates an XML parser (instance of <code>DBMS_XMLPARSER.parser</code>) and uses it to parse the XML document (text) in variable <code>indoc</code>. Parsing creates a DOM document, which is retrieved from the parser using <code>DBMS_XMLPARSER.getDocument</code>. A DOM node is created that contains the entire document, and the node is printed. After freeing (destroying) the DOM document, the parser instance is freed using <code>DBMS_XMLPARSER.freeParser</code>.</p>
<div id="ADXDB4914" class="example">
<p class="titleinexample"><a id="BEIGFDHI"></a>Example 13-9 Parsing an XML Document</p>
<pre>
DECLARE
  indoc    VARCHAR2(2000);
  indomdoc DBMS_XMLDOM.DOMDocument;
  innode   DBMS_XMLDOM.DOMNode;
  myparser DBMS_XMLPARSER.parser;
  buf      VARCHAR2(2000);
BEGIN
  indoc := '&lt;emp&gt;&lt;name&gt;De Selby&lt;/name&gt;&lt;/emp&gt;';
  myParser := DBMS_XMLPARSER.newParser;
  DBMS_XMLPARSER.parseBuffer(myParser, indoc);
  indomdoc := DBMS_XMLPARSER.getDocument(myParser);
  innode := DBMS_XMLDOM.makeNode(indomdoc);
  DBMS_XMLDOM.writeToBuffer(innode, buf);
  DBMS_OUTPUT.put_line(buf);
  DBMS_XMLDOM.freeDocument(indomdoc);
  DBMS_XMLPARSER.freeParser(myParser);
END;
/
</pre>
<p>This produces the following output:</p>
<pre>
&lt;emp&gt;&lt;name&gt;De Selby&lt;/name&gt;&lt;/emp&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1043472"></a>
<div id="ADXDB4915" class="sect1">
<h2 class="sect1">PL/SQL XSLT Processor for XMLType (<a id="sthref1094"></a><a id="sthref1095"></a><a id="sthref1096"></a>DBMS_XSLPROCESSOR)</h2>
<p>The W3C XSL Recommendation describes rules for transforming a source tree into a result tree. A transformation expressed in Extensible Stylesheet Language Transformation (XSLT) language is called an <a id="sthref1097"></a><span class="glossaryterm">XSL style sheet</span>. The transformation specified is achieved by associating patterns with templates defined in the XSLT style sheet. A template is instantiated to create part of the result tree.</p>
<div id="ADXDB4916" class="sect2"><a id="sthref1098"></a>
<h3 class="sect2">Enabling Transformations and Conversions with XSLT</h3>
<p>The Oracle XML&nbsp;DB PL/SQL DOM API for <code>XMLType</code> also supports XSLT. This enables transformation from one XML document to another, or conversion into HTML, PDF, or other formats. XSLT is also widely used to convert XML to HTML for browser display.</p>
<p>The embedded XSLT processor follows Extensible Stylesheet Language (XSL) statements and traverses the DOM tree structure for XML data residing in <code>XMLType</code>. Oracle XML&nbsp;DB applications do not require a separate parser as did the prior release XML Parser for PL/SQL. However, applications requiring external processing can still use the XML Parser for PL/SQL first to expose the document structure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The XML Parser for PL/SQL in Oracle XML Developer's Kit parses an XML document (or a standalone DTD) so that the XML document can be processed by an application, typically running on the client. PL/SQL APIs for <code>XMLType</code> are used for applications that run on the server and are natively integrated in the database. Benefits include performance improvements and enhanced access and manipulation options.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb08tra.htm#g1030361">Chapter 11, "Transforming and Validating XMLType Data"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4917" class="sect2"><a id="sthref1099"></a>
<h3 class="sect2">PL/SQL XSLT Processor for XMLType: Features</h3>
<p>PL/SQL XSLT Processor for <code>XMLType</code> (<code>DBMS_XSLPROCESSOR</code>) is the Oracle XML&nbsp;DB implementation of the XSL processor. This follows the W3C XSLT final recommendation (REC-xslt-19991116). It includes the required action of an XSL processor in terms of how it must read XSLT style sheets and the transformations it must achieve. It provides a convenient and efficient way of applying a single style sheet to multiple documents.</p>
<p>The types and methods of the PL/SQL XSLT Processor API are made available by PL/SQL package <code>DBMS_XSLPROCESSOR</code>. The methods in this package use PL/SQL data types <code>PROCESSOR</code> and <code>STYLESHEET</code>, which are specific to the XSL Processor implementation.</p>
<p>All <code>DBMS_XSLPROCESSOR</code> methods are supported by Oracle XML&nbsp;DB, with the <span class="italic">exception</span> of method <code>setErrorLog()</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS379" href="../../appdev.112/e40758/d_xslpro.htm#ARPLS379"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for descriptions of the individual <code>DBMS_XSLPROCESSOR</code> methods</div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4918" class="sect2"><a id="sthref1100"></a>
<h3 class="sect2">Using the PL/SQL XSLT Processor API for XMLType (DBMS_XSLPROCESSOR)</h3>
<p><a href="#BEIJAGBB">Figure 13-3</a> illustrates how to use XSLT Processor for <code>XMLType</code> (<code>DBMS_XSLPROCESSOR</code>). These are the steps:</p>
<ol>
<li>
<p>Construct an XSLT processor using <code>newProcessor</code>.</p>
</li>
<li>
<p>Use <code>newStylesheet</code> to build a <code>STYLESHEET</code> object from a DOM document.</p>
</li>
<li>
<p>Optionally, you can set parameters for the <code>STYLESHEET</code> object using <code>setParams</code>.</p>
</li>
<li>
<p>Use <code>processXSL</code> to transform a DOM document using the processor and <code>STYLESHEET</code> object.</p>
</li>
<li>
<p>Use the PL/SQL DOM API for <code>XMLType</code> to manipulate the result of XSLT processing.</p>
</li>
</ol>
<div id="ADXDB4919" class="figure">
<p class="titleinfigure"><a id="BEIJAGBB"></a>Figure 13-3 Using the PL/SQL XSLT Processor for XMLType</p>
<img width="361" height="380" src="img/adxdb016.gif" alt="Description of Figure 13-3 follows" /><br />
<a id="sthref1101" href="img_text/adxdb016.htm">Description of "Figure 13-3 Using the PL/SQL XSLT Processor for XMLType"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BEIFDEJB">Example 13-10</a> transforms an XML document using procedure <code><a id="sthref1102"></a><a id="sthref1103"></a>processXSL</code>. It uses the same parser instance to create two different DOM documents: the XML text to transform and the XSLT style sheet. An XSL processor instance is created, which applies the style sheet to the source XML to produce a new DOM fragment. A DOM node (<code>outnode</code>) is created from this fragment, and the node content is printed. The output DOM fragment, parser, and XSLT processor instances are freed using procedures <code>freeDocFrag</code>, <code>freeParser</code>, and <code>freeProcessor</code>, respectively.</p>
<div id="ADXDB4920" class="example">
<p class="titleinexample"><a id="BEIFDEJB"></a>Example 13-10 Transforming an XML Document using an <a id="sthref1104"></a>XSL Style Sheet</p>
<pre>
DECLARE
  indoc      VARCHAR2(2000);
  xsldoc     VARCHAR2(2000);
  myParser   DBMS_XMLPARSER.parser;
  indomdoc   DBMS_XMLDOM.DOMDocument;
  xsltdomdoc DBMS_XMLDOM.DOMDocument;
  xsl        DBMS_XSLPROCESSOR.stylesheet;
  outdomdocf DBMS_XMLDOM.DOMDocumentFragment;
  outnode    DBMS_XMLDOM.DOMNode;
  proc       DBMS_XSLPROCESSOR.processor;
  buf        VARCHAR2(2000);
BEGIN
  indoc := '&lt;emp&gt;&lt;empno&gt;1&lt;/empno&gt; 
              &lt;fname&gt;robert&lt;/fname&gt; 
              &lt;lname&gt;smith&lt;/lname&gt;
              &lt;sal&gt;1000&lt;/sal&gt;
              &lt;job&gt;engineer&lt;/job&gt;
            &lt;/emp&gt;';
  xsldoc := '&lt;?xml version="1.0"?&gt; 
             &lt;xsl:stylesheet version="1.0"     
                             xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
               &lt;xsl:output encoding="utf-8"/&gt;
               &lt;!-- alphabetizes an xml tree --&gt;
               &lt;xsl:template match="*"&gt;
                 &lt;xsl:copy&gt;
                   &lt;xsl:apply-templates select="*|text()"&gt;
                     &lt;xsl:sort select="name(.)" data-type="text" 
                               order="ascending"/&gt;
                   &lt;/xsl:apply-templates&gt;
                 &lt;/xsl:copy&gt;
               &lt;/xsl:template&gt;
               &lt;xsl:template match="text()"&gt;
                 &lt;xsl:value-of select="normalize-space(.)"/&gt;
               &lt;/xsl:template&gt;
             &lt;/xsl:stylesheet&gt;';
  myParser := DBMS_XMLPARSER.newParser;
  DBMS_XMLPARSER.parseBuffer(myParser, indoc);
  indomdoc   := DBMS_XMLPARSER.getDocument(myParser);
  DBMS_XMLPARSER.parseBuffer(myParser, xsldoc);
  xsltdomdoc := DBMS_XMLPARSER.getDocument(myParser);
  xsl        := DBMS_XSLPROCESSOR.newStyleSheet(xsltdomdoc, '');
  proc       := DBMS_XSLPROCESSOR.newProcessor;
  --apply stylesheet to DOM document   
  outdomdocf := DBMS_XSLPROCESSOR.processXSL(proc, xsl, indomdoc);
  outnode    := DBMS_XMLDOM.makeNode(outdomdocf); 
  -- PL/SQL DOM API for XMLType can be used here
  DBMS_XMLDOM.writeToBuffer(outnode, buf);
  DBMS_OUTPUT.put_line(buf);
  DBMS_XMLDOM.freeDocument(indomdoc);
  DBMS_XMLDOM.freeDocument(xsltdomdoc);
  DBMS_XMLDOM.freeDocFrag(outdomdocf);
  DBMS_XMLPARSER.freeParser(myParser);
  DBMS_XSLPROCESSOR.freeProcessor(proc);
END;
/
</pre>
<p>This produces the following output:</p>
<pre>
&lt;emp&gt;
&lt;empno&gt;1&lt;/empno&gt;
&lt;fname&gt;robert&lt;/fname&gt;
&lt;job&gt;engineer&lt;/job&gt;
&lt;lname&gt;smith&lt;/lname&gt;
&lt;sal&gt;1000&lt;/sal&gt;
&lt;/emp&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEIIBEGB"></a>
<div id="ADXDB4921" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">PL/SQL Translation API for XMLType (DBMS_XMLTRANSLATIONS)</h2>
<p>When you store security objects in the Oracle XML&nbsp;DB Repository, you store them as <code>XMLType</code> instances. The security objects also contain some strings that must be translated, so that you can search for or display them in various languages. The translations for these strings are also stored in the Oracle XML&nbsp;DB Repository, along with the original strings, because they must be associated with the original document. You can retrieve and operate on these strings, depending on your language settings.</p>
<p>Oracle XML&nbsp;DB provides translation support through the <code>DBMS_XMLTRANSLATIONS</code> package, which provides an interface to perform translations so that strings can be searched or displayed in various languages.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb05sto.htm#g1070409">Chapter 7, "XML Schema Storage and Query: Basic"</a> for an overview of XML translations</div>
<div id="ADXDB4922" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1105"></a>
<h3 class="sect2">DBMS_XMLTRANSLATIONS Methods</h3>
<p>PL/SQL package <code>DBMS_XMLTRANSLATIONS</code> provides the following methods:</p>
<ul>
<li>
<p><code>updateTranslation()</code>: Updates the translation in a particular language at the specified <code>XPATH</code>. If the translation in that language is not present, then it is inserted.</p>
</li>
<li>
<p><code>setSourceLang()</code>: Sets the source language to a particular language at the specified <code>XPATH</code>.</p>
</li>
<li>
<p><code>translateXML()</code>: Returns the document in the specified language.</p>
</li>
<li>
<p><code>getBaseDocument()</code>: Returns the base document with all the translations.</p>
</li>
<li>
<p><code>extractXLiff()</code>: Extracts the translations in <code>XLIFF</code> format from either an <code>XMLTYPE</code> instance or a resource in Oracle XML&nbsp;DB Repository.</p>
</li>
<li>
<p><code>mergeXLiff()</code>: Merges the translations in <code>XLIFF</code> format into either an <code>XMLTYPE</code> or a resource in Oracle XML&nbsp;DB Repository.</p>
</li>
<li>
<p><code>disableTranslation()</code>: Disables translations in the current session so that query or retrieval takes place on the base document, ignoring session language values.</p>
</li>
<li>
<p><code>enableTranslation()</code>: Enables translations in the current session.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Type References</span></a> for a description of the individual <code>DBMS_XMLTRANSLATIONS</code> methods.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="partpg3.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb_dbmstore.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
