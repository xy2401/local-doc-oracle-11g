<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Java DOM API for XMLType</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:15Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="xdb_dbmstore.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb12oci.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">25/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='xdb11jav'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADXDB1300" class="chapter"><a id="g1039140"></a>
<h1 class="chapter"><span class="secnum">15</span> Java DOM API for XMLType</h1>
<p>This chapter describes how to use <code>XMLType</code> in Java, including fetching <code>XMLType</code> data through Java Database Connectivity (JDBC).</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1030427">Overview of Java DOM API for XMLType</a></p>
</li>
<li>
<p><a href="#i1033914">Java DOM API for XMLType</a></p>
</li>
<li>
<p><a href="#CHDHGIIC">Loading a Large XML Document into the Database using JDBC</a></p>
</li>
<li>
<p><a href="#i1030882">Java DOM API for XMLType Features</a></p>
</li>
<li>
<p><a href="#i1031670">Java DOM API for XMLType Classes</a></p>
</li>
<li>
<p><a href="#CHDEBEFB">Handling Large Nodes using Java</a></p>
</li>
<li>
<p><a href="#CHDHGHDG">Using the Java DOM API and JDBC with Binary XML</a></p>
</li>
</ul>
<a id="i1030427"></a>
<div id="ADXDB4931" class="sect1">
<h2 class="sect1"><a id="sthref1123"></a><a id="sthref1124"></a>Overview of Java DOM API for XMLType</h2>
<p>Oracle XML&nbsp;DB supports the Java Document Object Model (DOM) Application Program Interface (API) for <code>XMLType</code>. This is a generic API for client and server, for both XML schema-based and non-schema-based documents. It is implemented using Java package <code><a id="sthref1125"></a><a id="sthref1126"></a>oracle.xml.parser.v2</code>. DOM is a tree-based object representation of XML documents in dynamic memory that enables programmatic access to their elements and attributes. The DOM object and interface are part of a W3C recommendation. DOM views the parsed document as a tree of objects.</p>
<p>To access <code>XMLType</code> data using JDBC, use the class <code><a id="sthref1127"></a>oracle.xdb.XMLType</code>.</p>
<p>For XML documents that do not conform to any XML schema, use the Java DOM API for <code>XMLType</code>, because it can handle <span class="italic">any</span> valid XML document.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a></div>
</div>
<!-- class="sect1" -->
<a id="i1033914"></a>
<div id="ADXDB4932" class="sect1">
<h2 class="sect1">Java DOM API for XMLType</h2>
<p>Java DOM API for <code>XMLType</code> handles all kinds of valid XML documents, irrespective of how they are stored in Oracle XML&nbsp;DB. It presents to the application a uniform view of the XML document, whether it is XML schema-based or non-schema-based and whatever the underlying storage model. Java DOM API works on both client and server.</p>
<p>As discussed in <a href="xdb10pls.htm#g1056962">Chapter 13, "PL/SQL APIs for XMLType"</a>, the Oracle XML&nbsp;DB DOM APIs are compliant with the W3C DOM Level 1.0 and Level 2.0 Core Recommendation.</p>
<p>The Java DOM API for <code>XMLType</code> can be used to construct an <code>XMLType</code> instance from data encoded in different character sets.</p>
<p>You can use the Java DOM API for <code>XMLType</code> to access XML documents stored in Oracle XML&nbsp;DB Repository from Java applications. Naming conforms to the Java binding for DOM as specified by the W3C DOM Recommendation. The repository can contain both XML schema-based and non-schema-based documents.</p>
<div id="ADXDB4933" class="sect2"><a id="sthref1128"></a>
<h3 class="sect2">Accessing XMLType Data using JDBC</h3>
<p>JDBC is a SQL-based way for Java applications to access any data in Oracle Database, including XML documents in Oracle XML&nbsp;DB. You use Java class <code>oracle.xdb.XMLType</code>, method <code><a id="sthref1129"></a><a id="sthref1130"></a><a id="sthref1131"></a>createXML()</code> to create XML data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Use the thick driver with method <code>XMLType.createXML()</code> if you pass a stream as input. You cannot use the thin driver in this case.</div>
<div id="ADXDB6004" class="sect3"><a id="sthref1132"></a>
<h4 class="sect3">Using XMLType Data with JDBC</h4>
<p>The JDBC 4.0 standard data type for XML data is <code>java.sql.SQLXML</code>. Method <code>getObject()</code> returns an object of type <code>oracle.xdb.XMLType</code>. Starting with Oracle Database Release 2 (11.2.0.3), <code>oracle.xdb.XMLType</code> implements interface <code>java.sql.SQLXML</code>.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4934" class="sect3"><a id="sthref1133"></a>
<h4 class="sect3"><a id="sthref1134"></a>How Java Applications Use JDBC to Access XML Documents in Oracle XML&nbsp;DB</h4>
<p>JDBC users can query an <code><a id="sthref1135"></a>XMLType</code> table to obtain a JDBC <code>XMLType</code> interface that supports all SQL/XML functions supported by SQL data type <code>XMLType</code>. The Java (JDBC) API for <code>XMLType</code> interface can implement the DOM document interface.</p>
<p><a href="#CHDHEGED">Example 15-1</a> illustrates how to use JDBC to query an <code>XMLType</code> table:</p>
<div id="ADXDB4935" class="example">
<p class="titleinexample"><a id="CHDHEGED"></a>Example 15-1 Querying an XMLType Table using JDBC</p>
<pre>
import oracle.xdb.XMLType; 
            ... 
OraclePreparedStatement stmt = (OraclePreparedStatement)
conn.prepareStatement("SELECT e.poDoc FROM po_xml_tab e"); 
ResultSet rset = stmt.executeQuery(); 
OracleResultSet orset = (OracleResultSet) rset; 
while(orset.next())
  { 
  // get the XMLType 
  <span class="bold">XMLType poxml = (XMLType)orset.getObject(1);</span> 
  // get the XMLDocument as a string... 
  Document podoc = (Document)poxml.getDOM(); 
  }
</pre></div>
<!-- class="example" -->
<p>You can select <code>XMLType</code> data using JDBC in any of these ways:</p>
<ul>
<li>
<p>Use SQL/XML function <code>XMLSerialize</code> in SQL, and obtain the result as an <code>oracle.sql.CLOB</code>, <code>java.lang.String</code> or <code>oracle.sql.BLOB</code> in Java. The Java snippet in <a href="#CHDGIDFE">Example 15-2</a> illustrates this.</p>
</li>
<li>
<p>Call method <code><a id="sthref1136"></a><a id="sthref1137"></a><a id="sthref1138"></a>getObject()</code> in the <code>PreparedStatement</code> to obtain the whole <code>XMLType</code> instance. The return value of this method is of type <code>oracle.xdb.XMLType</code>. Then you can use Java functions on class <code>XMLType</code> to access the data. <a href="#CHDJJHCE">Example 15-3</a> shows how to do this.</p>
</li>
</ul>
<div id="ADXDB5887" class="example">
<p class="titleinexample"><a id="CHDGIDFE"></a>Example 15-2 Selecting XMLType Data using getStringVal() and getCLOB()</p>
<pre>
DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
Connection conn = 
  DriverManager.getConnection("jdbc:oracle:oci8:@", "QUINE", "CURRY");
OraclePreparedStatement stmt = 
  (OraclePreparedStatement) conn.prepareStatement(
     "SELECT <span class="bold">XMLSerialize</span>(DOCUMENT e.poDoc <span class="bold">AS CLOB</span>) poDoc, " +
     "<span class="bold">XMLSerialize</span>(DOCUMENT e.poDoc AS <span class="bold">VARCHAR2(2000)</span>) poString " +
     " FROM po_xml_tab e");
ResultSet rset = stmt.executeQuery();
OracleResultSet orset = (OracleResultSet) rset;
while(orset.next())
  {
  // the first argument is a CLOB
  <span class="bold">oracle.sql.CLOB clb = orset.getCLOB(1);</span>
  // the second argument is a string..
  String poString = orset.getString(2);
  // now use the CLOB inside the program
  }
</pre></div>
<!-- class="example" -->
<p><a href="#CHDJJHCE">Example 15-3</a> shows the use of method <code><a id="sthref1139"></a><a id="sthref1140"></a><a id="sthref1141"></a>getObject()</code> to directly obtain an <code>XMLType</code> instance from <code>ResultSet</code>.</p>
<div id="ADXDB4937" class="example">
<p class="titleinexample"><a id="CHDJJHCE"></a>Example 15-3 Returning XMLType Data using getObject()</p>
<pre>
import oracle.xdb.XMLType;
...
PreparedStatement stmt =  conn.prepareStatement(
  "SELECT e.poDoc FROM po_xml_tab e"); 
ResultSet rset = stmt.executeQuery(); 
while(rset.next())
{ 
// get the XMLType 
XMLType poxml = (XMLType)rset.<span class="bold">getObject</span>(1); 
// get the XML as a string...
String poString = poxml.getStringVal();
}
</pre></div>
<!-- class="example" -->
<p><a href="#CHDGFDCD">Example 15-4</a> shows how to bind an output parameter of type <code>XMLType</code> to a SQL statement. The output parameter is registered as having data type <code>XMLType</code>.</p>
<div id="ADXDB4938" class="example">
<p class="titleinexample"><a id="CHDGFDCD"></a>Example 15-4 Returning XMLType Data using an Output Parameter</p>
<pre>
public void doCall (String[] args) 
  throws Exception 
  { 
//  CREATE OR REPLACE FUNCTION getPurchaseOrder(reference VARCHAR2) 
//  RETURN XMLTYPE 
//  AS 
//    xml XMLTYPE; 
//  BEGIN 
//    SELECT OBJECT_VALUE INTO xml 
//      FROM purchaseorder 
//      WHERE XMLCast(XMLQuery('$p/PurchaseOrder/Reference'
//                             PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
//                    AS VARCHAR2(30))
//            = reference;
//      RETURN xml; 
//  END; 
    String SQLTEXT = "{? = call getPurchaseOrder('BLAKE-2002100912333601PDT')}"; 
    CallableStatement sqlStatement = null; 
    XMLType xml = null; 
    super.doSomething(args); 
    createConnection(); 
    try 
    { 
      System.out.println("SQL := " + SQLTEXT); 
      sqlStatement = getConnection().prepareCall(SQLTEXT); 
      sqlStatement.<span class="bold">registerOutParameter</span> (1, OracleTypes.OPAQUE,"SYS.XMLTYPE"); 
      sqlStatement.execute(); 
      xml = <span class="bold">(XMLType)</span> sqlStatement.<span class="bold">getObject</span>(1); 
      System.out.println(xml.getStringVal()); 
    } 
    catch (SQLException SQLe) 
    { 
      if (sqlStatement != null) 
      { 
        sqlStatement.close(); 
        throw SQLe; 
      } 
    } 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDB4939" class="sect2"><a id="sthref1142"></a>
<h3 class="sect2"><a id="sthref1143"></a>Manipulating XML Database Documents using JDBC</h3>
<p>You can also update, insert, and delete <code>XMLType</code> data using Java Database Connectivity (JDBC).</p>
<div align="center">
<div class="inftblinformal"><br />
<table class="cellalignment1031">
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028">
<p class="notep1">Note:</p>
<code>XMLType</code> methods <code>extract()</code>, <code>transform()</code>, and <code>existsNode()</code> work only with the OCI driver.
<p>Not all <code>oracle.xdb.XMLType</code> functions are supported by the <a id="sthref1144"></a>thin JDBC driver. If you do not use <code>oracle.xdb.XMLType</code> classes and the OCI driver, you could lose performance benefits associated with the intelligent handling of XML.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<p>You can update, insert, or delete <code>XMLType</code> data in either of these ways:</p>
<ul>
<li>
<p>Bind a <code>CLOB</code> instance or a string to an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement, and use the <code>XMLType</code> constructor inside SQL to construct the XML instance. <a href="#CHDJFABC">Example 15-5</a> illustrates this.</p>
</li>
<li>
<p>Use <code><a id="sthref1145"></a><a id="sthref1146"></a><a id="sthref1147"></a>setObject()</code> in the <code>PreparedStatement</code> to set the entire <code>XMLType</code> instance. <a href="#CHDJBADD">Example 15-6</a> illustrates this.</p>
</li>
</ul>
<div id="ADXDB5889" class="example">
<p class="titleinexample"><a id="CHDJFABC"></a>Example 15-5 Updating XMLType Data using SQL UPDATE with Constructor XMLType</p>
<pre>
OraclePreparedStatement stmt = 
    (OraclePreparedStatement) conn.prepareStatement(
        "UPDATE po_xml_tab SET poDoc = <span class="bold">XMLType</span>(?)");

// the second argument is a string..
String poString = "&lt;PO&gt;&lt;PONO&gt;200&lt;/PONO&gt;&lt;PNAME&gt;PO_2&lt;/PNAME&gt;&lt;/PO&gt;";

// now bind the string..
stmt.setString(1,poString);
stmt.execute();
</pre></div>
<!-- class="example" -->
<div id="ADXDB5890" class="example">
<p class="titleinexample"><a id="CHDJBADD"></a>Example 15-6 Updating XMLType Data using SQL UPDATE with setObject()</p>
<pre>
import oracle.xdb.XMLType;
...
OraclePreparedStatement stmt = 
    (OraclePreparedStatement) conn.prepareStatement(
        "UPDATE po_xml_tab SET poDoc = ?");

// the second argument is a string
String poString = "&lt;PO&gt;&lt;PONO&gt;200&lt;/PONO&gt;&lt;PNAME&gt;PO_2&lt;/PNAME&gt;&lt;/PO&gt;";
XMLType poXML = XMLType.createXML(conn, poString);

// now bind the string..
stmt.<span class="bold">setObject</span>(1,poXML);
stmt.execute();
</pre></div>
<!-- class="example" -->
<p>When selecting <code>XMLType</code> values, JDBC describes the column as an opaque type. You can select the column type name and compare it with <code>XMLTYPE</code> to see whether you are dealing with an <code>XMLType</code> instance. <a href="#i1031938">Example 15-7</a> illustrates this.</p>
<div id="ADXDB4941" class="example">
<p class="titleinexample"><a id="i1031938"></a>Example 15-7 Retrieving Metadata about XMLType Data using JDBC</p>
<pre>
import oracle.sql.*;
import oracle.jdbc.*;
...
OraclePreparedStatement stmt = 
    (OraclePreparedStatement) conn.prepareStatement(
        "SELECT poDoc FROM po_xml_tab");

OracleResultSet rset = (OracleResultSet)stmt.executeQuery();

// Get the resultset metadata
OracleResultSetMetaData mdata = 
        (OracleResultSetMetaData)rset.getMetaData();

// Describe the column = the column type comes out as OPAQUE
// and column type name comes out as XMLTYPE
if (mdata.getColumnType(1) == OracleTypes.OPAQUE &amp;&amp; 
    mdata.getColumnTypeName(1).compareTo("SYS.XMLTYPE") == 0)
{
   // It is an XMLtype
}
</pre></div>
<!-- class="example" -->
<p><a href="#i1031963">Example 15-8</a> updates element <code>discount</code> inside element <code>PurchaseOrder</code> stored in an <code>XMLType</code> column. It uses JDBC and class <code>oracle.xdb.XMLType</code>. It uses the XML parser to update a DOM tree and write the updated XML value to the <code>XMLType</code> column.</p>
<div id="ADXDB4942" class="example">
<p class="titleinexample"><a id="i1031963"></a>Example 15-8 Updating an Element in an XMLType Column using JDBC</p>
<pre>
-- Create po_xml_hist table to store old PurchaseOrders
CREATE TABLE po_xml_hist (xpo XMLType);
/* NOTE: You must have xmlparserv2.jar and xdb.jar in CLASSPATH */
import java.sql.*;
import java.io.*;
import oracle.xml.parser.v2.*;
import org.xml.sax.*;
import org.w3c.dom.*;
import oracle.jdbc.driver.*;
import oracle.sql.*;
import oracle.xdb.XMLType;
public class tkxmtpje
  {
  static String conStr = "jdbc:oracle:oci8:@";
  static String user = "QUINE";
  static String pass = "CURRY";
  static String qryStr =
  "SELECT x.poDoc from po_xml_tab x " +
  "WHERE XMLCast(XMLQuery('/PO/PONO/text()'" +
  " PASSING x.poDoc RETURNING CONTENT)" +
  " AS NUMBER)" +
  " = 200";
  static String updateXML(String xmlTypeStr)
  Java DOM API for XMLType
  Beta Draft Java DOM API for XMLType 15-7
    {
    System.out.println("\n===============================");
    System.out.println("xmlType.getStringVal():");
    System.out.println(xmlTypeStr);
    System.out.println("===============================");
    String outXML = null;
    try {
        DOMParser parser = new DOMParser();
        parser.setValidationMode(false);
        parser.setPreserveWhitespace (true);
        parser.parse(new StringReader(xmlTypeStr));
        System.out.println("xmlType.getStringVal(): xml String is well-formed");
        XMLDocument doc = parser.getDocument();
        NodeList nl = doc.getElementsByTagName("<span class="bold">DISCOUNT</span>");
        for(int i=0;i&lt;nl.getLength();i++)
          {
          XMLElement discount = (XMLElement)nl.item(i);
          XMLNode textNode = (XMLNode)discount.getFirstChild();
          textNode.setNodeValue("<span class="bold">10</span>");
          }
        StringWriter sw = new StringWriter();
        doc.print(new PrintWriter(sw));
        outXML = sw.toString();
        //print modified xml
        System.out.println("\n===============================");
        System.out.println("Updated PurchaseOrder:");
        System.out.println(outXML);
        System.out.println("===============================");
        }
    catch (Exception e)
      {
      e.printStackTrace(System.out);
      }
    return outXML;
    }
  }
 
public static void main(String args[]) throws Exception
  {
  try {
      System.out.println("qryStr=" + qryStr);
      DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
      Connection conn =
      DriverManager.getConnection("jdbc:oracle:oci8:@", user, pass);
      Statement s = conn.createStatement();
      OraclePreparedStatement stmt;
      ResultSet rset = s.executeQuery(qryStr);
      OracleResultSet orset = (OracleResultSet) rset;
      while(orset.next())
        {
        //retrieve PurchaseOrder xml document from database
        XMLType xt = (XMLType)orset.getObject(1);
        //store this PurchaseOrder in po_xml_hist table
        stmt = (OraclePreparedStatement)conn.prepareStatement(
        "INSERT INTO po_xml_hist VALUES(?)");
        stmt.setObject(1,xt); // bind the XMLType instance
        stmt.execute();
        //update "DISCOUNT" element
        String newXML = updateXML(xt.getStringVal());
        // create a new instance of an XMLtype from the updated value
        xt = XMLType.createXML(conn, newXML);
        // update PurchaseOrder xml document in database
        stmt = (OraclePreparedStatement)conn.prepareStatement(
        "UPDATE po_xml_tab x SET x.poDoc =? WHERE " +
        "XMLCast(XMLQuery('/PO/PONO/text()'" +
        " PASSING value(xmltab) RETURNING CONTENT)" +
        " AS NUMBER)" +
        "= 200");
        stmt.setObject(1,xt); // bind the XMLType instance
        stmt.execute();
        conn.commit();
        System.out.println("PurchaseOrder 200 Updated!");
        }
      //delete PurchaseOrder 1001
      s.execute("DELETE FROM po_xml x WHERE" +
                "XMLCast(XMLQuery('/PurchaseOrder/PONO/text()'" +
                " PASSING value(xmltab) RETURNING CONTENT)" +
                " AS NUMBER)" +
                "= 1001");
      System.out.println("PurchaseOrder 1001 deleted!");
      }
  catch(Exception e)
    {
    e.printStackTrace(System.out);
    }
  }
 
SELECT x.xpo.getCLOBVal() FROM po_xml x;
</pre></div>
<!-- class="example" -->
<p><a href="#CHDBDGFB">Example 15-9</a> shows the updated purchase order that results from <a href="#i1031963">Example 15-8</a>.</p>
<div id="ADXDB5891" class="example">
<p class="titleinexample"><a id="CHDBDGFB"></a>Example 15-9 Updated Purchase-Order Document</p>
<pre>
&lt;?xml version = "1.0"?&gt;
&lt;PurchaseOrder&gt;
  &lt;PONO&gt;200&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;2&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;John Nike&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;323 College Drive&lt;/STREET&gt;
    &lt;CITY&gt;Edison&lt;/CITY&gt;
    &lt;STATE&gt;NJ&lt;/STATE&gt;
    &lt;ZIP&gt;08820&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;609-555-1212&lt;/VARCHAR2&gt;
    &lt;VARCHAR2&gt;201-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;20-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;20-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo="1"&gt;
    &lt;ITEM StockNo="1004"&gt;
     &lt;PRICE&gt;6750&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;1&lt;/QUANTITY&gt;
    <span class="bold">&lt;DISCOUNT&gt;10&lt;/DISCOUNT&gt;</span>
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo="2"&gt;
    &lt;ITEM StockNo="1011"&gt;
     &lt;PRICE&gt;4500.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;2&lt;/QUANTITY&gt;
    <span class="bold">&lt;DISCOUNT&gt;10&lt;/DISCOUNT&gt;</span>
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR&gt;
   &lt;STREET&gt;55 Madison Ave&lt;/STREET&gt;
   &lt;CITY&gt;Madison&lt;/CITY&gt;
   &lt;STATE&gt;WI&lt;/STATE&gt;
   &lt;ZIP&gt;53715&lt;/ZIP&gt;
  &lt;/SHIPTOADDR&gt;
&lt;/PurchaseOrder&gt;
</pre></div>
<!-- class="example" -->
<p><a href="#CHDEFDIE">Example 15-10</a> does all of the following:</p>
<ul>
<li>
<p>Selects an <code>XMLType</code> instance from an <code>XMLType</code> table</p>
</li>
<li>
<p>Extracts portions of the <code>XMLType</code> instance, based on an XPath expression</p>
</li>
<li>
<p>Checks for the existence of elements</p>
</li>
<li>
<p>Transforms the <code>XMLType</code> instance to another XML format based on XSL</p>
</li>
<li>
<p>Checks the validity of the <code>XMLType</code> document against an XML schema</p>
</li>
</ul>
<div id="ADXDB5892" class="example">
<p class="titleinexample"><a id="CHDEFDIE"></a>Example 15-10 Manipulating an XMLType Column using JDBC</p>
<pre>
import java.sql.*;
import java.io.*;
import java.net.*;
import java.util.*;
import oracle.xml.parser.v2.*;
import oracle.xml.parser.schema.*;
import org.xml.sax.*;
import org.w3c.dom.*;
import oracle.xml.sql.dataset.*;
import oracle.xml.sql.query.*;
import oracle.xml.sql.docgen.*;
import oracle.xml.sql.*;
import oracle.jdbc.driver.*;
import oracle.sql.*;
import oracle.xdb.XMLType;
public class tkxmtpk1
{
static String conStr = "jdbc:oracle:oci8:@";
static String user = "tpjc";
static String pass = "tpjc";
static String qryStr = "select x.resume from t1 x where id&lt;3";
static String xslStr =
"&lt;?xml version='1.0'?&gt; " +
"&lt;xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1" +
"999/XSL/Transform'&gt; " +
"&lt;xsl:template match='ROOT'&gt; " +
"&lt;xsl:apply-templates/&gt; " +
"&lt;/xsl:template&gt; " +
"&lt;xsl:template match='NAME'&gt; " +
"&lt;html&gt; " +
" &lt;body&gt; " +
" This is Test " +
" &lt;/body&gt; " +
"&lt;/html&gt; " +
"&lt;/xsl:template&gt; " +
"&lt;/xsl:stylesheet&gt;";
static void parseArg(String args[])
{
conStr = (args.length &gt;= 1 ? args[0]:conStr);
user = (args.length &gt;= 2 ? args[1].substring(0, args[1].indexOf("/")):user);
pass = (args.length &gt;= 2 ? args[1].substring(args[1].indexOf("/")+1):pass);
qryStr = (args.length &gt;= 3 ? args[2]:qryStr);
}
/**
* Print the byte array contents
*/
static void showValue(byte[] bytes) throws SQLException
{
if (bytes == null)
System.out.println("null");
else if (bytes.length == 0)
System.out.println("empty");
else
{
for(int i=0; i&lt;bytes.length; i++)
System.out.print((bytes[i]&amp;0xff)+" ");
System.out.println();
}
}
public static void main(String args[]) throws Exception
{
tkxmjnd1 util = new tkxmjnd1();
try{
if(args != null)
parseArg(args);
// System.out.println("conStr=" + conStr);
System.out.println("user/pass=" + user + "/" +pass );
System.out.println("qryStr=" + qryStr);
DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
Connection conn = DriverManager.getConnection(conStr, user, pass);
Statement s = conn.createStatement();
ResultSet rset = s.executeQuery(qryStr);
OracleResultSet orset = (OracleResultSet) rset;
OPAQUE xml;
while(orset.next()){
oracle.xdb.XMLType xt = (oracle.xdb.XMLType)(orset.getObject(1));
System.out.println("Testing getDOM() ...");
Document doc = xt.getDOM();
util.printDocument(doc);
System.out.println("Testing getBytesValue() ...");
showValue(xt.getBytesValue());
System.out.println("Testing existsNode() ...");
try {
System.out.println("existsNode(/)" + xt.existsNode("/", null));
}
Java DOM API for XMLType
Beta Draft Java DOM API for XMLType 15-11
catch (SQLException e) {
System.out.println("Thin driver Expected exception: " + e);
}
System.out.println("Testing extract() ...");
try {
XMLType xt1 = xt.extract("/RESUME", null);
System.out.println("extract RESUME: " + xt1.getStringVal());
System.out.println("should be Fragment: " + xt1.isFragment());
}
catch (SQLException e) {
System.out.println("Thin driver Expected exception: " + e);
}
System.out.println("Testing isFragment() ...");
try {
System.out.println("isFragment = " + xt.isFragment()); }
catch (SQLException e)
{
System.out.println("Thin driver Expected exception: " + e);
}
System.out.println("Testing isSchemaValid() ...");
try {
System.out.println("isSchemaValid(): " + xt.isSchemaValid(null,"RES UME"));
}
catch (SQLException e) {
System.out.println("Thin driver Expected exception: " + e);
}
System.out.println("Testing transform() ...");
System.out.println("XSLDOC: \n" + xslStr + "\n");
try {
/* XMLType xslDoc = XMLType.createXML(conn, xslStr);
System.out.println("XSLDOC Generated");
System.out.println("After transformation:\n" + (xt.transform(xslDoc,
null)).getStringVal()); */
System.out.println("After transformation:\n" + (xt.transform(null,
null)).getStringVal());
}
catch (SQLException e) {
System.out.println("Thin driver Expected exception: " + e);
}
System.out.println("Testing createXML(conn, doc) ...");
try {
XMLType xt1 = XMLType.createXML(conn, doc);
System.out.println(xt1.getStringVal());
}
catch (SQLException e) {
System.out.println("Got exception: " + e);
}
}
}
catch(Exception e)
{
e.printStackTrace(System.out);
}
}
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDHGIIC"></a>
<div id="ADXDB4944" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Loading a Large XML Document into the Database using <a id="sthref1148"></a><a id="sthref1149"></a>JDBC</h2>
<p>If a large XML document (greater than 4000 characters, typically) is inserted into an <code>XMLType</code> table or column using a <code>String</code> object in JDBC, this run-time error occurs:</p>
<pre>
"java.sql.SQLException: Data size bigger than max size for this type"
</pre>
<p>This error can be avoided by using a Java <code>CLOB</code> object to hold the large XML document. <a href="#CHDCHFIG">Example 15-11</a> shows code that uses this technique. It defines <code>XMLType</code> method <code><a id="sthref1150"></a><a id="sthref1151"></a><a id="sthref1152"></a>insertXML()</code>, which can be used to insert a large XML document into <code>XMLType</code> column <code>purchaseOrder</code> of table <code>poTable</code>. The same approach can be used for an <code>XMLType</code> table.</p>
<p>Method <code>insertXML()</code> uses a <code>CLOB</code> object that contains the XML document. It creates the <code>CLOB</code> object using class <code>oracle.sql.CLOB</code> on the client side. This class is the Oracle JDBC driver implementation of the standard JDBC interface <code>java.sql.Clob</code>. Method <code>insertXML()</code> binds the <code>CLOB</code> object to a JDBC prepared statement, which inserts the data into the <code>XMLType</code> column.</p>
<p>The prerequisites for using <code>insertXML()</code> are as follows:</p>
<ul>
<li>
<p>Oracle Database, release 9.2.0.1 or later.</p>
</li>
<li>
<p>The target database table. Execute the following SQL before running the example:</p>
<p><code>CREATE TABLE poTable (purchaseOrder XMLType);</code></p>
</li>
</ul>
<p>The formal parameters of <code>XMLType</code> method <code>insertXML()</code> are as follows:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">xmlData</span></code> &ndash; XML data to be inserted into the <code>XMLType</code> column</p>
</li>
<li>
<p><code><span class="codeinlineitalic">conn</span></code> &ndash; database connection object (Oracle Connection Object)</p>
</li>
</ul>
<div id="ADXDB5893" class="example">
<p class="titleinexample"><a id="CHDCHFIG"></a>Example 15-11 Java Method insertXML()</p>
<pre>
...
import oracle.sql.CLOB; 
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.PreparedStatement;
... 
 
private void <span class="bold">insertXML</span>(String xmlData, Connection conn) {
  CLOB clob = null;
  String query;
    // Initialize statement Object
  PreparedStatement pstmt = null;
  try{
    query = "INSERT INTO potable (purchaseOrder) VALUES (XMLType(?)) ";
    // Get the statement Object
    pstmt = conn.prepareStatement(query);
    // xmlData is the string that contains the XML Data.
    // Get the CLOB object.
    clob = <span class="bold">getCLOB</span>(xmlData, conn);
    // Bind this CLOB with the prepared Statement
    pstmt.setObject(1, clob);
    // Execute the Prepared Statement
    if (pstmt.executeUpdate () == 1) {
    System.out.println ("Successfully inserted a Purchase Order");
    }
  } catch(SQLException sqlexp){
    sqlexp.printStackTrace();
  } catch(Exception exp){
    exp.printStackTrace();
  }
}
</pre></div>
<!-- class="example" -->
<p>Java method <code>insertXML()</code> calls <a id="sthref1153"></a><a id="sthref1154"></a><a id="sthref1155"></a>method <code>getCLOB()</code> to create and return the <code>CLOB</code> object that holds the XML data. The formal parameters of method <code>getCLOB()</code>, which is defined in <a href="#CHDFFDJH">Example 15-12</a>, are as follows:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">xmlData</span></code> &ndash; XML data to be inserted into the <code>XMLType</code> column</p>
</li>
<li>
<p><code><span class="codeinlineitalic">conn</span></code> &ndash; database connection object (Oracle Connection Object)</p>
</li>
</ul>
<div id="ADXDB5894" class="example">
<p class="titleinexample"><a id="CHDFFDJH"></a>Example 15-12 Java Method getCLOB()</p>
<pre>
...
import oracle.sql.CLOB; 
import java.sql.Connection;
import java.sql.SQLException;
import java.io.Writer;
... 
 
private CLOB <span class="bold">getCLOB</span>(String xmlData, Connection conn) throws SQLException{
  CLOB tempClob = null;
  try{
    // If the temporary CLOB has not yet been created, create one
    tempClob = CLOB.createTemporary(conn, true, CLOB.DURATION_SESSION); 
 
    // Open the temporary CLOB in readwrite mode, to enable writing
    tempClob.open(CLOB.MODE_READWRITE); 
    // Get the output stream to write
    Writer tempClobWriter = tempClob.getCharacterOutputStream(); 
    // Write the data into the temporary CLOB
    tempClobWriter.write(xmlData); 
 
    // Flush and close the stream
    tempClobWriter.flush();
    tempClobWriter.close(); 
 
    // Close the temporary CLOB 
    tempClob.close();    
  } catch(SQLException sqlexp){
    tempClob.freeTemporary(); 
    sqlexp.printStackTrace();
  } catch(Exception exp){
    tempClob.freeTemporary(); 
    exp.printStackTrace();
  }
  return tempClob; 
}
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="sect1" -->
<a id="i1030882"></a>
<div id="ADXDB4946" class="sect1">
<h2 class="sect1">Java DOM API for <a id="sthref1156"></a>XMLType Features</h2>
<p>When you use the Java DOM API to retrieve XML data from Oracle XML&nbsp;DB:</p>
<ul>
<li>
<p>If the connection is <span class="italic">thin</span>, you get an <code><span class="codeinlinebold">XML</span></code><code>Document</code> instance</p>
</li>
<li>
<p>If the connection is <span class="italic">thick</span> or <span class="italic">kprb</span>, you get an <code><span class="codeinlinebold">XDB</span></code><code>Document</code> instance with method <code>getDOM()</code> and an <code><span class="codeinlinebold">XML</span></code><code>Document</code> instance with method <code>getDocument()</code>. Method <code>getDOM()</code> and class <code>XDBDocument</code> are deprecated.</p>
</li>
</ul>
<p>Both <code>XMLDocument</code> and <code>XDBDocument</code> (which is deprecated) are instances of the W3C Document Object Model (DOM) interface. From this document interface you can access the document elements and perform all the operations specified in the W3C DOM Recommendation. The DOM works on:</p>
<ul>
<li>
<p>Any type of XML document, schema-based or non-schema-based</p>
</li>
<li>
<p>Any type of underlying storage used by the document:</p>
<ul>
<li>
<p>Character Large Object (CLOB)</p>
</li>
<li>
<p>Binary Large Object (BLOB)</p>
</li>
<li>
<p>object-relational</p>
</li>
</ul>
</li>
</ul>
<p>The Java DOM API for <code>XMLType</code> supports deep and shallow searching in the document to retrieve children and properties of XML objects such as name, namespace, and so on. Conforming to the DOM 2.0 recommendation, Java DOM API for <code>XMLType</code> is namespace aware.</p>
<p>The Java API for <code>XMLType</code> also lets applications create XML documents programmatically, even on the fly (dynamically). Such documents can conform to a registered XML schema or not.</p>
<div id="ADXDB4947" class="sect2"><a id="sthref1157"></a>
<h3 class="sect2">Creating XML Schema-Based Documents</h3>
<p>To create XML schema-based documents, Java DOM API for <code>XMLType</code> uses an extension to specify which XML schema URL to use. For XML schema-based documents, it also verifies that the DOM being created conforms to the specified XML schema, that is, that the appropriate children are being inserted under the appropriate documents.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Java DOM API for <code>XMLType</code> does <span class="italic">not</span> perform type and constraint checks.</div>
<p>Once the DOM object has been created, it can be saved to Oracle XML&nbsp;DB Repository using the Oracle XML&nbsp;DB resource API for Java. The XML document is stored in the appropriate format:</p>
<ul>
<li>
<p>As a BLOB instance for non-schema-based documents.</p>
</li>
<li>
<p>In the format specified by the XML schema for XML schema-based documents.</p>
</li>
</ul>
<p><a href="#CHDGCCEB">Example 15-13</a> shows how you can use the Java DOM API for <code>XMLType</code> to create a DOM object and store it in the format specified by the associated XML schema. Validation against the XML schema is not shown here.</p>
<div id="ADXDB4948" class="example">
<p class="titleinexample"><a id="CHDGCCEB"></a>Example 15-13 Creating a DOM Object with the Java DOM API</p>
<pre>
import oracle.xdb.XMLType;
...
OraclePreparedStatement stmt = 
    (OraclePreparedStatement) conn.prepareStatement(
        "update po_xml_XMLTypetab set poDoc = ? ");

// the second argument is a string
String poString = "&lt;PO&gt;&lt;PONO&gt;200&lt;/PONO&gt;&lt;PNAME&gt;PO_2&lt;/PNAME&gt;&lt;/PO&gt;";
XMLType poXML = XMLType.createXML(conn, poString);
Document poDOM = (Document)poXML.getDOM();

Element rootElem = poDOM.createElement("PO");
poDOM.insertBefore(poDOM, rootElem, null);

// now bind the string..
stmt.setObject(1,poXML);
stmt.execute();
</pre></div>
<!-- class="example" -->
<a id="i1031308"></a>
<div id="ADXDB4949" class="sect3">
<h4 class="sect3">JDBC or <a id="sthref1158"></a>SQLJ</h4>
<p>An <code>XMLType</code> instance is represented in Java by <code><a id="sthref1159"></a>oracle.xdb.XMLType</code>. When an instance of <code>XMLType</code> is fetched using JDBC, it is automatically manifested as an object of the provided <code>XMLType</code> class. Similarly, objects of this class can be bound as values to Data Manipulation Language (DML) statements where an <code>XMLType</code> is expected. The same action is supported in SQLJ clients.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1031670"></a>
<div id="ADXDB4950" class="sect1">
<h2 class="sect1">Java DOM API for XMLType Classes</h2>
<p>Oracle XML&nbsp;DB supports the W3C DOM Level 2 Recommendation. In addition to the W3C Recommendation, Oracle XML&nbsp;DB DOM API also provides Oracle-specific extensions, to facilitate your application interfacing with Oracle XML Developer's Kit for Java. A list of the Oracle extensions is available at:</p>
<p><code><a href="http://www.oracle.com/technetwork/database-features/xmldb/overview/index.html">http://www.oracle.com/technetwork/database-features/xmldb/overview/index.html</a></code></p>
<p><code>XMLDocument</code> is a class that represents the DOM for the instantiated XML document. You can retrieve the <code>XMLType</code> value from the XML document using the constructor <code>XMLType</code> constructor that takes a <code>Document</code> argument:</p>
<p><code>XMLType createXML(Connection conn, Document domdoc)</code></p>
<p><a href="#i1031365">Table 15-1</a> lists the Java DOM API for <code>XMLType</code> classes and the W3C DOM interfaces they implement. The Java DOM API classes are all in package <code>oracle.xml.parser.v2</code>.</p>
<div id="ADXDB4951" class="tblhruleformal">
<p class="titleintable"><a id="sthref1160"></a><a id="sthref1161"></a>Table 15-1 <a id="i1031365"></a><span class="bolditalic">Java DOM API for XMLType: Classes</span></p>
<table class="cellalignment1032" title="Java DOM API for XMLType: Classes" summary="This table describes the Java DOM API for XMLType classes. It includes a listing of the equivalent W3C classes." >
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t7">Java DOM API for XMLType Class</th>
<th class="cellalignment1027" id="r1c2-t7">W3C DOM Interface Recommendation Class</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t7" headers="r1c1-t7">
<pre>
XMLDocument
</pre></td>
<td class="cellalignment1028" headers="r2c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Document 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t7" headers="r1c1-t7">
<pre>
XMLCDATA
</pre></td>
<td class="cellalignment1028" headers="r3c1-t7 r1c2-t7">
<pre>
org.w3c.dom.CDataSection 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t7" headers="r1c1-t7">
<pre>
XMLComment
</pre></td>
<td class="cellalignment1028" headers="r4c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Comment 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t7" headers="r1c1-t7">
<pre>
XMLPI
</pre></td>
<td class="cellalignment1028" headers="r5c1-t7 r1c2-t7">
<pre>
org.w3c.dom.ProcessingInstruction 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t7" headers="r1c1-t7">
<pre>
XMLText 
</pre></td>
<td class="cellalignment1028" headers="r6c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Text 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t7" headers="r1c1-t7">
<pre>
XMLEntity
</pre></td>
<td class="cellalignment1028" headers="r7c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Entity 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t7" headers="r1c1-t7">
<pre>
DTD
</pre></td>
<td class="cellalignment1028" headers="r8c1-t7 r1c2-t7">
<pre>
org.w3c.dom.DocumentType 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t7" headers="r1c1-t7">
<pre>
XMLNotation
</pre></td>
<td class="cellalignment1028" headers="r9c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Notation 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t7" headers="r1c1-t7">
<pre>
XMLAttr
</pre></td>
<td class="cellalignment1028" headers="r10c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Attribute 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t7" headers="r1c1-t7">
<pre>
XMLDomImplementation
</pre></td>
<td class="cellalignment1028" headers="r11c1-t7 r1c2-t7">
<pre>
org.w3c.dom.DOMImplementation 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t7" headers="r1c1-t7">
<pre>
XMLElement
</pre></td>
<td class="cellalignment1028" headers="r12c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Element 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r13c1-t7" headers="r1c1-t7">
<pre>
XMLAttrList
</pre></td>
<td class="cellalignment1028" headers="r13c1-t7 r1c2-t7">
<pre>
org.w3c.dom.NamedNodeMap 
</pre></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r14c1-t7" headers="r1c1-t7">
<pre>
XMLNode 
</pre></td>
<td class="cellalignment1028" headers="r14c1-t7 r1c2-t7">
<pre>
org.w3c.dom.Node 
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<a id="CHDFAGHG"></a>
<div id="ADXDB4952" class="sect2">
<h3 class="sect2">Java Methods That Are Deprecated or Not Supported</h3>
<p>The following methods documented in release 2 (9.2.0.1) are no longer supported:</p>
<ul>
<li>
<p><code>XDBDocument.getElementByID</code></p>
</li>
<li>
<p><code>XDBDocument.importNode</code></p>
</li>
<li>
<p><code>XDBNode.normalize</code></p>
</li>
<li>
<p><code>XDBNode.isSupported</code></p>
</li>
<li>
<p><code>XDBDomImplementation.hasFeature</code></p>
</li>
</ul>
<p>In addition, in releases prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 1, a different API, in package <code>oracle.xdb.dom</code>, was used for the Java DOM. Please refer to the documentation for such releases for more information on that deprecated API. The following classes in <code>oracle.xdb.dom</code> are <span class="italic">deprecated</span>. Use <code>oracle.xml.parser.v2</code> classes instead.</p>
<ul>
<li>
<p><code>XDBAttribute</code> &ndash; use <code>XMLAttr</code></p>
</li>
<li>
<p><code>XDBBinaryDocument</code></p>
</li>
<li>
<p><code>XDBCData</code> &ndash; use <code>XMLCDATA</code></p>
</li>
<li>
<p><code>XDBComment</code> &ndash; use <code>XMLComment</code></p>
</li>
<li>
<p><code>XDBDocFragment</code> &ndash; use <code>XMLDocumentFragment</code></p>
</li>
<li>
<p><code>XDBDocument</code> &ndash; use <code>XMLDocument</code></p>
</li>
<li>
<p><code>XDBDocumentType</code> &ndash; use <code>DTD</code></p>
</li>
<li>
<p><code>XDBDOMException</code> &ndash; use <code>XMLDomException</code></p>
</li>
<li>
<p><code>XDBDomImplementation</code> &ndash; use <code>XMLDomImplementation</code></p>
</li>
<li>
<p><code>XDBElement</code> &ndash; use <code>XMLElement</code></p>
</li>
<li>
<p><code>XDBEntity</code> &ndash; use <code>XMLEntity</code></p>
</li>
<li>
<p><code>XDBEntityReference</code> &ndash; use <code>XMLEntityReference</code></p>
</li>
<li>
<p><code>XDBNamedNodeMap</code> &ndash; use <code>XMLAttrList</code></p>
</li>
<li>
<p><code>XDBNode</code> &ndash; use <code>XMLNode</code></p>
</li>
<li>
<p><code>XDBNodeList</code> &ndash; use <code>NodeList</code></p>
</li>
<li>
<p><code>XDBNotation</code> &ndash; use <code>XMLNotation</code></p>
</li>
<li>
<p><code>XDBProcInst</code> &ndash; use <code>XMLPI</code></p>
</li>
<li>
<p><code>XDBText</code> &ndash; use <code>XMLText</code></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB4953" class="sect2"><a id="sthref1162"></a>
<h3 class="sect2">Using the Java DOM API for XMLType</h3>
<p><a href="#i1031454">Figure 15-1</a> illustrates how to use the Java DOM API for <code>XMLType</code>.<a id="sthref1163" href="#sthref1163" onclick='footdisplay(1,"This assumes that your XML data is pre-registered with an XML schema, and that it is stored in an \u003ccode\u003eXMLType\u003c/code\u003e column.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a> These are the steps:</p>
<ol>
<li>
<p>Retrieve the XML data from the <code>XMLType</code> table or <code>XMLType</code> column in the table. When you fetch XML data, Oracle creates an instance of an <code>XMLType</code>. You can then use method <code>getDocument()</code> to retrieve a Document instance. You can then manipulate elements in the DOM tree using Java DOM API for <code>XMLType</code>.</p>
</li>
<li>
<p>Use the Java DOM API for <code>XMLType</code> to manipulate elements of the DOM tree. The XMLType instance holds the modified data, but the data is sent back using a JDBC update.</p>
</li>
</ol>
<p>The <code>XMLType</code> and <code>XMLDocument</code> instances should be closed using method <code>close()</code> in the respective classes. This frees any underlying memory that is held.</p>
<div id="ADXDB4954" class="figure">
<p class="titleinfigure"><a id="i1031454"></a>Figure 15-1 Using the Java DOM API for XMLType</p>
<img width="323" height="300" src="img/adxdb024.gif" alt="Description of Figure 15-1 follows" /><br />
<a id="sthref1164" href="img_text/adxdb024.htm">Description of "Figure 15-1 Using the Java DOM API for XMLType"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEBEFB"></a>
<div id="ADXDB1150" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Handling <a id="sthref1165"></a>Large Nodes using Java</h2>
<p>Prior to Oracle Database 11g Release 1 (11.1), there were restrictions on the size of nodes to less than 64 KB, because the Java methods to set and get a node value supported only arguments of type <code>java.lang.String</code>. The maximum size of a string is dependent on the implementation of the Java VM, but it is bounded. Prior to Release 11.1, the Java DOM APIs to manage a node value, contained within class <code>oracle.xdb.dom.XDBNode.java</code>, were these:</p>
<pre>
public String getNodeValue ();
public void setNodeValue (String value);
</pre>
<p>The Java DOM APIs to manage an attribute, contained within class <code>oracle.xdb.dom.XDBAttribute.java</code>, were these:</p>
<pre>
public String getValue ();
public void setValue (String value);
</pre>
<p>Package <code>oracle.xdb.dom</code> is deprecated, starting with Oracle Database 11g Release 1 (11.1). Java classes <code>XDBNode</code> and <code>XDBAttribute</code> in that package are replaced by classes <code>XMLNode</code> and <code>XMLAttr</code>, respectively, in package <code>oracle.xml.parser.v2</code>. In addition, these DOM APIs were extended in Release 11.1 to support text and binary node values of arbitrary size.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The large-node feature works only with a thick or kprb connection. It does not work with a thin connection.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb10pls.htm#CHDDHHEG">"Large Node Handling using DBMS_XMLDOM"</a> for information on using PL/SQL with large nodes</p>
</li>
<li>
<p><a href="#CHDFAGHG">"Java Methods That Are Deprecated or Not Supported"</a> for more about deprecated classes <code>XDBNode</code> and <code>XDBAttribute</code></p>
</li>
</ul>
</div>
<div id="ADXDB4955" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1166"></a>
<h3 class="sect2">Stream Extensions to Java DOM</h3>
<p>All <code>Java String</code>, <code>Reader</code>, and <code>Writer</code> data is represented in <code>UCS2</code>, which might be different from the database character set. Additionally, node character data is tagged with a character set id, which is set at the time the node value is populated.</p>
<p>The following methods of <code>oracle.xml.parser.v2.XMLNode.java</code> can be used to access nodes of size greater than 64 KB. These APIs throw exceptions if you try to get or set a node that is not a leaf node (attribute, <code>PI</code>, <code>CDATA</code>, and so on). Also, be sure to use <code>close()</code> which actually writes the value and frees resources used to maintain the state for streaming access to nodes.</p>
<div id="ADXDB4956" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1167"></a>
<h4 class="sect3">Get-Pull Model</h4>
<p>For a binary input stream:</p>
<pre>
public java.io.InputStream getNodeValueAsBinaryStream () 
       throws java.io.IOException, DOMException;
</pre>
<p>Method <code>getNodeValueAsBinaryStream()</code> returns an instance of <code>java.io.InputStream</code> that can be read using the defined methods for this class. The data type of the node must be <code>RAW</code> or <code>BLOB</code>. If not, an <code>IOException</code> is thrown. The following example fragment illustrates reading the value of a node in binary 50-byte segments:</p>
<pre>
...
oracle.xml.parser.v2.XMLNode node = null;
...
 
java.io.InputStream value = node.getNodeValueAsBinaryStream ();
// now read InputStream...
byte buffer [] = new byte [50];
int returnValue = 0;
while ((returnValue = value.read (buffer)) != -1)
{
   // process next 50 bytes of node
}
...
</pre>
<p>For a character input stream:</p>
<pre>
public java.io.Reader getNodeValueAsCharacterStream() 
       throws java.io.IOException, DOMException;
</pre>
<p>Method <code>getNodeValueAsCharacterStream()</code> returns an instance of <code>java.io.Reader</code> that can be read using the defined methods for this class. If the data type of the node is neither character nor <code>CLOB</code>, the node data is first converted to character. All node data is ultimately in character format and is converted to <code>UCS2</code>, if necessary. The following example fragment illustrates reading the node value in segments of 50 characters:</p>
<pre>
...
oracle.xml.parser.v2.XMLNode node = null;
...
 
java.io.Reader value = node.getNodeValueAsCharacterStream ();
// now read InputStream
char buffer [] = new char [50];
int returnValue = 0;
while ((returnValue = value.read (buffer)) != -1)
{
   // process next 50 characters of node
}
...
</pre></div>
<!-- class="sect3" -->
<div id="ADXDB4957" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1168"></a>
<h4 class="sect3">Get-Push Model</h4>
<p>For a binary output stream:</p>
<pre>
public void getNodeValueAsBinaryStream (java.io.OutputStream pushValue) 
       throws java.io.IOException,  DOMException;
</pre>
<p>The state of the <code>java.io.OutputStream</code> specified by <code>pushValue</code> must be open. The data type of the node must be <code>RAW</code> or <code>BLOB</code>. If not, an <code>IOException</code> is thrown. The node binary data is written to <code>pushValue</code> using method <code>write()</code> of <code>OutputStream</code>, and method <code>close()</code> is called when the node value has been completely written to the stream.</p>
<p>For a character output stream:</p>
<pre>
public void getNodeValueAsCharacterStream (java.io.Writer pushValue) 
       throws java.io.IOException, DOMException;
</pre>
<p>The state of the <code>java.io.Writer</code> specified by <code>pushValue</code> must be open. If the data type of the node is neither character nor <code>CLOB</code>, then the data is first converted to character. The node data, always in character format, is converted, as necessary, to <code>UCS2</code> and then pushed into the <code>java.io.Writer</code>.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4958" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1169"></a>
<h4 class="sect3">Set-Pull Model</h4>
<p>For a binary input stream:</p>
<pre>
public void setNodeValueAsBinaryStream (java.io.InputStream pullValue) 
       throws java.io.IOException, DOMException;
</pre>
<p>The state of the <code>java.io.InputStream</code> specified by <code>pullValue</code> must be open. The data type of the node must be <code>RAW</code> or <code>BLOB</code>. If not, an <code>IOException</code> is thrown. The binary data from <code>pullValue</code> is read in its entirety using method <code>read()</code> of <code>InputStream</code> and replaces the node value.</p>
<pre>
import java.io.InputStream;
import oracle.xml.parser.*;
...
oracle.xml.parser.v2.XMLNode node = null;
...
byte [] buffer = new byte [500];
java.io.InputStream  istream; //user-defined input stream
node.setNodeValueAsBinaryStream (istream);
</pre>
<p>For a character input stream:</p>
<pre>
public void setNodeValueAsCharacterStream (java.io.Reader pullValue) 
       throws java.io.IOException, DOMException;
</pre>
<p>The state of the <code>java.io.Reader</code> specified by <code>pullValue</code> must be open. If the data type of the node is neither character nor <code>CLOB</code>, the character data is converted from <code>UCS2</code> to the node data type. If the data type of the node is character or <code>CLOB</code>, then the character data read from <code>pullValue</code> is converted from <code>UCS2</code> to the character set of the node.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4959" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1170"></a>
<h4 class="sect3">Set-Push Model</h4>
<p>For a binary output stream:</p>
<pre>
public java.io.OutputStream setNodeValueAsBinaryStream () 
     throws java.io.IOException, DOMException;
</pre>
<p>Method <code>setNodeValueAsBinaryStream()</code> returns an instance of <code>java.io.OutputStream</code>, into which the caller can write the node value. The data type of the node must be <code>RAW</code> or <code>BLOB</code>. Otherwise, an <code>IOException</code> is raised. The following example fragment illustrates setting the value of a node to binary data by writing to the implementation of <code>java.io.OutputStream</code> provided by Oracle XML&nbsp;DB or Oracle XML Developer's Kit.</p>
<p>For a character output stream:</p>
<pre>
public java.io.Writer setNodeValueAsCharacterStream () 
       throws java.io.IOException, DOMException;
</pre>
<p>Method <code>setNodeValueAsCharacterStream()</code> returns an instance of <code>java.io.Writer</code> into which the caller can write the node value. The character data written is first converted from <code>UCS2</code> to the node character set, if necessary. If the data type of the node is neither character nor <code>CLOB</code>, then the character data is converted to the node data type. Similarly, the following example fragment illustrates setting the value of a node to character data by writing to the implementation of <code>java.io.Writer</code> provided by Oracle XML&nbsp;DB or Oracle XML Developer's Kit.</p>
<pre>
import java.io.Writer;
import oracle.xml.parser.*;
...
oracle.xml.parser.v2.XMLNode node = null;
...
char [] buffer = new char [500];
java.io.Writer  writer = node.setNodeValueAsCharacterStream ();
for (int k = 0; k &lt; 10; k++)
  {
    byte segment [] = new byte [50];
    // copy next subset of buffer into segment
    writer.write (segment);
  }
writer.flush ();
writer.close();
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a></p>
</li>
<li>
<p><a class="olink CAXML" href="../e10770/toc.htm"><span class="italic">Oracle Database XML C API Reference</span></a> for information about C functions for large nodes</p>
</li>
</ul>
</div>
<p>Oracle XML&nbsp;DB creates a <code>writer</code> or <code>OutputStream</code> and passes it to the user who calls method <code>write()</code> repeatedly until the complete node value has been written. The new node value is reflected only when the user calls method <code>close()</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDHGHDG"></a>
<div id="ADXDB4960" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the Java DOM API and JDBC with Binary XML</h2>
<p>XML data can be stored in Oracle XML&nbsp;DB using <code>XMLType</code>, and one of the storage models for this abstract data type is binary XML. Binary XML is a compact, XML Schema-aware encoding of XML data. You can use it as a storage model for <code>XMLType</code> in the database, but you can also use it for XML data located outside the database. Client-side processing of XML data can involve data stored in Oracle XML&nbsp;DB or transient data that resides outside the database.</p>
<p>You can use the Java DOM API for XML to read or write XML data that is encoded as binary XML from or to Oracle XML&nbsp;DB. Doing so involves the usual read and write procedures.</p>
<p>Binary XML is XML Schema-aware and can use various encoding schemes, depending on your needs and your data. Because of this, in order to manipulate binary XML data, you must have both the data and this metadata about the relevant XML schemas and encodings.</p>
<p>For <code>XMLType</code> data stored in the database, this metadata is also stored in the database. However, depending on how your database and data are set up, the metadata might not be on the same server as the data it applies to. If this is the case, then, before you can read or write binary XML data from or to the database, you must carry out these steps:</p>
<ol>
<li>
<p>Create a context instance for the metadata.</p>
</li>
<li>
<p>Associate this context with a data connection that you use to access binary XML data in the database. A data connection can be a dedicated connection or a connection pool. You use methods <code>getDedicatedConn()</code> and <code>getConnPool()</code> in class <code>java.sql.Connection</code> to obtain handles to these two types of connection, respectively.</p>
</li>
</ol>
<p>Then, when your application needs to encode or decode binary XML data on the data connection, it automatically fetches the metadata needed for that. The overall sequence of actions is thus as follows:</p>
<ol>
<li>
<p>Create an XML data connection object, in class <code>java.sql.Connection</code>.</p>
</li>
<li>
<p>Create one or more metadata contexts, as needed, using method <code>BinXMLMetadataProviderFactory.createDBMetadataProvider()</code> in package <code>oracle.xml.binxml</code>. A metadata context is sometimes referred to as a metadata repository. You can create a metadata context from a dedicated connection or from a connection pool.</p>
</li>
<li>
<p>Associate the metadata context(s) with the binary XML data connection(s). Use method <code>DBBinXMLMetadataProvider.associateDataConnection()</code> in package <code>oracle.xml.binxml</code> to do this.</p>
</li>
<li>
<p>(Optional) If the XML data originated outside of the database, use method <code>oracle.xdb.XMLType.setFormatPref()</code> to specify that XML data to be sent to the database be encoded in the binary XML format. This applies to a DOM document (class <code>oracle.xdb.XMLType</code>). If you do not specify binary XML, the data is sent to the database as text.</p>
</li>
<li>
<p>Use the usual Java methods to read and write XML data from and to the database. Whenever it is needed for encoding or decoding binary XML documents, the necessary metadata is fetched automatically using the metadata context.</p>
<p>Use the Java DOM API for XML to operate on the XML data at the client level.</p>
</li>
</ol>
<p><a href="#CHDJJAED">Example 15-14</a> illustrates this.</p>
<div id="ADXDB4961" class="example">
<p class="titleinexample"><a id="CHDJJAED"></a>Example 15-14 Using the Java DOM API with Binary XML</p>
<pre>
import java.sql.*;
import oracle.jdbc.*;
import oracle.jdbc.pool.OracleDataSource;
import oracle.xdb.XMLType;
import oracle.xml.binxml.*;
 
class tdadxdbxdb11jav001 {
  public static void printBinXML() throws SQLException, BinXMLException
  {
    // Create datasource to connect to local database
    OracleDataSource ods = new OracleDataSource();
    ods.setURL("jdbc:oracle:kprb");
    System.out.println("Starting Binary XML Java Example");
    // Create data connection
    Connection conn = ods.<span class="bold">getConnection</span>();
    // Create binary XML metadata context, using connection pool
    DBBinXMLMetadataProvider repos =
      <span class="bold">BinXMLMetadataProviderFactory.createDBMetadataProvider</span>();
    repos.<span class="bold">setConnectionPool</span>(ods);
    // Associate metadata context with data connection
    repos.<span class="bold">associateDataConnection</span>(conn);
    // Query XML data stored in XMLType column as binary XML
    Statement stmt = conn.createStatement();
    ResultSet rset = stmt.executeQuery("SELECT doc FROM po_binxmltab");
    // Get the XMLType object
    while (rset.next())
    {
      XMLType xmlobj = (XMLType) rset.getObject(1);
      // Perform XMLType operation
      String xmlvalue = xmlobj.getStringVal();
      System.out.println(xmlvalue);
    }
    // Close result set, statement, and connection
    rset.close();
    stmt.close();
    conn.close();
    System.out.println("Completed Binary XML Java Example");
  }
}
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb01int.htm#BABECDCF">"XMLType Storage Models"</a></p>
</li>
<li>
<p><a class="olink ADXDK4440" href="../../appdev.112/e23582/adx_j_xmlbin.htm#ADXDK4440"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;This assumes that your XML data is pre-registered with an XML schema, and that it is stored in an <code>XMLType</code> column.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="xdb_dbmstore.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb12oci.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
