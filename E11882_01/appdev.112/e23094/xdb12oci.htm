<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using the C API for XML</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:15Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="xdb11jav.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb_odpnet.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">26/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='xdb12oci'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADXDB1400" class="chapter"><a id="BABHFHIB"></a>
<h1 class="chapter"><span class="secnum">16</span> Using the <a id="sthref1171"></a><a id="sthref1172"></a>C API for XML</h1>
<p>This chapter provides help for using the C API for XML with Oracle XML&nbsp;DB. It contains these topics:</p>
<ul>
<li>
<p><a href="#BABGJEFA">Overview of the C API for XML (Oracle XDK and Oracle XML&nbsp;DB)</a></p>
</li>
<li>
<p><a href="#BGBGDJDI">Using OCI and the C API for XML with Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BGBBAGEE">XML Context Parameter for C DOM API Functions</a></p>
</li>
<li>
<p><a href="#BABFAIBI">Initializing and Terminating an XML Context</a></p>
</li>
<li>
<p><a href="#CHDGIDHJ">Using the C API for XML with Binary XML</a></p>
</li>
<li>
<p><a href="#CHDGCDHD">Using the Oracle XML Developer's Kit Pull Parser with Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#BGBIGBBE">Common XMLType Operations in C</a></p>
</li>
</ul>
<a id="BABGJEFA"></a>
<div id="ADXDB4962" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of the C API for XML (Oracle XDK and Oracle XML&nbsp;DB)</h2>
<p>The C API for XML is used for both Oracle XML Developer's Kit (XDK) and Oracle XML&nbsp;DB. It is a C-based DOM<a id="sthref1173" href="#sthref1173" onclick='footdisplay(1,"DOM refers to compliance with the World Wide Web Consortium (W3C) DOM 2.0 Recommendation.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a> API for XML. It can be used for XML data that is inside or outside the database. This API also includes performance-improving extensions that you can use in XDK for traditional storage of XML data, or in Oracle XML&nbsp;DB for storage as an <code>XMLType</code> column in a table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
C DOM functions from releases prior to Oracle Database&nbsp;10<span class="italic">g</span> Release 1 are supported only for backward compatibility.</div>
<p>The C API for XML is implemented on <code>XMLType</code> in Oracle XML&nbsp;DB. In the W3C DOM Recommendation, the term "document" is used in a broad sense (URI, file system, memory buffer, standard input and output). The C API for XML is a combined programming interface that includes all of the functionality needed by Oracle XML Developer's Kit and Oracle XML&nbsp;DB applications. It provides XSLT and XML Schema implementations. Although the DOM 2.0 Recommendation was followed closely, some naming changes were required for mapping from the objected-oriented DOM 2.0 Recommendation to the flat C namespace. For example, method <code>getName()</code> was renamed to <code>getAttrName()</code>.</p>
<p>The C API for XML supersedes older Oracle APIs. In particular, the <code>oraxml</code> interface (top-level, DOM, SAX, and XSLT) and <code>oraxsd.h</code> (Schema) interfaces will be deprecated in a future release.</p>
</div>
<!-- class="sect1" -->
<a id="BGBGDJDI"></a>
<div id="ADXDB4963" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using OCI and the C API for XML with Oracle XML&nbsp;DB</h2>
<p>OCI applications typically operate on XML data stored in the server or created on the client. This section explains these two access methods in more detail.</p>
<div id="ADXDB4964" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1174"></a>
<h3 class="sect2">Accessing XMLType Data Stored in the Database</h3>
<p>Oracle XML&nbsp;DB provides support for storing and manipulating XML instances using abstract data type <code>XMLType</code>. These XML instances can be accessed and manipulated on the client side using the Oracle Call Interface (OCI) in conjunction with the C DOM API for XML. You can bind and define <code>XMLType</code> values using the C DOM structure <code>xmldocnode</code>. This structure can be used for binding, defining and operating on XML values in OCI statements. You can use OCI statements to select XML data from the server, which you can then use with C DOM API functions. Similarly, values can be bound back to SQL statements directly.</p>
<p>The main flow for an application program involves initializing the usual OCI handles, such as server handle and statement handle, and then initializing an XML context parameter. You can then either operate on XML instances in the database or create new instances on the client side. The initialized XML context can be used with all of the C DOM functions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BGBBAGEE">"XML Context Parameter for C DOM API Functions"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4965" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1175"></a>
<h3 class="sect2">Creating XMLType Instances on the Client</h3>
<p>You can construct new <code>XMLType</code> instances on the client side using <code>XmlLoadDom()</code>, as follows:</p>
<ol>
<li>
<p>Initialize the <code>xmlctx</code> as in <a href="#CHDGCGGE">Example 16-1</a>.</p>
</li>
<li>
<p>Construct the XML data from a user buffer, local file, or URI. The return value, a (<code>xmldocnode*</code>), can be used in the rest of the common C API.</p>
</li>
<li>
<p>If required, you can cast (<code>xmldocnode *</code>) to (<code>void*</code>) and provide it directly as the bind value.</p>
</li>
</ol>
<p>You can construct empty <code>XMLType</code> instances with <code>XMLCreateDocument()</code>. This is similar to using <code>OCIObjectNew()</code> for other types.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BGBBAGEE"></a>
<div id="ADXDB4966" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">XML Context Parameter for C DOM API Functions</h2>
<p>An <span class="italic">XML context</span> is a required parameter to all the C DOM API functions. This opaque context encapsulates information about the data encoding, the error message language, and so on. The contents of the context are different for Oracle XML Developer's Kit applications and Oracle XML&nbsp;DB. For Oracle XML&nbsp;DB, there are two OCI functions that initialize (<code>OCIXmlDbInitXmlCtx()</code>) and terminate (<code>OCIXmlDbFreeXmlCtx()</code>) an XML context.</p>
<div id="ADXDB4967" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1176"></a>
<h3 class="sect2">OCIXmlDbInitXmlCtx() Syntax</h3>
<p>The syntax of function <code>OCIXmlDbInitXmlCtx()</code> is as follows:</p>
<pre>
xmlctx *OCIXmlDbInitXMlCtx (OCIEnv        *envhp,
                            OCISvcHp      *svchp,
                            OCIError      *errhp,
                            ocixmldbparam *params,
                            ub4           num_params);
</pre>
<p><a href="#BGGHEDDH">Table 16-1</a> describes the parameters.</p>
<div id="ADXDB4968" class="tblhruleformal">
<p class="titleintable"><a id="sthref1177"></a><a id="BGGHEDDH"></a>Table 16-1 OCIXmlDbInitXMlCtx() Parameters</p>
<table class="cellalignment1032" title="OCIXmlDbInitXMlCtx() Parameters " summary="This table describes the OCIXmlDBlInitXmlCtx parameters." >
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t4">Parameter</th>
<th class="cellalignment1027" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t4" headers="r1c1-t4">
<p><code>envhp (IN)</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t4 r1c2-t4">
<p>The OCI environment handle.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t4" headers="r1c1-t4">
<p><code>svchp (IN)</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t4 r1c2-t4">
<p>The OCI service handle.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t4" headers="r1c1-t4">
<p><code>errhp (IN)</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t4 r1c2-t4">
<p>The OCI error handle.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t4" headers="r1c1-t4">
<p><code>params (IN)</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t4 r1c2-t4">
<p>An array of optional values:</p>
<ul>
<li>
<p>OCI duration. Default value is <code>OCI_DURATION_SESSION</code>.</p>
</li>
<li>
<p>Error handler, which is a user-registered callback:</p>
<pre>
void (*err_handler) (sword errcode, 
                     (CONST OraText *) errmsg);
</pre></li>
</ul>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t4" headers="r1c1-t4">
<p><code>num_params (IN)</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t4 r1c2-t4">
<p>Number of parameters to be read from <code>params</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect2" -->
<div id="ADXDB4969" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1178"></a>
<h3 class="sect2">OCIXmlDbFreeXmlCtx() Syntax</h3>
<p>The syntax of function <code>OCIXmlDbFreeXmlCtx()</code> is as follows, where parameter <code>xctx (IN)</code> is the XML context to terminate.:</p>
<pre>
void OCIXmlDbFreeXmlCtx (xmlctx *xctx);
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFAIBI"></a>
<div id="ADXDB4970" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Initializing and Terminating an XML Context</h2>
<p><a href="#CHDGCGGE">Example 16-1</a> shows a C program that uses the C&nbsp;DOM API to construct an XML document and save it to Oracle Database in table <code>my_table</code>. It calls OCI functions <code>OCIXmlDbInitXmlCtx()</code> and <code>OCIXmlDbFreeXmlCtx()</code> to initialize and terminate the XML context. These OCI functions are defined in header file <code>ocixmldb.h</code>.</p>
<p>The C code in <a href="#CHDGCGGE">Example 16-1</a> assumes that the following SQL code has first been executed to create table <code>my_table</code> in database schema <code>capiuser</code>:</p>
<pre>
CONNECT CAPIUSER
Enter password: <span class="italic">password</span>

Connected.

CREATE TABLE my_table OF XMLType;
</pre>
<p><a href="#CHDGCGGE">Example 16-1</a> shows how to use OCI functions <code>OCIXmlDbInitXmlCtx()</code> and <code>OCIXmlDbFreeXmlCtx()</code> to initialize and terminate the XML context.</p>
<div id="ADXDB4971" class="example">
<p class="titleinexample"><a id="CHDGCGGE"></a>Example 16-1 Using OCIXMLDBINITXMLCTX() and OCIXMLDBFREEXMLCTX()</p>
<pre>
#ifndef S_ORACLE
#include &lt;s.h&gt;
#endif
#ifndef ORATYPES_ORACLE
#include &lt;oratypes.h&gt;
#endif
#ifndef XML_ORACLE
#include &lt;xml.h&gt;
#endif
#ifndef OCIXML_ORACLE
#include &lt;ocixml.h&gt;
#endif
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
#include &lt;string.h&gt;
 
typedef struct test_ctx {
        OCIEnv *envhp;
        OCIError *errhp;
        OCISvcCtx *svchp;
        OCIStmt *stmthp;
        OCIServer *srvhp;
        OCIDuration dur;
        OCISession *sesshp;
        oratext *username;
        oratext *password;
} test_ctx;
 
/* Helper function 1: execute a sql statement which binds xml data */
STATICF sword <span class="bold">exec_bind_xml</span>(OCISvcCtx *svchp,
                    OCIError *errhp,
                    OCIStmt *stmthp,
                    void *xml,
                    OCIType *xmltdo,
                    OraText *sqlstmt);
 
/* Helper function 2: Initialize OCI handles and connect */
STATICF sword <span class="bold">init_oci_handles</span>(test_ctx *ctx);
 
/* Helper function 3: Free OCI handles and disconnect */
STATICF <span class="bold">sword free_oci_handles</span>(test_ctx *ctx);
 
void <span class="bold">main</span>()
{
  test_ctx temp_ctx;
  test_ctx *ctx = &amp;temp_ctx;
  OCIType *xmltdo = (OCIType *) 0;
  xmldocnode *doc = (xmldocnode *)0;
  ocixmldbparam params[1];
  xmlnode *quux, *foo, *foo_data, *top;
  xmlerr err;
  sword status = 0;
  xmlctx *xctx;
 
  oratext ins_stmt[] = "insert into my_table values (:1)"; 
  oratext tlpxml_test_sch[] = "<span class="bold">&lt;TOP/&gt;</span>";
  ctx-&gt;username = (oratext *)"capiuser";
  ctx-&gt;password = (oratext *)"***********"; /* Replace with real password */
 
  /* Initialize envhp, svchp, errhp, dur, stmthp */
  init_oci_handles(ctx);
 
  /* Get an xml context */
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;ctx-&gt;dur;
  xctx = <span class="bold">OCIXmlDbInitXmlCtx</span>(ctx-&gt;envhp, ctx-&gt;svchp, ctx-&gt;errhp, params, 1);
 
  /* Start processing - first, check that this DOM supports XML 1.0 */
  printf("\n\nSupports XML 1.0? : %s\n",
         <span class="bold">XmlHasFeature</span>(xctx, (oratext *) "xml", (oratext *) "1.0") ?
         "YES" : "NO");
 
  /* Parse a document */
  if (!(doc = <span class="bold">XmlLoadDom</span>(xctx, &amp;err, "buffer", tlpxml_test_sch,
                         "buffer_length", sizeof(tlpxml_test_sch)-1,
                         "validate", TRUE, NULL)))
  {
    printf("Parse failed, code %d\n", err);
  }
  else
  {
    /* Get the document element */
    top = (xmlnode *)<span class="bold">XmlDomGetDocElem</span>(xctx, doc);
 
    /* Print out the top element */
    printf("\n\nOriginal top element is :\n");   
    <span class="bold">XmlSaveDom</span>(xctx, &amp;err, top, "stdio", stdout, NULL);
 
    /* Print out the document-note that the changes are reflected here */
    printf("\n\nOriginal document is :\n");
    <span class="bold">XmlSaveDom</span>(xctx, &amp;err, (xmlnode *)doc, "stdio", stdout, NULL);
 
    /* Create some elements and add them to the document */
    quux = (xmlnode *) <span class="bold">XmlDomCreateElem</span>(xctx ,doc, (oratext *) "<span class="bold">QUUX</span>");
    foo = (xmlnode *) <span class="bold">XmlDomCreateElem</span>(xctx, doc, (oratext *) "<span class="bold">FOO</span>");
    foo_data = (xmlnode *) <span class="bold">XmlDomCreateText</span>(xctx, doc, (oratext *) "<span class="bold">data</span>");
    foo_data = <span class="bold">XmlDomAppendChild</span>(xctx, (xmlnode *) foo, (xmlnode *) foo_data);
    foo = <span class="bold">XmlDomAppendChild</span>(xctx, quux, foo);
    quux = <span class="bold">XmlDomAppendChild</span>(xctx, top, quux);
 
    /* Print out the top element */
    printf("\n\nNow the top element is :\n");   
    <span class="bold">XmlSaveDom</span>(xctx, &amp;err, top, "stdio", stdout, NULL);
 
    /* Print out the document. Note that the changes are reflected here */
    printf("\n\nNow the document is :\n");
    <span class="bold">XmlSaveDom</span>(xctx, &amp;err, (xmlnode *)doc, "stdio", stdout, NULL);
 
    /* Insert the document into my_table */
    status = OCITypeByName(ctx-&gt;envhp, ctx-&gt;errhp, ctx-&gt;svchp, 
                           (const text *) "SYS", (ub4) strlen((char *)"SYS"), 
                           (const text *) "XMLTYPE",
                           (ub4) strlen((char *)"XMLTYPE"), (CONST text *) 0,
                           (ub4) 0, OCI_DURATION_SESSION, OCI_TYPEGET_HEADER,
                           (OCIType **) &amp;xmltdo);
    if (status == OCI_SUCCESS)
    {
      exec_bind_xml(ctx-&gt;svchp, ctx-&gt;errhp, ctx-&gt;stmthp, (void *)doc, xmltdo, 
                    ins_stmt);
    }
  }
  /* Free xml ctx */
  <span class="bold">OCIXmlDbFreeXmlCtx</span>(xctx);
 
  /* Free envhp, svchp, errhp, stmthp */
  free_oci_handles(ctx);
}
</pre>
<p>The output from compiling and running this C program is as follows:</p>
<pre>
Supports XML 1.0? : YES
 
Original top element is :
&lt;TOP/&gt;
 
Original document is :
&lt;TOP/&gt;
 
Now the top element is :
&lt;TOP&gt;
  &lt;QUUX&gt;
    &lt;FOO&gt;data&lt;/FOO&gt;
  &lt;/QUUX&gt;
&lt;/TOP&gt;
 
Now the document is :
&lt;TOP&gt;
  &lt;QUUX&gt;
    &lt;FOO&gt;data&lt;/FOO&gt;
  &lt;/QUUX&gt;
&lt;/TOP&gt;
</pre>
<p>This is the result of querying the constructed document in <code>my_table</code>:</p>
<pre>
SELECT * FROM my_table;

SYS_NC_ROWINFO$
---------------
&lt;TOP&gt; 
  &lt;QUUX&gt; 
    &lt;FOO&gt;data&lt;/FOO&gt; 
  &lt;/QUUX&gt; 
&lt;/TOP&gt; 
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHDGCGGE">Example 16-1</a> constructs an XML document using the C&nbsp;DOM API and saves it to the database. The code uses helper functions <code>exec_bind_xml</code>, <code>init_oci_handles</code>, and <code>free_oci_handles</code>, which are not listed here. The complete listing of this example, including the helper functions, can be found in <a href="apphxdb.htm#g648966">Appendix A, "Oracle-Supplied XML Schemas and Examples"</a>, <a href="apphxdb.htm#BABHEICJ">"Initializing and Terminating an XML Context (OCI)"</a>.</p>
<p><a href="#CHDBIHJI">Example 16-4</a> queries table <code>my_table</code> to show the data that was inserted by <a href="#CHDGCGGE">Example 16-1</a>.</p>
</div>
<!-- class="sect1" -->
<a id="CHDGIDHJ"></a>
<div id="ADXDB4976" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the C API for XML with Binary XML</h2>
<p>XML data can be stored in Oracle XML&nbsp;DB using <code>XMLType</code>, and one of the storage models for this abstract data type is binary XML. Binary XML is a compact, XML Schema-aware encoding of XML data. You can use it as a storage model for <code>XMLType</code> in the database, but you can also use it for XML data located outside the database. As explained in <a href="#BGBGDJDI">"Using OCI and the C API for XML with Oracle XML&nbsp;DB"</a>, client-side processing of XML data can involve data stored in Oracle XML&nbsp;DB or transient data that resides outside the database.</p>
<p>You can use the C API for XML to read or write XML data that is encoded as binary XML from or to Oracle XML&nbsp;DB. Doing so involves the usual read and write procedures.</p>
<p>Binary XML is XML Schema-aware and can use various encoding schemes, depending on your needs and your data. Because of this, in order to manipulate binary XML data, you must have both the data and this metadata about the relevant XML schemas and encodings.</p>
<p>For <code>XMLType</code> data stored in the database, this metadata is also stored in the database. However, depending on how your database and data are set up, the metadata might not be on the same server as the data it applies to. If this is the case, then, before you can read or write binary XML data from or to the database, you must carry out these steps:</p>
<ol>
<li>
<p>Create a context instance for the metadata.</p>
</li>
<li>
<p>Associate this context with a data connection that you use to access binary XML data in the database. A data connection can be a dedicated connection (<code>OCISvcCtx</code>) or a connection pool (<code>OCICPool</code>).</p>
</li>
</ol>
<p>Then, when your application needs to encode or decode binary XML data on the data connection, it automatically fetches the metadata needed for that. The overall sequence of actions is thus as follows:</p>
<ol>
<li>
<p>Create the usual OCI handles for environment (<code>OCIEnv</code>), connection (<code>OCISvcCtx</code>), and error context (<code>OCIError</code>).</p>
</li>
<li>
<p>Create one or more metadata contexts, as needed. A metadata context is sometimes referred to as a metadata repository, and <code>OCIBinXMLReposCtx</code> is the OCI context data structure.</p>
<p>You use <code>OCIBinXMLCreateReposCtxFromConn</code> to create a metadata context from a dedicated connection and <code>OCIBinXMLCreateReposCtxFromCPool</code> to create a context from a connection pool.</p>
</li>
<li>
<p>Associate the metadata context(s) with the binary XML data connection(s). You use <code>OCIBinXmlSetReposCtxForConn</code> to do this.</p>
</li>
<li>
<p>(Optional) If the XML data originated outside of the database, use <code>setPicklePreference</code> to specify that XML data to be sent to the database from now on is in binary XML format. This applies to a DOM document (<code>xmldomdoc</code>). If you do not specify binary XML, the data is stored as text (<code>CLOB</code>).</p>
</li>
<li>
<p>Use OCI libraries to read and write XML data from and to the database. Whenever it is needed for encoding or decoding binary XML documents, the necessary metadata is fetched automatically using the metadata context.</p>
<p>Use the C DOM API for XML to operate on the XML data at the client level.</p>
</li>
</ol>
<p><a href="#CHDEHEHF">Example 16-2</a> illustrates this.</p>
<div id="ADXDB4977" class="example">
<p class="titleinexample"><a id="CHDEHEHF"></a>Example 16-2 Using the C API for XML with Binary XML</p>
<pre>
<span class="bold">. . .</span>
/* Private types and constants */
#define SCHEMA        (OraText *)"SYS"
#define TYPE          (OraText *)"XMLTYPE"
#define USER          (OraText *)"oe"
#define USER_LEN      (ub2)(strlen((char *)USER))
#define PWD           (OraText *)"oe"
#define PWD_LEN       (ub2)(strlen((char *)PWD))
#define NUM_PARAMS    1
STATICF void checkerr(OCIError *errhp, sword status);
STATICF sword create_env(OraText *user, ub2 user_len, OraText *pwd, ub2 pwd_len,
                         OCIEnv **envhp, OCISvcCtx **svchp, OCIError **errhp);
STATICF sword run_example(OCIEnv *envhp, OCISvcCtx *svchp, OCIError *errhp,
                          OCIDuration dur);
STATICF void cleanup(OCIEnv *envhp, OCISvcCtx *svchp, OCIError *errhp);
 
int <span class="bold">main</span> (int argc, char *argv[])
{
  OCIEnv     *envhp;
  <span class="bold">OCISvcCtx</span>  *svchp;
  OCIError   *errhp;
  printf("*** Starting Binary XML Example program\n");
  if (create_env(USER, USER_LEN, PWD, PWD_LEN, &amp;envhp, &amp;svchp, &amp;errhp))
    {
      printf("FAILED: create_env()\n");
      cleanup(envhp, svchp, errhp);
      return OCI_ERROR;
    }
  if (run_example(envhp, svchp, errhp, OCI_DURATION_SESSION))
    {
      printf("FAILED: run_example()\n");
      cleanup(envhp, svchp, errhp);
      return OCI_ERROR;
    }
  cleanup(envhp, svchp, errhp);
  printf ("*** Completed Binary XML example\n");
  return OCI_SUCCESS;
}
 
STATICF sword <span class="bold">create_env</span>(OraText *user, ub2 user_len,
                         OraText *pwd,  ub2 pwd_len,
                         OCIEnv **envhp, OCISvcCtx **svchp, OCIError **errhp)
{
  sword       status;
  OCIServer  *srvhp;
  OCISession *usrp;
  OCICPool   *poolhp;
  OraText    *poolname;
  ub4         poolnamelen;
  OraText    *database =(OraText *)"";
  <span class="bold">OCIBinXmlReposCtx</span> *rctx;
  /* Create and initialize environment. Allocate error handle. */
  <span class="bold">. . .</span>
  if ((status = OCIConnectionPoolCreate((dvoid *)*envhp, (dvoid*)*errhp,
                                        (dvoid *)poolhp, &amp;poolname,
                                        (sb4 *)&amp;poolnamelen, 
                                        (OraText *)0, 
                                        (sb4) 0, 1, 10, 1, 
                                        (OraText *)USER, 
                                        (sb4) USER_LEN, 
                                        (OraText *)PWD, 
                                        (sb4) PWD_LEN,
                                        OCI_DEFAULT)) != OCI_SUCCESS)
    {
      printf ("OCIConnectionPoolCreate - Fail %d\n", status);
      return OCI_ERROR;
    }
  status = OCILogon2((OCIEnv *)*envhp, *errhp, svchp, (OraText *)USER,
                     (ub4)USER_LEN, (const oratext *)PWD, (ub4)PWD_LEN,
                     (const oratext *)poolname, poolnamelen, OCI_CPOOL);
  if (status)
    {
      printf ("OCILogon2 - Fail %d\n", status);
      return OCI_ERROR;
    }
  <span class="bold">OCIBinXmlCreateReposCtxFromCPool</span>(*envhp, poolhp, *errhp, &amp;rctx);
  <span class="bold">OCIBinXmlSetReposCtxForConn</span>(*svchp, rctx);
  return OCI_SUCCESS;
}
 
STATICF sword <span class="bold">run_example</span>(OCIEnv *envhp, OCISvcCtx *svchp, OCIError *errhp,
                          OCIDuration dur)
{
  OCIType   *xmltdo = (OCIType *)0;
  OCIStmt   *stmthp;
  OCIDefine *defnp;
  xmldocnode *xmldoc = (xmldocnode *)0;
  ub4        xmlsize = 0;
  text      *selstmt = (text *)"SELECT doc FROM po_binxmltab";
  sword      status;
  struct xmlctx *xctx = (xmlctx *) 0;
  ocixmldbparam params[NUM_PARAMS];
  xmlerr xerr = (xmlerr) 0;
  /* Obtain type definition for XMLType. Allocate statement handle.
     Prepare SELECT statement. Define variable for XMLType. Execute statement. */
  <span class="bold">. . .</span>
  /* Construct xmlctx for using XML C API */
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;dur;
  xctx = OCIXmlDbInitXmlCtx(envhp, svchp, errhp, params, NUM_PARAMS);
  /* Print result to local string */
  XmlSaveDom(xctx, &amp;xerr, (xmlnode *)xmldoc, "stdio", stdout, NULL);
  /* Free instances */
  <span class="bold">. . .</span>
}
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb01int.htm#BABECDCF">"XMLType Storage Models"</a></p>
</li>
<li>
<p><a class="olink ADXDK1810" href="../../appdev.112/e23582/adx_c_xmlbin.htm#ADXDK1810"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CHDGCDHD"></a>
<div id="ADXDB4978" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the Oracle XML Developer's Kit Pull Parser with Oracle XML&nbsp;DB</h2>
<p>You can use the Oracle XML Developer's Kit pull parser with <code>XMLType</code> instances in Oracle XML&nbsp;DB. When you use this parser, parsing is done on demand, so your application drives the parsing process. Your application accesses an XML document through a sequence of events, with start tags, end tags, and comments, just as in Simple API for XML (SAX) parsing. However, unlike the case of SAX parsing, where parsing events are handled by callbacks, in pull parsing your application calls methods to ask for (pull) events only when it needs them. This gives the application more control over XML processing. In particular, filtering is more flexible with the pull parser than with the SAX parser.</p>
<p>You can also use the Oracle XML Developer's Kit pull parser to perform stream-based XML Schema validation.</p>
<p><a href="#CHDIFDBE">Example 16-3</a> shows how to use the Oracle XML&nbsp;DB pull parser with an <code>XMLType</code> instance. To use the pull parser, you also need static library <code>libxml10.a</code> on UNIX and Linux systems or <code>oraxml10.dll</code> on Microsoft Windows systems. You also need header file <code>xmlev.h</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADXDK1410" href="../../appdev.112/e23582/adx_c_parser.htm#ADXDK1410"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a> for information about the Oracle XML Developer's Kit pull parser</p>
</li>
<li>
<p><a class="olink ADXDK1600" href="../../appdev.112/e23582/adx_c_sproc.htm#ADXDK1600"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a> for information on using the pull parser for stream-based validation</p>
</li>
</ul>
</div>
<div id="ADXDB4979" class="example">
<p class="titleinexample"><a id="CHDIFDBE"></a>Example 16-3 Using the Oracle XML&nbsp;DB Pull Parser</p>
<pre>
#define MAXBUFLEN 64*1024
void main()
{
  test_ctx temp_ctx;
  test_ctx *ctx = &amp;temp_ctx;
  OCIType *xmltdo = (OCIType *) 0;
  ocixmldbparam params[1];
  sword status = 0;
  xmlctx *xctx;
  OCIDefine *defnp = (OCIDefine *) 0;
  oratext sel_stmt[] =
    "<span class="bold">SELECT XMLSerialize(DOCUMENT x.OBJECT_VALUE AS CLOB) FROM PURCHASEORDER x where rownum = 1</span>";
  OCILobLocator *cob;
  ub4 amtp, nbytes;
  ub1 bufp[MAXBUFLEN];
  ctx-&gt;username = (oratext *)"oe";
  ctx-&gt;password = (oratext *)"*************";    /* Replace with real password */
 
  <span class="bold">/* Initialize envhp, svchp, errhp, dur, stmthp */</span>
  init_oci_handles(ctx);
 
  <span class="bold">/* Get an xml context */</span>
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;ctx-&gt;dur;
  xctx = OCIXmlDbInitXmlCtx(ctx-&gt;envhp, ctx-&gt;svchp, ctx-&gt;errhp, params, 1);
 
  <span class="bold">/* Start processing */</span>
  printf("\n\n<span class="bold">Supports XML 1.0? :</span> %s\n",
         XmlHasFeature(xctx, (oratext *) "xml", (oratext *) "1.0") ?
         "YES" : "NO");
 
  <span class="bold">/* Allocate the lob descriptor */</span>
  status = OCIDescriptorAlloc((dvoid *) ctx-&gt;envhp, (dvoid **) &amp;clob,
                       (ub4)OCI_DTYPE_LOB, (size_t) 0, (dvoid **) 0);
  if (status)
  {
    printf("OCIDescriptorAlloc Failed\n");
    goto error;
  }
  status = OCIStmtPrepare(ctx-&gt;stmthp, ctx-&gt;errhp,
                 (CONST OraText *)sel_stmt, (ub4) strlen((char *)sel_stmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  if (status)
  {
    printf("OCIStmtPrepare Failed\n");
    goto error;
  }
  status = OCIDefineByPos(ctx-&gt;stmthp, &amp;defnp, ctx-&gt;errhp, (ub4) 1,
                 (dvoid *) &amp;clob, (sb4) -1, (ub2 ) SQLT_CLOB,
                 (dvoid *) 0, (ub2 *)0,
                 (ub2 *)0, (ub4) OCI_DEFAULT);
  if (status)
  {
    printf("OCIDefineByPos Failed\n");
    goto error;
  }
  status = OCIStmtExecute(ctx-&gt;svchp, ctx-&gt;stmthp, ctx-&gt;errhp, (ub4) 1,
                          (ub4) 0, (CONST OCISnapshot*) 0, (OCISnapshot*) 0,
                          (ub4) OCI_DEFAULT);
  if (status)
  {
    printf("OCIStmtExecute Failed\n");
    goto error;
  }
  /* read the fetched value into a buffer */
  amtp = nbytes = MAXBUFLEN-1;
  status = OCILobRead(ctx-&gt;svchp, ctx-&gt;errhp, clob, &amp;amtp,
                (ub4) 1, (dvoid *) bufp, (ub4) nbytes, (dvoid *)0,
                (sb4 (*)(dvoid *, CONST dvoid *, ub4, ub1)) 0,
                (ub2) 0, (ub1) SQLCS_IMPLICIT);
  if (status)
  {
    printf("OCILobRead Failed\n");
    goto error;
  }
  bufp[amtp] = '\0';
  if (amtp &gt; 0)
  {
     printf("\n<span class="bold">=&gt; Query result</span> of %s: \n%s\n", sel_stmt, bufp);
     <span class="bold">/********** PULL PARSING ******************/</span>
     status = pp_parse(xctx, bufp, amtp);
     if (status)
       printf("Pull Parsing failed\n");
  }
error: 
  <span class="bold">/* Free XML Ctx */</span>
  OCIXmlDbFreeXmlCtx(xctx);
 
  <span class="bold">/* Free envhp, svchp, errhp, stmthp */</span>
  free_oci_handles(ctx);
}
#define ERRBUFLEN 256
sb4 pp_parse(xctx, buf, amt)
xmlctx  *xctx;
oratext *buf;
ub4     amt;
{
  xmlevctx *evctx;
  xmlerr   xerr = XMLERR_OK;
  oratext  message[ERRBUFLEN];
  oratext  *emsg = message;
  xmlerr   ecode;
  boolean  done, inattr = FALSE;
  xmlevtype event;
 
  <span class="bold">/* Create an XML event context - Pull Parser Context */</span>
  evctx = XmlEvCreatePPCtx(xctx, &amp;xerr,
                           "expand_entities", FALSE,
                           "validate", TRUE,
                           "attr_events", TRUE,
                           "raw_buffer_len", 1024,
                           NULL);
 if (!evctx)
  {
    printf("FAILED: XmlEvCreatePPCtx: %d\n", xerr);
    return OCI_ERROR;
  }
  <span class="bold">/* Load the document from input buffer */</span>
  xerr = XmlEvLoadPPDoc(xctx, evctx, "buffer", buf, amt, "utf-8");
  if (xerr)
  {
    printf("FAILED: XmlEvLoadPPDoc: %d\n", xerr);
    return OCI_ERROR;
  }
 <span class="bold"> /* Process the events until END_DOCUMENT event or error */</span>
  done = FALSE;
  while(!done)
  {
    event = XmlEvNext(evctx);
    switch(event)
    {
      case XML_EVENT_START_ELEMENT:
        printf("<span class="bold">START ELEMENT:</span> %s\n", XmlEvGetName0(evctx));
        break;
      case XML_EVENT_END_ELEMENT:
        printf("<span class="bold">END ELEMENT:</span> %s\n", XmlEvGetName0(evctx));
        break;
      case XML_EVENT_START_DOCUMENT:
        printf("<span class="bold">START DOCUMENT</span>\n");
        break;
      case XML_EVENT_END_DOCUMENT:
        printf("<span class="bold">END DOCUMENT</span>\n");
        done = TRUE;
        break;
      case XML_EVENT_START_ATTR:
        printf("<span class="bold">START ATTRIBUTE:</span> %s\n", XmlEvGetAttrName0(evctx, 0));
        inattr = TRUE;
        break;
      case XML_EVENT_END_ATTR:
        printf("<span class="bold">END ATTRIBUTE:</span> %s\n", XmlEvGetAttrName0(evctx, 0));
        inattr = FALSE;
        break;
      case XML_EVENT_CHARACTERS:
        if (inattr)
          printf("<span class="bold">ATTR VALUE:</span> %s\n", XmlEvGetText0(evctx));
        else
          printf("<span class="bold">TEXT:</span> %s\n", XmlEvGetText0(evctx));
        break;
      case XML_EVENT_ERROR:
      case XML_EVENT_FATAL_ERROR:
        done = TRUE;
        ecode = XmlEvGetError(evctx, &amp;emsg);
        printf("ERROR: %d: %s\n", ecode, emsg);
        break;
    }
  }
  <span class="bold">/* Destroy the event context */</span>
  XmlEvDestroyPPCtx(xctx, evctx);
  return OCI_SUCCESS;
}
</pre>
<p>The output from compiling and running this C program is as follows:</p>
<pre>
<span class="bold">=&gt; Query result</span> of XMLSerialize(DOCUMENT x.OBJECT_VALUE AS CLOB) FROM PURCHASEORDER x where rownum = 1: 
&lt;PurchaseOrder xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:noNamespaceSchemaLocation=
                 "http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd"&gt;
  &lt;Reference&gt;AMCEWEN-20021009123336171PDT&lt;/Reference&gt;
  &lt;Actions&gt;
    &lt;Action&gt;
      &lt;User&gt;KPARTNER&lt;/User&gt;
    &lt;/Action&gt;
  &lt;/Actions&gt;
  &lt;Reject/&gt;
  &lt;Requestor&gt;Allan D. McEwen&lt;/Requestor&gt;
  &lt;User&gt;AMCEWEN&lt;/User&gt;
  &lt;CostCenter&gt;S30&lt;/CostCenter&gt;
  &lt;ShippingInstructions&gt;
    &lt;name&gt;Allan D. McEwen&lt;/name&gt;
    &lt;address&gt;Oracle Plaza
Twin Dolphin Drive
Redwood Shores
CA
94065
USA&lt;/address&gt;
    &lt;telephone&gt;650 506 7700&lt;/telephone&gt;
  &lt;/ShippingInstructions&gt;
  &lt;SpecialInstructions&gt;Ground&lt;/SpecialInstructions&gt;
  &lt;LineItems&gt;
    &lt;LineItem ItemNumber="1"&gt;
      &lt;Description&gt;Salesman&lt;/Description&gt;
      &lt;Part Id="37429158920" UnitPrice="39.95" Quantity="2"/&gt;
    &lt;/LineItem&gt;
    <span class="bold">. . .</span>
  &lt;/LineItems&gt;
&lt;/PurchaseOrder&gt;
 
START DOCUMENT
START ELEMENT: PurchaseOrder
START ATTRIBUTE: xmlns:xsi
ATTR VALUE: http://www.w3.org/2001/XMLSchema-instance
END ATTRIBUTE: xmlns:xsi
START ATTRIBUTE: xsi:noNamespaceSchemaLocation
ATTR VALUE: http://localhost:8080/source/schemas/poSource/xsd/purchaseOrder.xsd
END ATTRIBUTE: xsi:noNamespaceSchemaLocation
START ELEMENT: Reference
TEXT: AMCEWEN-20021009123336171PDT
END ELEMENT: Reference
START ELEMENT: Actions
START ELEMENT: Action
START ELEMENT: User
TEXT: KPARTNER
END ELEMENT: User
END ELEMENT: Action
END ELEMENT: Actions
START ELEMENT: Reject
END ELEMENT: Reject
START ELEMENT: Requestor
TEXT: Allan D. McEwen
END ELEMENT: Requestor
START ELEMENT: User
TEXT: AMCEWEN
END ELEMENT: User
START ELEMENT: CostCenter
TEXT: S30
END ELEMENT: CostCenter
START ELEMENT: ShippingInstructions
START ELEMENT: name
TEXT: Allan D. McEwen
END ELEMENT: name
START ELEMENT: address
TEXT: Oracle Plaza
Twin Dolphin Drive
Redwood Shores
CA
94065
USA
END ELEMENT: address
START ELEMENT: telephone
TEXT: 650 506 7700
END ELEMENT: telephone
END ELEMENT: ShippingInstructions
START ELEMENT: SpecialInstructions
TEXT: Ground
END ELEMENT: SpecialInstructions
START ELEMENT: LineItems
START ELEMENT: LineItem
START ATTRIBUTE: ItemNumber
ATTR VALUE: 1
END ATTRIBUTE: ItemNumber
START ELEMENT: Description
TEXT: Salesman
END ELEMENT: Description
START ELEMENT: Part
START ATTRIBUTE: Id
ATTR VALUE: 37429158920
END ATTRIBUTE: Id
START ATTRIBUTE: UnitPrice
ATTR VALUE: 39.95
END ATTRIBUTE: UnitPrice
START ATTRIBUTE: Quantity
ATTR VALUE: 2
END ATTRIBUTE: Quantity
END ELEMENT: Part
END ELEMENT: LineItem
<span class="bold">. . .</span>
END ELEMENT: LineItems
END ELEMENT: PurchaseOrder
END DOCUMENT
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="BGBIGBBE"></a>
<div id="ADXDB4980" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Common XMLType Operations in C</h2>
<p><a href="#BABGGACF">Table 16-2</a> provides the <code>XMLType</code> functional equivalent of common XML operations.</p>
<div id="ADXDB4981" class="tblformal">
<p class="titleintable"><a id="sthref1179"></a><a id="BABGGACF"></a>Table 16-2 Common XMLType Operations in C</p>
<table class="cellalignment1026" title="Common XMLType Operations in C " summary="This table describes the C API for XML&rsquo;s XMLType functions." dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t7">Description</th>
<th class="cellalignment1027" id="r1c2-t7">C API XMLType Function</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t7" headers="r1c1-t7">
<p>Create empty <code>XMLType</code> instance</p>
</td>
<td class="cellalignment1028" headers="r2c1-t7 r1c2-t7">
<p><code>XmlCreateDocument()</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t7" headers="r1c1-t7">
<p>Create from a source buffer</p>
</td>
<td class="cellalignment1028" headers="r3c1-t7 r1c2-t7">
<p><code>XmlLoadDom()</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t7" headers="r1c1-t7">
<p>Extract an XPath expression</p>
</td>
<td class="cellalignment1028" headers="r4c1-t7 r1c2-t7">
<p><code>XmlXPathEvalexpr()</code> and family</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t7" headers="r1c1-t7">
<p>Transform using an XSLT style sheet</p>
</td>
<td class="cellalignment1028" headers="r5c1-t7 r1c2-t7">
<p><code>XmlXslProcess()</code> and family</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t7" headers="r1c1-t7">
<p>Check if an XPath exists</p>
</td>
<td class="cellalignment1028" headers="r6c1-t7 r1c2-t7">
<p><code>XmlXPathEvalexpr()</code> and family</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t7" headers="r1c1-t7">
<p>Is document schema-based?</p>
</td>
<td class="cellalignment1028" headers="r7c1-t7 r1c2-t7">
<p><code>XmlDomIsSchemaBased()</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t7" headers="r1c1-t7">
<p>Get schema information</p>
</td>
<td class="cellalignment1028" headers="r8c1-t7 r1c2-t7">
<p><code>XmlDomGetSchema()</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t7" headers="r1c1-t7">
<p>Get document namespace</p>
</td>
<td class="cellalignment1028" headers="r9c1-t7 r1c2-t7">
<p><code>XmlDomGetNodeURI()</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t7" headers="r1c1-t7">
<p>Validate using schema</p>
</td>
<td class="cellalignment1028" headers="r10c1-t7 r1c2-t7">
<p><code>XmlSchemaValidate()</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t7" headers="r1c1-t7">
<p>Obtain DOM from XMLType</p>
</td>
<td class="cellalignment1028" headers="r11c1-t7 r1c2-t7">
<p>Cast <code>(void *)</code> to <code>(xmldocnode *)</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t7" headers="r1c1-t7">
<p>Obtain XMLType from DOM</p>
</td>
<td class="cellalignment1028" headers="r12c1-t7 r1c2-t7">
<p>Cast <code>(xmldocnode *)</code> to <code>(void *)</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDK1400" href="../../appdev.112/e23582/adx_c_parser.htm#ADXDK1400"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a> "XML Parser for C"</div>
<p><a href="#CHDBIHJI">Example 16-4</a> shows how to use the DOM to determine how many instances of a particular part have been ordered. The part in question has <code>Id</code> <code>37429158722</code>. See <a href="apphxdb.htm#g648966">Appendix A, "Oracle-Supplied XML Schemas and Examples"</a>, <a href="apphxdb.htm#BABGHJFA">Example A-5</a> for the definitions of helper functions <code>exec_bind_xml</code>, <code>free_oci_handles</code>, and <code>init_oci_handles</code>.</p>
<div id="ADXDB4982" class="example">
<p class="titleinexample"><a id="CHDBIHJI"></a>Example 16-4 Using the DOM to Count Ordered Parts</p>
<pre>
#ifndef S_ORACLE
#include &lt;s.h&gt;
#endif
#ifndef ORATYPES_ORACLE
#include &lt;oratypes.h&gt;
#endif
#ifndef XML_ORACLE
#include &lt;xml.h&gt;
#endif
#ifndef OCIXML_ORACLE
#include &lt;ocixml.h&gt;
#endif
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
#include &lt;string.h&gt;
 
typedef struct test_ctx {
        OCIEnv *envhp;
        OCIError *errhp;
        OCISvcCtx *svchp;
        OCIStmt *stmthp;
        OCIServer *srvhp;
        OCIDuration dur;
        OCISession *sesshp;
        oratext *username;
        oratext *password;
} test_ctx;
 
/* Helper function 1: execute a sql statement which binds xml data */
STATICF sword <span class="bold">exec_bind_xml</span>(OCISvcCtx *svchp,
                    OCIError *errhp,
                    OCIStmt *stmthp,
                    void *xml,
                    OCIType *xmltdo,
                    OraText *sqlstmt);
 
/* Helper function 2: Initialize OCI handles and connect */
STATICF sword <span class="bold">init_oci_handles</span>(test_ctx *ctx);
 
/* Helper function 3: Free OCI handles and disconnect */
STATICF sword <span class="bold">free_oci_handles</span>(test_ctx *ctx);
 
void <span class="bold">main</span>()
{
  test_ctx temp_ctx;
  test_ctx *ctx = &amp;temp_ctx;
  OCIType *xmltdo = (OCIType *) 0;
  xmldocnode *doc = (xmldocnode *)0;
  ocixmldbparam params[1];
  xmlnode *quux, *foo, *foo_data, *top;
  xmlerr err;
  sword status = 0;
  xmlctx *xctx;
  ub4 xmlsize = 0;
  OCIDefine *defnp = (OCIDefine *) 0;
  oratext sel_stmt[] = "SELECT SYS_NC_ROWINFO$ FROM PURCHASEORDER";
  xmlnodelist *litems = (xmlnodelist *)0;
  xmlnode *item = (xmlnode *)item;
  xmlnode *part;
  xmlnamedmap *attrs;
  xmlnode *id;
  xmlnode *qty;
  oratext *idval;
  oratext *qtyval;
  ub4 total_qty;
  int i;
  int numdocs;
  
  ctx-&gt;username = (oratext *)"oe";
  ctx-&gt;password = (oratext *)"***********";   /* Replace with real password */

  /* Initialize envhp, svchp, errhp, dur, stmthp */
  init_oci_handles(ctx);
 
  /* Get an xml context */
  params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
  params[0].value_ocixmldbparam = &amp;ctx-&gt;dur;
  xctx = OCIXmlDbInitXmlCtx(ctx-&gt;envhp, ctx-&gt;svchp, ctx-&gt;errhp, params, 1);
 
  /* Start processing */
  printf("\n\n<span class="bold">Supports XML 1.0? :</span> %s\n",
         XmlHasFeature(xctx, (oratext *) "xml", (oratext *) "1.0") ?
         "YES" : "NO");
 
  /* Get the documents from the database using a select statement */
  status = OCITypeByName(ctx-&gt;envhp, ctx-&gt;errhp, ctx-&gt;svchp, (const text *) "SYS",
                         (ub4) strlen((char *)"SYS"), (const text *) "XMLTYPE",
                         (ub4) strlen((char *)"XMLTYPE"), (CONST text *) 0,
                         (ub4) 0, OCI_DURATION_SESSION, OCI_TYPEGET_HEADER,
                         (OCIType **) &amp;xmltdo);
  status = OCIStmtPrepare(ctx-&gt;stmthp, ctx-&gt;errhp,
                 (CONST OraText *)sel_stmt, (ub4) strlen((char *)sel_stmt),
                 (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT);
  status = OCIDefineByPos(ctx-&gt;stmthp, &amp;defnp, ctx-&gt;errhp, (ub4) 1, (dvoid *) 0,
                 (sb4) 0, SQLT_NTY, (dvoid *) 0, (ub2 *)0,
                 (ub2 *)0, (ub4) OCI_DEFAULT);
  status = OCIDefineObject(defnp, ctx-&gt;errhp, (OCIType *) xmltdo,
                  (dvoid **) &amp;doc,
                  &amp;xmlsize, (dvoid **) 0, (ub4 *) 0);
  status = OCIStmtExecute(ctx-&gt;svchp, ctx-&gt;stmthp, ctx-&gt;errhp, (ub4) 0, (ub4) 0,
                 (CONST OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT);
 
  /* Initialize variables */
  total_qty = 0;
  numdocs = 0; 
 
  /* Loop through all the documents */
  while ((status = OCIStmtFetch2(ctx-&gt;stmthp, ctx-&gt;errhp, (ub4) 1, (ub4) OCI_FETCH_NEXT,
                                 (ub4)1, (ub4) OCI_DEFAULT)) == 0)
  {
    numdocs++;
 
    /* Get all the LineItem elements */
    litems = XmlDomGetDocElemsByTag(xctx, doc, (oratext *)"LineItem");
    i = 0;
 
    /* Loop through all LineItems */
    while (item = XmlDomGetNodeListItem(xctx, litems, i))
    {
      /* Get the part */
      part = XmlDomGetLastChild(xctx, item);
     
      /* Get the attributes */
      attrs = XmlDomGetAttrs(xctx, (xmlelemnode *)part);
 
      /* Get the id attribute and its value */
      id = XmlDomGetNamedItem(xctx, attrs, (oratext *)"Id");
      idval = XmlDomGetNodeValue(xctx, id);
 
      /* Keep only parts with id 37429158722 */
      if (idval &amp;&amp; (strlen((char *)idval) == 11 )
          &amp;&amp; !strncmp((char *)idval, (char *)"37429158722", 11))
      {
        /* Get the quantity attribute and its value.*/
        qty = XmlDomGetNamedItem(xctx, attrs, (oratext *)"Quantity");
        qtyval = XmlDomGetNodeValue(xctx, qty);
 
        /* Add the quantity to total_qty */
        total_qty += atoi((char *)qtyval);
      }
      i++;
    }
    XmlFreeDocument(xctx, doc);
    doc = (xmldocnode *)0;
  }
  printf("<span class="bold">Total quantity needed for part 37429158722 =</span> %d\n", total_qty);
  printf("<span class="bold">Number of documents in table PURCHASEORDER =</span> %d\n", numdocs);
 
  /* Free Xml Ctx */
  OCIXmlDbFreeXmlCtx(xctx);
 
  /* Free envhp, svchp, errhp, stmthp */
  free_oci_handles(ctx);
}
</pre>
<p>The output from compiling and running this C program is as follows:</p>
<pre>
Supports XML 1.0? : YES
Total quantity needed for part 37429158722 = 42
Number of documents in table PURCHASEORDER = 132
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;DOM refers to compliance with the World Wide Web Consortium (W3C) DOM 2.0 Recommendation.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="xdb11jav.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb_odpnet.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
