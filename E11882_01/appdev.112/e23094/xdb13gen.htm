<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Generating XML Data from the Database</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:15Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="partpg4.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb14vie.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">29/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='xdb13gen'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADXDB1600" class="chapter"><a id="g1047191"></a>
<h1 class="chapter"><span class="secnum">18</span> Generating <a id="sthref1182"></a>XML Data from the Database</h1>
<p>This chapter describes Oracle XML&nbsp;DB features for generating (constructing) XML data from relational data in the database. It describes the SQL/XML standard functions and Oracle Database-provided functions and packages for generating XML data from relational content.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#i1027254">Overview of Generating XML Data From Oracle Database</a></p>
</li>
<li>
<p><a href="#i1029583">Generating XML using SQL Functions</a></p>
</li>
<li>
<p><a href="#i1025386">Generating XML using DBMS_XMLGEN</a></p>
</li>
<li>
<p><a href="#i1026349">SYS_XMLGEN Oracle SQL Function</a></p>
</li>
<li>
<p><a href="#i1031169">SYS_XMLAGG Oracle SQL Function</a></p>
</li>
<li>
<p><a href="#BABJGBCH">Guidelines for Generating XML with Oracle XML&nbsp;DB</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a> for information about constructing XML data using SQL/XML functions <code>XMLQuery</code> and <code>XMLTable</code></div>
<a id="i1027254"></a>
<div id="ADXDB4987" class="sect1">
<h2 class="sect1">Overview of Generating XML Data From Oracle Database</h2>
<p><a id="i1028072"></a>You can generate XML data with Oracle Database in all of these ways:</p>
<ul>
<li>
<p>Use standard SQL/XML functions. See <a href="#i1029583">"Generating XML using SQL Functions"</a>.</p>
</li>
<li>
<p>Use <a id="sthref1183"></a>Oracle SQL functions&thinsp;. See the following sections:</p>
<ul>
<li>
<p><a href="#CHDEGCFD">XMLROOT Oracle SQL Function</a></p>
</li>
<li>
<p><a href="#i1032060">XMLCOLATTVAL Oracle SQL Function</a></p>
</li>
<li>
<p><a href="#CHDGCFFI">XMLCDATA Oracle SQL Function</a></p>
</li>
<li>
<p><a href="#i1026349">SYS_XMLGEN Oracle SQL Function</a>. This operates on rows, generating XML documents.</p>
</li>
<li>
<p><a href="#i1031169">SYS_XMLAGG Oracle SQL Function</a>. This operates on groups of rows, aggregating several XML documents into one.</p>
</li>
</ul>
</li>
<li>
<p>Use PL/SQL package <code>DBMS_XMLGEN</code>. See <a href="#i1025386">"Generating XML using DBMS_XMLGEN"</a>.</p>
</li>
<li>
<p>Use a <code>DBURIType</code> instance to construct XML documents from database data. See <a href="xdb15dbu.htm#BABIBHDB">Chapter 20, "Accessing Data Through URIs"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb03usg.htm#g1055369">Chapter 3, "Using Oracle XML&nbsp;DB"</a></p>
</li>
<li>
<p><a href="xdb08tra.htm#g1030361">Chapter 11, "Transforming and Validating XMLType Data"</a></p>
</li>
<li>
<p><a href="xdb10pls.htm#g1056962">Chapter 13, "PL/SQL APIs for XMLType"</a></p>
</li>
<li>
<p><a href="xdb11jav.htm#g1039140">Chapter 15, "Java DOM API for XMLType"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1029583"></a>
<div id="ADXDB1620" class="sect1">
<h2 class="sect1">Generating <a id="sthref1184"></a>XML using SQL Functions</h2>
<p>This section describes SQL functions that you can use to construct XML data. Most of these functions belong to the SQL/XML standard.</p>
<ul>
<li>
<p><a href="#i1028612">XMLELEMENT and XMLATTRIBUTES SQL/XML Functions</a></p>
</li>
<li>
<p><a href="#i1028160">XMLFOREST SQL/XML Function</a></p>
</li>
<li>
<p><a href="#i1032050">XMLCONCAT SQL/XML Function</a></p>
</li>
<li>
<p><a href="#i1028180">XMLAGG SQL/XML Function</a></p>
</li>
<li>
<p><a href="#CHDGHGGJ">XMLPI SQL/XML Function</a></p>
</li>
<li>
<p><a href="#CHDFCEBI">XMLCOMMENT SQL/XML Function</a></p>
</li>
<li>
<p><a href="#CHDDIHBH">XMLSERIALIZE SQL/XML Function</a></p>
</li>
<li>
<p><a href="#CHDBCGCI">XMLPARSE SQL/XML Function</a></p>
</li>
</ul>
<p>The standard XML-generation functions are also known as <span class="glossaryterm"><a id="sthref1185"></a>SQL/XML publishing</span> functions.</p>
<p>You can also construct XML data using the SQL/XML function <code>XMLQuery</code>. The use of <code>XMLQuery</code> is not limited to publishing XML data. It is very general and is referred to in this book as a SQL/XML <span class="italic">query and access</span> function.</p>
<p>This standardization process is ongoing. Please refer to <code><a href="http://www.sqlx.org">http://www.sqlx.org</a></code> for the latest information about SQL/XML functions, including <code>XMLQuery</code> and <code>XMLTable</code>.</p>
<p>Other XML-generating SQL functions presented in this section are Oracle-specific (not part of the SQL/XML standard):</p>
<ul>
<li>
<p><a href="#CHDEGCFD">XMLROOT Oracle SQL Function</a>.</p>
</li>
<li>
<p><a href="#i1032060">XMLCOLATTVAL Oracle SQL Function</a>.</p>
</li>
<li>
<p><a href="#CHDGCFFI">XMLCDATA Oracle SQL Function</a>.</p>
</li>
<li>
<p><a href="#i1026349">SYS_XMLGEN Oracle SQL Function</a>. This operates on relational rows, generating XML documents.</p>
</li>
<li>
<p><a href="#i1031169">SYS_XMLAGG Oracle SQL Function</a>. This operates on groups of relational rows, aggregating several XML documents into one.</p>
</li>
</ul>
<p>All of the XML-generation SQL functions convert scalars and user-defined data-type instances to their canonical XML format. In this canonical mapping, user-defined data-type attributes are mapped to XML elements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_xquery.htm#CBAGCBGJ">Chapter 5, "Using XQuery with Oracle XML&nbsp;DB"</a> for information about constructing XML data using SQL/XML function <code>XMLQuery</code></p>
</li>
<li>
<p><a class="olink SQLRF55529" href="../../server.112/e41084/ap_standard_sql010.htm#SQLRF55529"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about Oracle support for the SQL/XML standard</p>
</li>
</ul>
</div>
<a id="i1028612"></a>
<div id="ADXDB4994" class="sect2">
<h3 class="sect2">XMLELEMENT<a id="sthref1186"></a><a id="sthref1187"></a><a id="sthref1188"></a> and <a id="sthref1189"></a><a id="sthref1190"></a><a id="sthref1191"></a>XMLATTRIBUTES SQL/XML Functions</h3>
<p>You use SQL/XML standard function <code>XMLElement</code> to construct XML elements from relational data. It takes as arguments an element name, an optional collection of attributes for the element, and zero or more additional arguments that make up the element content. It returns an <code>XMLType</code> instance.</p>
<div id="ADXDB4995" class="figure">
<p class="titleinfigure"><a id="i1030781"></a>Figure 18-1 XMLELEMENT Syntax</p>
<img width="810" height="199" src="img/xmlelement.gif" alt="Description of Figure 18-1 follows" /><br />
<a id="sthref1192" href="img_text/xmlelement.htm">Description of "Figure 18-1 XMLELEMENT Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>For an explanation of keywords <code>ENTITYESCAPING</code> and <code>NOENTITYESCAPING</code>, see <a href="#CHDBDAGE">"Escaping Characters in Generated XML Data"</a>. These keywords are Oracle extensions to standard SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>.</p>
<p>The first argument to function <code>XMLElement</code> defines an identifier that names the <span class="italic">root</span> XML element to be created. The root-element identifier argument can be defined using a literal identifier (<code><span class="codeinlineitalic">identifier</span></code>, in <a href="#i1030781">Figure 18-1</a>) or by <code>EVALNAME</code> followed by an expression (<code><span class="codeinlineitalic">value_expr</span></code>) that evaluates to an identifier. However it is defined, the identifier must not be <code>NULL</code> or else an error is raised. The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLElement</code>.</p>
<p>The optional <code><span class="codeinlineitalic">XML-attributes-clause</span></code> argument of function <code>XMLElement</code> specifies the attributes of the root element to be generated. <a href="#BABBDEJF">Figure 18-2</a> shows the syntax of this argument.</p>
<p>In addition to the optional <code><span class="codeinlineitalic">XML-attributes-clause</span></code> argument, function <code>XMLElement</code> accepts zero or more <code><span class="codeinlineitalic">value_expr</span></code> arguments that make up the <span class="italic">content</span> of the root element (child elements and text content). If an <code><span class="codeinlineitalic">XML-attributes-clause</span></code> argument is also present, these content arguments must follow the <code><span class="codeinlineitalic">XML-attributes-clause</span></code> argument. Each of the content-argument expressions is evaluated, and the result is converted to XML format. If a value argument evaluates to <code>NULL</code>, then no content is created for that argument.</p>
<p>The optional <code><span class="codeinlineitalic">XML-attributes-clause</span></code> argument uses SQL/XML standard function <code>XMLAttributes</code> to specify the <span class="italic">attributes</span> of the root element. Function <code>XMLAttributes</code> can be used <span class="italic">only</span> in a call to function <code>XMLElement</code>. It cannot be used on its own.</p>
<div id="ADXDB4996" class="figure">
<p class="titleinfigure"><a id="BABBDEJF"></a>Figure 18-2 XMLAttributes Clause Syntax (XMLATTRIBUTES)</p>
<img width="770" height="135" src="img/xml_attributes_clause.gif" alt="Description of Figure 18-2 follows" /><br />
<a id="sthref1193" href="img_text/xml_attributes_clause.htm">Description of "Figure 18-2 XMLAttributes Clause Syntax (XMLATTRIBUTES)"</a><br />
<br /></div>
<!-- class="figure" -->
<p>For an explanation of keywords <code>ENTITYESCAPING</code> and <code>NOENTITYESCAPING</code>, see <a href="#CHDBDAGE">"Escaping Characters in Generated XML Data"</a>. These keywords are Oracle extensions to standard SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>.</p>
<p>Keywords <code>SCHEMACHECK</code> and <code>NOSCHEMACHECK</code> determine whether or not a run-time check is made of the generated attributes, to see if any of them specify a schema location that corresponds to an XML schema that is registered with Oracle XML&nbsp;DB, and, if so, to try to generate XML schema-based XML data accordingly. The default behavior is that provided by <code>NOSCHEMACHECK</code>: no check is made. In releases prior to 11<span class="italic">g</span> Release 2 (11.2), the default behavior is to perform the check. Keyword <code>SCHEMACHECK</code> can be used to obtain backward compatibility.</p>
<p>Note that a similar check is <span class="italic">always</span> made at <span class="italic">compile</span> time, regardless of the presence or absence of <code>NOSCHEMACHECK</code>. This means, in particular, that if you use a string literal to specify an XML schema location attribute value, then a (compile-time) check is made, and, if appropriate, XML schema-based data is generated accordingly.</p>
<p>Keywords <code>SCHEMACHECK</code> and <code>NOSCHEMACHECK</code> are Oracle extensions to standard SQL/XML function <code>XMLAttributes</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a view is created to generate XML data, function <code>XMLAttributes</code> is used to add XML-schema location references, and the target XML schema has not yet been registered with Oracle XML&nbsp;DB, then the XML data generated is not XML schema-based. If the XML schema is subsequently registered, then XML data generated thereafter is also <span class="italic">not</span> XML-schema-based. To create XML schema-based data, you must recompile the view.</div>
<p>Argument <code><span class="codeinlineitalic">XML-attributes-clause</span></code> itself contains one or more <code><span class="codeinlineitalic">value_expr</span></code> expressions as arguments to function <code>XMLAttributes</code>. These are evaluated to obtain the values for the attributes of the root element. (Do not confuse these <code><span class="codeinlineitalic">value_expr</span></code> arguments to function <code>XMLAttributes</code> with the <code><span class="codeinlineitalic">value_expr</span></code> arguments to function <code>XMLElement</code>, which specify the content of the root element.) The optional <code>AS</code> <code><span class="codeinlineitalic">c_alias</span></code> clause for each <code><span class="codeinlineitalic">value_expr</span></code> specifies that the attribute name is <code><span class="codeinlineitalic">c_alias</span></code>, which can be either a string literal or <code>EVALNAME</code> followed by an expression that evaluates to a string literal. (The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLElement</code>.)</p>
<p>If an attribute value expression evaluates to <code>NULL</code>, then no corresponding attribute is created. The data type of an attribute value expression cannot be an object type or a collection.</p>
<a id="CHDBDAGE"></a>
<div id="ADXDB4997" class="sect3">
<h4 class="sect3">Escaping Characters in Generated XML Data</h4>
<p>As specified by the SQL/XML standard, characters in explicit <span class="italic">identifiers</span> are <span class="italic">not</span> escaped in any way &ndash; it is up to you to ensure that valid XML names are used. This applies to all SQL/XML functions. In particular, it applies to the root-element identifier of <code>XMLElement</code> (<code><span class="codeinlineitalic">identifier</span></code>, in <a href="#i1030781">Figure 18-1</a>) and to attribute identifier aliases named with <code>AS</code> clauses of <code>XMLAttributes</code> (see <a href="#BABBDEJF">Figure 18-2</a>).</p>
<p>However, other XML data that is generated is <span class="italic">escaped</span>, by default, to ensure that only valid XML <code>NameChar</code> characters are generated. As part of generating a valid XML element or attribute name from a SQL identifier, each character that is disallowed in an XML name is replaced with an underscore character (<code>_</code>), followed by the hexadecimal Unicode representation of the original character, followed by a second underscore character. For example, the colon character (<code>:</code>) is escaped by replacing it with <code>_003A_</code>, where 003A is the hexadecimal Unicode representation.</p>
<p>Escaping applies to characters in the evaluated <code><span class="codeinlineitalic">value_expr</span></code> arguments to <span class="italic">all</span> SQL/XML functions, including <code>XMLElement</code> and <code>XMLAttributes</code>. It applies also to the characters of an attribute identifier that is defined implicitly from an <code>XMLAttributes</code> attribute value expression that is <span class="italic">not</span> followed by an <code>AS</code> clause: the escaped form of the SQL column name is used as the name of the attribute.</p>
<p>In some cases, you might not need or want character escaping. If you know, for example, that the XML data being generated is well-formed, then you can save some processing time by inhibiting escaping. You can do that by specifying the keyword <code>NOENTITYESCAPING</code> for SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>. Keyword <code>ENTITYESCAPING</code> imposes escaping, which is the default behavior. Keywords <code>NOENTITYESCAPING</code> and <code>ENTITYESCAPING</code> are Oracle extensions to standard SQL/XML functions <code>XMLElement</code> and <code>XMLAttributes</code>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDBIDIJ"></a>
<div id="ADXDB4998" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Formatting of XML Dates and Timestamps</h4>
<p>The XML Schema standard specifies that dates and timestamps in XML data be in standard formats. XML generation functions in Oracle XML&nbsp;DB produce XML dates and timestamps according to this standard.</p>
<p>In releases prior to Oracle Database&nbsp;10g Release 2, the database settings for date and timestamp formats, not the XML Schema standard formats, were used for XML. You can reproduce this <span class="italic">previous</span> behavior by setting the database event 19119, level 0x8, as follows:</p>
<pre>
ALTER SESSION SET EVENTS '19119 TRACE NAME CONTEXT FOREVER, LEVEL 0x8';
</pre>
<p>If you must otherwise produce a nonstandard XML date or timestamp, use SQL function <code>to_char</code> &ndash; see <a href="#CHDGFEIF">Example 18-1</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#isoformats">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#isoformats</a></code> for the XML Schema specification of XML date and timestamp formats</div>
</div>
<!-- class="sect3" -->
<div id="ADXDB4999" class="sect3"><a id="sthref1194"></a>
<h4 class="sect3">XMLElement Examples</h4>
<p>This section provides examples that use SQL/XML function <code>XMLElement</code>.</p>
<p><a href="#CHDGFEIF">Example 18-1</a> uses <code>XMLElement</code> to generate an XML date with a format that is different from the XML Schema standard date format.</p>
<div id="ADXDB5000" class="example">
<p class="titleinexample"><a id="CHDGFEIF"></a>Example 18-1 XMLELEMENT: Formatting a Date</p>
<pre>
-- With standard XML date format:
SELECT XMLElement("Date", hire_date)
  FROM hr.employees
  WHERE employee_id = 203;
 
XMLELEMENT("DATE",HIRE_DATE)
----------------------------
&lt;Date&gt;2002-06-07&lt;/Date&gt;
 
1 row selected.
 
-- With an alternative date format:
SELECT XMLElement("Date", <span class="bold">to_char</span>(hire_date))
  FROM hr.employees
  WHERE employee_id = 203;
 
XMLELEMENT("DATE",TO_CHAR(HIRE_DATE))
-------------------------------------
&lt;Date&gt;<span class="bold">07-JUN-02</span>&lt;/Date&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHEGBHCC">Example 18-2</a> uses <code>XMLElement</code> to generate an <code>Emp</code> element for each employee, with the employee name as the content.</p>
<div id="ADXDB5001" class="example">
<p class="titleinexample"><a id="CHEGBHCC"></a>Example 18-2 XMLELEMENT: Generating an Element for Each Employee</p>
<pre>
SELECT e.employee_id, 
       XMLELEMENT ("Emp", e.first_name ||' '|| e.last_name) AS "RESULT"
   FROM hr.employees e
   WHERE employee_id &gt; 200;
</pre>
<p>This query produces the following typical result:</p>
<pre>
EMPLOYEE_ID RESULT
----------- -----------------------------------
        201 &lt;Emp&gt;Michael Hartstein&lt;/Emp&gt;
        202 &lt;Emp&gt;Pat Fay&lt;/Emp&gt;
        203 &lt;Emp&gt;Susan Mavris&lt;/Emp&gt;
        204 &lt;Emp&gt;Hermann Baer&lt;/Emp&gt;
        205 &lt;Emp&gt;Shelley Higgins&lt;/Emp&gt;
        206 &lt;Emp&gt;William Gietz&lt;/Emp&gt;
 
6 rows selected.
</pre>
<p>SQL/XML function <code>XMLElement</code> can also be nested, to produce XML data with a nested structure.</p>
</div>
<!-- class="example" -->
<p><a href="#CHEGGIGG">Example 18-3</a> uses <code>XMLElement</code> to generate an <code>Emp</code> element for each employee, with child elements that provide the employee name and hire date.</p>
<div id="ADXDB5002" class="example">
<p class="titleinexample"><a id="CHEGGIGG"></a>Example 18-3 XMLELEMENT: Generating <a id="sthref1195"></a>Nested XML</p>
<pre>
SELECT XMLElement("Emp", 
                   XMLElement("name", e.first_name ||' '|| e.last_name),
                   XMLElement("hiredate", e.hire_date)) AS "RESULT" 
FROM hr.employees e 
WHERE employee_id &gt; 200;
</pre>
<p>This query produces the following typical XML result:</p>
<pre>
RESULT
-----------------------------------------------------------------------
&lt;Emp&gt;&lt;name&gt;Michael Hartstein&lt;/name&gt;&lt;hiredate&gt;2004-02-17&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Pat Fay&lt;/name&gt;&lt;hiredate&gt;2005-08-17&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Susan Mavris&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Hermann Baer&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;Shelley Higgins&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
&lt;Emp&gt;&lt;name&gt;William Gietz&lt;/name&gt;&lt;hiredate&gt;2002-06-07&lt;/hiredate&gt;&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHEDFACF">Example 18-4</a> uses <code>XMLElement</code> to generate an <code>Emp</code> element for each employee, with attributes <code>id</code> and <code>name</code>.</p>
<div id="ADXDB5003" class="example">
<p class="titleinexample"><a id="CHEDFACF"></a>Example 18-4 XMLELEMENT: Generating Employee Elements with Attributes ID and Name</p>
<pre>
SELECT XMLElement("Emp", XMLAttributes(
                           e.employee_id as "ID",
                           e.first_name ||' ' || e.last_name AS "name"))
  AS "RESULT"
  FROM hr.employees e
  WHERE employee_id &gt; 200;
</pre>
<p>This query produces the following typical XML result fragment:</p>
<pre>
RESULT
-----------------------------------------------
&lt;Emp ID="201" name="Michael Hartstein"&gt;&lt;/Emp&gt;
&lt;Emp ID="202" name="Pat Fay"&gt;&lt;/Emp&gt;
&lt;Emp ID="203" name="Susan Mavris"&gt;&lt;/Emp&gt;
&lt;Emp ID="204" name="Hermann Baer"&gt;&lt;/Emp&gt;
&lt;Emp ID="205" name="Shelley Higgins"&gt;&lt;/Emp&gt;
&lt;Emp ID="206" name="William Gietz"&gt;&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" -->
<p>As mentioned in <a href="#CHDBDAGE">"Escaping Characters in Generated XML Data"</a>, characters in the root-element name and the names of any attributes defined by <code>AS</code> clauses are <span class="italic">not</span> escaped. Characters in an identifier name are escaped only if the name is created from an evaluated expression (such as a column reference).</p>
<p><a href="#CHEIEAJH">Example 18-5</a> shows that, with XML data constructed using <code>XMLElement</code>, the root-element name and the attribute name are <span class="italic">not</span> escaped. Invalid XML is produced because greater-than sign (<code>&gt;</code>) and a comma (<code>,</code>) are not allowed in XML element and attribute names.</p>
<div id="ADXDB5895" class="example">
<p class="titleinexample"><a id="CHEIEAJH"></a>Example 18-5 XMLELEMENT: Characters in Generated XML Are Not Escaped</p>
<pre>
SELECT XMLElement("Emp-<span class="bold">&gt;</span>Special", 
                  XMLAttributes(e.last_name || ', ' || e.first_name
                                AS "Last<span class="bold">,</span>First"))
   AS "RESULT"
   FROM hr.employees e
   WHERE employee_id = 201;
</pre>
<p>This query produces the following result, which is <span class="italic">not</span> well-formed XML:</p>
<pre>
RESULT
--------------------------------------------------------------------
&lt;Emp-<span class="bold">&gt;</span>Special Last<span class="bold">,</span>First="Hartstein, Michael"&gt;&lt;/Emp-<span class="bold">&gt;</span>Special&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<p>A full description of character escaping is included in the SQL/XML standard.</p>
<p><a href="#CHEHAGJJ">Example 18-6</a> illustrates the use of namespaces to create an XML schema-based document. Assuming that an XML schema "<code>http://www.oracle.com/Employee.xsd</code>" exists and has no target namespace, the query in <a href="#CHEHAGJJ">Example 18-6</a> creates an <code>XMLType</code> instance conforming to that schema:</p>
<div id="ADXDB5004" class="example">
<p class="titleinexample"><a id="CHEHAGJJ"></a>Example 18-6 Creating a Schema-Based XML Document using XMLELEMENT with Namespaces</p>
<pre>
SELECT XMLElement("Employee", 
                  XMLAttributes('http://www.w3.org/2001/XMLSchema' AS
                                  "xmlns:xsi",
                                'http://www.oracle.com/Employee.xsd' AS
                                  "xsi:nonamespaceSchemaLocation"),
                  XMLForest(employee_id, last_name, salary)) AS "RESULT"
   FROM hr.employees
   WHERE department_id = 10;
</pre>
<p>This creates the following XML document that conforms to XML schema <code>Employee.xsd</code>. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
RESULT
-----------------------------------------------------------------------------
&lt;Employee xmlns:xsi="http://www.w3.org/2001/XMLSchema"
          xsi:nonamespaceSchemaLocation="http://www.oracle.com/Employee.xsd"&gt;
   &lt;EMPLOYEE_ID&gt;200&lt;/EMPLOYEE_ID&gt;
   &lt;LAST_NAME&gt;Whalen&lt;/LAST_NAME&gt;
   &lt;SALARY&gt;4400&lt;/SALARY&gt;
&lt;/Employee&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHDFGFJC">Example 18-7</a> uses <code>XMLElement</code> to generate an XML document with employee and department information, using data from sample database schema table <code>hr.departments</code>.</p>
<div id="ADXDB5005" class="example">
<p class="titleinexample"><a id="CHDFGFJC"></a>Example 18-7 XMLELEMENT: Generating an Element from a <a id="sthref1196"></a>User-Defined Data-Type Instance</p>
<pre>
CREATE OR REPLACE TYPE emp_t AS OBJECT ("@EMPNO" NUMBER(4),
                                         ENAME VARCHAR2(10));

CREATE OR REPLACE TYPE emplist_t AS TABLE OF emp_t;

CREATE OR REPLACE TYPE dept_t AS OBJECT ("@DEPTNO" NUMBER(2),
                                         DNAME VARCHAR2(14),
                                         EMP_LIST emplist_t);

SELECT XMLElement("Department",
                  dept_t(department_id,
                         department_name,
                         cast(MULTISET
                              (SELECT employee_id, last_name
                                 FROM hr.employees e
                                 WHERE e.department_id = d.department_id)
                              AS emplist_t)))
  AS deptxml
  FROM hr.departments d
  WHERE d.department_id = 10;
</pre>
<p>This produces an XML document which contains the <code>Department</code> element and the canonical mapping of type <code>dept_t</code>.</p>
<pre>
DEPTXML
-------------
&lt;Department&gt;
  &lt;DEPT_T DEPTNO="10"&gt;
    &lt;DNAME&gt;ACCOUNTING&lt;/DNAME&gt;
    &lt;EMPLIST&gt;
      &lt;EMP_T EMPNO="7782"&gt;
        &lt;ENAME&gt;CLARK&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
      &lt;EMP_T EMPNO="7839"&gt;
        &lt;ENAME&gt;KING&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
      &lt;EMP_T EMPNO="7934"&gt;
        &lt;ENAME&gt;MILLER&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
    &lt;/EMPLIST&gt;
  &lt;/DEPT_T&gt;
&lt;/Department&gt;

1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1028160"></a>
<div id="ADXDB5006" class="sect2">
<h3 class="sect2">XMLFOREST SQL/XML <a id="sthref1197"></a><a id="sthref1198"></a><a id="sthref1199"></a>Function</h3>
<p>You use SQL/XML standard function <code>XMLForest</code> to construct a forest of XML elements. Its arguments are expressions to be evaluated, with optional aliases. <a href="#i1030830">Figure 18-3</a> describes the <code>XMLForest</code> syntax.</p>
<div id="ADXDB5007" class="figure">
<p class="titleinfigure"><a id="i1030830"></a>Figure 18-3 XMLFOREST Syntax</p>
<img width="576" height="112" src="img/xmlforest.gif" alt="Description of Figure 18-3 follows" /><br />
<a id="sthref1200" href="img_text/xmlforest.htm">Description of "Figure 18-3 XMLFOREST Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Each of the value expressions (<code><span class="codeinlineitalic">value_expr</span></code> in <a href="#i1030830">Figure 18-3</a>) is converted to XML format, and, optionally, identifier <code><span class="codeinlineitalic">c_alias</span></code> is used as the attribute identifier (<code><span class="codeinlineitalic">c_alias</span></code> can be a string literal or <code>EVALNAME</code> followed by an expression that evaluates to a string literal). The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLForest</code>.</p>
<p>For an object type or collection, the <code>AS</code> clause is required. For other types, the <code>AS</code> clause is optional. For a given expression, if the <code>AS</code> clause is omitted, then characters in the evaluated value expression are <span class="italic">escaped</span> to form the name of the enclosing tag of the element. The escaping is as defined in <a href="#CHDBDAGE">"Escaping Characters in Generated XML Data"</a>. If the value expression evaluates to <code>NULL</code>, then no element is created for that expression.</p>
<p><a href="#CHDBJDAG">Example 18-8</a> uses <code>XMLElement</code> and <code>XMLForest</code> to generate an <code>Emp</code> element for each employee, with a <code>name</code> attribute and with child elements containing the employee hire date and department as the content.</p>
<div id="ADXDB5008" class="example">
<p class="titleinexample"><a id="CHDBJDAG"></a>Example 18-8 XMLFOREST: Generating Elements with Attribute and Child Elements</p>
<pre>
SELECT XMLElement("Emp", 
                  XMLAttributes(e.first_name ||' '|| e.last_name AS "name"),
                  XMLForest(e.hire_date, e.department AS "department"))
AS "RESULT"
FROM employees e WHERE e.department_id = 20;
</pre>
<p>(The <code>WHERE</code> clause is used here to keep the example brief.) This query produces the following XML result:</p>
<pre>
RESULT
-------------------------------------
&lt;Emp name="Michael Hartstein"&gt;
  &lt;HIRE_DATE&gt;2004-02-17&lt;/HIRE_DATE&gt;
  &lt;department&gt;20&lt;/department&gt;
&lt;/Emp&gt;
&lt;Emp name="Pat Fay"&gt;
  &lt;HIRE_DATE&gt;2005-08-17&lt;/HIRE_DATE&gt;
  &lt;department&gt;20&lt;/department&gt;
&lt;/Emp&gt;

2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDBEBGD">Example 18-20, "XMLCOLATTVAL: Generating Elements with Attribute and Child Elements"</a></div>
<p><a href="#CHEFIJFD">Example 18-9</a> uses <code>XMLForest</code> to generate hierarchical XML data from user-defined data-type instances.</p>
<div id="ADXDB5009" class="example">
<p class="titleinexample"><a id="CHEFIJFD"></a>Example 18-9 XMLFOREST: Generating an Element from a User-Defined Data-Type Instance</p>
<pre>
SELECT XMLForest(
  dept_t(department_id,
         department_name,
         cast(MULTISET
              (SELECT employee_id, last_name
                 FROM hr.employees e WHERE e.department_id = d.department_id)
              AS emplist_t))
         AS "Department")
  AS deptxml
  FROM hr.departments d
  WHERE department_id=10;
</pre></div>
<!-- class="example" -->
<p>This produces an XML document with element <code>Department</code> containing attribute <code>DEPTNO</code> and child element <code>DNAME</code>.</p>
<pre>
DEPTXML
---------------------------------
&lt;Department DEPTNO="10"&gt;
  &lt;DNAME&gt;Administration&lt;/DNAME&gt;
    &lt;EMP_LIST&gt;
      &lt;EMP_T EMPNO="200"&gt;
        &lt;ENAME&gt;Whalen&lt;/ENAME&gt;
      &lt;/EMP_T&gt;
    &lt;/EMP_LIST&gt;
&lt;/Department&gt;

1 row selected.
</pre>
<p>You may want to compare this example with <a href="#CHDFGFJC">Example 18-7</a> and <a href="#i1025801">Example 18-25</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1032050"></a>
<div id="ADXDB5016" class="sect2">
<h3 class="sect2">XMLCONCAT SQL/XML <a id="sthref1201"></a><a id="sthref1202"></a><a id="sthref1203"></a>Function</h3>
<p>You use SQL/XML standard function <code>XMLConcat</code> to construct an XML fragment by concatenating multiple <code>XMLType</code> instances. <a href="#i1032783">Figure 18-4</a> shows the <code>XMLConcat</code> syntax. Function <code>XMLConcat</code> has two forms:</p>
<ul>
<li>
<p>The first form takes as argument an <code>XMLSequenceType</code> value, which is a varray of <code>XMLType</code> instances, and returns a single <code>XMLType</code> instance that is the concatenation of all of the elements of the varray. This form is useful to collapse lists of <code>XMLType</code> instances into a single instance.</p>
</li>
<li>
<p>The second form takes an arbitrary number of <code>XMLType</code> instances and concatenates them together. If one of the values is <code>NULL</code>, then it is ignored in the result. If all the values are <code>NULL</code>, then the result is <code>NULL</code>. This form is used to concatenate arbitrary number of <code>XMLType</code> instances in the same row. Function <code>XMLAgg</code> can be used to concatenate <code>XMLType</code> instances across rows.</p>
</li>
</ul>
<div id="ADXDB5017" class="figure">
<p class="titleinfigure"><a id="i1032783"></a>Figure 18-4 XMLCONCAT Syntax</p>
<img width="331" height="58" src="img/xmlconcat.gif" alt="Description of Figure 18-4 follows" /><br />
<a id="sthref1204" href="img_text/xmlconcat.htm">Description of "Figure 18-4 XMLCONCAT Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#CHECFIGF">Example 18-10</a> uses SQL/XML function <code>XMLConcat</code> to return a concatenation of <code>XMLType</code> instances from an <code>XMLSequenceType</code> value (a varray of <code>XMLType</code> instances).</p>
<div id="ADXDB5018" class="example">
<p class="titleinexample"><a id="CHECFIGF"></a>Example 18-10 XMLCONCAT: Concatenating XMLType Instances from a Sequence</p>
<pre>
SELECT XMLSerialize(
         CONTENT
         XMLConcat(XMLSequenceType(
                   XMLType('&lt;PartNo&gt;1236&lt;/PartNo&gt;'),
                   XMLType('&lt;PartName&gt;Widget&lt;/PartName&gt;'),
                   XMLType('&lt;PartPrice&gt;29.99&lt;/PartPrice&gt;')))
         AS CLOB)
  AS "RESULT"
  FROM DUAL;
</pre>
<p>This query returns a single XML fragment. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
RESULT
---------------
&lt;PartNo&gt;1236&lt;/PartNo&gt;
&lt;PartName&gt;Widget&lt;/PartName&gt;
&lt;PartPrice&gt;29.99&lt;/PartPrice&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHECFCJG">Example 18-11</a> uses <code>XMLConcat</code> to create and concatenate XML elements for employee first and the last names.</p>
<div id="ADXDB5019" class="example">
<p class="titleinexample"><a id="CHECFCJG"></a>Example 18-11 XMLCONCAT: Concatenating XML Elements</p>
<pre>
SELECT XMLConcat(XMLElement("first", e.first_name), 
                 XMLElement("last", e.last_name))
  AS "RESULT"
  FROM employees e;
</pre>
<p>This query produces the following XML fragment:</p>
<pre>
RESULT
--------------------------------------------
&lt;first&gt;Den&lt;/first&gt;&lt;last&gt;Raphaely&lt;/last&gt;
&lt;first&gt;Alexander&lt;/first&gt;&lt;last&gt;Khoo&lt;/last&gt;
&lt;first&gt;Shelli&lt;/first&gt;&lt;last&gt;Baida&lt;/last&gt;
&lt;first&gt;Sigal&lt;/first&gt;&lt;last&gt;Tobias&lt;/last&gt;
&lt;first&gt;Guy&lt;/first&gt;&lt;last&gt;Himuro&lt;/last&gt;
&lt;first&gt;Karen&lt;/first&gt;&lt;last&gt;Colmenares&lt;/last&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1028180"></a>
<div id="ADXDB5020" class="sect2">
<h3 class="sect2">XMLAGG <a id="sthref1205"></a><a id="sthref1206"></a><a id="sthref1207"></a>SQL/XML Function</h3>
<p>You use SQL/XML standard function <code>XMLAgg</code> to construct a forest of XML elements from a collection of XML elements&thinsp;&mdash;&thinsp;it is an aggregate function.</p>
<div id="ADXDB5021" class="figure">
<p class="titleinfigure"><a id="i1032735"></a>Figure 18-5 XMLAGG Syntax</p>
<img width="433" height="46" src="img/xmlagg.gif" alt="Description of Figure 18-5 follows" /><br />
<a id="sthref1208" href="img_text/xmlagg.htm">Description of "Figure 18-5 XMLAGG Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#i1032735">Figure 18-5</a> describes the <code>XMLAgg</code> syntax, where the <code>order_by_clause</code> is the following:</p>
<pre>
ORDER BY [list of: expr [ASC|DESC] [NULLS {FIRST|LAST}]]
</pre>
<p>Numeric literals are <span class="italic">not</span> interpreted as column positions. For example, <code>ORDER BY 1</code> does not mean order by the first column. Instead, numeric literals are interpreted as any other literals.</p>
<p>As with SQL/XML function <code>XMLConcat</code>, any arguments whose value is <code>NULL</code> are dropped from the result. SQL/XML function <code>XMLAgg</code> is similar to Oracle SQL function <code>sys_XMLAgg</code>, but <code>XMLAgg</code> returns a forest of nodes and it does not accept an <code><a id="sthref1209"></a>XMLFormat</code> parameter.</p>
<p>SQL/XML function <code>XMLAgg</code> can be used to concatenate <code>XMLType</code> instances across <span class="italic">multiple rows</span>. It also accepts an optional <code>ORDER BY</code> clause, to order the XML values being aggregated. Function <code>XMLAgg</code> produces one aggregated XML result for each group. If there is no group by specified in the query, then it returns a single aggregated XML result for all the rows of the query.</p>
<p><a href="#CHEJIFCD">Example 18-12</a> uses SQL/XML functions <code>XMLAgg</code> and <code>XMLElement</code> to construct a <code>Department</code> element that contains <code>Employee</code> elements that have employee job ID and last name as their contents. It also orders the <code>Employee</code> elements in the department by employee last name. (The result is shown pretty-printed, for clarity.)</p>
<div id="ADXDB5022" class="example">
<p class="titleinexample"><a id="CHEJIFCD"></a>Example 18-12 XMLAGG: Generating a Department Element with Child Employee Elements</p>
<pre>
SELECT XMLElement("Department", XMLAgg(XMLElement("Employee",
                                                  e.job_id||' '||e.last_name)
                                       ORDER BY e.last_name))
  AS "Dept_list"     
  FROM hr.employees e
  WHERE e.department_id = 30 OR e.department_id = 40;

Dept_list
------------------
&lt;Department&gt;
  &lt;Employee&gt;PU_CLERK Baida&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Colmenares&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Himuro&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Khoo&lt;/Employee&gt;
  &lt;Employee&gt;HR_REP Mavris&lt;/Employee&gt;
  &lt;Employee&gt;PU_MAN Raphaely&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Tobias&lt;/Employee&gt;
&lt;/Department&gt;

<span class="bold">1</span> row selected.
</pre></div>
<!-- class="example" -->
<p>The result is a <span class="italic">single</span> row, because <code>XMLAgg</code> aggregates the employee rows.</p>
<p><a href="#CHEEEACD">Example 18-13</a> shows how to use the <code>GROUP</code> <code>BY</code> clause to group the returned set of rows into multiple groups, forming multiple <code>Department</code> elements. (The result is shown here pretty-printed, for clarity.)</p>
<div id="ADXDB5896" class="example">
<p class="titleinexample"><a id="CHEEEACD"></a>Example 18-13 XMLAGG: Using GROUP BY to Generate Multiple Department Elements</p>
<pre>
SELECT XMLElement("Department", XMLAttributes(department_id AS "deptno"), 
                  XMLAgg(XMLElement("Employee", e.job_id||' '||e.last_name)))
   AS "Dept_list"
   FROM hr.employees e
   <span class="bold">GROUP BY e.department_id;</span>

Dept_list
------------------
&lt;Department deptno="<span class="bold">30</span>"&gt;
  &lt;Employee&gt;PU_MAN Raphaely&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Colmenares&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Himuro&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Tobias&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Baida&lt;/Employee&gt;
  &lt;Employee&gt;PU_CLERK Khoo&lt;/Employee&gt;&lt;/Department&gt;

&lt;Department deptno="<span class="bold">40</span>"&gt;
  &lt;Employee&gt;HR_REP Mavris&lt;/Employee&gt;
&lt;/Department&gt;

<span class="bold">2</span> rows selected.
</pre></div>
<!-- class="example" -->
<p>You can order the employees within each department by using the <code>ORDER BY</code> clause inside the <code>XMLAgg</code> expression.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Within the <code>ORDER BY</code> clause, Oracle Database does not interpret number literals as column positions, as it does in other uses of this clause.</div>
<p>Function <code>XMLAgg</code> can be used to reflect the hierarchical nature of some relationships that exist in tables. <a href="#CHEHHCJI">Example 18-14</a> generates a department element for department 30. Within this element is a child element <code>emp</code> for each employee of the department. Within each employee element is a <code>dependent</code> element for each dependent of that employee.</p>
<div id="ADXDB5023" class="example">
<p class="titleinexample"><a id="CHEHHCJI"></a>Example 18-14 XMLAGG: Generating Nested Elements</p>
<pre>
SELECT last_name, employee_id FROM employees WHERE department_id = 30;
 
LAST_NAME                 EMPLOYEE_ID
------------------------- -----------
Raphaely                          114
Khoo                              115
Baida                             116
Tobias                            117
Himuro                            118
Colmenares                        119
 
6 rows selected.
 
</pre>
<p>A <code>dependents</code> table holds the dependents of each employee.</p>
<pre>
CREATE TABLE hr.dependents (id NUMBER(4) PRIMARY KEY,
                            employee_id NUMBER(4),
                            name VARCHAR2(10));
Table created.
INSERT INTO dependents VALUES (1, 114, 'MARK');
1 row created.
INSERT INTO dependents VALUES (2, 114, 'JACK');
1 row created.
INSERT INTO dependents VALUES (3, 115, 'JANE');
1 row created.
INSERT INTO dependents VALUES (4, 116, 'HELEN');
1 row created.
INSERT INTO dependents VALUES (5, 116, 'FRANK');
1 row created.
COMMIT;
Commit complete.
 
</pre>
<p>The following query generates the XML data for a department that contains the information about dependents. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
SELECT
  XMLElement(
    "Department",
    XMLAttributes(d.department_name AS "name"),
    (SELECT
       XMLAgg(XMLElement("emp",
                         XMLAttributes(e.last_name AS name),
                         (SELECT XMLAgg(XMLElement("dependent",
                                        XMLAttributes(de.name AS "name")))
                            FROM dependents de
                            WHERE de.employee_id = e.employee_id)))
       FROM employees e
       WHERE e.department_id = d.department_id)) AS "dept_list"
  FROM departments d
  WHERE department_id = 30;
 
dept_list
--------------------------------------------------------------------------------
&lt;Department name="Purchasing"&gt;
  &lt;emp NAME="Raphaely"&gt;
    &lt;dependent name="MARK"&gt;&lt;/dependent&gt;
    &lt;dependent name="JACK"&gt;&lt;/dependent&gt;
  &lt;/emp&gt;&lt;emp NAME="Khoo"&gt;
    &lt;dependent name="JANE"&gt;&lt;/dependent&gt;
  &lt;/emp&gt;
  &lt;emp NAME="Baida"&gt;
    &lt;dependent name="HELEN"&gt;&lt;/dependent&gt;
    &lt;dependent name="FRANK"&gt;&lt;/dependent&gt;
  &lt;/emp&gt;&lt;emp NAME="Tobias"&gt;&lt;/emp&gt;
  &lt;emp NAME="Himuro"&gt;&lt;/emp&gt;
  &lt;emp NAME="Colmenares"&gt;&lt;/emp&gt;
&lt;/Department&gt;
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDGHGGJ"></a>
<div id="ADXDB5024" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLPI<a id="sthref1210"></a><a id="sthref1211"></a><a id="sthref1212"></a> SQL/XML Function</h3>
<p>You use SQL/XML standard function <code>XMLPI</code> to construct an XML processing instruction (PI). <a href="#CHDIAAEJ">Figure 18-6</a> shows the syntax:</p>
<div id="ADXDB5025" class="figure">
<p class="titleinfigure"><a id="CHDIAAEJ"></a>Figure 18-6 XMLPI Syntax</p>
<img width="503" height="79" src="img/xmlpi.gif" alt="Description of Figure 18-6 follows" /><br />
<a id="sthref1213" href="img_text/xmlpi.htm">Description of "Figure 18-6 XMLPI Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Argument <code><span class="codeinlineitalic">value_expr</span></code> is evaluated, and the string result is appended to the optional identifier (<code><span class="codeinlineitalic">identifier</span></code>), separated by a space. This concatenation is then enclosed between <code>"&lt;?"</code> and <code>"?&gt;</code>" to create the processing instruction. That is, if <code><span class="codeinlineitalic">string-result</span></code> is the result of evaluating <code><span class="codeinlineitalic">value_expr</span></code>, then the generated processing instruction is <code>&lt;?</code><code><span class="codeinlineitalic">identifier</span></code> <code><span class="codeinlineitalic">string-result?&gt;</span></code>. If <code><span class="codeinlineitalic">string-result</span></code> is the empty string, <code>''</code>, then the function returns <code>&lt;?</code><code><span class="codeinlineitalic">identifier</span></code><code><span class="codeinlineitalic">?&gt;</span></code>.</p>
<p>As an alternative to using keyword <code>NAME</code> followed by a <span class="italic">literal</span> string <code><span class="codeinlineitalic">identifier</span></code>, you can use keyword <code>EVALNAME</code> followed by an expression that evaluates to a string to be used as the identifier. The possibility of using <code>EVALNAME</code> is an Oracle extension to standard SQL/XML function <code>XMLPI</code>.</p>
<p>An error is raised if the constructed XML is not a legal XML processing instruction. In particular:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">identifier</span></code> must <span class="italic">not</span> be the word "<code>xml</code>" (uppercase, lowercase, or mixed case).</p>
</li>
<li>
<p><code><span class="codeinlineitalic">string-result</span></code> must <span class="italic">not</span> contain the character sequence "<code>?&gt;</code>".</p>
</li>
</ul>
<p>Function <code>XMLPI</code> returns an instance of <code>XMLType</code>. If <code><span class="codeinlineitalic">string-result</span></code> is <code>NULL</code>, then it returns <code>NULL</code>.</p>
<p><a href="#CHEFBGFC">Example 18-15</a> uses <code>XMLPI</code> to generate a simple processing instruction.</p>
<div id="ADXDB5026" class="example">
<p class="titleinexample"><a id="CHEFBGFC"></a>Example 18-15 Using SQL/XML Function XMLPI</p>
<pre>
SELECT XMLPI(NAME "OrderAnalysisComp", 'imported, reconfigured, disassembled')
  AS pi FROM DUAL; 
</pre>
<p>This results in the following output:</p>
<pre>
PI
----------------------------------------------------------
&lt;?OrderAnalysisComp imported, reconfigured, disassembled?&gt;

1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDFCEBI"></a>
<div id="ADXDB5027" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLCOMMENT<a id="sthref1214"></a><a id="sthref1215"></a><a id="sthref1216"></a> SQL/XML Function</h3>
<p>You use SQL/XML standard function <code>XMLComment</code> to construct an XML comment. <a href="#CHDFIFFI">Figure 18-7</a> shows the syntax:</p>
<div id="ADXDB5028" class="figure">
<p class="titleinfigure"><a id="CHDFIFFI"></a>Figure 18-7 XMLComment Syntax</p>
<img width="268" height="27" src="img/xmlcomment.gif" alt="Description of Figure 18-7 follows" /><br />
<a id="sthref1217" href="img_text/xmlcomment.htm">Description of "Figure 18-7 XMLComment Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Argument <code><span class="codeinlineitalic">value_expr</span></code> is evaluated to a string, and the result is used as the body of the generated XML comment. The result is thus <code>&lt;!--</code><code><span class="codeinlineitalic">string-result</span></code><code>--&gt;</code>, where <code><span class="codeinlineitalic">string-result</span></code> is the string result of evaluating <code><span class="codeinlineitalic">value_expr</span></code>. If <code><span class="codeinlineitalic">string-result</span></code> is the empty string, then the comment is empty: <code>&lt;!----&gt;</code>.</p>
<p>An error is raised if the constructed XML is not a legal XML comment. In particular, <code><span class="codeinlineitalic">string-result</span></code> must <span class="italic">not</span> contain two consecutive hyphens (<code>-</code>): "<code>--</code>".</p>
<p>Function <code>XMLComment</code> returns an instance of <code>XMLType</code>. If <code><span class="codeinlineitalic">string-result</span></code> is <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="#CHECEGCI">Example 18-16</a> uses <code>XMLComment</code> to generate a simple XML comment.</p>
<div id="ADXDB5029" class="example">
<p class="titleinexample"><a id="CHECEGCI"></a>Example 18-16 Using SQL/XML Function XMLCOMMENT</p>
<pre>
SELECT XMLComment('This is a comment') AS cmnt FROM DUAL; 
</pre>
<p>This query results in the following output:</p>
<pre>
CMNT
--------------------------
&lt;!--This is a comment--&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDDIHBH"></a>
<div id="ADXDB5033" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLSERIALIZE<a id="sthref1218"></a><a id="sthref1219"></a><a id="sthref1220"></a> SQL/XML Function</h3>
<p>You use SQL/XML standard function <code>XMLSerialize</code> to obtain a string or LOB representation of XML data.</p>
<p><a href="#CHDBGEEH">Figure 18-8</a> shows the syntax of <code>XMLSerialize</code>:</p>
<div id="ADXDB5034" class="figure">
<p class="titleinfigure"><a id="CHDBGEEH"></a>Figure 18-8 XMLSerialize Syntax</p>
<img width="616" height="256" src="img/xmlserialize.gif" alt="Description of Figure 18-8 follows" /><br />
<a id="sthref1221" href="img_text/xmlserialize.htm">Description of "Figure 18-8 XMLSerialize Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Argument <code><span class="codeinlineitalic">value_expr</span></code> is evaluated, and the resulting <code>XMLType</code> instance is serialized to produce the content of the created string or LOB. If present<a id="sthref1222" href="#sthref1222" onclick='footdisplay(1,"The SQL/XML standard requires argument \u003ccode\u003e\u003cspan class=\"codeinlineitalic\"\u003edata-type\u003c/span\u003e\u003c/code\u003e to be present, but it is \u003cspan class=\"italic\"\u003eoptional\u003c/span\u003e in the Oracle XML&nbsp;DB implementation of the standard, for ease of use.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a>, the specified <code><span class="codeinlineitalic">datatype</span></code> must be one of the following (the default data type is <code>CLOB</code>):</p>
<ul>
<li>
<p><code>VARCHAR2(</code><code><span class="codeinlineitalic">N</span></code><code>)</code>, where <code><span class="codeinlineitalic">N</span></code> is the size in bytes (limit 4000)</p>
</li>
<li>
<p><code>CLOB</code></p>
</li>
<li>
<p><code>BLOB</code></p>
</li>
</ul>
<p>If you specify <code>DOCUMENT</code>, then the result of evaluating <code><span class="codeinlineitalic">value_expr</span></code> must be a well-formed document. In particular, it must have a single root. If the result is not a well-formed document, then an error is raised. If you specify <code>CONTENT</code>, however, then the result of <code><span class="codeinlineitalic">value_expr</span></code> is <span class="italic">not</span> checked for being well-formed.</p>
<p>If <code><span class="codeinlineitalic">value_expr</span></code> evaluates to <code>NULL</code> or to the empty string (<code>''</code>), then function <code>XMLSerialize</code> returns <code>NULL</code>.</p>
<p>The <code>ENCODING</code> clause specifies the character encoding for XML data that is serialized as a <code>BLOB</code> instance. <code><span class="codeinlineitalic">xml_encoding_spec</span></code> is an XML encoding declaration (<code>encoding="..."</code>). If <code><span class="codeinlineitalic">datatype</span></code> is <code>BLOB</code> and you specify an <code>ENCODING</code> clause, then the output is encoded as specified, and <code><span class="codeinlineitalic">xml_encoding_spec</span></code> is added to the prolog to indicate the <code>BLOB</code> encoding. If you specify an <code>ENCODING</code> clause with a <code><span class="codeinlineitalic">datatype</span></code> other than <code>BLOB</code>, then an error is raised.</p>
<p>If you specify the <code>VERSION</code>, then that version is used in the XML declaration (<code>&lt;?xml version="..." ...?&gt;</code>).</p>
<p><a id="sthref1223"></a>If you specify <code>NO INDENT</code>, then all insignificant whitespace is stripped, so that it does not appear in the output. If you specify <code>INDENT SIZE =</code> <code><span class="codeinlineitalic">N</span></code>, where <code><span class="codeinlineitalic">N</span></code> is a whole number, then the output is <span class="italic">pretty-printed</span> using a relative indentation of <code><span class="codeinlineitalic">N</span></code> spaces. If <code><span class="codeinlineitalic">N</span></code> is <code>0</code>, then pretty-printing inserts a newline character after each element, placing each element on a line by itself, but there is no other insignificant whitespace in the output. If you specify <code>INDENT</code> without a <code>SIZE</code> specification, then 2-space indenting is used. If you specify neither <code>NO INDENT</code> nor <code>INDENT</code>, then the behavior (pretty-printing or not) is indeterminate.</p>
<p><code>HIDE DEFAULTS</code> and <code>SHOW DEFAULTS</code> apply only to XML schema-based data. If you specify <code>SHOW DEFAULTS</code> and the input data is missing any optional elements or attributes for which the XML schema defines default values, then those elements or attributes are included in the output with their default values. If you specify <code>HIDE DEFAULTS</code>, then no such elements or attributes are included in the output. <code>HIDE DEFAULTS</code> is the default behavior.</p>
<p><a href="#CHEHCEAA">Example 18-17</a> uses <code>XMLSerialize</code> to produce a <code>CLOB</code> instance containing serialized XML data.</p>
<div id="ADXDB5035" class="example">
<p class="titleinexample"><a id="CHEHCEAA"></a>Example 18-17 Using SQL/XML Function XMLSERIALIZE</p>
<pre>
SELECT XMLSerialize(DOCUMENT XMLType('&lt;poid&gt;143598&lt;/poid&gt;') AS CLOB)
  AS xmlserialize_doc FROM DUAL; 
</pre>
<p>This results in the following output:</p>
<pre>
XMLSERIALIZE_DOC
-------------------
&lt;poid&gt;143598&lt;/poid&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDBCGCI"></a>
<div id="ADXDB5036" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLPARSE<a id="sthref1224"></a><a id="sthref1225"></a><a id="sthref1226"></a> SQL/XML Function</h3>
<p>You use SQL/XML standard function <code>XMLParse</code> to parse a string containing XML data and construct a corresponding <code>XMLType</code> instance. <a href="#CHDBGIJH">Figure 18-9</a> shows the syntax:</p>
<div id="ADXDB5037" class="figure">
<p class="titleinfigure"><a id="CHDBGIJH"></a>Figure 18-9 XMLParse Syntax</p>
<img width="524" height="64" src="img/xmlparse.gif" alt="Description of Figure 18-9 follows" /><br />
<a id="sthref1227" href="img_text/xmlparse.htm">Description of "Figure 18-9 XMLParse Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Argument <code><span class="codeinlineitalic">value_expr</span></code> is evaluated to produce the string that is parsed. If you specify <code>DOCUMENT</code>, then <code><span class="codeinlineitalic">value_expr</span></code> must correspond to a <span class="italic">singly rooted</span>, well-formed XML document. If you specify <code>CONTENT</code>, then <code><span class="codeinlineitalic">value_expr</span></code> need only correspond to a well-formed XML fragment (it need not be singly rooted).</p>
<p>Keyword <code>WELLFORMED</code> is an Oracle XML&nbsp;DB extension to the SQL/XML standard. When you specify <code>WELLFORMED</code>, you are informing the parser that argument <code><span class="codeinlineitalic">value_expr</span></code> is well-formed, so Oracle XML&nbsp;DB does <span class="italic">not</span> check to ensure that it is well-formed.</p>
<p>Function <code>XMLParse</code> returns an instance of <code>XMLType</code>. If <code><span class="codeinlineitalic">value_expr</span></code> evaluates to <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="#CHECCHJG">Example 18-18</a> uses <code>XMLParse</code> to parse a string of XML code and produce an <code>XMLType</code> instance.</p>
<div id="ADXDB5038" class="example">
<p class="titleinexample"><a id="CHECCHJG"></a>Example 18-18 Using SQL/XML Function XMLPARSE</p>
<pre>
SELECT XMLParse(CONTENT 
                '124 &lt;purchaseOrder poNo="12435"&gt;
                       &lt;customerName&gt; Acme Enterprises&lt;/customerName&gt;
                       &lt;itemNo&gt;32987457&lt;/itemNo&gt;
                     &lt;/purchaseOrder&gt;'
                WELLFORMED)
  AS po FROM DUAL d;
</pre>
<p>This results in the following output:</p>
<pre>
PO
-----------------------------------------------
124 &lt;purchaseOrder poNo="12435"&gt;
&lt;customerName&gt;Acme Enterprises&lt;/customerName&gt;
&lt;itemNo&gt;32987457&lt;/itemNo&gt;
&lt;/purchaseOrder&gt;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<code><a href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a></code>, <span class="italic">Extensible Markup Language (XML) 1.0</span>, for the definition of well-formed XML documents and fragments</div>
</div>
<!-- class="sect2" -->
<a id="CHDEGCFD"></a>
<div id="ADXDB5030" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLROOT<a id="sthref1228"></a><a id="sthref1229"></a><a id="sthref1230"></a> Oracle SQL Function</h3>
<p>Oracle SQL function <code>XMLRoot</code> was at one time part of the SQL/XML standard, but it is <span class="italic">deprecated</span> as a standard function as of SQL/XML 2005. It remains available in Oracle XML&nbsp;DB, as an Oracle SQL function.</p>
<p>You use <code>XMLRoot</code> to add a <code>VERSION</code> property, and optionally a <code>STANDALONE</code> property, to the root information item of an XML value. Typically, this is done to ensure data-model compliance. <a href="#CHDFCACA">Figure 18-10</a> shows the syntax of <code>XMLRoot</code>:</p>
<div id="ADXDB5031" class="figure">
<p class="titleinfigure"><a id="CHDFCACA"></a>Figure 18-10 XMLRoot Syntax</p>
<img width="803" height="128" src="img/xmlroot.gif" alt="Description of Figure 18-10 follows" /><br />
<a id="sthref1231" href="img_text/xmlroot.htm">Description of "Figure 18-10 XMLRoot Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The first argument, <code><span class="codeinlineitalic">xml-expression</span></code>, is evaluated, and the indicated properties (<code>VERSION</code>, <code>STANDALONE</code>) and their values are added to a new prolog for the resulting <code>XMLType</code> instance. If the evaluated <code><span class="codeinlineitalic">xml-expression</span></code> already contains a prolog, then an error is raised.</p>
<p>Second argument <code><span class="codeinlineitalic">string-valued-expression</span></code> (which follows keyword <code>VERSION</code>) is evaluated, and the resulting string is used as the value of the prolog <code>version</code> property. The value of the prolog <code>standalone</code> property (lowercase) is taken from the optional third argument <code>STANDALONE</code> <code>YES</code> or <code>NO</code> value. If <code>NOVALUE</code> is used for <code>VERSION</code>, then <code>"version=1.0"</code> is used in the resulting prolog. If <code>NOVALUE</code> is used for <code>STANDALONE</code>, then the <code>standalone</code> property is omitted from the resulting prolog.</p>
<p>Function <code>XMLRoot</code> returns an instance of <code>XMLType</code>. If first argument <code><span class="codeinlineitalic">xml-expression</span></code> evaluates to <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="#CHECHGFD">Example 18-19</a> uses <code>XMLRoot</code> to add an XML declaration with <code>version</code> and <code>standalone</code> attributes.</p>
<div id="ADXDB5032" class="example">
<p class="titleinexample"><a id="CHECHGFD"></a>Example 18-19 Using Oracle SQL Function XMLRoot</p>
<pre>
SELECT XMLRoot(XMLType('&lt;poid&gt;143598&lt;/poid&gt;'), VERSION '1.0', STANDALONE YES)
  AS xmlroot FROM DUAL; 
</pre>
<p>This results in the following output:</p>
<pre>
XMLROOT
--------------------------------------
&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;poid&gt;143598&lt;/poid&gt;

1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1032060"></a>
<div id="ADXDB5041" class="sect2">
<h3 class="sect2">XMLCOLATTVAL Oracle SQL <a id="sthref1232"></a><a id="sthref1233"></a><a id="sthref1234"></a>Function</h3>
<p>Oracle SQL function <code>XMLColAttVal</code> generates a forest of XML <code>column</code> elements containing the values of the arguments passed in. This function is an Oracle extension to the SQL/XML ANSI-ISO standard functions. <a href="#i1032066">Figure 18-11</a> shows the <code>XMLColAttVal</code> syntax.</p>
<div id="ADXDB5042" class="figure">
<p class="titleinfigure"><a id="i1032066"></a>Figure 18-11 XMLCOLATTVAL Syntax</p>
<img width="596" height="110" src="img/xmlcolattval.gif" alt="Description of Figure 18-11 follows" /><br />
<a id="sthref1235" href="img_text/xmlcolattval.htm">Description of "Figure 18-11 XMLCOLATTVAL Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The arguments are used as the values of the <code>name</code> attribute of the <code>column</code> element. The <code><span class="codeinlineitalic">c_alias</span></code> values are used as the attribute identifiers.</p>
<p>As an alternative to using keyword <code>AS</code> followed by a <span class="italic">literal</span> string <code><span class="codeinlineitalic">c_alias</span></code>, you can use <code>AS EVALNAME</code> followed by an expression that evaluates to a string to be used as the attribute identifier.</p>
<p>Because argument values <code><span class="codeinlineitalic">value_expr</span></code> are used only as attribute <span class="italic">values</span>, they need <span class="italic">not</span> be escaped in any way. This is in contrast to function <code>XMLForest</code>. It means that you can use <code>XMLColAttVal</code> to transport SQL columns and values without escaping.</p>
<p><a href="#CHDBEBGD">Example 18-20</a> uses <code>XMLColAttVal</code> to generate an <code>Emp</code> element for each employee, with a <code>name</code> attribute, and with <code>column</code> elements that have the employee hire date and department as the content.</p>
<div id="ADXDB5043" class="example">
<p class="titleinexample"><a id="CHDBEBGD"></a>Example 18-20 XMLCOLATTVAL: Generating Elements with Attribute and Child Elements</p>
<pre>
SELECT XMLElement("Emp", 
                  XMLAttributes(e.first_name ||' '||e.last_name AS "fullname" ),
                  XMLColAttVal(e.hire_date, e.department_id AS "department"))
  AS "RESULT" 
  FROM hr.employees e
  WHERE e.department_id = 30;
</pre>
<p>This query produces the following XML result. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
RESULT
-----------------------------------------------------------
&lt;Emp fullname="Den Raphaely"&gt;
  &lt;column name = "HIRE_DATE"&gt;2002-12-07&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Alexander Khoo"&gt;
  &lt;column name = "HIRE_DATE"&gt;2003-05-18&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Shelli Baida"&gt;
  &lt;column name = "HIRE_DATE"&gt;2005-12-24&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Sigal Tobias"&gt;
  &lt;column name = "HIRE_DATE"&gt;2005-07-24&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Guy Himuro"&gt;
  &lt;column name = "HIRE_DATE"&gt;2006-11-15&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
&lt;Emp fullname="Karen Colmenares"&gt;
  &lt;column name = "HIRE_DATE"&gt;2007-08-10&lt;/column&gt;
  &lt;column name = "department"&gt;30&lt;/column&gt;
&lt;/Emp&gt;
 
6 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDBJDAG">Example 18-8, "XMLFOREST: Generating Elements with Attribute and Child Elements"</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDGCFFI"></a>
<div id="ADXDB5044" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLCDATA<a id="sthref1236"></a><a id="sthref1237"></a><a id="sthref1238"></a> Oracle SQL Function</h3>
<p>You use Oracle SQL function <code>XMLCDATA</code> to generate an XML <code>CDATA</code> section. <a href="#CHDFIDBF">Figure 18-12</a> shows the syntax:</p>
<div id="ADXDB5045" class="figure">
<p class="titleinfigure"><a id="CHDFIDBF"></a>Figure 18-12 XMLCDATA Syntax</p>
<img width="248" height="27" src="img/xmlcdata.gif" alt="Description of Figure 18-12 follows" /><br />
<a id="sthref1239" href="img_text/xmlcdata.htm">Description of "Figure 18-12 XMLCDATA Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Argument <code><span class="codeinlineitalic">value_expr</span></code> is evaluated to a string, and the result is used as the body of the generated XML <code>CDATA</code> section, <code>&lt;![CDATA[</code><code><span class="codeinlineitalic">string-result</span></code><code>]]&gt;</code>, where <code><span class="codeinlineitalic">string-result</span></code> is the result of evaluating <code><span class="codeinlineitalic">value_expr</span></code>. If <code><span class="codeinlineitalic">string-result</span></code> is the empty string, then the <code>CDATA</code> section is empty: <code>&lt;![CDATA[]]&gt;</code>.</p>
<p>An error is raised if the constructed XML is not a legal XML <code>CDATA</code> section. In particular, <code><span class="codeinlineitalic">string-result</span></code> must <span class="italic">not</span> contain two consecutive right brackets (<code>]</code>): "<code>]]</code>".</p>
<p>Function <code>XMLCDATA</code> returns an instance of <code>XMLType</code>. If <code><span class="codeinlineitalic">string-result</span></code> is <code>NULL</code>, then the function returns <code>NULL</code>.</p>
<p><a href="#CHEHADIH">Example 18-21</a> uses <code>XMLCDATA</code> to generate an XML <code>CDATA</code> section.</p>
<div id="ADXDB5046" class="example">
<p class="titleinexample"><a id="CHEHADIH"></a>Example 18-21 Using Oracle SQL Function XMLCDATA</p>
<pre>
SELECT XMLElement("PurchaseOrder",
                  XMLElement("Address",
                             XMLCDATA('100 Pennsylvania Ave.'),
                             XMLElement("City", 'Washington, D.C.')))
  AS RESULT FROM DUAL;
                            
</pre>
<p>This results in the following output. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
RESULT
--------------------------
&lt;PurchaseOrder&gt;
  &lt;Address&gt;
    &lt;![CDATA[100 Pennsylvania Ave.]]&gt;
    &lt;City&gt;Washington, D.C.&lt;/City&gt;
  &lt;/Address&gt;
&lt;/PurchaseOrder&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1025386"></a>
<div id="ADXDB5047" class="sect1">
<h2 class="sect1">Generating XML using DBMS_<a id="sthref1240"></a><a id="sthref1241"></a><a id="sthref1242"></a>XMLGEN</h2>
<p>PL/SQL package <code>DBMS_XMLGEN</code> creates XML documents from SQL query results. It retrieves an XML document as a <code>CLOB</code> or <code>XMLType</code> value.</p>
<p>It provides a <span class="italic">fetch</span> interface, whereby you can specify the maximum number of rows to retrieve and the number of rows to skip. For example, the first fetch could retrieve a maximum of ten rows, skipping the first four. This is especially useful for pagination requirements in Web applications.</p>
<p>Package <code>DBMS_XMLGEN</code> also provides options for changing tag names for <code>ROW</code>, <code>ROWSET</code>, and so on. The parameters of the package can restrict the number of rows retrieved and the enclosing tag names.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS374" href="../../appdev.112/e40758/d_xmlgen.htm#ARPLS374"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></p>
</li>
<li>
<p><a class="olink ADXDK070" href="../../appdev.112/e23582/adx_j_xsu.htm#ADXDK070"><span class="italic">Oracle XML Developer's Kit Programmer's Guide</span></a> (compare <code>OracleXMLQuery</code> with <code>DBMS_XMLGEN</code>)</p>
</li>
</ul>
</div>
<div id="ADXDB5048" class="sect2"><a id="sthref1243"></a>
<h3 class="sect2">Using PL/SQL Package DBMS_XMLGEN</h3>
<p><a href="#i1025437">Figure 18-13</a> illustrates how to use package <code>DBMS_XMLGEN</code>. The steps are as follows:</p>
<ol>
<li>
<p>Get the context from the package by supplying a SQL query and calling PL/SQL function <code>newContext</code>.</p>
</li>
<li>
<p>Pass the context to all procedures or functions in the package to set the various options. For example, to set the <code>ROW</code> element name, use <code>setRowTag(ctx)</code>, where <code>ctx</code> is the context got from the previous <code>newContext</code> call.</p>
</li>
<li>
<p>Get the XML result, using PL/SQL function <code>getXML</code> or <code>getXMLType</code>. By setting the maximum number of rows to be retrieved for each fetch using PL/SQL procedure <code>setMaxRows</code>, you can call either of these functions repeatedly, retrieving up to the maximum number of rows for each call. These functions return XML data (as a <code>CLOB</code> value and as an instance of <code>XMLType</code>, respectively), unless there are no rows retrieved. In that case, these functions return <code>NULL</code>. To determine how many rows were retrieved, use PL/SQL function <code>getNumRowsProcessed</code>.</p>
</li>
<li>
<p>You can reset the query to start again and repeat step 3.</p>
</li>
<li>
<p>Call PL/SQL procedure <code>closeContext</code> to free up any previously allocated resources.</p>
</li>
</ol>
<div id="ADXDB5049" class="figure">
<p class="titleinfigure"><a id="i1025437"></a>Figure 18-13 Using PL/SQL Package DBMS_XMLGEN</p>
<img width="683" height="365" src="img/adxdb054.gif" alt="Description of Figure 18-13 follows" /><br />
<a id="sthref1244" href="img_text/adxdb054.htm">Description of "Figure 18-13 Using PL/SQL Package DBMS_XMLGEN"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In conjunction with a SQL query, PL/SQL method <code>DBMS_XMLGEN.getXML()</code> typically returns a result similar to the following, as a <code>CLOB</code> value:</p>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;17-JUN-87&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
  &lt;SALARY&gt;24000&lt;/SALARY&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-89&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
</pre>
<p>The default mapping between relational data and XML data is as follows:</p>
<ul>
<li>
<p>Each row returned by the SQL query maps to an XML element with the default element name <code>ROW</code>.</p>
</li>
<li>
<p>Each column returned by the SQL query maps to a child element of the <code>ROW</code> element.</p>
</li>
<li>
<p>The entire result is wrapped in a <code>ROWSET</code> element.</p>
</li>
<li>
<p>Binary data is transformed to its hexadecimal representation.</p>
</li>
</ul>
<p>Element names <code>ROW</code> and <code>ROWSET</code> can be replaced with names you choose, using <code>DBMS_XMLGEN</code> procedures <code>setRowTagName</code> and <code>setRowSetTagName</code>, respectively.</p>
<p>The <code>CLOB</code> value returned by <code>getXML</code> has the same encoding as the database character set. If the database character set is SHIFTJIS, then the XML document returned is also SHIFTJIS.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB5050" class="sect2"><a id="sthref1245"></a>
<h3 class="sect2">Functions and Procedures of Package DBMS_XMLGEN</h3>
<p><a href="#g1033764">Table 18-1</a> describes the functions and procedures of package <code>DBMS_XMLGEN</code>.</p>
<div id="ADXDB5051" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref1246"></a><a id="g1033764"></a>Table 18-1 DBMS_XMLGEN Functions and Procedures</p>
<table class="cellalignment1032" title=" DBMS_XMLGEN Functions and Procedures" summary="This table describes DBMS_XMLGEN functions and procedures." >
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t12">Function or Procedure</th>
<th class="cellalignment1027" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t12" headers="r1c1-t12">
<pre>
SUBTYPE ctxHandle IS NUMBER
</pre></td>
<td class="cellalignment1028" headers="r2c1-t12 r1c2-t12">
<p>The context handle used by all functions.</p>
<p>Document Type Definition (DTD) or schema specifications:</p>
<p><code>NONE CONSTANT NUMBER:= 0;</code></p>
<p><code>DTD CONSTANT NUMBER:= 1;</code></p>
<p><code>SCHEMA CONSTANT NUMBER:= 2;</code></p>
<p>Can be used in function <code>getXML</code> to specify whether to generate a DTD or XML schema or neither (<code>NONE</code>). Only the <code>NONE</code> specification is supported.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t12" headers="r1c1-t12">
<pre>
<a id="i1025480"></a>
newContext()
</pre></td>
<td class="cellalignment1028" headers="r3c1-t12 r1c2-t12">
<p>Given a query string, generate a new context handle to be used in subsequent functions.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t12" headers="r1c1-t12">
<pre>
newContext(
  queryString IN VARCHAR2)
</pre></td>
<td class="cellalignment1028" headers="r4c1-t12 r1c2-t12">
<p>Returns a new context</p>
<p><span class="italic">Parameter:</span> <code>queryString</code> <code>(IN)</code>- the query string, the result of which must be converted to XML</p>
<p><span class="italic">Returns:</span> Context handle. Call this function first to obtain a handle that you can use in the <code>getXML</code> and other functions to get the XML back from the result.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t12" headers="r1c1-t12">
<pre>
newContext(
  queryString IN SYS_REFCURSOR)
  RETURN ctxHandle;
</pre></td>
<td class="cellalignment1028" headers="r5c1-t12 r1c2-t12">
<p>Creates a new context handle from a PL/SQL cursor variable. The context handle can be used for the rest of the functions.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t12" headers="r1c1-t12">
<pre>
newContextFromHierarchy(
  queryString IN VARCHAR2)
  RETURN ctxHandle;
</pre></td>
<td class="cellalignment1028" headers="r6c1-t12 r1c2-t12">
<p><span class="italic">Parameter:</span> <code>queryString (IN)</code> - the query string, the result of which must be converted to XML. The query is a hierarchical query typically formed using a <code>CONNECT BY</code> clause, and the result must have the same property as the result set generated by a <code>CONNECT BY</code> query. The result set must have only two columns, the level number and an XML value. The level number is used to determine the hierarchical position of the XML value within the result XML document.</p>
<p><span class="italic">Returns:</span> Context handle. Call this function first to obtain a handle that you can use in the <code>getXML</code> and other functions to get a hierarchical XML with recursive elements back from the result.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t12" headers="r1c1-t12">
<pre>
setRowTag()
</pre></td>
<td class="cellalignment1028" headers="r7c1-t12 r1c2-t12">
<p>Sets the name of the element separating all the rows. The default name is <code>ROW</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t12" headers="r1c1-t12">
<pre>
<a id="i1025497"></a>
setRowTag(ctx IN ctxHandle,
          rowTag IN VARCHAR2);
</pre></td>
<td class="cellalignment1028" headers="r8c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle obtained from the <code>newContext</code> call.</p>
<p><code>rowTag(IN)</code> - the name of the <code>ROW</code> element. A <code>NULL</code> value for <code>rowTag</code> indicates that you do not want the <code>ROW</code> element to be present.</p>
<p>Call this procedure to set the name of the <code>ROW</code> element, if you do not want the default <code>ROW</code> name to show up. You can also set <code>rowTag</code> to <code>NULL</code> to suppress the <code>ROW</code> element itself.</p>
<p>However, since getXML returns complete XML documents, not XML fragments, there must be a (single) root element. Therefore, an error is raised if both the <code>rowTag</code> value and the <code>rowSetTag</code> value (see <code>setRowSetTag</code>, next) are <code>NULL</code> and there is more than one column or row in the output.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t12" headers="r1c1-t12">
<pre>
<a id="i1025505"></a>
setRowSetTag()
</pre></td>
<td class="cellalignment1028" headers="r9c1-t12 r1c2-t12">
<p>Sets the name of the document root element. The default name is <code>ROWSET</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t12" headers="r1c1-t12">
<pre>
setRowSetTag(ctx IN ctxHandle, 
             rowSetTag IN VARCHAR2);
</pre></td>
<td class="cellalignment1028" headers="r10c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> &ndash; the context handle obtained from the <code>newContext</code> call.</p>
<p><code>rowSetTag(IN)</code> &ndash; the name of the document root element to be used in the output. A <code>NULL</code> value for <code>rowSetTag</code> indicates that you do <span class="italic">not</span> want the <code>ROWSET</code> element to be present.</p>
<p>Call this procedure to set the name of the document root element, if you do not want the default name <code>ROWSET</code> to be used. You can set <code>rowSetTag</code> to <code>NULL</code> to suppress printing of the document root element.</p>
<p>However, since function <code>getXML</code> returns complete XML documents, not XML fragments, there must be a (single) root element. Therefore, an error is raised if both the <code>rowTag</code> value and the <code>rowSetTag</code> value (see <code>setRowTag</code>, previous) are <code>NULL</code> and there is more than one column or row in the output, or if the <code>rowSetTag</code> value is <code>NULL</code> and there is more than one row in the output.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t12" headers="r1c1-t12">
<pre>
getXML()
</pre></td>
<td class="cellalignment1028" headers="r11c1-t12 r1c2-t12">
<p>Gets the XML document by fetching the maximum number of rows specified. It appends the XML document to the <code>CLOB</code> passed in.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t12" headers="r1c1-t12">
<pre>
getXML(ctx IN ctxHandle, 
       clobval IN OUT NCOPY clob, 
       dtdOrSchema IN number:= NONE);
</pre></td>
<td class="cellalignment1028" headers="r12c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - The context handle obtained from calling <code>newContext</code>.</p>
<p><code>clobval(IN/OUT)</code> - the <code>CLOB</code> to which the XML document is to be appended,</p>
<p><code>dtdOrSchema(IN)</code> - whether you should generate the DTD or Schema. This parameter is NOT supported.</p>
<p>Use this version of the getXML function, to avoid any extra <code>CLOB</code> copies and if you want to reuse the same <code>CLOB</code> for subsequent calls. This <code>getXML</code> call is more efficient than the next flavor, though this involves that you create the LOB locator. When generating the XML, the number of rows indicated by the <code>setSkipRows</code> call are skipped, then the maximum number of rows as specified by the <code>setMaxRows</code> call (or the entire result if not specified) is fetched and converted to XML. Use the <code>getNumRowsProcessed</code> function to check if any rows were retrieved or not.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r13c1-t12" headers="r1c1-t12">
<pre>
getXML()
</pre></td>
<td class="cellalignment1028" headers="r13c1-t12 r1c2-t12">
<p>Generates the XML document and returns it as a <code>CLOB</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r14c1-t12" headers="r1c1-t12">
<pre>
getXML(ctx IN ctxHandle, 
       dtdOrSchema IN number:= NONE) 
  RETURN clob;
</pre></td>
<td class="cellalignment1028" headers="r14c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - The context handle obtained from calling <code>newContext</code>.</p>
<p><code>dtdOrSchema(IN)</code> - whether to generate a DTD or XML schema. This parameter is <span class="italic">not</span> supported.</p>
<p><span class="italic">Returns:</span> A temporary <code>CLOB</code> containing the document. Free the temporary <code>CLOB</code> obtained from this function using the <code>DBMS_LOB.freeTemporary</code> call.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r15c1-t12" headers="r1c1-t12">
<pre>
<a id="i1025548"></a>
getXMLType(
  ctx IN ctxHandle, 
  dtdOrSchema IN number:= NONE)
  RETURN XMLType;
</pre></td>
<td class="cellalignment1028" headers="r15c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - The context handle obtained from calling <code>newContext</code>.</p>
<p><code>dtdOrSchema(IN)</code> - whether to generate a DTD or XML schema. This parameter is <span class="italic">not</span> supported.</p>
<p><span class="italic">Returns:</span> An <code>XMLType</code> instance containing the document.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r16c1-t12" headers="r1c1-t12">
<pre>
getXML(
  sqlQuery IN VARCHAR2, 
  dtdOrSchema IN NUMBER := NONE)
  RETURN CLOB;
</pre></td>
<td class="cellalignment1028" headers="r16c1-t12 r1c2-t12">
<p>Converts the query results from the passed in SQL query string to XML format, and returns the XML as a <code>CLOB</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r17c1-t12" headers="r1c1-t12">
<pre>
getXMLType(
  sqlQuery IN VARCHAR2, 
  dtdOrSchema IN NUMBER := NONE)   
  RETURN XMLType;
</pre></td>
<td class="cellalignment1028" headers="r17c1-t12 r1c2-t12">
<p>Converts the query results from the passed in SQL query string to XML format, and returns the XML as a <code>CLOB</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r18c1-t12" headers="r1c1-t12">
<p class="synopsis"><code>getNumRowsProcessed()</code></p>
</td>
<td class="cellalignment1028" headers="r18c1-t12 r1c2-t12">
<p>Gets the number of SQL rows processed when generating XML data using function <code>getXML</code>. This count does not include the number of rows <span class="italic">skipped</span> before generating XML data.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r19c1-t12" headers="r1c1-t12">
<pre>
getNumRowsProcessed(ctx IN ctxHandle) 
  RETURN number;
</pre></td>
<td class="cellalignment1028" headers="r19c1-t12 r1c2-t12">
<p><span class="italic">Parameter:</span> <code>queryString(IN)</code>- the query string, the result of which must be converted to XML</p>
<p><span class="italic">Returns:</span> The number of SQL rows that were processed in the last call to <code>getXML</code>.</p>
<p>You can call this to find out if the end of the result set has been reached. This does not include the number of rows <span class="italic">skipped</span> before generating XML data. Use this function to determine the terminating condition if you are calling <code>getXML</code> in a loop. Note that <code>getXML</code> would always generate an XML document even if there are no rows present.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r20c1-t12" headers="r1c1-t12">
<pre>
setMaxRows()
</pre></td>
<td class="cellalignment1028" headers="r20c1-t12 r1c2-t12">
<p>Sets the maximum number of rows to fetch from the SQL query result for every invocation of the <code>getXML</code> call. It is an error to call this function on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r21c1-t12" headers="r1c1-t12">
<pre>
setMaxRows(ctx IN ctxHandle, 
           maxRows IN NUMBER);
</pre></td>
<td class="cellalignment1028" headers="r21c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle corresponding to the query executed,</p>
<p><code>maxRows(IN)</code> - the maximum number of rows to get for each call to <code>getXML</code>.</p>
<p>The <code>maxRows</code> parameter can be used when generating paginated results using this utility. For instance when generating a page of XML or HTML data, you can restrict the number of rows converted to XML and then in subsequent calls, you can get the next set of rows and so on. This also can provide for faster response times. It is an error to call this procedure on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r22c1-t12" headers="r1c1-t12">
<pre>
setSkipRows()
</pre></td>
<td class="cellalignment1028" headers="r22c1-t12 r1c2-t12">
<p>Skips a given number of rows before generating the XML output for every call to <code>getXML</code>. It is an error to call this function on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r23c1-t12" headers="r1c1-t12">
<pre>
setSkipRows(ctx IN ctxHandle, 
            skipRows IN NUMBER);
</pre></td>
<td class="cellalignment1028" headers="r23c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle corresponding to the query executed,</p>
<p><code>skipRows(IN)</code> - the number of rows to skip for each call to <code>getXML</code>.</p>
<p>The <code>skipRows</code> parameter can be used when generating paginated results for stateless Web pages using this utility. For instance when generating the first page of XML or HTML data, you can set <code>skipRows</code> to zero. For the next set, you can set the <code>skipRows</code> to the number of rows that you got in the first case. It is an error to call this function on a context handle created by function <code>newContextFromHierarchy</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r24c1-t12" headers="r1c1-t12">
<pre>
setConvertSpecialChars()
</pre></td>
<td class="cellalignment1028" headers="r24c1-t12 r1c2-t12">
<p>Determines whether or not special characters in the XML data must be converted into their escaped XML equivalent. For example, the <code>&lt;</code> sign is converted to <code>&amp;lt;</code>. The default behavior is to perform escape conversions.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r25c1-t12" headers="r1c1-t12">
<pre>
setConvertSpecialChars(
  ctx IN ctxHandle, 
  conv IN BOOLEAN);
</pre></td>
<td class="cellalignment1028" headers="r25c1-t12 r1c2-t12">
<p><span class="italic">Parameters:</span></p>
<p><code>ctx(IN)</code> - the context handle to use,</p>
<p><code>conv(IN)</code> - true indicates that conversion is needed.</p>
<p>You can use this function to speed up the XML processing whenever you are sure that the input data cannot contain any special characters such as <code><span class="codeinlinebold">&lt;</span></code>, <code><span class="codeinlinebold">&gt;</span></code>, <code><span class="codeinlinebold">"</span></code>, <code><span class="codeinlinebold">'</span></code>, and so on, which must be preceded by an escape character. It is expensive to scan the character data to replace the special characters, particularly if it involves a lot of data. So, in cases when the data is XML-safe, this function can be called to improve performance.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r26c1-t12" headers="r1c1-t12">
<pre>
useItemTagsForColl()
</pre></td>
<td class="cellalignment1028" headers="r26c1-t12 r1c2-t12">
<p>Sets the name of the collection elements. The default name for collection elements it the type name itself. You can override that to use the name of the column with the <code>_ITEM</code> tag appended to it using this function.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r27c1-t12" headers="r1c1-t12">
<pre>
useItemTagsForColl(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment1028" headers="r27c1-t12 r1c2-t12">
<p><span class="italic">Parameter:</span> <code>ctx(IN)</code> - the context handle.</p>
<p>If you have a collection of <code>NUMBER</code>, say, the default tag name for the collection elements is <code>NUMBER</code>. You can override this action and generate the collection column name with the <code>_ITEM</code> tag appended to it, by calling this procedure.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r28c1-t12" headers="r1c1-t12">
<pre>
restartQuery()
</pre></td>
<td class="cellalignment1028" headers="r28c1-t12 r1c2-t12">
<p>Restarts the query and generate the XML from the first row again.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r29c1-t12" headers="r1c1-t12">
<pre>
restartQuery(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment1028" headers="r29c1-t12 r1c2-t12">
<p><span class="italic">Parameter:</span> <code>ctx(IN)</code> - the context handle corresponding to the current query. You can call this to start executing the query again, without having to create a new context.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r30c1-t12" headers="r1c1-t12">
<pre>
closeContext()
</pre></td>
<td class="cellalignment1028" headers="r30c1-t12 r1c2-t12">
<p>Closes a given context and releases all resources associated with that context, including the SQL cursor and bind and define buffers, and so on.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r31c1-t12" headers="r1c1-t12">
<pre>
closeContext(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment1028" headers="r31c1-t12 r1c2-t12">
<p><span class="italic">Parameter:</span> <code>ctx(IN)</code> - the context handle to close. Closes all resources associated with this handle. After this you cannot use the handle for any other <code>DBMS_XMLGEN</code> function call.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r32c1-t12" headers="r1c1-t12">
<p><span class="italic">Conversion Functions</span></p>
<pre>
convert(
  xmlData IN varchar2, 
  flag IN NUMBER := ENTITY_ENCODE)    
  RETURN VARCHAR2;
</pre></td>
<td class="cellalignment1028" headers="r32c1-t12 r1c2-t12">
<p>Encodes or decodes the XML data string argument.</p>
<ul>
<li>
<p>Encoding refers to replacing entity references such as <code>&lt;</code> to their escaped equivalent, such as <code>&amp;lt;</code>.</p>
</li>
<li>
<p>Decoding refers to the reverse conversion.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r33c1-t12" headers="r1c1-t12">
<pre>
convert(
  xmlData IN CLOB, 
  flag IN NUMBER := ENTITY_ENCODE) 
  RETURN CLOB;
</pre></td>
<td class="cellalignment1028" headers="r33c1-t12 r1c2-t12">
<p>Encodes or decodes the passed in XML <code>CLOB</code> data.</p>
<ul>
<li>
<p>Encoding refers to replacing entity references such as <code>&lt;</code> to their escaped equivalent, such as <code>&amp;lt;</code>.</p>
</li>
<li>
<p>Decoding refers to the reverse conversion.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r34c1-t12" headers="r1c1-t12">
<p><span class="italic">NULL Handling</span></p>
<pre>
setNullHandling(ctx IN ctxHandle, 
                flag IN NUMBER);
</pre></td>
<td class="cellalignment1028" headers="r34c1-t12 r1c2-t12">
<p>The <code>setNullHandling</code> flag values are:</p>
<ul>
<li>
<p><code>DROP_NULLS CONSTANT NUMBER := 0;</code></p>
<p>This is the default setting and leaves out the tag for <code>NULL</code> elements.</p>
</li>
<li>
<p><code>NULL_ATTR CONSTANT NUMBER := 1;</code></p>
<p>This sets <code>xsi:nil = "true"</code>.</p>
</li>
<li>
<p><code>EMPTY_TAG CONSTANT NUMBER := 2;</code></p>
<p>This sets, for example, <code>&lt;foo/&gt;</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r35c1-t12" headers="r1c1-t12">
<pre>
useNullAttributeIndicator(
  ctx IN ctxHandle, 
  attrind IN BOOLEAN := TRUE);
</pre></td>
<td class="cellalignment1028" headers="r35c1-t12 r1c2-t12">
<p><code>useNullAttributeIndicator</code> is a shortcut for <code>setNullHandling(ctx, NULL_ATTR)</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r36c1-t12" headers="r1c1-t12">
<pre>
setBindValue(
  ctx IN ctxHandle, 
  bindVariableName IN VARCHAR2, 
  bindValue IN VARCHAR2);
</pre></td>
<td class="cellalignment1028" headers="r36c1-t12 r1c2-t12">
<p>Sets bind value for the bind variable appearing in the query string associated with the context handle. The query string with bind variables cannot be executed until all of the bind variables are set values using <code>setBindValue</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r37c1-t12" headers="r1c1-t12">
<pre>
clearBindValue(ctx IN ctxHandle);
</pre></td>
<td class="cellalignment1028" headers="r37c1-t12 r1c2-t12">
<p>Clears all the bind values for all the bind variables appearing in the query string associated with the context handle. Afterwards, all of the bind variables must rebind new values using <code>setBindValue</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect2" -->
<div id="ADXDB5052" class="sect2"><a id="sthref1247"></a>
<h3 class="sect2">DBMS_XMLGEN Examples</h3>
<p><a href="#i1025636">Example 18-22</a> uses <code>DBMS_XMLGEN</code> to create an XML document by selecting employee data from an object-relational table and putting the resulting <code>CLOB</code> value into a table.</p>
<div id="ADXDB5053" class="example">
<p class="titleinexample"><a id="i1025636"></a>Example 18-22 DBMS_XMLGEN: Generating Simple XML</p>
<pre>
CREATE TABLE temp_clob_tab (result CLOB);

DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  qryCtx := DBMS_XMLGEN.newContext(
              'SELECT * FROM hr.employees WHERE employee_id = 101');
  -- Set the row header to be EMPLOYEE
  DBMS_XMLGEN.setRowTag(qryCtx, 'EMPLOYEE');
  -- Get the result
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  --Close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
</pre>
<p>That generates the following XML document:</p>
<pre>
SELECT * FROM temp_clob_tab;

RESULT
-------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-05&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>Instead of generating all of the XML data for all rows, you can use the fetch interface of package <code>DBMS_XMLGEN</code> to retrieve a fixed number of rows each time. This speeds up response time and can help in scaling applications that need a Document Object Model (DOM) Application Program Interface (API) on the resulting XML, particularly if the number of rows is large.</p>
<p><a href="#i1025688">Example 18-23</a> uses <code>DBMS_XMLGEN</code> to retrieve results from table <code>HR.employees</code>:</p>
<div id="ADXDB5054" class="example">
<p class="titleinexample"><a id="i1025688"></a>Example 18-23 DBMS_XMLGEN: Generating Simple XML with Pagination (Fetch)</p>
<pre>
-- Create a table to hold the results
CREATE TABLE temp_clob_tab (result clob);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  -- Get the query context;
  qryCtx := DBMS_XMLGEN.newContext('SELECT * FROM hr.employees');
  -- Set the maximum number of rows to be 2
  DBMS_XMLGEN.<span class="bold">setMaxRows</span>(qryCtx, 2);
  LOOP
    -- Get the result
    result := DBMS_XMLGEN.getXML(qryCtx);
    -- If no rows were processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
 
    -- Do some processing with the lob data
    --   Insert the results into a table.
    --   You can print the lob out, output it to a stream,
    --   put it in a queue, or do any other processing.
    INSERT INTO temp_clob_tab VALUES(result);
  END LOOP;
  --close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/

SELECT * FROM temp_clob_tab WHERE rownum &lt; 3;

RESULT
----------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;17-JUN-03&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
  &lt;SALARY&gt;24000&lt;/SALARY&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;101&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Neena&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Kochhar&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;NKOCHHAR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4568&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;21-SEP-05&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;102&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Lex&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;De Haan&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;LDEHAAN&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;515.123.4569&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;13-JAN-01&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;AD_VP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;17000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;103&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Alexander&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Hunold&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;AHUNOLD&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;590.423.4567&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;03-JAN-06&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;IT_PROG&lt;/JOB_ID&gt;
  &lt;SALARY&gt;9000&lt;/SALARY&gt;
  &lt;MANAGER_ID&gt;102&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;60&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BABFCBFF">Example 18-24</a> uses <code>DBMS_XMLGEN</code> with object types to represent nested structures.</p>
<div id="ADXDB5055" class="example">
<p class="titleinexample"><a id="BABFCBFF"></a>Example 18-24 DBMS_XMLGEN: Generating XML using Object Types</p>
<pre>
CREATE TABLE new_departments (department_id   NUMBER PRIMARY KEY,
                              department_name VARCHAR2(20));
CREATE TABLE new_employees (employee_id       NUMBER PRIMARY KEY,
                            last_name         VARCHAR2(20),
                            department_id     NUMBER REFERENCES new_departments);
CREATE TYPE emp_t AS OBJECT ("@employee_id"   NUMBER,
                             last_name        VARCHAR2(20));
/
INSERT INTO new_departments VALUES (10, 'SALES');
INSERT INTO new_departments VALUES (20, 'ACCOUNTING');
INSERT INTO new_employees   VALUES (30, 'Scott', 10);
INSERT INTO new_employees   VALUES (31, 'Mary',  10);
INSERT INTO new_employees   VALUES (40, 'John',  20);
INSERT INTO new_employees   VALUES (41, 'Jerry', 20);
COMMIT;
CREATE TYPE emplist_t AS TABLE OF emp_t;
/
CREATE TYPE dept_t AS OBJECT ("@department_id" NUMBER,
                              department_name  VARCHAR2(20),
                              emplist          emplist_t);
/
CREATE TABLE temp_clob_tab (result CLOB);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  DBMS_XMLGEN.setRowTag(qryCtx, NULL);
  qryCtx := DBMS_XMLGEN.newContext
    ('SELECT dept_t(department_id,
                    department_name,
                    cast(MULTISET
                         (SELECT e.employee_id, e.last_name
                            FROM new_employees e
                            WHERE e.department_id = d.department_id)
                         AS emplist_t))
        AS deptxml
        FROM new_departments d');
  -- now get the result
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES (result);
  -- close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
SELECT * FROM temp_clob_tab;
</pre>
<p>Here is the resulting XML:</p>
<pre>
RESULT
--------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;DEPTXML department_id="10"&gt;
   &lt;DEPARTMENT_NAME&gt;SALES&lt;/DEPARTMENT_NAME&gt;
   &lt;EMPLIST&gt;
    &lt;EMP_T employee_id="30"&gt;
     &lt;LAST_NAME&gt;Scott&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
    &lt;EMP_T employee_id="31"&gt;
     &lt;LAST_NAME&gt;Mary&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
   &lt;/EMPLIST&gt;
  &lt;/DEPTXML&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;DEPTXML department_id="20"&gt;
   &lt;DEPARTMENT_NAME&gt;ACCOUNTING&lt;/DEPARTMENT_NAME&gt;
   &lt;EMPLIST&gt;
    &lt;EMP_T employee_id="40"&gt;
     &lt;LAST_NAME&gt;John&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
    &lt;EMP_T employee_id="41"&gt;
     &lt;LAST_NAME&gt;Jerry&lt;/LAST_NAME&gt;
    &lt;/EMP_T&gt;
   &lt;/EMPLIST&gt;
  &lt;/DEPTXML&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>With relational data, the result is an XML document without nested elements. To obtain nested XML structures, you can use object-relational data, where the mapping is as follows:</p>
<ul>
<li>
<p><span class="italic">Object types</span> map as an XML element &ndash; see <a href="xdb05sto.htm#g1070409">Chapter 7, "XML Schema Storage and Query: Basic"</a>.</p>
</li>
<li>
<p><span class="italic">Attributes of the type</span> map to sub-elements of the parent element</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Complex structures can be obtained by using object types and creating object views or object tables. A canonical mapping is used to map object instances to XML.
<p>When used in column names or attribute names, the at-sign (<code>@</code>) is translated into an attribute of the enclosing XML element in the mapping.</p>
</div>
</li>
</ul>
<p>When you provide a user-defined data-type instance to <code>DBMS_XMLGEN</code> functions, the user-defined data-type instance is mapped to an XML document using canonical mapping: the <span class="italic">attributes</span> of the user-defined data type are mapped to XML <span class="italic">elements</span>. Attributes with names starting with an at-sign character (<code>@</code>) are mapped to attributes of the preceding element.</p>
<p>User-defined data-type instances can be used for nesting in the resulting XML document.</p>
<p>For example, consider the tables <code>emp</code> and <code>dept</code> defined in <a href="#i1025801">Example 18-25</a>. To generate a hierarchical view of the data, that is, departments with their employees, <a href="#i1025801">Example 18-25</a> defines suitable object types to create the structure inside the database.</p>
<div id="ADXDB5056" class="example">
<p class="titleinexample"><a id="i1025801"></a>Example 18-25 DBMS_XMLGEN: Generating XML using User-Defined Data-Type Instances<a id="sthref1248"></a></p>
<pre>
CREATE TABLE dept (deptno NUMBER PRIMARY KEY, dname VARCHAR2(20));
CREATE TABLE emp (empno   NUMBER PRIMARY KEY, ename VARCHAR2(20), 
                  deptno  NUMBER REFERENCES dept);
</pre>
<pre>
-- empno is preceded by an at-sign (@) to indicate that it must 
-- be mapped as an attribute of the enclosing Employee element. 
CREATE TYPE emp_t AS OBJECT ("@empno" NUMBER,  -- empno defined as attribute
                              ename   VARCHAR2(20));
/
INSERT INTO DEPT VALUES (10, 'Sports');
INSERT INTO DEPT VALUES(20, 'Accounting');
INSERT INTO EMP VALUES(200, 'John',  10);
INSERT INTO EMP VALUES(300, 'Jack',  10);
INSERT INTO EMP VALUES(400, 'Mary',  20);
INSERT INTO EMP VALUES(500, 'Jerry', 20);
COMMIT;
CREATE TYPE emplist_t AS TABLE OF emp_t;
/
CREATE TYPE dept_t AS OBJECT("@deptno" NUMBER, 
                             dname     VARCHAR2(20),
                             emplist   emplist_t);
/
-- Department type dept_t contains a list of employees.
-- You can now query the employee and department tables and get 
-- the result as an XML document, as follows:
CREATE TABLE temp_clob_tab (result CLOB);
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  RESULT CLOB;
BEGIN
  -- get query context
  qryCtx := DBMS_XMLGEN.newContext(
    'SELECT <span class="bold">dept_t</span>(deptno,
                   dname,
                   <span class="bold">cast</span>(<span class="bold">MULTISET</span>
                        (SELECT empno, ename FROM emp e WHERE e.deptno = d.deptno)
                        AS <span class="bold">emplist_t</span>))
       AS deptxml
       FROM dept d');
  -- set maximum number of rows to 5
  DBMS_XMLGEN.setMaxRows(qryCtx, 5);
  -- set no row tag for this result, since there is a single ADT column
  DBMS_XMLGEN.<span class="bold">setRowTag</span>(qryCtx, <span class="bold">NULL</span>);
  LOOP 
    -- get result
    result := DBMS_XMLGEN.getXML(qryCtx);
    -- if there were no rows processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
    -- do something with the result
    INSERT INTO temp_clob_tab VALUES (result);
  END LOOP;
END;
/
</pre>
<p>The <code>MULTISET</code> keyword for Oracle SQL function <code>cast</code> treats the employees working in the department as a list, which <code>cast</code> assigns to the appropriate collection type. A department instance is created using constructor <code>dept_t</code>, and <code>DBMS_XMLGEN</code> routines create the XML data for the object instance.</p>
<pre>
SELECT * FROM temp_clob_tab;

RESULT
---------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;DEPTXML deptno="10"&gt;
  &lt;DNAME&gt;Sports&lt;/DNAME&gt;
  &lt;EMPLIST&gt;
   &lt;EMP_T empno="200"&gt;
    &lt;ENAME&gt;John&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
   &lt;EMP_T empno="300"&gt;
    &lt;ENAME&gt;Jack&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
  &lt;/EMPLIST&gt;
 &lt;/DEPTXML&gt;
 &lt;DEPTXML deptno="20"&gt;
  &lt;DNAME&gt;Accounting&lt;/DNAME&gt;
  &lt;EMPLIST&gt;
   &lt;EMP_T empno="400"&gt;
    &lt;ENAME&gt;Mary&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
   &lt;EMP_T empno="500"&gt;
    &lt;ENAME&gt;Jerry&lt;/ENAME&gt;
   &lt;/EMP_T&gt;
  &lt;/EMPLIST&gt;
 &lt;/DEPTXML&gt;
&lt;/ROWSET&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>The default name <code>ROW</code> is not present because it was set to <code>NULL</code>. The <code>deptno</code> and <code>empno</code> have become attributes of the enclosing element.</p>
<p><a href="#i1032455">Example 18-26</a> uses <code>DBMS_XMLGEN.getXMLType</code> to generate a purchase order document in XML format using object views.</p>
<div id="ADXDB5057" class="example">
<p class="titleinexample"><a id="i1032455"></a>Example 18-26 DBMS_XMLGEN: Generating an XML Purchase Order</p>
<pre>
-- Create relational schema and define object views
-- DBMS_XMLGEN maps user-defined data-type attribute names that start
--    with an at-sign (@) to XML attributes
 
-- Purchase Order Object View Model
 
-- PhoneList varray object type
CREATE TYPE phonelist_vartyp AS VARRAY(10) OF VARCHAR2(20)
/
-- Address object type
CREATE TYPE address_typ AS OBJECT(Street VARCHAR2(200),
                                  City   VARCHAR2(200),
                                  State  CHAR(2),
                                  Zip    VARCHAR2(20))
/
-- Customer object type
CREATE TYPE customer_typ AS OBJECT(CustNo    NUMBER,
                                   CustName  VARCHAR2(200),
                                   Address   address_typ,
                                   PhoneList phonelist_vartyp)
/
-- StockItem object type
CREATE TYPE stockitem_typ AS OBJECT("@StockNo" NUMBER,
                                    Price      NUMBER,
                                    TaxRate    NUMBER)
/
-- LineItems object type
CREATE TYPE lineitem_typ AS OBJECT("@LineItemNo" NUMBER,
                                   Item          stockitem_typ,
                                   Quantity      NUMBER,
                                   Discount      NUMBER)
/
-- LineItems ordered collection table
CREATE TYPE lineitems_ntabtyp AS TABLE OF lineitem_typ 
/
-- Purchase Order object type
CREATE TYPE po_typ AUTHID CURRENT_USER
  AS OBJECT(PONO            NUMBER,
            Cust_ref        REF customer_typ,
            OrderDate       DATE,
            ShipDate        TIMESTAMP,
            LineItems_ntab  lineitems_ntabtyp,
            ShipToAddr      address_typ)
/
-- Create Purchase Order relational model tables
-- Customer table
CREATE TABLE customer_tab (CustNo     NUMBER NOT NULL,
                           CustName   VARCHAR2(200),
                           Street     VARCHAR2(200),
                           City       VARCHAR2(200),
                           State      CHAR(2),
                           Zip        VARCHAR2(20),
                           Phone1     VARCHAR2(20),
                           Phone2     VARCHAR2(20),
                           Phone3     VARCHAR2(20),
                           CONSTRAINT cust_pk PRIMARY KEY (CustNo));
-- Purchase Order table
CREATE TABLE po_tab (PONo       NUMBER,        /* purchase order number */
                     Custno     NUMBER     /*  foreign KEY referencing customer */
                                CONSTRAINT po_cust_fk REFERENCES customer_tab, 
                     OrderDate  DATE,          /*  date of order */  
                     ShipDate   TIMESTAMP,     /* date to be shipped */    
                     ToStreet   VARCHAR2(200), /* shipto address */    
                     ToCity     VARCHAR2(200),    
                     ToState    CHAR(2),    
                     ToZip      VARCHAR2(20),
                     CONSTRAINT po_pk PRIMARY KEY(PONo));    
--Stock Table
CREATE TABLE stock_tab (StockNo NUMBER CONSTRAINT stock_uk UNIQUE,
                        Price   NUMBER,
                        TaxRate NUMBER);
--Line Items table
CREATE TABLE lineitems_tab (LineItemNo NUMBER,
                            PONo       NUMBER
                                       CONSTRAINT li_po_fk REFERENCES po_tab,
                            StockNo    NUMBER,
                            Quantity   NUMBER,
                            Discount   NUMBER,
                            CONSTRAINT li_pk PRIMARY KEY (PONo, LineItemNo));
-- Create Object views
-- Customer Object View
CREATE OR REPLACE VIEW customer OF customer_typ
  WITH OBJECT IDENTIFIER(CustNo)
  AS SELECT c.custno, c.custname,
            address_typ(c.street, c.city, c.state, c.zip),
            phonelist_vartyp(phone1, phone2, phone3)
       FROM customer_tab c;
--Purchase order view
CREATE OR REPLACE VIEW po OF po_typ
  WITH OBJECT IDENTIFIER (PONo)
  AS SELECT p.pono, make_ref(Customer, P.Custno), p.orderdate, p.shipdate,
            cast(MULTISET
                 (SELECT lineitem_typ(l.lineitemno,
                                      stockitem_typ(l.stockno, s.price,
                                                    s.taxrate),
                                      l.quantity, l.discount)
                    FROM lineitems_tab l, stock_tab s
                    WHERE l.pono = p.pono AND s.stockno=l.stockno)
                 AS lineitems_ntabtyp),
            address_typ(p.tostreet,p.tocity, p.tostate, p.tozip)
       FROM po_tab p;
-- Create table with XMLType column to store purchase order in XML format
CREATE TABLE po_xml_tab (poid  NUMBER, podoc XMLType)
/
-- Populate data
-------------------
-- Establish Inventory
INSERT INTO stock_tab VALUES(1004, 6750.00, 2);
INSERT INTO stock_tab VALUES(1011, 4500.23, 2);
INSERT INTO stock_tab VALUES(1534, 2234.00, 2);
INSERT INTO stock_tab VALUES(1535, 3456.23, 2);
-- Register Customers
INSERT INTO customer_tab
  VALUES (1, 'Jean Nance', '2 Avocet Drive',
          'Redwood Shores', 'CA', '95054',
          '415-555-1212', NULL, NULL);
INSERT INTO customer_tab
  VALUES (2, 'John Nike', '323 College Drive',
          'Edison', 'NJ', '08820',
          '609-555-1212', '201-555-1212', NULL);
-- Place orders
INSERT INTO po_tab
  VALUES (1001, 1, '10-APR-1997', '10-MAY-1997',
          NULL, NULL, NULL, NULL);
INSERT INTO po_tab
  VALUES (2001, 2, '20-APR-1997', '20-MAY-1997',
          '55 Madison Ave', 'Madison', 'WI', '53715');
-- Detail line items
INSERT INTO lineitems_tab VALUES(01, 1001, 1534, 12,  0);
INSERT INTO lineitems_tab VALUES(02, 1001, 1535, 10, 10);
INSERT INTO lineitems_tab VALUES(01, 2001, 1004,  1,  0);
INSERT INTO lineitems_tab VALUES(02, 2001, 1011,  2,  1);
 
-- Use package DBMS_XMLGEN to generate purchase order in XML format
--   and store XMLType in table po_xml 
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  pxml XMLType;
  cxml CLOB;
BEGIN
  -- get query context;
  qryCtx := DBMS_XMLGEN.newContext('SELECT pono,deref(cust_ref) customer,
                                           p.orderdate,
                                           p.shipdate,
                                           lineitems_ntab lineitems,
                                           shiptoaddr
                                      FROM po p');
  -- set maximum number of rows to be 1,
  DBMS_XMLGEN.setMaxRows(qryCtx, 1);
  -- set ROWSET tag to NULL and ROW tag to PurchaseOrder
  DBMS_XMLGEN.<span class="bold">setRowSetTag</span>(qryCtx, <span class="bold">NULL</span>);
  DBMS_XMLGEN.<span class="bold">setRowTag</span>(qryCtx, '<span class="bold">PurchaseOrder</span>');
  LOOP 
    -- get purchase order in XML format
    pxml := DBMS_XMLGEN.getXMLType(qryCtx);
    -- if there were no rows processed, then quit
    EXIT WHEN DBMS_XMLGEN.getNumRowsProcessed(qryCtx) = 0;
    -- Store XMLType po in po_xml table (get the pono out)
    INSERT INTO po_xml_tab(poid, poDoc)
      VALUES(XMLCast(XMLQuery('//PONO/text()' PASSING pxml RETURNING CONTENT)
                     AS NUMBER),
             pxml);
  END LOOP;
END;
/
</pre>
<p>This query then produces two XML purchase-order documents:</p>
<pre>
SELECT XMLSerialize(DOCUMENT x.podoc AS CLOB) xpo FROM po_xml_tab x;

XPO
---------------------------------------------------
 &lt;PurchaseOrder&gt;
  &lt;PONO&gt;1001&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;1&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;Jean Nance&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;2 Avocet Drive&lt;/STREET&gt;
    &lt;CITY&gt;Redwood Shores&lt;/CITY&gt;
    &lt;STATE&gt;CA&lt;/STATE&gt;
    &lt;ZIP&gt;95054&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;415-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;10-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;10-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo="1"&gt;
    &lt;ITEM StockNo="1534"&gt;
     &lt;PRICE&gt;2234&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;12&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo="2"&gt;
    &lt;ITEM StockNo="1535"&gt;
     &lt;PRICE&gt;3456.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;10&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;10&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR/&gt;
 &lt;/PurchaseOrder&gt;
 
 &lt;PurchaseOrder&gt;
  &lt;PONO&gt;2001&lt;/PONO&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTNO&gt;2&lt;/CUSTNO&gt;
   &lt;CUSTNAME&gt;John Nike&lt;/CUSTNAME&gt;
   &lt;ADDRESS&gt;
    &lt;STREET&gt;323 College Drive&lt;/STREET&gt;
    &lt;CITY&gt;Edison&lt;/CITY&gt;
    &lt;STATE&gt;NJ&lt;/STATE&gt;
    &lt;ZIP&gt;08820&lt;/ZIP&gt;
   &lt;/ADDRESS&gt;
   &lt;PHONELIST&gt;
    &lt;VARCHAR2&gt;609-555-1212&lt;/VARCHAR2&gt;
    &lt;VARCHAR2&gt;201-555-1212&lt;/VARCHAR2&gt;
   &lt;/PHONELIST&gt;
  &lt;/CUSTOMER&gt;
  &lt;ORDERDATE&gt;20-APR-97&lt;/ORDERDATE&gt;
  &lt;SHIPDATE&gt;20-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
  &lt;LINEITEMS&gt;
   &lt;LINEITEM_TYP LineItemNo="1"&gt;
    &lt;ITEM StockNo="1004"&gt;
     &lt;PRICE&gt;6750&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;1&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
   &lt;LINEITEM_TYP LineItemNo="2"&gt;
    &lt;ITEM StockNo="1011"&gt;
     &lt;PRICE&gt;4500.23&lt;/PRICE&gt;
     &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
    &lt;/ITEM&gt;
    &lt;QUANTITY&gt;2&lt;/QUANTITY&gt;
    &lt;DISCOUNT&gt;1&lt;/DISCOUNT&gt;
   &lt;/LINEITEM_TYP&gt;
  &lt;/LINEITEMS&gt;
  &lt;SHIPTOADDR&gt;
   &lt;STREET&gt;55 Madison Ave&lt;/STREET&gt;
   &lt;CITY&gt;Madison&lt;/CITY&gt;
   &lt;STATE&gt;WI&lt;/STATE&gt;
   &lt;ZIP&gt;53715&lt;/ZIP&gt;
  &lt;/SHIPTOADDR&gt;
 &lt;/PurchaseOrder&gt;
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CHEEGHEC">Example 18-27</a> shows how to open a cursor variable for a query and use that cursor variable to create a new context handle for <code>DBMS_XMLGEN</code>.</p>
<div id="ADXDB5058" class="example">
<p class="titleinexample"><a id="CHEEGHEC"></a>Example 18-27 DBMS_XMLGEN: Generating a New Context Handle from a REF Cursor</p>
<pre>
CREATE TABLE emp_tab (emp_id       NUMBER PRIMARY KEY,
                      name         VARCHAR2(20),
                      dept_id      NUMBER);
Table created.
INSERT INTO emp_tab VALUES (122, 'Scott',  301);
1 row created.
INSERT INTO emp_tab VALUES (123, 'Mary',   472);
1 row created.
INSERT INTO emp_tab VALUES (124, 'John',   93);
1 row created.
INSERT INTO emp_tab VALUES (125, 'Howard', 488);
1 row created.
INSERT INTO emp_tab VALUES (126, 'Sue',    16);
1 row created.
COMMIT;
 
DECLARE
  ctx     NUMBER;
  maxrow  NUMBER;
  xmldoc  CLOB;
  refcur  SYS_REFCURSOR;
BEGIN
  DBMS_LOB.createtemporary(xmldoc, TRUE);
  maxrow := 3;
  OPEN refcur FOR 'SELECT * FROM emp_tab WHERE ROWNUM &lt;= :1' USING maxrow;
  ctx := DBMS_XMLGEN.newContext(refcur);
   -- xmldoc will have 3 rows
  DBMS_XMLGEN.getXML(ctx, xmldoc, DBMS_XMLGEN.NONE);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_LOB.freetemporary(xmldoc);
  CLOSE refcur;
  DBMS_XMLGEN.closeContext(ctx);
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;122&lt;/EMP_ID&gt;
  &lt;NAME&gt;Scott&lt;/NAME&gt;
  &lt;DEPT_ID&gt;301&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;123&lt;/EMP_ID&gt;
  &lt;NAME&gt;Mary&lt;/NAME&gt;
  &lt;DEPT_ID&gt;472&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMP_ID&gt;124&lt;/EMP_ID&gt;
  &lt;NAME&gt;John&lt;/NAME&gt;
  &lt;DEPT_ID&gt;93&lt;/DEPT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01312" href="../../appdev.112/e25519/cursor_variable.htm#LNPLS01312"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about cursor variables (<code>REF CURSOR</code>)</div>
<p><a href="#CHEHDBFI">Example 18-28</a> shows how to specify <code>NULL</code> handling when using <code>DBMS_XMLGEN</code>.</p>
<div id="ADXDB5059" class="example">
<p class="titleinexample"><a id="CHEHDBFI"></a>Example 18-28 DBMS_XMLGEN: Specifying NULL Handling</p>
<pre>
CREATE TABLE emp_tab (emp_id       NUMBER PRIMARY KEY,
                      name         VARCHAR2(20),
                      dept_id      NUMBER);
Table created.
INSERT INTO emp_tab VALUES (30, 'Scott', NULL);
1 row created.
INSERT INTO emp_tab VALUES (31, 'Mary', NULL);
1 row created.
INSERT INTO emp_tab VALUES (40, 'John', NULL);
1 row created.
COMMIT;
CREATE TABLE temp_clob_tab (result CLOB);
Table created.
 
DECLARE
  qryCtx DBMS_XMLGEN.ctxHandle;
  result CLOB;
BEGIN
  qryCtx := DBMS_XMLGEN.newContext('SELECT * FROM emp_tab where name = :NAME');
  -- Set the row header to be EMPLOYEE
  DBMS_XMLGEN.setRowTag(qryCtx, 'EMPLOYEE');
  -- Drop nulls
  DBMS_XMLGEN.setBindValue(qryCtx, 'NAME', 'Scott');
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.DROP_NULLS);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  -- Null attribute
  DBMS_XMLGEN.setBindValue(qryCtx, 'NAME', 'Mary');
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.NULL_ATTR);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  -- Empty tag
  DBMS_XMLGEN.setBindValue(qryCtx, 'NAME', 'John');
  DBMS_XMLGEN.setNullHandling(qryCtx, DBMS_XMLGEN.EMPTY_TAG);
  result := DBMS_XMLGEN.getXML(qryCtx);
  INSERT INTO temp_clob_tab VALUES(result);
  --Close context
  DBMS_XMLGEN.closeContext(qryCtx);
END;
/
 
PL/SQL procedure successfully completed.
 
SELECT * FROM temp_clob_tab;
 
RESULT
-------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;30&lt;/EMP_ID&gt;
  &lt;NAME&gt;Scott&lt;/NAME&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET xmlns:xsi = "http://www.w3.org/2001/XMLSchema-instance"&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;31&lt;/EMP_ID&gt;
  &lt;NAME&gt;Mary&lt;/NAME&gt;
  &lt;DEPT_ID xsi:nil = "true"/&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;EMPLOYEE&gt;
  &lt;EMP_ID&gt;40&lt;/EMP_ID&gt;
  &lt;NAME&gt;John&lt;/NAME&gt;
  &lt;DEPT_ID/&gt;
 &lt;/EMPLOYEE&gt;
&lt;/ROWSET&gt;
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p>Function <code>DBMS_XMLGEN.newContextFromHierarchy</code> takes as argument a hierarchical query string, which is typically formulated with a <code>CONNECT BY</code> clause. It returns a context that can be used to generate a hierarchical XML document with recursive elements.</p>
<p>The hierarchical query returns two columns, the level number (a pseudocolumn generated by <code>CONNECT BY</code> query) and an <code>XMLType</code>. The level is used to determine the position of the <code>XMLType</code> value within the hierarchy of the result XML document.</p>
<p>It is an error to set the skip number of rows or the maximum number of rows for a context created using <code>newContextFromHierarchy</code>.</p>
<p><a href="#CHECHBFE">Example 18-29</a> uses <code>DBMS_ XMLGEN.newContextFromHierarchy</code> to generate a manager&ndash;employee hierarchy.</p>
<div id="ADXDB5060" class="example">
<p class="titleinexample"><a id="CHECHBFE"></a>Example 18-29 DBMS_XMLGEN: Generating Recursive XML with a Hierarchical Query</p>
<pre>
CREATE TABLE sqlx_display (id NUMBER, xmldoc XMLType);
Table created.

DECLARE
  qryctx DBMS_XMLGEN.ctxhandle;
  result XMLType;
BEGIN
  qryctx := 
    DBMS_XMLGEN.<span class="bold">newContextFromHierarchy</span>(
      'SELECT level, 
              XMLElement("employees", 
                         XMLElement("enumber", employee_id),
                         XMLElement("name", last_name),
                         XMLElement("Salary", salary),
                         XMLElement("Hiredate", hire_date))
         FROM hr.employees
         START WITH last_name=''De Haan'' CONNECT BY PRIOR employee_id=manager_id
         ORDER SIBLINGS BY hire_date');
  result := DBMS_XMLGEN.getxmltype(qryctx);
  DBMS_OUTPUT.put_line('<span class="bold">&lt;result num rows&gt;</span>');
  DBMS_OUTPUT.put_line(<span class="bold">to_char(DBMS_XMLGEN.getNumRowsProcessed(qryctx))</span>);
  DBMS_OUTPUT.put_line('<span class="bold">&lt;/result num rows&gt;</span>');
  INSERT INTO sqlx_display VALUES (2, result);
  COMMIT;
  DBMS_XMLGEN.closecontext(qryctx);
END;
/
<span class="bold">&lt;result num rows&gt;</span>
<span class="bold">6</span>
<span class="bold">&lt;/result num rows&gt;</span>
PL/SQL procedure successfully completed.

SELECT xmldoc FROM sqlx_display WHERE id = 2;

XMLDOC
-----------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;employees&gt;
  &lt;enumber&gt;102&lt;/enumber&gt;
  &lt;name&gt;De Haan&lt;/name&gt;
  &lt;Salary&gt;17000&lt;/Salary&gt;
  &lt;Hiredate&gt;2001-01-13&lt;/Hiredate&gt;
  &lt;employees&gt;
    &lt;enumber&gt;103&lt;/enumber&gt;
    &lt;name&gt;Hunold&lt;/name&gt;
    &lt;Salary&gt;9000&lt;/Salary&gt;
    &lt;Hiredate&gt;2006-01-03&lt;/Hiredate&gt;
    &lt;employees&gt;
      &lt;enumber&gt;105&lt;/enumber&gt;
      &lt;name&gt;Austin&lt;/name&gt;
      &lt;Salary&gt;4800&lt;/Salary&gt;
      &lt;Hiredate&gt;2005-06-25&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;106&lt;/enumber&gt;
      &lt;name&gt;Pataballa&lt;/name&gt;
      &lt;Salary&gt;4800&lt;/Salary&gt;
      &lt;Hiredate&gt;2006-02-05&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;107&lt;/enumber&gt;
      &lt;name&gt;Lorentz&lt;/name&gt;
      &lt;Salary&gt;4200&lt;/Salary&gt;
      &lt;Hiredate&gt;2007-02-07&lt;/Hiredate&gt;
    &lt;/employees&gt;
    &lt;employees&gt;
      &lt;enumber&gt;104&lt;/enumber&gt;
      &lt;name&gt;Ernst&lt;/name&gt;
      &lt;Salary&gt;6000&lt;/Salary&gt;
      &lt;Hiredate&gt;2007-05-21&lt;/Hiredate&gt;
    &lt;/employees&gt;
  &lt;/employees&gt;
&lt;/employees&gt;

1 row selected.
</pre>
<p>By default, the <code>ROWSET</code> tag is <code>NULL</code>: there is no default <code>ROWSET</code> tag used to enclose the XML result. However, you can explicitly set the <code>ROWSET</code> tag by using procedure <code>setRowSetTag</code>, as follows:</p>
<pre>
CREATE TABLE gg (x XMLType);
Table created.

DECLARE
  qryctx DBMS_XMLGEN.ctxhandle;
  result CLOB;
BEGIN
  qryctx := DBMS_XMLGEN.newContextFromHierarchy(
              'SELECT level,
                      XMLElement("NAME", last_name) AS myname FROM hr.employees
               CONNECT BY PRIOR employee_id=manager_id
               START WITH employee_id = 102');
  DBMS_XMLGEN.<span class="bold">setRowSetTag</span>(qryctx, '<span class="bold">mynum_hierarchy</span>');
  result:=DBMS_XMLGEN.getxml(qryctx);
  DBMS_OUTPUT.put_line('&lt;result num rows&gt;');
  DBMS_OUTPUT.put_line(to_char(DBMS_XMLGEN.getNumRowsProcessed(qryctx)));
  DBMS_OUTPUT.put_line('&lt;/result num rows&gt;');
  INSERT INTO gg VALUES(XMLType(result));
  COMMIT;
  DBMS_XMLGEN.closecontext(qryctx);
END;
/
&lt;result num rows&gt;
6
&lt;/result num rows&gt;
PL/SQL procedure successfully completed.

SELECT * FROM gg;
 
X
----------------------------------------------------------
&lt;?xml version="1.0"?&gt;
<span class="bold">&lt;mynum_hierarchy&gt;</span>
  &lt;NAME&gt;De Haan
    &lt;NAME&gt;Hunold
      &lt;NAME&gt;Ernst&lt;/NAME&gt;
      &lt;NAME&gt;Austin&lt;/NAME&gt;
      &lt;NAME&gt;Pataballa&lt;/NAME&gt;
      &lt;NAME&gt;Lorentz&lt;/NAME&gt;
    &lt;/NAME&gt;
  &lt;/NAME&gt;
<span class="bold">&lt;/mynum_hierarchy&gt;</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>If the query string used to create a context contains host variables, you can use PL/SQL method <code>setBindValue()</code> to give the variables values before query execution. <a href="#CHEHABDH">Example 18-30</a> illustrates this.</p>
<div id="ADXDB5061" class="example">
<p class="titleinexample"><a id="CHEHABDH"></a>Example 18-30 DBMS_XMLGEN: Binding Query Variables using SETBINDVALUE()</p>
<pre>
-- <span class="bold">Bind one variable</span>
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext(
           'SELECT * FROM employees WHERE employee_id = <span class="bold">:NO</span>');
  DBMS_XMLGEN.<span class="bold">setBindValue</span>(ctx, '<span class="bold">NO</span>', '<span class="bold">145</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;<span class="bold">145</span>&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;01-OCT-04&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
PL/SQL procedure successfully completed.

-- <span class="bold">Bind one variable twice with different values</span>
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext('SELECT * FROM employees
                                   WHERE hire_date = <span class="bold">:MDATE</span>');
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">MDATE</span>', '<span class="bold">01-OCT-04</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">MDATE</span>', '<span class="bold">10-MAR-05</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;145&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">01-OCT-04</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;147&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Alberto&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Errazuriz&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;AERRAZUR&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429278&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">10-MAR-05</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;12000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.3&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;159&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;Lindsey&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Smith&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;LSMITH&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1345.729268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">10-MAR-97</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_REP&lt;/JOB_ID&gt;
  &lt;SALARY&gt;8000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.3&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;146&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
PL/SQL procedure successfully completed.
-- <span class="bold">Bind two variables</span> 
DECLARE
  ctx NUMBER;
  xmldoc CLOB;
BEGIN
  ctx := DBMS_XMLGEN.newContext('SELECT * FROM employees
                                   WHERE employee_id = <span class="bold">:NO</span>
                                     AND hire_date = <span class="bold">:MDATE</span>');
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">NO</span>', '<span class="bold">145</span>');
  DBMS_XMLGEN.setBindValue(ctx, '<span class="bold">MDATE</span>', '<span class="bold">01-OCT-04</span>');
  xmldoc := DBMS_XMLGEN.getXML(ctx);
  DBMS_OUTPUT.put_line(xmldoc);
  DBMS_XMLGEN.closeContext(ctx);
EXCEPTION
  WHEN OTHERS THEN DBMS_XMLGEN.closeContext(ctx);
  RAISE;
END;
/
&lt;?xml version="1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW&gt;
  &lt;EMPLOYEE_ID&gt;<span class="bold">145</span>&lt;/EMPLOYEE_ID&gt;
  &lt;FIRST_NAME&gt;John&lt;/FIRST_NAME&gt;
  &lt;LAST_NAME&gt;Russell&lt;/LAST_NAME&gt;
  &lt;EMAIL&gt;JRUSSEL&lt;/EMAIL&gt;
  &lt;PHONE_NUMBER&gt;011.44.1344.429268&lt;/PHONE_NUMBER&gt;
  &lt;HIRE_DATE&gt;<span class="bold">01-OCT-04</span>&lt;/HIRE_DATE&gt;
  &lt;JOB_ID&gt;SA_MAN&lt;/JOB_ID&gt;
  &lt;SALARY&gt;14000&lt;/SALARY&gt;
  &lt;COMMISSION_PCT&gt;.4&lt;/COMMISSION_PCT&gt;
  &lt;MANAGER_ID&gt;100&lt;/MANAGER_ID&gt;
  &lt;DEPARTMENT_ID&gt;80&lt;/DEPARTMENT_ID&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1026349"></a>
<div id="ADXDB5062" class="sect1">
<h2 class="sect1">SYS_XMLGEN Oracle SQL Function<a id="sthref1249"></a><a id="sthref1250"></a><a id="sthref1251"></a></h2>
<p>Oracle SQL function <code>sys_XMLGen</code> is similar to standard SQL/XML function <code>XMLElement</code>, but it takes a single argument and it converts the result to an <code>XMLType</code> instance. Unlike the other XML generation functions, <code>sys_XMLGen</code> always returns a well-formed XML <span class="italic">document</span>. Unlike package <code>DBMS_XMLGEN</code>, which operates at a query level, <code>sys_XMLGen</code> operates at the row level, returning an XML <span class="italic">document for each row</span>.</p>
<p><a href="#CHEEEEJC">Example 18-31</a> uses <code>sys_XMLGen</code> to query XML instances, returning an XML document for each row of relational data.</p>
<div id="ADXDB5063" class="example">
<p class="titleinexample"><a id="CHEEEEJC"></a>Example 18-31 Creating XML Data using SYS_XMLGEN</p>
<pre>
SELECT sys_XMLGen(employee_id) AS "result"
  FROM employees WHERE first_name LIKE 'John%';
</pre>
<p>The resulting XML documents are as follows:</p>
<pre>
result
---------------
&lt;?xml version="1.0"?&gt;
&lt;EMPLOYEE_ID&gt;110&lt;/EMPLOYEE_ID&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;EMPLOYEE_ID&gt;139&lt;/EMPLOYEE_ID&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;EMPLOYEE_ID&gt;145&lt;/EMPLOYEE_ID&gt;
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<p class="subhead1"><a id="ADXDB5064"></a>SYS_XMLGEN Syntax</p>
<p>Oracle SQL function <code>sys_XMLGen</code> takes as argument a scalar value, object type, or <code>XMLType</code> instance to be converted to an XML document. It also takes an optional <code>XMLFormat</code> object (previously called <code>XMLGenFormatType)</code>, which you can use to specify formatting options for the resulting XML document. The syntax is shown in <a href="#i1031142">Figure 18-14</a>.</p>
<div id="ADXDB5065" class="figure">
<p class="titleinfigure"><a id="i1031142"></a>Figure 18-14 SYS_XMLGEN Syntax</p>
<img width="346" height="46" src="img/sys_xmlgen.gif" alt="Description of Figure 18-14 follows" /><br />
<a id="sthref1252" href="img_text/sys_xmlgen.htm">Description of "Figure 18-14 SYS_XMLGEN Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Expression <code><span class="codeinlineitalic">expr</span></code> evaluates to a particular row and column of the database. It can be a scalar value, a user-defined data-type instance, or an <code>XMLType</code> instance.</p>
<ul>
<li>
<p>If <code><span class="codeinlineitalic">expr</span></code> evaluates to a scalar value, then the function returns an XML element containing the scalar value.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">expr</span></code> evaluates to a user-defined data-type instance, then the function maps the user-defined data-type attributes to XML elements.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">expr</span></code> evaluates to an <code>XMLType</code> instance, then the function encloses the document in an XML element whose default tag name is <code>ROW</code>.</p>
</li>
</ul>
<p>By default, the elements of the XML document match <code><span class="codeinlineitalic">expr</span></code>. For example, if <code><span class="codeinlineitalic">expr</span></code> resolves to a column name, then the enclosing XML element has the same name as the column. If you want to format the XML document differently, then specify <code><span class="codeinlineitalic">fmt</span></code>, which is an instance of the <code>XMLFormat</code> object.</p>
<p>You can use a <code>WHERE</code> clause in a query to suppress <code>&lt;ROW/&gt;</code> tags with <code>sys_XMLGen</code>, if you do not want <code>NULL</code> values represented:</p>
<pre>
SELECT sys_XMLGen(x) FROM table_name WHERE x IS NOT NULL;
</pre>
<p><a href="#CHEFEBDA">Example 18-32</a> retrieves the employee first name from table <code>HR.employees</code>, where the <code>employee_id</code> value is <code>110</code>, and it generates an <code>XMLType</code> instance containing an XML document with an <code>FIRST_NAME</code> element.</p>
<div id="ADXDB5066" class="example">
<p class="titleinexample"><a id="CHEFEBDA"></a>Example 18-32 SYS_XMLGEN: Generating an XML Element from a Database Column</p>
<pre>
SELECT XMLSerialize(DOCUMENT SYS_XMLGEN(<span class="bold">first_name</span>))
  FROM employees WHERE employee_id = 110;

XMLSERIALIZE(DOCUMENTSYS_XMLGEN(FIRST_NAME))
--------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;<span class="bold">FIRST_NAME</span>&gt;John&lt;/<span class="bold">FIRST_NAME</span>&gt;

1 row selected.
</pre></div>
<!-- class="example" -->
<div id="ADXDB6005" class="sect2"><a id="sthref1253"></a>
<h3 class="sect2">Advantages of using Oracle SQL Function SYS_XMLGEN</h3>
<p>Oracle SQL function <code>sys_XMLGen</code> has the following advantages:</p>
<ul>
<li>
<p>You can create and query XML instances <span class="italic">within</span> SQL queries.</p>
</li>
<li>
<p>Using the object-relational infrastructure, you can create complex and nested XML instances from simple relational tables. For example, when you use an <code>XMLType</code> view that uses <code>sys_XMLGen</code> on top of an object type, Oracle XML&nbsp;DB rewrites these queries when possible. See also <a href="xdb_rewrite.htm#BABHJECG">Chapter 8, "XPath Rewrite for Structured Storage"</a>.</p>
</li>
</ul>
<p><code>sys_XMLGen</code> creates an XML document from a user-defined data-type instance, a scalar value, or an <code>XMLType</code> instance. It returns an <code>XMLType</code> instance.</p>
<p><code>sys_XMLGen</code> also accepts an optional <code>XMLFormat</code> object as argument, which you can use to customize the result. A <code>NULL</code> format object implies that the default mapping action is to be used.</p>
</div>
<!-- class="sect2" -->
<a id="i1032810"></a>
<div id="ADXDB5068" class="sect2">
<h3 class="sect2"><a id="sthref1254"></a><a id="sthref1255"></a>Using XML<a id="sthref1256"></a>Format Object Type</h3>
<p>You can use the <code>XMLFormat</code> object to specify formatting arguments for Oracle SQL functions <code>sys_XMLGen</code> and <code>sys_XMLAgg</code>.</p>
<p>Function <code>sys_XMLGen</code> returns an <code>XMLType</code> instance containing an XML document. Oracle Database provides the <code>XMLFormat</code> object to format the output of <code>sys_XMLGen</code>.</p>
<p><a href="#g1033914">Table 18-2</a> lists the <a id="sthref1257"></a><a id="sthref1258"></a>attributes of object <code>XMLFormat</code>.</p>
<div id="ADXDB5069" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref1259"></a><a id="g1033914"></a>Table 18-2 Attributes of the XMLFormat Object</p>
<table class="cellalignment1032" title="Attributes of the XMLFormat Object" summary="This table describes the attributes of the XMLFormat object for formatting SYS_XMLGEN." dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t15">Attribute</th>
<th class="cellalignment1027" id="r1c2-t15">Data Type</th>
<th class="cellalignment1027" id="r1c3-t15">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t15" headers="r1c1-t15">
<p><code>enclTag</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t15 r1c2-t15">
<p><code>VARCHAR2(100)</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t15 r1c3-t15">
<p>The name of the enclosing tag for the result of the <code>sys_XMLGen</code> function. If the input to the function is a column name, then the column name is used as the default value. Otherwise, the default value is <code>ROWSET</code>. When <code>schemaType</code> is set to <code>USE_GIVEN_SCHEMA</code>, this attribute also provides the name of the XML schema element.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t15" headers="r1c1-t15">
<p><code>schemaType</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t15 r1c2-t15">
<p><code>VARCHAR2(100)</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t15 r1c3-t15">
<p>The type of schema generation for the output document. Valid values are '<code>NO_SCHEMA</code>' and '<code>USE_GIVEN_SCHEMA</code>'. The default value is '<code>NO_SCHEMA</code>'.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t15" headers="r1c1-t15">
<p><code>schemaName</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t15 r1c2-t15">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t15 r1c3-t15">
<p>The name of the target schema used if <code>schemaType</code> is '<code>USE_GIVEN_SCHEMA</code>'. If you specify <code>schemaName</code>, then the enclosing tag is used as the element name.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t15" headers="r1c1-t15">
<p><code>targetNameSpace</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t15 r1c2-t15">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t15 r1c3-t15">
<p>The target namespace if the schema is specified (that is, <code>schemaType</code> is <code>GEN_SCHEMA_</code>*, or <code>USE_GIVEN_SCHEMA</code>)</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t15" headers="r1c1-t15">
<p><code>dburl</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t15 r1c2-t15">
<p><code>VARCHAR2(2000)</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t15 r1c3-t15">
<p>The URL to the database to be used if <code>WITH_SCHEMA</code> is specified. If this attribute is not specified, then a relative URL reference is used for the URL to the types.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t15" headers="r1c1-t15">
<p><code>processingIns</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t15 r1c2-t15">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t15 r1c3-t15">
<p>User-provided processing instructions. They are appended to the top of the function output, before the element.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>You can use PL/SQL method <code>createFormat()</code> to implement the <code>XMLFormat</code> object. Method <code>createFormat()</code> of object <code>XMLFormat</code> accepts as arguments the enclosing element name, the XML schema type, and the XML schema name. Default values are provided for the other <code>XMLFormat</code> attributes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDHAJCG">Example 18-35</a> for an example of using <code>createFormat</code> to name the root element that is output by <code>sys_XMLGen</code></p>
</li>
<li>
<p><a class="olink SQLRF06123" href="../../server.112/e41084/functions190.htm#SQLRF06123"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code>sys_XMLGen</code> and the <code>XMLFormat</code> object</p>
</li>
</ul>
</div>
<p>Oracle SQL function <code>sys_XMLGen</code> converts a scalar value to an element that contains the scalar value. The query in <a href="#i1026449">Example 18-33</a> illustrates this. It returns an XML document that contains the <code>employee_id</code> value as the content of element <code>EMPLOYEE_ID</code>.</p>
<div id="ADXDB5070" class="example">
<p class="titleinexample"><a id="i1026449"></a>Example 18-33 SYS_XMLGEN: Converting a <a id="sthref1260"></a>Scalar Value to XML Element Contents</p>
<pre>
SELECT sys_XMLGen(employee_id) FROM hr.employees WHERE ROWNUM &lt; 2;
 
SYS_XMLGEN(EMPLOYEE_ID)
---------------------------
&lt;?xml version="1.0"?&gt;
&lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>The enclosing element name, in this case <code>EMPLOYEE_ID</code>, is derived from the column name passed to <code>sys_XMLGen</code>. The query result is a single row containing an <code>XMLType</code> instance that corresponds to a complete XML document.</p>
<p>In <a href="#i1026449">Example 18-33</a>, the column name <code>EMPLOYEE_ID</code> is used by default for the XML element name. If the column name cannot be derived directly, then the default name <code>ROW</code> is used instead, as shown in <a href="#CHEJBDBC">Example 18-34</a>.</p>
<div id="ADXDB5071" class="example">
<p class="titleinexample"><a id="CHEJBDBC"></a>Example 18-34 SYS_XMLGEN: Default Element Name ROW</p>
<pre>
SELECT sys_XMLGen(employee_id<span class="bold">*2</span>) FROM hr.employees WHERE ROWNUM &lt; 2;
 
SYS_XMLGEN(EMPLOYEE_ID*2)
-------------------------
&lt;?xml version="1.0"?&gt;
&lt;<span class="bold">ROW</span>&gt;200&lt;/<span class="bold">ROW</span>&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHEJBDBC">Example 18-34</a>, the argument to <code>sys_XMLGen</code> is not a simple column name, so the name of the output element tag cannot be a column name &ndash; the default element name, <code>ROW</code>, is used.</p>
<p>You can override the default <code>ROW</code> tag by supplying an <code>XMLFormat</code> object as the second <code>sys_XMLGen</code> argument. <a href="#CHDHAJCG">Example 18-35</a> illustrates this: the query passes a formatting argument to <code>sys_XMLGen</code>, to name the element explicitly.</p>
<div id="ADXDB5072" class="example">
<p class="titleinexample"><a id="CHDHAJCG"></a>Example 18-35 Overriding the Default Element Name using SYS_XMLGEN with XMLFormat</p>
<pre>
SELECT XMLSerialize(DOCUMENT
                    SYS_XMLGEN(employee_id*2,
                               XMLFormat.createformat('<span class="bold">DOUBLE_ID</span>'))
                    AS CLOB)
 FROM hr.employees WHERE ROWNUM &lt; 2;
 
XMLSERIALIZE(DOCUMENTSYS_XMLGEN(EMPLOYEE_ID*2,XMLFORMAT.CREATEFORMAT('DOUBLE_ID'
--------------------------------------------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;<span class="bold">DOUBLE_ID</span>&gt;200&lt;/<span class="bold">DOUBLE_ID</span>&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>When you provide a user-defined data-type instance as an argument to <code>sys_XMLGen</code>, the instance is canonically mapped to an XML document. In this mapping, the user-defined data-type attributes are mapped to XML elements.</p>
<p>Any data-type attributes with names that start with an at sign (<code>@</code>) are mapped to attributes of the preceding XML element. User-defined data-type instances can be used to obtain nesting in the resulting XML document.</p>
<p><a href="#CHEHAECD">Example 18-36</a> shows how to generate hierarchical XML for the employee-and-department example of section <a href="#i1025386">"Generating XML using DBMS_XMLGEN"</a>.</p>
<div id="ADXDB5073" class="example">
<p class="titleinexample"><a id="CHEHAECD"></a>Example 18-36 SYS_XMLGEN: Converting a User-Defined Data-Type Instance to XML</p>
<pre>
CREATE OR REPLACE TYPE hr.emp_t AS OBJECT(empno    NUMBER(6),
                                          ename    VARCHAR2(25),
                                          job      VARCHAR2(10),
                                          mgr      NUMBER(6),
                                          hiredate DATE,
                                          sal      NUMBER(8,2),
                                          comm     NUMBER(2,2));
/
Type created.
CREATE OR REPLACE TYPE hr.emplist_t AS TABLE OF emp_t;
/
Type created.
CREATE OR REPLACE TYPE hr.dept_t AS OBJECT(deptno  NUMBER(4),
                                           dname   VARCHAR2(30),
                                           loc     VARCHAR2(4),
                                           emplist emplist_t);
/
Type created.
 
SELECT XMLSerialize(
         DOCUMENT
         SYS_XMLGEN(
           <span class="bold">dept_t</span>(department_id,
                  department_name,
                  d.location_id,
                  <span class="bold">cast</span>(<span class="bold">MULTISET</span>
                       (SELECT emp_t(e.employee_id, e.last_name,
                                     e.job_id, e.manager_id, e.hire_date,
                                     e.salary, e.commission_pct)
                          FROM hr.employees e
                          WHERE e.department_id = d.department_id)
                       AS <span class="bold">emplist_t</span>)))
         AS CLOB)
  AS deptxml
  FROM hr.departments d WHERE department_id = 10 OR department_id = 20;
</pre>
<p>The <code>MULTISET</code> keyword for Oracle SQL function <code>cast</code> treats the employees working in the department as a list, which <code>cast</code> assigns to the appropriate collection type. <code>sys_XMLGen</code> creates the XML data for the object instance.</p>
<p>The result is as follows. The default name <code>ROW</code> is present because the function cannot deduce the name of the input operand directly.</p>
<pre>
DEPTXML
-------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;ROW&gt;
 &lt;DEPTNO&gt;10&lt;/DEPTNO&gt;
 &lt;DNAME&gt;Administration&lt;/DNAME&gt;
 &lt;LOC&gt;1700&lt;/LOC&gt;
 &lt;EMPLIST&gt;
  &lt;EMP_T&gt;
   &lt;EMPNO&gt;200&lt;/EMPNO&gt;
   &lt;ENAME&gt;Whalen&lt;/ENAME&gt;
   &lt;JOB&gt;AD_ASST&lt;/JOB&gt;
   &lt;MGR&gt;101&lt;/MGR&gt;
   &lt;HIREDATE&gt;17-SEP-03&lt;/HIREDATE&gt;
   &lt;SAL&gt;4400&lt;/SAL&gt;
  &lt;/EMP_T&gt;
 &lt;/EMPLIST&gt;
&lt;/ROW&gt;
 
&lt;?xml version="1.0"?&gt;
&lt;ROW&gt;
 &lt;DEPTNO&gt;20&lt;/DEPTNO&gt;
 &lt;DNAME&gt;Marketing&lt;/DNAME&gt;
 &lt;LOC&gt;1800&lt;/LOC&gt;
 &lt;EMPLIST&gt;
  &lt;EMP_T&gt;
   &lt;EMPNO&gt;201&lt;/EMPNO&gt;
   &lt;ENAME&gt;Hartstein&lt;/ENAME&gt;
   &lt;JOB&gt;MK_MAN&lt;/JOB&gt;
   &lt;MGR&gt;100&lt;/MGR&gt;
   &lt;HIREDATE&gt;17-FEB-04&lt;/HIREDATE&gt;
   &lt;SAL&gt;13000&lt;/SAL&gt;
  &lt;/EMP_T&gt;
  &lt;EMP_T&gt;
   &lt;EMPNO&gt;202&lt;/EMPNO&gt;
   &lt;ENAME&gt;Fay&lt;/ENAME&gt;
   &lt;JOB&gt;MK_REP&lt;/JOB&gt;
   &lt;MGR&gt;201&lt;/MGR&gt;
   &lt;HIREDATE&gt;17-AUG-05&lt;/HIREDATE&gt;
   &lt;SAL&gt;6000&lt;/SAL&gt;
  &lt;/EMP_T&gt;
 &lt;/EMPLIST&gt;
&lt;/ROW&gt;
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The difference between using SQL function <code>sys_XMLGen</code> and PL/SQL package <code>DBMS_XMLGEN</code> is apparent from the preceding example. Function <code>sys_XMLGen</code> works inside SQL queries, and operates on the expressions and columns within the rows. Package <code>DBMS_XMLGEN</code> works on the entire result set.</div>
<p>If you pass an XML document to function <code>sys_XMLGen</code>, the function wraps the document (or fragment) with an element whose tag name is the default <code>ROW</code>, or the name passed in through the <code>XMLFormat</code> formatting object. This functionality can be used to turn XML fragments into well-formed documents. <a href="#i1031572">Example 18-37</a> illustrates this.</p>
<div id="ADXDB5074" class="example">
<p class="titleinexample"><a id="i1031572"></a>Example 18-37 <a id="sthref1261"></a>SYS_XMLGEN: Converting an XMLType Instance</p>
<pre>
CREATE TABLE po_xml_tab (podoc XMLType);
Table created.

INSERT INTO po_xml_tab VALUES (XMLType('&lt;DOCUMENT&gt;
                                          &lt;EMPLOYEE&gt;
                                            &lt;ENAME&gt;John&lt;/ENAME&gt;
                                            &lt;EMPNO&gt;200&lt;/EMPNO&gt;
                                          &lt;/EMPLOYEE&gt;
                                          &lt;EMPLOYEE&gt;
                                            &lt;ENAME&gt;Jack&lt;/ENAME&gt;
                                            &lt;EMPNO&gt;400&lt;/EMPNO&gt;
                                          &lt;/EMPLOYEE&gt;
                                          &lt;EMPLOYEE&gt;
                                            &lt;ENAME&gt;Joseph&lt;/ENAME&gt;
                                            &lt;EMPNO&gt;300&lt;/EMPNO&gt;
                                          &lt;/EMPLOYEE&gt;
                                        &lt;/DOCUMENT&gt;'));
1 row created.
COMMIT;
</pre>
<p>This query extracts <code>ENAME</code> elements:</p>
<pre>
SELECT XMLQuery('/DOCUMENT/EMPLOYEE/ENAME' PASSING e.podoc RETURNING CONTENT)
  FROM po_xml_tab e;
</pre>
<p>The query result is an XML document fragment (pretty-printed here for clarity):</p>
<pre>
&lt;ENAME&gt;John&lt;/ENAME&gt;
&lt;ENAME&gt;Jack&lt;/ENAME&gt;
&lt;ENAME&gt;Joseph&lt;/ENAME&gt;
</pre>
<p>You can make such a fragment into a valid XML document by calling <code>sys_XMLGen</code> to wrap a root element around the fragment, as follows:</p>
<pre>
SELECT XMLSerialize(DOCUMENT
                    <span class="bold">sys_XMLGen</span>(XMLQuery('/DOCUMENT/EMPLOYEE/ENAME'
                                        PASSING e.podoc RETURNING CONTENT))
                    AS CLOB)
  FROM po_xml_tab e;
</pre>
<p>This places a <code>ROW</code> element around the fragment, as follows (pretty-printed here for clarity):</p>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;ROW&gt;
  &lt;ENAME&gt;John&lt;/ENAME&gt;
  &lt;ENAME&gt;Jack&lt;/ENAME&gt;
  &lt;ENAME&gt;Joseph&lt;/ENAME&gt;
&lt;/ROW&gt;
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
If the input to <code>sys_XMLGen</code> is a column, then the column name is used as the default element name. You can override the element name using the <code>XMLFormat</code> formatting object as a second argument to <code>sys_XMLGen</code>. See <a href="#i1032810">"Using XMLFormat Object Type"</a>.</div>
<p><a href="#CHDJCBGG">Example 18-38</a> shows how to use <code>sys_XMLGen</code> with object views. (For any undefined entities here, refer to the code in <a href="#i1032455">Example 18-26</a>.)</p>
<div id="ADXDB5075" class="example">
<p class="titleinexample"><a id="CHDJCBGG"></a>Example 18-38 Using <a id="sthref1262"></a>SYS_XMLGEN with Object Views</p>
<pre>
-- Create purchase order object type
CREATE OR REPLACE TYPE po_typ AUTHID CURRENT_USER
  AS OBJECT(pono            NUMBER,
            customer        customer_typ,
            orderdate       DATE,
            shipdate        TIMESTAMP,
            lineitems_ntab  lineitems_ntabtyp,
            shiptoaddr      address_typ)
/
--Purchase order view
CREATE OR REPLACE VIEW po OF po_typ
  WITH OBJECT IDENTIFIER (PONO)
  AS SELECT p.pono, customer_typ(p.custno, c.custname, c.address, c.phonelist),
            p.orderdate, p.shipdate,
            cast(MULTISET
                 (SELECT lineitem_typ(l.lineitemno,
                                      stockitem_typ(l.stockno, s.price,
                                                    s.taxrate),
                                      l.quantity, l.discount)
                    FROM lineitems_tab l, stock_tab s
                    WHERE l.pono = p.pono AND s.stockno=l.stockno)
                 AS lineitems_ntabtyp),
            address_typ(p.tostreet, p.tocity, p.tostate, p.tozip)
       FROM po_tab p, customer c
       WHERE p.custno=c.custno;
 
-- Use sys_XMLGen to generate PO in XML format
SELECT XMLSerialize(DOCUMENT
                    SYS_XMLGEN(OBJECT_VALUE,
                               XMLFormat.createFormat('PurchaseOrder'))
                    AS CLOB) PO
  FROM po p WHERE p.pono=1001;
</pre>
<p>The query returns the purchase order in XML format:</p>
<pre>
PO
----------------------------------------------
&lt;?xml version="1.0"?&gt;
&lt;PurchaseOrder&gt;
 &lt;PONO&gt;1001&lt;/PONO&gt;
 &lt;CUSTOMER&gt;
  &lt;CUSTNO&gt;1&lt;/CUSTNO&gt;
  &lt;CUSTNAME&gt;Jean Nance&lt;/CUSTNAME&gt;
  &lt;ADDRESS&gt;
   &lt;STREET&gt;2 Avocet Drive&lt;/STREET&gt;
   &lt;CITY&gt;Redwood Shores&lt;/CITY&gt;
   &lt;STATE&gt;CA&lt;/STATE&gt;
   &lt;ZIP&gt;95054&lt;/ZIP&gt;
  &lt;/ADDRESS&gt;
  &lt;PHONELIST&gt;
   &lt;VARCHAR2&gt;415-555-1212&lt;/VARCHAR2&gt;
  &lt;/PHONELIST&gt;
 &lt;/CUSTOMER&gt;
 &lt;ORDERDATE&gt;10-APR-97&lt;/ORDERDATE&gt;
 &lt;SHIPDATE&gt;10-MAY-97 12.00.00.000000 AM&lt;/SHIPDATE&gt;
 &lt;LINEITEMS_NTAB&gt;
  &lt;LINEITEM_TYP LineItemNo="1"&gt;
   &lt;ITEM StockNo="1534"&gt;
    &lt;PRICE&gt;2234&lt;/PRICE&gt;
    &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
   &lt;/ITEM&gt;
   &lt;QUANTITY&gt;12&lt;/QUANTITY&gt;
   &lt;DISCOUNT&gt;0&lt;/DISCOUNT&gt;
  &lt;/LINEITEM_TYP&gt;
  &lt;LINEITEM_TYP LineItemNo="2"&gt;
   &lt;ITEM StockNo="1535"&gt;
    &lt;PRICE&gt;3456.23&lt;/PRICE&gt;
    &lt;TAXRATE&gt;2&lt;/TAXRATE&gt;
   &lt;/ITEM&gt;
   &lt;QUANTITY&gt;10&lt;/QUANTITY&gt;
   &lt;DISCOUNT&gt;10&lt;/DISCOUNT&gt;
  &lt;/LINEITEM_TYP&gt;
 &lt;/LINEITEMS_NTAB&gt;
 &lt;SHIPTOADDR/&gt;
&lt;/PurchaseOrder&gt;
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1031169"></a>
<div id="ADXDB5076" class="sect1">
<h2 class="sect1">SYS_XMLAGG<a id="sthref1263"></a><a id="sthref1264"></a><a id="sthref1265"></a> Oracle SQL Function</h2>
<p>Oracle SQL function <code>sys_XMLAgg</code> aggregates all XML documents or fragments represented by an expression, producing a single XML document from them. It wraps the results of the expression in a new element named <code>ROWSET</code> (by default).</p>
<p>Oracle function <code>sys_XMLAgg</code> is similar to standard SQL/XML function <code>XMLAgg</code>, but <code>sys_XMLAgg</code> returns a single node and it accepts an <code><a id="sthref1266"></a>XMLFormat</code> parameter. You can use that parameter to format the resulting XML document in various ways.</p>
<div id="ADXDB5077" class="figure">
<p class="titleinfigure"><a id="sthref1267"></a>Figure 18-15 SYS_XMLAGG Syntax</p>
<img width="348" height="46" src="img/sys_xmlagg.gif" alt="Description of Figure 18-15 follows" /><br />
<a id="sthref1268" href="img_text/sys_xmlagg.htm">Description of "Figure 18-15 SYS_XMLAGG Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect1" -->
<a id="BABJGBCH"></a>
<div id="ADXDB5083" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Guidelines for Generating XML with Oracle XML&nbsp;DB</h2>
<p>This section describes additional guidelines for generating XML using Oracle XML&nbsp;DB.</p>
<div id="ADXDB5084" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1269"></a>
<h3 class="sect2">Ordering Query Results Before Aggregating, using XMLAGG ORDER BY Clause</h3>
<p>To use the <code>XMLAgg ORDER BY</code> clause before aggregation, specify the <code>ORDER BY</code> clause following the first <code>XMLAGG</code> argument. This is illustrated in <a href="#CHEEJJDE">Example 18-39</a>.</p>
<div id="ADXDB5085" class="example">
<p class="titleinexample"><a id="CHEEJJDE"></a>Example 18-39 Using XMLAGG ORDER BY Clause</p>
<pre>
CREATE TABLE dev_tab (dev         NUMBER,
                      dev_total   NUMBER,
                      devname     VARCHAR2(20));
Table created.
INSERT INTO dev_tab VALUES (16, 5,  'Alexis');
1 row created.
INSERT INTO dev_tab VALUES (2,  14, 'Han');
1 row created.
INSERT INTO dev_tab VALUES (1,  2,  'Jess');
1 row created.
INSERT INTO dev_tab VALUES (9,  88, 'Kurt');
1 row created.
COMMIT;
</pre>
<p>The result of the following query is aggregated according to the order of the <code>dev</code> column. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
SELECT XMLAgg(XMLElement("Dev", 
                         XMLAttributes(dev AS "id", dev_total AS "total"),
                         devname) 
              ORDER BY dev) 
  FROM tab1 dev_total;

XMLAGG(XMLELEMENT("DEV",XMLATTRIBUTES(DEVAS"ID",DEV_TOTALAS"TOTAL"),DEVNAME)ORDE
--------------------------------------------------------------------------------
&lt;Dev id="<span class="bold">1</span>" total="2"&gt;Jess&lt;/Dev&gt;
&lt;Dev id="<span class="bold">2</span>" total="14"&gt;Han&lt;/Dev&gt;
&lt;Dev id="<span class="bold">9</span>" total="88"&gt;Kurt&lt;/Dev&gt;
&lt;Dev id="<span class="bold">16</span>" total="5"&gt;Alexis&lt;/Dev&gt;
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="ADXDB5086" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1270"></a>
<h3 class="sect2">Returning a Rowset using XMLTABLE</h3>
<p>You can use standard SQL/XML function <code>XMLTable</code> to return a rowset with relevant portions of a document extracted as multiple rows, as shown in <a href="#CHDGBFFC">Example 18-40</a>.</p>
<div id="ADXDB5087" class="example">
<p class="titleinexample"><a id="CHDGBFFC"></a>Example 18-40 Returning a Rowset using XMLTABLE</p>
<pre>
CONNECT oe
Enter password: <span class="italic">password</span>

Connected.

SELECT item.descr, item.partid
  FROM purchaseorder,
       XMLTable('$p/PurchaseOrder/LineItems/LineItem' PASSING OBJECT_VALUE
                COLUMNS descr  VARCHAR2(256) PATH 'Description',
                        partid VARCHAR2(14)  PATH 'Part/@Id') item
  WHERE item.partid = '715515012027'
     OR item.partid = '715515011921'
  ORDER BY partid;
</pre>
<p>This returns a rowset with just the descriptions and part IDs, ordered by part ID.</p>
<pre>
DESCR
--------------
PARTID
--------------
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921

My Man Godfrey
715515011921

My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
My Man Godfrey
715515011921
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
Mona Lisa
715515012027
 
16 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;The SQL/XML standard requires argument <code><span class="codeinlineitalic">data-type</span></code> to be present, but it is <span class="italic">optional</span> in the Oracle XML&nbsp;DB implementation of the standard, for ease of use.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="partpg4.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb14vie.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
