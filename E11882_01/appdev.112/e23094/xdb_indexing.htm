<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Indexing XMLType Data</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:13Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="xdb_xquery.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb05sto.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='xdb_indexing'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADXDB0500" class="chapter"><a id="CHDEADIH"></a>
<h1 class="chapter"><span class="secnum">6</span> Indexing XMLType Data</h1>
<p>You can create indexes on your XML data, to focus on particular parts of it that you query often and thus improve performance. This chapter includes guidelines for doing this. It describes various ways that you can index <code>XMLType</code> data, whether schema-based or non-schema-based, and regardless of the <code>XMLType</code> storage model you use (binary XML, unstructured, hybrid, or structured).</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CHDJECDA">Oracle XML&nbsp;DB Tasks Involving Indexes</a></p>
</li>
<li>
<p><a href="#CHDCGACG">Overview of Indexing XMLType Data</a></p>
</li>
<li>
<p><a href="#CHDCIEJB">Indexing XMLType Data Stored Object-Relationally</a></p>
</li>
<li>
<p><a href="#CHDFCGGI">XMLIndex</a></p>
</li>
<li>
<p><a href="#CHDDHECG">Oracle Text Indexes on XML Data</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The execution plans shown here are for illustration only. If you run the examples presented here in your environment then your execution plans might not be identical.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT811" href="../../server.112/e40540/indexiot.htm#CNCPT811"><span class="italic">Oracle Database Concepts</span></a> for an overview of indexing</p>
</li>
<li>
<p><a class="olink ADFNS005" href="../../appdev.112/e41502/adfns_indexes.htm#ADFNS005"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for information about using indexes in application development</p>
</li>
</ul>
</div>
<a id="CHDJECDA"></a>
<div id="ADXDB4308" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Oracle XML&nbsp;DB Tasks Involving Indexes</h2>
<p><a href="#BCGBDDDE">Table 6-1</a> identifies the documentation for some basic user tasks involving indexes for XML data.</p>
<div id="ADXDB5812" class="tblformalwide">
<p class="titleintable"><a id="sthref480"></a><a id="BCGBDDDE"></a>Table 6-1 Basic XML Indexing Tasks</p>
<table class="cellalignment1032" title="Basic XML Indexing Tasks" summary="Basic tasks involving indexing XML data" >
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t4">For information about how to...</th>
<th class="cellalignment1027" id="r1c2-t4">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t4" headers="r1c1-t4">
<p>Index <code>XMLType</code> data stored object-relationally</p>
</td>
<td class="cellalignment1028" headers="r2c1-t4 r1c2-t4">
<p><a href="#CHDCIEJB">"Indexing XMLType Data Stored Object-Relationally"</a>, <a href="xdb_rewrite.htm#CACHDCID">"Guideline: Create indexes on ordered collection tables"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t4" headers="r1c1-t4">
<p>Create, drop, or rename an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r3c1-t4 r1c2-t4">
<p><a href="#CHDCGJHC">Example 6-6</a>, <a href="#CHDFIGIB">Example 6-8</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td>&nbsp;</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t4" headers="r1c1-t4">
<p>Obtain the name of an <code>XMLIndex</code> index for a given table or column</p>
</td>
<td class="cellalignment1028" headers="r5c1-t4 r1c2-t4">
<p><a href="#CHDDGHDF">Example 6-7</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t4" headers="r1c1-t4">
<p>Determine whether a given <code>XMLIndex</code> index is used in evaluating a query</p>
</td>
<td class="cellalignment1028" headers="r6c1-t4 r1c2-t4">
<p><a href="#CHDGIAIE">"How to Tell Whether XMLIndex is Used"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t4" headers="r1c1-t4">
<p>Turn off use of an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r7c1-t4 r1c2-t4">
<p><a href="#CHDBBAGA">"Turning Off Use of XMLIndex"</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a href="#BCGDECIA">Table 6-2</a> identifies the documentation for some user tasks involving <code>XMLIndex</code> indexes that have a <span class="italic">structured</span> component.</p>
<div id="ADXDB5813" class="tblformalwide">
<p class="titleintable"><a id="sthref481"></a><a id="BCGDECIA"></a>Table 6-2 Tasks Involving XMLIndex Indexes with a Structured Component</p>
<table class="cellalignment1032" title="Tasks Involving XMLIndex Indexes with a Structured Component" summary="Tasks involving XMLIndex indexes with a structured component" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t5">For information about how to...</th>
<th class="cellalignment1027" id="r1c2-t5">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t5" headers="r1c1-t5">
<p>Create an <code>XMLIndex</code> index with a structured component</p>
</td>
<td class="cellalignment1028" headers="r2c1-t5 r1c2-t5">
<p><a href="#BCGJCEAF">Example 6-20</a>, <a href="#BCGDDBDI">Example 6-24</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t5" headers="r1c1-t5">
<p>Drop the structured component of an <code>XMLIndex</code> index (drop all structure groups)</p>
</td>
<td class="cellalignment1028" headers="r3c1-t5 r1c2-t5">
<p><a href="#BCGJGJAD">Example 6-21</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t5" headers="r1c1-t5">
<p>Ensure data type correspondence between a query and an <code>XMLIndex</code> index with a structured component</p>
</td>
<td class="cellalignment1028" headers="r4c1-t5 r1c2-t5">
<p><a href="#BCGJDFCE">"Data Type Considerations for XMLIndex Structured Component"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t5" headers="r1c1-t5">
<p>Create a B-tree index on a content table of an <code>XMLIndex</code> structured component</p>
</td>
<td class="cellalignment1028" headers="r5c1-t5 r1c2-t5">
<p><a href="#BCGEGABJ">Example 6-22</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t5" headers="r1c1-t5">
<p>Create an Oracle Text <code>CONTEXT</code> index on a content table of an <code>XMLIndex</code> structured component</p>
</td>
<td class="cellalignment1028" headers="r6c1-t5 r1c2-t5">
<p><a href="#BCGDEHEA">Example 6-23</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a href="#BCGFHJJE">Table 6-3</a> identifies the documentation for some user tasks involving <code>XMLIndex</code> indexes that have an <span class="italic">unstructured</span> component.</p>
<div id="ADXDB5814" class="tblformalwide">
<p class="titleintable"><a id="sthref482"></a><a id="BCGFHJJE"></a>Table 6-3 Tasks Involving XMLIndex Indexes with an Unstructured Component</p>
<table class="cellalignment1032" title="Tasks Involving XMLIndex Indexes with an Unstructured Component" summary="Tasks involving XMLIndex indexes with an unstructured component" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t6">For information about how to...</th>
<th class="cellalignment1027" id="r1c2-t6">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t6" headers="r1c1-t6">
<p>Create an <code>XMLIndex</code> index with an unstructured component</p>
</td>
<td class="cellalignment1028" headers="r2c1-t6 r1c2-t6">
<p><a href="#CHDJCDCF">Example 6-9</a>, <a href="#CHDBIGIJ">Example 6-11</a>, <a href="#CHDIHICC">Example 6-31</a>, <a href="#CHDJEICC">Example 6-33</a>, <a href="#CHDGDGFA">Example 6-34</a>, <a href="#CHDFFICC">Example 6-35</a>, <a href="#CHDBCDJD">Example 6-36</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t6" headers="r1c1-t6">
<p>Drop the unstructured component of an <code>XMLIndex</code> index (drop the path table)</p>
</td>
<td class="cellalignment1028" headers="r3c1-t6 r1c2-t6">
<p><a href="#BCGHIIFB">Example 6-12</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t6" headers="r1c1-t6">
<p>Name the path table when creating an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r4c1-t6 r1c2-t6">
<p><a href="#CHDJCDCF">Example 6-9</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t6" headers="r1c1-t6">
<p>Specify storage options when creating an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r5c1-t6 r1c2-t6">
<p><a href="#CHDBIGIJ">Example 6-11</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t6" headers="r1c1-t6">
<p>Show all existing secondary indexes on an <code>XMLIndex</code> path table</p>
</td>
<td class="cellalignment1028" headers="r6c1-t6 r1c2-t6">
<p><a href="#CHDJHFGG">Example 6-13</a>, <a href="#CHDJACJG">Example 6-19</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t6" headers="r1c1-t6">
<p>Obtain the name of a path table for an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r7c1-t6 r1c2-t6">
<p><a href="#CHDBCCHJ">Example 6-10</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t6" headers="r1c1-t6">
<p>Obtain the name of an <code>XMLIndex</code> index with an unstructured component, given its path table</p>
</td>
<td class="cellalignment1028" headers="r8c1-t6 r1c2-t6">
<p><a href="#CHDBCJIG">Example 6-26</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t6" headers="r1c1-t6">
<p>Create a secondary index on an <code>XMLIndex</code> path table</p>
</td>
<td class="cellalignment1028" headers="r9c1-t6 r1c2-t6">
<p><a href="#CHDGDAJF">"Using XMLIndex with an Unstructured Component"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t6" headers="r1c1-t6">
<p>Obtain information about all of the secondary indexes on an <code>XMLIndex</code> path table</p>
</td>
<td class="cellalignment1028" headers="r10c1-t6 r1c2-t6">
<p><a href="#CHDJACJG">Example 6-19</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t6" headers="r1c1-t6">
<p>Create a function-based index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment1028" headers="r11c1-t6 r1c2-t6">
<p><a href="#CHDGADGI">Example 6-14</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t6" headers="r1c1-t6">
<p>Create a numeric index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment1028" headers="r12c1-t6 r1c2-t6">
<p><a href="#CHDFHBBJ">Example 6-16</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r13c1-t6" headers="r1c1-t6">
<p>Create a date index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment1028" headers="r13c1-t6 r1c2-t6">
<p><a href="#CHDBABFD">Example 6-17</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r14c1-t6" headers="r1c1-t6">
<p>Create an Oracle Text <code>CONTEXT</code> index on a path-table <code>VALUE</code> column</p>
</td>
<td class="cellalignment1028" headers="r14c1-t6 r1c2-t6">
<p><a href="#CHDJEHFC">Example 6-18</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r15c1-t6" headers="r1c1-t6">
<p>Exclude or include particular XPath expressions from use by an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r15c1-t6 r1c2-t6">
<p><a href="#CHDCJIJB">"XMLIndex Path Subsetting: Specifying the Paths You Want to Index"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r16c1-t6" headers="r1c1-t6">
<p>Specify namespace prefixes for XPath expressions used for <code>XMLIndex</code></p>
</td>
<td class="cellalignment1028" headers="r16c1-t6 r1c2-t6">
<p><a href="#CHDCJIJB">"XMLIndex Path Subsetting: Specifying the Paths You Want to Index"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r17c1-t6" headers="r1c1-t6">
<p>Exclude or include particular XPath expressions from use by an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r17c1-t6 r1c2-t6">
<p><a href="#CHDCJIJB">"XMLIndex Path Subsetting: Specifying the Paths You Want to Index"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r18c1-t6" headers="r1c1-t6">
<p>Specify namespace prefixes for XPath expressions used for <code>XMLIndex</code></p>
</td>
<td class="cellalignment1028" headers="r18c1-t6 r1c2-t6">
<p><a href="#CHDCJIJB">"XMLIndex Path Subsetting: Specifying the Paths You Want to Index"</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a href="#BCGDFDFE">Table 6-4</a> identifies the documentation for some other user tasks involving <code>XMLIndex</code> indexes.</p>
<div id="ADXDB5815" class="tblformalwide">
<p class="titleintable"><a id="sthref483"></a><a id="BCGDFDFE"></a>Table 6-4 Miscellaneous Tasks Involving XMLIndex Indexes</p>
<table class="cellalignment1032" title="Miscellaneous Tasks Involving XMLIndex Indexes" summary="Miscellaneous tasks involving XMLIndex indexes" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t7">For information about how to...</th>
<th class="cellalignment1027" id="r1c2-t7">See...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td>&nbsp;</td>
</tr>
<tr class="cellalignment1020">
<td>&nbsp;</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t7" headers="r1c1-t7">
<p>Specify that an <code>XMLIndex</code> index should be created and maintained using parallel processes</p>
</td>
<td class="cellalignment1028" headers="r4c1-t7 r1c2-t7">
<p><a href="#CHDBBCEF">"XMLIndex Partitioning and Parallelism"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t7" headers="r1c1-t7">
<p>Change the parallelism of an <code>XMLIndex</code> path table to tune index performance</p>
</td>
<td class="cellalignment1028" headers="r5c1-t7 r1c2-t7">
<p><a href="#CHDBBCEF">"XMLIndex Partitioning and Parallelism"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t7" headers="r1c1-t7">
<p>Schedule maintenance for an <code>XMLIndex</code> index</p>
</td>
<td class="cellalignment1028" headers="r6c1-t7 r1c2-t7">
<p><a href="#CHDBCBHD">"Asynchronous (Deferred) Maintenance of XMLIndex Indexes"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t7" headers="r1c1-t7">
<p>Manually synchronize an <code>XMLIndex</code> index and its base table</p>
</td>
<td class="cellalignment1028" headers="r7c1-t7 r1c2-t7">
<p><a href="#CHDBCBHD">"Asynchronous (Deferred) Maintenance of XMLIndex Indexes"</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t7" headers="r1c1-t7">
<p>Collect statistics on a table or index for the cost-based optimizer</p>
</td>
<td class="cellalignment1028" headers="r8c1-t7 r1c2-t7">
<p><a href="#CHDEHFDF">Example 6-38</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t7" headers="r1c1-t7">
<p>Create an Oracle Text <code>CONTEXT</code> index</p>
</td>
<td class="cellalignment1028" headers="r9c1-t7 r1c2-t7">
<p><a href="#CHDIDGCD">Example 6-39</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t7" headers="r1c1-t7">
<p>Create an Oracle Text <code>CONTEXT</code> index on a content table of an <code>XMLIndex</code> structured component</p>
</td>
<td class="cellalignment1028" headers="r10c1-t7 r1c2-t7">
<p><a href="#BCGDEHEA">Example 6-23</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t7" headers="r1c1-t7">
<p>Use an Oracle Text <code>CONTEXT</code> index for full-text search of XML data</p>
</td>
<td class="cellalignment1028" headers="r11c1-t7 r1c2-t7">
<p><a href="#CHDIBBDC">Example 6-40</a></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t7" headers="r1c1-t7">
<p>Show whether an Oracle Text <code>CONTEXT</code> index is used in a query</p>
</td>
<td class="cellalignment1028" headers="r12c1-t7 r1c2-t7">
<p><a href="#CHDIBBDC">Example 6-40</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect1" -->
<a id="CHDCGACG"></a>
<div id="ADXDB4310" class="sect1">
<h2 class="sect1">Overview of Indexing <a id="sthref484"></a><a id="sthref485"></a>XMLType Data</h2>
<p>Database indexes improve performance by providing faster access to table data. The use of indexes is particularly recommended for online transaction processing (OLTP) environments involving few updates.</p>
<p>The principle way you index XML data is using <code>XMLIndex</code>. You can also use Oracle Text <code>CONTEXT</code> indexes to supplement the use of <code>XMLIndex</code>.</p>
<div id="ADXDB5816" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref486"></a>
<h3 class="sect2">XMLIndex Addresses the Fine-Grained Structure of XML Data</h3>
<p>You can create indexes on one or more table columns, or on a functional expression. XML data, however, has its own, fine-grained structure, which is not necessarily reflected in the structure of the database tables used to store it. For this reason, effectively indexing XML data can be a bit different from indexing most database data.</p>
<p>For structured XML storage, XML objects such as elements and attributes correspond to object-relational columns and tables, so creating <span class="italic">B-tree indexes</span> on those columns and tables provides an excellent way to effectively index the corresponding XML objects. Here, the storage model directly reflects the fine-grained structure of the XML data, so there is no special problem for indexing structured XML data. See <a href="#CHDCIEJB">"Indexing XMLType Data Stored Object-Relationally"</a>.</p>
<p>For unstructured, hybrid, and binary XML storage models, indexing a database column using the standard sorts of index (B-tree, bitmap) is generally not helpful for accessing particular parts of an XML document. If an <code>XMLType</code> column that contains an XML document is stored as a <code>CLOB</code> instance, then the details within that document are inaccessible to the column index&thinsp;&mdash;&thinsp;the entire document acts as a single unit as far as the column index is concerned. In <span class="glossaryterm"><a id="sthref487"></a>hybrid storage</span>, part of an XML document is broken up and stored object-relationally (structured storage), but one or more XML fragments are stored as <code>CLOB</code> instances (unstructured storage). A typical use case here is mapping an XML-schema <code>complexType</code> or a complex element to <code>CLOB</code> storage, because the entire fragment is generally accessed as a unit. For standard indexes, it acts as a unit for indexing as well.</p>
<p><code><span class="codeinlineitalic">XMLIndex</span></code> provides a general, XML-specific index that indexes the internal structure of XML data. One of its main purposes is to overcome the indexing limitation presented by unstructured, hybrid, and binary XML storage.</p>
<ul>
<li>
<p>An <code>XMLIndex</code> index with an <span class="italic">unstructured component</span> indexes the XML <span class="italic">tags</span> of your document and identifies document fragments based on XPath expressions that target them. It can also index scalar node <span class="italic">values</span>, to provide quick lookup based on individual values or ranges of values. It also records document <span class="italic">hierarchy</span> information for each node it indexes: relations parent&ndash;child, ancestor&ndash;descendant, and sibling. This index component is particularly useful for queries that extract XML fragments from documents that have little or variable structure.</p>
</li>
<li>
<p>An <code>XMLIndex</code> index with a <span class="italic">structured component</span> indexes highly structured and predictable parts of XML data that is nevertheless for the most part unstructured. This index component is particularly useful for queries that project and use such islands of structured content.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDFCGGI">"XMLIndex"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB5817" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref488"></a>
<h3 class="sect2">Oracle Text Indexes</h3>
<p>Besides accessing XML nodes such as elements and attributes, it is sometimes important to provide fast access to particular passages of text within XML text nodes. This is the purpose of <span class="italic">Oracle Text indexes</span>: they index full-text strings. An Oracle Text <code>CONTEXT</code> index enables Oracle SQL function <code><a id="sthref489"></a><a id="sthref490"></a><a id="sthref491"></a><a id="sthref492"></a>contains</code> for full-text search over XML. With structured storage, XPath rewrite can often rewrite queries that use XPath function <code>ora:contains</code> to queries that use SQL function <code>contains</code>, so in those cases too an Oracle Text index can be employed.</p>
<p>Full-text indexing is particularly useful for <span class="italic">document-centric</span> applications, which often contain a mix of XML elements and text-node content. Full-text searching can often be made more powerful, more focused, by combining it with structural XML searching, that is, by restricting it to certain parts of an XML document, which are identified by using XPath expressions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDDHECG">"Oracle Text Indexes on XML Data"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB4319" class="sect2"><a id="sthref493"></a>
<h3 class="sect2">Optimization Chooses the Right Indexes to Use</h3>
<p>Which indexes are used when more than one might apply in a given case? Cost-based optimization determines the index or indexes to use, so that performance is maximized. Oracle Text indexes apply only to text, which, for XML data, means text nodes. Whenever text nodes are targeted and a corresponding Oracle Text index is defined, it is used. If other indexes are also appropriate in a particular context, then they can be used as well. However, just because an index is defined and it might appear applicable in a given situation does not mean that it will be used&thinsp;&mdash;&thinsp;it will not be used if the cost-based optimizer deems that its use is not cost-effective.</p>
</div>
<!-- class="sect2" -->
<a id="BCGCIAHF"></a>
<div id="ADXDB4315" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Deprecated Indexes for XML Data</h3>
<p>In releases prior to Oracle Database&nbsp;11<span class="italic">g</span> Release&nbsp;1 (11.1), <code>CTXXPath</code> indexes were sometimes appropriate for use with <code>XMLType</code> data. In releases prior to Oracle Database&nbsp;11<span class="italic">g</span> Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with <code>XMLType</code> data. These indexing methods are no longer recommended for use with <code>XMLType</code> data.</p>
<a id="BCGIDHFB"></a>
<div id="ADXDB4316" class="sect3">
<h4 class="sect3">Function-Based <a id="sthref494"></a><a id="sthref495"></a>Indexes</h4>
<p>In releases prior to Oracle Database&nbsp;11<span class="italic">g</span> Release&nbsp;2 (11.2), function-based indexes were sometimes appropriate for use with <code>XMLType</code> data when an XPath expression targeted a singleton node. Oracle recommends that you use the structured component of <code>XMLIndex</code> instead. Doing so obviates the overhead associated with maintenance operations on function-based indexes, and it increases the number of situations in which the optimizer can correctly select the index. No changes to existing DML statements are required as a result of this.</p>
<p>It continues to be the case that, for structured storage, defining an index for (deprecated) Oracle SQL function <code>extractValue</code> often leads, by XPath rewrite, to automatic creation of B-tree indexes on the underlying objects (instead of a function-based index on <code>extractValue</code>). The XPath target here must be a <span class="italic">singleton</span> element or attribute. A similar shortcut exists for <code>XMLCast</code> applied to <code>XMLQuery</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDCIEJB">"Indexing XMLType Data Stored Object-Relationally"</a></p>
</li>
<li>
<p><a href="#BCGCBDHH">"XMLIndex Structured Component"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADXDB4318" class="sect3"><a id="sthref496"></a>
<h4 class="sect3">CTXXPath Indexes</h4>
<p>Another type of index that is available for indexing XML data, <code>CTXXPath</code>, is <span class="italic">deprecated</span>, starting with Oracle Database&nbsp;11<span class="italic">g</span> Release 1 (11.1). It has been superseded by <code>XMLIndex</code>, and it is made available <span class="italic">only for use with older database releases</span>. It cannot help in extracting an XML fragment, and it acts only as a preliminary filter for equality predicates; after such filtering, XPath expressions are evaluated functionally (that is, without the benefit of XPath rewrite).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>CTXSYS.CTXXPath</code> indexing was deprecated in Oracle Database 11g Release 1 (11.1). The functionality that was provided by <code>CTXXPath</code> is now provided by <code>XMLIndex</code>.
<p>Oracle recommends that you replace <code>CTXXPath</code> indexes with <code>XMLIndex</code> indexes. The intention is that <code>CTXXPath</code> will no longer be supported in a future release of the database.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCIEJB"></a>
<div id="ADXDB4320" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Indexing XMLType Data Stored Object-Relationally</h2>
<p>You can effectively index XML data that is stored object-relationally (structured storage) by creating B-tree indexes on the underlying database columns that correspond to XML nodes.</p>
<p>If the data to be indexed is a <span class="italic">singleton</span>, that is, if it can occur only once in any XML instance document, then you can use a <span class="italic">shortcut</span> of ostensibly creating a function-based index, where the expression defining the index is a functional application, with an XPath-expression argument that targets the singleton data. A shortcut is defined for <code>XMLCast</code> applied to <code>XMLQuery</code>, and another shortcut is defined for (deprecated) Oracle SQL function <code>extractValue</code>.</p>
<p>In many cases, Oracle XML&nbsp;DB then automatically creates appropriate indexes on the underlying object-relational tables or columns; it does <span class="italic">not</span> create a function-based index on the targeted <code>XMLType</code> data as the <code>CREATE INDEX</code> statement would suggest.</p>
<p>In the case of the <code>extractValue</code> shortcut, the index created is a B-tree index. In the case of <code>XMLCast</code> applied to <code>XMLQuery</code>, the index created is a function-based index on the scalar value resulting from the functional expression. <a href="#CHDBHADG">"Indexing Non-Repeating text() Nodes or Attribute Values"</a> describes this.</p>
<p>If the data to be indexed is a <span class="italic">collection</span>, then you cannot use such a shortcut; you must create the B-tree indexes manually. <a href="#CHDGJBFI">"Indexing Repeating (Collection) Elements"</a> describes this.</p>
<a id="CHDBHADG"></a>
<div id="ADXDB4325" class="sect2">
<h3 class="sect2">Indexing Non-<a id="sthref497"></a>Repeating text() Nodes or Attribute Values</h3>
<p>Table <code>purchaseorder</code> in sample database schema <code>OE</code> is stored object-relationally. Each purchase-order document has a single <code>Reference</code> element; this element is a singleton. You can thus use a shortcut to create an index on the underlying object-relational data.</p>
<p><a href="#CHDBJCCI">Example 6-1</a> shows a <code>CREATE INDEX</code> statement that ostensibly tries to create a function-based index using <code>XMLCast</code> applied to <code>XMLQuery</code>, targeting the text content of element <code>Reference</code>. (The content of this element is only text, so targeting the element is the same as targeting its text node using node test <code>text()</code>.)</p>
<p><a href="#BCGFIDAE">Example 6-2</a> ostensibly tries to create a function-based index using (deprecated) Oracle SQL function <code>extractValue</code>, targeting the same data.</p>
<div id="ADXDB4326" class="example">
<p class="titleinexample"><a id="CHDBJCCI"></a>Example 6-1 CREATE INDEX using XMLCAST and XMLQUERY on a Singleton Element</p>
<pre>
CREATE INDEX po_reference_ix ON purchaseorder
  (XMLCast(XMLQuery ('$p/PurchaseOrder/Reference' PASSING po.OBJECT_VALUE AS "p"
                                                  RETURNING CONTENT)
              AS VARCHAR2(128)));
</pre></div>
<!-- class="example" -->
<div id="ADXDB5818" class="example">
<p class="titleinexample"><a id="BCGFIDAE"></a>Example 6-2 CREATE INDEX using EXTRACTVALUE on a Singleton Element</p>
<pre>
CREATE INDEX po_reference_ix ON purchaseorder
  (extractValue(OBJECT_VALUE, '/PurchaseOrder/Reference'));
</pre></div>
<!-- class="example" -->
<p>In reality, in both <a href="#CHDBJCCI">Example 6-1</a> and <a href="#BCGFIDAE">Example 6-2</a> no function-based index is created on the targeted <code>XMLType</code> data. Instead, Oracle XML&nbsp;DB rewrites the <code>CREATE INDEX</code> statements to create indexes on the underlying scalar data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb_rewrite.htm#CACDBHCJ">Example 8-4</a> and <a href="xdb_rewrite.htm#CACCAJDI">Example 8-5</a> for information about XPath rewrite as it applies to such <code>CREATE INDEX</code> statements</div>
<p>In some cases when you use either of these shortcuts, the <code>CREATE INDEX</code> statement is not able to create an index on the underlying scalar data as described, and it instead actually does create a function-based index on the referenced <code>XMLType</code> data. (This is so, even if the <span class="italic">value</span> of the index might be a scalar.)</p>
<p>If this happens, drop the index, and create instead an <code>XMLIndex</code> index with a structured component that targets the same XPath. As a general rule, Oracle recommends against using a function-based index on <code>XMLType</code> data.</p>
<p>This is an instance of a general rule for <code>XMLType</code> data, regardless of the storage method used: Use an <code>XMLIndex</code> with a structured component instead of a function-based index. This rule applies starting with Oracle Database&nbsp;11<span class="italic">g</span> Release&nbsp;2 (11.2). Respecting this rule obviates the overhead associated with maintenance operations on function-based indexes, and it can increase the number of situations in which the optimizer can correctly select the index.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGIDHFB">"Function-Based Indexes"</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDGJBFI"></a>
<div id="ADXDB4328" class="sect2">
<h3 class="sect2">Indexing Repeating (Collection) Elements</h3>
<p>In structured storage, a collection is stored as an ordered collection table (OCT) of an <code>XMLType</code> instance, which means that you can directly access its members. Because the structured storage model directly reflects the fine-grained structure of the XML data, you can create indexes that target individual collection members.</p>
<p>You must create such indexes manually. The special feature of automatically creating B-tree indexes when you ostensibly create a function-based index for (deprecated) Oracle SQL function <code>extractValue</code> does <span class="italic">not</span> apply to collections (the XPath expression passed to <code>extractValue</code> must target a singleton).</p>
<p>To create B-tree indexes for a collection, you must understand the structure of the SQL object that is used to manage the collection. Given this information, you can use conventional object-relational SQL code to created the indexes directly on the appropriate SQL-object attributes. Refer to <a href="xdb_rewrite.htm#CACHDCID">"Guideline: Create indexes on ordered collection tables"</a> for an example of how to do this.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFCGGI"></a>
<div id="ADXDB4332" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">XMLIndex</h2>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CHDDCBJD">Advantages of XMLIndex</a></p>
</li>
<li>
<p><a href="#BCGFDCIG">Structured and Unstructured XMLIndex Components</a></p>
</li>
<li>
<p><a href="#BCGCBDHH">XMLIndex Structured Component</a></p>
</li>
<li>
<p><a href="#CHDCJDAA">XMLIndex Unstructured Component</a></p>
</li>
<li>
<p><a href="#CHDEFFJD">Creating, Dropping, Altering, and Examining an XMLIndex Index</a></p>
</li>
<li>
<p><a href="#CHDGDAJF">Using XMLIndex with an Unstructured Component</a></p>
</li>
<li>
<p><a href="#BCGHGIGC">Using XMLIndex with a Structured Component</a></p>
</li>
<li>
<p><a href="#CHDGIAIE">How to Tell Whether XMLIndex is Used</a></p>
</li>
<li>
<p><a href="#CHDBBAGA">Turning Off Use of XMLIndex</a></p>
</li>
<li>
<p><a href="#CHDCJIJB">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</a></p>
</li>
<li>
<p><a href="#CHDDEBGF">Guidelines for Using XMLIndex with an Unstructured Component</a></p>
</li>
<li>
<p><a href="#CEGDAFIF">Guidelines for Using XMLIndex with a Structured Component</a></p>
</li>
<li>
<p><a href="#CHDBBCEF">XMLIndex Partitioning and Parallelism</a></p>
</li>
<li>
<p><a href="#CHDBCBHD">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</a></p>
</li>
<li>
<p><a href="#CHDCEIFC">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</a></p>
</li>
<li>
<p><a href="#CHDEJEGH">Data Dictionary Static Public Views Related to XMLIndex</a></p>
</li>
<li>
<p><a href="#CHDBGCCI">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</a></p>
</li>
</ul>
<p>B-tree indexes can be used advantageously with structured (object-relational) storage&thinsp;&mdash;&thinsp;they provide sharp focus by targeting the underlying objects directly. They are generally ineffective, however, in addressing the detailed structure (elements and attributes) of an XML document stored using binary XML or <code>CLOB</code> storage, or of an XML fragment stored in a <code>CLOB</code> instance embedded in object-relational storage. That is the special domain of <code>XMLIndex</code>: unstructured and hybrid storage.</p>
<p>One typical use case for <code>XMLIndex</code> is where you generally expect to access certain portions of a document in their entirety, so you pack those portions into one or more <code>CLOB</code> instances. You might nevertheless sometimes need to query within these document portions. <code>XMLIndex</code> can help here.</p>
<p>Another use case is where an XML schema contains <code>xsd:any</code> elements, for lack of any specific knowledge of the document structure and data types involved. The data corresponding to these elements is stored in <code>CLOB</code> instances, and <code>XMLIndex</code> can be used to speed access to it.</p>
<a id="CHDDCBJD"></a>
<div id="ADXDB4333" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Advantages of XMLIndex</h3>
<p><code>XMLIndex</code> is a <span class="italic">domain</span> index; it is designed specifically for the domain of XML data. It is a <span class="italic">logical</span> index. An <code>XMLIndex</code> index can be used for SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>.</p>
<p>XMLIndex presents the following advantages over other indexing methods:</p>
<ul>
<li>
<p>An <code>XMLIndex</code> index is effective in any part of a query; &thinsp;it is not limited to use in a <code>WHERE</code> clause. This is not the case for any of the other kinds of indexes you might use with XML data.</p>
</li>
<li>
<p>An <code>XMLIndex</code> index with an unstructured component can speed access to both <code>SELECT</code> list data and <code>FROM</code> list data, making it useful for XML <span class="italic">fragment</span> extraction, in particular. Function-based indexes and <code>CTXXPath</code> indexes, both of which are deprecated, cannot be used to extract document fragments.</p>
</li>
<li>
<p>You can use an <code>XMLIndex</code> index with either XML schema-based or non-schema-based data. You can use it with unstructured storage, hybrid storage, and binary XML storage. B-tree indexing is appropriate only for XML schema-based data that is stored object-relationally (structured storage); it is ineffective for XML schema-based data stored in a <code>CLOB</code> instance.</p>
</li>
<li>
<p>You can use an <code>XMLIndex</code> index for searches with XPath expressions that target <span class="italic">collections</span>, that is, nodes that occur multiple times within a document. This is not the case for function-based indexes.</p>
</li>
<li>
<p>You need no prior knowledge of the XPath expressions that might be used in queries. The unstructured component of an <code>XMLIndex</code> index can be completely general. This is not the case for function-based indexes.</p>
</li>
<li>
<p>If you have prior knowledge of the XPath expressions to be used in queries, then you can improve performance either by using a <span class="italic">structured</span> <code>XMLIndex</code> component that targets fixed, structured islands of data that are queried often.</p>
</li>
<li>
<p><code>XMLIndex</code> indexing&thinsp;&mdash;&thinsp;both index creation and index maintenance&thinsp;&mdash;&thinsp;can be carried out in parallel, using multiple database processes. This is not the case for function-based and <code>CTXXPATH</code> indexes, which are deprecated.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BCGFDCIG"></a>
<div id="ADXDB4336" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Structured and <a id="sthref498"></a><a id="sthref499"></a><a id="sthref500"></a><a id="sthref501"></a>Unstructured XMLIndex Components</h3>
<p><code>XMLIndex</code> is used to index XML data that is semi-structured<a id="sthref502" href="#sthref502" onclick='footdisplay(1,"In this book, \"structured\" and \"unstructured\" generally refer to \u003ccode\u003eXMLType\u003c/code\u003e storage options; they refer less often to the nature of your data. \"Hybrid\" refers to object-relational storage with some embedded \u003ccode\u003eCLOB\u003c/code\u003e storage. \"Semi-structured\" refers to XML content, regardless of storage. Unstructured storage is \u003ccode\u003eCLOB\u003c/code\u003e-based storage, and structured storage is object-relational storage.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a>, that is, data that generally has little or no fixed structure. It applies to data that is stored using binary XML or <code>CLOB</code>-based storage. This includes XML data stored in <code>CLOB</code> instances that are embedded in object-relational storage (hybrid storage).</p>
<p>Semi-structured XML data can sometimes nevertheless contain islands of predictable, structured data. An <code>XMLIndex</code> index can therefore have two components: a <span class="glossaryterm">structured component</span>, used to index such islands, and an <span class="glossaryterm">unstructured component</span>, used to index data that has little or variable structure.</p>
<p>A structured component can help with queries that project and use islands of structured content. An unstructured component can help with queries that extract XML fragments. Either component can be omitted from a given <code>XMLIndex</code> index.</p>
<p>Unlike a structured component, an unstructured component is general and relatively untargeted. Though you can restrict an unstructured component to apply only to certain XPath subsets, its path table indexes node content that can be of different scalar types, which can require you to create multiple secondary indexes on the <code>VALUE</code> column to deal with the different data types&thinsp;&mdash;&thinsp;see <a href="#BCGHHJEE">"Secondary Indexes on Column VALUE"</a>. Using an unstructured component alone can also lead to inefficiencies involving multiple probes and self-joins of its path table, for queries that project structured islands.</p>
<p>On the other hand, a structured component is not suited for queries that involve little structure or queries that extract XML fragments. Use a structured component to index structured islands of data; use an unstructured component to index data that has little structure.</p>
<p><a href="#BCGBEAEC">Figure 6-1</a> is the same as <a href="xdb01int.htm#CHDGBEFE">Figure 1-5</a> in <a href="xdb01int.htm#g1054540">Chapter 1</a>. The last row indicates the applicability of <code>XMLIndex</code> for different XML data use cases. It shows that <code>XMLIndex</code> is appropriate for semi-structured XML data, however it is stored (last three columns). And an <code>XMLIndex</code> index with a structured component is useful for document-centric data that contains structured islands (fourth column).</p>
<div id="ADXDB4337" class="figure">
<p class="titleinfigure"><a id="BCGBEAEC"></a>Figure 6-1 XML Use Cases and XML Indexing</p>
<img width="662" height="290" src="img/adxdb057.gif" alt="Description of Figure 6-1 follows" /><br />
<a id="sthref503" href="img_text/adxdb057.htm">Description of "Figure 6-1 XML Use Cases and XML Indexing"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGCBDHH">"XMLIndex Structured Component"</a></p>
</li>
<li>
<p><a href="#CHDCJDAA">"XMLIndex Unstructured Component"</a></p>
</li>
<li>
<p><a href="#CHDDCBJD">"Advantages of XMLIndex"</a> for a summary of the advantages provided by each <code>XMLIndex</code> component type</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BCGCBDHH"></a>
<div id="ADXDB4338" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLIndex Structured Component</h3>
<p>You create and use the structured component of an <code>XMLIndex</code> index for queries that project fixed, structured islands of XML content, even if the surrounding data is relatively unstructured.</p>
<p>A structured <code>XMLIndex</code> component organizes such islands in a relational format. In this it is similar to SQL/XML <span class="italic">function</span> <code>XMLTable</code>, and the syntax you use to define the structured component reflects this similarity. The relational tables used to store the indexing data are data-type aware, and each column can be of a different scalar data type.</p>
<p>You can thus think of the act of creating the structured component of an <code>XMLIndex</code> index as <span class="italic">decomposing</span> a structured portion of your XML data into relational format. This differs from the object-relational storage model of <code>XMLType</code> in these ways:</p>
<ul>
<li>
<p>A structured index component <span class="italic">explicitly</span> decomposes particular <span class="italic">portions</span> of your data, which you specify&thinsp;&mdash;&thinsp;portions that you commonly query. Object-relational <code>XMLType</code> storage involves automatic decomposition of an entire <code>XMLType</code> table or column.</p>
</li>
<li>
<p>The structured component of an <code>XMLIndex</code> index applies to both XML schema-based and non-schema-based data. Object-relational <code>XMLType</code> storage applies only to data that is based on an XML schema.</p>
</li>
<li>
<p>The decomposed data for a structured <code>XMLIndex</code> component is stored in addition to the <code>XMLType</code> data, as an index, rather than being the storage model for the <code>XMLType</code> data itself.</p>
</li>
<li>
<p>For a structured <code>XMLIndex</code> component, the same data can be projected multiple times, as columns of different data type.</p>
</li>
</ul>
<p>The index content tables used for the structured component of an <code>XMLIndex</code> index are part of the index, but because they are normal relational tables you can, in turn, <span class="italic">index</span> them using any standard relational indexes, including indexes that satisfy primary-key and foreign-key constraints. You can also index them using domain indexes, such as an Oracle Text <code>CONTEXT</code> index.</p>
<p>Another way to look at the structured component of an <code>XMLIndex</code> index sees that it acts as a <span class="italic">generalized function-based index</span>. A function-based index is similar to a structured <code>XMLIndex</code> component that has only one relational column.</p>
<p>If you find that for a particular application you are creating multiple function-based indexes, then consider using a structured <code>XMLIndex</code> index instead. Create also B-tree indexes on the columns of the structured index component.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Queries that use SQL/XML function <code>XMLTable</code> can typically be rewritten to use the relational indexing tables of an <code>XMLIndex</code> structured component. These tables also contain some internal, system-defined columns. These internal columns might change in the future, so do not write code that depends on any assumptions about their existence or contents.</p>
</li>
<li>
<p>Queries that use Oracle SQL function <code>XMLSequence</code> within a SQL <code>TABLE</code> collection expression, that is, <code>TABLE(XMLSequence(...))</code>, are <span class="italic">not</span> rewritten to use the indexing tables of an <code>XMLIndex</code> structured component. Oracle SQL function <code>XMLSequence</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2; use standard SQL/XML function <code>XMLTable</code> instead.</p>
<p>See <a class="olink SQLRF30047" href="../../server.112/e41084/statements_10002.htm#SQLRF30047"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the SQL <code>TABLE</code> collection expression.</p>
</li>
</ul>
</div>
<div id="ADXDB4339" class="sect3"><a id="sthref504"></a>
<h4 class="sect3">Ignore the Index Content Tables; They Are Transparent</h4>
<p>Although the index content tables of an <code>XMLIndex</code> structured component are normal relational tables, they are also <span class="italic">read-only</span>: you cannot add or drop their columns or modify (insert, update, or delete) their rows.</p>
<p>You can thus generally ignore the relational index content tables. You cannot access them, other than to <code>DESCRIBE</code> them and create (secondary) indexes on them. You need never explicitly gather statistics on them. You need only collect statistics on the <code>XMLIndex</code> index itself or the base table on which the <code>XMLIndex</code> index is defined; statistics are collected and maintained on the index content tables transparently.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDCEIFC">"Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer"</a></div>
</div>
<!-- class="sect3" -->
<a id="BCGJDFCE"></a>
<div id="ADXDB4340" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Data Type Considerations for XMLIndex Structured Component</h4>
<p>The relational tables that are used for an <code>XMLIndex</code> structured component use SQL data types. XQuery expressions that are used in queries use XML data types (XML Schema data types and XQuery data types).</p>
<p>XQuery typing rules can automatically change the data type of a subexpression, to ensure coherence and type-checking. For example, if a document that is queried using XPath expression <code>/PurchaseOrder/LineItem[@ItemNumber = 25]</code> is not XML schema-based, then the subexpression <code>@ItemNumber</code> is untyped, and it is then automatically cast to <code>xs:double</code> by the XQuery <code>=</code> comparison operator. To index this data using an <code>XMLIndex</code> structured component you must use <code>BINARY_DOUBLE</code> as the SQL data type.</p>
<p>This is a general rule. For an <code>XMLIndex</code> index with structured component to apply to a query, the data types must correspond. <a href="#BCGFIFFH">Table 6-5</a> shows the data-type correspondences.</p>
<div id="ADXDB4341" class="tblformal">
<p class="titleintable"><a id="sthref505"></a><a id="BCGFIFFH"></a>Table 6-5 XML and SQL Data Type Correspondence for XMLIndex</p>
<table class="cellalignment1026" title="XML and SQL Data Type Correspondence for XMLIndex" summary="XML and SQL data type correspondence for XMLIndex" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t17">XML Data Type</th>
<th class="cellalignment1027" id="r1c2-t17">SQL Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t17" headers="r1c1-t17">
<p><code>xs:decimal</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t17 r1c2-t17">
<p><code>INTEGER</code> or <code>NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t17" headers="r1c1-t17">
<p><code>xs:double</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t17 r1c2-t17">
<p><code>BINARY_DOUBLE</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t17" headers="r1c1-t17">
<p><code>xs:float</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t17 r1c2-t17">
<p><code>BINARY_FLOAT</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t17" headers="r1c1-t17">
<p><code>xs:date</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t17 r1c2-t17">
<p><code>DATE</code>, <code>TIMESTAMP WITH TIMEZONE</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t17" headers="r1c1-t17">
<p><code>xs:dateTime</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t17 r1c2-t17">
<p><code>TIMESTAMP</code>, <code>TIMESTAMP WITH TIMEZONE</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t17" headers="r1c1-t17">
<p><code>xs:dayTimeDuration</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t17 r1c2-t17">
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t17" headers="r1c1-t17">
<p><code>xs:yearMonthDuration</code></p>
</td>
<td class="cellalignment1028" headers="r8c1-t17 r1c2-t17">
<p><code>INTERVAL YEAR TO MONTH</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
If the XML data type is <code>xs:date</code> or <code>xs:dateTime</code>, and if you know that the data that you will query and for which you are creating an index will <span class="italic">not</span> contain a time-zone component, then you can increase performance by using SQL data type <code>DATE</code> or <code>TIMESTAMP</code>. If the data might contain a time-zone component, then you must use SQL data type <code>TIMESTAMP WITH TIMEZONE</code>.</div>
<p>If the XML and SQL data types involved do not have a built-in one-to-one correspondence, then you must make them correspond (according to <a href="#BCGFIFFH">Table 6-5</a>), in order for the index to be picked up for your query. There are two ways you can do this:</p>
<ul>
<li>
<p><span class="bold">Make the index correspond to the query &ndash;</span> Define (or redefine) the column in the structured index component, so that it corresponds to the XML data type. For example, if a query that you want to index uses the XML data type <code>xs:double</code>, then define the index to use the corresponding SQL data type, <code>BINARY_DOUBLE</code>.</p>
</li>
<li>
<p><span class="bold">Make the query correspond to the index &ndash;</span> In your query, explicitly cast the relevant parts of an XQuery expression to data types that correspond to the SQL data types used in the index content table.</p>
</li>
</ul>
<p><a href="#BCGBBEIB">Example 6-3</a> and <a href="#BCGIIDAA">Example 6-4</a> show how you can cast an XQuery expression in your query to match the SQL data type used in the index content table.</p>
<div id="ADXDB4342" class="example">
<p class="titleinexample"><a id="BCGBBEIB"></a>Example 6-3 Making Query Data Compatible with Index Data &ndash; SQL Cast</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE <span class="bold">XMLCast</span>(XMLQuery('$p/PurchaseOrder/LineItem/@ItemNumber'
                         PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
                <span class="bold">AS INTEGER</span>)
        = 25;
</pre></div>
<!-- class="example" -->
<div id="ADXDB4343" class="example">
<p class="titleinexample"><a id="BCGIIDAA"></a>Example 6-4 Making Query Data Compatible with Index Data &ndash; XQuery Cast</p>
<pre>
SELECT count(*) FROM purchaseorder
  WHERE XMLExists('$p/PurchaseOrder/LineItem[<span class="bold">xs:decimal</span>(@ItemNumber) = 25]'
                  PASSING OBJECT_VALUE AS "p");
</pre></div>
<!-- class="example" -->
<p>Notice that the number <code>25</code> plays a different role in these two examples, even though in both cases it is the purchase-order item number. In <a href="#BCGBBEIB">Example 6-3</a>, <code>25</code> is a SQL number of data type <code>INTEGER</code>; in <a href="#BCGIIDAA">Example 6-4</a>, <code>25</code> is an XQuery number of data type <code>xs:decimal</code>.</p>
<p>In <a href="#BCGBBEIB">Example 6-3</a>, the <code>XMLQuery</code> result is cast to SQL type <code>INTEGER</code>, which is compared with the SQL value 25. In <a href="#BCGIIDAA">Example 6-4</a>, the value of attribute <code>ItemNumber</code> is cast (in XQuery) to the XML data type <code>xs:decimal</code>, which is compared with the XQuery value 25 and which corresponds to the SQL data type (<code>INTEGER</code>) used for the index. There are thus two different kinds of data-type conversion in these examples, but they both convert query data to make it type-compatible with the index content table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb05sto.htm#i1030995">"Mapping XML Schema Data Types to SQL Data Types"</a> for information about the built-in correspondence between XML Schema data types and SQL data types</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDCJDAA"></a>
<div id="ADXDB4344" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLIndex Unstructured Component</h3>
<p>Unlike a B-tree index, which you define for a specific database column that represents an individual XML element or attribute, or the <code>XMLIndex</code> structured component, which applies to specific, structured document parts, the unstructured component of an <code>XMLIndex</code> index is, by default, very general. Unless you specify a more narrow focus by detailing specific XPath expressions to use or not to use in indexing, an unstructured <code>XMLIndex</code> component applies to <span class="italic">all possible XPath expressions</span> for your XML data.</p>
<p>The unstructured component of an <code>XMLIndex</code> index has three logical parts:</p>
<ul>
<li>
<p>A <span class="glossaryterm"><a id="sthref506"></a><a id="sthref507"></a>path index</span> &ndash; This indexes the XML <span class="italic">tags</span> of a document and identifies its various document <span class="italic">fragments</span>.</p>
</li>
<li>
<p>An <span class="glossaryterm"><a id="sthref508"></a><a id="sthref509"></a>order index</span> &ndash; This indexes the hierarchical <span class="italic">positions</span> of the nodes in an XML document. It keeps track of parent&ndash;child, ancestor&ndash;descendant, and sibling relations.</p>
</li>
<li>
<p>A <span class="glossaryterm"><a id="sthref510"></a><a id="sthref511"></a>value index</span> &ndash; This indexes the <span class="italic">values</span> of an XML document. It provides lookup by either value equality or value range. A value index is used for values in query predicates (<code>WHERE</code> clause).</p>
</li>
</ul>
<p>The unstructured component of an <code>XMLIndex</code> index uses a path table and a set of (local) secondary indexes on the path table, which implement the logical parts described above. Two secondary indexes are created automatically:</p>
<ul>
<li>
<p>A <span class="glossaryterm">pikey index</span>, which implements the logical indexes for both path and order.</p>
</li>
<li>
<p>A real <span class="glossaryterm">value index</span>, which implements the logical value index.</p>
</li>
</ul>
<p>You can modify these two indexes or create additional secondary indexes. The path table and its secondary indexes are all owned by the owner of the base table upon which the <code>XMLIndex</code> index is created.</p>
<p>The pikey index handles paths and order relationships together, which gives the best performance in most cases. If you find in some particular case that the value index is not picked up when think it should be, you can replace the pikey index with separate indexes for the paths and order relationships. Such (optional) indexes are called <span class="glossaryterm">path id</span> and <span class="glossaryterm">order key</span> indexes, respectively. For best results, contact Oracle Support if you find that the pikey index is not sufficient for your needs in some case.</p>
<p>The path table contains one row for each indexed node in the XML document. For each indexed node, the <span class="glossaryterm"><a id="sthref512"></a><a id="sthref513"></a>path table</span> stores:</p>
<ul>
<li>
<p>The corresponding <span class="italic">rowid</span> of the table that stores the document.</p>
</li>
<li>
<p>A <span class="italic">locator</span>, which provides fast access to the corresponding document fragment. For binary XML storage of XML schema-based data, it also stores data-type information.</p>
</li>
<li>
<p>An <span class="italic">order key</span>, to record the hierarchical position of the node in the document. You can think of this as a Dewey decimal key like that used in library cataloging and Internet protocol SNMP. In such a system, the key <code>3.21.5</code> represents the node position of the fifth child of the twenty-first child of the third child of the document root node.</p>
</li>
<li>
<p>An identifier that represents an XPath <span class="italic">path</span> to the node.</p>
</li>
<li>
<p>The effective <span class="italic">text value</span> of the node.</p>
</li>
</ul>
<p><a href="#CHDICGFB">Table 6-6</a> shows the main information<a id="sthref514" href="#sthref514" onclick='footdisplay(2,"The actual path table implementation may be slightly different.")'><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a> that is in the path table.</p>
<div id="ADXDB4345" class="tblformal">
<p class="titleintable"><a id="sthref515"></a><a id="CHDICGFB"></a>Table 6-6 XMLIndex Path Table</p>
<table class="cellalignment1026" title="XMLIndex Path Table" summary="XMLIndex Path Table" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t20">Column</th>
<th class="cellalignment1027" id="r1c2-t20">Data Type</th>
<th class="cellalignment1027" id="r1c3-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t20" headers="r1c1-t20">
<p><code>PATHID</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t20 r1c2-t20">
<p><code>RAW(8)</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t20 r1c3-t20">
<p>Unique identifier for the XPath path to the node.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t20" headers="r1c1-t20">
<p><code>RID</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t20 r1c2-t20">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t20 r1c3-t20">
<p>Rowid of the table used to store the XML data.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t20" headers="r1c1-t20">
<p><code>ORDER_KEY</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t20 r1c2-t20">
<p><code>RAW(1000)</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t20 r1c3-t20">
<p>Decimal order key that identifies the hierarchical position of the node. (Document ordering is preserved.)</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t20" headers="r1c1-t20">
<p><code>LOCATOR</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t20 r1c2-t20">
<p><code>RAW(2000)</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t20 r1c3-t20">
<p>Fragment-location information. Used for fragment extraction. For binary XML storage of XML schema-based data, data-type information is also stored here.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t20" headers="r1c1-t20">
<p><code>VALUE</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t20 r1c2-t20">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t20 r1c3-t20">
<p>Effective text value the node.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The pikey index uses path table columns <code>PATHID</code>, <code>RID</code>, and <code>ORDER_KEY</code> to represent the path and order indexes. An optional path id index uses columns <code>PATHID</code> and <code>RID</code> to represent the path index. A value index is an index on the <code>VALUE</code> column.</p>
<p><a href="#CHDJGGDH">Example 6-5</a> explores the contents of the path table for two purchase-order documents.</p>
<div id="ADXDB4346" class="example">
<p class="titleinexample"><a id="CHDJGGDH"></a>Example 6-5 Path Table Contents for Two Purchase Orders</p>
<pre>
&lt;PurchaseOrder&gt;
 &lt;Reference&gt;SBELL-2002100912333601PDT&lt;/Reference&gt;
 &lt;Actions&gt;
  &lt;Action&gt;
   &lt;User&gt;SVOLLMAN&lt;/User&gt;
  &lt;/Action&gt;
 &lt;/Actions&gt;
 . . .
&lt;/PurchaseOrder&gt;

&lt;PurchaseOrder&gt;
 &lt;Reference&gt;ABEL-20021127121040897PST&lt;/Reference&gt;
 &lt;Actions&gt;
  &lt;Action&gt;
   &lt;User&gt;ZLOTKEY&lt;/User&gt;
  &lt;/Action&gt;
  &lt;Action&gt;
   &lt;User&gt;KING&lt;/User&gt;
  &lt;/Action&gt;
 &lt;/Actions&gt;
 . . .
&lt;/PurchaseOrder&gt;
</pre>
<p>An <code>XMLIndex</code> index on an <code>XMLType</code> table or column storing these purchase orders includes a path table that has one row for each indexed node in the XML documents. Suppose that the system assigns the following <code>PATHID</code>s when indexing the nodes according to their XPath expressions:</p>
<div class="inftblinformal">
<table class="cellalignment1032" title="Example path table values" summary="PATHIDs for sample XPath expressions" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t21">PATHID</th>
<th class="cellalignment1027" id="r1c2-t21">Indexed XPath</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t21" headers="r1c1-t21"><code>1</code></td>
<td class="cellalignment1028" headers="r2c1-t21 r1c2-t21"><code>/PurchaseOrder</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t21" headers="r1c1-t21"><code>2</code></td>
<td class="cellalignment1028" headers="r3c1-t21 r1c2-t21"><code>/PurchaseOrder/Reference</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t21" headers="r1c1-t21"><code>3</code></td>
<td class="cellalignment1028" headers="r4c1-t21 r1c2-t21"><code>/PurchaseOrder/Actions</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t21" headers="r1c1-t21"><code>4</code></td>
<td class="cellalignment1028" headers="r5c1-t21 r1c2-t21"><code>/PurchaseOrder/Actions/Action</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t21" headers="r1c1-t21"><code>5</code></td>
<td class="cellalignment1028" headers="r6c1-t21 r1c2-t21"><code>/PurchaseOrder/Actions/Action/User</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The resulting path table would then be something like this (column <code>LOCATOR</code> is not shown):</p>
<div class="inftblinformal">
<table class="cellalignment1032" title="Example path table values" summary="Path table corresponding to sample XPath expressions" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t22">PATHID</th>
<th class="cellalignment1027" id="r1c2-t22">RID</th>
<th class="cellalignment1027" id="r1c3-t22">ORDER_KEY</th>
<th class="cellalignment1027" id="r1c4-t22">VALUE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t22" headers="r1c1-t22"><code>1</code></td>
<td class="cellalignment1028" headers="r2c1-t22 r1c2-t22"><code>R1</code></td>
<td class="cellalignment1028" headers="r2c1-t22 r1c3-t22"><code>1</code></td>
<td class="cellalignment1028" headers="r2c1-t22 r1c4-t22"><code>SBELL-2002100912333601PDTSVOLLMAN</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t22" headers="r1c1-t22"><code>2</code></td>
<td class="cellalignment1028" headers="r3c1-t22 r1c2-t22"><code>R1</code></td>
<td class="cellalignment1028" headers="r3c1-t22 r1c3-t22"><code>1.1</code></td>
<td class="cellalignment1028" headers="r3c1-t22 r1c4-t22"><code>SBELL-2002100912333601PDT</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t22" headers="r1c1-t22"><code>3</code></td>
<td class="cellalignment1028" headers="r4c1-t22 r1c2-t22"><code>R1</code></td>
<td class="cellalignment1028" headers="r4c1-t22 r1c3-t22"><code>1.2</code></td>
<td class="cellalignment1028" headers="r4c1-t22 r1c4-t22"><code>SVOLLMAN</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t22" headers="r1c1-t22"><code>4</code></td>
<td class="cellalignment1028" headers="r5c1-t22 r1c2-t22"><code>R1</code></td>
<td class="cellalignment1028" headers="r5c1-t22 r1c3-t22"><code>1.2.1</code></td>
<td class="cellalignment1028" headers="r5c1-t22 r1c4-t22"><code>SVOLLMAN</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t22" headers="r1c1-t22"><code>5</code></td>
<td class="cellalignment1028" headers="r6c1-t22 r1c2-t22"><code>R1</code></td>
<td class="cellalignment1028" headers="r6c1-t22 r1c3-t22"><code>1.2.1.1</code></td>
<td class="cellalignment1028" headers="r6c1-t22 r1c4-t22"><code>SVOLLMAN</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t22" headers="r1c1-t22"><code>1</code></td>
<td class="cellalignment1028" headers="r7c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r7c1-t22 r1c3-t22"><code>1</code></td>
<td class="cellalignment1028" headers="r7c1-t22 r1c4-t22"><code>ABEL-20021127121040897PSTZLOTKEYKING</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t22" headers="r1c1-t22"><code>2</code></td>
<td class="cellalignment1028" headers="r8c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r8c1-t22 r1c3-t22"><code>1.1</code></td>
<td class="cellalignment1028" headers="r8c1-t22 r1c4-t22"><code>ABEL-20021127121040897PST</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t22" headers="r1c1-t22"><code>3</code></td>
<td class="cellalignment1028" headers="r9c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r9c1-t22 r1c3-t22"><code>1.2</code></td>
<td class="cellalignment1028" headers="r9c1-t22 r1c4-t22"><code>ZLOTKEYKING</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t22" headers="r1c1-t22"><code>4</code></td>
<td class="cellalignment1028" headers="r10c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r10c1-t22 r1c3-t22"><code>1.2.1</code></td>
<td class="cellalignment1028" headers="r10c1-t22 r1c4-t22"><code>ZLOTKEY</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t22" headers="r1c1-t22"><code>5</code></td>
<td class="cellalignment1028" headers="r11c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r11c1-t22 r1c3-t22"><code>1.2.1.1</code></td>
<td class="cellalignment1028" headers="r11c1-t22 r1c4-t22"><code>ZLOTKEY</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r12c1-t22" headers="r1c1-t22"><code>4</code></td>
<td class="cellalignment1028" headers="r12c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r12c1-t22 r1c3-t22"><code>1.2.2</code></td>
<td class="cellalignment1028" headers="r12c1-t22 r1c4-t22"><code>KING</code></td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r13c1-t22" headers="r1c1-t22"><code>5</code></td>
<td class="cellalignment1028" headers="r13c1-t22 r1c2-t22"><code>R2</code></td>
<td class="cellalignment1028" headers="r13c1-t22 r1c3-t22"><code>1.2.2.1</code></td>
<td class="cellalignment1028" headers="r13c1-t22 r1c4-t22"><code>KING</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="example" -->
<div id="ADXDB4347" class="sect3"><a id="sthref516"></a>
<h4 class="sect3">Ignore the Path Table &ndash; It Is Transparent</h4>
<p>Though you can create secondary indexes on path-table columns, you can generally ignore the path table itself. You <span class="italic">cannot access</span> the path table, other than to <code>DESCRIBE</code> it and create (secondary) indexes on it. You need never explicitly gather statistics on the path table. You need only collect statistics on the <code>XMLIndex</code> index or the base table on which the <code>XMLIndex</code> index is defined; statistics are collected and maintained on the path table and its secondary indexes transparently.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDCEIFC">"Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer"</a></div>
</div>
<!-- class="sect3" -->
<a id="BCGBGFEC"></a>
<div id="ADXDB4348" class="sect3">
<h4 class="sect3">Column VALUE of an XMLIndex Path Table</h4>
<p>A secondary index on column <code>VALUE</code> is used with XPath expressions in a <code>WHERE</code> clause that have predicates involving string matches. For example:</p>
<pre>
/PurchaseOrder[Reference/text() = "SBELL-2002100912333601PDT"]
</pre>
<p>Column <code>VALUE</code> stores the <span class="glossaryterm"><a id="sthref517"></a><a id="sthref518"></a>effective text value</span> of an element or an attribute node&thinsp;&mdash;&thinsp;comments and processing instructions are ignored during indexing.</p>
<ul>
<li>
<p>For an <span class="italic">attribute</span>, the effective text value is the attribute value.</p>
</li>
<li>
<p>For a <span class="italic">simple</span> element (an element that has no children), the effective text value is the concatenation of all of the text nodes of the element.</p>
</li>
<li>
<p>For a <span class="italic">complex</span> element (an element that has children), the effective text value is the concatenation of (1) the text nodes of the element itself and (2) the effective text values of all of its simple-element descendants. (This is a recursive definition.)</p>
</li>
</ul>
<p>The effective text value is limited (truncated), however, to 4000 bytes for a simple element or attribute and to 80 bytes for a complex element.</p>
<p>Column <code>VALUE</code> is a fixed size, <code>VARCHAR2(4000)</code>. Any overflow (beyond 4000 bytes) during index creation or update is truncated, but the <code>LOCATOR</code> value for that row is then flagged so that the full value can be retrieved from the base table when needed.</p>
<p>In addition to the 4000-byte limit for column <code>VALUE</code>, there is a limit on the size of a key for the secondary index created on this column. This is the case for B-tree and function-based indexes as well; it is not an <code>XMLIndex</code> limitation. The index-key size limit is a function of the block size for your database. It is this limit that determines how much of <code>VALUE</code> is indexed.</p>
<p>Thus, only the first 4000 bytes of the effective text value are stored in column <code>VALUE</code>, and only the first <span class="italic">N</span> bytes of column <code>VALUE</code> are indexed, where <span class="italic">N</span> is the index-key size limit (<span class="italic">N</span> &lt; 4000). Because of the index-key size limit, the index on column <code>VALUE</code> acts only as a <span class="italic">preliminary filter</span> for the effective text value.</p>
<p>For example, suppose that your database block size requires that the <code>VALUE</code> index be no larger than 800 bytes, so that only the first 800 bytes of the effective text value is indexed. The first 800 bytes of the effective text value is first tested, using <code>XMLIndex</code>, and only if that text prefix matches the query value is the rest of the effective text value tested.</p>
<p>The secondary index on column <code>VALUE</code> is an index on SQL function <code>substr</code> (substring equality), because that function is used to test the text prefix. This function-based index is created automatically as part of the implementation of <code>XMLIndex</code> for column <code>VALUE</code>.</p>
<p>For example, the XPath expression <code>/PurchaseOrder[Reference/text() = :1]</code> in a query <code>WHERE</code> clause might, in effect, be rewritten to a test something like this:</p>
<pre>
substr(VALUE, 1 800) = substr(:1, 1, 800) AND VALUE = :1;
</pre>
<p>This conjunction contains two parts, which are processed from left to right. The first test uses the index on function <code>substr</code> as a preliminary filter, to eliminate text whose first 800 bytes do not match the first 800 bytes of the value of bind variable <code>:1</code>.</p>
<p>Only the first test uses an index&thinsp;&mdash;&thinsp;the full value of column <code>VALUE</code> is not indexed. After preliminary filtering by the first test, the second test checks the entire effective text value&thinsp;&mdash;&thinsp;that is, the full value of column <code>VALUE</code>&thinsp;&mdash;&thinsp;for full equality with the value of <code>:1</code>. This check does not use an index.</p>
<p>Even if only the first 800 bytes of text is indexed, it is important for query performance that up to 4000 bytes be stored in column <code>VALUE</code>, because that provides quick, direct access to the data, instead of requiring, for example, extracting it from deep within a <code>CLOB</code>-instance XML document. If the effective text value is greater than 4000 bytes, then the second test in the <code>WHERE</code>-clause conjunction requires accessing the base-table data.</p>
<p>Note that neither the <code>VALUE</code> column 4000-byte limit nor the index-key size affect query results in any way; they can affect only performance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because of the possibility of the <code>VALUE</code> column being truncated, an Oracle Text <code>CONTEXT</code> index created on the <code>VALUE</code> column might return incorrect results.</div>
<p>As mentioned, <code>XMLIndex</code> can be used with XML schema-based data. If an XML schema specifies a <code>defaultValue</code> value for a given element or attribute, and a particular document does not specify a value for that element or attribute, then the <code>defaultValue</code> value is used for the <code>VALUE</code> column.</p>
</div>
<!-- class="sect3" -->
<a id="BCGHHJEE"></a>
<div id="ADXDB4350" class="sect3">
<h4 class="sect3">Secondary Indexes on Column VALUE</h4>
<p>Even if you do not specify a secondary index for column <code>VALUE</code> when you create an <code>XMLIndex</code> index, a default secondary index is created on column <code>VALUE</code>. This default index has the default properties&thinsp;&mdash;&thinsp;in particular, it is an index for <span class="italic">text</span> (string-valued) data only.</p>
<p>You can, however, create a <code>VALUE</code> index of a different type. For example, you can create a number-valued index if that is appropriate for many of your queries. You can create multiple secondary indexes on the <code>VALUE</code> column. An index of a particular type is used only when it is appropriate. For example, a number-valued index is used only when the <code>VALUE</code> column is a number; it is ignored for other values. Secondary indexes on path-table columns are treated like any other secondary indexes&thinsp;&mdash;&thinsp;you can alter them, drop them, mark them unusable, and so on.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDGDAJF">"Using XMLIndex with an Unstructured Component"</a> for examples of creating secondary indexes on column <code>VALUE</code></p>
</li>
<li>
<p><a href="#CHDBGCCI">"PARAMETERS Clause for CREATE INDEX and ALTER INDEX"</a> for the syntax of the <code>PARAMETERS</code> clause</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDCGJDF"></a>
<div id="ADXDB4351" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">XPath Expressions that Are Not Indexed by an XMLIndex Unstructured Component</h4>
<p>The following types of XPath expressions are <span class="italic">not</span> indexed by <code>XMLIndex</code>:</p>
<ul>
<li>
<p>Applications of XPath functions, <span class="italic">except</span> <code>ora:contains</code>. In particular, user-defined XPath functions are <span class="italic">not</span> indexed.</p>
</li>
<li>
<p>Axes other than <code>child</code>, <code>descendant</code>, and <code>attribute</code>, that is, axes <code>parent</code>, <code>ancestor</code>, <code>following-sibling</code>, <code>preceding-sibling</code>, <code>following</code>, <code>preceding</code>, and <code>ancestor-or-self</code>.</p>
</li>
<li>
<p>Expressions using the union operator, <code><span class="codeinlinebold">|</span></code> (vertical bar).</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEFFJD"></a>
<div id="ADXDB4352" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating, Dropping, Altering, and Examining an <a id="sthref519"></a><a id="sthref520"></a><a id="sthref521"></a><a id="sthref522"></a>XMLIndex Index</h3>
<p>You create an <code>XMLIndex</code> index by declaring the index type to be <code>XDB.XMLIndex</code>, as illustrated in <a href="#CHDCGJHC">Example 6-6</a>.</p>
<div id="ADXDB4353" class="example">
<p class="titleinexample"><a id="CHDCGJHC"></a>Example 6-6 Creating an XMLIndex Index on XMLType Unstructured Storage</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS <span class="bold">XDB.XMLIndex</span>;
</pre></div>
<!-- class="example" -->
<p>This creates an <code>XMLIndex</code> index named <code>po_xmlindex_ix</code> on <code>XMLType</code> table <code>po_clob</code>. The index has only an unstructured component, no structured component.</p>
<p>You specify inclusion of a structured component in an <code>XMLIndex</code> index by including a <code><span class="codeinlineitalic">structured_clause</span></code> in the <code>PARAMETERS</code> clause. You specify inclusion of an unstructured component by including a <code><span class="codeinlineitalic">path_table_clause</span></code> in the <code>PARAMETERS</code> clause. You can do this when you create the <code>XMLIndex</code> index or when you modify it. If, as in <a href="#CHDCGJHC">Example 6-6</a>, you specify neither a <code><span class="codeinlineitalic">structured_clause</span></code> nor a <code><span class="codeinlineitalic">path_table_clause</span></code>, then <span class="italic">only</span> an unstructured component is included.</p>
<p>If an <code>XMLIndex</code> index has both an unstructured and a structured component, then you can drop either of these components using <code>ALTER INDEX</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDBGCCI">"PARAMETERS Clause for CREATE INDEX and ALTER INDEX"</a></p>
</li>
<li>
<p><a href="#BCGFGBEB">"<span class="italic">structured_clause ::=</span>"</a></p>
</li>
<li>
<p><a href="#BCGJAGCI">"<span class="italic">path_table_clause ::=</span>"</a></p>
</li>
<li>
<p><a href="#BCGGGBCB">"<span class="italic">drop_path_table_clause ::=</span>"</a></p>
</li>
<li>
<p><a href="#BCGJAAGH">"<span class="italic">alter_index_group_clause ::=</span>"</a></p>
</li>
</ul>
</div>
<p>You can obtain the name of an <code>XMLIndex</code> index on a particular <code>XMLType</code> table (or column), as shown in <a href="#CHDDGHDF">Example 6-7</a>. You can also select <code>INDEX_NAME</code> from <code>DBA_INDEXES</code> or <code>ALL_INDEXES</code>, as appropriate.</p>
<div id="ADXDB4356" class="example">
<p class="titleinexample"><a id="CHDDGHDF"></a>Example 6-7 Obtaining the Name of an XMLIndex Index on a Particular Table</p>
<pre>
SELECT INDEX_NAME FROM <span class="bold">USER_INDEXES</span>
  WHERE TABLE_NAME = 'PO_CLOB' AND <span class="bold">ITYP_NAME = 'XMLINDEX'</span>;

INDEX_NAME
---------------
PO_XMLINDEX_IX
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>You rename or drop an <code>XMLIndex</code> index just as you would any other index, as illustrated in <a href="#CHDFIGIB">Example 6-8</a>. This renaming changes the name of the <code>XMLIndex</code> index only. It does not change the name of the path table&thinsp;&mdash;&thinsp;you can rename the path table separately.</p>
<div id="ADXDB4357" class="example">
<p class="titleinexample"><a id="CHDFIGIB"></a>Example 6-8 Renaming and Dropping an XMLIndex Index</p>
<pre>
ALTER INDEX po_xmlindex_ix <span class="bold">RENAME TO new_name_ix</span>;

DROP INDEX new_name_ix;
</pre></div>
<!-- class="example" -->
<p>Similarly, you can change other index properties using other <code>ALTER INDEX</code> options, such as <code>REBUILD</code>. <code>XMLIndex</code> is no different from other index types in this respect.</p>
<p>The <code>RENAME</code> clause of an <code>ALTER INDEX</code> statement for <code>XMLIndex</code> applies only to the <code>XMLIndex</code> index itself. To rename the path table and secondary indexes, you must determine the names of these objects and use appropriate <code>ALTER TABLE</code> or <code>ALTER INDEX</code> statements on them directly. Similarly, to retrieve the physical properties of the secondary indexes or alter them in any other way, you must obtain their names, as in <a href="#CHDJHFGG">Example 6-13</a>.</p>
<p><a href="#CHDCGJHC">Example 6-6</a> shows how to create an <code>XMLIndex</code> index on unstructured storage.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDBGCCI">"PARAMETERS Clause for CREATE INDEX and ALTER INDEX"</a> for the syntax of the <code>PARAMETERS</code> clause</div>
</div>
<!-- class="sect2" -->
<a id="CHDGDAJF"></a>
<div id="ADXDB4362" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using XMLIndex with an Unstructured Component</h3>
<p>This section covers operations you can perform on an <code>XMLIndex</code> index that has an unstructured component (whether or not it also has a structured component)&thinsp;&mdash;&thinsp;see <a href="#CHDCJDAA">"XMLIndex Unstructured Component"</a>.</p>
<p>To include an unstructured component in an <code>XMLIndex</code> index, you use a <code><span class="codeinlineitalic">path_table_clause</span></code> in the <code>PARAMETERS</code> clause when you create or modify the <code>XMLIndex</code> index&thinsp;&mdash;&thinsp;see <a href="#BCGJAGCI">"<span class="italic">path_table_clause ::=</span>"</a>.</p>
<p>If you do not specify a <span class="italic">structured</span> component, then the index will have an unstructured component, even if you do not specify the path table. It is however generally a good idea to specify the path table, so that it has a recognizable, user-oriented name that you can refer to in other <code>XMLIndex</code> operations.</p>
<p><a href="#CHDJCDCF">Example 6-9</a> shows how to name the path table ("my_path_table") when creating an <code>XMLIndex</code> index with an unstructured component.</p>
<div id="ADXDB4358" class="example">
<p class="titleinexample"><a id="CHDJCDCF"></a>Example 6-9 Naming the Path Table of an XMLIndex Index</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  <span class="bold">PARAMETERS ('PATH TABLE my_path_table')</span>;
</pre></div>
<!-- class="example" -->
<p>If you do not name the path table then its name is generated by the system, using the index name you provide to <code>CREATE INDEX</code> as a base. <a href="#CHDBCCHJ">Example 6-10</a> shows this for the <code>XMLIndex</code> index created in <a href="#CHDCGJHC">Example 6-6</a>.</p>
<div id="ADXDB4359" class="example">
<p class="titleinexample"><a id="CHDBCCHJ"></a>Example 6-10 Determining the System-Generated Name of an XMLIndex Path Table</p>
<pre>
SELECT <span class="bold">PATH_TABLE_NAME</span> FROM <span class="bold">USER_XML_INDEXES</span>
  WHERE TABLE_NAME = 'PO_CLOB' AND INDEX_NAME = 'PO_XMLINDEX_IX';
 
PATH_TABLE_NAME
------------------------------
<span class="bold">SYS67567</span>_PO_XMLINDE_<span class="bold">PATH_TABLE</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>By default, the storage options of a path table and its secondary indexes are derived from the storage properties of the base table on which the <code>XMLIndex</code> index is created. You can specify different storage options by using a <code>PARAMETERS</code> clause when you create the index, as shown in <a href="#CHDBIGIJ">Example 6-11</a>. The <code>PARAMETERS</code> clause of <code>CREATE INDEX</code> (and <code>ALTER INDEX</code>) must be between single quotation marks (<code><span class="codeinlinebold">'</span></code>).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDBGCCI">"PARAMETERS Clause for CREATE INDEX and ALTER INDEX"</a> for the syntax of the <code>PARAMETERS</code> clause</div>
<div id="ADXDB4360" class="example">
<p class="titleinexample"><a id="CHDBIGIJ"></a>Example 6-11 Specifying Storage Options When Creating an XMLIndex Index</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS
    ('PATH TABLE po_path_table
      (PCTFREE 5 PCTUSED 90 INITRANS 5
       <span class="bold">STORAGE</span> (INITIAL 1k NEXT 2k MINEXTENTS 3 BUFFER_POOL KEEP)
       NOLOGGING ENABLE ROW MOVEMENT PARALLEL 3)
      <span class="bold">PIKEY INDEX</span> po_pikey_ix (LOGGING PCTFREE 1 INITRANS 3)
      <span class="bold">VALUE INDEX</span> po_value_ix (LOGGING PCTFREE 1 INITRANS 3)');
</pre></div>
<!-- class="example" -->
<p>Because <code>XMLIndex</code> is a logical <span class="italic">domain</span> index, not a physical index, all physical attributes are either zero (<code>0</code>) or <code>NULL</code>.</p>
<p>If an <code>XMLIndex</code> index has both an unstructured and a structured component, then you can use <code>ALTER INDEX</code> to drop the unstructured component. To do this, you drop the path table. <a href="#BCGHIIFB">Example 6-12</a> illustrates this. (This assumes that you also have a structured component&thinsp;&mdash;&thinsp;<a href="#BCGJCEAF">Example 6-20</a> results in an index with both structured and unstructured components.)</p>
<div id="ADXDB5827" class="example">
<p class="titleinexample"><a id="BCGHIIFB"></a>Example 6-12 Dropping an XMLIndex Unstructured Component</p>
<pre>
ALTER INDEX po_xmlindex_ix PARAMETERS('DROP PATH TABLE');
</pre></div>
<!-- class="example" -->
<p>Note that, in addition to specifying storage options for the path table, <a href="#CHDBIGIJ">Example 6-11</a> names the secondary indexes on the path table.</p>
<p>Like the name of the path table, the names of the secondary indexes on the path-table columns are generated automatically using the index name as a base, unless you specify them in the <code>PARAMETERS</code> clause. <a href="#CHDJHFGG">Example 6-13</a> illustrates this, and shows how you can determine these names using public view <code>USER_IND_COLUMNS</code>. It also shows that the pikey index uses three columns.</p>
<div id="ADXDB4361" class="example">
<p class="titleinexample"><a id="CHDJHFGG"></a>Example 6-13 Determining the Names of the Secondary Indexes of an XMLIndex Index</p>
<pre>
SELECT INDEX_NAME, COLUMN_NAME, COLUMN_POSITION FROM USER_IND_COLUMNS
  WHERE TABLE_NAME IN (SELECT PATH_TABLE_NAME FROM USER_XML_INDEXES
                         WHERE INDEX_NAME = 'PO_XMLINDEX_IX')
  ORDER BY INDEX_NAME, COLUMN_NAME;
 
INDEX_NAME                     COLUMN_NAME  COLUMN_POSITION
------------------------------ ------------ ---------------
SYS67563_PO_XMLINDE_PIKEY_IX   ORDER_KEY                  3
SYS67563_PO_XMLINDE_PIKEY_IX   PATHID                     2
SYS67563_PO_XMLINDE_PIKEY_IX   RID                        1
SYS67563_PO_XMLINDE_VALUE_IX   SYS_NC00006$               1
 
4 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDJACJG">Example 6-19</a> for a similar, but more complex example</div>
<div id="ADXDB5828" class="sect3"><a id="sthref523"></a>
<h4 class="sect3">Creating Additional Secondary Indexes on an XMLIndex Path Table</h4>
<p>This section adds extra secondary indexes to the <code>XMLIndex</code> index created in <a href="#CHDBIGIJ">Example 6-11</a>.</p>
<p>You can create any number of additional secondary indexes on the <code>VALUE</code> column of the path table of an <code>XMLIndex</code> index. These can be of different types, including function-based indexes and Oracle Text indexes.</p>
<p>Whether or not a given index is used for a given element occurrence when processing a query is determined by whether it is of the appropriate type for that value and whether it is cost-effective to use it.</p>
<p><a href="#CHDGADGI">Example 6-14</a> creates a function-based index on column <code>VALUE</code> of the path table using SQL function <code>substr</code>. This might be useful if your queries often use <code>substr</code> applied to the text nodes of XML elements.</p>
<div id="ADXDB4363" class="example">
<p class="titleinexample"><a id="CHDGADGI"></a>Example 6-14 Creating a Function-Based Index on Path-Table Column VALUE</p>
<pre>
CREATE INDEX fn_based_ix ON <span class="bold">po_path_table</span> (<span class="bold">substr</span>(<span class="bold">VALUE</span>, 1, 100));
</pre></div>
<!-- class="example" -->
<p>If you have many elements whose text nodes represent numeric values, then it can make sense to create a numeric index on the column <code>VALUE</code>. However, doing so directly, in a manner analogous to <a href="#CHDGADGI">Example 6-14</a>, raises an ORA-01722 error (invalid number) if some of the element values are <span class="italic">not</span> numbers. This is illustrated in <a href="#CHDJBCDD">Example 6-15</a>.</p>
<div id="ADXDB4364" class="example">
<p class="titleinexample"><a id="CHDJBCDD"></a>Example 6-15 Trying to Create a Numeric Index on Path-Table Column VALUE Directly</p>
<pre>
CREATE INDEX direct_num_ix ON po_path_table (to_binary_double(VALUE));
CREATE INDEX direct_num_ix ON po_path_table (to_binary_double(VALUE))
                                             <span class="bold">*</span>
ERROR at line 1:
ORA-01722: <span class="bold">invalid number</span>
</pre></div>
<!-- class="example" -->
<p>What is needed is an index that is used for numeric-valued elements but is ignored for element occurrences that do not have numeric values. Procedure <code>createNumberIndex</code> of package <code>DBMS_XMLINDEX</code> exists specifically for this purpose. You pass it the names of the database schema, the <code>XMLIndex</code> index, and the numeric index to be created. Creation of a numeric index is illustrated in <a href="#CHDFHBBJ">Example 6-16</a>.</p>
<div id="ADXDB4365" class="example">
<p class="titleinexample"><a id="CHDFHBBJ"></a>Example 6-16 Creating a Numeric Index on Column VALUE with Procedure createNumberIndex</p>
<pre>
CALL DBMS_XMLINDEX.<span class="bold">createNumberIndex</span>('OE', 'PO_XMLINDEX_IX', 'API_NUM_IX');
</pre></div>
<!-- class="example" -->
<p>Note that because such an index is specifically designed to ignore elements that do not have numeric values, its use does not detect their presence. If there are non-numeric elements and, for whatever reason, the <code>XMLIndex</code> index is not used in some query, then an <code>ORA-01722</code> error is raised. However, if the index is used, no such error is raised, because the index ignores non-numeric data. As always, the use of an index never changes the result set&thinsp;&mdash;&thinsp;it never gives you different results, but use of an index can prevent you from detecting erroneous data.</p>
<p>Creating a date-valued index is similar to creating a numeric index; you use procedure <code>DBMS_XMLINDEX.createDateIndex</code>. <a href="#CHDBABFD">Example 6-17</a> shows this.</p>
<div id="ADXDB4366" class="example">
<p class="titleinexample"><a id="CHDBABFD"></a>Example 6-17 Creating a Date Index on Column VALUE with Procedure createDateIndex</p>
<pre>
CALL DBMS_XMLINDEX.<span class="bold">createDateIndex</span>('OE', 'PO_XMLINDEX_IX', 'API_DATE_IX', 
                                   'dateTime');
</pre></div>
<!-- class="example" -->
<p><a href="#CHDJEHFC">Example 6-18</a> creates an Oracle Text <code>CONTEXT</code> index on column <code>VALUE</code>. This is useful for full-text queries on text values of XML elements. XPath predicates that use XPath function <code>ora:contains</code> are rewritten to applications of Oracle SQL function <code>contains</code> on column <code>VALUE</code>. If a <code>CONTEXT</code> index is defined on column <code>VALUE</code>, then it is used during predicate evaluation. An Oracle Text index is independent of all other <code>VALUE</code>-column indexes.</p>
<div id="ADXDB4367" class="example">
<p class="titleinexample"><a id="CHDJEHFC"></a>Example 6-18 Creating an Oracle Text CONTEXT Index on Path-Table Column VALUE</p>
<pre>
CREATE INDEX po_otext_ix ON po_path_table (VALUE)
  INDEXTYPE IS <span class="bold">CTXSYS.CONTEXT</span> PARAMETERS('TRANSACTIONAL');
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGBGFEC">"Column VALUE of an XMLIndex Path Table"</a> for information about the possibility of an Oracle Text <code>CONTEXT</code> index created on the <code>VALUE</code> column returning incorrect results</p>
</li>
<li>
<p><a href="#CHDDHECG">"Oracle Text Indexes on XML Data"</a></p>
</li>
</ul>
</div>
<p>The query in <a href="#CHDJACJG">Example 6-19</a> shows all of the secondary indexes created on the path table of an <code>XMLIndex</code> index. The indexes created explicitly are in bold. Note in particular that some indexes, such as the function-based index created on column <code>VALUE</code>, do not appear as such; the column name listed for such an index is a system-generated name such as <code>SYS_NC00007$</code>. You <span class="italic">cannot</span> see these columns by executing a query with <code>COLUMN_NAME = 'VALUE'</code> in the <code>WHERE</code> clause.</p>
<div id="ADXDB4368" class="example">
<p class="titleinexample"><a id="CHDJACJG"></a>Example 6-19 Showing All Secondary Indexes on an XMLIndex Path Table</p>
<pre>
SELECT c.INDEX_NAME, c.COLUMN_NAME, c.COLUMN_POSITION, e.COLUMN_EXPRESSION
  FROM <span class="bold">USER_IND_COLUMNS</span> c LEFT OUTER JOIN <span class="bold">USER_IND_EXPRESSIONS</span> e
    ON (c.INDEX_NAME = e.INDEX_NAME)
  WHERE c.TABLE_NAME IN (SELECT PATH_TABLE_NAME FROM USER_XML_INDEXES
                           WHERE INDEX_NAME = 'PO_XMLINDEX_IX')
  ORDER BY c.INDEX_NAME, c.COLUMN_NAME;
 
INDEX_NAME           COLUMN_NAME  COLUMN_POSITION COLUMN_EXPRESSION
-------------------- ------------ --------------- ----------------------
<span class="bold">API_DATE_IX</span>          <span class="bold">SYS_NC00009$</span>               1 SYS_EXTRACT_UTC(SYS_XMLCONV("V
                                                  ALUE",3,8,0,0,181))
<span class="bold">API_NUM_IX</span>           <span class="bold">SYS_NC00008$</span>               1 TO_BINARY_DOUBLE("VALUE")
<span class="bold">FN_BASED_IX</span>          <span class="bold">SYS_NC00007$</span>               1 SUBSTR("VALUE",1,100)
<span class="bold">PO_OTEXT_IX</span>          VALUE                      1
PO_PIKEY_IX          ORDER_KEY                  3
PO_PIKEY_IX          PATHID                     2
PO_PIKEY_IX          RID                        1
PO_VALUE_IX          SYS_NC00006$               1 SUBSTRB("VALUE",1,1599)
 
8 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS212" href="../../appdev.112/e40758/d_xmlindex.htm#ARPLS212"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information on PL/SQL procedures <code>createNumberIndex</code> and <code>createDateIndex</code> in package <code>DBMS_XMLINDEX</code></p>
</li>
<li>
<p><a href="#CHDHCDHH">"Oracle Text Indexes Are Used Independently of Other Indexes"</a> for information on using Oracle Text indexes</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BCGHGIGC"></a>
<div id="ADXDB4369" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using XMLIndex with a Structured Component</h3>
<p>To include a structured component in an <code>XMLIndex</code> index, you use a <code><span class="codeinlineitalic">structured_clause</span></code> in the <code>PARAMETERS</code> clause when you create or modify the <code>XMLIndex</code> index&thinsp;&mdash;&thinsp;see <a href="#BCGFGBEB">"<span class="italic">structured_clause ::=</span>"</a>.</p>
<p>A <code><span class="codeinlineitalic">structured_clause</span></code> specifies the structured islands that you want to index. You use the keyword <code>GROUP</code> to specify each structured island: an island thus corresponds syntactically to a structure <span class="glossaryterm"><a id="sthref524"></a>group</span>. If you specify no group explicitly, then the predefined group <code>DEFAULT_GROUP</code> is used. For <code>ALTER INDEX</code>, you precede the <code>GROUP</code> keyword with the modification operation keyword: <code>ADD_GROUP</code> specifies a new group (island); <code>DROP_GROUP</code> deletes a group.</p>
<p>Why have multiple groups within a single index, instead of simply using multiple <code>XMLIndex</code> indexes? The reason is that <code>XMLIndex</code> is a domain index, and you can create only one domain index of a given type on a given database column.</p>
<p>The syntax for defining a structure group, that is, indexing a structured island, is similar to the syntax for invoking SQL/XML <span class="italic">function</span> <code>XMLTable</code>: you use keywords <code>XMLTable</code> and <code>COLUMNS</code> to define relational columns, and you use multilevel chaining of <code>XMLTable</code> to handle collections.</p>
<p><a href="#BCGJCEAF">Example 6-20</a> shows the creation of an <code>XMLIndex</code> index with only an unstructured component. An unstructured component is created because the <code>PARAMETERS</code> clause explicitly names the path table.</p>
<p><a href="#BCGJCEAF">Example 6-20</a> then uses <code>ALTER INDEX</code> to add a structured component (group) named <code>po_item</code>. This structure group includes two relational tables, each specified with keyword <code>XMLTable</code>.</p>
<div id="ADXDB4370" class="example">
<p class="titleinexample"><a id="BCGJCEAF"></a>Example 6-20 XMLIndex Index: Adding a Structured Component</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE)
  INDEXTYPE IS XDB.XMLIndex PARAMETERS ('PATH TABLE path_tab');

BEGIN
  DBMS_XMLINDEX.<span class="bold">registerParameter</span>(
    'myparam',
    '<span class="bold">ADD_GROUP GROUP</span> po_item
       <span class="bold">XMLTable</span> po_idx_tab ''/PurchaseOrder''
         COLUMNS reference   VARCHAR2(30)  PATH ''Reference'',
                 requestor   VARCHAR2(30)  PATH ''Requestor'',
                 username    VARCHAR2(30)  PATH ''User'',
                 lineitem    XMLType       PATH ''LineItems/LineItem'' <span class="bold">VIRTUAL</span>
       <span class="bold">XMLTable</span> po_index_lineitem ''/LineItem'' PASSING lineitem
         COLUMNS itemno      BINARY_DOUBLE PATH ''@ItemNumber'',
                 description VARCHAR2(256) PATH ''Description'',
                 partno      VARCHAR2(14)  PATH ''Part/@Id'',
                 quantity    BINARY_DOUBLE PATH ''Part/@Quantity'',
                 unitprice   BINARY_DOUBLE PATH ''Part/@UnitPrice''');
END;
/

ALTER INDEX po_xmlindex_ix PARAMETERS('<span class="bold">PARAM</span> myparam');
</pre></div>
<!-- class="example" -->
<p>The top-level table, <code>po_idx_tab</code>, has columns <code>reference</code>, <code>requestor</code>, <code>username</code>, and <code>lineitem</code>. Column <code>lineitem</code> is of type <code>XMLType</code>. It represents a collection, so it is passed to the second <code>XMLTable</code> construct to form the second-level relational table, <code>po_index_lineitem</code>, which has columns <code>itemno</code>, <code>description</code>, <code>partno</code>, <code>quantity</code>, and <code>unitprice</code>.</p>
<p>The keyword <code>VIRTUAL</code> is <span class="italic">required</span> for an <code>XMLType</code> column. It specifies that the <code>XMLType</code> column itself is not materialized: its data is stored in the <code>XMLIndex</code> index only in the form of the relational columns specified by its corresponding <code>XMLTable</code> table.</p>
<p>You cannot create more than one <code>XMLType</code> column in a given <code>XMLTable</code> clause. To achieve that effect, you must instead define an additional group.</p>
<p><a href="#BCGJCEAF">Example 6-20</a> also illustrates the use of a registered parameter string in the <code>PARAMETERS</code> clause. It uses PL/SQL procedure <code>DBMS_XMLINDEX.registerParameter</code> to register the parameters string named <code>myparam</code>. Then it uses <code>ALTER INDEX</code> to update the index parameters to include those in the string <code>myparam</code>.</p>
<p>If an <code>XMLIndex</code> index has both an unstructured and a structured component, then you can use <code>ALTER INDEX</code> to drop the structured component. You do this by dropping <span class="italic">all</span> of the structure groups that compose the structured component. <a href="#BCGJGJAD">Example 6-21</a> shows how to drop the structured component that was added in <a href="#BCGJCEAF">Example 6-20</a>, by dropping its only structure group, <code>po_item</code>.</p>
<div id="ADXDB5829" class="example">
<p class="titleinexample"><a id="BCGJGJAD"></a>Example 6-21 Dropping an XMLIndex Structured Component</p>
<pre>
ALTER INDEX po_xmlindex_ix PARAMETERS('DROP_GROUP GROUP po_item');
</pre></div>
<!-- class="example" -->
<p>As indicated in section <a href="#BCGCBDHH">"XMLIndex Structured Component"</a>, because the tables used for the structured component of an <code>XMLIndex</code> index are normal relational tables, you can index them using any standard relational indexes.</p>
<p><a href="#BCGEGABJ">Example 6-22</a> and <a href="#BCGDEHEA">Example 6-23</a> illustrate this: <a href="#BCGEGABJ">Example 6-22</a> creates a B-tree index on the <code>reference</code> column of the index content table (structured fragment) for the <code>XMLIndex</code> index of <a href="#BCGJCEAF">Example 6-20</a>. <a href="#BCGDEHEA">Example 6-23</a> creates an Oracle Text <code>CONTEXT</code> index on the <code>description</code> column and then uses a full-text query on the content.</p>
<div id="ADXDB4371" class="example">
<p class="titleinexample"><a id="BCGEGABJ"></a>Example 6-22 Creating a B-Tree Index on an XMLIndex Index Content Table</p>
<pre>
CREATE INDEX idx_tab_ref_ix ON po_idx_tab (reference);
</pre></div>
<!-- class="example" -->
<div id="ADXDB5830" class="example">
<p class="titleinexample"><a id="BCGDEHEA"></a>Example 6-23 Oracle Text CONTEXT Index on an XMLIndex Index Content Table</p>
<pre>
CREATE INDEX idx_tab_desc_ix ON po_index_lineitem (description)
  INDEXTYPE IS CTXSYS.CONTEXT PARAMETERS ('transactional');

SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem'
                PASSING OBJECT_VALUE RETURNING CONTENT)
  FROM po_clob
    WHERE XMLExists('/PurchaseOrder/LineItems/LineItem
                     [ora:contains(Description, "Picnic") &gt; 0]'
                    PASSING OBJECT_VALUE)
      AND XMLExists('/PurchaseOrder[User="SBELL"]' PASSING OBJECT_VALUE);
</pre></div>
<!-- class="example" -->
<p><a href="#BCGDDBDI">Example 6-24</a> shows the creation of an <code>XMLIndex</code> index that has only a structured component (no path table clause) and that uses the <code>XMLNAMESPACES</code> clause to specify namespaces. It specifies that the index data be compressed and use tablespace <code>SYSAUX</code>. The example assumes a binary XML table <code>po_binxml</code> with non XML schema-based data.</p>
<div id="ADXDB5831" class="example">
<p class="titleinexample"><a id="BCGDDBDI"></a>Example 6-24 XMLIndex with Only a Structured Component and using Namespaces</p>
<pre>
CREATE INDEX po_struct ON po_binxml (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('XMLTable po_ptab
                 (TABLESPACE "SYSAUX" COMPRESS FOR OLTP)
                 XMLNAMESPACES (DEFAULT ''http://www.example.com/po''),
                 ''/purchaseOrder''
                 COLUMNS orderdate   DATE          PATH ''@orderDate'',
                         id          BINARY_DOUBLE PATH ''@id'',
                         items       XMLType       PATH ''items/item'' VIRTUAL
               XMLTable li_tab
                 (TABLESPACE "SYSAUX" COMPRESS FOR OLTP)
                 XMLNAMESPACES (DEFAULT ''http://www.example.com/po''),
                 ''/item'' PASSING items
                 COLUMNS partnum     VARCHAR2(15)  PATH ''@partNum'',
                         description CLOB          PATH ''productName'',
                         usprice     BINARY_DOUBLE PATH ''USPrice'',
                         shipdat     DATE          PATH ''shipDate''');
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGEFFEG">Example 6-28, "Using a Structured XMLIndex Component for a Query with Two Predicates"</a></p>
</li>
<li>
<p><a href="#CHDDHECG">"Oracle Text Indexes on XML Data"</a></p>
</li>
<li>
<p><a href="#BCGBHGJB">"Using a Registered PARAMETERS Clause for XMLIndex"</a></p>
</li>
<li>
<p><a href="#BCGFGBEB">"<span class="italic">structured_clause ::=</span>"</a></p>
</li>
<li>
<p><a href="#BCGGCCJB">"Usage of XMLIndex_xmltable_clause"</a> for information about an <code>XMLType</code> column in an <code>XMLTable</code> clause</p>
</li>
<li>
<p><a href="#BCGJCCFG">"Usage of column_clause"</a> for information about keywords <code>COLUMNS</code> and <code>VIRTUAL</code></p>
</li>
<li>
<p><a href="#BCGJDFCE">"Data Type Considerations for XMLIndex Structured Component"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDGIAIE"></a>
<div id="ADXDB4372" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">How to Tell Whether XMLIndex is Used</h3>
<p>It is at query compile time that Oracle Database determines whether or not a given <code>XMLIndex</code> index can be used, that is, whether the query can be rewritten into a query against the index.</p>
<p>For an unstructured <code>XMLIndex</code> component, if it cannot be determined at compile time that an XPath expression in the query is a subset of the paths you specified to be used for <code>XMLIndex</code> indexing, then the unstructured component of the&thinsp; index &thinsp;is not used.</p>
<p>For example, if the path <code>/PurchaseOrder/LineItems//*</code> is included for indexing, then a query with <code>/PurchaseOrder/LineItems/LineItem/Description</code> can use the index, but a query with <code>//Description</code> cannot. The latter also matches potential <code>Description</code> elements that are not children of <code>/PurchaseOrder/LineItems</code>, and it is not possible at compile time to know if such additional <code>Description</code> elements are present in the data.</p>
<p>To know whether a particular <code>XMLIndex</code> index has been used in resolving a query, you can examine an execution plan for the query.</p>
<ul>
<li>
<p>If the <span class="italic">unstructured</span> component of the index is used, then its path table, order key, or path id is referenced in the execution plan. The execution plan does <span class="italic">not</span> directly indicate that a domain index was used; it does <span class="italic">not</span> refer to the <code>XMLIndex</code> index by name. See <a href="#CHDDJDGI">Example 6-25</a> and <a href="#CHDIEGBF">Example 6-27</a>.</p>
</li>
<li>
<p>If the <span class="italic">structured</span> component of the index is used, then one or more of its index content tables is called out in the execution plan. See <a href="#BCGEFFEG">Example 6-28</a> and <a href="#BCGJEDEA">Example 6-29</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink PFGRF" href="../../server.112/e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a></p>
</li>
</ul>
</div>
<p><a href="#CHDDJDGI">Example 6-25</a> shows that the <code>XMLIndex</code> index created in <a href="#CHDJCDCF">Example 6-9</a> is used in a particular query. The reference to <code>MY_PATH_TABLE</code> in the execution plan here indicates that the <code>XMLIndex</code> index (created in <a href="#CHDJCDCF">Example 6-9</a>) is used in this query. Similarly, reference to columns <code>LOCATOR</code>, <code>ORDER_KEY</code>, and <code>PATHID</code> indicates the same thing.</p>
<div id="ADXDB4373" class="example">
<p class="titleinexample"><a id="CHDDJDGI"></a>Example 6-25 Checking Whether an XMLIndex Unstructured Component Is Used</p>
<pre>
SET AUTOTRACE ON EXPLAIN

SELECT XMLQuery('/PurchaseOrder/Requestor' PASSING OBJECT_VALUE RETURNING CONTENT) FROM po_clob
  WHERE XMLExists('/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]' PASSING OBJECT_VALUE);
 
XMLQUERY('/PURCHASEORDER/REQUESTOR'PASSINGOBJECT_VALUERETURNINGCONTENT)
-----------------------------------------------------------------------
&lt;Requestor&gt;Sarah J. Bell&lt;/Requestor&gt;
 
1 row selected.
 
 
Execution Plan
<span class="bold">. . .</span>
----------------------------------------------------------------------------------------------------------------
| Id  | Operation                       | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                |                              |     1 |    24 |    28   (4)| 00:00:01 |
|   1 |  SORT GROUP BY                  |                              |     1 |  3524 |            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID   | MY_PATH_TABLE                |     2 |  7048 |     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN             | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |     2   (0)| 00:00:01 |
|   4 |  NESTED LOOPS                   |                              |     1 |    24 |    28   (4)| 00:00:01 |
|   5 |   VIEW                          | VW_SQ_1                      |     1 |    12 |    26   (0)| 00:00:01 |
|   6 |    HASH UNIQUE                  |                              |     1 |  5046 |            |          |
|   7 |     NESTED LOOPS                |                              |     1 |  5046 |    26   (0)| 00:00:01 |
|*  8 |      TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    24   (0)| 00:00:01 |
|*  9 |       INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">VALUE_IX</span> |    73 |       |     1   (0)| 00:00:01 |
|* 10 |      TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |     2   (0)| 00:00:01 |
|* 11 |       INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |     1   (0)| 00:00:01 |
|  12 |   TABLE ACCESS BY USER ROWID    | PO_CLOB                      |     1 |    12 |     1   (0)| 00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P0"."<span class="bold">LOCATOR</span>")=1)
   3 - access("SYS_P0"."RID"=:B1 AND "SYS_P0"."<span class="bold">PATHID</span>"=HEXTORAW('76E2') )
   8 - filter("SYS_P4"."VALUE"='SBELL-2002100912333601PDT' AND "SYS_P4"."<span class="bold">PATHID</span>"=HEXTORAW('4F8C')  AND
              SYS_XMLI_LOC_ISNODE("SYS_P4"."<span class="bold">LOCATOR</span>")=1)
   9 - access(SUBSTRB("VALUE",1,1599)='SBELL-2002100912333601PDT')
  10 - filter(SYS_XMLI_LOC_ISNODE("SYS_P2"."<span class="bold">LOCATOR</span>")=1)
  11 - access("SYS_P4"."RID"="SYS_P2"."RID" AND "SYS_P2"."PATHID"=HEXTORAW('4E36')  AND
              "SYS_P2"."<span class="bold">ORDER_KEY</span>"&lt;"SYS_P4"."<span class="bold">ORDER_KEY</span>")
       filter("SYS_P4"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>("SYS_P2"."<span class="bold">ORDER_KEY</span>") AND
              <span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P2"."<span class="bold">ORDER_KEY</span>")+1=<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P4"."<span class="bold">ORDER_KEY</span>"))
<span class="bold">. . .</span>
</pre></div>
<!-- class="example" -->
<p>Given the name of a path table from an execution plan such as this, you can obtain the name of its <code>XMLIndex</code> index as shown in <a href="#CHDBCJIG">Example 6-26</a>. (This is more or less opposite to the query in <a href="#CHDBCCHJ">Example 6-10</a>.)</p>
<div id="ADXDB4374" class="example">
<p class="titleinexample"><a id="CHDBCJIG"></a>Example 6-26 Obtaining the Name of an XMLIndex Index from Its Path-Table Name</p>
<pre>
SELECT INDEX_NAME FROM USER_XML_INDEXES WHERE PATH_TABLE_NAME = 'MY_PATH_TABLE';
 
INDEX_NAME
------------------------------
PO_XMLINDEX_IX
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><code>XMLIndex</code> can be used for XPath expressions in the <code>SELECT</code> list, the <code>FROM</code> list, and the <code>WHERE</code> clause of a query, and it is useful for SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>. Unlike function-based indexes (and <code>CTXXPath</code> indexes, which are deprecated), <code>XMLIndex</code> indexes can be used when you extract data from an XML fragment in a document.</p>
<p><a href="#CHDIEGBF">Example 6-27</a> illustrates this.</p>
<div id="ADXDB4375" class="example">
<p class="titleinexample"><a id="CHDIEGBF"></a>Example 6-27 Extracting Data from an XML Fragment using XMLIndex</p>
<pre>
SET AUTOTRACE ON EXPLAIN
 
SELECT li.description, li.itemno
  FROM po_clob, XMLTable('/PurchaseOrder/LineItems/LineItem'
                         PASSING OBJECT_VALUE
                         COLUMNS "DESCRIPTION" VARCHAR(40) PATH 'Description',
                                 "ITEMNO"      INTEGER     PATH '@ItemNumber') li
  WHERE XMLExists('/PurchaseOrder[Reference="SBELL-2002100912333601PDT"]'
                  PASSING OBJECT_VALUE);
 
DESCRIPTION                                  ITEMNO
---------------------------------------- ----------
A Night to Remember                               1
The Unbearable Lightness Of Being                 2
Sisters                                           3
 
3 rows selected.

Execution Plan

----------------------------------------------------------------------------------------------------------------
| Id  | Operation                         | Name                         | Rows  | Bytes |Cost (%CPU)| Time    |
----------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                  |                              |     1 |  1546 |   30   (4)|00:00:01 |
|*  1 |  FILTER                           |                              |       |       |           |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    3   (0)|00:00:01 |
|*  3 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    2   (0)|00:00:01 |
|*  4 |  FILTER                           |                              |       |       |           |         |
|*  5 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |    3   (0)|00:00:01 |
|*  6 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    2   (0)|00:00:01 |
|   7 |  NESTED LOOPS                     |                              |       |       |           |         |
|   8 |   NESTED LOOPS                    |                              |     1 |  1546 |   30   (4)|00:00:01 |
|   9 |    NESTED LOOPS                   |                              |     1 |    24 |   28   (4)|00:00:01 |
|  10 |     VIEW                          | VW_SQ_1                      |     1 |    12 |   26   (0)|00:00:01 |
|  11 |      HASH UNIQUE                  |                              |     1 |  5046 |           |         |
|  12 |       NESTED LOOPS                |                              |     1 |  5046 |   26   (0)|00:00:01 |
|* 13 |        TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  3524 |   24   (0)|00:00:01 |
|* 14 |         INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">VALUE_IX</span> |    73 |       |    1   (0)|00:00:01 |
|* 15 |        TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |    2   (0)|00:00:01 |
|* 16 |         INDEX RANGE SCAN          | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    1   (0)|00:00:01 |
|  17 |     TABLE ACCESS BY USER ROWID    | PO_CLOB                      |     1 |    12 |    1   (0)|00:00:01 |
|* 18 |    INDEX RANGE SCAN               | SYS67616_PO_XMLINDE_<span class="bold">PIKEY_IX</span> |     1 |       |    1   (0)|00:00:01 |
|* 19 |   TABLE ACCESS BY INDEX ROWID     | <span class="bold">MY_PATH_TABLE</span>                |     1 |  1522 |    2   (0)|00:00:01 |
----------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   1 - filter(:B1&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B2))
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P2"."<span class="bold">LOCATOR</span>")=1)
   3 - access("SYS_P2"."RID"=:B1 AND "SYS_P2"."<span class="bold">PATHID</span>"=HEXTORAW('28EC')  AND "SYS_P2"."ORDER_KEY"&gt;:B2 AND
              "SYS_P2"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B3))
       filter(<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P2"."<span class="bold">ORDER_KEY</span>")=<span class="bold">SYS_ORDERKEY_DEPTH</span>(:B1)+1)
   4 - filter(:B1&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B2))
   5 - filter(SYS_XMLI_LOC_ISNODE("SYS_P5"."<span class="bold">LOCATOR</span>")=1)
   6 - access("SYS_P5"."RID"=:B1 AND "SYS_P5"."<span class="bold">PATHID</span>"=HEXTORAW('60E0')  AND "SYS_P5"."<span class="bold">ORDER_KEY</span>"&gt;:B2 AND
              "SYS_P5"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>(:B3))
       filter(<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P5"."<span class="bold">ORDER_KEY</span>")=<span class="bold">SYS_ORDERKEY_DEPTH</span>(:B1)+1)
  13 - filter("SYS_P10"."VALUE"='SBELL-2002100912333601PDT' AND "SYS_P10"."<span class="bold">PATHID</span>"=HEXTORAW('4F8C')  AND
              SYS_XMLI_LOC_ISNODE("SYS_P10"."<span class="bold">LOCATOR</span>")=1)
  14 - access(SUBSTRB("VALUE",1,1599)='SBELL-2002100912333601PDT')
  15 - filter(SYS_XMLI_LOC_ISNODE("SYS_P8"."<span class="bold">LOCATOR</span>")=1)
  16 - access("SYS_P10"."RID"="SYS_P8"."RID" AND "SYS_P8"."<span class="bold">PATHID</span>"=HEXTORAW('4E36')  AND
              "SYS_P8"."<span class="bold">ORDER_KEY</span>"&lt;"SYS_P10"."<span class="bold">ORDER_KEY</span>")
       filter("SYS_P10"."<span class="bold">ORDER_KEY</span>"&lt;<span class="bold">SYS_ORDERKEY_MAXCHILD</span>("SYS_P8"."<span class="bold">ORDER_KEY</span>") AND
              <span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P8"."<span class="bold">ORDER_KEY</span>")+1=<span class="bold">SYS_ORDERKEY_DEPTH</span>("SYS_P10"."<span class="bold">ORDER_KEY</span>"))
  18 - access("PO_CLOB".ROWID="SYS_ALIAS_4"."RID" AND "SYS_ALIAS_4"."<span class="bold">PATHID</span>"=HEXTORAW('3748') )
  19 - filter(SYS_XMLI_LOC_ISNODE("SYS_ALIAS_4"."<span class="bold">LOCATOR</span>")=1)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
</pre></div>
<!-- class="example" -->
<p>The execution plan for the query in <a href="#CHDIEGBF">Example 6-27</a> shows, by referring to the path table, that <code>XMLIndex</code> is used. It also shows the use of Oracle internal SQL function <code>sys_orderkey_depth</code>&thinsp;&mdash;&thinsp;see <a href="#CHDDEBGF">"Guidelines for Using XMLIndex with an Unstructured Component"</a>.</p>
<p><a href="#BCGEFFEG">Example 6-28</a> shows an execution plan that indicates that the <code>XMLIndex</code> index created in <a href="#BCGJCEAF">Example 6-20</a> is picked up for a query that uses two <code>WHERE</code> clause predicates. With only the unstructured <code>XMLIndex</code> component, this query would involve a join of the path table to itself, because of the two different paths in the <code>WHERE</code> clause.</p>
<div id="ADXDB4376" class="example">
<p class="titleinexample"><a id="BCGEFFEG"></a>Example 6-28 Using a Structured XMLIndex Component for a Query with Two Predicates</p>
<pre>
EXPLAIN PLAN FOR
  SELECT XMLQuery('/PurchaseOrder/LineItems/LineItem' PASSING OBJECT_VALUE RETURNING CONTENT)
    FROM po_clob
    WHERE XMLExists('/PurchaseOrder/LineItems/LineItem
                     [ora:contains(Description, "Picnic") &gt; 0]' PASSING OBJECT_VALUE)
      AND XMLEXists('/PurchaseOrder[User="SBELL"]' PASSING OBJECT_VALUE);

-------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                              |     1 |   189 |    22  (14)| 00:00:01 |
|   1 |  SORT GROUP BY               |                              |     1 |  3524 |            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID| <span class="bold">PATH_TAB</span>                     |     2 |  7048 |     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | SYS67840_PO_XMLINDE_PIKEY_IX |     1 |       |     2   (0)| 00:00:01 |
|*  4 |  HASH JOIN SEMI              |                              |     1 |   189 |    22  (14)| 00:00:01 |
|   5 |   NESTED LOOPS               |                              |    13 |   637 |     4  (25)| 00:00:01 |
|   6 |    SORT UNIQUE               |                              |    13 |   351 |     3   (0)| 00:00:01 |
|*  7 |     TABLE ACCESS FULL        | <span class="bold">PO_IDX_TAB</span>                   |    13 |   351 |     3   (0)| 00:00:01 |
|*  8 |    INDEX UNIQUE SCAN         | SYS_C006004                  |     1 |    22 |     0   (0)| 00:00:01 |
|*  9 |   TABLE ACCESS FULL          | <span class="bold">PO_INDEX_LINEITEM</span>            |    13 |  1820 |    17   (6)| 00:00:01 |
-------------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P0"."LOCATOR")=1)
   3 - access("SYS_P0"."RID"=:B1 AND "SYS_P0"."PATHID"=HEXTORAW('3748') )
   4 - access("SYS_ALIAS_1"."SYS_NC_OID$"="SYS_ALIAS_3"."OID")
   7 - filter("SYS_ALIAS_2"."USERNAME"='SBELL')
   8 - access("SYS_ALIAS_1"."SYS_NC_OID$"="SYS_ALIAS_2"."OID")
   9 - filter(SYS_XMLCONTAINS("SYS_ALIAS_3"."DESCRIPTION",'Picnic')&gt;0)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
   - Unoptimized XML construct detected (enable XMLOptimizationCheck for more information)
 
30 rows selected.
 
</pre></div>
<!-- class="example" -->
<p>The presence in <a href="#BCGEFFEG">Example 6-28</a> of the path table name, <code>path_tab</code>, indicates that the unstructured index component of the index is used. The presence of the index content table <code>po_idx_tab</code> indicates that the structured index component is used.</p>
<p><a href="#BCGJEDEA">Example 6-29</a> shows an execution plan that indicates that the same <code>XMLIndex</code> index is also picked up for a query that uses multilevel <code>XMLTable</code> chaining. With only the unstructured <code>XMLIndex</code> component, this query too would involve a join of the path table to itself, because of the different paths in the two <code>XMLTable</code> function calls.</p>
<div id="ADXDB4377" class="example">
<p class="titleinexample"><a id="BCGJEDEA"></a>Example 6-29 Using a Structured XMLIndex Component for a Query with Multilevel Chaining</p>
<pre>
EXPLAIN PLAN FOR
  SELECT po.reference, li.*
    FROM po_clob p,
         XMLTable('/PurchaseOrder' PASSING p.OBJECT_VALUE
                  COLUMNS reference   VARCHAR2(30)  PATH 'Reference',
                          lineitem    XMLType       PATH 'LineItems/LineItem') po,
         XMLTable('/LineItem' PASSING po.lineitem
                  COLUMNS itemno      BINARY_DOUBLE PATH '@ItemNumber',
                          description VARCHAR2(256) PATH 'Description',
                          partno      VARCHAR2(14)  PATH 'Part/@Id',
                          quantity    BINARY_DOUBLE PATH 'Part/@Quantity',
                          unitprice   BINARY_DOUBLE PATH 'Part/@UnitPrice') li
    WHERE po.reference = 'SBELL-20021009123335280PDT';
 
-------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                   | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                        |    17 | 20366 |    11   (0)| 00:00:01 |
|   1 |  NESTED LOOPS                |                        |       |       |            |          |
|   2 |   NESTED LOOPS               |                        |    17 | 20366 |    11   (0)| 00:00:01 |
|   3 |    NESTED LOOPS              |                        |     1 |   539 |     3   (0)| 00:00:01 |
|*  4 |     TABLE ACCESS FULL        | <span class="bold">PO_IDX_TAB</span>             |     1 |   529 |     3   (0)| 00:00:01 |
|*  5 |     INDEX UNIQUE SCAN        | SYS_C006320            |     1 |    10 |     0   (0)| 00:00:01 |
|*  6 |    INDEX RANGE SCAN          | SYS69412_69421_PKY_IDX |    17 |       |     1   (0)| 00:00:01 |
|   7 |   TABLE ACCESS BY INDEX ROWID| <span class="bold">PO_INDEX_LINEITEM</span>      |    17 | 11203 |     8   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   4 - filter("SYS_ALIAS_8"."REFERENCE"='SBELL-20021009123335280PDT')
   5 - access("SYS_ALIAS_8"."OID"="P"."SYS_NC_OID$")
   6 - access("SYS_ALIAS_8"."KEY"="SYS_ALIAS_9"."PKEY")
 
Note
-----
   - dynamic sampling used for this statement
 
25 rows selected.
</pre></div>
<!-- class="example" -->
<p>The execution plan shows direct access to the relational index content tables, <code>po_idx_tab</code> and <code>po_index_lineitem</code>. There is <span class="italic">no</span> access at all to the path table, <code>path_tab</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDCEIFC">"Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer"</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDBBAGA"></a>
<div id="ADXDB4378" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Turning Off Use of XMLIndex</h3>
<p>You can turn off the use of <code>XMLIndex</code> in any of these ways:</p>
<ul>
<li>
<p>Use optimizer hint <code>/*+ NO_XML_QUERY_REWRITE */</code></p>
</li>
<li>
<p>Use optimizer hint <code>/*+ NO_XMLINDEX_REWRITE */</code></p>
</li>
</ul>
<p>Hints <code>NO_XML_QUERY_REWRITE</code> and <code>NO_XMLINDEX_REWRITE</code> turn off the use of <span class="italic">all</span> <code>XMLIndex</code> indexes. In addition to turning off use of <code>XMLIndex</code>, <code>NO_XML_QUERY_REWRITE</code> turns off all XQuery optimization (<code>XMLIndex</code> is part of XPath rewrite).</p>
<p><a href="#CHDBJFGE">Example 6-30</a> shows the use of these optimizer hints.</p>
<div id="ADXDB4379" class="example">
<p class="titleinexample"><a id="CHDBJFGE"></a>Example 6-30 Turning Off XMLIndex using Optimizer Hints</p>
<pre>
SELECT <span class="bold">/*+ NO_XMLINDEX_REWRITE */</span> 
  count(*) FROM po_clob WHERE XMLExists('$p/*' PASSING OBJECT_VALUE AS "p");

SELECT <span class="bold">/*+ NO_XML_QUERY_REWRITE */</span>
  count(*) FROM po_clob WHERE XMLExists('$p/*' PASSING OBJECT_VALUE AS "p");
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>NO_INDEX</code> optimizer hint does not apply to <code>XMLIndex</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_xquery.htm#BABICHDC">"XQuery Optional Features"</a> for information about XQuery pragmas <a id="sthref525"></a><code>ora:xq_proc</code> and <code>ora:xq_qry</code>, which you can use for fine-grained control of XQuery optimization</p>
</li>
<li>
<p><a href="xdb03usg.htm#BABDBEFG">"How Oracle XML&nbsp;DB Processes XMLType Methods and SQL Functions"</a> for information about streaming evaluation of binary XML data</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDCJIJB"></a>
<div id="ADXDB4380" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLIndex Path Subsetting: Specifying the Paths You Want to Index</h3>
<p>One of the advantages of an <code>XMLIndex</code> index with an unstructured component is that it is very general: you need not specify which XPath locations to index; you need no prior knowledge of the XPath expressions that will be queried. By default, an unstructured <code>XMLIndex</code> indexes all possible XPath locations in your XML data.</p>
<p>However, if you are aware of the XPath expressions that you are most likely to query, then you can narrow the focus of <code>XMLIndex</code> indexing and thus improve performance. Having fewer indexed nodes means less space is required for indexing, which improves index maintenance during DML operations. Having fewer indexed nodes improves DDL performance, and having a smaller path table improves query performance.</p>
<p>You narrow the focus of indexing by pruning the set of XPath expressions (paths) corresponding to XML fragments to be indexed, specifying a subset of all possible paths. You can do this in two alternative ways:</p>
<ul>
<li>
<p>Exclusion &ndash; Start with the default behavior of including all possible XPath expressions, and exclude some of them from indexing.</p>
</li>
<li>
<p>Inclusion &ndash; Start with an empty set of XPath expressions to be used in indexing, and add paths to this inclusion set.</p>
</li>
</ul>
<p>You can specify path subsetting either when you create an <code>XMLIndex</code> index using <code>CREATE INDEX</code> or when you modify it using <code>ALTER INDEX</code>. In both cases, you provide the subsetting information in the <code>PATHS</code> parameter of the statement's <code>PARAMETERS</code> clause. For exclusion, you use keyword <code>EXCLUDE</code>. For inclusion, you use keyword <code>INCLUDE</code> for <code>ALTER INDEX</code> and no keyword for <code>CREATE INDEX</code> (list the paths to include). You can also specify namespace mappings for the nodes targeted by the <code>PATHS</code> parameter.</p>
<p>For <code>ALTER INDEX</code>, keyword <code>INCLUDE</code> or <code>EXCLUDE</code> is followed by keyword <code>ADD</code> or <code>REMOVE</code>, to indicate whether the list of paths that follows the keyword is to be added or removed from the inclusion or exclusion list. For example, this statement adds path <code>/PurchaseOrder/Reference</code> to the list of paths to be excluded from indexing:</p>
<pre>
ALTER INDEX po_xmlindex_ix REBUILD
  PARAMETERS ('PATHS (<span class="bold">EXCLUDE ADD</span> (/PurchaseOrder/Reference))');
</pre>
<p>To alter an <code>XMLIndex</code> index so that it <span class="italic">includes all</span> possible paths, use keyword <code>INDEX_ALL_PATHS</code>. See <a href="#BCGFAECD">"<span class="italic">alter_index_paths_clause ::=</span>"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you create an <code>XMLIndex</code> index that has both structured and unstructured components, then, by default, any nodes indexed in the structured component are also indexed in the unstructured component; that is, they are <span class="italic">not</span> automatically <span class="italic">excluded</span> from the unstructured component. If you do not want unstructured <code>XMLIndex</code> indexing to apply to them, then you must explicitly use path subsetting to exclude them.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDBGCCI">"PARAMETERS Clause for CREATE INDEX and ALTER INDEX"</a> for the syntax of the <code>PARAMETERS</code> clause</div>
<div id="ADXDB4381" class="sect3"><a id="sthref526"></a>
<h4 class="sect3">Examples of XMLIndex Path Subsetting</h4>
<p>This section presents some examples of defining <code>XMLIndex</code> indexes on subsets of XPath expressions.</p>
<div id="ADXDB4382" class="example">
<p class="titleinexample"><a id="CHDIHICC"></a>Example 6-31 XMLIndex Path Subsetting with CREATE INDEX</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS XDB.XMLINDEX
  PARAMETERS ('PATHS (INCLUDE (/PurchaseOrder/LineItems//* 
                               /PurchaseOrder/Reference))');
</pre>
<p>This statement creates an index that indexes only top-level element <code>PurchaseOrder</code> and some of its children, as follows:</p>
<ul>
<li>
<p>All <code>LineItems</code> elements and their descendants</p>
</li>
<li>
<p>All <code>Reference</code> elements</p>
</li>
</ul>
<p>It does that by including the specified paths, starting with an empty set of paths to be used for the index.</p>
</div>
<!-- class="example" -->
<div id="ADXDB4383" class="example">
<p class="titleinexample"><a id="CHDDFGBC"></a>Example 6-32 XMLIndex Path Subsetting with ALTER INDEX</p>
<pre>
ALTER INDEX po_xmlindex_ix REBUILD
  PARAMETERS ('PATHS (INCLUDE ADD (/PurchaseOrder/Requestor 
                                   /PurchaseOrder/Actions/Action//*))');
</pre>
<p>This statement adds two more paths to those used for indexing. These paths index element <code>Requestor</code> and descendants of element <code>Action</code> (and their ancestors).</p>
</div>
<!-- class="example" -->
<div id="ADXDB4384" class="example">
<p class="titleinexample"><a id="CHDJEICC"></a>Example 6-33 XMLIndex Path Subsetting using a Namespace Prefix</p>
<p>If an XPath expression to be used for <code>XMLIndex</code> indexing uses namespace prefixes, you can use a <code>NAMESPACE MAPPING</code> clause to the <code>PATHS</code> list, to specify those prefixes. Here is an example:</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('PATHS (INCLUDE (/PurchaseOrder/LineItems//*   /PurchaseOrder/<span class="bold">ipo:</span>Reference)
                     NAMESPACE MAPPING (xmlns="http://xmlns.oracle.com"
                                        xmlns:<span class="bold">ipo</span>="http://xmlns.oracle.com/ipo"))');
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADXDB4385" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref527"></a>
<h4 class="sect3">XMLIndex Path-Subsetting Rules</h4>
<p>The following rules apply to <code>XMLIndex</code> path subsetting:</p>
<ul>
<li>
<p>The paths must reference only child and descendant axes, and they must test only element and attribute nodes or their names (possibly using wildcards). In particular, the paths must not involve predicates.</p>
</li>
<li>
<p>You cannot specify both path exclusion and path inclusion; choose one or the other.</p>
</li>
<li>
<p>If an index was created using path exclusion (inclusion), then you can modify it using only path exclusion (inclusion)&thinsp;&mdash;&thinsp;index modification must either further restrict or further extend the path subset. For example, you cannot create an index that includes certain paths and subsequently modify it to exclude certain paths.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDDEBGF"></a>
<div id="ADXDB4386" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Guidelines for Using XMLIndex with an Unstructured Component</h3>
<p>The following are some guidelines for using <code>XMLIndex</code> with an unstructured component. These guidelines are applicable only when the two alternatives discussed return the same result set.</p>
<ul>
<li>
<p>Avoid prefixing <code>//</code> with ancestor elements. For example, use <code>//c</code>, <span class="italic">not</span> <code><span class="codeinlinebold">/a/b</span></code><code>//c</code>, provided these return the same result set.</p>
</li>
<li>
<p>Avoid prefixing <code>/*</code> with ancestor elements. For example, use <code>/*/*/*</code>, <span class="italic">not</span> <code><span class="codeinlinebold">/a</span></code><code>/*/*</code>, provided these return the same result set.</p>
</li>
<li>
<p>In a <code>WHERE</code> clause, use <code>XMLExists</code> rather than <code>XMLCast</code> of <code>XMLQuery</code>. This can allow optimization that, in effect, invokes a subquery against the path-table <code>VALUE</code> column. For example, use this:</p>
<pre>
SELECT count(*) FROM purchaseorder p 
  WHERE 
    XMLExists('$p/PurchaseOrder/LineItems/LineItem/Part[@Id="715515011020"]'
                  PASSING OBJECT_VALUE AS "p");
</pre>
<p>Do not use this:</p>
<pre>
SELECT count(*) FROM purchaseorder p
  WHERE XMLCast(XMLQuery('$p/PurchaseOrder/LineItems/LineItem/Part/@Id'
                         PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
                AS VARCHAR2(14))
        = "715515011020";
</pre></li>
<li>
<p>When possible, use <code>count(*)</code>, <span class="italic">not</span> <code>count(XMLCast(XMLQuery(...))</code>, in a <code>SELECT</code> clause. For example, if you know that a <code>LineItem</code> element in a purchase-order document has only one <code>Description</code> child, use this:</p>
<pre>
SELECT count(*) FROM po_clob, XMLTable('//LineItem' PASSING OBJECT_VALUE);
</pre>
<p>Do not use this:</p>
<pre>
SELECT count(li.value)
 FROM po_clob p, XMLTable('//LineItem' PASSING p.OBJECT_VALUE
                          COLUMNS value VARCHAR2(30) PATH 'Description') li;
</pre></li>
<li>
<p>Reduce the number of XPath expressions used in a query <code>FROM</code> list as much as possible. For example, use this:</p>
<pre>
SELECT li.description
  FROM po_clob p,
       XMLTable('PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH 'Description') li;
</pre>
<p>Do not use this:</p>
<pre>
SELECT li.description
  FROM po_clob p,
       XMLTable('PurchaseOrder/LineItems' PASSING p.OBJECT_VALUE) ls,
       XMLTable('LineItems/LineItem'      PASSING ls.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH 'Description') li;
</pre></li>
<li>
<p>If you use an XPath expression in a query to drill down inside a virtual table (created, for example, using SQL/XML function <code>XMLTable</code>), then create a secondary index on the order key of the path table using Oracle SQL function <code>sys_orderkey_depth</code>. Here is an example of such a query; the selection navigates to element <code>Description</code> inside virtual line-item table <code>li</code>.</p>
<pre>
SELECT li.description
  FROM po_clob p,
       XMLTable('PurchaseOrder/LineItems/LineItem' PASSING p.OBJECT_VALUE
                COLUMNS description VARCHAR2(256) PATH 'Description') li;
</pre>
<p>Such queries are evaluated using function <code>sys_orderkey_depth</code>, which returns the depth of the order-key value. Because the order index uses two columns, the index needed is a <span class="italic">composite</span> index over columns <code>ORDER_KEY</code> and <code>RID</code>, as well as over function <code>sys_orderkey_depth</code> applied to the <code>ORDER_KEY</code> value. For example:</p>
<pre>
CREATE INDEX depth_ix ON my_path_table
  (RID, sys_orderkey_depth(ORDER_KEY), ORDER_KEY);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDIEGBF">Example 6-27</a> for an example that shows the use of <code>sys_orderkey_depth</code></div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CEGDAFIF"></a>
<div id="ADXDB6001" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Guidelines for Using XMLIndex with a Structured Component</h3>
<p>The following are some guidelines for using <code>XMLIndex</code> with a structured component.</p>
<ul>
<li>
<p>Use <code>XMLIndex</code> with a structured component to project and index XML data as relational columns. Do not use function-based indexes; they are deprecated for use with XML. See <a href="#BCGIDHFB">"Function-Based Indexes"</a>.</p>
</li>
<li>
<p>Ensure data type correspondence between a query and an <code>XMLIndex</code> index that has a structured component. See <a href="#BCGJDFCE">"Data Type Considerations for XMLIndex Structured Component"</a>.</p>
</li>
<li>
<p>If you create a relational view over <code>XMLType</code> data (for example, using SQL function <code>XMLTable</code>), then you consider also creating an <code>XMLIndex</code> index with a structured component that targets the same relational columns. See <a href="xdb14vie.htm#CJIDAFJI">Chapter 19, "XMLType Views"</a>.</p>
</li>
<li>
<p>Instead of using a single XQuery expression for both fragment extraction and value filtering (search), use SQL/XML function <code>XMLQuery</code> in the <code>SELECT</code> clause to extract fragments and <code>XMLExists</code> in the <code>WHERE</code> clause to filter values.</p>
<p>This lets Oracle XML DB evaluate fragment extraction functionally or by using streaming evaluation. For value filtering, this lets Oracle XML&nbsp;DB pick up an <code>XMLIndex</code> index that has a relevant structured component.</p>
</li>
<li>
<p>To order query results, use a SQL <code>ORDER BY</code> clause, together with SQL/XML function <code>XMLTable</code>. Avoid using the XQuery <code>order by</code> clause. This is particularly pertinent if you use an <code>XMLIndex</code> index with a structured component.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDBBCEF"></a>
<div id="ADXDB4397" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XMLIndex Partitioning and Parallelism</h3>
<p>If you partition an <code>XMLType</code> table, or a table with an <code>XMLType</code> column using range or list partitioning, you can also create an <code>XMLIndex</code> index on the table. If you use the keyword <code>LOCAL</code> when you create the <code>XMLIndex</code> index, then the index and all of its storage tables are locally equipartitioned with respect to the base table.</p>
<p>If you do not use the keyword <code>LOCAL</code>, then you cannot create an <code>XMLIndex</code> index on a partitioned table. Also, if you hash-partition a table, then you cannot create an <code>XMLIndex</code> index on it.</p>
<p>You can use a <code>PARALLEL</code> clause (with optional degree) when creating or altering an <code>XMLIndex</code> index to ensure that index creation and maintenance are carried out in parallel. If the base table is partitioned or enabled for parallelism, then this can improve the performance for both DML operations (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>) and index DDL operations (<code>CREATE</code>, <code>ALTER</code>, <code>REBUILD</code>).</p>
<p>Specifying parallelism for an index can also consume more storage, because storage parameters apply separately to each query server process. For example, an index created with an <code>INITIAL</code> value of 5M and a parallelism degree of 12 consumes at least 60M of storage during index creation.</p>
<p>The syntax for the parallelism clause for <code>CREATE INDEX</code> and <code>ALTER INDEX</code> is the same as for other domain indexes:</p>
<pre>
{ NOPARALLEL | PARALLEL [ integer ] }
</pre>
<p><a href="#CHDGDGFA">Example 6-34</a> creates an <code>XMLIndex</code> index with a parallelism degree of 10. If the base table is partitioned, then this index is equipartitioned.</p>
<div id="ADXDB4398" class="example">
<p class="titleinexample"><a id="CHDGDGFA"></a>Example 6-34 Creating an XMLIndex Index in Parallel</p>
<pre>
CREATE INDEX po_xmlindex_ix ON sale_info (sale_po_clob) INDEXTYPE IS XDB.XMLIndex 
 <span class="bold"> LOCAL PARALLEL 10</span>;
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDGDGFA">Example 6-34</a>, the path table and the secondary indexes are created with the same parallelism degree as the <code>XMLIndex</code> index itself, 10, by inheritance. You can specify different parallelism degrees for these by using separate <code>PARALLEL</code> clauses. <a href="#CHDFFICC">Example 6-35</a> demonstrates this. Again, because of keyword <code>LOCAL</code>, if the base table is partitioned, then this index is equipartitioned.</p>
<div id="ADXDB4399" class="example">
<p class="titleinexample"><a id="CHDFFICC"></a>Example 6-35 Using Different PARALLEL Degrees for XMLIndex Internal Objects</p>
<pre>
CREATE INDEX po_xmlindex_ix ON sale_info (sale_po_clob) INDEXTYPE IS XDB.XMLIndex 
  LOCAL PARAMETERS ('PATH TABLE po_path_table <span class="bold">(PARALLEL 10)</span>
                     PIKEY INDEX po_pikey_ix
                     VALUE INDEX po_value_ix <span class="bold">(PARALLEL 5)</span>') <span class="bold">NOPARALLEL</span>;
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDFFICC">Example 6-35</a>, the <code>XMLIndex</code> index itself is created serially, because of <code>NOPARALLEL</code>. The secondary index <code>po_pikey_ix</code> is also populated serially, because no parallelism is specified explicitly for it; it inherits the parallelism of the <code>XMLIndex</code> index. The path table itself is created with a parallelism degree of 10, and the secondary index value column, <code>po_value_ix</code>, is populated with a degree of 5, due to their explicit parallelism specifications.</p>
<p>Any parallelism you specify for an <code>XMLIndex</code> index, its path table, or its secondary indexes is exploited during subsequent DML operations and queries.</p>
<p>Note that there are two places where you can specify parallelism for <code>XMLIndex</code>: within the <code>PARAMETERS</code> clause parenthetical expression and after it.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01209" href="../../server.112/e41084/statements_5012.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a> for information on the <code>CREATE INDEX</code> parallel clause</p>
</li>
<li>
<p><a href="#CHDBGCCI">"PARAMETERS Clause for CREATE INDEX and ALTER INDEX"</a> for the syntax of the <code>PARAMETERS</code> clause</p>
</li>
<li>
<p><a href="#BCGFDCIG">"Structured and Unstructured XMLIndex Components"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDBCBHD"></a>
<div id="ADXDB4400" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Asynchronous (Deferred) Maintenance of XMLIndex Indexes</h3>
<p>This feature applies to an <code>XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component. If you specify asynchronous maintenance for an <code>XMLIndex</code> index that has a <span class="italic">structured</span> component, then an error is raised.</p>
<p>By default, <code>XMLIndex</code> indexing is updated (maintained) at each DML operation, so that it remains in sync with the base table. In some situations, you might not require this, and using possibly stale indexes might be acceptable. In that use case, you can decide to defer the cost of index maintenance, performing at commit time only or at some time when database load is reduced. This can improve DML performance. It can also improve index maintenance performance by enabling bulk loading of unsynchronized index rows when an index is synchronized.</p>
<p>Using a stale index has no effect, other than performance, on DML operations. It can have an effect on query results, however: If the index is not up-to-date at query time, then the query results might not be up-to-date either. Even if only one column of a base table is of data type <code>XMLType</code>, all queries on that table reflect the database data as of the last synchronization of the <code>XMLIndex</code> index on the <code>XMLType</code> column.</p>
<p>You can specify index maintenance deferment using the parameters clause of a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement.</p>
<p>Be aware that even if you defer synchronization for an <code>XMLIndex</code> index, the following database operations automatically synchronize the index:</p>
<ul>
<li>
<p>Any DDL operation on the index &ndash; <code>ALTER INDEX</code> or creation of secondary indexes</p>
</li>
<li>
<p>Any DDL operation on the base table &ndash; <code>ALTER TABLE</code> or creation of another index</p>
</li>
</ul>
<p><a href="#CHDBEJGA">Table 6-7</a> lists the synchronization options and the <code>ASYNC</code> clause syntax you use to specify them. The <code>ASYNC</code> clause is used in the <code>PARAMETERS</code> clause of a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement for <code>XMLIndex</code>.</p>
<div id="ADXDB4401" class="tblformal">
<p class="titleintable"><a id="sthref528"></a><a id="CHDBEJGA"></a>Table 6-7 Index Synchronization</p>
<table class="cellalignment1026" title="Index Synchronization" summary="Index Synchronization" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t41">When to Synchronize</th>
<th class="cellalignment1027" id="r1c2-t41">ASYNC Clause Syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t41" headers="r1c1-t41">
<p>Always</p>
</td>
<td class="cellalignment1028" headers="r2c1-t41 r1c2-t41">
<p><code>ASYNC (SYNC ALWAYS)</code></p>
<p>This is the default behavior. You can specify it explicitly, to cancel a previous <code>ASYNC</code> specification.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t41" headers="r1c1-t41">
<p>Upon commit</p>
</td>
<td class="cellalignment1028" headers="r3c1-t41 r1c2-t41">
<p><code>ASYNC (SYNC ON COMMIT)</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t41" headers="r1c1-t41">
<p>Periodically</p>
</td>
<td class="cellalignment1028" headers="r4c1-t41 r1c2-t41">
<p><code>ASYNC (SYNC EVERY "</code><code><span class="codeinlineitalic">repeat_interval</span></code><code>")</code></p>
<p><code><span class="codeinlineitalic">repeat_interval</span></code> is the same as for the calendaring syntax of <code>DBMS_SCHEDULER</code></p>
<p>To use <code>EVERY</code>, you must have the <code>CREATE JOB</code> privilege.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t41" headers="r1c1-t41">
<p>Manually, on demand</p>
</td>
<td class="cellalignment1028" headers="r5c1-t41 r1c2-t41">
<p><code>ASYNC (SYNC MANUAL)</code></p>
<p>You can manually synchronize the index using PL/SQL procedure <code>DBMS_XMLINDEX.SyncIndex</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Optional <code>ASYNC</code> syntax parameter <code>STALE</code> is intended for possible future use; you need never specify it explicitly. It has value <code>FALSE</code> whenever <code>ALWAYS</code> is used; otherwise it has value <code>TRUE</code>. Specifying an explicit <code>STALE</code> value that contradicts this rule raises an error.</p>
<p><a href="#CHDBCDJD">Example 6-36</a> creates an XMLIndex index that is synchronized every Monday at 3:00 pm, starting tomorrow.</p>
<div id="ADXDB4402" class="example">
<p class="titleinexample"><a id="CHDBCDJD"></a>Example 6-36 Specifying Deferred Synchronization for XMLIndex</p>
<pre>
CREATE INDEX po_xmlindex_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS XDB.XMLIndex
  PARAMETERS ('<span class="bold">ASYNC (SYNC EVERY "FREQ=HOURLY; INTERVAL = 1")</span>');
</pre></div>
<!-- class="example" -->
<p><a href="#CHDHIGIA">Example 6-37</a> manually synchronizes the index created in <a href="#CHDBCDJD">Example 6-36</a>.</p>
<div id="ADXDB4403" class="example">
<p class="titleinexample"><a id="CHDHIGIA"></a>Example 6-37 Manually Synchronizing an XMLIndex Index using SYNCINDEX</p>
<pre>
EXEC DBMS_XMLINDEX.SyncIndex('OE', 'PO_XMLINDEX_IX', REINDEX =&gt; TRUE);
</pre></div>
<!-- class="example" -->
<p>When <code>XMLIndex</code> index synchronization is deferred, all DML changes (inserts, updates, and deletions) made to the base table since the last index synchronization are recorded in a pending table, one row per DML operation. The name of this table is the value of column <code>PEND_TABLE_NAME</code> of static public views <code>USER_XML_INDEXES</code>, <code>ALL_XML_INDEXES</code>, and <code>DBA_XML_INDEXES</code>.</p>
<p>You can examine this table to determine when synchronization might be appropriate for a given <code>XMLIndex</code> index. The more rows there are in the pending table, the more the index is likely to be in need of synchronization.</p>
<p>If the pending table is large, then setting parameter <code>REINDEX</code> to <code>TRUE</code> when calling <code>SyncIndex</code>, as in <a href="#CHDHIGIA">Example 6-37</a>, can improve performance. When <code>REINDEX</code> is <code>TRUE</code>, all of the secondary indexes are dropped and then re-created after the pending table data is bulk-loaded.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS72263" href="../../appdev.112/e40758/d_sched.htm#ARPLS72263"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, section "Calendaring Syntax", for the syntax of <code><span class="codeinlineitalic">repeat_interval</span></code></p>
</li>
<li>
<p><a class="olink ARPLS212" href="../../appdev.112/e40758/d_xmlindex.htm#ARPLS212"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information on PL/SQL procedure <code>DBMS_XMLINDEX.SyncIndex</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDCEIFC"></a>
<div id="ADXDB4404" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Collecting Statistics on XMLIndex Objects for the Cost-Based Optimizer</h3>
<p>The Oracle Database cost-based optimizer determines how to most cost-effectively evaluate a given query, including which indexes, if any, to use. For it to be able to do this accurately, you must collect statistics on various database objects.</p>
<p>For <code>XMLIndex</code>, you normally need to collect statistics on only the base table on which the <code>XMLIndex</code> index is defined (using, for example, procedure <code>DBMS_STATS.gather_table_stats</code>). This automatically collects statistics for the <code>XMLIndex</code> index itself, as well as the path table, its secondary indexes, and any structured component content tables and their secondary indexes.</p>
<p>If you delete statistics on the base table (using procedure <code>DBMS_STATS.delete_table_stats</code>), then statistics on the other objects are also deleted. Similarly, if you collect statistics on the <code>XMLIndex</code> index (using procedure <code>DBMS_STATS.gather_index_stats</code>), then statistics are also collected on the path table, its secondary indexes, and any structured component content tables and their secondary indexes.</p>
<p><a href="#CHDEHFDF">Example 6-38</a> collects statistics on the base table <code>po_clob</code>. Statistics are automatically collected on the <code>XMLIndex</code> index, its path table, and the secondary path-table indexes.</p>
<div id="ADXDB4405" class="example">
<p class="titleinexample"><a id="CHDEHFDF"></a>Example 6-38 Automatic Collection of Statistics on XMLIndex Objects</p>
<pre>
CALL DBMS_STATS.gather_table_stats(USER, 'PO_CLOB', ESTIMATE_PERCENT =&gt; NULL);
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDEJEGH">"Data Dictionary Static Public Views Related to XMLIndex"</a> for information about database views that record statistics information for an <code>XMLIndex</code> index</div>
</div>
<!-- class="sect2" -->
<a id="CHDEJEGH"></a>
<div id="ADXDB4334" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Data Dictionary Static Public Views Related to XMLIndex</h3>
<p>Information about the standard database indexes is available in static public views <code>USER_INDEXES</code>, <code>ALL_INDEXES</code>, and <code>DBA_INDEXES</code>. Similar information about <code>XMLIndex</code> indexes is available in static public views <code>USER_XML_INDEXES</code>, <code>ALL_XML_INDEXES</code>, and <code>DBA_XML_INDEXES</code>.</p>
<p><a href="#CHDGHHAB">Table 6-8</a> describes the columns in each of these views.</p>
<div id="ADXDB4335" class="tblformal">
<p class="titleintable"><a id="sthref529"></a><a id="CHDGHHAB"></a>Table 6-8 XMLIndex Static Public Views</p>
<table class="cellalignment1026" title="XMLIndex Static Public Views" summary="XMLIndex Public Views" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t44">Column Name</th>
<th class="cellalignment1027" id="r1c2-t44">Type</th>
<th class="cellalignment1027" id="r1c3-t44">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t44" headers="r1c1-t44">
<p><code>ASYNC</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t44 r1c3-t44">
<p>Asynchronous index updating specification. See <a href="#CHDBCBHD">"Asynchronous (Deferred) Maintenance of XMLIndex Indexes"</a>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t44" headers="r1c1-t44">
<p><code>EX_OR_INCLUDE</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t44 r1c3-t44">
<p>Path subsetting:</p>
<ul>
<li>
<p><code>FULLY_IX</code> &ndash; The index uses no path subsetting.</p>
</li>
<li>
<p><code>EXCLUDE</code> &ndash; The index uses only exclusion subsetting.</p>
</li>
<li>
<p><code>INCLUDE</code> &ndash; The index uses only inclusion subsetting.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t44" headers="r1c1-t44">
<p><code>INDEX_NAME</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t44 r1c3-t44">
<p>Name of the <code>XMLIndex</code> index.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t44" headers="r1c1-t44">
<p><code>INDEX_OWNER</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t44 r1c3-t44">
<p>Owner of the index. Not available for <code>USER_XML_INDEXES</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t44" headers="r1c1-t44">
<p><code>INDEX_TYPE</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t44 r1c3-t44">
<p>The types of components the index is composed of: <code>STRUCTURED</code>, <code>UNSTRUCTURED</code>, or <code>STRUCTURED AND UNSTRUCTURED</code>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t44" headers="r1c1-t44">
<p><code>PARAMETERS</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t44 r1c2-t44">
<p><code>XMLType</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t44 r1c3-t44">
<p>Information from the <code>PARAMETERS</code> clause that was used to create the index.</p>
<p>If an unstructured <code>XMLIndex</code> component is present, the <code>PARAMETERS</code> clause can include the set of XPath paths defining path-subsetting and the name of a scheduler job for synchronization.</p>
<p>If a structured component is present, the <code>PARAMETERS</code> clause includes the name of the structure group and the table definitions provided by <code>XMLTable</code>, including the XQuery expressions that define the columns.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t44" headers="r1c1-t44">
<p><code>PATH_TABLE_NAME</code></p>
</td>
<td class="cellalignment1028" headers="r8c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r8c1-t44 r1c3-t44">
<p>Name of the <code>XMLIndex</code> path table.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r9c1-t44" headers="r1c1-t44">
<p><code>PEND_TABLE_NAME</code></p>
</td>
<td class="cellalignment1028" headers="r9c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r9c1-t44 r1c3-t44">
<p>Name of the table that records base-table DML operations since the last index synchronization. See <a href="#CHDBCBHD">"Asynchronous (Deferred) Maintenance of XMLIndex Indexes"</a>.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r10c1-t44" headers="r1c1-t44">
<p><code>TABLE_NAME</code></p>
</td>
<td class="cellalignment1028" headers="r10c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r10c1-t44 r1c3-t44">
<p>Name of the base table on which the index is defined.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r11c1-t44" headers="r1c1-t44">
<p><code>TABLE_OWNER</code></p>
</td>
<td class="cellalignment1028" headers="r11c1-t44 r1c2-t44">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment1028" headers="r11c1-t44 r1c3-t44">
<p>Owner of the base table on which the index is defined.</p>
</td>
</tr>
<tr class="cellalignment1020">
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>These views provide information about an <code>XMLIndex</code> index, but there is no single catalog view that provides information about the statistics gathered for an <code>XMLIndex</code> index. This statistics information is distributed among the following views:</p>
<ul>
<li>
<p><code>USER_INDEXES</code>, <code>ALL_INDEXES</code>, <code>DBA_INDEXES</code> &ndash; Column <code>LAST_ANALYZED</code> provides the date when the <code>XMLIndex</code> index was last analyzed.</p>
</li>
<li>
<p><code>USER_TAB_STATISTICS</code>, <code>ALL_TAB_STATISTICS</code>, <code>DBA_TAB_STATISTICS</code> &ndash; Column <code>TABLE_NAME</code> provides information about the structured and unstructured components of an <code>XMLIndex</code> index. For information about the structured or unstructured component, query using the name of the path table or the <code>XMLTable</code> table as <code>TABLE_NAME</code>, respectively.</p>
</li>
<li>
<p><code>USER_IND_STATISTICS</code>, <code>ALL_IND_STATISTICS</code>, <code>DBA_IND_STATISTICS</code> &ndash; Column <code>INDEX_NAME</code> provides information about each of the secondary indexes for an <code>XMLIndex</code> index. for information about a given secondary index, query using the name of that secondary index as <code>INDEX_NAME</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDBGCCI"></a>
<div id="ADXDB4406" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">PARAMETERS Clause for CREATE INDEX and ALTER INDEX</h3>
<p>This section describes the usage and syntax of the <code>PARAMETERS</code> clause for SQL statements <code>CREATE INDEX</code> and <code>ALTER INDEX</code> when used with <code>XMLIndex</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF20021" href="../../server.112/e41084/statements_5012.htm#SQLRF20021"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <code><span class="codeinlineitalic">index_attributes</span></code></p>
</li>
<li>
<p><a class="olink SQLRF20022" href="../../server.112/e41084/statements_7002.htm#SQLRF20022"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <code><span class="codeinlineitalic">segment_attributes_clause</span></code></p>
</li>
<li>
<p><a class="olink SQLRF20023" href="../../server.112/e41084/statements_7002.htm#SQLRF20023"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <code><span class="codeinlineitalic">table_properties</span></code></p>
</li>
<li>
<p><a class="olink SQLRF20024" href="../../server.112/e41084/clauses006.htm#SQLRF20024"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of <code><span class="codeinlineitalic">parallel_clause</span></code></p>
</li>
<li>
<p><a class="olink SQLRF01209" href="../../server.112/e41084/statements_5012.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about the syntax and semantics of <code>CREATE INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF00805" href="../../server.112/e41084/statements_1010.htm#SQLRF00805"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about the syntax and semantics of <code>ALTER INDEX</code></p>
</li>
<li>
<p><a class="olink ARPLS72263" href="../../appdev.112/e40758/d_sched.htm#ARPLS72263"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>, section "Calendaring Syntax", for the syntax of <code><span class="codeinlineitalic">repeat_interval</span></code></p>
</li>
</ul>
</div>
<a id="BCGBHGJB"></a>
<div id="ADXDB4407" class="sect3">
<h4 class="sect3">Using a Registered <a id="sthref530"></a><a id="sthref531"></a><a id="sthref532"></a>PA<a id="sthref533"></a><a id="sthref534"></a><a id="sthref535"></a>RAMETERS Clause for XMLIndex</h4>
<p>The string value used for the <code>PARAMETERS</code> clause of a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement has a 1000-character limit. To get around this limitation, you can use PL/SQL procedures <code>registerParameter</code> and <code>modifyParameter</code> in package <code>DBMS_XMLINDEX</code>.</p>
<p>For each of these procedures, you provide a string of parameters (unlimited in length) and an identifier under which the string is registered. Then, in the index <code>PARAMETERS</code> clause, you provide the identifier preceded by the keyword <code>PARAM</code>, instead of a literal string.</p>
<p>The identifier must already have been registered before you can use it in a <code>CREATE INDEX</code> or <code>ALTER INDEX</code> statement.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDB4408" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref536"></a>
<h4 class="sect3">PARAMETERS Clause Syntax for CREATE INDEX and ALTER INDEX</h4>
<p class="subhead2"><a id="ADXDB4409"></a><span class="italic">XMLIndex_parameters_clause ::=</span></p>
<img width="412" height="58" src="img/xmlindex_parameters_clause.gif" alt="Description of xmlindex_parameters_clause.gif follows" /><br />
<a id="sthref537" href="img_text/xmlindex_parameters_clause.htm">Description of the illustration xmlindex_parameters_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGCEBIJ">"Usage of XMLIndex_parameters_clause"</a></div>
<p class="subhead2"><a id="ADXDB4410"></a><span class="italic">XMLIndex_parameters ::=</span></p>
<img width="225" height="39" src="img/xmlindex_parameters.gif" alt="Description of xmlindex_parameters.gif follows" /><br />
<a id="sthref538" href="img_text/xmlindex_parameters.htm">Description of the illustration xmlindex_parameters.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGGDFFF">"Usage of XMLIndex_parameters"</a></div>
<p class="subhead2"><a id="ADXDB4411"></a><span class="italic">XMLIndex_parameter_clause ::=</span></p>
<img width="178" height="91" src="img/xmlindex_parameter_clause.gif" alt="Description of xmlindex_parameter_clause.gif follows" /><br />
<a id="sthref539" href="img_text/xmlindex_parameter_clause.htm">Description of the illustration xmlindex_parameter_clause.gif</a><br />
<br />
<p class="subhead2"><a id="BCGEJHBG"></a><a id="ADXDB5832"></a><span class="italic">unstructured_clause ::=</span></p>
<img width="378" height="251" src="img/unstructured_clause.gif" alt="Description of unstructured_clause.gif follows" /><br />
<a id="sthref540" href="img_text/unstructured_clause.htm">Description of the illustration unstructured_clause.gif</a><br />
<br />
<p class="subhead2"><a id="BCGJAHHA"></a><a id="ADXDB4412"></a><span class="italic">create_index_paths_clause ::=</span></p>
<img width="553" height="64" src="img/create_index_paths_clause.gif" alt="Description of create_index_paths_clause.gif follows" /><br />
<a id="sthref541" href="img_text/create_index_paths_clause.htm">Description of the illustration create_index_paths_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGGBEEB">"Usage of PATHS Clause"</a></p>
</li>
<li>
<p><a href="#BCGEHFGD">"Usage of create_index_paths_clause and alter_index_paths_clause"</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="BCGFAECD"></a><a id="ADXDB4413"></a><span class="italic">alter_index_paths_clause ::=</span></p>
<img width="690" height="95" src="img/alter_index_paths_clause.gif" alt="Description of alter_index_paths_clause.gif follows" /><br />
<a id="sthref542" href="img_text/alter_index_paths_clause.htm">Description of the illustration alter_index_paths_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGGBEEB">"Usage of PATHS Clause"</a></p>
</li>
<li>
<p><a href="#BCGEHFGD">"Usage of create_index_paths_clause and alter_index_paths_clause"</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="ADXDB4414"></a><span class="italic">namespace_mapping_clause ::=</span></p>
<img width="371" height="39" src="img/namespace_mapping_clause.gif" alt="Description of namespace_mapping_clause.gif follows" /><br />
<a id="sthref543" href="img_text/namespace_mapping_clause.htm">Description of the illustration namespace_mapping_clause.gif</a><br />
<br />
<p class="subhead2"><a id="BCGJAGCI"></a><a id="ADXDB4415"></a><span class="italic">path_table_clause ::=</span></p>
<img width="629" height="48" src="img/path_table_clause.gif" alt="Description of path_table_clause.gif follows" /><br />
<a id="sthref544" href="img_text/path_table_clause.htm">Description of the illustration path_table_clause.gif</a><br />
<br />
<p class="subhead2"><a id="ADXDB5833"></a><span class="italic">pikey_clause ::=</span></p>
<img width="515" height="67" src="img/pikey_clause.gif" alt="Description of pikey_clause.gif follows" /><br />
<a id="sthref545" href="img_text/pikey_clause.htm">Description of the illustration pikey_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGCBEBE">"Usage of pikey_clause, path_id_clause, and order_key_clause"</a></div>
<p class="subhead2"><a id="ADXDB4416"></a><span class="italic">path_id_clause ::=</span></p>
<img width="548" height="67" src="img/path_id_clause.gif" alt="Description of path_id_clause.gif follows" /><br />
<a id="sthref546" href="img_text/path_id_clause.htm">Description of the illustration path_id_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGCBEBE">"Usage of pikey_clause, path_id_clause, and order_key_clause"</a></div>
<p class="subhead2"><a id="ADXDB4417"></a><span class="italic">order_key_clause ::=</span></p>
<img width="570" height="67" src="img/order_key_clause.gif" alt="Description of order_key_clause.gif follows" /><br />
<a id="sthref547" href="img_text/order_key_clause.htm">Description of the illustration order_key_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGCBEBE">"Usage of pikey_clause, path_id_clause, and order_key_clause"</a></div>
<p class="subhead2"><a id="ADXDB4418"></a><span class="italic">value_clause ::=</span></p>
<img width="518" height="67" src="img/value_clause.gif" alt="Description of value_clause.gif follows" /><br />
<a id="sthref548" href="img_text/value_clause.htm">Description of the illustration value_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGFGFBA">"Usage of value_clause"</a></div>
<p class="subhead2"><a id="BCGGGBCB"></a><a id="ADXDB5834"></a><span class="italic">drop_path_table_clause ::=</span></p>
<img width="195" height="27" src="img/drop_path_table_clause.gif" alt="Description of drop_path_table_clause.gif follows" /><br />
<a id="sthref549" href="img_text/drop_path_table_clause.htm">Description of the illustration drop_path_table_clause.gif</a><br />
<br />
<p class="subhead2"><a id="ADXDB4419"></a><span class="italic">parallel_clause ::=</span></p>
<img width="241" height="79" src="img/parallel_clause.gif" alt="Description of parallel_clause.gif follows" /><br />
<a id="sthref550" href="img_text/parallel_clause.htm">Description of the illustration parallel_clause.gif</a><br />
<br />
<p class="subhead2"><a id="BCGFGBEB"></a><a id="ADXDB4420"></a><span class="italic">structured_clause ::=</span></p>
<img width="206" height="58" src="img/structured_clause.gif" alt="Description of structured_clause.gif follows" /><br />
<a id="sthref551" href="img_text/structured_clause.htm">Description of the illustration structured_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGEEBED">"Usage of groups_clause and alter_index_group_clause"</a></div>
<p class="subhead2"><a id="ADXDB5835"></a><span class="italic">async_clause ::=</span></p>
<img width="661" height="128" src="img/async_clause.gif" alt="Description of async_clause.gif follows" /><br />
<a id="sthref552" href="img_text/async_clause.htm">Description of the illustration async_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGJDBBG">"Usage of async_clause"</a></div>
<p class="subhead2"><a id="BCGHGCCH"></a><a id="ADXDB4421"></a><span class="italic">groups_clause ::=</span></p>
<img width="143" height="39" src="img/groups_clause.gif" alt="Description of groups_clause.gif follows" /><br />
<a id="sthref553" href="img_text/groups_clause.htm">Description of the illustration groups_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGEEBED">"Usage of groups_clause and alter_index_group_clause"</a></div>
<p class="subhead2"><a id="ADXDB4422"></a><span class="italic">group_clause ::=</span></p>
<img width="367" height="46" src="img/group_clause.gif" alt="Description of group_clause.gif follows" /><br />
<a id="sthref554" href="img_text/group_clause.htm">Description of the illustration group_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGEEBED">"Usage of groups_clause and alter_index_group_clause"</a></div>
<p class="subhead2"><a id="CEGJCAJF"></a><a id="ADXDB4423"></a><span class="italic">XMLIndex_xmltable_clause ::=</span></p>
<img width="550" height="211" src="img/xmlindex_xmltable_clause.gif" alt="Description of xmlindex_xmltable_clause.gif follows" /><br />
<a id="sthref555" href="img_text/xmlindex_xmltable_clause.htm">Description of the illustration xmlindex_xmltable_clause.gif</a><br />
<br />
<p>Syntax elements <span class="syntaxinline">XML_namespaces_clause</span> and <span class="syntaxinline">XQuery_string</span> are the same as for SQL/XML function <code>XMLTable</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGGCCJB">"Usage of XMLIndex_xmltable_clause"</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#BABJCHCC">"XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB"</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="ADXDB4424"></a><span class="italic">column_clause ::=</span></p>
<img width="412" height="79" src="img/column_clause.gif" alt="Description of column_clause.gif follows" /><br />
<a id="sthref556" href="img_text/column_clause.htm">Description of the illustration column_clause.gif</a><br />
<br />
<p>Syntax element <span class="syntaxinline">column_clause</span> is similar, but not identical, to <span class="syntaxinline">XML_table_column</span> in SQL/XML function <code>XMLTable</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BCGJCCFG">"Usage of column_clause"</a></p>
</li>
<li>
<p><a href="xdb_xquery.htm#BABJCHCC">"XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB"</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="BCGJAAGH"></a><a id="ADXDB4425"></a><span class="italic">alter_index_group_clause ::=</span></p>
<img width="371" height="175" src="img/alter_index_group_clause.gif" alt="Description of alter_index_group_clause.gif follows" /><br />
<a id="sthref557" href="img_text/alter_index_group_clause.htm">Description of the illustration alter_index_group_clause.gif</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGEEBED">"Usage of groups_clause and alter_index_group_clause"</a></div>
<p class="subhead2"><a id="ADXDB4426"></a><span class="italic">add_column_clause :==</span></p>
<img width="254" height="27" src="img/add_column_clause.gif" alt="Description of add_column_clause.gif follows" /><br />
<a id="sthref558" href="img_text/add_column_clause.htm">Description of the illustration add_column_clause.gif</a><br />
<br />
<p class="subhead2"><a id="ADXDB4427"></a><span class="italic">add_column_options :==</span></p>
<img width="803" height="58" src="img/add_column_options.gif" alt="Description of add_column_options.gif follows" /><br />
<a id="sthref559" href="img_text/add_column_options.htm">Description of the illustration add_column_options.gif</a><br />
<br />
<p>Syntax element <span class="syntaxinline">XML_namespaces_clause</span> is the same as for SQL/XML function <code>XMLTable</code>. See <a href="xdb_xquery.htm#BABJCHCC">"XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB"</a>.</p>
<p class="subhead2"><a id="ADXDB4428"></a><span class="italic">drop_column_clause :==</span></p>
<img width="268" height="27" src="img/drop_column_clause.gif" alt="Description of drop_column_clause.gif follows" /><br />
<a id="sthref560" href="img_text/drop_column_clause.htm">Description of the illustration drop_column_clause.gif</a><br />
<br />
<p class="subhead2"><a id="ADXDB4429"></a><span class="italic">drop_column_options :==</span></p>
<img width="539" height="58" src="img/drop_column_options.gif" alt="Description of drop_column_options.gif follows" /><br />
<a id="sthref561" href="img_text/drop_column_options.htm">Description of the illustration drop_column_options.gif</a><br />
<br /></div>
<!-- class="sect3" -->
<a id="BCGCEBIJ"></a>
<div id="ADXDB4430" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of XMLIndex_parameters_clause</h4>
<p>When you create an <code>XMLIndex</code> index, if there is no <code><span class="codeinlineitalic">XMLIndex_parameters_clause</span></code>, then the new index has only an unstructured component. If there is an <code><span class="codeinlineitalic">XMLIndex_parameters_clause</span></code>, but the <code>PARAMETERS</code> argument is empty (<code>''</code>), then the result is the same: an index with only an unstructured component.</p>
</div>
<!-- class="sect3" -->
<a id="BCGGDFFF"></a>
<div id="ADXDB4431" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of XMLIndex_parameters</h4>
<p>The following considerations apply to using <code><span class="codeinlineitalic">XMLIndex_parameters</span></code>.</p>
<ul>
<li>
<p>There can be at most one <code><span class="codeinlineitalic">XMLIndex_parameter_clause</span></code> of each type in <code><span class="codeinlineitalic">XMLIndex_parameters</span></code>. For example, there can be at most one <code>PATHS</code> clause, at most one <code><span class="codeinlineitalic">path_table_clause</span></code>, and so on.</p>
</li>
<li>
<p>If there is no <code><span class="codeinlineitalic">structured_clause</span></code> when you create an <code>XMLIndex</code> index, then the new index has only an unstructured component. If there is only a <code><span class="codeinlineitalic">structured_clause</span></code>, then the new index has only a structured component.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGGBEEB"></a>
<div id="ADXDB4433" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of PATHS Clause</h4>
<p>The following considerations apply to using the <code>PATHS</code> clause.</p>
<ul>
<li>
<p>There can be at most one <code>PATHS</code> clause in a <code>CREATE INDEX</code> statement. That is, there can be at most one occurrence of <code>PATHS</code> followed by <code><span class="codeinlineitalic">create_index_paths_clause</span></code>.</p>
</li>
<li>
<p>Clause <code><span class="codeinlineitalic">create_index_paths_clause</span></code> is used only with <code>CREATE INDEX</code>; <code><span class="codeinlineitalic">alter_index_paths_clause</span></code> is used only with <code>ALTER INDEX</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGEHFGD"></a>
<div id="ADXDB4434" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of create_index_paths_clause and alter_index_paths_clause</h4>
<p>The following considerations apply to using <code><span class="codeinlineitalic">create_index_paths_clause</span></code> and <code><span class="codeinlineitalic">alter_index_paths_clause</span></code>.</p>
<ul>
<li>
<p>The <code>INDEX_ALL_PATHS</code> keyword rebuilds the index to include all paths. This keyword is available only for <code><span class="codeinlineitalic">alter_index_paths_clause</span></code>, not <code><span class="codeinlineitalic">create_index_paths_clause</span></code>.</p>
</li>
<li>
<p>An explicit list of paths to index can include wildcards and <code>//</code>.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">XPaths_list</span></code> is a list of one or more XPath expressions, each of which includes only child axis, descendant axis, name test, and wildcard (<code>*</code>) constructs.</p>
</li>
<li>
<p>If <code><span class="codeinlineitalic">XPaths_list</span></code> is omitted from <code><span class="codeinlineitalic">create_index_paths_clause</span></code>, all paths are indexed.</p>
</li>
<li>
<p>For each unique namespace prefix that is used in an XPath expression in <code><span class="codeinlineitalic">XPaths_list</span></code>, a standard XML <code><span class="codeinlineitalic">namespace</span></code> declaration is needed, to provide the corresponding namespace information.</p>
</li>
<li>
<p>You can change an index in ways that are not reflected directly in the syntax by dropping it and then creating it again as needed. For example, to change an index that was defined by including paths to one that is defined by excluding paths, drop it and then create it using <code>EXCLUDE</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGCBEBE"></a>
<div id="ADXDB5939" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of pikey_clause, path_id_clause, and order_key_clause</h4>
<p>Syntactically, each of the clauses <code>pikey_clause</code>, <code>path_id_clause</code>, and <code>order_key_clause</code> is optional. A pikey index is created even if you do not specify a <code>pikey_clause</code>. To create a path id index or an order-key index, you must specify a <code>path_id_clause</code> or an <code>order_key_clause</code>, respectively.</p>
</div>
<!-- class="sect3" -->
<a id="BCGFGFBA"></a>
<div id="ADXDB4435" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of value_clause</h4>
<p>The following considerations apply to using <code><span class="codeinlineitalic">value_clause</span></code>.</p>
<ul>
<li>
<p>Column <code>VALUE</code> is created as <code>VARCHAR2(4000)</code>.</p>
</li>
<li>
<p>If clause <code><span class="codeinlineitalic">value_clause</span></code> consists only of the keyword <code>VALUE</code>, then the value index is created with the usual default attributes.</p>
</li>
<li>
<p>If clause <code><span class="codeinlineitalic">path_id_clause</span></code> consists only of the keywords <code>PATH ID</code>, then the path-id index is created with the usual default attributes.</p>
</li>
<li>
<p>If clause <code><span class="codeinlineitalic">order_key_clause</span></code> consists only of the keywords <code>ORDER KEY</code>, then the order-key index is created with the usual default attributes.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGJDBBG"></a>
<div id="ADXDB4436" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of async_clause</h4>
<p>The following considerations apply to using the <code>ASYNC</code> clause.</p>
<ul>
<li>
<p>Use this feature only with an <code>XMLIndex</code> index that has <span class="italic">only</span> an <span class="italic">unstructured</span> component. If you specify an <code>ASYNC</code> clause for an <code>XMLIndex</code> index that has a <span class="italic">structured</span> component, then an error is raised.</p>
</li>
<li>
<p><code>ALWAYS</code> means automatic synchronization occurs for each DML statement.</p>
</li>
<li>
<p><code>MANUAL</code> means no automatic synchronization occurs. You must manually synchronize the index using <code>DBMS_XMLINDEX.SyncIndex</code>.</p>
</li>
<li>
<p><code>EVERY</code> <code><span class="codeinlineitalic">repeat_interval</span></code> means automatically synchronize the index at interval <code><span class="codeinlineitalic">repeat_interval</span></code>. The syntax of <code><span class="codeinlineitalic">repeat_interval</span></code> is the same as that for PL/SQL package <code>DBMS_SCHEDULER</code>, and it must be enclosed in double-quotes (<code>"</code>). To use <code>EVERY</code> you must have the <code>CREATE JOB</code> privilege.</p>
</li>
<li>
<p><code>ON COMMIT</code> means synchronize the index immediately after a commit operation. The commit does not return until the synchronization is complete. Since the synchronization is performed as a separate transaction, there can be a short period when the data is committed but index changes are not yet committed.</p>
</li>
<li>
<p><code>STALE</code> is optional. A value of <code>TRUE</code> means that query results might be stale; a value of <code>FALSE</code> means that query results are always up-to-date. The default value, and the only permitted explicitly specified value, is as follows.</p>
<ul>
<li>
<p>For <code>ALWAYS</code>, <code>STALE</code> is <code>TRUE</code>.</p>
</li>
<li>
<p>For any other <code>ASYNC</code> option besides <code>ALWAYS</code>, <code>STALE</code> is <code>FALSE</code>.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGEEBED"></a>
<div id="ADXDB4437" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of groups_clause and alter_index_group_clause</h4>
<p>Clause <code><span class="codeinlineitalic">groups_clause</span></code> is used only with <code>CREATE INDEX</code>; clause <code><span class="codeinlineitalic">alter_index_group_clause</span></code> is used only with <code>ALTER INDEX</code>.</p>
</div>
<!-- class="sect3" -->
<a id="BCGGCCJB"></a>
<div id="ADXDB4438" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of XMLIndex_xmltable_clause</h4>
<p>The following considerations apply to using <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code>.</p>
<ul>
<li>
<p>The <code><span class="codeinlineitalic">XQuery_string</span></code> expression in <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code> must not use the XQuery functions <code>ora:view</code> (deprecated), <code>fn:doc</code>, or <code>fn:collection</code>.</p>
</li>
<li>
<p>Oracle XML&nbsp;DB raises an error if a given <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code> contains more than one <code><span class="codeinlineitalic">column_clause</span></code> of data type <code>XMLType</code>. To achieve the effect of defining two such virtual columns, you must instead add a separate <code><span class="codeinlineitalic">group_clause</span></code>.</p>
</li>
<li>
<p>The <code>PASSING</code> clause in <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code> is optional. If not present, then an <code>XMLType</code> column is passed implicitly, as follows:</p>
<ul>
<li>
<p>For the first <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code> in a parameters clause, the <code>XMLType</code> column being indexed is passed implicitly. (When indexing an <code>XMLType</code> table, pseudocolumn <code>OBJECT_VALUE</code> is passed.)</p>
</li>
<li>
<p>For each subsequent <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code>, the <code>VIRTUAL</code> <code>XMLType</code> column of the preceding <code><span class="codeinlineitalic">XMLIndex_xmltable_clause</span></code> is passed implicitly.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGJCCFG"></a>
<div id="ADXDB4439" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Usage of column_clause</h4>
<p>When you use multilevel chaining of <code>XMLTable</code> in an <code>XMLIndex</code> index, the <code>XMLTable</code> table at one level corresponds to an <code>XMLType</code> column at the previous level. The syntax description shows keyword <code>VIRTUAL</code> as optional. In fact, it is used only for such an <code>XMLType</code> column, in which case it is <span class="italic">required</span>. It is an error to use it for a non-<code>XMLType</code> column. <code>VIRTUAL</code> specifies that the <code>XMLType</code> column itself is not materialized, meaning that its data is stored in the index only in the form of the relational columns specified by its corresponding <code>XMLTable</code> table.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDHECG"></a>
<div id="ADXDB4442" class="sect1">
<h2 class="sect1">Oracle Text <a id="sthref562"></a><a id="sthref563"></a>Indexes on XML Data</h2>
<p>You can create an Oracle Text index on an <code>XMLType</code> column. An Oracle Text <code>CONTEXT</code> index enables Oracle SQL function <code>contains</code> for full-text search over XML. With structured storage, XPath rewrite can often rewrite XPath function <code>ora:contains</code> to SQL function <code>contains</code>, so in those cases too an Oracle Text index can be employed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb09sea.htm#i1006756">Chapter 12, "Full-Text Search Over XML Data"</a> for more information about using Oracle Text operations with Oracle XML&nbsp;DB</p>
</li>
<li>
<p><a href="#BCGDEHEA">Example 6-23, "Oracle Text CONTEXT Index on an XMLIndex Index Content Table"</a></p>
</li>
</ul>
</div>
<a id="CHDDBHEF"></a>
<div id="ADXDB4443" class="sect2">
<h3 class="sect2">Creating and Using Oracle Text Indexes</h3>
<p>To create an Oracle Text index, use <code>CREATE INDEX</code>, specifying the <code>INDEXTYPE</code> as <code>CTXSYS.CONTEXT</code>, as illustrated in <a href="#CHDIDGCD">Example 6-39</a>.</p>
<div id="ADXDB4444" class="example">
<p class="titleinexample"><a id="CHDIDGCD"></a>Example 6-39 Creating an Oracle Text Index</p>
<pre>
CREATE INDEX po_otext_ix ON po_clob (OBJECT_VALUE) INDEXTYPE IS CTXSYS.CONTEXT;
</pre></div>
<!-- class="example" -->
<p>You can also perform Oracle Text operations such as <code>contains</code> and <code>score</code> on <code>XMLType</code> columns. <a href="#CHDIBBDC">Example 6-40</a> shows an Oracle Text search using Oracle SQL function <code>contains</code>.</p>
<div id="ADXDB4445" class="example">
<p class="titleinexample"><a id="CHDIBBDC"></a>Example 6-40 Searching XML Data using SQL Function CONTAINS</p>
<pre>
SELECT DISTINCT XMLCast(XMLQuery('$p/PurchaseOrder/ShippingInstructions/address'
                                 PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
                        AS VARCHAR2(256)) "Address"
  FROM po_clob po
  WHERE <span class="bold">contains</span>(po.OBJECT_VALUE,
                 '$(Fortieth) INPATH (PurchaseOrder/ShippingInstructions/address)') &gt; 0;
 
Address
------------------------------
1200 East Forty Seventh Avenue
New York
NY
10024
USA
 
1 row selected.
</pre>
<p>The execution plan for this query shows two ways that the Oracle Text <code>CONTEXT</code> index is used:</p>
<ul>
<li>
<p>It references the index explicitly, as a domain index.</p>
</li>
<li>
<p>It refers to Oracle SQL function <code>contains</code> in the predicate information.</p>
</li>
</ul>
<pre>
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------
Plan hash value: 274475732
 
--------------------------------------------------------------------------------------------
| Id  | Operation                    | Name        | Rows  | Bytes | Cost (%CPU)| Time     |
--------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |             |     7 | 14098 |    10  (10)| 00:00:01 |
|   1 |  HASH UNIQUE                 |             |     7 | 14098 |    10  (10)| 00:00:01 |
|   2 |   TABLE ACCESS BY INDEX ROWID| PO_CLOB     |     7 | 14098 |     9   (0)| 00:00:01 |
|*  3 |    DOMAIN INDEX              | <span class="bold">PO_OTEXT_IX</span> |       |       |     4   (0)| 00:00:01 |
--------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------

   3 - access("CTXSYS"."<span class="bold">CONTAINS</span>"(SYS_MAKEXML('2B0A2483AB140B35E040578C8A173FEC',523
              3,"XMLDATA"),'$(Fortieth) INPATH (PurchaseOrder/ShippingInstructions/address)')&gt;0)
 
20 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDHCDHH"></a>
<div id="ADXDB4446" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle Text Indexes Are Used Independently of Other Indexes</h3>
<p>Oracle Text indexing is completely orthogonal to the other types of indexing described in this chapter. Whenever Oracle SQL function <code>contains</code> or XPath function <code>ora:contains</code> is used, an Oracle Text index can be used for full-text search.</p>
<p><a href="#CHDEJJBG">Example 6-41</a> demonstrates this in the case where both an <code>XMLIndex</code> index and an Oracle Text index are defined on the same XML data. The query is the same as in <a href="#CHDIBBDC">Example 6-40</a>. The Oracle Text index is created on the <code>VALUE</code> column of the <code>XMLIndex</code> path table of <a href="#CHDJCDCF">Example 6-9</a>.</p>
<div id="ADXDB4447" class="example">
<p class="titleinexample"><a id="CHDEJJBG"></a>Example 6-41 Using an Oracle Text Index and an XMLIndex Index</p>
<pre>
CREATE INDEX po_otext_ix ON <span class="bold">my_path_table</span> (<span class="bold">VALUE</span>) INDEXTYPE IS CTXSYS.CONTEXT;

EXPLAIN PLAN FOR
  SELECT DISTINCT XMLCast(XMLQuery('$p/PurchaseOrder/ShippingInstructions/address'
                                   PASSING po.OBJECT_VALUE AS "p" RETURNING CONTENT)
                          AS VARCHAR2(256)) "Address"
    FROM po_clob po
    WHERE <span class="bold">contains</span>(po.OBJECT_VALUE,
                   '$(Fortieth) INPATH (PurchaseOrder/ShippingInstructions/address)') &gt; 0;

-------------------------------------------------------------------------------------------------------------
| Id  | Operation                    | Name                         | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                              |     7 | 14098 |     3  (34)| 00:00:01 |
|   1 |  SORT GROUP BY               |                              |     1 |  3524 |            |          |
|*  2 |   TABLE ACCESS BY INDEX ROWID| <span class="bold">MY_PATH_TABLE</span>                |     2 |  7048 |     3   (0)| 00:00:01 |
|*  3 |    INDEX RANGE SCAN          | <span class="bold">SYS67616_PO_XMLINDE_PIKEY_IX</span> |     1 |       |     2   (0)| 00:00:01 |
|   4 |  HASH UNIQUE                 |                              |     7 | 14098 |     3  (34)| 00:00:01 |
|*  5 |   TABLE ACCESS FULL          | PO_CLOB                      |     7 | 14098 |     2   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(SYS_XMLI_LOC_ISNODE("SYS_P0"."LOCATOR")=1)
   3 - access("SYS_P0"."RID"=:B1 AND "SYS_P0"."PATHID"=HEXTORAW('6F7F') )
   5 - filter("CTXSYS"."<span class="bold">CONTAINS</span>"(SYS_MAKEXML(0,"SYS_ALIAS_1"."XMLDATA"),'$(Fortieth) INPATH
              (PurchaseOrder/ShippingInstructions/address)')&gt;0)
 
Note
-----
   - dynamic sampling used for this statement (level=2)
   - Unoptimized XML construct detected (enable XMLOptimizationCheck for more information)
 
24 rows selected.
</pre></div>
<!-- class="example" -->
<p>The execution plan in <a href="#CHDEJJBG">Example 6-41</a> references both the <code>XMLIndex</code> index and the Oracle Text index, indicating that both are used.</p>
<ul>
<li>
<p>The <code>XMLIndex</code> index is indicated by its path table, <code>MY_PATH_TABLE</code>, and its order-key index, <code>SYS78942_PO_XMLINDE_ORDKEY_IX</code>.</p>
</li>
<li>
<p>The Oracle Text index is indicated by the reference to Oracle SQL function <code>contains</code> in the predicate information.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;In this book, "structured" and "unstructured" generally refer to <code>XMLType</code> storage options; they refer less often to the nature of your data. "Hybrid" refers to object-relational storage with some embedded <code>CLOB</code> storage. "Semi-structured" refers to XML content, regardless of storage. Unstructured storage is <code>CLOB</code>-based storage, and structured storage is object-relational storage.<br />
Footnote&nbsp;2:&nbsp;The actual path table implementation may be slightly different.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="xdb_xquery.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb05sto.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
