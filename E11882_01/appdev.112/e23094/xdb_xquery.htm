<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using XQuery with Oracle XML&nbsp;DB</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 748" />
<meta name="description" content="This manual describes Oracle XML&nbsp;DB. It includes guidelines and examples for storing, generating, accessing, searching, validating, transforming, evolving, and indexing XML data in Oracle Database." />
<meta name="dcterms.created" content="2014-02-20T9:56:12Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML DB Developer's Guide" />
<meta name="dcterms.identifier" content="E23094-04" />
<meta name="dcterms.isVersionOf" content="ADXDB" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="xdb04cre.htm" title="Previous" type="text/html" />
<link rel="Next" href="xdb_indexing.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23094.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='xdb_xquery'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="ADXDB1700" class="chapter"><a id="CBAGCBGJ"></a>
<h1 class="chapter"><span class="secnum">5</span> Using <a id="sthref356"></a>XQuery with Oracle XML&nbsp;DB</h1>
<p>This chapter describes how to use the XQuery language with Oracle XML&nbsp;DB. It covers Oracle XML&nbsp;DB support for the language, including SQL/XML functions <code>XMLQuery</code> and <code>XMLTable</code> and the SQL*Plus <code>XQUERY</code> command.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CBAIIEFG">Overview of XQuery in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#CBACEDGE">Overview of the XQuery Language</a></p>
</li>
<li>
<p><a href="#CBAHGAJI">SQL/XML Functions XMLQUERY and XMLTABLE</a></p>
</li>
<li>
<p><a href="#CBAJCIAG">When To Use XQuery</a></p>
</li>
<li>
<p><a href="#CBAJBDFA">Predefined Namespaces and Prefixes</a></p>
</li>
<li>
<p><a href="#BABECFFD">URI Scheme oradb: Querying Table or View Data with XQuery</a></p>
</li>
<li>
<p><a href="#CBAJFJBH">Oracle XQuery Extension Functions</a></p>
</li>
<li>
<p><a href="#CBAJBBDD">XMLQUERY and XMLTABLE Examples</a></p>
</li>
<li>
<p><a href="#CBACDEEC">Performance Tuning for XQuery</a></p>
</li>
<li>
<p><a href="#CBAHDDBE">XQuery Static Type-Checking in Oracle XML&nbsp;DB</a></p>
</li>
<li>
<p><a href="#CBAGFIAE">SQL*Plus XQUERY Command</a></p>
</li>
<li>
<p><a href="#CBAEEJDE">Using XQuery with PL/SQL, JDBC, and ODP.NET</a></p>
</li>
<li>
<p><a href="#CBADGDEA">Oracle XML&nbsp;DB Support for XQuery</a></p>
</li>
</ul>
<a id="CBAIIEFG"></a>
<div id="ADXDB5088" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of XQuery in Oracle XML&nbsp;DB</h2>
<p>Oracle XML&nbsp;DB support for the XQuery language is provided through a native implementation of SQL/XML functions <code>XMLQuery</code> and <code>XMLTable</code>. As a convenience, SQL*Plus command <code>XQUERY</code> is also provided, which lets you enter XQuery expressions directly&thinsp;&mdash;&thinsp;in effect, this command turns SQL*Plus into an XQuery command-line interpreter.</p>
<p>Oracle XML&nbsp;DB compiles XQuery expressions that are passed as arguments to SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code>. This compilation produces SQL query blocks and operator trees that use SQL/XML functions and XPath functions. A SQL statement that includes <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, or <code>XMLCast</code> is compiled and optimized as a whole, leveraging both relational database and XQuery-specific optimization technologies. Depending on the XML storage and indexing methods used, XPath functions can be further optimized. The resulting optimized operator tree is executed in a streaming fashion.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CBAHGAJI">SQL/XML Functions XMLQUERY and XMLTABLE</a> and <a href="#CBAGFIAE">SQL*Plus XQUERY Command</a></p>
</li>
<li>
<p><a href="#CBAJFJBH">Oracle XQuery Extension Functions</a> for Oracle-specific XQuery functions that extend the language</p>
</li>
<li>
<p><a href="#CBADGDEA">Oracle XML&nbsp;DB Support for XQuery</a> for details on Oracle XML&nbsp;DB support for XQuery</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CBACEDGE"></a>
<div id="ADXDB5089" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of the XQuery Language</h2>
<p>Oracle XML&nbsp;DB supports the latest version of the XQuery language specification, W3C XQuery 1.0 Recommendation. This section presents a brief overview of the language. For more information, consult a recent book on the language or refer to the standards documents that define it, which are available at <code>http://www.w3c.org</code>.</p>
<a id="CBADAAIG"></a>
<div id="ADXDB5090" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Functional Language Based on Sequences</h3>
<p>XQuery 1.0 is the W3C language designed for querying XML data. It is similar to SQL in many ways, but just as SQL is designed for querying structured, relational data, XQuery is designed especially for querying semi-structured, XML data from a variety of data sources. You can use XQuery to query XML data wherever it is found, whether it is stored in database tables, available through Web Services, or otherwise created on the fly. In addition to querying XML data, XQuery can be used to <span class="italic">construct</span> XML data. In this regard, XQuery can serve as an alternative or a complement to both XSLT and the other SQL/XML publishing functions, such as <code>XMLElement</code>.</p>
<p>XQuery builds on the Post-Schema-Validation Infoset (PSVI) data model, which unites the XML Information Set (Infoset) data model and the XML Schema type system. XQuery defines a new data model based on <span class="italic">sequences</span>: the result of <span class="italic">each</span> XQuery expression is a sequence. XQuery is all about manipulating sequences. This makes XQuery similar to a set-manipulation language, except that sequences are ordered and can contain duplicate items. XQuery sequences differ from the sequences in some other languages in that nested XQuery sequences are always <span class="italic">flattened</span> in their effect.</p>
<p>In many cases, sequences can be treated as unordered, to maximize optimization &ndash; where this is available, it is under your control. This <span class="glossaryterm"><a id="sthref357"></a>unordered mode</span> can be applied to join order in the treatment of nested iterations (<code>for</code>), and it can be applied to the treatment of XPath expressions (for example, in <code>/a/b</code>, the matching <code>b</code> elements can be processed without regard to document order).</p>
<p>An XQuery <span class="glossaryterm"><a id="sthref358"></a>sequence</span> consists of zero or more <span class="glossaryterm"><a id="sthref359"></a>items</span>, which can be either <span class="italic">atomic</span> (scalar) values or XML <span class="italic">nodes</span>. Items are typed using a rich type system that is based upon the types of XML Schema. This type system is a major change from that of XPath 1.0, which is limited to simple scalar types such as Boolean, number, and string.</p>
<p>XQuery is a <span class="italic">functional</span> language. As such, it consists of a set of possible <span class="italic">expressions</span> that are <span class="italic">evaluated</span> and return <span class="italic">values</span> (which, for XQuery, are sequences). As a functional language, XQuery is also <span class="glossaryterm"><a id="sthref360"></a>referentially transparent</span>, generally: the <span class="italic">same expression</span> evaluated in the <span class="italic">same context</span> returns the <span class="italic">same value</span>.</p>
<p><span class="italic">Exceptions</span> to this desirable mathematical property include the following:</p>
<ul>
<li>
<p>XQuery expressions that derive their value from interaction with the external environment. For example, an expression such as <code>fn:current-time(...)</code> or <code>fn:doc(...)</code> does not necessarily always return the same value, since it depends on external conditions that can change (the time changes; the content of the target document might change).</p>
<p>In some cases, like that of <code>fn:doc</code>, XQuery is defined to be referentially transparent within the execution of a single query: within a query, each invocation of <code>fn:doc</code> with the same argument results in the same document.</p>
</li>
<li>
<p>XQuery expressions that are defined to be dependent on the particular XQuery language implementation. The result of evaluating such expressions might vary between implementations. Function <code>fn:doc</code> is an example of a function that is essentially implementation-defined.</p>
</li>
</ul>
<p>Referential transparency applies also to XQuery <span class="italic">variables</span>: the same variable in the same context has the same value. Functional languages are like mathematics formalisms in this respect and unlike procedural, or imperative, programming languages. A variable in a procedural language is really a name for a memory location; it has a <span class="italic">current</span> value, or state, as represented by its content at any time. A variable in a declarative language such as XQuery is really a name for a <span class="italic">static</span> value.</p>
</div>
<!-- class="sect2" -->
<a id="CBABGHHC"></a>
<div id="ADXDB5091" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref361"></a>XQuery Expressions</h3>
<p>XQuery expressions are case-sensitive. The expressions include the following:</p>
<ul>
<li>
<p><span class="glossaryterm">primary expression &ndash;</span> literal, variable, or function application. A variable name starts with a dollar-sign (<code>$</code>) &ndash; for example, <code>$foo</code>. Literals include numerals, strings, and character or entity references.</p>
</li>
<li>
<p><span class="glossaryterm">XPath expression &ndash;</span> Any XPath expression. The XPath 2.0 standard is a subset of XQuery.</p>
</li>
<li>
<p><span class="glossaryterm">FLWOR expression &ndash;</span> The most important XQuery expression, composed of the following, in order, from which FLWOR takes its name: <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, <code>return</code>.</p>
</li>
<li>
<p><span class="glossaryterm">XQuery sequence</span> &ndash; The comma (<code>,</code>) constructor creates sequences. Sequence-manipulating functions such as <code>union</code> and <code>intersect</code> are also available. All XQuery sequences are effectively <span class="glossaryterm">flat</span>: a nested sequence is treated as its flattened equivalent. Thus, for instance, <code>(1, 2, (3, 4, (5), 6), 7)</code> is treated as <code>(1, 2, 3, 4, 5, 6, 7)</code>. A singleton sequence, such as <code>(42)</code>, acts the same in most XQuery contexts as does its single item, <code>42</code>. Remember that the result of any XQuery expression is a sequence.</p>
</li>
<li>
<p><span class="glossaryterm">Direct (literal) constructions</span> &ndash; XML element and attribute syntax automatically constructs elements and attributes: what you see is what you get. For example, the XQuery expression <code>&lt;a&gt;33&lt;/a&gt;</code> constructs the XML element <code>&lt;a&gt;33&lt;/a&gt;</code>.</p>
</li>
<li>
<p><span class="glossaryterm">Computed (dynamic) constructions &ndash;</span> You can construct XML data at run time using computed values. For example, the following XQuery expression constructs this XML data: <code>&lt;foo toto="5"&gt;&lt;bar&gt;tata titi&lt;/bar&gt; why? &lt;/foo&gt;</code>.</p>
<pre>
&lt;foo&gt;attribute toto {2+3},
     element bar {"tata", "titi"},
     text {" why? "}&lt;/foo&gt;
</pre>
<p>In this example, element <code>foo</code> is a direct construction; the other constructions are computed. In practice, the arguments to computed constructors are not literals (such as <code>toto</code> and <code>"tata"</code>), but expressions to be evaluated (such as <code>2+3</code>). Both the name and the value arguments of an element or attribute constructor can be computed. Braces (<code>{</code>, <code>}</code>) are used to mark off an XQuery expression to be evaluated.</p>
</li>
<li>
<p><span class="glossaryterm">Conditional expression &ndash;</span> As usual, but remember that each part of the expression is itself an arbitrary expression. For instance, in this conditional expression, each of these subexpressions can be any XQuery expression: <code>something</code>, <code>somethingElse</code>, <code>expression1</code>, and <code>expression2</code>.</p>
<pre>
 if (something &lt; somethingElse) then expression1 else expression2
</pre></li>
<li>
<p><span class="glossaryterm">Arithmetic, relational expression &ndash;</span> As usual, but remember that each relational expression returns a (Boolean<a id="sthref362" href="#sthref362" onclick='footdisplay(1,"The value returned is a sequence, as always. However, in XQuery, a sequence of one item is equivalent to that item itself. In this case, the single item is a Boolean value.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a>) value. Examples:</p>
<pre>
2 + 3
42 &lt; $a + 5
(1, 4) = (1, 2)
5 &gt; 3 eq true()
</pre></li>
<li>
<p><span class="glossaryterm">Quantifier expression &ndash;</span> Universal (<code>every</code>) and existential (<code>some</code>) quantifier functions provide shortcuts to using a FLWOR expression in some cases. Examples:</p>
<pre>
every $foo in doc("bar.xml")//Whatever satisfies $foo/@bar &gt; 42
some $toto in (42, 5), $titi in (123, 29, 5) satisfies $toto = $titi
</pre></li>
<li>
<p><span class="glossaryterm">Regular expression &ndash;</span> XQuery regular expressions are based on XML Schema 1.0 and Perl. (See <a href="#CBACGAIC">Support for XQuery Functions and Operators</a>.)</p>
</li>
<li>
<p><span class="glossaryterm">Type expression &ndash;</span> An XQuery expression that represents an XQuery type. Examples: <code>item()</code>, <code>node()</code>, <code>attribute()</code>, <code>element()</code>, <code>document-node()</code>, <code>namespace()</code>, <code>text()</code>, <code>xs:integer</code>, <code>xs:string</code>.<a id="sthref363" href="#sthref363" onclick='footdisplay(2,"Namespace prefix \u003ccode\u003exs\u003c/code\u003e is predefined for the XML Schema namespace, \u003ccode\u003ehttp://www.w3.org/2001/XMLSchema\u003c/code\u003e.")'><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></p>
<p>Type expressions can have <span class="glossaryterm"><a id="sthref364"></a>occurrence indicators</span>: <code><span class="codeinlinebold">?</span></code> (optional: zero or one), <code><span class="codeinlinebold">*</span></code> (zero or more), <code><span class="codeinlinebold">+</span></code> (one or more). Examples: <code>document-node(element())*</code>, <code>item()+</code>, <code>attribute()?</code>.</p>
<p>XQuery also provides operators for working with types. These include <code>cast as</code>, <code>castable as</code>, <code>treat as</code>, <code>instance of</code>, <code>typeswitch</code>, and <code>validate</code>. For example, <code>"42" cast as xs:integer</code> is an expression whose value is the integer 2. (It is not, strictly speaking, a type expression, because its value does not represent a type.)</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADXDB5092" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref365"></a>
<h3 class="sect2"><a id="sthref366"></a><a id="sthref367"></a>FLWOR Expressions</h3>
<p>As for XQuery in general, there is a lot to learn about FLWOR expressions. This section provides only a brief overview.</p>
<p>FLWOR is the most general expression syntax in XQuery. FLWOR (pronounced "flower") stands for <code>for</code>, <code>let</code>, <code>where</code>, <code>order by</code>, and <code>return</code>. A FLWOR expression has at least one <code>for</code> or <code>let</code> clause and a <code>return</code> clause; single <code>where</code> and <code>order by</code> clauses are optional.</p>
<ul>
<li>
<p><code><span class="codeinlinebold">for</span></code> &ndash; Bind one or more variables each to any number of values, in turn. That is, for each variable, iterate, binding the variable to a different value for each iteration.</p>
<p>At each iteration, the variables are bound in the order they appear, so that the value of a variable <code>$earlier</code> that is listed before a variable <code>$later</code> in the <code>for</code> list, can be used in the binding of variable <code>$later</code>. For example, during its second iteration, this expression binds <code>$i</code> to <code>4</code> and <code>$j</code> to <code>6</code> (2+4):</p>
<pre>
 for $i in (3, 4), $j in ($i, 2+$i)
</pre></li>
<li>
<p><code><span class="codeinlinebold">let</span></code> &ndash; Bind one or more variables.</p>
<p>Just as with <code>for</code>, a variable can be bound by <code>let</code> to a value computed using another variable that is listed previously in the binding list of the <code>let</code> (or an enclosing <code>for</code> or <code>let</code>). For example, this expression binds <code>$j</code> to <code>5</code> (3+2):</p>
<pre>
let $i := 3, $j := $i + 2
</pre></li>
<li>
<p><code><span class="codeinlinebold">where</span></code> &ndash; Filter the <code>for</code> and <code>let</code> variable bindings according to some condition. This is similar to a SQL <code>WHERE</code> clause.</p>
</li>
<li>
<p><code><span class="codeinlinebold">order by</span></code> &ndash; Sort the result of <code>where</code> filtering.</p>
</li>
<li>
<p><code><span class="codeinlinebold">return</span></code> &ndash; Construct a result from the ordered, filtered values. This is the result of the FLWOR expression as a whole. It is a flattened sequence.</p>
</li>
</ul>
<p>Expressions <code>for</code> and <code>let</code> act similarly to a SQL <code>FROM</code> clause. Expression <code>where</code> acts like a SQL <code>WHERE</code> clause Expression <code>order by</code> is similar to <code>ORDER BY</code> in SQL. Expression <code>return</code> is like <code>SELECT</code> in SQL. Except for the two keywords whose names are the same in both languages (<code>where</code>, <code>order by</code>), FLWOR clause order is more or less opposite to the SQL clause order, but the meanings of the corresponding clauses are quite similar.</p>
<p>Note that using a FLWOR expression (with <code>order by</code>) is the <span class="italic">only</span> way to construct an XQuery sequence in any order other than document order.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CBAHGAJI"></a>
<div id="ADXDB5093" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref368"></a><a id="sthref369"></a><a id="sthref370"></a><a id="sthref371"></a><a id="sthref372"></a>SQL/XML Functions <a id="sthref373"></a>XMLQUERY and XMLTABLE</h2>
<p>SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, <code>XMLExists</code>, and <code>XMLCast</code> are defined by the SQL/XML standard as a general interface between the SQL and XQuery languages. As is the case for the other SQL/XML functions, these functions let you take advantage of the power and flexibility of both SQL and XML. Using these functions, you can construct XML data using relational data, query relational data as if it were XML, and construct relational data from XML data.</p>
<p>SQL functions <code>XMLExists</code> and <code>XMLCast</code> are documented elsewhere in this manual. This section presents functions <code>XMLQuery</code> and <code>XMLTable</code>, but many of the examples in this chapter use also <code>XMLExists</code>, and <code>XMLCast</code>. In terms of typical use:</p>
<ul>
<li>
<p><code>XMLQuery</code> and <code>XMLCast</code> are typically used in a <code>SELECT</code> list.</p>
</li>
<li>
<p><code>XMLTable</code> is typically used in a SQL <code>FROM</code> clause.</p>
</li>
<li>
<p><code>XMLExists</code> is typically used in a SQL <code>WHERE</code> clause.</p>
</li>
</ul>
<p>Both <code>XMLQuery</code> and <code>XMLTable</code> evaluate an XQuery expression. In the XQuery language, an expression always returns a sequence of items. Function <code>XMLQuery</code> aggregates the items in this sequence to return a single XML document or fragment. Function <code>XMLTable</code> returns a SQL table whose rows each contain one item from the XQuery sequence.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF55529" href="../../server.112/e41084/ap_standard_sql010.htm#SQLRF55529"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about Oracle support for the SQL/XML standard</p>
</li>
<li>
<p><code><a href="http://www.sqlx.org">http://www.sqlx.org</a></code> for information about SQL/XML functions</p>
</li>
<li>
<p><code><a href="http://www.w3.org">http://www.w3.org</a></code> for information about the XQuery language</p>
</li>
<li>
<p><a href="xdb13gen.htm#i1029583">"Generating XML using SQL Functions"</a> for information about using other SQL/XML functions with Oracle XML&nbsp;DB</p>
</li>
<li>
<p><a href="xdb04cre.htm#i1024833">"Querying XMLType Data using SQL/XML Functions XMLExists and XMLCast"</a></p>
</li>
</ul>
</div>
<a id="BABFJFFJ"></a>
<div id="ADXDB5094" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref374"></a><a id="sthref375"></a>XMLQUERY SQL/XML Function in Oracle XML&nbsp;DB</h3>
<p>You use SQL/XML function <code>XMLQuery</code> to construct or query XML data. This function takes as arguments an <span class="italic">XQuery expression</span>, as a string literal, and an optional XQuery <span class="italic">context item</span>, as a SQL expression. The context item establishes the XPath context in which the XQuery expression is evaluated. Additionally, <code>XMLQuery</code> accepts as arguments any number of SQL expressions whose values are bound to XQuery variables during the XQuery expression evaluation. The function returns the result of evaluating the XQuery expression, as an <code>XMLType</code> instance.</p>
<div id="ADXDB5095" class="figure">
<p class="titleinfigure"><a id="sthref376"></a>Figure 5-1 XMLQUERY Syntax</p>
<img width="742" height="103" src="img/xmlquery.gif" alt="Description of Figure 5-1 follows" /><br />
<a id="sthref377" href="img_text/xmlquery.htm">Description of "Figure 5-1 XMLQUERY Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a id="ADXDB5096"></a><span class="subhead3"><span class="italic">XML_passing_clause ::=</span>&nbsp;</span></p>
<img width="484" height="79" src="img/xml_passing_clause.gif" alt="Description of xml_passing_clause.gif follows" /><br />
<a id="sthref378" href="img_text/xml_passing_clause.htm">Description of the illustration xml_passing_clause.gif</a><br />
<br />
<ul>
<li>
<p><code><span class="codeinlineitalic">XQuery_string</span></code> is a complete XQuery expression, possibly including a prolog, as a literal string.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">XML_passing_clause</span></code> is the keyword <code>PASSING</code> followed by one or more SQL expressions (<code><span class="codeinlineitalic">expr</span></code>) that each return an <code>XMLType</code> instance or an instance of a SQL scalar data type (that is, not an object or collection data type). Each expression (<code><span class="codeinlineitalic">expr</span></code>) can be a table or view column value, a PL/SQL variable, or a bind variable with proper casting. All but possibly one of the expressions must each be followed by the keyword <code>AS</code> and an XQuery <code><span class="codeinlineitalic">identifier</span></code>. The result of evaluating each <code><span class="codeinlineitalic">expr</span></code> is bound to the corresponding <code><span class="codeinlineitalic">identifier</span></code> for the evaluation of <code><span class="codeinlineitalic">XQuery_string</span></code>. If there is an <code><span class="codeinlineitalic">expr</span></code> that is not followed by an <code>AS</code> clause, then the result of evaluating that <code><span class="codeinlineitalic">expr</span></code> is used as the <span class="italic">context</span> item for evaluating <code><span class="codeinlineitalic">XQuery_string</span></code>. Oracle XML&nbsp;DB supports only passing <code>BY VALUE</code>, not passing <code>BY REFERENCE</code>, so the clause <code>BY VALUE</code> is implicit and can be omitted.</p>
</li>
<li>
<p><code>RETURNING</code> <code>CONTENT</code> indicates that the value returned by an application of <code>XMLQuery</code> is an instance of parameterized XML type <code>XML(CONTENT)</code>, not parameterized type <code>XML(SEQUENCE)</code>. It is a document fragment that conforms to the <span class="italic">extended</span> Infoset data model. As such, it is a single document node with any number of children. The children can each be of any XML node type; in particular, they can be text nodes.</p>
<p>Oracle XML&nbsp;DB supports only the <code>RETURNING CONTENT</code> clause of SQL/XML function <code>XMLQuery</code>; it does <span class="italic">not</span> support the <code>RETURNING SEQUENCE</code> clause.</p>
</li>
</ul>
<p>You can pass an <code>XMLType</code> column, table, or view as the context-item argument to function <code>XMLQuery</code>&thinsp;&mdash;&thinsp;see, for example, <a href="#CBADDAEJ">Example 5-8</a>.</p>
<p>To query a relational table or view as if it were XML data, without having to first create a SQL/XML view on top of it, use XQuery function <code>fn:collection</code> within an XQuery expression, passing as argument a URI that uses the URI-scheme name <code>oradb</code> together with the database location of the data. See <a href="#BABECFFD">"URI Scheme oradb: Querying Table or View Data with XQuery"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL functions <code>extract</code> and <code>extractValue</code> to do some of what can be done better using SQL/XML functions <code>XMLQuery</code> and <code>XMLCast</code>. SQL functions <code>extract</code> and <code>extractValue</code> are <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><code><a href="http://www.sqlx.org">http://www.sqlx.org</a></code> for information about the definition of SQL/XML function <code>XMLQuery</code></p>
</li>
<li>
<p><a class="olink SQLRF06209" href="../../server.112/e41084/functions249.htm#SQLRF06209"><span class="italic">Oracle Database SQL Language Reference</span></a> for reference information about SQL/XML function <code>XMLQuery</code> in Oracle Database</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABJCHCC"></a>
<div id="ADXDB5097" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref379"></a><a id="sthref380"></a>XMLTABLE SQL/XML Function in Oracle XML&nbsp;DB</h3>
<p>You use SQL/XML function <code>XMLTable</code> to decompose the result of an XQuery-expression evaluation into the relational rows and columns of a new, virtual table. You can then insert the virtual table into a pre-existing database table, or you can query it using SQL&thinsp;&mdash;&thinsp;in a join expression, for example (see <a href="#CBAHBFGE">Example 5-9</a>). You use <code>XMLTable</code> in a SQL <code>FROM</code> clause.</p>
<div id="ADXDB5098" class="figure">
<p class="titleinfigure"><a id="sthref381"></a>Figure 5-2 XMLTABLE Syntax</p>
<img width="626" height="46" src="img/xmltable.gif" alt="Description of Figure 5-2 follows" /><br />
<a id="sthref382" href="img_text/xmltable.htm">Description of "Figure 5-2 XMLTABLE Syntax"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a id="ADXDB5099"></a><span class="subhead3"><span class="italic">XML_namespaces_clause ::=</span>&nbsp;</span></p>
<img width="628" height="79" src="img/xml_namespaces_clause.gif" alt="Description of xml_namespaces_clause.gif follows" /><br />
<a id="sthref383" href="img_text/xml_namespaces_clause.htm">Description of the illustration xml_namespaces_clause.gif</a><br />
<br />
<p><a id="ADXDB5100"></a><span class="subhead3"><span class="italic">XMLTABLE_options ::=</span>&nbsp;</span></p>
<img width="484" height="70" src="img/xmltable_options.gif" alt="Description of xmltable_options.gif follows" /><br />
<a id="sthref384" href="img_text/xmltable_options.htm">Description of the illustration xmltable_options.gif</a><br />
<br />
<p><a id="ADXDB5101"></a><span class="subhead3"><span class="italic">XML_passing_clause ::=</span>&nbsp;</span></p>
<img width="484" height="79" src="img/xml_passing_clause.gif" alt="Description of xml_passing_clause.gif follows" /><br />
<a id="sthref385" href="img_text/xml_passing_clause.htm">Description of the illustration xml_passing_clause.gif</a><br />
<br />
<p><a id="ADXDB5102"></a><span class="subhead3"><span class="italic">XML_table_column ::=</span>&nbsp;</span></p>
<img width="511" height="79" src="img/xml_table_column.gif" alt="Description of xml_table_column.gif follows" /><br />
<a id="sthref386" href="img_text/xml_table_column.htm">Description of the illustration xml_table_column.gif</a><br />
<br />
<ul>
<li>
<p><code><span class="codeinlineitalic">XQuery_string</span></code> is a complete XQuery expression, possibly including a prolog, as a literal string. The value of the expression serves as input to the <code>XMLTable</code> function; it is this XQuery result that is decomposed and stored as relational data.</p>
</li>
<li>
<p>The optional <code>XMLNAMESPACES</code> clause contains XML namespace declarations that are referenced by <code><span class="codeinlineitalic">XQuery_string</span></code> and by the XPath expression in the <code>PATH</code> clause of <code><span class="codeinlineitalic">XML_table_column</span></code>.</p>
</li>
<li>
<p>The <code><span class="codeinlineitalic">XML_passing_clause</span></code> is the keyword <code>PASSING</code> followed by one or more SQL expressions (<code><span class="codeinlineitalic">expr</span></code>) that each return an <code>XMLType</code> instance or an instance of a SQL scalar data type (that is, not an object or collection data type). Each expression (<code><span class="codeinlineitalic">expr</span></code>) can be a table or view column value, a PL/SQL variable, or a bind variables with proper casting. All but possibly one of the expressions must each be followed by the keyword <code>AS</code> and an XQuery <code><span class="codeinlineitalic">identifier</span></code>. The result of evaluating each <code><span class="codeinlineitalic">expr</span></code> is bound to the corresponding <code><span class="codeinlineitalic">identifier</span></code> for the evaluation of <code><span class="codeinlineitalic">XQuery_string</span></code>. If there is an <code><span class="codeinlineitalic">expr</span></code> that is not followed by an <code>AS</code> clause, then the result of evaluating that <code><span class="codeinlineitalic">expr</span></code> is used as the <span class="italic">context</span> item for evaluating <code><span class="codeinlineitalic">XQuery_string</span></code>. Oracle XML&nbsp;DB supports only passing <code>BY VALUE</code>, not passing <code>BY REFERENCE</code>, so the clause <code>BY VALUE</code> is implicit and can be omitted.</p>
</li>
<li>
<p>The optional <code>COLUMNS</code> clause defines the columns of the virtual table to be created by <code>XMLTable</code>.</p>
<ul>
<li>
<p>If you omit the <code>COLUMNS</code> clause, then <code>XMLTable</code> returns a row with a single <code>XMLType</code> pseudo-column, named <code>COLUMN_VALUE</code>.</p>
</li>
<li>
<p><code>FOR ORDINALITY</code> specifies that <code><span class="codeinlineitalic">column</span></code> is to be a column of generated row numbers (SQL data type <code>NUMBER</code>). There must be at most one <code>FOR ORDINALITY</code> clause.</p>
</li>
<li>
<p>For each resulting column except the <code>FOR ORDINALITY</code> column, you must specify the column data type, which can be <code>XMLType</code> or any other SQL data type (called <code><span class="codeinlineitalic">datatype</span></code> in the syntax description).</p>
</li>
<li>
<p>The optional <code>PATH</code> clause specifies that the portion of the XQuery result that is addressed by XQuery expression <code><span class="codeinlineitalic">string</span></code> is to be used as the <code><span class="codeinlineitalic">column</span></code> content. You can use multiple <code>PATH</code> clauses to split the XQuery result into different virtual-table columns.</p>
<p>If you omit <code>PATH</code>, then the XQuery expression <code><span class="codeinlineitalic">column</span></code> is assumed. For example, these two expressions are equivalent:</p>
<pre>
XMLTable(... COLUMNS foo)
XMLTable(... COLUMNS foo PATH 'FOO')
</pre>
<p>The XQuery expression <code><span class="codeinlineitalic">string</span></code> must represent a <span class="italic">relative</span> path; it is relative to the path <code><span class="codeinlineitalic">XQuery_string</span></code>.</p>
</li>
<li>
<p>The optional <code>DEFAULT</code> clause specifies the value to use when the <code>PATH</code> expression results in an empty sequence (or <code>NULL</code>). Its <code><span class="codeinlineitalic">expr</span></code> is an XQuery expression that is evaluated to produce the default value.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><code><a href="http://www.sqlx.org">http://www.sqlx.org</a></code> for information about the definition of SQL/XML function <code>XMLTable</code></p>
</li>
<li>
<p><a class="olink SQLRF06232" href="../../server.112/e41084/functions253.htm#SQLRF06232"><span class="italic">Oracle Database SQL Language Reference</span></a> for reference information about SQL/XML function <code>XMLTable</code> in Oracle Database</p>
</li>
</ul>
</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Prior to Oracle Database&nbsp;11<span class="italic">g</span> Release 2, some users employed Oracle SQL function <code>XMLSequence</code> within a SQL <code>TABLE</code> collection expression, that is, <code>TABLE(XMLSequence(...))</code>, to do some of what can be done better using SQL/XML function <code>XMLTable</code>. Function <code>XMLSequence</code> is <span class="italic">deprecated</span> in Oracle Database&nbsp;11<span class="italic">g</span> Release 2.
<p>See <a class="olink SQLRF30047" href="../../server.112/e41084/statements_10002.htm#SQLRF30047"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the SQL <code>TABLE</code> collection expression.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CBAJCIAG"></a>
<div id="ADXDB5103" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">When To Use XQuery</h2>
<p>You can use XQuery to do many of the same things that you might do using the SQL/XML generation functions or XSLT; there is a great deal of overlap. The decision to use one or the other tool to accomplish a given task can be based on many considerations, most of which are not specific to Oracle Database. Please consult external documentation on this general question.</p>
<p>One general rule of thumb is that XQuery is often used when the focus is the world of XML data, while the SQL/XML generation functions (<code>XMLElement</code>, <code>XMLAgg</code>, and so on) are often used when the focus is the world of relational data.</p>
<p>Other things being equal, if a query constructs an XML document from fragments extracted from existing XML documents, then it is likely that an XQuery FLOWR expression is simpler (simplifying code maintenance) than extracting scalar values from relational data and constructing appropriate XML data using SQL/XML generation functions. If, instead, a query constructs an XML document from existing relational data, the SQL/XML generation functions can often be more suitable.</p>
<p>With respect to Oracle XML&nbsp;DB, you can expect the same general level of performance using the SQL/XML generation functions as with <code>XMLQuery</code> and <code>XMLTable</code>&thinsp;&mdash;&thinsp;all are subject to rewrite optimizations.</p>
</div>
<!-- class="sect1" -->
<a id="CBAJBDFA"></a>
<div id="ADXDB5104" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Predefined <a id="sthref387"></a>Namespaces<a id="sthref388"></a><a id="sthref389"></a> and Prefixes</h2>
<p>The following namespaces and prefixes are predefined for use with XQuery in Oracle XML&nbsp;DB:</p>
<div id="ADXDB5105" class="tblformalwide">
<p class="titleintable"><a id="sthref390"></a><a id="sthref391"></a>Table 5-1 Predefined Namespaces and Prefixes</p>
<table class="cellalignment1032" title="Predefined Namespaces and Prefixes" summary="Predefined namespaces and prefixes" >
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t8">Prefix</th>
<th class="cellalignment1027" id="r1c2-t8">Namespace</th>
<th class="cellalignment1027" id="r1c3-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t8" headers="r1c1-t8">
<p><code>ora</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t8 r1c2-t8">
<p><code>http://xmlns.oracle.com/xdb</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t8 r1c3-t8">
<p>Oracle XML&nbsp;DB namespace</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t8" headers="r1c1-t8">
<p><code>local</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t8 r1c2-t8">
<p><code>http://www.w3.org/2003/11/xpath-local-functions</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t8 r1c3-t8">
<p>XPath local function declaration namespace</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t8" headers="r1c1-t8">
<p><code>fn</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t8 r1c2-t8">
<p><code>http://www.w3.org/2003/11/xpath-functions</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t8 r1c3-t8">
<p>XPath function namespace</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t8" headers="r1c1-t8">
<p><code>xml</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t8 r1c2-t8">
<p><code>http://www.w3.org/XML/1998/namespace</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t8 r1c3-t8">
<p>XML namespace</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t8" headers="r1c1-t8">
<p><code>xs</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t8 r1c2-t8">
<p><code>http://www.w3.org/2001/XMLSchema</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t8 r1c3-t8">
<p>XML Schema namespace</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t8" headers="r1c1-t8">
<p><code>xsi</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t8 r1c2-t8">
<p><code>http://www.w3.org/2001/XMLSchema-instance</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t8 r1c3-t8">
<p>XML Schema instance namespace</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>You can use these prefixes in XQuery expressions without first declaring them in the XQuery-expression prolog. You can redefine any of them <span class="italic">except</span> <code>xml</code> in the prolog. All of these prefixes except <code>ora</code> are predefined in the XQuery standard.</p>
</div>
<!-- class="sect1" -->
<a id="BABECFFD"></a>
<div id="ADXDB5994" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">URI Scheme oradb: Querying Table or View Data with XQuery</h2>
<p>You can use XQuery functions <code>fn:doc</code> and <code>fn:collection</code> to query resources in Oracle XML&nbsp;DB Repository&thinsp;&mdash;&thinsp;see<a href="#CBAGBECJ">"Querying XML Data in Oracle XML&nbsp;DB Repository using XQuery"</a>. This section is about using XQuery function <code>fn:collection</code> to query data in database tables and views.</p>
<p>To do this, you pass function <code>fn:collection</code> a URI argument that specifies the table or view to query. The Oracle URI scheme <code>oradb</code> identifies this usage: without it, the argument is treated as a repository location.</p>
<p>The table or view that is queried can be relational or of type <code>XMLType</code>. If relational, its data is converted on the fly and treated as XML. The result returned by <code>fn:collection</code> is always an XQuery sequence.</p>
<ul>
<li>
<p>For an <code>XMLType</code> table, the root element of each XML document returned by <code>fn:collection</code> is the same as the root element of an XML document in the table.</p>
</li>
<li>
<p>For a relational table, the root element of each XML document returned by <code>fn:collection</code> is <code>ROW</code>. The children of the <code>ROW</code> element are elements with the same names (uppercase) as columns of the table. The content of a child element corresponds to the column data. That content is an XML element if the column is of type <code>XMLType</code>; otherwise (the column is a scalar type), the content is of type <code>xs:string</code>.</p>
</li>
</ul>
<p>The format of the URI argument passed to <code>fn:collection</code> is as follows:</p>
<ul>
<li>
<p>For an <code>XMLType</code> or relational table or view, <code><span class="codeinlineitalic">TABLE</span></code>, in database schema <code><span class="codeinlineitalic">DB-SCHEMA</span></code>:</p>
<pre>
<span class="bold">oradb:</span>/<span class="italic">DB-SCHEMA</span>/<span class="italic">TABLE</span>/
</pre>
<p>You can use <code><span class="codeinlinebold">PUBLIC</span></code> for <code><span class="codeinlineitalic">DB-SCHEMA</span></code> if <code><span class="codeinlineitalic">TABLE</span></code> is a public synonym or <code><span class="codeinlineitalic">TABLE</span></code> is a table or view that is accessible to the database user currently logged in.</p>
</li>
<li>
<p>For an <code>XMLType</code> column in a <span class="italic">relational</span> table or view:</p>
<pre>
<span class="bold">oradb:</span>/<span class="italic">DB-SCHEMA</span>/<span class="italic">REL-TABLE</span>/<span class="bold">ROW</span><span class="italic">PRED</span>/<span class="italic">X-COL</span>
</pre>
<p><code><span class="codeinlineitalic">REL-TABLE</span></code> is a relational table or view; <code><span class="codeinlineitalic">PRED</span></code> is an XPath predicate that does not involve any <code>XMLType</code> columns; and <code><span class="codeinlineitalic">X-COL</span></code> is an <code>XMLType</code> column in <code><span class="codeinlineitalic">REL-TABLE</span></code>. <code><span class="codeinlineitalic">PRED</span></code> is optional; <code><span class="codeinlineitalic">DB-SCHEMA</span></code>, <code><span class="codeinlineitalic">REL-TABLE</span></code>, and <code><span class="codeinlineitalic">X-COL</span></code> are required.</p>
</li>
</ul>
<p>Optional XPath predicate <code><span class="codeinlineitalic">PRED</span></code> must satisfy the following conditions:</p>
<ul>
<li>
<p>It does not involve any <code>XMLType</code> columns.</p>
</li>
<li>
<p>It involves only conjunctions (<code>and</code>) and disjunctions (<code>or</code>) of general equality and inequality comparisons (<code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, and <code>&lt;=</code>).</p>
</li>
<li>
<p>For each comparison operation: Either both sides name (non-XML) columns in <code><span class="codeinlineitalic">REL-TABLE</span></code> or one side names such a column and the other is a value of the proper type, as specified in <a href="#BABCEJCJ">Table 5-2</a>. Use of any other type raises an error.</p>
</li>
</ul>
<div id="ADXDB5995" class="tblformal">
<p class="titleintable"><a id="sthref392"></a><a id="BABCEJCJ"></a>Table 5-2 oradb Expressions: Column Types for Comparisons</p>
<table class="cellalignment1026" title="oradb Expressions: Column Types for Comparisons" summary="Column types allowed in comparison expressions of oradb predicates" dir="ltr">
<thead>
<tr class="cellalignment1020">
<th class="cellalignment1027" id="r1c1-t9">Relational Column Type</th>
<th class="cellalignment1027" id="r1c2-t9">XQuery Value Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r2c1-t9" headers="r1c1-t9">
<p><code>VARCHAR2</code>, <code>CHAR</code></p>
</td>
<td class="cellalignment1028" headers="r2c1-t9 r1c2-t9">
<p><code>xs:string</code> or string literal</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r3c1-t9" headers="r1c1-t9">
<p><code>NUMBER</code>, <code>FLOAT</code>, <code>BINARY_FLOAT</code>, <code>BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment1028" headers="r3c1-t9 r1c2-t9">
<p><code>xs:decimal</code>, <code>xs:float</code>, <code>xs:double</code>, or numeric literal</p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r4c1-t9" headers="r1c1-t9">
<p><code>DATE</code>, <code>TIMESTAMP</code>, <code>TIMESTAMP WITH TIMEZONE</code>, <code>TIMESTAMP WITH LOCAL TIMEZONE</code></p>
</td>
<td class="cellalignment1028" headers="r4c1-t9 r1c2-t9">
<p><code>xs:date</code>, <code>xs:time</code>, or <code>xs:dateTime</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r5c1-t9" headers="r1c1-t9">
<p><code>INTERVAL YEAR TO MONTH</code></p>
</td>
<td class="cellalignment1028" headers="r5c1-t9 r1c2-t9">
<p><code>xs:yearMonthDuration</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r6c1-t9" headers="r1c1-t9">
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment1028" headers="r6c1-t9 r1c2-t9">
<p><code>xs:dayTimeDuration</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r7c1-t9" headers="r1c1-t9">
<p><code>RAW</code></p>
</td>
<td class="cellalignment1028" headers="r7c1-t9 r1c2-t9">
<p><code>xs:hexBinary</code></p>
</td>
</tr>
<tr class="cellalignment1020">
<td class="cellalignment1028" id="r8c1-t9" headers="r1c1-t9">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment1028" headers="r8c1-t9 r1c2-t9">
<p><code>xs:string</code> or string literal</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>For example, this XQuery expression represents all XML documents in <code>XMLType</code> column <code>warehouse_spec</code> of table <code>oe.warehouses</code>, for the rows where column <code>warehouse_id</code> has a value less than 6:</p>
<pre>
fn:collection('oradb:/OE/WAREHOUSES/ROW[WAREHOUSE_ID &lt; 6]/WAREHOUSE_SPEC')
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBAEJEHG">"Querying Table or View Data using XQuery"</a></div>
</div>
<!-- class="sect1" -->
<a id="CBAJFJBH"></a>
<div id="ADXDB5106" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Oracle XQuery <a id="sthref393"></a>Extension Functions</h2>
<p>Oracle XML&nbsp;DB adds some XQuery functions to those provided in the W3C standard. These additional functions are in the Oracle XML&nbsp;DB namespace, <code>http://xmlns.oracle.com/xdb</code>, which uses the predefined prefix <code><span class="codeinlinebold">ora</span></code>. This section describes these Oracle extension functions.</p>
<div id="ADXDB5109" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref394"></a>
<h3 class="sect2"><a id="sthref395"></a><a id="sthref396"></a>ora:contains XQuery Function</h3>
<p class="subhead1"><a id="ADXDB5110"></a>ora:contains Syntax</p>
<pre>
ora:contains (<span class="italic">input_text</span>, <span class="italic">text_query</span> [, <span class="italic">policy_name</span>] [, <span class="italic">policy_owner</span>])
</pre>
<p>XQuery and XPath function <code>ora:contains</code> can be used in an XQuery expression in a call to SQL/XML function <code>XMLQuery</code>, <code>XMLTable</code>, or <code>XMLExists</code>. It is used to restrict a structural search with a full-text predicate. Function <code>ora:contains</code> returns a positive integer when the <code><span class="codeinlineitalic">input_text</span></code> matches <code><span class="codeinlineitalic">text_query</span></code> (the higher the number, the more relevant the match), and zero otherwise. When used in an XQuery expression (that is not also an XPath expression), the XQuery return type is <code>xs:integer()</code>; when used in an XPath expression outside of an XQuery expression, the XPath return type is <code>number</code>.</p>
<p>Argument <code><span class="codeinlineitalic">input_text</span></code> must evaluate to a single text node or an attribute. The syntax and semantics of <code><span class="codeinlineitalic">text_query</span></code> in <code>ora:contains</code> are the same as <code><span class="codeinlineitalic">text_query</span></code> in <code>contains</code>, with a few restrictions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb09sea.htm#CBBHCGEC">"ora:contains XQuery Function"</a></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB5111" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref397"></a>
<h3 class="sect2"><a id="sthref398"></a><a id="sthref399"></a><a id="sthref400"></a>ora:matches XQuery Function</h3>
<p class="subhead1"><a id="ADXDB5112"></a>ora:matches Syntax</p>
<pre>
ora:matches (<span class="italic">target_string</span>, <span class="italic">match_pattern</span> [, <span class="italic">match_parameter</span>])
</pre>
<p>XQuery function <code>ora:matches</code> lets you use a regular expression to match text in a string. It returns <code>true()</code> if its <code><span class="codeinlineitalic">target_string</span></code> argument matches its regular-expression <code><span class="codeinlineitalic">match_pattern</span></code> argument and <code>false()</code> otherwise. If <code><span class="codeinlineitalic">target_string</span></code> is the empty sequence, <code>false()</code> is returned. Optional argument <code><span class="codeinlineitalic">match_parameter</span></code> is a code that qualifies matching: case-sensitivity and so on.</p>
<p>The behavior of XQuery function <code>ora:matches</code> is the same as that of SQL condition <code>REGEXP_LIKE</code>, but the types of its arguments are XQuery types instead of SQL data types. The argument types are as follows:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">target_string</span></code> &ndash; <code>xs:string?</code><a id="sthref401" href="#sthref401" onclick='footdisplay(3,"The question mark (\u003ccode\u003e?\u003c/code\u003e) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See \u003ca target=\"xdb_xquery\" href=\"#CBABGHHC\"\u003e\"XQuery Expressions\"\u003c/a\u003e.")'><sup class="tablefootnote">Foot&nbsp;3&nbsp;</sup></a></p>
</li>
<li>
<p><code><span class="codeinlineitalic">match_pattern</span></code> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">match_parameter</span></code> &ndash; <code>xs:string</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00501" href="../../server.112/e41084/conditions007.htm#SQLRF00501"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL condition <code>REGEXP_LIKE</code></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB5113" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref402"></a>
<h3 class="sect2"><a id="sthref403"></a><a id="sthref404"></a><a id="sthref405"></a>ora:replace XQuery Function</h3>
<p class="subhead1"><a id="ADXDB5114"></a>ora:replace Syntax</p>
<pre>
ora:replace (<span class="italic">target_string, match_pattern</span>, <span class="italic">replace_string</span> [, <span class="italic">match_parameter</span>])
</pre>
<p>XQuery function <code>ora:replace</code> lets you use a regular expression to replace matching text in a string. <span class="italic">Each</span> occurrence in <code><span class="codeinlineitalic">target_string</span></code> that matches regular-expression <code><span class="codeinlineitalic">match_pattern</span></code> is replaced by <code><span class="codeinlineitalic">replace_string</span></code>. It returns the new string that results from the replacement. If <code><span class="codeinlineitalic">target_string</span></code> is the empty sequence, then the empty string (<code>""</code>) is returned. Optional argument <code><span class="codeinlineitalic">match_parameter</span></code> is a code that qualifies matching: case-sensitivity and so on.</p>
<p>The behavior of XQuery function <code>ora:replace</code> is the same as that of SQL function <code>regexp_replace</code>, but the types of its arguments are XQuery types instead of SQL data types. The argument types are as follows:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">target_string</span></code> &ndash; <code>xs:string?</code><a id="sthref406" href="#sthref406" onclick='footdisplay(4,"The question mark (\u003ccode\u003e?\u003c/code\u003e) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See \u003ca target=\"xdb_xquery\" href=\"#CBABGHHC\"\u003e\"XQuery Expressions\"\u003c/a\u003e.")'><sup class="tablefootnote">Foot&nbsp;4&nbsp;</sup></a></p>
</li>
<li>
<p><code><span class="codeinlineitalic">match_pattern</span></code> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">replace_string</span></code> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">match_parameter</span></code> &ndash; <code>xs:string</code></p>
</li>
</ul>
<p>In addition, <code>ora:replace</code> requires argument <code><span class="codeinlineitalic">replace_string</span></code> (it is optional in <code>regexp_replace</code>) and it does not use arguments for position and number of occurrences &ndash; search starts with the first character and all occurrences are replaced.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF06302" href="../../server.112/e41084/functions149.htm#SQLRF06302"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL function <code>regexp_replace</code></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB5115" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref407"></a>
<h3 class="sect2"><a id="sthref408"></a><a id="sthref409"></a><a id="sthref410"></a>ora:sqrt XQuery Function</h3>
<p class="subhead1"><a id="ADXDB5116"></a>ora:sqrt Syntax</p>
<pre>
ora:sqrt (<span class="italic">number</span>)
</pre>
<p>XQuery function <code>ora:sqrt</code> returns the square root of its numeric argument, which can be of XQuery type <code>xs:decimal</code>, <code>xs:float</code>, or <code>xs:double</code>. The returned value is of the same XQuery type as the argument.</p>
</div>
<!-- class="sect2" -->
<div id="ADXDB5117" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref411"></a>
<h3 class="sect2"><a id="sthref412"></a><a id="sthref413"></a><a id="sthref414"></a>ora:tokenize XQuery Function</h3>
<p class="subhead1"><a id="ADXDB5118"></a>ora:tokenize Syntax</p>
<pre>
ora:tokenize (<span class="italic">target_string</span>, <span class="italic">match_pattern</span> [, <span class="italic">match_parameter</span>])
</pre>
<p>XQuery function <code>ora:tokenize</code> lets you use a regular expression to split the input string <code><span class="codeinlineitalic">target_string</span></code> into a sequence of strings. It treats each substring that matches the regular-expression <code><span class="codeinlineitalic">match_pattern</span></code> as a separator indicating where to split.</p>
<p>It returns the sequence of tokens as an XQuery value of type <code>xs:string*</code> (a sequence of <code>xs:string</code> values). If <code><span class="codeinlineitalic">target_string</span></code> is the empty sequence, it is returned. Optional argument <code><span class="codeinlineitalic">match_parameter</span></code> is a code that qualifies matching: case-sensitivity and so on.</p>
<p>The argument types are as follows:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">target_string</span></code> &ndash; <code>xs:string?</code><a id="sthref415" href="#sthref415" onclick='footdisplay(5,"The question mark (\u003ccode\u003e?\u003c/code\u003e) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See \u003ca target=\"xdb_xquery\" href=\"#CBABGHHC\"\u003e\"XQuery Expressions\"\u003c/a\u003e.")'><sup class="tablefootnote">Foot&nbsp;5&nbsp;</sup></a></p>
</li>
<li>
<p><code><span class="codeinlineitalic">match_pattern</span></code> &ndash; <code>xs:string</code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">match_parameter</span></code> &ndash; <code>xs:string</code></p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<div id="ADXDB5996" class="sect1"><!-- infolevel="all" infotype="General" --><a id="sthref416"></a>
<h2 class="sect1">Oracle XQuery Extension-Expression P<a id="sthref417"></a><a id="sthref418"></a><a id="sthref419"></a>ragmas</h2>
<p>The W3C XQuery specification lets an implementation provide implementation-defined extension expressions. An XQuery extension expression is an XQuery expression that is enclosed in braces (<code>{</code>,&nbsp;<code>}</code>) and prefixed by an implementation-defined pragma.</p>
<p>The Oracle implementation provides the pragmas described in this section. No other pragmas are recognized than those listed here. Use of any other pragma, or use of any of these pragmas with incorrect pragma content (for example, <code>(#ora:view_on_null something_else #)</code>), raises an error.</p>
<p>In the <code>ora:view_on_null</code> examples here, assume that table <code>null_test</code> has columns <code>a</code> and <code>b</code> of type <code>VARCHAR2(10)</code>, and that column <code>b</code> (but not <code>a</code>) is empty.</p>
<ul>
<li>
<p>(<code>#<a id="sthref420"></a>ora:defaultTable #</code>) &ndash; Specify the default table used to store repository data. Use this to improve the performance of repository queries that use Query function <code>fn:doc</code> or <code>fn:collection</code>. See <a href="#BABCDFEF">"Using Oracle XQuery Pragma ora:defaultTable"</a>.</p>
</li>
<li>
<p><code>(#<a id="sthref421"></a>ora:invalid_path empty #)</code> &ndash; Treat an invalid XPath expression as if its targeted nodes do not exist. For example:</p>
<pre>
SELECT XMLQuery('(#ora:invalid_path empty #)
                 {exists($p/PurchaseOrder//NotInTheSchema)}'
                PASSING OBJECT_VALUE AS "p" RETURNING CONTENT)
  FROM oe.purchaseorder p;
</pre>
<p>The XML schema for table <code>oe.purchaseorder</code> does not allow any such node <code>NotInTheSchema</code> as a descendant of node <code>PurchaseOrder</code>. Without the pragma, the use of this invalid XPath expression would raise an error. But with the pragma, the calling context acts just as if the XPath expression had targeted no nodes. That calling context in this example is XQuery function <code>exists</code>, which returns XQuery Boolean value <code>false</code> when passed an empty node sequence. (XQuery function <code>exists</code> is used in this example only to illustrate the behavior; the pragma is not especially related to function <code>exists</code>.)</p>
</li>
<li>
<p><code>(#<a id="sthref422"></a>ora:view_on_null empty #)</code> &ndash; XQuery function <code>fn:collection</code> returns an empty XML element for each <code>NULL</code> column. For example, the following query returns <code>&lt;ROW&gt;&lt;A&gt;x&lt;/A&gt;</code><code><span class="codeinlinebold">&lt;B&gt;&lt;/B&gt;</span></code><code>&lt;/ROW&gt;</code>:</p>
<pre>
SELECT XMLQuery('(#ora:view_on_null <span class="bold">empty</span> #)
                 {for $i in fn:collection("oradb:/PUBLIC/NULL_TEST")/ROW 
                  return $i}'
                RETURNING CONTENT)
  FROM DUAL;
</pre></li>
<li>
<p><code>(#ora:view_on_null null #)</code> &ndash; XQuery function <code>fn:collection</code> returns no element for a <code>NULL</code> column. For example, the following query returns <code>&lt;ROW&gt;&lt;A&gt;x&lt;/A&gt;&lt;/ROW&gt;</code>:</p>
<pre>
SELECT XMLQuery('(#ora:view_on_null <span class="bold">null</span> #)
                 {for $i in fn:collection("oradb:/PUBLIC/NULL_TEST")/ROW 
                  return $i}'
                RETURNING CONTENT)
  FROM DUAL;
</pre></li>
<li>
<p><code>(#<a id="sthref423"></a>ora:xq_proc #)</code> &ndash; Do not optimize XQuery procedure calls in the XQuery expression that follows the pragma; use functional evaluation instead.</p>
<p>This has the same effect as the SQL hint <code>/*+ NO_XML_QUERY_REWRITE */</code>, but the scope of the pragma is only the XQuery expression that follows it (not an entire SQL statement).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb_indexing.htm#CHDBBAGA">"Turning Off Use of XMLIndex"</a> for information about optimizer hint <code>NO_XML_QUERY_REWRITE</code></div>
</li>
<li>
<p><code>(#<a id="sthref424"></a>ora:xq_qry #)</code> &ndash; Try to optimize the XQuery expression that follows the pragma. That is, if possible, do not evaluate it functionally.</p>
<p>As an example of using both <code>ora:xq_proc</code> and <code>ora:xq_qry</code>, in the following query the XQuery expression argument to <code>XMLQuery</code> will in general be evaluated functionally, but the <code>fn:collection</code> subexpressions that are preceded by pragma <code>ora:xq_qry</code> will be optimized, if possible.</p>
<pre>
SELECT XMLQuery('<span class="bold">(#ora:xq_proc#)</span>   (: Do not optimize the XQuery expression :)
                 {for $i in <span class="bold">(#ora:xq_qry#)</span>   (: Optimize this subexpression :)
                            {fn:collection("oradb:/HR/REGIONS")},
                      $j in <span class="bold">(#ora:xq_qry#)</span>   (: Optimize this subexpression :)
                            {fn:collection("oradb:/HR/COUNTRIES")}
                  where $i/ROW/REGION_ID = $j/ROW/REGION_ID
                    and $i/ROW/REGION_NAME = $regionname
                  return $j}'
         PASSING CAST('&amp;REGION' AS VARCHAR2(40)) AS "regionname"
           RETURNING CONTENT)
  AS asian_countries FROM DUAL;
</pre></li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CBAJBBDD"></a>
<div id="ADXDB5121" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">XMLQUERY and XMLTABLE <a id="sthref425"></a>Examples</h2>
<p>XQuery is a very general and expressive language, and SQL/XML functions <code>XMLQuery</code>, <code>XMLTable</code>, and <code>XMLExists</code> combine that power of expression and computation with the similar strengths of SQL. This section illustrates some of what you can do with these two SQL/XML functions. See <a href="xdb04cre.htm#CHDDDDAA">"XMLEXISTS SQL/XML Function"</a> for information about <code>XMLExists</code>.</p>
<p>You typically use XQuery with Oracle XML&nbsp;DB in the following ways. The examples here are organized to reflect these different uses.</p>
<ul>
<li>
<p>Query XML data in Oracle XML&nbsp;DB Repository.</p>
<p>See <a href="#CBAGBECJ">"Querying XML Data in Oracle XML&nbsp;DB Repository using XQuery"</a>.</p>
</li>
<li>
<p>Query a relational table or view as if it were XML data. To do this, you use Oracle XQuery function <code>fn:collection</code>, passing as argument a URI that uses the URI-scheme name <code>oradb</code> together with the database location of the data.</p>
<p>See <a href="#CBAEJEHG">"Querying Table or View Data using XQuery"</a>.</p>
</li>
<li>
<p>Query <code>XMLType</code> relational data, possibly decomposing the resulting XML into relational data using function <code>XMLTable</code>.</p>
<p>See <a href="#CBAIFJJJ">"Using XQuery with XMLType Data"</a>.</p>
</li>
</ul>
<p><a href="#CBAFDFCH">Example 5-1</a> creates Oracle XML&nbsp;DB Repository resources that are used in some of the other examples in this chapter.</p>
<div id="ADXDB5122" class="example">
<p class="titleinexample"><a id="CBAFDFCH"></a>Example 5-1 Creating Resources for Examples</p>
<pre>
DECLARE
  res BOOLEAN;
  empsxmlstring VARCHAR2(300):= 
    '&lt;?xml version="1.0"?&gt;
     &lt;emps&gt;
       &lt;emp empno="1" deptno="10" ename="John" salary="21000"/&gt;
       &lt;emp empno="2" deptno="10" ename="Jack" salary="310000"/&gt;
       &lt;emp empno="3" deptno="20" ename="Jill" salary="100001"/&gt;
     &lt;/emps&gt;';
  empsxmlnsstring VARCHAR2(300):=
    '&lt;?xml version="1.0"?&gt;
     &lt;emps xmlns="http://example.com"&gt;
       &lt;emp empno="1" deptno="10" ename="John" salary="21000"/&gt;
       &lt;emp empno="2" deptno="10" ename="Jack" salary="310000"/&gt;
       &lt;emp empno="3" deptno="20" ename="Jill" salary="100001"/&gt;
     &lt;/emps&gt;';
  deptsxmlstring VARCHAR2(300):=
    '&lt;?xml version="1.0"?&gt;
     &lt;depts&gt;
       &lt;dept deptno="10" dname="Administration"/&gt;
       &lt;dept deptno="20" dname="Marketing"/&gt;
       &lt;dept deptno="30" dname="Purchasing"/&gt;
     &lt;/depts&gt;';
BEGIN
  res := DBMS_XDB.createResource('/public/emps.xml',   empsxmlstring);
  res := DBMS_XDB.createResource('/public/empsns.xml', empsxmlnsstring);
  res := DBMS_XDB.createResource('/public/depts.xml',  deptsxmlstring);
END;
/
</pre></div>
<!-- class="example" -->
<div id="ADXDB5123" class="sect2"><a id="sthref426"></a>
<h3 class="sect2">XQuery Is About Sequences</h3>
<p>It is important to keep in mind that XQuery is a general <span class="italic">sequence</span>-manipulation language. Its expressions and their results are not necessarily XML data. An XQuery sequence can contain items of any XQuery type, which includes numbers, strings, Boolean values, dates, and various types of XML node (<code>document-node()</code>, <code>element()</code>, <code>attribute()</code>, <code>text()</code>, <code>namespace()</code>, and so on). <a href="#CBAJAIAF">Example 5-2</a> provides a sampling.</p>
<div id="ADXDB5124" class="example">
<p class="titleinexample"><a id="CBAJAIAF"></a>Example 5-2 XMLQuery Applied to a Sequence of Items of Different Types</p>
<pre>
SELECT XMLQuery('(1, 2 + 3, "a", 100 to 102, &lt;A&gt;33&lt;/A&gt;)'
                RETURNING CONTENT) AS output
  FROM DUAL;

OUTPUT
--------------------------
1 5 a 100 101 102&lt;A&gt;33&lt;/A&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CBAJAIAF">Example 5-2</a> applies SQL/XML function <code>XMLQuery</code> to an XQuery sequence that contains items of several different kinds:</p>
<ul>
<li>
<p>an integer literal: <code>1</code></p>
</li>
<li>
<p>a arithmetic expression: <code>2 + 3</code></p>
</li>
<li>
<p>a string literal: <code>"a"</code></p>
</li>
<li>
<p>a sequence of integers: <code>100 to 102</code></p>
</li>
<li>
<p>a constructed XML element node: <code>&lt;A&gt;33&lt;/A&gt;</code></p>
</li>
</ul>
<p><a href="#CBAJAIAF">Example 5-2</a> also shows construction of a sequence using the comma operator (<code><span class="codeinlinebold">,</span></code>) and parentheses (<code><span class="codeinlinebold">(</span></code>, <code><span class="codeinlinebold">)</span></code>) for grouping.</p>
<p>The sequence expression <code>100 to 102</code> evaluates to the sequence <code>(100, 101, 102)</code>, so the argument to <code>XMLQuery</code> here is a sequence that contains a nested sequence. The sequence argument is automatically flattened, as is always the case for XQuery sequences. The argument is, in effect, <code>(1, 5, "a", 100, 101, 102, &lt;A&gt;33&lt;/A&gt;)</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CBAGBECJ"></a>
<div id="ADXDB5125" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Querying XML Data <a id="sthref427"></a><a id="sthref428"></a>in Oracle XML&nbsp;DB Repository using XQuery</h3>
<p>This section presents examples of using XQuery with XML data in Oracle XML&nbsp;DB Repository. You use XQuery functions <code>fn:doc</code> and <code>fn:collection</code> to query file and folder resources in the repository, respectively. The examples in this section use XQuery function <code>fn:doc</code> to obtain a repository file that contains XML data, and then bind XQuery variables to parts of that data using <code>for</code> and <code>let</code> FLWOR-expression clauses.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBABJDAG">XQuery Functions fn:doc, fn:collection, and fn:doc-available</a></div>
<p><a href="#CBAGIABD">Example 5-3</a> queries two XML-document resources in Oracle XML&nbsp;DB Repository: <code>/public/emps.xml</code> and <code>/public/depts.xml</code>. It illustrates the use of <code>fn:doc</code> and each of the possible FLWOR-expression clauses.</p>
<div id="ADXDB5126" class="example">
<p class="titleinexample"><a id="CBAGIABD"></a>Example 5-3 FLOWR Expression using for, let, order by, where, and return</p>
<pre>
SELECT XMLQuery('for $e in doc("/public/emps.xml")/emps/emp
                 let $d :=
                   doc("/public/depts.xml")//dept[@deptno = $e/@deptno]/@dname
                 where $e/@salary &gt; 100000
                 order by $e/@empno
                 return &lt;emp ename="{$e/@ename}" dept="{$d}"/&gt;'
                RETURNING CONTENT) FROM DUAL;

XMLQUERY('FOR$EINDOC("/PUBLIC/EMPS.XML")/EMPS/EMPLET$D:=DOC("/PUBLIC/DEPTS.XML")
--------------------------------------------------------------------------------
&lt;emp ename="Jack" dept="Administration"&gt;&lt;/emp&gt;&lt;emp ename="Jill" dept="Marketing"
&gt;&lt;/emp&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CBAGIABD">Example 5-3</a>, the various FLWOR clauses perform these operations:</p>
<ul>
<li>
<p><code><span class="codeinlinebold">for</span></code> iterates over the <code>emp</code> elements in <code>/public/emps.xml</code>, binding variable <code>$e</code> to the value of each such element, in turn. That is, it iterates over a general list of employees, binding <code>$e</code> to each employee.</p>
</li>
<li>
<p><code><span class="codeinlinebold">let</span></code> binds variable <code>$d</code> to a <span class="italic">sequence</span> consisting of all of the values of <code>dname</code> attributes of those <code>dept</code> elements in <code>/public/emps.xml</code> whose <code>deptno</code> attributes have the same value as the <code>deptno</code> attribute of element <code>$e</code> (this is a join operation). That is, it binds <code>$d</code> to the names of all of the departments that have the same department number as the department of employee <code>$e</code>. (It so happens that the <code>dname</code> value is unique for each <code>deptno</code> value in <code>depts.xml</code>.) Note that, unlike <code>for</code>, <code>let</code> never iterates over values; <code>$d</code> is bound only once in this example.</p>
</li>
<li>
<p>Together, <code>for</code> and <code>let</code> produce a stream of tuples (<code>$e</code>, <code>$d</code>), where <code>$e</code> represents an employee and <code>$d</code> represents the names of all of the departments to which that employee belongs&thinsp;&mdash;in this case, the unique name of the employee's unique department.</p>
</li>
<li>
<p><code><span class="codeinlinebold">where</span></code> filters this tuple stream, keeping only tuples with employees whose salary is greater than 100,000.</p>
</li>
<li>
<p><code><span class="codeinlinebold">order by</span></code> sorts the filtered tuple stream by employee number, <code>empno</code> (in ascending order, by default).</p>
</li>
<li>
<p><code><span class="codeinlinebold">return</span></code> constructs <code>emp</code> elements, one for each tuple. Attributes <code>ename</code> and <code>dept</code> of these elements are constructed using attribute <code>ename</code> from the input and <code>$d</code>, respectively. Note that the element and attribute names <code>emp</code> and <code>ename</code> in the output have no necessary connection with the same names in the input document <code>emps.xml</code>.</p>
</li>
</ul>
<p><a href="#CBAHEIJG">Example 5-4</a> also uses each of the FLWOR-expression clauses. It shows the use of XQuery functions <code>doc</code>, <code>count</code>, <code>avg</code>, and <code>integer</code>, which are in the namespace for built-in XQuery functions, <code>http://www.w3.org/2003/11/xpath-functions</code>. This namespace is bound to the prefix <code>fn</code>.</p>
<div id="ADXDB5127" class="example">
<p class="titleinexample"><a id="CBAHEIJG"></a>Example 5-4 FLOWR Expression using Built-In Functions</p>
<pre>
SELECT XMLQuery('for $d in fn:doc("/public/depts.xml")/depts/dept/@deptno
                 let $e := fn:doc("/public/emps.xml")/emps/emp[@deptno = $d]
                 where fn:count($e) &gt; 1
                 order by fn:avg($e/@salary) descending
                 return
                   &lt;big-dept&gt;{$d,
                              &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
                              &lt;avgsal&gt;{xs:integer(fn:avg($e/@salary))}&lt;/avgsal&gt;}
                   &lt;/big-dept&gt;'
                RETURNING CONTENT) FROM DUAL;

XMLQUERY('FOR$DINFN:DOC("/PUBLIC/DEPTS.XML")/DEPTS/DEPT/@DEPTNOLET$E:=FN:DOC("/P
--------------------------------------------------------------------------------
&lt;big-dept deptno="10"&gt;&lt;headcount&gt;2&lt;/headcount&gt;&lt;avgsal&gt;165500&lt;/avgsal&gt;&lt;/big-dept&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CBAHEIJG">Example 5-4</a>, the various FLWOR clauses perform these operations:</p>
<ul>
<li>
<p><code><span class="codeinlinebold">for</span></code> iterates over <code>deptno</code> attributes in input document <code>/public/depts.xml</code>, binding variable <code>$d</code> to the value of each such attribute, in turn.</p>
</li>
<li>
<p><code><span class="codeinlinebold">let</span></code> binds variable <code>$e</code> to a sequence consisting of all of the <code>emp</code> elements in input document <code>/public/emps.xml</code> whose <code>deptno</code> attributes have value <code>$d</code> (this is a join operation).</p>
</li>
<li>
<p>Together, <code>for</code> and <code>let</code> produce a stream of tuples (<code>$d</code>, <code>$e</code>), where <code>$d</code> represents a department number and <code>$e</code> represents the set of employees in that department.</p>
</li>
<li>
<p><code><span class="codeinlinebold">where</span></code> filters this tuple stream, keeping only tuples with more than one employee.</p>
</li>
<li>
<p><code><span class="codeinlinebold">order by</span></code> sorts the filtered tuple stream by average salary in descending order. The average is computed by applying XQuery function <code>avg</code> (in namespace <code>fn</code>) to the values of attribute <code>salary</code>, which is attached to the <code>emp</code> elements of <code>$e</code>.</p>
</li>
<li>
<p><code><span class="codeinlinebold">return</span></code> constructs <code>big-dept</code> elements, one for each tuple produced by <code>order by</code>. The <code>text()</code> node of <code>big-dept</code> contains the department number, bound to <code>$d</code>. A <code>headcount</code> child element contains the number of employees, bound to <code>$e</code>, as determined by XQuery function <code>count</code>. An <code>avgsal</code> child element contains the computed average salary.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CBAEJEHG"></a>
<div id="ADXDB5129" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Querying Table or View Data using XQuery</h3>
<p>This section presents examples of using XQuery to query relational data as if it were XML data.</p>
<p><a href="#CBAFCFCF">Example 5-5</a> uses Oracle XQuery function <code>fn:collection</code> in a FLWOR expression to query two relational tables, <code>regions</code> and <code>countries</code>. Both tables belong to sample database schema <code>HR</code>. The example also passes scalar SQL value <code>Asia</code> to XQuery variable <code>$regionname</code>. Any SQL expression can be evaluated to produce a value passed to XQuery using <code>PASSING</code>. In this case, the value comes from a SQL*Plus variable, <code>REGION</code>. You must cast the value to the scalar SQL data type expected, in this case, <code>VARCHAR2(40)</code>.</p>
<div id="ADXDB5130" class="example">
<p class="titleinexample"><a id="CBAFCFCF"></a>Example 5-5 Querying Relational Tables as XML</p>
<pre>
DEFINE REGION = 'Asia'
SELECT XMLQuery('for $i in <span class="bold">fn:collection("oradb:/HR/REGIONS")</span>,
                     $j in <span class="bold">fn:collection("oradb:/HR/COUNTRIES")</span>
                   where $i/ROW/REGION_ID = $j/ROW/REGION_ID
                     and $i/ROW/REGION_NAME = $regionname
                   return $j'
                PASSING CAST('&amp;REGION' AS VARCHAR2(40)) AS "regionname"
                RETURNING CONTENT) AS asian_countries
  FROM DUAL;
</pre>
<p>This produces the following result. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
ASIAN_COUNTRIES
-----------------------------------------
&lt;ROW&gt;
  &lt;COUNTRY_ID&gt;AU&lt;/COUNTRY_ID&gt;
  &lt;COUNTRY_NAME&gt;Australia&lt;/COUNTRY_NAME&gt;
  &lt;REGION_ID&gt;3&lt;/REGION_ID&gt;
&lt;/ROW&gt;
&lt;ROW&gt;
  &lt;COUNTRY_ID&gt;CN&lt;/COUNTRY_ID&gt;
  &lt;COUNTRY_NAME&gt;China&lt;/COUNTRY_NAME&gt;
  &lt;REGION_ID&gt;3&lt;/REGION_ID&gt;
&lt;/ROW&gt;
&lt;ROW&gt;
  &lt;COUNTRY_ID&gt;HK&lt;/COUNTRY_ID&gt;
  &lt;COUNTRY_NAME&gt;HongKong&lt;/COUNTRY_NAME&gt;
  &lt;REGION_ID&gt;3&lt;/REGION_ID&gt;
&lt;/ROW&gt;
&lt;ROW&gt;
  &lt;COUNTRY_ID&gt;IN&lt;/COUNTRY_ID&gt;
  &lt;COUNTRY_NAME&gt;India&lt;/COUNTRY_NAME&gt;
  &lt;REGION_ID&gt;3&lt;/REGION_ID&gt;
&lt;/ROW&gt;
&lt;ROW&gt;
  &lt;COUNTRY_ID&gt;JP&lt;/COUNTRY_ID&gt;
  &lt;COUNTRY_NAME&gt;Japan&lt;/COUNTRY_NAME&gt;
  &lt;REGION_ID&gt;3&lt;/REGION_ID&gt;
&lt;/ROW&gt;
&lt;ROW&gt;
  &lt;COUNTRY_ID&gt;SG&lt;/COUNTRY_ID&gt;
  &lt;COUNTRY_NAME&gt;Singapore&lt;/COUNTRY_NAME&gt;
  &lt;REGION_ID&gt;3&lt;/REGION_ID&gt;
&lt;/ROW&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CBAFCFCF">Example 5-5</a>, the various FLWOR clauses perform these operations:</p>
<ul>
<li>
<p><code><span class="codeinlinebold">for</span></code> iterates over sequences of XML elements returned by calls to <code>fn:collection</code>. In the first call, each element corresponds to a row of relational table <code>hr.regions</code> and is bound to variable <code>$i</code>. Similarly, in the second call to <code>fn:collection</code>, <code>$j</code> is bound to successive rows of table <code>hr.countries</code>. Since <code>regions</code> and <code>countries</code> are not <code>XMLType</code> tables, the top-level element corresponding to a row in each table is <code>ROW</code> (a wrapper element). Iteration over the row elements is unordered.</p>
</li>
<li>
<p><code><span class="codeinlinebold">where</span></code> filters the rows from both tables, keeping only those pairs of rows whose <code>region_id</code> is the same for each table (it performs a join on <code>region_id</code>) and whose <code>region_name</code> is <code>Asia</code>.</p>
</li>
<li>
<p><code><span class="codeinlinebold">return</span></code> returns the filtered rows from table <code>hr.countries</code> as an XML document containing XML fragments with <code>ROW</code> as their top-level element.</p>
</li>
</ul>
<p><a href="#CBAJHHJD">Example 5-6</a> uses <code>fn:collection</code> within nested FLWOR expressions to query relational data.</p>
<div id="ADXDB5131" class="example">
<p class="titleinexample"><a id="CBAJHHJD"></a>Example 5-6 Using Relational Data in a Nested FLWOR Query</p>
<pre>
CONNECT hr
Enter password: <span class="italic">password</span>

Connected.

GRANT SELECT ON LOCATIONS TO OE
/
CONNECT oe
Enter password: <span class="italic">password</span>

Connected.

SELECT XMLQuery(
         'for $i in <span class="bold">fn:collection("oradb:/OE/WAREHOUSES")/ROW</span>
          return &lt;Warehouse id="{$i/WAREHOUSE_ID}"&gt;
                   &lt;Location&gt;
                     {for $j in <span class="bold">fn:collection("oradb:/HR/LOCATIONS")/ROW</span>
                      where $j/LOCATION_ID eq $i/LOCATION_ID 
                      return ($j/STREET_ADDRESS, $j/CITY, $j/STATE_PROVINCE)}
                   &lt;/Location&gt;    
                 &lt;/Warehouse&gt;'
         RETURNING CONTENT) FROM DUAL;
</pre>
<p>This query is an example of using nested FLWOR expressions. It accesses relational table <code>warehouses</code>, which is in sample database schema <code>oe</code>, and relational table <code>locations</code>, which is in sample database schema <code>HR</code>. To run this example as user <code>oe</code>, you must first connect as user <code>hr</code> and grant permission to user <code>oe</code> to perform <code>SELECT</code> operations on table <code>locations</code>.</p>
<p>This produces the following result. (The result is shown here pretty-printed, for clarity.)</p>
<pre>
XMLQUERY('FOR$IINFN:COLLECTION("ORADB:/OE/WAREHOUSES")/ROWRETURN&lt;WAREHOUSEID="{$
--------------------------------------------------------------------------------
&lt;Warehouse id="1"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;2014 Jabberwocky Rd&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Southlake&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;Texas&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="2"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;2011 Interiors Blvd&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;South San Francisco&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;California&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="3"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;2007 Zagora St&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;South Brunswick&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;New Jersey&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="4"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;2004 Charade Rd&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Seattle&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;Washington&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="5"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;147 Spadina Ave&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Toronto&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;Ontario&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="6"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;12-98 Victoria Street&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Sydney&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;New South Wales&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="7"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;Mariano Escobedo 9991&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Mexico City&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;Distrito Federal,&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="8"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;40-5-12 Laogianggen&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Beijing&lt;/CITY&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="9"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;1298 Vileparle (E)&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Bombay&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;Maharashtra&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CBAJHHJD">Example 5-6</a>, the various FLWOR clauses perform these operations:</p>
<ul>
<li>
<p>The outer <code><span class="codeinlinebold">for</span></code> iterates over the sequence of XML elements returned by <code>fn:collection</code>: each element corresponds to a row of relational table <code>oe.warehouses</code> and is bound to variable <code>$i</code>. Since <code>warehouses</code> is not an <code>XMLType</code> table, the top-level element corresponding to a row is <code>ROW</code>. The iteration over the row elements is unordered.</p>
</li>
<li>
<p>The inner <code><span class="codeinlinebold">for</span></code> iterates, similarly, over a sequence of XML elements returned by <code>fn:collection</code>: each element corresponds to a row of relational table <code>hr.locations</code> and is bound to variable <code>$j</code>.</p>
</li>
<li>
<p><code><span class="codeinlinebold">where</span></code> filters the tuples (<code>$i</code>, <code>$j</code>), keeping only those whose <code>location_id</code> child is the same for <code>$i</code> and <code>$j</code> (it performs a join on <code>location_id</code>).</p>
</li>
<li>
<p>The inner <code><span class="codeinlinebold">return</span></code> constructs an XQuery sequence of elements <code>STREET_ADDRESS</code>, <code>CITY</code>, and <code>STATE_PROVINCE</code>, all of which are children of locations-table <code>ROW</code> element <code>$j</code>; that is, they are the values of the locations-table columns of the same name.</p>
</li>
<li>
<p>The outer <code><span class="codeinlinebold">return</span></code> wraps the result of the inner <code>return</code> in a <code>Location</code> element, and wraps that in a <code>Warehouse</code> element. It provides the <code>Warehouse</code> element with an <code>id</code> attribute whose value comes from the <code>warehouse_id</code> column of table <code>warehouses</code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBAIJAAD">Example 5-15</a> for the execution plan of <a href="#CBAJHHJD">Example 5-6</a></div>
<p><a href="#CBAJEGFH">Example 5-7</a> uses SQL/XML function <code>XMLTable</code> to decompose the result of an XQuery query to produce virtual relational data. The XQuery expression used in this example is identical to the one used in <a href="#CBAJHHJD">Example 5-6</a>; the result of evaluating the XQuery expression is a sequence of <code>Warehouse</code> elements. Function <code>XMLTable</code> produces a virtual relational table whose rows are those <code>Warehouse</code> elements. More precisely, the value of pseudocolumn <code>COLUMN_VALUE</code> for each virtual-table row is an XML fragment (of type <code>XMLType</code>) with a single <code>Warehouse</code> element.</p>
<div id="ADXDB5132" class="example">
<p class="titleinexample"><a id="CBAJEGFH"></a>Example 5-7 Querying a Relational Table as XML using XMLTable</p>
<pre>
SELECT * 
  FROM XMLTable(
         'for $i in fn:collection("oradb:/OE/WAREHOUSES")/ROW
          return &lt;Warehouse id="{$i/WAREHOUSE_ID}"&gt;
                   &lt;Location&gt;
                     {for $j in fn:collection("oradb:/HR/LOCATIONS")/ROW
                      where $j/LOCATION_ID eq $i/LOCATION_ID 
                      return ($j/STREET_ADDRESS, $j/CITY, $j/STATE_PROVINCE)}
                   &lt;/Location&gt;
                 &lt;/Warehouse&gt;');
</pre>
<p>This produces the same result as <a href="#CBAJHHJD">Example 5-6</a>, except that each <code>Warehouse</code> element is output as a separate row, instead of all <code>Warehouse</code> elements being output together in a single row.</p>
<pre>
COLUMN_VALUE
--------------------------------------------------------
&lt;Warehouse id="1"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;2014 Jabberwocky Rd&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;Southlake&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;Texas&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
&lt;Warehouse id="2"&gt;
  &lt;Location&gt;
    &lt;STREET_ADDRESS&gt;2011 Interiors Blvd&lt;/STREET_ADDRESS&gt;
    &lt;CITY&gt;South San Francisco&lt;/CITY&gt;
    &lt;STATE_PROVINCE&gt;California&lt;/STATE_PROVINCE&gt;
  &lt;/Location&gt;
&lt;/Warehouse&gt;
<span class="bold">. . .</span>
 
<span class="bold">9 rows selected.</span>
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBAJFIBF">Example 5-16</a> for the execution plan of <a href="#CBAJEGFH">Example 5-7</a></div>
</div>
<!-- class="sect2" -->
<a id="CBAIFJJJ"></a>
<div id="ADXDB5133" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using XQuery with <a id="sthref429"></a>XMLType Data</h3>
<p>This section presents examples of using XQuery with <code>XMLType</code> relational data.</p>
<p>The query in <a href="#CBADDAEJ">Example 5-8</a> passes an <code>XMLType</code> column, <code>warehouse_spec</code>, as <span class="italic">context</span> item to XQuery, using function <code>XMLQuery</code> with the <code>PASSING</code> clause. It constructs a <code>Details</code> element for each of the warehouses whose area is greater than 80,000: <code>/Warehouse/ Area &gt; 80000</code>.</p>
<div id="ADXDB5134" class="example">
<p class="titleinexample"><a id="CBADDAEJ"></a>Example 5-8 Querying an XMLType Column using XMLQuery PASSING Clause</p>
<pre>
SELECT warehouse_name, 
       XMLQuery(
         'for $i in /Warehouse 
          where  $i/Area &gt; 80000 
          return &lt;Details&gt;
                   &lt;Docks num="{$i/Docks}"/&gt;
                   &lt;Rail&gt;{if ($i/RailAccess = "Y") then "true" else "false"}
                   &lt;/Rail&gt;
                 &lt;/Details&gt;'
         PASSING warehouse_spec RETURNING CONTENT) big_warehouses
  FROM oe.warehouses;
</pre>
<p>This produces the following output:</p>
<pre>
WAREHOUSE_NAME
--------------
BIG_WAREHOUSES
--------------
Southlake, Texas
 
 
San Francisco
 
 
New Jersey
&lt;Details&gt;&lt;Docks num=""&gt;&lt;/Docks&gt;&lt;Rail&gt;false&lt;/Rail&gt;&lt;/Details&gt;
 
Seattle, Washington
&lt;Details&gt;&lt;Docks num="3"&gt;&lt;/Docks&gt;&lt;Rail&gt;true&lt;/Rail&gt;&lt;/Details&gt;
 
Toronto
 
 
Sydney
 
 
Mexico City
 
 
Beijing
 
 
Bombay
 
 
9 rows selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CBADDAEJ">Example 5-8</a>, function <code>XMLQuery</code> is applied to the <code>warehouse_spec</code> column in each row of table <code>warehouses</code>. The various FLWOR clauses perform these operations:</p>
<ul>
<li>
<p><code><span class="codeinlinebold">for</span></code> iterates over the <code>Warehouse</code> elements in each row of column <code>warehouse_spec</code> (the passed context item): each such element is bound to variable <code>$i</code>, in turn. The iteration is unordered.</p>
</li>
<li>
<p><code><span class="codeinlinebold">where</span></code> filters the <code>Warehouse</code> elements, keeping only those whose <code>Area</code> child has a value greater than 80,000.</p>
</li>
<li>
<p><code><span class="codeinlinebold">return</span></code> constructs an XQuery sequence of <code>Details</code> elements, each of which contains a <code>Docks</code> and a <code>Rail</code> child elements. The <code>num</code> attribute of the constructed <code>Docks</code> element is set to the <code>text()</code> value of the <code>Docks</code> child of <code>Warehouse</code>. The <code>text()</code> content of <code>Rail</code> is set to <code>true</code> or <code>false</code>, depending on the value of the <code>RailAccess</code> attribute of element <code>Warehouse</code>.</p>
</li>
</ul>
<p>The <code>SELECT</code> statement in <a href="#CBADDAEJ">Example 5-8</a> applies to each row in table <code>warehouses</code>. The <code>XMLQuery</code> expression returns the <span class="italic">empty sequence</span> for those rows that do not match the XQuery expression. Only the warehouses in New Jersey and Seattle satisfy the XQuery query, so they are the only warehouses for which <code>&lt;Details&gt;...&lt;/Details&gt;</code> is returned.</p>
<p><a href="#CBAHBFGE">Example 5-9</a> uses SQL/XML function <code>XMLTable</code> to query an <code>XMLType</code> table, <code>oe.purchaseorder</code>, which contains XML Schema-based data. It uses the <code>PASSING</code> clause to provide the <code>purchaseorder</code> table as the context item for the XQuery-expression argument to <code>XMLTable</code>. Pseudocolumn <code>COLUMN_VALUE</code> of the resulting virtual table holds a constructed element, <code>A10po</code>, which contains the <code>Reference</code> information for those purchase orders whose <code>CostCenter</code> element has value <code>A10</code> and whose <code>User</code> element has value <code>SMCCAIN</code>. The query performs a join between the virtual table and database table <code>purchaseorder</code>.</p>
<div id="ADXDB5135" class="example">
<p class="titleinexample"><a id="CBAHBFGE"></a>Example 5-9 Using XMLTABLE with XML Schema-Based Data</p>
<pre>
SELECT xtab.COLUMN_VALUE
  FROM purchaseorder, XMLTable('for $i in /PurchaseOrder
                                where $i/CostCenter eq "A10"
                                  and $i/User eq "SMCCAIN"
                                return &lt;A10po pono="{$i/Reference}"/&gt;'
                               PASSING OBJECT_VALUE) xtab;
 
COLUMN_VALUE
---------------------------------------------------
&lt;A10po pono="SMCCAIN-20021009123336151PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336341PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123337173PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123335681PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123335470PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336972PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336842PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336512PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-2002100912333894PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123337403PDT"&gt;&lt;/A10po&gt;
 
10 rows selected.
</pre></div>
<!-- class="example" -->
<p>The <code>PASSING</code> clause of function <code>XMLTable</code> passes the <code>OBJECT_VALUE</code> of <code>XMLType</code> table <code>purchaseorder</code>, to serve as the XPath context. The <code>XMLTable</code> expression thus <span class="italic">depends</span> on the <code>purchaseorder</code> table. Because of this, table <code>purchaseorder</code> must appear <span class="italic">before</span> the <code>XMLTable</code> expression in the <code>FROM</code> list. This is a general requirement in any situation involving data dependence.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Whenever a <code>PASSING</code> <a id="sthref430"></a><a id="sthref431"></a><a id="sthref432"></a>clause refers to a column of an <code>XMLType</code> table in a query, that table <span class="bolditalic">must appear before</span> the <code>XMLTable</code> expression in the query <code>FROM</code> list. This is because the <code>XMLTable</code> expression <span class="italic">depends</span> on the <code>XMLType</code> table&thinsp;&mdash;&thinsp;a <span class="italic">left lateral</span> (correlated) join is needed, to ensure a one-to-many (1:N) relationship between the <code>XMLType</code> table row accessed and the rows generated from it by <code>XMLTable</code>.</div>
<p><a href="#CBAJIBCD">Example 5-10</a> is similar to <a href="#CBAHBFGE">Example 5-9</a> in its effect. It uses <code>XMLQuery</code>, instead of <code>XMLTable</code>, to query <code>oe.purchaseorder</code>. These two examples differ in their treatment of the empty sequences returned by the XQuery expression. In <a href="#CBAHBFGE">Example 5-9</a>, these empty sequences are not joined with the <code>purchaseorder</code> table, so the overall SQL-query result set has only ten rows. In <a href="#CBAJIBCD">Example 5-10</a>, these empty sequences are part of the overall result set of the SQL query, which contains 132 rows, one for each of the rows in table <code>purchaseorder</code>. All but ten of those rows are empty, and show up in the output as empty lines. To save space here, those empty lines have been removed.</p>
<div id="ADXDB5136" class="example">
<p class="titleinexample"><a id="CBAJIBCD"></a>Example 5-10 Using XMLQUERY with Schema-Based Data</p>
<pre>
SELECT XMLQuery('for $i in /PurchaseOrder
                 where $i/CostCenter eq "A10"
                   and $i/User eq "SMCCAIN"
                 return &lt;A10po pono="{$i/Reference}"/&gt;'
                PASSING OBJECT_VALUE
                RETURNING CONTENT)
  FROM purchaseorder;
 
XMLQUERY('FOR$IIN/PURCHASEORDERWHERE$I/COSTCENTEREQ"A10"AND$I/USEREQ"SMCCAIN"RET
--------------------------------------------------------------------------------
&lt;A10po pono="SMCCAIN-20021009123336151PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336341PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123337173PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123335681PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123335470PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336972PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336842PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123336512PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-2002100912333894PDT"&gt;&lt;/A10po&gt;
&lt;A10po pono="SMCCAIN-20021009123337403PDT"&gt;&lt;/A10po&gt;
 
<span class="bold">132 rows selected.</span>
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBAFEHBC">Example 5-17</a> for the execution plan of <a href="#CBAJIBCD">Example 5-10</a></div>
<p><a href="#CBAJEEFD">Example 5-11</a> uses <code>XMLTable</code> clauses <code>PASSING</code> and <code>COLUMNS</code>. The XQuery expression iterates over top-level <code>PurchaseOrder</code> elements, constructing a <code>PO</code> element for each purchase order with cost center <code>A10</code>. The resulting <code>PO</code> elements are then passed to <code>XMLTable</code> for processing.</p>
<div id="ADXDB5137" class="example">
<p class="titleinexample"><a id="CBAJEEFD"></a>Example 5-11 Using XMLTABLE with PASSING and COLUMNS Clauses</p>
<pre>
SELECT xtab.poref, xtab.priority, xtab.contact
  FROM purchaseorder,
       XMLTable('for $i in /PurchaseOrder
                 let $spl := $i/SpecialInstructions
                 where $i/CostCenter eq "A10"
                 return &lt;PO&gt;
                          &lt;Ref&gt;{$i/Reference}&lt;/Ref&gt;
                          {if ($spl eq "Next Day Air" or $spl eq "Expedite") then
                             &lt;Type&gt;Fastest&lt;/Type&gt;
                           else if ($spl eq "Air Mail") then
                             &lt;Type&gt;Fast&lt;/Type&gt;
                           <span class="bold">else ()}</span>
                          &lt;Name&gt;{$i/Requestor}&lt;/Name&gt;
                        &lt;/PO&gt;'
                <span class="bold">PASSING</span> OBJECT_VALUE
                <span class="bold">COLUMNS</span> poref    VARCHAR2(20) PATH 'Ref',
                        priority VARCHAR2(8)  PATH 'Type' <span class="bold">DEFAULT</span> 'Regular',
                        contact  VARCHAR2(20) PATH 'Name') xtab;
 
POREF                PRIORITY CONTACT
-------------------- -------- --------------------
SKING-20021009123336 Fastest  Steven A. King
SMCCAIN-200210091233 Regular  Samuel B. McCain
SMCCAIN-200210091233 Fastest  Samuel B. McCain
JCHEN-20021009123337 Fastest  John Z. Chen
JCHEN-20021009123337 Regular  John Z. Chen
SKING-20021009123337 Regular  Steven A. King
SMCCAIN-200210091233 Regular  Samuel B. McCain
JCHEN-20021009123338 Regular  John Z. Chen
SMCCAIN-200210091233 Regular  Samuel B. McCain
SKING-20021009123335 Regular  Steven X. King
SMCCAIN-200210091233 Regular  Samuel B. McCain
SKING-20021009123336 Regular  Steven A. King
SMCCAIN-200210091233 Fast     Samuel B. McCain
SKING-20021009123336 Fastest  Steven A. King
SKING-20021009123336 Fastest  Steven A. King
SMCCAIN-200210091233 Regular  Samuel B. McCain
JCHEN-20021009123335 Regular  John Z. Chen
SKING-20021009123336 Regular  Steven A. King
JCHEN-20021009123336 Regular  John Z. Chen
SKING-20021009123336 Regular  Steven A. King
SMCCAIN-200210091233 Regular  Samuel B. McCain
SKING-20021009123337 Regular  Steven A. King
SKING-20021009123338 Fastest  Steven A. King
SMCCAIN-200210091233 Regular  Samuel B. McCain
JCHEN-20021009123337 Regular  John Z. Chen
JCHEN-20021009123337 Regular  John Z. Chen
JCHEN-20021009123337 Regular  John Z. Chen
SKING-20021009123337 Regular  Steven A. King
JCHEN-20021009123337 Regular  John Z. Chen
SKING-20021009123337 Regular  Steven A. King
SKING-20021009123337 Regular  Steven A. King
SMCCAIN-200210091233 Fast     Samuel B. McCain
 
32 rows selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CBAJEEFD">Example 5-11</a>, data from the children of <code>PurchaseOrder</code> is used to construct the children of <code>PO</code>, which are <code>Ref</code>, <code>Type</code>, and <code>Name</code>. The content of <code>Type</code> is taken from the content of <code>/PurchaseOrder/SpecialInstructions</code>, but the classes of <code>SpecialInstructions</code> are divided up differently for <code>Type</code>.</p>
<p>Function <code>XMLTable</code> breaks up the result of XQuery evaluation, returning it as three <code>VARCHAR2</code> columns of a virtual table: <code>poref</code>, <code>priority</code>, and <code>contact</code>. The <code>DEFAULT</code> clause is used to supply a default <code>priority</code> of <code>Regular</code>.</p>
<p>In <a href="#CBACIIDC">Example 5-12</a>, SQL/XML function <code>XMLTable</code> is used to break up the XML data in an <code>XMLType</code> collection element, <code>LineItem</code>, into separate columns of a virtual table.</p>
<div id="ADXDB5138" class="example">
<p class="titleinexample"><a id="CBACIIDC"></a>Example 5-12 Decomposing XML Collection Elements into Relational Data using XMLTABLE</p>
<pre>
SELECT lines.lineitem, lines.description, lines.partid,
       lines.unitprice, lines.quantity
  FROM purchaseorder,
       XMLTable('for $i in /PurchaseOrder/LineItems/LineItem
                 where $i/@ItemNumber &gt;= 8
                  and $i/Part/@UnitPrice &gt; 50
                  and $i/Part/@Quantity &gt; 2
                 return $i'
                PASSING OBJECT_VALUE
                COLUMNS lineitem    NUMBER       PATH '@ItemNumber',
                        description VARCHAR2(30) PATH 'Description',
                        partid      NUMBER       PATH 'Part/@Id',
                        unitprice   NUMBER       PATH 'Part/@UnitPrice',
                        quantity    NUMBER       PATH 'Part/@Quantity') lines; 

LINEITEM DESCRIPTION                           PARTID UNITPRICE QUANTITY
-------- ------------------------------ ------------- --------- --------
      11 Orphic Trilogy                   37429148327        80        3
      22 Dreyer Box Set                   37429158425        80        4
      11 Dreyer Box Set                   37429158425        80        3
      16 Dreyer Box Set                   37429158425        80        3
       8 Dreyer Box Set                   37429158425        80        3
      12 Brazil                           37429138526        60        3
      18 Eisenstein: The Sound Years      37429149126        80        4
      24 Dreyer Box Set                   37429158425        80        3
      14 Dreyer Box Set                   37429158425        80        4
      10 Brazil                           37429138526        60        3
      17 Eisenstein: The Sound Years      37429149126        80        3
      16 Orphic Trilogy                   37429148327        80        4
      13 Orphic Trilogy                   37429148327        80        4
      10 Brazil                           37429138526        60        4
      12 Eisenstein: The Sound Years      37429149126        80        3
      12 Dreyer Box Set                   37429158425        80        4
      13 Dreyer Box Set                   37429158425        80        4
 
17 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CBABFDJG">Example 5-18</a> for the execution plan of <a href="#CBACIIDC">Example 5-12</a></p>
</li>
<li>
<p><a href="xdb03usg.htm#CHDCAIBH">"Breaking Up Multiple Levels of XML Data"</a>, for an example of applying <code>XMLTable</code> to multiple document levels (multilevel chaining)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CBAFECDI"></a>
<div id="ADXDB5139" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using <a id="sthref433"></a><a id="sthref434"></a>Namespaces with XQuery</h3>
<p>You can use the XQuery <code>declare namespace</code> declaration in the prolog of an XQuery expression to define a namespace prefix. You can use <code>declare</code> <code><span class="codeinlinebold">default</span></code> <code>namespace</code> to establish the namespace as the default namespace for the expression.</p>
<p>Be aware of the following pitfall, if you use SQL*Plus: If the semicolon (<code>;</code>) at the end of a namespace declaration terminates a line, SQL*Plus interprets it as a SQL terminator. To avoid this, you can do one of the following:</p>
<ul>
<li>
<p>Place the text that follows the semicolon on the same line.</p>
</li>
<li>
<p>Place a comment, such as <code><span class="codeinlinebold">(: :)</span></code>, after the semicolon, on the same line.</p>
</li>
<li>
<p>Turn off the recognition of the SQL terminator with SQL*Plus command <code>SET SQLTERMINATOR</code>.</p>
</li>
</ul>
<p><a href="#BABIDFEC">Example 5-13</a> illustrates use of a namespace declaration in an XQuery expression.</p>
<div id="ADXDB5140" class="example">
<p class="titleinexample"><a id="BABIDFEC"></a>Example 5-13 Using XMLQUERY with a Namespace Declaration</p>
<pre>
SELECT XMLQuery('declare namespace e = "http://example.com"<span class="bold">;</span>
ERROR:
ORA-01756: quoted string not properly terminated
 
                 for $i in doc("/public/empsns.xml")/e:emps/e:emp
SP2-0734: unknown command beginning "for $i in ..." - rest of line ignored.
...

-- This works - do not end the line with ";".
SELECT XMLQuery('declare namespace e = "http://example.com"<span class="bold">; for</span>
                     $i in doc("/public/empsns.xml")/e:emps/e:emp
                 let $d := 
                   doc("/public/depts.xml")//dept[deptno=$i/@deptno]/@dname
                 where $i/@salary &gt; 100000
                 order by $i/@empno
                 return &lt;emp ename="{$i/@ename}" dept="{$d}"/&gt;'
                RETURNING CONTENT) FROM DUAL;
 
XMLQUERY('DECLARENAMESPACEE="HTTP://EXAMPLE.COM";FOR$IINDOC("/PUBLIC/EMPSNS.XML"
--------------------------------------------------------------------------------
&lt;emp ename="Jack" dept=""&gt;&lt;/emp&gt;&lt;emp ename="Jill" dept=""&gt;&lt;/emp&gt;

-- This works too - add a comment after the ";".
SELECT XMLQuery('declare namespace e = "http://example.com";  <span class="bold">(: :)</span>
                 for $i in doc("/public/empsns.xml")/e:emps/e:emp
                 let $d := doc("/public/depts.xml")//dept[deptno=$i/@deptno]/@dname
                 where $i/@salary &gt; 100000
                 order by $i/@empno
                 return &lt;emp ename="{$i/@ename}" dept="{$d}"/&gt;'
                RETURNING CONTENT) FROM DUAL;
 
XMLQUERY('DECLARENAMESPACEE="HTTP://EXAMPLE.COM";(::)FOR$IINDOC("/PUBLIC/EMPSNS.
--------------------------------------------------------------------------------
&lt;emp ename="Jack" dept=""&gt;&lt;/emp&gt;&lt;emp ename="Jill" dept=""&gt;&lt;/emp&gt;
 
1 row selected.

-- This works too - tell SQL*Plus to ignore the ";".
<span class="bold">SET SQLTERMINATOR OFF</span>
 
SELECT XMLQuery('declare namespace e = "http://example.com"<span class="bold">;</span>
                 for $i in doc("/public/empsns.xml")/e:emps/e:emp
                 let $d :=
                   doc("/public/depts.xml")//dept[deptno=$i/@deptno]/@dname
                 where $i/@salary &gt; 100000
                 order by $i/@empno
                 return &lt;emp ename="{$i/@ename}" dept="{$d}"/&gt;'
                RETURNING CONTENT) FROM DUAL
<span class="bold">/</span>
 
XMLQUERY('DECLARENAMESPACEE="HTTP://EXAMPLE.COM";FOR$IINDOC("/PUBLIC/EMPSNS.XML"
--------------------------------------------------------------------------------
&lt;emp ename="Jack" dept=""&gt;&lt;/emp&gt;&lt;emp ename="Jill" dept=""&gt;&lt;/emp&gt;
</pre></div>
<!-- class="example" -->
<p>An XQuery namespace declaration has no effect outside of its XQuery expression. To declare a namespace prefix for use in an <code>XMLTable</code> expression outside of the XQuery expression, use the <code>XMLNAMESPACES</code> clause. This clause also covers the XQuery expression argument to <code>XMLTable</code>, eliminating the need for a separate declaration in the XQuery prolog.</p>
<p>In <a href="#CBABFGAJ">Example 5-14</a>, <code>XMLNAMESPACES</code> is used to define the prefix <code>e</code> for the namespace <code>http://example.com</code>. This namespace is used in the <code>COLUMNS</code> clause and the XQuery expression of the <code>XMLTable</code> expression.</p>
<div id="ADXDB5141" class="example">
<p class="titleinexample"><a id="CBABFGAJ"></a>Example 5-14 Using XMLTABLE with the XMLNAMESPACES Clause</p>
<pre>
SELECT * FROM XMLTable(<span class="bold">XMLNAMESPACES ('http://example.com' AS "e"),</span>
                       'for $i in doc("/public/empsns.xml")
                        return $i/<span class="bold">e:</span>emps/<span class="bold">e:</span>emp'
                       COLUMNS name VARCHAR2(6) PATH '@ename',
                               id   NUMBER      PATH '@empno');
</pre>
<p>This produces the following result:</p>
<pre>
NAME           ID
------ ----------
John            1
Jack            2
Jill            3
 
3 rows selected.
</pre>
<p>It is the presence of qualified names <code>e:ename</code> and <code>e:empno</code> in the <code>COLUMNS</code> clause that necessitates using the <code>XMLNAMESPACES</code> clause. Otherwise, a prolog namespace declaration (<code>declare namespace e = "http://example.com"</code>) would suffice for the XQuery expression itself.</p>
<p>Because the same namespace is used throughout the <code>XMLTable</code> expression, a default namespace could be used: <code>XMLNAMESPACES (DEFAULT 'http://example.com')</code>. The qualified name <code>$i/e:emps/e:emp</code> could then be written without an explicit prefix: <code>$i/emps/emp</code>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CBACDEEC"></a>
<div id="ADXDB5142" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref435"></a>Performance Tuning for <a id="sthref436"></a><a id="sthref437"></a><a id="sthref438"></a><a id="sthref439"></a>XQuery</h2>
<p>A SQL query that involves XQuery expressions can often be rewritten (optimized) in one or more ways. This optimization is referred to as <a id="sthref440"></a><span class="glossaryterm">XML query rewrite</span> or optimization. XPath expressions are a proper subset of XQuery expressions.</p>
<p><span class="glossaryterm"><a id="sthref441"></a>XPath rewrite</span> is a subset of XML query rewrite that involves rewriting queries that involve XPath expressions. XPath rewrite includes <code>XMLIndex</code> optimizations, streaming evaluation of binary XML, and rewrite to underlying object-relational or relational structures in the case of structured storage or <code>XMLType</code> views over relational data.</p>
<p>Just as query tuning can improve SQL performance, so it can improve XQuery performance. You tune XQuery performance by choosing appropriate XML storage models and indexes.</p>
<p>As with database queries generally, you determine whether tuning is required by examining the execution plan for a query. If the plan is not optimal, then consult the following documentation for specific tuning information:</p>
<ul>
<li>
<p>For structured storage: <a href="xdb_rewrite.htm#BABHJECG">Chapter 8, "XPath Rewrite for Structured Storage"</a></p>
</li>
<li>
<p>For unstructured storage and binary XML storage: <a href="xdb_indexing.htm#CHDEADIH">Chapter 6, "Indexing XMLType Data"</a></p>
</li>
</ul>
<p>In addition, be aware that the following expressions can be expensive to process, so they might add performance overhead when processing large volumes of data:</p>
<ul>
<li>
<p>SQL expressions that use the following Oracle SQL functions, which accept XPath expression arguments:</p>
<ul>
<li>
<p><code>appendChildXML</code> (use <code>insertChildXMLAfter</code> instead)</p>
</li>
<li>
<p><code>insertXMLAfter</code> (use <code>insertChildXMLAfter</code> instead)</p>
</li>
<li>
<p><code>insertXMLBefore</code> (use <code>insertChildXMLBefore</code> instead)</p>
</li>
</ul>
</li>
<li>
<p>XQuery expressions that use the following axes (use forward and descendent axes instead):</p>
<ul>
<li>
<p><code>ancestor</code></p>
</li>
<li>
<p><code>ancestor-or-self</code></p>
</li>
<li>
<p><code>descendant-or-self</code></p>
</li>
<li>
<p><code>following</code></p>
</li>
<li>
<p><code>following-sibling</code></p>
</li>
<li>
<p><code>namespace</code></p>
</li>
<li>
<p><code>parent</code></p>
</li>
<li>
<p><code>preceding</code></p>
</li>
<li>
<p><code>preceding-sibling</code></p>
</li>
</ul>
</li>
<li>
<p>XQuery expressions that involve node identity (for example, using the order-comparison operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>)</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CBADGDEA">"Oracle XML&nbsp;DB Support for XQuery"</a></div>
<p>The following sections present the execution plans for some of the examples shown earlier in this chapter, to indicate how they are executed.</p>
<ul>
<li>
<p><a href="#BABCCCDD">"XQuery Optimization over Relational Data"</a>: examples with XQuery expressions that target XML data created on the fly using <code>fn:collection</code> together with URI scheme <code>oradb</code>.</p>
</li>
<li>
<p><a href="#BABDIBCJ">"XQuery Optimization over XML Schema-Based XMLType Data"</a>: examples with XQuery expressions that target an XML schema-based <code>XMLType</code> table stored object-relationally</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb_rewrite.htm#BABHJECG">Chapter 8, "XPath Rewrite for Structured Storage"</a></p>
</li>
<li>
<p><a href="xdb_indexing.htm#CHDEADIH">Chapter 6, "Indexing XMLType Data"</a> for information about using <code>XMLIndex</code></p>
</li>
<li>
<p><a href="xdb03usg.htm#BABDBEFG">"How Oracle XML&nbsp;DB Processes XMLType Methods and SQL Functions"</a> for information about streaming evaluation of binary XML data</p>
</li>
</ul>
</div>
<a id="BABIDDAJ"></a>
<div id="ADXDB5143" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Rule-Based and Cost-Based XQuery Optimization</h3>
<p>Several competing optimization possibilities can exist for queries with XQuery expressions, depending on various factors such as the <code>XMLType</code> storage model and indexing that are used.</p>
<p>By default, Oracle XML&nbsp;DB follows a prioritized set of rules to determine which of the possible optimizations should be used for any given query and context. This behavior is referred to as <a id="sthref442"></a><a id="sthref443"></a><span class="glossaryterm">rule-based</span> XML query rewrite.</p>
<p>Alternatively, Oracle XML&nbsp;DB can use <span class="glossaryterm"><a id="sthref444"></a><a id="sthref445"></a>cost-based</span> XML query rewrite. In this mode, Oracle XML&nbsp;DB estimates the performance of the various XML optimization possibilities for a given query and chooses the combination that is expected to be most performant.</p>
<p>You can <a id="sthref446"></a><a id="sthref447"></a>impose cost-based optimization for a given SQL statement by using the optimizer hint <code>/*+ COST_XML_QUERY_REWRITE */</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABCCCDD"></a>
<div id="ADXDB5144" class="sect2">
<h3 class="sect2">XQuery <a id="sthref448"></a>Optimization over Relational Data</h3>
<p><a href="#CBAIJAAD">Example 5-15</a> shows the optimization of <code>XMLQuery</code> over relational data accessed as XML. <a href="#CBAJFIBF">Example 5-16</a> shows the optimization of <code>XMLTable</code> in the same context.</p>
<div id="ADXDB5145" class="example">
<p class="titleinexample"><a id="CBAIJAAD"></a>Example 5-15 Optimization of XMLQuery over Relational Data</p>
<p>Here again is the query of <a href="#CBAJHHJD">Example 5-6</a>, together with its execution plan, which shows that the query has been optimized.</p>
<pre>
SELECT XMLQuery(
         'for $i in fn:collection("oradb:/OE/WAREHOUSES")/ROW
          return &lt;Warehouse id="{$i/WAREHOUSE_ID}"&gt;
                   &lt;Location&gt;
                     {for $j in fn:collection("oradb:/HR/LOCATIONS")/ROW
                      where $j/LOCATION_ID eq $i/LOCATION_ID 
                      return ($j/STREET_ADDRESS, $j/CITY, $j/STATE_PROVINCE)}
                   &lt;/Location&gt;    
                 &lt;/Warehouse&gt;'
         RETURNING CONTENT) FROM DUAL;
</pre>
<pre>
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------------------
Plan hash value: 3341889589

-------------------------------------------------------------------------------------------
| Id  | Operation                    | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |            |     1 |       |     2   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE              |            |     1 |    41 |            |          |
|   2 |   <span class="bold">TABLE ACCESS BY INDEX ROWID</span>| <span class="bold">LOCATIONS</span>  |     1 |    41 |     1   (0)| 00:00:01 |
|*  3 |    <span class="bold">INDEX UNIQUE SCAN</span>         | <span class="bold">LOC_ID_PK</span>  |     1 |       |     0   (0)| 00:00:01 |
|   4 |  SORT AGGREGATE              |            |     1 |     6 |            |          |
|   5 |   TABLE ACCESS FULL          | WAREHOUSES |     9 |    54 |     2   (0)| 00:00:01 |
|   6 |  FAST DUAL                   |            |     1 |       |     2   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - access("LOCATION_ID"=:B1)
 
18 rows selected.
</pre></div>
<!-- class="example" -->
<div id="ADXDB5146" class="example">
<p class="titleinexample"><a id="CBAJFIBF"></a>Example 5-16 Optimization of XMLTable over Relational Data</p>
<p>Here again is the query of <a href="#CBAJEGFH">Example 5-7</a>, together with its execution plan, which shows that the query has been optimized.</p>
<pre>
SELECT * 
  FROM XMLTable(
         'for $i in fn:collection("oradb:/OE/WAREHOUSES")/ROW
          return &lt;Warehouse id="{$i/WAREHOUSE_ID}"&gt;
                   &lt;Location&gt;
                     {for $j in fn:collection("oradb:/HR/LOCATIONS")/ROW
                      where $j/LOCATION_ID eq $i/LOCATION_ID 
                      return ($j/STREET_ADDRESS, $j/CITY, $j/STATE_PROVINCE)}
                   &lt;/Location&gt;
                 &lt;/Warehouse&gt;');
</pre>
<pre>
PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------------------
Plan hash value: 1021775546
 
-------------------------------------------------------------------------------------------
| Id  | Operation                    | Name       | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |            |     9 |    54 |     2   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE              |            |     1 |    41 |            |          |
|   2 |   <span class="bold">TABLE ACCESS BY INDEX ROWID</span>| <span class="bold">LOCATIONS</span>  |     1 |    41 |     1   (0)| 00:00:01 |
|*  3 |    <span class="bold">INDEX UNIQUE SCAN</span>         | <span class="bold">LOC_ID_PK</span>  |     1 |       |     0   (0)| 00:00:01 |
|   4 |  TABLE ACCESS FULL           | WAREHOUSES |     9 |    54 |     2   (0)| 00:00:01 |
-------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - access("LOCATION_ID"=:B1)
 
16 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABDIBCJ"></a>
<div id="ADXDB5147" class="sect2">
<h3 class="sect2">XQuery Optimization over XML <a id="sthref449"></a>Schema-Based XMLType Data</h3>
<p><a href="#CBAFEHBC">Example 5-17</a> shows the optimization of <code>XMLQuery</code> over an XML schema-based <code>XMLType</code> table. <a href="#CBABFDJG">Example 5-18</a> shows the optimization of <code>XMLTable</code> in the same context.</p>
<div id="ADXDB5148" class="example">
<p class="titleinexample"><a id="CBAFEHBC"></a>Example 5-17 Optimization of XMLQuery with Schema-Based XMLType Data</p>
<p>Here again is the query of <a href="#CBAJIBCD">Example 5-10</a>, together with its execution plan, which shows that the query has been optimized.</p>
<pre>
SELECT XMLQuery('for $i in /PurchaseOrder
                 where $i/CostCenter eq "<span class="bold">A10</span>"
                   and $i/User eq "<span class="bold">SMCCAIN</span>"
                 return &lt;A10po pono="{$i/Reference}"/&gt;'
                PASSING OBJECT_VALUE
                RETURNING CONTENT)
  FROM purchaseorder;
 
</pre>
<pre>
PLAN_TABLE_OUTPUT
-------------------------------------------------------------------------------------
Plan hash value: 3611789148
 
-------------------------------------------------------------------------------------
| Id  | Operation           | Name          | Rows  | Bytes | Cost (%CPU)| Time     |
-------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT    |               |     1 |   530 |     5   (0)| 00:00:01 |
|   1 |  SORT AGGREGATE     |               |     1 |       |            |          |
|*  2 |   FILTER            |               |       |       |            |          |
|   3 |    FAST DUAL        |               |     1 |       |     2   (0)| 00:00:01 |
|*  4 |    TABLE ACCESS FULL| PURCHASEORDER |     1 |   530 |     5   (0)| 00:00:01 |
-------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - filter(:B1='<span class="bold">SMCCAIN</span>' AND :B2='<span class="bold">A10</span>')
   4 - filter(SYS_CHECKACL("ACLOID","OWNERID",xmltype('&lt;privilege
              xmlns="http://xmlns.oracle.com/xdb/acl.xsd"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://xmlns.oracle.com/xdb/acl.xsd
              http://xmlns.oracle.com/xdb/acl.xsd DAV:http://xmlns.oracle.com/xdb/dav.xsd"&gt;
              &lt;read-properties/&gt;&lt;read-contents/&gt;&lt;/privilege&gt;'))=1)
 
22 rows selected.
</pre></div>
<!-- class="example" -->
<div id="ADXDB5149" class="example">
<p class="titleinexample"><a id="CBABFDJG"></a>Example 5-18 Optimization of XMLTable with Schema-Based XMLType Data</p>
<p>Here again is the query of <a href="#CBACIIDC">Example 5-12</a>, together with its execution plan, which shows that the query has been optimized. The XQuery result is never materialized. Instead, the underlying storage columns for the XML collection element <code>LineItem</code> are used to generate the overall result set.</p>
<pre>
SELECT lines.lineitem, lines.description, lines.partid,
       lines.unitprice, lines.quantity
  FROM purchaseorder,
       XMLTable('for $i in /PurchaseOrder/LineItems/LineItem
                 where $i/@ItemNumber &gt;= 8
                  and $i/Part/@UnitPrice &gt; 50
                  and $i/Part/@Quantity &gt; 2
                 return $i'
                PASSING OBJECT_VALUE
                COLUMNS lineitem    NUMBER       PATH '@ItemNumber',
                        description VARCHAR2(30) PATH 'Description',
                        partid      NUMBER       PATH 'Part/@Id',
                        unitprice   NUMBER       PATH 'Part/@UnitPrice',
                        quantity    NUMBER       PATH 'Part/@Quantity') lines;
 
</pre>
<pre>
-----------------------------------------------------------------------------------------------
| Id  | Operation                    | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
-----------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT             |                |     4 |   384 |     7   (0)| 00:00:01 |
|   1 |  NESTED LOOPS                |                |       |       |            |          |
|   2 |   NESTED LOOPS               |                |     4 |   384 |     7   (0)| 00:00:01 |
|*  3 |    <span class="bold">TABLE ACCESS FULL</span>         | PURCHASEORDER  |     1 |    37 |     5   (0)| 00:00:01 |
|*  4 |    <span class="bold">INDEX RANGE SCAN</span>          | SYS_C005478    |    17 |       |     1   (0)| 00:00:01 |
|*  5 |   TABLE ACCESS BY INDEX ROWID| LINEITEM_TABLE |     3 |   177 |     2   (0)| 00:00:01 |
-----------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   3 - filter(SYS_CHECKACL("ACLOID","OWNERID",xmltype('&lt;privilege
              xmlns="http://xmlns.oracle.com/xdb/acl.xsd"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://xmlns.oracle.com/xdb/acl.xsd
              http://xmlns.oracle.com/xdb/acl.xsd DAV:http://xmlns.oracle.com/xdb/dav.xsd"&gt;&lt;read-prop
              erties/&gt;&lt;read-contents/&gt;&lt;/privilege&gt;'))=1)
   4 - access("NESTED_TABLE_ID"="PURCHASEORDER"."SYS_NC0003400035$")
   5 - filter("SYS_NC00013$"&gt;50 AND "SYS_NC00012$"&gt;2 AND "ITEMNUMBER"&gt;=8 AND
              "SYS_NC_TYPEID$" IS NOT NULL)
 
25 rows selected.
</pre>
<p>This example traverses table <code>oe.purchaseorder</code> completely. The <code>XMLTable</code> expression is evaluated for each purchase-order document. It is more efficient to have the <code>XMLTable</code> expression, not the <code>purchaseorder</code> table, drive the SQL-query execution.</p>
<p>Although the XQuery expression has been rewritten to relational expressions, you can improve this optimization by creating an <span class="italic">index</span> on the underlying relational data&thinsp;&mdash;&thinsp;you can optimize this query in the same way that you would optimize a purely SQL query. That is always the case with XQuery in Oracle XML&nbsp;DB: the optimization techniques you use are the same as those you use in SQL.</p>
<p>The <code>UnitPrice</code> attribute of collection element <code>LineItem</code> is an appropriate index target. The governing XML schema specifies that an ordered collection table (OCT) is used to store the <code>LineItem</code> elements.</p>
<p>However, the name of this OCT was generated by Oracle XML&nbsp;DB when the XML purchase-order documents were decomposed as XML schema-based data. Instead of using table <code>purchaseorder</code> from sample database schema <code>HR</code>, you could manually create a new <code>purchaseorder</code> table (in a different database schema) with the same properties and same data, but having OCTs with user-friendly names. Refer to <a href="xdb03usg.htm#CHDDIACH">Example 3-13</a> for how to do this.</p>
<p>Assuming that a <code>purchaseorder</code> table has been created as in <a href="xdb03usg.htm#CHDDIACH">Example 3-13</a>, the following statement creates the appropriate index:</p>
<pre>
CREATE INDEX unitprice_index ON lineitem_table("PART"."UNITPRICE");
</pre>
<p>With this index defined, the query of <a href="#CBACIIDC">Example 5-12</a> results in the following execution plan, which shows that the <code>XMLTable</code> expression has driven the overall evaluation.</p>
<pre>
PLAN_TABLE_OUTPUT
----------------------------------------------------------------------------------------
Plan hash value: 1578014525
 
----------------------------------------------------------------------------------------
| Id  | Operation          | Name              | Rows  | Bytes | Cost (%CPU)| Time     |
----------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT   |                   |     3 |   624 |     8   (0)| 00:00:01 |
|   1 |  NESTED LOOPS      |                   |     3 |   624 |     8   (0)| 00:00:01 |
|*  2 |   <span class="bold">INDEX UNIQUE SCAN</span>| SYS_IOT_TOP_49323 |     3 |   564 |     5   (0)| 00:00:01 |
|*  3 |    <span class="bold">INDEX RANGE SCAN</span>| <span class="bold">UNITPRICE_INDEX</span>   |    20 |       |     2   (0)| 00:00:01 |
|*  4 |   <span class="bold">INDEX UNIQUE SCAN</span>| SYS_C004411       |     1 |       |     0   (0)| 00:00:01 |
----------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   2 - access("SYS_NC00013$"&gt;50)
       filter("ITEMNUMBER"&gt;=8 AND "SYS_NC00012$"&gt;2)
   3 - access("SYS_NC00013$"&gt;50)
   4 - access("NESTED_TABLE_ID"="PURCHASEORDER"."SYS_NC0003400035$")
 
Note
-----
   - dynamic sampling used for this statement
 
23 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABHDGJH"></a>
<div id="ADXDB4583" class="sect2">
<h3 class="sect2">Diagnosing XQuery Optimization: XMLOptimizationCheck</h3>
<p>You can examine an execution plan for your SQL code to determine whether XQuery optimization occurs or the plan is instead suboptimal. In the latter case, a note such as the following appears immediately after the plan:</p>
<pre>
Unoptimized XML construct detected (enable XMLOptimizationCheck
for more information)
</pre>
<p>You can also compare the execution plan output with the plan output that you see after you use the optimizer hint <code>NO_XML_QUERY_REWRITE</code>, which turns off XQuery optimization.</p>
<p>In addition, you can use the SQL*Plus <code>SET</code> command with system variable <code><a id="sthref450"></a>XMLOptimizationCheck</code> to turn on an <a id="sthref451"></a><span class="glossaryterm">XML diagnosability mode</span> for SQL:</p>
<pre>
SET XMLOptimizationCheck ON
</pre>
<p>When this mode is on, the plan of execution is automatically checked for XQuery optimization, and if the plan is suboptimal then an error is raised and diagnostic information is written to the trace file indicating which operators are not rewritten.</p>
<p>The main advantage of <code><a id="sthref452"></a>XMLOptimizationCheck</code> is that it brings a potential problem to your attention immediately. For this reason, you might find it preferable to leave it turned on at all times. Then, if an application change or a database change for some reason prevents a SQL operation from rewriting, execution is stopped instead of performance being negatively impacted without your being aware of the cause.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>You can use event 19027 with level 8192 (0x2000) to dump a trace that indicates why a particular expression is not rewritten.</p>
</li>
<li>
<p><code>XMLOptimizationCheck</code> was not available prior to Oracle Database&nbsp;11g Release 2 (11.2.0.2). Users of older releases directly manipulated event 19201 to obtain XQuery optimization information.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xdb_indexing.htm#CHDBBAGA">"Turning Off Use of XMLIndex"</a> for information about optimizer hint <code>NO_XML_QUERY_REWRITE</code></div>
</div>
<!-- class="sect2" -->
<div id="ADXDB5809" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref453"></a>
<h3 class="sect2">Improving Performance for fn:doc and fn:collection on Repository Data</h3>
<p>In Oracle XML&nbsp;DB, you can use XQuery functions <code><a id="sthref454"></a><a id="sthref455"></a>fn:doc</code> and <code>fn:collection</code> to reference documents and collections in Oracle XML&nbsp;DB Repository. When repository XML data is stored object-relationally or as binary XML, queries that use <code>fn:doc</code> and <code>fn:collection</code> are evaluated functionally; that is, they are not optimized to access the underlying storage tables directly.</p>
<p>To improve the performance of such queries, you must link them to the actual database tables that hold the repository data being queried. You can do that in either of the following ways:</p>
<ul>
<li>
<p>Join view <code>RESOURCE_VIEW</code> with the <code>XMLType</code> table that holds the data, and then use the Oracle SQL functions <code>equals_path</code> and <code>under_path</code> instead of the XQuery functions <code>fn:doc</code> and <code>fn:collection</code>, respectively. These SQL functions reference repository resources in a performant way.</p>
</li>
<li>
<p>Use the Oracle XQuery extension-expression pragma <code>ora:defaultTable</code>.</p>
</li>
</ul>
<p>Both methods have the same effect. Oracle recommends that you use the <code>ora:defaultTable</code> pragma because it lets you continue to use the XQuery standard functions <code>fn:doc</code> and <code>fn:collection</code> and it simplifies your code.</p>
<p>These two methods are illustrated in the examples of this section.</p>
<div id="ADXDB5998" class="sect3"><a id="sthref456"></a>
<h4 class="sect3">Using equals_path and under_path Instead of fn:doc and fn:collection</h4>
<p>SQL function <code><a id="sthref457"></a><a id="sthref458"></a>equals_path</code> references a resource located at a specified repository path, and SQL function <code>under_path</code> references a resource located under a specified repository path. <a href="#BABIDGGE">Example 5-19</a> and <a href="#BABBIGDC">Example 5-20</a> illustrate this for functions <code>fn:doc</code> and <code>equals_path</code>; functions <code>fn:collection</code> and <code>under_path</code> are treated similarly.</p>
<div id="ADXDB5810" class="example">
<p class="titleinexample"><a id="BABIDGGE"></a>Example 5-19 Unoptimized Repository Query using fn:doc</p>
<pre>
SELECT XMLQuery('let $val :=
                     fn:doc("/home/OE/PurchaseOrders/2002/Sep/VJONES-20021009123337583PDT.xml")
                     /PurchaseOrder/LineItems/LineItem[@ItemNumber =19]
                 return $val' RETURNING CONTENT)
  FROM DUAL;
</pre></div>
<!-- class="example" -->
<div id="ADXDB5811" class="example">
<p class="titleinexample"><a id="BABBIGDC"></a>Example 5-20 Optimized Repository Query using EQUALS_PATH</p>
<pre>
SELECT XMLQuery('let $val := $DOC/PurchaseOrder/LineItems/LineItem[@ItemNumber = 19]
                 return $val' PASSING OBJECT_VALUE AS "DOC" RETURNING CONTENT)
  FROM RESOURCE_VIEW rv, purchaseorder p
  WHERE ref(p) = XMLCast(XMLQuery('declare default element namespace 
                                   "http://xmlns.oracle.com/xdb/XDBResource.xsd"; (: :)
                                   fn:data<a id="sthref459" href="#sthref459" onclick='footdisplay(6,"XQuery function \u003ccode\u003efn:data\u003c/code\u003e is used here to atomize its argument, in this case returning the \u003ccode\u003eXMLRef\u003c/code\u003e node\x27s typed atomic value.")'><sup class="tablefootnote">Foot 6 </sup></a>(/Resource/XMLRef)' PASSING rv.RES RETURNING CONTENT)
                         AS REF XMLType)
    AND equals_path(rv.RES, '/home/OE/PurchaseOrders/2002/Sep/VJONES-20021009123337583PDT.xml')
        = 1;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABCDFEF"></a>
<div id="ADXDB5999" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using Oracle XQuery Pragma <a id="sthref460"></a>ora:defaultTable</h4>
<p>Oracle XQuery extension-expression pragma <code>ora:defaultTable</code> lets you specify the default table used to store repository data that you query. The query is rewritten to automatically join the default table to view <code>RESOURCE_VIEW</code> and use Oracle SQL functions <code>equals_path</code> and <code>under_path</code> instead of XQuery functions <code>fn:doc</code> and <code>fn:collection</code>, respectively. The effect is thus the same as coding the query manually to use an explicit join and <code>equals_path</code> or <code>under_path</code>. <a href="#BABFGFEJ">Example 5-21</a> illustrates this; the query is rewritten automatically to what is shown in <a href="#BABBIGDC">Example 5-20</a>.</p>
<div id="ADXDB6000" class="example">
<p class="titleinexample"><a id="BABFGFEJ"></a>Example 5-21 Repository Query using Oracle XQuery Pragma ora:defaultTable</p>
<pre>
SELECT XMLQuery('for $doc in <span class="bold">(#ora:defaultTable PURCHASEORDER #)</span>
                             {fn:doc("/home/OE/PurchaseOrders/2002/Sep/VJONES-20021009123337583PDT.xml")}
                   let $val := $doc/PurchaseOrder/LineItems/LineItem[@ItemNumber = 19]
                     return $val}'
                RETURNING CONTENT)
  FROM DUAL;
</pre></div>
<!-- class="example" -->
<p>For clarity of scope Oracle recommends that you apply pragma <code>ora:defaultTable</code> directly to the relevant document or collection expression, <code>fn:doc</code> or <code>fn:collection</code>, rather than to a larger expression.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CBAHDDBE"></a>
<div id="ADXDB5150" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref461"></a><a id="sthref462"></a><a id="sthref463"></a><a id="sthref464"></a>XQuery Static Type-Checking in Oracle XML&nbsp;DB</h2>
<p>Oracle XML&nbsp;DB type-checks <span class="italic">all</span> XQuery expressions. Doing this at run time can be costly, however. As an optimization technique, whenever there is sufficient static type information available for a given query at compile time, Oracle XML&nbsp;DB performs <span class="italic">static</span> (compile time) type-checking of that query. Whenever sufficient static type information is not available for a given query at compile time, Oracle XML&nbsp;DB uses dynamic (run-time) type checking for that query.</p>
<p>Static type-checking can save execution time by raising errors at compile time. Static type-checking errors include both data-type errors and the use of XPath expressions that are invalid with respect to an XML schema.</p>
<p>Typical ways of providing sufficient static type information at query compile time include the following:</p>
<ul>
<li>
<p>Using XQuery with <code>fn:doc</code> or <code>fn:collection</code> over relational data.</p>
</li>
<li>
<p>Using XQuery to query an <code>XMLType</code> table, column, or view whose XML Schema information is available at query compile time.</p>
</li>
</ul>
<p>This section presents examples that demonstrate the utility of static type-checking and the use of these two means of communicating type information.</p>
<p>The XML data produced on the fly by <code>fn:collection</code> together with URI scheme <code>oradb</code> has <code>ROW</code> as its top-level element, but the query of <a href="#BABFDFHI">Example 5-22</a> incorrectly lacks that <code>ROW</code> wrapper element. This omission raises a query compile-time error. Forgetting that <code>fn:collection</code> with <code>oradb</code> wraps relational data in this way is an easy mistake to make, and one that could be difficult to diagnose without static type-checking. <a href="#CBAFCFCF">Example 5-5</a> shows the correct code.</p>
<div id="ADXDB5151" class="example">
<p class="titleinexample"><a id="BABFDFHI"></a>Example 5-22 Static Type-Checking of XQuery Expressions: oradb URI scheme</p>
<pre>
-- This produces a static-type-check error, because "ROW" is missing.
SELECT XMLQuery('for $i in fn:collection("oradb:/HR/REGIONS"),
                     $j in fn:collection("oradb:/HR/COUNTRIES")
                 where $i/REGION_ID = $j/REGION_ID and $i/REGION_NAME = "Asia"
                 return $j'
                RETURNING CONTENT) AS asian_countries
  FROM DUAL;
SELECT XMLQuery('for $i in fn:collection("oradb:/HR/REGIONS"),
*
ERROR at line 1:
ORA-19276: XPST0005 - XPath step specifies an invalid element/attribute name:
(REGION_ID)
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABIDDDF">Example 5-23</a>, XQuery static type-checking finds a mismatch between an XPath expression and its target XML schema-based data. Element <code>CostCenter</code> is misspelled here as <code>costcenter</code> (XQuery and XPath are case-sensitive). <a href="#CBAJEEFD">Example 5-11</a> shows the correct code.</p>
<div id="ADXDB5152" class="example">
<p class="titleinexample"><a id="BABIDDDF"></a>Example 5-23 Static Type-Checking of XQuery Expressions: Schema-Based XML</p>
<pre>
-- This results in a static-type-check error: CostCenter is not the right case.
SELECT xtab.poref, xtab.usr, xtab.requestor
  FROM purchaseorder,
       XMLTable('for $i in /PurchaseOrder where $i/<span class="bold">costcenter</span> eq "A10" return $i'
                PASSING OBJECT_VALUE
                COLUMNS poref     VARCHAR2(20) PATH 'Reference',
                        usr       VARCHAR2(20) PATH 'User' DEFAULT 'Unknown',
                        requestor VARCHAR2(20) PATH 'Requestor') xtab;
  FROM purchaseorder,
       *
ERROR at line 2:
ORA-19276: XPST0005 - XPath step specifies an invalid element/attribute name:
(costcenter)
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CBAGFIAE"></a>
<div id="ADXDB5153" class="sect1">
<h2 class="sect1"><a id="sthref465"></a><a id="sthref466"></a><a id="sthref467"></a>SQL*Plus XQUERY Command</h2>
<p><a href="#CBACBEFC">Example 5-24</a> shows how you can enter an XQuery expression directly at the SQL*Plus command line, by preceding the expression with the SQL*Plus command <code><span class="codeinlinebold">XQUERY</span></code> and following it with a slash (<code>/</code>) on a line by itself. Oracle Database treats XQuery expressions submitted with this command the same way it treats XQuery expressions in SQL/XML functions <code>XMLQuery</code> and <code>XMLTable</code>. Execution is identical, with the same optimizations.</p>
<div id="ADXDB5154" class="example">
<p class="titleinexample"><a id="CBACBEFC"></a>Example 5-24 Using the SQL*Plus XQUERY Command</p>
<pre>
SQL&gt; XQUERY for $i in fn:collection("oradb:/HR/DEPARTMENTS")
  2  where $i/ROW/DEPARTMENT_ID &lt; 50
  3  return $i
  4  /
 
Result Sequence
--------------------------------------------------------------------------------
&lt;ROW&gt;&lt;DEPARTMENT_ID&gt;10&lt;/DEPARTMENT_ID&gt;&lt;DEPARTMENT_NAME&gt;Administration&lt;/DEPARTMEN
T_NAME&gt;&lt;MANAGER_ID&gt;200&lt;/MANAGER_ID&gt;&lt;LOCATION_ID&gt;1700&lt;/LOCATION_ID&gt;&lt;/ROW&gt;
 
&lt;ROW&gt;&lt;DEPARTMENT_ID&gt;20&lt;/DEPARTMENT_ID&gt;&lt;DEPARTMENT_NAME&gt;Marketing&lt;/DEPARTMENT_NAM
E&gt;&lt;MANAGER_ID&gt;201&lt;/MANAGER_ID&gt;&lt;LOCATION_ID&gt;1800&lt;/LOCATION_ID&gt;&lt;/ROW&gt;
 
&lt;ROW&gt;&lt;DEPARTMENT_ID&gt;30&lt;/DEPARTMENT_ID&gt;&lt;DEPARTMENT_NAME&gt;Purchasing&lt;/DEPARTMENT_NA
ME&gt;&lt;MANAGER_ID&gt;114&lt;/MANAGER_ID&gt;&lt;LOCATION_ID&gt;1700&lt;/LOCATION_ID&gt;&lt;/ROW&gt;
 
&lt;ROW&gt;&lt;DEPARTMENT_ID&gt;40&lt;/DEPARTMENT_ID&gt;&lt;DEPARTMENT_NAME&gt;Human Resources&lt;/DEPARTME
NT_NAME&gt;&lt;MANAGER_ID&gt;203&lt;/MANAGER_ID&gt;&lt;LOCATION_ID&gt;2400&lt;/LOCATION_ID&gt;&lt;/ROW&gt;
</pre></div>
<!-- class="example" -->
<p>There are also a few SQL*Plus <code>SET</code> commands that you can use for settings that are specific to XQuery. Use <code>SHOW XQUERY</code> to see the current settings.</p>
<ul>
<li>
<p><code><span class="codeinlinebold">SET XQUERY BASEURI</span></code> &ndash; Set the base URI for <code>XQUERY</code>. URIs in XQuery expressions are relative to this URI.</p>
</li>
<li>
<p><code><span class="codeinlinebold">SET XQUERY CONTEXT</span></code> &ndash; Specify a context item for subsequent <code>XQUERY</code> evaluations.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQPUG135" href="../../server.112/e16604/ch_twelve052.htm#SQPUG135"><span class="italic">SQL*Plus User's Guide and Reference</span></a></div>
</div>
<!-- class="sect1" -->
<a id="CBAEEJDE"></a>
<div id="ADXDB5155" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using XQuery with PL/SQL, JDBC, and ODP.NET</h2>
<p>Previous sections in this chapter have shown how to invoke XQuery from SQL. This section provides examples of using XQuery with the Oracle APIs for PL/SQL, JDBC, and Oracle Data Provider for .NET (ODP.NET).</p>
<p><a href="#BABJFFAC">Example 5-25</a> shows how to use XQuery with PL/SQL, in particular, how to bind <span class="italic">dynamic variables</span> to an XQuery expression using the <code>XMLQuery</code> <code>PASSING</code> clause. The bind variables <code>:1</code> and <code>:2</code> are bound to the PL/SQL bind arguments <code>nbitems</code> and <code>partid</code>, respectively. These are then passed to XQuery as XQuery variables <code>itemno</code> and <code>id</code>, respectively.</p>
<div id="ADXDB5156" class="example">
<p class="titleinexample"><a id="BABJFFAC"></a>Example 5-25 Using XQuery with PL/SQL</p>
<pre>
DECLARE
  sql_stmt VARCHAR2(2000); -- Dynamic SQL statement to execute
  <span class="bold">nbitems</span>  NUMBER := 3; -- Number of items
  <span class="bold">partid</span>   VARCHAR2(20):= '715515009058'; -- Part ID
  result   XMLType;
  doc      DBMS_XMLDOM.DOMDocument;
  ndoc     DBMS_XMLDOM.DOMNode;
  buf      VARCHAR2(20000);
BEGIN
  sql_stmt :=
    'SELECT XMLQuery(
              ''for $i in fn:collection("oradb:/OE/PURCHASEORDER") ' ||
               'where count($i/PurchaseOrder/LineItems/LineItem) = <span class="bold">$itemno</span> ' ||
                 'and $i/PurchaseOrder/LineItems/LineItem/Part/@Id = <span class="bold">$id</span> ' ||
               'return $i/PurchaseOrder/LineItems'' ' ||
              'PASSING <span class="bold">:1</span> AS "<span class="bold">itemno</span>", <span class="bold">:2</span> AS "<span class="bold">id</span>" ' ||
              'RETURNING CONTENT) FROM DUAL';
 
  EXECUTE IMMEDIATE sql_stmt INTO result USING <span class="bold">nbitems</span>, <span class="bold">partid</span>;
  doc  := DBMS_XMLDOM.newDOMDocument(result);
  ndoc := DBMS_XMLDOM.makeNode(doc);
  DBMS_XMLDOM.writeToBuffer(ndoc, buf);
  DBMS_OUTPUT.put_line(buf);
END;
/
</pre>
<p>This produces the following output:</p>
<pre>
&lt;LineItems&gt;
  &lt;LineItem ItemNumber="1"&gt;
    &lt;Description&gt;Samurai 2: Duel at Ichijoji Temple&lt;/Description&gt;
    &lt;Part Id="37429125526" UnitPrice="29.95" Quantity="3"/&gt;
  &lt;/LineItem&gt;
  &lt;LineItem ItemNumber="2"&gt;
    &lt;Description&gt;The Red Shoes&lt;/Description&gt;
    &lt;Part Id="37429128220" UnitPrice="39.95" Quantity="4"/&gt;
  &lt;/LineItem&gt;
  &lt;LineItem ItemNumber="3"&gt;
    &lt;Description&gt;A Night to Remember&lt;/Description&gt;
    &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="1"/&gt;
  &lt;/LineItem&gt;
&lt;/LineItems&gt;
&lt;LineItems&gt;
  &lt;LineItem ItemNumber="1"&gt;
    &lt;Description&gt;A Night to Remember&lt;/Description&gt;
    &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="2"/&gt;
  &lt;/LineItem&gt;
  &lt;LineItem ItemNumber="2"&gt;
    &lt;Description&gt;The Unbearable Lightness Of Being&lt;/Description&gt;
    &lt;Part Id="37429140222" UnitPrice="29.95" Quantity="2"/&gt;
  &lt;/LineItem&gt;
  &lt;LineItem ItemNumber="3"&gt;
    &lt;Description&gt;Sisters&lt;/Description&gt;
    &lt;Part Id="715515011020" UnitPrice="29.95" Quantity="4"/&gt;
  &lt;/LineItem&gt;
&lt;/LineItems&gt;

PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p><a href="#BABEJFCH">Example 5-26</a> shows how to use XQuery with JDBC, binding variables by position with the <code>PASSING</code> clause of SQL/XML function <code>XMLTable</code>.</p>
<div id="ADXDB5157" class="example">
<p class="titleinexample"><a id="BABEJFCH"></a>Example 5-26 Using XQuery with JDBC</p>
<pre>
import java.sql.*;
import oracle.sql.*;
import oracle.jdbc.*;
import oracle.xdb.XMLType; 
import java.util.*;
 
public class QueryBindByPos
{
  public static void main(String[] args) throws Exception, SQLException
  {
    System.out.println("*** JDBC Access of XQuery using Bind Variables ***");
    DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
    OracleConnection conn
      = (OracleConnection)
        DriverManager.getConnection("jdbc:oracle:oci8:@localhost:1521:ora11gR1", "oe", "oe");
    String xqString
      = "SELECT COLUMN_VALUE" +
          "FROM XMLTable('for $i in fn:collection(\"oradb:/OE/PURCHASEORDER\") " +
                         "where $i/PurchaseOrder/Reference= <span class="bold">$ref</span> " +
                         "return $i/PurchaseOrder/LineItems' " +
                        "PASSING <span class="bold">?</span> AS \"<span class="bold">ref</span>\")";
    OraclePreparedStatement stmt = (OraclePreparedStatement)conn.prepareStatement(xqString);
    String refString = "EABEL-20021009123336251PDT"; // Set the filter value
    stmt.setString(1, refString); // Bind the string
    ResultSet rs = stmt.executeQuery();
    while (rs.next())
    {
       XMLType desc = (XMLType) rs.getObject(1);
       System.out.println("LineItem Description: " + desc.getStringVal());
       desc.close();
    }
    rs.close();
    stmt.close();
  }
}
</pre>
<p>This produces the following output:</p>
<pre>
*** JDBC Access of Database XQuery with Bind Variables ***
LineItem Description: Samurai 2: Duel at Ichijoji Temple
LineItem Description: The Red Shoes
LineItem Description: A Night to Remember
</pre></div>
<!-- class="example" -->
<p><a href="#BABBCACI">Example 5-27</a> shows how to use XQuery with ODP.NET and the C# language. The C# input parameters <code>:nbitems</code> and <code>:partid</code> are passed to XQuery as XQuery variables <code>itemno</code> and <code>id</code>, respectively.</p>
<div id="ADXDB5158" class="example">
<p class="titleinexample"><a id="BABBCACI"></a>Example 5-27 Using XQuery with ODP.NET and C#</p>
<pre>
using System;
using System.Data;
using System.Text;
using System.IO;
using System.Xml;
using Oracle.DataAccess.Client;
using Oracle.DataAccess.Types;
 
namespace XQuery
{
  /// &lt;summary&gt;
  /// Demonstrates how to bind variables for XQuery calls
  /// &lt;/summary&gt;
  class XQuery
  {
    /// &lt;summary&gt;
    /// The main entry point for the application.
    /// &lt;/summary&gt;
    static void Main(string[] args)
    {
      int rows = 0;
      StreamReader sr = null;
 
      // Create the connection.
      string constr = "User Id=oe;Password=***********;Data Source=ora11gr2"; // Replace with real password.
      OracleConnection con = new OracleConnection(constr);
      con.Open();
 
      // Create the command.
      OracleCommand cmd = new OracleCommand("", con);
 
      // Set the XML command type to query.
      cmd.CommandType   = CommandType.Text;
        
      // Create the SQL query with the XQuery expression.
      StringBuilder blr = new StringBuilder();
      blr.Append("SELECT COLUMN_VALUE FROM XMLTable");
      blr.Append("(\'for $i in fn:collection(\"oradb:/OE/PURCHASEORDER\") ");
      blr.Append("   where count($i/PurchaseOrder/LineItems/LineItem) = <span class="bold">$itemno</span> ");
      blr.Append("      and $i/PurchaseOrder/LineItems/LineItem/Part/@Id = <span class="bold">$id</span> ");
      blr.Append("   return $i/PurchaseOrder/LineItems\' ");
      blr.Append("  PASSING <span class="bold">:nbitems</span> AS \"<span class="bold">itemno</span>\", <span class="bold">:partid</span> AS \"<span class="bold">id</span>\")");
 
      cmd.CommandText = blr.ToString();
      cmd.Parameters.Add("<span class="bold">:nbitems</span>", OracleDbType.Int16, 3, ParameterDirection.Input);
      cmd.Parameters.Add("<span class="bold">:partid</span>", OracleDbType.Varchar2, "715515009058", ParameterDirection.Input);
 
      // Get the XML document as an XmlReader.
      OracleDataReader dr = cmd.ExecuteReader();
      dr.Read();
 
      // Get the XMLType column as an OracleXmlType
      OracleXmlType xml = dr.GetOracleXmlType(0);
 
      // Print the XML data in the OracleXmlType object
      Console.WriteLine(xml.Value);
      xml.Dispose();
 
      // Clean up.
      cmd.Dispose();
      con.Close();
      con.Dispose();
    }
  }
}
</pre>
<p>This produces the following output:</p>
<pre>
&lt;LineItems&gt;
  &lt;LineItem ItemNumber="1"&gt;
    &lt;Description&gt;Samurai 2: Duel at Ichijoji Temple&lt;/Description&gt;
    &lt;Part Id="37429125526" UnitPrice="29.95" Quantity="3"/&gt;
  &lt;/LineItem&gt;
  &lt;LineItem ItemNumber="2"&gt;
    &lt;Description&gt;The Red Shoes&lt;/Description&gt;
    &lt;Part Id="37429128220" UnitPrice="39.95" Quantity="4"/&gt;
  &lt;/LineItem&gt;
  &lt;LineItem ItemNumber="3"&gt;
    &lt;Description&gt;A Night to Remember&lt;/Description&gt;
    &lt;Part Id="715515009058" UnitPrice="39.95" Quantity="1"/&gt;
  &lt;/LineItem&gt;
&lt;/LineItems&gt;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xdb10pls.htm#g1056962">Chapter 13, "PL/SQL APIs for XMLType"</a></p>
</li>
<li>
<p><a href="xdb11jav.htm#g1039140">Chapter 15, "Java DOM API for XMLType"</a></p>
</li>
<li>
<p><a href="xdb_odpnet.htm#BIICCFHB">Chapter 17, "Using Oracle Data Provider for .NET with Oracle XML&nbsp;DB"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CBADGDEA"></a>
<div id="ADXDB5159" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref468"></a>Oracle XML&nbsp;DB Support for XQuery</h2>
<p>This section describes Oracle XML&nbsp;DB for the XQuery language.</p>
<a id="CBAECCIJ"></a>
<div id="ADXDB5160" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Support for XQuery and SQL</h3>
<p>Support for the XQuery language in Oracle XML&nbsp;DB is designed to provide the best fit between the worlds of relational storage and querying XML data. That is, Oracle XML&nbsp;DB is a general XQuery implementation, but it is in addition specifically designed to make relational and XQuery queries work well together.</p>
<p>The specific properties of the Oracle XML&nbsp;DB XQuery implementation are described in this section. The XQuery standard explicitly calls out certain aspects of the language processing as implementation-defined or implementation-dependent. There are also some features that are specified by the XQuery standard but are not supported by Oracle XML&nbsp;DB.</p>
<div id="ADXDB5161" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref469"></a>
<h4 class="sect3">Implementation Choices Specified in the XQuery Standard</h4>
<p>The XQuery specification specifies that each of the following aspects of language processing is to be defined by the implementation.</p>
<ul>
<li>
<p><span class="italic">Implicit time zone support &ndash;</span> In Oracle XML&nbsp;DB, the implicit time zone is always assumed to be <code>Z</code>, and instances of <code>xs:date</code>, <code>xs:time</code>, and <code>xs:datetime</code> that are missing time zones are&nbsp; automatically converted to UTC.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADXDB5162" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref470"></a>
<h4 class="sect3">XQuery Features Not Supported by Oracle XML&nbsp;DB</h4>
<p>The following features specified by the XQuery standard are not supported by Oracle XML&nbsp;DB:</p>
<ul>
<li>
<p><span class="italic">Copy-namespace mode</span> &ndash; Oracle XML&nbsp;DB supports only <code>preserve</code> and <code>inherit</code> for a <code>copy-namespaces</code> declaration. If an existing element node is copied by an element constructor or a document constructor, all in-scope namespaces of the original element are retained in the copy. Otherwise, the copied node inherits all in-scope namespaces of the constructed node. An error is raised if you specify <code>no-preserve</code> or <code>no-inherit</code>.</p>
</li>
<li>
<p><span class="italic">Version encoding</span> &ndash; Oracle XML&nbsp;DB does not support an optional encoding declaration in a version declaration. That is, you cannot include <code>(encoding</code> <code><span class="codeinlineitalic">an-encoding</span></code><code>)</code> in a declaration <code>xquery version</code> <code><span class="codeinlineitalic">a-version</span></code><code>;</code>. In particular, you cannot specify an encoding used in the query. An error is raised if you include an encoding declaration.</p>
</li>
<li>
<p><span class="italic">xml:id</span> &ndash; Oracle XML&nbsp;DB does not support use of <code>xml:id</code>. If you use <code>xml:id</code>, then an error is raised.</p>
</li>
<li>
<p>XQuery prolog default-collation declaration.</p>
</li>
<li>
<p>XQuery prolog boundary-space declaration.</p>
</li>
<li>
<p>XQuery data type <code>xs:duration</code>. Use either <code>xs:yearMonthDuration</code> or <code>xs:DayTimeDuration</code> instead.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BABICHDC"></a>
<div id="ADXDB5163" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">XQuery Optional Features</h4>
<p>The following optional features specified by the XQuery standard are not supported by Oracle XML&nbsp;DB:</p>
<ul>
<li>
<p>Schema Validation Feature</p>
</li>
<li>
<p>Module Feature</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CBACGAIC"></a>
<div id="ADXDB5164" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Support for XQuery Functions and Operators</h3>
<p>Oracle XML&nbsp;DB supports all of the XQuery functions and <a id="sthref471"></a><a id="sthref472"></a><a id="sthref473"></a><a id="sthref474"></a><a id="sthref475"></a><a id="sthref476"></a><a id="sthref477"></a><a id="sthref478"></a>operators included in the latest <span class="italic">XQuery 1.0 and XPath 2.0 Functions and Operators</span> specification, with the following exceptions. There is <span class="italic">no</span> support for the following:</p>
<ul>
<li>
<p>The XQuery regular-expression functions: <code>fn:matches</code>, <code>fn:replace</code>, and <code>fn:tokenize</code>. Use Oracle XQuery functions <code>ora:matches</code>, <code>ora:replace</code>, and <code>ora:tokenize</code> instead, respectively.</p>
</li>
<li>
<p>Functions <code>fn:id</code> and <code>fn:idref</code>.</p>
</li>
<li>
<p>Function <code>fn:collection</code> without arguments.</p>
</li>
<li>
<p>Optional collation parameters for XQuery functions.</p>
</li>
</ul>
<a id="CBABJDAG"></a>
<div id="ADXDB5165" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">XQuery Functions fn:doc, fn:collection, and fn:doc-available</h4>
<p>Oracle XML&nbsp;DB supports XQuery <a id="sthref479"></a>functions <code>fn:doc</code>, <code>fn:collection</code>, and <code>fn:doc-available</code> for all resources in Oracle XML&nbsp;DB Repository.</p>
<p>Function <code>fn:doc</code> returns the repository <span class="italic">file</span> resource that is targeted by its URI argument; it must be a file of well-formed XML data. Function <code>fn:collection</code> is similar, but works on repository <span class="italic">folder</span> resources (each file in the folder must contain well-formed XML data).</p>
<p>When used with Oracle URI scheme <code>oradb</code>, <code>fn:collection</code> can return XML data derived on the fly from existing relational data that is not in the repository.</p>
<p>XQuery function <code>fn:collection</code> raises an error when used with URI scheme <code>oradb</code>, if its targeted table or view, or a targeted column, does not exist. Functions <code>fn:doc</code> and <code>fn:collection</code> do <span class="italic">not</span> raise an error if the repository resource passed as argument is not found. Instead, they return an empty sequence.</p>
<p>You can determine whether a given document exists using XQuery function <code>fn:doc-available</code>. It returns <code>true</code> if its document argument exists, <code>false</code> if not.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<code><a href="http://www.w3.org">http://www.w3.org</a></code> for the definitions of XQuery functions and operators</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" -->
<hr />
<br />
<p style="text-decoration:underline">Footnote Legend</p>
Footnote&nbsp;1:&nbsp;The value returned is a sequence, as always. However, in XQuery, a sequence of one item is equivalent to that item itself. In this case, the single item is a Boolean value.<br />
Footnote&nbsp;2:&nbsp;Namespace prefix <code>xs</code> is predefined for the XML Schema namespace, <code>http://www.w3.org/2001/XMLSchema</code>.<br />
Footnote&nbsp;3:&nbsp;The question mark (<code>?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <a href="#CBABGHHC">"XQuery Expressions"</a>.<br />
Footnote&nbsp;4:&nbsp;The question mark (<code>?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <a href="#CBABGHHC">"XQuery Expressions"</a>.<br />
Footnote&nbsp;5:&nbsp;The question mark (<code>?</code>) here is a zero-or-one occurrence indicator that indicates that the argument can be the empty sequence. See <a href="#CBABGHHC">"XQuery Expressions"</a>.<br />
Footnote&nbsp;6:&nbsp;XQuery function <code>fn:data</code> is used here to atomize its argument, in this case returning the <code>XMLRef</code> node's typed atomic value.<br /></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1019">
<tr>
<td class="cellalignment1028">
<table class="cellalignment1024">
<tr>
<td class="cellalignment1023"><a href="xdb04cre.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1023"><a href="xdb_indexing.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1030">
<table class="cellalignment1022">
<tr>
<td class="cellalignment1023"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1023"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1023"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1023"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1023"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1023"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
