<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using the XML Parser for C</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T14:20:38Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML Developer's Kit Programmer's Guide" />
<meta name="dcterms.identifier" content="E23582-06" />
<meta name="dcterms.isVersionOf" content="ADXDK" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adx_c_xslt.htm" title="Previous" type="text/html" />
<link rel="Next" href="adx_c_xmlbin.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23582.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">27/47</span> <!-- End Header -->
<div id="ADXDK1400" class="chapter"><a id="i451906"></a>
<h1 class="chapter"><span class="secnum">18</span> Using the XML Parser for C</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CCHEGHHA">Introduction to the XML Parser for C</a></p>
</li>
<li>
<p><a href="#i453234">Using the XML Parser for C</a></p>
</li>
<li>
<p><a href="#i452668">Using the DOM API for C</a></p>
</li>
<li>
<p><a href="#CCHFFDHF">Using orastream Functions</a></p>
</li>
<li>
<p><a href="#CCHGHCBF">Using the SAX API for C</a></p>
</li>
<li>
<p><a href="#CCHBGCIF">Using the XML Pull Parser for C</a></p>
</li>
<li>
<p><a href="#i454255">Using OCI and the XDK C API</a></p>
</li>
</ul>
<a id="CCHEGHHA"></a>
<div id="ADXDK19749" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Introduction to the XML Parser for C</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHFFHIF">Prerequisites</a></p>
</li>
<li>
<p><a href="#CCHHICDJ">Standards and Specifications</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adx_j_parser.htm#CCHCCEHA">"Introduction to the XML Parsing for Java"</a> for a generic introduction to XML parsing with DOM and SAX. Much of the information in the introduction is language-independent and applies equally to C.</div>
<a id="CCHFFHIF"></a>
<div id="ADXDK19750" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Prerequisites</h3>
<p>The Oracle XML parser for C reads an XML document and uses DOM or SAX APIs to provide programmatic access to its content and structure. You can use the parser in validating or nonvalidating mode. A pull parser is also available.</p>
<p>This chapter assumes that you are familiar with the following technologies:</p>
<ul>
<li>
<p><a href="glossary.htm#CBAGDBJI"><span class="xrefglossterm">Document Object Model (DOM)</span></a>. DOM is an in-memory tree representation of the structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#CBAFICHD"><span class="xrefglossterm">Simple API for XML (SAX)</span></a>. SAX is a standard for event-based XML parsing.</p>
</li>
<li>
<p><a href="#CCHBGCIF"><span class="xreftitlebold">Using the XML Pull Parser for C</span></a>. Pull Parser uses XML events.</p>
</li>
<li>
<p><a href="glossary.htm#CBAHIAFA"><span class="xrefglossterm">Document Type Definition (DTD)</span></a>. An XML DTD defines the legal structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#CBABDIHJ"><span class="xrefglossterm">XML Schema</span></a>. Like a DTD, an XML schema defines the legal structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#CBAEJBCC"><span class="xrefglossterm">XML Namespaces</span></a>. Namespaces are a mechanism for differentiating element and attribute names.</p>
</li>
</ul>
<p>If you require a general introduction to the preceding technologies, consult the XML resources listed in <a href="preface.htm#CIAFJDBI">"Related Documents"</a> of the preface.</p>
</div>
<!-- class="sect2" -->
<a id="CCHHICDJ"></a>
<div id="ADXDK19751" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Standards and Specifications</h3>
<p>XML 1.0 is a W3C Recommendation. The C XDK API provides full support for XML 1.0 (Second Edition). You can find the specification for the Second Edition at the following URL:</p>
<pre dir="ltr">
<a href="http://www.w3.org/TR/2000/REC-xml-20001006">http://www.w3.org/TR/2000/REC-xml-20001006</a>
</pre>
<p>The DOM Level 1, Level 2, and Level 3 specifications are W3C Recommendations. The C XDK API provides full support for DOM Level 1 and 2, but no support for Level 3. You can find links to the specifications for all three levels at the following URL:</p>
<pre dir="ltr">
<a href="http://www.w3.org/DOM/DOMTR">http://www.w3.org/DOM/DOMTR</a>
</pre>
<p>SAX is available in version 1.0, which is deprecated, and 2.0. SAX is not a W3C specification. The C XDK API provides full support for both SAX 1.0 and 2.0. You can find the documentation for SAX at the following URL:</p>
<pre dir="ltr">
<a href="http://www.saxproject.org">http://www.saxproject.org</a>
</pre>
<p>XML Namespaces are a W3C Recommendation. You can find the specification at the following URL:</p>
<pre dir="ltr">
<a href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</a>
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adx_ref_standards.htm#BABDIIJG">Chapter 31, "XDK Standards"</a> for a summary of the standards supported by the XDK</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i453234"></a>
<div id="ADXDK19752" class="sect1">
<h2 class="sect1">Using the XML Parser for C</h2>
<p>Oracle XML parser for C checks if an XML document is well-formed, and optionally validates it against a DTD. Your application can access the parsed data through the DOM or SAX APIs.</p>
<a id="CCHHIIBC"></a>
<div id="ADXDK19753" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Overview of the Parser API for C</h3>
<p>The core of the XML parsing API are the XML, DOM, and SAX APIs. <a href="#CCHEDFAC">Table 18-1</a> describes the interfaces for these APIs. Refer to <a class="olink CAXML00100" href="../../appdev.112/e10770/datatypes.htm#CAXML00100"><span class="italic">Oracle XML API Reference</span></a> for the complete API documentation.</p>
<div id="ADXDK19754" class="tblruleformalwide">
<p class="titleintable"><a id="sthref495"></a><a id="CCHEDFAC"></a>Table 18-1 Interfaces for XML, DOM, and SAX APIs</p>
<table class="cellalignment1211" title="Interfaces for XML, DOM, and SAX APIs" summary="Summarizes the C APIs for the XML parser." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t4">Package</th>
<th class="cellalignment1212" id="r1c2-t4">Interfaces</th>
<th class="cellalignment1212" id="r1c3-t4">Function Name Convention</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t4" headers="r1c1-t4">
<p>XML</p>
</td>
<td class="cellalignment1213" headers="r2c1-t4 r1c2-t4">
<p>This package implements a single <code dir="ltr">XML</code> interface. The interface defines functions for the following tasks:</p>
<ul>
<li>
<p>Creating and destroying contexts. A top-level XML context (<code dir="ltr">xmlctx</code>) shares common information between cooperating XML components.</p>
</li>
<li>
<p>Creating and parsing XML documents and DTDs.</p>
</li>
</ul>
</td>
<td class="cellalignment1213" headers="r2c1-t4 r1c3-t4">
<p>Function names begin with the string <code dir="ltr">Xml</code>.</p>
<p>Refer to <a class="olink CAXML6192" href="../../appdev.112/e10770/xmldiff.htm#CAXML6192"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t4" headers="r1c1-t4">
<p>DOM</p>
</td>
<td class="cellalignment1213" headers="r3c1-t4 r1c2-t4">
<p>This package provides programmatic access to parsed XML. The package implements the following interfaces:</p>
<ul>
<li>
<p><code dir="ltr">Attr</code> defines get and set functions for XML attributes.</p>
</li>
<li>
<p><code dir="ltr">CharacterData</code> defines functions for manipulating character data.</p>
</li>
<li>
<p><code dir="ltr">Document</code> defines functions for creating XML nodes, obtaining information about an XML document, and setting the DTD for a document.</p>
</li>
<li>
<p><code dir="ltr">DocumentType</code> defines get functions for DTDs.</p>
</li>
<li>
<p><code dir="ltr">Element</code> defines get and set functions for XML elements.</p>
</li>
<li>
<p><code dir="ltr">Entity</code> defines get functions for XML entities.</p>
</li>
<li>
<p><code dir="ltr">NamedNodeMap</code> defines get functions for named nodes.</p>
</li>
<li>
<p><code dir="ltr">Node</code> defines get and set functions for XML nodes.</p>
</li>
<li>
<p><code dir="ltr">NodeList</code> defines functions that free a node list and get a node from a list.</p>
</li>
<li>
<p><code dir="ltr">Notation</code> defines functions that get the system and public ID from a node.</p>
</li>
<li>
<p><code dir="ltr">ProcessingInstruction</code> defines get and set functions for processing instructions.</p>
</li>
<li>
<p><code dir="ltr">Text</code> defines a function that splits a text node into two.</p>
</li>
</ul>
</td>
<td class="cellalignment1213" headers="r3c1-t4 r1c3-t4">
<p>Function names begin with the string <code dir="ltr">XmlDom</code>.</p>
<p>Refer to <a class="olink CAXML00300" href="../../appdev.112/e10770/dom.htm#CAXML00300"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t4" headers="r1c1-t4">
<p>SAX</p>
</td>
<td class="cellalignment1213" headers="r4c1-t4 r1c2-t4">
<p>This package provides programmatic access to parsed XML. The package implements the <code dir="ltr">SAX</code> interface, which defines functions that receive notifications for SAX events.</p>
</td>
<td class="cellalignment1213" headers="r4c1-t4 r1c3-t4">
<p>Function names begin with the string <code dir="ltr">XmlSax</code>.</p>
<p>Refer to <a class="olink CAXML5908" href="../../appdev.112/e10770/sax.htm#CAXML5908"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t4" headers="r1c1-t4">
<p>XML Pull Parser</p>
</td>
<td class="cellalignment1213" headers="r5c1-t4 r1c2-t4">
<p>XML events is a representation of an XML document which is similar to SAX events in that the document is represented as a sequence of events like start tag, end tag, comment, and so on. The difference is that SAX events are driven by the parser (producer) and XML events are driven by the application (consumer).</p>
</td>
<td class="cellalignment1213" headers="r5c1-t4 r1c3-t4">
<p>Function names begin with the string <code dir="ltr">XmlEv</code>.</p>
<p>Refer to <a class="olink CAXML02000" href="../../appdev.112/e10770/event.htm#CAXML02000"><span class="italic">Oracle Database XML C API Reference</span></a> for API documentation.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwide" -->
<a id="CCHGFEDF"></a>
<div id="ADXDK19755" class="sect3">
<h4 class="sect3">XML Parser for C Datatypes</h4>
<p>Refer to <a class="olink CAXML00100" href="../../appdev.112/e10770/datatypes.htm#CAXML00100"><span class="italic">Oracle XML API Reference</span></a> for the complete list of datatypes for the C XDK. <a href="#g455054">Table 18-2</a> describes the datatypes used in the XML parser for C.</p>
<div id="ADXDK19756" class="tblformal">
<p class="titleintable"><a id="sthref496"></a><a id="g455054"></a>Table 18-2 Datatypes Used in the XML Parser for C</p>
<table class="cellalignment1214" title="Datatypes Used in the XML Parser for C " summary="Datatype and Description are the column names." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t5">Datatype</th>
<th class="cellalignment1212" id="r1c2-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t5" headers="r1c1-t5">
<p class="synopsis"><code dir="ltr">oratext</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t5 r1c2-t5">
<p>String pointer</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t5" headers="r1c1-t5">
<p class="synopsis"><code dir="ltr">xmlctx</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t5 r1c2-t5">
<p>Master XML context</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t5" headers="r1c1-t5">
<p class="synopsis"><code dir="ltr">xmlsaxcb</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t5 r1c2-t5">
<p>SAX callback structure (SAX only)</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t5" headers="r1c1-t5">
<p class="synopsis"><code dir="ltr">ub4</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t5 r1c2-t5">
<p>32-bit (or larger) unsigned integer</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t5" headers="r1c1-t5">
<p class="synopsis"><code dir="ltr">uword</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t5 r1c2-t5">
<p>Native unsigned integer</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<a id="CCHFGACF"></a>
<div id="ADXDK19757" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">XML Parser for C Defaults</h4>
<p>Note the following defaults for the XML parser for C:</p>
<ul>
<li>
<p>Character set encoding is UTF-8. If all your documents are ASCII, then setting the encoding to US-ASCII increases performance.</p>
</li>
<li>
<p>The parser prints messages to <code dir="ltr">stderr</code> unless an error handler is provided.</p>
</li>
<li>
<p>The parser checks inputs documents for well-formedness but not validity. You can set the property "validate" to validate the input.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is recommended that you set the default encoding explicitly if using only single byte character sets (such as US-ASCII or any of the ISO-8859 character sets) for faster performance than is possible with multibyte character sets such as UTF-8.</div>
</li>
<li>
<p>The parser conforms to the XML 1.0 specification when processing whitespace, that is, the parser reports all whitespace to the application but indicates which whitespace can be ignored. However, some applications may prefer to set the property "discard-whitespace," which discards all whitespace between an end-element tag and the following start-element tag.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CAXML00300" href="../../appdev.112/e10770/dom.htm#CAXML00300"><span class="italic">Oracle Database XML C API Reference</span></a> for the DOM, SAX, pull parser, and callback APIs.</p>
</li>
<li>
<p><code dir="ltr"><a href="http://www.oracle.com/technetwork/database-features/xdk/overview/index.html">http://www.oracle.com/technetwork/database-features/xdk/overview/index.html</a></code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHEJDEJ"></a>
<div id="ADXDK19758" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XML Parser for C Calling Sequence</h3>
<p><a href="#BABCDCDC">Figure 18-1</a> illustrates the calling sequence for the XML parser for C.</p>
<div id="ADXDK19759" class="figure">
<p class="titleinfigure"><a id="BABCDCDC"></a>Figure 18-1 XML Parser for C Calling Sequence</p>
<img width="660" height="944" src="img/adxdk096.gif" alt="Description of Figure 18-1 follows" /><br />
<a id="sthref497" href="img_text/adxdk096.htm">Description of "Figure 18-1 XML Parser for C Calling Sequence"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="i453326"></a>
<div id="ADXDK19760" class="sect2">
<h3 class="sect2">Using the XML Parser for C: Basic Process</h3>
<p>Perform the following steps in your application:</p>
<ol>
<li>
<p>Initialize the parsing process with the <code dir="ltr">XmlCreate()</code> function. The following sample code fragment is from <code dir="ltr">DOMNamespace.c</code>:</p>
<pre dir="ltr">
xmlctx     *xctx;
...
xctx = XmlCreate(&amp;ecode, (oratext *) "namespace_xctx", NULL);
</pre></li>
<li>
<p>Parse the input item, which can be an XML document or string buffer.</p>
<p>If you are parsing with DOM, call the <code dir="ltr">XmlLoadDom()</code> function. The following sample code fragment is from <code dir="ltr">DOMNamespace.c</code>:</p>
<pre dir="ltr">
xmldocnode *doc;
...
doc = XmlLoadDom(xctx, &amp;ecode, "file", DOCUMENT,
                 "validate", TRUE, "discard_whitespace", TRUE, NULL);
</pre>
<p>If you are parsing with SAX, call the <code dir="ltr">XmlLoadSax()</code> function. The following sample code fragment is from <code dir="ltr">SAXNamespace.c</code>:</p>
<pre dir="ltr">
xmlerr      ecode;
...
ecode = XmlLoadSax(xctx, &amp;sax_callback, &amp;sc, "file", DOCUMENT,
                   "validate", TRUE, "discard_whitespace", TRUE, NULL);
</pre>
<p>If you are using the pull parser, then include the following steps to create the event context and load the document to parse:</p>
<pre dir="ltr">
evctx = XmlEvCreatePPCtx(xctx, &amp;xerr, NULL);
XmlEvLoadPPDoc(xctx, evctx, "File", input_filenames[i], 0, NULL);
</pre></li>
<li>
<p>If you are using the DOM interface, then include the following steps:</p>
<ul>
<li>
<p>Use the <code dir="ltr">XmlLoadDom()</code> function to call <code dir="ltr">XmlDomGetDocElem()</code>. This step calls other DOM functions, which are typically node or print functions that output the DOM document, as required. The following sample code fragment is from <code dir="ltr">DOMNamespace.c</code>:</p>
<pre dir="ltr">
printElements(xctx, XmlDomGetDocElem(xctx, doc));
</pre></li>
<li>
<p>Invoke the <code dir="ltr">XmlFreeDocument()</code> function to clean up any data structures created during the parse process. The following sample code fragment is from <code dir="ltr">DOMNamespace.c</code>:</p>
<pre dir="ltr">
XmlFreeDocument(xctx, doc);
</pre></li>
</ul>
<p>If you are using the SAX interface, then include the following steps:</p>
<ul>
<li>
<p>Process the results of the invocation of <code dir="ltr">XmlLoadSax()</code> with a callback function, such as the following</p>
<pre dir="ltr">
xmlsaxcb saxcb = {
 UserStartDocument,  /* user's own callback functions */
 UserEndDocument,
 /* ... */
}; 

if (XmlLoadSax(xctx, &amp;saxcb, NULL, "file", "some_file.xml", NULL) != 0)
  /* an error occured */
</pre></li>
<li>
<p>Register the callback functions. Note that you can set any of the SAX callback functions to <code dir="ltr">NULL</code> if not needed.</p>
</li>
</ul>
<p>If you are using the pull parser, iterate over the events using:</p>
<pre dir="ltr">
cur_event = XmlEvNext(evctx);
</pre>
<p>Use the Get APIs to get information about that event.</p>
</li>
<li>
<p>Use <code dir="ltr">XmlFreeDocument()</code> to clean up the memory and structures used during a parse. The program does not free memory allocated for parameters passed to the SAX callbacks or for nodes and data stored with the DOM parse tree until you call <code dir="ltr">XMLFreeDocument()</code> or <code dir="ltr">XMLDestroy()</code>. The following sample code fragment is from <code dir="ltr">DOMNamespace.c</code>:</p>
<pre dir="ltr">
XmlFreeDocument(xctx, doc);
</pre>
<p>Either return to Step 2 or proceed to the next step.</p>
<p>For the pull parser call <code dir="ltr">XmlEvCleanPPCtx()</code> to release memory and structures used during the parse. The application can call <code dir="ltr">XmlEvLoadPPDoc()</code> again to parse another document. Or, it can call <code dir="ltr">XMLEvDestroyPPCtx()</code> after which the pull parser context cannot be used again.</p>
<pre dir="ltr">
XmlEvCleanPPCtx(xctx, evctx);
...
XmlEvDestroyPPCtx(xctx, evctx);
</pre></li>
<li>
<p>Terminate the parsing process with <code dir="ltr">XmlDestroy()</code>. The following sample code fragment is from <code dir="ltr">DOMNamespace.c</code>:</p>
<pre dir="ltr">
(void) XmlDestroy(xctx);
</pre>
<p>If threads fork off somewhere in the sequence of calls between initialization and termination, the application produces unpredictable behavior and results.</p>
</li>
</ol>
<p>You can use the memory callback functions <code dir="ltr">XML_ALLOC_F</code> and <code dir="ltr">XML_FREE_F</code> for your own memory allocation. If you do, then specify both functions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHBGCIF">"Using the XML Pull Parser for C"</a></div>
</div>
<!-- class="sect2" -->
<a id="CCHDJEHA"></a>
<div id="ADXDK19761" class="sect2">
<h3 class="sect2">Running the XML Parser for C Demo Programs<a id="sthref498"></a><a id="sthref499"></a><a id="sthref500"></a><a id="sthref501"></a><a id="sthref502"></a></h3>
<p>The <code dir="ltr">$ORACLE_HOME/xdk/demo/c/</code> (UNIX) and <code dir="ltr">%ORACLE_HOME%\xdk\demo\c</code> (Windows) directories include several XML applications that illustrate how to use the XML parser for C with the DOM and SAX interfaces. <a href="#CCHJHGCD">Table 18-3</a> describes the demos.</p>
<p>The <code dir="ltr">make</code> utility compiles the source file <code dir="ltr"><span class="codeinlineitalic">fileName.c</span></code> to produce the demo program <code dir="ltr"><span class="codeinlineitalic">fileName</span></code> and the output file <code dir="ltr"><span class="codeinlineitalic">fileName.out</span></code> . The <code dir="ltr"><span class="codeinlineitalic">fileName.std</span></code> is the expected output.</p>
<div id="ADXDK19762" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref503"></a><a id="CCHJHGCD"></a>Table 18-3 C Parser Demos</p>
<table class="cellalignment1211" title="C Parser Demos" summary="Describes the subdirectories of the /demo/java directory." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t9">Directory</th>
<th class="cellalignment1212" id="r1c2-t9">Contents</th>
<th class="cellalignment1212" id="r1c3-t9">Demos</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t9" headers="r1c1-t9">
<p><code dir="ltr">dom</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t9 r1c2-t9">
<pre dir="ltr">
DOMNamespace.c
DOMSample.c
FullDom.c
FullDom.xml
NSExample.xml
Traverse.c
XPointer.c
class.xml
cleo.xml
pantry.xml
</pre></td>
<td class="cellalignment1213" headers="r2c1-t9 r1c3-t9">
<p>The following demo programs use the DOM API:</p>
<ul>
<li>
<p>The <code dir="ltr">DOMNamespace</code> program uses Namespace extensions to the DOM API. It prints out all elements and attributes of <code dir="ltr">NSExample.xml</code> along with full namespace information.</p>
</li>
<li>
<p>The <code dir="ltr">DOMSample</code> program uses DOM APIs to display an outline of <span class="italic">Cleopatra</span>, that is, the XML elements <code dir="ltr">ACT</code> and <code dir="ltr">SCENE</code>. The <code dir="ltr">cleo.xml</code> document contains the XML version of Shakespeare's <span class="italic">The Tragedy of Antony and Cleopatra</span>.</p>
</li>
<li>
<p>The <code dir="ltr">FullDom</code> program shows sample usage of the full DOM interface. It exercises all the calls. The program accepts <code dir="ltr">FullDom.xml</code>, which shows the use of entities, as input.</p>
</li>
<li>
<p>The <code dir="ltr">Traverse</code> program illustrates the use of DOM iterators, tree walkers, and ranges. The program accepts the <code dir="ltr">class.xml</code> document, which describes a college Calculus course, as input.</p>
</li>
<li>
<p>The <code dir="ltr">XPointer</code> program illustrates the use of the XML Pointer Language by locating the children of the <code dir="ltr">&lt;pantry&gt;</code> element in <code dir="ltr">pantry.xml</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t9" headers="r1c1-t9">
<p><code dir="ltr">sax</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t9 r1c2-t9">
<pre dir="ltr">
NSExample.xml
SAXNamespace.c
SAXSample.c
cleo.xml
</pre></td>
<td class="cellalignment1213" headers="r3c1-t9 r1c3-t9">
<p>The following demo programs use the SAX APIs:</p>
<ul>
<li>
<p>The <code dir="ltr">SAXNamespace</code> program uses namespace extensions to the SAX API. It prints out all elements and attributes of <code dir="ltr">NSExample.xml</code> along with full namespace information.</p>
</li>
<li>
<p>The <code dir="ltr">SAXSample</code> program uses SAX APIs to show all lines in the play <span class="italic">Cleopatra</span> containing a given word. If you do not specify a word, then it uses the word "death." The <code dir="ltr">cleo.xml</code> document contains the XML version of Shakespeare's <span class="italic">The Tragedy of Antony and Cleopatra</span>.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>You can find documentation that describes how to compile and run the sample programs in the <code dir="ltr">README</code> in the same directory. The basic steps are as follows:</p>
<ol>
<li>
<p>Change into the <code dir="ltr">$ORACLE_HOME/xdk/demo/c</code> directory (UNIX) or <code dir="ltr">%ORACLE_HOME%\xdk\demo\c</code> directory (Windows).</p>
</li>
<li>
<p>Make sure that your environment variables are set as described in <a href="adx_c_gs.htm#CHDJEIDC">"Setting C XDK Environment Variables on UNIX"</a> and <a href="adx_c_gs.htm#i1015381">"Setting C XDK Environment Variables on Windows"</a>.</p>
</li>
<li>
<p>Run <code dir="ltr">make</code> (UNIX) or <code dir="ltr">Make.bat</code> (Windows) at the system prompt. The <code dir="ltr">make</code> utility changes into each demo subdirectory and runs <code dir="ltr">make</code> to do the following:</p>
<ol>
<li>
<p>Compiles the C source files with the <code dir="ltr">cc</code> utility. For example, the <code dir="ltr">Makefile</code> in the <code dir="ltr">$ORACLE_HOME/xdk/demo/c/dom</code> directory includes the following line:</p>
<pre dir="ltr">
$(CC) -o DOMSample $(INCLUDE) $@.c $(LIB)
</pre></li>
<li>
<p>Runs each demo program and redirects the output to a file. For example, the <code dir="ltr">Makefile</code> in the <code dir="ltr">$ORACLE_HOME/xdk/demo/c/dom</code> directory includes the following line:</p>
<pre dir="ltr">
./DOMSample &gt; DOMSample.out
</pre></li>
</ol>
</li>
<li>
<p>Compare the <code dir="ltr">*.std</code> files to the <code dir="ltr">*.out</code> files for each program. The <code dir="ltr">*.std</code> file contains the expected output for each program. For example, <code dir="ltr">DOMSample.std</code> contains the expected output from running <code dir="ltr">DOMSample</code>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDEDCGH"></a>
<div id="ADXDK19763" class="sect2">
<h3 class="sect2">Using the C XML Parser Command-Line Utility</h3>
<p>The <code dir="ltr">xml</code> utility, which is located in <code dir="ltr">$ORACLE_HOME/bin</code> (UNIX) or <code dir="ltr">%ORACLE_HOME%\bin</code> (Windows), is a command-line interface that parses XML documents. It checks for both well-formedness and validity.</p>
<p>To use <code dir="ltr">xml</code> ensure that your environment is set up as described in <a href="adx_c_gs.htm#CHDJEIDC">"Setting C XDK Environment Variables on UNIX"</a> and <a href="adx_c_gs.htm#i1015381">"Setting C XDK Environment Variables on Windows"</a>.</p>
<p>Use the following syntax on the command line to invoke <code dir="ltr">xml</code>. Use <code dir="ltr">xml.exe</code> for Windows:</p>
<pre dir="ltr">
xml [options] [document URI]
xml -f [options] [document filespec]
</pre>
<p><a href="#g1016893">Table 18-4</a> describes the command-line options.</p>
<div id="ADXDK19764" class="tblformal">
<p class="titleintable"><a id="sthref504"></a><a id="g1016893"></a>Table 18-4 C XML Parser Command-Line Options</p>
<table class="cellalignment1214" title="C XML Parser Command-Line Options " summary="Option and Meaning are the columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t10">Option</th>
<th class="cellalignment1212" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-B</code> BaseURI</p>
</td>
<td class="cellalignment1213" headers="r2c1-t10 r1c2-t10">
<p>Sets the base URI for the XSLT processor. The base URI of <code dir="ltr">http://pqr/xsl.txt</code> resolves <code dir="ltr">pqr.txt</code> to <code dir="ltr">http://pqr/pqr.txt</code>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-c</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t10 r1c2-t10">
<p>Checks well-formedness, but performs no validation.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-e</code> <code dir="ltr"><span class="codeinlineitalic">encoding</span></code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t10 r1c2-t10">
<p>Specifies default input file encoding ("incoding").</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-E</code> <code dir="ltr"><span class="codeinlineitalic">encoding</span></code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t10 r1c2-t10">
<p>Specifies DOM/SAX encoding ("outcoding").</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-f</code> <code dir="ltr"><span class="codeinlineitalic">file</span></code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t10 r1c2-t10">
<p>Interprets the file as filespec, not URI.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-G</code> <code dir="ltr"><span class="codeinlineitalic">xptr_exprs</span></code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t10 r1c2-t10">
<p>Evaluates <code dir="ltr">XPointer</code> scheme examples given in a file.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-h</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t10 r1c2-t10">
<p>Shows usage help and basic list of command-line options.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-hh</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t10 r1c2-t10">
<p>Shows complete list command-line options.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-i</code> <code dir="ltr"><span class="codeinlineitalic">n</span></code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t10 r1c2-t10">
<p>Specifies the number of times to iterate the <code dir="ltr">XSLT</code> processing.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-l</code> <code dir="ltr"><span class="codeinlineitalic">language</span></code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t10 r1c2-t10">
<p>Specifies the language for error reporting.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r12c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-n</code></p>
</td>
<td class="cellalignment1213" headers="r12c1-t10 r1c2-t10">
<p>Traverses the DOM and reports the number of elements, as shown in the following sample output:</p>
<pre dir="ltr">
ELEMENT       1
 PCDATA       1
    DOC       1
  TOTAL       3 * 60 = 180
</pre></td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r13c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-o</code> <code dir="ltr"><span class="codeinlineitalic">XSLoutfile</span></code></p>
</td>
<td class="cellalignment1213" headers="r13c1-t10 r1c2-t10">
<p>Specifies the output file of the <code dir="ltr">XSLT</code> processor.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r14c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-p</code></p>
</td>
<td class="cellalignment1213" headers="r14c1-t10 r1c2-t10">
<p>Prints the document/DTD structures after the parse. For example, the root element <code dir="ltr">&lt;greeting&gt;hello&lt;/greeting&gt;</code> is printed as:</p>
<pre dir="ltr">
+---ELEMENT greeting 
    +---PCDATA "hello"
</pre></td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r15c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-P</code></p>
</td>
<td class="cellalignment1213" headers="r15c1-t10 r1c2-t10">
<p>Prints the document from the root element. For example, the root element <code dir="ltr">&lt;greeting&gt;hello&lt;/greeting&gt;</code> is printed as:</p>
<pre dir="ltr">
&lt;greeting&gt;hello&lt;/greeting&gt;
</pre></td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r16c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-PP</code></p>
</td>
<td class="cellalignment1213" headers="r16c1-t10 r1c2-t10">
<p>Prints from the root node (DOC) and includes the XML declaration.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r17c1-t10" headers="r1c1-t10">
<p><code dir="ltr"><span class="codeinlineitalic">-PE encoding</span></code></p>
</td>
<td class="cellalignment1213" headers="r17c1-t10 r1c2-t10">
<p>Specifies the encoding for <code dir="ltr">-P</code> or <code dir="ltr">-PP</code> output.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r18c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-PX</code></p>
</td>
<td class="cellalignment1213" headers="r18c1-t10 r1c2-t10">
<p>Includes the XML declaration in the output.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r19c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-s</code> <code dir="ltr"><span class="codeinlineitalic">stylesheet</span></code></p>
</td>
<td class="cellalignment1213" headers="r19c1-t10 r1c2-t10">
<p>Specifies the <code dir="ltr">XSLT</code> stylesheet.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r20c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-v</code></p>
</td>
<td class="cellalignment1213" headers="r20c1-t10 r1c2-t10">
<p>Displays the XDK parser version and then exits.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r21c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-V</code> <code dir="ltr"><span class="codeinlineitalic">var value</span></code></p>
</td>
<td class="cellalignment1213" headers="r21c1-t10 r1c2-t10">
<p>Tests top-level variables in <code dir="ltr">CXSLT</code>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r22c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-w</code></p>
</td>
<td class="cellalignment1213" headers="r22c1-t10 r1c2-t10">
<p>Preserves all whitespace.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r23c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-W</code></p>
</td>
<td class="cellalignment1213" headers="r23c1-t10 r1c2-t10">
<p>Stops parsing after a warning.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r24c1-t10" headers="r1c1-t10">
<p><code dir="ltr">-x</code></p>
</td>
<td class="cellalignment1213" headers="r24c1-t10 r1c2-t10">
<p>Exercises the SAX interface and prints the document, as shown in the following sample output:</p>
<pre dir="ltr">
StartDocument
XMLDECL version='1.0' encoding=FALSE
&lt;greeting&gt;
    "hello"
&lt;/greeting&gt;
EndDocument
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="ADXDK19765" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref505"></a>
<h4 class="sect3">Using the XML Parser Command-Line Utility: Example</h4>
<p>You can test <code dir="ltr">xml</code> on the various XML files located in <code dir="ltr">$ORACLE_HOME/xdk/demo/c</code>. <a href="#BGBFHECI">Example 18-1</a> displays the contents of <code dir="ltr">NSExample.xml</code>.</p>
<div id="ADXDK19766" class="example">
<p class="titleinexample"><a id="BGBFHECI"></a>Example 18-1 NSExample.xml</p>
<pre dir="ltr">
&lt;!DOCTYPE doc [
&lt;!ELEMENT doc (child*)&gt;
&lt;!ATTLIST doc xmlns:nsprefix CDATA #IMPLIED&gt;
&lt;!ATTLIST doc xmlns CDATA #IMPLIED&gt;
&lt;!ATTLIST doc nsprefix:a1 CDATA #IMPLIED&gt;
&lt;!ELEMENT child (#PCDATA)&gt;
]&gt;
&lt;doc nsprefix:a1 = "v1" xmlns="http://www.w3c.org" 
     xmlns:nsprefix="http://www.oracle.com"&gt;
&lt;child&gt;
This element inherits the default Namespace of doc.
&lt;/child&gt;
&lt;/doc&gt;
</pre></div>
<!-- class="example" -->
<p>You can parse this file, count the number of elements, and display the DOM tree as shown in the following example:</p>
<pre dir="ltr">
xml -np NSEample.xml &gt; xml.out
</pre>
<p>The output is shown in the following example:</p>
<div id="ADXDK19767" class="example">
<p class="titleinexample"><a id="sthref506"></a>Example 18-2 xml.out</p>
<pre dir="ltr">
   ELEMENT       2
    PCDATA       1
       DOC       1
       DTD       1
  ELEMDECL       2
  ATTRDECL       3
     TOTAL      10 * 112 = 1120
+---ELEMENT doc [nsprefix:a1='v1'*, xmlns='http://www.w3c.org'*, xmlns:nsprefix=
'http://www.oracle.com'*]
    +---ELEMENT child
        +---PCDATA "
This element inherits the default Namespace of doc.
"
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i452668"></a>
<div id="ADXDK19768" class="sect1">
<h2 class="sect1">Using the DOM API for C</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHFDCJJ">Controlling the Data Encoding of XML Documents for the C API</a></p>
</li>
<li>
<p><a href="#CCHFBEBE">Using NULL-Terminated and Length-Encoded C API Functions</a></p>
</li>
<li>
<p><a href="#CCHEJAEC">Handling Errors with the C API</a></p>
</li>
</ul>
<a id="CCHFDCJJ"></a>
<div id="ADXDK19769" class="sect2">
<h3 class="sect2">Controlling the Data Encoding of XML Documents for the C API</h3>
<p>XML data occurs in many encodings. You can control the XML encoding in the following ways:</p>
<ul>
<li>
<p>Specify a default encoding to assume for files that are not self-describing</p>
</li>
<li>
<p>Specify the presentation encoding for DOM or SAX</p>
</li>
<li>
<p>Re-encode when a DOM is serialized</p>
</li>
</ul>
<p>Input XML data is always encoded. Some encodings are entirely self-describing, such as UTF-16, which requires a specific BOM before the start of the actual data. The <code dir="ltr">XMLDecl</code> or MIME header of the document can also specify an encoding. If the application cannot determine the specific encoding, then it applies the default input encoding. If you do not provide a default, then the application assumes UTF-8 on ASCII platforms and UTF-E on EBCDIC platforms.</p>
<p>The API makes a provision for cases when the encoding data of the input document is corrupt. For example, suppose an ASCII document with an <code dir="ltr">XMLDecl</code> of <code dir="ltr">encoding=ascii</code> is blindly converted to EBCDIC. The new EBCDIC document contains (in EBCDIC) an <code dir="ltr">XMLDecl</code> that incorrectly claims the document is ASCII. The correct behavior for a program that is re-encoding XML data is to regenerate but not convert the <code dir="ltr">XMLDecl</code>. The <code dir="ltr">XMLDecl</code> is metadata, not data itself. This rule is often ignored, however, which results in corrupt documents. To work around this problem, the API provides an additional flag that enables you to forcibly set the input encoding, thereby overcoming an incorrect <code dir="ltr">XMLDecl</code>.</p>
<p>The precedence rules for determining input encoding are as follows:</p>
<ol>
<li>
<p>Forced encoding as specified by the user</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Forced encoding can result in a fatal error if there is a conflict. For example, the input document is UTF-16 and starts with a UTF-16 BOM, but the user specifies a forced UTF-8 encoding. In this case, the parser objects about the conflict.</div>
</li>
<li>
<p>Protocol specification (HTTP header, and so on)</p>
</li>
<li>
<p><code dir="ltr">XMLDecl</code> specification</p>
</li>
<li>
<p>User's default input encoding</p>
</li>
<li>
<p>The default, which is UTF-8 on ASCII platforms or UTF-E on EBCDIC platforms</p>
</li>
</ol>
<p>After the application has determined the input encoding, it can parse the document and present the data. You are allowed to choose the presentation encoding; the data is in that encoding regardless of the original input encoding.</p>
<p>When an application writes back a DOM in serialized form, it can choose at that time to re-encode the presentation data. Thus, the you can place the serialized document in any encoding.</p>
</div>
<!-- class="sect2" -->
<a id="CCHFBEBE"></a>
<div id="ADXDK19770" class="sect2">
<h3 class="sect2">Using NULL-Terminated and Length-Encoded C API Functions</h3>
<p>The native string representation in C is NULL-terminated. Thus, the primary DOM interface takes and returns NULL-terminated strings. When stored in table form, however, Oracle XML DB data is <span class="italic">not</span> NULL-terminated but <span class="italic">length-encoded</span>. Consequently, the XDK provides an additional set of length-encoded APIs for the high-frequency cases to improve performance. In particular, the DOM functions in <a href="#CCHBCCCF">Table 18-5</a> have dual APIs.</p>
<div id="ADXDK19771" class="tblformal">
<p class="titleintable"><a id="sthref507"></a><a id="CCHBCCCF"></a>Table 18-5 NULL-Terminated and Length-Encoded C API Functions</p>
<table class="cellalignment1214" title="NULL-Terminated and Length-Encoded C API Functions " summary="NULL-Terminated API and Length-Encoded API are the columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t12">NULL-Terminated API</th>
<th class="cellalignment1212" id="r1c2-t12">Length-Encoded API</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetNodeName()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetNodeNameLen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetNodeLocal()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetNodeLocalLen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetNodeURI()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetNodeURILen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetNodeValue()</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetNodeValueLen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetAttrName()</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetAttrNameLen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetAttrLocal()</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetAttrLocalLen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetAttrURI()</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetAttrURILen()</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t12" headers="r1c1-t12">
<p><code dir="ltr">XmlDomGetAttrValue()</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t12 r1c2-t12">
<p><code dir="ltr">XmlDomGetAttrValueLen()</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CCHEJAEC"></a>
<div id="ADXDK19772" class="sect2">
<h3 class="sect2">Handling Errors with the C API</h3>
<p>The C API functions typically either return a numeric error code (0 for success, nonzero on failure), or pass back an error code through a variable. In all cases, the API stores error codes. Your application can retrieve the most recent error by calling the <code dir="ltr">XmlDomGetLastError()</code> function.</p>
<p>By default, the functions output error messages to <code dir="ltr">stderr</code>. However, you can register an error message callback at initialization time. When an error occurs, the application invokes the registered callback and does not print an error.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CCHFFDHF"></a>
<div id="ADXDK99918" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><a id="sthref508"></a>Using orastream Functions</h2>
<p>The orastream function API is an interface that enables you to stream large chunks of data out of a node instead of getting it all in one piece. Nodes of greater than 64KB are thus accessible.</p>
<p>The orastream API represents a generic input or output stream. This interface is available to XDK users through <code dir="ltr">xml.h</code> and is defined by the <code dir="ltr">orastream</code> data structure and a set of functions that implement the interface. The creator of the stream passes a list of stream function addresses, along with a stream context to <code dir="ltr">OraStreamInit</code>. This function returns an instance of an <code dir="ltr">orastream</code> structure.</p>
<p>A number of stream properties are specified at the time of initialization. If read or write is provided, the stream operates in byte mode using <code dir="ltr">OraStreamRead()</code> and <code dir="ltr">OraStreamWrite()</code>. If "read_char" or "write_char" is provided, the stream operates in character mode using <code dir="ltr">OraStreamReadChar()</code> and <code dir="ltr">OraStreamWriteChar()</code>. In character mode only complete characters are read or written and are never split over buffer boundaries.</p>
<p>A stream context is used to represent the state of the orastream and it persists for the lifetime of a stream.</p>
<p>Just like the input or output streams in Java, a source or a sink for the data is always specified. Output streams store the address of the external stream or object where they need to populate the data. Similarly, input streams store the address of the object that is read.</p>
<p>Here are the orastream functions:</p>
<pre dir="ltr">
struct orastream;
typedef struct orastream orastream;
typedef ub4 oraerr; /* Error code: zero is success, non-zero is failure */
</pre>
<pre dir="ltr">
/* Initialize (Create) &amp; Destroy (Terminate) stream object */
 
orastream  *OraStreamInit(void *sctx, void *sid, oraerr *err, ...);
oraerr     OraStreamTerm(orastream *stream);
 
/* Set or Change SID (streamID) for stream (returns old stream ID through osid)*/
 
oraerr     OraStreamSid(orastream *stream, void *sid, void **osid);
 
/* Is a stream readable or writable? */
 
boolean    OraStreamReadable(orastream *stream);
boolean    OraStreamWritable(orastream *stream);
 
/* Open &amp; Close stream */
 
oraerr     OraStreamOpen(orastream *stream, ubig_ora *length);
oraerr     OraStreamClose(orastream *stream);
 
/* Read | Write byte stream */
 
oraerr     OraStreamRead(orastream *stream, oratext *dest, ubig_ora size,
           oratext **start, ubig_ora *nread, ub1 *eoi);
oraerr     OraStreamWrite(orastream *stream, oratext *src, ubig_ora size,
           ubig_ora *nwrote);
 
/* Read | Write char stream */
 
oraerr     OraStreamReadChar(orastream *stream, oratext *dest, ubig_ora size,
           oratext **start, ubig_ora *nread, ub1 *eoi);
oraerr     OraStreamWriteChar(orastream *stream, oratext *src, ubig_ora size,
           ubig_ora *nwrote);
 
/* Return handles for stream */
 
orastreamhdl *OraStreamHandle(orastream *stream);
 
/* Returns status: if the stream object is currently opened or not */

boolean OraStreamIsOpen(orastream *stream);
</pre>
<p>The stream error codes are:</p>
<pre dir="ltr">
#define ORASTREAM_ERR_NULL_POINTER      1      /* NULL pointer given */
#define ORASTREAM_ERR_BAD_STREAM        2      /* invalid stream object */
#define ORASTREAM_ERR_WRONG_DECTION     3      /* tried wrong-direction I/O */
#define ORASTREAM_ERR_UNKNOWN_PROPERTY  4      /* unknown creation prop */
#define ORASTREAM_ERR_NO_DIRECTION      5      /* neither read nor write? */
#define ORASTREAM_ERR_BI_DIRECTION      6      /* both read any write? */
#define ORASTREAM_ERR_NOT_OPEN          7      /* stream not open */
#define ORASTREAM_ERR_WRONG_MODE        8      /* wrote byte/char mode */
/* --- Open errors --- */
#define ORASTREAM_ERR_CANT_OPEN         10     /* can't open stream */
/* --- Close errors --- */
#define ORASTREAM_ERR_CANT_CLOSE        20     /* can't close stream */
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CAXML01400" href="../../appdev.112/e10770/orastream.htm#CAXML01400"><span class="italic">Oracle Database XML C API Reference</span></a> for reference information such as parameter definitions in the orastream API</div>
<div id="ADXDK99923" class="example">
<p class="titleinexample"><a id="sthref509"></a>Example 18-3 Using orastream Functions</p>
<pre dir="ltr">
int test_read()
{
   xmlctx *xctx = NULL;
   oratext *barray, *docName = "NSExample.xml";
   orastream* ostream = (orastream *) 0;
   xmlerr ecode = 0;
   ub4 wcount = 0;
   ubig_ora  destsize, nread;
   oraerr oerr = 0;
   ub1 eoi = 0;
   nread = destsize = 1024;
   if (!(xctx = XmlCreateNew(&amp;ecode, (oratext *)"stream_xctx", NULL, wcount,
                             NULL)))
    {
       printf("Failed to create XML context, error %u\n", (unsigned)ecode);
       return -1;
    }
 
   barray = XmlAlloc(xctx, sizeof(oratext) * destsize);
    
   /* open function should be specified in order to read correctly. */
   if (!(ostream = OraStreamInit(NULL,docName, (oraerr *)&amp;ecode,
                                 "open", fileopen,  
                                 "read", fileread,
                                 NULL)))
   {
      printf("Failed to initialize OrsStream, error %u\n",(unsigned)ecode);
      return -1;
   }  
 
   /* check readable and writable  */
    if (OraStreamReadable(ostream))
       printf("ostream is readable\n");
    else
       printf("ostream is not readable\n");
 
     if (OraStreamWritable(ostream))
       printf("ostream is writable\n");
    else
       printf("ostream is not writable\n");
    
    if (oerr = OraStreamRead(ostream, barray, destsize, &amp;barray, &amp;nread, &amp;eoi))
    {
      printf("Failed to read due to orastream was not open, error %u\n", oerr);
    }
 
   /* open orastream */
   OraStreamOpen(ostream, NULL);
 
   /* read document */
   OraStreamRead(ostream, barray, destsize, &amp;barray, &amp;nread, &amp;eoi);
   
   OraStreamTerm(ostream);
    
   XmlDestroy(xctx);
   return 0;
}
ORASTREAM_OPEN_F(fileopen, sctx, sid, hdl, length)
{
    FILE *fh = NULL;
 
    printf("Opening orastream %s...\n", (oratext *)sid);
 
    if (sid &amp;&amp; ((fh= fopen(sid, "r")) != NULL))
    {
        printf("Opening orastream %s...\n", (oratext *)sid);
    }
    else
    {
         printf("Failed to open input file.\n");
         return -1;
     }
 
    /* store file handle generically, NULL means stdout */
    hdl-&gt;ptr_orastreamhdl = fh;
 
    return XMLERR_OK;
}
 
ORASTREAM_READ_F(fileread, sctx, sid, hdl,
                         dest, size, start, nread, eoi)
{
    FILE *fh = NULL;
    int i =0;
    printf("Reading orastream %s ...\n", (oratext *)sid);
    
    // read data from file to dest
    if ((fh = (FILE *) hdl-&gt;ptr_orastreamhdl) != NULL)
        *nread = fread(dest, 1, size, fh);
    printf("Read %d bytes from orastream...\n", (int) *nread);
 
    *eoi = (*nread &lt; size);
    if (start)
        *start = dest;
 
    printf("printing document ...\n");
    for(i =0; i &lt; *nread; i++)
    printf("%c", (char)dest[i]);
    printf("\nend ...\n");
    return ORAERR_OK;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CCHGHCBF"></a>
<div id="ADXDK19773" class="sect1">
<h2 class="sect1">Using the SAX API for C</h2>
<p>To use SAX, initialize an <code dir="ltr">xmlsaxcb</code> structure with function pointers and pass it to <code dir="ltr">XmlLoadSax()</code>. You can also include a pointer to a user-defined context structure, which you pass to each SAX function.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CAXML5908" href="../../appdev.112/e10770/sax.htm#CAXML5908"><span class="italic">Oracle Database XML C API Reference</span> for the SAX callback structure</a></div>
</div>
<!-- class="sect1" -->
<a id="CCHBGCIF"></a>
<div id="ADXDK1410" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the <a id="sthref510"></a>XML Pull Parser for C</h2>
<p>The XML Pull Parser is an implementation of the XML Events interface.</p>
<p>The XML Pull Parser and the SAX parser are similar, but using the Pull Parser, the application (consumer) drives the events, while in SAX, the parser (producer) drives the events. Both the XML Pull Parser and SAX represent the document as a sequence of events, with start tags, end tags, and comments.XML Pull Parser gives control to the application by exposing a simple set of APIs and an underlying set of events. Methods such as <code dir="ltr">XmlEvNext</code> allow an application to ask for (or pull) the next event, rather than handling the event in a callback, as in SAX. Thus, the application has more procedural control over XML processing. Also, the application can decide to stop further processing, unlike a SAX application, which parses the entire document.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHJCADG">Using Basic XML Pull Parsing Capabilities</a></p>
</li>
<li>
<p><a href="#CCHDIHDA">Parsing Multiple XML Documents</a></p>
</li>
<li>
<p><a href="#CCHEHFBD">ID Callback</a></p>
</li>
<li>
<p><a href="#CCHCCHGG">Error Handling for the XML Pull Parser</a></p>
</li>
<li>
<p><a href="#CCHCCJJJ">Sample Pull Parser Application</a></p>
</li>
</ul>
<a id="CCHJCADG"></a>
<div id="ADXDK19774" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using Basic XML Pull Parsing Capabilities</h3>
<p>To use the XML Pull Parser, your application must do the following, in the order given:</p>
<ol>
<li>
<p>Call <code dir="ltr">XmlCreate</code> to initialize the XML meta-context.</p>
</li>
<li>
<p>Initialize the Pull Parser context with a call to the <code dir="ltr">XmlEvCreatePPCtx</code> function, which creates and returns the event context.</p>
<p>The <code dir="ltr">XmlEvCreatePPCtx</code> function supports all the properties supported by <code dir="ltr">XmlLoadDom</code> and <code dir="ltr">XmlLoadSax</code>, plus some additional ones.</p>
<p>The <code dir="ltr">XmlEvCreatePPCtx</code> and <code dir="ltr">XmlEvCreatePPCtxVA</code> functions are fully implemented.</p>
</li>
<li>
<p>Ensure that the event context is passed to all subsequent calls to the Pull Parser.</p>
</li>
<li>
<p>Terminate the Pull Parser context by calling the <code dir="ltr">XmlEvDestoryPPCtx</code> function, to clean up memory.</p>
</li>
<li>
<p>Destroy the XML meta-context by calling the <code dir="ltr">XmlDestoryCtx</code> function.</p>
</li>
</ol>
<div id="ADXDK19775" class="sect3"><a id="sthref511"></a>
<h4 class="sect3">XML Event Context</h4>
<p><a href="#CCHJDIHJ">Example 18-4</a> shows the structure of the event context.</p>
<div id="ADXDK19776" class="example">
<p class="titleinexample"><a id="CCHJDIHJ"></a>Example 18-4 XML Event Context</p>
<pre dir="ltr">
typedef  struct {
   void *ctx_xmlevctx;                   /* implementation specific context */
   xmlevdisp *disp_xmlevctx;             /* dispatch table */
   ub4 checkword_xmlevctx;               /* checkword for integrity check */
   ub4 flags_xmlevctx;                   /* mode; default: expand_entity */
   struct xmlevctx *input_xmlevctx;      /* input xmlevctx; chains the XML Event
                                            context */
} xmlevctx;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADXDK19777" class="sect3"><a id="sthref512"></a>
<h4 class="sect3">About the XML Event Context</h4>
<p>Each XML Pull Parser is allowed to create its own context and implement its own API functions.</p>
<ul>
<li>
<p>Dispatch Table</p>
<p>The dispatch table, <code dir="ltr">disp_xmlevctx</code>, contains one pointer for each API function, except for the <code dir="ltr">XmlEvCreatePPCtx</code>, <code dir="ltr">XmlEvCreatePPCtxVA</code>, <code dir="ltr">XmlEvDestoryPPCtx</code>, <code dir="ltr">XmlEvLoadPPDoc</code>, and <code dir="ltr">XmlEvCleanPPCtx</code> functions.</p>
<p>When the event context is created, the pointer <code dir="ltr">disp_xmlevctx</code> is initialized with the address of that static table.</p>
</li>
<li>
<p>Implementation-Specific Event Context</p>
<p>The field <code dir="ltr">ctx_xmlevctx</code> must be initialized with the address of the context specific to this invocation of the particular implementation. The implementation-specific event context is of type <code dir="ltr">*void</code>, so that it can differ for different applications.</p>
</li>
<li>
<p>Input Event Context</p>
<p>Each Pull Parser can specify an input event context, <code dir="ltr">xmlevctx</code>. This field enables the parser to chain multiple event producers. As a result, if a dispatch function is specified as <code dir="ltr">NULL</code> in a context, the application uses the next non-null dispatch function in the chain of input event contexts. The base <code dir="ltr">xmlevctx</code> must ensure that all dispatch function pointers are non-null.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHDIHDA"></a>
<div id="ADXDK19778" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Parsing Multiple XML Documents</h3>
<p>After creating and initializing the XML Event Context, the application can parse multiple documents with repeated calls to <code dir="ltr">XmlEvLoadPPDoc</code> and <code dir="ltr">XmlEvCleanPPCtx</code>. These functions are fully implemented.</p>
<p>Note that the properties defined by the application during the XML Event Context creation cannot be changed for each call to the <code dir="ltr">XmlLoadPPDoc</code> function. If you want to change the properties, destroy the event context and re-create it.</p>
<p>After <code dir="ltr">XmlEvCleanPPCtx</code> cleans up the internal structure of the current parser, the event context can be re-used to parse another document.</p>
</div>
<!-- class="sect2" -->
<a id="CCHEHFBD"></a>
<div id="ADXDK19779" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">ID Callback</h3>
<p>You can provide a callback to convert text-based names to 8-byte IDs.</p>
<p class="subhead2"><a id="ADXDK19780"></a>Callback Function Signature</p>
<pre dir="ltr">
typedef  sb8 (*xmlev_id_cb_funcp)( void *ctx , ub1 type, ub1 *token, ub4 tok_len,
              sb8 nmspid, boolean isAttribute);
</pre>
<p class="subhead2"><a id="ADXDK19781"></a>Return Value</p>
<p><code dir="ltr">sb8</code>: an 8-byte ID.</p>
<p class="subhead2"><a id="ADXDK19782"></a>Arguments</p>
<ul>
<li>
<p>*<code dir="ltr">ctx</code>: The implementation context.</p>
</li>
<li>
<p><code dir="ltr">type</code>: The type, which is indicated by the following enumeration:</p>
<pre dir="ltr">
typedef enum 
{
  XML_EVENT_ID_URI,
  XML_EVENT_ID_QNAME,
}xmlevidtype;
</pre></li>
<li>
<p>*<code dir="ltr">token</code> and <code dir="ltr">tok_len</code>: The actual text to be converted.</p>
</li>
<li>
<p><code dir="ltr">nmspid</code>: The namespace ID.</p>
</li>
<li>
<p><code dir="ltr">isAttribute</code>: A Boolean value indicating an attribute.</p>
</li>
</ul>
<p>Internally, the <code dir="ltr">XmlEvGetTagId</code> and <code dir="ltr">XmlEvGetAttrID</code> APIs call this callback twice, once to fetch the namespace ID and once to fetch the actual ID of the tag or the attribute <code dir="ltr">Qname</code>.</p>
<p>The <code dir="ltr">XmlEvGetTagUriID</code> and <code dir="ltr">XmlEvGetAttrUriID</code> functions invoke this callback once to get the ID of the corresponding URI.</p>
<p>If a callback is not supplied, an error <code dir="ltr">XML_ERR_EVENT_NOIDCBK</code> is returned when these APIs are used.</p>
</div>
<!-- class="sect2" -->
<a id="CCHCCHGG"></a>
<div id="ADXDK19783" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Error Handling for the <a id="sthref513"></a>XML Pull Parser</h3>
<p>The following sections describe error handling for the XML Pull Parser.</p>
<div id="ADXDK19784" class="sect3"><a id="sthref514"></a>
<h4 class="sect3">Parser Errors</h4>
<p>The XML Pull Parser returns the message <code dir="ltr">XML_EVENT_FATAL_ERROR</code> when it throws an error because the input document is malformed. The <code dir="ltr">XmlEvGetError</code> function is provided to get the error number and message.</p>
<p>Note that during the <code dir="ltr">XmlEvCreatePPCtx</code> operation, any error handler supplied by the application during <code dir="ltr">XmlCreate</code> is overridden. The application must call the <code dir="ltr">XmlErrSetHandler</code> function after the <code dir="ltr">XmlEvDestroyPPCtx</code> operation to restore the original callback.</p>
</div>
<!-- class="sect3" -->
<div id="ADXDK19785" class="sect3"><a id="sthref515"></a>
<h4 class="sect3">Programming Errors</h4>
<p>To handle programmatic errors. XDK provides a callback that the application can supply when creating an event context. This callback is invoked when the application makes a call to an illegal API. The callback signature is as follows:</p>
<pre dir="ltr">
typedef  void (* xmlev_err_cb_funcp)(xmlctx *xctx, xmlevctx *evctx, 
        xmlevtype cur_event);
</pre>
<p>An example of an illegal API call is:</p>
<p><code dir="ltr">XmlEvGetName</code> cannot be called for the <code dir="ltr">XML_EVENT_CHARACTERS</code> event.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHCCJJJ"></a>
<div id="ADXDK19786" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Sample Pull Parser Application</h3>
<p>This section contains a sample <a id="sthref516"></a>pull parser application, a document to be parsed, and a list of the events that the application generates from the document.</p>
<div id="ADXDK19787" class="sect3"><a id="sthref517"></a>
<h4 class="sect3">An XML Pull Parser Sample Application</h4>
<div id="ADXDK19788" class="example">
<p class="titleinexample"><a id="BABCJHAB"></a>Example 18-5 Sample Pull Parser Application Example</p>
<pre dir="ltr">
# include "xml.h"
# include "xmlev.h"
...
xmlctx *xctx;
xmlevctx *evtcx;
if (!(xctx = XmlCreate(&amp;xerr, (oratext *) "test")))
{
    printf("Failed to create XML context, error %u\n", (unsigned) xerr);
    return -1;
}
...
if(!(evctx = XmlEvCreatePPCtx(xctx, &amp;xerr, NULL)))
{
   printf("Failed to create EVENT context, error %u\n", (unsigned) xerr);
   return -1;
 }
for(i = 0; i &lt; numDocs; i++)
{
  if (xerr = XmlEvLoadPPDoc(xctx, evctx, "file", input_filenames[i], 0, NULL)
     {
       printf("Failed to load the document, error %u\n", (unsigned) xerr);
       return -1;
     }
...
  for(;;)
  {
    xmlevtype cur_event;
    cur_event = XmlEvNext(evctx);
    switch(cur_event)
         {
               case XML_EVENT_FATAL_ERROR:
                     XmlEvGetError(evctx, (oratext **)&amp;errmsg);
                          printf("Error %s\n", errmsg);
               return;
               case XML_EVENT_START_ELEMENT:
                     printf("&lt;%s&gt;", XmlEvGetName0(evctx));
               break;
               case XML_EVENT_END_DOCUMENT:
                     printf("&lt;%s&gt;", XmlEvGetName0(evctx));
               return;
         }
  }
  XmlEvCleanPPCtx(xctx, evctx);
}
XmlEvDestroyPPCtx(xctx, evctx);
XmlDestroy(xctx);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADXDK19789" class="sect3"><a id="sthref518"></a>
<h4 class="sect3">Sample Document</h4>
<div id="ADXDK19790" class="example">
<p class="titleinexample"><a id="sthref519"></a>Example 18-6 Sample Document to Parse</p>
<pre dir="ltr">
&lt;!DOCTYPE doc [
&lt;!ENTITY ent SYSTEM "file:attendees.txt"&gt;
&lt;!ELEMENT doc ANY&gt;
&lt;!ELEMENT meeting (topic, date, publishAttendees)&gt;
&lt;!ELEMENT publishAttendees (#PCDATA)&gt;
&lt;!ELEMENT topic (#PCDATA)&gt;
&lt;!ELEMENT date (#PCDATA)&gt;
]&gt;
&lt;!-- Begin Document --&gt;
&lt;doc&gt;
  &lt;!-- Info about the meeting --&gt;
  &lt;meeting&gt;
    &lt;topic&gt;Group meeting&lt;/topic&gt;
    &lt;date&gt;April 25, 2005&lt;/date&gt;
    &lt;publishAttendees&gt;&amp;ent;&lt;/publishAttendees&gt;
  &lt;/meeting&gt;
&lt;/doc&gt;
&lt;!-- End Document --&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADXDK19791" class="sect3"><a id="sthref520"></a>
<h4 class="sect3">Events Generated by XML Pull Parser Sample Application</h4>
<p>This is the sequence of events generated when the attribute events property is <code dir="ltr">FALSE</code> and expand entities properties is <code dir="ltr">TRUE</code>.</p>
<div id="ADXDK19792" class="example">
<p class="titleinexample"><a id="sthref521"></a>Example 18-7 Events Generated by Parsing a Sample Document</p>
<pre dir="ltr">
XML_EVENT_START_DOCUMENT
XML_EVENT_START_DTD
XML_EVENT_PE_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_ELEMENT_DECLARATION
XML_EVENT_END_DTD 
XML_EVENT_COMMENT
XML_EVENT_START_ELEMENT
XML_EVENT_SPACE
XML_EVENT_COMMENT
XML_EVENT_SPACE
XML_EVENT_START_ELEMENT
XML_EVENT_START_ELEMENT
XML_EVENT_CHARACTERS
XML_EVENT_END_ELEMENT
XML_EVENT_START_ELEMENT
XML_EVENT_CHARACTERS
XML_EVENT_END_ELEMENT
XML_EVENT_START_ELEMENT
XML_EVENT_START_ENTITY
XML_EVENT_CHARACTERS
XML_EVENT_END_ENTITY
XML_EVENT_END_ELEMENT
XML_EVENT_END_ELEMENT
XML_EVENT_SPACE
XML_EVENT_END_ELEMENT
XML_EVENT_COMMENT
XML_EVENT_END_DOCUMENT
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i454255"></a>
<div id="ADXDK19793" class="sect1">
<h2 class="sect1">Using <a id="sthref522"></a>OCI and the XDK C API</h2>
<p>This section describes calling the XDK C functions from Oracle Call Interface (OCI).</p>
<a id="i452157"></a>
<div id="ADXDK19794" class="sect2">
<h3 class="sect2">Using XMLType Functions and Descriptions</h3>
<p>You can use the C API for XML for <code dir="ltr">XMLType</code> columns in the database. An OCI program can access XML data stored in a table by initializing the values of OCI handles such as the following:</p>
<ul>
<li>
<p>Environment handle</p>
</li>
<li>
<p>Service handle</p>
</li>
<li>
<p>Error handle</p>
</li>
<li>
<p>Optional parameters</p>
</li>
</ul>
<p>The program can pass these input values to the function <code dir="ltr">OCIXmlDbInitXmlCtx()</code>, which returns an XML context. After the program makes calls to the C API, the function <code dir="ltr">OCIXmlDbFreeXmlCtx()</code> frees the context.</p>
<p><a href="#CCHBDJDE">Table 18-6</a> describes a few of the functions for XML operations.</p>
<div id="ADXDK19795" class="tblformal">
<p class="titleintable"><a id="sthref523"></a><a id="CCHBDJDE"></a>Table 18-6 XMLType Functions</p>
<table class="cellalignment1214" title="XMLType Functions " summary="Description and Function Name are the columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t15">Function Name</th>
<th class="cellalignment1212" id="r1c2-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlCreateDocument()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t15 r1c2-t15">
<p>Create empty <code dir="ltr">XMLType</code> instance</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlLoadDom()</code> and so on</p>
</td>
<td class="cellalignment1213" headers="r3c1-t15 r1c2-t15">
<p>Create from a source buffer</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlXPathEvalexpr()</code> and family</p>
</td>
<td class="cellalignment1213" headers="r4c1-t15 r1c2-t15">
<p>Extract an <code dir="ltr">XPath</code> expression</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlXslProcess()</code> and family</p>
</td>
<td class="cellalignment1213" headers="r5c1-t15 r1c2-t15">
<p>Transform using an XSLT stylesheet</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlXPathEvalexpr()</code> and family</p>
</td>
<td class="cellalignment1213" headers="r6c1-t15 r1c2-t15">
<p>Check if an <code dir="ltr">XPath</code> exists</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlDomIsSchemaBased()</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t15 r1c2-t15">
<p>Is document schema-based?</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlDomGetSchema()</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t15 r1c2-t15">
<p>Get schema information</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlDomGetNodeURI()</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t15 r1c2-t15">
<p>Get document namespace</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t15" headers="r1c1-t15">
<p><code dir="ltr">XmlSchemaValidate()</code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t15 r1c2-t15">
<p>Validate using schema</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t15" headers="r1c1-t15">
<p>Cast <code dir="ltr">(void *)</code> to <code dir="ltr">(xmldocnode *)</code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t15 r1c2-t15">
<p>Obtain DOM from <code dir="ltr">XMLType</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r12c1-t15" headers="r1c1-t15">
<p>Cast <code dir="ltr">(xmldocnode *)</code> to <code dir="ltr">(void *)</code></p>
</td>
<td class="cellalignment1213" headers="r12c1-t15 r1c2-t15">
<p>Obtain <code dir="ltr">XMLType</code> from DOM</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CCHHGBEA"></a>
<div id="ADXDK19796" class="sect2">
<h3 class="sect2">Initializing an XML Context for XML DB</h3>
<p>An XML context is a required parameter in all the C DOM API functions. This opaque context encapsulates information pertaining to data encoding, error message language, and so on. The contents of this XML context are different for XDK applications and for Oracle XML DB applications.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Do not use an XML context for XDK in an XML DB application, or an XML context for XML DB in an XDK application.</div>
<p>For Oracle XML DB, the two OCI functions that initialize and free an XML context have the following prototypes:</p>
<pre dir="ltr">
xmlctx *OCIXmlDbInitXmlCtx (OCIEnv *envhp, OCISvcCtx *svchp, OCIError *errhp,
       ocixmldbparam *params, ub4 num_params);

void OCIXmlDbFreeXmlCtx (xmlctx *xctx);
</pre>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink LNOCI220" href="../../appdev.112/e10646/oci23xml.htm#LNOCI220"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for reference material on the functions</p>
</li>
<li>
<p><a class="olink LNOCI1390" href="../../appdev.112/e10646/oci14oca.htm#LNOCI1390"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for a discussion about OCI support for XML</p>
</li>
<li>
<p><a class="olink CAXML00300" href="../../appdev.112/e10770/dom.htm#CAXML00300"><span class="italic">Oracle Database XML C API Reference</span></a> for reference information on the DOM APIs</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i452152"></a>
<div id="ADXDK19797" class="sect2">
<h3 class="sect2">Creating XMLType Instances on the Client</h3>
<p>You can construct new <code dir="ltr">XMLType</code> instances on the client by using the <code dir="ltr">XmlLoadDom()</code> calls. Follow these basic steps:</p>
<ol>
<li>
<p>You first have to initialize the <code dir="ltr">xmlctx</code>, as illustrated in the example in <a href="#i452668">"Using the DOM API for C"</a>.</p>
</li>
<li>
<p>You can construct the XML data itself from the following sources:</p>
<ul>
<li>
<p>User buffer</p>
</li>
<li>
<p>Local file</p>
</li>
<li>
<p>URI</p>
</li>
</ul>
<p>The return value from these is an <code dir="ltr">(xmldocnode *)</code>, which you can use in the rest of the common C API.</p>
</li>
<li>
<p>Finally, you can cast the <code dir="ltr">(xmldocnode *)</code> to a (<code dir="ltr">void *)</code> and directly provide it as the bind value if required.</p>
</li>
</ol>
<p>You can construct empty <code dir="ltr">XMLType</code> instances by using the <code dir="ltr">XmlCreateDocument()</code> call. This function would be equivalent to an <code dir="ltr">OCIObjectNew()</code> for other types. You can operate on the <code dir="ltr">(xmldocnode *)</code> returned by the preceding call and finally cast it to a <code dir="ltr">(void *)</code> if it must be provided as a bind value.</p>
</div>
<!-- class="sect2" -->
<a id="CCHIFCBI"></a>
<div id="ADXDK19798" class="sect2">
<h3 class="sect2">Operating on XML Data in the Database Server</h3>
<p>You can operate on XML data in Oracle Database by means of OCI statement calls. You can bind and define <code dir="ltr">XMLType</code> values using <code dir="ltr">xmldocnode</code> and use OCI statements to select XML data from the database. You can use this data directly in the C DOM functions. Similarly, you can bind the values directly to SQL statements.</p>
</div>
<!-- class="sect2" -->
<a id="CCHJHGFB"></a>
<div id="ADXDK19799" class="sect2">
<h3 class="sect2"><a id="sthref524"></a>Using OCI and the XDK C API: Examples</h3>
<p><a href="#CCHHJFAE">Example 18-8</a> illustrates how to construct a schema-based document with the DOM API and save it to the database. Note that you must include the header files <code dir="ltr">xml.h</code> and <code dir="ltr">ocixmldb.h</code>.</p>
<div id="ADXDK19800" class="example">
<p class="titleinexample"><a id="CCHHJFAE"></a>Example 18-8 Constructing a Schema-Based Document with the DOM API</p>
<pre dir="ltr">
#include &lt;xml.h&gt;
#include &lt;ocixmldb.h&gt;
static oratext tlpxml_test_sch[] = "&lt;TOP xmlns='example1.xsd'\n\
xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' \n\
xsi:schemaLocation='example1.xsd example1.xsd'/&gt;";

void example1()
{
    OCIEnv *envhp;
    OCIError *errhp;
    OCISvcCtx *svchp;
    OCIStmt *stmthp;
    OCIDuration dur;
    OCIType *xmltdo;

    xmldocnode  *doc;
    ocixmldbparam params[1];
    xmlnode *quux, *foo, *foo_data;
    xmlerr       err;

    /* Initialize envhp, svchp, errhp, dur, stmthp */
    /* ........ */

    /* Get an xml context */
    params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
    params[0].value_ocixmldbparam = &amp;dur;
    xctx = OCIXmlDbInitXmlCtx(envhp, svchp, errhp, params, 1);

    /* Start processing */ 
    printf("Supports XML 1.0: %s\n",
       XmlHasFeature(xctx, (oratext *) "xml", (oratext *) "1.0") ? "YES" : "NO");

    /* Parsing a schema-based document */
    if (!(doc = XmlLoadDom(xctx, &amp;err, "buffer", tlpxml_test_sch,
                          "buffer_length", sizeof(tlpxml_test_sch)-1,
                          "validate", TRUE, NULL)))
    {
       printf("Parse failed, code %d\n");
       return;
    }

    /* Create some elements and add them to the document */
    top = XmlDomGetDocElem(xctx, doc);
    quux = (xmlnode *) XmlDomCreateElem(xctx ,doc, (oratext *) "QUUX");
    foo = (xmlnode *) XmlDomCreateElem(xctx, doc, (oratext *) "FOO");
    foo_data = (xmlnode *) XmlDomCreateText(xctx, doc, (oratext *)"foo's data");
    foo_data = XmlDomAppendChild(xctx, (xmlnode *) foo, (xmlnode *) foo_data);
    foo = XmlDomAppendChild(xctx, quux, foo);
    quux = XmlDomAppendChild(xctx, top, quux);

    XmlSaveDom(xctx, &amp;err, top, "stdio", stdout, NULL);
    XmlSaveDom(xctx, &amp;err, doc, "stdio", stdout, NULL);

    /* Insert the document to my_table */
    ins_stmt = "insert into my_table values (:1)";

    status = OCITypeByName(envhp, errhp, svchp, (const text *) "SYS",
                   (ub4) strlen((char *)"SYS"), (const text *) "XMLTYPE",
                   (ub4) strlen((char *)"XMLTYPE"), (CONST text *) 0,
                   (ub4) 0, dur, OCI_TYPEGET_HEADER,
                   (OCIType **) &amp;xmltdo)) ;

    if (status == OCI_SUCCESS)
    {
       exec_bind_xml(svchp, errhp, stmthp, (void *)doc, xmltdo, ins_stmt));
    }

   /* free xml ctx */
   OCIXmlDbFreeXmlCtx(xctx);
}

/*--------------------------------------------------------*/
/* execute a sql statement which binds xml data */
/*--------------------------------------------------------*/
sword exec_bind_xml(svchp, errhp, stmthp, xml, xmltdo, sqlstmt)
OCISvcCtx *svchp;
OCIError *errhp;
OCIStmt *stmthp;
void *xml;
OCIType *xmltdo;
OraText *sqlstmt;
{
   OCIBind *bndhp1 = (OCIBind *) 0;
   OCIBind *bndhp2 = (OCIBind *) 0;
   sword  status = 0;
   OCIInd ind = OCI_IND_NOTNULL;
   OCIInd *indp = &amp;ind;

   if(status = OCIStmtPrepare(stmthp, errhp, (OraText *)sqlstmt,
                    (ub4)strlen((char *)sqlstmt),
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT)) {
     return OCI_ERROR;
   }

   if(status = OCIBindByPos(stmthp, &amp;bndhp1, errhp, (ub4) 1, (dvoid *) 0,
                   (sb4) 0, SQLT_NTY, (dvoid *) 0, (ub2 *)0,
                   (ub2 *)0, (ub4) 0, (ub4 *) 0, (ub4) OCI_DEFAULT)) {
     return OCI_ERROR;
   }

   if(status = OCIBindObject(bndhp1, errhp, (CONST OCIType *) xmltdo,
               (dvoid **) &amp;xml, (ub4 *) 0, (dvoid **) &amp;indp, (ub4 *) 0)) {
     return OCI_ERROR;
   }

   if(status = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                (CONST OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT)) {
     return OCI_ERROR;
  }

   return OCI_SUCCESS;
}
</pre></div>
<!-- class="example" -->
<p><a href="#CCHDJDBE">Example 18-9</a> illustrates how to get a document from the database and modify it with the DOM API.</p>
<div id="ADXDK19801" class="example">
<p class="titleinexample"><a id="CCHDJDBE"></a>Example 18-9 Modifying a Database Document with the DOM API</p>
<pre dir="ltr">
#include &lt;xml.h&gt;
#include &lt;ocixmldb.h&gt;
sword example2()
{
    OCIEnv *envhp;
    OCIError *errhp;
    OCISvcCtx *svchp;
    OCIStmt *stmthp;
    OCIDuration dur;
    OCIType *xmltdo;
  
    xmldocnode  *doc;
    xmlnodelist *item_list; ub4 ilist_l;
    ocixmldbparam params[1];
    text *sel_xml_stmt = (text *)"SELECT xml_col FROM my_table";
    ub4    xmlsize = 0;
    sword  status = 0;
    OCIDefine *defnp = (OCIDefine *) 0;

    /* Initialize envhp, svchp, errhp, dur, stmthp */
    /* ... */

    /* Get an xml context */
    params[0].name_ocixmldbparam = XCTXINIT_OCIDUR;
    params[0].value_ocixmldbparam = &amp;dur;
    xctx = OCIXmlDbInitXmlCtx(envhp, svchp, errhp, params, 1);

    /* Start processing */
    if(status = OCITypeByName(envhp, errhp, svchp, (const text *) "SYS",
                   (ub4) strlen((char *)"SYS"), (const text *) "XMLTYPE",
                   (ub4) strlen((char *)"XMLTYPE"), (CONST text *) 0,
                   (ub4) 0, dur, OCI_TYPEGET_HEADER,
                   (OCIType **) xmltdo_p)) {
       return OCI_ERROR;
    }

    if(!(*xmltdo_p)) {
       printf("NULL tdo returned\n");
       return OCI_ERROR;
    }

    if(status = OCIStmtPrepare(stmthp, errhp, (OraText *)selstmt,
                    (ub4)strlen((char *)selstmt),
                    (ub4) OCI_NTV_SYNTAX, (ub4) OCI_DEFAULT)) {
      return OCI_ERROR;
    }

    if(status = OCIDefineByPos(stmthp, &amp;defnp, errhp, (ub4) 1, (dvoid *) 0,
                   (sb4) 0, SQLT_NTY, (dvoid *) 0, (ub2 *)0,
                   (ub2 *)0, (ub4) OCI_DEFAULT)) {
       return OCI_ERROR;
    }

    if(status = OCIDefineObject(defnp, errhp, (OCIType *) *xmltdo_p,
                            (dvoid **) &amp;doc,
                            &amp;xmlsize, (dvoid **) 0, (ub4 *) 0)) {
      return OCI_ERROR;
    }

    if(status = OCIStmtExecute(svchp, stmthp, errhp, (ub4) 1, (ub4) 0,
                 (CONST OCISnapshot*) 0, (OCISnapshot*) 0, (ub4) OCI_DEFAULT)) {
      return OCI_ERROR;
    }

    /* We have the doc. Now we can operate on it */
    printf("Getting Item list...\n");

   item_list = XmlDomGetElemsByTag(xctx,(xmlelemnode *) elem,(oratext *)"Item"); 
    ilist_l   = XmlDomGetNodeListLength(xctx, item_list);
    printf(" Item list length = %d \n", ilist_l);

    for (i = 0; i &lt; ilist_l; i++)
    {
      elem = XmlDomGetNodeListItem(xctx, item_list, i);
      printf("Elem Name:%s\n", XmlDomGetNodeName(xctx, fragelem));
      XmlDomRemoveChild(xctx, fragelem);
    }

    XmlSaveDom(xctx, &amp;err, doc, "stdio", stdout, NULL);

   /* free xml ctx */
   OCIXmlDbFreeXmlCtx(xctx);

   return OCI_SUCCESS;
}
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1204">
<tr>
<td class="cellalignment1213">
<table class="cellalignment1209">
<tr>
<td class="cellalignment1208"><a href="adx_c_xslt.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1208"><a href="adx_c_xmlbin.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1216">
<table class="cellalignment1207">
<tr>
<td class="cellalignment1208"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1208"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1208"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1208"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1208"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1208"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
