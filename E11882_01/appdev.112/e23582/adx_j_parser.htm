<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>XML Parsing for Java</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T14:20:37Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML Developer's Kit Programmer's Guide" />
<meta name="dcterms.identifier" content="E23582-06" />
<meta name="dcterms.isVersionOf" content="ADXDK" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adx_j_gs.htm" title="Previous" type="text/html" />
<link rel="Next" href="adx_j_xmlbin.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23582.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/47</span> <!-- End Header -->
<div id="ADXDK3000" class="chapter"><a id="i1008366"></a>
<h1 class="chapter"><span class="secnum">4</span> XML Parsing for Java</h1>
<p><a id="sthref67"></a><a id="sthref68"></a><a id="sthref69"></a><a id="sthref70"></a>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CCHCCEHA">Introduction to the XML Parsing for Java</a></p>
</li>
<li>
<p><a href="#i1033575">Using XML Parsing for Java: Overview</a></p>
</li>
<li>
<p><a href="#CCHEEHHB">Parsing XML with DOM</a></p>
</li>
<li>
<p><a href="#CCHGBGIG">Parsing XML with SAX</a></p>
</li>
<li>
<p><a href="#i1034434">Parsing XML with JAXP</a></p>
</li>
<li>
<p><a href="#CCHJDAFB">Compressing XML</a></p>
</li>
<li>
<p><a href="#CCHCGIDI">Tips and Techniques for Parsing XML</a></p>
</li>
</ul>
<a id="CCHCCEHA"></a>
<div id="ADXDK19083" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Introduction to the XML Parsing for Java</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDFECEF">Prerequisites</a></p>
</li>
<li>
<p><a href="#CCHCIBBC">Standards and Specifications</a></p>
</li>
<li>
<p><a href="#i1013320">XML Parsing in Java</a></p>
</li>
<li>
<p><a href="#BGBCFHAJ">DOM in XML Parsing</a></p>
</li>
<li>
<p><a href="#CCHGIADJ">Scalable DOM</a></p>
</li>
<li>
<p><a href="#BGBGAJIA">SAX in the XML Parser</a></p>
</li>
<li>
<p><a href="#BGBFDFBH">JAXP in the XML Parser</a></p>
</li>
<li>
<p><a href="#CCHJIEHB">Namespace Support in the XML Parser</a></p>
</li>
<li>
<p><a href="#i1024648">Validation in the XML Parser</a></p>
</li>
<li>
<p><a href="#i1027439">Compression in the XML Parser</a></p>
</li>
</ul>
<a id="CHDFECEF"></a>
<div id="ADXDK19084" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Prerequisites</h3>
<p>Oracle XML parsing reads an XML document and uses DOM or SAX APIs to provide programmatic access to its content and structure. You can use parsing in validating or nonvalidating mode.</p>
<p>This chapter assumes that you are familiar with the following technologies:</p>
<ul>
<li>
<p><a href="glossary.htm#CBAGDBJI"><span class="xrefglossterm">Document Object Model (DOM)</span></a>. DOM is an in-memory tree representation of the structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#CBAFICHD"><span class="xrefglossterm">Simple API for XML (SAX)</span></a>. SAX is a standard for event-based XML parsing.</p>
</li>
<li>
<p><a href="glossary.htm#CBAGABHC"><span class="xrefglossterm">Java API for XML Processing (JAXP)</span></a>. JAXP is a standard interface for processing XML with Java applications. It supports the DOM and SAX standards.</p>
</li>
<li>
<p><a href="glossary.htm#CBAHIAFA"><span class="xrefglossterm">Document Type Definition (DTD)</span></a>. An XML DTD defines the legal structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#CBABDIHJ"><span class="xrefglossterm">XML Schema</span></a>. Like a DTD, an XML schema defines the legal structure of an XML document.</p>
</li>
<li>
<p><a href="glossary.htm#CBAEJBCC"><span class="xrefglossterm">XML Namespaces</span></a>. Namespaces are a mechanism for differentiating element and attribute names.</p>
</li>
<li>
<p><a href="glossary.htm#CBAFIDHA"><span class="xrefglossterm">binary XML</span></a>. Both scalable and nonscalable DOMs can save XML documents in this format.</p>
</li>
</ul>
<p>If you require a general introduction to the preceding technologies, consult the XML resources listed in <a href="preface.htm#CIAFJDBI">"Related Documents"</a> of the preface.</p>
</div>
<!-- class="sect2" -->
<a id="CCHCIBBC"></a>
<div id="ADXDK19085" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Standards and Specifications</h3>
<p>The DOM Level 1, Level 2, and Level 3 specifications are W3C Recommendations. You can find links to the specifications for all three levels at the following URL:</p>
<pre dir="ltr">
<a href="http://www.w3.org/DOM/DOMTR">http://www.w3.org/DOM/DOMTR</a>
</pre>
<p>SAX is available in version 1.0, which is deprecated, and 2.0. It is not a W3C specification. You can find the documentation for SAX at the following URL:</p>
<pre dir="ltr">
<a href="http://www.saxproject.org/">http://www.saxproject.org/</a>
</pre>
<p>XML Namespaces are a W3C Recommendation. You can find the specification at the following URL:</p>
<pre dir="ltr">
<a href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</a>
</pre>
<p><a id="sthref71"></a><a id="sthref72"></a>JCR 1.0 (also known as JSR 170) defines a standard Java API for applications to interact with content repositories.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB2630" href="../../appdev.112/e23094/xdb_jcr.htm#ADXDB2630"><span class="italic">Oracle XML DB Developer's Guide,</span></a></div>
<p>JAXP version 1.2 includes an XSLT framework plus some updates to the parsing API to support DOM Level 2 and SAX version 2.0 and an improved scheme to locate pluggable implementations. JAXP provides support for XML schema and an XSLT compiler. You can access the JAXP specification at the following URL:</p>
<pre dir="ltr">
<a href="http://www.oracle.com/technetwork/java/index.html">http://www.oracle.com/technetwork/java/index.html</a>
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adx_ref_standards.htm#BABDIIJG">Chapter 31, "XDK Standards"</a> for an account of the standards supported by the XDK</div>
</div>
<!-- class="sect2" -->
<a id="BABCGGII"></a>
<div id="ADXDK19086" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Large Node Handling</h3>
<p>DOM Stream access to XML nodes is done by PL/SQL and Java APIs. Nodes in an XML document can now exceed 64 KBytes by a large amount. Thus JPEG, Word, PDF, RTF, and HTML documents can be more readily stored.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB1150" href="../../appdev.112/e23094/xdb11jav.htm#ADXDB1150"><span class="italic">Oracle XML DB Developer's Guide</span></a> for complete details on the Java large node capabilities</div>
</div>
<!-- class="sect2" -->
<a id="i1013320"></a>
<div id="ADXDK19087" class="sect2">
<h3 class="sect2">XML Parsing in Java</h3>
<p><code dir="ltr">XMLParser</code> is the abstract base class for the XML parser for Java. An instantiated parser invokes the <code dir="ltr">parse()</code> method to read an XML document.</p>
<p><code dir="ltr">XMLDOMImplementation</code> factory methods provide another method to parse Binary XML to create scalable DOM.</p>
<p><a href="#i1041301">Figure 4-1</a> illustrates the basic parsing process, using <code dir="ltr">XMLParser</code>. The diagram does not apply to <code dir="ltr">XMLDOMImplementation</code>().</p>
<div id="ADXDK19088" class="figure">
<p class="titleinfigure"><a id="i1041301"></a>Figure 4-1 The XML Parser Process</p>
<img width="363" height="326" src="img/adxdk040.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref73" href="img_text/adxdk040.htm">Description of "Figure 4-1 The XML Parser Process"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The following APIs provide a Java application with access to a parsed XML document:</p>
<ul>
<li>
<p>DOM API, which parses XML documents and builds a tree representation of the documents in memory. Use either a <code dir="ltr">DOMParser</code> object to parse with DOM or the <code dir="ltr">XMLDOMImplementation</code> interface factory methods to create a pluggable, scalable DOM.</p>
</li>
<li>
<p>SAX API, which processes an XML document as a stream of events, which means that a program cannot access random locations in a document. Use a <code dir="ltr">SAXParser</code> object to parse with SAX.</p>
</li>
<li>
<p>JAXP, which is a Java-specific API that supports DOM, SAX, and XSL. Use a <code dir="ltr">DocumentBuilder</code> or <code dir="ltr">SAXParser</code> object to parse with JAXP.</p>
</li>
</ul>
<p>The sample XML document in <a href="#CCHHDCHF">Example 4-1</a> helps illustrate the differences among DOM, SAX, and JAXP.</p>
<div id="ADXDK19089" class="example">
<p class="titleinexample"><a id="CCHHDCHF"></a>Example 4-1 Sample XML Document</p>
<pre dir="ltr">
&lt;?xml version="1.0"?&gt;
  &lt;EMPLIST&gt;
    &lt;EMP&gt;
     &lt;ENAME&gt;MARY&lt;/ENAME&gt;
    &lt;/EMP&gt;
    &lt;EMP&gt;
     &lt;ENAME&gt;SCOTT&lt;/ENAME&gt;
    &lt;/EMP&gt;
  &lt;/EMPLIST&gt;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BGBCFHAJ"></a>
<div id="ADXDK19090" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DOM in XML Parsing</h3>
<p>DOM builds an in-memory tree representation of the XML document. For example, the DOM API receives the document described in <a href="#CCHHDCHF">Example 4-1</a> and creates an in-memory tree as shown in <a href="#CCHDFAJF">Figure 4-2</a>. DOM provides classes and methods to navigate and process the tree.</p>
<p>In general, the DOM API provides the following advantages:</p>
<ul>
<li>
<p>DOM API is easier to use than SAX because it provides a familiar tree structure of objects.</p>
</li>
<li>
<p>Structural manipulations of the XML tree, such as re-ordering elements, adding to and deleting elements and attributes, and renaming elements, can be performed.</p>
</li>
<li>
<p>Interactive applications can store the object model in memory, enabling users to access and manipulate it.</p>
</li>
<li>
<p>DOM as a standard does not support XPath. However, most XPath implementations use DOM. The Oracle XDK includes DOM API extensions to support XPath.</p>
</li>
<li>
<p>A pluggable, scalable DOM can be created that considerably improves scalability and efficiency.</p>
</li>
</ul>
<div id="ADXDK19091" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref74"></a>
<h4 class="sect3">DOM Creation</h4>
<p>In Java XDK, there are three ways to create a DOM:</p>
<ul>
<li>
<p>Parse a document using <code dir="ltr">DOMParser</code>. This has been the traditional XDK approach.</p>
</li>
<li>
<p>Create a scalable DOM using <code dir="ltr">XMLDOMImplementation</code> factory methods.</p>
</li>
<li>
<p>Use an <code dir="ltr">XMLDocument</code> constructor. This is not a common solution in XDK.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHGIADJ"></a>
<div id="ADXDK3400" class="sect2">
<h3 class="sect2">Scalable DOM</h3>
<p>With Oracle 11<span class="italic">g</span> Release 1 (11.1), XDK provides scalable, pluggable support for DOM. This relieves problems of memory inefficiency, limited scalability, and lack of control over the DOM configuration.</p>
<p>For the scalable DOM, the configuration and creation are mainly supported using the <code dir="ltr">XMLDOMImplementation</code> class.</p>
<p>These are important aspects of scalable DOM:</p>
<ul>
<li>
<p>Plug-in Data allows external XML representation to be directly used by Scalable DOM without replicating XML in internal representation.</p>
<p>Scalable DOM is created on top of plug-in XML data through the <code dir="ltr">Reader</code> and <code dir="ltr">InfosetWriter</code> abstract interfaces. XML data can be in different forms, such as Binary XML, <code dir="ltr">XMLType</code>, and third-party DOM, and so on.</p>
</li>
<li>
<p>Transient nodes. DOM nodes are created lazily and may be freed if not in use.</p>
</li>
<li>
<p>Binary XML</p>
<p>The scalable DOM can use binary XML as both input and output format. Scalable DOM can interact with the data in two ways:</p>
<ul>
<li>
<p>Through the abstract <code dir="ltr">InfosetReader</code> and <code dir="ltr">InfosetWriter</code> interfaces. Users can (1) use the <code dir="ltr">BinXML</code> implementation of <code dir="ltr">InfosetReader</code> and <code dir="ltr">InfosetWriter</code> to read and write <code dir="ltr">BinXML</code> data, and (2) use other implementations supplied by the user to read and write in other forms of XML infoset.</p>
</li>
<li>
<p>Through an implementation of the <code dir="ltr">InfosetReader</code> and <code dir="ltr">InfosetWriter</code> adaptor for <code dir="ltr">BinXMLStream</code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adx_j_xmlbin.htm#BAJFBGGB">Chapter 5, "Using Binary XML for Java"</a></div>
</li>
</ul>
<p>Scalable DOM support consists of the following:</p>
<ul>
<li>
<p><a href="#CCHFAGDG">Pluggable DOM Support</a></p>
</li>
<li>
<p><a href="#BGBFHGAA">Lazy Materialization</a></p>
</li>
<li>
<p><a href="#BGBIBGJD">Configurable DOM Settings</a></p>
</li>
</ul>
<a id="CCHFAGDG"></a>
<div id="ADXDK19092" class="sect3">
<h4 class="sect3">Pluggable DOM Support</h4>
<p>Pluggable DOM is an XDK mechanism that enables you to split the DOM API from the data layer. The DOM API is separated from the data by the <code dir="ltr">InfosetReader</code> and <code dir="ltr">InfosetWriter</code> interfaces.</p>
<p>Using pluggable DOM, XML data can be easily moved from one processor to another.</p>
<p>The DOM API includes unified standard APIs on top of the data to support node access, navigation, update processes, and searching capability.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHHIFJB">"Using Pluggable DOM"</a></div>
</div>
<!-- class="sect3" -->
<a id="BGBFHGAA"></a>
<div id="ADXDK19093" class="sect3">
<h4 class="sect3">Lazy Materialization</h4>
<p>Using the lazy materialization mechanism, XDK only creates nodes that are accessed and frees unused nodes from memory. Applications can process very large XML documents with improved scalability.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHEEFID">"Using Lazy Materialization"</a></div>
</div>
<!-- class="sect3" -->
<a id="BGBIBGJD"></a>
<div id="ADXDK19094" class="sect3">
<h4 class="sect3">Configurable DOM Settings</h4>
<p>DOM configurations can be made to suit different applications. You can configure the DOM with different access patterns such as read-only, streaming, transient update, and shadow copy, achieving maximum memory use and performance in your applications.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHEIFGI">"Using Configurable DOM Settings"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBGAJIA"></a>
<div id="ADXDK19095" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SAX in the XML Parser</h3>
<p>Unlike DOM, SAX is event-based, so it does not build in-memory tree representations of input documents. SAX processes the input document element by element and can report events and significant data to callback methods in the application. The XML document in <a href="#CCHHDCHF">Example 4-1</a> is parsed as a series of linear events as shown in <a href="#CCHDFAJF">Figure 4-2</a>.</p>
<p>In general, the SAX API provides the following advantages:</p>
<ul>
<li>
<p>It is useful for search operations and other programs that do not need to manipulate an XML tree.</p>
</li>
<li>
<p>It does not consume significant memory resources.</p>
</li>
<li>
<p>It is faster than DOM when retrieving XML documents from a database.</p>
</li>
</ul>
<div id="ADXDK19096" class="figure">
<p class="titleinfigure"><a id="CCHDFAJF"></a>Figure 4-2 Comparing DOM (Tree-Based) and SAX (Event-Based) APIs</p>
<img width="645" height="345" src="img/adxdk041.gif" alt="Description of Figure 4-2 follows" /><br />
<a id="sthref75" href="img_text/adxdk041.htm">Description of "Figure 4-2 Comparing DOM (Tree-Based) and SAX (Event-Based) APIs"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="BGBFDFBH"></a>
<div id="ADXDK19097" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">JAXP in the XML Parser</h3>
<p>The JAXP API enables you to plug in an implementation of the SAX or DOM parser. The SAX and DOM APIs provided in the Oracle XDK are examples of vendor-specific implementations supported by JAXP.</p>
<p>In general, the advantage of JAXP is that you can use it to write interoperable applications. If an application uses features available through JAXP, then it can very easily switch the implementation.</p>
<p>The main disadvantage of JAXP is that it runs more slowly than vendor-specific APIs. In addition, several features are available through Oracle-specific APIs that are not available through JAXP APIs. Only some of the Oracle-specific features are available through the extension mechanism provided in JAXP. If an application uses these extensions, however, then the flexibility of switching implementation is lost.</p>
</div>
<!-- class="sect2" -->
<a id="CCHJIEHB"></a>
<div id="ADXDK19098" class="sect2">
<h3 class="sect2">Namespace Support in the XML Parser</h3>
<p>The XML parser for Java can parse unqualified element types and attribute names as well as those in namespaces. Namespaces are a mechanism to resolve or avoid name collisions between element types or attributes in XML documents by providing "universal" names. Consider the XML document shown in <a href="#CCHBFJHA">Example 4-2</a>.</p>
<div id="ADXDK19099" class="example">
<p class="titleinexample"><a id="CCHBFJHA"></a>Example 4-2 Sample XML Document Without Namespaces</p>
<pre dir="ltr">
&lt;?xml version='1.0'?&gt;
&lt;addresslist&gt;
  &lt;company&gt;
    &lt;address&gt;500 Oracle Parkway,
             Redwood Shores, CA 94065
    &lt;/address&gt;
  &lt;/company&gt;
  &lt;!-- ... --&gt;
  &lt;employee&gt;
    &lt;lastname&gt;King&lt;/lastname&gt;
    &lt;address&gt;3290 W Big Beaver
             Troy, MI 48084
    &lt;/address&gt;
  &lt;/employee&gt;
  &lt;!-- ... --&gt;
&lt;/addresslist&gt;
</pre></div>
<!-- class="example" -->
<p>Without the use of namespaces, an application processing the XML document in <a href="#CCHBFJHA">Example 4-2</a> does not know whether the <code dir="ltr">&lt;address&gt;</code> tag refers to a company or employee address. As shown in <a href="#CCHDECGB">Example 4-3</a>, you can use namespaces to distinguish the <code dir="ltr">&lt;address&gt;</code> tags. The example declares the following XML namespaces:</p>
<pre dir="ltr">
http://www.oracle.com/employee
http://www.oracle.com/company
</pre>
<p><a href="#CCHDECGB">Example 4-3</a> associates the <code dir="ltr">com</code> prefix with the first namespace and the <code dir="ltr">emp</code> prefix with the second namespace. Thus, an application can distinguish <code dir="ltr">&lt;com:address&gt;</code> from <code dir="ltr">&lt;emp:address&gt;</code>.</p>
<div id="ADXDK19100" class="example">
<p class="titleinexample"><a id="CCHDECGB"></a>Example 4-3 Sample XML Document with Namespaces</p>
<pre dir="ltr">
&lt;?xml version='1.0'?&gt;
&lt;addresslist&gt;
&lt;!-- ... --&gt;
  &lt;com:company 
    xmlns:com="http://www.oracle.com/company/"&gt;
    &lt;com:address&gt;500 Oracle Parkway,
             Redwood Shores, CA 94065
    &lt;/com:address&gt;
  &lt;/com:company&gt;
  &lt;!-- ... --&gt;
  &lt;emp:employee
    xmlns:emp="http://www.oracle.com/employee/"&gt;
    &lt;emp:lastname&gt;King&lt;/emp:lastname&gt;
    &lt;emp:address&gt;3290 W Big Beaver
             Troy, MI 48084
    &lt;/emp:address&gt;
&lt;/emp:employee&gt;
</pre></div>
<!-- class="example" -->
<p>It is helpful to remember the following terms when parsing documents that use namespaces:</p>
<ul>
<li>
<p>Namespace prefix, which is a namespace prefix declared with <code dir="ltr">xmlns</code>. In <a href="#CCHDECGB">Example 4-3</a>, <code dir="ltr">emp</code> and <code dir="ltr">com</code> are namespace prefixes.</p>
</li>
<li>
<p>Local name, which is the name of an element or attribute without the namespace prefix. In <a href="#CCHDECGB">Example 4-3</a>, <code dir="ltr">employee</code> and <code dir="ltr">company</code> are local names.</p>
</li>
<li>
<p>Qualified name, which is the local name plus the prefix. In <a href="#CCHDECGB">Example 4-3</a>, <code dir="ltr">emp:employee</code> and <code dir="ltr">com:company</code> are qualified names.</p>
</li>
<li>
<p>Namespace URI, which is the URI assigned to <code dir="ltr">xmlns</code>. In <a href="#CCHDECGB">Example 4-3</a>, <code dir="ltr">http://www.oracle.com/employee</code> and <code dir="ltr">http://www.oracle.com/company</code> are namespace URIs.</p>
</li>
<li>
<p>Expanded name, which is obtained by substituting the namespace URI for the namespace prefix. In <a href="#CCHDECGB">Example 4-3</a>, <code dir="ltr">http://www.oracle.com/employee:employee</code> and <code dir="ltr">http://www.oracle.com/company:company</code> are expanded element names.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1024648"></a>
<div id="ADXDK19101" class="sect2">
<h3 class="sect2">Validation in the XML Parser</h3>
<p>Applications invoke the <code dir="ltr">parse()</code> method to parse XML documents. Typically, applications invoke initialization and termination methods in association with the <code dir="ltr">parse()</code> method. You can use the <code dir="ltr">setValidationMode()</code> method defined in <code dir="ltr">oracle.xml.parser.v2.XMLParser</code> to set the parser mode to validating or nonvalidating.</p>
<p>By parsing an XML document according to the rules specified in a DTD or an XML schema, a validating XML parser determines whether the document conforms to the specified DTD or XML schema. If the XML document does conform, then the document is valid, which means that the structure of the document conforms to the DTD or schema rules. A nonvalidating parser checks for well-formedness only.</p>
<p><a href="#g1043218">Table 4-1</a> shows the flags that you can use in <code dir="ltr">setValidationMode()</code> to set the validation mode in the Oracle XDK parser.</p>
<div id="ADXDK19102" class="tblhruleformalwidemax">
<p class="titleintable"><a id="sthref76"></a><a id="g1043218"></a>Table 4-1 XML Parser for Java Validation Modes</p>
<table class="cellalignment1211" title="XML Parser for Java Validation Modes " summary="Name of Mode, Mode Value in Java, and Description are the columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t9">Name</th>
<th class="cellalignment1212" id="r1c2-t9">Value</th>
<th class="cellalignment1212" id="r1c3-t9">The XML Parser . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t9" headers="r1c1-t9">
<p>Nonvalidating mode</p>
</td>
<td class="cellalignment1213" headers="r2c1-t9 r1c2-t9">
<p><code dir="ltr">NONVALIDATING</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t9 r1c3-t9">
<p>Verifies that the XML is well-formed and parses the data.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t9" headers="r1c1-t9">
<p><span class="bold"><a id="sthref77"></a></span>DTD validating mode</p>
</td>
<td class="cellalignment1213" headers="r3c1-t9 r1c2-t9">
<p><code dir="ltr">DTD_VALIDATION</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t9 r1c3-t9">
<p>Verifies that the XML is well-formed and validates the XML data against the DTD. The DTD defined in the <code dir="ltr">&lt;!DOCTYPE&gt;</code> declaration must be relative to the location of the input XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t9" headers="r1c1-t9">
<p><span class="bold"><a id="sthref78"></a><a id="sthref79"></a></span>Schema validation mode</p>
</td>
<td class="cellalignment1213" headers="r4c1-t9 r1c2-t9">
<p><code dir="ltr">SCHEMA_VALIDATION</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t9 r1c3-t9">
<p>Validates the XML Document according to the XML schema specified for the document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t9" headers="r1c1-t9">
<p>LAX validation mode</p>
</td>
<td class="cellalignment1213" headers="r5c1-t9 r1c2-t9">
<p><code dir="ltr">SCHEMA_LAX_VALIDATION</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t9 r1c3-t9">
<p>Tries to validate part or all of the instance document as long as it can find the schema definition. It does not raise an error if it cannot find the definition. See the sample program <code dir="ltr">XSDLax.java</code> in the <code dir="ltr">schema</code> directory.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t9" headers="r1c1-t9">
<p>Strict validation mode</p>
</td>
<td class="cellalignment1213" headers="r6c1-t9 r1c2-t9">
<p><code dir="ltr">SCHEMA_STRICT_VALIDATION</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t9 r1c3-t9">
<p>Tries to validate the whole instance document, raising errors if it cannot find the schema definition or if the instance does not conform to the definition.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t9" headers="r1c1-t9">
<p><span class="bold"><a id="sthref80"></a></span>Partial validation mode</p>
</td>
<td class="cellalignment1213" headers="r7c1-t9 r1c2-t9">
<p><code dir="ltr">PARTIAL_VALIDATION</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t9 r1c3-t9">
<p>Validates all or part of the input XML document according to the DTD, if present. If the DTD is not present, then the parser is set to nonvalidating mode.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t9" headers="r1c1-t9">
<p><span class="bold"><a id="sthref81"></a><a id="sthref82"></a></span>Auto validation mode</p>
</td>
<td class="cellalignment1213" headers="r8c1-t9 r1c2-t9">
<p><code dir="ltr">AUTO_VALIDATION</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t9 r1c3-t9">
<p>Validates all or part of the input XML document according to the DTD or XML schema, if present. If neither is present, then the parser is set to nonvalidating mode.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwidemax" -->
<p>In addition to setting the validation mode with <code dir="ltr">setValidationMode()</code>, you can use the <code dir="ltr"><a id="sthref83"></a>oracle.xml.parser.schema.XSDBuilder</code> class to build an XML schema and then configure the parser to use it by invoking the <code dir="ltr">XMLParser.setXMLSchema()</code> method. In this case, the XML parser automatically sets the validation mode to <code dir="ltr">SCHEMA_STRICT_VALIDATION</code> and ignores the <code dir="ltr">schemaLocation</code> and <code dir="ltr">noNamespaceSchemaLocation</code> attributes. You can also change the validation mode to <code dir="ltr">SCHEMA_LAX_VALIDATION</code>. The <code dir="ltr">XMLParser.setDoctype()</code> method is a parallel method for DTDs, but unlike <code dir="ltr">setXMLSchema()</code> it does not alter the validation mode.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adx_j_sproc.htm#i1003036">Chapter 7, "Using the Schema Processor for Java"</a> to learn about validation</p>
</li>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> to learn about the <code dir="ltr">XMLParser</code> and <code dir="ltr">XSDBuilder</code> classes</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1027439"></a>
<div id="ADXDK19103" class="sect2">
<h3 class="sect2">Compression in the XML Parser</h3>
<p>You can use the XML compressor, which is implemented in the XML parser, to compress and decompress XML documents. The compression algorithm is based on tokenizing the XML tags. The assumption is that any XML document repeats a number of tags and so tokenizing these tags gives considerable compression. The degree of compression depends on the type of document: the larger the tags and the lesser the text content, the better the compression.</p>
<p>The Oracle XML parser generates a binary compressed output from an in-memory DOM tree or SAX events generated from an XML document. <a href="#CCHHGEDF">Table 4-2</a> describes the two types of compression.</p>
<div id="ADXDK19104" class="tblruleformalwide">
<p class="titleintable"><a id="sthref84"></a><a id="CCHHGEDF"></a>Table 4-2 XML Compression with DOM and SAX</p>
<table class="cellalignment1211" title="XML Compression with DOM and SAX" summary="This table describes differences between compression with the DOM and SAX APIs." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t11">Type</th>
<th class="cellalignment1212" id="r1c2-t11">Description</th>
<th class="cellalignment1212" id="r1c3-t11">Compression APIs</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t11" headers="r1c1-t11">
<p>DOM-based</p>
</td>
<td class="cellalignment1213" headers="r2c1-t11 r1c2-t11">
<p>The goal is to reduce the size of the XML document without losing the structural and hierarchical information of the DOM tree. The parser serializes an in-memory DOM tree, corresponding to a parsed XML document, and generates a compressed XML output stream. The serialized stream regenerates the DOM tree when read back.</p>
</td>
<td class="cellalignment1213" headers="r2c1-t11 r1c3-t11">
<p>Use the <code dir="ltr">writeExternal()</code> method to generate compressed XML and the <code dir="ltr">readExternal()</code> method to reconstruct it. The methods are in the <code dir="ltr">oracle.xml.parser.v2.XMLDocument</code> class.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t11" headers="r1c1-t11">
<p>SAX-based</p>
</td>
<td class="cellalignment1213" headers="r3c1-t11 r1c2-t11">
<p>The SAX parser generates a compressed stream when it parses an XML file. SAX events generated by the SAX parser are handled by the SAX compression utility, which generates a compressed binary stream. When the binary stream is read back, the SAX events are generated.</p>
</td>
<td class="cellalignment1213" headers="r3c1-t11 r1c3-t11">
<p>To generate compressed XML, instantiate <code dir="ltr">oracle.xml.comp.CXMLHandlerBase</code> by passing an output stream to the constructor. Pass the object to <code dir="ltr">SAXParser.setContentHandler()</code> and then execute the <code dir="ltr">parse()</code> method. Use the <code dir="ltr">oracle.xml.comp.CXMLParser</code> class to decompress the XML.</p>
<p><span class="bold">Note:</span> <code dir="ltr">CXMLHandlerBase</code> implements both SAX 1.0 and 2.0, but because 1.0 is deprecated, it is recommended that you use the 2.0 API.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwide" -->
<p>The compressed streams generated from DOM and SAX are compatible, that is, you can use the compressed stream generated from SAX to generate the DOM tree and vice versa. As with XML documents in general, you can store the compressed XML data output in the database as a <code dir="ltr">BLOB</code>.</p>
<p>When a program parses a large XML document and creates a DOM tree in memory, it can affect performance. You can compress an XML document into a binary stream by serializing the DOM tree. You can regenerate the DOM tree without validating the XML data in the compressed stream. You can treat the compressed stream as a serialized stream, but the data in the stream is more controlled and managed than the compression implemented by Java's default serialization.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Text cannot search a compressed XML document. Decompression reduces performance. If you are transferring files between client and server, then HTTP compression can be easier.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1033575"></a>
<div id="ADXDK19105" class="sect1">
<h2 class="sect1">Using XML Parsing for Java: Overview<a id="sthref85"></a></h2>
<p>The fundamental component of any XML development is XML parsing. XML parsing for Java is a standalone XML component that parses an XML document (and possibly also a standalone DTD or XML Schema) so that your program can process it. This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHBEHEF">Using the XML Parser for Java: Basic Process</a></p>
</li>
<li>
<p><a href="#CCHGBAGC">Running the XML Parser Demo Programs</a></p>
</li>
<li>
<p><a href="#i1035390">Using the XML Parser Command-Line Utility</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use the parser with any supported JavaVMs. With Oracle9<span class="italic">i</span> or higher you can load the parser into the database and use the internal <a id="sthref86"></a><a id="sthref87"></a>Oracle9<span class="italic">i</span> JVM. For other database versions, run the parser in an external JVM and connect to a database through JDBC.</div>
<a id="CCHBEHEF"></a>
<div id="ADXDK19106" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the XML Parser for Java: Basic Process</h3>
<p><a href="#i1038080">Figure 4-3</a> shows how to use the XML parser in a typical XML processing application.</p>
<div id="ADXDK19107" class="figure">
<p class="titleinfigure"><a id="i1038080"></a>Figure 4-3 XML Parser for Java</p>
<img width="329" height="273" src="img/adxdk002.gif" alt="Description of Figure 4-3 follows" /><br />
<a id="sthref88" href="img_text/adxdk002.htm">Description of "Figure 4-3 XML Parser for Java"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The basic process of the application shown in <a href="#i1038080">Figure 4-3</a> is as follows:</p>
<ol>
<li>
<p>The DOM or SAX parser parses input XML documents. For example, the program can parse XML data documents, DTDs, XML schemas, and XSL stylesheets.</p>
</li>
<li>
<p>If you implement a validating parser, then the processor attempts to validate the XML data document against any supplied DTDs or XML schemas.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adx_j_xslt.htm#g1034010">Chapter 6, "Using the XSLT Processor for Java"</a></p>
</li>
<li>
<p><a href="adx_j_sproc.htm#i1003036">Chapter 7, "Using the Schema Processor for Java"</a> to learn about validation</p>
</li>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> for XML parser classes and methods</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CCHGBAGC"></a>
<div id="ADXDK19108" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Running the XML Parser Demo Programs</h3>
<p>Demo programs for the XML parser for Java are included in <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser</code>. The demo programs are distributed among the subdirectories described in <a href="#CCHHGCFI">Table 4-3</a>.</p>
<div id="ADXDK19109" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref89"></a><a id="CCHHGCFI"></a>Table 4-3 Java Parser Demos</p>
<table class="cellalignment1211" title="Java Parser Demos" summary="Describes the subdirectories of the /demo/java directory." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t15">Directory</th>
<th class="cellalignment1212" id="r1c2-t15">Contents</th>
<th class="cellalignment1212" id="r1c3-t15">These programs ...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t15" headers="r1c1-t15">
<p><code dir="ltr">common</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t15 r1c2-t15">
<pre dir="ltr">
class.xml
DemoUtil.java
empl.xml
family.dtd
family.xml
iden.xsl
NSExample.xml
traversal.xml
</pre></td>
<td class="cellalignment1213" headers="r2c1-t15 r1c3-t15">
<p>Provide XML files and Java programs for general use with the XML parser. For example, you can use the XSLT stylesheet <code dir="ltr">iden.xsl</code> to achieve an identity transformation of the XML files. <code dir="ltr">DemoUtil.java</code> implements a helper method to create a URL from a file name. This method is used by many of the other demo programs.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t15" headers="r1c1-t15">
<p><code dir="ltr">comp</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t15 r1c2-t15">
<pre dir="ltr">
DOMCompression.java
DOMDeCompression.java
SAXCompression.java
SAXDeCompression.java
SampleSAXHandler.java
sample.xml
xml.ser
</pre></td>
<td class="cellalignment1213" headers="r3c1-t15 r1c3-t15">
<p>Illustrate DOM and SAX compression:</p>
<ul>
<li>
<p><code dir="ltr">DOMCompression.java</code> compresses a DOM tree.</p>
</li>
<li>
<p><code dir="ltr">DOMDeCompression.java</code> reads back a DOM from a compressed stream.</p>
</li>
<li>
<p><code dir="ltr">SAXCompression.java</code> compresses the output from a SAX parser.</p>
</li>
<li>
<p><code dir="ltr">SAXDeCompression.java</code> regenerates SAX events from the compressed stream.</p>
</li>
<li>
<p><code dir="ltr">SampleSAXHandler.java</code> illustrates use of a handler to handle the events thrown by the SAX <code dir="ltr">DeCompressor</code>.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t15" headers="r1c1-t15">
<p><code dir="ltr">dom</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t15 r1c2-t15">
<pre dir="ltr">
AutoDetectEncoding.java
DOM2Namespace.java
DOMNamespace.java
DOMRangeSample.java
DOMSample.java
EventSample.java
I18nSafeXMLFileWritingSample.java
NodeIteratorSample.java
ParseXMLFromString.java
TreeWalkerSample.java
</pre></td>
<td class="cellalignment1213" headers="r4c1-t15 r1c3-t15">
<p>Illustrate uses of the DOM API:</p>
<ul>
<li>
<p><code dir="ltr">DOM2Namespace.java</code> shows how to use DOM Level 2.0 APIs.</p>
</li>
<li>
<p><code dir="ltr">DOMNamespace.java</code> shows how to use Namespace extensions to DOM APIs.</p>
</li>
<li>
<p><code dir="ltr">DOMRangeSample.java</code> shows how to use DOM Range APIs.</p>
</li>
<li>
<p><code dir="ltr">DOMSample.java</code> shows basic use of the DOM APIs.</p>
</li>
<li>
<p><code dir="ltr">EventSample.java</code> shows how to use DOM Event APIs.</p>
</li>
<li>
<p><code dir="ltr">NodeIteratorSample.java</code> shows how to use DOM Iterator APIs.</p>
</li>
<li>
<p><code dir="ltr">TreeWalkerSample.java</code> shows how to use DOM <code dir="ltr">TreeWalker</code> APIs.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t15" headers="r1c1-t15">
<p><code dir="ltr">jaxp</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t15 r1c2-t15">
<pre dir="ltr">
JAXPExamples.java
age.xsl
general.xml
jaxpone.xml
jaxpone.xsl
jaxpthree.xsl
jaxptwo.xsl
oraContentHandler.java
</pre></td>
<td class="cellalignment1213" headers="r5c1-t15 r1c3-t15">
<p>Illustrate various uses of the JAXP API:</p>
<ul>
<li>
<p><code dir="ltr">JAXPExamples.java</code> provides a few examples of how to use the JAXP 1.1 API to run the Oracle engine.</p>
</li>
<li>
<p><code dir="ltr">oraContentHandler.java</code> implements a SAX content handler. The program invokes methods such as <code dir="ltr">startDocument()</code>, <code dir="ltr">endDocument()</code>, <code dir="ltr">startElement()</code>, and <code dir="ltr">endElement()</code> when it recognizes an XML tag.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t15" headers="r1c1-t15">
<p><code dir="ltr">sax</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t15 r1c2-t15">
<pre dir="ltr">
SAX2Namespace.java
SAXNamespace.java
SAXSample.java
Tokenizer.java
</pre></td>
<td class="cellalignment1213" headers="r6c1-t15 r1c3-t15">
<p>Illustrate various uses of the SAX APIs:</p>
<ul>
<li>
<p><code dir="ltr">SAX2Namespace.java</code> shows how to use SAX 2.0.</p>
</li>
<li>
<p><code dir="ltr">SAXNamespace.java</code> shows how to use namespace extensions to SAX APIs.</p>
</li>
<li>
<p><code dir="ltr">SAXSample.java</code> shows basic use of the SAX APIs.</p>
</li>
<li>
<p><code dir="ltr">Tokenizer.java</code> shows how to use the <code dir="ltr">XMLToken</code> interface APIs. The program implements the <code dir="ltr">XMLToken</code> interface, which must be registered with the <code dir="ltr">setTokenHandler()</code> method. A request for XML tokens is registered with the <code dir="ltr">setToken()</code> method. During tokenizing, the parser does not validate the document and does not include or read internal/external utilities.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t15" headers="r1c1-t15">
<p><code dir="ltr">xslt</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t15 r1c2-t15">
<pre dir="ltr">
XSLSample.java
XSLSample2.java
match.xml
match.xsl
math.xml
math.xsl
number.xml
number.xsl
position.xml
position.xsl
reverse.xml
reverse.xsl
string.xml
string.xsl
style.txt
variable.xml
variable.xsl
</pre></td>
<td class="cellalignment1213" headers="r7c1-t15 r1c3-t15">
<p>Illustrate the transformation of documents with XSLT:</p>
<ul>
<li>
<p><code dir="ltr">XSLSample.java</code> shows how to use the XSL processing capabilities of the Oracle XML parser. It transforms an input XML document with a given input stylesheet. This demo builds the result of XSL transformations as a <code dir="ltr">DocumentFragment</code> and so does not support <code dir="ltr">xsl:output</code> features.</p>
</li>
<li>
<p><code dir="ltr">XSLSample2.java</code> transforms an input XML document with a given input stylesheet. The demo streams the result of the XSL transformation and so supports <code dir="ltr">xsl:output</code> features.</p>
</li>
</ul>
<p><span class="bold">See Also:</span> <a href="adx_j_xslt.htm#i1012603">"Running the XSLT Processor Demo Programs"</a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>Documentation for how to compile and run the sample programs is located in the README. The basic steps are as follows:</p>
<ol>
<li>
<p>Change into the <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser</code> directory (UNIX) or <code dir="ltr">%ORACLE_HOME%\xdk\demo\java\parser</code> directory (Windows).</p>
</li>
<li>
<p>Set up your environment as described in <a href="adx_j_gs.htm#BACFEAGD">"Setting Up the Java XDK Environment"</a>.</p>
</li>
<li>
<p>Change into each of the following subdirectories and run <code dir="ltr">make</code> (UNIX) or <code dir="ltr">Make.bat</code> (Windows) at the command line. For example:</p>
<pre dir="ltr">
cd comp;make;cd ..
cd jaxp;make;cd ..
cd sax;make;cd ..
cd dom;make;cd ..
cd xslt;make;cd ..
</pre>
<p>The make file compiles the source code in each directory, runs the programs, and writes the output for each program to a file with an <code dir="ltr">*.out</code> extension.</p>
</li>
<li>
<p>You can view the <code dir="ltr">*.out</code> files to view the output for the programs.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1035390"></a>
<div id="ADXDK19110" class="sect2">
<h3 class="sect2"><a id="sthref90"></a><a id="sthref91"></a><a id="sthref92"></a>Using the XML Parser Command-Line Utility</h3>
<p>The <code dir="ltr">oraxml</code> utility, which is located in <code dir="ltr">$ORACLE_HOME/bin</code> (UNIX) or <code dir="ltr">%ORACLE_HOME%\bin</code> (Windows), is a command-line interface that parses XML documents. It checks for both well-formedness and validity.</p>
<p>To use <code dir="ltr">oraxml</code> ensure that the following is true:</p>
<ul>
<li>
<p>Your <code dir="ltr">CLASSPATH</code> is set up as described in <a href="adx_j_gs.htm#BACFEAGD">"Setting Up the Java XDK Environment"</a>. In particular, make sure you <code dir="ltr">CLASSPATH</code> environment variable points to the <code dir="ltr">xmlparserv2.jar</code> file.</p>
</li>
<li>
<p>Your <code dir="ltr">PATH</code> environment variable can find the Java interpreter that comes with the version of the JDK that you are using.</p>
</li>
</ul>
<p><a href="#BGBIBHBG">Table 4-4</a> lists the <code dir="ltr">oraxml</code> command-line options.</p>
<div id="ADXDK19111" class="tblformal">
<p class="titleintable"><a id="sthref93"></a><a id="BGBIBHBG"></a>Table 4-4 oraxml Command-Line Options</p>
<table class="cellalignment1214" title="oraxml Command-Line Options " summary="Option and Purpose are the columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t16">Option</th>
<th class="cellalignment1212" id="r1c2-t16">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">help</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t16 r1c2-t16">
<p>Prints the help message</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">version</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t16 r1c2-t16">
<p>Prints the release version</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">novalidate</code> <code dir="ltr"><span class="codeinlineitalic">fileName</span></code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t16 r1c2-t16">
<p>Checks whether the input file is well-formed</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">dtd</code> <code dir="ltr"><span class="codeinlineitalic">fileName</span></code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t16 r1c2-t16">
<p>Validates the input file with DTD Validation</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">schema</code> <code dir="ltr"><span class="codeinlineitalic">fileName</span></code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t16 r1c2-t16">
<p>Validates the input file with Schema Validation</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">log</code> <code dir="ltr"><span class="codeinlineitalic">logfile</span></code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t16 r1c2-t16">
<p>Writes the errors to the output log file</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">comp</code> <code dir="ltr"><span class="codeinlineitalic">fileName</span></code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t16 r1c2-t16">
<p>Compresses the input XML file</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">decomp</code> <code dir="ltr"><span class="codeinlineitalic">fileName</span></code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t16 r1c2-t16">
<p>Decompresses the input compressed file</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">enc</code> <code dir="ltr"><span class="codeinlineitalic">fileName</span></code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t16 r1c2-t16">
<p>Prints the encoding of the input file</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t16" headers="r1c1-t16">
<p>-<code dir="ltr">warning</code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t16 r1c2-t16">
<p>Show warnings</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>For example, change into the <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser/common</code> directory. You can validate the document <code dir="ltr">family.xml</code> against <code dir="ltr">family.dtd</code> by executing the following on the command line:</p>
<pre dir="ltr">
oraxml -dtd -enc family.xml
</pre>
<p>The output should appear as follows:</p>
<pre dir="ltr">
The encoding of the input file: UTF-8The input XML file is parsed without errors using DTD validation mode.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CCHEEHHB"></a>
<div id="ADXDK19112" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Parsing XML with DOM</h2>
<p>The W3C standard library <code dir="ltr">org.w3c.dom</code> defines the <code dir="ltr">Document</code> class as well as classes for the components of a DOM. The Oracle XML parser includes the standard DOM APIs and is compliant with the W3C DOM recommendation. Along with <code dir="ltr">org.w3c.dom</code>, Oracle XML parsing includes classes that implement the DOM APIs and extend them to provide features such as printing document fragments and retrieving namespace information.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHIBFIA">Using the DOM API</a></p>
</li>
<li>
<p><a href="#CCHGCFEG">DOM Parser Architecture</a></p>
</li>
<li>
<p><a href="#CCHBEGDD">Performing Basic DOM Parsing</a></p>
</li>
<li>
<p><a href="#BGBHADBF">Creating Scalable DOM</a></p>
</li>
<li>
<p><a href="#CCHBDIFD">Performing DOM Operations with Namespaces</a></p>
</li>
<li>
<p><a href="#CCHBAHCJ">Performing DOM Operations with Events</a></p>
</li>
<li>
<p><a href="#CCHDFBIA">Performing DOM Operations with Ranges</a></p>
</li>
<li>
<p><a href="#CCHFFEEH">Performing DOM Operations with TreeWalker</a></p>
</li>
</ul>
<a id="CCHIBFIA"></a>
<div id="ADXDK19113" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the DOM API</h3>
<p>To implement DOM-based components in your XML application, you can use the following XDK classes:</p>
<ul>
<li>
<p><code dir="ltr">oracle.xml.parser.v2.DOMParser</code>. This class implements an XML 1.0 parser according to the W3C recommendation. Because <code dir="ltr">DOMParser</code> extends <code dir="ltr">XMLParser</code>, all methods of <code dir="ltr">XMLParser</code> are available to <code dir="ltr">DOMParser</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHGCFEG">"DOM Parser Architecture"</a></div>
</li>
<li>
<p><code dir="ltr">oracle.xml.parser.v2.XMLDOMImplementation</code>. This class contains factory methods used to created scalable, pluggable DOM.</p>
<p>For purposes of this discussion, DOMs created with the <code dir="ltr">XMLDOMImplementation</code> class are referred to as scalable or pluggable DOM.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BGBHADBF">"Creating Scalable DOM"</a></div>
</li>
</ul>
<p>You can also make use of the <code dir="ltr">DOMNamespace</code> and <code dir="ltr">DOM2Namespace</code> classes, which are sample programs included in <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser/dom</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CCHGCFEG"></a>
<div id="ADXDK19114" class="sect2">
<h3 class="sect2">DOM Parser Architecture</h3>
<p><a href="#i1040902">Figure 4-4</a> is an architectural diagram of the DOM Parser.</p>
<div id="ADXDK19115" class="figure">
<p class="titleinfigure"><a id="i1040902"></a>Figure 4-4 Basic Architecture of the DOM Parser</p>
<img width="666" height="566" src="img/adxdk055.gif" alt="Description of Figure 4-4 follows" /><br />
<a id="sthref94" href="img_text/adxdk055.htm">Description of "Figure 4-4 Basic Architecture of the DOM Parser"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="CCHBEGDD"></a>
<div id="ADXDK19116" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Performing Basic DOM Parsing</h4>
<p>The program <code dir="ltr">DOMSample.java</code> is provided to illustrate the basic steps for parsing an input XML document and accessing it through a DOM.</p>
<p>The program receives an XML file as input, parses it, and prints the elements and attributes in the DOM tree.</p>
<p>The steps provide reference to tables that provide possible methods and interfaces you can use at that point.</p>
<ol>
<li>
<p>Create a <code dir="ltr">DOMParser</code> object by calling the <code dir="ltr">DOMParser()</code> constructor. You can use this parser to parse input XML data documents as well as DTDs. The following code fragment from <code dir="ltr">DOMSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
DOMParser parser = new DOMParser();
</pre></li>
<li>
<p>Configure parser properties. See <a href="#CCHHJABF">Table 4-5</a>.</p>
<p>The following code fragment from <code dir="ltr">DOMSample.java</code> specifies the error output stream, sets the validation mode to DTD validation, and enables warning messages:</p>
<pre dir="ltr">
parser.setErrorStream(System.err);
parser.setValidationMode(DOMParser.DTD_VALIDATION);
parser.showWarnings(true);
</pre></li>
<li>
<p>Parse the input XML document by invoking the <code dir="ltr">parse()</code> method. The program builds a tree of <code dir="ltr">Node</code> objects in memory.</p>
<p>This code fragment from <code dir="ltr">DOMSample.java</code> shows how to parse an instance of the <code dir="ltr">java.net.URL</code> class:</p>
<pre dir="ltr">
parser.parse(url);
</pre>
<p>Note that the XML input can be a file, string buffer, or URL. As illustrated by the following code fragment, <code dir="ltr">DOMSample.java</code> accepts a filename as a parameter and calls the <code dir="ltr">createURL</code> helper method to construct a URL object that can be passed to the parser:</p>
<pre dir="ltr">
public class DOMSample
{
   static public void main(String[] argv)
   {
      try
      {
         if (argv.length != 1)
         {
            // Must pass in the name of the XML file.
            System.err.println("Usage: java DOMSample filename");
            System.exit(1);
         }
         ...
         // Generate a URL from the filename.
         URL url = DemoUtil.createURL(argv[0]);
         ...
</pre></li>
<li>
<p>Invoke <code dir="ltr">getDocument()</code> to obtain a handle to the root of the in-memory DOM tree, which is an <code dir="ltr">XMLDocument</code> object. You can use this handle to access every part of the parsed XML document. The <code dir="ltr">XMLDocument</code> class implements the interfaces shown in <a href="#CCHIFIEF">Table 4-6</a>.</p>
<p>This code fragment from <code dir="ltr">DOMSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
XMLDocument doc = parser.getDocument();
</pre></li>
<li id="CCHBFACH">
<p>Obtain and manipulate DOM nodes of the retrieved document by calling various <code dir="ltr">XMLDocument</code> methods. See <a href="#CCHBDBGE">Table 4-7</a>.</p>
<p>The following code fragment from <code dir="ltr">DOMSample.java</code> uses the <code dir="ltr">DOMParser.print()</code> method to print the elements and attributes of the DOM tree:</p>
<pre dir="ltr">
System.out.print("The elements are: ");
printElements(doc);
 
System.out.println("The attributes of each element are: ");
printElementAttributes(doc);
</pre>
<p>The program implements the <code dir="ltr">printElements()</code> method, which calls <code dir="ltr">getElementsByTagName()</code> to obtain a list of all the elements in the DOM tree. It then loops through each item in the list and calls <code dir="ltr">getNodeName()</code> to print the name of each element:</p>
<pre dir="ltr">
static void printElements(Document doc)
{
   NodeList nl = doc.getElementsByTagName("*");
   Node n;

   for (int i=0; i&lt;nl.getLength(); i++)
   {
      n = nl.item(i);
      System.out.print(n.getNodeName() + " ");
   }
 
   System.out.println();
}
</pre>
<p>The program implements the <code dir="ltr">printElementAttributes()</code> method, which calls <code dir="ltr">Document.getElementsByTagName()</code> to obtain a list of all the elements in the DOM tree. It then loops through each element in the list and calls <code dir="ltr">Element.getAttributes()</code> to obtain the list of attributes for the element. It then calls <code dir="ltr">Node.getNodeName()</code> to obtain the attribute name and <code dir="ltr">Node.getNodeValue()</code> to obtain the attribute value:</p>
<pre dir="ltr">
static void printElementAttributes(Document doc)
{
   NodeList nl = doc.getElementsByTagName("*");
   Element e;
   Node n;
   NamedNodeMap nnm;
 
   String attrname;
   String attrval;
   int i, len;
 
   len = nl.getLength();

   for (int j=0; j &lt; len; j++)
   {
      e = (Element)nl.item(j);
      System.out.println(e.getTagName() + ":");
      nnm = e.getAttributes();
 
      if (nnm != null)
      {
         for (i=0; i&lt;nnm.getLength(); i++)
         {
            n = nnm.item(i);
            attrname = n.getNodeName();
            attrval = n.getNodeValue();
            System.out.print(" " + attrname + " = " + attrval);
         }
      }
      System.out.println();
   }
}
</pre></li>
<li>
<p>Reset the parser state by invoking the <code dir="ltr">reset()</code> method. The parser is now ready to parse a new document.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="ADXDK19117" class="sect2"><a id="sthref95"></a>
<h3 class="sect2">Useful Methods and Interfaces</h3>
<p>The following tables provide useful methods and interfaces to use in creating an application such as the one just created in <a href="#CCHBEGDD">"Performing Basic DOM Parsing"</a>.</p>
<p><a href="#CCHHJABF">Table 4-5</a> lists useful configuration methods.</p>
<div id="ADXDK19118" class="tblhruleformal">
<p class="titleintable"><a id="sthref96"></a><a id="CCHHJABF"></a>Table 4-5 DOMParser Configuration Methods</p>
<table class="cellalignment1211" title="DOMParser Configuration Methods" summary="This table describes methods that you can use to set various properties of the DOM parser." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t19">Method</th>
<th class="cellalignment1212" id="r1c2-t19">Use this method to . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t19" headers="r1c1-t19">
<p><code dir="ltr">setBaseURL()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t19 r1c2-t19">
<p>Set the base URL for loading external entities and DTDs. Call this method if the XML document is an <code dir="ltr">InputStream</code>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t19" headers="r1c1-t19">
<p><code dir="ltr">setDoctype()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t19 r1c2-t19">
<p>Specify the DTD to use when parsing.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t19" headers="r1c1-t19">
<p><code dir="ltr">setErrorStream()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t19 r1c2-t19">
<p>Create an output stream for the output of errors and warnings.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t19" headers="r1c1-t19">
<p><code dir="ltr">setPreserveWhitespace()</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t19 r1c2-t19">
<p>Instruct the parser to preserve the whitespace in the input XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t19" headers="r1c1-t19">
<p><code dir="ltr">setValidationMode()</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t19 r1c2-t19">
<p>Set the validation mode of the parser. <a href="#g1043218">Table 4-1</a> describes the flags that you can use with this method.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t19" headers="r1c1-t19">
<p><code dir="ltr">showWarnings()</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t19 r1c2-t19">
<p>Specify whether the parser should print warnings.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p><a href="#CCHIFIEF">Table 4-6</a> lists the interfaces that the <code dir="ltr">XMLDocument</code> class implements.</p>
<div id="ADXDK19119" class="tblhruleformal">
<p class="titleintable"><a id="sthref97"></a><a id="CCHIFIEF"></a>Table 4-6 Some Interfaces Implemented by XMLDocument</p>
<table class="cellalignment1211" title="Some Interfaces Implemented by XMLDocument" summary="Lists some of the interfaces implemented by XMLDocument." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t20">Interface</th>
<th class="cellalignment1212" id="r1c2-t20">Defines . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t20" headers="r1c1-t20">
<p><code dir="ltr">org.w3c.dom.Node</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t20 r1c2-t20">
<p>A single node in the document tree and methods to access and process the node.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t20" headers="r1c1-t20">
<p><code dir="ltr">org.w3c.dom.Document</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t20 r1c2-t20">
<p>A <code dir="ltr">Node</code> that represents the entire XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t20" headers="r1c1-t20">
<p><code dir="ltr">org.w3c.dom.Element</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t20 r1c2-t20">
<p>A <code dir="ltr">Node</code> that represents an XML element.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p><a href="#CCHBDBGE">Table 4-7</a> lists some useful methods for obtaining nodes.</p>
<div id="ADXDK19120" class="tblhruleformal">
<p class="titleintable"><a id="sthref98"></a><a id="CCHBDBGE"></a>Table 4-7 Useful XMLDocument Methods</p>
<table class="cellalignment1211" title="Useful XMLDocument Methods" summary="This table describes useful methods of the XMLDocument class." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t21">Method</th>
<th class="cellalignment1212" id="r1c2-t21">Use this method to . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getAttributes()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t21 r1c2-t21">
<p>Generate a <code dir="ltr">NamedNodeMap</code> containing the attributes of this node (if it is an element) or <code dir="ltr">null</code> otherwise.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getElementsbyTagName()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t21 r1c2-t21">
<p>Retrieve recursively all elements that match a given tag name under a certain level. This method supports the <code dir="ltr">*</code> tag, which matches any tag. Call <code dir="ltr">getElementsByTagName("*")</code> through the handle to the root of the document to generate a list of all elements in the document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getExpandedName()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t21 r1c2-t21">
<p>Obtain the expanded name of the element. This method is specified in the <code dir="ltr">NSName</code> interface.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getLocalName()</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t21 r1c2-t21">
<p>Obtain the local name for this element. If an element name is <code dir="ltr">&lt;E1:locn xmlns:E1="http://www.oracle.com/"/&gt;</code>, then <code dir="ltr">locn</code> is the local name.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getNamespaceURI()</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t21 r1c2-t21">
<p>Obtain the namespace URI of this node, or <code dir="ltr">null</code> if it is unspecified. If an element name is <code dir="ltr">&lt;E1:locn xmlns:E1="http://www.oracle.com/"/&gt;</code>, then <code dir="ltr">http://www.oracle.com</code> is the namespace URI.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getNodeName()</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t21 r1c2-t21">
<p>Obtain the name of a node in the DOM tree.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getNodeValue()</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t21 r1c2-t21">
<p>Obtain the value of this node, depending on its type. This mode is in the <code dir="ltr">Node</code> interface.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getPrefix()</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t21 r1c2-t21">
<p>Obtain the namespace prefix for an element.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getQualifiedName()</code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t21 r1c2-t21">
<p>Obtain the qualified name for an element. If an element name is <code dir="ltr">&lt;E1:locn xmlns:E1="http://www.oracle.com/"/&gt;</code>, then <code dir="ltr">E1:locn</code> is the qualified name..</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t21" headers="r1c1-t21">
<p><code dir="ltr">getTagName()</code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t21 r1c2-t21">
<p>Obtain the name of an element in the DOM tree.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect2" -->
<a id="BGBHADBF"></a>
<div id="ADXDK19121" class="sect2">
<h3 class="sect2">Creating Scalable DOM</h3>
<p>This section discusses how to create and use a scalable DOM.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHHIFJB">Using Pluggable DOM</a></p>
</li>
<li>
<p><a href="#CCHEEFID">Using Lazy Materialization</a></p>
</li>
<li>
<p><a href="#CCHEIFGI">Using Configurable DOM Settings</a></p>
</li>
<li>
<p><a href="#CCHIICBJ">Scalable DOM Applications</a></p>
</li>
</ul>
<a id="CCHHIFJB"></a>
<div id="ADXDK19122" class="sect3">
<h4 class="sect3">Using Pluggable DOM</h4>
<p>Pluggable DOM has the DOM API split from the data. The underlying data can be either internal or plug-in, and both can be in binary XML.</p>
<ul>
<li>
<p>Internal Data</p>
<p>To plug in internal data (XML text that has not been parsed), the XML text must be saved as binary XML, then parsed by the <code dir="ltr">DOMParser</code>. The parsed binary XML can be then be plugged into the <code dir="ltr">InfoSetReader</code> of the DOM API layer.</p>
<p>The <code dir="ltr">InfosetReader</code> argument is the interface to the underlying XML data.</p>
</li>
<li>
<p>Plug-in Data</p>
<p>Plug-in data is data that has already been parsed and therefore can be transferred from one processor to another without requiring parsing.</p>
</li>
</ul>
<p>To create a pluggable DOM, XML data is plugged in through the <code dir="ltr">InfosetReader</code> interface on an <code dir="ltr">XMLDOMImplementation</code> object, for example:</p>
<pre dir="ltr">
public Document createDocument(InfosetReader reader) throws DOMException
</pre>
<p>The <code dir="ltr">InfosetReader</code> API is implemented on top of the XDK <code dir="ltr">BinXMLStream</code>. Optional adaptors for other forms of XML data such as DOM4J, JDOM, or JDBC may also be supported. Users can also plug in their own implementations.</p>
<p><code dir="ltr">InfosetReader</code> serves as the interface between the scalable DOM API layer and the underlying data. It is a generic, stream-based pull API that accesses XML data. The <code dir="ltr">InfosetReader</code> retrieves sequential events from the XML stream and queries the state and data from these events. In the following example, the XML data is scanned to retrieve the <code dir="ltr">QName</code>s and attributes of all elements:</p>
<pre dir="ltr">
InfosetReader reader;
While (reader.hasNext())
{
   reader.next();
   if (reader.getEventType() == START_ELEMENT)
   {
        QName name = reader.getQName();
        TypedAttributeList attrList = reader.getAttributeList();
     }
} 
</pre>
<div id="ADXDK19123" class="sect4"><a id="sthref99"></a>
<h5 class="sect4">InfosetReader Options</h5>
<p>The <code dir="ltr">InfosetReader</code> interface supports the following functionality:</p>
<p>Copying: To support shadow copy of DOM across documents, a new copy of <code dir="ltr">InfosetReader</code> can be created to ensure thread safety, using the <code dir="ltr">Clone</code> method. An <code dir="ltr">InfosetReader</code> obtained from <code dir="ltr">BinXMLStream</code> always supports this (Optional).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHBHGHA">"Using Shadow Copy"</a></div>
<p>Moving Focus: To support lazy materialization, the <code dir="ltr">InfosetReader</code> may have the ability to move focus to any location specified by <code dir="ltr">Offset</code> (Optional).</p>
<pre dir="ltr">
If (reader.hasSeekSupport())
   <span class="bold">reader.seek(offset</span>);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CCHEEFID">"Using Lazy Materialization"</a></div>
</div>
<!-- class="sect4" -->
<div id="ADXDK19124" class="sect4"><a id="sthref100"></a>
<h5 class="sect4">InfosetWriter</h5>
<p><code dir="ltr">InfosetWriter</code> is an extension of the <code dir="ltr">InfosetReader</code> interface that supports data writing. XDK provides an implementation on top of binary XML. Users cannot modify this implementation.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDK19125" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref101"></a>
<h5 class="sect4">Saving XML Text as <a id="sthref102"></a>Binary XML</h5>
<p>To create a scalable DOM from XML text, you must save the XML text as binary XML, before you can run <code dir="ltr">DOMParser</code> on it. You can save the XML text as either of the following:</p>
<ul>
<li>
<p>Binary XML</p>
</li>
<li>
<p>References to binary XML: You can save the section reference of binary XML instead of actual data, if you know that the data source is available for deserialization.</p>
</li>
</ul>
<p>The following example illustrates how to save as binary XML.</p>
<pre dir="ltr">
XMLDocument doc;
InfosetWriter writer;
doc.save(writer, <span class="bold">false</span>);
writer.close();
 
</pre>
<p>To save as references to binary XML, use <code dir="ltr">true</code> as the argument for the <code dir="ltr">save</code> command.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adx_j_xmlbin.htm#BAJFBGGB">Chapter 5, "Using Binary XML for Java"</a></div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CCHEEFID"></a>
<div id="ADXDK19126" class="sect3">
<h4 class="sect3">Using Lazy Materialization</h4>
<p>Using lazy materialization, you can plug in an empty DOM, which can pull in more data when needed and free nodes when they are no longer needed.</p>
<div id="ADXDK19127" class="sect4"><a id="sthref103"></a>
<h5 class="sect4">Pulling Data on Demand</h5>
<p>The plug-in DOM architecture creates an empty DOM, which contains a single <code dir="ltr">Document</code> node as the root of the tree. The rest of the DOM tree can be expanded later if it is accessed. A node may have unexpanded child and sibling nodes, but its parent and ancestors are always expanded. Each node maintains the <code dir="ltr">InfoSetReader.Offset</code> property of the next node so that the DOM can pull data additional to create the next node.</p>
<p>Depending on the access method type, DOM nodes may expand more than the set of nodes returned:</p>
<ul>
<li>
<p>DOM Navigation</p>
<p>The DOM navigation interface allows access to neighboring nodes such as first child, last child, parent, previous or next sibling. If node creation is needed, it is always done in document order.</p>
</li>
<li>
<p>ID Indexing</p>
<p>A DTD or XML schema can specify nodes with the type ID. If the DOM supports ID indexing, those nodes can be directly retrieved using the index. In the case of scalable DOM, retrieval by index does not cause the expansion of all previous nodes, but their ancestor nodes are materialized.</p>
</li>
<li>
<p>XPath Expressions</p>
<p>XPath evaluation can cause materialization of all intermediate nodes in memory. For example, the descendent axis '//' results in the expansion of the whole subtree, although some nodes might be released after evaluation.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="ADXDK19128" class="sect4"><a id="sthref104"></a>
<h5 class="sect4">Freeing Nodes When No Longer Needed</h5>
<p>Scalable DOM supports either manual or automatic dereferencing of nodes:</p>
<ul>
<li>
<p>Automatic Dereferencing Using Weak References</p>
<p>To enable automatic dereferencing, set <code dir="ltr">PARTIAL_DOM</code> attribute to <code dir="ltr">Boolean.TRUE</code>.</p>
<p>Supporting DOM navigation requires adding cross references among nodes. In automatic dereferencing mode, some of the links are weak references, which can be freed during garbage collection.</p>
<p>Node release is based on the importance of the links: Links to parent nodes cannot be dropped because ancestors provide context for in-scope namespaces and it is difficult to retrieve dropped parent nodes using streaming APIs such as <code dir="ltr">InfosetReader</code>.</p>
<p>The scalable DOM always holds its parent and previous sibling strongly but holds its children and following sibling weakly. When the Java Virtual Machine frees the nodes, references to them are still available in the underlying data so they can be recreated if needed.</p>
</li>
<li>
<p>Manual Dereferencing:</p>
<p>To enable manual dereferencing, set the attribute <code dir="ltr">PARTIAL_DOM</code> to <code dir="ltr">Boolean.FALSE</code> and create the DOM with plug-in XML data.</p>
<p>In this mode, the DOM depends on the application to explicitly dereference a document fragment from the whole tree. There are no weak references. It is recommended that if an application has a deterministic order of processing the data, to avoid the extra overhead of repeatedly releasing and recreating nodes.</p>
<p>To dereference a node from all other nodes, call <code dir="ltr">freeNode()</code> on it. For example:</p>
<pre dir="ltr">
Element root = doc.getDocumentElement();
 Node item = root.getFirstChild();
While (item != null)
{
     processItem(item);
     Node tmp = item;
     item = item.getNextSibling();
<span class="bold">     ((XMLNode)tmp).freeNode();</span>
}
</pre>
<p>The <code dir="ltr">freeNode</code> call has no effect on a non-scalable DOM.</p>
<p>Note that dereferencing nodes is different from removing nodes from a DOM tree. The DOM tree does not change when <code dir="ltr">freeNode</code> is called on a DOM node. The node can still be accessed and recreated from its parent, previous, and following siblings. However, a variable that holds the node will throw an error when accessing the node after the node has been freed.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="CCHBHGHA"></a>
<div id="ADXDK19129" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Using Shadow Copy</h5>
<p>With shadow copy, the data underneath can be shared to avoid data replications</p>
<p>Cloning, a common operation in XML processing, can be done lazily with pluggable DOM.</p>
<p>When the <code dir="ltr">copy</code> method is used, it creates just the root node of the fragment being copied, and the subtree can be expanded on demand.</p>
<p>Data sharing is for the underlying data, not the DOM nodes themselves. The DOM specification requires that the clone and its original have different node identities, and that they have different parent nodes.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDK19130" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref105"></a>
<h5 class="sect4">Incorporating DOM Updates</h5>
<p>The DOM API supports update operations such as adding, deleting nodes, setting, deleting, changing, and inserting values. When a DOM is created by plugging in XML data, the underlying data is considered external to the DOM. DOM updates are visible from the DOM APIs but the data source remains the same. Normal update operations are available and do not interfere with each other.</p>
<p>To make a modified DOM persistent, you must explicitly save the DOM. This merges all the changes with the original data and serializes the data in persistent storage. If you do not save a modified DOM explicitly, the changes are lost once the transaction ends.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDK19131" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref106"></a>
<h5 class="sect4">Using the PageManager Interface to Support Internal Data</h5>
<p>When XML text is parsed with <code dir="ltr">DOMParser</code> and configured to create a scalable DOM, internal data is cached in the form of binary XML, and the DOM API layer is built on top of the internal data. This provides increased scalability, because the binary XML is more compact than DOM nodes.</p>
<p>For additional scalability, the scalable DOM can use backend storage for binary data through the <code dir="ltr">PageManager</code> interface. Then, binary data can be swapped out of memory when not in use.</p>
<p>This code example illustrates how to use the <code dir="ltr">PageManager</code> interface.</p>
<pre dir="ltr">
DOMParser parser = new DOMParser();
parser.setAttribute(PARTIAL_DOM, Boolean.TRUE); //enable scalable DOM
parser.setAttribute(PAGE_MANAGER, new FilePageManager("pageFile"));
...
// DOMParser other configuration
parser.parse(fileURL);
XMLDocument doc = parser.getDocument();
</pre>
<p>If the <code dir="ltr">PageManager</code> interface is not used, then the parser caches the whole document as binary XML.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CCHEIFGI"></a>
<div id="ADXDK19132" class="sect3">
<h4 class="sect3">Using Configurable DOM Settings</h4>
<p>When you create a DOM with the <code dir="ltr">XMLDOMImplementation</code> class, you can configure the DOM to suit different applications and achieve maximum efficiency, using the <code dir="ltr">setAttribute</code> method in the <code dir="ltr">XMLDOMImplementation</code> class.</p>
<pre dir="ltr">
public void setAttribute(String name, Object value) throws IllegalArgumentException
</pre>
<p>For scalable DOM, call <code dir="ltr">setAttribute</code> for the <code dir="ltr">PARTIAL_DOM</code> and <code dir="ltr">ACCESS_MODE</code> attributes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
New attribute values always affect the next DOM, not the current one, so an instance of <code dir="ltr">XMLDOMImplementation</code> can be used to create DOMs with different configurations.</div>
<ul>
<li>
<p><code dir="ltr">PARTIAL_DOM</code></p>
<p>This attribute indicates whether the DOM is scalable (partial), and whether it takes a Boolean value. DOM creation is scalable when the attribute is set to <code dir="ltr">TRUE</code> and nodes that are not in use are freed and recreated when needed. DOM creation is not scalable when the attribute is set to <code dir="ltr">FALSE</code> or is not set.</p>
</li>
<li>
<p><code dir="ltr">ACCESS_MODE</code></p>
<p>This attribute controls the access of the DOM and applies to both scalable DOM and non-scalable DOM. It has the following values:</p>
<ul>
<li>
<p><code dir="ltr">UPDATEABLE</code></p>
<p>The DOM supports all DOM update operations.</p>
<p><code dir="ltr">UPDATEABLE</code> is the default value for the <code dir="ltr">ACCESS_MODE</code> attribute, in order to maintain backward compatibility with the XDK DOM implementation.</p>
</li>
<li>
<p><code dir="ltr">READ_ONLY</code></p>
<p>DOM can only read this.</p>
<p>Any attempt to modify the DOM tree results in an error, but node creation such as cloning is allowed, as long as the new nodes are not added to the DOM tree.</p>
</li>
<li>
<p><code dir="ltr">FORWARD_READ</code></p>
<p>This value allows forward navigation, such as <code dir="ltr">getFirstChild()</code>.<code dir="ltr">getNextSibling()</code>, and <code dir="ltr">getLastChild()</code>, but not backward access, such as <code dir="ltr">getPreviousSibling()</code>.</p>
<p><code dir="ltr">FORWARD_READ</code> can still access parent and ancestor nodes.</p>
</li>
<li>
<p><code dir="ltr">STREAMING</code></p>
<p>DOM access is limited to the stream of nodes in Document Order, similar to SAX-event access.</p>
<p>Following the concept of current node in stream mode, the current node is the last node that has been accessed in document order. Applications can hold nodes in variables and revisit them, but using the DOM method to access any node before the current node causes a DOM error. However, accessing ancestor nodes and attribute nodes is always allowed.</p>
<p>The following illustrates the DOM behavior in stream mode:</p>
<pre dir="ltr">
Node parent = currentNode.getParentNode(); // OK although parent is before current node
</pre>
<pre dir="ltr">
Node child = parent.getFirstChild(); // Error if the current node is not the first child of parent!
</pre>
<pre dir="ltr">
Attribute attr = parent.getFirstAttribute();// OK accessing attributes from Element is always //allowed
</pre></li>
</ul>
<p>The following lists the access modes from less restrictive to more restrictive.</p>
<p><code dir="ltr">UPDATEABLE</code> &gt; <code dir="ltr">READ_ONLY</code> &gt; <code dir="ltr">FORWARD_READ</code> &gt; <code dir="ltr">STREAM_READ</code></p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADXDK19133" class="sect3"><a id="sthref107"></a>
<h4 class="sect3">Performance Advantages to Configurable DOM Settings</h4>
<p>DOM cannot be modified in <code dir="ltr">READ_ONLY</code> mode, so the whole write buffer is not needed.</p>
<p>DOM does not read backward in <code dir="ltr">FORWARD_READ</code> mode, except to the ancestor node. Therefore, the previous sibling link is not created.</p>
<p>DOM only maintains parent links and does not need to remember data location for a node in <code dir="ltr">STREAM_READ</code> mode. Therefore, it does not need to recreate any node that has been freed.</p>
</div>
<!-- class="sect3" -->
<a id="CCHIICBJ"></a>
<div id="ADXDK19134" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Scalable DOM Applications</h4>
<p>Here is an application that creates and uses a scalable, pluggable DOM:</p>
<pre dir="ltr">
XMLDOMImplementation domimpl = new XMLDOMImplementation();
domimpl.setAttribute(XMLDocument.SCALABLE_DOM, Boolean.TRUE);
domimpl.setAttribute(XMLDocument.ACCESS_MODE,XMLDocument.UPDATEABLE);
XMLDocument scalableDoc = (XMLDocument) domimpl.createDocument(reader);
</pre>
<p>Here is an application that creates and uses a scalable, pluggable DOM based on binary XML, which is described in <a href="adx_j_xmlbin.htm#BAJFBGGB">Chapter 5, "Using Binary XML for Java"</a>:</p>
<pre dir="ltr">
BinXMLProcessor proc = BinXMLProcessorFactory.createProcessor();
BinXMLStream bstr = proc.createBinXMLStream();
BinXMLEncoder enc = bstr.getEncoder();
enc.setProperty(BinXMLEncoder.ENC_SCHEMA_AWARE, false);
 
SAXParser parser = new SAXParser();
parser.setContentHandler(enc.getContentHandler());
parser.setErrorHandler(enc.getErrorHandler());
parser.parse(BinXMLUtil.createURL(xmlfile));
 
BinXMLDecoder dec = bstr.getDecoder();
InfosetReader reader = dec.getReader();
XMLDOMImplementation domimpl = new XMLDOMImplementation();
domimpl.setAttribute(XMLDocument.SCALABLE_DOM, Boolean.TRUE);
XMLDocument currentDoc = (XMLDocument) domimpl.createDocument(reader);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHBDIFD"></a>
<div id="ADXDK19135" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing DOM Operations with Namespaces</h3>
<p>The <code dir="ltr">DOM2Namespace.java</code> program illustrates a simple use of the parser and namespace extensions to the DOM APIs. The program receives an XML document, parses it, and prints the elements and attributes in the document.</p>
<p>The initial four steps of the <a href="#CCHBEGDD">"Performing Basic DOM Parsing"</a>, from parser creation to the <code dir="ltr">getDocument()</code> call, are basically the same as for <code dir="ltr">DOM2Namespace.java</code>. The principal difference is in printing the DOM tree, which is step <a href="#CCHBFACH">5</a>. The <code dir="ltr">DOM2Namespace.java</code> program does the following instead:</p>
<pre dir="ltr">
// Print document elements
printElements(doc);
 
// Print document element attributes
System.out.println("The attributes of each element are: ");
printElementAttributes(doc);
</pre>
<p>The <code dir="ltr">printElements()</code> method implemented by <code dir="ltr">DOM2Namespace.java</code> calls <code dir="ltr">getElementsByTagName()</code> to obtain a list of all the elements in the DOM tree. It then loops through each item in the list and casts each <code dir="ltr">Element</code> to an <code dir="ltr">nsElement</code>. For each <code dir="ltr">nsElement</code> it calls <code dir="ltr">nsElement.getPrefix()</code> to get the namespace prefix, <code dir="ltr">nsElement.getLocalName()</code> to get the local name, and <code dir="ltr">nsElement.getNamespaceURI()</code> to get the namespace URI:</p>
<pre dir="ltr">
static void printElements(Document doc)
{
   NodeList nl = doc.getElementsByTagName("*");
   Element nsElement;
   String prefix;
   String localName;
   String nsName;

   System.out.println("The elements are: ");
   for (int i=0; i &lt; nl.getLength(); i++)
   {
      nsElement = (Element)nl.item(i);
 
      prefix = nsElement.getPrefix();
      System.out.println("  ELEMENT Prefix Name :" + prefix);
 
      localName = nsElement.getLocalName();
      System.out.println("  ELEMENT Local Name    :" + localName);
 
      nsName = nsElement.getNamespaceURI();
      System.out.println("  ELEMENT Namespace     :" + nsName);
   } 
   System.out.println();
}
</pre>
<p>The <code dir="ltr">printElementAttributes()</code> method calls <code dir="ltr">Document.getElementsByTagName()</code> to obtain a <code dir="ltr">NodeList</code> of the elements in the DOM tree. It then loops through each element and calls <code dir="ltr">Element.getAttributes()</code> to obtain the list of attributes for the element as special list called a <code dir="ltr">NamedNodeMap</code>. For each item in the attribute list it calls <code dir="ltr">nsAttr.getPrefix()</code> to get the namespace prefix, <code dir="ltr">nsAttr.getLocalName()</code> to get the local name, and <code dir="ltr">nsAttr.getValue()</code> to obtain the value:</p>
<pre dir="ltr">
static void printElementAttributes(Document doc)
{
   NodeList nl = doc.getElementsByTagName("*");
   Element e;
   Attr nsAttr; 
   String attrpfx;
   String attrname;
   String attrval; 
   NamedNodeMap nnm;
   int i, len;
 
   len = nl.getLength();
 
   for (int j=0; j &lt; len; j++)
   {
      e = (Element) nl.item(j);
      System.out.println(e.getTagName() + ":");
 
      nnm = e.getAttributes();
 
      if (nnm != null)
      {
         for (i=0; i &lt; nnm.getLength(); i++)
         {
            nsAttr = (Attr) nnm.item(i);
 
            attrpfx = nsAttr.getPrefix();
            attrname = nsAttr.getLocalName();
            attrval = nsAttr.getNodeValue();
 
            System.out.println(" " + attrpfx + ":" + attrname + " = " 
                               + attrval);
         }
      }
      System.out.println();
   }
}
</pre></div>
<!-- class="sect2" -->
<a id="CCHBAHCJ"></a>
<div id="ADXDK19136" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing DOM Operations with Events</h3>
<p>The <code dir="ltr">EventSample.java</code> program shows how to register various events with an event listener. For example, if a node is added to a specified DOM element, an event is triggered, which causes the listener to print information about the event.</p>
<p>The program follows these steps:</p>
<ol>
<li>
<p>Instantiate an event listener. When a registered change triggers an event, this event is passed to the event listener, which handles it. The following code fragment from <code dir="ltr">EventSample.java</code> shows the implementation of the listener:</p>
<pre dir="ltr">
eventlistener evtlist = new eventlistener();
...
class eventlistener implements EventListener
{
   public eventlistener(){}
   public void handleEvent(Event e)
   {
      String s = " Event "+e.getType()+" received " + "\n";
      s += " Event is cancelable :"+e.getCancelable()+"\n";
      s += " Event is bubbling event :"+e.getBubbles()+"\n";
      s += " The Target is " + ((Node)(e.getTarget())).getNodeName() + "\n\n";
      System.out.println(s);
   }
}
</pre></li>
<li>
<p>Instantiate a new <code dir="ltr">XMLDocument</code> and then call <code dir="ltr">getImplementation()</code> to retrieve a <code dir="ltr">DOMImplementation</code> object. You can call the <code dir="ltr">hasFeature()</code> method to determine which features are supported by this implementation. The following code fragment from <code dir="ltr">EventSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
XMLDocument doc1 = new XMLDocument();
DOMImplementation impl = doc1.getImplementation();
 
System.out.println("The impl supports Events "+
                   impl.hasFeature("Events", "2.0"));
System.out.println("The impl supports Mutation Events "+
                   impl.hasFeature("MutationEvents", "2.0"));
</pre></li>
<li>
<p>Register desired events with the listener. The following code fragment from <code dir="ltr">EventSample.java</code> registers three events on the document node:</p>
<pre dir="ltr">
doc1.addEventListener("DOMNodeRemoved", evtlist, false);
doc1.addEventListener("DOMNodeInserted", evtlist, false);
doc1.addEventListener("DOMCharacterDataModified", evtlist, false);
</pre>
<p>The following code fragment from <code dir="ltr">EventSample.java</code> creates a node of type <code dir="ltr">XMLElement</code> and then registers three events on this node:</p>
<pre dir="ltr">
XMLElement el = (XMLElement)doc1.createElement("element");
...
el.addEventListener("DOMNodeRemoved", evtlist, false);
el.addEventListener("DOMNodeRemovedFromDocument", evtlist, false);
el.addEventListener("DOMCharacterDataModified", evtlist, false);
...
</pre></li>
<li>
<p>Perform actions that trigger events, which are then passed to the listener for handling. The following code fragment from <code dir="ltr">EventSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
att.setNodeValue("abc");
el.appendChild(el1);
el.appendChild(text);
text.setNodeValue("xyz");
doc1.removeChild(el);
</pre></li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CCHDFBIA"></a>
<div id="ADXDK19137" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing DOM Operations with Ranges</h3>
<p>According to the W3C DOM specification, a range identifies a range of content in a <code dir="ltr">Document</code>, <code dir="ltr">DocumentFragment</code>, or <code dir="ltr">Attr</code>. It selects the content between a pair of boundary-points that correspond to the start and the end of the range. <a href="#CCHBADDC">Table 4-8</a> describes useful range methods accessible through <code dir="ltr">XMLDocument</code>.</p>
<div id="ADXDK19138" class="tblhruleformal">
<p class="titleintable"><a id="sthref108"></a><a id="CCHBADDC"></a>Table 4-8 Useful Methods in the Range Class</p>
<table class="cellalignment1211" title="Useful Methods in the Range Class" summary="This table describes useful range methods in the XMLDocument class." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t26">Method</th>
<th class="cellalignment1212" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t26" headers="r1c1-t26">
<p><code dir="ltr">cloneContents()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t26 r1c2-t26">
<p>Duplicates the contents of a range</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t26" headers="r1c1-t26">
<p><code dir="ltr">deleteContents()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t26 r1c2-t26">
<p>Deletes the contents of a range</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t26" headers="r1c1-t26">
<p><code dir="ltr">getCollapsed()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t26 r1c2-t26">
<p>Returns <code dir="ltr">TRUE</code> is the range is collapsed</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t26" headers="r1c1-t26">
<p><code dir="ltr">getEndContainer()</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t26 r1c2-t26">
<p>Obtains the node within which the range ends</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t26" headers="r1c1-t26">
<p><code dir="ltr">getStartContainer()</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t26 r1c2-t26">
<p>Obtains the node within which the range begins</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t26" headers="r1c1-t26">
<p><code dir="ltr">selectNode()</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t26 r1c2-t26">
<p>Selects a node and its contents</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t26" headers="r1c1-t26">
<p><code dir="ltr">selectNodeContents()</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t26 r1c2-t26">
<p>Selects the contents within a node</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t26" headers="r1c1-t26">
<p><code dir="ltr">setEnd()</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t26 r1c2-t26">
<p>Sets the attributes describing the end of a range</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t26" headers="r1c1-t26">
<p><code dir="ltr">setStart()</code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t26 r1c2-t26">
<p>Sets the attributes describing the beginning of a range</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>The <code dir="ltr">DOMRangeSample.java</code> program illustrates some of the things that you can do with ranges.</p>
<p>The initial four steps of the <a href="#CCHBEGDD">"Performing Basic DOM Parsing"</a>, from parser creation to the <code dir="ltr">getDocument()</code> call, are the same as for <code dir="ltr">DOMRangeSample.java</code>. The <code dir="ltr">DOMRangeSample.java</code> program then proceeds by following these steps:</p>
<ol>
<li>
<p>After calling <code dir="ltr">getDocument()</code> to create the <code dir="ltr">XMLDocument</code>, create a range object with <code dir="ltr">createRange()</code> and call <code dir="ltr">setStart()</code> and <code dir="ltr">setEnd()</code> to set its boundaries. The following code fragment from <code dir="ltr">DOMRangeSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
XMLDocument doc = parser.getDocument();
...
Range r = (Range) doc.createRange();
XMLNode c = (XMLNode) doc.getDocumentElement();
 
// set the boundaries
r.setStart(c,0);
r.setEnd(c,1);
</pre></li>
<li>
<p>Call <code dir="ltr">XMLDocument</code> methods to obtain information about the range and manipulate its contents. <a href="#CCHBADDC">Table 4-8</a> describes useful methods. The following code fragment from <code dir="ltr">DOMRangeSample.java</code> selects the contents of the current node and prints it:</p>
<pre dir="ltr">
r.selectNodeContents(c);
System.out.println(r.toString());
</pre>
<p>The following code fragment clones a range contents and prints it:</p>
<pre dir="ltr">
XMLDocumentFragment df =(XMLDocumentFragment) r.cloneContents();
df.print(System.out);
</pre>
<p>The following code fragment obtains and prints the start and end containers for the range:</p>
<pre dir="ltr">
c = (XMLNode) r.getStartContainer();
System.out.println(c.getText());
c = (XMLNode) r.getEndContainer();
System.out.println(c.getText());
</pre></li>
</ol>
<p>Only some of the features of the demo program are described in this section. For more detail, refer to the demo program itself.</p>
</div>
<!-- class="sect2" -->
<a id="CCHFFEEH"></a>
<div id="ADXDK19139" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing DOM Operations with TreeWalker</h3>
<p>The W3C DOM Level 2 Traversal and Range specification defines the <code dir="ltr">NodeFilter</code> and <code dir="ltr">TreeWalker</code> interfaces. The XDK includes implementations of these interfaces.</p>
<p>A node filter is an object that can filter out certain types of <code dir="ltr">Node</code> objects. For example, it can filter out entity reference nodes but accept element and attribute nodes. You create a node filter by implementing the <code dir="ltr">NodeFilter</code> interface and then passing a <code dir="ltr">Node</code> object to the <code dir="ltr">acceptNode()</code> method. Typically, the <code dir="ltr">acceptNode()</code> method implementation calls <code dir="ltr">getNodeType()</code> to obtain the type of the node and compares it to static variables such as <code dir="ltr">ELEMENT_TYPE</code>, <code dir="ltr">ATTRIBUTE_TYPE</code>, and so forth, and then returns one of the static fields in <a href="#CCHHHHAH">Table 4-9</a> based on what it finds.</p>
<div id="ADXDK19140" class="tblhruleformal">
<p class="titleintable"><a id="sthref109"></a><a id="CCHHHHAH"></a>Table 4-9 Static Fields in the NodeFilter Interface</p>
<table class="cellalignment1211" title="Static Fields in the NodeFilter Interface" summary="This table describes useful variables in the NodeFilter interface." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t27">Method</th>
<th class="cellalignment1212" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t27" headers="r1c1-t27">
<p><code dir="ltr">FILTER_ACCEPT</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t27 r1c2-t27">
<p>Accept the node. Navigation methods defined for <code dir="ltr">NodeIterator</code> or <code dir="ltr">TreeWalker</code> will return this node.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t27" headers="r1c1-t27">
<p><code dir="ltr">FILTER_REJECT</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t27 r1c2-t27">
<p>Rejects the node. Navigation methods defined for <code dir="ltr">NodeIterator</code> or <code dir="ltr">TreeWalker</code> will not return this node. For <code dir="ltr">TreeWalker</code>, the children of this node will also be rejected. <code dir="ltr">NodeIterators</code> treat this as a synonym for <code dir="ltr">FILTER_SKIP</code>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t27" headers="r1c1-t27">
<p><code dir="ltr">FILTER_SKIP</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t27 r1c2-t27">
<p>Skips this single node. Navigation methods defined for <code dir="ltr">NodeIterator</code> or <code dir="ltr">TreeWalker</code> will not return this node. For both <code dir="ltr">NodeIterator</code> and <code dir="ltr">TreeWalker</code>, the children of this node will still be considered.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>You can use <code dir="ltr">TreeWalker</code> objects to traverse a document tree or subtree using the view of the document defined by their <code dir="ltr">whatToShow</code> flags and filters (if any). You can use the <code dir="ltr">XMLDocument.createTreeWalker()</code> method to create a <code dir="ltr">TreeWalker</code> object by specifying the following:</p>
<ul>
<li>
<p>A root node for the tree</p>
</li>
<li>
<p>A flag that governs the type of nodes it should include in the logical view</p>
</li>
<li>
<p>A filter for filtering nodes</p>
</li>
<li>
<p>A flag that determines whether entity references and their descendents should be included</p>
</li>
</ul>
<p><a href="#CCHGGBGD">Table 4-10</a> describes useful methods in the <code dir="ltr">org.w3c.dom.traversal.TreeWalker</code> interface.</p>
<div id="ADXDK19141" class="tblhruleformal">
<p class="titleintable"><a id="sthref110"></a><a id="CCHGGBGD"></a>Table 4-10 Useful Methods in the TreeWalker Interface</p>
<table class="cellalignment1211" title="Useful Methods in the TreeWalker Interface" summary="This table describes methods in the TreeWalker interface." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t28">Method</th>
<th class="cellalignment1212" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t28" headers="r1c1-t28">
<p><code dir="ltr">firstChild()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t28 r1c2-t28">
<p>Moves the tree walker to the first visible child of the current node and returns the new node. If the current node has no visible children, then it returns <code dir="ltr">null</code> and retains the current node.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t28" headers="r1c1-t28">
<p><code dir="ltr">getRoot()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t28 r1c2-t28">
<p>Obtains the root node of the tree walker as specified when it was created.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t28" headers="r1c1-t28">
<p><code dir="ltr">lastChild()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t28 r1c2-t28">
<p>Moves the tree walker to the last visible child of the current node and returns the new node. If the current node has no visible children, then it returns <code dir="ltr">null</code> and retains the current node.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t28" headers="r1c1-t28">
<p><code dir="ltr">nextNode()</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t28 r1c2-t28">
<p>Moves the tree walker to the next visible node in document order relative to the current node and returns the new node.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>The <code dir="ltr">TreeWalkerSample.java</code> program illustrates some of the things that you can do with node filters and tree traversals.</p>
<p>The initial four steps of the <a href="#CCHBEGDD">"Performing Basic DOM Parsing"</a>, from parser creation to the <code dir="ltr">getDocument()</code> call, are the same as for <code dir="ltr">TreeWalkerSample.java</code>. The <code dir="ltr">TreeWalkerSample.java</code> program then proceeds by following these steps:</p>
<ol>
<li>
<p>Create a node filter object. The <code dir="ltr">acceptNode()</code> method in the <code dir="ltr">nf</code> class, which implements the <code dir="ltr">NodeFilter</code> interface, invokes <code dir="ltr">getNodeType()</code> to obtain the type of node. The following code fragment from <code dir="ltr">TreeWalkerSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
NodeFilter n2 = new nf();
...
class nf implements NodeFilter
{
  public short acceptNode(Node node)
  {
    short type = node.getNodeType();
 
    if ((type == Node.ELEMENT_NODE) || (type == Node.ATTRIBUTE_NODE))
       return FILTER_ACCEPT;
    if ((type == Node.ENTITY_REFERENCE_NODE))
       return FILTER_REJECT;
    return FILTER_SKIP;
  }
}
</pre></li>
<li>
<p>Invoke the <code dir="ltr">XMLDocument.createTreeWalker()</code> method to create a tree walker. The following code fragment from <code dir="ltr">TreeWalkerSample.java</code> uses the root node of the <code dir="ltr">XMLDocument</code> as the root node of the tree walker and includes all nodes in the tree:</p>
<pre dir="ltr">
XMLDocument doc = parser.getDocument();
...
TreeWalker tw = doc.createTreeWalker(doc.getDocumentElement(),NodeFilter.SHOW_ALL,n2,true);
</pre></li>
<li>
<p>Obtain the root element of the <code dir="ltr">TreeWalker</code> object. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
XMLNode nn = (XMLNode)tw.getRoot();
</pre></li>
<li>
<p>Traverse the tree. The following code fragment illustrates how to walk the tree in document order by calling the <code dir="ltr">TreeWalker.nextNode()</code> method:</p>
<pre dir="ltr">
while (nn != null)
{
  System.out.println(nn.getNodeName() + " " + nn.getNodeValue());
  nn = (XMLNode)tw.nextNode();
}
</pre>
<p>The following code fragment illustrates how to walk the tree the left depth of the tree by calling the <code dir="ltr">firstChild()</code> method (you can traverse the right depth of the tree by calling the <code dir="ltr">lastChild()</code> method):</p>
<pre dir="ltr">
 while (nn != null)
 {
   System.out.println(nn.getNodeName() + " " + nn.getNodeValue());
   nn = (XMLNode)tw.firstChild();
 }
</pre></li>
</ol>
<p>Only some of the features of the demo program are described in this section. For more detail, refer to the demo program itself.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CCHGBGIG"></a>
<div id="ADXDK19142" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Parsing XML with SAX</h2>
<p>SAX is a standard interface for event-based XML parsing. This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHGIIHA">Using the SAX API</a></p>
</li>
<li>
<p><a href="#CCHBAHFB">Performing Basic SAX Parsing</a></p>
</li>
<li>
<p><a href="#CCHCJBCA">Performing Basic SAX Parsing with Namespaces</a></p>
</li>
<li>
<p><a href="#CCHJIIJF">Performing SAX Parsing with XMLTokenizer</a></p>
</li>
</ul>
<a id="CCHGIIHA"></a>
<div id="ADXDK19143" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the SAX API</h3>
<p>The SAX API, which is released in a Level 1 and Level 2 versions, is a set of interfaces and classes. We can divide the API into the following categories:</p>
<ul>
<li>
<p>Interfaces implemented by the Oracle XML parser.</p>
</li>
<li>
<p>Interfaces that you must implement in your application. The SAX 2.0 interfaces are listed in <a href="#CCHIEFJI">Table 4-11</a>.</p>
<div id="ADXDK19144" class="tblhruleformal">
<p class="titleintable"><a id="sthref111"></a><a id="CCHIEFJI"></a>Table 4-11 SAX2 Handler Interfaces</p>
<table class="cellalignment1211" title="SAX2 Handler Interfaces" summary="This table describes SAX2 handler interfaces." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t29">Interface</th>
<th class="cellalignment1212" id="r1c2-t29">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t29" headers="r1c1-t29">
<p><code dir="ltr">ContentHandler</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t29 r1c2-t29">
<p>Receives notifications from the XML parser. The major event-handling methods are <code dir="ltr">startDocument()</code>, <code dir="ltr">endDocument()</code>, <code dir="ltr">startElement()</code>, and <code dir="ltr">endElement()</code> when it recognizes an XML tag. This interface also defines the methods <code dir="ltr">characters()</code> and <code dir="ltr">processingInstruction()</code>, which are invoked when the parser encounters the text in an XML element or an inline processing instruction.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t29" headers="r1c1-t29">
<p><code dir="ltr">DeclHandler</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t29 r1c2-t29">
<p>Receives notifications about DTD declarations in the XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t29" headers="r1c1-t29">
<p><code dir="ltr">DTDHandler</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t29 r1c2-t29">
<p>Processes notations and unparsed (binary) entities.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t29" headers="r1c1-t29">
<p><code dir="ltr">EntityResolver</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t29 r1c2-t29">
<p>Needed to perform redirection of URIs in documents. The <code dir="ltr">resolveEntity()</code> method is invoked when the parser must identify data identified by a URI.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t29" headers="r1c1-t29">
<p><code dir="ltr">ErrorHandler</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t29 r1c2-t29">
<p>Handles parser errors. The program invokes the methods <code dir="ltr">error()</code>, <code dir="ltr">fatalError()</code>, and <code dir="ltr">warning()</code> in response to various parsing errors.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t29" headers="r1c1-t29">
<p><code dir="ltr">LexicalHandler</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t29 r1c2-t29">
<p>Receives notifications about lexical information such as comments and CDATA section boundaries.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></li>
<li>
<p>Standard SAX classes.</p>
</li>
<li>
<p>Additional Java classes in <code dir="ltr">org.xml.sax.helper</code>. The SAX 2.0 helper classes are as follows:</p>
<ul>
<li>
<p><code dir="ltr">AttributeImpl</code>, which makes a persistent copy of an <code dir="ltr">AttributeList</code></p>
</li>
<li>
<p><code dir="ltr">DefaultHandler</code>, which is a base class with default implementations of the SAX2 handler interfaces listed in <a href="#CCHIEFJI">Table 4-11</a></p>
</li>
<li>
<p><code dir="ltr">LocatorImpl</code>, which makes a persistent snapshot of a Locator's values at specified point in the parse</p>
</li>
<li>
<p><code dir="ltr">NamespaceSupport</code>, which adds support for XML namespaces</p>
</li>
<li>
<p><code dir="ltr">XMLFilterImpl</code>, which is a base class used by applications that need to modify the stream of events</p>
</li>
<li>
<p><code dir="ltr">XMLReaderFactory</code>, which supports loading SAX parsers dynamically</p>
</li>
</ul>
</li>
<li>
<p>Demonstration classes in the <code dir="ltr">nul</code> package.</p>
</li>
</ul>
<p><a href="#i1013043">Figure 4-5</a> illustrates how to create a SAX parser and use it to parse an input document.</p>
<div id="ADXDK19145" class="figure">
<p class="titleinfigure"><a id="i1013043"></a>Figure 4-5 Using the SAXParser Class</p>
<img width="453" height="320" src="img/adxdk052.gif" alt="Description of Figure 4-5 follows" /><br />
<a id="sthref112" href="img_text/adxdk052.htm">Description of "Figure 4-5 Using the SAXParser Class"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The basic stages for parsing an input XML document with SAX are as follows:</p>
<ol>
<li>
<p>Create a <code dir="ltr">SAXParser</code> object and configure its properties (see <a href="#CCHHJABF">Table 4-5</a> for useful property methods). For example, set the validation mode of the parser.</p>
</li>
<li>
<p>Instantiate an event handler. The program should provide implementations of the handler interfaces in <a href="#CCHIEFJI">Table 4-11</a>.</p>
</li>
<li>
<p>Register the event handlers with the parser. You must register your event handlers with the parser so that it knows which methods to invoke when a given event occurs. <a href="#CCHEIGGF">Table 4-12</a> lists registration methods available in <code dir="ltr">SAXParser</code>.</p>
<div id="ADXDK19146" class="tblhruleformal">
<p class="titleintable"><a id="sthref113"></a><a id="CCHEIGGF"></a>Table 4-12 SAXParser Methods for Registering Event Handlers</p>
<table class="cellalignment1211" title="SAXParser Methods for Registering Event Handlers" summary="This table describes SAXParser methods for registering event handlers." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t30">Method</th>
<th class="cellalignment1212" id="r1c2-t30">Use this method to . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t30" headers="r1c1-t30">
<p><code dir="ltr">setContentHandler()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t30 r1c2-t30">
<p>Register a content event handler with an application. The <code dir="ltr">org.xml.sax.DefaultHandler</code> class implements the <code dir="ltr">org.xml.sax.ContentHandler</code> interface. Applications can register a new or different handler in the middle of a parse; the SAX parser must begin using the new handler immediately.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t30" headers="r1c1-t30">
<p><code dir="ltr">setDTDHandler()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t30 r1c2-t30">
<p>Register a DTD event handler. If the application does not register a DTD handler, all DTD events reported by the SAX parser are silently ignored. Applications may register a new or different handler in the middle of a parse; the SAX parser must begin using the new handler immediately.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t30" headers="r1c1-t30">
<p><code dir="ltr">setErrorHandler()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t30 r1c2-t30">
<p>Register an error event handler with an application. If the application does not register an error handler, all error events reported by the SAX parser are silently ignored; however, normal processing may not continue. It is highly recommended that all SAX applications implement an error handler to avoid unexpected bugs. Applications may register a new or different handler in the middle of a parse; the SAX parser must begin using the new handler immediately.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t30" headers="r1c1-t30">
<p><code dir="ltr">setEntityResolver()</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t30 r1c2-t30">
<p>Register an entity resolver with an application. If the application does not register an entity resolver, the <code dir="ltr">XMLReader</code> performs its own default resolution. Applications may register a new or different resolver in the middle of a parse; the SAX parser must begin using the new resolver immediately.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></li>
<li>
<p>Parse the input document with the <code dir="ltr">SAXParser.parse()</code> method. All SAX interfaces are assumed to be synchronous: the parse method must not return until parsing is complete. Readers must wait for an event-handler callback to return before reporting the next event.</p>
</li>
<li>
<p>When the <code dir="ltr">SAXParser.parse()</code> method is called, the program invokes one of several callback methods implemented in the application. The methods are defined by the <code dir="ltr">ContentHandler</code>, <code dir="ltr">ErrorHandler</code>, <code dir="ltr">DTDHandler</code>, and <code dir="ltr">EntityResolver</code> interfaces implemented in the event handler. For example, the application can call the <code dir="ltr">startElement()</code> method when a start element is encountered.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CCHBAHFB"></a>
<div id="ADXDK19147" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing Basic SAX Parsing</h3>
<p>The <code dir="ltr">SAXSample.java</code> program illustrates the basic steps of SAX parsing. The <code dir="ltr">SAXSample</code> class extends <code dir="ltr">HandlerBase</code>. The program receives an XML file as input, parses it, and prints information about the contents of the file.</p>
<p>The program follows these steps:</p>
<ol>
<li>
<p>Store the <code dir="ltr">Locator</code>. The <code dir="ltr">Locator</code> associates a SAX event with a document location. The SAX parser provides location information to the application by passing a <code dir="ltr">Locator</code> instance to the <code dir="ltr">setDocumentLocator()</code> method in the content handler. The application can use the object to obtain the location of any other content handler event in the XML source document. The following code fragment from <code dir="ltr">SAXSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
Locator locator;
</pre></li>
<li>
<p>Instantiate a new event handler. The following code fragment from <code dir="ltr">SAXSample.java</code> illustrates this technique:</p>
<pre dir="ltr">
SAXSample sample = new SAXSample();
</pre></li>
<li>
<p>Instantiate the SAX parser and configure it. The following code fragment from <code dir="ltr">SAXSample.java</code> sets the mode to DTD validation:</p>
<pre dir="ltr">
Parser parser = new SAXParser();
((SAXParser)parser).setValidationMode(SAXParser.DTD_VALIDATION);
</pre></li>
<li>
<p>Register event handlers with the SAX parser. You can use the registration methods in the <code dir="ltr">SAXParser</code> class, but you must implement the handler interfaces yourself. The following code fragment registers the handlers:</p>
<pre dir="ltr">
parser.setDocumentHandler(sample);
parser.setEntityResolver(sample);
parser.setDTDHandler(sample);
parser.setErrorHandler(sample);
</pre>
<p>The following code shows some of the <code dir="ltr">DocumentHandler</code> interface implementation:</p>
<pre dir="ltr">
public void setDocumentLocator (Locator locator)
{
  System.out.println("SetDocumentLocator:");
  this.locator = locator;
}
public void startDocument()
{
  System.out.println("StartDocument");
}
public void endDocument() throws SAXException
{
  System.out.println("EndDocument");
}
public void startElement(String name, AttributeList atts)
                                               throws SAXException
{
  System.out.println("StartElement:"+name);
  for (int i=0;i&lt;atts.getLength();i++)
  {
    String aname = atts.getName(i);
    String type = atts.getType(i);
    String value = atts.getValue(i); 
    System.out.println("   "+aname+"("+type+")"+"="+value);
  }  
}
...
</pre>
<p>The following code shows the <code dir="ltr">EntityResolver</code> interface implementation:</p>
<pre dir="ltr">
public InputSource resolveEntity (String publicId, String systemId)
                      throws SAXException
{
  System.out.println("ResolveEntity:"+publicId+" "+systemId);
  System.out.println("Locator:"+locator.getPublicId()+" locator.getSystemId()+
                    " "+locator.getLineNumber()+" "+locator.getColumnNumber());
  return null;
}
</pre>
<p>The following code shows the <code dir="ltr">DTDHandler</code> interface implementation:</p>
<pre dir="ltr">
public void notationDecl (String name, String publicId, String systemId)
{
  System.out.println("NotationDecl:"+name+" "+publicId+" "+systemId);
}
public void unparsedEntityDecl (String name, String publicId,
                                String systemId, String notationName)
{
  System.out.println("UnparsedEntityDecl:"+name + " "+publicId+" "+
                      systemId+" "+notationName);
}
</pre>
<p>The following code shows the <code dir="ltr">ErrorHandler</code> interface implementation:</p>
<pre dir="ltr">
public void warning (SAXParseException e)
           throws SAXException
{
  System.out.println("Warning:"+e.getMessage());
}
public void error (SAXParseException e)
           throws SAXException
{
  throw new SAXException(e.getMessage());
}
public void fatalError (SAXParseException e)
          throws SAXException
{
  System.out.println("Fatal error");
  throw new SAXException(e.getMessage());
}
</pre></li>
<li>
<p>Parse the input XML document. The following code fragment converts the document to a URL and then parses it:</p>
<pre dir="ltr">
parser.parse(DemoUtil.createURL(argv[0]).toString());
</pre></li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CCHCJBCA"></a>
<div id="ADXDK19148" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing Basic SAX Parsing with Namespaces</h3>
<p>This section discusses the <code dir="ltr">SAX2Namespace.java</code> sample program, which implements an event handler named <code dir="ltr">XMLDefaultHandler</code> as a subclass of the <code dir="ltr">org.xml.sax.helpers.DefaultHandler</code> class. The easiest way to implement the <code dir="ltr">ContentHandler</code> interface is to extend the <code dir="ltr">org.xml.sax.helpers.DefaultHandler</code> class. The <code dir="ltr">DefaultHandler</code> class provides some default behavior for handling events, although typically the behavior is to do nothing.</p>
<p>The <code dir="ltr">SAX2Namespace.java</code> program overrides methods for only the events that it cares about. Specifically, the <code dir="ltr">XMLDefaultHandler</code> class implements only two methods: <code dir="ltr">startElement()</code> and <code dir="ltr">endElement()</code>. The <code dir="ltr">startElement</code> event is triggered whenever <code dir="ltr">SAXParser</code> encounters a new element within the XML document. When this event is triggered, the <code dir="ltr">startElement()</code> method prints the namespace information for the element.</p>
<p>The <code dir="ltr">SAX2Namespace.java</code> sample program follows these steps:</p>
<ol>
<li>
<p>Instantiate a new event handler of type <code dir="ltr">DefaultHandler</code>. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
DefaultHandler defHandler = new XMLDefaultHandler();
</pre></li>
<li>
<p>Create a SAX parser and set its validation mode. The following code fragment from <code dir="ltr">SAXSample.java</code> sets the mode to DTD validation:</p>
<pre dir="ltr">
Parser parser = new SAXParser();
((SAXParser)parser).setValidationMode(SAXParser.DTD_VALIDATION);
</pre></li>
<li>
<p>Register event handlers with the SAX parser. The following code fragment registers handlers for the input document, the DTD, entities, and errors:</p>
<pre dir="ltr">
parser.setContentHandler(defHandler);
parser.setEntityResolver(defHandler);
parser.setDTDHandler(defHandler);
parser.setErrorHandler(defHandler);
</pre>
<p>The following code shows the <code dir="ltr">XMLDefaultHandler</code> implementation. The <code dir="ltr">startElement()</code> and <code dir="ltr">endElement()</code> methods print the qualified name, local name, and namespace URI for each element (refer to <a href="#CCHBDBGE">Table 4-7</a> for an explanation of these terms):</p>
<pre dir="ltr">
class XMLDefaultHandler extends DefaultHandler
{
   public void XMLDefaultHandler(){}
   public void startElement(String uri, String localName,
                            String qName, Attributes atts)
   throws SAXException
   {
      System.out.println("ELEMENT Qualified Name:" + qName);
      System.out.println("ELEMENT Local Name    :" + localName);
      System.out.println("ELEMENT Namespace     :" + uri);
 
      for (int i=0; i&lt;atts.getLength(); i++)
      {
         qName = atts.getQName(i);
         localName = atts.getLocalName(i);
         uri = atts.getURI(i);
 
         System.out.println(" ATTRIBUTE Qualified Name   :" + qName);
         System.out.println(" ATTRIBUTE Local Name       :" + localName);
         System.out.println(" ATTRIBUTE Namespace        :" + uri);
 
         // You can get the type and value of the attributes either
         // by index or by the Qualified Name.
 
         String type = atts.getType(qName);
         String value = atts.getValue(qName);
 
         System.out.println(" ATTRIBUTE Type             :" + type);
         System.out.println(" ATTRIBUTE Value            :" + value);
 
         System.out.println();
 
      }
   }
   public void endElement(String uri, String localName,
                          String qName) throws SAXException
   {
      System.out.println("ELEMENT Qualified Name:" + qName);
      System.out.println("ELEMENT Local Name    :" + localName);
      System.out.println("ELEMENT Namespace     :" + uri);
   }
}
</pre></li>
<li>
<p>Parse the input XML document. The following code fragment converts the document to a URL and then parses it:</p>
<pre dir="ltr">
parser.parse(DemoUtil.createURL(argv[0]).toString());
</pre></li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CCHJIIJF"></a>
<div id="ADXDK19149" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing SAX Parsing with XMLTokenizer</h3>
<p>You can create a simple SAX parser as a instance of the <code dir="ltr">XMLTokenizer</code> class and use the parser to tokenize the input XML. <a href="#CCHJDBGJ">Table 4-13</a> lists useful methods in the class.</p>
<div id="ADXDK19150" class="tblhruleformal">
<p class="titleintable"><a id="sthref114"></a><a id="CCHJDBGJ"></a>Table 4-13 XMLTokenizer Methods</p>
<table class="cellalignment1211" title="XMLTokenizer Methods" summary="This table describes XMLTokenizer methods." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t31">Method</th>
<th class="cellalignment1212" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t31" headers="r1c1-t31">
<p><code dir="ltr">setToken()</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t31 r1c2-t31">
<p>Register a new token for XML tokenizer.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t31" headers="r1c1-t31">
<p><code dir="ltr">setErrorStream()</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t31 r1c2-t31">
<p>Register a output stream for errors</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t31" headers="r1c1-t31">
<p><code dir="ltr">tokenize()</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t31 r1c2-t31">
<p>Tokenizes the input XML</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>SAX parsers with <code dir="ltr">Tokenizer</code> features must implement the <code dir="ltr">XMLToken</code> interface. The callback method for <code dir="ltr">XMLToken</code> is <code dir="ltr">token()</code>, which receives an XML token and its corresponding value and performs an action. For example, you can implement <code dir="ltr">token()</code> so that it prints the token name followed by the value of the token.</p>
<p>The <code dir="ltr">Tokenizer.java</code> program accepts an XML document as input, parses it, and prints a list of the XML tokens. The program implements a <code dir="ltr">doParse()</code> method that does the following:</p>
<ol>
<li>
<p>Create a URL from the input XML stream:</p>
<pre dir="ltr">
URL url = DemoUtil.createURL(arg);
</pre></li>
<li>
<p>Create an <code dir="ltr">XMLTokenizer</code> parser as follows:</p>
<pre dir="ltr">
parser  = new XMLTokenizer ((XMLToken)new Tokenizer());
</pre></li>
<li>
<p>Register an output error stream as follows:</p>
<pre dir="ltr">
parser.setErrorStream  (System.out);
</pre></li>
<li>
<p>Register tokens with the parser. The following code fragment from <code dir="ltr">Tokenizer.java</code> shows just some of the registered tokens:</p>
<pre dir="ltr">
parser.setToken (STagName, true);
parser.setToken (EmptyElemTag, true);
parser.setToken (STag, true);
parser.setToken (ETag, true);
parser.setToken (ETagName, true);
...
</pre></li>
<li>
<p>Tokenize the XML document as follows:</p>
<pre dir="ltr">
parser.tokenize (url);
</pre>
<p>The <code dir="ltr">token()</code> callback method determines the action to take when an particular token is encountered. The following code fragment from <code dir="ltr">Tokenizer.java</code> shows some of the implementation of this method:</p>
<pre dir="ltr">
public void token (int token, String value)
{
   switch (token)
   {
   case XMLToken.STag:
      System.out.println ("STag: " + value);
      break;
   case XMLToken.ETag:
      System.out.println ("ETag: " + value);
      break;
   case XMLToken.EmptyElemTag:
      System.out.println ("EmptyElemTag: " + value);
      break;
   case XMLToken.AttValue:
      System.out.println ("AttValue: " + value);
      break;
   ...
   default:
      break;
   }
}
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1034434"></a>
<div id="ADXDK19151" class="sect1">
<h2 class="sect1">Parsing XML with <a id="sthref115"></a>JAXP</h2>
<p>JAXP enables you to use the SAX and DOM parsers and the XSLT processor in your Java program. This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHJAEGJ">Using the JAXP API</a></p>
</li>
<li>
<p><a href="#CCHCJHJH">Parsing with JAXP</a></p>
</li>
<li>
<p><a href="#CCHBCHGC">Performing Basic Transformations with JAXP</a></p>
</li>
</ul>
<a id="CCHJAEGJ"></a>
<div id="ADXDK19152" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using the JAXP API</h3>
<p>The JAXP APIs, which are listed in <a href="#CCHDAAFH">Table 4-14</a>, have an API structure consisting of abstract classes that provide a thin layer for parser pluggability. Oracle implemented JAXP based on the Sun Microsystems reference implementation.</p>
<div id="ADXDK19153" class="tblruleformal">
<p class="titleintable"><a id="sthref116"></a><a id="CCHDAAFH"></a>Table 4-14 JAXP Packages</p>
<table class="cellalignment1211" title="JAXP Packages" summary="Describes JAXP packages." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t32">Package</th>
<th class="cellalignment1212" id="r1c2-t32">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t32" headers="r1c1-t32">
<p><code dir="ltr">javax.xml.parsers</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t32 r1c2-t32">
<p>Provides standard APIs for DOM 2.0 and SAX 1.0 parsers. The package contains vendor-neutral factory classes that give you a <code dir="ltr">SAXParser</code> and a <code dir="ltr">DocumentBuilder</code>. <code dir="ltr">DocumentBuilder</code> creates a DOM-compliant <code dir="ltr">Document</code> object.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t32" headers="r1c1-t32">
<p><code dir="ltr">javax.xml.transform</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t32 r1c2-t32">
<p>Defines the generic APIs for processing XML transformation and performing a transformation from a source to a result.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t32" headers="r1c1-t32">
<p><code dir="ltr">javax.xml.transform.dom</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t32 r1c2-t32">
<p>Provides DOM-specific transformation APIs.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t32" headers="r1c1-t32">
<p><code dir="ltr">javax.xml.transform.sax</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t32 r1c2-t32">
<p>Provides SAX2-specific transformation APIs.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t32" headers="r1c1-t32">
<p><code dir="ltr">javax.xml.transform.stream</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t32 r1c2-t32">
<p>Provides stream- and URI- specific transformation APIs.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div id="ADXDK19154" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref117"></a>
<h4 class="sect3">Using the SAX API Through JAXP</h4>
<p>You can rely on the factory design pattern to create new SAX parser engines with JAXP. <a href="#CCHBFEID">Figure 4-6</a> illustrates the basic process.</p>
<div id="ADXDK19155" class="figure">
<p class="titleinfigure"><a id="CCHBFEID"></a>Figure 4-6 SAX Parsing with JAXP</p>
<img width="414" height="198" src="img/adxdk114.gif" alt="Description of Figure 4-6 follows" /><br />
<a id="sthref118" href="img_text/adxdk114.htm">Description of "Figure 4-6 SAX Parsing with JAXP"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The basic steps for parsing with SAX through JAXP are as follows:</p>
<ol>
<li>
<p>Create a new SAX parser factory with the <code dir="ltr">SAXParserFactory</code> class.</p>
</li>
<li>
<p>Configure the factory.</p>
</li>
<li>
<p>Create a new SAX parser (<code dir="ltr">SAXParser</code>) object from the factory.</p>
</li>
<li>
<p>Set the event handlers for the SAX parser.</p>
</li>
<li>
<p>Parse the input XML documents.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADXDK19156" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref119"></a>
<h4 class="sect3">Using the DOM API Through JAXP</h4>
<p>You can rely on the factory design pattern to create new DOM document builder engines with JAXP. <a href="#CCHEJCHF">Figure 4-7</a> illustrates the basic process.</p>
<div id="ADXDK19157" class="figure">
<p class="titleinfigure"><a id="CCHEJCHF"></a>Figure 4-7 DOM Parsing with JAXP</p>
<img width="456" height="207" src="img/adxdk115.gif" alt="Description of Figure 4-7 follows" /><br />
<a id="sthref120" href="img_text/adxdk115.htm">Description of "Figure 4-7 DOM Parsing with JAXP"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The basic steps for parsing with DOM through JAXP are as follows:</p>
<ol>
<li>
<p>Create a new DOM parser factory. with the <code dir="ltr">DocumentBuilderFactory</code> class.</p>
</li>
<li>
<p>Configure the factory.</p>
</li>
<li>
<p>Create a new DOM builder (<code dir="ltr">DocumentBuilder</code>) object from the factory.</p>
</li>
<li>
<p>Set the error handler and entity resolver for the DOM builder.</p>
</li>
<li>
<p>Parse the input XML documents.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADXDK19158" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref121"></a>
<h4 class="sect3">Transforming XML Through JAXP</h4>
<p>The basic steps for transforming XML through JAXP are as follows:</p>
<ol>
<li>
<p>Create a new transformer factory. Use the <code dir="ltr">TransformerFactory</code> class.</p>
</li>
<li>
<p>Configure the factory.</p>
</li>
<li>
<p>Create a new transformer from the factory and specify an XSLT stylesheet.</p>
</li>
<li>
<p>Configure the transformer.</p>
</li>
<li>
<p>Transform the document.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHCJHJH"></a>
<div id="ADXDK19159" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Parsing with JAXP</h3>
<p>The <code dir="ltr">JAXPExamples.java</code> program illustrates the basic steps of parsing with JAXP. The program implements the following methods and uses them to parse and perform additional processing on XML files in the <code dir="ltr">/jaxp</code> directory:</p>
<ul>
<li>
<p><code dir="ltr">basic()</code></p>
</li>
<li>
<p><code dir="ltr">identity()</code></p>
</li>
<li>
<p><code dir="ltr">namespaceURI()</code></p>
</li>
<li>
<p><code dir="ltr">templatesHandler()</code></p>
</li>
<li>
<p><code dir="ltr">contentHandler2contentHandler()</code></p>
</li>
<li>
<p><code dir="ltr">contentHandler2DOM()</code></p>
</li>
<li>
<p><code dir="ltr">reader()</code></p>
</li>
<li>
<p><code dir="ltr">xmlFilter()</code></p>
</li>
<li>
<p><code dir="ltr">xmlFilterChain()</code></p>
</li>
</ul>
<p>The program creates URLs for the <code dir="ltr">jaxpone.xml</code> and <code dir="ltr">jaxpone.xsl</code> sample XML files and then calls the preceding methods in sequence. The basic design of the demo is as follows (to save space only the <code dir="ltr">basic()</code> method is shown):</p>
<pre dir="ltr">
public class JAXPExamples
{
        public static void main(String argv[])
        throws TransformerException, TransformerConfigurationException,
               IOException, SAXException, ParserConfigurationException,                 
               FileNotFoundException
        {
        try {
         URL xmlURL = createURL("jaxpone.xml");
         String xmlID = xmlURL.toString();
         URL xslURL = createURL("jaxpone.xsl");
         String xslID = xslURL.toString();
         //
         System.out.println("--- basic ---");
         basic(xmlID, xslID);
         System.out.println();
         ...
      } catch(Exception err) {
        err.printStackTrace();
      }
   }
   //
   public static void basic(String xmlID, String xslID)
      throws TransformerException, TransformerConfigurationException
   {
      TransformerFactory tfactory = TransformerFactory.newInstance();
      Transformer transformer = tfactory.newTransformer(new StreamSource(xslID));
      StreamSource source = new StreamSource(xmlID);
      transformer.transform(source, new StreamResult(System.out));
   }
...
}
</pre>
<p>The <code dir="ltr">reader()</code> method in <code dir="ltr">JAXPExamples.java</code> program shows a simple technique for parsing an XML document with SAX. It follows these steps:</p>
<ol>
<li>
<p>Create a new instance of a <code dir="ltr">TransformerFactory</code> and then cast it to a <code dir="ltr">SAXTransformerFactory</code>. The application can use the SAX factory to configure and obtain SAX parser instances. For example:</p>
<pre dir="ltr">
TransformerFactory tfactory = TransformerFactory.newInstance();
SAXTransformerFactory stfactory = (SAXTransformerFactory)tfactory;
</pre></li>
<li>
<p>Create an XML reader by creating a <code dir="ltr">StreamSource</code> object from a stylesheet and passing it to the factory method <code dir="ltr">newXMLFilter()</code>. This method returns an <code dir="ltr">XMLFilter</code> object that uses the specified <code dir="ltr">Source</code> as the transformation instructions. For example:</p>
<pre dir="ltr">
URL xslURL = createURL("jaxpone.xsl");
String xslID = xslURL.toString();
...
StreamSource streamSource = new StreamSource(xslID);
XMLReader reader = stfactory.newXMLFilter(streamSource);
</pre></li>
<li>
<p>Create content handler and register it with the XML reader. The following example creates an instance of the class <code dir="ltr">oraContentHandler</code>, which is created by compiling the <code dir="ltr">oraContentHandler.java</code> program in the demo directory:</p>
<pre dir="ltr">
ContentHandler contentHandler = new oraContentHandler();
reader.setContentHandler(contentHandler);
</pre>
<p>The following code fragment shows some of the implementation of the <code dir="ltr">oraContentHandler</code> class:</p>
<pre dir="ltr">
public class oraContentHandler implements ContentHandler
{
   private static final String TRADE_MARK = "Oracle 9i ";
 
   public void setDocumentLocator(Locator locator)
   {
      System.out.println(TRADE_MARK + "- setDocumentLocator");
   }
 
   public void startDocument()
      throws SAXException
   {
      System.out.println(TRADE_MARK + "- startDocument");
   }
 
   public void endDocument()
      throws SAXException
   {
      System.out.println(TRADE_MARK + "- endDocument");
   }
   ...
</pre></li>
<li>
<p>Parse the input XML document by passing the <code dir="ltr">InputSource</code> to the <code dir="ltr">XMLReader.parse()</code> method. For example:</p>
<pre dir="ltr">
InputSource is = new InputSource(xmlID);
reader.parse(is);
</pre></li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CCHBCHGC"></a>
<div id="ADXDK19160" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Performing Basic Transformations with JAXP</h3>
<p>You can use JAXP to transform any class of the interface <code dir="ltr">Source</code> into a class of the interface <code dir="ltr">Result</code>. <a href="#CCHDAGBJ">Table 4-15</a> shows some sample transformations.</p>
<div id="ADXDK19161" class="tblformal">
<p class="titleintable"><a id="sthref122"></a><a id="CCHDAGBJ"></a>Table 4-15 Transforming Classes with JAXP</p>
<table class="cellalignment1214" title="Transforming Classes with JAXP" summary="Explains that you can transform DOMSource into DOMResult, StreamSource into StreamResult, and SAXSource into SAXResult." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t33">Use JAXP to transform this class . . .</th>
<th class="cellalignment1212" id="r1c2-t33">Into this class . . .</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t33" headers="r1c1-t33">
<p><code dir="ltr">DOMSource</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t33 r1c2-t33">
<p><code dir="ltr">DOMResult</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t33" headers="r1c1-t33">
<p><code dir="ltr">StreamSource</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t33 r1c2-t33">
<p><code dir="ltr">StreamResult</code></p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t33" headers="r1c1-t33">
<p><code dir="ltr">SAXSource</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t33 r1c2-t33">
<p><code dir="ltr">SAXResult</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>These transformations accept the following types of input:</p>
<ul>
<li>
<p>XML documents</p>
</li>
<li>
<p>stylesheets</p>
</li>
<li>
<p>The <code dir="ltr">ContentHandler</code> class defined in <code dir="ltr">oraContentHandler.java</code></p>
</li>
</ul>
<p>For example, you can use the <code dir="ltr">identity()</code> method to perform a transformation in which the output XML document is the same as the input XML document. You can use the <code dir="ltr">xmlFilterChain()</code> method to apply three stylesheets in a chain.</p>
<p>The <code dir="ltr">basic()</code> method shows how to perform a basic XSLT transformation. The method follows these steps:</p>
<ol>
<li>
<p>Create a new instance of a <code dir="ltr">TransformerFactory</code>. For example:</p>
<pre dir="ltr">
TransformerFactory tfactory = TransformerFactory.newInstance();
</pre></li>
<li>
<p>Create a new XSL transformer from the factory and specify the stylesheet to use for the transformation. The following example specifies the <code dir="ltr">jaxpone.xsl</code> stylesheet:</p>
<pre dir="ltr">
URL xslURL = createURL("jaxpone.xsl");
String xslID = xslURL.toString();
. . .
Transformer transformer = tfactory.newTransformer(new StreamSource(xslID));
</pre></li>
<li>
<p>Set the stream source to the input XML document. The following fragment from the <code dir="ltr">basic()</code> method sets the stream source to <code dir="ltr">jaxpone.xml</code>:</p>
<pre dir="ltr">
URL xmlURL = createURL("jaxpone.xml");
String xmlID = xmlURL.toString();
. . .
StreamSource source = new StreamSource(xmlID);
</pre></li>
<li>
<p>Transform the document from a <code dir="ltr">StreamSource</code> to a <code dir="ltr">StreamResult</code>. The following example transforms a <code dir="ltr">StreamSource</code> into a <code dir="ltr">StreamResult</code>:</p>
<pre dir="ltr">
transformer.transform(source, new StreamResult(System.out));
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CCHJDAFB"></a>
<div id="ADXDK19162" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Compressing XML</h2>
<p>The Oracle XDK enables you to use SAX or DOM to parse XML and then write the parsed data to a compressed binary stream. You can then reverse the process and reconstruct the XML data. This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHBIIDF">Compressing and Decompressing XML from DOM</a></p>
</li>
<li>
<p><a href="#CCHBJIHF">Compressing and Decompressing XML from SAX</a></p>
</li>
</ul>
<a id="CCHBIIDF"></a>
<div id="ADXDK19163" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Compressing and Decompressing XML from DOM</h3>
<p>The <code dir="ltr">DOMCompression.java</code> and <code dir="ltr">DOMDeCompression.java</code> programs illustrate the basic steps of DOM compression and decompression. The most important DOM compression methods are the following:</p>
<ul>
<li>
<p><code dir="ltr">XMLDocument.writeExternal()</code> saves the state of the object by creating a binary compressed stream with information about the object.</p>
</li>
<li>
<p><code dir="ltr">XMLDocument.readExternal()</code> reads the information written in the compressed stream by the <code dir="ltr">writeExternal()</code> method and restores the object.</p>
</li>
</ul>
<div id="ADXDK19164" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref123"></a>
<h4 class="sect3">Compressing a DOM Object</h4>
<p>The basic technique for serialization is create an <code dir="ltr">XMLDocument</code> by parsing an XML document, initialize an <code dir="ltr">ObjectOutputStream</code>, and then call <code dir="ltr">XMLDocument.writeExternal()</code> to write the compressed stream.</p>
<p>The <code dir="ltr">DOMCompression.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a DOM parser, parse an input XML document, and obtain the DOM representation. This technique is described in <a href="#CCHBEGDD">"Performing Basic DOM Parsing"</a>. The following code fragment from <code dir="ltr">DOMCompression.java</code> illustrates this technique:</p>
<pre dir="ltr">
public class DOMCompression
{
   static OutputStream out = System.out;
   public static void main(String[] args)
   {
      XMLDocument doc = new XMLDocument();
      DOMParser parser = new DOMParser();
      try
      {
        parser.setValidationMode(XMLParser.SCHEMA_VALIDATION);
        parser.setPreserveWhitespace(false);
        parser.retainCDATASection(true);
        parser.parse(createURL(args[0]));
        doc = parser.getDocument();
        ...
</pre></li>
<li>
<p>Create a <code dir="ltr">FileOutputStream</code> and wrap it in an <code dir="ltr">ObjectOutputStream</code> for serialization. The following code fragment creates the <code dir="ltr">xml.ser</code> output file:</p>
<pre dir="ltr">
OutputStream os = new FileOutputStream("xml.ser");
ObjectOutputStream oos = new ObjectOutputStream(os);
</pre></li>
<li>
<p>Serialize the object to the file by calling <code dir="ltr">XMLDocument.writeExternal()</code>. This method saves the state of the object by creating a binary compressed stream with information about this object. The following statement illustrates this technique:</p>
<pre dir="ltr">
doc.writeExternal(oos);
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADXDK19165" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref124"></a>
<h4 class="sect3">Decompressing a DOM Object</h4>
<p>The basic technique for decompression is to create an <code dir="ltr">ObjectInputStream</code> object and then call <code dir="ltr">XMLDocument.readExternal()</code> to read the compressed stream.The <code dir="ltr">DOMDeCompression.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a file input stream for the compressed file and wrap it in an <code dir="ltr">ObjectInputStream</code>. The following code fragment from <code dir="ltr">DOMDeCompression.java</code> creates a <code dir="ltr">FileInputStream</code> from the compressed file created in the previous section:</p>
<pre dir="ltr">
InputStream is;
ObjectInputStream ois;
...
is = new FileInputStream("xml.ser");
ois = new ObjectInputStream(is);
</pre></li>
<li>
<p>Create a new XML document object to contain the decompressed data. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
XMLDocument serializedDoc = null;
serializedDoc = new XMLDocument();
</pre></li>
<li>
<p>Read the compressed file by calling <code dir="ltr">XMLDocument.readExternal()</code>. The following code fragment read the data and prints it to <code dir="ltr">System.out</code>:</p>
<pre dir="ltr">
serializedDoc.readExternal(ois);
serializedDoc.print(System.out);
</pre></li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CCHBJIHF"></a>
<div id="ADXDK19166" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Compressing and Decompressing XML from SAX</h3>
<p>The <code dir="ltr">SAXCompression.java</code> program illustrates the basic steps of parsing a file with SAX, writing the compressed stream to a file, and then reading the serialized data from the file. The important classes are as follows:</p>
<ul>
<li>
<p><code dir="ltr">CXMLHandlerBase</code> is a SAX <code dir="ltr">Handler</code> that compresses XML data based on SAX events. To use the SAX compression, implement this interface and register with the SAX parser by calling <code dir="ltr">Parser.setDocumentHandler()</code>.</p>
</li>
<li>
<p><code dir="ltr">CXMLParser</code> is an XML parser that regenerates SAX events from a compressed stream.</p>
</li>
</ul>
<div id="ADXDK19167" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref125"></a>
<h4 class="sect3">Compressing a SAX Object</h4>
<p>The basic technique for serialization is to register a <code dir="ltr">CXMLHandlerBase</code> handler with a SAX parser, initialize an <code dir="ltr">ObjectOutputStream</code>, and then parse the input XML. The <code dir="ltr">SAXCompression.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a <code dir="ltr">FileOutputStream</code> and wrap it in an <code dir="ltr">ObjectOutputStream</code>. The following code fragment from <code dir="ltr">SAXCompression.java</code> creates the <code dir="ltr">xml.ser</code> file:</p>
<pre dir="ltr">
String compFile = "xml.ser";
FileOutputStream outStream = new FileOutputStream(compFile);
ObjectOutputStream out = new ObjectOutputStream(outStream);
</pre></li>
<li>
<p>Create the SAX event handler. The <code dir="ltr">CXMLHandlerBase</code> class implements the <code dir="ltr">ContentHandler</code>, <code dir="ltr">DTDHandler</code>, <code dir="ltr">EntityResolver</code>, and <code dir="ltr">ErrorHandler</code> interfaces. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
CXMLHandlerBase cxml = new CXMLHandlerBase(out);
</pre></li>
<li>
<p>Create the SAX parser. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
SAXParser parser = new SAXParser();
</pre></li>
<li>
<p>Configure the SAX parser. The following code fragment sets the content handler and entity resolver, and also sets the validation mode:</p>
<pre dir="ltr">
parser.setContentHandler(cxml);
parser.setEntityResolver(cxml);
parser.setValidationMode(XMLConstants.NONVALIDATING);
</pre>
<p>Note that <code dir="ltr">oracle.xml.comp.CXMLHandlerBase</code> implements both <code dir="ltr">DocumentHandler</code> and <code dir="ltr">ContentHandler</code> interfaces, but use of the SAX 2.0 <code dir="ltr">ContentHandler</code> interface is preferred.</p>
</li>
<li>
<p>Parse the XML. The program writes the serialized data to the <code dir="ltr">ObjectOutputStream</code>. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
parser.parse(url);
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADXDK19168" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref126"></a>
<h4 class="sect3">Decompressing a SAX Object</h4>
<p>The basic technique for deserialization of a SAX object is to create a SAX compression parser with the <code dir="ltr">CXMLParser</code> class, set the content handler for the parser, and then parse the compressed stream.</p>
<p>The <code dir="ltr">SAXDeCompression.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a SAX event handler. The <code dir="ltr">SampleSAXHandler.java</code> program creates a handler for use by <code dir="ltr">SAXDeCompression.java</code>. The following code fragment from <code dir="ltr">SAXDeCompression.java</code> creates handler object:</p>
<pre dir="ltr">
SampleSAXHandler xmlHandler = new SampleSAXHandler();
</pre></li>
<li>
<p>Create the SAX parser by instantiating the <code dir="ltr">CXMLParser</code> class. This class implements the regeneration of XML documents from a compressed stream by generating SAX events from them. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
CXMLParser parser = new CXMLParser();
</pre></li>
<li>
<p>Set the event handler for the SAX parser. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
parser.setContentHandler(xmlHandler);
</pre></li>
<li>
<p>Parse the compressed stream and generates the SAX events. The following code receives a filename from the command line and parses the XML:</p>
<pre dir="ltr">
parser.parse(args[0]);
</pre></li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CCHCGIDI"></a>
<div id="ADXDK19169" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Tips and Techniques for Parsing XML</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHIAHGG">Extracting Node Values from a DOM Tree</a></p>
</li>
<li>
<p><a href="#CCHEAAGB">Merging Documents with appendChild()</a></p>
</li>
<li>
<p><a href="#i1037028">Parsing DTDs</a></p>
</li>
<li>
<p><a href="#i1040534">Handling Character Sets with the XML Parser</a></p>
</li>
</ul>
<a id="CCHIAHGG"></a>
<div id="ADXDK19170" class="sect2">
<h3 class="sect2">Extracting Node Values from a DOM Tree<a id="sthref127"></a></h3>
<p>You can use the <code dir="ltr">selectNodes()</code> method in the <code dir="ltr">XMLNode</code> class to extract content from a DOM tree or subtree based on the select patterns allowed by XSL. You can use the optional second parameter of <code dir="ltr">selectNodes()</code> to resolve namespace prefixes, that is, to return the expanded namespace URL when given a prefix. The <code dir="ltr">XMLElement</code> class implements <code dir="ltr">NSResolver</code>, so a reference to an <code dir="ltr">XMLElement</code> object can be sent as the second parameter. <code dir="ltr">XMLElement</code> resolves the prefixes based on the input document. You can use the <code dir="ltr">NSResolver</code> interface if you need to override the namespace definitions.</p>
<p>The sample code in <a href="#CCHHEIGA">Example 4-4</a> illustrates how to use <code dir="ltr">selectNodes()</code>.</p>
<div id="ADXDK19171" class="example">
<p class="titleinexample"><a id="CCHHEIGA"></a>Example 4-4 Extracting Contents of a DOM Tree with selectNodes()</p>
<pre dir="ltr">
//
// selectNodesTest.java
//
import java.io.*;
import oracle.xml.parser.v2.*;
import org.w3c.dom.Node;
import org.w3c.dom.Element;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
 
public class selectNodesTest
{
  public static void main(String[] args)
    throws Exception
  {
    // supply an xpath expression
    String pattern = "/family/member/text()";
    // accept a filename on the command line
    // run the program with $ORACLE_HOME/xdk/demo/java/parser/common/family.xml
    String file    = args[0];
 
    if (args.length == 2)
      pattern = args[1];
 
    DOMParser dp = new DOMParser();
 
    dp.parse(DemoUtil.createURL(file));  // include createURL from DemoUtil
    XMLDocument xd = dp.getDocument();
    XMLElement element = (XMLElement) xd.getDocumentElement();
    NodeList nl = element.selectNodes(pattern, element);
    for (int i = 0; i &lt; nl.getLength(); i++)
    {
      System.out.println(nl.item(i).getNodeValue());
    } // end for
  } // end main
} // end selectNodesTest
</pre></div>
<!-- class="example" -->
<p>To test the program, create a file with the code in <a href="#CCHHEIGA">Example 4-4</a> and then compile it in the <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser/</code><code dir="ltr">common</code> directory. Pass the filename <code dir="ltr">family.xml</code> to the program as a parameter to traverse the <code dir="ltr">&lt;family&gt;</code> tree. The output should be as follows:</p>
<pre dir="ltr">
% java selectNodesTest family.xml
Sarah
Bob
Joanne
Jim
</pre>
<p>Now run the following to determine the values of the <code dir="ltr">memberid</code> attributes of all <code dir="ltr">&lt;member&gt;</code> elements in the document:</p>
<pre dir="ltr">
% java selectNodesTest family.xml //member/@memberid
m1
m2
m3
m4
</pre></div>
<!-- class="sect2" -->
<a id="CCHEAAGB"></a>
<div id="ADXDK19172" class="sect2">
<h3 class="sect2">Merging Documents with appendChild()<a id="sthref128"></a></h3>
<p>Suppose that you want to write a program so that a user can fill in a client-side Java form and obtain an XML document. Suppose that your Java program contains the following variables of type <code dir="ltr">String</code>:</p>
<pre dir="ltr">
String firstname = "Gianfranco";
String lastname = "Pietraforte";
</pre>
<p>You can use either of the following techniques to insert this information into an XML document:</p>
<ul>
<li>
<p>Create an XML document in a string and then parse it. For example:</p>
<pre dir="ltr">
String xml = "&lt;person&gt;&lt;first&gt;"+firstname+"&lt;/first&gt;"+
     "&lt;last&gt;"+lastname+"&lt;/last&gt;&lt;/person&gt;";
DOMParser d = new DOMParser();
d.parse(new StringReader(xml));
Document xmldoc = d.getDocument();
</pre></li>
<li>
<p>Use DOM APIs to construct an XML document, creating elements and then appending them to one another. For example:</p>
<pre dir="ltr">
Document xmldoc = new XMLDocument();
Element e1 = xmldoc.createElement("person");
xmldoc.appendChild(e1);
Element e2 = xmldoc.createElement("firstname");
e1.appendChild(e2);
Text t = xmldoc.createText("Larry");
e2.appendChild(t);
</pre></li>
</ul>
<p>Note that you can only use the second technique on a <span class="italic">single</span> DOM tree. For example, suppose that you write the code snippet in <a href="#CCHHCEFA">Example 4-5</a>.</p>
<div id="ADXDK19173" class="example">
<p class="titleinexample"><a id="CCHHCEFA"></a>Example 4-5 Incorrect Use of appendChild()</p>
<pre dir="ltr">
XMLDocument xmldoc1 = new XMLDocument();
XMLElement e1 = xmldoc1.createElement("person");
XMLDocument xmldoc2 = new XMLDocument();
XMLElement e2 = xmldoc2.createElement("firstname");
e1.appendChild(e2);  
</pre></div>
<!-- class="example" -->
<p>The preceding code raises a DOM exception of <code dir="ltr">WRONG_DOCUMENT_ERR</code> when calling <code dir="ltr">XMLElement.appendChild()</code> because the owner document of <code dir="ltr">e1</code> is <code dir="ltr">xmldoc1</code> whereas the owner of <code dir="ltr">e2</code> is <code dir="ltr">xmldoc2</code>. The <code dir="ltr">appendChild()</code> method only works within a single tree, but the code in <a href="#CCHHCEFA">Example 4-5</a> uses two different trees.</p>
<p>You can use the <code dir="ltr">XMLDocument.importNode()</code> method, introduced in DOM 2, and the <code dir="ltr">XMLDocument.adoptNode()</code> method, introduced in DOM 3, to copy and paste a DOM document fragment or a DOM node across different XML documents. The commented lines in <a href="#CCHGICFG">Example 4-6</a> show how to perform this task.</p>
<div id="ADXDK19174" class="example">
<p class="titleinexample"><a id="CCHGICFG"></a>Example 4-6 Merging Documents with appendChild</p>
<pre dir="ltr">
XMLDocument doc1 = new XMLDocument();
XMLElement element1 = doc1.createElement("person");
XMLDocument doc2 = new XMLDocument();
XMLElement element2 = doc2.createElement("firstname");
// element2 = doc1.importNode(element2);
// element2 = doc1.adoptNode(element2);
element1.appendChild(element2);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1037028"></a>
<div id="ADXDK19175" class="sect2">
<h3 class="sect2">Parsing <a id="sthref129"></a>DTDs</h3>
<p>This section discusses techniques for parsing DTDs. It contains the sections:</p>
<ul>
<li>
<p><a href="#i1040377">Loading External DTDs</a></p>
</li>
<li>
<p><a href="#i1040367">Caching DTDs with setDoctype</a></p>
</li>
</ul>
<a id="i1040377"></a>
<div id="ADXDK19176" class="sect3">
<h4 class="sect3">Loading <a id="sthref130"></a><a id="sthref131"></a>External DTDs</h4>
<p>If you call the <code dir="ltr">DOMParser.parse()</code> method to parse the XML Document as an <code dir="ltr">InputStream</code>, then use the <code dir="ltr">DOMParser.setBaseURL()</code> method to recognize external DTDs within your Java program. This method points to a location where the DTDs are exposed.</p>
<p>The following procedure describes how to load and parse a DTD:</p>
<ol>
<li>
<p>Load the DTD as an <code dir="ltr">InputStream</code>. For example, assume that you want to validate documents against the <code dir="ltr">/mydir/my.dtd</code> external DTD. You can use the following code:</p>
<pre dir="ltr">
InputStream is = MyClass.class.getResourceAsStream("/mydir/my.dtd");
</pre>
<p>This code opens <code dir="ltr">./mydir/my.dtd</code> in the first relative location in the <code dir="ltr">CLASSPATH</code> where it can be found, including the JAR file if it is in the <code dir="ltr">CLASSPATH</code>.</p>
</li>
<li>
<p>Create a DOM parser and set the validation mode. For example, use this code:</p>
<pre dir="ltr">
DOMParser d = new DOMParser();
d.setValidationMode(DTD_VALIDATION);
</pre></li>
<li>
<p>Parse the DTD. The following example passes the <code dir="ltr">InputStream</code> object to the <code dir="ltr">DOMParser.parseDTD()</code> method:</p>
<pre dir="ltr">
d.parseDTD(is, "rootelementname");
</pre></li>
<li>
<p>Get the document type and then set it. The <code dir="ltr">getDoctype()</code> method obtains the DTD object and the <code dir="ltr">setDoctype()</code> method sets the DTD to use for parsing. The following example illustrates this technique:</p>
<pre dir="ltr">
d.setDoctype(d.getDoctype());
</pre>
<p>The following code demonstrates an alternative technique. You can invoke the <code dir="ltr"><a id="sthref132"></a>parseDTD()</code> method to parse a DTD file separately and get a DTD object:</p>
<pre dir="ltr">
d.parseDTD(new FileReader("/mydir/my.dtd"));
DTD dtd = d.getDoctype();
parser.setDoctype(dtd);
</pre></li>
<li>
<p>Parse the input XML document. For example, the following code parses <code dir="ltr">mydoc.xml</code>:</p>
<pre dir="ltr">
d.parse("mydoc.xml");
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<a id="i1040367"></a>
<div id="ADXDK19177" class="sect3">
<h4 class="sect3">Caching DTDs with setDoctype</h4>
<p>The XML parser for Java provides for DTD caching in validation and nonvalidation modes through the <code dir="ltr">DOMParser.setDoctype()</code> method. After you set the DTD with this method, the parser caches this DTD for further parsing. Note that DTD caching is optional and is not enabled automatically.</p>
<p>Assume that your program must parse several XML documents with the same DTD. After you parse the first XML document, you can obtain the DTD from the parser and set it as in the following example:</p>
<pre dir="ltr">
DOMParser parser = new DOMParser();
DTD dtd = parser.getDoctype();
parser.setDoctype(dtd);
</pre>
<p>The parser caches this DTD and uses it for parsing subsequent XML documents. <a href="#CCHDIBGH">Example 4-7</a> provides a more complete illustration of how you can invoke <code dir="ltr">DOMParser.setDoctype()</code> to cache the DTD.</p>
<div id="ADXDK19178" class="example">
<p class="titleinexample"><a id="CCHDIBGH"></a>Example 4-7 DTDSample.java</p>
<pre dir="ltr">
/**
 * DESCRIPTION
 * This program illustrates DTD caching.
 */

import java.net.URL;
import java.io.*;
import org.xml.sax.InputSource;
import oracle.xml.parser.v2.*;
 
public class DTDSample
{
   static public void main(String[] args)
   {
      try
      {
         if (args.length != 3)
         {
            System.err.println("Usage: java DTDSample dtd rootelement xmldoc");
            System.exit(1);
         }
 
         // Create a DOM parser
         DOMParser parser = new DOMParser();
 
         // Configure the parser
         parser.setErrorStream(System.out);
         parser.showWarnings(true);
 
        // Create a FileReader for the DTD file specified on the command
        // line and wrap it in an InputSource
        FileReader r = new FileReader(args[0]);
        InputSource inSource = new InputSource(r);
 
        // Create a URL from the command-line argument and use it to set the 
        // system identifier
        inSource.setSystemId(DemoUtil.createURL(args[0]).toString());
 
        // Parse the external DTD from the input source. The second argument is 
        // the name of the root element.
        parser.parseDTD(inSource, args[1]);
        DTD dtd = parser.getDoctype();
 
        // Create a FileReader object from the XML document specified on the
        // command line
        r = new FileReader(args[2]);
 
        // Wrap the FileReader in an InputSource, create a URL from the filename,
        // and set the system identifier
        inSource = new InputSource(r);
        inSource.setSystemId(DemoUtil.createURL(args[2]).toString());

        // ********************
        parser.setDoctype(dtd);
        // ********************

        parser.setValidationMode(DOMParser.DTD_VALIDATION);
       // parser.setAttribute(DOMParser.USE_DTD_ONLY_FOR_VALIDATION,Boolean.TRUE);
        parser.parse(inSource);
 
        // Obtain the DOM tree and print
        XMLDocument doc = parser.getDocument();
        doc.print(new PrintWriter(System.out));
 
      }
      catch (Exception e)
      {
         System.out.println(e.toString());
      }
   }
}
</pre></div>
<!-- class="example" -->
<p>If the cached DTD Object is used only for validation, then set the <code dir="ltr">DOMParser.USE_DTD_ONLY_FOR_VALIDATION</code> attribute. Otherwise, the XML parser will copy the DTD object and add it to the resulting DOM tree. You can set the parser as follows:</p>
<pre dir="ltr">
parser.setAttribute(DOMParser.USE_DTD_ONLY_FOR_VALIDATION,Boolean.TRUE);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1040534"></a>
<div id="ADXDK19179" class="sect2">
<h3 class="sect2">Handling Character Sets with the XML Parser</h3>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CCHJHCHG">Detecting the Encoding of an XML File on the Operating System</a></p>
</li>
<li>
<p><a href="#CCHGIACD">Detecting the Encoding of XML Stored in an NCLOB Column</a></p>
</li>
<li>
<p><a href="#CCHCDECA">Writing an XML File in a Nondefault Encoding</a></p>
</li>
<li>
<p><a href="#CCHFBDBD">Working with XML in Strings</a></p>
</li>
<li>
<p><a href="#CCHEEEGE">Parsing XML Documents with Accented Characters</a></p>
</li>
<li>
<p><a href="#CCHIBCGC">Handling Special Characters in Tag Names</a></p>
</li>
</ul>
<a id="CCHJHCHG"></a>
<div id="ADXDK19180" class="sect3">
<h4 class="sect3"><a id="sthref133"></a><a id="sthref134"></a>Detecting the Encoding of an XML File on the Operating System</h4>
<p>When reading an XML file stored on the operating system, do not use the <code dir="ltr">FileReader</code> class. Instead, use the XML parser to detect the character encoding of the document automatically. Given a binary <code dir="ltr">FileInputStream</code> with no external encoding information, the parser automatically determines the character encoding based on the byte-order mark and encoding declaration of the XML document. You can parse any well-formed document in any supported encoding with the sample code in the <code dir="ltr">AutoDetectEncoding.java</code> demo. This demo is located in $ORACLE_HOME/xdk/demo/java/parser/dom.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Include the proper encoding declaration in your document according to the specification. <code dir="ltr">setEncoding()</code> cannot set the encoding for your input document. Rather, it is used with <code dir="ltr">oracle.xml.parser.v2.XMLDocument</code> to set the correct encoding for printing.</div>
</div>
<!-- class="sect3" -->
<a id="CCHGIACD"></a>
<div id="ADXDK19181" class="sect3">
<h4 class="sect3">Detecting the Encoding of XML Stored in an NCLOB Column</h4>
<p>Suppose that you load XML into the an <code dir="ltr">NCLOB</code> column of a database using UTF-8 encoding. The XML contains two UTF-8 multibyte characters:</p>
<p><code dir="ltr">G(0xc2,0x82)otingen, Br(0xc3,0xbc)ck_W</code></p>
<p>You write a Java stored function that does the following:</p>
<ol>
<li>
<p>Uses the default connection object to connect to the database.</p>
</li>
<li>
<p>Runs a <code dir="ltr">SELECT</code> query.</p>
</li>
<li>
<p>Obtains the <code dir="ltr">oracle.jdbc.OracleResultSet</code> object.</p>
</li>
<li>
<p>Calls the <code dir="ltr">OracleResultSet.getCLOB()</code> method.</p>
</li>
<li>
<p>Calls the <code dir="ltr">getAsciiStream()</code> method on the <code dir="ltr">CLOB</code> object.</p>
</li>
<li>
<p>Executes the following code to get the XML into a DOM object:</p>
<pre dir="ltr">
DOMParser parser = new DOMParser();
parser.setPreserveWhitespace(true);
parser.parse(istr);
// istr getAsciiStream XMLDocument xmldoc = parser.getDocument();
</pre></li>
</ol>
<p>The program throws an exception stating that the XML contains an invalid UTF-8 encoding even though the character (<code dir="ltr">0xc2</code>, <code dir="ltr">0x82</code>) is valid UTF-8. The problem is that the character can be distorted when the program calls the <code dir="ltr">OracleResultSet.getAsciiStream()</code> method. To solve this problem, invoke the <code dir="ltr">getUnicodeStream()</code> and <code dir="ltr">getBinaryStream()</code> methods instead of <code dir="ltr">getAsciiStream()</code>. If this technique does not work, then try to print the characters to make sure that they are not distorted before they are sent to the parser in when you call <code dir="ltr">DOMParser.parse(istr)</code>.</p>
</div>
<!-- class="sect3" -->
<a id="CCHCDECA"></a>
<div id="ADXDK19182" class="sect3">
<h4 class="sect3">Writing an XML File in <a id="sthref135"></a><a id="sthref136"></a>a Nondefault Encoding</h4>
<p>You should not use the <code dir="ltr">FileWriter</code> class when writing XML files because it depends on the default character encoding of the runtime environment. The output file can suffer from a parsing error or data loss if the document contains characters that are not available in the default character encoding.</p>
<p>UTF-8 encoding is popular for XML documents, but UTF-8 is not usually the default file encoding of Java. Using a Java class in your program that assumes the default file encoding can cause problems. To avoid these problems, you can use the technique illustrated in the <code dir="ltr">I18nSafeXMLFileWritingSample.java</code> program in <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser/dom</code>.</p>
<p>Note that you cannot use <code dir="ltr">System.out.println()</code> to output special characters. You need to use a binary output stream such as <code dir="ltr">OutputStreamWriter</code> that is encoding aware. You can construct an <code dir="ltr">OutputStreamWriter</code> and use the <code dir="ltr">write(char[]</code>, <code dir="ltr">int</code>, <code dir="ltr">int)</code> method to print, as in the following example:</p>
<pre dir="ltr">
/* Java encoding string for ISO8859-1*/
OutputStreamWriter out = new OutputStreamWriter(System.out, "8859_1");
OutputStreamWriter.write(...);
</pre></div>
<!-- class="sect3" -->
<a id="CCHFBDBD"></a>
<div id="ADXDK19183" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Working with XML in Strings</h4>
<p>Currently, there is no method that can directly parse an XML document contained in a <code dir="ltr">String</code>. You need to convert the string into an <code dir="ltr">InputStream</code> or <code dir="ltr">InputSource</code> object before parsing.</p>
<p>One technique is to create a <code dir="ltr">ByteArrayInputStream</code> that uses the bytes in the string. For example, assume that <code dir="ltr">xmlDoc</code> is a reference to a string of XML. You can use technique shown in <a href="#CCHFBJDJ">Example 4-8</a> to convert the string to a byte array, convert the array to a <code dir="ltr">ByteArrwayInputStream</code>, and then parse.</p>
<div id="ADXDK19184" class="example">
<p class="titleinexample"><a id="CCHFBJDJ"></a>Example 4-8 Converting XML in a String</p>
<pre dir="ltr">
// create parser
DOMParser parser=new DOMParser();
// create XML document in a string
String xmlDoc =
       "&lt;?xml version='1.0'?&gt;"+
       "&lt;hello&gt;"+
       "  &lt;world/&gt;"+
       "&lt;/hello&gt;";
// convert string to bytes to stream
byte aByteArr [] = xmlDoc.getBytes();
ByteArrayInputStream bais = new ByteArrayInputStream(aByteArr,0,aByteArr.length);
//  parse and obtain DOM tree
DOMParser.parse(bais);
XMLDocument doc = parser.getDocument();
</pre></div>
<!-- class="example" -->
<p>Suppose that you want to convert the <code dir="ltr">XMLDocument</code> object created in the previous code back to a string. You can perform this task by wrapping a <code dir="ltr">StringWriter</code> in a <code dir="ltr">PrintWriter</code>. The following example illustrates this technique:</p>
<pre dir="ltr">
StringWriter sw = new StringWriter();
PrintWriter  pw = new PrintWriter(sw);
doc.print(pw);
String YourDocInString = sw.toString();
</pre>
<p><code dir="ltr">ParseXMLFromString.java</code>, which is located in <code dir="ltr">$ORACLE_HOME/xdk/demo/java/parser/dom</code>, is a complete program that creates an XML document as a string and parses it.</p>
</div>
<!-- class="sect3" -->
<a id="CCHEEEGE"></a>
<div id="ADXDK19185" class="sect3">
<h4 class="sect3"><a id="sthref137"></a>Parsing XML Documents with Accented Characters</h4>
<p>Assume that an input XML file contains accented characters such as an <code dir="ltr">&eacute;</code>. <a href="#CCHCBEEG">Example 4-9</a> shows one way to parse an XML document with accented characters.</p>
<div id="ADXDK19186" class="example">
<p class="titleinexample"><a id="CCHCBEEG"></a>Example 4-9 Parsing a Document with Accented Characters</p>
<pre dir="ltr">
DOMParser parser=new DOMParser(); 
parser.setPreserveWhitespace(true); 
parser.setErrorStream(System.err); 
parser.setValidationMode(false); 
parser.showWarnings(true);
parser.parse (new FileInputStream(new File("file_with_accents.xml")));
</pre></div>
<!-- class="example" -->
<p>When you attempt to parse the XML file, the parser can sometimes throw an "Invalid UTF-8 encoding" exception. If you explicitly set the encoding to UTF-8, or if you do not specify it at all, then the parser interprets an accented character&mdash;which has an ASCII value greater than 127&mdash;as the first byte of a UTF-8 multibyte sequence. If the subsequent bytes do not form a valid UTF-8 sequence, then you receive an error.</p>
<p>This error means that your XML editor did not save the file with UTF-8 encoding. For example, it may have saved it with ISO-8859-1 encoding. The encoding is a particular scheme used to write the Unicode character number representation to disk. Adding the following element to the top of an XML document does not itself cause your editor to write out the bytes representing the file to disk with UTF-8 encoding:</p>
<pre dir="ltr">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
</pre>
<p>One solution is to read in accented characters in their hex or decimal format within the XML document, for example, <code dir="ltr">&amp;#xd9;</code>. If you prefer not to use this technique, however, then you can set the encoding based on the character set that you were using when you created the XML file. For example, try setting the encoding to ISO-8859-1 (Western European ASCII) or to something different, depending on the tool or operating system you are using.</p>
</div>
<!-- class="sect3" -->
<a id="CCHIBCGC"></a>
<div id="ADXDK19187" class="sect3">
<h4 class="sect3"><a id="sthref138"></a><a id="sthref139"></a>Handling Special Characters in Tag Names</h4>
<p>Special characters such as <code dir="ltr">&amp;</code>, <code dir="ltr">$</code>, and <code dir="ltr">#</code>, and so on are not legal in tag names. For example, if a document names tags after companies, and if the document includes the tag <code dir="ltr">&lt;A&amp;B&gt;</code>, then the parser issues an error about invalid characters.</p>
<p>If you are creating an XML document from scratch, then you can work around this problem by using only valid <code dir="ltr">NameChars</code>. For example, you can name the tag <code dir="ltr">&lt;A_B&gt;, &lt;AB&gt;</code>, <code dir="ltr">&lt;A_AND_B&gt;</code> and so on. If you are generating XML from external data sources such as database tables, however, then XML 1.0 does not address this problem.</p>
<p>The datatype <code dir="ltr">XMLType</code> addresses this problem by providing the <code dir="ltr">setConvertSpecialChars</code> and <code dir="ltr">convert</code> functions in the <code dir="ltr">DBMS_XMLGEN</code> package. You can use these functions to control the use of special characters in SQL names and XML names. The SQL to XML name mapping functions escape invalid XML <code dir="ltr">NameChar</code> characters in the format of <code dir="ltr"><span class="codeinlineitalic">_XHHHH_</span></code>, where <code dir="ltr"><span class="codeinlineitalic">HHHH</span></code> is the Unicode value of the invalid character. For example, table name <code dir="ltr">V$SESSION</code> is mapped to XML name <code dir="ltr">V_X0024_SESSION</code>.</p>
<p>Escaping invalid characters is another workaround to give users a way to serialize names so that they can reload them somewhere else.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1204">
<tr>
<td class="cellalignment1213">
<table class="cellalignment1209">
<tr>
<td class="cellalignment1208"><a href="adx_j_gs.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1208"><a href="adx_j_xmlbin.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1216">
<table class="cellalignment1207">
<tr>
<td class="cellalignment1208"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1208"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1208"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1208"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1208"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1208"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
