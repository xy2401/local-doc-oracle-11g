<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using the XML SQL Utility (XSU)</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T14:20:37Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="XML Developer's Kit Programmer's Guide" />
<meta name="dcterms.identifier" content="E23582-06" />
<meta name="dcterms.isVersionOf" content="ADXDK" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="adx_j_beans.htm" title="Previous" type="text/html" />
<link rel="Next" href="adx_j_transx.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e23582.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/47</span> <!-- End Header -->
<div id="ADXDK070" class="chapter"><a id="i1000441"></a>
<h1 class="chapter"><span class="secnum">11</span> Using the XML SQL Utility (XSU)</h1>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#BABIFEED">Introduction to the XML SQL Utility (XSU)</a></p>
</li>
<li>
<p><a href="#i1013897">Using the XML SQL Utility: Overview</a></p>
</li>
<li>
<p><a href="#i1008145">Programming with the XSU Java API</a></p>
</li>
<li>
<p><a href="#BABGGGAH">Programming with the XSU PL/SQL API</a></p>
</li>
<li>
<p><a href="#i1007013">Tips and Techniques for Programming with XSU</a></p>
</li>
</ul>
<a id="BABIFEED"></a>
<div id="ADXDK19392" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Introduction to the XML SQL Utility (XSU)</h2>
<p><a href="glossary.htm#i999059"><span class="xrefglossterm">XML SQL Utility (XSU)</span></a> is an XDK component that enables you to transfer XML data through Oracle SQL statements. You can use XSU to perform the following tasks:</p>
<ul>
<li>
<p>Transform data in object-relational database tables or views into XML. XSU can query the database and return the result set as an XML document.</p>
</li>
<li>
<p>Extract data from an XML document and use canonical mapping to insert the data into a table or a view or update or delete values of the appropriate columns or attributes.</p>
</li>
</ul>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABEEDHB">Prerequisites</a></p>
</li>
<li>
<p><a href="#BABHJFJJ">XSU Features</a></p>
</li>
<li>
<p><a href="#BABBFBFI">XSU Restrictions</a></p>
</li>
</ul>
<a id="BABEEDHB"></a>
<div id="ADXDK19393" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Prerequisites</h3>
<p>This chapter assumes that you are familiar with the following technologies:</p>
<ul>
<li>
<p>Oracle Database SQL. XSU transfers XML to and from a database through <code dir="ltr">SELECT</code> statements and DML.</p>
</li>
<li>
<p>PL/SQL. The XDK supplies a PL/SQL API for XSU that mirrors the Java API.</p>
</li>
<li>
<p><a href="glossary.htm#i999282"><span class="xrefglossterm">Java Database Connectivity (JDBC)</span></a>. Java applications that use XSU to transfer XML to and from a database require a JDBC connection.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABHJFJJ"></a>
<div id="ADXDK19394" class="sect2">
<h3 class="sect2">XSU Features</h3>
<p>XSU has the following key features:</p>
<ul>
<li>
<p>Dynamically generates DTDs or XML schemas.</p>
</li>
<li>
<p>Generates XML documents in their string or DOM representations.</p>
</li>
<li>
<p>Performs simple transformations during generation such as modifying default tag names for each <code dir="ltr">&lt;ROW&gt;</code> element. You can also register an XSL transformation that XSU applies to the generated XML documents as needed.</p>
</li>
<li>
<p>Generates XML as a stream of SAX2 callbacks.</p>
</li>
<li>
<p>Supports XML attributes during generation, which enables you to specify that a particular column or group of columns maps to an XML attribute instead of an XML element.</p>
</li>
<li>
<p>Allows SQL to XML tag escaping. Sometimes column names are not valid XML tag names. To avoid this problem you can either alias all the column names or turn on tag escaping.</p>
</li>
<li>
<p>Supports <code dir="ltr">XMLType</code> columns in objects or tables.</p>
</li>
<li>
<p>Inserts XML into relational database tables or views. When given an XML document, XSU can also update or delete records from a database object.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABBFBFI"></a>
<div id="ADXDK19395" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">XSU Restrictions</h3>
<p>Note the following restrictions when using XSU:</p>
<ul>
<li>
<p>XSU can only store data in a single table. You can store XML across tables, however, by using the Oracle XSLT processor to transform a document into multiple documents and inserting them separately. You can also define views over multiple tables and perform insertions into the views. If a view is non-updatable (because of complex joins), then you can use <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers over the views to perform the inserts.</p>
</li>
<li>
<p>You cannot use XSU to load XML data stored in attributes into a database schema, but you can use an XSLT transformation to change the attributes into elements.</p>
</li>
<li>
<p>By default XSU is case sensitive. You can either use the correct case or specify that case should be ignored.</p>
</li>
<li>
<p>XSU cannot generate a relational database schema from an input DTD.</p>
</li>
<li>
<p>Inserting into <code dir="ltr">XMLType</code> tables using XSU is not supported. <code dir="ltr">XMLType</code> columns are supported.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1013897"></a>
<div id="ADXDK19396" class="sect1">
<h2 class="sect1">Using the XML SQL Utility: Overview<a id="sthref263"></a></h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1020043">Using XSU: Basic Process</a></p>
</li>
<li>
<p><a href="#BABDJHGC">Installing XSU</a></p>
</li>
<li>
<p><a href="#BABIEAEI">Running the XSU Demo Programs</a></p>
</li>
<li>
<p><a href="#i1014447">Using the XSU Command-Line Utility</a></p>
</li>
</ul>
<a id="i1020043"></a>
<div id="ADXDK19397" class="sect2">
<h3 class="sect2">Using XSU: Basic Process<a id="sthref264"></a><a id="sthref265"></a></h3>
<p>XSU is accessible through the following interfaces:</p>
<ul>
<li>
<p>The <code dir="ltr">OracleXML</code><code dir="ltr">Query</code> and <code dir="ltr">OracleXMLSave</code> Java classes in the <code dir="ltr">oracle.xml.sql.query</code> package. Use the <code dir="ltr">OracleXMLQuery</code> class to generate XML from relational data and <code dir="ltr">OracleXMLSave</code> class to perform DML.</p>
</li>
<li>
<p>The PL/SQL packages <a class="olink ARPLS376" href="../../appdev.112/e40758/d_xmlque.htm#ARPLS376"><code dir="ltr">DBMS_XMLQuery</code></a> and <a class="olink ARPLS066" href="../../appdev.112/e40758/d_xmlsav.htm#ARPLS066"><code dir="ltr">DBMS_XMLSave</code></a>, which mirror the Java classes.</p>
</li>
</ul>
<p>You can write the following types of XSU applications:</p>
<ul>
<li>
<p>Java programs that run inside the database and access the internal XSU Java API</p>
</li>
<li>
<p>Java programs that run on the client and access the client-side XSU Java API</p>
</li>
<li>
<p>PL/SQL programs that access XSU through PL/SQL packages</p>
</li>
</ul>
<a id="BABIFCGB"></a>
<div id="ADXDK19398" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Generating XML with the XSU Java API: Basic Process</h4>
<p>The <code dir="ltr">OracleXMLQuery</code> class makes up the XML generation part of the XSU Java API. <a href="#BABJAEAE">Figure 11-1</a> illustrates the basic process for generating XML with XSU.</p>
<p>The basic steps in <a href="#BABJAEAE">Figure 11-1</a> are as follows:</p>
<div id="ADXDK19399" class="figure">
<p class="titleinfigure"><a id="BABJAEAE"></a>Figure 11-1 Generating XML with XSU</p>
<img width="659" height="111" src="img/adxdk032.gif" alt="Description of Figure 11-1 follows" /><br />
<a id="sthref266" href="img_text/adxdk032.htm">Description of "Figure 11-1 Generating XML with XSU"</a><br />
<br /></div>
<!-- class="figure" -->
<ol>
<li>
<p>Create a JDBC connection to the database. Normally, you establish a connection with the <code dir="ltr">DriverManager</code> class, which manages a set of JDBC drivers. After the JDBC drivers are loaded, call <code dir="ltr">getConnection()</code>. When it finds the right driver, this method returns a <code dir="ltr">Connection</code> object that represents a database session. All SQL statements are executed within the context of this session.</p>
<p>You have the following options:</p>
<ul>
<li>
<p>Create the connection with the JDBC OCI driver. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
// import the Oracle driver class
import oracle.jdbc.*;
// load the Oracle JDBC driver
DriverManager.registerDriver(new oracle.jdbc.OracleDriver());     
// create the connection
Connection conn =
   DriverManager.getConnection("jdbc:oracle:oci:@","hr","<span class="italic">password</span>");
</pre>
<p>The preceding example uses the default connection for the <a id="sthref267"></a><a id="sthref268"></a>JDBC OCI driver.</p>
</li>
</ul>
<ul>
<li>
<p>Create the connection with the JDBC thin driver. The thin driver is written in pure Java and can be called from any Java program. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
Connection conn =        
   DriverManager.getConnection("jdbc:oracle:thin:@dlsun489:1521:ORCL",
     "hr","<span class="italic">password</span>");
</pre>
<p>The thin driver requires the host name (<code dir="ltr">dlsun489</code>), port number (1521), and the Oracle SID (<code dir="ltr">ORCL</code>). The database must have an active TCP/IP listener.</p>
</li>
<li>
<p>Use default connection used by the server-side internal JDBC driver. This driver runs within a default session and default transaction context. You are already connected to the database; your SQL operations are part of the default transaction. Thus, you do not need to register the driver. Create the <code dir="ltr">Connection</code> object as follows:</p>
<pre dir="ltr">
Connection conn = new oracle.jdbc.OracleDriver().defaultConnection ();
</pre></li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">OracleXMLDataSetExtJdbc</code> is used only for Oracle JDBC, whereas <code dir="ltr">OracleXMLDataSetGenJdbc</code> is used for non-Oracle JDBC. These classes are in the oracle.xml.sql.dataset package.</div>
</li>
<li>
<p>Create an XML query object and assign it a SQL query. You create an <code dir="ltr">OracleXMLQuery</code> Class instance by passing a SQL query to the constructor, as shown in the following example:</p>
<pre dir="ltr">
OracleXMLQuery qry = new OracleXMLQuery (conn, "SELECT * from EMPLOYEES");
</pre></li>
<li>
<p>Configure the XML query object by invoking <code dir="ltr">OracleXMLQuery</code> methods. The following example specifies that only 20 rows should be included in the result set:</p>
<pre dir="ltr">
xmlQry.setMaxRows(20); 
</pre></li>
<li>
<p>Return a DOM object or string by invoking <code dir="ltr">OracleXMLQuery</code> methods. For example, obtain a DOM object as follows:</p>
<pre dir="ltr">
XMLDocument domDoc = (XMLDocument)qry.getXMLDOM();
</pre>
<p>Obtain a string object as follows:</p>
<pre dir="ltr">
String xmlString = qry.getXMLString();
</pre></li>
<li>
<p>Perform additional processing on the string or DOM as needed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink JJDEV" href="../../java.112/e10588/toc.htm"><span class="italic">Oracle Database Java Developer's Guide</span></a> to learn about Oracle JDBC</p>
</li>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> to learn about <code dir="ltr">OracleXMLQuery</code> methods</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADXDK19400" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref269"></a>
<h4 class="sect3">Performing DML with the XSU Java API: Basic Process</h4>
<p>Use the <code dir="ltr">OracleXMLSave</code> class to insert, update, and delete XML in the database. <a href="#BABCEFEJ">Figure 11-2</a> illustrates the basic process.</p>
<div id="ADXDK19401" class="figure">
<p class="titleinfigure"><a id="BABCEFEJ"></a>Figure 11-2 Storing XML in the Database Using XSU</p>
<img width="580" height="352" src="img/adxdk013.gif" alt="Description of Figure 11-2 follows" /><br />
<a id="sthref270" href="img_text/adxdk013.htm">Description of "Figure 11-2 Storing XML in the Database Using XSU"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The basic steps in <a href="#BABCEFEJ">Figure 11-2</a> are as follows:</p>
<ol>
<li>
<p>Create a JDBC connection to the database. This step is identical to the first step described in <a href="#BABIFCGB">"Generating XML with the XSU Java API: Basic Process"</a>.</p>
</li>
<li>
<p>Create an XML save object and assign it a table on which to perform DML. Pass a table or view name to the constructor, as shown in the following example:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Specify the primary key columns. For example, the following code specifies that <code dir="ltr">employee_id</code> is the key column:</p>
<pre dir="ltr">
String [] keyColNames = new String[1];
keyColNames[0] = "EMPLOYEE_ID";
sav.setKeyColumnList(keyColNames);
</pre></li>
<li>
<p>Configure the XML save object by invoking <code dir="ltr">OracleXMLSave</code> methods. The following example specifies an update of the <code dir="ltr">salary</code> and <code dir="ltr">job_id</code> columns:</p>
<pre dir="ltr">
String[] updateColNames = new String[2];
updateColNames[0] = "SALARY";
updateColNames[1] = "JOB_ID";
sav.setUpdateColumnList(updateColNames); // set the columns to update
</pre></li>
<li>
<p>Invoke the <code dir="ltr">insertXML()</code>, <code dir="ltr">updateXML()</code>, or <code dir="ltr">deleteXML()</code> methods on the <code dir="ltr">OracleXMLSave</code> object. The following example illustrates an update:</p>
<pre dir="ltr">
// Assume that the user passes in this XML document as the first argument
sav.updateXML(sav.getURL(argv[0]));
</pre>
<p>When performing the DML, XSU performs the following tasks:</p>
<ol>
<li>
<p>Parses the input XML document.</p>
</li>
<li>
<p>Matches element names to column names in the target table or view.</p>
</li>
<li>
<p>Converts the elements to SQL types and binds them to the appropriate statement.</p>
</li>
</ol>
</li>
<li>
<p>Close the <code dir="ltr">OracleXMLSave</code> object and deallocate all contexts associated with it, as shown in the following example:</p>
<pre dir="ltr">
sav.close();
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink JJDEV" href="../../java.112/e10588/toc.htm"><span class="italic">Oracle Database Java Developer's Guide</span></a> to learn about JDBC</p>
</li>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> to learn about <code dir="ltr">OracleXMLSave</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="ADXDK19402" class="sect3"><a id="sthref271"></a>
<h4 class="sect3">Generating XML with <a id="sthref272"></a><a id="sthref273"></a><a id="sthref274"></a><a id="sthref275"></a>the XSU PL/SQL API: Basic Process</h4>
<p>The XSU PL/SQL API reflects the Java API in the generation and storage of XML documents from and to a database. <code dir="ltr">DBMS_XMLQuery</code> is the PL/SQL package that reflects the methods in the <code dir="ltr">OracleXMLQuery</code> Java class. This package has a context handle associated with it. Create a context by calling one of the constructor-like functions to get the handle and then use the handle in all subsequent calls.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For improved performance, consider using the C-based <code dir="ltr">DBMS_XMLGEN</code>, which is written in C and built into the database, rather than <code dir="ltr">DBMS_XMLQUERY</code>.</div>
<p>XSU supports the <code dir="ltr">XMLType</code> datatype. Using XSU with <code dir="ltr">XMLType</code> is useful if, for example, you have <code dir="ltr">XMLType</code> columns in objects or tables.</p>
<p>Generating XML results in a CLOB that contains the XML document. To use <a class="olink ARPLS376" href="../../appdev.112/e40758/d_xmlque.htm#ARPLS376"><code dir="ltr">DBMS_XMLQuery</code></a> and the XSU generation engine, follow these basic steps:</p>
<ol>
<li>
<p>Declare a variable for the XML query context and a variable for the generated XML. For example:</p>
<pre dir="ltr">
v_queryCtx  DBMS_XMLQuery.ctxType;
v_result    CLOB;
</pre></li>
<li>
<p>Obtain a context handle by calling the <code dir="ltr">DBMS_XMLQuery.<a id="sthref276"></a><a id="sthref277"></a><a id="sthref278"></a>newContext</code> function and supplying it the query, either as a <code dir="ltr">CLOB</code> or a <code dir="ltr">VARCHAR2</code>. The following example registers a query to select the rows from the <code dir="ltr">employees</code> table with the <code dir="ltr">WHERE</code> clause containing the bind variables <code dir="ltr">:EMPLOYEE_ID</code> and <code dir="ltr">:FIRST_NAME</code>:</p>
<pre dir="ltr">
v_queryCtx = DBMS_XMLQuery.newContext('SELECT * FROM employees 
                   WHERE employee_id=:EMPLOYEE_ID AND first_name=:FIRST_NAME');
</pre></li>
<li>
<p>Bind values to the query. The binds work by binding a name to the position. <code dir="ltr"><a id="sthref279"></a><a id="sthref280"></a><a id="sthref281"></a><a id="sthref282"></a>clearBindValues</code> clears all the bind variables, whereas <code dir="ltr">setBindValue</code> sets a single bind variable with a string value. For example, bind the <code dir="ltr">employee_id</code> and <code dir="ltr">first_name</code> values as shown:</p>
<pre dir="ltr">
DBMS_XMLQuery.setBindValue(v_queryCtx,'EMPLOYEE_ID',20);
DBMS_XMLQuery.setBindValue(v_queryCtx,'FIRST_NAME','John');
</pre></li>
<li>
<p>Configure the query context. Set optional arguments such as the <code dir="ltr">ROW</code> tag name, the <code dir="ltr">ROWSET</code> tag name, or the number of rows to fetch, and so on. The following example specifies changes the default <code dir="ltr">ROWSET</code> element name to <code dir="ltr">EMPSET</code>:</p>
<pre dir="ltr">
DBMS_XMLQuery.setRowSetTag(v_queryCtx,'EMPSET');
</pre></li>
<li>
<p>Fetch the results. You can obtain the XML as a <code dir="ltr">CLOB</code> with the <code dir="ltr">getXML</code> function, which generates XML with or without a DTD or XML schema. The following example applies bind values to the statement and gets the result corresponding to the predicate <code dir="ltr">employee_id = 20</code> and <code dir="ltr">first_name = 'John'</code>:</p>
<pre dir="ltr">
v_result := <a id="sthref283"></a><a id="sthref284"></a><a id="sthref285"></a>DBMS_XMLQuery.getXML(v_queryCtx);
</pre></li>
<li>
<p>Process the results of the XML generation. For example, suppose that your program declared the following variables:</p>
<pre dir="ltr">
v_xmlstr VARCHAR2(32767);
v_line   VARCHAR2(2000);
</pre>
<p>You can print the <code dir="ltr">CLOB</code> stored in <code dir="ltr">v_result</code> as follows:</p>
<pre dir="ltr">
v_xmlstr := DBMS_LOB.SUBSTR(v_result,32767);
LOOP
  EXIT WHEN v_xmlstr IS NULL;
  v_line := substr(v_xmlstr,1,INSTR(v_xmlstr,CHR(10))-1);
  DBMS_OUTPUT.PUT_LINE('| ' || v_line);
  v_xmlstr := SUBSTR(v_xmlstr,INSTR(v_xmlstr,CHR(10))+1);
END LOOP;
</pre></li>
<li>
<p>Close the context. For example:</p>
<pre dir="ltr">
DBMS_XMLQuery.closeContext(v_queryCtx);
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<a id="BABJFICC"></a>
<div id="ADXDK19403" class="sect3">
<h4 class="sect3">Performing DML with the PL/SQL API<a id="sthref286"></a><a id="sthref287"></a>: Basic Process</h4>
<p><a class="olink ARPLS066" href="../../appdev.112/e40758/d_xmlsav.htm#ARPLS066"><code dir="ltr">DBMS_XMLSave</code></a> is the PL/SQL package that reflects the methods in the <code dir="ltr">OracleXMLSave</code> Java class. This package has a context handle associated with it. Create a context by calling one of the constructor-like functions to get the handle and then use the handle in all subsequent calls.</p>
<p>To use <a id="sthref288"></a><a id="sthref289"></a><code dir="ltr">DBMS_XMLSave</code>, follow these basic steps:</p>
<ol>
<li>
<p>Declare a variable for the XML save context and a variable for the number of rows touched by the DML. For example:</p>
<pre dir="ltr">
savCtx DBMS_XMLSave.ctxType;
v_rows   NUMBER;
</pre></li>
<li>
<p>Create a context handle by calling the <code dir="ltr">DBMS_XMLSave.<a id="sthref290"></a><a id="sthref291"></a>newContext</code> function and supply it the table name to use for the DML operations.</p>
<pre dir="ltr">
savCtx  := DBMS_XMLSave.newContext('hr.employees');
</pre></li>
<li>
<p>Set options based on the type of DML that you want to perform.</p>
<p>For inserts you can set the list of columns to insert into the <code dir="ltr">setUpdateColumn</code> function. The default is to insert values into all columns. The following example sets five columns in the <code dir="ltr">employees</code> table:</p>
<pre dir="ltr">
DBMS_XMLSave.setUpdateColumn(savCtx,'EMPLOYEE_ID'); 
DBMS_XMLSave.setUpdateColumn(savCtx,'LAST_NAME');
DBMS_XMLSave.setUpdateColumn(savCtx,'EMAIL');
DBMS_XMLSave.setUpdatecolumn(savCtx,'JOB_ID');
DBMS_XMLSave.setUpdateColumn(savCtx,'HIRE_DATE');
</pre>
<p>For updates you must supply the list of key columns. Optionally, you can then supply the list of columns for update. In this case, the tags in the XML document matching the key column names will be used in the <code dir="ltr">WHERE</code> clause of the <code dir="ltr">UPDATE</code> statement and the tags matching the update column list will be used in the <code dir="ltr">SET</code> clause of the <code dir="ltr">UPDATE</code> statement. For example:</p>
<pre dir="ltr">
DBMS_XMLSave.setKeyColumn(savCtx,'employee_id'); -- set key column
-- set list of columns to update.
DBMS_XMLSave.setUpdateColumn(savCtx,'salary');
DBMS_XMLSave.setUpdateColumn(savCtx,'job_id');
</pre>
<p>For deletes the default is to create a <code dir="ltr">WHERE</code> clause to match all the tag values present in each <code dir="ltr">&lt;ROW&gt;</code> element of the document supplied. To override this behavior, set the list of key columns. In this case only those tag values whose tag names match these columns are used to identify the rows to delete (in effect used in the <code dir="ltr">WHERE</code> clause of the <code dir="ltr">DELETE</code> statement). For example:</p>
<pre dir="ltr">
DBMS_XMLSave.setKeyColumn(savCtx,'EMPLOYEE_ID');
</pre></li>
<li>
<p>Supply a context and XML document to the <code dir="ltr"><a id="sthref292"></a><a id="sthref293"></a><a id="sthref294"></a><a id="sthref295"></a>insertXML</code>, <code dir="ltr">updateXML</code>, or <code dir="ltr">deleteXML</code> functions. For example:</p>
<pre dir="ltr">
v_rows := DBMS_XMLSave.deleteXML(savCtx,xmlDoc);
</pre></li>
<li>
<p>Repeat the DML any number of times if needed.</p>
</li>
<li>
<p>Close the context. For example:</p>
<pre dir="ltr">
DBMS_XMLSave.closeContext(savCtx);
</pre></li>
</ol>
<p>For a model use the Java examples described in <a href="#i1008145">"Programming with the XSU Java API"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDJHGC"></a>
<div id="ADXDK19404" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Installing XSU</h3>
<p>XSU is included in the Oracle Database software CD along with the other XDK utilities. <a href="adx_j_gs.htm#CHDDHEIJ">"Java XDK Component Dependencies"</a> describes the XSU components and dependencies.</p>
<p>By default, the Oracle Universal Installer installs XSU on disk and loads it into the database. No user intervention is required. If you did not load XSU in the database when installing Oracle, you can install XSU manually as follows:</p>
<ol>
<li>
<p>Make sure that Oracle XML DB is installed.</p>
</li>
<li>
<p>Load the <code dir="ltr">xsu12.jar</code> file into the database. This JAR file, which has a dependency on <code dir="ltr">xdb.jar</code> for <code dir="ltr">XMLType</code> access, is described in <a href="adx_j_gs.htm#BACCJCEA">Table 3-1</a>.</p>
</li>
<li>
<p>Run the <code dir="ltr">$ORACLE_HOME/rdbms/admin/dbmsxsu.sql</code> script. This SQL script builds the XSU PL/SQL API.</p>
</li>
</ol>
<p>As explained in <a href="#i1020043">"Using XSU: Basic Process"</a>, you do not have to load XSU into the database in order to use it. XSU can reside in any tier that supports Java.</p>
<p>The following sections describe your installation options:</p>
<ul>
<li>
<p><a href="#BABBAAFI">Installing XSU in the Database</a></p>
</li>
<li>
<p><a href="#BABEJDEF">Installing XSU in an Application Server</a></p>
</li>
<li>
<p><a href="#BABDCIDC">Installing XSU in a Web Server</a></p>
</li>
</ul>
<a id="BABBAAFI"></a>
<div id="ADXDK19405" class="sect3">
<h4 class="sect3">Installing XSU in the Database</h4>
<p><a href="#BABFHEJD">Figure 11-3</a> shows the typical architecture for applications that use the XSU libraries installed in the database. XML generated from XSU running in the database can be placed in advanced queues in the database to be queued to other systems or clients. You deliver the XML internally through stored procedures in the database or externally through web or application servers.</p>
<p>In <a href="#BABFHEJD">Figure 11-3</a> all lines are bidirectional. Because XSU can generate as well as save data, resources can deliver XML to XSU running inside the database, which can then insert it in the appropriate database tables.</p>
<div id="ADXDK19406" class="figure">
<p class="titleinfigure"><a id="BABFHEJD"></a>Figure 11-3 Running XSU in the Database</p>
<img width="672" height="332" src="img/adxdk018.gif" alt="Description of Figure 11-3 follows" /><br />
<a id="sthref296" href="img_text/adxdk018.htm">Description of "Figure 11-3 Running XSU in the Database"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABEJDEF"></a>
<div id="ADXDK19407" class="sect3">
<h4 class="sect3">Installing XSU in an Application Server</h4>
<p>Your application architecture may need to use an application server in the middle tier. The application tier can be an Oracle database, Oracle application server, or a third-party application server that supports Java programs.</p>
<p>You can generate XML in the middle tier from SQL queries or <code dir="ltr">ResultSets</code> for various reasons, for example, to integrate different JDBC data sources in the middle tier. In this case, you can install the XSU in your middle tier, thereby enabling your Java programs to make use of XSU through its Java API.</p>
<p><a href="#BABIGADF">Figure 11-4</a> shows a typical architecture for running XSU in a middle tier. In the middle tier, data from JDBC sources is converted by XSU into XML and then sent to Web servers or other systems. Again, the process is bidirectional, which means that the data can be put back into the JDBC sources (database tables or views) by means of XSU. If an Oracle database itself is used as the application server, then you can use the PL/SQL front-end instead of Java.</p>
<div id="ADXDK19408" class="figure">
<p class="titleinfigure"><a id="BABIGADF"></a>Figure 11-4 Running XSU in the MIddle Tier</p>
<img width="663" height="327" src="img/adxdk019.gif" alt="Description of Figure 11-4 follows" /><br />
<a id="sthref297" href="img_text/adxdk019.htm">Description of "Figure 11-4 Running XSU in the MIddle Tier"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="BABDCIDC"></a>
<div id="ADXDK19409" class="sect3">
<h4 class="sect3">Installing XSU in a Web Server</h4>
<p><a href="#BABEHFAH">Figure 11-5</a> shows that XSU can live in the Web server as long as the Web server supports Java servlets. In this way you can write Java servlets that use XSU. XSQL Servlet is a standard servlet provided by Oracle. It is built on top of XSU and provides a template-like interface to XSU functionality. To perform XML processing in the Web server and avoid intricate servlet programming, you can use the XSQL Servlet.</p>
<div id="ADXDK19410" class="figure">
<p class="titleinfigure"><a id="BABEHFAH"></a>Figure 11-5 Running XSU in a Web Server</p>
<img width="590" height="202" src="img/adxdk020.gif" alt="Description of Figure 11-5 follows" /><br />
<a id="sthref298" href="img_text/adxdk020.htm">Description of "Figure 11-5 Running XSU in a Web Server"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADXDB" href="../e23094/toc.htm"><span class="italic">Oracle XML DB Developer's Guide</span></a>, especially the chapter on generating XML, for examples on using XSU with <code dir="ltr">XMLType</code></p>
</li>
<li>
<p><a class="olink JAXML" href="../e10769/toc.htm"><span class="italic">Oracle Database XML Java API Reference</span></a> to learn about the classes <code dir="ltr">OracleXML</code><code dir="ltr">Query</code> and <code dir="ltr">OracleXMLSave</code></p>
</li>
<li>
<p><a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> to learn about the packages <code dir="ltr">DBMS_XMLQuery</code> and <code dir="ltr">DBMS_XMLSave</code></p>
</li>
<li>
<p><a href="adx_j_xsqlpub.htm#g1070142">Chapter 14, "Using the XSQL Pages Publishing Framework"</a> to learn about XSQL Servlet</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABIEAEI"></a>
<div id="ADXDK19411" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Running the XSU Demo Programs</h3>
<p>Demo programs for XSU are included in <code dir="ltr">$ORACLE_HOME/xdk/demo/java/xsu</code>. <a href="#BABICEIE">Table 11-1</a> describes the XML files and programs that you can use to test XSU.</p>
<div id="ADXDK19412" class="tblhruleformalwidemax">
<p class="titleintable"><a id="sthref299"></a><a id="BABICEIE"></a>Table 11-1 XSU Sample Files</p>
<table class="cellalignment1211" title="XSU Sample Files " summary="File and Description are the Columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t7">File</th>
<th class="cellalignment1212" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t7" headers="r1c1-t7">
<p><code dir="ltr">bindSQLVariables.sql</code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t7 r1c2-t7">
<p>An PL/SQL script that binds values for <code dir="ltr">EMPLOYEE_ID</code> and <code dir="ltr">FIRST_NAME</code> to columns in the employees table. Refer to <a href="#BABCBFJD">"Binding Values in XSU"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t7" headers="r1c1-t7">
<p><code dir="ltr">changeElementName.sql</code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t7 r1c2-t7">
<p>A PL/SQL program that obtains the first 20 rows of the <code dir="ltr">employees</code> table as an XML document. Refer to <a href="#BABBBEIB">"Specifying Element Names with DBMS_XMLQuery"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t7" headers="r1c1-t7">
<p><code dir="ltr">createObjRelSchema.sql</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t7 r1c2-t7">
<p>A SQL script that sets up an object-relational schema and populates it. Refer to <a href="#CHDHIGFC">"XML Mapping Against an Object-Relational Schema"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t7" headers="r1c1-t7">
<p><code dir="ltr">createObjRelSchema2.sql</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t7 r1c2-t7">
<p>A SQL script that sets up an object-relational schema and populates it. Refer to <a href="#i1016364">"Altering the Database Schema or SQL Query"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t7" headers="r1c1-t7">
<p><code dir="ltr">createRelSchema.sql</code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t7 r1c2-t7">
<p>A SQL script that creates a relational table and then creates a customer view that contains a customer object on top of it. Refer to <a href="#i1016364">"Altering the Database Schema or SQL Query"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t7" headers="r1c1-t7">
<p><code dir="ltr">customer.xml</code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t7 r1c2-t7">
<p>An XML document that describes a customer. Refer to <a href="#i1016364">"Altering the Database Schema or SQL Query"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t7" headers="r1c1-t7">
<p><code dir="ltr">deleteEmployeeByKey.sql</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t7 r1c2-t7">
<p>A PL/SQL program that deletes an employee by primary key. Refer to <a href="#CHDHFHGI">"Deleting by Key with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t7" headers="r1c1-t7">
<p><code dir="ltr">deleteEmployeeByRow.sql</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t7 r1c2-t7">
<p>A PL/SQL program that deletes an employee by row. Refer to <a href="#CHDFHDJG">"Deleting by Row with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t7" headers="r1c1-t7">
<p><code dir="ltr">domTest.java</code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t7 r1c2-t7">
<p>A program that generates a DOM tree and then traverses it in document order, printing the nodes one by one. Refer to <a href="#BABHHECH">"Generating a DOM Tree with OracleXMLQuery"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t7" headers="r1c1-t7">
<p><code dir="ltr">index.txt</code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t7 r1c2-t7">
<p>A README that describes the programs in the demo directory.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r12c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insProc.sql</code></p>
</td>
<td class="cellalignment1213" headers="r12c1-t7 r1c2-t7">
<p>A PL/SQL program that inserts an XML document into a table. Refer to <a href="#BABJBCIB">"Inserting Values into All Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r13c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insertClob.sql</code></p>
</td>
<td class="cellalignment1213" headers="r13c1-t7 r1c2-t7">
<p>A SQL script that creates a table called <code dir="ltr">xmldocument</code> and stores an XML document in the table as a <code dir="ltr">CLOB</code>. Refer to <a href="#BABJBCIB">"Inserting Values into All Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r14c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insertClob2.sql</code></p>
</td>
<td class="cellalignment1213" headers="r14c1-t7 r1c2-t7">
<p>A SQL script that inserts an XML document into the <code dir="ltr">xmldocument</code> table. Refer to <a href="#BABJCFDC">"Inserting into a Subset of Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r15c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insertClob3.sql</code></p>
</td>
<td class="cellalignment1213" headers="r15c1-t7 r1c2-t7">
<p>A SQL script that inserts an XML document into the <code dir="ltr">xmldocument</code> table. Refer to <a href="#BABGDIHB">"Updating with Key Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r16c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insertClob4.sql</code></p>
</td>
<td class="cellalignment1213" headers="r16c1-t7 r1c2-t7">
<p>A SQL script that inserts an XML document into the <code dir="ltr">xmldocument</code> table. Refer to <a href="#BABHDEEH">"Specifying a List of Columns with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r17c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insertEmployee.sql</code></p>
</td>
<td class="cellalignment1213" headers="r17c1-t7 r1c2-t7">
<p>A PL/SQL script that calls the <code dir="ltr">insProc</code> stored procedure and inserts an employee into the <code dir="ltr">employees</code> table. Refer to <a href="#BABGHBGG">"Inserting XML with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r18c1-t7" headers="r1c1-t7">
<p><code dir="ltr">insertEmployee2.sql</code></p>
</td>
<td class="cellalignment1213" headers="r18c1-t7 r1c2-t7">
<p>A PL/SQL script that invokes the <code dir="ltr">testInsert</code> procedure to insert the XML data for an employee into the <code dir="ltr">hr.employees</code> table. Refer to <a href="#BABJCFDC">"Inserting into a Subset of Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r19c1-t7" headers="r1c1-t7">
<p><code dir="ltr">mapColumnToAtt.sql</code></p>
</td>
<td class="cellalignment1213" headers="r19c1-t7 r1c2-t7">
<p>A SQL script that queries the <code dir="ltr">employees</code> table, rendering <code dir="ltr">employee_id</code> as an XML attribute. Refer to <a href="#i1016364">"Altering the Database Schema or SQL Query"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r20c1-t7" headers="r1c1-t7">
<p><code dir="ltr">new_emp.xml</code></p>
</td>
<td class="cellalignment1213" headers="r20c1-t7 r1c2-t7">
<p>An XML document that describes a new employee. Refer to <a href="#BABGAFGD">"Running the testInsert Program"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r21c1-t7" headers="r1c1-t7">
<p><code dir="ltr">new_emp2.xml</code></p>
</td>
<td class="cellalignment1213" headers="r21c1-t7 r1c2-t7">
<p>An XML document that describes a new employee. Refer to <a href="#BABGFDEB">"Running the testInsertSubset Program"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r22c1-t7" headers="r1c1-t7">
<p><code dir="ltr">noRowsTest.java</code></p>
</td>
<td class="cellalignment1213" headers="r22c1-t7 r1c2-t7">
<p>A program that throws an exception when there are no more rows. Refer to <a href="#i1008161">"Raising a No Rows Exception"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r23c1-t7" headers="r1c1-t7">
<p><code dir="ltr">pageTest.java</code></p>
</td>
<td class="cellalignment1213" headers="r23c1-t7 r1c2-t7">
<p>A program that uses the JDBC <code dir="ltr">ResultSet</code> to generate XML one page at a time. Refer to <a href="#BABJABDF">"Generating Scrollable Result Sets"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r24c1-t7" headers="r1c1-t7">
<p><code dir="ltr">paginateResults.java</code></p>
</td>
<td class="cellalignment1213" headers="r24c1-t7 r1c2-t7">
<p>A program that generates an XML page that paginates results. Refer to <a href="#i1016651">"Paginating Results with OracleXMLQuery: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r25c1-t7" headers="r1c1-t7">
<p><code dir="ltr">paginateResults.sql</code></p>
</td>
<td class="cellalignment1213" headers="r25c1-t7 r1c2-t7">
<p>A PL/SQL script that paginates results. It skips the first 3 rows of the <code dir="ltr">employees</code> table and then prints the rest of the rows 10 at a time by setting <code dir="ltr">skipRows</code> to 3 for the first batch of 10 rows and then to 0 for the rest of the batches. Refer to <a href="#BABGHBCI">"Paginating Results with DBMS_XMLQuery"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r26c1-t7" headers="r1c1-t7">
<p><code dir="ltr">printClobOut.sql</code></p>
</td>
<td class="cellalignment1213" headers="r26c1-t7 r1c2-t7">
<p>A PL/SQL script that prints a CLOB to the output buffer. Refer to <a href="#BABGCFCD">"Generating XML from Simple Queries with DBMS_XMLQuery"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r27c1-t7" headers="r1c1-t7">
<p><code dir="ltr">raiseException.sql</code></p>
</td>
<td class="cellalignment1213" headers="r27c1-t7 r1c2-t7">
<p>A PL/SQL script that invokes the <code dir="ltr">DBMS_XMLQuery.getExceptionContent</code> procedure. Refer to <a href="#BABFGGIA">"Handling Exceptions in the XSU PL/SQL API"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r28c1-t7" headers="r1c1-t7">
<p><code dir="ltr">refCurTest.java</code></p>
</td>
<td class="cellalignment1213" headers="r28c1-t7 r1c2-t7">
<p>A program that generates XML from the results of the SQL query defined in the <code dir="ltr">testRefCur</code> function. Refer to <a href="#BABHHBBG">"Generating XML from Cursor Objects"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r29c1-t7" headers="r1c1-t7">
<p><code dir="ltr">samp1.java</code></p>
</td>
<td class="cellalignment1213" headers="r29c1-t7 r1c2-t7">
<p>A program that queries the <code dir="ltr">scott.emp</code> table, then generates an XML document from the query results.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r30c1-t7" headers="r1c1-t7">
<p><code dir="ltr">samp10.java</code></p>
</td>
<td class="cellalignment1213" headers="r30c1-t7 r1c2-t7">
<p>A program that inserts <code dir="ltr">sampdoc.xml</code> into the <code dir="ltr">xmltest_tab1</code> table.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r31c1-t7" headers="r1c1-t7">
<p><code dir="ltr">samp2.java</code></p>
</td>
<td class="cellalignment1213" headers="r31c1-t7 r1c2-t7">
<p>A program that queries the <code dir="ltr">scott.emp</code> table, then generates an XML document from the query results. This program demonstrates how you can customize the generated XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r32c1-t7" headers="r1c1-t7">
<p><code dir="ltr">sampdoc.xml</code></p>
</td>
<td class="cellalignment1213" headers="r32c1-t7 r1c2-t7">
<p>A sample XML data document that <code dir="ltr">samp10.java</code> inserts into the database.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r33c1-t7" headers="r1c1-t7">
<p><code dir="ltr">samps.sql</code></p>
</td>
<td class="cellalignment1213" headers="r33c1-t7 r1c2-t7">
<p>A SQL script that creates the <code dir="ltr">xmltest_tab1</code> table used by <code dir="ltr">samp10.java</code>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r34c1-t7" headers="r1c1-t7">
<p><code dir="ltr">simpleQuery.sql</code></p>
</td>
<td class="cellalignment1213" headers="r34c1-t7 r1c2-t7">
<p>A PL/SQL script that selects 20 rows from the <code dir="ltr">hr.employees</code> table and obtains an XML document as a CLOB. Refer to <a href="#BABGCFCD">"Generating XML from Simple Queries with DBMS_XMLQuery"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r35c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testDML.sql</code></p>
</td>
<td class="cellalignment1213" headers="r35c1-t7 r1c2-t7">
<p>A PL/SQL script that uses the same context and settings to perform DML depending on user input. Refer to <a href="#BABCFACI">"Reusing the Context Handle with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r36c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testDeleteKey.java</code></p>
</td>
<td class="cellalignment1213" headers="r36c1-t7 r1c2-t7">
<p>A program that limits the number of elements used to identify a row, which improves performance by caching the <code dir="ltr">DELETE</code> statement and batching transactions. Refer to <a href="#BABDBJGJ">"Deleting by Key with OracleXMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r37c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testDeleteKey.sql</code></p>
</td>
<td class="cellalignment1213" headers="r37c1-t7 r1c2-t7">
<p>A PL/SQL script that deletes a row from the <code dir="ltr">employees</code> table for every <code dir="ltr">&lt;ROW&gt;</code> element in an input XML document. Refer to <a href="#CHDHFHGI">"Deleting by Key with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r38c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testDeleteRow.java</code></p>
</td>
<td class="cellalignment1213" headers="r38c1-t7 r1c2-t7">
<p>A program that accepts an XML document filename as input and deletes the rows corresponding to the elements in the document. Refer to <a href="#BABEEFFI">"Deleting by Row with OracleXMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r39c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testDeleteRow.sql</code></p>
</td>
<td class="cellalignment1213" headers="r39c1-t7 r1c2-t7">
<p>A SQL script that deletes a row from the <code dir="ltr">employees</code> table for every <code dir="ltr">&lt;ROW&gt;</code> element in an input XML document. Refer to <a href="#CHDFHDJG">"Deleting by Row with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r40c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testException.java</code></p>
</td>
<td class="cellalignment1213" headers="r40c1-t7 r1c2-t7">
<p>A sample program shown that throws a runtime exception and then obtains the parent exception by invoking <code dir="ltr">Exception.getParentException()</code>. Refer to <a href="#BABHBEBC">"Obtaining the Parent Exception"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r41c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testInsert.java</code></p>
</td>
<td class="cellalignment1213" headers="r41c1-t7 r1c2-t7">
<p>A Java program that inserts XML values into all columns of the <code dir="ltr">hr.employees</code> table. Refer to <a href="#BABEFGAJ">"Inserting XML into All Columns with OracleXMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r42c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testInsert.sql</code></p>
</td>
<td class="cellalignment1213" headers="r42c1-t7 r1c2-t7">
<p>A PL/SQL script that inserts XML data into a subset of columns. Refer to <a href="#BABJCFDC">"Inserting into a Subset of Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r43c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testInsertSubset.java</code></p>
</td>
<td class="cellalignment1213" headers="r43c1-t7 r1c2-t7">
<p>A program shown that inserts XML data into a subset of columns. Refer to <a href="#BABGEIIF">"Inserting XML into a Subset of Columns with OracleXMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r44c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testRef.sql</code></p>
</td>
<td class="cellalignment1213" headers="r44c1-t7 r1c2-t7">
<p>A PL/SQL script that creates a function that defines a REF cursor and returns it. Every time the <code dir="ltr">testRefCur</code> function is called, it opens a cursor object for the <code dir="ltr">SELECT</code> query and returns that cursor instance. Refer to <a href="#BABHHBBG">"Generating XML from Cursor Objects"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r45c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testUpdate.java</code></p>
</td>
<td class="cellalignment1213" headers="r45c1-t7 r1c2-t7">
<p>A sample program that updates the <code dir="ltr">hr.employees</code> table by invoking the <code dir="ltr">OracleXMLSave.setKeyColumnList()</code> method. Refer to <a href="#BABEJABF">"Updating Rows with OracleXMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r46c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testUpdateKey.sql</code></p>
</td>
<td class="cellalignment1213" headers="r46c1-t7 r1c2-t7">
<p>A PL/SQL that creates a PL/SQL procedure called <code dir="ltr">testUpdateKey</code> that uses the <code dir="ltr">employee_id</code> column of the <code dir="ltr">employees</code> table as a primary key. Refer to <a href="#BABGDIHB">"Updating with Key Columns with DBMS_XMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r47c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testUpdateList.java</code></p>
</td>
<td class="cellalignment1213" headers="r47c1-t7 r1c2-t7">
<p>Suppose only want to update the salary and job title for each employee and ignore the other information. If you know that all the elements to be updated are the same for all <code dir="ltr">ROW</code> elements in the XML document, then you can use the <code dir="ltr"><a id="sthref300"></a>OracleXMLSave.setUpdateColumnNames()</code> method to specify the columns. Refer to <a href="#BABHIECJ">"Updating a Column List with OracleXMLSave"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r48c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testUpdateSubset.sql</code></p>
</td>
<td class="cellalignment1213" headers="r48c1-t7 r1c2-t7">
<p>A SQL script that creates the procedure <code dir="ltr">testUpdateSubset</code>. The procedure specifies the <code dir="ltr">employee_id</code> column as the key and specifies that <code dir="ltr">salary</code> and <code dir="ltr">job_id</code> should be updated. Refer to <a href="#BABHDEEH">"Specifying a List of Columns with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r49c1-t7" headers="r1c1-t7">
<p><code dir="ltr">testXMLSQL.java</code></p>
</td>
<td class="cellalignment1213" headers="r49c1-t7 r1c2-t7">
<p>A sample program that uses XSU to generate XML as a <code dir="ltr">String</code> object. This program queries the <code dir="ltr">hr.employees</code> table and prints the result set to standard output. Refer to <a href="#BABBJBFB">"Generating a String with OracleXMLQuery"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r50c1-t7" headers="r1c1-t7">
<p><code dir="ltr">upd_emp.xml</code></p>
</td>
<td class="cellalignment1213" headers="r50c1-t7 r1c2-t7">
<p>An XML document that contains updated salary and other information for a series of employees. Refer to <a href="#BABBAEJB">"Running the testUpdate Program"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r51c1-t7" headers="r1c1-t7">
<p><code dir="ltr">upd_emp2.xml</code></p>
</td>
<td class="cellalignment1213" headers="r51c1-t7 r1c2-t7">
<p>An XML document that contains updated salary and other information for a series of employees. Refer to <a href="#BABBAEJB">"Running the testUpdate Program"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r52c1-t7" headers="r1c1-t7">
<p><code dir="ltr">updateEmployee.sql</code></p>
</td>
<td class="cellalignment1213" headers="r52c1-t7 r1c2-t7">
<p>An XML document that contains new data for two employees. Refer to <a href="#BABCDJEH">"Running the testUpdateList Program"</a>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r53c1-t7" headers="r1c1-t7">
<p><code dir="ltr">updateEmployee2.sql</code></p>
</td>
<td class="cellalignment1213" headers="r53c1-t7 r1c2-t7">
<p>A PL/SQL script that passes an XML document to the <code dir="ltr">testUpdateSubset</code> procedure and generates two <code dir="ltr">UPDATE</code> statements. Refer to <a href="#BABHDEEH">"Specifying a List of Columns with DBMS_XMLSave: Example"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwidemax" -->
<p>The steps for running the demos are:</p>
<ol>
<li>
<p>Change into the <code dir="ltr">$ORACLE_HOME/xdk/demo/java/xsu</code> directory (UNIX) or <code dir="ltr">%ORACLE_HOME%\xdk\demo\java\xsu</code> directory (Windows).</p>
</li>
<li>
<p>Make sure that your environment variables are set as described in <a href="adx_j_gs.htm#BACFEAGD">"Setting Up the Java XDK Environment"</a>. In particular, make sure that the Java classpath includes <code dir="ltr">xsu12.jar</code> for XSU and <code dir="ltr">ojdbc5.jar</code> (Java 1.5) for JDBC. If you use a multibyte character set other than UTF-8, ISO8859-1, or JA16SJIS, then place <code dir="ltr">orai18n.jar</code> in your classpath so that JDBC can convert the character set of the input file to the database character set.</p>
</li>
<li>
<p>Compile the Java programs as shown in the following example:</p>
<pre dir="ltr">
javac samp1.java samp2.java samp10.java
</pre></li>
<li>
<p>Connect to an Oracle database as <code dir="ltr">hr</code> and run the SQL script <code dir="ltr">createRelSchema</code>:</p>
<pre dir="ltr">
CONNECT hr
@$ORACLE_HOME/xdk/demo/java/xsu/createRelSchema
</pre></li>
</ol>
<p>The following sections describe the XSU demos in detail.</p>
</div>
<!-- class="sect2" -->
<a id="i1014447"></a>
<div id="ADXDK19413" class="sect2">
<h3 class="sect2">Using the XSU Command-Line Utility</h3>
<p>The XDK includes a command-line Java interface for XSU. XSU command-line options are provided through the Java class <code dir="ltr"><a id="sthref301"></a>OracleXML</code>. To use this API ensure that your Java classpath is set as described in <a href="adx_j_gs.htm#BACFEAGD">"Setting Up the Java XDK Environment"</a>.</p>
<p>To print usage information for XSU to standard output, run the following command:</p>
<pre dir="ltr">
java OracleXML
</pre>
<p>To use XSU, invoke it with either the <code dir="ltr">getXML</code> or <code dir="ltr">putXML</code> parameter as follows:</p>
<pre dir="ltr">
java OracleXML getXML <span class="codeinlineitalic">options</span>
java OracleXML putXML <span class="codeinlineitalic">options</span>
</pre>
<p><a href="#BABGDFFJ">Table 11-2</a> describes the <code dir="ltr">getXML</code> options.</p>
<div id="ADXDK19414" class="tblformalwide">
<p class="titleintable"><a id="sthref302"></a><a id="BABGDFFJ"></a>Table 11-2 getXML Options</p>
<table class="cellalignment1211" title="getXML Options" summary="Describes the getXML options" dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t8">getXML Option</th>
<th class="cellalignment1212" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-user</code> "<code dir="ltr"><span class="codeinlineitalic">username</span></code>/<code dir="ltr"><span class="codeinlineitalic">password"</span></code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t8 r1c2-t8">
<p>Specifies the username and password to connect to the database. If this is not specified, then the user defaults to <code dir="ltr">scott/tiger</code>. Note that the connect string is also specified. You can specify the username and password as part of the connect string.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-conn</code> <code dir="ltr"><span class="codeinlineitalic">"JDBC_connect_string"</span></code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t8 r1c2-t8">
<p>Specifies the JDBC database connect string. By default the connect string is: "<code dir="ltr">jdbc:oracle:oci:@</code>".</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-withDTD</code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t8 r1c2-t8">
<p>Instructs the XSU to generate the DTD along with the XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-withSchema</code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t8 r1c2-t8">
<p>Instructs the XSU to generate the schema along with the XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-rowsetTag</code> <code dir="ltr"><span class="codeinlineitalic">tag_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t8 r1c2-t8">
<p>Specifies the rowset tag, which is tag that encloses all the XML elements corresponding to the records returned by the query. The default rowset tag is <code dir="ltr">&lt;ROWSET&gt;</code>. If you specify an empty string ("") for rowset, then XSU omits the rowset element.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-rowTag</code> <code dir="ltr"><span class="codeinlineitalic">tag_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t8 r1c2-t8">
<p>Specifies the row tag that encloses the data corresponding to a database row. The default row tag is <code dir="ltr">&lt;ROW&gt;</code>. If you specify an empty string ("") for the row tag, then XSU omits the row tag.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-rowIdAttr</code> <code dir="ltr"><span class="codeinlineitalic">row_id_attribute_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t8 r1c2-t8">
<p>Names the attribute of the <code dir="ltr">ROW</code> element that keeps track of the cardinality of the <code dir="ltr">rows</code>. By default this attribute is <code dir="ltr">num</code>. If you specify an empty string as the <code dir="ltr">rowID</code> attribute, then XSU omits the attribute.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t8" headers="r1c1-t8">
<p>-<code dir="ltr">rowIdColumn</code> <code dir="ltr"><span class="codeinlineitalic">row_Id_column_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t8 r1c2-t8">
<p>Specifies that the value of one of the scalar columns from the query is to be used as the value of the <code dir="ltr">rowID</code> attribute.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-collectionIdAttr</code> <code dir="ltr"><span class="codeinlineitalic">collect_id_attr_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t8 r1c2-t8">
<p>Names the attribute of an XML list element that keeps track of the cardinality of the elements of the list. The generated XML lists correspond to either a cursor query, or collection. If you specify an empty string ("") as the <code dir="ltr">rowID</code> attribute, then XSU omits the attribute.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-useTypeForCollElemTag</code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t8 r1c2-t8">
<p>Specifies the use type name for the column-element tag. By default XSU uses the <code dir="ltr">column-name_item</code>.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r12c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-useNullAttrId</code></p>
</td>
<td class="cellalignment1213" headers="r12c1-t8 r1c2-t8">
<p>Specifies the attribute <code dir="ltr">NULL (TRUE/FALSE)</code> to indicate the nullness of an element.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r13c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-styleSheet</code> <code dir="ltr"><span class="codeinlineitalic">stylesheet_URI</span></code></p>
</td>
<td class="cellalignment1213" headers="r13c1-t8 r1c2-t8">
<p>Specifies the stylesheet in the XML processing instruction.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r14c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-stylesheetType</code> <code dir="ltr"><span class="codeinlineitalic">stylesheet_type</span></code></p>
</td>
<td class="cellalignment1213" headers="r14c1-t8 r1c2-t8">
<p>Specifies the stylesheet type in the XML processing instruction.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r15c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-setXSLT</code> <code dir="ltr"><span class="codeinlineitalic">URI</span></code></p>
</td>
<td class="cellalignment1213" headers="r15c1-t8 r1c2-t8">
<p>Specifies the XSLT stylesheet to apply to the XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r16c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-setXSLTRef</code> <code dir="ltr"><span class="codeinlineitalic">URI</span></code></p>
</td>
<td class="cellalignment1213" headers="r16c1-t8 r1c2-t8">
<p>Sets the XSLT external entity reference.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r17c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-useLowerCase | -useUpperCase</code></p>
</td>
<td class="cellalignment1213" headers="r17c1-t8 r1c2-t8">
<p>Generates lowercase or uppercase tag names. The default is to match the case of the SQL object names from which the tags are generated.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r18c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-withEscaping</code></p>
</td>
<td class="cellalignment1213" headers="r18c1-t8 r1c2-t8">
<p>Specifies the treatment of characters that are legal in SQL object names but illegal in XML tags. If such a character is encountered, then it is escaped so that it does not throw an exception.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r19c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-errorTag</code> <code dir="ltr"><span class="codeinlineitalic">error tag_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r19c1-t8 r1c2-t8">
<p>Specifies the tag to enclose error messages that are formatted as XML.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r20c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-raiseException</code></p>
</td>
<td class="cellalignment1213" headers="r20c1-t8 r1c2-t8">
<p>Specifies that XSU should throw a Java exception. By default XSU catches any error and produces the XML error.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r21c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-raiseNoRowsException</code></p>
</td>
<td class="cellalignment1213" headers="r21c1-t8 r1c2-t8">
<p>Raises an exception if no rows are returned.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r22c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-useStrictLegalXMLCharCheck</code></p>
</td>
<td class="cellalignment1213" headers="r22c1-t8 r1c2-t8">
<p>Performs strict checking on input data.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r23c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-maxRows</code> <code dir="ltr"><span class="codeinlineitalic">maximum_rows</span></code></p>
</td>
<td class="cellalignment1213" headers="r23c1-t8 r1c2-t8">
<p>Specifies the maximum number of rows to be retrieved and converted to XML.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r24c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-skipRows</code> <code dir="ltr"><span class="codeinlineitalic">number_of_rows_to_skip</span></code></p>
</td>
<td class="cellalignment1213" headers="r24c1-t8 r1c2-t8">
<p>Specifies the number of rows to be skipped.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r25c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-encoding</code> <code dir="ltr"><span class="codeinlineitalic">encoding_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r25c1-t8 r1c2-t8">
<p>Specifies the character set encoding of the generated XML.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r26c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-dateFormat</code> <code dir="ltr"><span class="codeinlineitalic">date_format</span></code></p>
</td>
<td class="cellalignment1213" headers="r26c1-t8 r1c2-t8">
<p>Specifies the date format for the date values in the XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r27c1-t8" headers="r1c1-t8">
<p><code dir="ltr">-fileName</code> <code dir="ltr"><span class="codeinlineitalic">SQL_query_fileName</span></code> | <code dir="ltr"><span class="codeinlineitalic">SQL_query</span></code></p>
</td>
<td class="cellalignment1213" headers="r27c1-t8 r1c2-t8">
<p>Specifies the file name that contains the query or the query itself.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a href="#BABEFCDB">Table 11-3</a> describes the <code dir="ltr">putXML</code> options.</p>
<div id="ADXDK19415" class="tblformalwide">
<p class="titleintable"><a id="sthref303"></a><a id="BABEFCDB"></a>Table 11-3 putXML Options</p>
<table class="cellalignment1211" title="putXML Options " summary="putXML Option and Description are the columns." dir="ltr">
<thead>
<tr class="cellalignment1205">
<th class="cellalignment1212" id="r1c1-t9">putXML Options</th>
<th class="cellalignment1212" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r2c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-user "</code><code dir="ltr"><span class="codeinlineitalic">username</span></code>/<code dir="ltr"><span class="codeinlineitalic">password"</span></code></p>
</td>
<td class="cellalignment1213" headers="r2c1-t9 r1c2-t9">
<p>Specifies the username and password to connect to the database. If not specified, the user defaults to <code dir="ltr">scott/tiger</code>. The connect string is also specified; you can specify the username and password as part of the connect string.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r3c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-conn</code> <code dir="ltr"><span class="codeinlineitalic">"JDBC_connect_string"</span></code></p>
</td>
<td class="cellalignment1213" headers="r3c1-t9 r1c2-t9">
<p>Specifies the JDBC database connect string. By default the connect string is: "<code dir="ltr">jdbc:oracle:oci:@</code>".</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r4c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-batchSize</code> <code dir="ltr"><span class="codeinlineitalic">batching_size</span></code></p>
</td>
<td class="cellalignment1213" headers="r4c1-t9 r1c2-t9">
<p>Specifies the batch size that controls the number of rows that are batched together and inserted in a single trip to the database to improve performance.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r5c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-commitBatch</code> <code dir="ltr"><span class="codeinlineitalic">commit_size</span></code></p>
</td>
<td class="cellalignment1213" headers="r5c1-t9 r1c2-t9">
<p>Specifies the number of inserted records after which a commit is to be executed. If the autocommit is <code dir="ltr">TRUE</code> (the default), then setting <code dir="ltr">commitBatch</code> has no consequence.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r6c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-rowTag</code> <code dir="ltr"><span class="codeinlineitalic">tag_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r6c1-t9 r1c2-t9">
<p>Specifies the <code dir="ltr">row</code> tag, which is tag used to enclose the data corresponding to a database row. The default row tag is <code dir="ltr">&lt;ROW&gt;</code>. If you specify an empty string for the row tag, then XSU omits the row tag.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r7c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-dateFormat</code> <code dir="ltr"><span class="codeinlineitalic">date_format</span></code></p>
</td>
<td class="cellalignment1213" headers="r7c1-t9 r1c2-t9">
<p>Specifies the date format for the date values in the XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r8c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-withEscaping</code></p>
</td>
<td class="cellalignment1213" headers="r8c1-t9 r1c2-t9">
<p>Turns on reverse mapping if SQL to XML name escaping was used when generating the doc.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r9c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-ignoreCase</code></p>
</td>
<td class="cellalignment1213" headers="r9c1-t9 r1c2-t9">
<p>Makes the matching of the column names with tag names case insensitive. For example, <code dir="ltr">EmpNo</code> matches with <code dir="ltr">EMPNO</code> if <code dir="ltr">ignoreCase</code> is on.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r10c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-preserveWhitespace</code></p>
</td>
<td class="cellalignment1213" headers="r10c1-t9 r1c2-t9">
<p>Preserves the whitespace in the inserted XML document.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r11c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-setXSLT</code> <code dir="ltr"><span class="codeinlineitalic">URI</span></code></p>
</td>
<td class="cellalignment1213" headers="r11c1-t9 r1c2-t9">
<p>Specifies the XSLT to apply to the XML document before inserting.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r12c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-setXSLTRef</code> <code dir="ltr"><span class="codeinlineitalic">URI</span></code></p>
</td>
<td class="cellalignment1213" headers="r12c1-t9 r1c2-t9">
<p>Sets the XSLT external entity reference.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r13c1-t9" headers="r1c1-t9">
<p><code dir="ltr">-fileName</code> <code dir="ltr"><span class="codeinlineitalic">file_name</span></code> | <code dir="ltr">-URL</code> <code dir="ltr"><span class="codeinlineitalic">URL</span></code> | <code dir="ltr">-xmlDoc</code> <code dir="ltr"><span class="codeinlineitalic">xml_document</span></code></p>
</td>
<td class="cellalignment1213" headers="r13c1-t9 r1c2-t9">
<p>Specifies the XML document to insert: a local file, a URL, or an XML document as a string on the command line.</p>
</td>
</tr>
<tr class="cellalignment1205">
<td class="cellalignment1213" id="r14c1-t9" headers="r1c1-t9">
<p><code dir="ltr"><span class="codeinlineitalic">table_name</span></code></p>
</td>
<td class="cellalignment1213" headers="r14c1-t9 r1c2-t9">
<p>Specifies the name of the table to put the values into.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<a id="BABCAGJH"></a>
<div id="ADXDK19416" class="sect3">
<h4 class="sect3">Generating XML with the XSU Command-Line Utility<a id="sthref304"></a><a id="sthref305"></a><a id="sthref306"></a><a id="sthref307"></a><a id="sthref308"></a></h4>
<p>To generate XML from the database schema use the <code dir="ltr">getXML</code> parameter. For example, to generate an XML document by querying the <code dir="ltr">employees</code> table in the <code dir="ltr">hr</code> schema, you can use the following syntax:</p>
<pre dir="ltr">
java OracleXML getXML -user "hr/<span class="italic">password</span>" "SELECT * FROM employees"
</pre>
<p>The preceding command performs the following tasks:</p>
<ol>
<li>
<p>Connects to the current default database</p>
</li>
<li>
<p>Executes the specified <code dir="ltr">SELECT</code> query</p>
</li>
<li>
<p>Converts the SQL result set to XML</p>
</li>
<li>
<p>Prints the XML to standard output</p>
</li>
</ol>
<p>The <code dir="ltr">getXML</code> parameter supports a wide range of options, which are explained in <a href="#BABGDFFJ">Table 11-2</a>.</p>
</div>
<!-- class="sect3" -->
<a id="i1029599"></a>
<div id="ADXDK071" class="sect3">
<h4 class="sect3">Generating XMLType Data with the XSU Command-Line Utility</h4>
<p>You can use XSU to generate XML from tables with <code dir="ltr">XMLType</code> columns. Suppose that you run the demo script <code dir="ltr">setup_xmltype.sql</code> to create and populate the <code dir="ltr">parts</code> table. You can generate XML from this table with XSU as follows:</p>
<pre dir="ltr">
java OracleXML getXML -user "hr/<span class="italic">password</span>" -rowTag "Part" "SELECT * FROM parts"
</pre>
<p>The output of the command is shown below:</p>
<pre dir="ltr">
&lt;?xml version = '1.0'?&gt;
&lt;ROWSET&gt;
   &lt;Part num="1"&gt;
      &lt;PARTNO&gt;1735&lt;/PARTNO&gt;
      &lt;PARTNAME&gt;Gizmo&lt;/PARTNAME&gt;
      &lt;PARTDESC&gt;
         &lt;Description&gt;
           &lt;Title&gt;Description of the Gizmo&lt;/Title&gt;
           &lt;Author&gt;John Smith&lt;/Author&gt;
           &lt;Body&gt;
             The &lt;b&gt;Gizmo&lt;/b&gt; is &lt;i&gt;grand&lt;/i&gt;.
           &lt;/Body&gt;
         &lt;/Description&gt;
      &lt;/PARTDESC&gt;
   &lt;/Part&gt;
&lt;/ROWSET&gt;
</pre></div>
<!-- class="sect3" -->
<div id="ADXDK19417" class="sect3"><a id="sthref309"></a>
<h4 class="sect3">Performing DML with the XSU Command-Line Utility</h4>
<p>To insert an XML document called <code dir="ltr">new_employees.xml</code> into the <code dir="ltr">hr.employees</code> table, use the following syntax:</p>
<pre dir="ltr">
java OracleXML putXML -user "hr/<span class="italic">password</span>" -fileName "new_employees.xml" employees
</pre>
<p>The preceding command performs the following tasks:</p>
<ol>
<li>
<p>Connects to the current database as <code dir="ltr">hr</code></p>
</li>
<li>
<p>Reads the XML document named <code dir="ltr">new_emp.xml</code></p>
</li>
<li>
<p>Parses the XML document, matching the tags with column names</p>
</li>
<li>
<p>Inserts the values appropriately into the <code dir="ltr">employees</code> table</p>
</li>
</ol>
<p>The <code dir="ltr">getXML</code> parameter supports a wide range of options, which are explained in <a href="#BABGDFFJ">Table 11-2</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008145"></a>
<div id="ADXDK19418" class="sect1">
<h2 class="sect1">Programming with the XSU Java API</h2>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABBJBFB">Generating a String with OracleXMLQuery</a></p>
</li>
<li>
<p><a href="#BABHHECH">Generating a DOM Tree with OracleXMLQuery</a></p>
</li>
<li>
<p><a href="#i1008350">Paginating Results with OracleXMLQuery</a></p>
</li>
<li>
<p><a href="#BABJABDF">Generating Scrollable Result Sets</a></p>
</li>
<li>
<p><a href="#BABHHBBG">Generating XML from Cursor Objects</a></p>
</li>
<li>
<p><a href="#BABBBIFA">Inserting Rows with OracleXMLSave</a></p>
</li>
<li>
<p><a href="#BABEJABF">Updating Rows with OracleXMLSave</a></p>
</li>
<li>
<p><a href="#BABJDBHE">Deleting Rows with OracleXMLSave</a></p>
</li>
<li>
<p><a href="#BABGHFFC">Handling XSU Java Exceptions</a></p>
</li>
</ul>
<a id="BABBJBFB"></a>
<div id="ADXDK19419" class="sect2">
<h3 class="sect2">Generating a String with OracleXMLQuery</h3>
<p>The <code dir="ltr">testXMLSQL.java</code> demo program uses XSU to generate XML as a <code dir="ltr">String</code> object. This program queries the <code dir="ltr">hr.employees</code> table and prints the result set to standard output.</p>
<p>The <code dir="ltr">testXMLSQL.java</code> program follows these steps:</p>
<ol>
<li>
<p>Register the JDBC driver and create a database connection. The following code fragment uses the OCI JDBC driver and connects with the username <code dir="ltr">hr</code>:</p>
<pre dir="ltr">
import oracle.jdbc.*;...Connection conn  = getConnection("hr","<span class="italic">password</span>");
...
private static Connection getConnection(String username, String password)
    throws SQLException
{
// register the JDBC driver
  DriverManager.registerDriver(new oracle.jdbc.OracleDriver()); 
// create the connection using the OCI driver
  Connection conn =
    DriverManager.getConnection("jdbc:oracle:oci:@",username,password);
  return conn;
}
</pre></li>
<li>
<p>Create an XML query object and initialize it with a SQL query. The following code fragment initializes the object with a <code dir="ltr">SELECT</code> statement on <code dir="ltr">hr.employees</code>:</p>
<pre dir="ltr">
OracleXMLQuery qry = new OracleXMLQuery(conn, "SELECT * FROM employees");
</pre></li>
<li>
<p>Obtain the query result set as a <code dir="ltr">String</code> object. The <code dir="ltr">getXMLString()</code> method transforms the object-relational data specified in the constructor into an XML document. The following example illustrates this technique:</p>
<pre dir="ltr">
String str = qry.getXMLString();
</pre></li>
<li>
<p>Close the query object to release any resources, as shown in the following code:</p>
<pre dir="ltr">
qry.close();
</pre></li>
</ol>
<div id="ADXDK19420" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref310"></a>
<h4 class="sect3">Running the testXMLSQL Program</h4>
<p>To run the <code dir="ltr">testXMLSQL.java</code> program perform the following steps:</p>
<ol>
<li>
<p>Compile <code dir="ltr">testXMLSQL.java</code> with <code dir="ltr">javac</code>.</p>
</li>
<li>
<p>Execute <code dir="ltr">java testXMLSQL</code> on the command line.</p>
</li>
</ol>
<p>You must have the <code dir="ltr">CLASSPATH</code> pointing to this directory for the Java executable to find the class. Alternatively, use visual Java tools such as Oracle JDeveloper to compile and run this program. When run, this program prints out the XML file to the screen. The following shows sample output with some rows edited out:</p>
<pre dir="ltr">
&lt;?xml version = '1.0'?&gt;
&lt;ROWSET&gt;
   &lt;ROW num="1"&gt;
      &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
      &lt;FIRST_NAME&gt;Steven&lt;/FIRST_NAME&gt;
      &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
      &lt;EMAIL&gt;SKING&lt;/EMAIL&gt;
      &lt;PHONE_NUMBER&gt;515.123.4567&lt;/PHONE_NUMBER&gt;
      &lt;HIRE_DATE&gt;6/17/1987 0:0:0&lt;/HIRE_DATE&gt;
      &lt;JOB_ID&gt;AD_PRES&lt;/JOB_ID&gt;
      &lt;SALARY&gt;24000&lt;/SALARY&gt;
      &lt;DEPARTMENT_ID&gt;90&lt;/DEPARTMENT_ID&gt;
   &lt;/ROW&gt;
&lt;!-- ROW num="2" through num="107" ... --&gt;
&lt;/ROWSET&gt;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABHHECH"></a>
<div id="ADXDK19421" class="sect2">
<h3 class="sect2">Generating a DOM Tree with OracleXMLQuery</h3>
<p>To generate a DOM tree from the XML generated by XSU, you can directly request a DOM document from XSU. This technique saves the overhead of creating a string representation of the XML document and then parsing it to generate the DOM tree.</p>
<p>XSU calls the Oracle XML parser to construct the DOM tree from the data values. The <code dir="ltr">domTest.java</code> demo program generates a DOM tree and then traverses it in document order, printing the nodes one by one.</p>
<p>The first two steps in the <code dir="ltr">domTest.java</code> program are the same as for the <code dir="ltr">testXMLSQL.java</code> program described in <a href="#BABBJBFB">"Generating a String with OracleXMLQuery"</a>. The program proceeds as follows:</p>
<ol>
<li>
<p>Obtain the DOM by invoking <code dir="ltr">getXMLDOM()</code> method. The following example illustrates this technique:</p>
<pre dir="ltr">
XMLDocument domDoc = (XMLDocument)qry.getXMLDOM();
</pre></li>
<li>
<p>Print the DOM tree. The following code prints to standard output:</p>
<pre dir="ltr">
domDoc.print(System.out);
</pre>
<p>You can also create a <code dir="ltr">StringWriter</code> and wrap it in a <code dir="ltr">PrintWriter</code> as follows:</p>
<pre dir="ltr">
StringWriter s = new StringWriter(10000);
domDoc.print(new PrintWriter(s));
System.out.println(" The string version ---&gt; \n"+s.toString());
</pre></li>
</ol>
<p>After compiling the program, run it from the command line as follows:</p>
<pre dir="ltr">
java domTest
</pre></div>
<!-- class="sect2" -->
<a id="i1008350"></a>
<div id="ADXDK19422" class="sect2">
<h3 class="sect2">Paginating Results with OracleXMLQuery</h3>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BABEAHED">Limiting the Number of Rows in the Result Set</a></p>
</li>
<li>
<p><a href="#BABDIEGC">Keeping the Object Open for the Duration of the User's Session</a></p>
</li>
<li>
<p><a href="#i1016651">Paginating Results with OracleXMLQuery: Example</a></p>
</li>
</ul>
<a id="BABEAHED"></a>
<div id="ADXDK19423" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Limiting the Number of Rows in the Result Set</h4>
<p>In <code dir="ltr">testXMLSQL.java</code> and <code dir="ltr">domTest.java</code>, XSU generated XML from all rows returned by the query. Suppose that you query a table that contains 1000 rows, but you want only 100 rows at a time. One approach is to execute one query to obtain the first 100 rows, another to obtain the next 100 rows, and so on. With this technique you cannot skip the first five rows of the query and then generate the result. To avoid these problems, use the following Java methods:</p>
<ul>
<li>
<p><code dir="ltr">OracleXMLSave.setSkipRows()</code> forces XSU to skip the desired number of rows before starting to generate the result. The command-line equivalent to this method is the <code dir="ltr">-skipRows</code> parameter.</p>
</li>
<li>
<p><code dir="ltr">OracleXMLSave.setMaxRows()</code> limits the number of rows converted to XML. The command-line equivalent to this method is the <code dir="ltr">-maxRows</code> parameter.</p>
</li>
</ul>
<p><a href="#BABHCFIG">Example 11-1</a> sets <code dir="ltr">skipRows</code> to a value of <code dir="ltr">5</code> and <code dir="ltr">maxRows</code> to a value of <code dir="ltr">1</code>, which causes XSU to skip the first 5 rows and then generate XML for the next row when querying the <code dir="ltr">hr.employees</code> table.</p>
<div id="ADXDK19424" class="example">
<p class="titleinexample"><a id="BABHCFIG"></a>Example 11-1 Specifying skipRows and maxRows on the Command Line</p>
<pre dir="ltr">
java OracleXML getXML -user "hr/<span class="italic">password</span>" -skipRows 5 -maxRows 1 \
  "SELECT * FROM employees"
</pre></div>
<!-- class="example" -->
<p>The following shows sample output (only row 6 of the query result set is returned):</p>
<pre dir="ltr">
&lt;?xml version = '1.0'?&gt;
&lt;ROWSET&gt;
   &lt;ROW num="6"&gt;
      &lt;EMPLOYEE_ID&gt;105&lt;/EMPLOYEE_ID&gt;
      &lt;FIRST_NAME&gt;David&lt;/FIRST_NAME&gt;
      &lt;LAST_NAME&gt;Austin&lt;/LAST_NAME&gt;
      &lt;EMAIL&gt;DAUSTIN&lt;/EMAIL&gt;
      &lt;PHONE_NUMBER&gt;590.423.4569&lt;/PHONE_NUMBER&gt;
      &lt;HIRE_DATE&gt;6/25/1997 0:0:0&lt;/HIRE_DATE&gt;
      &lt;JOB_ID&gt;IT_PROG&lt;/JOB_ID&gt;
      &lt;SALARY&gt;4800&lt;/SALARY&gt;
      &lt;MANAGER_ID&gt;103&lt;/MANAGER_ID&gt;
      &lt;DEPARTMENT_ID&gt;60&lt;/DEPARTMENT_ID&gt;
   &lt;/ROW&gt;
&lt;/ROWSET&gt;
</pre></div>
<!-- class="sect3" -->
<a id="BABDIEGC"></a>
<div id="ADXDK19425" class="sect3">
<h4 class="sect3">Keeping the Object Open for the Duration of the User's Session</h4>
<p>In some situations you may want to keep the query object open for the duration of the user session. You can handle such cases with the <code dir="ltr">maxRows()</code> method and the <code dir="ltr">keepObjectOpen()</code> method.</p>
<p>Consider a Web search engine that paginates search results. The first page lists 10 results, the next page lists 10 more, and so on. To perform this task with XSU, request 10 rows at a time and keep the <code dir="ltr">ResultSet</code> open so that the next time you ask XSU for more results, it starts generating from where the last generation finished. If <code dir="ltr">OracleXMLQuery</code> creates a result set from the SQL query string, then it typically closes the <code dir="ltr">ResultSet</code> internally because it assumes no more results are required. Thus, you should invoke <code dir="ltr">keepObjectOpen()</code> to keep the cursor active.</p>
<p>A different case requiring an open query object is when the number of rows or number of columns in a row is very large. In this case, you can generate multiple small documents rather than one large document.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1016651">"Paginating Results with OracleXMLQuery: Example"</a></div>
</div>
<!-- class="sect3" -->
<a id="i1016651"></a>
<div id="ADXDK19426" class="sect3">
<h4 class="sect3">Paginating Results with OracleXMLQuery: Example</h4>
<p>The <code dir="ltr">paginateResults.java</code> program shows how you can generate an XML page that paginates results. The output XML displays only 20 rows of the <code dir="ltr">hr</code> table.</p>
<p>The first step of the <code dir="ltr">paginateResults.java</code> program, which creates the connection, is the same as in <code dir="ltr">testXMLSQL.java</code>. The program continues as follows:</p>
<ol>
<li>
<p>Create a SQL statement object and initialize it with a SQL query. The following code fragment sets two options in <code dir="ltr">java.sql.ResultSet</code>:</p>
<pre dir="ltr">
Statement stmt = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, 
                                      ResultSet.CONCUR_READ_ONLY);
</pre></li>
<li>
<p>Create the query as a string and execute it by invoking <code dir="ltr">Statement.executeQuery()</code>. The return object is of type <code dir="ltr">ResultSet</code>. The following example illustrates this technique:</p>
<pre dir="ltr">
String sCmd = "SELECT first_name, last_name FROM hr.employees"; 
ResultSet rs = stmt.executeQuery(sCmd); 
</pre></li>
<li>
<p>Create the query object, as shown in the following code:</p>
<pre dir="ltr">
OracleXMLQuery xmlQry = new OracleXMLQuery(conn, rs);
</pre></li>
<li>
<p>Configure the query object. The following code specifies that the query object should be open for the duration of the session. It also limits the number of rows returned to 20:</p>
<pre dir="ltr">
xmlQry.keepObjectOpen(true); 
xmlQry.setRowsetTag("ROWSET"); 
xmlQry.setRowTag("ROW"); 
xmlQry.setMaxRows(20); 
</pre></li>
<li>
<p>Retrieve the result as a <code dir="ltr">String</code> and print:</p>
<pre dir="ltr">
String sXML = xmlQry.getXMLString(); 
System.out.println(sXML);
</pre></li>
</ol>
<p>After compiling the program, run it from the command line as follows:</p>
<pre dir="ltr">
java paginateResults
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJABDF"></a>
<div id="ADXDK19427" class="sect2">
<h3 class="sect2">Generating Scrollable Result Sets</h3>
<p>In some situations you may want to perform a query and then retrieve a previous page of results from within the result set. To enable scrolling, instantiate the <code dir="ltr">Oracle.jdbc.ResultSet</code> class. You can use the <code dir="ltr">ResultSet</code> object to move back and forth within the result set and use XSU to generate XML each time.</p>
<p>The <code dir="ltr">pageTest.java</code> program shows how to use the JDBC <code dir="ltr">ResultSet</code> to generate XML a page at a time. Using <code dir="ltr">ResultSet</code> may be necessary in cases that are not handled directly by XSU, for example, when setting the batch size and binding values.</p>
<p>The <code dir="ltr">pageTest.java</code> program creates a <code dir="ltr">pageTest</code> object and initializes it with a SQL query. The constructor for the <code dir="ltr">pageTest</code> object performs the following steps:</p>
<ol>
<li>
<p>Create a JDBC connection by calling the same <code dir="ltr">getConnection()</code> method defined in <code dir="ltr">paginateResults.java</code>:</p>
<pre dir="ltr">
Connection conn;
...
conn  = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create a statement as follows:</p>
<pre dir="ltr">
Statement stmt;
...
stmt = conn.createStatement();
</pre></li>
<li>
<p>Execute the query passed to the constructor to obtain the scrollable result set. The following code illustrates this technique:</p>
<pre dir="ltr">
ResultSet rset = stmt.executeQuery(sqlQuery);
</pre></li>
<li>
<p>Create a query object by passing references to the connection and result set objects to the constructor. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
OracleXMLQuery qry;
...
qry = new OracleXMLQuery(conn,rset); 
</pre></li>
<li>
<p>Configure the query object. The following code fragment specifies that the query object should be kept open and that it should raise an exception when there are no more rows:</p>
<pre dir="ltr">
qry.keepObjectOpen(true);
qry.setRaiseNoRowsException(true);
qry.setRaiseException(true);
</pre></li>
<li>
<p>After creating the query object by passing it the string <code dir="ltr">"SELECT * FROM employees"</code>, the program loops through the result set. The <code dir="ltr">getResult()</code> method receives integer values specifying the start row and end row of the set. It sets the maximum number of rows to retrieve by calculating the difference of these values and then retrieves the result as a string. The following <code dir="ltr">while</code> loop retrieves and prints ten rows at a time:</p>
<pre dir="ltr">
int i = 0;
while ((str = test.getResult(i,i+10))!= null)
{
  System.out.println(str);
  i+= 10;
}
</pre></li>
</ol>
<p>After compiling the program, run it from the command line as follows:</p>
<pre dir="ltr">
java pageTest
</pre></div>
<!-- class="sect2" -->
<a id="BABHHBBG"></a>
<div id="ADXDK19428" class="sect2">
<h3 class="sect2">Generating XML from Cursor Objects</h3>
<p>The <code dir="ltr">OracleXMLQuery</code> class provides XML conversion only for query strings or <code dir="ltr">ResultSet</code> objects. If your program uses PL/SQL procedures that return <code dir="ltr">REF</code> cursors, then how do you perform the conversion? You can use the <code dir="ltr">ResultSet</code> conversion mechanism described in <a href="#BABJABDF">"Generating Scrollable Result Sets"</a>.</p>
<p><code dir="ltr">REF</code> cursors are references to cursor objects in PL/SQL. These cursor objects are SQL statements over which a program can iterate to obtain a set of values. The cursor objects are converted into <code dir="ltr">OracleResultSet</code> objects in the Java world. In your Java program you can initialize a <code dir="ltr">CallableStatement</code> object, execute a PL/SQL function that returns a cursor variable, obtain the <code dir="ltr">OracleResultSet</code> object, and then send it to the <code dir="ltr">OracleXMLQuery</code> object to obtain the desired XML.</p>
<p>Consider the <code dir="ltr">testRef</code> PL/SQL package defined in the <code dir="ltr">testRef.sql</code> script. It creates a function that defines a <code dir="ltr">REF</code> cursor and returns it. Every time the <code dir="ltr">testRefCur</code> PL/SQL function is called, it opens a cursor object for the <code dir="ltr">SELECT</code> query and returns that cursor instance. To convert the object to XML, do the following:</p>
<ol>
<li>
<p>Run the <code dir="ltr">testRef.sql</code> script to create the <code dir="ltr">testRef</code> package in the <code dir="ltr">hr</code> schema.</p>
</li>
<li>
<p>Compile and run the <code dir="ltr">refCurTest.java</code> program to generate XML from the results of the SQL query defined in the <code dir="ltr">testRefCur</code> function.</p>
</li>
</ol>
<p>To apply the stylesheet, you can use the <code dir="ltr">applyStylesheet</code> command, which forces the stylesheet to be applied before generating the output.</p>
</div>
<!-- class="sect2" -->
<a id="BABBBIFA"></a>
<div id="ADXDK19429" class="sect2">
<h3 class="sect2">Inserting Rows with OracleXMLSave</h3>
<p>To insert a document into a table or view, supply the table or view name and then the document. XSU parses the document (if a string is given) and then creates an <code dir="ltr">INSERT</code> statement into which it binds all the values. By default XSU inserts values into all columns of the table or view. An absent element is treated as a <code dir="ltr">NULL</code> value. The following example shows how you can store the XML document generated from the <code dir="ltr">hr.employees</code> table in the table.</p>
<a id="BABEFGAJ"></a>
<div id="ADXDK19430" class="sect3">
<h4 class="sect3">Inserting XML into All Columns with OracleXMLSave</h4>
<p>The <code dir="ltr">testInsert.java</code> demo program inserts XML values into all columns of the <code dir="ltr">hr.employees</code> table.</p>
<p>The program follows these steps:</p>
<ol>
<li>
<p>Create a JDBC OCI connection. The program calls the same <code dir="ltr">getConnection()</code> method used by the previous examples in this chapter:</p>
<pre dir="ltr">
Connection conn = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create an XML save object. You initialize the object by passing it the <code dir="ltr">Connection</code> reference and the name of the table on which you want to perform DML. The following example illustrates this technique:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Insert the data in an input XML document into the <code dir="ltr">hr.employees</code> table. The following code fragment creates a URL from the document filename specified on the command line:</p>
<pre dir="ltr">
sav.insertXML(sav.getURL(argv[0]));
</pre></li>
<li>
<p>Close the XML save object as follows:</p>
<pre dir="ltr">
sav.close();
</pre></li>
</ol>
<a id="BABGAFGD"></a>
<div id="ADXDK19431" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Running the testInsert Program</h5>
<p>Assume that you write the <code dir="ltr">new_emp.xml</code> document to describe new employee Janet Smith, who has employee ID 7369. You pass the filename <code dir="ltr">new_emp.xml</code> as an argument to the <code dir="ltr">testInsert</code> program as follows:</p>
<pre dir="ltr">
java testInsert "new_emp.xml"
</pre>
<p>The program inserts a new row in the <code dir="ltr">employees</code> table that contains the values for the columns specified. Any absent element inside the row element is treated as <code dir="ltr">NULL</code>.</p>
<p>Running the program generates an <code dir="ltr">INSERT</code> statement of the following form:</p>
<pre dir="ltr">
INSERT INTO hr.employees 
  (employee_id, first_name, last_name, email, phone_number, hire_date, 
   salary, commission_pct, manager_id, department_id)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);     
</pre>
<p>XSU matches the element tags in the input XML document that match the column names and binds their values.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABGEIIF"></a>
<div id="ADXDK19432" class="sect3">
<h4 class="sect3">Inserting XML into a Subset of Columns with OracleXMLSave</h4>
<p>In some circumstances you may not want to insert values into all columns. For example, the group of values that you obtain may not be the complete set, requiring you to use triggers or default values for the remaining columns. The <code dir="ltr">testInsertSubset.java</code> demo program shows how to handle this case.</p>
<p>The program follows these steps:</p>
<ol>
<li>
<p>Create a JDBC OCI connection. The program calls the same <code dir="ltr">getConnection()</code> method used by the previous examples in this chapter:</p>
<pre dir="ltr">
Connection conn = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create an XML save object. Initialize the object by passing it the <code dir="ltr">Connection</code> reference and the name of the table on which you want to perform DML. The following example illustrates this technique:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Create an array of strings. Each element of the array should contain the name of a column in which values will be inserted. The following code fragment specifies the names of five columns:</p>
<pre dir="ltr">
String [] colNames = new String[5];
colNames[0] = "EMPLOYEE_ID";
colNames[1] = "LAST_NAME";
colNames[2] = "EMAIL";
colNames[3] = "JOB_ID";
colNames[4] = "HIRE_DATE";
</pre></li>
<li>
<p>Configure the XML save object to update the specified columns. The following statement passes a reference to the array to the <code dir="ltr">OracleXMLSave.setUpdateColumnList()</code> method:</p>
<pre dir="ltr">
sav.setUpdateColumnList(colNames);
</pre></li>
<li>
<p>Insert the data in an input XML document into the <code dir="ltr">hr.employees</code> table. The following code fragment creates a URL from the document filename specified on the command line:</p>
<pre dir="ltr">
sav.insertXML(sav.getURL(argv[0]));
</pre></li>
<li>
<p>Close the XML save object as follows:</p>
<pre dir="ltr">
sav.close();
</pre></li>
</ol>
<a id="BABGFDEB"></a>
<div id="ADXDK19433" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Running the testInsertSubset Program</h5>
<p>Assume that you use the <code dir="ltr">new_emp2.xml</code> document to store data for new employee Adams, who has employee ID 7400. You pass <code dir="ltr">new_emp2.xml</code> as an argument to the <code dir="ltr">testInsert</code> program as follows:</p>
<pre dir="ltr">
java testInsert new_emp2.xml
</pre>
<p>The program ignores values for the columns that were not specified in the input file. It performs an <code dir="ltr">INSERT</code> for each <code dir="ltr">ROW</code> element in the input and batches the <code dir="ltr">INSERT</code> statements by default.</p>
<p>The program generates the following <code dir="ltr">INSERT</code> statement:</p>
<pre dir="ltr">
INSERT INTO hr.employees (employee_id, last_name, email, job_id, hire_date) 
  VALUES (?, ?, ?, ?, ?);
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABEJABF"></a>
<div id="ADXDK19434" class="sect2">
<h3 class="sect2">Updating Rows with OracleXMLSave</h3>
<p>To update the fields in a table or view, supply the table or view name and then the XML document. XSU parses the document (if a string is given) and then creates one or more <code dir="ltr">UPDATE</code> statements into which it binds all the values. The following examples show how you can use an XML document to update the <code dir="ltr">hr.employees</code> table.</p>
<a id="BABFDCFA"></a>
<div id="ADXDK19435" class="sect3">
<h4 class="sect3">Updating with Key Columns with OracleXMLSave</h4>
<p>The <code dir="ltr">testUpdate.java</code> demo program updates the <code dir="ltr">hr.employees</code> table by invoking the <code dir="ltr">OracleXMLSave.setKeyColumnList()</code> method.</p>
<p>The <code dir="ltr">testUpdate.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a JDBC OCI connection. The program calls the same <code dir="ltr">getConnection()</code> method used by the previous examples in this chapter:</p>
<pre dir="ltr">
Connection conn = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create an XML save object. You initialize the object by passing it the <code dir="ltr">Connection</code> reference and the name of the table on which you want to perform DML. The following example illustrates this technique:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Create a single-element <code dir="ltr">String</code> array to hold the name of the primary key column in the table to be updated. The following code fragment specifies the name of the <code dir="ltr">employee_id</code> column:</p>
<pre dir="ltr">
String [] keyColNames = new String[1];
colNames[0] = "EMPLOYEE_ID";
</pre></li>
<li>
<p>Set the XML save object to the primary key specified in the array. The following statement passes a reference to the <code dir="ltr">keyColNames</code> array to the <code dir="ltr">OracleXMLSave.setKeyColumnList()</code> method:</p>
<pre dir="ltr">
sav.setKeyColumnList(keyColNames);
</pre></li>
<li>
<p>Update the rows specified in the input XML document. The following statement creates a URL from the filename specified on the command line:</p>
<pre dir="ltr">
sav.updateXML(sav.getURL(argv[0]));
</pre></li>
<li>
<p>Close the XML save object as follows:</p>
<pre dir="ltr">
sav.close();
</pre></li>
</ol>
<a id="BABBAEJB"></a>
<div id="ADXDK19436" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Running the testUpdate Program</h5>
<p>You can use XSU to update specified fields in a table. <a href="#BABJCJDJ">Example 11-2</a> shows <code dir="ltr">upd_emp.xml</code>, which contains updated salary and other information for the two employees that you just added, 7369 and 7400.</p>
<div id="ADXDK19437" class="example">
<p class="titleinexample"><a id="BABJCJDJ"></a>Example 11-2 upd_emp.xml</p>
<pre dir="ltr">
&lt;?xml version='1.0'?&gt;
&lt;ROWSET&gt;
 &lt;ROW num="1"&gt;
    &lt;EMPLOYEE_ID&gt;7400&lt;/EMPLOYEE_ID&gt;
    &lt;SALARY&gt;3250&lt;/SALARY&gt;
 &lt;/ROW&gt;
 &lt;ROW num="2"&gt;
    &lt;EMPLOYEE_ID&gt;7369&lt;/EMPLOYEE_ID&gt;
    &lt;JOB_ID&gt;SA_REP&lt;/JOB_ID&gt;
    &lt;MANAGER_ID&gt;145&lt;/MANAGER_ID&gt;
 &lt;/ROW&gt;
&lt;!-- additional rows ... --&gt;
&lt;/ROWSET&gt;
</pre></div>
<!-- class="example" -->
<p>For updates, supply XSU with the list of key column names in the <code dir="ltr">WHERE</code> clause of the <code dir="ltr">UPDATE</code> statement. In the <code dir="ltr">hr.employees</code> table the <code dir="ltr">employee_id</code> column is the key.</p>
<p>Pass the filename <code dir="ltr">upd_emp.xml</code> as an argument to the preceding program as follows:</p>
<pre dir="ltr">
java testUpdate upd_emp.xml
</pre>
<p>The program generates two <code dir="ltr">UPDATE</code> statements. For the first <code dir="ltr">ROW</code> element, the program generates an <code dir="ltr">UPDATE</code> statement to update the <code dir="ltr">SALARY</code> field as follows:</p>
<pre dir="ltr">
UPDATE hr.employees SET salary = 3250 WHERE employee_id = 7400;
</pre>
<p>For the second <code dir="ltr">ROW</code> element the program generates the following statement:</p>
<pre dir="ltr">
UPDATE hr.employees SET job_id = 'SA_REP' AND MANAGER_ID = 145 
  WHERE employee_id = 7369;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABHIECJ"></a>
<div id="ADXDK19438" class="sect3">
<h4 class="sect3">Updating a Column List with OracleXMLSave</h4>
<p>You may want to update a table by using only a subset of the elements in an XML document. You can achieve this goal by specifying a list of columns. This technique speeds processing because XSU uses the same <code dir="ltr">UPDATE</code> statement with bind variables for all the <code dir="ltr">ROW</code> elements. You can also ignore other tags in the XML document.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you specify a list of columns to update, if an element corresponding to one of the update columns is absent, XSU treats it as <code dir="ltr">NULL</code>.</div>
<p>Suppose you want to update the salary and job title for each employee and ignore the other data. If you know that all the elements to be updated are the same for all <code dir="ltr">ROW</code> elements in the XML document, then you can use the <code dir="ltr"><a id="sthref311"></a>OracleXMLSave.setUpdateColumnNames()</code> method to specify the columns. The <code dir="ltr">testUpdateList.java</code> program illustrates this technique.</p>
<p>The <code dir="ltr">testUpdateList.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a JDBC OCI connection. The program calls the same <code dir="ltr">getConnection()</code> method used by the previous examples in this chapter:</p>
<pre dir="ltr">
Connection conn = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create an XML save object. You initialize the object by passing it the <code dir="ltr">Connection</code> reference and the name of the table on which you want to perform DML. The following example illustrates this technique:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Create an array of type <code dir="ltr">String</code> to hold the name of the primary key column in the table to be updated. The array contains only one element, which is the name of the primary key column in the table to be updated. The following code fragment specifies the name of the <code dir="ltr">employee_id</code> column:</p>
<pre dir="ltr">
String [] colNames = new String[1];
colNames[0] = "EMPLOYEE_ID";
</pre></li>
<li>
<p>Set the XML save object to the primary key specified in the array. The following statement passes a reference to the <code dir="ltr">colNames</code> array to the <code dir="ltr">OracleXMLSave.setKeyColumnList()</code> method:</p>
<pre dir="ltr">
sav.setKeyColumnList(keyColNames);
</pre></li>
<li>
<p>Create an array of type <code dir="ltr">String</code> to hold the name of the columns to be updated. The following code fragment specifies the name of the <code dir="ltr">employee_id</code> column:</p>
<pre dir="ltr">
String[] updateColNames = new String[2];
updateColNames[0] = "SALARY";
updateColNames[1] = "JOB_ID";
</pre></li>
<li>
<p>Set the XML save object to the list of columns to be updated. The following statement performs this task:</p>
<pre dir="ltr">
sav.setUpdateColumnList(updateColNames);
</pre></li>
<li>
<p>Update the rows specified in the input XML document. The following code fragment creates a URL from the filename specified on the command line:</p>
<pre dir="ltr">
sav.updateXML(sav.getURL(argv[0]));
</pre></li>
<li>
<p>Close the XML save object as follows:</p>
<pre dir="ltr">
sav.close();
</pre></li>
</ol>
<a id="BABCDJEH"></a>
<div id="ADXDK19439" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Running the testUpdateList Program</h5>
<p>Suppose that you use the sample XML document <code dir="ltr">upd_emp2.xml</code> to store new data for employees Steven King, who has an employee ID of 100, and William Gietz, who has an employee ID of 206. You pass <code dir="ltr">upd_emp2.xml</code> as an argument to the <code dir="ltr">testUpdateList</code> program as follows:</p>
<pre dir="ltr">
java testUpdateList upd_emp2.xml
</pre>
<p>In this example, the program generates two <code dir="ltr">UPDATE</code> statements. For the first <code dir="ltr">ROW</code> element, the program generates the following statement:</p>
<pre dir="ltr">
UPDATE hr.employees SET salary = 8350 AND job_id = 'AC_ACCOUNT' 
  WHERE employee_id = 100;
</pre>
<p>For the second <code dir="ltr">ROW</code> element the program generates the following statement:</p>
<pre dir="ltr">
UPDATE hr.employees SET salary = 25000 AND job_id = 'AD_PRES' 
  WHERE employee_id = 206;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJDBHE"></a>
<div id="ADXDK19440" class="sect2">
<h3 class="sect2">Deleting Rows with OracleXMLSave</h3>
<p>When deleting from XML documents, you can specify a list of key columns. XSU uses these columns in the <code dir="ltr">WHERE</code> clause of the <code dir="ltr">DELETE</code> statement. If you do not supply the key column names, then XSU creates a new <code dir="ltr">DELETE</code> statement for each <code dir="ltr">ROW</code> element of the XML document. The list of columns in the <code dir="ltr">WHERE</code> clause of the <code dir="ltr">DELETE</code> statement matches those in the <code dir="ltr">ROW</code> element.</p>
<a id="BABEEFFI"></a>
<div id="ADXDK19441" class="sect3">
<h4 class="sect3">Deleting by Row with OracleXMLSave</h4>
<p>The <code dir="ltr">testDeleteRow.java</code> demo program accepts an XML document filename as input and deletes the rows corresponding to the elements in the document.</p>
<p>The <code dir="ltr">testDeleteRow.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a JDBC OCI connection. The program calls the same <code dir="ltr">getConnection()</code> method used by the previous examples in this chapter:</p>
<pre dir="ltr">
Connection conn = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create an XML save object. You initialize the object by passing it the <code dir="ltr">Connection</code> reference and the name of the table on which you want to perform DML. The following example illustrates this technique:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Delete the rows specified in the input XML document. The following code fragment creates a URL from the filename specified on the command line:</p>
<pre dir="ltr">
sav.deleteXML(sav.getURL(argv[0]));
</pre></li>
<li>
<p>Close the XML save object as follows:</p>
<pre dir="ltr">
sav.close();
</pre></li>
</ol>
<div id="ADXDK19442" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref312"></a>
<h5 class="sect4">Running the testDelete Program</h5>
<p>Suppose that you want to delete the employees 7400 and 7369 that you added in <a href="#BABBBIFA">"Inserting Rows with OracleXMLSave"</a>.</p>
<p>To make this example work correctly, connect to the database and disable a constraint on the <code dir="ltr">hr.job_history</code> table:</p>
<pre dir="ltr">
CONNECT hr
ALTER TABLE job_history
  DISABLE CONSTRAINT JHIST_EMP_FK;
EXIT
</pre>
<p>Now pass <code dir="ltr">upd_emp.xml</code> to the <code dir="ltr">testDeleteRow</code> program as follows:</p>
<pre dir="ltr">
java testDeleteRow upd_emp.xml
</pre>
<p>The program forms the <code dir="ltr">DELETE</code> statements based on the tag names present in each <code dir="ltr">ROW</code> element in the XML document. It executes the following statements:</p>
<pre dir="ltr">
DELETE FROM hr.employees WHERE salary = 3250 AND employee_id = 7400;
DELETE FROM hr.employees WHERE job_id = 'SA_REP' AND MANAGER_ID = 145 
  AND employee_id = 7369;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BABDBJGJ"></a>
<div id="ADXDK19443" class="sect3">
<h4 class="sect3">Deleting by Key with OracleXMLSave</h4>
<p>To only use the key values as predicates on the <code dir="ltr">DELETE</code> statement, invoke the <code dir="ltr"><a id="sthref313"></a><a id="sthref314"></a>OracleXMLSave.setKeyColumnList()</code> method. This approach limits the number of elements used to identify a row, which has the benefit of improving performance by caching the <code dir="ltr">DELETE</code> statement and batching transactions. The <code dir="ltr">testDeleteKey.java</code> program illustrates this technique.</p>
<p>The <code dir="ltr">testDeleteKey.java</code> program follows these steps:</p>
<ol>
<li>
<p>Create a JDBC OCI connection. The program calls the same <code dir="ltr">getConnection()</code> method used by the previous examples in this chapter:</p>
<pre dir="ltr">
Connection conn = getConnection("hr","<span class="italic">password</span>");
</pre></li>
<li>
<p>Create an XML save object. You initialize the object by passing it the <code dir="ltr">Connection</code> reference and the name of the table on which you want to perform DML. The following example illustrates this technique:</p>
<pre dir="ltr">
OracleXMLSave sav = new OracleXMLSave(conn, "employees");
</pre></li>
<li>
<p>Create an array of type <code dir="ltr">String</code> to hold the name of the primary key column in the table. The array contains only one element. The following code fragment specifies the name of the <code dir="ltr">employee_id</code> column:</p>
<pre dir="ltr">
String [] colNames = new String[1];
colNames[0] = "EMPLOYEE_ID";
</pre></li>
<li>
<p>Set the XML save object to the primary key specified in the array. The following statement passes a reference to the <code dir="ltr">colNames</code> array to the <code dir="ltr">OracleXMLSave.setKeyColumnList()</code> method:</p>
<pre dir="ltr">
sav.setKeyColumnList(keyColNames);
</pre></li>
<li>
<p>Delete the rows specified in the input XML document. The following code fragment creates a URL from the filename specified on the command line:</p>
<pre dir="ltr">
sav.deleteXML(sav.getURL(argv[0]));
</pre></li>
<li>
<p>Close the XML save object as follows:</p>
<pre dir="ltr">
sav.close();
</pre></li>
</ol>
<div id="ADXDK19444" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref315"></a>
<h5 class="sect4">Running the testDeleteKey Program</h5>
<p>Suppose that you want to delete employees 7400 and 7369 that you added in <a href="#BABFDCFA">"Updating with Key Columns with OracleXMLSave"</a>. Note that if you already deleted these employees in the previous example, you can first add them back to the <code dir="ltr">employees</code> table as follows:</p>
<pre dir="ltr">
java testInsert new_emp.xml
java testInsert new_emp2.xml
</pre>
<p>Delete employees 7400 and 7369 by passing the same <code dir="ltr">upd_emp.xml</code> document to the <code dir="ltr">testDeleteRow</code> program as follows:</p>
<pre dir="ltr">
java testDeleteKey upd_emp.xml
</pre>
<p>The program forms the following single generated <code dir="ltr">DELETE</code> statement:</p>
<pre dir="ltr">
DELETE FROM hr.employees WHERE employee_id=?;
</pre>
<p>The program executes the following <code dir="ltr">DELETE</code> statements, one for each employee:</p>
<pre dir="ltr">
DELETE FROM hr.employees WHERE employee_id = 7400;
DELETE FROM hr.employees WHERE employee_id = 7369;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGHFFC"></a>
<div id="ADXDK19445" class="sect2">
<h3 class="sect2">Handling XSU Java Exceptions</h3>
<p>XSU catches all exceptions that occur during processing and throws <code dir="ltr">oracle.xml.sql.<a id="sthref316"></a>OracleXMLSQLException</code><span class="italic">,</span> which is a generic runtime exception. The calling program does not have to catch this exception if it can still perform the appropriate action. The exception class provides methods to obtain error messages and also get any existing parent exception.</p>
<a id="BABHBEBC"></a>
<div id="ADXDK19446" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Obtaining the Parent Exception</h4>
<p>The <code dir="ltr">testException.java</code> demo program throws a runtime exception and then obtains the parent exception by invoking <code dir="ltr">Exception.getParentException()</code>.</p>
<p>Running the preceding program generates the following error message:</p>
<pre dir="ltr">
Caught SQL Exception:ORA-00904: "SD": invalid identifier
</pre></div>
<!-- class="sect3" -->
<a id="i1008161"></a>
<div id="ADXDK19447" class="sect3">
<h4 class="sect3">Raising a No Rows Exception<a id="sthref317"></a></h4>
<p>When there are no rows to process, XSU returns a <code dir="ltr">null</code> string. You can throw an exception every time there are no more rows, however, so that the program can process this exception through exception handlers. When a program invokes <code dir="ltr">OracleXMLQuery.setRaiseNoRowsException()</code>, XSU raises an <code dir="ltr">oracle.xml.sql.OracleXMLSQLNoRowsException</code> whenever there are no rows to generate for the output. This is a runtime exception and need not be caught.</p>
<p>The <code dir="ltr">noRowsTest.java</code> demo program instantiates the <code dir="ltr">pageTest</code> class defined in <code dir="ltr">pageTest.java</code>. The condition to check the termination changed from checking whether the result is <code dir="ltr">null</code> to an exception handler.</p>
<p>The <code dir="ltr">noRowsTest.java</code> program creates a <code dir="ltr">pageTest</code> object and initializes it with a SQL query. The program proceeds as follows:</p>
<ol>
<li>
<p>Configure the query object or raise a no rows exception. The following code fragment illustrates this technique:</p>
<pre dir="ltr">
pageTest test = new pageTest("SELECT * from employees");
...
test.qry.setRaiseNoRowsException(true);
</pre></li>
<li>
<p>Loop through the result set infinitely, retrieving ten rows at a time. When no rows are available, the program throws an exception. The following code fragment calls <code dir="ltr">pageTest.nextPage()</code>, which scrolls through the result set ten rows at a time:</p>
<pre dir="ltr">
try
{
  while(true)
    System.out.println(test.nextPage());
}
</pre></li>
<li>
<p>Catch the no rows exception and print "END OF OUTPUT". The following code illustrates this technique:</p>
<pre dir="ltr">
catch(oracle.xml.sql.OracleXMLSQLNoRowsException e)
{
  System.out.println(" END OF OUTPUT "); 
  try
  {
    test.close();
  }
  catch ( Exception ae )
  {
    ae.printStackTrace(System.out);
  }
}
</pre></li>
</ol>
<p>After compiling the program, run it from the command line as follows:</p>
<pre dir="ltr">
java noRowsTest
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABGGGAH"></a>
<div id="ADXDK19448" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Programming with the XSU PL/SQL API</h2>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABGCFCD">Generating XML from Simple Queries with DBMS_XMLQuery</a></p>
</li>
<li>
<p><a href="#BABBBEIB">Specifying Element Names with DBMS_XMLQuery</a></p>
</li>
<li>
<p><a href="#BABGHBCI">Paginating Results with DBMS_XMLQuery</a></p>
</li>
<li>
<p><a href="#BABBBGBJ">Setting Stylesheets in XSU</a></p>
</li>
<li>
<p><a href="#BABCBFJD">Binding Values in XSU</a></p>
</li>
<li>
<p><a href="#BABGHBGG">Inserting XML with DBMS_XMLSave</a></p>
</li>
<li>
<p><a href="#BABDGJDF">Updating with DBMS_XMLSave</a></p>
</li>
<li>
<p><a href="#BABECCGF">Deleting with DBMS_XMLSave</a></p>
</li>
<li>
<p><a href="#BABFGGIA">Handling Exceptions in the XSU PL/SQL API</a></p>
</li>
<li>
<p><a href="#BABCFACI">Reusing the Context Handle with DBMS_XMLSave</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For increased performance, consider using <a class="olink ARPLS374" href="../../appdev.112/e40758/d_xmlgen.htm#ARPLS374"><code dir="ltr">DBMS_XMLGen</code></a> and <a class="olink ARPLS801" href="../../appdev.112/e40758/d_xmlstr.htm#ARPLS801"><code dir="ltr">DBMS_XMLStore</code></a> as alternatives to <code dir="ltr">DBMS_XMLQuery</code> and <code dir="ltr">DBMS_XMLSave</code>. The two former packages are written in C and are built in to the database kernel. You can also use SQL/XML functions such as <code dir="ltr">XMLElement</code> for XML access in the database.</div>
<a id="BABGCFCD"></a>
<div id="ADXDK19449" class="sect2">
<h3 class="sect2">Generating XML from Simple Queries with DBMS_XMLQuery</h3>
<p>This section shows how you can use the <code dir="ltr">DBMS_XMLQuery</code> package to generate XML from a SQL query. To make the example work, connect to the database as <code dir="ltr">hr</code> and run the <code dir="ltr">printClobOut.sql</code> script. The script creates <code dir="ltr">printClobOut</code>, which is a simple procedure that prints a CLOB to the output buffer. If you run the <code dir="ltr">printClobOut</code> procedure in SQL*Plus, it prints the input CLOB to the screen. Set server output to <code dir="ltr">ON</code> to see the results. You may have to increase your display buffer to see all the output.</p>
<p>Run the <code dir="ltr">simpleQuery.sql</code> script to select 20 rows from the <code dir="ltr">hr.employees</code> table and obtain an XML document as a CLOB. The program first gets the context handle by passing in a query and then calls the <code dir="ltr">getXML</code> function to obtain the CLOB value. The document is in the same encoding as the database character set. This sample application assumes that you created the <code dir="ltr">printClobOut</code> procedure by running <code dir="ltr">printClobOut.sql</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABBBEIB"></a>
<div id="ADXDK19450" class="sect2">
<h3 class="sect2">Specifying Element Names with DBMS_XMLQuery</h3>
<p>With the XSU PL/SQL API you can change the default <code dir="ltr">ROW</code> and the <code dir="ltr">ROWSET</code> element names, which are the default names placed around each row of the result and around the whole output XML document. Use the PL/SQL procedures <code dir="ltr">setRowTagName</code> and <code dir="ltr">setRowSetTagName</code> to accomplish this task.</p>
<p>Connect as <code dir="ltr">hr</code> and run the <code dir="ltr">changeElementName.sql</code> script in SQL*Plus to obtain the first 20 rows of the <code dir="ltr">employees</code> table as an XML document. The anonymous PL/SQL block changes the <code dir="ltr">ROW</code> and <code dir="ltr">ROWSET</code> element names to <code dir="ltr">EMP</code> and <code dir="ltr">EMPSET</code>. Note that the block calls the <code dir="ltr">printClobOut</code> procedure that you created by running <code dir="ltr">printClobOut.sql</code>.</p>
<p>The generated XML document has an <code dir="ltr">&lt;EMPSET&gt;</code> document element. Each row is separated with the <code dir="ltr">&lt;EMP&gt;</code> tag.</p>
</div>
<!-- class="sect2" -->
<a id="BABGHBCI"></a>
<div id="ADXDK19451" class="sect2">
<h3 class="sect2">Paginating Results with DBMS_XMLQuery</h3>
<p>You can paginate query results by calling the following PL/SQL functions:</p>
<ul>
<li>
<p><code dir="ltr"><a id="sthref318"></a>setMaxRows</code> sets the maximum number of rows to be converted to XML. This maximum is relative to the current row position from which the previous result was generated.</p>
</li>
<li>
<p><code dir="ltr"><a id="sthref319"></a>setSkipRows</code> specifies the number of rows to skip before converting the row values to XML.</p>
</li>
</ul>
<p>Run the <code dir="ltr">paginateResult.sql</code> script to execute an anonymous block that paginates results. It skips the first 3 rows of the <code dir="ltr">employees</code> table and prints the rest of the rows 10 at a time by setting <code dir="ltr">skipRows</code> to 3 for the first batch of 10 rows and then to 0 for the rest of the batches. For multiple fetches, you must determine when there are no more rows to fetch, which you can do by calling <code dir="ltr"><a id="sthref320"></a><a id="sthref321"></a>setRaiseNoRowsException</code>. This procedure raises an exception if no rows are written to the CLOB. This exception can be caught and used as the termination condition.</p>
</div>
<!-- class="sect2" -->
<a id="BABBBGBJ"></a>
<div id="ADXDK19452" class="sect2">
<h3 class="sect2">Setting Stylesheets in XSU</h3>
<p>The XSU PL/SQL API provides the ability to set stylesheets on the generated XML documents as follows:</p>
<ul>
<li>
<p>Set the stylesheet header in the result with the <code dir="ltr"><a id="sthref322"></a><a id="sthref323"></a>setStylesheetHeader</code> procedure. This procedure adds the XML processing instruction that includes the stylesheet.</p>
</li>
<li>
<p>Apply a stylesheet to the resulting XML document before generation. This method increases performance dramatically because otherwise the XML document must be generated as a CLOB, sent to the parser again, and have the stylesheet applied. XSU generates a DOM document, calls the parser, applies the stylesheet and then generates the result. To apply the stylesheet to the resulting XML document, use the <code dir="ltr"><a id="sthref324"></a><a id="sthref325"></a><a id="sthref326"></a>setXSLT</code> procedure, which uses the stylesheet to generate the result.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABCBFJD"></a>
<div id="ADXDK19453" class="sect2">
<h3 class="sect2">Binding Values in XSU</h3>
<p>The XSU PL/SQL API provides the ability to bind values to a SQL statement. The SQL statement can contain named bind variables, which must be prefixed with a colon (<code dir="ltr">:</code>). The <code dir="ltr">bindSQLVariables.sql</code> script runs an anonymous PL/SQL block that binds values for <code dir="ltr">EMPLOYEE_ID</code> and <code dir="ltr">FIRST_NAME</code> to columns in the <code dir="ltr">employees</code> table.</p>
</div>
<!-- class="sect2" -->
<a id="BABGHBGG"></a>
<div id="ADXDK19454" class="sect2">
<h3 class="sect2">Inserting XML with DBMS_XMLSave</h3>
<p>To insert a document into a table or view, supply the table or the view name and then the XML document. XSU parses the XML document (if a string is given) and then creates an <code dir="ltr">INSERT</code> statement into which it binds all the values. By default, XSU inserts values into all the columns of the table or view and treats absent elements as <code dir="ltr">NULL</code>.</p>
<a id="BABJBCIB"></a>
<div id="ADXDK19455" class="sect3">
<h4 class="sect3">Inserting Values into All Columns with DBMS_XMLSave</h4>
<p>Run the <code dir="ltr">insProc.sql</code> demo script to create a PL/SQL stored procedure, <code dir="ltr">insProc</code>, which accepts the following parameters:</p>
<ul>
<li>
<p>An XML document as a <code dir="ltr">CLOB</code></p>
</li>
<li>
<p>The name of the table in which to insert the document</p>
</li>
</ul>
<p>You can invoke the <code dir="ltr">insProc</code> procedure to insert an XML document into the table.</p>
<p>Run the <code dir="ltr">insertClob.sql</code> script to create a table called <code dir="ltr">xmldocument</code> and store an XML document in the table as a <code dir="ltr">CLOB</code>. The XML document describes employee 7370, Liz Gardner, whom you want to insert into the <code dir="ltr">hr.employees</code> table.</p>
<div id="ADXDK19456" class="example">
<p class="titleinexample"><a id="sthref327"></a>Example 11-3 insertClob.sql</p>
<pre dir="ltr">
CREATE TABLE hr.xmldocument
  (docid   NUMBER PRIMARY KEY,
  xml_text CLOB);
-- insert an XML document into the CLOB column
INSERT INTO hr.xmldocument (docid,xml_text)
VALUES (1,
       '&lt;?xml version="1.0"?&gt;
       &lt;ROWSET&gt;
        &lt;ROW num="1"&gt;
           &lt;EMPLOYEE_ID&gt;7370&lt;/EMPLOYEE_ID&gt;
           &lt;FIRST_NAME&gt;Liz&lt;/FIRST_NAME&gt;
           &lt;LAST_NAME&gt;Gardner&lt;/LAST_NAME&gt;
           &lt;EMAIL&gt;liz.gardner@business.com&lt;/EMAIL&gt;
           &lt;PHONE_NUMBER&gt;650-555-6127&lt;/PHONE_NUMBER&gt;
           &lt;HIRE_DATE&gt;12/18/2004 0:0:0&lt;/HIRE_DATE&gt;
           &lt;SALARY&gt;3000&lt;/SALARY&gt;
           &lt;COMMISSION_PCT&gt;0&lt;/COMMISSION_PCT&gt;
           &lt;JOB_ID&gt;SH_CLERK&lt;/JOB_ID&gt;
           &lt;MANAGER_ID&gt;103&lt;/MANAGER_ID&gt;
           &lt;DEPARTMENT_ID&gt;20&lt;/DEPARTMENT_ID&gt;
        &lt;/ROW&gt;
       &lt;/ROWSET&gt;');
</pre></div>
<!-- class="example" -->
<p>Run the <code dir="ltr">insertEmployee.sql</code> script shown in <a href="#BABDGHDD">Example 11-4</a> to call the <code dir="ltr">insProc</code> stored procedure and insert Liz Gardner into the <code dir="ltr">employees</code> table.</p>
<div id="ADXDK19457" class="example">
<p class="titleinexample"><a id="BABDGHDD"></a>Example 11-4 insertEmployee.sql</p>
<pre dir="ltr">
DECLARE
  v_xml_text CLOB;
BEGIN
  SELECT xml_text 
    INTO v_xml_text
  FROM hr.xmldocument
  WHERE docid = 1;
  insProc(v_xml_text, 'employees');
END;
/
</pre></div>
<!-- class="example" -->
<p>As in <a href="#BABBBIFA">"Inserting Rows with OracleXMLSave"</a>, running the <code dir="ltr">callinsProc</code> procedure generates an <code dir="ltr">INSERT</code> statement of the form shown in <a href="#BABJADEA">Example 11-5</a>.</p>
<div id="ADXDK19458" class="example">
<p class="titleinexample"><a id="BABJADEA"></a>Example 11-5 Form of the INSERT Statement</p>
<pre dir="ltr">
INSERT INTO hr.employees 
  (employee_id, first_name, last_name, email, phone_number, hire_date, 
   salary, commission_pct, manager_id, department_id)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?);     
</pre></div>
<!-- class="example" -->
<p>XSU matches the element tags in the input XML document that match the column names and binds their values.</p>
</div>
<!-- class="sect3" -->
<a id="BABJCFDC"></a>
<div id="ADXDK19459" class="sect3">
<h4 class="sect3">Inserting into a Subset of Columns with DBMS_XMLSave</h4>
<p>As explained in <a href="#BABGEIIF">"Inserting XML into a Subset of Columns with OracleXMLSave"</a>, you may not want to insert values into all columns. You can create a list of column names for insert processing and pass it to the <code dir="ltr">DBMS_XMLSave</code> procedure. You can set these values by calling the <code dir="ltr"><a id="sthref328"></a>setUpdateColumnName</code> procedure repeatedly and passing in a column name to update every time. Clear the column name settings by invoking <code dir="ltr"><a id="sthref329"></a>clearUpdateColumnList</code><span class="italic">.</span></p>
<p>Run the <code dir="ltr">testInsert.sql</code> demo script to create a PL/SQL stored procedure called <code dir="ltr">testInsert</code>. You can use this procedure to insert XML data of type CLOB into the <code dir="ltr">hr.employees</code> table.</p>
<p>Run the <code dir="ltr">insertClob2.sql</code> script shown in <a href="#BABDIHBI">Example 11-6</a> to insert an XML document describing new employee Jordan into a CLOB column of the <code dir="ltr">xmldocument</code> table. Note that the document does not contain an element corresponding to every column in the <code dir="ltr">employees</code> table.</p>
<div id="ADXDK19460" class="example">
<p class="titleinexample"><a id="BABDIHBI"></a>Example 11-6 insertClob2.sql</p>
<pre dir="ltr">
-- insert an XML document into the CLOB column  of the xmldocument table with only 
-- some of the possible elements
INSERT INTO hr.xmldocument (docid, xml_text)
VALUES (2,
       '&lt;?xml version="1.0"?&gt;
       &lt;ROWSET&gt;
        &lt;ROW num="1"&gt;
           &lt;EMPLOYEE_ID&gt;7401&lt;/EMPLOYEE_ID&gt;
           &lt;LAST_NAME&gt;Jordan&lt;/LAST_NAME&gt;
           &lt;EMAIL&gt;jim.jordan@business.com&lt;/EMAIL&gt;
           &lt;JOB_ID&gt;SH_CLERK&lt;/JOB_ID&gt;
           &lt;HIRE_DATE&gt;12/17/2004 0:0:0&lt;/HIRE_DATE&gt;
        &lt;/ROW&gt;
       &lt;/ROWSET&gt;');
</pre></div>
<!-- class="example" -->
<p>Running the <code dir="ltr">insertEmployee2.sql</code> script shown in <a href="#BABDBECH">Example 11-7</a> inserts the data for employee Jim Jordan into a subset of the columns in the <code dir="ltr">hr.employees</code> table.</p>
<div id="ADXDK19461" class="example">
<p class="titleinexample"><a id="BABDBECH"></a>Example 11-7 insertEmployee2.sql</p>
<pre dir="ltr">
DECLARE
  v_xml_text CLOB;
BEGIN
  SELECT xml_text 
    INTO v_xml_text
  FROM hr.xmldocument
  WHERE docid = 2;
  testInsert(v_xml_text);
END;
/
</pre></div>
<!-- class="example" -->
<p>As in <a href="#BABGEIIF">"Inserting XML into a Subset of Columns with OracleXMLSave"</a>, calling <code dir="ltr">testInsert</code> generates the following <code dir="ltr">INSERT</code> statement:</p>
<pre dir="ltr">
INSERT INTO hr.employees (employee_id, last_name, email, job_id, hire_date) 
  VALUES (?, ?, ?, ?, ?);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDGJDF"></a>
<div id="ADXDK19462" class="sect2">
<h3 class="sect2">Updating with DBMS_XMLSave</h3>
<p>As described in <a href="#BABEJABF">"Updating Rows with OracleXMLSave"</a>, you can use an XML document to update specified fields in a table. You can either specify a column to use as a key or pass a list of columns for updating.</p>
<a id="BABGDIHB"></a>
<div id="ADXDK19463" class="sect3">
<h4 class="sect3">Updating with Key Columns with DBMS_XMLSave</h4>
<p>Run the <code dir="ltr">testUpdateKey.sql</code> script to create a PL/SQL procedure called <code dir="ltr">testUpdateKey</code>. This procedure uses the <code dir="ltr">employee_id</code> column of the <code dir="ltr">hr.employees</code> table as a primary key.</p>
<p>Run the <code dir="ltr">insertClob3.sql</code> script shown in shown in <a href="#BABDFCGH">Example 11-8</a> to insert an XML document into the CLOB column of the <code dir="ltr">xmldocument</code> table. The document specifies a new salary for employee 7400 and a new job ID and manager ID for employee 7369.</p>
<div id="ADXDK19464" class="example">
<p class="titleinexample"><a id="BABDFCGH"></a>Example 11-8 insertClob3.sql</p>
<pre dir="ltr">
INSERT INTO hr.xmldocument (docid, xml_text)
VALUES (3,
       '&lt;?xml version="1.0"?&gt;
        &lt;ROWSET&gt;
         &lt;ROW num="1"&gt;
            &lt;EMPLOYEE_ID&gt;7400&lt;/EMPLOYEE_ID&gt;
            &lt;SALARY&gt;3250&lt;/SALARY&gt;
         &lt;/ROW&gt;
         &lt;ROW num="2"&gt;
            &lt;EMPLOYEE_ID&gt;7369&lt;/EMPLOYEE_ID&gt;
            &lt;JOB_ID&gt;SA_REP&lt;/JOB_ID&gt;
            &lt;MANAGER_ID&gt;145&lt;/MANAGER_ID&gt;
         &lt;/ROW&gt;
        &lt;/ROWSET&gt;');
</pre></div>
<!-- class="example" -->
<p>Run the <code dir="ltr">updateEmployee.sql</code> script shown in <a href="#BABJJGAF">Example 11-9</a> to pass the XML document to the <code dir="ltr">testUpdateKey</code> procedure and generate two <code dir="ltr">UPDATE</code> statements.</p>
<div id="ADXDK19465" class="example">
<p class="titleinexample"><a id="BABJJGAF"></a>Example 11-9 updateEmployee.sql</p>
<pre dir="ltr">
DECLARE
  v_xml_text CLOB;
BEGIN
  SELECT xml_text 
    INTO v_xml_text
  FROM hr.xmldocument
  WHERE docid = 3;
  testUpdateKey(v_xml_text);
END;
/
</pre></div>
<!-- class="example" -->
<p>For the first <code dir="ltr">ROW</code> element, the program generates an <code dir="ltr">UPDATE</code> statement as follows:</p>
<pre dir="ltr">
UPDATE hr.employees SET salary = 3250 WHERE employee_id = 7400;
</pre>
<p>For the second <code dir="ltr">ROW</code> element the program generates the following statement:</p>
<pre dir="ltr">
UPDATE hr.employees SET job_id = 'SA_REP' AND MANAGER_ID = 145 
  WHERE employee_id = 7369;
</pre></div>
<!-- class="sect3" -->
<a id="BABHDEEH"></a>
<div id="ADXDK19466" class="sect3">
<h4 class="sect3">Specifying a List of Columns with DBMS_XMLSave: Example</h4>
<p>As described in <a href="#BABHIECJ">"Updating a Column List with OracleXMLSave"</a>, you can specify a list of columns to update.</p>
<p>Run the <code dir="ltr">testUpdateSubset.sql</code> script creates the PL/SQL procedure <code dir="ltr">testUpdateSubset</code>. The procedure uses the <code dir="ltr">employee_id</code> column as key and updates only the <code dir="ltr">salary</code> and <code dir="ltr">job_id</code> columns of the <code dir="ltr">hr.employees</code> table.</p>
<p>Run the <code dir="ltr">insertClob4.sql</code> script to insert an XML document into the <code dir="ltr">xmldocument</code> table. The <code dir="ltr">&lt;ROW&gt;</code> elements in the document describe employees 100 and 206. Each <code dir="ltr">&lt;ROW&gt;</code> element has ten subelements that contain descriptive text.</p>
<p>Run the <code dir="ltr">updateEmployee2.sql</code> script shown in <a href="#BABIAHBD">Example 11-10</a> to pass the XML CLOB to the <code dir="ltr">testUpdateSubset</code> procedure and generate two <code dir="ltr">UPDATE</code> statements.</p>
<div id="ADXDK19467" class="example">
<p class="titleinexample"><a id="BABIAHBD"></a>Example 11-10 updateEmployee2.sql</p>
<pre dir="ltr">
DECLARE
  v_xml_text CLOB;
BEGIN
  SELECT xml_text 
    INTO v_xml_text
  FROM hr.xmldocument
  WHERE docid = 4;
  testUpdateSubset(v_xml_text);
END;
/
</pre></div>
<!-- class="example" -->
<p>The procedure updates only those columns specified in the <code dir="ltr">setUpdateColumn</code> procedure, <code dir="ltr">salary</code> and <code dir="ltr">email</code>, for employees 100 and 206.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABECCGF"></a>
<div id="ADXDK19468" class="sect2">
<h3 class="sect2">Deleting with DBMS_XMLSave</h3>
<p>As described in <a href="#BABJDBHE">"Deleting Rows with OracleXMLSave"</a>, you can supply a list of key columns that XSU uses to determine which rows to delete. XSU specifies these columns in the <code dir="ltr">WHERE</code> clause of the <code dir="ltr">DELETE</code> statement.</p>
<a id="CHDFHDJG"></a>
<div id="ADXDK19469" class="sect3">
<h4 class="sect3">Deleting by Row with DBMS_XMLSave: Example</h4>
<p>Create the <code dir="ltr">testDeleteRow</code> PL/SQL procedure by running the <code dir="ltr">testDeleteRow.sql</code> script. The procedure deletes a row from the <code dir="ltr">hr.employees</code> table for every <code dir="ltr">&lt;ROW&gt;</code> element in an input XML document.</p>
<p>Suppose that you want to delete the employee Jim Jordan that you added in <a href="#BABDBECH">Example 11-7</a>. Run the <code dir="ltr">deleteEmployeeByRow.sql</code> script shown in <a href="#BABIIJIH">Example 11-11</a> to pass the XML document as a CLOB to the <code dir="ltr">testDeleteRow</code> stored procedure.</p>
<div id="ADXDK19470" class="example">
<p class="titleinexample"><a id="BABIIJIH"></a>Example 11-11 Deleting by Row</p>
<pre dir="ltr">
DECLARE
  v_xml_text CLOB;
BEGIN
  SELECT xml_text 
    INTO v_xml_text
  FROM hr.xmldocument
  WHERE docid = 2;
  testDeleteRow(v_xml_text);
END;
/
</pre></div>
<!-- class="example" -->
<p>The preceding call to <code dir="ltr">testDeleteRow</code> generates the following <code dir="ltr">DELETE</code> statement:</p>
<pre dir="ltr">
DELETE FROM hr.employees
  WHERE employee_id = 7401 AND last_name = 'JORDAN'
  AND email = 'jim.jordan@business.com' AND job_id = 'SH_CLERK'
  AND hire_date = '12/17/2004 0:0:0';
</pre>
<p>The program forms the <code dir="ltr">DELETE</code> statements based on the tag names present in each <code dir="ltr">&lt;ROW&gt;</code> element in the XML document.</p>
</div>
<!-- class="sect3" -->
<a id="CHDHFHGI"></a>
<div id="ADXDK19471" class="sect3">
<h4 class="sect3">Deleting by Key with DBMS_XMLSave: Example</h4>
<p>As explained in <a href="#BABDBJGJ">"Deleting by Key with OracleXMLSave"</a>, you can specify a column to use as a primary key for the deletions. Use the <code dir="ltr"><a id="sthref330"></a>DBMS_XMLSave.setKeyColumn</code> function to specify the key.</p>
<p>The <code dir="ltr">testDeleteKey</code> procedure created by running <code dir="ltr">testDeleteKey.sql</code> deletes a row from the <code dir="ltr">employees</code> table for every <code dir="ltr">&lt;ROW&gt;</code> element in an input XML document.</p>
<p>Suppose that you want to delete the employee Liz Gardner that you added in <a href="#BABDGHDD">Example 11-4</a>. Run the <code dir="ltr">deleteEmployeeByKey.sql</code> script shown in <a href="#BABHIBFD">Example 11-12</a> to pass the XML document as a CLOB to the <code dir="ltr">testDeleteKey</code> stored procedure.</p>
<div id="ADXDK19472" class="example">
<p class="titleinexample"><a id="BABHIBFD"></a>Example 11-12 Deleting by Key</p>
<pre dir="ltr">
DECLARE
  v_xml_text CLOB;
BEGIN
  SELECT xml_text 
    INTO v_xml_text
  FROM hr.xmldocument
  WHERE docid = 1;
  testDeleteKey(v_xml_text);
END;
/
</pre></div>
<!-- class="example" -->
<p>In the preceding procedure call, XSU generates a single <code dir="ltr">DELETE</code> statement of the following form:</p>
<pre dir="ltr">
DELETE FROM hr.employees WHERE employee_id=?
</pre>
<p>XSU uses this statement for all <code dir="ltr">ROW</code> elements in the input XML document.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABFGGIA"></a>
<div id="ADXDK19473" class="sect2">
<h3 class="sect2"><a id="sthref331"></a>Handling Exceptions in the XSU PL/SQL API</h3>
<p>Good PL/SQL coding practice accounts for possible exceptions. The anonymous PL/SQL block in <code dir="ltr">raiseException.sql</code> demonstrates how to invoke the <code dir="ltr">DBMS_XMLQuery.getExceptionContent</code> procedure. Run the script in SQL*Plus to print the following error message:</p>
<pre dir="ltr">
Exception caught 904 ORA-00904: "Z": invalid identifier
</pre></div>
<!-- class="sect2" -->
<a id="BABCFACI"></a>
<div id="ADXDK19474" class="sect2">
<h3 class="sect2">Reusing the Context Handle with DBMS_XMLSave</h3>
<p>In the DML examples described in the preceding sections, you can use the same context handle to perform more than one operation. That is, you can perform more than one <code dir="ltr">INSERT</code> with the same context provided that all of the insertions access the same table specified when creating the <code dir="ltr">save</code> context. You can also use the same context to mix DML statements.</p>
<p>The <code dir="ltr">testDML.sql</code> script shows how to use the same context and settings to perform DML depending on user input. The example uses a PL/SQL supplied package static variable to store the context so that the same context can be used for all function calls.</p>
<p>In the <code dir="ltr">testDML</code> package created by the script, you <a id="sthref332"></a>create a context once for the whole package (and thus the session) and reuse the context for multiple DML operations.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
The key column <code dir="ltr">employee_id</code> is used both for updates and deletes as a way of identifying the row.</div>
<p>You can call any of the three procedures created by the script to update the <code dir="ltr">employees</code> table:</p>
<pre dir="ltr">
testDML.insertXML(xmlclob);
testDML.deleteXML(xmlclob);
testDML.updateXML(xmlclob);
</pre>
<p>Each procedure call uses the same context, which improves the performance of these operations, particularly if these operations are performed frequently.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007013"></a>
<div id="ADXDK19475" class="sect1">
<h2 class="sect1">Tips and T<a id="sthref333"></a>echniques for Programming with XSU</h2>
<p>This section provides additional tips and techniques for writing programs with XSU. It contains the following topics:</p>
<ul>
<li>
<p><a href="#i1014723">How XSU Maps Between SQL and XML</a></p>
</li>
<li>
<p><a href="#i1014899">How XSU Processes SQL Statements</a></p>
</li>
</ul>
<a id="i1014723"></a>
<div id="ADXDK19476" class="sect2">
<h3 class="sect2"><a id="sthref334"></a><a id="sthref335"></a>How XSU Maps Between SQL and XML<a id="sthref336"></a><a id="sthref337"></a></h3>
<p>The fundamental component of a table is a column, whereas the fundamental components of an XML document are elements and attributes. How do tables map to XML documents? For example, if the <code dir="ltr">hr.employees</code> table has a column called <code dir="ltr">last_name</code>, how is this structure represented in XML: as an <code dir="ltr">&lt;EMPLOYEES&gt;</code> element with a <code dir="ltr">last_name</code> attribute or as a <code dir="ltr">&lt;LAST_NAME&gt;</code> element within a different root element? This section answers such questions by describing how SQL maps to XML and vice versa. It contains the following topics:</p>
<ul>
<li>
<p><a href="#i1015108">Default SQL to XML Mapping</a></p>
</li>
<li>
<p><a href="#i1015503">Default XML to SQL Mapping</a></p>
</li>
<li>
<p><a href="#i1015168">Customizing Generated XML</a></p>
</li>
</ul>
<a id="i1015108"></a>
<div id="ADXDK19477" class="sect3">
<h4 class="sect3"><a id="sthref338"></a>Default SQL to XML Mapping</h4>
<p>Assume that you want to display data from some column of the <code dir="ltr">hr.employees</code> table as an XML document. You run XSU at the command line as follows:</p>
<pre dir="ltr">
java OracleXML getXML -user "hr/<span class="italic">password</span>" -withschema \
  "SELECT employee_id, last_name, hire_date FROM employees"
</pre>
<p>XSU outputs an XML document based on the input query. The root element of the document is <code dir="ltr">&lt;DOCUMENT&gt;</code>. The following shows sample output, with extraneous lines replaced by comments:</p>
<pre dir="ltr">
&lt;?xml version = '1.0'?&gt;
&lt;DOCUMENT xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
   &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
   &lt;!-- children of schema element ... --&gt;
   &lt;/xsd:schema&gt;
   &lt;ROWSET xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:noNamespaceSchemaLocation="#/DOCUMENT/xsd:schema[not(@targetNamespace)]"&gt;
      &lt;ROW num="1"&gt;
         &lt;EMPLOYEE_ID&gt;100&lt;/EMPLOYEE_ID&gt;
         &lt;LAST_NAME&gt;King&lt;/LAST_NAME&gt;
         &lt;HIRE_DATE&gt;6/17/1987 0:0:0&lt;/HIRE_DATE&gt;
      &lt;/ROW&gt;
      &lt;!-- additional rows ... --&gt;
   &lt;/ROWSET&gt;
&lt;/DOCUMENT&gt;
</pre>
<p>In the generated XML, the rows returned by the SQL query are children of the <code dir="ltr">&lt;ROWSET&gt;</code> element. The XML document has the following features:</p>
<ul>
<li>
<p>The <code dir="ltr">&lt;ROWSET&gt;</code> element has zero or more <code dir="ltr">&lt;ROW&gt;</code> child elements corresponding to the number of rows returned. If the query generates no rows, then no <code dir="ltr">&lt;ROW&gt;</code> elements are included; if the query generates one row, then one <code dir="ltr">&lt;ROW&gt;</code> element is included, and so forth.</p>
</li>
<li>
<p>Each <code dir="ltr">&lt;ROW&gt;</code> element contains data from one of the table rows. Specifically, each <code dir="ltr">&lt;ROW&gt;</code> element has one or more child elements whose names and content are identical to the database columns specified in the <code dir="ltr">SELECT</code> statement.</p>
</li>
</ul>
<a id="CHDHIGFC"></a>
<div id="ADXDK19478" class="sect4">
<h5 class="sect4">XML Mapping Against an Object-Relational Schema</h5>
<p>Assume a case in which you generate an XML document from an object-relational schema. Run the <code dir="ltr">createObjRelSchema.sql</code> script in SQL*Plus to set up and populate an object-relational schema. The schema contains a <code dir="ltr">dept1</code> table with two columns that employ user-defined types.</p>
<p>You can query the <code dir="ltr">dept1</code> table as follows by invoking XSU from the command line:</p>
<pre dir="ltr">
% java OracleXML getXML -user "hr/<span class="italic">password</span>" -withschema "SELECT * FROM dept1"
</pre>
<p>XSU returns the XML document shown in <a href="#BABBHAFE">Example 11-13</a>, which is altered so that extraneous lines are replaced by comments.</p>
<div id="ADXDK19479" class="example">
<p class="titleinexample"><a id="BABBHAFE"></a>Example 11-13 XSU-Generated Sample Document</p>
<pre dir="ltr">
&lt;?xml version='1.0'?&gt;
&lt;DOCUMENT xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;
   &lt;schema targetNamespace="http://xmlns.oracle.com/xdb/SYSTEM"      
           xmlns="http://www.w3.org/2001/XMLSchema"
           xmlns:SYSTEM="http://xmlns.oracle.com/xdb/SYSTEM"&gt;
   &lt;!-- children of schema element ... --&gt;
   &lt;/xsd:schema&gt;
   &lt;ROWSET xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="#/DOCUMENT/xsd:schema[not(@targetNamespace)]"&gt;
      &lt;ROW num="1"&gt;
         &lt;DEPTNO&gt;120&lt;/DEPTNO&gt;
         &lt;DEPTNAME&gt;Treasury&lt;/DEPTNAME&gt;
         &lt;DEPTADDR&gt;
            &lt;STREET&gt;2004 Charade Rd&lt;/STREET&gt;
            &lt;CITY&gt;Seattle&lt;/CITY&gt;
            &lt;STATE&gt;WA&lt;/STATE&gt;
            &lt;ZIP&gt;98199&lt;/ZIP&gt;
         &lt;/DEPTADDR&gt;
         &lt;EMPLIST&gt;
            &lt;EMPLIST_ITEM&gt;
               &lt;EMPLOYEE_ID&gt;1&lt;/EMPLOYEE_ID&gt;
               &lt;LAST_NAME&gt;Mehta&lt;/LAST_NAME&gt;
               &lt;SALARY&gt;6000&lt;/SALARY&gt;
               &lt;EMPLOYEE_ADDRESS&gt;
                  &lt;STREET&gt;500 Main Road&lt;/STREET&gt;
                  &lt;CITY&gt;Seattle&lt;/CITY&gt;
                  &lt;STATE&gt;WA&lt;/STATE&gt;
                  &lt;ZIP&gt;98199&lt;/ZIP&gt;
               &lt;/EMPLOYEE_ADDRESS&gt;
            &lt;/EMPLIST_ITEM&gt;
         &lt;/EMPLIST&gt;
      &lt;/ROW&gt;
   &lt;/ROWSET&gt;
&lt;/DOCUMENT&gt;
 
</pre></div>
<!-- class="example" -->
<p>As in the previous example, the mapping is canonical, that is, <code dir="ltr">&lt;ROWSET&gt;</code> contains <code dir="ltr">&lt;ROW&gt;</code> child elements, which in turn contain child elements corresponding to the columns in <code dir="ltr">dept1</code>. For example, the <code dir="ltr">&lt;DEPTNAME&gt;</code> element corresponds to the <code dir="ltr">dept1.deptname</code> column. The elements corresponding to scalar type columns contain the data from the columns.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDK19480" class="sect4"><a id="sthref339"></a>
<h5 class="sect4">Default Mapping of Complex Type Columns to XML</h5>
<p>The situation is more complex with elements corresponding to a complex type column. In <a href="#BABBHAFE">Example 11-13</a>, <code dir="ltr">&lt;DEPTADDR&gt;</code> corresponds to the <code dir="ltr">dept1.deptAddr</code> column, which is of object type <code dir="ltr">AddressType</code>. Consequently, <code dir="ltr">&lt;DEPTADDR&gt;</code> contains child elements corresponding to the attributes specified in the type <code dir="ltr">AddressType</code>. The <code dir="ltr">AddressType</code> attribute <code dir="ltr">street</code> corresponds to the child XML element <code dir="ltr">&lt;STREET&gt;</code> and so forth. These sub-elements can contain data or subelements of their own, depending on whether the attribute they correspond to is of a simple or complex type.</p>
</div>
<!-- class="sect4" -->
<div id="ADXDK19481" class="sect4"><a id="sthref340"></a>
<h5 class="sect4">Default Mapping of Collections to XML</h5>
<p>When dealing with elements corresponding to database collections, the situation is also different. In <a href="#BABBHAFE">Example 11-13</a>, the <code dir="ltr">&lt;EMPLIST&gt;</code> element corresponds to the <code dir="ltr">emplist</code> column of type <code dir="ltr">EmployeeListType</code>. Consequently, the <code dir="ltr">&lt;EMPLIST&gt;</code> element contains a list of <code dir="ltr">&lt;EMPLIST_ITEM&gt;</code> elements, each corresponding to one of the elements of the collection. Note the following:</p>
<ul>
<li>
<p>The <code dir="ltr">&lt;ROW&gt;</code> elements contain a cardinality attribute <code dir="ltr">num</code>.</p>
</li>
<li>
<p>If a particular column or attribute value is <code dir="ltr">NULL</code>, then for that row, the corresponding XML element is left out altogether.</p>
</li>
<li>
<p>If a top-level scalar column name starts with the at sign (@) character, then the column is mapped to an XML attribute instead of an XML element.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1015503"></a>
<div id="ADXDK19482" class="sect3">
<h4 class="sect3">Default XML to SQL Mapping</h4>
<p>XML to SQL mapping is the reverse of SQL to XML mapping. Consider the following differences when using XSU to map XML to SQL:</p>
<ul>
<li>
<p>When transforming XML to SQL, XSU ignores XML attributes. Thus, there is really no mapping of XML attributes to SQL.</p>
</li>
<li>
<p>When transforming SQL to XML, XSU performs the mapping on a single <code dir="ltr">ResultSet</code> created by a SQL query. The query can span multiple database tables or views. When transforming XML into SQL, note the following:</p>
<ul>
<li>
<p>To insert one XML document into multiple tables or views, you must create an object-relational view over the target schema.</p>
</li>
<li>
<p>If the view is not updatable, then you can use <code dir="ltr">INSTEAD OF INSERT</code> triggers.</p>
</li>
</ul>
</li>
</ul>
<p>If the XML document does not perfectly map to the target database schema, then you can perform the following actions:</p>
<ul>
<li>
<p>Modify the target. Create an object-relational view over the target schema and make the view the new target.</p>
</li>
<li>
<p>Modify the XML document by using XSLT to transform the XML document. You can register the XSLT stylesheet with XSU so that the incoming XML is automatically transformed before it attempts any mapping.</p>
</li>
<li>
<p>Modify XSU's XML-to-SQL mapping. You can instruct XSU to perform case-insensitive matching of XML elements to database columns or attributes. For example, you can instruct XSU to do the following:</p>
<ul>
<li>
<p>Use the name of the element corresponding to a database row instead of <code dir="ltr">ROW</code>.</p>
</li>
<li>
<p>Specify the date format to use when parsing dates in the XML document.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1015168"></a>
<div id="ADXDK19483" class="sect3">
<h4 class="sect3"><a id="sthref341"></a><a id="sthref342"></a>Customizing Generated XML</h4>
<p>In some circumstances you may need to generate XML with a specific structure. Because the desired structure may differ from the default structure of the generated XML document, you want to have some flexibility in this process. You can customize the structure of a generated XML document by using one of the following methods:</p>
<ul>
<li>
<p><a href="#i1016364">Altering the Database Schema or SQL Query</a></p>
</li>
<li>
<p><a href="#i1016368">Modifying XSU</a></p>
</li>
</ul>
<a id="i1016364"></a>
<div id="ADXDK19484" class="sect4">
<h5 class="sect4">Altering the Database Schema or SQL Query</h5>
<p>You can perform source customizations by altering the SQL query or the database schema. The simplest and most powerful source customizations include the following:</p>
<ul>
<li>
<p>In the database schema, create an object-relational view that maps to the desired XML document structure.</p>
</li>
<li>
<p>In your query, do the following:</p>
<ul>
<li>
<p>Use cursor subqueries or cast-multiset constructs to create nesting in the XML document that comes from a flat schema.</p>
</li>
<li>
<p>Alias column and attribute names to obtain the desired XML element names.</p>
</li>
<li>
<p>Alias top-level scalar type columns with identifiers that begin with the at sign (@) to make them map to an XML attribute instead of an XML element. For example, executing the following statement generates an XML document in which the <code dir="ltr">&lt;ROW&gt;</code> element has the attribute <code dir="ltr">empno</code>:</p>
<pre dir="ltr">
SELECT employee_name AS "@empno",... FROM employees;
</pre></li>
</ul>
</li>
</ul>
<p>Consider the <code dir="ltr">customer.xml</code> document shown in <a href="#BABCIAJB">Example 11-14</a>.</p>
<div id="ADXDK19485" class="example">
<p class="titleinexample"><a id="BABCIAJB"></a>Example 11-14 customer.xml</p>
<pre dir="ltr">
&lt;?xml version = "1.0"?&gt;
&lt;ROWSET&gt;
 &lt;ROW num="1"&gt;
  &lt;CUSTOMER&gt;
   &lt;CUSTOMERID&gt;1044&lt;/CUSTOMERID&gt;
   &lt;FIRSTNAME&gt;Paul&lt;/FIRSTNAME&gt;
   &lt;LASTNAME&gt;Astoria&lt;/LASTNAME&gt;
   &lt;HOMEADDRESS&gt;
    &lt;STREET&gt;123 Cherry Lane&lt;/STREET&gt;
    &lt;CITY&gt;SF&lt;/CITY&gt;
    &lt;STATE&gt;CA&lt;/STATE&gt;
    &lt;ZIP&gt;94132&lt;/ZIP&gt;
   &lt;/HOMEADDRESS&gt;
  &lt;/CUSTOMER&gt;
 &lt;/ROW&gt;
&lt;/ROWSET&gt;
</pre></div>
<!-- class="example" -->
<p>Suppose that you need to design a set of database tables to store this data. Because the XML is nested more than one level, you can use an object-relational database schema that maps canonically to the preceding XML document. Run the <code dir="ltr">createObjRelSchema2.sql</code> script in SQL*Plus to create such a database schema.</p>
<p>You can load the data in the <code dir="ltr">customer.xml</code> document into the <code dir="ltr">customer_tab</code> table created by the script. Invoke XSU for Java from the command line as follows:</p>
<pre dir="ltr">
java OracleXML putXML -user "hr/<span class="italic">password</span>" -fileName customer.xml customer_tab
</pre>
<p>To load <code dir="ltr">customer.xml</code> into a database schema that is not object-relational, you can create objects in views on top of a standard relational schema. For example, you can create a relational table that contains the necessary columns, then create a customer view that contains a customer object on top of it, as shown in the <code dir="ltr">createRelSchema.sql</code> script in <a href="#BABBCCEG">Example 11-15</a>.</p>
<div id="ADXDK19486" class="example">
<p class="titleinexample"><a id="BABBCCEG"></a>Example 11-15 createRelSchema.sql</p>
<pre dir="ltr">
CREATE TABLE hr.cust_tab
 ( customerid NUMBER(10), 
   firstname VARCHAR2(20), 
   lastname VARCHAR2(20),
   street VARCHAR2(40),
   city VARCHAR2(20),
   state VARCHAR2(20),
   zip VARCHAR2(20)
 );

CREATE VIEW customer_view 
AS
SELECT customer_type(customerid, firstname, lastname,
       address_type(street,city,state,zip)) customer
FROM cust_tab;
</pre></div>
<!-- class="example" -->
<p>You can load data into <code dir="ltr">customer_view</code> as follows:</p>
<pre dir="ltr">
java OracleXML putXML -user "hr/<span class="italic">password</span>" -fileName customer.xml customer_view
</pre>
<p>Alternatively, you can flatten your XML by means of XSLT and then insert it directly into a relational schema. However, this is the least recommended option.</p>
<p>Suppose that you want to map a particular column or a group of columns to an XML attribute instead of an XML element. To achieve this functionality, you can create an alias for the column name and prepend the at sign (@) before the name of this alias. For example, you can use the <code dir="ltr">mapColumnToAtt.sql</code> script to query the <code dir="ltr">hr.employees</code> table, rendering <code dir="ltr">employee_id</code> as an XML attribute.</p>
<p>You can run the <code dir="ltr">mapColumnToAtt.sql</code> script from the command line as follows:</p>
<pre dir="ltr">
java OracleXML getXML -user "hr/<span class="italic">password</span>" -fileName "mapColumnToAtt.sql"
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
All attributes must appear <span class="italic">before</span> any non-attribute.</div>
</div>
<!-- class="sect4" -->
<a id="i1016368"></a>
<div id="ADXDK19487" class="sect4">
<h5 class="sect4">Modifying XSU</h5>
<p>XSU enables you to modify the rules that it uses to transform SQL data into XML. You can make any of the following changes when mapping SQL to XML:</p>
<ul>
<li>
<p>Change or omit the <code dir="ltr">&lt;ROWSET&gt;</code> or <code dir="ltr">&lt;ROW&gt;</code> tag.</p>
</li>
<li>
<p>Change or omit the attribute <code dir="ltr">num</code>, which is the cardinality attribute of the <code dir="ltr">&lt;ROW&gt;</code> element.</p>
</li>
<li>
<p>Specify the case for the generated XML element names.</p>
</li>
<li>
<p>Specify that XML elements corresponding to elements of a collection must have a cardinality attribute.</p>
</li>
<li>
<p>Specify the format for dates in the XML document.</p>
</li>
<li>
<p>Specify that null values in the XML document have to be indicated with a nullness attribute rather then by omission of the element.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1014899"></a>
<div id="ADXDK19488" class="sect2">
<h3 class="sect2">How XSU Processes SQL Statements</h3>
<p>This section describes how XSU interacts with the database:</p>
<ul>
<li>
<p><a href="#i1016383">How XSU Queries the Database</a></p>
</li>
<li>
<p><a href="#i1021526">How XSU Inserts Rows</a></p>
</li>
<li>
<p><a href="#i1016401">How XSU Updates Rows</a></p>
</li>
<li>
<p><a href="#i1016408">How XSU Deletes Rows</a></p>
</li>
<li>
<p><a href="#BABFAAEE">How XSU Commits After DML</a></p>
</li>
</ul>
<a id="i1016383"></a>
<div id="ADXDK19489" class="sect3">
<h4 class="sect3"><a id="sthref343"></a><a id="sthref344"></a>How XSU Queries the Database</h4>
<p>XSU executes SQL queries and retrieves the <code dir="ltr">ResultSet</code> from the database. XSU then acquires and analyzes metadata about the <code dir="ltr">ResultSet</code>. Using the mapping described in <a href="#i1015108">"Default SQL to XML Mapping"</a>, XSU processes the SQL result set and converts it into an XML document.</p>
<p>XSU cannot handle certain types of queries, especially those that mix columns of type <code dir="ltr">LONG</code> or <code dir="ltr">LONG RAW</code> with <code dir="ltr">CURSOR()</code> expressions in the <code dir="ltr">SELECT</code> clause. <code dir="ltr">LONG</code> and <code dir="ltr">LONG RAW</code> are two examples of datatypes that JDBC accesses as streams and whose use is deprecated. If you migrate these columns to <code dir="ltr">CLOBs</code>, then the queries succeed.</p>
</div>
<!-- class="sect3" -->
<a id="i1021526"></a>
<div id="ADXDK19490" class="sect3">
<h4 class="sect3"><a id="sthref345"></a><a id="sthref346"></a>How XSU Inserts Rows</h4>
<p>When inserting the contents of an XML document into a table or view, XSU performs the following steps:</p>
<ol>
<li>
<p>Retrieves metadata about the target table or view.</p>
</li>
<li>
<p>Generates a SQL <code dir="ltr">INSERT</code> statement based on the metadata. For example, assume that the target table is <code dir="ltr">dept1</code> and the XML document is generated from <code dir="ltr">dept1</code>. XSU generates the following <code dir="ltr">INSERT</code> statement:</p>
<pre dir="ltr">
INSERT INTO dept1 (deptno, deptname, deptaddr, emplist) VALUES (?,?,?,?)
</pre></li>
<li>
<p>Parses the XML document, and for each record, it binds the appropriate values to the appropriate columns or attributes. For example, it binds the values for <code dir="ltr">INSERT</code> statement as follows:</p>
<pre dir="ltr">
deptno   &lt;- 100
deptname &lt;- SPORTS
deptaddr &lt;- AddressType('100 Redwood Shores Pkwy','Redwood Shores',
                        'CA','94065')
emplist  &lt;- EmployeeListType(EmployeeType(7369,'John',100000,
            AddressType('300 Embarcadero','Palo Alto','CA','94056'),...)
</pre></li>
<li>
<p>Executes the statement. You can optimize <code dir="ltr">INSERT</code> processing to insert in batches and commit in batches.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1015108">"Default SQL to XML Mapping"</a></p>
</li>
<li>
<p><a href="#BABBBIFA">"Inserting Rows with OracleXMLSave"</a> for more detail on batching</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1016401"></a>
<div id="ADXDK19491" class="sect3">
<h4 class="sect3"><a id="sthref347"></a><a id="sthref348"></a>How XSU Updates Rows</h4>
<p>Updates and delete statements differ from inserts in that they can affect more than one row in the database table. For inserts, each <code dir="ltr">&lt;ROW&gt;</code> element of the XML document can affect at most one row in the table if no triggers or constraints are on the table. With updates and deletes, the XML element can match more than one row if the matching columns are not key columns in the table.</p>
<p>For update statements, you must provide a list of key columns that XSU must identify the row to update. For example, assume that you have an XML document that contains the following fragment:</p>
<pre dir="ltr">
&lt;ROWSET&gt;
  &lt;ROW num="1"&gt;
    &lt;DEPTNO&gt;100&lt;/DEPTNO&gt;
    &lt;DEPTNAME&gt;SportsDept&lt;/DEPTNAME&gt;
  &lt;/ROW&gt;
&lt;/ROWSET&gt;
</pre>
<p>You want to change the <code dir="ltr">DEPTNAME</code> value from <code dir="ltr">Sports</code> to <code dir="ltr">SportsDept</code>. If you supply the <code dir="ltr">DEPTNO</code> as the key column, then XSU generates the following <code dir="ltr">UPDATE</code> statement:</p>
<pre dir="ltr">
UPDATE dept1 SET deptname = ? WHERE deptno = ?
</pre>
<p>XSU binds the values in the following way:</p>
<pre dir="ltr">
deptno &lt;- 100
deptname &lt;- SportsDept
</pre>
<p>For updates, you can also choose to update only a set of columns and not all the elements present in the XML document.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABEJABF">"Updating Rows with OracleXMLSave"</a></div>
</div>
<!-- class="sect3" -->
<a id="i1016408"></a>
<div id="ADXDK19492" class="sect3">
<h4 class="sect3">How XSU Deletes Rows</h4>
<p>For deletes, you can choose to provide a set of key columns so that XSU can identify the rows to be deleted. If you do not provide the set of key columns, then the <code dir="ltr">DELETE</code> statement tries to match all the columns in the document. Assume that you pass the following document to XSU:</p>
<pre dir="ltr">
&lt;ROWSET&gt;
 &lt;ROW num="1"&gt;
  &lt;DEPTNO&gt;100&lt;/DEPTNO&gt;
  &lt;DEPTNAME&gt;Sports&lt;/DEPTNAME&gt;
  &lt;DEPTADDR&gt;
      &lt;STREET&gt;100 Redwood Shores Pkwy&lt;/STREET&gt;
      &lt;CITY&gt;Redwood Shores&lt;/CITY&gt;
      &lt;STATE&gt;CA&lt;/STATE&gt;
      &lt;ZIP&gt;94065&lt;/ZIP&gt;
  &lt;/DEPTADDR&gt;
 &lt;/ROW&gt;
 &lt;!-- additional rows ... --&gt;
&lt;/ROWSET&gt;
</pre>
<p>XSU builds a <code dir="ltr">DELETE</code> statement for each <code dir="ltr">ROW</code> element:</p>
<pre dir="ltr">
DELETE FROM dept1 WHERE deptno = ? AND deptname = ? AND deptaddr = ?
</pre>
<p>The binding is as follows:</p>
<pre dir="ltr">
deptno   &lt;- 100
deptname &lt;- sports
deptaddr &lt;- addresstype('100 redwood shores pkwy','redwood city','ca',
            '94065')
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABJDBHE">"Deleting Rows with OracleXMLSave"</a></div>
</div>
<!-- class="sect3" -->
<a id="BABFAAEE"></a>
<div id="ADXDK19493" class="sect3">
<h4 class="sect3">How XSU Commits After DML</h4>
<p>By default XSU performs no explicit commits. If <code dir="ltr">AUTOCOMMIT</code> is on, which is the default for a JDBC connection, then after each batch of statement executions XSU executes a <code dir="ltr">COMMIT</code>. You can override this behavior by turning <code dir="ltr">AUTOCOMMIT</code> off and then using <code dir="ltr">setCommitBatch</code> to specify the number of statement executions before XSU should commit. If an error occurs, then XSU rolls back to either the state the target table was in before the call to XSU, or the state after the last commit made during the current call to XSU.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1204">
<tr>
<td class="cellalignment1213">
<table class="cellalignment1209">
<tr>
<td class="cellalignment1208"><a href="adx_j_beans.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1208"><a href="adx_j_transx.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1216">
<table class="cellalignment1207">
<tr>
<td class="cellalignment1208"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1208"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1208"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1208"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1208"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1208"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
