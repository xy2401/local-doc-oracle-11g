<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Collections and Records</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:52:56Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="controlstatements.htm" title="Previous" type="text/html" />
<link rel="Next" href="static.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/99</span> <!-- End Header -->
<div id="LNPLS005" class="chapter"><a id="CIHIEBJC"></a>
<h1 class="chapter"><span class="secnum">5</span> PL/SQL Collections and Records</h1>
<p>A <a id="sthref336"></a><a id="sthref337"></a><span class="bold">composite data type</span> stores values that have internal components. You can pass entire composite variables to subprograms as parameters, and you can access internal components of <a id="sthref338"></a><a id="sthref339"></a>composite variables individually. Internal components can be either scalar or composite. You can use scalar components wherever you can use scalar variables. PL/SQL lets you define two kinds of composite data types, collection and record. You can use composite components wherever you can use composite variables of the same type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you pass a composite variable as a parameter to a <a id="sthref340"></a>remote subprogram, then you must create a redundant loop-back <code dir="ltr">DATABASE</code> <code dir="ltr">LINK</code>, so that when the remote subprogram compiles, the type checker that verifies the source uses the same definition of the user-defined composite variable type as the invoker uses. For information about the <code dir="ltr">CREATE</code> <code dir="ltr">DATABASE</code> <code dir="ltr">LINK</code> statement, see <a class="olink SQLRF01205" href="../../server.112/e41084/statements_5005.htm#SQLRF01205"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
<p>In a <a id="sthref341"></a><span class="bold">collection</span>, the internal components always have the same data type, and are called <a id="sthref342"></a><span class="bold">elements</span>. You can access each element of a collection variable by its unique <a id="sthref343"></a>index, with this syntax: <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code>. To create a collection variable, you either define a collection type and then create a variable of that type or use <code dir="ltr">%TYPE</code>.</p>
<p>In a <a id="sthref344"></a><span class="bold">record</span>, the internal components can have different data types, and are called <a id="sthref345"></a><span class="bold">fields</span>. You can access each field of a record variable by its name, with this syntax: <a id="sthref346"></a><code dir="ltr"><span class="codeinlineitalic">variable_name.field_name</span></code>. To create a record variable, you either define a <code dir="ltr">RECORD</code> type and then create a variable of that type or use <code dir="ltr">%ROWTYPE</code> or <code dir="ltr">%TYPE</code>.</p>
<p>You can create a collection of records, and a record that contains collections.</p>
<p class="subhead2"><a id="CHDFGHJF"></a><a id="LNPLS357"></a>Collection Topics</p>
<ul>
<li>
<p><a href="#CHDBHJEI">Collection Types</a></p>
</li>
<li>
<p><a href="#CHDEIDIC">Associative Arrays</a></p>
</li>
<li>
<p><a href="#CHDEIJHD">Varrays (Variable-Size Arrays)</a></p>
</li>
<li>
<p><a href="#CHDHIGFH">Nested Tables</a></p>
</li>
<li>
<p><a href="#i20453">Collection Constructors</a></p>
</li>
<li>
<p><a href="#i20985">Assigning Values to Collection Variables</a></p>
</li>
<li>
<p><a href="#i33997">Multidimensional Collections</a></p>
</li>
<li>
<p><a href="#i36377">Collection Comparisons</a></p>
</li>
<li>
<p><a href="#i27396">Collection Methods</a></p>
</li>
<li>
<p><a href="#CJAJEIBA">Collection Types Defined in Package Specifications</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="tuning.htm#i49139">"BULK COLLECT Clause"</a> for information about retrieving query results into a collection</p>
</li>
<li>
<p><a href="collection.htm#i33100">"Collection Variable Declaration"</a> for syntax and semantics of collection type definition and collection variable declaration</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="CHDHCIAF"></a><a id="LNPLS358"></a>Record Topics</p>
<ul>
<li>
<p><a href="#CIHFCFCJ">Record Variables</a></p>
</li>
<li>
<p><a href="#i20483">Assigning Values to Record Variables</a></p>
</li>
<li>
<p><a href="#CJAIIBHD">Record Comparisons</a></p>
</li>
<li>
<p><a href="#i36801">Inserting Records into Tables</a></p>
</li>
<li>
<p><a href="#i36279">Updating Rows with Records</a></p>
</li>
<li>
<p><a href="#CJABADDJ">Restrictions on Record Inserts and Updates</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Several examples in this chapter define procedures that print their composite variables. Several of those procedures invoke this standalone procedure, which prints either its integer parameter (if it is not <code dir="ltr">NULL</code>) or the string <code dir="ltr">'NULL'</code>:
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE print (n INTEGER) IS
BEGIN
  IF n IS NOT NULL THEN
    DBMS_OUTPUT.PUT_LINE(n);
  ELSE
    DBMS_OUTPUT.PUT_LINE('NULL');
  END IF;
END print;
/
</pre>
<p>Some examples in this chapter define functions that return values of composite types.</p>
<p>You can understand the examples in this chapter without completely understanding PL/SQL procedures and functions, which are explained in <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms"</a>.</p>
</div>
<a id="CHDBHJEI"></a>
<div id="LNPLS00501" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Collection Types</h2>
<p>PL/SQL has three collection <a id="sthref347"></a>types&mdash;associative array, <code dir="ltr">VARRAY</code> (variable-size array), and nested table. <a href="#CIHHDDGF">Table 5-1</a> summarizes their similarities and differences.</p>
<div id="LNPLS359" class="tblformal">
<p class="titleintable"><a id="sthref348"></a><a id="CIHHDDGF"></a>Table 5-1 PL/SQL Collection Types</p>
<table class="cellalignment1092" title="PL/SQL Collection Types" summary="Summarizes the similarities and differences of the three types of PL/SQL collections." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t5">Collection Type</th>
<th class="cellalignment1090" id="r1c2-t5"><a href="#CIHHHHAG"><span class="xreftitlebold">Number of Elements</span></a><br /></th>
<th class="cellalignment1090" id="r1c3-t5">Index Type</th>
<th class="cellalignment1090" id="r1c4-t5"><a href="#CIHDHIFD"><span class="xreftitlebold">Dense or Sparse</span></a><br /></th>
<th class="cellalignment1090" id="r1c5-t5"><a href="#CIHCDDDG"><span class="xreftitlebold">Uninitialized Status</span></a><br /></th>
<th class="cellalignment1090" id="r1c6-t5"><a href="#CIHFCEAE"><span class="xreftitlebold">Where Defined</span></a><br /></th>
<th class="cellalignment1090" id="r1c7-t5"><a href="#CIHDDDIG"><span class="xreftitlebold">Can Be ADT Attribute Data Type</span></a><br /></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t5" headers="r1c1-t5">
<p><a id="sthref349"></a>Associative array (or index-by table)</p>
</td>
<td class="cellalignment1091" headers="r2c1-t5 r1c2-t5">
<p>Unspecified</p>
</td>
<td class="cellalignment1091" headers="r2c1-t5 r1c3-t5">
<p>String or <code dir="ltr">PLS_INTEGER</code></p>
</td>
<td class="cellalignment1091" headers="r2c1-t5 r1c4-t5">
<p>Either</p>
</td>
<td class="cellalignment1091" headers="r2c1-t5 r1c5-t5">
<p>Empty</p>
</td>
<td class="cellalignment1091" headers="r2c1-t5 r1c6-t5">
<p>In PL/SQL block or package</p>
</td>
<td class="cellalignment1091" headers="r2c1-t5 r1c7-t5">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t5" headers="r1c1-t5">
<p><a id="sthref350"></a><code dir="ltr">VARRAY</code> (variable-size array)</p>
</td>
<td class="cellalignment1091" headers="r3c1-t5 r1c2-t5">
<p>Specified</p>
</td>
<td class="cellalignment1091" headers="r3c1-t5 r1c3-t5">
<p>Integer</p>
</td>
<td class="cellalignment1091" headers="r3c1-t5 r1c4-t5">
<p>Always dense</p>
</td>
<td class="cellalignment1091" headers="r3c1-t5 r1c5-t5">
<p>Null</p>
</td>
<td class="cellalignment1091" headers="r3c1-t5 r1c6-t5">
<p>In PL/SQL block or package or at schema level</p>
</td>
<td class="cellalignment1091" headers="r3c1-t5 r1c7-t5">
<p>Only if defined at schema level</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t5" headers="r1c1-t5">
<p><a id="sthref351"></a><a id="sthref352"></a>Nested table</p>
</td>
<td class="cellalignment1091" headers="r4c1-t5 r1c2-t5">
<p>Unspecified</p>
</td>
<td class="cellalignment1091" headers="r4c1-t5 r1c3-t5">
<p>Integer</p>
</td>
<td class="cellalignment1091" headers="r4c1-t5 r1c4-t5">
<p>Starts dense, can become sparse</p>
</td>
<td class="cellalignment1091" headers="r4c1-t5 r1c5-t5">
<p>Null</p>
</td>
<td class="cellalignment1091" headers="r4c1-t5 r1c6-t5">
<p>In PL/SQL block or package or at schema level</p>
</td>
<td class="cellalignment1091" headers="r4c1-t5 r1c7-t5">
<p>Only if defined at schema level</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="CIHHHHAG"></a><a id="LNPLS360"></a>Number of Elements</p>
<p>If the number of elements is specified, it is the maximum number of elements in the collection. If the number of elements is unspecified, the maximum number of elements in the collection is the upper limit of the index type.</p>
<p class="subhead2"><a id="CIHDHIFD"></a><a id="LNPLS361"></a>Dense or Sparse</p>
<p>A <a id="sthref353"></a><span class="bold">dense collection</span> has no gaps between elements&mdash;every element between the first and last element is defined and has a value (the value can be <code dir="ltr">NULL</code> unless the element has a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint). A <a id="sthref354"></a><span class="bold">sparse collection</span> has gaps between elements.</p>
<p class="subhead2"><a id="CIHCDDDG"></a><a id="LNPLS362"></a>Uninitialized Status</p>
<p>An <a id="sthref355"></a><a id="sthref356"></a><span class="bold">empty collection</span> exists but has no elements. To add elements to an empty collection, invoke the <code dir="ltr">EXTEND</code> method (described in <a href="#CJAIJHEI">"EXTEND Collection Method"</a>).</p>
<p>A <a id="sthref357"></a><a id="sthref358"></a><span class="bold">null collection</span> (also called an <span class="bold">atomically null collection</span>) does not exist. To change a null collection to an existing collection, you must initialize it, either by making it empty or by assigning a non-<code dir="ltr">NULL</code> value to it (for details, see <a href="#i20453">"Collection Constructors"</a> and <a href="#i20985">"Assigning Values to Collection Variables"</a>). You cannot use the <code dir="ltr">EXTEND</code> method to initialize a null collection.</p>
<p class="subhead2"><a id="CIHFCEAE"></a><a id="LNPLS363"></a>Where Defined</p>
<p>A collection type defined in a PL/SQL block is a <span class="bold">local type</span>. It is available only in the block, and is stored in the database only if the block is in a standalone or package subprogram. (Standalone and package subprograms are explained in <a href="subprograms.htm#CIHCBDHB">"Nested, Package, and Standalone Subprograms"</a>.)</p>
<p>A collection type defined in a package specification is a <span class="bold">public item</span>. You can reference it from outside the package by qualifying it with the package name (<code dir="ltr"><span class="codeinlineitalic">package_name.type_name</span></code>). It is stored in the database until you drop the package. (Packages are explained in <a href="packages.htm#CIHIJECJ">Chapter 10, "PL/SQL Packages."</a>)</p>
<p>A collection type defined at schema level is a <span class="bold">standalone type</span>. You create it with the <a href="create_type.htm#BABHJHEB">"CREATE TYPE Statement"</a>. It is stored in the database until you drop it with the <a href="drop_type.htm#CJAEEEJI">"DROP TYPE Statement"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A collection type defined in a package specification is incompatible with an identically defined local or standalone collection type (see <a href="#CHDIHDIJ">Example 5-31</a> and <a href="#CIHBGBBH">Example 5-32</a>).</div>
<p class="subhead2"><a id="CIHDDDIG"></a><a id="LNPLS364"></a>Can Be ADT Attribute Data Type</p>
<p>To be an ADT attribute data type, a collection type must be a standalone collection type. For other restrictions, see <a href="create_type.htm#BABEHDBJ"><span class="xreftitlebold">Restrictions on <span class="italic">datatype</span></span></a>.</p>
<p class="subhead2"><a id="LNPLS365"></a>Translating Non-PL/SQL Composite Types to PL/SQL Composite Types</p>
<p>If you have code or business logic that uses another language, you can usually translate the array and set types of that language directly to PL/SQL collection types. For example:</p>
<div class="inftblinformal">
<table class="cellalignment1089" title="Equivalent Non-PL/SQL and PL/SQL Composite Types" summary="This table gives five examples of non-PL/SQL composite types and their equivalent PL/SQL composite types." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t7">Non-PL/SQL Composite Type</th>
<th class="cellalignment1090" id="r1c2-t7">Equivalent PL/SQL Composite Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t7" headers="r1c1-t7"><a id="sthref359"></a><a id="sthref360"></a>Hash table</td>
<td class="cellalignment1091" headers="r2c1-t7 r1c2-t7">Associative array</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t7" headers="r1c1-t7"><a id="sthref361"></a><a id="sthref362"></a>Unordered table</td>
<td class="cellalignment1091" headers="r3c1-t7 r1c2-t7">Associative array</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t7" headers="r1c1-t7"><a id="sthref363"></a>Set</td>
<td class="cellalignment1091" headers="r4c1-t7 r1c2-t7">Nested table</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t7" headers="r1c1-t7"><a id="sthref364"></a>Bag</td>
<td class="cellalignment1091" headers="r5c1-t7 r1c2-t7">Nested table</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r6c1-t7" headers="r1c1-t7"><a id="sthref365"></a>Array</td>
<td class="cellalignment1091" headers="r6c1-t7 r1c2-t7"><code dir="ltr">VARRAY</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00613" href="../../server.112/e41084/functions023.htm#SQLRF00613"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CAST</code> function, which converts one SQL data type or collection-typed value into another SQL data type or collection-typed value.</div>
</div>
<!-- class="sect1" -->
<a id="CHDEIDIC"></a>
<div id="LNPLS99969" class="sect1">
<h2 class="sect1">Associative Arrays</h2>
<p>An <a id="sthref366"></a><span class="bold">associative array</span> (formerly called <span class="bold">PL/SQL table</span> or <span class="bold">index-by table</span>) is a set of key-value pairs. Each key is a unique index, used to locate the associated value with the syntax <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code>.</p>
<p>The data type of <code dir="ltr"><span class="codeinlineitalic">index</span></code> can be either a string type or <code dir="ltr">PLS_INTEGER</code>. Indexes are stored in sort order, not creation order. For string types, sort order is determined by the initialization parameters <code dir="ltr">NLS_SORT</code> and <code dir="ltr">NLS_COMP</code>.</p>
<p>Like a database table, an associative array:</p>
<ul>
<li>
<p>Is empty (but not null) until you populate it</p>
</li>
<li>
<p>Can hold an unspecified number of elements, which you can access without knowing their positions</p>
</li>
</ul>
<p>Unlike a database table, an associative array:</p>
<ul>
<li>
<p>Does not need disk space or network operations</p>
</li>
<li>
<p>Cannot be manipulated with DML statements</p>
</li>
</ul>
<p><a href="#BABHGFHJ">Example 5-1</a> defines a type of associative array indexed by string, declares a variable of that type, populates the variable with three elements, changes the value of one element, and prints the values (in sort order, not creation order). (<code dir="ltr">FIRST</code> and <code dir="ltr">NEXT</code> are collection methods, described in <a href="#i27396">"Collection Methods"</a>.)</p>
<div id="LNPLS440" class="example">
<p class="titleinexample"><a id="BABHGFHJ"></a>Example 5-1 Associative Array Indexed by String</p>
<pre dir="ltr">
DECLARE
  -- Associative array indexed by string:
  
  TYPE population IS TABLE OF NUMBER  -- Associative array type
    INDEX BY VARCHAR2(64);            --  indexed by string
  
  city_population  population;        -- Associative array variable
  i  VARCHAR2(64);                    -- Scalar variable
  
BEGIN
  -- Add elements (key-value pairs) to associative array:
 
  city_population('Smallville')  := 2000;
  city_population('Midland')     := 750000;
  city_population('Megalopolis') := 1000000;
 
  -- Change value associated with key 'Smallville':
 
  city_population('Smallville') := 2001;
 
  -- Print associative array:
 
  i := city_population.FIRST;  -- Get first element of array
 
  WHILE i IS NOT NULL LOOP
    DBMS_Output.PUT_LINE
      ('Population of ' || i || ' is ' || city_population(i));
    i := city_population.NEXT(i);  -- Get next element of array
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Population of Megalopolis is 1000000
Population of Midland is 750000
Population of Smallville is 2001
</pre></div>
<!-- class="example" -->
<p><a href="#BEIEBJJI">Example 5-2</a> defines a type of associative array indexed by <code dir="ltr">PLS_INTEGER</code> and a function that returns an associative array of that type.</p>
<div id="LNPLS461" class="example">
<p class="titleinexample"><a id="BEIEBJJI"></a>Example 5-2 Function Returns Associative Array Indexed by PLS_INTEGER</p>
<pre dir="ltr">
DECLARE
  <span class="bold">TYPE sum_multiples IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;</span>
  n  PLS_INTEGER := 5;   -- number of multiples to sum for display
  sn PLS_INTEGER := 10;  -- number of multiples to sum
  m  PLS_INTEGER := 3;   -- multiple

  <span class="bold">FUNCTION get_sum_multiples (</span>
    multiple IN PLS_INTEGER,
    num      IN PLS_INTEGER
  <span class="bold">) RETURN sum_multiples</span>
  IS
    s sum_multiples;
  BEGIN
    FOR i IN 1..num LOOP
      s(i) := multiple * ((i * (i + 1)) / 2);  -- sum of multiples
    END LOOP;
    RETURN s;
  END get_sum_multiples;

BEGIN
  DBMS_OUTPUT.PUT_LINE (
    'Sum of the first ' || TO_CHAR(n) || ' multiples of ' ||
    TO_CHAR(m) || ' is ' || TO_CHAR(get_sum_multiples (m, sn)(n))
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Sum of the first 5 multiples of 3 is 45
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS366"></a>Topics</p>
<ul>
<li>
<p><a href="#BABEADJA">Declaring Associative Array Constants</a></p>
</li>
<li>
<p><a href="#CIHDIIGC">NLS Parameter Values Affect Associative Arrays Indexed by String</a></p>
</li>
<li>
<p><a href="#CIHBEIII">Appropriate Uses for Associative Arrays</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CIHHDDGF">Table 5-1</a> for a summary of associative array characteristics</p>
</li>
<li>
<p><a href="collection.htm#CJABHAHJ">"<span class="italic">assoc_array_type_def</span> ::="</a> for the syntax of an associative array type definition</p>
</li>
</ul>
</div>
<a id="BABEADJA"></a>
<div id="LNPLS99857" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Declaring Associative Array Constants</h3>
<p><a id="sthref367"></a><a id="sthref368"></a>When declaring an associative array constant, you must create a function that populates the associative array with its initial value and then invoke the function in the constant declaration, as in <a href="#BABIBCCB">Example 5-3</a>. (The function does for the associative array what a constructor does for a varray or nested table. For information about constructors, see <a href="#i20453">"Collection Constructors"</a>.)</p>
<div id="LNPLS367" class="example">
<p class="titleinexample"><a id="BABIBCCB"></a>Example 5-3 Declaring Associative Array Constant</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE My_Types AUTHID DEFINER IS
  TYPE My_AA IS TABLE OF VARCHAR2(20) INDEX BY PLS_INTEGER;
  FUNCTION Init_My_AA RETURN My_AA;
END My_Types;
/
CREATE OR REPLACE PACKAGE BODY My_Types IS
  <span class="bold">FUNCTION Init_My_AA RETURN My_AA IS</span>
    <span class="bold">Ret My_AA;</span>
  <span class="bold">BEGIN</span>
    <span class="bold">Ret(-10) := '-ten';</span>
    <span class="bold">Ret(0) := 'zero';</span>
    <span class="bold">Ret(1) := 'one';</span>
    <span class="bold">Ret(2) := 'two';</span>
    <span class="bold">Ret(3) := 'three';</span>
    <span class="bold">Ret(4) := 'four';</span>
    <span class="bold">Ret(9) := 'nine';</span>
    <span class="bold">RETURN Ret;</span>
  <span class="bold">END Init_My_AA;</span>
END My_Types;
/
DECLARE
  <span class="bold">v CONSTANT My_Types.My_AA := My_Types.Init_My_AA();</span>
BEGIN
  DECLARE
    Idx PLS_INTEGER := v.FIRST();
  BEGIN
    WHILE Idx IS NOT NULL LOOP
      DBMS_OUTPUT.PUT_LINE(TO_CHAR(Idx, '999')||LPAD(v(Idx), 7));
      Idx := v.NEXT(Idx);
    END LOOP;
  END;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
-10   -ten
0   zero
1    one
2    two
3  three
4   four
9   nine
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHDIIGC"></a>
<div id="LNPLS99931" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">NLS Parameter Values Affect Associative Arrays Indexed by String</h3>
<p><a id="sthref369"></a><a id="sthref370"></a>National Language Support (NLS) parameters such as <code dir="ltr">NLS_SORT</code>, <code dir="ltr">NLS_COMP</code>, and <code dir="ltr">NLS_DATE_FORMAT</code> affect associative arrays indexed by string.</p>
<p class="subhead2"><a id="LNPLS368"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHFGIDG">Changing NLS Parameter Values After Populating Associative Arrays</a></p>
</li>
<li>
<p><a href="#CIHCIJIE">Indexes of Data Types Other Than VARCHAR2</a></p>
</li>
<li>
<p><a href="#CIHDGAJD">Passing Associative Arrays to Remote Databases</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG229" href="../../server.112/e10729/ch3globenv.htm#NLSPG229"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about linguistic sort parameters</div>
<a id="CIHFGIDG"></a>
<div id="LNPLS369" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Changing NLS Parameter Values After Populating Associative Arrays</h4>
<p>The initialization parameters <code dir="ltr">NLS_SORT</code> and <code dir="ltr">NLS_COMP</code> determine the storage order of string indexes of an associative array. If you change the value of either parameter after populating an associative array indexed by string, then the collection methods <code dir="ltr">FIRST</code>, <code dir="ltr">LAST</code>, <code dir="ltr">NEXT</code>, and <code dir="ltr">PRIOR</code> (described in <a href="#i27396">"Collection Methods"</a>) might return unexpected values or raise exceptions. If you must change these parameter values during your session, restore their original values before operating on associative arrays indexed by string.</p>
</div>
<!-- class="sect3" -->
<a id="CIHCIJIE"></a>
<div id="LNPLS370" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Indexes of Data Types Other Than VARCHAR2</h4>
<p>In the declaration of an associative array indexed by string, the string type must be <code dir="ltr">VARCHAR2</code> or one of its subtypes. However, you can populate the associative array with indexes of any data type that the <code dir="ltr">TO_CHAR</code> function can convert to <code dir="ltr">VARCHAR2</code>. (For information about <code dir="ltr">TO_CHAR</code>, see <a class="olink SQLRF06128" href="../../server.112/e41084/functions199.htm#SQLRF06128"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<p>If your indexes have data types other than <code dir="ltr">VARCHAR2</code> and its subtypes, ensure that these indexes remain consistent and unique if the values of initialization parameters change. For example:</p>
<ul>
<li>
<p>Do not use <code dir="ltr">TO_CHAR(SYSDATE)</code> as an index.</p>
<p>If the value of <code dir="ltr">NLS_DATE_FORMAT</code> changes, then the value of <code dir="ltr">(TO_CHAR(SYSDATE))</code> might also change.</p>
</li>
<li>
<p>Do not use different <code dir="ltr">NVARCHAR2</code> indexes that might be converted to the same <code dir="ltr">VARCHAR2</code> value.</p>
</li>
<li>
<p>Do not use <code dir="ltr">CHAR</code> or <code dir="ltr">VARCHAR2</code> indexes that differ only in case, accented characters, or punctuation characters.</p>
<p>If the value of <code dir="ltr">NLS_SORT</code> ends in <code dir="ltr">_CI</code> (case-insensitive comparisons) or <code dir="ltr">_AI</code> (accent- and case-insensitive comparisons), then indexes that differ only in case, accented characters, or punctuation characters might be converted to the same value.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIHDGAJD"></a>
<div id="LNPLS371" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Passing Associative Arrays to Remote Databases</h4>
<p>If you pass an associative array as a parameter to a remote database, and the local and the remote databases have different <code dir="ltr">NLS_SORT</code> or <code dir="ltr">NLS_COMP</code> values, then:</p>
<ul>
<li>
<p>The collection method <code dir="ltr">FIRST</code>, <code dir="ltr">LAST</code>, <code dir="ltr">NEXT</code> or <code dir="ltr">PRIOR</code> (described in <a href="#i27396">"Collection Methods"</a>) might return unexpected values or raise exceptions.</p>
</li>
<li>
<p>Indexes that are unique on the local database might not be unique on the remote database, raising the predefined exception <code dir="ltr">VALUE_ERROR</code>.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHBEIII"></a>
<div id="LNPLS99930" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Appropriate Uses for Associative Arrays</h3>
<p>An associative array is appropriate for:</p>
<ul>
<li>
<p>A relatively small lookup table, which can be constructed in memory each time you invoke the subprogram or initialize the package that declares it</p>
</li>
<li>
<p>Passing collections to and from the database server</p>
<p>Declare formal subprogram parameters of associative array types. With <a id="sthref371"></a><a id="sthref372"></a>Oracle Call Interface (OCI) or an Oracle precompiler, bind the host arrays to the corresponding actual parameters. PL/SQL automatically converts between host arrays and associative arrays indexed by <code dir="ltr">PLS_INTEGER</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot declare an associative array type at schema level. Therefore, to pass an associative array variable as a parameter to a standalone subprogram, you must declare the type of that variable in a package specification. Doing so makes the type available to both the invoked subprogram (which declares a formal parameter of that type) and the invoking subprogram or anonymous block (which declares and passes the variable of that type). See <a href="packages.htm#BABDFGED">Example 10-2</a>.</div>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
The most efficient way to pass collections to and from the database server is to use associative arrays with the <code dir="ltr">FORALL</code> statement or <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause. For details, see <a href="tuning.htm#i54218">"FORALL Statement"</a> and <a href="tuning.htm#i49139">"BULK COLLECT Clause"</a>.</div>
</li>
</ul>
<p>An associative array is intended for temporary data storage. To make an associative array persistent for the life of a database session, declare it in a package specification and populate it in the package body.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEIJHD"></a>
<div id="LNPLS443" class="sect1">
<h2 class="sect1">Varrays (Variable-Size Arrays)</h2>
<p>A <a id="sthref373"></a><span class="bold">varray (variable-size array)</span> is an array whose number of elements can vary from zero (empty) to the declared maximum size. To access an element of a varray variable, use the syntax <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code>. The lower bound of <code dir="ltr"><span class="codeinlineitalic">index</span></code> is 1; the upper bound is the current number of elements. The upper bound changes as you add or delete elements, but it cannot exceed the maximum size. When you store and retrieve a varray from the database, its indexes and element order remain stable.</p>
<p><a href="#CIHGHIBH">Figure 5-1</a>shows a varray variable named <code dir="ltr">Grades</code>, which has maximum size 10 and contains seven elements. <code dir="ltr">Grades</code>(<code dir="ltr"><span class="codeinlineitalic">n</span></code>) references the <span class="italic">n</span>th element of <code dir="ltr">Grades</code>. The upper bound of <code dir="ltr">Grades</code> is 7, and it cannot exceed 10.</p>
<div id="LNPLS372" class="figure">
<p class="titleinfigure"><a id="CIHGHIBH"></a>Figure 5-1 Varray of Maximum Size 10 with 7 Elements</p>
<img width="443" height="65" src="img/lnpls017.gif" alt="Description of Figure 5-1 follows" /><br />
<a id="sthref374" href="img_text/lnpls017.htm">Description of "Figure 5-1 Varray of Maximum Size 10 with 7 Elements"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The database stores a varray variable as a single object. If a varray variable is less than 4 KB, it resides inside the table of which it is a column; otherwise, it resides outside the table but in the same tablespace.</p>
<p>An uninitialized varray variable is a null collection. You must <a id="sthref375"></a>initialize it, either by making it empty or by assigning a non-<code dir="ltr">NULL</code> value to it. For details, see <a href="#i20453">"Collection Constructors"</a> and <a href="#i20985">"Assigning Values to Collection Variables"</a>.</p>
<p><a href="#CIHFJAAD">Example 5-4</a> defines a local <code dir="ltr">VARRAY</code> type, declares a variable of that type (initializing it with a constructor), and defines a procedure that prints the varray. The example invokes the procedure three times: After initializing the variable, after changing the values of two elements individually, and after using a constructor to the change the values of all elements. (For an example of a procedure that prints a varray that might be null or empty, see <a href="#CIHHAEGC">Example 5-24</a>.)</p>
<div id="LNPLS373" class="example">
<p class="titleinexample"><a id="CIHFJAAD"></a>Example 5-4 Varray (Variable-Size Array)</p>
<pre dir="ltr">
DECLARE
  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);  -- VARRAY type
 
  -- varray variable initialized with constructor:
 
  team Foursome := Foursome('John', 'Mary', 'Alberto', 'Juanita');
 
  PROCEDURE print_team (heading VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    FOR i IN 1..4 LOOP
      DBMS_OUTPUT.PUT_LINE(i || '.' || team(i));
    END LOOP;
 
    DBMS_OUTPUT.PUT_LINE('---'); 
  END;
  
BEGIN 
  print_team('2001 Team:');
 
  team(3) := 'Pierre';  -- Change values of two elements
  team(4) := 'Yvonne';
  print_team('2005 Team:');
 
  -- Invoke constructor to assign new values to varray variable:
 
  team := Foursome('Arun', 'Amitha', 'Allan', 'Mae');
  print_team('2009 Team:');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
2001 Team:
1.John
2.Mary
3.Alberto
4.Juanita
---
2005 Team:
1.John
2.Mary
3.Pierre
4.Yvonne
---
2009 Team:
1.Arun
2.Amitha
3.Allan
4.Mae
---
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS375"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHCFBDB">Appropriate Uses for Varrays</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CIHHDDGF">Table 5-1</a> for a summary of varray characteristics</p>
</li>
<li>
<p><a href="collection.htm#CJAEAJJA">"<span class="italic">varray_type_def</span> ::="</a> for the syntax of a <code dir="ltr">VARRAY</code> type definition</p>
</li>
<li>
<p><a href="create_type.htm#BABHJHEB">"CREATE TYPE Statement"</a> for information about creating standalone <code dir="ltr">VARRAY</code> types</p>
</li>
<li>
<p><a class="olink SQLRF51007" href="../../server.112/e41084/sql_elements001.htm#SQLRF51007"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about varrays</p>
</li>
</ul>
</div>
<a id="CIHCFBDB"></a>
<div id="LNPLS99929" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Appropriate Uses for Varrays</h3>
<p>A varray is appropriate when:</p>
<ul>
<li>
<p>You know the maximum number of elements.</p>
</li>
<li>
<p>You usually access the elements sequentially.</p>
</li>
</ul>
<p>Because you must store or retrieve all elements at the same time, a varray might be impractical for large numbers of elements.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDHIGFH"></a>
<div id="LNPLS99981" class="sect1">
<h2 class="sect1">Nested Tables</h2>
<p>In the database, a <a id="sthref376"></a><a id="sthref377"></a><span class="bold">nested table</span> is a column type that stores an unspecified number of rows in no particular order. When you retrieve a nested table value from the database into a PL/SQL nested table variable, PL/SQL gives the rows consecutive indexes, starting at 1. Using these indexes, you can access the individual rows of the nested table variable. The syntax is <code dir="ltr"><span class="codeinlineitalic">variable_name</span></code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code>. The indexes and row order of a nested table might not remain stable as you store and retrieve the nested table from the database.</p>
<p>The amount of memory that a nested table variable occupies can increase or decrease dynamically, as you add or delete elements.</p>
<p>An uninitialized nested table variable is a null collection. You must <a id="sthref378"></a>initialize it, either by making it empty or by assigning a non-<code dir="ltr">NULL</code> value to it. For details, see <a href="#i20453">"Collection Constructors"</a> and <a href="#i20985">"Assigning Values to Collection Variables"</a>.</p>
<p><a href="#CIHCICAE">Example 5-5</a> defines a local nested table type, declares a variable of that type (initializing it with a constructor), and defines a procedure that prints the nested table. (The procedure uses the collection methods <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code>, described in <a href="#i27396">"Collection Methods"</a>.) The example invokes the procedure three times: After initializing the variable, after changing the value of one element, and after using a constructor to the change the values of all elements. After the second constructor invocation, the nested table has only two elements. Referencing element 3 would raise error ORA-06533.</p>
<div id="LNPLS376" class="example">
<p class="titleinexample"><a id="CIHCICAE"></a>Example 5-5 Nested Table of Local Type</p>
<pre dir="ltr">
DECLARE
  TYPE Roster IS TABLE OF VARCHAR2(15);  -- nested table type
 
  -- nested table variable initialized with constructor:
 
  names Roster := Roster('D Caruso', 'J Hamil', 'D Piro', 'R Singh');
 
  PROCEDURE print_names (heading VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    FOR i IN names.FIRST .. names.LAST LOOP  -- For first to last element
      DBMS_OUTPUT.PUT_LINE(names(i));
    END LOOP;
 
    DBMS_OUTPUT.PUT_LINE('---');
  END;
  
BEGIN 
  print_names('Initial Values:');
 
  names(3) := 'P Perez';  -- Change value of one element
  print_names('Current Values:');
 
  names := Roster('A Jansen', 'B Gupta');  -- Change entire table
  print_names('Current Values:');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Initial Values:
D Caruso
J Hamil
D Piro
R Singh
---
Current Values:
D Caruso
J Hamil
P Perez
R Singh
---
Current Values:
A Jansen
B Gupta
</pre></div>
<!-- class="example" -->
<p><a href="#CIHDEIIG">Example 5-6</a> defines a standalone nested table type, <code dir="ltr">nt_type</code>, and a standalone procedure to print a variable of that type, <code dir="ltr">print_nt</code>. (The procedure uses the collection methods <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code>, described in <a href="#i27396">"Collection Methods"</a>.) An anonymous block declares a variable of type <code dir="ltr">nt_type</code>, initializing it to empty with a constructor, and invokes <code dir="ltr">print_nt</code> twice: After initializing the variable and after using a constructor to the change the values of all elements.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a href="#CIHJFHJE">Example 5-17</a>, <a href="#BABHDBGC">Example 5-19</a>, and <a href="#BABBGAIB">Example 5-20</a> reuse <code dir="ltr">nt_type</code> and <code dir="ltr">print_nt</code>.</div>
<div id="LNPLS377" class="example">
<p class="titleinexample"><a id="CIHDEIIG"></a>Example 5-6 Nested Table of Standalone Type</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE nt_type IS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE print_nt (nt nt_type) IS
  i  NUMBER;
BEGIN
  i := nt.FIRST;
 
  IF i IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('nt is empty');
  ELSE
    WHILE i IS NOT NULL LOOP
      DBMS_OUTPUT.PUT('nt.(' || i || ') = '); print(nt(i));
      i := nt.NEXT(i);
    END LOOP;
  END IF;
 
  DBMS_OUTPUT.PUT_LINE('---');
END print_nt;
/
DECLARE
  nt nt_type := nt_type();  -- nested table variable initialized to empty
BEGIN
  print_nt(nt);
  nt := nt_type(90, 9, 29, 58);
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
nt is empty
---
nt.(1) = 90
nt.(2) = 9
nt.(3) = 29
nt.(4) = 58
---
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS378"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHBBBAH">Important Differences Between Nested Tables and Arrays</a></p>
</li>
<li>
<p><a href="#CIHDGDHJ">Appropriate Uses for Nested Tables</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CIHHDDGF">Table 5-1</a> for a summary of nested table characteristics</p>
</li>
<li>
<p><a href="collection.htm#CJAFJBHF">"<span class="italic">nested_table_type_def</span> ::="</a> for the syntax of a nested table type definition</p>
</li>
<li>
<p><a href="create_type.htm#BABHJHEB">"CREATE TYPE Statement"</a> for information about creating standalone nested table types</p>
</li>
<li>
<p><a href="triggers.htm#CIHGDJFJ">"INSTEAD OF Triggers on Nested Table Columns of Views"</a> for information about triggers that update nested table columns of views</p>
</li>
<li>
<p><a class="olink SQLRF51008" href="../../server.112/e41084/sql_elements001.htm#SQLRF51008"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about nested tables</p>
</li>
</ul>
</div>
<a id="CIHBBBAH"></a>
<div id="LNPLS99928" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Important Differences Between Nested Tables and Arrays</h3>
<p>Conceptually, a nested table is like a one-dimensional array with an arbitrary number of elements. However, a nested table differs from an array in these important ways:</p>
<ul>
<li>
<p>An array has a declared number of elements, but a nested table does not. The size of a nested table can increase dynamically.</p>
</li>
<li>
<p>An array is always dense. A nested array is dense initially, but it can become sparse, because you can delete elements from it.</p>
</li>
</ul>
<p><a href="#CIHBBFBJ">Figure 5-2</a> shows the important differences between a nested table and an array.</p>
<div id="LNPLS380" class="figure">
<p class="titleinfigure"><a id="CIHBBFBJ"></a>Figure 5-2 Array and Nested Table</p>
<img width="470" height="156" src="img/lnpls016.gif" alt="Description of Figure 5-2 follows" /><br />
<a id="sthref379" href="img_text/lnpls016.htm">Description of "Figure 5-2 Array and Nested Table"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="CIHDGDHJ"></a>
<div id="LNPLS99927" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Appropriate Uses for Nested Tables</h3>
<p>A nested table is appropriate when:</p>
<ul>
<li>
<p>The number of elements is not set.</p>
</li>
<li>
<p>Index values are not consecutive.</p>
</li>
<li>
<p>You must delete or update some elements, but not all elements simultaneously.</p>
<p>Nested table data is stored in a separate <a id="sthref380"></a><a id="sthref381"></a>store table, a system-generated database table. When you access a nested table, the database joins the nested table with its store table. This makes nested tables suitable for queries and updates that affect only some elements of the collection.</p>
</li>
<li>
<p>You would create a separate lookup table, with multiple entries for each row of the main table, and access it through join queries.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i20453"></a>
<div id="LNPLS00504" class="sect1">
<h2 class="sect1">Collection Constructors</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
This topic applies only to varrays and nested tables. Associative arrays do not have constructors. In this topic, <span class="italic">collection</span> means <span class="italic">varray or nested table</span>.</div>
<p>A <a id="sthref382"></a><span class="bold">collection constructor (constructor)</span> is a system-defined function with the same name as a collection type, which returns a collection of that type. The syntax of a constructor invocation is:</p>
<pre dir="ltr">
<span class="italic">collection_type</span> ( [ <span class="italic">value</span> [, <span class="italic">value</span> ]... ] )
</pre>
<p>If the parameter list is empty, the constructor returns an <a id="sthref383"></a><a id="sthref384"></a>empty collection. Otherwise, the constructor returns a collection that contains the specified values. For semantic details, see <a href="expression.htm#CHDGAFDC">"<span class="italic">collection_constructor</span>"</a>.</p>
<p>You can assign the returned collection to a collection variable (of the same type) in the variable declaration and in the executable part of a block.</p>
<p><a href="#CIHCBBJJ">Example 5-7</a> invokes a constructor twice: to initialize the varray variable <code dir="ltr">team</code> to empty in its declaration, and to give it new values in the executable part of the block. The procedure <code dir="ltr">print_team</code> shows the initial and final values of <code dir="ltr">team</code>. To determine when <code dir="ltr">team</code> is empty, <code dir="ltr">print_team</code> uses the collection method <code dir="ltr">COUNT</code>, described in <a href="#i27396">"Collection Methods"</a>. (For an example of a procedure that prints a varray that might be null, see <a href="#CIHHAEGC">Example 5-24</a>.)</p>
<div id="LNPLS381" class="example">
<p class="titleinexample"><a id="CIHCBBJJ"></a>Example 5-7 Initializing Collection (Varray) Variable to Empty</p>
<pre dir="ltr">
DECLARE
  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);
  <span class="bold">team Foursome := Foursome();  -- initialize to empty</span>
 
  PROCEDURE print_team (heading VARCHAR2)
  IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    IF team.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('Empty');
    ELSE 
      FOR i IN 1..4 LOOP
        DBMS_OUTPUT.PUT_LINE(i || '.' || team(i));
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE('---'); 
  END;
 
BEGIN
  print_team('Team:');
  <span class="bold">team := Foursome('John', 'Mary', 'Alberto', 'Juanita');</span>
  print_team('Team:');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Team:
Empty
---
Team:
1.John
2.Mary
3.Alberto
4.Juanita
---
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i20985"></a>
<div id="LNPLS00505" class="sect1">
<h2 class="sect1">Assigning Values to Collection Variables</h2>
<p><a id="sthref385"></a><a id="sthref386"></a>You can assign a value to a collection variable in these ways:</p>
<ul>
<li>
<p>Invoke a constructor to create a collection and assign it to the collection variable, as explained in <a href="#i20453">"Collection Constructors"</a>.</p>
</li>
<li>
<p>Use the assignment statement (described in <a href="assignment_statement.htm#CHDIGIFB">"Assignment Statement"</a>) to assign it the value of another existing collection variable.</p>
</li>
<li>
<p>Pass it to a subprogram as an <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameter, and then assign the value inside the subprogram.</p>
</li>
</ul>
<p>To assign a value to a scalar element of a collection variable, reference the element as <code dir="ltr"><span class="codeinlineitalic">collection_variable_name</span></code><code dir="ltr">(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code> and assign it a value as instructed in <a href="fundamentals.htm#i16001">"Assigning Values to Variables"</a>.</p>
<p class="subhead2"><a id="LNPLS382"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHJJIBC">Data Type Compatibility</a></p>
</li>
<li>
<p><a href="#CIHGCGHF">Assigning Null Values to Varray or Nested Table Variables</a></p>
</li>
<li>
<p><a href="#CIHIHEHG">Assigning Set Operation Results to Nested Table Variables</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="tuning.htm#i49139">"BULK COLLECT Clause"</a></div>
<a id="CIHJJIBC"></a>
<div id="LNPLS99918" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Data Type Compatibility</h3>
<p><a id="sthref387"></a><a id="sthref388"></a><a id="sthref389"></a>You can assign a collection to a collection variable only if they have the same data type. Having the same element type is not enough.</p>
<p>In <a href="#BABHBDJJ">Example 5-8</a>, <code dir="ltr">VARRAY</code> types <code dir="ltr">triplet</code> and <code dir="ltr">trio</code> have the same element type, <code dir="ltr">VARCHAR(15)</code>. Collection variables <code dir="ltr">group1</code> and <code dir="ltr">group2</code> have the same data type, <code dir="ltr">triplet</code>, but collection variable <code dir="ltr">group3</code> has the data type <code dir="ltr">trio</code>. The assignment of <code dir="ltr">group1</code> to <code dir="ltr">group2</code> succeeds, but the assignment of <code dir="ltr">group1</code> to <code dir="ltr">group3</code> fails.</p>
<div id="LNPLS462" class="example">
<p class="titleinexample"><a id="BABHBDJJ"></a>Example 5-8 Data Type Compatibility for Collection Assignment</p>
<pre dir="ltr">
DECLARE
  TYPE triplet IS VARRAY(3) OF VARCHAR2(15);
  TYPE trio    IS VARRAY(3) OF VARCHAR2(15);
 
  group1 triplet := triplet('Jones', 'Wong', 'Marceau');
  <span class="bold">group2 triplet;</span>
  <span class="bold">group3 trio;</span>
BEGIN
  group2 := group1;  -- succeeds
  <span class="bold">group3 := group1;  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
ERROR at line 10:
ORA-06550: line 10, column 13:
PLS-00382: expression is of wrong type
ORA-06550: line 10, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHGCGHF"></a>
<div id="LNPLS99917" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Assigning Null Values to Varray or Nested Table Variables</h3>
<p>To a <a id="sthref390"></a>varray or <a id="sthref391"></a>nested table variable, you can assign the value <a id="sthref392"></a><code dir="ltr">NULL</code> or a <a id="sthref393"></a><a id="sthref394"></a>null collection of the same data type. Either assignment makes the variable null.</p>
<p><a href="#CIHCBBJJ">Example 5-7</a> initializes the nested table variable <code dir="ltr">dname_tab</code> to a non-null value; assigns a null collection to it, making it null; and re-initializes it to a different non-null value.</p>
<div id="LNPLS463" class="example">
<p class="titleinexample"><a id="BABEFBBB"></a>Example 5-9 Assigning Null Value to Nested Table Variable</p>
<pre dir="ltr">
DECLARE
  TYPE dnames_tab IS TABLE OF VARCHAR2(30);
 
  dept_names dnames_tab := dnames_tab(
    'Shipping','Sales','Finance','Payroll');  -- Initialized to non-null value
 
  empty_set dnames_tab;  -- Not initialized, therefore null
 
  PROCEDURE print_dept_names_status IS
  BEGIN
    IF dept_names IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('dept_names is null.');
    ELSE
      DBMS_OUTPUT.PUT_LINE('dept_names is not null.');
    END IF;
  END  print_dept_names_status;
 
BEGIN
  print_dept_names_status;
  <span class="bold">dept_names := empty_set;  -- Assign null collection to dept_names.</span>
  print_dept_names_status;
  dept_names := dnames_tab (
    'Shipping','Sales','Finance','Payroll');  -- Re-initialize dept_names
  print_dept_names_status;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
dept_names is not null.
<span class="bold">dept_names is null.</span>
dept_names is not null.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHIHEHG"></a>
<div id="LNPLS99916" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Assigning Set Operation Results to Nested Table Variables</h3>
<p>To a <a id="sthref395"></a>nested table variable, you can assign the result of a SQL <code dir="ltr">MULTISET</code> operation or SQL <code dir="ltr">SET</code> function invocation.</p>
<p>The <a id="sthref396"></a>SQL <code dir="ltr">MULTISET</code> operators combine two nested tables into a single nested table. The elements of the two nested tables must have comparable data types. For information about the <code dir="ltr">MULTISET</code> operators, see <a class="olink SQLRF0032" href="../../server.112/e41084/operators006.htm#SQLRF0032"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>The SQL <code dir="ltr">SET</code> function takes a nested table argument and returns a nested table of the same data type whose elements are distinct (the function eliminates duplicate elements). For information about the <code dir="ltr">SET</code> function, see <a class="olink SQLRF06308" href="../../server.112/e41084/functions163.htm#SQLRF06308"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p><a href="#BABFIDIG">Example 5-10</a> assigns the results of several <code dir="ltr">MULTISET</code> operations and one <code dir="ltr">SET</code> function invocation of the nested table variable <code dir="ltr">answer</code>, using the procedure <code dir="ltr">print_nested_table</code> to print <code dir="ltr">answer</code> after each assignment. The procedure use the collection methods <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code>, described in <a href="#i27396">"Collection Methods"</a>.</p>
<div id="LNPLS464" class="example">
<p class="titleinexample"><a id="BABFIDIG"></a>Example 5-10 Assigning Set Operation Results to Nested Table Variable</p>
<pre dir="ltr">
DECLARE
  TYPE nested_typ IS TABLE OF NUMBER;
 
  nt1    nested_typ := nested_typ(1,2,3);
  nt2    nested_typ := nested_typ(3,2,1);
  nt3    nested_typ := nested_typ(2,3,1,3);
  nt4    nested_typ := nested_typ(1,2,4);
  answer nested_typ;
 
  PROCEDURE print_nested_table (nt nested_typ) IS
    output VARCHAR2(128);
  BEGIN
    IF nt IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('Result: null set');
    ELSIF nt.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('Result: empty set');
    ELSE
      FOR i IN nt.FIRST .. nt.LAST LOOP  -- For first to last element
        output := output || nt(i) || ' ';
      END LOOP;
      DBMS_OUTPUT.PUT_LINE('Result: ' || output);
    END IF;
  END print_nested_table;
 
BEGIN
  <span class="bold">answer := nt1 MULTISET UNION nt4;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt1 MULTISET UNION nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt1 MULTISET UNION DISTINCT nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt2 MULTISET INTERSECT nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt2 MULTISET INTERSECT DISTINCT nt3;</span>
  print_nested_table(answer);
  <span class="bold">answer := SET(nt3);</span>
  print_nested_table(answer);
  <span class="bold">answer := nt3 MULTISET EXCEPT nt2;</span>
  print_nested_table(answer);
  <span class="bold">answer := nt3 MULTISET EXCEPT DISTINCT nt2;</span>
  print_nested_table(answer);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Result: 1 2 3 1 2 4
Result: 1 2 3 2 3 1 3
Result: 1 2 3
Result: 3 2 1
Result: 3 2 1
Result: 2 3 1
Result: 3
Result: empty set
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i33997"></a>
<div id="LNPLS00507" class="sect1">
<h2 class="sect1">Multidimensional Collections</h2>
<p>Although a collection has only one dimension, you can model a <a id="sthref397"></a><a id="sthref398"></a>multidimensional collection with a collection whose elements are collections.</p>
<p>In <a href="#BABHFDCF">Example 5-11</a>, <code dir="ltr">nva</code> is a two-dimensional varray&mdash;a varray of varrays of integers.</p>
<div id="LNPLS470" class="example">
<p class="titleinexample"><a id="BABHFDCF"></a>Example 5-11 Two-Dimensional Varray (Varray of Varrays)</p>
<pre dir="ltr">
DECLARE
  TYPE t1 IS VARRAY(10) OF INTEGER;  -- varray of integer
  va t1 := t1(2,3,5);

  TYPE nt1 IS VARRAY(10) OF t1;      -- varray of varray of integer
  nva nt1 := nt1(va, t1(55,6,73), t1(2,4), va);

  i INTEGER;
  va1 t1;
BEGIN
  i := nva(2)(3);
  DBMS_OUTPUT.PUT_LINE('i = ' || i);

  nva.EXTEND;
  nva(5) := t1(56, 32);          -- replace inner varray elements
  nva(4) := t1(45,43,67,43345);  -- replace an inner integer element
  nva(4)(4) := 1;                -- replace 43345 with 1

  nva(4).EXTEND;    -- add element to 4th varray element
  nva(4)(5) := 89;  -- store integer 89 there
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
i = 73
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABBHGFG">Example 5-12</a>, <code dir="ltr">ntb1</code> is a nested table of nested tables of strings, and <code dir="ltr">ntb2</code> is a nested table of varrays of integers.</p>
<div id="LNPLS471" class="example">
<p class="titleinexample"><a id="BABBHGFG"></a>Example 5-12 Nested Tables of Nested Tables and Varrays of Integers</p>
<pre dir="ltr">
DECLARE
  TYPE tb1 IS TABLE OF VARCHAR2(20);  -- nested table of strings
  vtb1 tb1 := tb1('one', 'three');

  TYPE ntb1 IS TABLE OF tb1; -- nested table of nested tables of strings
  vntb1 ntb1 := ntb1(vtb1);

  TYPE tv1 IS VARRAY(10) OF INTEGER;  -- varray of integers
  TYPE ntb2 IS TABLE OF tv1;          -- nested table of varrays of integers
  vntb2 ntb2 := ntb2(tv1(3,5), tv1(5,7,3));

BEGIN
  vntb1.EXTEND;
  vntb1(2) := vntb1(1);
  vntb1.DELETE(1);     -- delete first element of vntb1
  vntb1(2).DELETE(1);  -- delete first string from second table in nested table
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABIBDDG">Example 5-13</a>, <code dir="ltr">aa1</code> is an associative array of associative arrays, and <code dir="ltr">ntb2</code> is a nested table of varrays of strings.</p>
<div id="LNPLS472" class="example">
<p class="titleinexample"><a id="BABIBDDG"></a>Example 5-13 Nested Tables of Associative Arrays and Varrays of Strings</p>
<pre dir="ltr">
DECLARE
  TYPE tb1 IS TABLE OF INTEGER INDEX BY PLS_INTEGER;  -- associative arrays
  v4 tb1;
  v5 tb1;

  TYPE aa1 IS TABLE OF tb1 INDEX BY PLS_INTEGER;  -- associative array of
  v2 aa1;                                         --  associative arrays

  TYPE va1 IS VARRAY(10) OF VARCHAR2(20);  -- varray of strings
  v1 va1 := va1('hello', 'world');

  TYPE ntb2 IS TABLE OF va1 INDEX BY PLS_INTEGER;  -- associative array of varrays
  v3 ntb2;

BEGIN
  v4(1)   := 34;     -- populate associative array
  v4(2)   := 46456;
  v4(456) := 343;

  v2(23) := v4;  -- populate associative array of associative arrays

  v3(34) := va1(33, 456, 656, 343);  -- populate associative array varrays

  v2(35) := v5;      -- assign empty associative array to v2(35)
  v2(35)(2) := 78;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i36377"></a>
<div id="LNPLS00506" class="sect1">
<h2 class="sect1">Collection Comparisons</h2>
<p><a id="sthref399"></a><a id="sthref400"></a>You cannot compare <a id="sthref401"></a><a id="sthref402"></a>associative array variables to the value <code dir="ltr">NULL</code> or to each other.</p>
<p>Except for <a href="#CIHJHBFI">Comparing Nested Tables for Equality and Inequality</a>, you cannot natively compare two collection variables with <a id="sthref403"></a><a id="sthref404"></a>relational operators (listed in <a href="fundamentals.htm#CIHCCCBB">Table 2-5</a>). This restriction also applies to implicit comparisons. For example, a collection variable cannot appear in a <code dir="ltr">DISTINCT</code>, <code dir="ltr">GROUP</code> <code dir="ltr">BY</code>, or <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause.</p>
<p>To determine if one collection variable is less than another (for example), you must define what less than means in that context and write a function that returns <code dir="ltr">TRUE</code> or <code dir="ltr">FALSE</code>. For information about writing functions, see <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms."</a></p>
<p class="subhead2"><a id="LNPLS383"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHBIDCE">Comparing Varray and Nested Table Variables to NULL</a></p>
</li>
<li>
<p><a href="#CIHJHBFI">Comparing Nested Tables for Equality and Inequality</a></p>
</li>
<li>
<p><a href="#CIHIHBIA">Comparing Nested Tables with SQL Multiset Conditions</a></p>
</li>
</ul>
<a id="CIHBIDCE"></a>
<div id="LNPLS99915" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Comparing Varray and Nested Table Variables to NULL</h3>
<p>You can compare <a id="sthref405"></a><a id="sthref406"></a>varray and <a id="sthref407"></a><a id="sthref408"></a>nested table variables to the value <code dir="ltr">NULL</code> with the <a id="sthref409"></a><a href="fundamentals.htm#CIHDCCGF">"IS [NOT] NULL Operator"</a>, but not with the relational operators equal (<code dir="ltr">=</code>) and not equal (<code dir="ltr">&lt;&gt;</code>, <code dir="ltr">!=</code>, <code dir="ltr">~=</code>, or <code dir="ltr">^=</code>).</p>
<p><a href="#CIHCGJIC">Example 5-14</a> compares a varray variable and a nested table variable to <code dir="ltr">NULL</code> correctly.</p>
<div id="LNPLS384" class="example">
<p class="titleinexample"><a id="CIHCGJIC"></a>Example 5-14 Comparing Varray and Nested Table Variables to NULL</p>
<pre dir="ltr">
DECLARE  
  TYPE Foursome IS VARRAY(4) OF VARCHAR2(15);  -- VARRAY type
  team Foursome;                               -- varray variable
  
  TYPE Roster IS TABLE OF VARCHAR2(15);        -- nested table type
  names Roster := Roster('Adams', 'Patel');    -- nested table variable
  
BEGIN
  <span class="bold">IF team IS NULL THEN</span>
    DBMS_OUTPUT.PUT_LINE('team IS NULL');
  ELSE
    DBMS_OUTPUT.PUT_LINE('team IS NOT NULL');
  END IF;
 
  <span class="bold">IF names IS NOT NULL THEN</span>
    DBMS_OUTPUT.PUT_LINE('names IS NOT NULL');
  ELSE
    DBMS_OUTPUT.PUT_LINE('names IS NULL');
  END IF;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
team IS NULL
names IS NOT NULL
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHJHBFI"></a>
<div id="LNPLS99914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Comparing Nested Tables for Equality and Inequality</h3>
<p>If two <a id="sthref410"></a>nested table variables have the same nested table type, and that nested table type does not have elements of a record type, then you can compare the two variables for equality or inequality with the relational operators equal (<code dir="ltr">=</code>) and not equal (<code dir="ltr">&lt;&gt;</code>, <code dir="ltr">!=</code>, <code dir="ltr">~=</code>, <code dir="ltr">^=</code>). Two nested table variables are equal if and only if they have the same set of elements (in any order).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJAIIBHD">"Record Comparisons"</a></div>
<p><a href="#BABCBFHA">Example 5-15</a> compares nested table variables for equality and inequality with relational operators.</p>
<div id="LNPLS468" class="example">
<p class="titleinexample"><a id="BABCBFHA"></a>Example 5-15 Comparing Nested Tables for Equality and Inequality</p>
<pre dir="ltr">
DECLARE
  TYPE dnames_tab IS TABLE OF <span class="bold">VARCHAR2(30)</span>; <span class="bold">-- element type is not record type</span>

  dept_names1 dnames_tab :=
    dnames_tab('Shipping','Sales','Finance','Payroll');

  dept_names2 dnames_tab :=
    dnames_tab('Sales','Finance','Shipping','Payroll');

  dept_names3 dnames_tab :=
    dnames_tab('Sales','Finance','Payroll');

BEGIN
  <span class="bold">IF dept_names1 = dept_names2 THEN</span>
    DBMS_OUTPUT.PUT_LINE('dept_names1 = dept_names2');
  END IF;

  <span class="bold">IF dept_names2 != dept_names3 THEN</span>
    DBMS_OUTPUT.PUT_LINE('dept_names2 != dept_names3');
  END IF;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">dept_names1 = dept_names2</span>
<span class="bold">dept_names2 != dept_names3</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHIHBIA"></a>
<div id="LNPLS99913" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Comparing Nested Tables with SQL Multiset Conditions</h3>
<p>You can compare <a id="sthref411"></a>nested table variables, and test some of their properties, with <a id="sthref412"></a><a id="sthref413"></a><a id="sthref414"></a>SQL multiset conditions (described in <a class="olink SQLRF52128" href="../../server.112/e41084/conditions006.htm#SQLRF52128"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
<p><a href="#BABCDABC">Example 5-16</a> uses the SQL multiset conditions and two SQL functions that take nested table variable arguments, <code dir="ltr">CARDINALITY</code> (described in <a class="olink SQLRF06305" href="../../server.112/e41084/functions022.htm#SQLRF06305"><span class="italic">Oracle Database SQL Language Reference</span></a>) and <code dir="ltr">SET</code> (described in <a class="olink SQLRF06308" href="../../server.112/e41084/functions163.htm#SQLRF06308"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
<div id="LNPLS469" class="example">
<p class="titleinexample"><a id="BABCDABC"></a>Example 5-16 Comparing Nested Tables with SQL Multiset Conditions</p>
<pre dir="ltr">
DECLARE
  TYPE nested_typ IS TABLE OF NUMBER;
  nt1 nested_typ := nested_typ(1,2,3);
  nt2 nested_typ := nested_typ(3,2,1);
  nt3 nested_typ := nested_typ(2,3,1,3);
  nt4 nested_typ := nested_typ(1,2,4);
 
  PROCEDURE testify (
    truth BOOLEAN := NULL,
    quantity NUMBER := NULL
  ) IS
  BEGIN
    IF truth IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE (
        CASE truth
           WHEN TRUE THEN 'True'
           WHEN FALSE THEN 'False'
        END
      );
    END IF;
    IF quantity IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE(quantity);
    END IF;
  END;
BEGIN
  testify(truth =&gt; (<span class="bold">nt1 IN (nt2,nt3,nt4)</span>));        -- condition
  testify(truth =&gt; (<span class="bold">nt1 SUBMULTISET OF nt3</span>));      -- condition
  testify(truth =&gt; (<span class="bold">nt1 NOT SUBMULTISET OF nt4</span>));  -- condition
  testify(truth =&gt; (<span class="bold">4 MEMBER OF nt1</span>));             -- condition
  testify(truth =&gt; (<span class="bold">nt3 IS A SET</span>));                -- condition
  testify(truth =&gt; (<span class="bold">nt3 IS NOT A SET</span>));            -- condition
  testify(truth =&gt; (<span class="bold">nt1 IS EMPTY</span>));                -- condition
  testify(quantity =&gt; (<span class="bold">CARDINALITY(nt3)</span>));         -- function
  testify(quantity =&gt; (<span class="bold">CARDINALITY(SET(nt3))</span>));    -- 2 functions
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
True
True
True
False
False
True
False
4
3
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i27396"></a>
<div id="LNPLS00508" class="sect1">
<h2 class="sect1">Collection Methods</h2>
<p>A <a id="sthref415"></a>collection method is a PL/SQL subprogram&mdash;either a function that returns information about a collection or a procedure that operates on a collection. Collection methods make collections easier to use and your applications easier to maintain. <a href="#CHDDJGFA">Table 5-2</a> summarizes the collection methods.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With a <a id="sthref416"></a>null collection, <code dir="ltr">EXISTS</code> is the only <a id="sthref417"></a>collection method that does not raise the predefined exception <code dir="ltr">COLLECTION_IS_NULL</code>.</div>
<div id="LNPLS385" class="tblformal">
<p class="titleintable"><a id="sthref418"></a><a id="CHDDJGFA"></a>Table 5-2 Collection Methods</p>
<table class="cellalignment1092" title="Collection Methods" summary="This table summarizes the collection methods. The first column lists their names, in alphabetical order. The second column lists their types (function or procedure). The third column gives brief descriptions of them." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t20">Method</th>
<th class="cellalignment1090" id="r1c2-t20">Type</th>
<th class="cellalignment1090" id="r1c3-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t20" headers="r1c1-t20">
<p><code dir="ltr">DELETE</code></p>
</td>
<td class="cellalignment1091" headers="r2c1-t20 r1c2-t20">
<p>Procedure</p>
</td>
<td class="cellalignment1091" headers="r2c1-t20 r1c3-t20">
<p>Deletes elements from collection.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t20" headers="r1c1-t20">
<p><code dir="ltr">TRIM</code></p>
</td>
<td class="cellalignment1091" headers="r3c1-t20 r1c2-t20">
<p>Procedure</p>
</td>
<td class="cellalignment1091" headers="r3c1-t20 r1c3-t20">
<p>Deletes elements from end of varray or nested table.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t20" headers="r1c1-t20">
<p><code dir="ltr">EXTEND</code></p>
</td>
<td class="cellalignment1091" headers="r4c1-t20 r1c2-t20">
<p>Procedure</p>
</td>
<td class="cellalignment1091" headers="r4c1-t20 r1c3-t20">
<p>Adds elements to end of varray or nested table.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t20" headers="r1c1-t20">
<p><code dir="ltr">EXISTS</code></p>
</td>
<td class="cellalignment1091" headers="r5c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r5c1-t20 r1c3-t20">
<p>Returns <code dir="ltr">TRUE</code> if and only if specified element of varray or nested table exists.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r6c1-t20" headers="r1c1-t20">
<p><code dir="ltr">FIRST</code></p>
</td>
<td class="cellalignment1091" headers="r6c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r6c1-t20 r1c3-t20">
<p>Returns first index in collection.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r7c1-t20" headers="r1c1-t20">
<p><code dir="ltr">LAST</code></p>
</td>
<td class="cellalignment1091" headers="r7c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r7c1-t20 r1c3-t20">
<p>Returns last index in collection.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r8c1-t20" headers="r1c1-t20">
<p><code dir="ltr">COUNT</code></p>
</td>
<td class="cellalignment1091" headers="r8c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r8c1-t20 r1c3-t20">
<p>Returns number of elements in collection.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r9c1-t20" headers="r1c1-t20">
<p><code dir="ltr">LIMIT</code></p>
</td>
<td class="cellalignment1091" headers="r9c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r9c1-t20 r1c3-t20">
<p>Returns maximum number of elements that collection can have.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r10c1-t20" headers="r1c1-t20">
<p><code dir="ltr">PRIOR</code></p>
</td>
<td class="cellalignment1091" headers="r10c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r10c1-t20 r1c3-t20">
<p>Returns index that precedes specified index.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r11c1-t20" headers="r1c1-t20">
<p><code dir="ltr">NEXT</code></p>
</td>
<td class="cellalignment1091" headers="r11c1-t20 r1c2-t20">
<p>Function</p>
</td>
<td class="cellalignment1091" headers="r11c1-t20 r1c3-t20">
<p>Returns index that succeeds specified index.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The <a id="sthref419"></a>basic syntax of a collection method invocation is:</p>
<pre dir="ltr">
<span class="italic">collection_name</span>.<span class="italic">method</span>
</pre>
<p>For detailed syntax, see <a href="collection_method.htm#i33024">"Collection Method Invocation"</a>.</p>
<p>A collection method invocation can appear anywhere that an invocation of a PL/SQL subprogram of its type (function or procedure) can appear, except in a <a id="sthref420"></a>SQL statement. (For general information about PL/SQL subprograms, see <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms."</a>)</p>
<p>In a subprogram, a <a id="sthref421"></a>collection parameter assumes the properties of the argument bound to it. You can apply <a id="sthref422"></a>collection methods to such parameters. For varray parameters, the value of <code dir="ltr">LIMIT</code> is always derived from the parameter type definition, regardless of the parameter mode.</p>
<p class="subhead2"><a id="LNPLS396"></a>Topics</p>
<ul>
<li>
<p><a href="#CJAFGFIG">DELETE Collection Method</a></p>
</li>
<li>
<p><a href="#CJAJAGII">TRIM Collection Method</a></p>
</li>
<li>
<p><a href="#CJAIJHEI">EXTEND Collection Method</a></p>
</li>
<li>
<p><a href="#CJAEFFID">EXISTS Collection Method</a></p>
</li>
<li>
<p><a href="#CJAEGDEF">FIRST and LAST Collection Methods</a></p>
</li>
<li>
<p><a href="#CJAEIFCA">COUNT Collection Method</a></p>
</li>
<li>
<p><a href="#CJABAAHE">LIMIT Collection Method</a></p>
</li>
<li>
<p><a href="#CJAGHFJF">PRIOR and NEXT Collection Methods</a></p>
</li>
</ul>
<a id="CJAFGFIG"></a>
<div id="LNPLS99961" class="sect2">
<h3 class="sect2">DELETE Collection Method</h3>
<p><a id="sthref423"></a><code dir="ltr">DELETE</code> is a procedure that deletes elements from a collection. This method has these forms:</p>
<ul>
<li>
<p><code dir="ltr">DELETE</code> deletes all elements from a collection of any type.</p>
<p>This operation immediately frees the memory allocated to the deleted elements.</p>
</li>
<li>
<p>From an associative array or nested table (but not a varray):</p>
<ul>
<li>
<p><code dir="ltr">DELETE(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> deletes the element whose index is <span class="italic">n</span>, if that element exists; otherwise, it does nothing.</p>
</li>
<li>
<p><code dir="ltr">DELETE(</code><code dir="ltr"><span class="codeinlineitalic">m,n</span></code><code dir="ltr">)</code> deletes all elements whose indexes are in the range <span class="italic">m</span>..<span class="italic">n</span>, if both <span class="italic">m</span> and <span class="italic">n</span> exist and <span class="italic">m</span> &lt;= <span class="italic">n</span>; otherwise, it does nothing.</p>
</li>
</ul>
<p>For these two forms of <code dir="ltr">DELETE</code>, PL/SQL keeps placeholders for the deleted elements. Therefore, the deleted elements are included in the <a id="sthref424"></a>internal size of the collection, and you can restore a deleted element by assigning a valid value to it.</p>
</li>
</ul>
<p><a href="#CIHJFHJE">Example 5-17</a> declares a nested table variable, initializing it with six elements; deletes and then restores the second element; deletes a range of elements and then restores one of them; and then deletes all elements. The restored elements occupy the same memory as the corresponding deleted elements. The procedure <code dir="ltr">print_nt</code> prints the nested table variable after initialization and after each <code dir="ltr">DELETE</code> operation. The type <code dir="ltr">nt_type</code> and procedure <code dir="ltr">print_nt</code> are defined in <a href="#CIHDEIIG">Example 5-6</a>.</p>
<div id="LNPLS397" class="example">
<p class="titleinexample"><a id="CIHJFHJE"></a>Example 5-17 DELETE Method with Nested Table</p>
<pre dir="ltr">
DECLARE
  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
BEGIN
  print_nt(nt);
 
  <span class="bold">nt.DELETE(2);     -- Delete second element</span>
  print_nt(nt);
 
  <span class="bold">nt(2) := 2222;    -- Restore second element</span>
  print_nt(nt);
 
  <span class="bold">nt.DELETE(2, 4);  -- Delete range of elements</span>
  print_nt(nt);
 
  <span class="bold">nt(3) := 3333;    -- Restore third element</span>
  print_nt(nt);
 
  <span class="bold">nt.DELETE;        -- Delete all elements</span>
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(2) = 2222
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(3) = 3333
nt.(5) = 55
nt.(6) = 66
---
nt is empty
---
</pre></div>
<!-- class="example" -->
<p><a href="#CIHHFHFJ">Example 5-18</a> populates an associative array indexed by string and deletes all elements, which frees the memory allocated to them. Next, the example replaces the deleted elements&mdash;that is, adds new elements that have the same indexes as the deleted elements. The new replacement elements do not occupy the same memory as the corresponding deleted elements. Finally, the example deletes one element and then a range of elements. The procedure <code dir="ltr">print_aa_str</code> shows the effects of the operations.</p>
<div id="LNPLS398" class="example">
<p class="titleinexample"><a id="CIHHFHFJ"></a>Example 5-18 DELETE Method with Associative Array Indexed by String</p>
<pre dir="ltr">
DECLARE
  TYPE aa_type_str IS TABLE OF INTEGER INDEX BY VARCHAR2(10);
  aa_str  aa_type_str;
 
  PROCEDURE print_aa_str IS
    i  VARCHAR2(10);
  BEGIN
    i := aa_str.FIRST;
 
    IF i IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('aa_str is empty');
    ELSE
      WHILE i IS NOT NULL LOOP
        DBMS_OUTPUT.PUT('aa_str.(' || i || ') = '); print(aa_str(i));
        i := aa_str.NEXT(i);
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE('---');
  END print_aa_str;
 
BEGIN
  aa_str('M') := 13;
  aa_str('Z') := 26;
  aa_str('C') := 3;
  print_aa_str;
 
  <span class="bold">aa_str.DELETE;  -- Delete all elements</span>
  print_aa_str;
 
  <span class="bold">aa_str('M') := 13;   -- Replace deleted element with same value</span>
  <span class="bold">aa_str('Z') := 260;  -- Replace deleted element with new value</span>
  <span class="bold">aa_str('C') := 30;   -- Replace deleted element with new value</span>
  aa_str('W') := 23;   -- Add new element
  aa_str('J') := 10;   -- Add new element
  aa_str('N') := 14;   -- Add new element
  aa_str('P') := 16;   -- Add new element
  aa_str('W') := 23;   -- Add new element
  aa_str('J') := 10;   -- Add new element
  print_aa_str;
 
  <span class="bold">aa_str.DELETE('C');      -- Delete one element</span>
  print_aa_str;
 
  <span class="bold">aa_str.DELETE('N','W');  -- Delete range of elements</span>
  print_aa_str;
 
  <span class="bold">aa_str.DELETE('Z','M');  -- Does nothing</span>
  print_aa_str;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
aa_str.(C) = 3
aa_str.(M) = 13
aa_str.(Z) = 26
---
aa_str is empty
---
aa_str.(C) = 30
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(N) = 14
aa_str.(P) = 16
aa_str.(W) = 23
aa_str.(Z) = 260
---
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(N) = 14
aa_str.(P) = 16
aa_str.(W) = 23
aa_str.(Z) = 260
---
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(Z) = 260
---
aa_str.(J) = 10
aa_str.(M) = 13
aa_str.(Z) = 260
---
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CJAJAGII"></a>
<div id="LNPLS99962" class="sect2">
<h3 class="sect2">TRIM Collection Method</h3>
<p><a id="sthref425"></a><code dir="ltr">TRIM</code> is a procedure that deletes elements from the end of a varray or nested table. This method has these forms:</p>
<ul>
<li>
<p><code dir="ltr">TRIM</code> removes one element from the end of the collection, if the collection has at least one element; otherwise, it raises the predefined exception <code dir="ltr">SUBSCRIPT_BEYOND_COUNT</code>.</p>
</li>
<li>
<p><code dir="ltr">TRIM(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> removes <span class="italic">n</span> elements from the end of the collection, if there are at least <span class="italic">n</span> elements at the end; otherwise, it raises the predefined exception <code dir="ltr">SUBSCRIPT_BEYOND_COUNT</code>.</p>
</li>
</ul>
<p><code dir="ltr">TRIM</code> operates on the <a id="sthref426"></a>internal size of a collection. That is, if <a id="sthref427"></a><code dir="ltr">DELETE</code> deletes an element but keeps a placeholder for it, then <code dir="ltr">TRIM</code> considers the element to exist. Therefore, <code dir="ltr">TRIM</code> can delete a deleted element.</p>
<p>PL/SQL does not keep placeholders for trimmed elements. Therefore, trimmed elements are not included in the internal size of the collection, and you cannot restore a trimmed element by assigning a valid value to it.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Do not depend on interaction between <code dir="ltr">TRIM</code> and <code dir="ltr">DELETE</code>. Treat nested tables like either fixed-size arrays (and use only <code dir="ltr">DELETE</code>) or stacks (and use only <code dir="ltr">TRIM</code> and <code dir="ltr">EXTEND</code>).</div>
<p><a href="#BABHDBGC">Example 5-19</a> declares a nested table variable, initializing it with six elements; trims the last element; deletes the fourth element; and then trims the last two elements&mdash;one of which is the deleted fourth element. The procedure <code dir="ltr">print_nt</code> prints the nested table variable after initialization and after the <code dir="ltr">TRIM</code> and <code dir="ltr">DELETE</code> operations. The type <code dir="ltr">nt_type</code> and procedure <code dir="ltr">print_nt</code> are defined in <a href="#CIHDEIIG">Example 5-6</a>.</p>
<div id="LNPLS480" class="example">
<p class="titleinexample"><a id="BABHDBGC"></a>Example 5-19 TRIM Method with Nested Table</p>
<pre dir="ltr">
DECLARE
  nt nt_type := nt_type(11, 22, 33, 44, 55, 66);
BEGIN
  print_nt(nt);

  <span class="bold">nt.TRIM;       -- Trim last element</span>
  print_nt(nt);

  <span class="bold">nt.DELETE(4);  -- Delete fourth element</span>
  print_nt(nt);

  <span class="bold">nt.TRIM(2);    -- Trim last two elements</span>
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
nt.(6) = 66
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 44
nt.(5) = 55
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(5) = 55
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
---
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CJAIJHEI"></a>
<div id="LNPLS99963" class="sect2">
<h3 class="sect2">EXTEND Collection Method</h3>
<p><a id="sthref428"></a><code dir="ltr">EXTEND</code> is a procedure that adds elements to the end of a varray or nested table. The collection can be empty, but not null. (To make a collection empty or add elements to a null collection, use a constructor. For more information, see <a href="#i20453">"Collection Constructors"</a>.)</p>
<p>The <code dir="ltr">EXTEND</code> method has these forms:</p>
<ul>
<li>
<p><code dir="ltr">EXTEND</code> appends one null element to the collection.</p>
</li>
<li>
<p><code dir="ltr">EXTEND(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> appends <span class="italic">n</span> null elements to the collection.</p>
</li>
<li>
<p><code dir="ltr">EXTEND(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code>,<code dir="ltr"><span class="codeinlineitalic">i</span></code><code dir="ltr">)</code> appends <span class="italic">n</span> copies of the <span class="italic">i</span>th element to the collection.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">EXTEND(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code>,<code dir="ltr"><span class="codeinlineitalic">i</span></code><code dir="ltr">)</code> is the only form that you can use for a collection whose elements have the <a id="sthref429"></a><code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint.</div>
</li>
</ul>
<p><code dir="ltr">EXTEND</code> operates on the <a id="sthref430"></a>internal size of a collection. That is, if <a id="sthref431"></a><code dir="ltr">DELETE</code> deletes an element but keeps a placeholder for it, then <code dir="ltr">EXTEND</code> considers the element to exist.</p>
<p><a href="#BABBGAIB">Example 5-20</a> declares a nested table variable, initializing it with three elements; appends two copies of the first element; deletes the fifth (last) element; and then appends one null element. Because <code dir="ltr">EXTEND</code> considers the deleted fifth element to exist, the appended null element is the sixth element. The procedure <code dir="ltr">print_nt</code> prints the nested table variable after initialization and after the <code dir="ltr">EXTEND</code> and <code dir="ltr">DELETE</code> operations. The type <code dir="ltr">nt_type</code> and procedure <code dir="ltr">print_nt</code> are defined in <a href="#CIHDEIIG">Example 5-6</a>.</p>
<div id="LNPLS479" class="example">
<p class="titleinexample"><a id="BABBGAIB"></a>Example 5-20 EXTEND Method with Nested Table</p>
<pre dir="ltr">
DECLARE
  nt nt_type := nt_type(11, 22, 33);
BEGIN
  print_nt(nt);
 
  <span class="bold">nt.EXTEND(2,1);  -- Append two copies of first element</span>
  print_nt(nt);
 
  <span class="bold">nt.DELETE(5);    -- Delete fifth element</span>
  print_nt(nt);
 
  <span class="bold">nt.EXTEND;       -- Append one null element</span>
  print_nt(nt);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 11
nt.(5) = 11
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 11
---
nt.(1) = 11
nt.(2) = 22
nt.(3) = 33
nt.(4) = 11
<span class="bold">nt.(6) = NULL</span>
---
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CJAEFFID"></a>
<div id="LNPLS99968" class="sect2">
<h3 class="sect2">EXISTS Collection Method</h3>
<p><a id="sthref432"></a><code dir="ltr">EXISTS</code> is a function that tells you whether the specified element of a varray or nested table exists.</p>
<p><code dir="ltr">EXISTS(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> returns <code dir="ltr">TRUE</code> if the <span class="italic">n</span>th element of the collection exists and <code dir="ltr">FALSE</code> otherwise. If <span class="italic">n</span> is out of range, <code dir="ltr">EXISTS</code> returns <code dir="ltr">FALSE</code> instead of raising the predefined exception <code dir="ltr">SUBSCRIPT_OUTSIDE_LIMIT</code>.</p>
<p>For a deleted element, <code dir="ltr">EXISTS(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> returns <code dir="ltr">FALSE</code>, even if <a id="sthref433"></a><code dir="ltr">DELETE</code> kept a placeholder for it.</p>
<p><a href="#BABEDEGG">Example 5-21</a> initializes a nested table with four elements, deletes the second element, and prints either the value or status of elements 1 through 6.</p>
<div id="LNPLS473" class="example">
<p class="titleinexample"><a id="BABEDEGG"></a>Example 5-21 EXISTS Method with Nested Table</p>
<pre dir="ltr">
DECLARE
  TYPE NumList IS TABLE OF INTEGER;
  n NumList := NumList(1,3,5,7);
BEGIN
  <span class="bold">n.DELETE(2); -- Delete second element</span>
 
  FOR i IN 1..6 LOOP
    IF <span class="bold">n.EXISTS(i)</span> THEN
      DBMS_OUTPUT.PUT_LINE('n(' || i || ') = ' || n(i));
    ELSE
      DBMS_OUTPUT.PUT_LINE('n(' || i || ') does not exist');
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
n(1) = 1
n(2) does not exist
n(3) = 5
n(4) = 7
n(5) does not exist
n(6) does not exist
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CJAEGDEF"></a>
<div id="LNPLS99965" class="sect2">
<h3 class="sect2">FIRST and LAST Collection Methods</h3>
<p><a id="sthref434"></a><code dir="ltr">FIRST</code> and <a id="sthref435"></a><code dir="ltr">LAST</code> are functions. If the collection has at least one element, <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> return the indexes of the first and last elements, respectively (ignoring deleted elements, even if <a id="sthref436"></a><a id="sthref437"></a><code dir="ltr">DELETE</code> kept placeholders for them). If the collection has only one element, <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> return the same index. If the collection is empty, <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> return <code dir="ltr">NULL</code>.</p>
<p class="subhead2"><a id="LNPLS401"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHECGHG">FIRST and LAST Methods for Associative Array</a></p>
</li>
<li>
<p><a href="#CIHEEGIJ">FIRST and LAST Methods for Varray</a></p>
</li>
<li>
<p><a href="#CIHGFJFA">FIRST and LAST Methods for Nested Table</a></p>
</li>
</ul>
<a id="CIHECGHG"></a>
<div id="LNPLS403" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">FIRST and LAST Methods for Associative Array</h4>
<p>For an <a id="sthref438"></a>associative array indexed by <code dir="ltr">PLS_INTEGER</code>, the first and last elements are those with the smallest and largest indexes, respectively.</p>
<p><a href="#CIHCAHDE">Example 5-22</a> shows the values of <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> for an associative array indexed by <code dir="ltr">PLS_INTEGER</code>, deletes the first and last elements, and shows the values of <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> again.</p>
<div id="LNPLS405" class="example">
<p class="titleinexample"><a id="CIHCAHDE"></a>Example 5-22 FIRST and LAST Values for Associative Array Indexed by PLS_INTEGER</p>
<pre dir="ltr">
DECLARE
  TYPE aa_type_int IS TABLE OF INTEGER INDEX BY PLS_INTEGER;
  aa_int  aa_type_int;
 
  PROCEDURE print_first_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('FIRST = ' || <span class="bold">aa_int.FIRST</span>);
    DBMS_OUTPUT.PUT_LINE('LAST = ' || <span class="bold">aa_int.LAST</span>);
  END print_first_and_last;
 
BEGIN
  aa_int(1) := 3;
  aa_int(2) := 6;
  aa_int(3) := 9;
  aa_int(4) := 12;
 
  DBMS_OUTPUT.PUT_LINE('Before deletions:');
  print_first_and_last;
 
  <span class="bold">aa_int.DELETE(1);</span>
  <span class="bold">aa_int.DELETE(4);</span>
 
  DBMS_OUTPUT.PUT_LINE('After deletions:');
  print_first_and_last;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Before deletions:
FIRST = 1
LAST = 4
After deletions:
FIRST = 2
LAST = 3
</pre></div>
<!-- class="example" -->
<p>For an associative array indexed by string, the first and last elements are those with the lowest and highest key values, respectively. Key values are in sorted order (for more information, see <a href="#CIHDIIGC">"NLS Parameter Values Affect Associative Arrays Indexed by String"</a>).</p>
<p><a href="#CIHFDDDJ">Example 5-23</a> shows the values of <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> for an associative array indexed by string, deletes the first and last elements, and shows the values of <code dir="ltr">FIRST</code> and <code dir="ltr">LAST</code> again.</p>
<div id="LNPLS407" class="example">
<p class="titleinexample"><a id="CIHFDDDJ"></a>Example 5-23 FIRST and LAST Values for Associative Array Indexed by String</p>
<pre dir="ltr">
DECLARE
  TYPE aa_type_str IS TABLE OF INTEGER INDEX BY VARCHAR2(10);
  aa_str  aa_type_str;
 
  PROCEDURE print_first_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('FIRST = ' || <span class="bold">aa_str.FIRST</span>);
    DBMS_OUTPUT.PUT_LINE('LAST = ' || <span class="bold">aa_str.LAST</span>);
  END print_first_and_last;
 
BEGIN
  aa_str('Z') := 26;
  aa_str('A') := 1;
  aa_str('K') := 11;
  aa_str('R') := 18;
 
  DBMS_OUTPUT.PUT_LINE('Before deletions:');
  print_first_and_last;
 
  <span class="bold">aa_str.DELETE('A');</span>
  <span class="bold">aa_str.DELETE('Z');</span>
 
  DBMS_OUTPUT.PUT_LINE('After deletions:');
  print_first_and_last;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Before deletions:
FIRST = A
LAST = Z
After deletions:
FIRST = K
LAST = R
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHEEGIJ"></a>
<div id="LNPLS408" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">FIRST and LAST Methods for Varray</h4>
<p>For a <a id="sthref439"></a>varray that is not empty, <code dir="ltr">FIRST</code> always returns 1. For every varray, <code dir="ltr">LAST</code> always equals <code dir="ltr">COUNT</code> (see <a href="#CIHIHFGI">Example 5-26</a>).</p>
<p><a href="#CIHHAEGC">Example 5-24</a> prints the varray <code dir="ltr">team</code> using a <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement with the bounds <code dir="ltr">team</code>.<code dir="ltr">FIRST</code> and <code dir="ltr">team</code>.<code dir="ltr">LAST</code>. Because a varray is always dense, <code dir="ltr">team(i)</code> inside the loop always exists.</p>
<div id="LNPLS417" class="example">
<p class="titleinexample"><a id="CIHHAEGC"></a>Example 5-24 Printing Varray with FIRST and LAST in FOR LOOP</p>
<pre dir="ltr">
DECLARE
  TYPE team_type IS VARRAY(4) OF VARCHAR2(15);
  team team_type;
 
  PROCEDURE print_team (heading VARCHAR2)
  IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    IF team IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('Does not exist');
    ELSIF <span class="bold">team.FIRST</span> IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('Has no members');
    ELSE
      FOR i IN <span class="bold">team.FIRST</span>..<span class="bold">team.LAST</span> LOOP
        DBMS_OUTPUT.PUT_LINE(i || '. ' || team(i));
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE('---'); 
  END;
  
BEGIN 
  print_team('Team Status:');
 
  team := team_type();  -- Team is funded, but nobody is on it.
  print_team('Team Status:');
 
  team := team_type('John', 'Mary');  -- Put 2 members on team.
  print_team('Initial Team:');
 
  team := team_type('Arun', 'Amitha', 'Allan', 'Mae');  -- Change team.
  print_team('New Team:');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Team Status:
Does not exist
---
Team Status:
Has no members
---
Initial Team:
1. John
2. Mary
---
New Team:
1. Arun
2. Amitha
3. Allan
4. Mae
---
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHGFJFA"></a>
<div id="LNPLS419" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">FIRST and LAST Methods for Nested Table</h4>
<p>For a <a id="sthref440"></a>nested table, <code dir="ltr">LAST</code> equals <code dir="ltr">COUNT</code> unless you delete elements from its middle, in which case <code dir="ltr">LAST</code> is larger than <code dir="ltr">COUNT</code> (see <a href="#BABHFIGG">Example 5-27</a>).</p>
<p><a href="#CIHGFDJA">Example 5-25</a> prints the nested table <code dir="ltr">team</code> using a <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement with the bounds <code dir="ltr">team</code>.<code dir="ltr">FIRST</code> and <code dir="ltr">team</code>.<code dir="ltr">LAST</code>. Because a nested table can be sparse, the <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement prints <code dir="ltr">team(i)</code> only if <code dir="ltr">team</code>.<code dir="ltr">EXISTS(i)</code> is <code dir="ltr">TRUE</code>.</p>
<div id="LNPLS426" class="example">
<p class="titleinexample"><a id="CIHGFDJA"></a>Example 5-25 Printing Nested Table with FIRST and LAST in FOR LOOP</p>
<pre dir="ltr">
DECLARE
  TYPE team_type IS TABLE OF VARCHAR2(15);
  team team_type;
 
  PROCEDURE print_team (heading VARCHAR2) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(heading);
 
    IF team IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('Does not exist');
    ELSIF <span class="bold">team.FIRST</span> IS NULL THEN
      DBMS_OUTPUT.PUT_LINE('Has no members');
    ELSE
      FOR i IN <span class="bold">team.FIRST</span>..<span class="bold">team.LAST</span> LOOP
        DBMS_OUTPUT.PUT(i || '. ');
        IF <span class="bold">team.EXISTS(i)</span> THEN
          DBMS_OUTPUT.PUT_LINE(team(i));
        ELSE
          DBMS_OUTPUT.PUT_LINE('(to be hired)');
        END IF;
      END LOOP;
    END IF;
 
    DBMS_OUTPUT.PUT_LINE('---'); 
  END;
  
BEGIN 
  print_team('Team Status:');
 
  team := team_type();  -- Team is funded, but nobody is on it.
  print_team('Team Status:');
 
  team := team_type('Arun', 'Amitha', 'Allan', 'Mae');  -- Add members.
  print_team('Initial Team:');
 
  team.DELETE(2,3);  -- Remove 2nd and 3rd members.
  print_team('Current Team:');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Team Status:
Does not exist
---
Team Status:
Has no members
---
Initial Team:
1. Arun
2. Amitha
3. Allan
4. Mae
---
Current Team:
1. Arun
2. (to be hired)
3. (to be hired)
4. Mae
---
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJAEIFCA"></a>
<div id="LNPLS99967" class="sect2">
<h3 class="sect2">COUNT Collection Method</h3>
<p><a id="sthref441"></a><code dir="ltr">COUNT</code> is a function that returns the number of elements in the collection (ignoring deleted elements, even if <a id="sthref442"></a><code dir="ltr">DELETE</code> kept placeholders for them).</p>
<p class="subhead2"><a id="LNPLS427"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHJGACD">COUNT Method for Varray</a></p>
</li>
<li>
<p><a href="#CIHGJCHF">COUNT Method for Nested Table</a></p>
</li>
</ul>
<a id="CIHJGACD"></a>
<div id="LNPLS433" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">COUNT Method for Varray</h4>
<p>For a <a id="sthref443"></a>varray, <code dir="ltr">COUNT</code> always equals <code dir="ltr">LAST</code>. If you increase or decrease the size of a varray (with the <code dir="ltr">EXTEND</code> or <code dir="ltr">TRIM</code> method), the value of <code dir="ltr">COUNT</code> changes.</p>
<p><a href="#CIHIHFGI">Example 5-26</a> shows the values of <code dir="ltr">COUNT</code> and <code dir="ltr">LAST</code> for a varray after initialization with four elements, after <code dir="ltr">EXTEND(3)</code>, and after <code dir="ltr">TRIM(5)</code>.</p>
<div id="LNPLS439" class="example">
<p class="titleinexample"><a id="CIHIHFGI"></a>Example 5-26 COUNT and LAST Values for Varray</p>
<pre dir="ltr">
DECLARE
  TYPE NumList IS VARRAY(10) OF INTEGER;
  n NumList := NumList(1,3,5,7);
 
  PROCEDURE print_count_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT('n.COUNT = ' || <span class="bold">n.COUNT</span> || ', ');
    DBMS_OUTPUT.PUT_LINE('n.LAST = ' || <span class="bold">n.LAST</span>);
  END  print_count_and_last;
 
BEGIN
  print_count_and_last;
 
  <span class="bold">n.EXTEND(3);</span>
  print_count_and_last;
 
  <span class="bold">n.TRIM(5);</span>
  print_count_and_last;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
n.COUNT = 4, n.LAST = 4
n.COUNT = 7, n.LAST = 7
n.COUNT = 2, n.LAST = 2
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHGJCHF"></a>
<div id="LNPLS441" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">COUNT Method for Nested Table</h4>
<p>For a <a id="sthref444"></a>nested table, <code dir="ltr">COUNT</code> equals <code dir="ltr">LAST</code> unless you delete elements from the middle of the nested table, in which case <code dir="ltr">COUNT</code> is smaller than <code dir="ltr">LAST</code>.</p>
<p><a href="#BABHFIGG">Example 5-27</a> shows the values of <code dir="ltr">COUNT</code> and <code dir="ltr">LAST</code> for a nested table after initialization with four elements, after deleting the third element, and after adding two null elements to the end. Finally, the example prints the status of elements 1 through 8.</p>
<div id="LNPLS474" class="example">
<p class="titleinexample"><a id="BABHFIGG"></a>Example 5-27 COUNT and LAST Values for Nested Table</p>
<pre dir="ltr">
DECLARE
  TYPE NumList IS TABLE OF INTEGER;
  n NumList := NumList(1,3,5,7);
 
  PROCEDURE print_count_and_last IS
  BEGIN
    DBMS_OUTPUT.PUT('n.COUNT = ' || <span class="bold">n.COUNT</span> || ', ');
    DBMS_OUTPUT.PUT_LINE('n.LAST = ' || <span class="bold">n.LAST</span>);
  END  print_count_and_last;
 
BEGIN
  print_count_and_last;
 
  <span class="bold">n.DELETE(3);</span>  -- Delete third element
  print_count_and_last;
 
  <span class="bold">n.EXTEND(2);</span>  -- Add two null elements to end
  print_count_and_last;
 
  FOR i IN 1..8 LOOP
    IF <span class="bold">n.EXISTS(i)</span> THEN
      IF n(i) IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('n(' || i || ') = ' || n(i));
      ELSE
        DBMS_OUTPUT.PUT_LINE('n(' || i || ') = NULL');
      END IF;
    ELSE
      DBMS_OUTPUT.PUT_LINE('n(' || i || ') does not exist');
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
n.COUNT = 4, n.LAST = 4
n.COUNT = 3, n.LAST = 4
n.COUNT = 5, n.LAST = 6
n(1) = 1
n(2) = 3
n(3) does not exist
n(4) = 7
n(5) = NULL
n(6) = NULL
n(7) does not exist
n(8) does not exist
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJABAAHE"></a>
<div id="LNPLS99966" class="sect2">
<h3 class="sect2">LIMIT Collection Method</h3>
<p><a id="sthref445"></a><code dir="ltr">LIMIT</code> is a function that returns the maximum number of elements that the collection can have. If the collection has no maximum number of elements, <code dir="ltr">LIMIT</code> returns <code dir="ltr">NULL</code>. Only a varray has a maximum size.</p>
<p><a href="#BABFCAGJ">Example 5-28</a> and prints the values of <code dir="ltr">LIMIT</code> and <code dir="ltr">COUNT</code> for an associative array with four elements, a varray with two elements, and a nested table with three elements.</p>
<div id="LNPLS475" class="example">
<p class="titleinexample"><a id="BABFCAGJ"></a>Example 5-28 LIMIT and COUNT Values for Different Collection Types</p>
<pre dir="ltr">
DECLARE
  TYPE aa_type IS TABLE OF INTEGER INDEX BY PLS_INTEGER;
  aa aa_type;                          -- associative array
 
  TYPE va_type IS VARRAY(4) OF INTEGER;
  va  va_type := va_type(2,4);   -- varray
 
  TYPE nt_type IS TABLE OF INTEGER;
  nt  nt_type := nt_type(1,3,5);  -- nested table
 
BEGIN
  aa(1):=3; aa(2):=6; aa(3):=9; aa(4):= 12;
  DBMS_OUTPUT.PUT('aa.COUNT = '); print(<span class="bold">aa.COUNT</span>);
  DBMS_OUTPUT.PUT('aa.LIMIT = '); print(<span class="bold">aa.LIMIT</span>);
 
  DBMS_OUTPUT.PUT('va.COUNT = '); print(<span class="bold">va.COUNT</span>);
  DBMS_OUTPUT.PUT('va.LIMIT = '); print(<span class="bold">va.LIMIT</span>);
 
  DBMS_OUTPUT.PUT('nt.COUNT = '); print(<span class="bold">nt.COUNT</span>);
  DBMS_OUTPUT.PUT('nt.LIMIT = '); print(<span class="bold">nt.LIMIT</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
aa.COUNT = 4
aa.LIMIT = NULL
va.COUNT = 2
va.LIMIT = 4
nt.COUNT = 3
nt.LIMIT = NULL
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CJAGHFJF"></a>
<div id="LNPLS99964" class="sect2">
<h3 class="sect2">PRIOR and NEXT Collection Methods</h3>
<p><a id="sthref446"></a><code dir="ltr">PRIOR</code> and <a id="sthref447"></a><code dir="ltr">NEXT</code> are functions that let you move backward and forward in the collection (ignoring deleted elements, even if <a id="sthref448"></a><a id="sthref449"></a><code dir="ltr">DELETE</code> kept placeholders for them). These methods are useful for <a id="sthref450"></a>traversing sparse collections.</p>
<p>Given an index:</p>
<ul>
<li>
<p><code dir="ltr">PRIOR</code> returns the index of the preceding existing element of the collection, if one exists. Otherwise, <code dir="ltr">PRIOR</code> returns <code dir="ltr">NULL</code>.</p>
<p>For any collection <code dir="ltr">c</code>, <code dir="ltr">c.PRIOR(c.FIRST)</code> returns <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p><code dir="ltr">NEXT</code> returns the index of the succeeding existing element of the collection, if one exists. Otherwise, <code dir="ltr">NEXT</code> returns <code dir="ltr">NULL</code>.</p>
<p>For any collection <code dir="ltr">c</code>, <code dir="ltr">c.NEXT(c.LAST)</code> returns <code dir="ltr">NULL</code>.</p>
</li>
</ul>
<p>The given index need not exist. However, if the collection <code dir="ltr">c</code> is a varray, and the index exceeds <code dir="ltr">c.LIMIT</code>, then:</p>
<ul>
<li>
<p><code dir="ltr">c.PRIOR(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code> returns <code dir="ltr">c.LAST</code>.</p>
</li>
<li>
<p><code dir="ltr">c.NEXT(</code><code dir="ltr"><span class="codeinlineitalic">index</span></code><code dir="ltr">)</code> returns <code dir="ltr">NULL</code>.</p>
</li>
</ul>
<p>For example:</p>
<pre dir="ltr">
DECLARE
  TYPE Arr_Type IS VARRAY(10) OF NUMBER;
  v_Numbers Arr_Type := Arr_Type();
BEGIN
  v_Numbers.EXTEND(4);
 
  v_Numbers (1) := 10;
  v_Numbers (2) := 20;
  v_Numbers (3) := 30;
  v_Numbers (4) := 40;
 
  DBMS_OUTPUT.PUT_LINE(NVL(v_Numbers.prior (3400), -1));
  DBMS_OUTPUT.PUT_LINE(NVL(v_Numbers.next (3400), -1));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
4
-1
</pre>
<p><a href="#CIHHHICG">Example 5-29</a> initializes a nested table with six elements, deletes the fourth element, and then shows the values of <code dir="ltr">PRIOR</code> and <code dir="ltr">NEXT</code> for elements 1 through 7. Elements 4 and 7 do not exist. Element 2 exists, despite its null value.</p>
<div id="LNPLS442" class="example">
<p class="titleinexample"><a id="CIHHHICG"></a>Example 5-29 PRIOR and NEXT Methods</p>
<pre dir="ltr">
DECLARE
  TYPE nt_type IS TABLE OF NUMBER;
  nt nt_type := nt_type(18, NULL, 36, 45, 54, 63);
 
BEGIN
  <span class="bold">nt.DELETE(4);</span>
  DBMS_OUTPUT.PUT_LINE('nt(4) was deleted.');
 
  FOR i IN 1..7 LOOP
    DBMS_OUTPUT.PUT('nt.PRIOR(' || i || ') = '); print(<span class="bold">nt.PRIOR(i)</span>);
    DBMS_OUTPUT.PUT('nt.NEXT(' || i || ')  = '); print(<span class="bold">nt.NEXT(i)</span>);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
nt(4) was deleted.
nt.PRIOR(1) = NULL
nt.NEXT(1)  = 2
nt.PRIOR(2) = 1
nt.NEXT(2)  = 3
nt.PRIOR(3) = 2
nt.NEXT(3)  = 5
nt.PRIOR(4) = 3
nt.NEXT(4)  = 5
nt.PRIOR(5) = 3
nt.NEXT(5)  = 6
nt.PRIOR(6) = 5
nt.NEXT(6)  = NULL
nt.PRIOR(7) = 6
nt.NEXT(7)  = NULL
</pre></div>
<!-- class="example" -->
<p>For an associative array indexed by string, the prior and next indexes are determined by key values, which are in sorted order (for more information, see <a href="#CIHDIIGC">"NLS Parameter Values Affect Associative Arrays Indexed by String"</a>). <a href="#BABHGFHJ">Example 5-1</a> uses <code dir="ltr">FIRST</code>, <code dir="ltr">NEXT</code>, and a <code dir="ltr">WHILE</code> <code dir="ltr">LOOP</code> statement to print the elements of an associative array.</p>
<p><a href="#BEIBJDBF">Example 5-30</a> prints the elements of a sparse nested table from first to last, using <code dir="ltr">FIRST</code> and <code dir="ltr">NEXT</code>, and from last to first, using <code dir="ltr">LAST</code> and <code dir="ltr">PRIOR</code>.</p>
<div id="LNPLS478" class="example">
<p class="titleinexample"><a id="BEIBJDBF"></a>Example 5-30 Printing Elements of Sparse Nested Table</p>
<pre dir="ltr">
DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  n NumList := NumList(1, 2, NULL, NULL, 5, NULL, 7, 8, 9, NULL);
  idx INTEGER;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('First to last:');
  idx := <span class="bold">n.FIRST</span>;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT('n(' || idx || ') = ');
    print(n(idx));
    idx := <span class="bold">n.NEXT(idx)</span>;
  END LOOP;
    
  DBMS_OUTPUT.PUT_LINE('--------------');
 
  DBMS_OUTPUT.PUT_LINE('Last to first:');
  idx := <span class="bold">n.LAST</span>;
  WHILE idx IS NOT NULL LOOP
    DBMS_OUTPUT.PUT('n(' || idx || ') = ');
    print(n(idx));
    idx := <span class="bold">n.PRIOR(idx)</span>;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
First to last:
n(1) = 1
n(2) = 2
n(3) = NULL
n(4) = NULL
n(5) = 5
n(6) = NULL
n(7) = 7
n(8) = 8
n(9) = 9
n(10) = NULL
--------------
Last to first:
n(10) = NULL
n(9) = 9
n(8) = 8
n(7) = 7
n(6) = NULL
n(5) = 5
n(4) = NULL
n(3) = NULL
n(2) = 2
n(1) = 1
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJAJEIBA"></a>
<div id="LNPLS00511" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Collection Types Defined in Package Specifications</h2>
<p>A collection type defined in a <a id="sthref451"></a><a id="sthref452"></a>package specification is incompatible with an identically defined local or standalone collection type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The examples in this topic define packages and procedures, which are explained in <a href="packages.htm#CIHIJECJ">Chapter 10, "PL/SQL Packages"</a> and <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms,"</a> respectively.</div>
<p>In <a href="#CHDIHDIJ">Example 5-31</a>, the package specification and the anonymous block define the collection type <code dir="ltr">NumList</code> identically. The package defines a procedure, <code dir="ltr">print_numlist</code>, which has a <code dir="ltr">NumList</code> parameter. The anonymous block declares the variable <code dir="ltr">n1</code> of the type <code dir="ltr">pkg.NumList</code> (defined in the package) and the variable <code dir="ltr">n2</code> of the type <code dir="ltr">NumList</code> (defined in the block). The anonymous block can pass <code dir="ltr">n1</code> to <code dir="ltr">print_numlist</code>, but it cannot pass <code dir="ltr">n2</code> to <code dir="ltr">print_numlist</code>.</p>
<div id="LNPLS486" class="example">
<p class="titleinexample"><a id="CHDIHDIJ"></a>Example 5-31 Identically Defined Package and Local Collection Types</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE pkg AS
  <span class="bold">TYPE NumList IS TABLE OF NUMBER;</span>
  PROCEDURE print_numlist (nums NumList);
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_numlist (nums NumList) IS
  BEGIN
    FOR i IN nums.FIRST..nums.LAST LOOP
      DBMS_OUTPUT.PUT_LINE(nums(i));
    END LOOP;
  END;
END pkg;
/
DECLARE
  <span class="bold">TYPE NumList IS TABLE OF NUMBER;  -- local type identical to package type</span>
  n1 pkg.NumList := pkg.NumList(2,4);  -- package type
  n2     NumList :=     NumList(6,8);  -- local type
BEGIN
  pkg.print_numlist(n1);  -- succeeds
  <span class="bold">pkg.print_numlist(n2);  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
  pkg.print_numlist(n2);  -- fails
  *
ERROR at line 7:
ORA-06550: line 7, column 3:
PLS-00306: wrong number or types of arguments in call to 'PRINT_NUMLIST'
ORA-06550: line 7, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" -->
<p><a href="#CIHBGBBH">Example 5-32</a> defines a standalone collection type <code dir="ltr">NumList</code> that is identical to the collection type <code dir="ltr">NumList</code> defined in the package specification in <a href="#CHDIHDIJ">Example 5-31</a>. The anonymous block declares the variable <code dir="ltr">n1</code> of the type <code dir="ltr">pkg.NumList</code> (defined in the package) and the variable <code dir="ltr">n2</code> of the standalone type <code dir="ltr">NumList</code>. The anonymous block can pass <code dir="ltr">n1</code> to <code dir="ltr">print_numlist</code>, but it cannot pass <code dir="ltr">n2</code> to <code dir="ltr">print_numlist</code>.</p>
<div id="LNPLS444" class="example">
<p class="titleinexample"><a id="CIHBGBBH"></a>Example 5-32 Identically Defined Package and Standalone Collection Types</p>
<pre dir="ltr">
<span class="bold">CREATE OR REPLACE TYPE NumList IS TABLE OF NUMBER;</span>
  <span class="bold">-- standalone collection type identical to package type</span>
/
DECLARE
  n1 pkg.NumList := pkg.NumList(2,4);  -- package type
  n2     NumList :=     NumList(6,8);  -- standalone type
 
BEGIN
  pkg.print_numlist(n1);  -- succeeds
  <span class="bold">pkg.print_numlist(n2);  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
  pkg.print_numlist(n2);  -- fails
  *
ERROR at line 7:
ORA-06550: line 7, column 3:
PLS-00306: wrong number or types of arguments in call to 'PRINT_NUMLIST'
ORA-06550: line 7, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CIHFCFCJ"></a>
<div id="LNPLS00509" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Record Variables</h2>
<p><a id="sthref453"></a>You can create a record variable in any of these ways:</p>
<ul>
<li>
<p>Define a <code dir="ltr">RECORD</code> type and then declare a variable of that type.</p>
</li>
<li>
<p>Use <code dir="ltr">%TYPE</code> to declare a record variable of the same type as a previously declared record variable.</p>
</li>
<li>
<p>Use <code dir="ltr">%ROWTYPE</code> to declare a record variable that represents either a full or partial row of a database table or view.</p>
</li>
</ul>
<p>For syntax and semantics, see <a href="record_definition.htm#i35745">"Record Variable Declaration"</a>.</p>
<p class="subhead2"><a id="LNPLS445"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHDCJEH">Initial Values of Record Variables</a></p>
</li>
<li>
<p><a href="#BABGGGGB">Declaring Record Constants</a></p>
</li>
<li>
<p><a href="#i20479">RECORD Types</a></p>
</li>
<li>
<p><a href="#i6079">%ROWTYPE Attribute</a></p>
</li>
</ul>
<a id="CIHDCJEH"></a>
<div id="LNPLS446" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Initial Values of Record Variables</h3>
<p>For a record variable of a <code dir="ltr">RECORD</code> type, the <a id="sthref454"></a>initial value of each field is <code dir="ltr">NULL</code> unless you specify a different initial value for it when you define the type. For a record variable declared with <code dir="ltr">%TYPE</code>, each field inherits the initial value of its corresponding field in the referenced record. See <a href="#CIHHBIDA">Example 5-34</a>.</p>
<p>For a record variable declared with <code dir="ltr">%ROWTYPE</code>, the initial value of each field is <code dir="ltr">NULL</code>. See <a href="#BEIBGEFH">Example 5-39</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABGGGGB"></a>
<div id="LNPLS99856" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Declaring Record Constants</h3>
<p><a id="sthref455"></a><a id="sthref456"></a>When declaring a record constant, you must create a function that populates the record with its initial value and then invoke the function in the constant declaration, as in <a href="#BABCGFCE">Example 5-33</a>.</p>
<div id="LNPLS447" class="example">
<p class="titleinexample"><a id="BABCGFCE"></a>Example 5-33 Declaring Record Constant</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE My_Types AUTHID DEFINER IS
  TYPE My_Rec IS RECORD (a NUMBER, b NUMBER);
  FUNCTION Init_My_Rec RETURN My_Rec;
END My_Types;
/
CREATE OR REPLACE PACKAGE BODY My_Types IS
  <span class="bold">FUNCTION Init_My_Rec RETURN My_Rec IS</span>
    <span class="bold">Rec My_Rec;</span>
  <span class="bold">BEGIN</span>
    <span class="bold">Rec.a := 0;</span>
    <span class="bold">Rec.b := 1;</span>
    <span class="bold">RETURN Rec;</span>
  <span class="bold">END Init_My_Rec;</span>
END My_Types;
/
DECLARE
  <span class="bold">r CONSTANT My_Types.My_Rec := My_Types.Init_My_Rec();</span>
BEGIN
  DBMS_OUTPUT.PUT_LINE('r.a = ' || r.a);
  DBMS_OUTPUT.PUT_LINE('r.b = ' || r.b);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
r.a = 0
r.b = 1
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i20479"></a>
<div id="LNPLS99971" class="sect2">
<h3 class="sect2">RECORD Types</h3>
<p>A <a id="sthref457"></a><code dir="ltr">RECORD</code> type defined in a PL/SQL block is a <span class="bold">local type</span>. It is available only in the block, and is stored in the database only if the block is in a standalone or package subprogram. (Standalone and package subprograms are explained in <a href="subprograms.htm#CIHCBDHB">"Nested, Package, and Standalone Subprograms"</a>).</p>
<p>A <a id="sthref458"></a><code dir="ltr">RECORD</code> type defined in a package specification is a <span class="bold">public item</span>. You can reference it from outside the package by qualifying it with the package name (<code dir="ltr"><span class="codeinlineitalic">package_name.type_name</span></code>). It is stored in the database until you drop the package with the <code dir="ltr">DROP</code> <code dir="ltr">PACKAGE</code> statement. (Packages are explained in <a href="packages.htm#CIHIJECJ">Chapter 10, "PL/SQL Packages."</a>)</p>
<p>You cannot create a <code dir="ltr">RECORD</code> type at schema level. Therefore, a <code dir="ltr">RECORD</code> type cannot be an ADT attribute data type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A <code dir="ltr">RECORD</code> type defined in a package specification is incompatible with an identically defined local <code dir="ltr">RECORD</code> type (see <a href="#CIHFBIAF">Example 5-37</a>).</div>
<p>To define a <code dir="ltr">RECORD</code> type, specify its name and define its fields. To define a field, specify its name and data type. By default, the initial value of a field is <code dir="ltr">NULL</code>. You can specify the <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint for a field, in which case you must also specify a non-<code dir="ltr">NULL</code> initial value. Without the <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint, a non-<code dir="ltr">NULL</code> initial value is optional.</p>
<p><a href="#CIHHBIDA">Example 5-34</a> defines a <code dir="ltr">RECORD</code> type named <code dir="ltr">DeptRecTyp</code>, specifying an initial value for each field except <code dir="ltr">loc_id</code>. Next, it declares the variable <code dir="ltr">dept_rec</code> of the type <code dir="ltr">DeptRecTyp</code> and the variable <code dir="ltr">dept_rec_2</code> of the type <code dir="ltr">dept_rec%TYPE</code>. Finally, it prints the fields of the two record variables, showing that in both records, <code dir="ltr">loc_id</code> has the value <code dir="ltr">NULL</code>, and all other fields have their default values.</p>
<div id="LNPLS448" class="example">
<p class="titleinexample"><a id="CIHHBIDA"></a>Example 5-34 RECORD Type Definition and Variable Declarations</p>
<pre dir="ltr">
DECLARE
  TYPE DeptRecTyp IS RECORD (
    dept_id    NUMBER(4) NOT NULL := 10,
    dept_name  VARCHAR2(30) NOT NULL := 'Administration',
    mgr_id     NUMBER(6) := 200,
    loc_id     NUMBER(4)
  );
 
  dept_rec DeptRecTyp;
  dept_rec_2 dept_rec%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE('dept_rec:');
  DBMS_OUTPUT.PUT_LINE('---------');
  DBMS_OUTPUT.PUT_LINE('dept_id:   ' || dept_rec.dept_id);
  DBMS_OUTPUT.PUT_LINE('dept_name: ' || dept_rec.dept_name);
  DBMS_OUTPUT.PUT_LINE('mgr_id:    ' || dept_rec.mgr_id);
  DBMS_OUTPUT.PUT_LINE('loc_id:    ' || dept_rec.loc_id);
 
  DBMS_OUTPUT.PUT_LINE('-----------');
  DBMS_OUTPUT.PUT_LINE('dept_rec_2:');
  DBMS_OUTPUT.PUT_LINE('-----------');
  DBMS_OUTPUT.PUT_LINE('dept_id:   ' || dept_rec_2.dept_id);
  DBMS_OUTPUT.PUT_LINE('dept_name: ' || dept_rec_2.dept_name);
  DBMS_OUTPUT.PUT_LINE('mgr_id:    ' || dept_rec_2.mgr_id);
  DBMS_OUTPUT.PUT_LINE('loc_id:    ' || dept_rec_2.loc_id);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
dept_rec:
---------
dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:
-----------
dept_rec_2:
-----------
dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p><a href="#CIHEGIFD">Example 5-35</a> defines two <code dir="ltr">RECORD</code> types, <code dir="ltr">name_rec</code> and <code dir="ltr">contact</code>. The type <code dir="ltr">contact</code> has a field of type <code dir="ltr">name_rec</code>.</p>
<div id="LNPLS449" class="example">
<p class="titleinexample"><a id="CIHEGIFD"></a>Example 5-35 RECORD Type with RECORD Field (Nested Record)</p>
<pre dir="ltr">
DECLARE
  <span class="bold">TYPE name_rec IS RECORD</span> (
    first  employees.first_name%TYPE,
    last   employees.last_name%TYPE
  );
 
  <span class="bold">TYPE contact IS RECORD</span> (
    <span class="bold">name  name_rec,                    -- <a id="sthref459"></a>nested record</span>
    phone employees.phone_number%TYPE
  );
 
  friend contact;
BEGIN
  friend.name.first := 'John';
  friend.name.last := 'Smith';
  friend.phone := '1-650-555-1234';
  
  DBMS_OUTPUT.PUT_LINE (
    friend.name.first  || ' ' ||
    friend.name.last   || ', ' ||
    friend.phone
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
John Smith, 1-650-555-1234
</pre></div>
<!-- class="example" -->
<p><a href="#CIHDJFDB">Example 5-36</a> defines a <code dir="ltr">VARRAY</code> type, <code dir="ltr">full_name</code>, and a <code dir="ltr">RECORD</code> type, <code dir="ltr">contact</code>. The type <code dir="ltr">contact</code> has a field of type <code dir="ltr">full_name</code>.</p>
<div id="LNPLS450" class="example">
<p class="titleinexample"><a id="CIHDJFDB"></a>Example 5-36 RECORD Type with Varray Field</p>
<pre dir="ltr">
DECLARE
  <span class="bold">TYPE full_name IS VARRAY(2) OF VARCHAR2(20);</span>
 
  <span class="bold">TYPE contact IS RECORD</span> (
    <span class="bold">name  full_name</span> := full_name('John', 'Smith'),  <span class="bold">-- varray field</span>
    phone employees.phone_number%TYPE
  );
 
  friend contact;
BEGIN
  friend.phone := '1-650-555-1234';
  
  DBMS_OUTPUT.PUT_LINE (
    friend.name(1) || ' ' ||
    friend.name(2) || ', ' ||
    friend.phone
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
John Smith, 1-650-555-1234
</pre></div>
<!-- class="example" -->
<p>A <code dir="ltr">RECORD</code> type defined in a <a id="sthref460"></a><a id="sthref461"></a>package specification is incompatible with an identically defined local <code dir="ltr">RECORD</code> type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The example in this topic defines a package and a procedure, which are explained in <a href="packages.htm#CIHIJECJ">Chapter 10, "PL/SQL Packages"</a> and <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms,"</a> respectively.</div>
<p>In <a href="#CIHFBIAF">Example 5-37</a>, the package <code dir="ltr">pkg</code> and the anonymous block define the <code dir="ltr">RECORD</code> type <code dir="ltr">rec_type</code> identically. The package defines a procedure, <code dir="ltr">print_rec_type</code>, which has a <code dir="ltr">rec_type</code> parameter. The anonymous block declares the variable <code dir="ltr">r1</code> of the package type (<code dir="ltr">pkg.rec_type</code>) and the variable <code dir="ltr">r2</code> of the local type (<code dir="ltr">rec_type</code>). The anonymous block can pass <code dir="ltr">r1</code> to <code dir="ltr">print_rec_type</code>, but it cannot pass <code dir="ltr">r2</code> to <code dir="ltr">print_rec_type</code>.</p>
<div id="LNPLS451" class="example">
<p class="titleinexample"><a id="CIHFBIAF"></a>Example 5-37 Identically Defined Package and Local RECORD Types</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE pkg AS
  <span class="bold">TYPE rec_type IS RECORD (       -- package RECORD type</span>
    <span class="bold">f1 INTEGER,</span>
    <span class="bold">f2 VARCHAR2(4)</span>
  <span class="bold">);</span>
  PROCEDURE print_rec_type (rec rec_type);
END pkg;
/
CREATE OR REPLACE PACKAGE BODY pkg AS
  PROCEDURE print_rec_type (rec rec_type) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE(rec.f1);
    DBMS_OUTPUT.PUT_LINE(rec.f2);
  END; 
END pkg;
/
DECLARE
  <span class="bold">TYPE rec_type IS RECORD (       -- local RECORD type</span>
    <span class="bold">f1 INTEGER,</span>
    <span class="bold">f2 VARCHAR2(4)</span>
  <span class="bold">);</span>
  r1 pkg.rec_type;                -- package type
  r2     rec_type;                -- local type
 
BEGIN
  r1.f1 := 10; r1.f2 := 'abcd';
  r2.f1 := 25; r2.f2 := 'wxyz';
 
  pkg.print_rec_type(r1);  -- succeeds
  <span class="bold">pkg.print_rec_type(r2);  -- fails</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
  pkg.print_rec_type(r2);  -- fails
  *
ERROR at line 14:
ORA-06550: line 14, column 3:
PLS-00306: wrong number or types of arguments in call to 'PRINT_REC_TYPE'
ORA-06550: line 14, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i6079"></a>
<div id="LNPLS99912" class="sect2">
<h3 class="sect2">%ROWTYPE Attribute</h3>
<p>The <a id="sthref462"></a><code dir="ltr">%ROWTYPE</code> attribute lets you declare a record variable that <a id="sthref463"></a>represents either a full or partial row of a database table or view. For every column of the full or partial row, the record has a field with the same name and data type. If the structure of the row changes, then the structure of the record changes accordingly.</p>
<p>The record fields do not inherit the constraints or initial values of the corresponding columns (see <a href="#BEIBGEFH">Example 5-39</a>).</p>
<p class="subhead2"><a id="LNPLS452"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHBIDGC">Record Variable that Always Represents Full Row</a></p>
</li>
<li>
<p><a href="#CIHHHGAE">Record Variable that Can Represent Partial Row</a></p>
</li>
<li>
<p><a href="#BABGAHFI">%ROWTYPE Attribute and Virtual Columns</a></p>
</li>
</ul>
<a id="CIHBIDGC"></a>
<div id="LNPLS453" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Record Variable that Always Represents Full Row</h4>
<p>To declare a record variable that always represents a full row of a database table or view, use this syntax:</p>
<pre dir="ltr">
<span class="italic">variable_name</span> <span class="italic">table_or_view_name</span>%ROWTYPE;
</pre>
<p>For every column of the table or view, the record has a field with the same name and data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="rowtype_attribute.htm#i35991">"%ROWTYPE Attribute"</a> for more information about <code dir="ltr">%ROWTYPE</code></div>
<p><a href="#CIHJDGEJ">Example 5-38</a> declares a record variable that represents a row of the table <code dir="ltr">departments</code>, assigns values to its fields, and prints them. Compare this example to <a href="#CIHHBIDA">Example 5-34</a>.</p>
<div id="LNPLS454" class="example">
<p class="titleinexample"><a id="CIHJDGEJ"></a>Example 5-38 %ROWTYPE Variable Represents Full Database Table Row</p>
<pre dir="ltr">
DECLARE
  <span class="bold">dept_rec departments%ROWTYPE;</span>
BEGIN
  -- Assign values to fields:
  
  dept_rec.department_id   := 10;
  dept_rec.department_name := 'Administration';
  dept_rec.manager_id      := 200;
  dept_rec.location_id     := 1700;
 
  -- Print fields:
 
  DBMS_OUTPUT.PUT_LINE('dept_id:   ' || dept_rec.department_id);
  DBMS_OUTPUT.PUT_LINE('dept_name: ' || dept_rec.department_name);
  DBMS_OUTPUT.PUT_LINE('mgr_id:    ' || dept_rec.manager_id);
  DBMS_OUTPUT.PUT_LINE('loc_id:    ' || dept_rec.location_id);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
dept_id:   10
dept_name: Administration
mgr_id:    200
loc_id:    1700
</pre></div>
<!-- class="example" -->
<p><a href="#BEIBGEFH">Example 5-39</a> creates a table with two columns, each with an initial value and a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint. Then it declares a record variable that represents a row of the table and prints its fields, showing that they did not inherit the initial values or <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints.</p>
<div id="LNPLS219" class="example">
<p class="titleinexample"><a id="BEIBGEFH"></a>Example 5-39 %ROWTYPE Variable Does Not Inherit Initial Values or Constraints</p>
<pre dir="ltr">
DROP TABLE t1;
CREATE TABLE t1 (
  c1 INTEGER <span class="bold">DEFAULT 0 NOT NULL</span>,
  c2 INTEGER <span class="bold">DEFAULT 1 NOT NULL</span>
);
 
DECLARE
  <span class="bold">t1_row t1%ROWTYPE;</span>
BEGIN
  DBMS_OUTPUT.PUT('t1.c1 = '); print(t1_row.c1);
  DBMS_OUTPUT.PUT('t1.c2 = '); print(t1_row.c2);
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">t1.c1 = NULL</span>
<span class="bold">t1.c2 = NULL</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHHHGAE"></a>
<div id="LNPLS455" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Record Variable that Can Represent Partial Row</h4>
<p>To declare a record variable that can represent a partial row of a database table or view, use this syntax:</p>
<pre dir="ltr">
<span class="italic">variable_name</span> <span class="italic">cursor</span>%ROWTYPE;
</pre>
<p>A cursor is associated with a query. For every column that the query selects, the record variable must have a corresponding, type-compatible field. If the query selects every column of the table or view, then the variable represents a full row; otherwise, the variable represents a partial row. The cursor must be either an explicit cursor or a strong cursor variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="fetch_statement.htm#i34221">"FETCH Statement"</a> for complete syntax</p>
</li>
<li>
<p><a href="static.htm#BABDHAED">"Cursors"</a> for information about cursors</p>
</li>
<li>
<p><a href="static.htm#CIHCAHJA">"Explicit Cursors"</a> for information about explicit cursors</p>
</li>
<li>
<p><a href="static.htm#i7106">"Cursor Variables"</a> for information about cursor variables</p>
</li>
</ul>
</div>
<p><a href="#CBJCGDHB">Example 5-40</a> defines an explicit cursor whose query selects only the columns <code dir="ltr">first_name</code>, <code dir="ltr">last_name</code>, and <code dir="ltr">phone_number</code> from the <code dir="ltr">employees</code> table in the sample schema <code dir="ltr">HR</code>. Then the example declares a record variable that has a field for each column that the cursor selects. The variable represents a partial row of <code dir="ltr">employees</code>. Compare this example to <a href="#CIHEGIFD">Example 5-35</a>.</p>
<div id="LNPLS220" class="example">
<p class="titleinexample"><a id="CBJCGDHB"></a>Example 5-40 %ROWTYPE Variable Represents Partial Database Table Row</p>
<pre dir="ltr">
DECLARE
  CURSOR c IS
    SELECT first_name, last_name, phone_number
    FROM employees;
 
  <span class="bold">friend c%ROWTYPE;</span>
BEGIN
  friend.first_name   := 'John';
  friend.last_name    := 'Smith';
  friend.phone_number := '1-650-555-1234';
  
  DBMS_OUTPUT.PUT_LINE (
    friend.first_name  || ' ' ||
    friend.last_name   || ', ' ||
    friend.phone_number
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
John Smith, 1-650-555-1234
</pre></div>
<!-- class="example" -->
<p><a href="#CBJCGDHB">Example 5-40</a> defines an explicit cursor whose query is a join and then declares a record variable that has a field for each column that the cursor selects. (For information about joins, see <a class="olink SQLRF30046" href="../../server.112/e41084/queries006.htm#SQLRF30046"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<div id="LNPLS221" class="example">
<p class="titleinexample"><a id="CIHIFJHG"></a>Example 5-41 %ROWTYPE Variable Represents Join Row</p>
<pre dir="ltr">
DECLARE
  CURSOR c2 IS
    SELECT employee_id, email, employees.manager_id, location_id
    FROM employees, departments
    WHERE employees.department_id = departments.department_id;
  
  <span class="bold">join_rec c2%ROWTYPE;</span>  -- includes columns from two tables
  
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABGAHFI"></a>
<div id="LNPLS1809" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">%ROWTYPE Attribute and Virtual Columns</h4>
<p>If you use the <a id="sthref464"></a><code dir="ltr">%ROWTYPE</code> attribute to define a record variable that represents a full row of a table that has a <a id="sthref465"></a>virtual column, then you cannot insert that record into the table. Instead, you must insert the individual record fields into the table, excluding the virtual column.</p>
<p><a href="#BABEHIII">Example 5-42</a> creates a record variable that represents a full row of a table that has a virtual column, populates the record, and inserts the record into the table, causing ORA-54013.</p>
<div id="LNPLS1964" class="example">
<p class="titleinexample"><a id="BABEHIII"></a>Example 5-42 Inserting %ROWTYPE Record into Table (Wrong)</p>
<pre dir="ltr">
DROP TABLE plch_departure;
 
CREATE TABLE plch_departure (
  destination    VARCHAR2(100),
  departure_time DATE,
  delay          NUMBER(10),
  <span class="bold">expected       GENERATED ALWAYS AS (departure_time + delay/24/60/60)</span>
);
 
 
DECLARE
 <span class="bold">dep_rec plch_departure%ROWTYPE;</span>
BEGIN
  dep_rec.destination := 'X'; 
  dep_rec.departure_time := SYSDATE;
  dep_rec.delay := 1500;
 
  <span class="bold">INSERT INTO plch_departure VALUES dep_rec;</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
DECLARE
*
ERROR at line 1:
<span class="bold">ORA-54013: INSERT operation disallowed on virtual columns</span>
ORA-06512: at line 8
</pre></div>
<!-- class="example" -->
<p><a href="#BABECFBJ">Example 5-43</a> solves the problem in <a href="#BABEHIII">Example 5-42</a> by inserting the individual record fields into the table, excluding the virtual column.</p>
<div id="LNPLS1965" class="example">
<p class="titleinexample"><a id="BABECFBJ"></a>Example 5-43 Inserting %ROWTYPE Record into Table (Right)</p>
<pre dir="ltr">
DECLARE
  dep_rec plch_departure%rowtype;
BEGIN
  dep_rec.destination := 'X';
  dep_rec.departure_time := SYSDATE;
  dep_rec.delay := 1500;
 
  <span class="bold">INSERT INTO plch_departure (destination, departure_time, delay)</span>
  <span class="bold">VALUES (dep_rec.destination, dep_rec.departure_time, dep_rec.delay);</span>
end;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i20483"></a>
<div id="LNPLS00510" class="sect1">
<h2 class="sect1">Assigning Values to Record Variables</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this topic, <span class="italic">record variable</span> means either a record variable or a record component of a composite variable (for example, <code dir="ltr">friend.name</code> in <a href="#CIHEGIFD">Example 5-35</a>).</div>
<p><a id="sthref466"></a><a id="sthref467"></a>To any record variable, you can assign a value to each field individually.</p>
<p>In some cases, you can assign the value of one record variable to another record variable.</p>
<p>If a record variable represents a full or partial row of a database table or view, you can assign the represented row to the record variable.</p>
<p class="subhead2"><a id="LNPLS456"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHCEJFC">Assigning One Record Variable to Another</a></p>
</li>
<li>
<p><a href="#CIHFAIJB">Assigning Full or Partial Rows to Record Variables</a></p>
</li>
<li>
<p><a href="#BABGHJJI">Assigning NULL to Record Variable</a></p>
</li>
</ul>
<a id="CIHCEJFC"></a>
<div id="LNPLS99910" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Assigning One Record Variable to Another</h3>
<p>You can assign the value of one record variable to another record variable only in these cases:</p>
<ul>
<li>
<p>The two variables have the same <code dir="ltr">RECORD</code> type (as in <a href="#CIHDEIBG">Example 5-44</a>).</p>
</li>
<li>
<p>The target variable is declared with a <code dir="ltr">RECORD</code> type, the source variable is declared with <code dir="ltr">%ROWTYPE</code>, their fields match in number and order, and corresponding fields have the same data type (as in <a href="#CIHDGDHE">Example 5-45</a>).</p>
</li>
</ul>
<p>For record components of composite variables, the types of the composite variables need not match (see <a href="#BEIDCCBE">Example 5-46</a>).</p>
<div id="LNPLS457" class="example">
<p class="titleinexample"><a id="CIHDEIBG"></a>Example 5-44 Assigning Record to Another Record of Same RECORD Type</p>
<pre dir="ltr">
DECLARE
  TYPE name_rec IS RECORD (
    first  employees.first_name%TYPE DEFAULT 'John',
    last   employees.last_name%TYPE DEFAULT 'Doe'
  );
 
  <span class="bold">name1 name_rec;</span>
  <span class="bold">name2 name_rec;</span>
 
BEGIN
  name1.first := 'Jane'; name1.last := 'Smith'; 
  DBMS_OUTPUT.PUT_LINE('name1: ' || name1.first || ' ' || name1.last);
  <span class="bold">name2 := name1;</span>
  DBMS_OUTPUT.PUT_LINE('name2: ' || name2.first || ' ' || name2.last); 
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
name1: Jane Smith
name2: Jane Smith
</pre></div>
<!-- class="example" -->
<div id="LNPLS458" class="example">
<p class="titleinexample"><a id="CIHDGDHE"></a>Example 5-45 Assigning %ROWTYPE Record to RECORD Type Record</p>
<pre dir="ltr">
DECLARE
  TYPE name_rec IS RECORD (
    first  <span class="bold">employees.first_name%TYPE</span> DEFAULT 'John',
    last   <span class="bold">employees.last_name%TYPE</span> DEFAULT 'Doe'
  );
 
  CURSOR c IS
    SELECT <span class="bold">first_name</span>, <span class="bold">last_name</span>
    FROM <span class="bold">employees</span>;
 
  <span class="bold">target name_rec;</span>
  <span class="bold">source c%ROWTYPE;</span>
 
BEGIN
  source.first_name := 'Jane'; source.last_name := 'Smith';
 
  DBMS_OUTPUT.PUT_LINE (
    'source: ' || source.first_name || ' ' || source.last_name
  );
 
 <span class="bold">target := source;</span>
 
 DBMS_OUTPUT.PUT_LINE (
   'target: ' || target.first || ' ' || target.last
 );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
source: Jane Smith
target: Jane Smith
</pre></div>
<!-- class="example" -->
<p><a href="#BEIDCCBE">Example 5-46</a> assigns the value of one <a id="sthref468"></a>nested record to another nested record. The nested records have the same <code dir="ltr">RECORD</code> type, but the records in which they are nested do not.</p>
<div id="LNPLS492" class="example">
<p class="titleinexample"><a id="BEIDCCBE"></a>Example 5-46 Assigning Nested Record to Another Record of Same RECORD Type</p>
<pre dir="ltr">
DECLARE
  TYPE name_rec IS RECORD (
    first  employees.first_name%TYPE,
    last   employees.last_name%TYPE
  );
 
  TYPE <span class="bold">phone_rec</span> IS RECORD (
    name  <span class="bold">name_rec</span>,                    -- nested record
    phone employees.phone_number%TYPE
  );
 
  TYPE <span class="bold">email_rec</span> IS RECORD (
    name  <span class="bold">name_rec</span>,                    -- nested record
    email employees.email%TYPE
  );
 
  <span class="bold">phone_contact phone_rec;</span>
  <span class="bold">email_contact email_rec;</span>
 
BEGIN
  phone_contact.name.first := 'John';
  phone_contact.name.last := 'Smith';
  phone_contact.phone := '1-650-555-1234';
 
  <span class="bold">email_contact.name := phone_contact.name;</span>
  email_contact.email := (
    email_contact.name.first || '.' ||
    email_contact.name.last  || '@' ||
    'example.com' 
  );
 
  DBMS_OUTPUT.PUT_LINE (email_contact.email);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
John.Smith@example.com
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHFAIJB"></a>
<div id="LNPLS99909" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Assigning Full or Partial Rows to Record Variables</h3>
<p>If a record variable represents a full or partial row of a database table or view, you can assign the represented row to the record variable.</p>
<p class="subhead2"><a id="LNPLS459"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHGFBBC">SELECT INTO Statement for Assigning Row to Record Variable</a></p>
</li>
<li>
<p><a href="#CIHCGCJA">FETCH Statement for Assigning Row to Record Variable</a></p>
</li>
<li>
<p><a href="#CHDHIJDF">SQL Statements that Return Rows in PL/SQL Record Variables</a></p>
</li>
</ul>
<a id="CIHGFBBC"></a>
<div id="LNPLS99906" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SELECT INTO Statement for Assigning Row to Record Variable</h4>
<p>The syntax of a simple <a id="sthref469"></a><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement is:</p>
<pre dir="ltr">
SELECT <span class="italic">select_list</span> INTO <span class="italic">record_variable_name</span> FROM <span class="italic">table_or_view_name</span>;
</pre>
<p>For each column in <code dir="ltr"><span class="codeinlineitalic">select_list</span></code>, the record variable must have a corresponding, type-compatible field. The columns in <code dir="ltr"><span class="codeinlineitalic">select_list</span></code> must appear in the same order as the record fields.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="selectinto_statement.htm#i36066">"SELECT INTO Statement"</a> for complete syntax</div>
<p>In <a href="#CIHBFCAE">Example 5-47</a>, the record variable <code dir="ltr">rec1</code> represents a partial row of the <code dir="ltr">employees</code> table&mdash;the columns <code dir="ltr">last_name</code> and <code dir="ltr">employee_id</code>. The <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement selects from <code dir="ltr">employees</code> the row for which <code dir="ltr">job_id</code> is <code dir="ltr">'AD_PRES'</code> and assigns the values of the columns <code dir="ltr">last_name</code> and <code dir="ltr">employee_id</code> in that row to the corresponding fields of <code dir="ltr">rec1</code>.</p>
<div id="LNPLS495" class="example">
<p class="titleinexample"><a id="CIHBFCAE"></a>Example 5-47 SELECT INTO Assigns Values to Record Variable</p>
<pre dir="ltr">
DECLARE
  TYPE RecordTyp IS RECORD (
    last employees.last_name%TYPE,
    id   employees.employee_id%TYPE
  );
  rec1 RecordTyp;
BEGIN
  <span class="bold">SELECT last_name, employee_id INTO rec1</span>
  <span class="bold">FROM employees</span>
  <span class="bold">WHERE job_id = 'AD_PRES';</span>

  DBMS_OUTPUT.PUT_LINE ('Employee #' || rec1.id || ' = ' || rec1.last);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Employee #100 = King
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHCGCJA"></a>
<div id="LNPLS99905" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">FETCH Statement for Assigning Row to Record Variable</h4>
<p>The syntax of a simple <a id="sthref470"></a><code dir="ltr">FETCH</code> statement is:</p>
<pre dir="ltr">
FETCH <span class="italic">cursor</span> INTO <span class="italic">record_variable_name</span>;
</pre>
<p>A cursor is associated with a query. For every column that the query selects, the record variable must have a corresponding, type-compatible field. The cursor must be either an explicit cursor or a strong cursor variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="fetch_statement.htm#i34221">"FETCH Statement"</a> for complete syntax</p>
</li>
<li>
<p><a href="static.htm#BABDHAED">"Cursors"</a> for information about all cursors</p>
</li>
<li>
<p><a href="static.htm#CIHCAHJA">"Explicit Cursors"</a> for information about explicit cursors</p>
</li>
<li>
<p><a href="static.htm#i7106">"Cursor Variables"</a> for information about cursor variables</p>
</li>
</ul>
</div>
<p>In <a href="#BEIDDADJ">Example 5-48</a>, each variable of <code dir="ltr">RECORD</code> type <code dir="ltr">EmpRecTyp</code> represents a partial row of the <code dir="ltr">employees</code> table&mdash;the columns <code dir="ltr">employee_id</code> and <code dir="ltr">salary</code>. Both the cursor and the function return a value of type <code dir="ltr">EmpRecTyp</code>. In the function, a <code dir="ltr">FETCH</code> statement assigns the values of the columns <code dir="ltr">employee_id</code> and <code dir="ltr">salary</code> to the corresponding fields of a local variable of type <code dir="ltr">EmpRecTyp</code>.</p>
<div id="LNPLS490" class="example">
<p class="titleinexample"><a id="BEIDDADJ"></a>Example 5-48 FETCH Assigns Values to Record that Function Returns</p>
<pre dir="ltr">
DECLARE
  TYPE EmpRecTyp IS RECORD (
    emp_id  employees.employee_id%TYPE,
    salary  employees.salary%TYPE
  );
 
  CURSOR desc_salary RETURN EmpRecTyp IS
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC;
 
  highest_paid_emp       EmpRecTyp;
  next_highest_paid_emp  EmpRecTyp;
 
  FUNCTION nth_highest_salary (n INTEGER) RETURN EmpRecTyp IS
    emp_rec  EmpRecTyp;
  BEGIN
    OPEN desc_salary;
    FOR i IN 1..n LOOP
      <span class="bold">FETCH desc_salary INTO emp_rec;</span>
    END LOOP;
    CLOSE desc_salary;
    RETURN emp_rec;
  END nth_highest_salary;
 
BEGIN
  highest_paid_emp := nth_highest_salary(1);
  next_highest_paid_emp := nth_highest_salary(2);
 
  DBMS_OUTPUT.PUT_LINE(
    'Highest Paid: #' ||
    highest_paid_emp.emp_id || ', $' ||
    highest_paid_emp.salary 
  );
  DBMS_OUTPUT.PUT_LINE(
    'Next Highest Paid: #' ||
    next_highest_paid_emp.emp_id || ', $' ||
    next_highest_paid_emp.salary
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Highest Paid: #100, $26460
Next Highest Paid: #101, $18742.5
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDHIJDF"></a>
<div id="LNPLS99953" class="sect3">
<h4 class="sect3">SQL Statements that Return Rows in PL/SQL Record Variables</h4>
<p>The SQL statements <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> have an optional <code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause that can return the affected row in a PL/SQL record variable. For information about this clause, see <a href="returninginto_clause.htm#CJAGFGDE">"RETURNING INTO Clause"</a>.</p>
<p>In <a href="#BABHDGIG">Example 5-49</a>, the <code dir="ltr">UPDATE</code> statement updates the salary of an employee and returns the name and new salary of the employee in a record variable.</p>
<div id="LNPLS501" class="example">
<p class="titleinexample"><a id="BABHDGIG"></a>Example 5-49 UPDATE Statement Assigns Values to Record Variable</p>
<pre dir="ltr">
DECLARE
  TYPE EmpRec IS RECORD (
    last_name  employees.last_name%TYPE,
    salary     employees.salary%TYPE
  );
  <span class="bold">emp_info    EmpRec;</span>
  old_salary  employees.salary%TYPE;
BEGIN
  SELECT salary INTO old_salary
   FROM employees
   WHERE employee_id = 100;
 
  <span class="bold">UPDATE employees</span>
    <span class="bold">SET salary = salary * 1.1</span>
    <span class="bold">WHERE employee_id = 100</span>
    <span class="bold">RETURNING last_name, salary INTO emp_info;</span>
 
  DBMS_OUTPUT.PUT_LINE (
    'Salary of ' || emp_info.last_name || ' raised from ' ||
    old_salary || ' to ' || emp_info.salary
  );
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Salary of King raised from 26460 to 29106
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGHJJI"></a>
<div id="LNPLS460" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Assigning NULL to Record Variable</h3>
<p><a id="sthref471"></a>Assigning the value <code dir="ltr">NULL</code> to a record variable assigns the value <code dir="ltr">NULL</code> to each of its fields. This assignment is recursive; that is, if a field is a record, then its fields are also assigned the value <code dir="ltr">NULL</code>.</p>
<p><a href="#BABHJAID">Example 5-50</a> prints the fields of a record variable (one of which is a record) before and after assigning <code dir="ltr">NULL</code> to it.</p>
<div id="LNPLS465" class="example">
<p class="titleinexample"><a id="BABHJAID"></a>Example 5-50 Assigning NULL to Record Variable</p>
<pre dir="ltr">
DECLARE
  TYPE age_rec IS RECORD (
    years  INTEGER DEFAULT 35,
    months INTEGER DEFAULT 6
  );
 
  TYPE name_rec IS RECORD (
    first  employees.first_name%TYPE DEFAULT 'John',
    last   employees.last_name%TYPE DEFAULT 'Doe',
    age    age_rec
  );
 
  name name_rec;
 
  PROCEDURE print_name AS
  BEGIN
    DBMS_OUTPUT.PUT(NVL(name.first, 'NULL') || ' '); 
    DBMS_OUTPUT.PUT(NVL(name.last,  'NULL') || ', ');
    DBMS_OUTPUT.PUT(NVL(TO_CHAR(name.age.years), 'NULL') || ' yrs ');
    DBMS_OUTPUT.PUT_LINE(NVL(TO_CHAR(name.age.months), 'NULL') || ' mos');
  END;
 
BEGIN
  print_name;
  <span class="bold">name := NULL;</span>
  print_name;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
John Doe, 35 yrs 6 mos
NULL NULL, NULL yrs NULL mos
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJAIIBHD"></a>
<div id="LNPLS496" class="sect1">
<h2 class="sect1">Record Comparisons</h2>
<p><a id="sthref472"></a>Records cannot be tested natively for nullity, equality, or inequality. These <code dir="ltr">BOOLEAN</code> expressions are illegal:</p>
<ul>
<li>
<p><code dir="ltr">My_Record IS NULL</code></p>
</li>
<li>
<p><code dir="ltr">My_Record_1 = My_Record_2</code></p>
</li>
<li>
<p><code dir="ltr">My_Record_1 &gt; My_Record_2</code></p>
</li>
</ul>
<p>You must write your own functions to implement such tests. For information about writing functions, see <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms."</a></p>
</div>
<!-- class="sect1" -->
<a id="i36801"></a>
<div id="LNPLS497" class="sect1">
<h2 class="sect1">Inserting Records into Tables</h2>
<p>The PL/SQL extension to the SQL <a id="sthref473"></a><code dir="ltr">INSERT</code> statement lets you insert a record into a table. The record must represent a row of the table. For more information, see <a href="insert_statement.htm#CJADIJED">"INSERT Statement Extension"</a>. For restrictions on inserting records into tables, see <a href="#CJABADDJ">"Restrictions on Record Inserts and Updates"</a>.</p>
<p><a href="#CHDBEBEB">Example 5-51</a> creates the table <code dir="ltr">schedule</code> and initializes it by putting default values in a record and inserting the record into the table for each week. (The <code dir="ltr">COLUMN</code> formatting commands are from SQL*Plus.)</p>
<div id="LNPLS466" class="example">
<p class="titleinexample"><a id="CHDBEBEB"></a>Example 5-51 Initializing Table by Inserting Record of Default Values</p>
<pre dir="ltr">
DROP TABLE schedule;
CREATE TABLE schedule (
  week  NUMBER,
  Mon   VARCHAR2(10),
  Tue   VARCHAR2(10),
  Wed   VARCHAR2(10),
  Thu   VARCHAR2(10),
  Fri   VARCHAR2(10),
  Sat   VARCHAR2(10),
  Sun   VARCHAR2(10)
);
 
DECLARE
  default_week  schedule%ROWTYPE;
  i             NUMBER;
BEGIN
  default_week.Mon := '0800-1700';
  default_week.Tue := '0800-1700';
  default_week.Wed := '0800-1700';
  default_week.Thu := '0800-1700';
  default_week.Fri := '0800-1700';
  default_week.Sat := 'Day Off';
  default_week.Sun := 'Day Off';
 
  FOR i IN 1..6 LOOP
    default_week.week    := i;
    
    <span class="bold">INSERT INTO schedule VALUES default_week;</span>
  END LOOP;
END;
/
 
COLUMN week FORMAT 99
COLUMN Mon  FORMAT A9
COLUMN Tue  FORMAT A9
COLUMN Wed  FORMAT A9
COLUMN Thu  FORMAT A9
COLUMN Fri  FORMAT A9
COLUMN Sat  FORMAT A9
COLUMN Sun  FORMAT A9
 
SELECT * FROM schedule;
</pre>
<p>Result:</p>
<pre dir="ltr">
WEEK MON       TUE       WED       THU       FRI       SAT       SUN
---- --------- --------- --------- --------- --------- --------- ---------
   1 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   2 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   3 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   4 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   5 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   6 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
</pre></div>
<!-- class="example" -->
<p>To efficiently insert a collection of records into a table, put the <code dir="ltr">INSERT</code> statement inside a <code dir="ltr">FORALL</code> statement. For information about the <code dir="ltr">FORALL</code> statement, see <a href="tuning.htm#i54218">"FORALL Statement"</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i36279"></a>
<div id="LNPLS499" class="sect1">
<h2 class="sect1">Updating Rows with Records</h2>
<p>The PL/SQL extension to the SQL <a id="sthref474"></a><code dir="ltr">UPDATE</code> statement lets you update one or more table rows with a record. The record must represent a row of the table. For more information, see <a href="update_statement.htm#CJAIGFJI">"UPDATE Statement Extensions"</a>. For restrictions on updating table rows with a record, see <a href="#CJABADDJ">"Restrictions on Record Inserts and Updates"</a>.</p>
<p><a href="#BABDGCDI">Example 5-52</a> updates the first three weeks of the table <code dir="ltr">schedule</code> (defined in <a href="#CHDBEBEB">Example 5-51</a>) by putting the new values in a record and updating the first three rows of the table with that record.</p>
<div id="LNPLS500" class="example">
<p class="titleinexample"><a id="BABDGCDI"></a>Example 5-52 Updating Rows with Record</p>
<pre dir="ltr">
DECLARE
  default_week  schedule%ROWTYPE;
BEGIN
  default_week.Mon := 'Day Off';
  default_week.Tue := '0900-1800';
  default_week.Wed := '0900-1800';
  default_week.Thu := '0900-1800';
  default_week.Fri := '0900-1800';
  default_week.Sat := '0900-1800';
  default_week.Sun := 'Day Off';
 
  FOR i IN 1..3 LOOP
    default_week.week    := i;
  
    UPDATE schedule
    SET ROW = default_week
    WHERE week = i;
  END LOOP;
END;
/
 
SELECT * FROM schedule;
</pre>
<p>Result:</p>
<pre dir="ltr">
WEEK MON       TUE       WED       THU       FRI       SAT       SUN
---- --------- --------- --------- --------- --------- --------- ---------
   1 Day Off   0900-1800 0900-1800 0900-1800 0900-1800 0900-1800 Day Off
   2 Day Off   0900-1800 0900-1800 0900-1800 0900-1800 0900-1800 Day Off
   3 Day Off   0900-1800 0900-1800 0900-1800 0900-1800 0900-1800 Day Off
   4 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   5 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
   6 0800-1700 0800-1700 0800-1700 0800-1700 0800-1700 Day Off   Day Off
</pre>
<p>To efficiently update a set of rows with a collection of records, put the <code dir="ltr">UPDATE</code> statement inside a <code dir="ltr">FORALL</code> statement. For information about the <code dir="ltr">FORALL</code> statement, see <a href="tuning.htm#i54218">"FORALL Statement"</a>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="CJABADDJ"></a>
<div id="LNPLS502" class="sect1">
<h2 class="sect1">Restrictions on Record Inserts and Updates</h2>
<p>These restrictions apply to record <a id="sthref475"></a>inserts and <a id="sthref476"></a>updates:</p>
<ul>
<li>
<p>Record variables are allowed only in these places:</p>
<ul>
<li>
<p>On the right side of the <code dir="ltr">SET</code> clause in an <code dir="ltr">UPDATE</code> statement</p>
</li>
<li>
<p>In the <code dir="ltr">VALUES</code> clause of an <code dir="ltr">INSERT</code> statement</p>
</li>
<li>
<p>In the <code dir="ltr">INTO</code> subclause of a <code dir="ltr">RETURNING</code> clause</p>
</li>
</ul>
<p>Record variables are not allowed in a <code dir="ltr">SELECT</code> list, <code dir="ltr">WHERE</code> clause, <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause, or <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause.</p>
</li>
<li>
<p>The keyword <code dir="ltr">ROW</code> is allowed only on the left side of a <code dir="ltr">SET</code> clause. Also, you cannot use <code dir="ltr">ROW</code> with a subquery.</p>
</li>
<li>
<p>In an <code dir="ltr">UPDATE</code> statement, only one <code dir="ltr">SET</code> clause is allowed if <code dir="ltr">ROW</code> is used.</p>
</li>
<li>
<p>If the <code dir="ltr">VALUES</code> clause of an <code dir="ltr">INSERT</code> statement contains a record variable, no other variable or value is allowed in the clause.</p>
</li>
<li>
<p>If the <code dir="ltr">INTO</code> subclause of a <code dir="ltr">RETURNING</code> clause contains a record variable, no other variable or value is allowed in the subclause.</p>
</li>
<li>
<p>These are not supported:</p>
<ul>
<li>
<p>Nested <code dir="ltr">RECORD</code> types</p>
</li>
<li>
<p>Functions that return a <code dir="ltr">RECORD</code> type</p>
</li>
<li>
<p>Record inserts and updates using the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="controlstatements.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="static.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
