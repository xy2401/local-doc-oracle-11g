<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Dynamic SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:52:57Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="static.htm" title="Previous" type="text/html" />
<link rel="Next" href="subprograms.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/99</span> <!-- End Header -->
<div id="LNPLS011" class="chapter"><a id="CACDDACH"></a>
<h1 class="chapter"><span class="secnum">7</span> PL/SQL Dynamic SQL</h1>
<p><a id="sthref627"></a><span class="bold">Dynamic SQL</span> is a programming methodology for generating and running SQL statements at run time. It is useful when writing general-purpose and flexible programs like ad hoc query systems, when writing programs that must run <a id="sthref628"></a>database definition language (DDL) statements, or when you do not know at compilation time the full text of a SQL statement or the number or data types of its input and output variables.</p>
<p>PL/SQL provides two ways to write dynamic SQL:</p>
<ul>
<li>
<p>Native dynamic SQL, a PL/SQL language (that is, native) feature for building and running dynamic SQL statements</p>
</li>
<li>
<p><code dir="ltr">DBMS_SQL</code> package, an API for building, running, and describing dynamic SQL statements</p>
</li>
</ul>
<p>Native dynamic SQL code is easier to read and write than equivalent code that uses the <code dir="ltr">DBMS_SQL</code> package, and runs noticeably faster (especially when it can be optimized by the compiler). However, to write native dynamic SQL code, you must know at compile time the number and data types of the input and output variables of the dynamic SQL statement. If you do not know this information at compile time, you must use the <code dir="ltr">DBMS_SQL</code> package.</p>
<p>When you need both the <code dir="ltr">DBMS_SQL</code> package and native dynamic SQL, you can switch between them, using the <a href="#BHCECGGF">"DBMS_SQL.TO_REFCURSOR Function"</a> and <a href="#BHCBJGEH">"DBMS_SQL.TO_CURSOR_NUMBER Function"</a>.</p>
<p class="subhead2"><a id="LNPLS521"></a>Topics</p>
<ul>
<li>
<p><a href="#i12999">When You Need Dynamic SQL</a></p>
</li>
<li>
<p><a href="#i13130">Native Dynamic SQL</a></p>
</li>
<li>
<p><a href="#BHCIBJBG">DBMS_SQL Package</a></p>
</li>
<li>
<p><a href="#CHDFCHHJ">SQL Injection</a></p>
</li>
</ul>
<a id="i12999"></a>
<div id="LNPLS01101" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">When You Need Dynamic SQL</h2>
<p>In PL/SQL, you need dynamic SQL to run:</p>
<ul>
<li>
<p>SQL whose text is unknown at compile time</p>
<p>For example, a <code dir="ltr">SELECT</code> statement that includes an identifier that is unknown at compile time (such as a table name) or a <code dir="ltr">WHERE</code> clause in which the number of subclauses is unknown at compile time.</p>
</li>
<li>
<p>SQL that is not supported as static SQL</p>
<p>That is, any SQL construct not included in <a href="static.htm#i7112">"Description of Static SQL"</a>.</p>
</li>
</ul>
<p>If you do not need dynamic SQL, use static SQL, which has these advantages:</p>
<ul>
<li>
<p>Successful compilation verifies that static SQL statements reference valid database objects and that the necessary privileges are in place to access those objects.</p>
</li>
<li>
<p>Successful compilation creates schema object dependencies.</p>
<p>For information about schema object dependencies, see <a class="olink ADFNS99967" href="../../appdev.112/e41502/adfns_dependencies.htm#ADFNS99967"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
</li>
</ul>
<p>For information about using static SQL statements with PL/SQL, see <a href="static.htm#BABGEDAE">Chapter 6, "PL/SQL Static SQL."</a></p>
</div>
<!-- class="sect1" -->
<a id="i13130"></a>
<div id="LNPLS01102" class="sect1">
<h2 class="sect1">Native Dynamic SQL</h2>
<p><a id="sthref629"></a><a id="sthref630"></a>Native dynamic SQL processes most dynamic SQL statements with the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement.</p>
<p>If the dynamic SQL statement is a <code dir="ltr">SELECT</code> statement that returns multiple rows, native dynamic SQL gives you these choices:</p>
<ul>
<li>
<p>Use the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement with the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause.</p>
</li>
<li>
<p>Use the <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code>, <code dir="ltr">FETCH</code>, and <code dir="ltr">CLOSE</code> statements.</p>
</li>
</ul>
<p><a id="sthref631"></a>The SQL cursor attributes work the same way after native dynamic SQL <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, <code dir="ltr">MERGE</code>, and single-row <code dir="ltr">SELECT</code> statements as they do for their static SQL counterparts. For more information about SQL cursor attributes, see <a href="static.htm#BABDHAED">"Cursors"</a>.</p>
<p class="subhead2"><a id="LNPLS522"></a>Topics</p>
<ul>
<li>
<p><a href="#BHCEBBAI">EXECUTE IMMEDIATE Statement</a></p>
</li>
<li>
<p><a href="#i13057">OPEN FOR, FETCH, and CLOSE Statements</a></p>
</li>
<li>
<p><a href="#BHCGEFCA">Repeated Placeholder Names in Dynamic SQL Statements</a></p>
</li>
</ul>
<a id="BHCEBBAI"></a>
<div id="LNPLS01115" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">EXECUTE IMMEDIATE Statement</h3>
<p>The <a id="sthref632"></a><code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement is the means by which native dynamic SQL processes most dynamic SQL statements.</p>
<p>If the dynamic SQL statement is <span class="bold">self-contained</span> (that is, if it has no <a id="sthref633"></a><a id="sthref634"></a>placeholders for bind variables and the only result that it can possibly return is an error), then the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement needs no clauses.</p>
<p>If the dynamic SQL statement includes placeholders for bind variables, each placeholder must have a corresponding bind variable in the appropriate clause of the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement, as follows:</p>
<ul>
<li>
<p>If the dynamic SQL statement is a <code dir="ltr">SELECT</code> statement that can return at most one row, put out-bind variables (defines) in the <code dir="ltr">INTO</code> clause and in-bind variables in the <code dir="ltr">USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a <code dir="ltr">SELECT</code> statement that can return multiple rows, put out-bind variables (defines) in the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause and in-bind variables in the <code dir="ltr">USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a DML statement without a <code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause, other than <code dir="ltr">SELECT</code>, put all bind variables in the <code dir="ltr">USING</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is a DML statement with a <code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause, put in-bind variables in the <code dir="ltr">USING</code> clause and out-bind variables in the <code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause.</p>
</li>
<li>
<p>If the dynamic SQL statement is an anonymous PL/SQL block or a <code dir="ltr">CALL</code> statement, put all bind variables in the <code dir="ltr">USING</code> clause.</p>
<p>If the dynamic SQL statement invokes a subprogram, ensure that:</p>
<ul>
<li>
<p>Every bind variable that corresponds to a placeholder for a subprogram parameter has the same parameter mode as that subprogram parameter (as in <a href="#CHDIEFCJ">Example 7-1</a>) and a data type that is compatible with that of the subprogram parameter. (For information about compatible data types, see <a href="subprograms.htm#i4100">"Formal and Actual Subprogram Parameters"</a>.)</p>
</li>
<li>
<p>No bind variable has a data type that SQL does not support (such as <code dir="ltr">BOOLEAN</code> in <a href="#BHCEJIDC">Example 7-2</a>).</p>
</li>
</ul>
</li>
</ul>
<p>The <code dir="ltr">USING</code> clause cannot contain the literal <code dir="ltr">NULL</code>. To work around this restriction, use an uninitialized variable where you want to use <code dir="ltr">NULL</code>, as in <a href="#BHCBIICB">Example 7-3</a>.</p>
<p>For syntax details of the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement, see <a href="executeimmediate_statement.htm#i33888">"EXECUTE IMMEDIATE Statement"</a>.</p>
<div id="LNPLS626" class="example">
<p class="titleinexample"><a id="CHDIEFCJ"></a>Example 7-1 Invoking Subprogram from Dynamic PL/SQL Block</p>
<pre dir="ltr">
<span class="bold">-- Subprogram that dynamic PL/SQL block invokes:</span>
CREATE OR REPLACE PROCEDURE create_dept (
  deptid <span class="bold">IN OUT</span> NUMBER,
  dname  <span class="bold">IN</span>     VARCHAR2,
  mgrid  <span class="bold">IN</span>     NUMBER,
  locid  <span class="bold">IN</span>     NUMBER
) AS
BEGIN
  deptid := departments_seq.NEXTVAL;

  INSERT INTO departments (
    department_id,
    department_name,
    manager_id,
    location_id
  )
  VALUES (deptid, dname, mgrid, locid);
END;
/
DECLARE
  plsql_block VARCHAR2(500);
  new_deptid  NUMBER(4);
  new_dname   VARCHAR2(30) := 'Advertising';
  new_mgrid   NUMBER(6)    := 200;
  new_locid   NUMBER(4)    := 1700;
BEGIN
<span class="bold"> -- Dynamic PL/SQL block invokes subprogram:</span>
  plsql_block := 'BEGIN create_dept(:a, :b, :c, :d); END;';

<span class="bold"> /* Specify bind variables in USING clause.</span>
<span class="bold">    Specify mode for first parameter.</span>
<span class="bold">    Modes of other parameters are correct by default. */</span>

  EXECUTE IMMEDIATE plsql_block
    USING <span class="bold">IN OUT</span> new_deptid, new_dname, new_mgrid, new_locid;
END;
/
</pre></div>
<!-- class="example" -->
<div id="LNPLS627" class="example">
<p class="titleinexample"><a id="BHCEJIDC"></a>Example 7-2 Unsupported Data Type in Native Dynamic SQL</p>
<pre dir="ltr">
DECLARE
  dyn_stmt VARCHAR2(200);
  <span class="bold">b1       BOOLEAN;</span>

  FUNCTION f (x INTEGER)
    RETURN BOOLEAN
  AS
  BEGIN
    NULL;
  END f;

BEGIN
  dyn_stmt := 'BEGIN :b := f(5); END;';
  EXECUTE IMMEDIATE dyn_stmt USING OUT <span class="bold">b1</span>;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
  EXECUTE IMMEDIATE dyn_stmt USING OUT <span class="bold">b1</span>;
                                       <span class="bold">*</span>
ERROR at line 15:
ORA-06550: line 15, column 40:
<span class="bold">PLS-00457: expressions have to be of SQL types</span>
ORA-06550: line 15, column 3:
PL/SQL: Statement ignored
</pre></div>
<!-- class="example" -->
<div id="LNPLS628" class="example">
<p class="titleinexample"><a id="BHCBIICB"></a>Example 7-3 Uninitialized Variable Represents NULL in USING Clause</p>
<pre dir="ltr">
CREATE TABLE employees_temp AS SELECT * FROM EMPLOYEES;

DECLARE
  a_null  CHAR(1);  <span class="bold">-- Set to NULL automatically at run time</span>
BEGIN
  EXECUTE IMMEDIATE 'UPDATE employees_temp SET commission_pct = :x'
    USING <span class="bold">a_null</span>;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i13057"></a>
<div id="LNPLS629" class="sect2">
<h3 class="sect2">OPEN FOR, FETCH, and CLOSE Statements</h3>
<p><a id="sthref635"></a>If the dynamic SQL statement represents a <code dir="ltr">SELECT</code> statement that returns multiple rows, you can process it with native dynamic SQL as follows:</p>
<ol>
<li>
<p>Use an <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement to associate a cursor variable with the dynamic SQL statement. In the <code dir="ltr">USING</code> clause of the <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement, specify a bind variable for each placeholder in the dynamic SQL statement.</p>
<p>The <code dir="ltr">USING</code> clause cannot contain the literal <code dir="ltr">NULL</code>. To work around this restriction, use an uninitialized variable where you want to use <code dir="ltr">NULL</code>, as in <a href="#BHCBIICB">Example 7-3</a>.</p>
<p>For syntax details, see <a href="openfor_statement.htm#i35231">"OPEN FOR Statement"</a>.</p>
</li>
<li>
<p>Use the <code dir="ltr">FETCH</code> statement to retrieve result set rows one at a time, several at a time, or all at once.</p>
<p>For syntax details, see <a href="fetch_statement.htm#i34221">"FETCH Statement"</a>.</p>
</li>
<li>
<p>Use the <code dir="ltr">CLOSE</code> statement to close the cursor variable.</p>
<p>For syntax details, see <a href="close_statement.htm#i32987">"CLOSE Statement"</a>.</p>
</li>
</ol>
<p><a href="#BHCFDIAI">Example 7-4</a> lists all employees who are managers, retrieving result set rows one at a time.</p>
<div id="LNPLS630" class="example">
<p class="titleinexample"><a id="BHCFDIAI"></a>Example 7-4 Native Dynamic SQL with OPEN FOR, FETCH, and CLOSE Statements</p>
<pre dir="ltr">
DECLARE
  TYPE EmpCurTyp  IS REF CURSOR;
  v_emp_cursor    EmpCurTyp;
  emp_record      employees%ROWTYPE;
  v_stmt_str      VARCHAR2(200);
  v_e_job         employees.job%TYPE;
BEGIN
  <span class="bold">-- Dynamic SQL statement with placeholder:</span>
  v_stmt_str := 'SELECT * FROM employees WHERE job_id = :j';

  <span class="bold">-- Open cursor &amp; specify bind variable in USING clause:</span>
  OPEN v_emp_cursor FOR v_stmt_str USING 'MANAGER';

  <span class="bold">-- Fetch rows from result set one at a time:</span>
  LOOP
    FETCH v_emp_cursor INTO emp_record;
    EXIT WHEN v_emp_cursor%NOTFOUND;
  END LOOP;

  <span class="bold">-- Close cursor:</span>
  CLOSE v_emp_cursor;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BHCGEFCA"></a>
<div id="LNPLS631" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Repeated Placeholder Names in Dynamic SQL Statements</h3>
<p>If you repeat <a id="sthref636"></a><a id="sthref637"></a>placeholder names in dynamic SQL statements, be aware that the way placeholders are associated with bind variables depends on the kind of dynamic SQL statement.</p>
<p class="subhead2"><a id="LNPLS523"></a>Topics</p>
<ul>
<li>
<p><a href="#BHCHIHEJ">Dynamic SQL Statement is Not Anonymous Block or CALL Statement</a></p>
</li>
<li>
<p><a href="#BHCHABFG">Dynamic SQL Statement is Anonymous Block or CALL Statement</a></p>
</li>
</ul>
<a id="BHCHIHEJ"></a>
<div id="LNPLS632" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Dynamic SQL Statement is Not Anonymous Block or CALL Statement</h4>
<p>If the dynamic SQL statement does not represent an anonymous PL/SQL block or a <code dir="ltr">CALL</code> statement, repetition of placeholder names is insignificant. Placeholders are associated with bind variables in the <code dir="ltr">USING</code> clause by position, not by name.</p>
<p>For example, in this dynamic SQL statement, the repetition of the name :<code dir="ltr">x</code> is insignificant:</p>
<pre dir="ltr">
sql_stmt := 'INSERT INTO payroll VALUES (:x, :x, :y, :x)';
</pre>
<p>In the corresponding <code dir="ltr">USING</code> clause, you must supply four bind variables. They can be different; for example:</p>
<pre dir="ltr">
EXECUTE IMMEDIATE sql_stmt USING a, b, c, d;
</pre>
<p>The preceding <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement runs this SQL statement:</p>
<pre dir="ltr">
INSERT INTO payroll VALUES (a, b, c, d)
</pre>
<p>To associate the same bind variable with each occurrence of :<code dir="ltr">x</code>, you must repeat that bind variable; for example:</p>
<pre dir="ltr">
EXECUTE IMMEDIATE sql_stmt USING a, a, b, a;
</pre>
<p>The preceding <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement runs this SQL statement:</p>
<pre dir="ltr">
INSERT INTO payroll VALUES (a, a, b, a)
</pre></div>
<!-- class="sect3" -->
<a id="BHCHABFG"></a>
<div id="LNPLS633" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Dynamic SQL Statement is Anonymous Block or CALL Statement</h4>
<p>If the dynamic SQL statement represents an anonymous PL/SQL block or a <code dir="ltr">CALL</code> statement, repetition of placeholder names is significant. Each unique placeholder name must have a corresponding bind variable in the <code dir="ltr">USING</code> clause. If you repeat a placeholder name, you need not repeat its corresponding bind variable. All references to that placeholder name correspond to one bind variable in the <code dir="ltr">USING</code> clause.</p>
<p>In <a href="#CHDFHEAG">Example 7-5</a>, all references to the first unique placeholder name, :<code dir="ltr">x</code>, are associated with the first bind variable in the <code dir="ltr">USING</code> clause, <code dir="ltr">a</code>, and the second unique placeholder name, :<code dir="ltr">y</code>, is associated with the second bind variable in the <code dir="ltr">USING</code> clause, <code dir="ltr">b</code>.</p>
<div id="LNPLS634" class="example">
<p class="titleinexample"><a id="CHDFHEAG"></a>Example 7-5 Repeated Placeholder Names in Dynamic PL/SQL Block</p>
<pre dir="ltr">
CREATE PROCEDURE calc_stats (
  w NUMBER,
  x NUMBER,
  y NUMBER,
  z NUMBER )
IS
BEGIN
  DBMS_OUTPUT.PUT_LINE(w + x + y + z);
END;
/
DECLARE
  a NUMBER := 4;
  b NUMBER := 7;
  plsql_block VARCHAR2(100);
BEGIN
  plsql_block := 'BEGIN calc_stats(:x, :x, :y, :x); END;';
  EXECUTE IMMEDIATE plsql_block USING a, b;  <span class="bold">-- calc_stats(a, a, b, a)</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BHCIBJBG"></a>
<div id="LNPLS01108" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">DBMS_SQL Package</h2>
<p>The <a id="sthref638"></a><code dir="ltr">DBMS_SQL</code> package defines an entity called a <a id="sthref639"></a>SQL cursor number. Because the SQL cursor number is a PL/SQL integer, you can pass it across call boundaries and store it.</p>
<p>You must use the <code dir="ltr">DBMS_SQL</code> package to run a dynamic SQL statement when you do not know either of these until run time:</p>
<ul>
<li>
<p><code dir="ltr">SELECT</code> list</p>
</li>
<li>
<p>What placeholders in a <code dir="ltr">SELECT</code> or DML statement must be bound</p>
</li>
</ul>
<p>In these situations, you must use native dynamic SQL instead of the <code dir="ltr">DBMS_SQL</code> package:</p>
<ul>
<li>
<p>The dynamic SQL statement retrieves rows into records.</p>
</li>
<li>
<p><a id="sthref640"></a>You want to use the SQL cursor attribute <code dir="ltr">%FOUND</code>, <code dir="ltr">%ISOPEN</code>, <code dir="ltr">%NOTFOUND</code>, or <code dir="ltr">%ROWCOUNT</code> after issuing a dynamic SQL statement that is an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, <code dir="ltr">MERGE</code>, or single-row <code dir="ltr">SELECT</code> statement.</p>
</li>
</ul>
<p>For information about native dynamic SQL, see <a href="#i13130">"Native Dynamic SQL"</a>.</p>
<p>When you need both the <a id="sthref641"></a><a id="sthref642"></a><a id="sthref643"></a><code dir="ltr">DBMS_SQL</code> package and native dynamic SQL, you can switch between them, using:</p>
<ul>
<li>
<p><a href="#BHCECGGF">DBMS_SQL.TO_REFCURSOR Function</a></p>
</li>
<li>
<p><a href="#BHCBJGEH">DBMS_SQL.TO_CURSOR_NUMBER Function</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can invoke <code dir="ltr">DBMS_SQL</code> subprograms remotely.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS058" href="../../appdev.112/e40758/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_SQL</code> package, including instructions for running a dynamic SQL statement that has an unknown number of input or output variables (<a id="sthref644"></a>"Method 4")</div>
<a id="BHCECGGF"></a>
<div id="LNPLS01113" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DBMS_SQL.TO_REFCURSOR Function</h3>
<p>The <a id="sthref645"></a><a id="sthref646"></a><code dir="ltr">DBMS_SQL</code>.<code dir="ltr">TO_REFCURSOR</code> function converts a SQL cursor number to a weak cursor variable, which you can use in native dynamic SQL statements.</p>
<p>Before passing a SQL cursor number to the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">TO_REFCURSOR</code> function, you must <code dir="ltr">OPEN</code>, <code dir="ltr">PARSE</code>, and <code dir="ltr">EXECUTE</code> it (otherwise an error occurs).</p>
<p>After you convert a SQL cursor number to a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> variable, <code dir="ltr">DBMS_SQL</code> operations can access it only as the <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> variable, not as the SQL cursor number. For example, using the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">IS_OPEN</code> function to see if a converted SQL cursor number is still open causes an error.</p>
<p><a href="#g1777282">Example 7-6</a> uses the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">TO_REFCURSOR</code> function to switch from the <code dir="ltr">DBMS_SQL</code> package to native dynamic SQL.</p>
<div id="LNPLS635" class="example">
<p class="titleinexample"><a id="g1777282"></a>Example 7-6 Switching from DBMS_SQL Package to Native Dynamic SQL</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE vc_array IS TABLE OF VARCHAR2(200);
/
CREATE OR REPLACE TYPE numlist IS TABLE OF NUMBER;
/
CREATE OR REPLACE PROCEDURE do_query_1 (
  placeholder vc_array,
  bindvars vc_array,
  sql_stmt VARCHAR2
)
IS
  TYPE curtype IS REF CURSOR;
  src_cur     curtype;
  curid       NUMBER;
  bindnames   vc_array;
  empnos      numlist;
  depts       numlist;
  ret         NUMBER;
  isopen      BOOLEAN;
BEGIN
  <span class="bold">-- Open SQL cursor number:</span>
  curid := DBMS_SQL.OPEN_CURSOR;

  <span class="bold">-- Parse SQL cursor number:</span>
  DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);

  bindnames := placeholder;

  -- Bind variables:
  FOR i IN 1 .. bindnames.COUNT LOOP
    DBMS_SQL.BIND_VARIABLE(curid, bindnames(i), bindvars(i));
  END LOOP;

  <span class="bold">-- Run SQL cursor number:</span>
  ret := DBMS_SQL.EXECUTE(curid);

  <span class="bold">-- Switch from DBMS_SQL to native dynamic SQL:</span>
  src_cur := DBMS_SQL.TO_REFCURSOR(curid);
  FETCH src_cur BULK COLLECT INTO empnos, depts;

  <span class="bold">-- This would cause an error because curid was converted to a REF CURSOR:</span>
  -- isopen := DBMS_SQL.IS_OPEN(curid);

  CLOSE src_cur;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BHCBJGEH"></a>
<div id="LNPLS00001" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DBMS_SQL.TO_CURSOR_NUMBER Function</h3>
<p>The <a id="sthref647"></a><a id="sthref648"></a><code dir="ltr">DBMS_SQL</code>.<code dir="ltr">TO_CURSOR_NUMBER</code> function converts a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> variable (either strong or weak) to a SQL cursor number, which you can pass to <code dir="ltr">DBMS_SQL</code> subprograms.</p>
<p>Before passing a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> variable to the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">TO_CURSOR_NUMBER</code> function, you must <code dir="ltr">OPEN</code> it.</p>
<p>After you convert a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> variable to a SQL cursor number, native dynamic SQL operations cannot access it.</p>
<p><a href="#BHCHJBHJ">Example 7-7</a> uses the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">TO_CURSOR_NUMBER</code> function to switch from native dynamic SQL to the <code dir="ltr">DBMS_SQL</code> package.</p>
<div id="LNPLS636" class="example">
<p class="titleinexample"><a id="BHCHJBHJ"></a>Example 7-7 Switching from Native Dynamic SQL to DBMS_SQL Package</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE do_query_2 (
  sql_stmt VARCHAR2
)
IS
  TYPE curtype IS REF CURSOR;
  src_cur   curtype;
  curid     NUMBER;
  desctab   DBMS_SQL.DESC_TAB;
  colcnt    NUMBER;
  namevar   VARCHAR2(50);
  numvar    NUMBER;
  datevar   DATE;
  empno     NUMBER := 100;
BEGIN
  -- sql_stmt := SELECT ... FROM employees WHERE employee_id = :b1';

  <span class="bold">-- Open REF CURSOR variable:</span>
  OPEN src_cur FOR sql_stmt USING empno;

  <span class="bold">-- Switch from native dynamic SQL to DBMS_SQL package:</span>
  curid := DBMS_SQL.TO_CURSOR_NUMBER(src_cur);
  DBMS_SQL.DESCRIBE_COLUMNS(curid, colcnt, desctab);

  -- Define columns:
  FOR i IN 1 .. colcnt LOOP
    IF desctab(i).col_type = 2 THEN
      DBMS_SQL.DEFINE_COLUMN(curid, i, numvar);
    ELSIF desctab(i).col_type = 12 THEN
      DBMS_SQL.DEFINE_COLUMN(curid, i, datevar);
      -- statements
    ELSE
      DBMS_SQL.DEFINE_COLUMN(curid, i, namevar, 50);
    END IF;
  END LOOP;

  -- Fetch rows with DBMS_SQL package:
  WHILE DBMS_SQL.FETCH_ROWS(curid) &gt; 0 LOOP
    FOR i IN 1 .. colcnt LOOP
      IF (desctab(i).col_type = 1) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, namevar);
      ELSIF (desctab(i).col_type = 2) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, numvar);
      ELSIF (desctab(i).col_type = 12) THEN
        DBMS_SQL.COLUMN_VALUE(curid, i, datevar);
        -- statements
      END IF;
    END LOOP;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(curid);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFCHHJ"></a>
<div id="LNPLS01109" class="sect1">
<h2 class="sect1">SQL Injection</h2>
<p><a id="sthref649"></a><a id="sthref650"></a>SQL injection maliciously exploits applications that use client-supplied data in SQL statements, thereby gaining unauthorized access to a database to view or manipulate restricted data. This section describes SQL injection vulnerabilities in PL/SQL and explains how to guard against them.</p>
<p>To try the examples in this topic, connect to the <code dir="ltr">HR</code> schema and run the statements in <a href="#CHDBJCFF">Example 7-8</a>.</p>
<div id="LNPLS637" class="example">
<p class="titleinexample"><a id="CHDBJCFF"></a>Example 7-8 Setup for SQL Injection Examples</p>
<pre dir="ltr">
DROP TABLE secret_records;
CREATE TABLE secret_records (
  user_name    VARCHAR2(9),
  service_type VARCHAR2(12),
  value        VARCHAR2(30),
  date_created DATE
);

INSERT INTO secret_records (
  user_name, service_type, value, date_created
)
VALUES ('Andy', 'Waiter', 'Serve dinner at Cafe Pete', SYSDATE);
 
INSERT INTO secret_records (
  user_name, service_type, value, date_created
)
VALUES ('Chuck', 'Merger', 'Buy company XYZ', SYSDATE);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS530"></a>Topics</p>
<ul>
<li>
<p><a href="#BJEEBJAE">SQL Injection Techniques</a></p>
</li>
<li>
<p><a href="#BJECFFHD">Guarding Against SQL Injection</a></p>
</li>
</ul>
<a id="BJEEBJAE"></a>
<div id="LNPLS638" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQL Injection Techniques</h3>
<p>All SQL injection techniques exploit a single vulnerability: String input is not correctly validated and is concatenated into a dynamic SQL statement.</p>
<p class="subhead2"><a id="LNPLS538"></a>Topics</p>
<ul>
<li>
<p><a href="#BJEBCDDH">Statement Modification</a></p>
</li>
<li>
<p><a href="#BJEJJDEG">Statement Injection</a></p>
</li>
<li>
<p><a href="#CHDDEBCJ">Data Type Conversion</a></p>
</li>
</ul>
<a id="BJEBCDDH"></a>
<div id="LNPLS639" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement Modification</h4>
<p><a id="sthref651"></a><span class="bold">Statement modification</span> means deliberately altering a dynamic SQL statement so that it runs in a way unintended by the application developer. Typically, the user retrieves unauthorized data by changing the <code dir="ltr">WHERE</code> clause of a <code dir="ltr">SELECT</code> statement or by inserting a <code dir="ltr">UNION</code> <code dir="ltr">ALL</code> clause. The classic example of this technique is bypassing password authentication by making a <code dir="ltr">WHERE</code> clause always <code dir="ltr">TRUE</code>.</p>
<p><a href="#BJEJABIC">Example 7-9</a> creates a procedure that is vulnerable to statement modification and then invokes that procedure with and without statement modification. With statement modification, the procedure returns a supposedly secret record.</p>
<div id="LNPLS640" class="example">
<p class="titleinexample"><a id="BJEJABIC"></a>Example 7-9 Procedure Vulnerable to Statement Modification</p>
<p>Create vulnerable procedure:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE get_record (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2,
  rec          OUT VARCHAR2
)
IS
  query VARCHAR2(4000);
BEGIN
  <span class="bold">-- Following SELECT statement is vulnerable to modification</span>
  <span class="bold">-- because it uses concatenation to build WHERE clause.</span>
  query := 'SELECT value FROM secret_records WHERE user_name='''
           || user_name 
           || ''' AND service_type=''' 
           || service_type 
           || '''';
  DBMS_OUTPUT.PUT_LINE('Query: ' || query);
  EXECUTE IMMEDIATE query INTO rec ;
  DBMS_OUTPUT.PUT_LINE('Rec: ' || rec );
END;
/
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">
SET SERVEROUTPUT ON;

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record('Andy', 'Waiter', record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Query: SELECT value FROM secret_records WHERE user_name='Andy' AND
service_type='Waiter'
Rec: Serve dinner at Cafe Pete
 
</pre>
<p>Example of statement modification:</p>
<pre dir="ltr">
DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record(
  <span class="bold">'Anybody '' OR service_type=''Merger''--',</span>
  'Anything',
  record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Query: SELECT value FROM secret_records WHERE user_name='Anybody ' OR</span>
<span class="bold">service_type='Merger'--' AND service_type='Anything'</span>
<span class="bold">Rec: Buy company XYZ</span>

PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BJEJJDEG"></a>
<div id="LNPLS641" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Statement Injection</h4>
<p><a id="sthref652"></a><span class="bold">Statement injection</span> means that a user appends one or more SQL statements to a dynamic SQL statement. Anonymous PL/SQL blocks are vulnerable to this technique.</p>
<p><a href="#BJEHHAFF">Example 7-10</a> creates a procedure that is vulnerable to statement injection and then invokes that procedure with and without statement injection. With statement injection, the procedure deletes the supposedly secret record exposed in <a href="#BJEJABIC">Example 7-9</a>.</p>
<div id="LNPLS642" class="example">
<p class="titleinexample"><a id="BJEHHAFF"></a>Example 7-10 Procedure Vulnerable to Statement Injection</p>
<p>Create vulnerable procedure:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE p (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2
)
IS
  block1 VARCHAR2(4000);
BEGIN
  <span class="bold">-- Following block is vulnerable to statement injection</span>
  <span class="bold">-- because it is built by concatenation.</span>
  block1 :=
    'BEGIN
    DBMS_OUTPUT.PUT_LINE(''user_name: ' || user_name || ''');'
    || 'DBMS_OUTPUT.PUT_LINE(''service_type: ' || service_type || ''');
    END;';

  DBMS_OUTPUT.PUT_LINE('Block1: ' || block1);
  
  EXECUTE IMMEDIATE block1;
END;
/
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">
SET SERVEROUTPUT ON;

BEGIN
  p('Andy', 'Waiter');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Block1: BEGIN
         DBMS_OUTPUT.PUT_LINE('user_name: Andy');
         DBMS_OUTPUT.PUT_LINE('service_type: Waiter');
       END;
user_name: Andy
service_type: Waiter
</pre>
<p>SQL*Plus formatting command:</p>
<pre dir="ltr">
COLUMN date_created FORMAT A12;
</pre>
<p>Query:</p>
<pre dir="ltr">
<span class="bold">SELECT * FROM secret_records ORDER BY user_name;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">
USER_NAME SERVICE_TYPE VALUE                          DATE_CREATED
--------- ------------ ------------------------------ ------------
Andy      Waiter       Serve dinner at Cafe Pete      28-APR-10
Chuck     Merger       Buy company XYZ                28-APR-10
</pre>
<p>Example of statement modification:</p>
<pre dir="ltr">
BEGIN
  p('Anybody', <span class="bold">'Anything'');</span>
  <span class="bold">DELETE FROM secret_records WHERE service_type=INITCAP(''Merger'</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Block1: BEGIN
       DBMS_OUTPUT.PUT_LINE('user_name: Anybody');
       DBMS_OUTPUT.PUT_LINE('service_type: Anything<span class="bold">');</span>
       <span class="bold">DELETE FROM secret_records WHERE service_type=INITCAP('Merger'</span>);
     END;
user_name: Anybody
service_type: Anything

PL/SQL procedure successfully completed.
</pre>
<p>Query:</p>
<pre dir="ltr">
<span class="bold">SELECT * FROM secret_records;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">
USER_NAME SERVICE_TYPE VALUE                          DATE_CREATED
--------- ------------ ------------------------------ ------------
Andy      Waiter       Serve dinner at Cafe Pete      18-MAR-09
 
<span class="bold">1 row selected.</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDDEBCJ"></a>
<div id="LNPLS643" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Data Type Conversion</h4>
<p><a id="sthref653"></a>A less known SQL injection technique uses <a id="sthref654"></a>NLS session parameters to modify or inject SQL statements.</p>
<p>A datetime or numeric value that is concatenated into the text of a dynamic SQL statement must be converted to the <code dir="ltr">VARCHAR2</code> data type. The conversion can be either implicit (when the value is an operand of the concatentation operator) or explicit (when the value is the argument of the <code dir="ltr">TO_CHAR</code> function). This data type conversion depends on the NLS settings of the database session that runs the dynamic SQL statement. The conversion of datetime values uses format models specified in the parameters <code dir="ltr">NLS_DATE_FORMAT</code>, <code dir="ltr">NLS_TIMESTAMP_FORMAT</code>, or <code dir="ltr">NLS_TIMESTAMP_TZ_FORMAT</code>, depending on the particular datetime data type. The conversion of numeric values applies decimal and group separators specified in the parameter <code dir="ltr">NLS_NUMERIC_CHARACTERS</code>.</p>
<p>One datetime format model is <code dir="ltr">"</code><code dir="ltr"><span class="codeinlineitalic">text</span></code><code dir="ltr">"</code>. The <code dir="ltr"><span class="codeinlineitalic">text</span></code> is copied into the conversion result. For example, if the value of <code dir="ltr">NLS_DATE_FORMAT</code> is <code dir="ltr">'"Month:" Month'</code>, then in June, <code dir="ltr">TO_CHAR(SYSDATE)</code> returns <code dir="ltr">'Month: June'</code>. The datetime format model can be abused as shown in <a href="#CHDEIABG">Example 7-11</a>.</p>
<div id="LNPLS644" class="example">
<p class="titleinexample"><a id="CHDEIABG"></a>Example 7-11 Procedure Vulnerable to SQL Injection Through Data Type Conversion</p>
<pre dir="ltr">
SELECT * FROM secret_records;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
USER_NAME SERVICE_TYPE VALUE                          DATE_CREATE
--------- ------------ ------------------------------ -----------
Andy      Waiter       Serve dinner at Cafe Pete      28-APR-2010
Chuck     Merger       Buy company XYZ                28-APR-2010
</pre>
<p>Create vulnerable procedure:</p>
<pre dir="ltr">
-- Return records not older than a month

CREATE OR REPLACE PROCEDURE get_recent_record (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2,
  rec          OUT VARCHAR2
)
IS
  query VARCHAR2(4000);
BEGIN
  <span class="bold">/* Following SELECT statement is vulnerable to modification</span>
  <span class="bold">   because it uses concatenation to build WHERE clause</span>
  <span class="bold">   and because SYSDATE depends on the value of NLS_DATE_FORMAT. */</span>

  query := 'SELECT value FROM secret_records WHERE user_name='''
           || user_name
           || ''' AND service_type='''
           || service_type
           || ''' AND date_created&gt;'''
           || <span class="bold">(SYSDATE - 30)</span>
           || '''';

  DBMS_OUTPUT.PUT_LINE('Query: ' || query);
  EXECUTE IMMEDIATE query INTO rec;
  DBMS_OUTPUT.PUT_LINE('Rec: ' || rec);
END;
/
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">
SET SERVEROUTPUT ON;
<span class="bold">ALTER SESSION SET NLS_DATE_FORMAT='DD-MON-YYYY';</span>

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_recent_record('Andy', 'Waiter', record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Query: SELECT value FROM secret_records WHERE user_name='Andy' AND
service_type='Waiter' AND date_created&gt;'29-MAR-2010'
Rec: Serve dinner at Cafe Pete
  
</pre>
<p>Example of statement modification:</p>
<pre dir="ltr">
<span class="bold">ALTER SESSION SET NLS_DATE_FORMAT='"'' OR service_type=''Merger"';</span>

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_recent_record('Anybody', 'Anything', record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Query: SELECT value FROM secret_records WHERE user_name='Anybody' AND</span>
<span class="bold">service_type='Anything' AND date_created&gt;'' OR service_type='Merger'</span>
<span class="bold">Rec: Buy company XYZ</span>
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BJECFFHD"></a>
<div id="LNPLS645" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Guarding Against SQL Injection</h3>
<p>If you use dynamic SQL in your PL/SQL applications, you must check the input text to ensure that it is exactly what you expected. You can use the following techniques:</p>
<ul>
<li>
<p><a href="#BJEDAHEE">Bind Variables</a></p>
</li>
<li>
<p><a href="#BJEICDDJ">Validation Checks</a></p>
</li>
<li>
<p><a href="#CHDGICJH">Explicit Format Models</a></p>
</li>
</ul>
<a id="BJEDAHEE"></a>
<div id="LNPLS646" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Bind Variables</h4>
<p><a id="sthref655"></a>The most effective way to make your PL/SQL code invulnerable to SQL injection attacks is to use bind variables. The database uses the values of bind variables exclusively and does not interpret their contents in any way. (Bind variables also improve performance.)</p>
<p>The procedure in <a href="#BJEIJEBJ">Example 7-12</a> is invulnerable to SQL injection because it builds the dynamic SQL statement with bind variables (not by concatenation as in the vulnerable procedure in <a href="#BJEJABIC">Example 7-9</a>). The same binding technique fixes the vulnerable procedure shown in <a href="#BJEHHAFF">Example 7-10</a>.</p>
<div id="LNPLS647" class="example">
<p class="titleinexample"><a id="BJEIJEBJ"></a>Example 7-12 Bind Variables Guarding Against SQL Injection</p>
<p>Create invulnerable procedure:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE get_record_2 (
  user_name    IN  VARCHAR2,
  service_type IN  VARCHAR2,
  rec          OUT VARCHAR2
)
IS
  query VARCHAR2(4000);
BEGIN
  query := 'SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>';
 
  DBMS_OUTPUT.PUT_LINE('Query: ' || query);
 
  EXECUTE IMMEDIATE query INTO rec <span class="bold">USING user_name, service_type</span>;
 
  DBMS_OUTPUT.PUT_LINE('Rec: ' || rec);
END;
/
 
</pre>
<p>Demonstrate procedure without SQL injection:</p>
<pre dir="ltr">
SET SERVEROUTPUT ON;
DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record_2('Andy', 'Waiter', record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Query: SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>
Rec: Serve dinner at Cafe Pete
 
PL/SQL procedure successfully completed.
 
</pre>
<p>Attempt statement modification:</p>
<pre dir="ltr">
DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_record_2('Anybody '' OR service_type=''Merger''--',
               'Anything',
               record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Query: SELECT value FROM secret_records
            WHERE user_name=<span class="bold">:a</span>
            AND service_type=<span class="bold">:b</span>
DECLARE
*
<span class="bold">ERROR at line 1:</span>
<span class="bold">ORA-01403: no data found</span>
<span class="bold">ORA-06512: at "HR.GET_RECORD_2", line 14</span>
<span class="bold">ORA-06512: at line 4</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BJEICDDJ"></a>
<div id="LNPLS648" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Validation Checks</h4>
<p><a id="sthref656"></a>Always have your program validate user input to ensure that it is what is intended. For example, if the user is passing a department number for a <code dir="ltr">DELETE</code> statement, check the validity of this department number by selecting from the <code dir="ltr">departments</code> table. Similarly, if a user enters the name of a table to be deleted, check that this table exists by selecting from the static data dictionary view <code dir="ltr">ALL_TABLES</code>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
When checking the validity of a user name and its password, always return the same error regardless of which item is invalid. Otherwise, a malicious user who receives the error message "invalid password" but not "invalid user name" (or the reverse) can realize that he or she has guessed one of these correctly.</div>
<p>In validation-checking code, the subprograms in the <a id="sthref657"></a><code dir="ltr">DBMS_ASSERT</code> package are often useful. For example, you can use the <code dir="ltr">DBMS_ASSERT</code>.<code dir="ltr">ENQUOTE_LITERAL</code> function to enclose a string literal in quotation marks, as <a href="#CHDGJEGD">Example 7-13</a> does. This prevents a malicious user from injecting text between an opening quotation mark and its corresponding closing quotation mark.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Although the <code dir="ltr">DBMS_ASSERT</code> subprograms are useful in validation code, they do not replace it. For example, an input string can be a qualified SQL name (verified by <code dir="ltr">DBMS_ASSERT</code>.<code dir="ltr">QUALIFIED_SQL_NAME</code>) and still be a fraudulent password.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS231" href="../../appdev.112/e40758/d_assert.htm#ARPLS231"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about <code dir="ltr">DBMS_ASSERT</code> subprograms</div>
<p>In <a href="#CHDGJEGD">Example 7-13</a>, the procedure <code dir="ltr">raise_emp_salary</code> checks the validity of the column name that was passed to it before it updates the <code dir="ltr">employees</code> table, and then the anonymous block invokes the procedure from both a dynamic PL/SQL block and a dynamic SQL statement.</p>
<div id="LNPLS649" class="example">
<p class="titleinexample"><a id="CHDGJEGD"></a>Example 7-13 Validation Checks Guarding Against SQL Injection</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE raise_emp_salary (
  column_value  NUMBER,
  emp_column    VARCHAR2,
  amount NUMBER )
IS
  v_column  VARCHAR2(30);
  sql_stmt  VARCHAR2(200);
BEGIN
  <span class="bold">-- Check validity of column name that was given as input:</span>
  SELECT column_name INTO v_column
  FROM USER_TAB_COLS
  WHERE TABLE_NAME = 'EMPLOYEES'
  AND COLUMN_NAME = emp_column;

  sql_stmt := 'UPDATE employees SET salary = salary + :1 WHERE '
    || <span class="bold">DBMS_ASSERT.ENQUOTE_NAME(v_column,FALSE)</span> || ' = :2';

  EXECUTE IMMEDIATE sql_stmt USING amount, column_value;

  <span class="bold">-- If column name is valid:</span>
  IF SQL%ROWCOUNT &gt; 0 THEN
    DBMS_OUTPUT.PUT_LINE('Salaries were updated for: '
      || emp_column || ' = ' || column_value);
  END IF;

  <span class="bold">-- If column name is not valid:</span>
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      DBMS_OUTPUT.PUT_LINE ('Invalid Column: ' || emp_column);
END raise_emp_salary;
/

DECLARE
  plsql_block  VARCHAR2(500);
BEGIN
  <span class="bold">-- Invoke raise_emp_salary from a dynamic PL/SQL block:</span>
  plsql_block :=
    'BEGIN raise_emp_salary(:cvalue, :cname, :amt); END;';

  EXECUTE IMMEDIATE plsql_block
    USING 110, 'DEPARTMENT_ID', 10;

  <span class="bold">-- Invoke raise_emp_salary from a dynamic SQL statement:</span>
  EXECUTE IMMEDIATE 'BEGIN raise_emp_salary(:cvalue, :cname, :amt); END;'
    USING 112, 'EMPLOYEE_ID', 10;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Salaries were updated for: DEPARTMENT_ID = 110
Salaries were updated for: EMPLOYEE_ID = 112
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDGICJH"></a>
<div id="LNPLS650" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Explicit Format Models</h4>
<p><a id="sthref658"></a><a id="sthref659"></a>If you use datetime and numeric values that are concatenated into the text of a SQL or PL/SQL statement, and you cannot pass them as bind variables, convert them to text using explicit format models that are independent from the values of the NLS parameters of the running session. Ensure that the converted values have the format of SQL datetime or numeric literals. Using explicit locale-independent format models to construct SQL is recommended not only from a security perspective, but also to ensure that the dynamic SQL statement runs correctly in any globalization environment.</p>
<p>The procedure in <a href="#CHDFIIEF">Example 7-14</a> is invulnerable to SQL injection because it converts the datetime parameter value, <code dir="ltr">SYSDATE</code> <code dir="ltr">-</code> <code dir="ltr">30</code>, to a <code dir="ltr">VARCHAR2</code> value explicitly, using the <code dir="ltr">TO_CHAR</code> function and a locale-independent format model (not implicitly, as in the vulnerable procedure in <a href="#CHDEIABG">Example 7-11</a>).</p>
<div id="LNPLS651" class="example">
<p class="titleinexample"><a id="CHDFIIEF"></a>Example 7-14 Explicit Format Models Guarding Against SQL Injection</p>
<p>Create invulnerable procedure:</p>
<pre dir="ltr">
-- Return records not older than a month

CREATE OR REPLACE PROCEDURE get_recent_record (
  user_name     IN  VARCHAR2,
  service_type  IN  VARCHAR2,
  rec           OUT VARCHAR2
)
IS
  query VARCHAR2(4000);
BEGIN
  /* Following SELECT statement is vulnerable to modification
     because it uses concatenation to build WHERE clause. */

  query := 'SELECT value FROM secret_records WHERE user_name='''
           || user_name 
           || ''' AND service_type=''' 
           || service_type 
           || ''' AND date_created&gt; DATE ''' 
           || <span class="bold">TO_CHAR(SYSDATE - 30,'YYYY-MM-DD'</span>) 
           || '''';

  DBMS_OUTPUT.PUT_LINE('Query: ' || query);
  EXECUTE IMMEDIATE query INTO rec;
  DBMS_OUTPUT.PUT_LINE('Rec: ' || rec);
END;
/
</pre>
<p>Attempt statement modification:</p>
<pre dir="ltr">
<span class="bold">ALTER SESSION SET NLS_DATE_FORMAT='"'' OR service_type=''Merger"';</span> 

DECLARE
  record_value VARCHAR2(4000);
BEGIN
  get_recent_record('Anybody', 'Anything', record_value);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Query: SELECT value FROM secret_records WHERE user_name='Anybody' AND</span> 
<span class="bold">service_type='Anything' AND date_created&gt; DATE '2010-03-29'</span> 
<span class="bold">DECLARE</span> 
<span class="bold">*</span> 
<span class="bold">ERROR at line 1:</span> 
<span class="bold">ORA-01403: no data found</span> 
<span class="bold">ORA-06512: at "SYS.GET_RECENT_RECORD", line 21</span> 
<span class="bold">ORA-06512: at line 4</span> 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="static.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="subprograms.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
