<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Name Resolution</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:53:7Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="wrap.htm" title="Previous" type="text/html" />
<link rel="Next" href="limits.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">95/99</span> <!-- End Header -->
<div id="LNPLS017" class="appendix"><a id="CHDGABGF"></a>
<h1 class="appendix"><span class="secnum">B</span> PL/SQL Name Resolution</h1>
<p>This appendix explains PL/SQL <a id="sthref1432"></a><span class="bold">name resolution</span>; that is, how the PL/SQL compiler resolves <a id="sthref1433"></a>ambiguous references to identifiers.</p>
<p>An unambiguous identifier reference can become ambiguous if you change identifiers in its compilation unit (that is, if you add, rename, or delete identifiers).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">AUTHID</code> property of a stored PL/SQL unit affects the name resolution of SQL statements that the unit issues at run time. For more information, see <a href="subprograms.htm#i18574">"Invoker's Rights and Definer's Rights (AUTHID Property)"</a>.</div>
<p class="subhead2"><a id="LNPLS2037"></a>Topics</p>
<ul>
<li>
<p><a href="#i3257">Qualified Names and Dot Notation</a></p>
</li>
<li>
<p><a href="#BABCAECA">Column Name Precedence</a></p>
</li>
<li>
<p><a href="#BCFCFBDH">Differences Between PL/SQL and SQL Name Resolution Rules</a></p>
</li>
<li>
<p><a href="#BABDCBJD">Resolution of Names in Static SQL Statements</a></p>
</li>
<li>
<p><a href="#i3265">What is Capture?</a></p>
</li>
<li>
<p><a href="#i3239">Avoiding Inner Capture in SELECT and DML Statements</a></p>
</li>
</ul>
<a id="i3257"></a>
<div id="LNPLS01702" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Qualified Names and Dot Notation</h2>
<p>When one named item belongs to another named item, you can (and sometimes must) qualify the name of the "child" item with the name of the "parent" item, using <a id="sthref1434"></a>dot notation. For example:</p>
<div class="inftblinformal">
<table class="cellalignment1089" title="Identifiers That You Must Qualify" summary="This table lists the &quot;child&quot; identifiers that you must qualify, their &quot;parents,&quot; and the syntax of their qualified names." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t3">When referencing ...</th>
<th class="cellalignment1090" id="r1c2-t3">You must qualify its name with ...</th>
<th class="cellalignment1090" id="r1c3-t3">Using this syntax ...</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t3" headers="r1c1-t3">Field of a record</td>
<td class="cellalignment1091" headers="r2c1-t3 r1c2-t3">Name of the record</td>
<td class="cellalignment1091" headers="r2c1-t3 r1c3-t3"><code dir="ltr"><span class="codeinlineitalic">record_name.field_name</span></code></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t3" headers="r1c1-t3">Method of a collection</td>
<td class="cellalignment1091" headers="r3c1-t3 r1c2-t3">Name of the collection</td>
<td class="cellalignment1091" headers="r3c1-t3 r1c3-t3"><code dir="ltr"><span class="codeinlineitalic">collection_name.method</span></code></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t3" headers="r1c1-t3">Pseudocolumn <code dir="ltr">CURRVAL</code></td>
<td class="cellalignment1091" headers="r4c1-t3 r1c2-t3">Name of a sequence</td>
<td class="cellalignment1091" headers="r4c1-t3 r1c3-t3"><code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code><code dir="ltr">.CURRVAL</code></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t3" headers="r1c1-t3">Pseudocolumn <code dir="ltr">NEXTVAL</code></td>
<td class="cellalignment1091" headers="r5c1-t3 r1c2-t3">Name of a sequence</td>
<td class="cellalignment1091" headers="r5c1-t3 r1c3-t3"><code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code><code dir="ltr">.NEXTVAL</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>If an identifier is declared in a named PL/SQL unit, you can qualify its simple name (the name in its declaration) with the name of the unit (block, subprogram, or package), using this syntax:</p>
<pre dir="ltr">
<span class="italic">unit_name.simple_identifier_name</span>
</pre>
<p>If the identifier is not visible, then you <span class="italic">must</span> qualify its name (see <a href="fundamentals.htm#CIHBJJJJ">"Scope and Visibility of Identifiers"</a>).</p>
<p>If an identifier belongs to another schema, then you must qualify its name with the name of the schema, using this syntax:</p>
<pre dir="ltr">
<span class="italic">schema_name.package_name</span>
</pre>
<p>A simple name can be qualified with multiple names, as <a href="#CHDBCGDB">Example B-1</a> shows.</p>
<div id="LNPLS1751" class="example">
<p class="titleinexample"><a id="CHDBCGDB"></a>Example B-1 Qualified Names</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE pkg1 AS
  m NUMBER;
  TYPE t1 IS RECORD (a NUMBER);
  v1 t1;
  TYPE t2 IS TABLE OF t1 INDEX BY PLS_INTEGER;
  v2 t2; 
  FUNCTION f1 (p1 NUMBER) RETURN t1;
  FUNCTION f2 (q1 NUMBER) RETURN t2;
END pkg1;
/

CREATE OR REPLACE PACKAGE BODY pkg1 AS
  FUNCTION f1 (p1 NUMBER) RETURN t1 IS
    n NUMBER;
  BEGIN
     n := m;             -- Unqualified variable name
     n := <span class="bold">pkg1.m</span>;        -- Variable name qualified by package name
     n := <span class="bold">pkg1.f1.p1</span>;    -- Parameter name qualified by function name,
                         --  which is qualified by package name
     n := <span class="bold">v1.a</span>;          -- Variable name followed by component name
     n := <span class="bold">pkg1.v1.a</span>;     -- Variable name qualified by package name
                         --  and followed by component name
     n := <span class="bold">v2(10).a</span>;      -- Indexed name followed by component name
     n := <span class="bold">f1(10).a</span>;      -- Function invocation followed by component name
     n := <span class="bold">f2(10)(10).a</span>;  -- Function invocation followed by indexed name
                         --  and followed by component name
     n := <span class="bold">hr.pkg1.f2(10)(10).a</span>;  -- Schema name, package name,
                                 -- function invocation, index, component name
     v1.a := p1;
     RETURN v1;
   END f1;

   FUNCTION f2 (q1 NUMBER) RETURN t2 IS
     v_t1 t1;
     v_t2 t2;
   BEGIN
     v_t1.a := q1;
     v_t2(1) := v_t1;
     RETURN v_t2;
   END f2;
END pkg1;
/
</pre></div>
<!-- class="example" -->
<p>Some examples of possibly ambiguous qualified names are:</p>
<ul>
<li>
<p>Field or attribute of a function return value, for example:</p>
<pre dir="ltr">
<span class="italic">func_name</span>().<span class="italic">field_name</span>
<span class="italic">func_name</span>().<span class="italic">attribute_name</span>
</pre></li>
<li>
<p>Schema object owned by another schema, for example:</p>
<pre dir="ltr">
<span class="italic">schema_name.table_name</span>
<span class="italic">schema_name.procedure_name</span>()
<span class="italic">schema_name.type_name.member_name</span>()
</pre></li>
<li>
<p>Package object owned by another user, for example:</p>
<pre dir="ltr">
<span class="italic">schema_name.package_name.procedure_name</span>()
<span class="italic">schema_name.package_name.record_name.field_name</span>
</pre></li>
<li>
<p>Record containing an ADT, for example:</p>
<pre dir="ltr">
<span class="italic">record_name.field_name.attribute_name</span>
<span class="italic">record_name.field_name.member_name</span>()
</pre></li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BABCAECA"></a>
<div id="LNPLS2038" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Column Name Precedence</h2>
<p>If a SQL statement references a name that belongs to both a column and either a local variable or formal parameter, then the column name takes precedence.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
When a variable or parameter name is interpreted as a column name, data can be deleted, changed, or inserted unintentionally.</div>
<p>In <a href="#CBJCHFHC">Example B-2</a>, the name <code dir="ltr">last_name</code> belongs to both a local variable and a column (names are not case-sensitive). Therefore, in the <code dir="ltr">WHERE</code> clause, both references to <code dir="ltr">last_name</code> resolve to the column, and all rows are deleted.</p>
<div id="LNPLS233" class="example">
<p class="titleinexample"><a id="CBJCHFHC"></a>Example B-2 Variable Name Interpreted as Column Name Causes Unintended Result</p>
<pre dir="ltr">
DROP TABLE employees2;
CREATE TABLE employees2 AS
  SELECT <span class="bold">LAST_NAME</span> FROM employees;
 
DECLARE
  <span class="bold">last_name</span>  VARCHAR2(10) := 'King';
BEGIN
  DELETE FROM employees2 WHERE <span class="bold">LAST_NAME = last_name</span>;
  DBMS_OUTPUT.PUT_LINE('Deleted ' || SQL%ROWCOUNT || ' rows.');
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Deleted 107 rows.</span>
</pre></div>
<!-- class="example" -->
<p><a href="#BABJJEBG">Example B-3</a> solves the problem in <a href="#CBJCHFHC">Example B-2</a> by giving the variable a different name.</p>
<div id="LNPLS2039" class="example">
<p class="titleinexample"><a id="BABJJEBG"></a>Example B-3 Fixing <a href="#CBJCHFHC">Example B-2</a> with Different Variable Name</p>
<pre dir="ltr">
DECLARE
  v_last_name  VARCHAR2(10) := 'King';
BEGIN
  DELETE FROM employees2 WHERE <span class="bold">LAST_NAME = v_last_name</span>;
  DBMS_OUTPUT.PUT_LINE('Deleted ' || SQL%ROWCOUNT || ' rows.');
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Deleted 2 rows.</span>
</pre></div>
<!-- class="example" -->
<p><a href="#BABGGJJG">Example B-4</a> solves the problem in <a href="#CBJCHFHC">Example B-2</a> by labeling the block and qualifying the variable name with the block name.</p>
<div id="LNPLS2040" class="example">
<p class="titleinexample"><a id="BABGGJJG"></a>Example B-4 Fixing <a href="#CBJCHFHC">Example B-2</a> with Block Label</p>
<pre dir="ltr">
<span class="bold">&lt;&lt;main&gt;&gt;</span>
DECLARE
  last_name  VARCHAR2(10) := 'King';
BEGIN
  DELETE FROM employees2 WHERE <span class="bold">last_name = main.last_name</span>;
  DBMS_OUTPUT.PUT_LINE('Deleted ' || SQL%ROWCOUNT || ' rows.');
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Deleted 2 rows.</span>
</pre></div>
<!-- class="example" -->
<p>In <a href="#BEIFDBJD">Example B-5</a>, the the function <code dir="ltr">dept_name</code> has a formal parameter and a local variable whose names are those of columns of the table <code dir="ltr">DEPARTMENTS</code>. The parameter and variable name are qualified with the function name to distinguish them from the column names.</p>
<div id="LNPLS234" class="example">
<p class="titleinexample"><a id="BEIFDBJD"></a>Example B-5 Subprogram Name for Name Resolution</p>
<pre dir="ltr">
DECLARE
  FUNCTION <span class="bold">dept_name</span> (<span class="bold">department_id</span> IN NUMBER)
    RETURN departments.department_name%TYPE
  IS
    <span class="bold">department_name</span>  departments.department_name%TYPE;
  BEGIN
    SELECT <span class="bold">department_name</span> INTO <span class="bold">dept_name.department_name</span>
      --   <span class="bold">^column</span>              <span class="bold">^local variable</span>
    FROM departments
    WHERE <span class="bold">department_id</span> = <span class="bold">dept_name.department_id</span>;
    --    <span class="bold">^column</span>         <span class="bold">^formal parameter</span>
    RETURN department_name;
  END dept_name;
BEGIN
  FOR item IN (
    SELECT department_id
    FROM departments
    ORDER BY department_name) LOOP
 
      DBMS_OUTPUT.PUT_LINE ('Department: ' || dept_name(item.department_id));
  END LOOP;
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
Department: Accounting
Department: Administration
Department: Benefits
Department: Construction
Department: Contracting
Department: Control And Credit
Department: Corporate Tax
Department: Executive
Department: Finance
Department: Government Sales
Department: Human Resources
Department: IT
Department: IT Helpdesk
Department: IT Support
Department: Manufacturing
Department: Marketing
Department: NOC
Department: Operations
Department: Payroll
Department: Public Relations
Department: Purchasing
Department: Recruiting
Department: Retail Sales
Department: Sales
Department: Shareholder Services
Department: Shipping
Department: Treasury
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="BCFCFBDH"></a>
<div id="LNPLS01703" class="sect1">
<h2 class="sect1">Differences Between PL/SQL and SQL Name Resolution Rules</h2>
<p><a id="sthref1435"></a>PL/SQL and SQL name resolution rules are very similar. However:</p>
<ul>
<li>
<p>PL/SQL rules are less permissive than SQL rules.</p>
<p>Because most SQL rules are context-sensitive, they recognize as legal more situations than PL/SQL rules do.</p>
</li>
<li>
<p>PL/SQL and SQL resolve qualified names differently.</p>
<p>For example, when resolving the table name <code dir="ltr">HR</code>.<code dir="ltr">JOBS</code>:</p>
<ul>
<li>
<p>PL/SQL searches first for packages, types, tables, and views named <code dir="ltr">HR</code> in the current schema, then for public synonyms, and finally for objects named <code dir="ltr">JOBS</code> in the <code dir="ltr">HR</code> schema.</p>
</li>
<li>
<p>SQL searches first for objects named <code dir="ltr">JOBS</code> in the <code dir="ltr">HR</code> schema, and then for packages, types, tables, and views named <code dir="ltr">HR</code> in the current schema.</p>
</li>
</ul>
</li>
</ul>
<p>To avoid problems caused by the few differences between PL/SQL and SQL name resolution rules, follow the recommendations in <a href="#i3239">"Avoiding Inner Capture in SELECT and DML Statements"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the PL/SQL compiler processes a static SQL statement, it sends that statement to the SQL subsystem, which uses SQL rules to resolve names in the statement. For details, see <a href="#BABDCBJD">"Resolution of Names in Static SQL Statements"</a>.</div>
</div>
<!-- class="sect1" -->
<a id="BABDCBJD"></a>
<div id="LNPLS99882" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Resolution of Names in Static SQL Statements</h2>
<p>Static SQL is described in <a href="static.htm#BABGEDAE">Chapter 6, "PL/SQL Static SQL"</a>.</p>
<p><a id="sthref1436"></a><a id="sthref1437"></a>When the PL/SQL compiler finds a static SQL statement:</p>
<ol>
<li id="BABBAFCJ">
<p>If the statement is a <code dir="ltr">SELECT</code> statement, the PL/SQL compiler removes the <code dir="ltr">INTO</code> clause.</p>
</li>
<li>
<p>The PL/SQL compiler sends the statement to the SQL subsystem.</p>
</li>
<li>
<p>The SQL subsystem checks the syntax of the statement.</p>
<p>If the syntax is incorrect, the compilation of the PL/SQL unit fails. If the syntax is correct, the SQL subsystem determines the names of the tables and tries to resolve the other names in the scope of the SQL statement.</p>
</li>
<li id="BABIBAGB">
<p>If the SQL subsystem cannot resolve a name in the scope of the SQL statement, then it sends the name back to the PL/SQL compiler. The name is called an <a id="sthref1438"></a><a id="sthref1439"></a><span class="bold">escaped identifier</span>.</p>
</li>
<li>
<p>The PL/SQL compiler tries to resolve the escaped identifier.</p>
<p>First, the compiler tries to resolve the identifier in the scope of the PL/SQL unit. If that fails, the compiler tries to resolve the identifier in the scope of the schema. If that fails, the compilation of the PL/SQL unit fails.</p>
</li>
<li>
<p>If the compilation of the PL/SQL unit succeeds, the PL/SQL compiler generates the text of the regular SQL statement that is equivalent to the static SQL statement and stores that text with the generated computer code.</p>
</li>
<li>
<p>At run time, the PL/SQL runtime system invokes routines that parse, bind, and run the regular SQL statement.</p>
<p>The bind variables are the escaped identifiers (see step&nbsp;<a href="#BABIBAGB">4</a>).</p>
</li>
<li>
<p>If the statement is a <code dir="ltr">SELECT</code> statement, the PL/SQL runtime system stores the results in the PL/SQL targets specified in the <code dir="ltr">INTO</code> clause that the PL/SQL compiler removed in step&nbsp;<a href="#BABBAFCJ">1</a>.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i3265"></a>
<div id="LNPLS01704" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">What is Capture?</h2>
<p><a id="sthref1440"></a>When a declaration or definition prevents the compiler from correctly resolving a reference in another scope, the declaration or definition is said to <span class="bold">capture</span> the reference. Capture is usually the result of migration or schema evolution.</p>
<p class="subhead2"><a id="LNPLS2041"></a>Topics</p>
<ul>
<li>
<p><a href="#CBBFJIED">Outer Capture</a></p>
</li>
<li>
<p><a href="#CBBIHAEB">Same-Scope Capture</a></p>
</li>
<li>
<p><a href="#CBBDAHHA">Inner Capture</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Same-scope and inner capture occur only in SQL scope.</div>
<a id="CBBFJIED"></a>
<div id="LNPLS1754" class="sect2">
<h3 class="sect2">Outer Capture</h3>
<p><a id="sthref1441"></a><span class="bold">Outer capture</span> occurs when a name in an inner scope, which had resolved to an item in an inner scope, now resolves to an item in an outer scope. Both PL/SQL and SQL are designed to prevent outer capture; you need not be careful to avoid it.</p>
</div>
<!-- class="sect2" -->
<a id="CBBIHAEB"></a>
<div id="LNPLS1753" class="sect2">
<h3 class="sect2">Same-Scope Capture</h3>
<p><a id="sthref1442"></a><span class="bold">Same-scope capture</span> occurs when a column is added to one of two tables used in a join, and the new column has the same name as a column in the other table. When only one table had a column with that name, the name could appear in the join unqualified. Now, to avoid same-scope capture, you must qualify the column name with the appropriate table name, everywhere that the column name appears in the join.</p>
</div>
<!-- class="sect2" -->
<a id="CBBDAHHA"></a>
<div id="LNPLS1752" class="sect2">
<h3 class="sect2">Inner Capture</h3>
<p><a id="sthref1443"></a><span class="bold">Inner capture</span> occurs when a name in an inner scope, which had resolved to an item in an outer scope, now either resolves to an item in an inner scope or cannot be resolved. In the first case, the result might change. In the second case, an error occurs.</p>
<p>In <a href="#BABGHDAJ">Example B-6</a>, a new column captures a reference to an old column with the same name. Before new column <code dir="ltr">col2</code> is added to table <code dir="ltr">tab2</code>, <code dir="ltr">col2</code> resolves to <code dir="ltr">tab1.col2</code>; afterward, it resolves to <code dir="ltr">tab2.col2</code>.</p>
<div id="LNPLS2042" class="example">
<p class="titleinexample"><a id="BABGHDAJ"></a>Example B-6 Inner Capture of Column Reference</p>
<p>Table <code dir="ltr">tab1</code> has a column named <code dir="ltr">col2</code>, but table <code dir="ltr">tab2</code> does not:</p>
<pre dir="ltr">
DROP TABLE tab1;
CREATE TABLE <span class="bold">tab1</span> (col1 NUMBER, <span class="bold">col2</span> NUMBER);
INSERT INTO tab1 (col1, col2) VALUES (100, 10);

DROP TABLE tab2;
CREATE TABLE <span class="bold">tab2</span> (col1 NUMBER);
INSERT INTO tab2 (col1) VALUES (100);
</pre>
<p>Therefore, in the inner <code dir="ltr">SELECT</code> statement, the reference to <code dir="ltr">col2</code> resolves to column <code dir="ltr">tab1.col2</code>:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE proc AS
  CURSOR c1 IS
    SELECT * FROM tab1
    WHERE EXISTS (<span class="bold">SELECT * FROM tab2 WHERE col2 = 10</span>);
BEGIN
  OPEN c1;
  CLOSE c1;
END;
/
</pre>
<p>Add a column named <code dir="ltr">col2</code> to table <code dir="ltr">tab2</code>:</p>
<pre dir="ltr">
ALTER TABLE tab2 ADD (col2 NUMBER);
</pre>
<p>Now procedure <code dir="ltr">proc</code> is invalid. At its next invocation, the database automatically recompiles it, and the reference to <code dir="ltr">col2</code> in the inner <code dir="ltr">SELECT</code> statement resolves to column <code dir="ltr">tab2.col2</code>.</p>
</div>
<!-- class="example" -->
<p>To avoid inner capture, follow the rules in <a href="#i3239">"Avoiding Inner Capture in SELECT and DML Statements"</a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i3239"></a>
<div id="LNPLS01705" class="sect1">
<h2 class="sect1">Avoiding Inner Capture in SELECT and DML Statements</h2>
<p>Avoid <a id="sthref1444"></a>inner capture of references in <code dir="ltr">SELECT</code>, <a id="sthref1445"></a><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code>, and <a id="sthref1446"></a>DML statements by following these recommendations:</p>
<ul>
<li>
<p>Specify a unique <a id="sthref1447"></a><a id="sthref1448"></a>alias for each table in the statement.</p>
</li>
<li>
<p>Do not specify a table alias that is the name of a schema that owns an item referenced in the statement.</p>
</li>
<li>
<p>Qualify each column reference in the statement with the appropriate table alias.</p>
</li>
</ul>
<p>In <a href="#BABGIFBD">Example B-7</a>, schema <code dir="ltr">hr</code> owns tables <code dir="ltr">tab1</code> and <code dir="ltr">tab2</code>. Table <code dir="ltr">tab1</code> has a column named <code dir="ltr">tab2</code>, whose Abstract Data Type (ADT) has attribute <code dir="ltr">a</code>. Table <code dir="ltr">tab2</code> does not have a column named <code dir="ltr">a</code>. Against recommendation, the query specifies alias <code dir="ltr">hr</code> for table <code dir="ltr">tab1</code> and references table <code dir="ltr">tab2</code>. Therefore, in the query, the reference <code dir="ltr">hr.tab2.a</code> resolves to table <code dir="ltr">tab1</code>, column <code dir="ltr">tab2</code>, attribute <code dir="ltr">a</code>. Then the example adds column <code dir="ltr">a</code> to table <code dir="ltr">tab2</code>. Now the reference <code dir="ltr">hr.tab2.a</code> in the query resolves to schema <code dir="ltr">hr</code>, table <code dir="ltr">tab2</code>, column <code dir="ltr">a</code>. Column <code dir="ltr">a</code> of table <code dir="ltr">tab2</code> captures the reference to attribute <code dir="ltr">a</code> in column <code dir="ltr">tab2</code> of table <code dir="ltr">tab1</code>.</p>
<div id="LNPLS2043" class="example">
<p class="titleinexample"><a id="BABGIFBD"></a>Example B-7 Inner Capture of Attribute Reference</p>
<pre dir="ltr">
CREATE OR REPLACE <span class="bold">TYPE type1</span> AS OBJECT (<span class="bold">a</span> NUMBER);
/
DROP TABLE tab1;
CREATE <span class="bold">TABLE tab1 (tab2 type1)</span>;
INSERT INTO tab1 (tab2) VALUES (type1(10));

DROP TABLE tab2;
CREATE <span class="bold">TABLE tab2 (x NUMBER)</span>;
INSERT INTO tab2 (x) VALUES (10);

<span class="bold">/* Alias tab1 with same name as schema name,</span>
   <span class="bold">a bad practice used here for illustration purpose.</span>
   <span class="bold">Note lack of alias in second SELECT statement. */</span>

SELECT * FROM tab1 <span class="bold">hr</span>
WHERE EXISTS (SELECT * FROM <span class="bold">hr.tab2</span> WHERE x = <span class="bold">hr.tab2.a</span>);
</pre>
<p>Result:</p>
<pre dir="ltr">
TAB2(A)
---------------
 
TYPE1(10)
 
1 row selected.
</pre>
<p>Add a column named <code dir="ltr">a</code> to table <code dir="ltr">tab2</code> (which belongs to schema <code dir="ltr">hr</code>):</p>
<pre dir="ltr">
ALTER TABLE tab2 ADD (a NUMBER);
</pre>
<p>Now, when the query runs, <code dir="ltr">hr.tab2.a</code> resolves to schema <code dir="ltr">hr</code>, table <code dir="ltr">tab2</code>, column <code dir="ltr">a</code>. To avoid this inner capture, apply the recommendations to the query:</p>
<pre dir="ltr">
SELECT * FROM <span class="bold">hr.</span>tab1 <span class="bold">p1</span>
WHERE EXISTS (SELECT * FROM hr.tab2 <span class="bold">p2</span> WHERE <span class="bold">p2.</span>x = <span class="bold">p1.</span>tab2.a);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS2044"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABHBHJF">Qualifying References to Attributes and Methods</a></p>
</li>
<li>
<p><a href="#BABGDEFH">Qualifying References to Row Expressions</a></p>
</li>
</ul>
<a id="BABHBHJF"></a>
<div id="LNPLS1755" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Qualifying References to Attributes and Methods</h3>
<p>To reference an attribute or method of a table element, you must give the table an <a id="sthref1449"></a><a id="sthref1450"></a>alias and use the alias to qualify the reference to the attribute or method.</p>
<p>In <a href="#BABFBEBJ">Example B-8</a>, table <code dir="ltr">tbl1</code> has column <code dir="ltr">col1</code> of data type <code dir="ltr">t1</code>, an ADT with attribute <code dir="ltr">x</code>. The example shows several correct and incorrect references to <code dir="ltr">tbl1.col1.x</code>.</p>
<div id="LNPLS2045" class="example">
<p class="titleinexample"><a id="BABFBEBJ"></a>Example B-8 Qualifying ADT Attribute References</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE t1 AS OBJECT (x NUMBER);
/
DROP TABLE tb1;
CREATE TABLE tb1 (col1 t1); 
</pre>
<p>The references in the following <code dir="ltr">INSERT</code> statements do not need aliases, because they have no column lists:</p>
<pre dir="ltr">
BEGIN
  INSERT INTO tb1 VALUES ( t1(10) );
  INSERT INTO tb1 VALUES ( t1(20) );
  INSERT INTO tb1 VALUES ( t1(30) );
END;
/
</pre>
<p>The following references to the attribute <code dir="ltr">x</code> cause error ORA-00904:</p>
<pre dir="ltr">
UPDATE tb1 SET <span class="bold">col1.x</span> = 10 WHERE <span class="bold">col1.x</span> = 20;

UPDATE tb1 SET <span class="bold">tb1.col1.x</span> = 10 WHERE <span class="bold">tb1.col1.x</span> = 20;

UPDATE hr.tb1 SET <span class="bold">hr.tb1.col1.x</span> = 10 WHERE <span class="bold">hr.tb1.col1.x</span> = 20;

DELETE FROM tb1 WHERE <span class="bold">tb1.col1.x</span> = 10;
</pre>
<p>The following references to the attribute <code dir="ltr">x</code>, with table aliases, are correct:</p>
<pre dir="ltr">
UPDATE hr.tb1 <span class="bold">t</span> SET <span class="bold">t.col1.x</span> = 10 WHERE <span class="bold">t.col1.x</span> = 20;

DECLARE
  y NUMBER;
BEGIN
  SELECT <span class="bold">t.col1.x</span> INTO y FROM tb1 <span class="bold">t</span> WHERE <span class="bold">t.col1.x</span> = 30;
END;
/

DELETE FROM tb1 <span class="bold">t</span> WHERE <span class="bold">t.col1.x</span> = 10;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABGDEFH"></a>
<div id="LNPLS1756" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Qualifying References to Row Expressions</h3>
<p>Row expressions must resolve as references to <a id="sthref1451"></a><a id="sthref1452"></a>table aliases. A row expression can appear in the <code dir="ltr">SET</code> clause of an <code dir="ltr">UPDATE</code> statement or be the parameter of the SQL function <code dir="ltr">REF</code> or <code dir="ltr">VALUE</code>.</p>
<p>In <a href="#BABICCCJ">Example B-9</a>, table <code dir="ltr">ot1</code> is a standalone nested table of elements of data type <code dir="ltr">t1</code>, an ADT with attribute <code dir="ltr">x</code>. The example shows several correct and incorrect references to row expressions.</p>
<div id="LNPLS2046" class="example">
<p class="titleinexample"><a id="BABICCCJ"></a>Example B-9 Qualifying References to Row Expressions</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE t1 AS OBJECT (x number);
/
DROP TABLE ot1;
CREATE TABLE ot1 OF t1;

BEGIN
  INSERT INTO ot1 VALUES (t1(10));
  INSERT INTO ot1 VALUES (20);
  INSERT INTO ot1 VALUES (30);
END;
/
</pre>
<p>The following references cause error ORA-00904:</p>
<pre dir="ltr">
UPDATE ot1 SET VALUE(<span class="bold">ot1.x</span>) = t1(20) WHERE VALUE(<span class="bold">ot1.x</span>) = t1(10);

DELETE FROM ot1 WHERE VALUE(<span class="bold">ot1</span>) = (t1(10));
</pre>
<p>The following references, with table aliases, are correct:</p>
<pre dir="ltr">
UPDATE ot1 <span class="bold">o</span> SET <span class="bold">o</span> = (t1(20)) WHERE <span class="bold">o.x</span> = 10;

DECLARE
  n_ref  REF t1;
BEGIN
  SELECT REF(<span class="bold">o</span>) INTO n_ref FROM ot1 <span class="bold">o</span> WHERE VALUE(<span class="bold">o</span>) = t1(30);
END;
/

DECLARE
  n t1;
BEGIN
  SELECT VALUE(<span class="bold">o</span>) INTO n FROM ot1 <span class="bold">o</span> WHERE VALUE(<span class="bold">o</span>) = t1(30);
END;
/

DECLARE
  n NUMBER;
BEGIN
  SELECT <span class="bold">o.x</span> INTO n FROM ot1 <span class="bold">o</span> WHERE <span class="bold">o.x</span> = 30;
END;
/

DELETE FROM ot1 <span class="bold">o</span> WHERE VALUE(<span class="bold">o</span>) = (t1(20));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="appendix" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="wrap.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="limits.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
