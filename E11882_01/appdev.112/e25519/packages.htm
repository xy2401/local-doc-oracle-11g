<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Packages</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:52:57Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="triggers.htm" title="Previous" type="text/html" />
<link rel="Next" href="errors.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">17/99</span> <!-- End Header -->
<div id="LNPLS009" class="chapter"><a id="CIHIJECJ"></a>
<h1 class="chapter"><span class="secnum">10</span> PL/SQL Packages</h1>
<p>This chapter explains how to bundle related PL/SQL code and data into a package, whose contents are available to many applications.</p>
<p class="subhead2"><a id="LNPLS734"></a>Topics</p>
<ul>
<li>
<p><a href="#i2404">What is a Package?</a></p>
</li>
<li>
<p><a href="#i2408">Reasons to Use Packages</a></p>
</li>
<li>
<p><a href="#i2412">Package Specification</a></p>
</li>
<li>
<p><a href="#i2416">Package Body</a></p>
</li>
<li>
<p><a href="#BABEBHEG">Package Instantiation and Initialization</a></p>
</li>
<li>
<p><a href="#CJADDABG">Package State</a></p>
</li>
<li>
<p><a href="#CJABACHJ">SERIALLY_REUSABLE Packages</a></p>
</li>
<li>
<p><a href="#i7562">Package Writing Guidelines</a></p>
</li>
<li>
<p><a href="#i4362">Package Example</a></p>
</li>
<li>
<p><a href="#i6060">How STANDARD Package Defines the PL/SQL Environment</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the many <a id="sthref838"></a><a id="sthref839"></a>product-specific packages that <a id="sthref840"></a>Oracle Database supplies</p>
</li>
<li>
<p><a href="drop_package.htm#CJAEAEIA">"DROP PACKAGE Statement"</a>, which drops a stored package from the database</p>
</li>
</ul>
</div>
<a id="i2404"></a>
<div id="LNPLS00901" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">What is a Package?</h2>
<p>A <a id="sthref841"></a><span class="bold">package</span> is a schema object that groups logically related PL/SQL types, variables, constants, subprograms, cursors, and exceptions. A package is compiled and stored in the database, where many applications can share its contents. You can think of a package as an <a id="sthref842"></a>application.</p>
<p>A package always has a <a id="sthref843"></a><span class="bold">specification</span>, which declares the <span class="bold">public items</span> that can be referenced from outside the package. You can think of the package specification as the application programming interface (API). For more information about the package specification, see <a href="#i2412">"Package Specification"</a>.</p>
<p>If the public items include cursors or subprograms, then the package must also have a <a id="sthref844"></a><span class="bold">body</span>. The body must define queries for public cursors and code for public subprograms. The body can also declare and define <span class="bold">private items</span> that cannot be referenced from outside the package, but are necessary for the internal workings of the package. Finally, the body can have an <span class="bold">initialization part</span>, whose statements initialize variables and do other one-time setup steps, and an exception-handling part. You can change the body without changing the specification or the references to the public items; therefore, you can think of the package body as a black box. For more information about the package body, see <a href="#i2416">"Package Body"</a>.</p>
<p>In either the package specification or package body, you can map a package subprogram to an external Java or C subprogram by using a <a id="sthref845"></a><span class="bold">call specification</span>, which maps the external subprogram name, parameter types, and return type to their SQL counterparts. For details, see <a href="function.htm#i34368">"Function Declaration and Definition"</a> and <a href="procedure.htm#i35564">"Procedure Declaration and Definition"</a>.</p>
<p>The <code dir="ltr"><span class="codeinlinebold">AUTHID</span></code> <span class="bold">clause</span> of the package specification determines whether the subprograms and cursors in the package run with the privileges of their definer (the default) or invoker, and whether their unqualified references to schema objects are resolved in the schema of the definer or invoker. For more information, see <a href="subprograms.htm#i18574">"Invoker's Rights and Definer's Rights (AUTHID Property)"</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i2408"></a>
<div id="LNPLS00902" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Reasons to Use Packages</h2>
<p><a id="sthref846"></a>Packages support the development and maintenance of reliable, reusable code with the following <a id="sthref847"></a>features:</p>
<ul>
<li>
<p><span class="bold">Modularity</span></p>
<p>Packages let you encapsulate logically related types, variables, constants, subprograms, cursors, and exceptions in named PL/SQL modules. You can make each package easy to understand, and make the interfaces between packages simple, clear, and well defined. This practice aids application development.</p>
</li>
<li>
<p><span class="bold">Easier Application Design</span></p>
<p>When designing an application, all you need initially is the interface information in the package specifications. You can code and compile specifications without their bodies. Next, you can compile standalone subprograms that reference the packages. You need not fully define the package bodies until you are ready to complete the application.</p>
</li>
<li>
<p><span class="bold">Information Hiding</span></p>
<p>Packages let you share your interface information in the package specification, and hide the implementation details in the package body. Hiding the implementation details in the body has these advantages:</p>
<ul>
<li>
<p>You can change the implementation details without affecting the application interface.</p>
</li>
<li>
<p>Application users cannot develop code that depends on implementation details that you might want to change.</p>
</li>
</ul>
</li>
<li>
<p><span class="bold">Added Functionality</span></p>
<p>Package public variables and cursors can persist for the life of a session. They can be shared by all subprograms that run in the environment. They let you maintain data across transactions without storing it in the database. (For the situations in which package public variables and cursors do not persist for the life of a session, see <a href="#CJADDABG">"Package State"</a>.)</p>
</li>
<li>
<p><span class="bold">Better Performance</span></p>
<p>The first time you invoke a package subprogram, Oracle Database loads the whole package into memory. Subsequent invocations of other subprograms in same the package require no disk I/O.</p>
<p>Packages prevent cascading dependencies and unnecessary recompiling. For example, if you change the body of a package function, Oracle Database does not recompile other subprograms that invoke the function, because these subprograms depend only on the parameters and return value that are declared in the specification.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot reference <a id="sthref848"></a><a id="sthref849"></a>host variables from inside a package.</div>
</div>
<!-- class="sect1" -->
<a id="i2412"></a>
<div id="LNPLS00904" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Package Specification</h2>
<p>A <span class="bold">package specification</span> declares <a id="sthref850"></a><span class="bold">public items</span>. The <a id="sthref851"></a>scope of a public item is the schema of the package. A public item is <a id="sthref852"></a>visible everywhere in the schema. To <a id="sthref853"></a>reference a public item that is in scope but not visible, qualify it with the package name. (For information about scope, visibility, and qualification, see <a href="fundamentals.htm#CIHBJJJJ">"Scope and Visibility of Identifiers"</a>.)</p>
<p>Each public item declaration has all information that you need to use the item. For example, suppose that a package specification declares the function <code dir="ltr">factorial</code> this way:</p>
<pre dir="ltr">
FUNCTION factorial (n INTEGER) RETURN INTEGER; -- returns n!
</pre>
<p>The declaration shows that <code dir="ltr">factorial</code> needs one argument of type <code dir="ltr">INTEGER</code> and returns a value of type <code dir="ltr">INTEGER</code>, which is all you must know to invoke <code dir="ltr">factorial</code>. You need not know how <code dir="ltr">factorial</code> is implemented (for example, whether it is iterative or recursive).</p>
<p class="subhead2"><a id="LNPLS735"></a>Topics</p>
<ul>
<li>
<p><a href="#CHDHABBD">Appropriate Public Items</a></p>
</li>
<li>
<p><a href="#BABHEFHD">Creating Package Specifications</a></p>
</li>
</ul>
<a id="CHDHABBD"></a>
<div id="LNPLS00911" class="sect2">
<h3 class="sect2">Appropriate Public Items</h3>
<p><a id="sthref854"></a>Appropriate public items are:</p>
<ul>
<li>
<p>Types, variables, constants, subprograms, cursors, and exceptions used by multiple subprograms</p>
<p>A type defined in a package specification is either a PL/SQL user-defined subtype (described in <a href="datatypes.htm#CHDEAFDJ">"User-Defined PL/SQL Subtypes"</a>) or a PL/SQL composite type (described in <a href="composites.htm#CIHIEBJC">Chapter 5, "PL/SQL Collections and Records"</a>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A PL/SQL composite type defined in a package specification is incompatible with an identically defined local or standalone type (see <a href="composites.htm#CHDIHDIJ">Example 5-31</a>, <a href="composites.htm#CIHBGBBH">Example 5-32</a>, and <a href="composites.htm#CIHFBIAF">Example 5-37</a>).</div>
</li>
<li>
<p>Associative array types of standalone subprogram parameters</p>
<p>You cannot declare an associative array type at schema level. Therefore, to pass an associative array variable as a parameter to a standalone subprogram, you must declare the type of that variable in a package specification. Doing so makes the type available to both the invoked subprogram (which declares a formal parameter of that type) and to the invoking subprogram or anonymous block ( which declares a variable of that type). See <a href="#BABDFGED">Example 10-2</a>.</p>
</li>
<li>
<p>Variables that must remain available between subprogram invocations in the same session</p>
</li>
<li>
<p>Subprograms that read and write public variables ("get" and "set" subprograms)</p>
<p>Provide these subprograms to discourage package users from reading and writing public variables directly.</p>
</li>
<li>
<p>Subprograms that invoke each other</p>
<p>You need not worry about compilation order for package subprograms, as you must for standalone subprograms that invoke each other.</p>
</li>
<li>
<p>Overloaded subprograms</p>
<p>Overloaded subprograms are variations of the same subprogram. That is, they have the same name but different formal parameters. For more information about them, see <a href="subprograms.htm#i12352">"Overloaded Subprograms"</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot reference <a id="sthref855"></a><a id="sthref856"></a>remote package public variables<a id="sthref857"></a>, even indirectly. For example, if a subprogram refers to a package public variable, you cannot invoke the subprogram through a database link.</div>
</div>
<!-- class="sect2" -->
<a id="BABHEFHD"></a>
<div id="LNPLS99922" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating Package Specifications</h3>
<p>To create a package specification, use the <a href="create_package.htm#i2091914">"CREATE PACKAGE Statement"</a>.</p>
<p>In <a href="#CIHEJJHJ">Example 10-1</a>, the specification for the package <code dir="ltr">trans_data</code> declares two public types and three public variables.</p>
<div id="LNPLS813" class="example">
<p class="titleinexample"><a id="CIHEJJHJ"></a>Example 10-1 Simple Package Specification</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE trans_data AS
  TYPE TimeRec IS RECORD (
    minutes SMALLINT,
    hours   SMALLINT);
  TYPE TransRec IS RECORD (
    category VARCHAR2(10),
    account  INT,
    amount   REAL,
    time_of  TimeRec);
  minimum_balance     CONSTANT REAL := 10.00;
  number_processed    INT;
  insufficient_funds  EXCEPTION;
END trans_data;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABDFGED">Example 10-2</a>, the specification for the package <code dir="ltr">aa_pkg</code> declares an associative array type, <code dir="ltr">aa_type</code>. Then, the standalone procedure <code dir="ltr">print_aa</code> declares a formal parameter of type <code dir="ltr">aa_type</code>. Next, the anonymous block declares a variable of type <code dir="ltr">aa_type</code>, populates it, and passes it to the procedure <code dir="ltr">print_aa</code>, which prints it.</p>
<div id="LNPLS736" class="example">
<p class="titleinexample"><a id="BABDFGED"></a>Example 10-2 Passing Associative Array to Standalone Subprogram</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE <span class="bold">aa_pkg</span> IS
  TYPE <span class="bold">aa_type</span> IS TABLE OF INTEGER INDEX BY VARCHAR2(15);
END;
/
CREATE OR REPLACE PROCEDURE print_aa (
  <span class="bold">aa aa_pkg.aa_type</span>
) IS
  i  VARCHAR2(15);
BEGIN
  i := aa.FIRST;
 
  WHILE i IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE (aa(i) || '  ' || i);
    i := aa.NEXT(i);
  END LOOP;
END;
/
DECLARE
  <span class="bold">aa_var  aa_pkg.aa_type</span>;
BEGIN
  aa_var('zero') := 0;
  aa_var('one') := 1;
  aa_var('two') := 2;
  <span class="bold">print_aa(aa_var)</span>;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
1  one
2  two
0  zero
</pre></div>
<!-- class="example" -->
<p>Because the package specifications in <a href="#CIHEJJHJ">Example 10-1</a> and <a href="#BABDFGED">Example 10-2</a> do not declare cursors or subprograms, the packages <code dir="ltr">trans_data</code> and <code dir="ltr">aa_pkg</code> do not need bodies.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i2416"></a>
<div id="LNPLS00905" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Package Body</h2>
<p>If a package specification declares cursors or subprograms, then a package body is required; otherwise, it is optional. The package body and package specification must be in the same schema.</p>
<p>Every cursor or subprogram declaration in the package specification must have a corresponding definition in the package body. The headings of corresponding subprogram declarations and definitions must match word for word, except for white space.</p>
<p>To create a package body, use the <a href="create_package_body.htm#i2065383">"CREATE PACKAGE BODY Statement"</a>.</p>
<p>In <a href="#CJAGEFEB">Example 10-3</a>, the headings of the corresponding subprogram declaration and definition do not match word for word; therefore, PL/SQL raises an exception, even though <code dir="ltr">employees.hire_date%TYPE</code> is <code dir="ltr">DATE</code>.</p>
<div id="LNPLS738" class="example">
<p class="titleinexample"><a id="CJAGEFEB"></a>Example 10-3 Matching Package Specification and Body</p>
<pre dir="ltr">
CREATE PACKAGE emp_bonus AS
  PROCEDURE calc_bonus (date_hired <span class="bold">employees.hire_date%TYPE</span>);
END emp_bonus;
/
CREATE PACKAGE BODY emp_bonus AS
  -- DATE does not match employees.hire_date%TYPE
  PROCEDURE calc_bonus (date_hired <span class="bold">DATE</span>) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE
      ('Employees hired on ' || date_hired || ' get bonus.');
  END;
END emp_bonus;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Warning: Package Body created with compilation errors.
</pre>
<p>Show errors (in SQL*Plus):</p>
<pre dir="ltr">
SHOW ERRORS
</pre>
<p>Result:</p>
<pre dir="ltr">
Errors for PACKAGE BODY EMP_BONUS:
 
LINE/COL ERROR
-------- -----------------------------------------------------------------
2/13     PLS-00323: subprogram or cursor 'CALC_BONUS' is declared in a
         package specification and must be defined in the package body
</pre>
<p>Correct problem:</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE BODY emp_bonus AS
  PROCEDURE calc_bonus
    (<span class="bold">date_hired employees.hire_date%TYPE</span>) IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE
      ('Employees hired on ' || date_hired || ' get bonus.');
  END;
END emp_bonus;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Package body created.
</pre></div>
<!-- class="example" -->
<p>The cursors and subprograms declared in the package specification and defined in the package body are public items that can be referenced from outside the package. The package body can also declare and define <a id="sthref858"></a><span class="bold">private items</span> that cannot be referenced from outside the package, but are necessary for the internal workings of the package.</p>
<p>Finally, the body can have an <a id="sthref859"></a><span class="bold">initialization part</span>, whose statements initialize public variables and do other one-time setup steps. The initialization part runs only the first time the package is referenced. The initialization part can include an exception handler.</p>
<p>You can change the package body without changing the specification or the references to the public items.</p>
</div>
<!-- class="sect1" -->
<a id="BABEBHEG"></a>
<div id="LNPLS99926" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Package Instantiation and Initialization</h2>
<p>When a session references a package item, Oracle Database instantiates the package for that session. Every session that references a package has its own instantiation of that package.</p>
<p>When Oracle Database instantiates a package, it initializes it. <a id="sthref860"></a>Initialization includes whichever of the following are applicable:</p>
<ul>
<li>
<p>Assigning initial values to public constants</p>
</li>
<li>
<p>Assigning initial values to public variables whose declarations specify them</p>
</li>
<li>
<p>Executing the initialization part of the package body</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CJADDABG"></a>
<div id="LNPLS804" class="sect1">
<h2 class="sect1">Package State</h2>
<p>The values of the variables, constants, and cursors that a package declares (in either its specification or body) comprise its <a id="sthref861"></a><span class="glossaryterm">package state</span>. If a PL/SQL package declares at least one variable, constant, or cursor, then the package is <span class="bold">stateful</span>; otherwise, it is <span class="bold">stateless</span>.</p>
<p>Each session that references a package item has its own instantiation of that package. If the package is stateful, the instantiation includes its state. The package state persists for the life of a session, except in these situations:</p>
<ul>
<li>
<p>The package is <code dir="ltr">SERIALLY_REUSABLE</code>.</p>
<p>For details, see <a href="#CJABACHJ">"SERIALLY_REUSABLE Packages"</a>.</p>
</li>
<li>
<p>The package body is recompiled.</p>
<p>If the body of an instantiated, stateful package is recompiled (either explicitly, with the <a href="alter_package.htm#i2227346">"ALTER PACKAGE Statement"</a>, or implicitly), the next invocation of a subprogram in the package causes Oracle Database to discard the existing package state and raise the exception ORA-04068.</p>
<p>After PL/SQL raises the exception, a reference to the package causes Oracle Database to re-instantiate the package, which re-initializes it. Therefore, previous changes to the package state are lost. (For information about initialization, see <a href="#BABEBHEG">"Package Instantiation and Initialization"</a>.)</p>
</li>
<li>
<p>Any of the session's instantiated packages are invalidated and revalidated.</p>
<p>All of a session's package instantiations (including package states) can be lost if any of the session's instantiated packages are invalidated and revalidated. For information about invalidation and revalidation of schema objects, see <a class="olink ADFNS99967" href="../../appdev.112/e41502/adfns_dependencies.htm#ADFNS99967"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
</li>
</ul>
<p>As of Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), Oracle Database treats a package as stateless if its state is constant for the life of a session (or longer). This is the case for a package whose items are all compile-time constants.</p>
<p>A <span class="bold">compile-time constant</span> is a constant whose value the PL/SQL compiler can determine at compilation time. A constant whose initial value is a literal is always a compile-time constant. A constant whose initial value is not a literal, but which the optimizer reduces to a literal, is also a compile-time constant. Whether the PL/SQL optimizer can reduce a nonliteral expression to a literal depends on optimization level. Therefore, a package that is stateless when compiled at one optimization level might be stateful when compiled at a different optimization level. For information about the optimizer, see <a href="tuning.htm#i53930">"PL/SQL Optimizer"</a>.</p>
</div>
<!-- class="sect1" -->
<a id="CJABACHJ"></a>
<div id="LNPLS99977" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">SERIALLY_REUSABLE Packages</h2>
<p><a id="sthref862"></a><a id="sthref863"></a><code dir="ltr">SERIALLY_REUSABLE</code> packages let you design applications that manage memory better for <a id="sthref864"></a>scalability.</p>
<p>If a package is not <code dir="ltr">SERIALLY_REUSABLE</code>, its package state is stored in the user global area (UGA) for each user. Therefore, the amount of UGA memory needed increases linearly with the number of users, limiting scalability. The package state can persist for the life of a session, locking UGA memory until the session ends. In some applications, such as Oracle Office, a typical session lasts several days.</p>
<p>If a package is <code dir="ltr">SERIALLY_REUSABLE</code>, its package state is stored in a work area in a small pool in the system global area (SGA). The package state persists only for the life of a server call. After the server call, the work area returns to the pool. If a subsequent server call references the package, then Oracle Database reuses an instantiation from the pool. Reusing an instantiation re-initializes it; therefore, changes made to the package state in previous server calls are invisible. (For information about initialization, see <a href="#BABEBHEG">"Package Instantiation and Initialization"</a>.)</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Trying to access a <code dir="ltr">SERIALLY_REUSABLE</code> package from a database trigger, or from a PL/SQL subprogram invoked by a SQL statement, raises an error.</div>
<p class="subhead2"><a id="LNPLS747"></a>Topics</p>
<ul>
<li>
<p><a href="#BABBCEFD">Creating SERIALLY_REUSABLE Packages</a></p>
</li>
<li>
<p><a href="#BABHHACH">SERIALLY_REUSABLE Package Work Unit</a></p>
</li>
<li>
<p><a href="#BABHHHAI">Explicit Cursors in SERIALLY_REUSABLE Packages</a></p>
</li>
</ul>
<a id="BABBCEFD"></a>
<div id="LNPLS99925" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating SERIALLY_REUSABLE Packages</h3>
<p>To create a <code dir="ltr">SERIALLY_REUSABLE</code> package, include the <code dir="ltr">SERIALLY_REUSABLE</code> pragma in the package specification and, if it exists, the package body.</p>
<p><a href="#BABBIBDC">Example 10-4</a> creates two very simple <code dir="ltr">SERIALLY_REUSABLE</code> packages, one with only a specification, and one with both a specification and a body.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="seriallyreusable_pragma.htm#i36155">"SERIALLY_REUSABLE Pragma"</a></div>
<div id="LNPLS810" class="example">
<p class="titleinexample"><a id="BABBIBDC"></a>Example 10-4 Creating SERIALLY_REUSABLE Packages</p>
<pre dir="ltr">
<span class="bold">-- Create bodiless SERIALLY_REUSABLE package:</span>
 
CREATE OR REPLACE PACKAGE bodiless_pkg IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END;
/
 
<span class="bold">-- Create SERIALLY_REUSABLE package with specification and body:</span>
 
CREATE OR REPLACE PACKAGE pkg IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END;
/
 
CREATE OR REPLACE PACKAGE BODY pkg IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
BEGIN
  n := 5;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABHHACH"></a>
<div id="LNPLS99924" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SERIALLY_REUSABLE Package Work Unit</h3>
<p>For a <code dir="ltr">SERIALLY_REUSABLE</code> package, the work unit is a server call. You must use its public variables only within the work unit.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you make a mistake and depend on the value of a public variable that was set in a previous work unit, then your program can fail. PL/SQL cannot check for such cases.</div>
<p>In <a href="#BABFAFDC">Example 10-5</a>, the bodiless packages <code dir="ltr">pkg</code> and <code dir="ltr">pkg_sr</code> are the same, except that <code dir="ltr">pkg_sr</code> is <code dir="ltr">SERIALLY_REUSABLE</code> and <code dir="ltr">pkg</code> is not. Each package declares public variable <code dir="ltr">n</code> with initial value 5. Then, an anonymous block changes the value of each variable to 10. Next, another anonymous block prints the value of each variable. The value of <code dir="ltr">pkg</code>.<code dir="ltr">n</code> is still 10, because the state of <code dir="ltr">pkg</code> persists for the life of the session. The value of <code dir="ltr">pkg_sr</code>.<code dir="ltr">n</code> is 5, because the state of <code dir="ltr">pkg_sr</code> persists only for the life of the server call.</p>
<div id="LNPLS809" class="example">
<p class="titleinexample"><a id="BABFAFDC"></a>Example 10-5 Effect of SERIALLY_REUSABLE Pragma</p>
<pre dir="ltr">
CREATE OR REPLACE <span class="bold">PACKAGE pkg</span> IS
  n NUMBER := 5;
END pkg;
/

CREATE OR REPLACE <span class="bold">PACKAGE sr_pkg</span> IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  n NUMBER := 5;
END sr_pkg;
/

BEGIN
  pkg.n := 10;
  sr_pkg.n := 10;
END;
/

BEGIN
  DBMS_OUTPUT.PUT_LINE('pkg.n: ' || pkg.n);
  DBMS_OUTPUT.PUT_LINE('sr_pkg.n: ' || sr_pkg.n);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">pkg.n: 10</span>
<span class="bold">sr_pkg.n: 5</span>
</pre></div>
<!-- class="example" -->
<p>After the work unit (server call) of a <code dir="ltr">SERIALLY_REUSABLE</code> package completes, Oracle Database does the following:</p>
<ul>
<li>
<p>Closes any open <a id="sthref865"></a>cursors.</p>
</li>
<li>
<p>Frees some nonreusable memory (for example, memory for collection and long <code dir="ltr">VARCHAR2</code> variables)</p>
</li>
<li>
<p>Returns the package instantiation to the pool of reusable instantiations kept for this package.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABHHHAI"></a>
<div id="LNPLS99923" class="sect2">
<h3 class="sect2">Explicit Cursors in SERIALLY_REUSABLE Packages</h3>
<p>An <a id="sthref866"></a>explicit cursor in a <code dir="ltr">SERIALLY_REUSABLE</code> package remains open until either you close it or its work unit (server call) ends. To re-open the cursor, you must make a new server call. A server call can be different from a subprogram invocation, as <a href="#BABHACDC">Example 10-6</a> shows.</p>
<p>In contrast, an explicit cursor in a package that is not <code dir="ltr">SERIALLY_REUSABLE</code> remains open until you either close it or disconnect from the session.</p>
<div id="LNPLS811" class="example">
<p class="titleinexample"><a id="BABHACDC"></a>Example 10-6 Cursor in SERIALLY_REUSABLE Package Open at Call Boundary</p>
<pre dir="ltr">
DROP TABLE people;
CREATE TABLE people (name VARCHAR2(20));
 
INSERT INTO people (name) VALUES ('John Smith');
INSERT INTO people (name) VALUES ('Mary Jones');
INSERT INTO people (name) VALUES ('Joe Brown');
INSERT INTO people (name) VALUES ('Jane White');

CREATE OR REPLACE <span class="bold">PACKAGE sr_pkg</span> IS
  <span class="bold">PRAGMA SERIALLY_REUSABLE;</span>
  <span class="bold">CURSOR c</span> IS SELECT name FROM people;
END sr_pkg;
/
 
CREATE OR REPLACE PROCEDURE fetch_from_cursor IS
  name_  VARCHAR2(200);
BEGIN
  IF sr_pkg.c%ISOPEN THEN
    DBMS_OUTPUT.PUT_LINE('Cursor is open.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Cursor is closed; opening now.');
    OPEN sr_pkg.c;
  END IF;
 
  FETCH sr_pkg.c INTO name_;
  DBMS_OUTPUT.PUT_LINE('Fetched: ' || name_);
 
  FETCH sr_pkg.c INTO name;
    DBMS_OUTPUT.PUT_LINE('Fetched: ' || name_);
  END fetch_from_cursor;
/
 
</pre>
<p>First call to server:</p>
<pre dir="ltr">
BEGIN
  fetch_from_cursor;
  fetch_from_cursor;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Cursor is closed; opening now.</span>
Fetched: John Smith
Fetched: Mary Jones
<span class="bold">Cursor is open.</span>
Fetched: Joe Brown
Fetched: Jane White
 
</pre>
<p>New call to server:</p>
<pre dir="ltr">
BEGIN
  fetch_from_cursor;
  fetch_from_cursor;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Cursor is closed; opening now.</span>
Fetched: John Smith
Fetched: Mary Jones
<span class="bold">Cursor is open.</span>
Fetched: Joe Brown
Fetched: Jane White
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7562"></a>
<div id="LNPLS00909" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Package Writing Guidelines</h2>
<ul>
<li>
<p><a id="sthref867"></a>Become familiar with the packages that Oracle Database supplies, and avoid writing packages that duplicate their features.</p>
<p>For more information about the packages that Oracle Database supplies, see <a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li>
<p>Keep your packages general so that future applications can reuse them.</p>
</li>
<li>
<p>Design and define the package specifications before the package bodies.</p>
</li>
<li>
<p>In package specifications, declare only items that must be visible to invoking programs.</p>
<p>This practice prevents other developers from building unsafe dependencies on your implementation details and reduces the need for recompilation.</p>
<p>If you change the package specification, you must recompile any subprograms that invoke the public subprograms of the package. If you change only the package body, you do not have to recompile those subprograms.</p>
</li>
<li>
<p>Declare public <a id="sthref868"></a>cursors in package specifications and define them in package bodies, as in <a href="#CIHFBJCG">Example 10-7</a>.</p>
<p>This practice lets you hide cursors' queries from package users and change them without changing cursor declarations.</p>
</li>
<li>
<p>Assign initial values in the <a id="sthref869"></a>initialization part of the package body instead of in declarations.</p>
<p>This practice has these advantages:</p>
<ul>
<li>
<p>The code for computing the initial values can be more complex and better documented.</p>
</li>
<li>
<p>If computing an initial value raises an exception, the initialization part can handle it with its own exception handler.</p>
</li>
</ul>
</li>
</ul>
<p>In <a href="#CIHFBJCG">Example 10-7</a>, the declaration and definition of the cursor <code dir="ltr">c1</code> are in the specification and body, respectively, of the package <code dir="ltr">emp_stuff</code>. The cursor declaration specifies only the data type of the return value, not the query, which appears in the cursor definition (for complete syntax and semantics, see <a href="explicit_cursor.htm#i33637">"Explicit Cursor Declaration and Definition"</a>).</p>
<div id="LNPLS826" class="example">
<p class="titleinexample"><a id="CIHFBJCG"></a>Example 10-7 Separating Cursor Declaration and Definition in Package</p>
<pre dir="ltr">
CREATE PACKAGE emp_stuff AS
  <span class="bold">CURSOR c1 RETURN employees%ROWTYPE;  -- Declare cursor</span>
END emp_stuff;
/
CREATE PACKAGE BODY emp_stuff AS
  <span class="bold">CURSOR c1 RETURN employees%ROWTYPE IS</span>
    <span class="bold">SELECT * FROM employees WHERE salary &gt; 2500;  -- Define cursor</span>
END emp_stuff;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i4362"></a>
<div id="LNPLS00906" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Package Example</h2>
<p><a href="#CJAIICFE">Example 10-8</a> creates a table, <code dir="ltr">log</code>, and a package, <code dir="ltr">emp_admin</code>, and then invokes package subprograms from an anonymous block. The package has both specification and body.</p>
<p>The specification declares a public type, cursor, and exception, and three public subprograms. One public subprogram is overloaded (for information about overloaded subprograms, see <a href="subprograms.htm#i12352">"Overloaded Subprograms"</a>).</p>
<p>The body declares a private variable, defines the public cursor and subprograms that the specification declares, declares and defines a private function, and has an initialization part.</p>
<p>The initialization part (which runs only the first time the anonymous block references the package) inserts one row into the table <code dir="ltr">log</code> and initializes the private variable <code dir="ltr">number_hired</code> to zero. Every time the package procedure <code dir="ltr">hire_employee</code> is invoked, it updates the private variable <code dir="ltr">number_hired</code>.</p>
<div id="LNPLS816" class="example">
<p class="titleinexample"><a id="CJAIICFE"></a>Example 10-8 Creating emp_admin Package</p>
<pre dir="ltr">
<span class="bold">-- Log to track changes (not part of package):</span>

DROP TABLE log;
CREATE TABLE log (
  date_of_action  DATE,
  user_id         VARCHAR2(20),
  package_name    VARCHAR2(30)
);

<span class="bold">-- Package specification:</span>

CREATE OR REPLACE PACKAGE emp_admin AS
  <span class="bold">-- Declare public type, cursor, and exception:</span>
  TYPE EmpRecTyp IS RECORD (emp_id NUMBER, sal NUMBER);
  CURSOR desc_salary RETURN EmpRecTyp;
  invalid_salary EXCEPTION;

  <span class="bold">-- Declare public subprograms:</span>

  FUNCTION hire_employee (
    last_name       VARCHAR2,
    first_name      VARCHAR2,
    email           VARCHAR2,
    phone_number    VARCHAR2,
    job_id          VARCHAR2,
    salary          NUMBER,
    commission_pct  NUMBER,
    manager_id      NUMBER,
    department_id   NUMBER
  ) RETURN NUMBER;

  <span class="bold">-- Overload preceding public subprogram:</span>
  PROCEDURE fire_employee (emp_id NUMBER);
  PROCEDURE fire_employee (emp_email VARCHAR2);

  PROCEDURE raise_salary (emp_id NUMBER, amount NUMBER);
  FUNCTION nth_highest_salary (n NUMBER) RETURN EmpRecTyp;
END emp_admin;
/
<span class="bold">-- Package body:</span>

CREATE OR REPLACE PACKAGE BODY emp_admin AS
  number_hired  NUMBER;  <span class="bold">-- private variable, visible only in this package</span>

  <span class="bold">-- Define cursor declared in package specification:</span>

  CURSOR desc_salary RETURN EmpRecTyp IS
    SELECT employee_id, salary
    FROM employees
    ORDER BY salary DESC;

  <span class="bold">-- Define subprograms declared in package specification:</span>

  FUNCTION hire_employee (
    last_name       VARCHAR2,
    first_name      VARCHAR2,
    email           VARCHAR2,
    phone_number    VARCHAR2,
    job_id          VARCHAR2,
    salary          NUMBER,
    commission_pct  NUMBER,
    manager_id      NUMBER,
    department_id   NUMBER
  ) RETURN NUMBER
  IS
    new_emp_id NUMBER;
  BEGIN
    new_emp_id := employees_seq.NEXTVAL;
    INSERT INTO employees (
      employee_id,
      last_name,
      first_name,
      email,
      phone_number,
      hire_date,
      job_id,
      salary,
      commission_pct,
      manager_id,
      department_id
    )
    VALUES (
      new_emp_id,
      hire_employee.last_name,
      hire_employee.first_name,
      hire_employee.email,
      hire_employee.phone_number,
      SYSDATE,
      hire_employee.job_id,
      hire_employee.salary,
      hire_employee.commission_pct,
      hire_employee.manager_id,
      hire_employee.department_id
    );
    number_hired := number_hired + 1;
    DBMS_OUTPUT.PUT_LINE('The number of employees hired is ' 
                         || TO_CHAR(number_hired) );   
    RETURN new_emp_id;
  END hire_employee;

  PROCEDURE fire_employee (emp_id NUMBER) IS
  BEGIN
    DELETE FROM employees WHERE employee_id = emp_id;
  END fire_employee;

  PROCEDURE fire_employee (emp_email VARCHAR2) IS
  BEGIN
    DELETE FROM employees WHERE email = emp_email;
  END fire_employee;

  <span class="bold">-- Define private function, available only inside package:</span>

  FUNCTION sal_ok (
    jobid VARCHAR2,
    sal NUMBER
  ) RETURN BOOLEAN
  IS
    min_sal NUMBER;
    max_sal NUMBER;
  BEGIN
    SELECT MIN(salary), MAX(salary)
    INTO min_sal, max_sal
    FROM employees
    WHERE job_id = jobid;

    RETURN (sal &gt;= min_sal) AND (sal &lt;= max_sal);
  END sal_ok;

  PROCEDURE raise_salary (
    emp_id NUMBER,
    amount NUMBER
  )
  IS
    sal NUMBER(8,2);
    jobid VARCHAR2(10);
  BEGIN
    SELECT job_id, salary INTO jobid, sal
    FROM employees
    WHERE employee_id = emp_id;

    IF <span class="bold">sal_ok(jobid, sal + amount)</span> THEN  <span class="bold">-- Invoke private function</span>
      UPDATE employees
      SET salary = salary + amount
      WHERE employee_id = emp_id;
    ELSE
      RAISE invalid_salary;
    END IF;
  EXCEPTION
    WHEN invalid_salary THEN
      DBMS_OUTPUT.PUT_LINE ('The salary is out of the specified range.');
  END raise_salary;

  FUNCTION nth_highest_salary (
    n NUMBER
  ) RETURN EmpRecTyp
  IS
    emp_rec  EmpRecTyp;
  BEGIN
    OPEN desc_salary;
    FOR i IN 1..n LOOP
      FETCH desc_salary INTO emp_rec;
    END LOOP;
    CLOSE desc_salary;
    RETURN emp_rec;
  END nth_highest_salary;

BEGIN  <span class="bold">-- initialization part of package body</span>
   INSERT INTO log (date_of_action, user_id, package_name)
   VALUES (SYSDATE, USER, 'EMP_ADMIN');
   number_hired := 0;
END emp_admin;
/
<span class="bold">-- Invoke packages subprograms in anonymous block:</span>

DECLARE
  new_emp_id NUMBER(6);
BEGIN
  new_emp_id := <span class="bold">emp_admin.hire_employee</span> (
    'Belden',
    'Enrique',
    'EBELDEN',
    '555.111.2222',
    'ST_CLERK',
    2500,
    .1,
    101,
    110
  );
  DBMS_OUTPUT.PUT_LINE ('The employee id is ' || TO_CHAR(new_emp_id));
  <span class="bold">emp_admin.raise_salary</span> (new_emp_id, 100);

  DBMS_OUTPUT.PUT_LINE (
    'The 10th highest salary is '||
    TO_CHAR (<span class="bold">emp_admin.nth_highest_salary(10).sal</span>) ||
             ', belonging to employee: ' ||
             TO_CHAR (<span class="bold">emp_admin.nth_highest_salary(10).emp_id</span>)
  );

  <span class="bold">emp_admin.fire_employee(new_emp_id)</span>;
  -- You can also delete the newly added employee as follows:
  -- <span class="bold">emp_admin.fire_employee('EBELDEN')</span>;
END;
/
</pre>
<p>Result is similar to:</p>
<pre dir="ltr">
The number of employees hired is 1
The employee id is 212
The 10th highest salary is 12075, belonging to employee: 168
There are now 107 employees.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i6060"></a>
<div id="LNPLS00907" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">How STANDARD Package Defines the PL/SQL Environment</h2>
<p>A <a id="sthref870"></a>package named <code dir="ltr">STANDARD</code> defines the PL/SQL environment. The package specification declares public types, variables, exceptions, subprograms, which are available automatically to PL/SQL programs. For example, package <code dir="ltr">STANDARD</code> declares function <code dir="ltr">ABS</code>, which returns the absolute value of its argument, as follows:</p>
<pre dir="ltr">
FUNCTION ABS (n NUMBER) RETURN NUMBER;
</pre>
<p>The contents of package <code dir="ltr">STANDARD</code> are directly visible to applications. You need not qualify references to its contents by prefixing the package name. For example, you might invoke <code dir="ltr">ABS</code> from a database trigger, stored subprogram, Oracle tool, or 3GL application, as follows:</p>
<pre dir="ltr">
abs_diff := ABS(x - y);
</pre>
<p>If you declare your own version of <code dir="ltr">ABS</code>, your local declaration overrides the public declaration. You can still invoke the SQL function by specifying its full name:</p>
<pre dir="ltr">
abs_diff := STANDARD.ABS(x - y);
</pre>
<p>Most SQL functions are overloaded. For example, package <code dir="ltr">STANDARD</code> contains these declarations:</p>
<pre dir="ltr">
FUNCTION TO_CHAR (right DATE) RETURN VARCHAR2;
FUNCTION TO_CHAR (left NUMBER) RETURN VARCHAR2;
FUNCTION TO_CHAR (left DATE, right VARCHAR2) RETURN VARCHAR2;
FUNCTION TO_CHAR (left NUMBER, right VARCHAR2) RETURN VARCHAR2;
</pre>
<p>PL/SQL resolves an invocation of <code dir="ltr">TO_CHAR</code> by matching the number and data types of the formal and actual parameters.</p>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="triggers.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="errors.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
