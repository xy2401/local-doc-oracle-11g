<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Static SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:52:56Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="composites.htm" title="Previous" type="text/html" />
<link rel="Next" href="dynamic.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/99</span> <!-- End Header -->
<div id="LNPLS006" class="chapter"><a id="BABGEDAE"></a>
<h1 class="chapter"><span class="secnum">6</span> PL/SQL Static SQL</h1>
<p><a id="sthref477"></a><span class="bold">Static SQL</span> is a PL/SQL feature that allows SQL syntax directly in a PL/SQL statement. This chapter describes static SQL and explains how to use it.</p>
<p class="subhead2"><a id="LNPLS467"></a>Topics</p>
<ul>
<li>
<p><a href="#i7112">Description of Static SQL</a></p>
</li>
<li>
<p><a href="#BABDHAED">Cursors</a></p>
</li>
<li>
<p><a href="#i45320">Query Result Set Processing</a></p>
</li>
<li>
<p><a href="#i7106">Cursor Variables</a></p>
</li>
<li>
<p><a href="#i44913">CURSOR Expressions</a></p>
</li>
<li id="BABJGIJI">
<p><a href="#i7105">Transaction Processing and Control</a></p>
</li>
<li>
<p><a href="#i36056">Autonomous Transactions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="nameresolution.htm#BABDCBJD">"Resolution of Names in Static SQL Statements"</a></div>
<a id="i7112"></a>
<div id="LNPLS00601" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Description of Static SQL</h2>
<p>Static SQL has the same syntax as SQL, except as noted.</p>
<p class="subhead2"><a id="LNPLS476"></a>Topics</p>
<ul>
<li>
<p><a href="#BABDDEHG">Statements</a></p>
</li>
<li>
<p><a href="#CJAJABAC">Pseudocolumns</a></p>
</li>
</ul>
<a id="BABDDEHG"></a>
<div id="LNPLS99878" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Statements</h3>
<p>These are the PL/SQL static SQL statements, which have the same syntax as the corresponding SQL statements, except as noted:</p>
<ul>
<li>
<p><code dir="ltr">SELECT</code> (this statement is also called a <span class="bold">query</span>)</p>
<p>For the PL/SQL syntax, see <a href="selectinto_statement.htm#i36066">"SELECT INTO Statement"</a>.</p>
</li>
<li>
<p>Data manipulation language (<a id="sthref478"></a>DML) statements:</p>
<ul>
<li>
<p><code dir="ltr">INSERT</code></p>
<p>For the PL/SQL syntax, see <a href="insert_statement.htm#CJADIJED">"INSERT Statement Extension"</a></p>
</li>
<li>
<p><code dir="ltr">UPDATE</code></p>
<p>For the PL/SQL syntax, see <a href="update_statement.htm#CJAIGFJI">"UPDATE Statement Extensions"</a></p>
</li>
<li>
<p><code dir="ltr">DELETE</code></p>
<p>For the PL/SQL syntax, see <a href="delete_statement.htm#CJAICFEA">"DELETE Statement Extension"</a></p>
</li>
<li>
<p><code dir="ltr">MERGE</code> (for syntax, see <a class="olink SQLRF01606" href="../../server.112/e41084/statements_9016.htm#SQLRF01606"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a class="olink SQLRF30042" href="../../server.112/e41084/statements_1001.htm#SQLRF30042"><span class="italic">Oracle Database SQL Language Reference</span></a> defines DML differently.</div>
</li>
<li id="BABEGEDB">
<p>Transaction control language (<a id="sthref479"></a>TCL) statements:</p>
<ul>
<li>
<p><code dir="ltr">COMMIT</code> (for syntax, see <a class="olink SQLRF01110" href="../../server.112/e41084/statements_4010.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">ROLLBACK</code> (for syntax, see <a class="olink SQLRF01610" href="../../server.112/e41084/statements_9021.htm#SQLRF01610"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">SAVEPOINT</code> (for syntax, see <a class="olink SQLRF01701" href="../../server.112/e41084/statements_10001.htm#SQLRF01701"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> (for syntax, see <a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
</li>
<li>
<p><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> (for syntax, see <a class="olink SQLRF01605" href="../../server.112/e41084/statements_9015.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
<p>A PL/SQL static SQL statement can have a PL/SQL <a id="sthref480"></a><a id="sthref481"></a>identifier wherever its SQL counterpart can have a <a id="sthref482"></a><a id="sthref483"></a>placeholder for a bind variable. The PL/SQL identifier must identify either a variable or a formal parameter.</p>
<p>In <a href="#BABIEJGE">Example 6-1</a>, a PL/SQL anonymous block declares three PL/SQL variables and uses them in the static SQL statements <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>. The block also uses the static SQL statement <code dir="ltr">COMMIT</code>.</p>
<div id="LNPLS477" class="example">
<p class="titleinexample"><a id="BABIEJGE"></a>Example 6-1 Static SQL Statements</p>
<pre dir="ltr">
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT employee_id, first_name, last_name 
  FROM employees;
 
DECLARE
  emp_id          employees_temp.employee_id%TYPE := 299;
  emp_first_name  employees_temp.first_name%TYPE  := 'Bob';
  emp_last_name   employees_temp.last_name%TYPE   := 'Henry';
BEGIN
  <span class="bold">INSERT</span> INTO employees_temp (employee_id, first_name, last_name) 
  VALUES (<span class="bold">emp_id</span>, <span class="bold">emp_first_name</span>, <span class="bold">emp_last_name</span>);
 
  <span class="bold">UPDATE</span> employees_temp
  SET first_name = 'Robert'
  WHERE employee_id = <span class="bold">emp_id</span>;
 
  <span class="bold">DELETE</span> FROM employees_temp
  WHERE employee_id = <span class="bold">emp_id</span>
  RETURNING first_name, last_name
  INTO <span class="bold">emp_first_name</span>, <span class="bold">emp_last_name</span>;
 
  <span class="bold">COMMIT</span>;
  DBMS_OUTPUT.PUT_LINE (emp_first_name || ' ' || emp_last_name);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Robert Henry
</pre></div>
<!-- class="example" -->
<p>To use PL/SQL identifiers for table names, column names, and so on, use the <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement, explained in <a href="dynamic.htm#i13130">"Native Dynamic SQL"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
After PL/SQL code runs a DML statement, the values of some <a id="sthref484"></a>variables are undefined. For example:
<ul>
<li>
<p>After a <code dir="ltr">FETCH</code> or <code dir="ltr">SELECT</code> statement raises an exception, the values of the define variables after that statement are undefined.</p>
</li>
<li>
<p>After a DML statement that affects zero rows, the values of the <code dir="ltr">OUT</code> bind variables are undefined, unless the DML statement is a <code dir="ltr">BULK</code> or multiple-row operation.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CJAJABAC"></a>
<div id="LNPLS00611" class="sect2">
<h3 class="sect2">Pseudocolumns</h3>
<p>A <a id="sthref485"></a>pseudocolumn behaves like a table column, but it is not stored in the table. For general information about pseudocolumns, including restrictions, see <a class="olink SQLRF0025" href="../../server.112/e41084/pseudocolumns.htm#SQLRF0025"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>Static SQL includes these SQL pseudocolumns:</p>
<ul>
<li>
<p><code dir="ltr">CURRVAL</code> and <code dir="ltr">NEXTVAL</code>, described in <a href="#CIHCBFIJ">"CURRVAL and NEXTVAL in PL/SQL"</a>.</p>
</li>
<li>
<p><a id="sthref486"></a><code dir="ltr">LEVEL</code>, described in <a class="olink SQLRF0025" href="../../server.112/e41084/pseudocolumns.htm#SQLRF0025"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><code dir="ltr">OBJECT_VALUE</code>, described in <a class="olink SQLRF50952" href="../../server.112/e41084/pseudocolumns006.htm#SQLRF50952"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="triggers.htm#g1662184">"OBJECT_VALUE Pseudocolumn"</a> for information about using <code dir="ltr">OBJECT_VALUE</code> in triggers</div>
</li>
<li>
<p><a id="sthref487"></a><code dir="ltr">ROWID</code>, described in <a class="olink SQLRF00254" href="../../server.112/e41084/pseudocolumns008.htm#SQLRF00254"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CIHFJCCI">"Simulating CURRENT OF Clause with ROWID Pseudocolumn"</a></div>
</li>
<li>
<p><code dir="ltr">ROWNUM</code>, described in <a class="olink SQLRF00255" href="../../server.112/e41084/pseudocolumns009.htm#SQLRF00255"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
</ul>
<a id="CIHCBFIJ"></a>
<div id="LNPLS00610" class="sect3">
<h4 class="sect3">CURRVAL and NEXTVAL in PL/SQL</h4>
<p>After a <a id="sthref488"></a>sequence is created, you can access its values in SQL statements with the <a id="sthref489"></a><code dir="ltr">CURRVAL</code> pseudocolumn, which returns the current value of the sequence, or the <a id="sthref490"></a><code dir="ltr">NEXTVAL</code> pseudocolumn, which increments the sequence and returns the new value. (For general information about sequences, see <a class="olink SQLRF01314" href="../../server.112/e41084/statements_6015.htm#SQLRF01314"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<p>To reference these pseudocolumns, use <a id="sthref491"></a>dot notation&mdash;for example, <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">CURRVAL</code>. For complete syntax, see <a class="olink SQLRF00253" href="../../server.112/e41084/pseudocolumns002.htm#SQLRF00253"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Each time you reference <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">NEXTVAL</code>, the sequence is incremented immediately and permanently, whether you commit or roll back the transaction.</div>
<p>As of Oracle Database 11<span class="italic">g</span> Release 1, you can use <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">CURRVAL</code> and <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">NEXTVAL</code> in a PL/SQL expression wherever you can use a <code dir="ltr">NUMBER</code> expression. However:</p>
<ul>
<li>
<p>Using <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">CURRVAL</code> or <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">NEXTVAL</code> to provide a default value for an ADT method parameter causes a compilation error.</p>
</li>
<li>
<p>PL/SQL evaluates every occurrence of <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">CURRVAL</code> and <code dir="ltr"><span class="codeinlineitalic">sequence_name</span></code>.<code dir="ltr">NEXTVAL</code> (unlike SQL, which evaluates a sequence expression for every row in which it appears).</p>
</li>
</ul>
<p><a href="#BABDDFGI">Example 6-2</a> generates a sequence number for the sequence <code dir="ltr">HR.EMPLOYEES_SEQ</code> and refers to that number in multiple statements.</p>
<div id="LNPLS512" class="example">
<p class="titleinexample"><a id="BABDDFGI"></a>Example 6-2 CURRVAL and NEXTVAL Pseudocolumns</p>
<pre dir="ltr">
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT employee_id, first_name, last_name
  FROM employees;
 
DROP TABLE employees_temp2;
CREATE TABLE employees_temp2 AS
  SELECT employee_id, first_name, last_name
  FROM employees;
 
DECLARE
  seq_value NUMBER;
BEGIN
  <span class="bold">-- Generate initial sequence number</span>
 
  seq_value := <span class="bold">employees_seq.NEXTVAL</span>;
 
  -- Print initial sequence number:
 
  DBMS_OUTPUT.PUT_LINE (
    'Initial sequence value: ' || TO_CHAR(seq_value)
  );
 
  <span class="bold">-- Use NEXTVAL to create unique number when inserting data:</span>
 
     INSERT INTO employees_temp (employee_id, first_name, last_name) 
     VALUES (<span class="bold">employees_seq.NEXTVAL</span>, 'Lynette', 'Smith');
 
  <span class="bold">-- Use CURRVAL to store same value somewhere else:</span>
 
     INSERT INTO employees_temp2 VALUES (<span class="bold">employees_seq.CURRVAL</span>,
                                         'Morgan', 'Smith');
 
  /* Because NEXTVAL values might be referenced
     by different users and applications,
     and some NEXTVAL values might not be stored in database,
     there might be gaps in sequence. */
 
  <span class="bold">-- Use CURRVAL to specify record to delete:</span>
 
     seq_value := <span class="bold">employees_seq.CURRVAL</span>;
 
     DELETE FROM employees_temp2
     WHERE employee_id = seq_value;
 
  <span class="bold">-- Update employee_id with NEXTVAL for specified record:</span>
 
     UPDATE employees_temp
     SET employee_id = <span class="bold">employees_seq.NEXTVAL</span>
     WHERE first_name = 'Lynette'
     AND last_name = 'Smith';
 
  <span class="bold">-- Display final value of CURRVAL:</span>
 
     seq_value := <span class="bold">employees_seq.CURRVAL</span>;
 
     DBMS_OUTPUT.PUT_LINE (
       'Ending sequence value: ' || TO_CHAR(seq_value)
     );
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABDHAED"></a>
<div id="LNPLS00602" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Cursors</h2>
<p>A <a id="sthref492"></a><span class="bold">cursor</span> is a pointer to a private SQL area that stores information about processing a specific <code dir="ltr">SELECT</code> or DML statement.</p>
<p>The cursors that this chapter explains are session cursors. A <a id="sthref493"></a><span class="bold">session cursor</span> lives in session memory until the session ends, when it ceases to exist.</p>
<p>A session cursor that is constructed and managed by PL/SQL is an <span class="bold">implicit cursor</span>. A session cursor that you construct and manage is an <span class="bold">explicit cursor</span>.</p>
<p>You can get information about any session cursor from its <a id="sthref494"></a>attributes (which you can reference in procedural statements, but not in SQL statements).</p>
<p>To list the session cursors that each user session currently has opened and parsed, query the dynamic performance view <code dir="ltr">V$OPEN_CURSOR</code>, explained in <a class="olink REFRN30166" href="../../server.112/e40402/dynviews_2083.htm#REFRN30166"><span class="italic">Oracle Database Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generally, PL/SQL parses an explicit cursor only the first time the session opens it and parses a SQL statement (creating an implicit cursor) only the first time the statement runs.
<p>All parsed SQL statements are cached. A SQL statement is reparsed only if it is aged out of the cache by a new SQL statement. Although you must close an explicit cursor before you can reopen it, PL/SQL need not reparse the associated query. If you close and immediately reopen an explicit cursor, PL/SQL does not reparse the associated query.</p>
</div>
<p>Topics</p>
<ul>
<li>
<p><a href="#i46192">Implicit Cursors</a></p>
</li>
<li>
<p><a href="#CIHCAHJA">Explicit Cursors</a></p>
</li>
</ul>
<a id="i46192"></a>
<div id="LNPLS99957" class="sect2">
<h3 class="sect2">Implicit Cursors</h3>
<p>An <a id="sthref495"></a><span class="bold">implicit cursor</span> is a session cursor that is constructed and managed by PL/SQL. PL/SQL opens an implicit cursor every time you run a <code dir="ltr">SELECT</code> or DML statement. You cannot control an implicit cursor, but you can get information from its <a id="sthref496"></a>attributes.</p>
<p>The syntax of an implicit cursor attribute value is <code dir="ltr">SQL</code><code dir="ltr"><span class="codeinlineitalic">attribute</span></code> (therefore, an implicit cursor is also called a <span class="bold">SQL cursor</span>). <code dir="ltr">SQL</code><code dir="ltr"><span class="codeinlineitalic">attribute</span></code> always refers to the most recently run <code dir="ltr">SELECT</code> or DML statement. If no such statement has run, the value of <code dir="ltr">SQL</code><code dir="ltr"><span class="codeinlineitalic">attribute</span></code> is <code dir="ltr">NULL</code>.</p>
<p>An implicit cursor closes after its associated statement runs; however, its attribute values remain available until another <code dir="ltr">SELECT</code> or DML statement runs.</p>
<p>The most recently run <code dir="ltr">SELECT</code> or DML statement might be in a different scope. To save an attribute value for later use, assign it to a local variable immediately. Otherwise, other operations, such as subprogram invocations, might change the value of the attribute before you can test it.</p>
<p>The implicit cursor attributes are:</p>
<ul>
<li>
<p><a href="#CIHCJHFH">SQL%ISOPEN Attribute: Is the Cursor Open?</a></p>
</li>
<li>
<p><a href="#CIHEHJDF">SQL%FOUND Attribute: Were Any Rows Affected?</a></p>
</li>
<li>
<p><a href="#CIHHHFFF">SQL%NOTFOUND Attribute: Were No Rows Affected?</a></p>
</li>
<li>
<p><a href="#CIHJJJDG">SQL%ROWCOUNT Attribute: How Many Rows Were Affected?</a></p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_ROWCOUNT</code> (see <a href="tuning.htm#i49056">"Getting Number of Rows Affected by FORALL Statement"</a>)</p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS</code> (see <a href="tuning.htm#i49099">"Handling FORALL Exceptions After FORALL Statement Completes"</a>)</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="sql_cursor.htm#i36237">"Implicit Cursor Attribute"</a> for complete syntax and semantics</div>
<a id="CIHCJHFH"></a>
<div id="LNPLS526" class="sect3">
<h4 class="sect3">SQL%ISOPEN Attribute: Is the Cursor Open?</h4>
<p><a id="sthref497"></a><a id="sthref498"></a><code dir="ltr">SQL%ISOPEN</code> always returns <code dir="ltr">FALSE</code>, because an implicit cursor always closes after its associated statement runs.</p>
</div>
<!-- class="sect3" -->
<a id="CIHEHJDF"></a>
<div id="LNPLS524" class="sect3">
<h4 class="sect3">SQL%FOUND Attribute: Were Any Rows Affected?</h4>
<p><a id="sthref499"></a><a id="sthref500"></a><a id="sthref501"></a><code dir="ltr">SQL%FOUND</code> returns:</p>
<ul>
<li>
<p><code dir="ltr">NULL</code> if no <code dir="ltr">SELECT</code> or DML statement has run</p>
</li>
<li>
<p><code dir="ltr">TRUE</code> if a <code dir="ltr">SELECT</code> statement returned one or more rows or a DML statement affected one or more rows</p>
</li>
<li>
<p><code dir="ltr">FALSE</code> otherwise</p>
</li>
</ul>
<p><a href="#BABJGHAI">Example 6-3</a> uses <code dir="ltr">SQL%FOUND</code> to determine if a <code dir="ltr">DELETE</code> statement affected any rows.</p>
<div id="LNPLS525" class="example">
<p class="titleinexample"><a id="BABJGHAI"></a>Example 6-3 SQL%FOUND Implicit Cursor Attribute</p>
<pre dir="ltr">
DROP TABLE dept_temp;
CREATE TABLE dept_temp AS
  SELECT * FROM departments;
 
CREATE OR REPLACE PROCEDURE p (
  dept_no NUMBER
) AUTHID DEFINER AS
BEGIN
  DELETE FROM dept_temp
  WHERE department_id = dept_no;
 
  IF <span class="bold">SQL%FOUND</span> THEN
    DBMS_OUTPUT.PUT_LINE (
      'Delete succeeded for department number ' || dept_no
    );
  ELSE
    DBMS_OUTPUT.PUT_LINE ('No department number ' || dept_no);
  END IF;
END;
/
BEGIN
  p(270);
  p(400);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Delete succeeded for department number 270
No department number 400
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHHHFFF"></a>
<div id="LNPLS527" class="sect3">
<h4 class="sect3">SQL%NOTFOUND Attribute: Were No Rows Affected?</h4>
<p><a id="sthref502"></a><a id="sthref503"></a><a id="sthref504"></a><code dir="ltr">SQL%NOTFOUND</code> (the logical opposite of <code dir="ltr">SQL%FOUND</code>) returns:</p>
<ul>
<li>
<p><code dir="ltr">NULL</code> if no <code dir="ltr">SELECT</code> or DML statement has run</p>
</li>
<li>
<p><code dir="ltr">FALSE</code> if a <code dir="ltr">SELECT</code> statement returned one or more rows or a DML statement affected one or more rows</p>
</li>
<li>
<p><code dir="ltr">TRUE</code> otherwise</p>
</li>
</ul>
<p>The <code dir="ltr">SQL%NOTFOUND</code> attribute is not useful with the PL/SQL <a id="sthref505"></a><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement, because:</p>
<ul>
<li>
<p>If the <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement returns no rows, PL/SQL raises the predefined exception <code dir="ltr">NO_DATA_FOUND</code> immediately, before you can check <code dir="ltr">SQL%NOTFOUND</code>.</p>
</li>
<li>
<p>A <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement that invokes a SQL <a id="sthref506"></a>aggregate function always returns a value (possibly <code dir="ltr">NULL</code>). After such a statement, the <code dir="ltr">SQL%NOTFOUND</code> attribute is always <code dir="ltr">FALSE</code>, so checking it is unnecessary.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIHJJJDG"></a>
<div id="LNPLS528" class="sect3">
<h4 class="sect3">SQL%ROWCOUNT Attribute: How Many Rows Were Affected?</h4>
<p><a id="sthref507"></a><a id="sthref508"></a><a id="sthref509"></a><code dir="ltr">SQL%ROWCOUNT</code> returns:</p>
<ul>
<li>
<p><code dir="ltr">NULL</code> if no <code dir="ltr">SELECT</code> or DML statement has run</p>
</li>
<li>
<p>Otherwise, the number of rows returned by a <code dir="ltr">SELECT</code> statement or affected by a DML statement (a <code dir="ltr">PLS_INTEGER</code>)</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the number of rows exceeds the maximum value for a <code dir="ltr">PLS_INTEGER</code>, then <code dir="ltr">SQL%ROWCOUNT</code> returns a negative value. For information about <code dir="ltr">PLS_INTEGER</code>, see <a href="datatypes.htm#i10726">"PLS_INTEGER and BINARY_INTEGER Data Types"</a>.</div>
</li>
</ul>
<p><a href="#BABJCAAG">Example 6-4</a> uses <code dir="ltr">SQL%ROWCOUNT</code> to determine the number of rows that were deleted.</p>
<div id="LNPLS529" class="example">
<p class="titleinexample"><a id="BABJCAAG"></a>Example 6-4 SQL%ROWCOUNT Implicit Cursor Attribute</p>
<pre dir="ltr">
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT * FROM employees;

DECLARE
  mgr_no NUMBER(6) := 122;
BEGIN
  DELETE FROM employees_temp WHERE manager_id = mgr_no;
  DBMS_OUTPUT.PUT_LINE
    ('Number of employees deleted: ' || TO_CHAR(<span class="bold">SQL%ROWCOUNT</span>));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Number of employees deleted: 8
</pre></div>
<!-- class="example" -->
<p>If a <a id="sthref510"></a><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement without a <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause returns multiple rows, PL/SQL raises the predefined exception <code dir="ltr">TOO_MANY_ROWS</code> and <code dir="ltr">SQL%ROWCOUNT</code> returns 1, not the actual number of rows that satisfy the query.</p>
<p>The value of <code dir="ltr">SQL%ROWCOUNT</code> attribute is unrelated to the state of a <a id="sthref511"></a>transaction. Therefore:</p>
<ul>
<li>
<p>When a transaction rolls back to a savepoint, the value of <code dir="ltr">SQL%ROWCOUNT</code> is not restored to the value it had before the savepoint.</p>
</li>
<li>
<p>When an autonomous transaction ends, <code dir="ltr">SQL%ROWCOUNT</code> is not restored to the original value in the parent transaction.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHCAHJA"></a>
<div id="LNPLS99956" class="sect2">
<h3 class="sect2">Explicit Cursors</h3>
<p>An <a id="sthref512"></a><span class="bold">explicit cursor</span> is a session cursor that you construct and manage. You must declare and define an explicit cursor, giving it a name and associating it with a query (typically, the query returns multiple rows). Then you can process the query result set in either of these ways:</p>
<ul>
<li>
<p>Open the explicit cursor (with the <code dir="ltr">OPEN</code> statement), fetch rows from the result set (with the <code dir="ltr">FETCH</code> statement), and close the explicit cursor (with the <code dir="ltr">CLOSE</code> statement).</p>
</li>
<li>
<p>Use the explicit cursor in a cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement (see <a href="#CIHCGJAD">"Query Result Set Processing With Cursor FOR LOOP Statements"</a>).</p>
</li>
</ul>
<p>You cannot assign a value to an explicit cursor, use it in an expression, or use it as a formal subprogram parameter or host variable. You <span class="italic">can</span> do those things with a cursor variable (see <a href="#i7106">"Cursor Variables"</a>).</p>
<p>Unlike an implicit cursor, you can reference an explicit cursor or cursor variable by its name. Therefore, an explicit cursor or cursor variable is called a <a id="sthref513"></a><a id="sthref514"></a><span class="bold">named cursor</span>.</p>
<p class="subhead2"><a id="LNPLS481"></a>Topics</p>
<ul>
<li>
<p><a href="#BABHEBAI">Declaring and Defining Explicit Cursors</a></p>
</li>
<li>
<p><a href="#CIHBJJJH">Opening and Closing Explicit Cursors</a></p>
</li>
<li>
<p><a href="#BABJIICC">Fetching Data with Explicit Cursors</a></p>
</li>
<li>
<p><a href="#BABIHHAF">Variables in Explicit Cursor Queries</a></p>
</li>
<li>
<p><a href="#i28378">When Explicit Cursor Queries Need Column Aliases</a></p>
</li>
<li>
<p><a href="#CIHFAHFE">Explicit Cursors that Accept Parameters</a></p>
</li>
<li>
<p><a href="#CIHJGBAG">Explicit Cursor Attributes</a></p>
</li>
</ul>
<a id="BABHEBAI"></a>
<div id="LNPLS531" class="sect3">
<h4 class="sect3">Declaring and Defining Explicit Cursors</h4>
<p>You can either declare an explicit cursor first and then define it later in the same block, subprogram, or package, or declare and define it at the same time.</p>
<p>An <span class="bold">explicit cursor declaration</span>, which only declares a cursor, has this syntax:</p>
<pre dir="ltr">
CURSOR <span class="italic">cursor_name</span> [ <span class="italic">parameter_list</span> ] RETURN <span class="italic">return_type</span>;
</pre>
<p>An <span class="bold">explicit cursor definition</span> has this syntax:</p>
<pre dir="ltr">
CURSOR <span class="italic">cursor_name</span> [ <span class="italic">parameter_list</span> ] [ RETURN <span class="italic">return_type</span> ]
  IS <span class="italic">select_statement</span>;
</pre>
<p>If you declared the cursor earlier, then the explicit cursor definition defines it; otherwise, it both declares and defines it.</p>
<p><a href="#BABHICAF">Example 6-5</a> declares and defines three explicit cursors.</p>
<div id="LNPLS532" class="example">
<p class="titleinexample"><a id="BABHICAF"></a>Example 6-5 Explicit Cursor Declaration and Definition</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 RETURN departments%ROWTYPE;    -- Declare c1
 
  CURSOR c2 IS                             -- Declare and define c2
    SELECT employee_id, job_id, salary FROM employees
    WHERE salary &gt; 2000; 
 
  CURSOR c1 RETURN departments%ROWTYPE IS  -- Define c1,
    SELECT * FROM departments              -- repeating return type
    WHERE department_id = 110;
 
  CURSOR c3 RETURN locations%ROWTYPE;      -- Declare c3
 
  CURSOR c3 IS                             -- Define c3,
    SELECT * FROM locations                -- omitting return type
    WHERE country_id = 'JP';
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="explicit_cursor.htm#i33637">"Explicit Cursor Declaration and Definition"</a> for the complete syntax and semantics of explicit cursor declaration and definition</p>
</li>
<li>
<p><a href="#CIHFAHFE">"Explicit Cursors that Accept Parameters"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CIHBJJJH"></a>
<div id="LNPLS533" class="sect3">
<h4 class="sect3">Opening and Closing Explicit Cursors</h4>
<p>After declaring and defining an explicit cursor, you can open it with the <code dir="ltr">OPEN</code> statement, which does the following:</p>
<ol>
<li>
<p>Allocates database resources to process the query</p>
</li>
<li>
<p>Processes the query; that is:</p>
<ol>
<li>
<p>Identifies the result set</p>
<p>If the query references variables or cursor parameters, their values affect the result set. For details, see <a href="#BABIHHAF">"Variables in Explicit Cursor Queries"</a> and <a href="#CIHFAHFE">"Explicit Cursors that Accept Parameters"</a>.</p>
</li>
<li>
<p>If the query has a <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause, locks the rows of the result set</p>
<p>For details, see <a href="#CIHHIIID">"SELECT FOR UPDATE and FOR UPDATE Cursors"</a>.</p>
</li>
</ol>
</li>
<li>
<p>Positions the cursor before the first row of the result set</p>
</li>
</ol>
<p>You close an open explicit cursor with the <code dir="ltr">CLOSE</code> statement, thereby allowing its resources to be reused. After closing a cursor, you cannot fetch records from its result set or reference its attributes. If you try, PL/SQL raises the predefined exception <code dir="ltr">INVALID_CURSOR</code>.</p>
<p>You can reopen a closed cursor. You must close an explicit cursor before you try to reopen it. Otherwise, PL/SQL raises the predefined exception <code dir="ltr">CURSOR_ALREADY_OPEN</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="open_statement.htm#i35173">"OPEN Statement"</a> for its syntax and semantics</p>
</li>
<li>
<p><a href="close_statement.htm#i32987">"CLOSE Statement"</a> for its syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABJIICC"></a>
<div id="LNPLS534" class="sect3">
<h4 class="sect3">Fetching Data with Explicit Cursors</h4>
<p>After opening an explicit cursor, you can fetch the rows of the query result set with the <code dir="ltr">FETCH</code> statement. The basic syntax of a <a id="sthref515"></a><code dir="ltr">FETCH</code> statement that returns one row is:</p>
<pre dir="ltr">
FETCH <span class="italic">cursor_name</span> INTO <span class="italic">into_clause</span>
</pre>
<p>The <code dir="ltr"><span class="codeinlineitalic">into_clause</span></code> is either a list of variables or a single record variable. For each column that the query returns, the variable list or record must have a corresponding type-compatible variable or field. The <code dir="ltr">%TYPE</code> and <code dir="ltr">%ROWTYPE</code> attributes are useful for declaring variables and records for use in <code dir="ltr">FETCH</code> statements.</p>
<p>The <code dir="ltr">FETCH</code> statement retrieves the current row of the result set, stores the column values of that row into the variables or record, and advances the cursor to the next row.</p>
<p>Typically, you use the <code dir="ltr">FETCH</code> statement inside a <code dir="ltr">LOOP</code> statement, which you exit when the <code dir="ltr">FETCH</code> statement runs out of rows. To detect this exit condition, use the cursor attribute <code dir="ltr">%NOTFOUND</code> (described in <a href="#CIHIDGCI">"%NOTFOUND Attribute: Has No Row Been Fetched?"</a>). PL/SQL does not raise an exception when a <a id="sthref516"></a><code dir="ltr">FETCH</code> statement returns no rows.</p>
<p><a href="#BABCFDJE">Example 6-6</a> fetches the result sets of two explicit cursors one row at a time, using <code dir="ltr">FETCH</code> and <code dir="ltr">%NOTFOUND</code> inside <code dir="ltr">LOOP</code> statements. The first <code dir="ltr">FETCH</code> statement retrieves column values into variables. The second <code dir="ltr">FETCH</code> statement retrieves column values into a record. The variables and record are declared with <code dir="ltr">%TYPE</code> and <code dir="ltr">%ROWTYPE</code>, respectively.</p>
<div id="LNPLS535" class="example">
<p class="titleinexample"><a id="BABCFDJE"></a>Example 6-6 FETCH Statements Inside LOOP Statements</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id FROM employees
    WHERE REGEXP_LIKE (job_id, 'S[HT]_CLERK')
    ORDER BY last_name;

  v_lastname  employees.last_name<span class="bold">%TYPE</span>;  -- variable for last_name
  v_jobid     employees.job_id<span class="bold">%TYPE</span>;     -- variable for job_id

  CURSOR c2 IS
    SELECT * FROM employees
    WHERE REGEXP_LIKE (job_id, '[ACADFIMKSA]_M[ANGR]')
    ORDER BY job_id;

  v_employees employees<span class="bold">%ROWTYPE</span>;  -- record variable for row of table

BEGIN
  OPEN c1;
  <span class="bold">LOOP</span>  -- Fetches 2 columns into variables
    <span class="bold">FETCH c1 INTO v_lastname, v_jobid;</span>
    <span class="bold">EXIT WHEN c1%NOTFOUND;</span>
    DBMS_OUTPUT.PUT_LINE( RPAD(v_lastname, 25, ' ') || v_jobid );
  <span class="bold">END LOOP;</span>
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE( '-------------------------------------' );

  OPEN c2;
  <span class="bold">LOOP</span>  -- Fetches entire row into the v_employees record
    <span class="bold">FETCH c2 INTO v_employees;</span>
    <span class="bold">EXIT WHEN c2%NOTFOUND;</span>
    DBMS_OUTPUT.PUT_LINE( RPAD(v_employees.last_name, 25, ' ') ||
                               v_employees.job_id );
  <span class="bold">END LOOP;</span>
  CLOSE c2;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Atkinson                 ST_CLERK
Bell                     SH_CLERK
Bissot                   ST_CLERK
...
Walsh                    SH_CLERK
-------------------------------------
Higgins                  AC_MGR
Greenberg                FI_MGR
Hartstein                MK_MAN
...
Zlotkey                  SA_MAN
</pre></div>
<!-- class="example" -->
<p><a href="#CJADGBJE">Example 6-7</a> fetches the first five rows of a result set into five records, using five <code dir="ltr">FETCH</code> statements, each of which fetches into a different record variable. The record variables are declared with <code dir="ltr">%ROWTYPE</code>.</p>
<div id="LNPLS537" class="example">
<p class="titleinexample"><a id="CJADGBJE"></a>Example 6-7 Fetching Same Explicit Cursor into Different Variables</p>
<pre dir="ltr">
DECLARE
  CURSOR c IS
    SELECT e.job_id, j.job_title
    FROM employees e, jobs j
    WHERE e.job_id = j.job_id AND e.manager_id = 100
    ORDER BY last_name;
 
  -- Record variables for rows of cursor result set:
 
  job1 c<span class="bold">%ROWTYPE</span>;
  job2 c<span class="bold">%ROWTYPE</span>;
  job3 c<span class="bold">%ROWTYPE</span>;
  job4 c<span class="bold">%ROWTYPE</span>;
  job5 c<span class="bold">%ROWTYPE</span>;
 
BEGIN
  OPEN c;
  <span class="bold">FETCH c INTO job1;</span>  -- fetches first row
  <span class="bold">FETCH c INTO job2;</span>  -- fetches second row
  <span class="bold">FETCH c INTO job3;</span>  -- fetches third row
  <span class="bold">FETCH c INTO job4;</span>  -- fetches fourth row
  <span class="bold">FETCH c INTO job5;</span>  -- fetches fifth row
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE(job1.job_title || ' (' || job1.job_id || ')');
  DBMS_OUTPUT.PUT_LINE(job2.job_title || ' (' || job2.job_id || ')');
  DBMS_OUTPUT.PUT_LINE(job3.job_title || ' (' || job3.job_id || ')');
  DBMS_OUTPUT.PUT_LINE(job4.job_title || ' (' || job4.job_id || ')');
  DBMS_OUTPUT.PUT_LINE(job5.job_title || ' (' || job5.job_id || ')');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Sales Manager (SA_MAN)
Administration Vice President (AD_VP)
Sales Manager (SA_MAN)
Stock Manager (ST_MAN)
Marketing Manager (MK_MAN)

PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="fetch_statement.htm#i34221">"FETCH Statement"</a> for its complete syntax and semantics</p>
</li>
<li>
<p><a href="tuning.htm#BCGGAGIF">"FETCH Statement with BULK COLLECT Clause"</a> for information about <code dir="ltr">FETCH</code> statements that return more than one row at a time</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABIHHAF"></a>
<div id="LNPLS99879" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Variables in Explicit Cursor Queries</h4>
<p>An explicit cursor query can reference any <a id="sthref517"></a>variable in its scope. When you open an explicit cursor, PL/SQL evaluates any variables in the query and uses those values when identifying the result set. Changing the values of the variables later does not change the result set.</p>
<p>In <a href="#CJAJAIFF">Example 6-8</a>, the explicit cursor query references the variable <code dir="ltr">factor</code>. When the cursor opens, <code dir="ltr">factor</code> has the value 2. Therefore, <code dir="ltr">sal_multiple</code> is always 2 times <code dir="ltr">sal</code>, despite that <code dir="ltr">factor</code> is incremented after every fetch.</p>
<div id="LNPLS536" class="example">
<p class="titleinexample"><a id="CJAJAIFF"></a>Example 6-8 Variable in Explicit Cursor Query&mdash;No Result Set Change</p>
<pre dir="ltr">
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  <span class="bold">factor        INTEGER := 2;</span>
 
  CURSOR c1 IS
    SELECT salary, salary*<span class="bold">factor</span> FROM employees
    WHERE job_id LIKE 'AD_%';
 
BEGIN
  <span class="bold">OPEN c1;  -- PL/SQL evaluates factor</span>
 
  LOOP
    <span class="bold">FETCH c1 INTO sal, sal_multiple;</span>
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('factor = ' || factor);
    DBMS_OUTPUT.PUT_LINE('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE('sal_multiple = ' || sal_multiple);
    <span class="bold">factor := factor + 1;  -- Does not affect sal_multiple</span>
  END LOOP;
 
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
factor = 2
sal          = 4451
sal_multiple = 8902
factor = 3
sal          = 26460
sal_multiple = 52920
factor = 4
sal          = 18742.5
sal_multiple = 37485
factor = 5
sal          = 18742.5
sal_multiple = 37485
</pre></div>
<!-- class="example" -->
<p>To change the result set, you must close the cursor, change the value of the variable, and then open the cursor again, as in <a href="#BABCAAFB">Example 6-9</a>.</p>
<div id="LNPLS482" class="example">
<p class="titleinexample"><a id="BABCAAFB"></a>Example 6-9 Variable in Explicit Cursor Query&mdash;Result Set Change</p>
<pre dir="ltr">
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  factor        INTEGER := 2;
 
  CURSOR c1 IS
    SELECT salary, salary*factor FROM employees
    WHERE job_id LIKE 'AD_%';
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('factor = ' || factor);
  <span class="bold">OPEN c1;  -- PL/SQL evaluates factor</span>
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE('sal_multiple = ' || sal_multiple);
  END LOOP;
  <span class="bold">CLOSE c1;</span>
 
  <span class="bold">factor := factor + 1;</span>
 
  DBMS_OUTPUT.PUT_LINE('factor = ' || factor);
  <span class="bold">OPEN c1;  -- PL/SQL evaluates factor</span>
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE('sal_multiple = ' || sal_multiple);
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
factor = 2
sal          = 4451
sal_multiple = 8902
sal          = 26460
sal_multiple = 52920
sal          = 18742.5
sal_multiple = 37485
sal          = 18742.5
sal_multiple = 37485
factor = 3
sal          = 4451
sal_multiple = 13353
sal          = 26460
sal_multiple = 79380
sal          = 18742.5
sal_multiple = 56227.5
sal          = 18742.5
sal_multiple = 56227.5
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i28378"></a>
<div id="LNPLS225" class="sect3">
<h4 class="sect3">When Explicit Cursor Queries Need Column Aliases</h4>
<p>When an <a id="sthref518"></a><a id="sthref519"></a>explicit cursor query includes a <a id="sthref520"></a><a id="sthref521"></a>virtual column (an expression), that column must have an alias if either of the following is true:</p>
<ul>
<li>
<p>You use the cursor to fetch into a record that was declared with <a id="sthref522"></a><a id="sthref523"></a><code dir="ltr">%ROWTYPE</code>.</p>
</li>
<li>
<p>You want to reference the virtual column in your program.</p>
</li>
</ul>
<p>In <a href="#CHDCEGIF">Example 6-10</a>, the virtual column in the explicit cursor needs an alias for both of the preceding reasons.</p>
<div id="LNPLS483" class="example">
<p class="titleinexample"><a id="CHDCEGIF"></a>Example 6-10 Explicit Cursor with Virtual Column that Needs Alias</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT employee_id,
           <span class="bold">(salary * .05) raise</span>
    FROM employees
    WHERE job_id LIKE '%_MAN'
    ORDER BY employee_id;
  <span class="bold">emp_rec c1%ROWTYPE;</span>
BEGIN
  OPEN c1;
  LOOP
    <span class="bold">FETCH c1 INTO emp_rec;</span>
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (
      'Raise for employee #' || emp_rec.employee_id ||
      ' is $' || <span class="bold">emp_rec.raise</span>
    ); 
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Raise for employee #114 is $550
Raise for employee #120 is $533.61
Raise for employee #121 is $520.905
Raise for employee #122 is $501.8475
Raise for employee #123 is $412.9125
Raise for employee #124 is $368.445
Raise for employee #145 is $700
Raise for employee #146 is $675
Raise for employee #147 is $600
Raise for employee #148 is $550
Raise for employee #149 is $525
Raise for employee #201 is $650
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJAIBIDJ">Example 6-21, "Cursor FOR Loop References Virtual Columns"</a></div>
</div>
<!-- class="sect3" -->
<a id="CIHFAHFE"></a>
<div id="LNPLS564" class="sect3">
<h4 class="sect3">Explicit Cursors that Accept Parameters</h4>
<p>You can create an explicit cursor that has formal <a id="sthref524"></a><a id="sthref525"></a>parameters, and then pass different actual parameters to the cursor each time you open it. In the cursor query, you can use a formal cursor parameter anywhere that you can use a constant. Outside the cursor query, you cannot reference formal cursor parameters.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
To avoid confusion, use different names for formal and actual cursor parameters.</div>
<p><a href="#BABHBHIC">Example 6-11</a> creates an explicit cursor whose two formal parameters represent a job and its maximum salary. When opened with a specified job and maximum salary, the cursor query selects the employees with that job who are overpaid (for each such employee, the query selects the first and last name and amount overpaid). Next, the example creates a procedure that prints the cursor query result set (for information about procedures, see <a href="subprograms.htm#CHDBEJGF">Chapter 8, "PL/SQL Subprograms"</a>). Finally, the example opens the cursor with one set of actual parameters, prints the result set, closes the cursor, opens the cursor with different actual parameters, prints the result set, and closes the cursor.</p>
<div id="LNPLS484" class="example">
<p class="titleinexample"><a id="BABHBHIC"></a>Example 6-11 Explicit Cursor that Accepts Parameters</p>
<pre dir="ltr">
DECLARE
  CURSOR c <span class="bold">(job VARCHAR2, max_sal NUMBER)</span> IS
    SELECT last_name, first_name, (salary - <span class="bold">max_sal</span>) overpayment
    FROM employees
    WHERE job_id = <span class="bold">job</span>
    AND salary &gt; <span class="bold">max_sal</span>
    ORDER BY salary;
 
  PROCEDURE print_overpaid IS
    last_name_   employees.last_name%TYPE;
    first_name_  employees.first_name%TYPE;
    overpayment_      employees.salary%TYPE;
  BEGIN
    LOOP
      FETCH c INTO last_name_, first_name_, overpayment_;
      EXIT WHEN c%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(last_name_ || ', ' || first_name_ ||
        ' (by ' || overpayment_ || ')');
    END LOOP;
  END print_overpaid;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('----------------------');
  DBMS_OUTPUT.PUT_LINE('Overpaid Stock Clerks:');
  DBMS_OUTPUT.PUT_LINE('----------------------');
  <span class="bold">OPEN c('ST_CLERK', 5000);</span>
  print_overpaid; 
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE('-------------------------------');
  DBMS_OUTPUT.PUT_LINE('Overpaid Sales Representatives:');
  DBMS_OUTPUT.PUT_LINE('-------------------------------');
  <span class="bold">OPEN c('SA_REP', 10000);</span>
  print_overpaid; 
  CLOSE c;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
----------------------
Overpaid Stock Clerks:
----------------------
Davies, Curtis (by 15.3)
Nayer, Julia (by 177.08)
Stiles, Stephen (by 177.08)
Bissot, Laura (by 338.87)
Mallin, Jason (by 338.87)
Rajs, Trenna (by 662.43)
Ladwig, Renske (by 824.21)
-------------------------------
Overpaid Sales Representatives:
-------------------------------
Fox, Tayler (by 80)
Tucker, Peter (by 500)
King, Janette (by 500)
Bloom, Harrison (by 500)
Vishney, Clara (by 1025)
Abel, Ellen (by 1550)
Ozer, Lisa (by 2075)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS485"></a>Topics</p>
<ul>
<li>
<p><a href="#BABGDDEI">Formal Cursor Parameters with Default Values</a></p>
</li>
<li>
<p><a href="#BABBIFDA">Adding Formal Cursor Parameters with Default Values</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="explicit_cursor.htm#i33637">"Explicit Cursor Declaration and Definition"</a> for more information about formal cursor parameters</p>
</li>
<li>
<p><a href="open_statement.htm#i35173">"OPEN Statement"</a> for more information about actual cursor parameters</p>
</li>
</ul>
</div>
<a id="BABGDDEI"></a>
<div id="LNPLS99874" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Formal Cursor Parameters with Default Values</h5>
<p>When you create an explicit cursor with formal parameters, you can specify <a id="sthref526"></a>default values for them. When a formal parameter has a default value, its corresponding actual parameter is optional. If you open the cursor without specifying the actual parameter, then the formal parameter has its default value.</p>
<p><a href="#BABHCIAC">Example 6-12</a> creates an explicit cursor whose formal parameter represents a location ID. The default value of the parameter is the location ID of company headquarters.</p>
<div id="LNPLS487" class="example">
<p class="titleinexample"><a id="BABHCIAC"></a>Example 6-12 Cursor Parameters with Default Values</p>
<pre dir="ltr">
DECLARE
  CURSOR c (<span class="bold">location</span> NUMBER <span class="bold">DEFAULT 1700</span>) IS
    SELECT d.department_name,
           e.last_name manager,
           l.city
    FROM departments d, employees e, locations l
    WHERE l.location_id = <span class="bold">location</span>
      AND l.location_id = d.location_id
      AND d.department_id = e.department_id
    ORDER BY d.department_id;
 
  PROCEDURE print_depts IS
    dept_name  departments.department_name%TYPE;
    mgr_name   employees.last_name%TYPE;
    city_name  locations.city%TYPE;
  BEGIN
    LOOP
      FETCH c INTO dept_name, mgr_name, city_name;
      EXIT WHEN c%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(dept_name || ' (Manager: ' || mgr_name || ')');
    END LOOP;
  END print_depts;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('DEPARTMENTS AT HEADQUARTERS:');
  DBMS_OUTPUT.PUT_LINE('--------------------------------');
  <span class="bold">OPEN c;</span>
  print_depts; 
  DBMS_OUTPUT.PUT_LINE('--------------------------------');
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE('DEPARTMENTS IN CANADA:');
  DBMS_OUTPUT.PUT_LINE('--------------------------------');
  <span class="bold">OPEN c(1800);</span> -- Toronto
  print_depts; 
  CLOSE c;
  <span class="bold">OPEN c(1900);</span> -- Whitehorse
  print_depts; 
  CLOSE c;
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
DEPARTMENTS AT HEADQUARTERS:
--------------------------------
Administration (Manager: Whalen)
Purchasing (Manager: Colmenares)
Purchasing (Manager: Baida)
Purchasing (Manager: Himuro)
Purchasing (Manager: Raphaely)
Purchasing (Manager: Khoo)
Purchasing (Manager: Tobias)
Executive (Manager: Kochhar)
Executive (Manager: De Haan)
Executive (Manager: King)
Finance (Manager: Popp)
Finance (Manager: Greenberg)
Finance (Manager: Faviet)
Finance (Manager: Chen)
Finance (Manager: Urman)
Finance (Manager: Sciarra)
Accounting (Manager: Gietz)
Accounting (Manager: Higgins)
--------------------------------
DEPARTMENTS IN CANADA:
--------------------------------
Marketing (Manager: Hartstein)
Marketing (Manager: Fay)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="BABBIFDA"></a>
<div id="LNPLS99873" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Adding Formal Cursor Parameters with Default Values</h5>
<p>If you add formal parameters to a cursor, and you specify default values for the added parameters, then you need not change existing references to the cursor. Compare <a href="#BABCBJGC">Example 6-13</a> to <a href="#BABHBHIC">Example 6-11</a>.</p>
<div id="LNPLS488" class="example">
<p class="titleinexample"><a id="BABCBJGC"></a>Example 6-13 Adding Formal Parameter to Existing Cursor</p>
<pre dir="ltr">
DECLARE
  CURSOR c (job VARCHAR2, max_sal NUMBER, <span class="bold">hired DATE DEFAULT '31-DEC-99'</span>) IS
    SELECT last_name, first_name, (salary - max_sal) overpayment
    FROM employees
    WHERE job_id = job
    AND salary &gt; max_sal
    <span class="bold">AND hire_date &gt; hired</span>
    ORDER BY salary;
 
  PROCEDURE print_overpaid IS
    last_name_   employees.last_name%TYPE;
    first_name_  employees.first_name%TYPE;
    overpayment_      employees.salary%TYPE;
  BEGIN
    LOOP
      FETCH c INTO last_name_, first_name_, overpayment_;
      EXIT WHEN c%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE(last_name_ || ', ' || first_name_ ||
        ' (by ' || overpayment_ || ')');
    END LOOP;
  END print_overpaid;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('-------------------------------');
  DBMS_OUTPUT.PUT_LINE('Overpaid Sales Representatives:');
  DBMS_OUTPUT.PUT_LINE('-------------------------------');
  OPEN c('SA_REP', 10000);  <span class="bold">-- existing reference</span>
  print_overpaid; 
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE('------------------------------------------------');
  DBMS_OUTPUT.PUT_LINE('Overpaid Sales Representatives Hired After 2004:');
  DBMS_OUTPUT.PUT_LINE('------------------------------------------------');
  OPEN c('SA_REP', 10000, <span class="bold">'31-DEC-04'</span>);  <span class="bold">-- new reference</span>
  print_overpaid; 
  CLOSE c;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
-------------------------------
Overpaid Sales Representatives:
-------------------------------
Fox, Tayler (by 80)
Tucker, Peter (by 500)
King, Janette (by 500)
Bloom, Harrison (by 500)
Vishney, Clara (by 1025)
Abel, Ellen (by 1550)
Ozer, Lisa (by 2075)
------------------------------------------------
Overpaid Sales Representatives Hired After 2004:
------------------------------------------------
Fox, Tayler (by 80)
Tucker, Peter (by 500)
Bloom, Harrison (by 500)
Vishney, Clara (by 1025)
Ozer, Lisa (by 2075)
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CIHJGBAG"></a>
<div id="LNPLS541" class="sect3">
<h4 class="sect3">Explicit Cursor Attributes</h4>
<p>The syntax for the value of an <a id="sthref527"></a>explicit cursor attribute is <code dir="ltr"><span class="codeinlineitalic">cursor_name</span></code> immediately followed by <code dir="ltr"><span class="codeinlineitalic">attribute</span></code> (for example, <code dir="ltr">c1%ISOPEN</code>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Explicit cursors and cursor variables (named cursors) have the same attributes. This topic applies to all named cursors except where noted.</div>
<p>The explicit cursor attributes are:</p>
<ul>
<li>
<p><a href="#CIHGFFBD">%ISOPEN Attribute: Is the Cursor Open?</a></p>
</li>
<li>
<p><a href="#CIHGFHDG">%FOUND Attribute: Has a Row Been Fetched?</a></p>
</li>
<li>
<p><a href="#CIHIDGCI">%NOTFOUND Attribute: Has No Row Been Fetched?</a></p>
</li>
<li>
<p><a href="#CIHDGDBF">%ROWCOUNT Attribute: How Many Rows Were Fetched?</a></p>
</li>
</ul>
<p>If an explicit cursor is not open, referencing any attribute except <code dir="ltr">%ISOPEN</code> raises the predefined exception <code dir="ltr">INVALID_CURSOR</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cursor_attribute.htm#i33378">"Named Cursor Attribute"</a> for complete syntax and semantics of named cursor (explicit cursor and cursor variable) attributes</div>
<a id="CIHGFFBD"></a>
<div id="LNPLS544" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">%ISOPEN Attribute: Is the Cursor Open?</h5>
<p><a id="sthref528"></a><a id="sthref529"></a><code dir="ltr">%ISOPEN</code> returns <code dir="ltr">TRUE</code> if its explicit cursor is open; <code dir="ltr">FALSE</code> otherwise.</p>
<p><code dir="ltr">%ISOPEN</code> is useful for:</p>
<ul>
<li>
<p>Checking that an explicit cursor is not already open before you try to open it.</p>
<p>If you try to open an explicit cursor that is already open, PL/SQL raises the predefined exception <code dir="ltr">CURSOR_ALREADY_OPEN</code>. You must close an explicit cursor before you can reopen it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The preceding paragraph does not apply to cursor variables.</div>
</li>
<li>
<p>Checking that an explicit cursor is open before you try to close it.</p>
</li>
</ul>
<p><a href="#BABJHBGA">Example 6-14</a> opens the explicit cursor <code dir="ltr">c1</code> only if it is not open and closes it only if it is open.</p>
<div id="LNPLS545" class="example">
<p class="titleinexample"><a id="BABJHBGA"></a>Example 6-14 %ISOPEN Explicit Cursor Attribute</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11;

  the_name employees.last_name%TYPE;
  the_salary employees.salary%TYPE;
BEGIN
  IF <span class="bold">NOT c1%ISOPEN</span> THEN
    OPEN c1;
  END IF;

  FETCH c1 INTO the_name, the_salary;

  IF <span class="bold">c1%ISOPEN</span> THEN
    CLOSE c1;
  END IF;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CIHGFHDG"></a>
<div id="LNPLS542" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">%FOUND Attribute: Has a Row Been Fetched?</h5>
<p><a id="sthref530"></a><a id="sthref531"></a><code dir="ltr">%FOUND</code> returns:</p>
<ul>
<li>
<p><code dir="ltr">NULL</code> after the explicit cursor is opened but before the first fetch</p>
</li>
<li>
<p><code dir="ltr">TRUE</code> if the most recent fetch from the explicit cursor returned a row</p>
</li>
<li>
<p><code dir="ltr">FALSE</code> otherwise</p>
</li>
</ul>
<p><code dir="ltr">%FOUND</code> is useful for determining whether there is a fetched row to process.</p>
<p><a href="#CJAEDJEE">Example 6-15</a> loops through a result set, printing each fetched row and exiting when there are no more rows to fetch.</p>
<div id="LNPLS543" class="example">
<p class="titleinexample"><a id="CJAEDJEE"></a>Example 6-15 %FOUND Explicit Cursor Attribute</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

  my_ename   employees.last_name%TYPE;
  my_salary  employees.salary%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_ename, my_salary;
    IF <span class="bold">c1%FOUND</span> THEN  -- fetch succeeded
      DBMS_OUTPUT.PUT_LINE('Name = ' || my_ename || ', salary = ' || my_salary);
    ELSE  -- fetch failed
      EXIT;
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Name = Abel, salary = 11000
Name = Ande, salary = 6400
Name = Atkinson, salary = 3557.4
Name = Austin, salary = 4800
Name = Baer, salary = 10000
Name = Baida, salary = 2900
Name = Banda, salary = 6200
Name = Bates, salary = 7300
Name = Bell, salary = 5082
Name = Bernstein, salary = 9500
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CIHIDGCI"></a>
<div id="LNPLS546" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">%NOTFOUND Attribute: Has No Row Been Fetched?</h5>
<p><a id="sthref532"></a><a id="sthref533"></a><code dir="ltr">%NOTFOUND</code> (the logical opposite of <code dir="ltr">%FOUND</code>) returns:</p>
<ul>
<li>
<p><code dir="ltr">NULL</code> after the explicit cursor is opened but before the first fetch</p>
</li>
<li>
<p><code dir="ltr">FALSE</code> if the most recent fetch from the explicit cursor returned a row</p>
</li>
<li>
<p><code dir="ltr">TRUE</code> otherwise</p>
</li>
</ul>
<p><code dir="ltr">%NOTFOUND</code> is useful for exiting a loop when <code dir="ltr">FETCH</code> fails to return a row, as in <a href="#CJAHDJIF">Example 6-16</a>.</p>
<div id="LNPLS547" class="example">
<p class="titleinexample"><a id="CJAHDJIF"></a>Example 6-16 %NOTFOUND Explicit Cursor Attribute</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

   my_ename   employees.last_name%TYPE;
   my_salary  employees.salary%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_ename, my_salary;
    IF <span class="bold">c1%NOTFOUND</span> THEN -- fetch failed
      EXIT;
    ELSE  -- fetch succeeded
      DBMS_OUTPUT.PUT_LINE
        ('Name = ' || my_ename || ', salary = ' || my_salary);
    END IF;
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Name = Abel, salary = 11000
Name = Ande, salary = 6400
Name = Atkinson, salary = 3557.4
Name = Austin, salary = 4800
Name = Baer, salary = 10000
Name = Baida, salary = 2900
Name = Banda, salary = 6200
Name = Bates, salary = 7300
Name = Bell, salary = 5082
Name = Bernstein, salary = 9500
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CIHDGDBF"></a>
<div id="LNPLS548" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">%ROWCOUNT Attribute: How Many Rows Were Fetched?</h5>
<p><a id="sthref534"></a><a id="sthref535"></a><code dir="ltr">%ROWCOUNT</code> returns:</p>
<ul>
<li>
<p>Zero after the explicit cursor is opened but before the first fetch</p>
</li>
<li>
<p>Otherwise, the number of rows fetched (a <code dir="ltr">PLS_INTEGER</code>)</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the number of rows exceeds the maximum value for a <code dir="ltr">PLS_INTEGER</code>, then <code dir="ltr">SQL%ROWCOUNT</code> returns a negative value. For information about <code dir="ltr">PLS_INTEGER</code>, see <a href="datatypes.htm#i10726">"PLS_INTEGER and BINARY_INTEGER Data Types"</a>.</div>
</li>
</ul>
<p><a href="#CJAFIFIB">Example 6-17</a> numbers and prints the rows that it fetches and prints a message after fetching the fifth row.</p>
<div id="LNPLS549" class="example">
<p class="titleinexample"><a id="CJAFIFIB"></a>Example 6-17 %ROWCOUNT Explicit Cursor Attribute</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

  name  employees.last_name%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO name;
    EXIT WHEN c1%NOTFOUND OR c1%NOTFOUND IS NULL;
    DBMS_OUTPUT.PUT_LINE(<span class="bold">c1%ROWCOUNT</span> || '. ' || name);
    <span class="bold">IF c1%ROWCOUNT = 5</span> THEN
       DBMS_OUTPUT.PUT_LINE('--- Fetched 5th row ---');
    END IF;
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
1. Abel
2. Ande
3. Atkinson
4. Austin
5. Baer
--- Fetched 5th row ---
6. Baida
7. Banda
8. Bates
9. Bell
10. Bernstein
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i45320"></a>
<div id="LNPLS00603" class="sect1">
<h2 class="sect1">Query Result Set Processing</h2>
<p>In PL/SQL, as in traditional database programming, you use cursors to <a id="sthref536"></a>process query result sets. However, in PL/SQL, you can use either implicit or explicit cursors. The former need less code, but the latter are more flexible. For example, explicit cursors can accept parameters (see <a href="#CIHFAHFE">"Explicit Cursors that Accept Parameters"</a>).</p>
<p>The following PL/SQL statements use implicit cursors that PL/SQL defines and manages for you:</p>
<ul>
<li>
<p><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code></p>
</li>
<li>
<p>Implicit cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code></p>
</li>
</ul>
<p>The following PL/SQL statements use explicit cursors:</p>
<ul>
<li>
<p>Explicit cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code></p>
<p>You define the explicit cursor, but PL/SQL manages it while the statement runs.</p>
</li>
<li>
<p><code dir="ltr">OPEN</code>, <code dir="ltr">FETCH</code>, and <code dir="ltr">CLOSE</code></p>
<p>You define and manage the explicit cursor.</p>
</li>
</ul>
<p class="subhead2"><a id="LNPLS489"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHCGIBF">Query Result Set Processing With SELECT INTO Statements</a></p>
</li>
<li>
<p><a href="#CIHCGJAD">Query Result Set Processing With Cursor FOR LOOP Statements</a></p>
</li>
<li>
<p><a href="#CIHBEEBG">Query Result Set Processing With Explicit Cursors, OPEN, FETCH, and CLOSE</a></p>
</li>
<li>
<p><a href="#i3317">Query Result Set Processing with Subqueries</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a query returns no rows, PL/SQL raises the exception <code dir="ltr">NO_DATA_FOUND</code>. For information about handling exceptions, see <a href="exception_handler.htm#i33826">"Exception Handler"</a>.</div>
<a id="CIHCGIBF"></a>
<div id="LNPLS551" class="sect2">
<h3 class="sect2">Query Result Set Processing With SELECT INTO Statements</h3>
<p>Using an <a id="sthref537"></a>implicit cursor, the <a id="sthref538"></a><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement retrieves values from one or more database tables (as the SQL <code dir="ltr">SELECT</code> statement does) and stores them in variables (which the SQL <code dir="ltr">SELECT</code> statement does not do).</p>
<p class="subhead2"><a id="LNPLS491"></a>Topics</p>
<ul>
<li>
<p><a href="#BABGJEJI">Single-Row Result Sets</a></p>
</li>
<li>
<p><a href="#BABBHFCC">Large Multiple-Row Result Sets</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="selectinto_statement.htm#i36066">"SELECT INTO Statement"</a> for its complete syntax and semantics</div>
<a id="BABGJEJI"></a>
<div id="LNPLS99881" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Single-Row Result Sets</h4>
<p>If you expect the query to return only one row, then use the <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement to store values from that row in either one or more scalar variables (see <a href="fundamentals.htm#CIHGGGGI">"Assigning Values to Variables with the SELECT INTO Statement"</a>) or one record variable (see <a href="composites.htm#CIHGFBBC">"SELECT INTO Statement for Assigning Row to Record Variable"</a>).</p>
<p>If the query might return multiple rows, but you care about only the <span class="italic">n</span>th row, then restrict the result set to that row with the clause <code dir="ltr">WHERE</code> <code dir="ltr">ROWNUM=</code><code dir="ltr"><span class="codeinlineitalic">n</span></code>. For more information about the <a id="sthref539"></a><code dir="ltr">ROWNUM</code> pseudocolumn, see <a class="olink SQLRF00255" href="../../server.112/e41084/pseudocolumns009.htm#SQLRF00255"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect3" -->
<a id="BABBHFCC"></a>
<div id="LNPLS99880" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Large Multiple-Row Result Sets</h4>
<p>If you must assign a large quantity of table data to variables, Oracle recommends using the <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement with the <a id="sthref540"></a><code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause. This statement retrieves an entire result set into one or more collection variables. For more information, see <a href="tuning.htm#BABEIACI">"SELECT INTO Statement with BULK COLLECT Clause"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHCGJAD"></a>
<div id="LNPLS553" class="sect2">
<h3 class="sect2">Query Result Set Processing With Cursor FOR LOOP Statements</h3>
<p>The <a id="sthref541"></a>cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement lets you run a <code dir="ltr">SELECT</code> statement and then immediately loop through the rows of the result set. This statement can use either an implicit or explicit cursor.</p>
<p>If you use the <code dir="ltr">SELECT</code> statement only in the cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement, then specify the <code dir="ltr">SELECT</code> statement inside the cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement, as in <a href="#CHDBJBJE">Example 6-18</a>. This form of the cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement uses an implicit cursor, and is called an <a id="sthref542"></a><span class="bold">implicit cursor</span> <code dir="ltr"><span class="codeinlinebold">FOR</span></code> <code dir="ltr"><span class="codeinlinebold">LOOP</span></code> <span class="bold">statement</span>. Because the implicit cursor is internal to the statement, you cannot reference it with the name <code dir="ltr">SQL</code>.</p>
<p>If you use the <code dir="ltr">SELECT</code> statement multiple times in the same PL/SQL unit, then define an explicit cursor for it and specify that cursor in the cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement, as in <a href="#BABGJBEA">Example 6-19</a>. This form of the cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement is called an <a id="sthref543"></a><span class="bold">explicit cursor</span> <code dir="ltr"><span class="codeinlinebold">FOR</span></code> <code dir="ltr"><span class="codeinlinebold">LOOP</span></code> <span class="bold">statement</span>. You can use the same explicit cursor elsewhere in the same PL/SQL unit.</p>
<p>The cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement implicitly declares its loop index as a <code dir="ltr">%ROWTYPE</code> record variable of the type that its cursor returns. This record is local to the loop and exists only during loop execution. Statements inside the loop can reference the record and its fields. They can reference virtual columns only by <a id="sthref544"></a><a id="sthref545"></a>aliases, as in <a href="#CJAIBIDJ">Example 6-21</a>.</p>
<p>After declaring the loop index record variable, the <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement opens the specified cursor. With each iteration of the loop, the <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement fetches a row from the result set and stores it in the record. When there are no more rows to fetch, the cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement closes the cursor. The cursor also closes if a statement inside the loop transfers control outside the loop or if PL/SQL raises an exception.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cursor_for_loop_statement.htm#CJABCJEA">"Cursor FOR LOOP Statement"</a> for its complete syntax and semantics</div>
<p>In <a href="#CHDBJBJE">Example 6-18</a>, an implicit cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement prints the last name and job ID of every clerk whose manager has an ID greater than 120.</p>
<div id="LNPLS493" class="example">
<p class="titleinexample"><a id="CHDBJBJE"></a>Example 6-18 Implicit Cursor FOR LOOP Statement</p>
<pre dir="ltr">
BEGIN
  FOR item IN (
    SELECT last_name, job_id
    FROM employees
    WHERE job_id LIKE '%CLERK%'
    AND manager_id &gt; 120
    ORDER BY last_name
  )
  LOOP
    DBMS_OUTPUT.PUT_LINE
      ('Name = ' || item.last_name || ', Job = ' || item.job_id);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Name = Atkinson, Job = ST_CLERK
Name = Bell, Job = SH_CLERK
Name = Bissot, Job = ST_CLERK
...
Name = Walsh, Job = SH_CLERK
</pre></div>
<!-- class="example" -->
<p><a href="#BABGJBEA">Example 6-19</a> is like <a href="#CHDBJBJE">Example 6-18</a>, except that it uses an explicit cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement.</p>
<div id="LNPLS494" class="example">
<p class="titleinexample"><a id="BABGJBEA"></a>Example 6-19 Explicit Cursor FOR LOOP Statement</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id FROM employees
    WHERE job_id LIKE '%CLERK%' AND manager_id &gt; 120
    ORDER BY last_name;
BEGIN
  FOR item IN c1
  LOOP
    DBMS_OUTPUT.PUT_LINE
      ('Name = ' || item.last_name || ', Job = ' || item.job_id);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Name = Atkinson, Job = ST_CLERK
Name = Bell, Job = SH_CLERK
Name = Bissot, Job = ST_CLERK
...
Name = Walsh, Job = SH_CLERK
</pre></div>
<!-- class="example" -->
<p><a href="#i45976">Example 6-20</a> declares and defines an explicit cursor that accepts two parameters, and then uses it in an explicit cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement to display the wages paid to employees who earn more than a specified wage in a specified department.</p>
<div id="LNPLS565" class="example">
<p class="titleinexample"><a id="i45976"></a>Example 6-20 Passing Parameters to Explicit Cursor FOR LOOP Statement</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 <span class="bold">(job VARCHAR2, max_wage NUMBER)</span> IS
    SELECT * FROM employees
    WHERE job_id = job
    AND salary &gt; max_wage;
BEGIN
  FOR person IN <span class="bold">c1('ST_CLERK', 3000)</span>
  LOOP
     -- process data record
    DBMS_OUTPUT.PUT_LINE (
      'Name = ' || person.last_name || ', salary = ' ||
      person.salary || ', Job Id = ' || person.job_id
    );
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Name = Nayer, salary = 4065.6, Job Id = ST_CLERK
Name = Mikkilineni, salary = 3430.35, Job Id = ST_CLERK
Name = Landry, salary = 3049.2, Job Id = ST_CLERK
...
Name = Vargas, salary = 3176.25, Job Id = ST_CLERK
</pre></div>
<!-- class="example" -->
<p>In <a href="#CJAIBIDJ">Example 6-21</a>, the implicit cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> references virtual columns by their aliases, <code dir="ltr">full_name</code> and <code dir="ltr">dream_salary</code>.</p>
<div id="LNPLS559" class="example">
<p class="titleinexample"><a id="CJAIBIDJ"></a>Example 6-21 Cursor FOR Loop References Virtual Columns</p>
<pre dir="ltr">
BEGIN
  FOR item IN (
    SELECT first_name || ' ' || last_name AS <span class="bold">full_name</span>,
           salary * 10                    AS <span class="bold">dream_salary</span> 
    FROM employees
    WHERE ROWNUM &lt;= 5
    ORDER BY dream_salary DESC, last_name ASC
  ) LOOP
    DBMS_OUTPUT.PUT_LINE
      (item.<span class="bold">full_name</span> || ' dreams of making ' || item.<span class="bold">dream_salary</span>);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Michael Hartstein dreams of making 143325
Pat Fay dreams of making 66150
Jennifer Whalen dreams of making 48510
Douglas Grant dreams of making 31531.5
Donald OConnell dreams of making 31531.5
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
When an exception is raised inside a <a id="sthref546"></a>cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement, the cursor closes before the exception handler runs. Therefore, the values of explicit cursor attributes are not available in the handler.</div>
</div>
<!-- class="sect2" -->
<a id="CIHBEEBG"></a>
<div id="LNPLS554" class="sect2">
<h3 class="sect2">Query Result Set Processing With Explicit Cursors, OPEN, FETCH, and CLOSE</h3>
<p>For full control over query result set processing, declare explicit cursors and manage them with the statements <a id="sthref547"></a><code dir="ltr">OPEN</code>, <code dir="ltr">FETCH</code>, and <code dir="ltr">CLOSE</code>. (For instructions and examples, see <a href="#CIHCAHJA">"Explicit Cursors"</a>.)</p>
<p>This result set processing technique is more complicated than the others, but it is also more flexible. For example, you can:</p>
<ul>
<li>
<p>Process multiple result sets in parallel, using multiple cursors.</p>
</li>
<li>
<p>Process multiple rows in a single loop iteration, skip rows, or split the processing into multiple loops.</p>
</li>
<li>
<p>Specify the query in one PL/SQL unit but retrieve the rows in another.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i3317"></a>
<div id="LNPLS00604" class="sect2">
<h3 class="sect2">Query Result Set Processing with Subqueries</h3>
<p>If you process a query result set by looping through it and running another query for each row, then you can improve performance by removing the second query from inside the loop and making it a <a id="sthref548"></a>subquery of the first query. For more information about subqueries, see <a class="olink SQLRF52357" href="../../server.112/e41084/queries007.htm#SQLRF52357"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p><a href="#CJABHDCB">Example 6-22</a> defines explicit cursor <code dir="ltr">c1</code> with a query whose <code dir="ltr">FROM</code> clause contains a subquery.</p>
<div id="LNPLS561" class="example">
<p class="titleinexample"><a id="CJABHDCB"></a>Example 6-22 Subquery in FROM Clause of Parent Query</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT t1.department_id, department_name, staff
    FROM departments t1,
         <span class="bold">( SELECT department_id, COUNT(*) AS staff</span>
           <span class="bold">FROM employees</span>
           <span class="bold">GROUP BY department_id</span>
         <span class="bold">)</span> t2
    WHERE (t1.department_id = t2.department_id) AND staff &gt;= 5
    ORDER BY staff;

BEGIN
   FOR dept IN c1
   LOOP
     DBMS_OUTPUT.PUT_LINE ('Department = '
       || dept.department_name || ', staff = ' || dept.staff);
   END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Department = IT, staff = 5
Department = Purchasing, staff = 6
Department = Finance, staff = 6
Department = Sales, staff = 34
Department = Shipping, staff = 45
</pre></div>
<!-- class="example" -->
<p>While an ordinary subquery is evaluated for each table, a <a id="sthref549"></a><a id="sthref550"></a><span class="bold">correlated subquery</span> is evaluated for each row. <a href="#BABCEJBA">Example 6-23</a> returns the name and salary of each employee whose salary exceeds the departmental average. For each row in the table, the correlated subquery computes the average salary for the corresponding department.</p>
<div id="LNPLS563" class="example">
<p class="titleinexample"><a id="BABCEJBA"></a>Example 6-23 Correlated Subquery</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT department_id, last_name, salary
    FROM employees t
    WHERE salary &gt; <span class="bold">( SELECT AVG(salary)</span>
                     <span class="bold">FROM employees</span>
                     <span class="bold">WHERE t.department_id = department_id</span>
                   )
    ORDER BY department_id, last_name;
BEGIN
  FOR person IN c1
  LOOP
    DBMS_OUTPUT.PUT_LINE('Making above-average salary = ' || person.last_name);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Making above-average salary = Hartstein
Making above-average salary = Raphaely
Making above-average salary = Bell
...
Making above-average salary = Higgins
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i7106"></a>
<div id="LNPLS00605" class="sect1">
<h2 class="sect1">Cursor Variables</h2>
<p>A <a id="sthref551"></a><span class="bold">cursor variable</span> is like an explicit cursor, except that:</p>
<ul>
<li>
<p>It is not limited to one query.</p>
<p>You can open a cursor variable for a query, process the result set, and then use the cursor variable for another query.</p>
</li>
<li>
<p>You can assign a value to it.</p>
</li>
<li>
<p>You can use it in an expression.</p>
</li>
<li>
<p>It can be a subprogram parameter.</p>
<p>You can use cursor variables to pass query result sets between subprograms.</p>
</li>
<li>
<p>It can be a host variable.</p>
<p>You can use cursor variables to pass query result sets between PL/SQL stored subprograms and their clients.</p>
</li>
<li>
<p>It cannot accept parameters.</p>
<p>You cannot pass parameters to a cursor variable, but you can pass whole queries to it.</p>
</li>
</ul>
<p>A cursor variable has this flexibility because it is a pointer; that is, its value is the address of an item, not the item itself.</p>
<p>Before you can reference a cursor variable, you must make it point to a SQL work area, either by opening it or by assigning it the value of an open PL/SQL cursor variable or open host cursor variable.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Cursor variables and explicit cursors are not interchangeable&mdash;you cannot use one where the other is expected. For example, you cannot reference a cursor variable in a cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement.</div>
<p class="subhead2"><a id="LNPLS498"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHCEICB">Creating Cursor Variables</a></p>
</li>
<li>
<p><a href="#CIHHABJH">Opening and Closing Cursor Variables</a></p>
</li>
<li>
<p><a href="#CIHFGIGH">Fetching Data with Cursor Variables</a></p>
</li>
<li>
<p><a href="#CHDHFHCH">Assigning Values to Cursor Variables</a></p>
</li>
<li>
<p><a href="#BABICAEJ">Variables in Cursor Variable Queries</a></p>
</li>
<li>
<p><a href="#BABCCAJC">Cursor Variable Attributes</a></p>
</li>
<li>
<p><a href="#CIHIHFCJ">Cursor Variables as Subprogram Parameters</a></p>
</li>
<li>
<p><a href="#CIHEHDHI">Cursor Variables as Host Variables</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="cursor_variable.htm#CJABEBDA">"Restrictions on Cursor Variables"</a></div>
<a id="CIHCEICB"></a>
<div id="LNPLS568" class="sect2">
<h3 class="sect2">Creating Cursor Variables</h3>
<p>To create a cursor variable, either declare a variable of the predefined type <a id="sthref552"></a><code dir="ltr">SYS_REFCURSOR</code> or define a <a id="sthref553"></a><code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> type and then declare a variable of that type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Informally, a cursor variable is sometimes called a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code>).</div>
<p>The basic syntax of a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> type definition is:</p>
<pre dir="ltr">
TYPE <span class="italic">type_name</span> IS REF CURSOR [ RETURN <span class="italic">return_type</span> ]
</pre>
<p>(For the complete syntax and semantics, see <a href="cursor_variable.htm#i33511">"Cursor Variable Declaration"</a>.)</p>
<p>If you specify <code dir="ltr"><span class="codeinlineitalic">return_type</span></code>, then the <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> type and cursor variables of that type are <a id="sthref554"></a><span class="bold">strong</span>; if not, they are <a id="sthref555"></a><span class="bold">weak</span>. <code dir="ltr">SYS_REFCURSOR</code> and cursor variables of that type are weak.</p>
<p>With a strong cursor variable, you can associate only queries that return the specified type. With a weak cursor variable, you can associate any query.</p>
<p>Weak cursor variables are more error-prone than strong ones, but they are also more flexible. Weak <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> types are interchangeable with each other and with the predefined type <code dir="ltr">SYS_REFCURSOR</code>. You can assign the value of a weak cursor variable to any other weak cursor variable.</p>
<p>You can assign the value of a strong cursor variable to another strong cursor variable only if both cursor variables have the same type (not merely the same return type).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can partition weak cursor variable arguments to <a id="sthref556"></a>table functions only with the <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> <code dir="ltr">ANY</code> clause, not with <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> <code dir="ltr">RANGE</code> or <code dir="ltr">PARTITION</code> <code dir="ltr">BY</code> <code dir="ltr">HASH</code>. For syntax and semantics, see <a href="create_function.htm#CIHCAJAF">"<span class="italic">parallel_enable_clause</span> ::="</a> and <a href="create_function.htm#CIHIHEIB">"<span class="italic">parallel_enable_clause</span>"</a>.</div>
<p><a href="#BABFHFHH">Example 6-24</a> defines strong and weak <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> types, variables of those types, and a variable of the predefined type <code dir="ltr">SYS_REFCURSOR</code>.</p>
<div id="LNPLS503" class="example">
<p class="titleinexample"><a id="BABFHFHH"></a>Example 6-24 Cursor Variable Declarations</p>
<pre dir="ltr">
DECLARE
  TYPE empcurtyp IS REF CURSOR <span class="bold">RETURN employees%ROWTYPE</span>;  -- strong type
  TYPE genericcurtyp IS REF CURSOR;                       -- weak type

  cursor1  empcurtyp;       -- strong cursor variable
  cursor2  genericcurtyp;   -- weak cursor variable
  my_cursor SYS_REFCURSOR;  -- weak cursor variable

  TYPE deptcurtyp IS REF CURSOR <span class="bold">RETURN departments%ROWTYPE</span>;  -- strong type
  dept_cv deptcurtyp;  -- strong cursor variable
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABHIJGD">Example 6-25</a>, <code dir="ltr"><span class="codeinlineitalic">return_type</span></code> is a user-defined <code dir="ltr">RECORD</code> type.</p>
<div id="LNPLS571" class="example">
<p class="titleinexample"><a id="BABHIJGD"></a>Example 6-25 Cursor Variable with User-Defined Return Type</p>
<pre dir="ltr">
DECLARE
  <span class="bold">TYPE EmpRecTyp IS RECORD</span> (
    employee_id NUMBER,
    last_name VARCHAR2(25),
    salary   NUMBER(8,2));

  TYPE EmpCurTyp IS REF CURSOR <span class="bold">RETURN EmpRecTyp</span>;
  emp_cv EmpCurTyp;
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHHABJH"></a>
<div id="LNPLS575" class="sect2">
<h3 class="sect2">Opening and Closing Cursor Variables</h3>
<p>After declaring a cursor variable, you can open it with the <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement, which does the following:</p>
<ol>
<li>
<p>Associates the cursor variable with a query (typically, the query returns multiple rows)</p>
<p>The query can include <a id="sthref557"></a><a id="sthref558"></a>placeholders for bind variables, whose values you specify in the <code dir="ltr">USING</code> clause of the <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement.</p>
</li>
<li>
<p>Allocates database resources to process the query</p>
</li>
<li>
<p>Processes the query; that is:</p>
<ol>
<li>
<p>Identifies the result set</p>
<p>If the query references variables, their values affect the result set. For details, see <a href="#BABICAEJ">"Variables in Cursor Variable Queries"</a>.</p>
</li>
<li>
<p>If the query has a <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause, locks the rows of the result set</p>
<p>For details, see <a href="#CIHHIIID">"SELECT FOR UPDATE and FOR UPDATE Cursors"</a>.</p>
</li>
</ol>
</li>
<li>
<p>Positions the cursor before the first row of the result set</p>
</li>
</ol>
<p>You need not close a cursor variable before reopening it (that is, using it in another <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement). After you reopen a cursor variable, the query previously associated with it is lost.</p>
<p>When you no longer need a cursor variable, close it with the <code dir="ltr">CLOSE</code> statement, thereby allowing its resources to be reused. After closing a cursor variable, you cannot fetch records from its result set or reference its attributes. If you try, PL/SQL raises the predefined exception <code dir="ltr">INVALID_CURSOR</code>.</p>
<p>You can reopen a closed cursor variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="openfor_statement.htm#i35231">"OPEN FOR Statement"</a> for its syntax and semantics</p>
</li>
<li>
<p><a href="close_statement.htm#i32987">"CLOSE Statement"</a> for its syntax and semantics</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHFGIGH"></a>
<div id="LNPLS581" class="sect2">
<h3 class="sect2">Fetching Data with Cursor Variables</h3>
<p>After opening a cursor variable, you can fetch the rows of the query result set with the <a id="sthref559"></a><code dir="ltr">FETCH</code> statement, which works as described in <a href="#BABJIICC">"Fetching Data with Explicit Cursors"</a>.</p>
<p>The return type of the cursor variable must be compatible with the <code dir="ltr"><span class="codeinlineitalic">into_clause</span></code> of the <code dir="ltr">FETCH</code> statement. If the cursor variable is <a id="sthref560"></a>strong, PL/SQL catches incompatibility at compile time. If the cursor variable is <a id="sthref561"></a>weak, PL/SQL catches incompatibility at run time, raising the predefined exception <code dir="ltr">ROWTYPE_MISMATCH</code> before the first fetch.</p>
<p><a href="#BABDJIFB">Example 6-26</a> uses one cursor variable to do what <a href="#BABCFDJE">Example 6-6</a> does with two explicit cursors. The first <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement includes the query itself. The second <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement references a variable whose value is a query.</p>
<div id="LNPLS504" class="example">
<p class="titleinexample"><a id="BABDJIFB"></a>Example 6-26 Fetching Data with Cursor Variables</p>
<pre dir="ltr">
DECLARE
  <span class="bold">cv SYS_REFCURSOR;  -- cursor variable</span>
 
  v_lastname  employees.last_name%TYPE;  -- variable for last_name
  v_jobid     employees.job_id%TYPE;     -- variable for job_id
 
  <span class="bold">query_2 VARCHAR2(200) :=</span>
    <span class="bold">'SELECT * FROM employees</span>
    <span class="bold">WHERE REGEXP_LIKE (job_id, ''[ACADFIMKSA]_M[ANGR]'')</span>
    <span class="bold">ORDER BY job_id';</span>
 
  v_employees employees%ROWTYPE;  -- record variable row of table
 
BEGIN
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT last_name, job_id FROM employees</span>
    <span class="bold">WHERE REGEXP_LIKE (job_id, 'S[HT]_CLERK')</span>
    <span class="bold">ORDER BY last_name;</span>
 
  LOOP  -- Fetches 2 columns into variables
    FETCH <span class="bold">cv</span> INTO v_lastname, v_jobid;
    EXIT WHEN <span class="bold">cv</span>%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE( RPAD(v_lastname, 25, ' ') || v_jobid );
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE( '-------------------------------------' );
 
  <span class="bold">OPEN cv FOR query_2;</span>
 
  LOOP  -- Fetches entire row into the v_employees record
    FETCH <span class="bold">cv</span> INTO v_employees;
    EXIT WHEN <span class="bold">cv</span>%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE( RPAD(v_employees.last_name, 25, ' ') ||
                               v_employees.job_id );
  END LOOP;
 
  CLOSE <span class="bold">cv</span>;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Atkinson                 ST_CLERK
Bell                     SH_CLERK
Bissot                   ST_CLERK
...
Walsh                    SH_CLERK
-------------------------------------
Higgins                  AC_MGR
Greenberg                FI_MGR
Hartstein                MK_MAN
...
Zlotkey                  SA_MAN
</pre></div>
<!-- class="example" -->
<p><a href="#BABGAICI">Example 6-27</a> fetches from a cursor variable into two collections (nested tables), using the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause of the <code dir="ltr">FETCH</code> statement.</p>
<div id="LNPLS583" class="example">
<p class="titleinexample"><a id="BABGAICI"></a>Example 6-27 Fetching from Cursor Variable into Collections</p>
<pre dir="ltr">
DECLARE
  TYPE empcurtyp IS REF CURSOR;
  TYPE namelist IS TABLE OF employees.last_name%TYPE;
  TYPE sallist IS TABLE OF employees.salary%TYPE;
  emp_cv  empcurtyp;
  names   namelist;
  sals    sallist;
BEGIN
  OPEN emp_cv FOR
    SELECT last_name, salary FROM employees
    WHERE job_id = 'SA_REP'
    ORDER BY salary DESC;

  <span class="bold">FETCH emp_cv BULK COLLECT INTO names, sals;</span>
  CLOSE emp_cv;
  -- loop through the names and sals collections
  FOR i IN names.FIRST .. names.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE
      ('Name = ' || names(i) || ', salary = ' || sals(i));
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Name = Ozer, salary = 12075
Name = Abel, salary = 11550
Name = Vishney, salary = 11025
...
Name = Kumar, salary = 6405
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="fetch_statement.htm#i34221">"FETCH Statement"</a> for its complete syntax and semantics</p>
</li>
<li>
<p><a href="tuning.htm#BCGGAGIF">"FETCH Statement with BULK COLLECT Clause"</a> for information about <code dir="ltr">FETCH</code> statements that return more than one row at a time</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDHFHCH"></a>
<div id="LNPLS505" class="sect2">
<h3 class="sect2">Assigning Values to Cursor Variables</h3>
<p>You can assign to a PL/SQL cursor variable the value of another PL/SQL cursor variable or host cursor variable. The syntax is:</p>
<pre dir="ltr">
<span class="italic">target_cursor_variable</span> := <span class="italic">source_cursor_variable</span>;
</pre>
<p>If <code dir="ltr"><span class="codeinlineitalic">source_cursor_variable</span></code> is open, then after the assignment, <code dir="ltr"><span class="codeinlineitalic">target_cursor_variable</span></code> is also open. The two cursor variables point to the same SQL work area.</p>
<p>If <code dir="ltr"><span class="codeinlineitalic">source_cursor_variable</span></code> is not open, opening <code dir="ltr"><span class="codeinlineitalic">target_cursor_variable</span></code> after the assignment does not open <code dir="ltr"><span class="codeinlineitalic">source_cursor_variable</span></code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABICAEJ"></a>
<div id="LNPLS506" class="sect2">
<h3 class="sect2">Variables in Cursor Variable Queries</h3>
<p>The query associated with a cursor variable can reference any <a id="sthref562"></a>variable in its scope. When you open a cursor variable with the <code dir="ltr">OPEN</code> <code dir="ltr">FOR</code> statement, PL/SQL evaluates any variables in the query and uses those values when identifying the result set. Changing the values of the variables later does not change the result set.</p>
<p><a href="#BABCHEGG">Example 6-28</a> opens a cursor variable for a query that references the variable <code dir="ltr">factor</code>, which has the value 2. Therefore, <code dir="ltr">sal_multiple</code> is always 2 times <code dir="ltr">sal</code>, despite that <code dir="ltr">factor</code> is incremented after every fetch.</p>
<div id="LNPLS507" class="example">
<p class="titleinexample"><a id="BABCHEGG"></a>Example 6-28 Variable in Cursor Variable Query&mdash;No Result Set Change</p>
<pre dir="ltr">
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  <span class="bold">factor        INTEGER := 2;</span>
 
  cv SYS_REFCURSOR;
 
BEGIN
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT salary, salary*factor</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id LIKE 'AD_%';   -- PL/SQL evaluates factor</span>
 
  LOOP
    <span class="bold">FETCH cv INTO sal, sal_multiple;</span>
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('factor = ' || factor);
    DBMS_OUTPUT.PUT_LINE('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE('sal_multiple = ' || sal_multiple);
    <span class="bold">factor := factor + 1;  -- Does not affect sal_multiple</span>
  END LOOP;
 
  CLOSE cv;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
factor = 2
sal          = 4451
sal_multiple = 8902
factor = 3
sal          = 26460
sal_multiple = 52920
factor = 4
sal          = 18742.5
sal_multiple = 37485
factor = 5
sal          = 18742.5
sal_multiple = 37485
</pre></div>
<!-- class="example" -->
<p>To change the result set, you must change the value of the variable and then open the cursor variable again for the same query, as in <a href="#BABIHIBA">Example 6-29</a>.</p>
<div id="LNPLS508" class="example">
<p class="titleinexample"><a id="BABIHIBA"></a>Example 6-29 Variable in Cursor Variable Query&mdash;Result Set Change</p>
<pre dir="ltr">
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  <span class="bold">factor        INTEGER := 2;</span>
 
  cv SYS_REFCURSOR;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('factor = ' || factor);
 
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT salary, salary*factor</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id LIKE 'AD_%';   -- PL/SQL evaluates factor</span>
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE('sal_multiple = ' || sal_multiple);
  END LOOP;
 
  <span class="bold">factor := factor + 1;</span>
 
  DBMS_OUTPUT.PUT_LINE('factor = ' || factor);
 
  <span class="bold">OPEN cv FOR</span>
    <span class="bold">SELECT salary, salary*factor</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id LIKE 'AD_%';   -- PL/SQL evaluates factor</span>
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE('sal_multiple = ' || sal_multiple);
  END LOOP;
 
  CLOSE cv;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
factor = 2
sal          = 4451
sal_multiple = 8902
sal          = 26460
sal_multiple = 52920
sal          = 18742.5
sal_multiple = 37485
sal          = 18742.5
sal_multiple = 37485
factor = 3
sal          = 4451
sal_multiple = 13353
sal          = 26460
sal_multiple = 79380
sal          = 18742.5
sal_multiple = 56227.5
sal          = 18742.5
sal_multiple = 56227.5
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABCCAJC"></a>
<div id="LNPLS509" class="sect2">
<h3 class="sect2">Cursor Variable Attributes</h3>
<p>A cursor variable has the same <a id="sthref563"></a>attributes as an explicit cursor (see <a href="#CIHJGBAG">"Explicit Cursor Attributes"</a>). The syntax for the value of a cursor variable attribute is <code dir="ltr"><span class="codeinlineitalic">cursor_variable_name</span></code> immediately followed by <code dir="ltr"><span class="codeinlineitalic">attribute</span></code> (for example, <code dir="ltr">cv%ISOPEN</code>). If a cursor variable is not open, referencing any attribute except <code dir="ltr">%ISOPEN</code> raises the predefined exception <code dir="ltr">INVALID_CURSOR</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHIHFCJ"></a>
<div id="LNPLS572" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Cursor Variables as Subprogram Parameters</h3>
<p>You can use a cursor variable as a <a id="sthref564"></a><a id="sthref565"></a>subprogram parameter, which makes it useful for passing query results between subprograms. For example:</p>
<ul>
<li>
<p>You can open a cursor variable in one subprogram and process it in a different subprogram.</p>
</li>
<li>
<p>In a multilanguage application, a PL/SQL subprogram can use a cursor variable to return a result set to a subprogram written in a different language.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The invoking and invoked subprograms must be in the same database instance. You cannot pass or return cursor variables to subprograms invoked through database links.</div>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Because cursor variables are pointers, using them as subprogram parameters increases the likelihood of subprogram parameter aliasing, which can have unintended results. For more information, see <a href="subprograms.htm#CHDEBECB">"Subprogram Parameter Aliasing with Cursor Variable Parameters"</a>.</div>
<p>When declaring a cursor variable as the formal parameter of a subprogram:</p>
<ul>
<li>
<p>If the subprogram opens or assigns a value to the cursor variable, then the parameter mode must be <code dir="ltr">IN</code> <code dir="ltr">OUT</code>.</p>
</li>
<li>
<p>If the subprogram only fetches from, or closes, the cursor variable, then the parameter mode can be either <code dir="ltr">IN</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code>.</p>
</li>
</ul>
<p>Corresponding formal and actual cursor variable parameters must have compatible return types. Otherwise, PL/SQL raises the predefined exception <code dir="ltr">ROWTYPE_MISMATCH</code>.</p>
<p>To pass a cursor variable parameter between subprograms in different PL/SQL units, define the <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> type of the parameter in a package. When the type is in a package, multiple subprograms can use it. One subprogram can declare a formal parameter of that type, and other subprograms can declare variables of that type and pass them to the first subprogram.</p>
<p><a href="#BABIIGAG">Example 6-30</a> defines, in a package, a <code dir="ltr">REF</code> <code dir="ltr">CURSOR</code> type and a procedure that opens a cursor variable parameter of that type.</p>
<div id="LNPLS577" class="example">
<p class="titleinexample"><a id="BABIIGAG"></a>Example 6-30 Procedure to Open Cursor Variable for One Query</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE emp_data AS
  TYPE empcurtyp IS REF CURSOR RETURN employees%ROWTYPE;
  PROCEDURE open_emp_cv (emp_cv IN OUT empcurtyp);
END emp_data;
/
CREATE OR REPLACE PACKAGE BODY emp_data AS
  PROCEDURE open_emp_cv (<span class="bold">emp_cv IN OUT EmpCurTyp</span>) IS
  BEGIN
    <span class="bold">OPEN emp_cv FOR SELECT * FROM employees;</span>
  END open_emp_cv;
END emp_data;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABFEJED">Example 6-31</a>,the stored procedure opens its cursor variable parameter for a chosen query. The queries have the same return type.</p>
<div id="LNPLS578" class="example">
<p class="titleinexample"><a id="BABFEJED"></a>Example 6-31 Opening Cursor Variable for Chosen Query (Same Return Type)</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE emp_data AS
  TYPE empcurtyp IS REF CURSOR RETURN employees%ROWTYPE;
  PROCEDURE open_emp_cv (emp_cv IN OUT empcurtyp, choice INT);
END emp_data;
/
CREATE OR REPLACE PACKAGE BODY emp_data AS
  PROCEDURE open_emp_cv (<span class="bold">emp_cv IN OUT empcurtyp, choice INT</span>) IS
  BEGIN
    IF <span class="bold">choice = 1</span> THEN
      OPEN emp_cv FOR SELECT *
      FROM employees
      <span class="bold">WHERE commission_pct IS NOT NULL</span>;
    ELSIF <span class="bold">choice = 2</span> THEN
      OPEN emp_cv FOR SELECT *
      FROM employees
      <span class="bold">WHERE salary &gt; 2500</span>;
    ELSIF <span class="bold">choice = 3</span> THEN
      OPEN emp_cv FOR SELECT *
      FROM employees
      <span class="bold">WHERE department_id = 100</span>;
    END IF;
  END;
END emp_data;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABEJEII">Example 6-32</a>,the stored procedure opens its cursor variable parameter for a chosen query. The queries have the different return types.</p>
<div id="LNPLS579" class="example">
<p class="titleinexample"><a id="BABEJEII"></a>Example 6-32 Opening Cursor Variable for Chosen Query (Different Return Types)</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE admin_data AS
  TYPE gencurtyp IS REF CURSOR;
  PROCEDURE open_cv (generic_cv IN OUT gencurtyp, choice INT);
END admin_data;
/
CREATE OR REPLACE PACKAGE BODY admin_data AS
  PROCEDURE open_cv (<span class="bold">generic_cv IN OUT gencurtyp, choice INT</span>) IS
  BEGIN
    IF <span class="bold">choice = 1</span> THEN
      OPEN generic_cv FOR SELECT * FROM <span class="bold">employees</span>;
    ELSIF <span class="bold">choice = 2</span> THEN
      OPEN generic_cv FOR SELECT * FROM <span class="bold">departments</span>;
    ELSIF <span class="bold">choice = 3</span> THEN
      OPEN generic_cv FOR SELECT * FROM <span class="bold">jobs</span>;
    END IF;
  END;
END admin_data;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="subprograms.htm#i23202">"Subprogram Parameters"</a> for more information about subprogram parameters</p>
</li>
<li>
<p><a href="#i44913">"CURSOR Expressions"</a> for information about <code dir="ltr">CURSOR</code> expressions, which can be actual parameters for formal cursor variable parameters</p>
</li>
<li>
<p><a href="packages.htm#CIHIJECJ">Chapter 10, "PL/SQL Packages,"</a> for more information about packages</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHEHDHI"></a>
<div id="LNPLS580" class="sect2">
<h3 class="sect2">Cursor Variables as Host Variables</h3>
<p>You can use a cursor variable as a <a id="sthref566"></a><a id="sthref567"></a>host variable, which makes it useful for passing query results between PL/SQL stored subprograms and their clients. When a cursor variable is a host variable, PL/SQL and the client (the host environment) share a pointer to the SQL work area that stores the result set.</p>
<p>To use a cursor variable as a host variable, declare the cursor variable in the host environment and then pass it as an input host variable (bind variable) to PL/SQL. Host cursor variables are compatible with any query return type (like weak PL/SQL cursor variables).</p>
<p>In <a href="#CHDJEEFC">Example 6-33</a>, a Pro*C client program declares a cursor variable and a selector and passes them as host variables to a PL/SQL anonymous block, which opens the cursor variable for the selected query.</p>
<div id="LNPLS510" class="example">
<p class="titleinexample"><a id="CHDJEEFC"></a>Example 6-33 Cursor Variable as Host Variable in Pro*C Client Program</p>
<pre dir="ltr">
EXEC SQL BEGIN DECLARE SECTION;
  SQL_CURSOR  generic_cv;  -- Declare host cursor variable.
  int         choice;      -- Declare selector.
EXEC SQL END DECLARE SECTION;
EXEC SQL ALLOCATE :generic_cv;  -- Initialize host cursor variable.
-- Pass host cursor variable and selector to PL/SQL block.
/
EXEC SQL EXECUTE
BEGIN
  IF :choice = 1 THEN
    OPEN :generic_cv FOR SELECT * FROM employees;
  ELSIF :choice = 2 THEN
    OPEN :generic_cv FOR SELECT * FROM departments;
  ELSIF :choice = 3 THEN
    OPEN :generic_cv FOR SELECT * FROM jobs;
  END IF;
END;
END-EXEC;
</pre></div>
<!-- class="example" -->
<p>A SQL work area remains accessible while any cursor variable points to it, even if you pass the value of a cursor variable from one scope to another. For example, in <a href="#CHDJEEFC">Example 6-33</a>, the Pro*C program passes a host cursor variable to an embedded PL/SQL anonymous block. After the block runs, the cursor variable still points to the SQL work area.</p>
<p>If you have a PL/SQL engine on the client side, calls from client to server impose no restrictions. For example, you can declare a cursor variable on the client side, open and fetch from it on the server side, and continue to fetch from it on the client side. You can also reduce network traffic with a PL/SQL anonymous block that opens or closes several host cursor variables in a single round trip. For example:</p>
<pre dir="ltr">
/* PL/SQL anonymous block in host environment */
BEGIN
  OPEN :emp_cv FOR SELECT * FROM employees;
  OPEN :dept_cv FOR SELECT * FROM departments;
  OPEN :loc_cv FOR SELECT * FROM locations;
END;
/
</pre>
<p>Because the cursor variables still point to the SQL work areas after the PL/SQL anonymous block runs, the client program can use them. When the client program no longer needs the cursors, it can use a PL/SQL anonymous block to close them. For example:</p>
<pre dir="ltr">
/* PL/SQL anonymous block in host environment */
BEGIN
  CLOSE :emp_cv;
  CLOSE :dept_cv;
  CLOSE :loc_cv;
END;
/
</pre>
<p>This technique is useful for populating a multiblock form, as in Oracle Forms. For example, you can open several SQL work areas in a single round trip, like this:</p>
<pre dir="ltr">
/* PL/SQL anonymous block in host environment */
BEGIN
  OPEN :c1 FOR SELECT 1 FROM DUAL;
  OPEN :c2 FOR SELECT 1 FROM DUAL;
  OPEN :c3 FOR SELECT 1 FROM DUAL;
END;
/
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you bind a host cursor variable into PL/SQL from an <a id="sthref568"></a><a id="sthref569"></a>Oracle Call Interface (OCI) client, then you cannot fetch from it on the server side unless you also open it there on the same server call.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i44913"></a>
<div id="LNPLS00606" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">CURSOR Expressions</h2>
<p>A <a id="sthref570"></a><a id="sthref571"></a><code dir="ltr">CURSOR</code> expression returns a <a id="sthref572"></a><a id="sthref573"></a>nested cursor. It has this syntax:</p>
<pre dir="ltr">
CURSOR ( <span class="italic">subquery</span> )
</pre>
<p>You can use a <code dir="ltr">CURSOR</code> expression in a <code dir="ltr">SELECT</code> statement that is not a subquery (as in <a href="#BABFGHDG">Example 6-34</a>) or pass it to a function that accepts a <a id="sthref574"></a>cursor variable parameter (see <a href="tuning.htm#BCGHHFHJ">"Passing CURSOR Expressions to Pipelined Table Functions"</a>). You cannot use a cursor expression with an <a id="sthref575"></a>implicit cursor.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF52077" href="../../server.112/e41084/expressions006.htm#SQLRF52077"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">CURSOR</code> expressions, including restrictions</div>
<p><a href="#BABFGHDG">Example 6-34</a> declares and defines an explicit cursor for a query that includes a cursor expression. For each department in the <code dir="ltr">departments</code> table, the nested cursor returns the last name of each employee in that department (which it retrieves from the <code dir="ltr">employees</code> table).</p>
<div id="LNPLS589" class="example">
<p class="titleinexample"><a id="BABFGHDG"></a>Example 6-34 CURSOR Expression</p>
<pre dir="ltr">
DECLARE
  TYPE emp_cur_typ IS REF CURSOR;
 
  emp_cur    emp_cur_typ;
  dept_name  departments.department_name%TYPE;
  emp_name   employees.last_name%TYPE;
 
  CURSOR c1 IS
    SELECT department_name,
      <span class="bold">CURSOR ( SELECT e.last_name</span>
                <span class="bold">FROM employees e</span>
                <span class="bold">WHERE e.department_id = d.department_id</span>
                <span class="bold">ORDER BY e.last_name</span>
              <span class="bold">)</span> employees
    FROM departments d
    WHERE department_name LIKE 'A%'
    ORDER BY department_name;
BEGIN
  OPEN c1;
  LOOP  -- Process each row of query result set
    FETCH c1 INTO dept_name, emp_cur;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('Department: ' || dept_name);
 
    LOOP -- Process each row of subquery result set
      FETCH emp_cur INTO emp_name;
      EXIT WHEN emp_cur%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('-- Employee: ' || emp_name);
    END LOOP;
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Department: Accounting
-- Employee: Gietz
-- Employee: Higgins
Department: Administration
-- Employee: Whalen
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i7105"></a>
<div id="LNPLS00608" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Transaction Processing and Control</h2>
<p>A <span class="bold">transaction</span> is a sequence of one or more SQL statements that Oracle Database treats as a unit: either all of the statements are performed, or none of them are. For more information about transactions, see <a class="olink CNCPT016" href="../../server.112/e40540/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p><span class="bold">Transaction processing</span> is an Oracle Database feature that lets multiple users work on the database concurrently, and ensures that each user sees a consistent version of data and that all changes are applied in the right order. For more information about transaction processing, see <a class="olink CNCPT1118" href="../../server.112/e40540/transact.htm#CNCPT1118"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p>Different users can write to the same data structures without harming each other's data or coordinating with each other, because Oracle Database locks data structures automatically. To maximize data availability, Oracle Database locks the minimum amount of data for the minimum amount of time. For more information about the Oracle Database locking mechanism, see <a class="olink CNCPT1331" href="../../server.112/e40540/consist.htm#CNCPT1331"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p>You rarely must write extra code to prevent problems with multiple users accessing data concurrently. However, if you do need this level of control, you can manually override the Oracle Database default locking mechanisms. For more information about manual data locks, see <a class="olink CNCPT1363" href="../../server.112/e40540/consist.htm#CNCPT1363"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p class="subhead2"><a id="LNPLS511"></a>Topics</p>
<ul>
<li>
<p><a href="#BABHHCHC">COMMIT Statement</a></p>
</li>
<li>
<p><a href="#CIHHIHAF">ROLLBACK Statement</a></p>
</li>
<li>
<p><a href="#CIHIAFDG">SAVEPOINT Statement</a></p>
</li>
<li>
<p><a href="#CIHDEHAJ">Implicit Rollbacks</a></p>
</li>
<li>
<p><a href="#i3316">SET TRANSACTION Statement</a></p>
</li>
<li>
<p><a href="#CIHFDDDA">Overriding Default Locking</a></p>
</li>
</ul>
<a id="BABHHCHC"></a>
<div id="LNPLS592" class="sect2">
<h3 class="sect2">COMMIT Statement</h3>
<p>The <a id="sthref576"></a><code dir="ltr">COMMIT</code> statement <a id="sthref577"></a>ends the current transaction, making its changes permanent and visible to other users.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A transaction can span multiple blocks, and a block can contain multiple transactions.</div>
<p>The <code dir="ltr">WRITE</code> clause of the <code dir="ltr">COMMIT</code> statement specifies the priority with which Oracle Database writes to the redo log the information that the commit operation generates.</p>
<p>In <a href="#CJAIDJID">Example 6-35</a>, a transaction transfers money from one bank account to another. It is important that the money both leaves one account and enters the other, hence the <code dir="ltr">COMMIT</code> <code dir="ltr">WRITE</code> <code dir="ltr">IMMEDIATE</code> <code dir="ltr">NOWAIT</code> statement.</p>
<div id="LNPLS593" class="example">
<p class="titleinexample"><a id="CJAIDJID"></a>Example 6-35 COMMIT Statement with COMMENT and WRITE Clauses</p>
<pre dir="ltr">
DROP TABLE accounts;
CREATE TABLE accounts (
  account_id  NUMBER(6),
  balance     NUMBER (10,2)
);
 
INSERT INTO accounts (account_id, balance)
VALUES (7715, 6350.00);
 
INSERT INTO accounts (account_id, balance)
VALUES (7720, 5100.50);
 
CREATE OR REPLACE PROCEDURE transfer (
  from_acct  NUMBER,
  to_acct    NUMBER,
  amount     NUMBER
) AUTHID DEFINER AS
BEGIN
  UPDATE accounts
  SET balance = balance - amount
  WHERE account_id = from_acct;
 
  UPDATE accounts
  SET balance = balance + amount
  WHERE account_id = to_acct;
 
  COMMIT WRITE IMMEDIATE NOWAIT;
END;
/
</pre>
<p>Query before transfer:</p>
<pre dir="ltr">
SELECT * FROM accounts;
</pre>
<p>Result:</p>
<pre dir="ltr">
ACCOUNT_ID    BALANCE
---------- ----------
      7715       6350
      7720     5100.5
 
BEGIN
  transfer(7715, 7720, 250);
END;
/
 
</pre>
<p>Query after transfer:</p>
<pre dir="ltr">
SELECT * FROM accounts;
</pre>
<p>Result:</p>
<pre dir="ltr">
ACCOUNT_ID    BALANCE
---------- ----------
      7715       6100
      7720     5350.5
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The default PL/SQL commit behavior for nondistributed transactions is <code dir="ltr">BATCH</code> <code dir="ltr">NOWAIT</code> if the <code dir="ltr">COMMIT_LOGGING</code> and <code dir="ltr">COMMIT_WAIT</code> database initialization parameters have not been set.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS1018" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS1018"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information about committing transactions</p>
</li>
<li>
<p><a class="olink CNCPT016" href="../../server.112/e40540/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for information about distributed transactions</p>
</li>
<li>
<p><a class="olink SQLRF01110" href="../../server.112/e41084/statements_4010.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a>for information about the <code dir="ltr">COMMIT</code> statement</p>
</li>
<li>
<p><a class="olink SBYDB02000" href="../../server.112/e41134/protection.htm#SBYDB02000"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for information about ensuring no loss of data during a failover to a standby database</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHHIHAF"></a>
<div id="LNPLS594" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">ROLLBACK Statement</h3>
<p>The <a id="sthref578"></a><code dir="ltr">ROLLBACK</code> statement <a id="sthref579"></a>ends the current transaction and undoes any changes made during that transaction. If you make a mistake, such as deleting the wrong row from a table, a rollback restores the original data. If you cannot finish a transaction because a SQL statement fails or PL/SQL raises an exception, a rollback lets you take corrective action and perhaps start over.</p>
<p><a href="#CJACGAFD">Example 6-36</a> inserts information about an employee into three different tables. If an <code dir="ltr">INSERT</code> statement tries to store a duplicate employee number, PL/SQL raises the predefined exception <code dir="ltr">DUP_VAL_ON_INDEX</code>. To ensure that changes to all three tables are undone, the exception handler runs a <code dir="ltr">ROLLBACK</code>.</p>
<div id="LNPLS595" class="example">
<p class="titleinexample"><a id="CJACGAFD"></a>Example 6-36 ROLLBACK Statement</p>
<pre dir="ltr">
DROP TABLE emp_name;
CREATE TABLE emp_name AS 
  SELECT employee_id, last_name
  FROM employees;
 
CREATE UNIQUE INDEX empname_ix
ON emp_name (employee_id);
 
 
DROP TABLE emp_sal;
CREATE TABLE emp_sal AS
  SELECT employee_id, salary
  FROM employees;
 
CREATE UNIQUE INDEX empsal_ix
ON emp_sal (employee_id);
 
 
DROP TABLE emp_job;
CREATE TABLE emp_job AS
  SELECT employee_id, job_id
  FROM employees;
 
CREATE UNIQUE INDEX empjobid_ix
ON emp_job (employee_id);
 
 
DECLARE
  emp_id        NUMBER(6);
  emp_lastname  VARCHAR2(25);
  emp_salary    NUMBER(8,2);
  emp_jobid     VARCHAR2(10);
BEGIN
  SELECT employee_id, last_name, salary, job_id
  INTO emp_id, emp_lastname, emp_salary, emp_jobid
  FROM employees
  WHERE employee_id = 120;
 
  INSERT INTO emp_name (employee_id, last_name)
  VALUES (emp_id, emp_lastname);
 
  INSERT INTO emp_sal (employee_id, salary) 
  VALUES (emp_id, emp_salary);
 
  INSERT INTO emp_job (employee_id, job_id)
  VALUES (emp_id, emp_jobid);
 
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN DUP_VAL_ON_INDEX THEN</span>
    <span class="bold">ROLLBACK;</span>
    DBMS_OUTPUT.PUT_LINE('Inserts were rolled back');
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01601" href="../../server.112/e41084/statements_9010.htm#SQLRF01601"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ROLLBACK</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="CIHIAFDG"></a>
<div id="LNPLS99976" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SAVEPOINT Statement</h3>
<p>The <a id="sthref580"></a><code dir="ltr">SAVEPOINT</code> statement names and marks the current point in the processing of a transaction. Savepoints let you roll back part of a transaction instead of the whole transaction. The number of active savepoints for each session is unlimited.</p>
<p><a href="#BABGAAIG">Example 6-37</a> marks a savepoint before doing an insert. If the <code dir="ltr">INSERT</code> statement tries to store a duplicate value in the <code dir="ltr">employee_id</code> column, PL/SQL raises the predefined exception <code dir="ltr">DUP_VAL_ON_INDEX</code> and the transaction rolls back to the savepoint, undoing only the <code dir="ltr">INSERT</code> statement.</p>
<div id="LNPLS596" class="example">
<p class="titleinexample"><a id="BABGAAIG"></a>Example 6-37 SAVEPOINT and ROLLBACK Statements</p>
<pre dir="ltr">
DROP TABLE emp_name;
CREATE TABLE emp_name AS
  SELECT employee_id, last_name, salary
  FROM employees;
 
CREATE UNIQUE INDEX empname_ix
ON emp_name (employee_id);
 
DECLARE
  emp_id        employees.employee_id%TYPE;
  emp_lastname  employees.last_name%TYPE;
  emp_salary    employees.salary%TYPE;
 
BEGIN
  SELECT employee_id, last_name, salary
  INTO emp_id, emp_lastname, emp_salary 
  FROM employees
  WHERE employee_id = 120;
 
  UPDATE emp_name
  SET salary = salary * 1.1
  WHERE employee_id = emp_id;
 
  DELETE FROM emp_name
  WHERE employee_id = 130;
 
  <span class="bold">SAVEPOINT do_insert;</span>
 
  INSERT INTO emp_name (employee_id, last_name, salary)
  VALUES (emp_id, emp_lastname, emp_salary);
 
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN DUP_VAL_ON_INDEX THEN</span>
    <span class="bold">ROLLBACK TO do_insert;</span>
  DBMS_OUTPUT.PUT_LINE('Insert was rolled back');
END;
/
</pre></div>
<!-- class="example" -->
<p>When you roll back to a savepoint, any savepoints marked after that savepoint are erased. The savepoint to which you roll back is not erased. A simple rollback or commit erases all savepoints.</p>
<p>If you mark a savepoint in a recursive subprogram, new instances of the <code dir="ltr">SAVEPOINT</code> statement run at each level in the recursive descent, but you can only roll back to the most recently marked savepoint.</p>
<p>Savepoint names are undeclared identifiers. Reusing a savepoint name in a transaction moves the savepoint from its old position to the current point in the transaction, which means that a rollback to the savepoint affects only the current part of the transaction.</p>
<div id="LNPLS597" class="example">
<p class="titleinexample"><a id="CJABIBIC"></a>Example 6-38 Reusing SAVEPOINT with ROLLBACK</p>
<pre dir="ltr">
DROP TABLE emp_name;
CREATE TABLE emp_name AS
  SELECT employee_id, last_name, salary
  FROM employees;
 
CREATE UNIQUE INDEX empname_ix
ON emp_name (employee_id);
 
DECLARE
  emp_id        employees.employee_id%TYPE;
  emp_lastname  employees.last_name%TYPE;
  emp_salary    employees.salary%TYPE;
 
BEGIN
  SELECT employee_id, last_name, salary
  INTO emp_id, emp_lastname, emp_salary
  FROM employees
  WHERE employee_id = 120;
 
  <span class="bold">SAVEPOINT my_savepoint;</span>
 
  UPDATE emp_name
  SET salary = salary * 1.1
  WHERE employee_id = emp_id;
 
  DELETE FROM emp_name
  WHERE employee_id = 130;
 
  <span class="bold">SAVEPOINT my_savepoint;</span>
 
  INSERT INTO emp_name (employee_id, last_name, salary)
  VALUES (emp_id, emp_lastname, emp_salary);
 
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    <span class="bold">ROLLBACK TO my_savepoint;</span>
    DBMS_OUTPUT.PUT_LINE('Transaction rolled back.');
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> SQL statement</div>
</div>
<!-- class="sect2" -->
<a id="CIHDEHAJ"></a>
<div id="LNPLS598" class="sect2">
<h3 class="sect2">Implicit Rollbacks</h3>
<p><a id="sthref581"></a><a id="sthref582"></a>Before running an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, or <code dir="ltr">MERGE</code> statement, the database marks an implicit savepoint (unavailable to you). If the statement fails, the database rolls back to the savepoint. Usually, just the failed SQL statement is rolled back, not the whole transaction. If the statement raises an unhandled exception, the host environment determines what is rolled back. (For information about handling exceptions, see <a href="errors.htm#CHDFGBJI">Chapter 11, "PL/SQL Error Handling"</a>).</p>
<p>The database can also roll back single SQL statements to break <a id="sthref583"></a>deadlocks. The database signals an error to a participating transaction and rolls back the current statement in that transaction.</p>
<p>Before running a SQL statement, the database must parse it, that is, examine it to ensure it follows syntax rules and refers to valid schema objects. Errors detected while running a SQL statement cause a rollback, but errors detected while parsing the statement do not.</p>
<p>If you exit a stored subprogram with an unhandled exception, PL/SQL does not assign values to <code dir="ltr">OUT</code> parameters, and does not do any rollback.</p>
</div>
<!-- class="sect2" -->
<a id="i3316"></a>
<div id="LNPLS99975" class="sect2">
<h3 class="sect2">SET TRANSACTION Statement</h3>
<p>You use the <a id="sthref584"></a><code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement to begin a <a id="sthref585"></a><a id="sthref586"></a>read-only or <a id="sthref587"></a><a id="sthref588"></a>read-write transaction, establish an isolation level, or assign your current transaction to a specified rollback segment. Read-only transactions are useful for running multiple queries while other users update the same tables.</p>
<p>During a read-only transaction, all queries refer to the same snapshot of the database, providing a multi-table, multi-query, read-consistent view. Other users can continue to query or update data as usual. A commit or rollback ends the transaction.</p>
<p>In <a href="#BABJIHCC">Example 6-39</a> a read-only transaction gather order totals for the day, the past week, and the past month. The totals are unaffected by other users updating the database during the transaction. The <code dir="ltr">orders</code> table is in the sample schema OE.</p>
<div id="LNPLS600" class="example">
<p class="titleinexample"><a id="BABJIHCC"></a>Example 6-39 SET TRANSACTION Statement in Read-Only Transaction</p>
<pre dir="ltr">
DECLARE
  daily_order_total    NUMBER(12,2);
  weekly_order_total   NUMBER(12,2); 
  monthly_order_total  NUMBER(12,2);
BEGIN
   COMMIT; -- end previous transaction
   SET TRANSACTION READ ONLY NAME 'Calculate Order Totals';

   SELECT SUM (order_total)
   INTO daily_order_total
   FROM orders
   WHERE order_date = SYSDATE;

   SELECT SUM (order_total)
   INTO weekly_order_total
   FROM orders
   WHERE order_date = SYSDATE - 7;

   SELECT SUM (order_total)
   INTO monthly_order_total
   FROM orders
   WHERE order_date = SYSDATE - 30;

   COMMIT; -- ends read-only transaction
END;
/
</pre></div>
<!-- class="example" -->
<p>The <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement must be the first SQL statement in a read-only transaction and can appear only once in a transaction. If you set a transaction to <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>, subsequent queries see only changes committed before the transaction began. The use of <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> does not affect other users or transactions.</p>
<p>Only the <code dir="ltr">SELECT</code>, <code dir="ltr">OPEN</code>, <code dir="ltr">FETCH</code>, <code dir="ltr">CLOSE</code>, <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code>, <code dir="ltr">COMMIT</code>, and <code dir="ltr">ROLLBACK</code> statements are allowed in a read-only transaction. Queries cannot be <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the SQL statement <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code></div>
</div>
<!-- class="sect2" -->
<a id="CIHFDDDA"></a>
<div id="LNPLS602" class="sect2">
<h3 class="sect2">Overriding Default Locking</h3>
<p><a id="sthref589"></a>By default, Oracle Database locks data structures automatically, which lets different applications write to the same data structures without harming each other's data or coordinating with each other.</p>
<p>If you must have exclusive access to data during a transaction, you can override default locking with these SQL statements:</p>
<ul>
<li>
<p><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code>, which explicitly locks entire tables.</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause (<code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>) , which explicitly locks specific rows of a table.</p>
</li>
</ul>
<p class="subhead2"><a id="LNPLS513"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHHDDHG">LOCK TABLE Statement</a></p>
</li>
<li>
<p><a href="#CIHHIIID">SELECT FOR UPDATE and FOR UPDATE Cursors</a></p>
</li>
<li>
<p><a href="#CIHFJCCI">Simulating CURRENT OF Clause with ROWID Pseudocolumn</a></p>
</li>
</ul>
<a id="CIHHDDHG"></a>
<div id="LNPLS605" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">LOCK TABLE Statement</h4>
<p>The <a id="sthref590"></a><a id="sthref591"></a><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement explicitly locks one or more tables in a specified lock mode so that you can share or deny access to them.</p>
<p>The <a id="sthref592"></a><a id="sthref593"></a>lock mode determines what other locks can be placed on the table. For example, many users can acquire row share locks on a table at the same time, but only one user at a time can acquire an exclusive lock. While one user has an exclusive lock on a table, no other users can insert, delete, or update rows in that table.</p>
<p>A table lock never prevents other users from querying a table, and a query never acquires a table lock. Only if two different transactions try to modify the same row does one transaction wait for the other to complete. The <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement lets you specify how long to wait for another transaction to complete.</p>
<p>Table locks are released when the transaction that acquired them is either committed or rolled back.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS00203" href="../../appdev.112/e41502/adfns_sqlproc.htm#ADFNS00203"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information about locking tables explicitly</p>
</li>
<li>
<p><a class="olink SQLRF01605" href="../../server.112/e41084/statements_9015.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CIHHIIID"></a>
<div id="LNPLS603" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SELECT FOR UPDATE and FOR UPDATE Cursors</h4>
<p>The <code dir="ltr">SELECT</code> statement with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause (<a id="sthref594"></a><a id="sthref595"></a><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement) selects the rows of the result set and locks them. <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> lets you base an update on the existing values in the rows, because it ensures that no other user can change those values before you update them. You can also use <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> to lock rows that you do not want to update, as in <a href="triggers.htm#BCFGAHIB">Example 9-11</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In tables compressed with Hybrid Columnar Compression (HCC), DML statements lock compression units rather than rows. HCC, a feature of certain Oracle storage systems, is described in <a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
<p>By default, the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement waits until the requested row lock is acquired. To change this behavior, use the <code dir="ltr">NOWAIT</code>, <code dir="ltr">WAIT</code>, or <code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> clause of the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement. For information about these clauses, see <a class="olink SQLRF01702" href="../../server.112/e41084/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>When <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> is associated with an explicit cursor, the cursor is called a <a id="sthref596"></a><a id="sthref597"></a><code dir="ltr"><span class="codeinlinebold">FOR</span></code> <code dir="ltr"><span class="codeinlinebold">UPDATE</span></code> <span class="bold">cursor</span>. Only a <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> cursor can appear in the <a id="sthref598"></a><code dir="ltr">CURRENT</code> <code dir="ltr">OF</code> clause of an <code dir="ltr">UPDATE</code> or <code dir="ltr">DELETE</code> statement. (The <a id="sthref599"></a><code dir="ltr">CURRENT</code> <code dir="ltr">OF</code> clause, a PL/SQL extension to the <code dir="ltr">WHERE</code> clause of the SQL statements <code dir="ltr">UPDATE</code> and <code dir="ltr">DELETE</code>, restricts the statement to the current row of the cursor.)</p>
<p>In <a href="#CHDGEHBF">Example 6-40</a>, a <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> cursor appears in the <code dir="ltr">CURRENT</code> <code dir="ltr">OF</code> clause of an <code dir="ltr">UPDATE</code> statement.</p>
<div id="LNPLS514" class="example">
<p class="titleinexample"><a id="CHDGEHBF"></a>Example 6-40 FOR UPDATE Cursor in CURRENT OF Clause of UPDATE Statement</p>
<pre dir="ltr">
DECLARE
  my_emp_id NUMBER(6);
  my_job_id VARCHAR2(10);
  my_sal    NUMBER(8,2);
  <span class="bold">CURSOR c1 IS</span>
    <span class="bold">SELECT</span> employee_id, job_id, salary
    FROM employees <span class="bold">FOR UPDATE</span>;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_emp_id, my_job_id, my_sal;
    IF my_job_id = 'SA_REP' THEN
      <span class="bold">UPDATE</span> employees
      SET salary = salary * 1.02
      WHERE <span class="bold">CURRENT OF c1</span>;
    END IF;
    EXIT WHEN c1%NOTFOUND;
  END LOOP;
END;
/
</pre></div>
<!-- class="example" -->
<p>When <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> queries multiple tables, it locks only rows whose columns appear in the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause.</p>
<p>In <a href="#CHDGCCGC">Example 6-41</a>, <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> queries the tables <code dir="ltr">EMPLOYEES</code> and <code dir="ltr">DEPARTMENTS</code>, but only <code dir="ltr">SALARY</code> appears in the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause. <code dir="ltr">SALARY</code> is a column of <code dir="ltr">EMPLOYEES</code>, but not of <code dir="ltr">DEPARTMENTS</code>; therefore, <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> locks only rows of <code dir="ltr">EMPLOYEES</code>. If the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause included <code dir="ltr">DEPARTMENT_ID</code> or <code dir="ltr">MANAGER_ID</code>, which are columns of both <code dir="ltr">EMPLOYEES</code> and <code dir="ltr">DEPARTMENTS</code>, <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> would lock rows of both tables.</p>
<div id="LNPLS515" class="example">
<p class="titleinexample"><a id="CHDGCCGC"></a>Example 6-41 SELECT FOR UPDATE Statement for Multiple Tables</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT last_name, department_name
    <span class="bold">FROM employees, departments</span>
    WHERE employees.department_id = departments.department_id 
    AND job_id = 'SA_MAN'
    <span class="bold">FOR UPDATE OF salary</span>;
BEGIN
  NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHFJCCI"></a>
<div id="LNPLS606" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Simulating CURRENT OF Clause with ROWID Pseudocolumn</h4>
<p>The rows of the result set are locked when you open a <a id="sthref600"></a><a id="sthref601"></a><a id="sthref602"></a><a id="sthref603"></a><code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> cursor, not as they are fetched. The rows are unlocked when you commit or roll back the transaction. After the rows are unlocked, you cannot <a id="sthref604"></a>fetch from the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> cursor, as <a href="#CHDHIIAI">Example 6-42</a> shows (the result is the same if you substitute <code dir="ltr">ROLLBACK</code> for <code dir="ltr">COMMIT</code>).</p>
<div id="LNPLS516" class="example">
<p class="titleinexample"><a id="CHDHIIAI"></a>Example 6-42 FETCH with FOR UPDATE Cursor After COMMIT Statement</p>
<pre dir="ltr">
DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
DECLARE
  CURSOR c1 IS
    SELECT * FROM emp
    <span class="bold">FOR UPDATE OF salary</span>
    ORDER BY employee_id;
 
  emp_rec  emp%ROWTYPE;
BEGIN
  OPEN c1;
  LOOP
    <span class="bold">FETCH c1 INTO emp_rec;  -- fails on second iteration</span>
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (
      'emp_rec.employee_id = ' ||
      TO_CHAR(emp_rec.employee_id)
    );
    
    UPDATE emp
    SET salary = salary * 1.05
    WHERE employee_id = 105;
 
    <span class="bold">COMMIT;  -- releases locks</span>
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
emp_rec.employee_id = 100
DECLARE
*
ERROR at line 1:
ORA-01002: fetch out of sequence
ORA-06512: at line 11
</pre></div>
<!-- class="example" -->
<p>The workaround is to simulate the <a id="sthref605"></a><code dir="ltr">CURRENT</code> <code dir="ltr">OF</code> clause with the <a id="sthref606"></a><code dir="ltr">ROWID</code> pseudocolumn (described in <a class="olink SQLRF00254" href="../../server.112/e41084/pseudocolumns008.htm#SQLRF00254"><span class="italic">Oracle Database SQL Language Reference</span></a>). Select the rowid of each row into a <code dir="ltr">UROWID</code> variable and use the rowid to identify the current row during subsequent updates and deletes, as in <a href="#CIHIJAAE">Example 6-43</a>. (To print the value of a <code dir="ltr">UROWID</code> variable, convert it to <code dir="ltr">VARCHAR2</code>, using the <code dir="ltr">ROWIDTOCHAR</code> function described in <a class="olink SQLRF06101" href="../../server.112/e41084/functions157.htm#SQLRF06101"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you update a row in a table compressed with Hybrid Columnar Compression (HCC), the <code dir="ltr">ROWID</code> of the row changes. HCC, a feature of certain Oracle storage systems, is described in <a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Because no <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause locks the fetched rows, other users might unintentionally overwrite your changes.</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
The extra space needed for read consistency is not released until the cursor is closed, which can slow down processing for large updates.</div>
<div id="LNPLS607" class="example">
<p class="titleinexample"><a id="CIHIJAAE"></a>Example 6-43 Simulating CURRENT OF Clause with ROWID Pseudocolumn</p>
<pre dir="ltr">
DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id, <span class="bold">rowid</span>
    FROM emp;  <span class="bold">-- no FOR UPDATE clause</span>
 
  my_lastname   employees.last_name%TYPE;
  my_jobid      employees.job_id%TYPE;
  <span class="bold">my_rowid      UROWID;</span>
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_lastname, my_jobid, my_rowid;
    EXIT WHEN c1%NOTFOUND;
 
    UPDATE emp
    SET salary = salary * 1.02
    <span class="bold">WHERE rowid = my_rowid;  -- simulates WHERE CURRENT OF c1</span>
 
    COMMIT;
  END LOOP;
  CLOSE c1;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i36056"></a>
<div id="LNPLS00609" class="sect1">
<h2 class="sect1">Autonomous Transactions</h2>
<p>An <a id="sthref607"></a><a id="sthref608"></a><span class="bold">autonomous transaction</span> is an independent transaction started by another transaction, the main transaction. Autonomous transactions do SQL operations and commit or roll back, without committing or rolling back the main transaction.</p>
<p><a href="#i28274">Figure 6-1</a> shows how control flows from the main transaction (MT) to an autonomous transaction (AT) and back again.</p>
<div id="LNPLS608" class="figure">
<p class="titleinfigure"><a id="i28274"></a>Figure 6-1 Transaction Control Flow</p>
<img width="515" height="193" src="img/lnpls028.gif" alt="Description of Figure 6-1 follows" /><br />
<a id="sthref609" href="img_text/lnpls028.htm">Description of "Figure 6-1 Transaction Control Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Although an autonomous transaction is started by another transaction, it is not a <a id="sthref610"></a><a id="sthref611"></a>nested transaction, because:
<ul>
<li>
<p>It does not share transactional resources (such as locks) with the main transaction.</p>
</li>
<li>
<p>It does not depend on the main transaction.</p>
<p>For example, if the main transaction rolls back, nested transactions roll back, but autonomous transactions do not.</p>
</li>
<li>
<p>Its committed changes are visible to other transactions immediately.</p>
<p>A nested transaction's committed changes are not visible to other transactions until the main transaction commits.</p>
</li>
<li>
<p>Exceptions raised in an autonomous transaction cause a transaction-level rollback, not a statement-level rollback.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="LNPLS517"></a>Topics</p>
<ul>
<li>
<p><a href="#CHDFJCGD">Advantages of Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#CIHJBIFB">Transaction Context</a></p>
</li>
<li>
<p><a href="#CIHGDBAH">Transaction Visibility</a></p>
</li>
<li>
<p><a href="#CIHFEJHG">Declaring Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#CIHDIIDI">Controlling Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#CIHEHGED">Autonomous Triggers</a></p>
</li>
<li>
<p><a href="#CIHDDAIA">Invoking Autonomous Functions from SQL</a></p>
</li>
</ul>
<a id="CHDFJCGD"></a>
<div id="LNPLS518" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Advantages of Autonomous Transactions</h3>
<p>After starting, an autonomous transaction is fully independent. It shares no locks, resources, or commit-dependencies with the main transaction. You can log events, increment retry counters, and so on, even if the main transaction rolls back.</p>
<p>Autonomous transactions help you build modular, reusable software components. You can encapsulate autonomous transactions in stored subprograms. An invoking application needs not know whether operations done by that stored subprogram succeeded or failed.</p>
</div>
<!-- class="sect2" -->
<a id="CIHJBIFB"></a>
<div id="LNPLS616" class="sect2">
<h3 class="sect2">Transaction Context</h3>
<p>The main transaction shares its <a id="sthref612"></a>context with nested routines, but not with autonomous transactions. When one autonomous routine invokes another (or itself, recursively), the routines share no transaction context. When an autonomous routine invokes a nonautonomous routine, the routines share the same transaction context.</p>
</div>
<!-- class="sect2" -->
<a id="CIHGDBAH"></a>
<div id="LNPLS617" class="sect2">
<h3 class="sect2">Transaction Visibility</h3>
<p>Changes made by an autonomous transaction become <a id="sthref613"></a>visible to other transactions when the autonomous transaction commits. These changes become visible to the main transaction when it resumes, if its isolation level is set to <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> (the default).</p>
<p>If you set the <a id="sthref614"></a>isolation level of the main transaction to <code dir="ltr">SERIALIZABLE</code>, changes made by its autonomous transactions are <span class="italic">not</span> visible to the main transaction when it resumes:</p>
<pre dir="ltr">
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Transaction properties apply only to the transaction in which they are set.</p>
</li>
<li>
<p>Cursor attributes are not affected by autonomous transactions.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHFEJHG"></a>
<div id="LNPLS610" class="sect2">
<h3 class="sect2">Declaring Autonomous Transactions</h3>
<p>To declare an autonomous transaction, use the <code dir="ltr">AUTONOMOUS_TRANSACTION</code> pragma. For information about this pragma, see <a href="autotransaction_pragma.htm#i32731">"AUTONOMOUS_TRANSACTION Pragma"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
For readability, put the <code dir="ltr">AUTONOMOUS_TRANSACTION</code> pragma at the top of the declarative section. (The pragma is allowed anywhere in the declarative section.)</div>
<p>You cannot apply the <code dir="ltr">AUTONOMOUS_TRANSACTION</code> pragma to an entire package or ADT, but you can apply it to each subprogram in a package or each method of an ADT.</p>
<p><a href="#BABIIHBJ">Example 6-44</a> marks a package function as autonomous.</p>
<div id="LNPLS611" class="example">
<p class="titleinexample"><a id="BABIIHBJ"></a>Example 6-44 Declaring Autonomous Function in Package</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE emp_actions AS  -- <span class="bold">package specification</span>
  <span class="bold">FUNCTION raise_salary</span> (emp_id NUMBER, sal_raise NUMBER)
  RETURN NUMBER;
END emp_actions;
/
CREATE OR REPLACE PACKAGE BODY emp_actions AS  -- <span class="bold">package body</span>
  -- code for function raise_salary
  <span class="bold">FUNCTION raise_salary</span> (emp_id NUMBER, sal_raise NUMBER)
  RETURN NUMBER IS
    <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span>;
    new_sal NUMBER(8,2);
  BEGIN
    UPDATE employees SET salary =
      salary + sal_raise WHERE employee_id = emp_id;
    COMMIT;
    SELECT salary INTO new_sal FROM employees
      WHERE employee_id = emp_id;
    RETURN new_sal;
  END raise_salary;
END emp_actions;
/
</pre></div>
<!-- class="example" -->
<p><a href="#BABEECAF">Example 6-45</a> marks a standalone subprogram as autonomous.</p>
<div id="LNPLS612" class="example">
<p class="titleinexample"><a id="BABEECAF"></a>Example 6-45 Declaring Autonomous Standalone Procedure</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE lower_salary
   (emp_id NUMBER, amount NUMBER)
AS
  <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span>;
BEGIN
  UPDATE employees
  SET salary =  salary - amount
  WHERE employee_id = emp_id;

  COMMIT;
END lower_salary;
/
</pre></div>
<!-- class="example" -->
<p><a href="#BABIJEID">Example 6-46</a> marks a schema-level PL/SQL block as autonomous. (A nested PL/SQL block cannot be autonomous.)</p>
<div id="LNPLS613" class="example">
<p class="titleinexample"><a id="BABIJEID"></a>Example 6-46 Declaring Autonomous PL/SQL Block</p>
<pre dir="ltr">
DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
DECLARE
  <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span>
  emp_id NUMBER(6)   := 200;
  amount NUMBER(6,2) := 200;
BEGIN
  UPDATE employees
  SET salary =  salary - amount
  WHERE employee_id = emp_id;
 
  COMMIT;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHDIIDI"></a>
<div id="LNPLS99982" class="sect2">
<h3 class="sect2">Controlling Autonomous Transactions</h3>
<p>The first SQL statement in an autonomous routine begins a transaction. When one transaction ends, the next SQL statement begins another transaction. All SQL statements run since the last commit or rollback comprise the current transaction. To control autonomous transactions, use these statements, which apply only to the current (active) transaction:</p>
<ul>
<li>
<p><code dir="ltr">COMMIT</code></p>
</li>
<li>
<p><code dir="ltr">ROLLBACK</code> [<code dir="ltr">TO</code> <code dir="ltr"><span class="codeinlineitalic">savepoint_name</span></code>]</p>
</li>
<li>
<p><code dir="ltr">SAVEPOINT</code> <code dir="ltr"><span class="codeinlineitalic">savepoint_name</span></code></p>
</li>
<li>
<p><code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code></p>
</li>
</ul>
<p class="subhead2"><a id="LNPLS519"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHCFGHJ">Entering and Exiting</a></p>
</li>
<li>
<p><a href="#CIHCIJGC">Committing and Rolling Back</a></p>
</li>
<li>
<p><a href="#CIHBFADB">Savepoints</a></p>
</li>
<li>
<p><a href="#CIHECEJI">Avoiding Errors with Autonomous Transactions</a></p>
</li>
</ul>
<a id="CIHCFGHJ"></a>
<div id="LNPLS618" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Entering and Exiting</h4>
<p>When you enter the executable section of an autonomous routine, the main transaction suspends. When you exit the routine, the main transaction resumes.</p>
<p>If you try to exit an active autonomous transaction without committing or rolling back, the database raises an exception. If the exception goes unhandled, or if the transaction ends because of some other unhandled exception, the transaction is rolled back.</p>
<p>To exit normally, you must explicitly commit or roll back all autonomous transactions. If the routine (or any routine invoked by it) has pending transactions, PL/SQL raises an exception and the pending transactions are rolled back.</p>
</div>
<!-- class="sect3" -->
<a id="CIHCIJGC"></a>
<div id="LNPLS619" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Committing and Rolling Back</h4>
<p><a id="sthref615"></a><code dir="ltr">COMMIT</code> and <a id="sthref616"></a><code dir="ltr">ROLLBACK</code> end the active autonomous transaction but do not exit the autonomous routine. When one transaction ends, the next SQL statement begins another transaction. A single autonomous routine can contain several autonomous transactions, if it issues several <code dir="ltr">COMMIT</code> statements.</p>
</div>
<!-- class="sect3" -->
<a id="CIHBFADB"></a>
<div id="LNPLS620" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Savepoints</h4>
<p><a id="sthref617"></a>The scope of a savepoint is the transaction in which it is defined. Savepoints defined in the main transaction are unrelated to savepoints defined in its autonomous transactions. In fact, the main transaction and an autonomous transaction can use the same savepoint names.</p>
<p>You can roll back only to savepoints marked in the current transaction. In an autonomous transaction, you cannot roll back to a savepoint marked in the main transaction. To do so, you must resume the main transaction by exiting the autonomous routine.</p>
<p>When in the main transaction, rolling back to a savepoint marked before you started an autonomous transaction does <span class="italic">not</span> roll back the autonomous transaction. Remember, autonomous transactions are fully independent of the main transaction.</p>
</div>
<!-- class="sect3" -->
<a id="CIHECEJI"></a>
<div id="LNPLS621" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Avoiding Errors with Autonomous Transactions</h4>
<p>You cannot run a <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement in your autonomous routine while your autonomous transaction is open. You must close the autonomous transaction before running the <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement. This is normally accomplished by committing or rolling back the autonomous transaction before running the <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement.</p>
<p>To avoid some common errors, remember:</p>
<ul>
<li>
<p>If an autonomous transaction attempts to access a resource held by the main transaction, a <a id="sthref618"></a>deadlock can occur. The database raises an exception in the autonomous transaction, which is rolled back if the exception goes unhandled.</p>
</li>
<li>
<p>The database <a id="sthref619"></a>initialization parameter <code dir="ltr">TRANSACTIONS</code> specifies the maximum number of <a id="sthref620"></a>concurrent transactions. That number might be exceeded because an autonomous transaction runs concurrently with the main transaction.</p>
</li>
<li>
<p>If you try to exit an active autonomous transaction without committing or rolling back, the database raises an exception. If the exception goes unhandled, the transaction is rolled back.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHEHGED"></a>
<div id="LNPLS622" class="sect2">
<h3 class="sect2">Autonomous Triggers</h3>
<p>A trigger must be <a id="sthref621"></a><a id="sthref622"></a>autonomous to run <a id="sthref623"></a><a id="sthref624"></a>TCL or <a id="sthref625"></a><a id="sthref626"></a>DDL statements. To run DDL statements, the trigger must use native dynamic SQL.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="triggers.htm#g1043102">Chapter 9, "PL/SQL Triggers,"</a> for general information about triggers</p>
</li>
<li>
<p><a href="#i7112">"Description of Static SQL"</a> for general information about TCL statements</p>
</li>
<li>
<p><a class="olink SQLRF30041" href="../../server.112/e41084/statements_1001.htm#SQLRF30041"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about DDL statements</p>
</li>
<li>
<p><a href="dynamic.htm#i13130">"Native Dynamic SQL"</a> for information about native dynamic SQL</p>
</li>
</ul>
</div>
<p>One use of triggers is to log events transparently&mdash;for example, to log all inserts into a table, even those that roll back. In <a href="#CJAICEDA">Example 6-47</a>, whenever a row is inserted into the <code dir="ltr">EMPLOYEES</code> table, a trigger inserts the same row into a log table. Because the trigger is autonomous, it can commit changes to the log table regardless of whether they are committed to the main table.</p>
<div id="LNPLS623" class="example">
<p class="titleinexample"><a id="CJAICEDA"></a>Example 6-47 Autonomous Trigger Logs INSERT Statements</p>
<pre dir="ltr">
DROP TABLE emp;
CREATE TABLE emp AS SELECT * FROM employees;
 
-- Log table:
 
DROP TABLE log;
CREATE TABLE log (
  log_id   NUMBER(6),
  up_date  DATE,
  new_sal  NUMBER(8,2),
  old_sal  NUMBER(8,2)
);
 
-- Autonomous trigger on emp table:
 
CREATE OR REPLACE <span class="bold">TRIGGER log_sal</span>
  BEFORE UPDATE OF salary ON emp FOR EACH ROW
DECLARE
  <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span>
BEGIN
  INSERT INTO log (
    log_id,
    up_date,
    new_sal,
    old_sal
  )
  VALUES (
    :old.employee_id,
    SYSDATE,
    :new.salary,
    :old.salary
  );
  <span class="bold">COMMIT;</span>
END;
/
UPDATE emp
SET salary = salary * 1.05
WHERE employee_id = 115;
 
<span class="bold">COMMIT;</span>
 
UPDATE emp
SET salary = salary * 1.05
WHERE employee_id = 116;
 
<span class="bold">ROLLBACK;</span>
 
-- Show that both committed and rolled-back updates
-- add rows to log table
 
<span class="bold">SELECT * FROM log</span>
<span class="bold">WHERE log_id = 115 OR log_id = 116;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">
    LOG_ID UP_DATE      NEW_SAL    OLD_SAL
---------- --------- ---------- ----------
       115 28-APR-10    3417.75       3255
       116 28-APR-10    3197.25       3045
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDFJBDA">Example 6-48</a>, an autonomous trigger uses native dynamic SQL (an <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement) to drop a temporary table after a row is inserted into the table <code dir="ltr">log</code>.</p>
<div id="LNPLS520" class="example">
<p class="titleinexample"><a id="CHDFJBDA"></a>Example 6-48 Autonomous Trigger Uses Native Dynamic SQL for DDL</p>
<pre dir="ltr">
DROP TABLE temp;
CREATE TABLE temp (
  temp_id NUMBER(6),
  up_date DATE
);

CREATE OR REPLACE <span class="bold">TRIGGER drop_temp_table</span>
  AFTER INSERT ON log
DECLARE 
  <span class="bold">PRAGMA</span> <span class="bold">AUTONOMOUS_TRANSACTION</span>;
BEGIN
  <span class="bold">EXECUTE IMMEDIATE 'DROP TABLE temp';</span>
  COMMIT;
END;
/
-- Show how trigger works
<span class="bold">SELECT * FROM temp;</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">no rows selected</span>

INSERT INTO log (log_id, up_date, new_sal, old_sal)
VALUES (999, SYSDATE, 5000, 4500);
 
1 row created.
 
<span class="bold">SELECT * FROM temp;</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">SELECT * FROM temp</span>
              <span class="bold">*</span>
<span class="bold">ERROR at line 1:</span>
<span class="bold">ORA-00942: table or view does not exist</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHDDAIA"></a>
<div id="LNPLS624" class="sect2">
<h3 class="sect2">Invoking Autonomous Functions from SQL</h3>
<p>A function invoked from SQL statements must obey rules meant to control side effects (for details, see<a href="subprograms.htm#i22204">"Subprogram Side Effects"</a>).</p>
<p>By definition, an autonomous routine never reads or writes database state (that is, it neither queries nor modifies any database table).</p>
<p>The package function <code dir="ltr">log_msg</code> in <a href="#CJAIGCJF">Example 6-49</a> is autonomous. Therefore, when the query invokes the function, the function inserts a message into database table <code dir="ltr">debug_output</code> without violating the rule against writing database state (modifying database tables).</p>
<div id="LNPLS625" class="example">
<p class="titleinexample"><a id="CJAIGCJF"></a>Example 6-49 Invoking Autonomous Function</p>
<pre dir="ltr">
DROP TABLE debug_output;
CREATE TABLE debug_output (message VARCHAR2(200));
 
CREATE OR REPLACE PACKAGE debugging AS
  FUNCTION log_msg (msg VARCHAR2) RETURN VARCHAR2;
END debugging;
/
CREATE OR REPLACE PACKAGE BODY debugging AS
  FUNCTION log_msg (msg VARCHAR2) RETURN VARCHAR2 IS
    <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION;</span>
  BEGIN
    INSERT INTO debug_output (message) VALUES (msg);
    COMMIT;
    RETURN msg;
  END;
END debugging;
/
-- Invoke package function from query
DECLARE
  my_emp_id    NUMBER(6);
  my_last_name VARCHAR2(25);
  my_count     NUMBER;
BEGIN
  my_emp_id := 120;
 
  SELECT <span class="bold">debugging.log_msg(last_name)</span>
  INTO my_last_name
  FROM employees
  WHERE employee_id = my_emp_id;
 
  /* Even if you roll back in this scope,
     the insert into 'debug_output' remains committed,
     because it is part of an autonomous transaction. */
 
  ROLLBACK;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="composites.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="dynamic.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
