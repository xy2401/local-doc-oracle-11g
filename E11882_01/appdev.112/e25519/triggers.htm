<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Triggers</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:52:57Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="subprograms.htm" title="Previous" type="text/html" />
<link rel="Next" href="packages.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/99</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='triggers'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="LNPLS020" class="chapter"><a id="g1043102"></a>
<h1 class="chapter"><span class="secnum">9</span> PL/SQL Triggers</h1>
<p>A <a id="sthref762"></a>trigger is like a stored procedure that Oracle Database invokes automatically whenever a specified event occurs.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The database can detect only system-defined events. You cannot define your own events.</div>
<p class="subhead2"><a id="LNPLS614"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHJJGJE">Overview of Triggers</a></p>
</li>
<li>
<p><a href="#CIHHDEEJ">Reasons to Use Triggers</a></p>
</li>
<li>
<p><a href="#CIHEHBEB">DML Triggers</a></p>
</li>
<li>
<p><a href="#CIHEFBJA">System Triggers</a></p>
</li>
<li>
<p><a href="#CIHEGACF">Subprograms Invoked by Triggers</a></p>
</li>
<li>
<p><a href="#i1006994">Trigger Compilation, Invalidation, and Recompilation</a></p>
</li>
<li>
<p><a href="#CIHGJCFI">Exception Handling in Triggers</a></p>
</li>
<li>
<p><a href="#i1006211">Trigger Design Guidelines</a></p>
</li>
<li>
<p><a href="#g1042050">Trigger Restrictions</a></p>
</li>
<li>
<p><a href="#g1041767">Order in Which Triggers Fire</a></p>
</li>
<li>
<p><a href="#CIHJJJHG">Trigger Enabling and Disabling</a></p>
</li>
<li>
<p><a href="#i1007033">Trigger Changing and Debugging</a></p>
</li>
<li>
<p><a href="#BCFGIDEB">Triggers and Oracle Database Data Transfer Utilities</a></p>
</li>
<li>
<p><a href="#i1007895">Triggers for Publishing Events</a></p>
</li>
<li>
<p><a href="#i1007097">Views for Information About Triggers</a></p>
</li>
</ul>
<a id="CIHJJGJE"></a>
<div id="LNPLS2001" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of Triggers</h2>
<p>Like a stored procedure, a trigger is a named PL/SQL unit that is stored in the database and can be invoked repeatedly. Unlike a stored procedure, you can enable and disable a trigger, but you cannot explicitly invoke it. While a trigger is <span class="bold">enabled</span>, the database automatically invokes it&mdash;that is, the trigger <span class="bold">fires</span>&mdash;whenever its triggering event occurs. While a trigger is <span class="bold">disabled</span>, it does not fire.</p>
<p>You create a trigger with the <code >CREATE</code> <code dir="ltr">TRIGGER</code> statement. You specify the <span class="bold">triggering event</span> in terms of <span class="bold">triggering statements</span> and the item on which they act. The trigger is said to be <span class="bold">created on</span> or <span class="bold">defined on</span> the item, which is either a table, a view, a schema, or the database. You also specify the <span class="bold">timing point</span>, which determines whether the trigger fires before or after the triggering statement runs and whether it fires for each row that the triggering statement affects. By default, a trigger is created in the enabled state. For more information about the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement, see <a href="create_trigger.htm#i2235611">"CREATE TRIGGER Statement"</a>.</p>
<p>If the trigger is created on a table or view, then the triggering event is composed of DML statements, and the trigger is called a <span class="bold">DML trigger</span>. For more information, see <a href="#CIHEHBEB">"DML Triggers"</a>.</p>
<p>If the trigger is created on a schema or the database, then the triggering event is composed of either DDL or database operation statements, and the trigger is called a <span class="bold">system trigger</span>. For more information, see <a href="#CIHEFBJA">"System Triggers"</a>.</p>
<p>A <a id="sthref763"></a><span class="bold">conditional trigger</span> has a <code dir="ltr">WHEN</code> clause that specifies a SQL condition that the database evaluates for each row that the triggering statement affects. For more information about the <code dir="ltr">WHEN</code> clause, see <a href="create_trigger.htm#CIHBJHFE">"WHEN (<span class="italic">condition</span>)"</a>.</p>
<p>When a trigger fires, tables that the trigger references might be undergoing changes made by SQL statements in other users' transactions. <a id="sthref764"></a>SQL statements running in triggers follow the same rules that standalone SQL statements do. Specifically:</p>
<ul>
<li>
<p>Queries in the trigger see the current read-consistent materialized view of referenced tables and any data changed in the same transaction.</p>
</li>
<li>
<p>Updates in the trigger wait for existing data locks to be released before proceeding.</p>
</li>
</ul>
<p>An <a id="sthref765"></a><code dir="ltr"><span class="codeinlinebold">INSTEAD</span></code> <code dir="ltr"><span class="codeinlinebold">OF</span></code> <span class="bold">trigger</span> is either:</p>
<ul>
<li>
<p>A DML trigger created on either a noneditioning view or a nested table column of a noneditioning view</p>
</li>
<li>
<p>A system trigger defined on a <code dir="ltr">CREATE</code> statement</p>
</li>
</ul>
<p>The database fires the <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger instead of running the triggering statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A trigger is often called by the name of its triggering statement (for example, <code dir="ltr"><span class="codeinlineitalic">DELETE</span></code> <span class="italic">trigger</span> or <code dir="ltr"><span class="codeinlineitalic">LOGON</span></code> <span class="italic">trigger</span>), the name of the item on which it is defined (for example, <code dir="ltr"><span class="codeinlineitalic">DATABASE</span></code> <span class="italic">trigger</span> or <code dir="ltr"><span class="codeinlineitalic">SCHEMA</span></code> <span class="italic">trigger</span>), or its timing point (for example, <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">statement trigger</span> or <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">each row trigger</span>).</div>
</div>
<!-- class="sect1" -->
<a id="CIHHDEEJ"></a>
<div id="LNPLS723" class="sect1">
<h2 class="sect1">Reasons to Use Triggers</h2>
<p>Triggers let you customize your database management system. For example, you can use triggers to:</p>
<ul>
<li>
<p>Automatically generate virtual column values</p>
</li>
<li>
<p>Log events</p>
</li>
<li>
<p>Gather statistics on table access</p>
</li>
<li>
<p>Modify table data when DML statements are issued against views</p>
</li>
<li>
<p>Enforce referential integrity when child and parent tables are on different nodes of a distributed database</p>
</li>
<li>
<p>Publish information about database events, user events, and SQL statements to subscribing applications</p>
</li>
<li>
<p>Prevent DML operations on a table after regular business hours</p>
</li>
<li>
<p>Prevent invalid transactions</p>
</li>
<li>
<p>Enforce complex business or referential integrity rules that you cannot define with constraints (see <a href="#CIHCEBAE">"How Triggers and Constraints Differ"</a>)</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Triggers are not reliable <a id="sthref766"></a><a id="sthref767"></a>security mechanisms, because they are programmatic and easy to disable. For high-assurance security, use Oracle Database Vault, described in <a class="olink DVADM" href="../../server.112/e23090/toc.htm"><span class="italic">Oracle Database Vault Administrator's Guide</span></a>.</div>
<p class="subhead2"><a id="CIHCEBAE"></a><a id="LNPLS769"></a>How Triggers and Constraints Differ</p>
<p>Both triggers and <a id="sthref768"></a>constraints can constrain data input, but they differ significantly.</p>
<p>A trigger always applies to new data only. For example, a trigger can prevent a DML statement from inserting a <code dir="ltr">NULL</code> value into a database column, but the column might contain <code dir="ltr">NULL</code> values that were inserted into the column before the trigger was defined or while the trigger was disabled.</p>
<p>A constraint can apply either to new data only (like a trigger) or to both new and existing data. Constraint behavior depends on constraint state, as explained in <a class="olink SQLRF52214" href="../../server.112/e41084/clauses002.htm#SQLRF52214"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>Constraints are easier to write and less error-prone than triggers that enforce the same rules. However, triggers can enforce some complex business rules that constraints cannot. Oracle strongly recommends that you use triggers to constrain data input only in these situations:</p>
<ul>
<li>
<p>To enforce referential integrity when child and parent tables are on different nodes of a distributed database</p>
</li>
<li>
<p>To enforce complex business or referential integrity rules that you cannot define with constraints</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS004" href="../../appdev.112/e41502/adfns_constraints.htm#ADFNS004"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for information about using constraints to enforce business rules and prevent the entry of invalid information into tables</p>
</li>
<li>
<p><a href="#BCFCAIGG">"Triggers for Ensuring Referential Integrity"</a> for information about using triggers and constraints to maintain referential integrity between parent and child tables</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="CIHEHBEB"></a>
<div id="LNPLS99888" class="sect1">
<h2 class="sect1">DML Triggers</h2>
<p>A <a id="sthref769"></a><span class="bold">DML trigger</span> is created on either a table or view, and its triggering event is composed of the DML statements <code dir="ltr">DELETE</code>, <code dir="ltr">INSERT</code>, and <code dir="ltr">UPDATE</code>. To create a trigger that fires in response to a <code dir="ltr">MERGE</code> statement, create triggers on the <code dir="ltr">INSERT</code> and <code dir="ltr">UPDATE</code> statements to which the <code dir="ltr">MERGE</code> operation decomposes.</p>
<p>A DML trigger is either simple or compound.</p>
<p>A <a id="sthref770"></a><span class="bold">simple DML trigger</span> fires at exactly one of these <a id="sthref771"></a>timing points:</p>
<ul>
<li>
<p>Before the triggering statement runs</p>
<p>(The trigger is called a <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">statement trigger</span> or <a id="sthref772"></a><span class="italic">statement-level</span> <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">trigger.</span>)</p>
</li>
<li>
<p>After the triggering statement runs</p>
<p>(The trigger is called an <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">statement trigger</span> or <span class="italic">statement-level</span> <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">trigger.</span>)</p>
</li>
<li>
<p>Before each row that the triggering statement affects</p>
<p>(The trigger is called a <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">each row trigger</span> or <a id="sthref773"></a><span class="italic">row-level</span> <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">trigger.</span>)</p>
</li>
<li>
<p>After each row that the triggering statement affects</p>
<p>(The trigger is called an <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">each row trigger</span> or <span class="italic">row-level</span> <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">trigger.</span>)</p>
</li>
</ul>
<p>A <span class="bold">compound DML trigger</span> created on a table or editioning view can fire at one, some, or all of the preceding timing points. Compound DML triggers help program an approach where you want the actions that you implement for the various timing points to share common data. For more information, see <a href="#CIHEFGFD">"Compound DML Triggers"</a>.</p>
<p>A simple or compound DML trigger that fires at row level can access the data in the row that it is processing. For details, see <a href="#CIHEIHAC">"Correlation Names and Pseudorecords"</a>.</p>
<p>An <code dir="ltr"><span class="codeinlinebold">INSTEAD</span></code> <code dir="ltr"><span class="codeinlinebold">OF</span></code> <span class="bold">DML</span> <span class="bold">trigger</span> is a DML trigger created on either a noneditioning view or a nested table column of a noneditioning view. For more information, see <a href="#i1006376">"INSTEAD OF DML Triggers"</a>.</p>
<p>A <a id="sthref774"></a><span class="bold">crossedition trigger</span> is a simple or compound DML trigger for use only in edition-based redefinition. For information about crossedition triggers, see <a class="olink ADFNS0203" href="../../appdev.112/e41502/adfns_editions.htm#ADFNS0203"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
<p>Except in an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger, a triggering <code dir="ltr">UPDATE</code> statement can include a column list. With a column list, the trigger fires only when a specified column is updated. Without a column list, the trigger fires when any column of the associated table is updated. For more information about the column list, see <a href="create_trigger.htm#CIHBAGHF">"<span class="italic">dml_event_clause</span>"</a>.</p>
<p class="subhead2"><a id="LNPLS615"></a>Topics</p>
<ul>
<li>
<p><a href="#BCFIDDBB">Conditional Predicates for Detecting Triggering DML Statement</a></p>
</li>
<li>
<p><a href="#CIHEIHAC">Correlation Names and Pseudorecords</a></p>
</li>
<li>
<p><a href="#g1662184">OBJECT_VALUE Pseudocolumn</a></p>
</li>
<li>
<p><a href="#i1006376">INSTEAD OF DML Triggers</a></p>
</li>
<li>
<p><a href="#CIHEFGFD">Compound DML Triggers</a></p>
</li>
<li>
<p><a href="#BCFCAIGG">Triggers for Ensuring Referential Integrity</a></p>
</li>
</ul>
<a id="BCFIDDBB"></a>
<div id="LNPLS750" class="sect2">
<h3 class="sect2">Conditional Predicates for Detecting Triggering DML Statement</h3>
<p>The triggering event of a DML trigger can be composed of multiple triggering statements. When one of them fires the trigger, the trigger can determine which one by using these <a id="sthref775"></a><span class="bold">conditional predicates</span>:</p>
<div class="inftblinformal">
<table class="cellalignment1089" title="Conditional Predicates" summary="This table has two columns. The left column lists the conditional predicates. The right column gives the condition under which each conditional predicate is true." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t6">Conditional Predicate</th>
<th class="cellalignment1090" id="r1c2-t6">TRUE if and only if:</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t6" headers="r1c1-t6"><a id="sthref776"></a><code dir="ltr">INSERTING</code></td>
<td class="cellalignment1091" headers="r2c1-t6 r1c2-t6">An <code dir="ltr">INSERT</code> statement fired the trigger.</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t6" headers="r1c1-t6"><a id="sthref777"></a><code dir="ltr">UPDATING</code></td>
<td class="cellalignment1091" headers="r3c1-t6 r1c2-t6">An <code dir="ltr">UPDATE</code> statement fired the trigger.</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t6" headers="r1c1-t6"><code dir="ltr">UPDATING ('</code><code dir="ltr"><span class="codeinlineitalic">column</span></code><code dir="ltr">')</code></td>
<td class="cellalignment1091" headers="r4c1-t6 r1c2-t6">An <code dir="ltr">UPDATE</code> statement that affected the specified column fired the trigger.</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t6" headers="r1c1-t6"><a id="sthref778"></a><code dir="ltr">DELETING</code></td>
<td class="cellalignment1091" headers="r5c1-t6 r1c2-t6">A <code dir="ltr">DELETE</code> statement fired the trigger.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>A conditional predicate can appear wherever a <code dir="ltr">BOOLEAN</code> expression can appear.</p>
<p><a href="#CIHBCDJH">Example 9-1</a> creates a DML trigger that uses conditional predicates to determine which of its four possible triggering statements fired it.</p>
<div id="LNPLS652" class="example">
<p class="titleinexample"><a id="CIHBCDJH"></a>Example 9-1 Trigger Uses Conditional Predicates to Detect Triggering Statement</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER t
  BEFORE
    <span class="bold">INSERT OR</span>
    <span class="bold">UPDATE OF salary, department_id OR</span>
    <span class="bold">DELETE</span>
  ON employees
BEGIN
  CASE
    WHEN <span class="bold">INSERTING</span> THEN
      DBMS_OUTPUT.PUT_LINE('Inserting');
    WHEN <span class="bold">UPDATING('salary')</span> THEN
      DBMS_OUTPUT.PUT_LINE('Updating salary');
    WHEN <span class="bold">UPDATING('department_id')</span> THEN
      DBMS_OUTPUT.PUT_LINE('Updating department ID');
    WHEN <span class="bold">DELETING</span> THEN
      DBMS_OUTPUT.PUT_LINE('Deleting');
  END CASE;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHEIHAC"></a>
<div id="LNPLS99955" class="sect2">
<h3 class="sect2">Correlation Names and Pseudorecords</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This topic applies only to triggers that fire at row level&mdash;that is, row-level simple DML triggers and compound DML triggers with row-level timing point sections.</div>
<p>A trigger that fires at row level can access the data in the row that it is processing by using <a id="sthref779"></a><span class="bold">correlation names</span>. The default correlation names are <a id="sthref780"></a><code dir="ltr">OLD</code>, <a id="sthref781"></a><code dir="ltr">NEW</code>, and <a id="sthref782"></a><code dir="ltr">PARENT</code>. To change the correlation names, use the <code dir="ltr">REFERENCING</code> clause of the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement (see <a href="create_trigger.htm#BABEBAAB">"<span class="italic">referencing_clause</span> ::="</a>).</p>
<p>If the trigger is created on a nested table in a view (see <a href="create_trigger.htm#BABGDFBI">"<span class="italic">dml_event_clause</span> ::="</a>), then <code dir="ltr">OLD</code> and <code dir="ltr">NEW</code> refer to the current row of the <a id="sthref783"></a>nested table, and <code dir="ltr">PARENT</code> refers to the current row of the parent table. If the trigger is created on a table or view, then <code dir="ltr">OLD</code> and <code dir="ltr">NEW</code> refer to the current row of the table or view, and <code dir="ltr">PARENT</code> is undefined.</p>
<p><code dir="ltr">OLD</code>, <code dir="ltr">NEW</code>, and <code dir="ltr">PARENT</code> are also called <a id="sthref784"></a><span class="bold">pseudorecords</span>, because they have record structure, but are allowed in fewer contexts than records are. The structure of a pseudorecord is <code dir="ltr"><span class="codeinlineitalic">table_name</span></code><code dir="ltr">%ROWTYPE</code>, where <code dir="ltr"><span class="codeinlineitalic">table_name</span></code> is the name of the table on which the trigger is created (for <code dir="ltr">OLD</code> and <code dir="ltr">NEW</code>) or the name of the parent table (for <code dir="ltr">PARENT</code>).</p>
<p>In the <code dir="ltr"><span class="codeinlineitalic">trigger_body</span></code> of a simple trigger or the <code dir="ltr"><span class="codeinlineitalic">tps_body</span></code> of a compound trigger, a correlation name is a <a id="sthref785"></a>placeholder for a bind variable. Reference the field of a pseudorecord with this syntax:</p>
<pre dir="ltr">
:<span class="italic">pseudorecord_name</span>.<span class="italic">field_name</span>
</pre>
<p>In the <code dir="ltr">WHEN</code> clause of a conditional trigger, a correlation name is not a placeholder for a bind variable. Therefore, omit the colon in the preceding syntax.</p>
<p><a href="#CIHDBHIH">Table 9-1</a> shows the values of <code dir="ltr">OLD</code> and <code dir="ltr">NEW</code> fields for the row that the triggering statement is processing.</p>
<div id="LNPLS655" class="tblformal">
<p class="titleintable"><a id="sthref786"></a><a id="CIHDBHIH"></a>Table 9-1 OLD and NEW Pseudorecord Field Values</p>
<table class="cellalignment1092" title="OLD and NEW Pseudorecord Field Values" summary="This table has three columns. The first column lists the three possible triggering statements for a DML trigger. The second and third columns list the field values of the pseudorecords OLD and NEW, respectively, for each triggering statement." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t8">Triggering Statement</th>
<th class="cellalignment1090" id="r1c2-t8">OLD.<span class="italic">field</span> Value</th>
<th class="cellalignment1090" id="r1c3-t8">NEW.<span class="italic">field</span> Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t8" headers="r1c1-t8">
<p><code dir="ltr">INSERT</code></p>
</td>
<td class="cellalignment1091" headers="r2c1-t8 r1c2-t8">
<p><code dir="ltr">NULL</code></p>
</td>
<td class="cellalignment1091" headers="r2c1-t8 r1c3-t8">
<p>Post-insert value</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t8" headers="r1c1-t8">
<p><code dir="ltr">UPDATE</code></p>
</td>
<td class="cellalignment1091" headers="r3c1-t8 r1c2-t8">
<p>Pre-update value</p>
</td>
<td class="cellalignment1091" headers="r3c1-t8 r1c3-t8">
<p>Post-update value</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t8" headers="r1c1-t8">
<p><code dir="ltr">DELETE</code></p>
</td>
<td class="cellalignment1091" headers="r4c1-t8 r1c2-t8">
<p>Pre-delete value</p>
</td>
<td class="cellalignment1091" headers="r4c1-t8 r1c3-t8">
<p><code dir="ltr">NULL</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The restrictions on pseudorecords are:</p>
<ul>
<li>
<p>A pseudorecord cannot appear in a record-level operation.</p>
<p>For example, the trigger cannot include this statement:</p>
<pre dir="ltr">
:NEW := NULL;
</pre></li>
<li>
<p>A pseudorecord cannot be an actual <a id="sthref787"></a>subprogram parameter.</p>
<p>(A pseudorecord field can be an actual subprogram parameter.)</p>
</li>
<li>
<p>The trigger cannot change <code dir="ltr">OLD</code> field values.</p>
<p>Trying to do so raises ORA-04085.</p>
</li>
<li>
<p>If the triggering statement is <code dir="ltr">DELETE</code>, then the trigger cannot change <code dir="ltr">NEW</code> field values.</p>
<p>Trying to do so raises ORA-04084.</p>
</li>
<li>
<p>An <code dir="ltr">AFTER</code> trigger cannot change <code dir="ltr">NEW</code> field values, because the triggering statement runs before the trigger fires.</p>
<p>Trying to do so raises ORA-04084.</p>
</li>
</ul>
<p>A <code dir="ltr">BEFORE</code> trigger can change <code dir="ltr">NEW</code> field values before a triggering <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement puts them in the table.</p>
<p>If a statement triggers both a <code dir="ltr">BEFORE</code> trigger and an <code dir="ltr">AFTER</code> trigger, and the <code dir="ltr">BEFORE</code> trigger changes a <code dir="ltr">NEW</code> field value, then the <code dir="ltr">AFTER</code> trigger "sees" that change.</p>
<p><a href="#BCFBDJEC">Example 9-2</a> creates a log table and a trigger that inserts a row in the log table after any <code dir="ltr">UPDATE</code> statement affects the <code dir="ltr">SALARY</code> column of the <code dir="ltr">EMPLOYEES</code> table, and then updates <code dir="ltr">EMPLOYEES</code>.<code dir="ltr">SALARY</code> and shows the log table.</p>
<div id="LNPLS660" class="example">
<p class="titleinexample"><a id="BCFBDJEC"></a>Example 9-2 Trigger Logs Changes to EMPLOYEES.SALARY</p>
<p>Create log table:</p>
<pre dir="ltr">
DROP TABLE Emp_log;
CREATE TABLE Emp_log (
  Emp_id     NUMBER,
  Log_date   DATE,
  New_salary NUMBER,
  Action     VARCHAR2(20));
 
</pre>
<p>Create trigger that inserts row in log table after <code dir="ltr">EMPLOYEES</code>.<code dir="ltr">SALARY</code> is updated:</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER log_salary_increase
  AFTER UPDATE OF salary ON employees
  FOR EACH ROW
BEGIN
  INSERT INTO Emp_log (Emp_id, Log_date, New_salary, Action)
  VALUES (:NEW.employee_id, SYSDATE, :NEW.salary, 'New Salary');
END;
/
</pre>
<p>Update <code dir="ltr">EMPLOYEES</code>.<code dir="ltr">SALARY</code>:</p>
<pre dir="ltr">
UPDATE employees
SET salary = salary + 1000.0
WHERE Department_id = 20;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
2 rows updated.
 
</pre>
<p>Show log table:</p>
<pre dir="ltr">
SELECT * FROM Emp_log;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
    EMP_ID LOG_DATE  NEW_SALARY ACTION
---------- --------- ---------- --------------------
       201 28-APR-10   15049.13 New Salary
       202 28-APR-10    6945.75 New Salary
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#CIHHEJCD">Example 9-3</a> creates a conditional trigger that prints salary change information whenever a <code dir="ltr">DELETE</code>, <code dir="ltr">INSERT</code>, or <code dir="ltr">UPDATE</code> statement affects the <code dir="ltr">EMPLOYEES</code> table&mdash;unless that information is about the President. The database evaluates the <code dir="ltr">WHEN</code> condition for each affected row. If the <code dir="ltr">WHEN</code> condition is <code dir="ltr">TRUE</code> for an affected row, then the trigger fires for that row before the triggering statement runs. If the <code dir="ltr">WHEN</code> condition is not <code dir="ltr">TRUE</code> for an affected row, then trigger does not fire for that row, but the triggering statement still runs.</p>
<div id="LNPLS724" class="example">
<p class="titleinexample"><a id="CIHHEJCD"></a>Example 9-3 Conditional Trigger Prints Salary Change Information</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER print_salary_changes
  BEFORE DELETE OR INSERT OR UPDATE ON employees
  FOR EACH ROW
  <span class="bold">WHEN (NEW.job_id &lt;&gt; 'AD_PRES')  -- do not print information about President</span>
DECLARE
  sal_diff  NUMBER;
BEGIN
  sal_diff  := :NEW.salary  - :OLD.salary;
  DBMS_OUTPUT.PUT(:NEW.last_name || ': ');
  DBMS_OUTPUT.PUT('Old salary = ' || :OLD.salary || ', ');
  DBMS_OUTPUT.PUT('New salary = ' || :NEW.salary || ', ');
  DBMS_OUTPUT.PUT_LINE('Difference: ' || sal_diff);
END;
/
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT last_name, department_id, salary, job_id
FROM employees
WHERE department_id IN (10, 20, 90)
ORDER BY department_id, last_name;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
LAST_NAME                 DEPARTMENT_ID     SALARY JOB_ID
------------------------- ------------- ---------- ----------
Whalen                               10       2800 AD_ASST
Fay                                  20       6000 MK_REP
Hartstein                            20      13000 MK_MAN
De Haan                              90      17000 AD_VP
<span class="bold">King                                 90      24000 AD_PRES</span>
Kochhar                              90      17000 AD_VP
 
<span class="bold">6 rows selected.</span>
</pre>
<p>Triggering statement:</p>
<pre dir="ltr">
UPDATE employees
SET salary = salary * 1.05
WHERE department_id IN (10, 20, 90);
</pre>
<p>Result:</p>
<pre dir="ltr">
Whalen: Old salary = 2800, New salary = 2940, Difference: 140
Hartstein: Old salary = 13000, New salary = 13650, Difference: 650
Fay: Old salary = 6000, New salary = 6300, Difference: 300
Kochhar: Old salary = 17000, New salary = 17850, Difference: 850
De Haan: Old salary = 17000, New salary = 17850, Difference: 850
 
<span class="bold">6 rows updated.</span>
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT salary FROM employees WHERE job_id = 'AD_PRES';
</pre>
<p>Result:</p>
<pre dir="ltr">
    SALARY
----------
     <span class="bold">25200</span>
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BCFJDBEH">Example 9-4</a> creates a trigger that modifies <code dir="ltr">CLOB</code> columns. (For information about <code dir="ltr">TO_CLOB</code> and other conversion functions, see <a class="olink SQLRF20034" href="../../server.112/e41084/functions002.htm#SQLRF20034"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<div id="LNPLS661" class="example">
<p class="titleinexample"><a id="BCFJDBEH"></a>Example 9-4 Trigger Modifies LOB Columns</p>
<pre dir="ltr">
DROP TABLE tab1;
<span class="bold">CREATE TABLE tab1 (c1 CLOB);</span>
INSERT INTO tab1 VALUES ('&lt;h1&gt;HTML Document Fragment&lt;/h1&gt;&lt;p&gt;Some text.');

CREATE OR REPLACE TRIGGER trg1
  BEFORE UPDATE ON tab1
  FOR EACH ROW
BEGIN
  DBMS_OUTPUT.PUT_LINE('Old value of CLOB column: '||:OLD.c1);
  DBMS_OUTPUT.PUT_LINE('Proposed new value of CLOB column: '||:NEW.c1);

  :NEW.c1 := :NEW.c1 || <span class="bold">TO_CLOB('&lt;hr&gt;&lt;p&gt;Standard footer paragraph.')</span>;

  DBMS_OUTPUT.PUT_LINE('Final value of CLOB column: '||:NEW.c1);
END;
/ 

SET SERVEROUTPUT ON;
UPDATE tab1 SET c1 = '&lt;h1&gt;Different Document Fragment&lt;/h1&gt;&lt;p&gt;Different text.';

SELECT * FROM tab1;
</pre></div>
<!-- class="example" -->
<p><a href="#BCFIAABG">Example 9-5</a> creates a table with the same name as a correlation name, <code dir="ltr">new</code>, and then creates a trigger on that table. To avoid conflict between the table name and the correlation name, the trigger references the correlation name as <code dir="ltr">Newest</code>.</p>
<div id="LNPLS663" class="example">
<p class="titleinexample"><a id="BCFIAABG"></a>Example 9-5 Trigger with REFERENCING Clause</p>
<pre dir="ltr">
CREATE TABLE new (
  field1  NUMBER,
  field2  VARCHAR2(20)
);

CREATE OR REPLACE TRIGGER Print_salary_changes
BEFORE UPDATE ON new
<span class="bold">REFERENCING new AS Newest</span>
FOR EACH ROW
BEGIN
  <span class="bold">:Newest</span>.Field2 := TO_CHAR (<span class="bold">:newest</span>.field1);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="g1662184"></a>
<div id="LNPLS752" class="sect2">
<h3 class="sect2">OBJECT_VALUE Pseudocolumn</h3>
<p>A trigger on an object table can reference the SQL pseudocolumn <a id="sthref788"></a><code dir="ltr">OBJECT_VALUE</code>, which returns system-generated names for the columns of the object table. The trigger can also invoke a PL/SQL subprogram that has a formal <code dir="ltr">IN</code> parameter whose data type is <code dir="ltr">OBJECT_VALUE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF50952" href="../../server.112/e41084/pseudocolumns006.htm#SQLRF50952"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">OBJECT_VALUE</code></div>
<p><a href="#BCFFIBBA">Example 9-6</a> creates object table <code dir="ltr">tbl</code>, table <code dir="ltr">tbl_history</code> for logging updates to <code dir="ltr">tbl</code>, and trigger <code dir="ltr">Tbl_Trg</code>. The trigger runs for each row of <code dir="ltr">tb1</code> that is affected by a DML statement, causing the old and new values of the object <code dir="ltr">t</code> in <code dir="ltr">tbl</code> to be written in <code dir="ltr">tbl_history</code>. The old and new values are :<code dir="ltr">OLD</code>.<code dir="ltr">OBJECT_VALUE</code> and :<code dir="ltr">NEW</code>.<code dir="ltr">OBJECT_VALUE</code>.</p>
<div id="LNPLS753" class="example">
<p class="titleinexample"><a id="BCFFIBBA"></a>Example 9-6 Trigger References OBJECT_VALUE Pseudocolumn</p>
<p>Create, populate, and show object table:</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE t AS OBJECT (n NUMBER, m NUMBER)
/
CREATE TABLE tbl OF t
/
BEGIN
  FOR j IN 1..5 LOOP
    INSERT INTO tbl VALUES (t(j, 0));
  END LOOP;
END;
/
SELECT * FROM tbl ORDER BY n;
</pre>
<p>Result:</p>
<pre dir="ltr">
         N          M
---------- ----------
         1          0
         2          0
         3          0
         4          0
         5          0

5 rows selected.
</pre>
<p>Create history table and trigger:</p>
<pre dir="ltr">
CREATE TABLE tbl_history ( d DATE, old_obj t, new_obj t)
/
CREATE OR REPLACE TRIGGER Tbl_Trg
  AFTER UPDATE ON tbl
  FOR EACH ROW
BEGIN
  INSERT INTO tbl_history (d, old_obj, new_obj)
  VALUES (SYSDATE, <span class="bold">:OLD.OBJECT_VALUE</span>, <span class="bold">:NEW.OBJECT_VALUE</span>);
END Tbl_Trg;
/
 
</pre>
<p>Update object table:</p>
<pre dir="ltr">
UPDATE tbl SET tbl.n = tbl.n+1
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
5 rows updated.
</pre>
<p>Show old and new values:</p>
<pre dir="ltr">
BEGIN
  FOR j IN (SELECT d, old_obj, new_obj FROM tbl_history) LOOP
    DBMS_OUTPUT.PUT_LINE (
      j.d ||
      ' -- old: ' || j.old_obj.n || ' ' || j.old_obj.m ||
      ' -- new: ' || j.new_obj.n || ' ' || j.new_obj.m
    );
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
28-APR-10 -- old: 1 0 -- new: 2 0
28-APR-10 -- old: 2 0 -- new: 3 0
28-APR-10 -- old: 3 0 -- new: 4 0
28-APR-10 -- old: 4 0 -- new: 5 0
28-APR-10 -- old: 5 0 -- new: 6 0
</pre></div>
<!-- class="example" -->
<p>All values of column <code dir="ltr">n</code> were increased by 1. The value of <code dir="ltr">m</code> remains 0.</p>
</div>
<!-- class="sect2" -->
<a id="i1006376"></a>
<div id="LNPLS20041" class="sect2">
<h3 class="sect2">INSTEAD OF DML Triggers</h3>
<p>An <a id="sthref789"></a><code dir="ltr"><span class="codeinlinebold">INSTEAD</span></code> <code dir="ltr"><span class="codeinlinebold">OF</span></code> <span class="bold">DML</span> <span class="bold">trigger</span> is a DML trigger created on a noneditioning view, or on a nested table column of a noneditioning view. The database fires the <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger instead of running the triggering DML statement. An <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger cannot be conditional.</p>
<p>An <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger is the only way to update a view that is not inherently updatable. (For information about inherently updatable views, see <a class="olink SQLRF54782" href="../../server.112/e41084/statements_8004.htm#SQLRF54782"><span class="italic">Oracle Database SQL Language Reference</span></a>.) Design the <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger to determine what operation was intended and do the appropriate DML operations on the underlying tables.</p>
<p>An <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger is always a row-level trigger. An <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger can read <code dir="ltr">OLD</code> and <code dir="ltr">NEW</code> values, but cannot change them.</p>
<p><a href="#CIHFGDJG">Example 9-7</a> creates the view <code dir="ltr">oe.order_info</code> to display information about customers and their orders. The view is not inherently updatable (because the primary key of the <code dir="ltr">orders</code> table, <code dir="ltr">order_id</code>, is not unique in the result set of the join view). The example creates an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger to process <code dir="ltr">INSERT</code> statements directed to the view. The trigger inserts rows into the base tables of the view, <code dir="ltr">customers</code> and <code dir="ltr">orders</code>.</p>
<div id="LNPLS664" class="example">
<p class="titleinexample"><a id="CIHFGDJG"></a>Example 9-7 INSTEAD OF Trigger</p>
<pre dir="ltr">
CREATE OR REPLACE VIEW order_info AS
   SELECT c.customer_id, c.cust_last_name, c.cust_first_name,
          o.order_id, o.order_date, o.order_status
   <span class="bold">FROM customers c, orders o</span>
   WHERE c.customer_id = o.customer_id;

CREATE OR REPLACE TRIGGER order_info_insert
   <span class="bold">INSTEAD OF INSERT ON order_info</span>
   DECLARE
     duplicate_info EXCEPTION;
     PRAGMA EXCEPTION_INIT (duplicate_info, -00001);
   BEGIN
     <span class="bold">INSERT INTO customers</span>
       <span class="bold">(customer_id, cust_last_name, cust_first_name)</span>
     <span class="bold">VALUES (</span>
     <span class="bold">:new.customer_id,</span>
     <span class="bold">:new.cust_last_name,</span>
     <span class="bold">:new.cust_first_name);</span>
   <span class="bold">INSERT INTO orders (order_id, order_date, customer_id)</span>
   <span class="bold">VALUES (</span>
     <span class="bold">:new.order_id,</span>
     <span class="bold">:new.order_date,</span>
     <span class="bold">:new.customer_id);</span>
   EXCEPTION
     WHEN duplicate_info THEN
       RAISE_APPLICATION_ERROR (
         num=&gt; -20107,
         msg=&gt; 'Duplicate customer or order ID');
   END order_info_insert;
/
</pre>
<p>Query to show that row to be inserted does not exist:</p>
<pre dir="ltr">
SELECT COUNT(*) FROM order_info WHERE customer_id = 999;
</pre>
<p>Result:</p>
<pre dir="ltr">
  COUNT(*)
----------
         0
 
1 row selected.
</pre>
<p>Insert row into view:</p>
<pre dir="ltr">
INSERT INTO order_info VALUES
   (999, 'Smith', 'John', 2500, '13-MAR-2001', 0);
</pre>
<p>Result:</p>
<pre dir="ltr">
1 row created.
</pre>
<p>Query to show that row has been inserted in view:</p>
<pre dir="ltr">
SELECT COUNT(*) FROM order_info WHERE customer_id = 999;
</pre>
<p>Result:</p>
<pre dir="ltr">
  COUNT(*)
----------
         1
 
1 row selected.
</pre>
<p>Query to show that row has been inserted in <code dir="ltr">customers</code> table:</p>
<pre dir="ltr">
SELECT COUNT(*) FROM customers WHERE customer_id = 999;
</pre>
<p>Result:</p>
<pre dir="ltr">
  COUNT(*)
----------
         1
 
1 row selected.
</pre>
<p>Query to show that row has been inserted in <code dir="ltr">orders</code> table:</p>
<pre dir="ltr">
SELECT COUNT(*) FROM orders WHERE customer_id = 999;
</pre>
<p>Result:</p>
<pre dir="ltr">
  COUNT(*)
----------
         1
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="CIHGDJFJ"></a><a id="LNPLS731"></a>INSTEAD OF Triggers on Nested Table Columns of Views</p>
<p>An <a id="sthref790"></a><code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger with the <a id="sthref791"></a><code dir="ltr">NESTED</code> <code dir="ltr">TABLE</code> clause fires only if the triggering statement operates on the elements of the specified nested table column of the view. The trigger fires for each modified nested table element.</p>
<p>In <a href="#CIHFBGDC">Example 9-8</a>, the view <code dir="ltr">dept_view</code> contains a nested table of employees, <code dir="ltr">emplist</code>, created by the <code dir="ltr">CAST</code> function (described in <a class="olink SQLRF00613" href="../../server.112/e41084/functions023.htm#SQLRF00613"><span class="italic">Oracle Database SQL Language Reference</span></a>). To modify the <code dir="ltr">emplist</code> column, the example creates an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger on the column.</p>
<div id="LNPLS669" class="example">
<p class="titleinexample"><a id="CIHFBGDC"></a>Example 9-8 INSTEAD OF Trigger on Nested Table Column of View</p>
<pre dir="ltr">
-- Create type of nested table element:
 
CREATE OR REPLACE TYPE nte
AUTHID DEFINER IS
OBJECT (
  emp_id     NUMBER(6),
  lastname   VARCHAR2(25),
  job        VARCHAR2(10),
  sal        NUMBER(8,2)
);
/
 
-- Created type of nested table:
 
CREATE OR REPLACE TYPE emp_list_ IS
  TABLE OF nte;
/
 
-- Create view:

CREATE OR REPLACE VIEW <span class="bold">dept_view</span> AS
  SELECT d.department_id, 
         d.department_name,
         CAST (MULTISET (SELECT e.employee_id, e.last_name, e.job_id, e.salary
                         FROM employees e
                         WHERE e.department_id = d.department_id
                        )
                        AS emp_list_
              ) <span class="bold">emplist</span>
  FROM departments d;
 
-- Create trigger:
 
CREATE OR REPLACE TRIGGER dept_emplist_tr
  <span class="bold">INSTEAD OF INSERT ON NESTED TABLE emplist OF dept_view</span>
  <span class="bold">REFERENCING NEW AS Employee</span>
              <span class="bold">PARENT AS Department</span>
  FOR EACH ROW
BEGIN
  -- Insert on nested table translates to insert on base table:
  INSERT INTO employees (
    employee_id,
    last_name,
    email,
    hire_date,
    job_id,
    salary,
    department_id
  )
  VALUES (
    :Employee.emp_id,                      -- employee_id
    :Employee.lastname,                    -- last_name
    :Employee.lastname || '@company.com',  -- email
    SYSDATE,                               -- hire_date
    :Employee.job,                         -- job_id
    :Employee.sal,                         -- salary
    :Department.department_id              -- department_id
  );
END;
/
</pre>
<p>Query view before inserting row into nested table:</p>
<pre dir="ltr">
SELECT emplist FROM dept_view WHERE department_id=10;
</pre>
<p>Result:</p>
<pre dir="ltr">
EMPLIST(EMP_ID, LASTNAME, JOB, SAL)
----------------------------------------------
 
EMP_LIST_(NTE(200, 'Whalen', 'AD_ASST', 2800))
 
1 row selected.
</pre>
<p>Query table before inserting row into nested table:</p>
<pre dir="ltr">
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE department_id = 10;
</pre>
<p>Result:</p>
<pre dir="ltr">
EMPLOYEE_ID LAST_NAME                 JOB_ID         SALARY
----------- ------------------------- ---------- ----------
        200 Whalen                    AD_ASST          2800
 
1 row selected.
</pre>
<p>Insert a row into nested table:</p>
<pre dir="ltr">
INSERT INTO TABLE (
  SELECT d.emplist 
  FROM dept_view d
  WHERE department_id = 10
)
VALUES (1001, 'Glenn', 'AC_MGR', 10000);
</pre>
<p>Query view after inserting row into nested table:</p>
<pre dir="ltr">
SELECT emplist FROM dept_view WHERE department_id=10;
</pre>
<p>Result (formatted to fit page):</p>
<pre dir="ltr">
EMPLIST(EMP_ID, LASTNAME, JOB, SAL)
--------------------------------------------------------------------------------
 
EMP_LIST_(NTE(200, 'Whalen', 'AD_ASST', 2800),
          NTE(1001, 'Glenn', 'AC_MGR', 10000))
 
1 row selected.
</pre>
<p>Query table after inserting row into nested table:</p>
<pre dir="ltr">
SELECT employee_id, last_name, job_id, salary
FROM employees
WHERE department_id = 10;
</pre>
<p>Result:</p>
<pre dir="ltr">
EMPLOYEE_ID LAST_NAME                 JOB_ID         SALARY
----------- ------------------------- ---------- ----------
        200 Whalen                    AD_ASST          2800
       1001 Glenn                     AC_MGR          10000
 
2 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHEFGFD"></a>
<div id="LNPLS2005" class="sect2">
<h3 class="sect2">Compound DML Triggers</h3>
<p>A <a id="sthref792"></a>compound DML trigger created on a table or editioning view can fire at multiple timing points. Each timing point section has its own executable part and optional exception-handling part, but all of these parts can access a common PL/SQL state. The common state is established when the triggering statement starts and is destroyed when the triggering statement completes, even when the triggering statement causes an error.</p>
<p>A compound DML trigger created on a noneditioning view is not really compound, because it has only one timing point section.</p>
<p>A compound trigger can be conditional, but not autonomous.</p>
<p>Two common uses of compound triggers are:</p>
<ul>
<li>
<p>To accumulate rows destined for a second table so that you can periodically bulk-insert them</p>
</li>
<li>
<p>To avoid the mutating-table error (ORA-04091)</p>
</li>
</ul>
<p class="subhead2"><a id="LNPLS692"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHJBEFE">Compound DML Trigger Structure</a></p>
</li>
<li>
<p><a href="#CIHIEFAE">Compound DML Trigger Restrictions</a></p>
</li>
<li>
<p><a href="#CIHBECCI">Performance Benefit of Compound DML Triggers</a></p>
</li>
<li>
<p><a href="#CIHFHIBH">Using Compound DML Triggers with Bulk Insertion</a></p>
</li>
<li>
<p><a href="#CHDFEBFJ">Using Compound DML Triggers to Avoid Mutating-Table Error</a></p>
</li>
</ul>
<a id="CIHJBEFE"></a>
<div id="LNPLS737" class="sect3">
<h4 class="sect3">Compound DML Trigger Structure</h4>
<p>The optional declarative part of a compound trigger declares variables and subprograms that all of its timing-point sections can use. When the trigger fires, the declarative part runs before any timing-point sections run. The variables and subprograms exist for the duration of the triggering statement.</p>
<p>A compound DML trigger created on a noneditioning view is not really compound, because it has only one <a id="sthref793"></a>timing point section. The syntax for creating the simplest compound DML trigger on a noneditioning view is:</p>
<pre dir="ltr">
CREATE <span class="italic">trigger</span> FOR <span class="italic">dml_event_clause</span> ON <span class="italic">view</span>
COMPOUND TRIGGER
<a id="sthref794"></a>INSTEAD OF EACH ROW IS BEGIN
  <span class="italic">statement</span>;
END INSTEAD OF EACH ROW;
</pre>
<p>A compound DML trigger created on a table or editioning view has at least one timing-point section in <a href="#CIHJGDGE">Table 9-2</a>. If the trigger has multiple timing-point sections, they can be in any order, but no timing-point section can be repeated. If a timing-point section is absent, then nothing happens at its timing point.</p>
<div id="LNPLS694" class="tblformal">
<p class="titleintable"><a id="sthref795"></a><a id="CIHJGDGE"></a>Table 9-2 Compound Trigger Timing-Point Sections</p>
<table class="cellalignment1092" title="Compound Trigger Timing-Point Sections" summary="This table show the possible trigger points and corresponding optional sections for a compound trigger associated with a table." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t10">Timing Point</th>
<th class="cellalignment1090" id="r1c2-t10">Section</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t10" headers="r1c1-t10">
<p>Before the triggering statement runs</p>
</td>
<td class="cellalignment1091" headers="r2c1-t10 r1c2-t10">
<p><code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code></p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t10" headers="r1c1-t10">
<p>After the triggering statement runs</p>
</td>
<td class="cellalignment1091" headers="r3c1-t10 r1c2-t10">
<p><code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code></p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t10" headers="r1c1-t10">
<p>Before each row that the triggering statement affects</p>
</td>
<td class="cellalignment1091" headers="r4c1-t10 r1c2-t10">
<p><code dir="ltr">BEFORE</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code></p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t10" headers="r1c1-t10">
<p>After each row that the triggering statement affects</p>
</td>
<td class="cellalignment1091" headers="r5c1-t10 r1c2-t10">
<p><code dir="ltr">AFTER</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="create_trigger.htm#i2235611">"CREATE TRIGGER Statement"</a> for more information about the syntax of compound triggers</div>
<p>A compound DML trigger does not have an initialization section, but the <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> section, which runs before any other timing-point section, can do any necessary initializations.</p>
<p>If a compound DML trigger has neither a <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> section nor an <code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code> section, and its triggering statement affects no rows, then the trigger never fires.</p>
</div>
<!-- class="sect3" -->
<a id="CIHIEFAE"></a>
<div id="LNPLS740" class="sect3">
<h4 class="sect3">Compound DML Trigger Restrictions</h4>
<p>In addition to the <a href="#g1042050">"Trigger Restrictions"</a>), compound DML triggers have these restrictions:</p>
<ul>
<li>
<p><code dir="ltr">OLD</code>, <code dir="ltr">NEW</code>, and <code dir="ltr">PARENT</code> cannot appear in the declarative part, the <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> section, or the <code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code> section.</p>
</li>
<li>
<p>Only the <code dir="ltr">BEFORE</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> section can change the value of <code dir="ltr">NEW</code>.</p>
</li>
<li>
<p>A timing-point section cannot handle exceptions raised in another timing-point section.</p>
</li>
<li>
<p>If a timing-point section includes a <code dir="ltr">GOTO</code> statement, the target of the <code dir="ltr">GOTO</code> statement must be in the same timing-point section.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIHBECCI"></a>
<div id="LNPLS739" class="sect3">
<h4 class="sect3">Performance Benefit of Compound DML Triggers</h4>
<p>A compound DML trigger has a performance benefit when the triggering statement affects many rows.</p>
<p>For example, suppose that this statement triggers a compound DML trigger that has all four timing-point sections in <a href="#CIHJGDGE">Table 9-2</a>:</p>
<pre dir="ltr">
INSERT INTO Target
  SELECT c1, c2, c3
  FROM Source
  WHERE Source.c1 &gt; 0
</pre>
<p>Although the <code dir="ltr">BEFORE</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> and <code dir="ltr">AFTER</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> sections of the trigger run for each row of <code dir="ltr">Source</code> whose column <code dir="ltr">c1</code> is greater than zero, the <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> section runs only before the <code dir="ltr">INSERT</code> statement runs and the <code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code> section runs only after the <code dir="ltr">INSERT</code> statement runs.</p>
<p>A compound DML trigger has a greater performance benefit when it uses <a id="sthref796"></a><a id="sthref797"></a>bulk SQL, described in <a href="tuning.htm#BABFHGHI">"Bulk SQL and Bulk Binding"</a>.</p>
</div>
<!-- class="sect3" -->
<a id="CIHFHIBH"></a>
<div id="LNPLS741" class="sect3">
<h4 class="sect3">Using Compound DML Triggers with Bulk Insertion</h4>
<p>A compound DML trigger is useful for accumulating rows destined for a second table so that you can periodically bulk-insert them. To get the performance benefit from the compound trigger, you must specify <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> in the <code dir="ltr">FORALL</code> statement (otherwise, the <code dir="ltr">FORALL</code> statement does a single-row DML operation multiple times). For more information about using the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause with the <code dir="ltr">FORALL</code> statement, see <a href="tuning.htm#BCGICBDF">"Using FORALL Statement and BULK COLLECT Clause Together"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="tuning.htm#i54218">"FORALL Statement"</a></div>
<p><span class="bold">Scenario:</span> You want to log every change to <code dir="ltr">hr</code>.<code dir="ltr">employees</code>.<code dir="ltr">salary</code> in a new table, <code dir="ltr">employee_salaries</code>. A single <code dir="ltr">UPDATE</code> statement updates many rows of the table <code dir="ltr">hr</code>.<code dir="ltr">employees</code>; therefore, bulk-inserting rows into <code dir="ltr">employee</code>.<code dir="ltr">salaries</code> is more efficient than inserting them individually.</p>
<p><span class="bold">Solution:</span> Define a compound trigger on updates of the table <code dir="ltr">hr</code>.<code dir="ltr">employees</code>, as in <a href="#CIHGJFAB">Example 9-9</a>. You do not need a <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> section to initialize <code dir="ltr">idx</code> or <code dir="ltr">salaries</code>, because they are state variables, which are initialized each time the trigger fires (even when the triggering statement is interrupted and restarted).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To run <a href="#CIHGJFAB">Example 9-9</a>, you must have the <code dir="ltr">EXECUTE</code> privilege on the package <code dir="ltr">DBMS_LOCK</code>.</div>
<div id="LNPLS742" class="example">
<p class="titleinexample"><a id="CIHGJFAB"></a>Example 9-9 Compound Trigger Logs Changes to One Table in Another Table</p>
<pre dir="ltr">
CREATE TABLE employee_salaries (
  employee_id NUMBER NOT NULL,
  change_date DATE   NOT NULL,
  salary NUMBER(8,2) NOT NULL,
  CONSTRAINT pk_employee_salaries PRIMARY KEY (employee_id, change_date),
  CONSTRAINT fk_employee_salaries FOREIGN KEY (employee_id)
    REFERENCES employees (employee_id)
      ON DELETE CASCADE)
/
CREATE OR REPLACE TRIGGER maintain_employee_salaries
  FOR UPDATE OF salary ON employees
    COMPOUND TRIGGER

-- Declarative Part:
-- Choose small threshhold value to show how example works:
  threshhold CONSTANT SIMPLE_INTEGER := 7;

  TYPE salaries_t IS TABLE OF employee_salaries%ROWTYPE INDEX BY SIMPLE_INTEGER;
  salaries  salaries_t;
  idx       SIMPLE_INTEGER := 0;

  PROCEDURE flush_array IS
    n CONSTANT SIMPLE_INTEGER := salaries.count();
  BEGIN
    <span class="bold">FORALL j IN 1..n</span>
      <span class="bold">INSERT INTO employee_salaries VALUES salaries(j);</span>
    salaries.delete();
    idx := 0;
    DBMS_OUTPUT.PUT_LINE('Flushed ' || n || ' rows');
  END flush_array;

  -- AFTER EACH ROW Section:

  AFTER EACH ROW IS
  BEGIN
    idx := idx + 1;
    salaries(idx).employee_id := :NEW.employee_id;
    salaries(idx).change_date := SYSDATE();
    salaries(idx).salary := :NEW.salary;
    IF idx &gt;= threshhold THEN
      flush_array();
    END IF;
  END AFTER EACH ROW;

  -- AFTER STATEMENT Section:

  AFTER STATEMENT IS
  BEGIN
    flush_array();
  END AFTER STATEMENT;
END maintain_employee_salaries;
/
/* Increase salary of every employee in department 50 by 10%: */

UPDATE employees
  SET salary = salary * 1.1
  WHERE department_id = 50
/

/* Wait two seconds: */

BEGIN
  DBMS_LOCK.SLEEP(2);
END;
/

/* Increase salary of every employee in department 50 by 5%: */

UPDATE employees
  SET salary = salary * 1.05
  WHERE department_id = 50
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CHDFEBFJ"></a>
<div id="LNPLS743" class="sect3">
<h4 class="sect3">Using Compound DML Triggers to Avoid Mutating-Table Error</h4>
<p>A compound DML trigger is useful for avoiding the mutating-table error (ORA-04091) explained in <a href="#g1699708">"Mutating-Table Restriction"</a>.</p>
<p><span class="bold">Scenario:</span> A business rule states that an employee's salary increase must not exceed 10% of the average salary for the employee's department. This rule must be enforced by a trigger.</p>
<p><span class="bold">Solution:</span> Define a compound trigger on updates of the table <code dir="ltr">hr</code>.<code dir="ltr">employees</code>, as in <a href="#CHDFGDAH">Example 9-10</a>. The state variables are initialized each time the trigger fires (even when the triggering statement is interrupted and restarted).</p>
<div id="LNPLS744" class="example">
<p class="titleinexample"><a id="CHDFGDAH"></a>Example 9-10 Compound Trigger Avoids Mutating-Table Error</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Check_Employee_Salary_Raise
  FOR UPDATE OF Salary ON Employees
COMPOUND TRIGGER
  Ten_Percent                 CONSTANT NUMBER := 0.1;
  TYPE Salaries_t             IS TABLE OF Employees.Salary%TYPE;
  Avg_Salaries                Salaries_t;
  TYPE Department_IDs_t       IS TABLE OF Employees.Department_ID%TYPE;
  Department_IDs              Department_IDs_t;

  -- Declare collection type and variable:

  TYPE Department_Salaries_t  IS TABLE OF Employees.Salary%TYPE
                                INDEX BY VARCHAR2(80);
  Department_Avg_Salaries     Department_Salaries_t;

  BEFORE STATEMENT IS
  BEGIN
    SELECT               AVG(e.Salary), NVL(e.Department_ID, -1)
      BULK COLLECT INTO  Avg_Salaries, Department_IDs
      FROM               Employees e
      GROUP BY           e.Department_ID;
    FOR j IN 1..Department_IDs.COUNT() LOOP
      Department_Avg_Salaries(Department_IDs(j)) := Avg_Salaries(j);
    END LOOP;
  END BEFORE STATEMENT;

  AFTER EACH ROW IS
  BEGIN
    IF :NEW.Salary - :Old.Salary &gt;
      Ten_Percent*Department_Avg_Salaries(:NEW.Department_ID)
    THEN
      Raise_Application_Error(-20000, 'Raise too big');
    END IF;
  END AFTER EACH ROW;
END Check_Employee_Salary_Raise;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BCFCAIGG"></a>
<div id="LNPLS770" class="sect2">
<h3 class="sect2">Triggers for Ensuring Referential Integrity</h3>
<p>You can use triggers and constraints to maintain referential integrity between parent and child tables, as <a href="#CIHIDBHH">Table 9-3</a> shows. (For more information about constraints, see <a class="olink SQLRF52180" href="../../server.112/e41084/clauses002.htm#SQLRF52180"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<div id="LNPLS720" class="tblformal">
<p class="titleintable"><a id="sthref798"></a><a id="CIHIDBHH"></a>Table 9-3 Constraints and Triggers for Ensuring Referential Integrity</p>
<table class="cellalignment1092" title="Constraints and Triggers for Ensuring Referential Integrity" summary="This table shows the kinds of constraints and triggers needed to maintain referential integrity between a parent and child table." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t14">Table</th>
<th class="cellalignment1090" id="r1c2-t14">Constraint to Declare on Table</th>
<th class="cellalignment1090" id="r1c3-t14">Triggers to Create on Table</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t14" headers="r1c1-t14">
<p>Parent</p>
</td>
<td class="cellalignment1091" headers="r2c1-t14 r1c2-t14">
<p><code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> or <code dir="ltr">UNIQUE</code></p>
</td>
<td class="cellalignment1091" headers="r2c1-t14 r1c3-t14">
<p>One or more triggers that ensure that when <code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> or <code dir="ltr">UNIQUE</code> values are updated or deleted, the desired action (<code dir="ltr">RESTRICT</code>, <code dir="ltr">CASCADE</code>, or <code dir="ltr">SET</code> <code dir="ltr">NULL</code>) occurs on corresponding <code dir="ltr">FOREIGN</code> <code dir="ltr">KEY</code> values.</p>
<p>No action is required for inserts into the parent table, because no dependent foreign keys exist.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t14" headers="r1c1-t14">
<p>Child</p>
</td>
<td class="cellalignment1091" headers="r3c1-t14 r1c2-t14">
<p><code dir="ltr">FOREIGN</code> <code dir="ltr">KEY</code>, if parent and child are in the same database. (The database does not support declarative referential constraints between tables on different nodes of a distributed database.)</p>
<p>Disable this foreign key constraint to prevent the corresponding <code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> or <code dir="ltr">UNIQUE</code> constraint from being dropped (except explicitly with the <code dir="ltr">CASCADE</code> option).</p>
</td>
<td class="cellalignment1091" headers="r3c1-t14 r1c3-t14">
<p>One trigger that ensures that values inserted or updated in the <code dir="ltr">FOREIGN</code> <code dir="ltr">KEY</code> correspond to <code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> or <code dir="ltr">UNIQUE</code> values in the parent table.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="LNPLS721"></a>Topics</p>
<ul>
<li>
<p><a href="#CIHIGFEJ">Foreign Key Trigger for Child Table</a></p>
</li>
<li>
<p><a href="#CIHCIJHB">UPDATE and DELETE RESTRICT Trigger for Parent Table</a></p>
</li>
<li>
<p><a href="#CIHBAJAF">UPDATE and DELETE SET NULL Trigger for Parent Table</a></p>
</li>
<li>
<p><a href="#CIHJHEBF">DELETE CASCADE Trigger for Parent Table</a></p>
</li>
<li>
<p><a href="#CIHHGFBC">UPDATE CASCADE Trigger for Parent Table</a></p>
</li>
<li>
<p><a href="#CIHDDGGD">Triggers for Complex Constraint Checking</a></p>
</li>
<li>
<p><a href="#CIHEFCJD">Triggers for Complex Security Authorizations</a></p>
</li>
<li>
<p><a href="#CIHGEFAH">Triggers for Transparent Event Logging</a></p>
</li>
<li>
<p><a href="#CIHCCGIB">Triggers for Deriving Column Values</a></p>
</li>
<li>
<p><a href="#CIHIBAIE">Triggers for Building Complex Updatable Views</a></p>
</li>
<li>
<p><a href="#CIHHHHHI">Triggers for Fine-Grained Access Control</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The examples in the following topics use these tables, which share the column <code dir="ltr">Deptno</code>:
<pre dir="ltr">
CREATE TABLE emp (
  Empno     NUMBER NOT NULL,
  Ename     VARCHAR2(10),
  Job       VARCHAR2(9),
  Mgr       NUMBER(4),
  Hiredate  DATE,
  Sal       NUMBER(7,2),
  Comm      NUMBER(7,2),
  <span class="bold">Deptno    NUMBER(2) NOT NULL</span>);

CREATE TABLE dept (
  <span class="bold">Deptno    NUMBER(2) NOT NULL</span>,
  Dname     VARCHAR2(14),
  Loc       VARCHAR2(13),
  Mgr_no    NUMBER,
  Dept_type NUMBER);
</pre>
<p>Several triggers include statements that lock rows (<code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>). This operation is necessary to maintain concurrency while the rows are being processed.</p>
<p>These examples are not meant to be used exactly as written. They are provided to assist you in designing your own triggers.</p>
</div>
<a id="CIHIGFEJ"></a>
<div id="LNPLS771" class="sect3">
<h4 class="sect3">Foreign Key Trigger for Child Table</h4>
<p><a id="i1007411"></a>The trigger in <a href="#BCFGAHIB">Example 9-11</a> ensures that before an <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement affects a foreign key value, the corresponding value exists in the parent key. The exception ORA-04091 (mutating-table error) allows the trigger <code dir="ltr">emp_dept_check</code> to be used with the <code dir="ltr">UPDATE_SET_DEFAULT</code> and <code dir="ltr">UPDATE_CASCADE</code> triggers. This exception is unnecessary if the trigger <code dir="ltr">emp_dept_check</code> is used alone.</p>
<div id="LNPLS772" class="example">
<p class="titleinexample"><a id="BCFGAHIB"></a>Example 9-11 Foreign Key Trigger for Child Table</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER emp_dept_check
  BEFORE INSERT OR UPDATE OF Deptno ON emp
  FOR EACH ROW WHEN (NEW.Deptno IS NOT NULL)

  -- Before row is inserted or DEPTNO is updated in emp table,
  -- fire this trigger to verify that new foreign key value (DEPTNO)
  -- is present in dept table.
DECLARE
  Dummy               INTEGER;  -- Use for cursor fetch
  Invalid_department  EXCEPTION;
  Valid_department    EXCEPTION;
  Mutating_table      EXCEPTION;
  PRAGMA EXCEPTION_INIT (Mutating_table, -4091);

  -- Cursor used to verify parent key value exists.
  -- If present, lock parent key's row so it cannot be deleted
  -- by another transaction until this transaction is
  -- committed or rolled back.

  CURSOR Dummy_cursor (Dn NUMBER) IS
    SELECT Deptno FROM dept
    WHERE Deptno = Dn
    FOR UPDATE OF Deptno;
BEGIN
  OPEN Dummy_cursor (:NEW.Deptno);
  FETCH Dummy_cursor INTO Dummy;

  -- Verify parent key.
  -- If not found, raise user-specified error code and message.
  -- If found, close cursor before allowing triggering statement to complete:

  IF Dummy_cursor%NOTFOUND THEN
    RAISE Invalid_department;
  ELSE
    RAISE valid_department;
  END IF;
  CLOSE Dummy_cursor;
EXCEPTION
  WHEN Invalid_department THEN
    CLOSE Dummy_cursor;
    Raise_application_error(-20000, 'Invalid Department'
      || ' Number' || TO_CHAR(:NEW.deptno));
  WHEN Valid_department THEN
    CLOSE Dummy_cursor;
  WHEN Mutating_table THEN
    NULL;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHCIJHB"></a>
<div id="LNPLS773" class="sect3">
<h4 class="sect3">UPDATE and DELETE RESTRICT Trigger for Parent Table</h4>
<p>The trigger in <a href="#BCFCCBAF">Example 9-12</a> enforces the <code dir="ltr">UPDATE</code> and <code dir="ltr">DELETE</code> <code dir="ltr">RESTRICT</code> referential action on the primary key of the <code dir="ltr">dept</code> table.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
The trigger in <a href="#BCFCCBAF">Example 9-12</a> does not work with self-referential tables (tables with both the primary/unique key and the foreign key). Also, this trigger does not allow triggers to cycle (such as when A fires B, which fires A).</div>
<div id="LNPLS774" class="example">
<p class="titleinexample"><a id="BCFCCBAF"></a>Example 9-12 UPDATE and DELETE RESTRICT Trigger for Parent Table</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER dept_restrict
  BEFORE DELETE OR UPDATE OF Deptno ON dept
  FOR EACH ROW

  -- Before row is deleted from dept or primary key (DEPTNO) of dept is updated,
  -- check for dependent foreign key values in emp;
  -- if any are found, roll back.

DECLARE
  Dummy                  INTEGER;  -- Use for cursor fetch
  Employees_present      EXCEPTION;
  employees_not_present  EXCEPTION;

  -- Cursor used to check for dependent foreign key values.
  CURSOR Dummy_cursor (Dn NUMBER) IS
    SELECT Deptno FROM emp WHERE Deptno = Dn;

BEGIN
  OPEN Dummy_cursor (:OLD.Deptno);
  FETCH Dummy_cursor INTO Dummy;

  -- If dependent foreign key is found, raise user-specified
  -- error code and message. If not found, close cursor
  -- before allowing triggering statement to complete.

  IF Dummy_cursor%FOUND THEN
    RAISE Employees_present;     -- Dependent rows exist
  ELSE
    RAISE Employees_not_present; -- No dependent rows exist
  END IF;
  CLOSE Dummy_cursor;

EXCEPTION
  WHEN Employees_present THEN
    CLOSE Dummy_cursor;
    Raise_application_error(-20001, 'Employees Present in'
      || ' Department ' || TO_CHAR(:OLD.DEPTNO));
  WHEN Employees_not_present THEN
    CLOSE Dummy_cursor;
END;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHBAJAF"></a>
<div id="LNPLS775" class="sect3">
<h4 class="sect3">UPDATE and DELETE SET NULL Trigger for Parent Table</h4>
<p>The trigger in <a href="#BCFBGFDJ">Example 9-13</a> enforces the <code dir="ltr">UPDATE</code> and <code dir="ltr">DELETE</code> <code dir="ltr">SET</code> <code dir="ltr">NULL</code> referential action on the primary key of the <code dir="ltr">dept</code> table.</p>
<div id="LNPLS776" class="example">
<p class="titleinexample"><a id="BCFBGFDJ"></a>Example 9-13 UPDATE and DELETE SET NULL Trigger for Parent Table</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER dept_set_null
  AFTER DELETE OR UPDATE OF Deptno ON dept
  FOR EACH ROW

  -- Before row is deleted from dept or primary key (DEPTNO) of dept is updated,
  -- set all corresponding dependent foreign key values in emp to NULL:

BEGIN
  IF UPDATING AND :OLD.Deptno != :NEW.Deptno OR DELETING THEN
    UPDATE emp SET emp.Deptno = NULL
    WHERE emp.Deptno = :OLD.Deptno;
  END IF;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHJHEBF"></a>
<div id="LNPLS777" class="sect3">
<h4 class="sect3">DELETE CASCADE Trigger for Parent Table</h4>
<p>The trigger in <a href="#BCFHHHBD">Example 9-14</a> enforces the <code dir="ltr">DELETE</code> <code dir="ltr">CASCADE</code> referential action on the primary key of the <code dir="ltr">dept</code> table.</p>
<div id="LNPLS778" class="example">
<p class="titleinexample"><a id="BCFHHHBD"></a>Example 9-14 DELETE CASCADE Trigger for Parent Table</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER dept_del_cascade
  AFTER DELETE ON dept
  FOR EACH ROW

  -- Before row is deleted from dept,
  -- delete all rows from emp table whose DEPTNO is same as
  -- DEPTNO being deleted from dept table:

BEGIN
  DELETE FROM emp
  WHERE emp.Deptno = :OLD.Deptno;
END;
/
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Typically, the code for <code dir="ltr">DELETE</code> <code dir="ltr">CASCADE</code> is combined with the code for <code dir="ltr">UPDATE</code> <code dir="ltr">SET</code> <code dir="ltr">NULL</code> or <code dir="ltr">UPDATE</code> <code dir="ltr">SET</code> <code dir="ltr">DEFAULT</code>, to account for both updates and deletes.</div>
</div>
<!-- class="sect3" -->
<a id="CIHHGFBC"></a>
<div id="LNPLS779" class="sect3">
<h4 class="sect3">UPDATE CASCADE Trigger for Parent Table</h4>
<p>The triggers in <a href="#BCFDBJDA">Example 9-15</a> ensure that if a department number is updated in the <code dir="ltr">dept</code> table, then this change is propagated to dependent foreign keys in the <code dir="ltr">emp</code> table.</p>
<div id="LNPLS780" class="example">
<p class="titleinexample"><a id="BCFDBJDA"></a>Example 9-15 UPDATE CASCADE Trigger for Parent Table</p>
<pre dir="ltr">
-- Generate sequence number to be used as flag
-- for determining if update occurred on column:

CREATE SEQUENCE Update_sequence
  INCREMENT BY 1 MAXVALUE 5000 CYCLE;

CREATE OR REPLACE PACKAGE Integritypackage AS
  Updateseq NUMBER;
END Integritypackage;
/
CREATE OR REPLACE PACKAGE BODY Integritypackage AS
END Integritypackage;
/
-- Create flag col:

ALTER TABLE emp ADD Update_id NUMBER;

CREATE OR REPLACE TRIGGER dept_cascade1
  BEFORE UPDATE OF Deptno ON dept
DECLARE
  -- Before updating dept table (this is a statement trigger),
  -- generate sequence number
  -- &amp; assign it to public variable UPDATESEQ of
  -- user-defined package named INTEGRITYPACKAGE:
BEGIN
  Integritypackage.Updateseq := Update_sequence.NEXTVAL;
END;
/
CREATE OR REPLACE TRIGGER dept_cascade2
  AFTER DELETE OR UPDATE OF Deptno ON dept
  FOR EACH ROW

  -- For each department number in dept that is updated,
  -- cascade update to dependent foreign keys in emp table.
  -- Cascade update only if child row was not updated by this trigger:
BEGIN
  IF UPDATING THEN
    UPDATE emp
    SET Deptno = :NEW.Deptno,
        Update_id = Integritypackage.Updateseq   --from 1st
    WHERE emp.Deptno = :OLD.Deptno
    AND Update_id IS NULL;

    /* Only NULL if not updated by 3rd trigger
       fired by same triggering statement */
  END IF;
  IF DELETING THEN
    -- After row is deleted from dept,
    -- delete all rows from emp table whose DEPTNO is same as
    -- DEPTNO being deleted from dept table:
    DELETE FROM emp
    WHERE emp.Deptno = :OLD.Deptno;
  END IF;
END;
/
CREATE OR REPLACE TRIGGER dept_cascade3
  AFTER UPDATE OF Deptno ON dept
BEGIN UPDATE emp
  SET Update_id = NULL
  WHERE Update_id = Integritypackage.Updateseq;
END;
/
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the trigger <code dir="ltr">dept_cascade2</code> updates the <code dir="ltr">emp</code> table, the <code dir="ltr">emp_dept_check</code> trigger in <a href="#BCFGAHIB">Example 9-11</a>, if enabled, also fires. The resulting mutating-table error is trapped by the <code dir="ltr">emp_dept_check</code> trigger. Carefully test any triggers that require error trapping to succeed to ensure that they always work properly in your environment.</div>
</div>
<!-- class="sect3" -->
<a id="CIHDDGGD"></a>
<div id="LNPLS781" class="sect3">
<h4 class="sect3">Triggers for Complex Constraint Checking</h4>
<p>Triggers can enforce integrity rules other than referential integrity. The trigger in <a href="#BCFECGBI">Example 9-16</a> does a complex check before allowing the triggering statement to run.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a href="#BCFECGBI">Example 9-16</a> needs this data structure:
<pre dir="ltr">
CREATE TABLE Salgrade (
  Grade               NUMBER,
  Losal               NUMBER,
  Hisal               NUMBER,
  Job_classification  NUMBER);
</pre></div>
<div id="LNPLS782" class="example">
<p class="titleinexample"><a id="BCFECGBI"></a>Example 9-16 Trigger Checks Complex Constraints</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER salary_check
  BEFORE INSERT OR UPDATE OF Sal, Job ON Emp
  FOR EACH ROW
DECLARE
  Minsal               NUMBER;
  Maxsal               NUMBER;
  Salary_out_of_range  EXCEPTION;

BEGIN
  /* Retrieve minimum &amp; maximum salary for employee's new job classification
     from SALGRADE table into MINSAL and MAXSAL: */

  SELECT Minsal, Maxsal INTO Minsal, Maxsal
  FROM Salgrade
  WHERE Job_classification = :NEW.Job;

  /* If employee's new salary is less than or greater than
     job classification's limits, raise exception.
     Exception message is returned and pending INSERT or UPDATE statement
     that fired the trigger is rolled back: */

  IF (:NEW.Sal &lt; Minsal OR :NEW.Sal &gt; Maxsal) THEN
    RAISE Salary_out_of_range;
  END IF;
EXCEPTION
  WHEN Salary_out_of_range THEN
    Raise_application_error (
      -20300,
      'Salary '|| TO_CHAR(:NEW.Sal) ||' out of range for '
      || 'job classification ' ||:NEW.Job
      ||' for employee ' || :NEW.Ename
    );
  WHEN NO_DATA_FOUND THEN
    Raise_application_error(-20322, 'Invalid Job Classification');
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHEFCJD"></a>
<div id="LNPLS783" class="sect3">
<h4 class="sect3">Triggers for Complex Security Authorizations</h4>
<p>Triggers are commonly used to enforce complex security authorizations for table data. Use triggers only to enforce complex security authorizations that you cannot define using the database security features provided with the database. For example, use a trigger to prohibit updates to the <code dir="ltr">employee</code> table during weekends and nonworking hours.</p>
<p>When using a trigger to enforce a complex security authorization, it is best to use a <code dir="ltr">BEFORE</code> statement trigger. Using a <code dir="ltr">BEFORE</code> statement trigger has these benefits:</p>
<ul>
<li>
<p>The security check is done before the triggering statement is allowed to run, so that no wasted work is done by an unauthorized statement.</p>
</li>
<li>
<p>The security check is done only for the triggering statement, not for each row affected by the triggering statement.</p>
</li>
</ul>
<p>The trigger in <a href="#BCFGEBAA">Example 9-17</a> enforces security by raising exceptions when anyone tries to update the table <code dir="ltr">employees</code> during weekends or nonworking hours.</p>
<div id="LNPLS784" class="example">
<p class="titleinexample"><a id="BCFGEBAA"></a>Example 9-17 Trigger Enforces Security Authorizations</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Employee_permit_changes
  BEFORE INSERT OR DELETE OR UPDATE ON employees
DECLARE
  Dummy             INTEGER;
  Not_on_weekends   EXCEPTION;
  Nonworking_hours  EXCEPTION;
  PRAGMA EXCEPTION_INIT (Not_on_weekends, -4097);
  PRAGMA EXCEPTION_INIT (Nonworking_hours, -4099);
BEGIN
   -- Check for weekends:
 
   IF (TO_CHAR(Sysdate, 'DAY') = 'SAT' OR
     TO_CHAR(Sysdate, 'DAY') = 'SUN') THEN
       RAISE Not_on_weekends;
   END IF;
 
  -- Check for work hours (8am to 6pm):
 
  IF (TO_CHAR(Sysdate, 'HH24') &lt; 8 OR
    TO_CHAR(Sysdate, 'HH24') &gt; 18) THEN
      RAISE Nonworking_hours;
  END IF;
 
EXCEPTION
  WHEN Not_on_weekends THEN
    Raise_application_error(-20324,'Might not change '
      ||'employee table during the weekend');
  WHEN Nonworking_hours THEN
    Raise_application_error(-20326,'Might not change '
     ||'emp table during Nonworking hours');
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DBSEG" href="../../network.112/e36292/toc.htm"><span class="italic">Oracle Database Security Guide</span></a> for detailed information about database security features</div>
</div>
<!-- class="sect3" -->
<a id="CIHGEFAH"></a>
<div id="LNPLS785" class="sect3">
<h4 class="sect3">Triggers for Transparent Event Logging</h4>
<p>Triggers are very useful when you want to transparently do a related change in the database following certain events.</p>
<p>The <code dir="ltr">REORDER</code> trigger example shows a trigger that reorders parts as necessary when certain conditions are met. (In other words, a triggering statement is entered, and the <code dir="ltr">PARTS_ON_HAND</code> value is less than the <code dir="ltr">REORDER_POINT</code> value.)</p>
</div>
<!-- class="sect3" -->
<a id="CIHCCGIB"></a>
<div id="LNPLS786" class="sect3">
<h4 class="sect3">Triggers for Deriving Column Values</h4>
<p>Triggers can derive column values automatically, based upon a value provided by an <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement. This type of trigger is useful to force values in specific columns that depend on the values of other columns in the same row. <code dir="ltr">BEFORE</code> row triggers are necessary to complete this type of operation for these reasons:</p>
<ul>
<li>
<p>The dependent values must be derived before the <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> occurs, so that the triggering statement can use the derived values.</p>
</li>
<li>
<p>The trigger must fire for each row affected by the triggering <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement.</p>
</li>
</ul>
<p>The trigger in <a href="#BCFDEHHE">Example 9-18</a> derives new column values for a table whenever a row is inserted or updated.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a href="#BCFDEHHE">Example 9-18</a> needs this change to this data structure:
<pre dir="ltr">
ALTER TABLE Emp ADD(
   Uppername   VARCHAR2(20),
   Soundexname VARCHAR2(20));
</pre></div>
<div id="LNPLS787" class="example">
<p class="titleinexample"><a id="BCFDEHHE"></a>Example 9-18 Trigger Derives New Column Values</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Derived 
BEFORE INSERT OR UPDATE OF Ename ON Emp

/* Before updating the ENAME field, derive the values for
   the UPPERNAME and SOUNDEXNAME fields. Restrict users
   from updating these fields directly: */
FOR EACH ROW
BEGIN
  :NEW.Uppername := UPPER(:NEW.Ename);
  :NEW.Soundexname := SOUNDEX(:NEW.Ename);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="CIHIBAIE"></a>
<div id="LNPLS788" class="sect3">
<h4 class="sect3">Triggers for Building Complex Updatable Views</h4>
<p>Views are an excellent mechanism to provide logical windows over table data. However, when the view query gets complex, the system implicitly cannot translate the DML on the view into those on the underlying tables. <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers help solve this problem. These triggers can be defined over views, and they fire instead of the actual DML.</p>
<p>Consider a library system where books are arranged by title. The library consists of a collection of book type objects:</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE Book_t AS OBJECT (
  Booknum    NUMBER,
  Title      VARCHAR2(20),
  Author     VARCHAR2(20),
  Available  CHAR(1)
);
/
CREATE OR REPLACE TYPE Book_list_t AS TABLE OF Book_t;
/
</pre>
<p>The table <code dir="ltr">Book_table</code> is created and populated like this:</p>
<pre dir="ltr">
DROP TABLE Book_table;
CREATE TABLE Book_table (
  Booknum    NUMBER,
  Section    VARCHAR2(20),
  Title      VARCHAR2(20),
  Author     VARCHAR2(20),
  Available  CHAR(1)
);
 
INSERT INTO Book_table (
  Booknum, Section, Title, Author, Available
) 
VALUES (
  121001, 'Classic', 'Iliad', 'Homer', 'Y'
);
 
INSERT INTO Book_table (
  Booknum, Section, Title, Author, Available
) 
VALUES ( 
  121002, 'Novel', 'Gone with the Wind', 'Mitchell M', 'N'
);
 
SELECT * FROM Book_table ORDER BY Booknum;
</pre>
<p>Result:</p>
<pre dir="ltr">
   BOOKNUM SECTION              TITLE                AUTHOR               A
---------- -------------------- -------------------- -------------------- -
    121001 Classic              Iliad                Homer                Y
    121002 Novel                Gone with the Wind   Mitchell M           N
 
2 rows selected.
</pre>
<p>The table <code dir="ltr">Library_table</code> is created and populated like this:</p>
<pre dir="ltr">
DROP TABLE Library_table;
CREATE TABLE Library_table (Section VARCHAR2(20));
 
INSERT INTO Library_table (Section)
VALUES ('Novel');
 
INSERT INTO Library_table (Section)
VALUES ('Classic');
 
SELECT * FROM Library_table ORDER BY Section;
</pre>
<p>Result:</p>
<pre dir="ltr">
SECTION
--------------------
Classic
Novel
 
2 rows selected.
</pre>
<p>You can define a complex view over the tables <code dir="ltr">Book_table</code> and <code dir="ltr">Library_table</code> to create a logical view of the library with sections and a collection of books in each section:</p>
<pre dir="ltr">
CREATE OR REPLACE VIEW Library_view AS
  SELECT i.Section, CAST (
    MULTISET (
      SELECT b.Booknum, b.Title, b.Author, b.Available
      FROM Book_table b
      WHERE b.Section = i.Section
    ) AS Book_list_t
  ) BOOKLIST
  FROM Library_table i;
</pre>
<p>(For information about the <code dir="ltr">CAST</code> function, see <a class="olink SQLRF00613" href="../../server.112/e41084/functions023.htm#SQLRF00613"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<p>Make <code dir="ltr">Library_view</code> updatable by defining an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger on it:</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Library_trigger
  INSTEAD OF
  INSERT ON Library_view
  FOR EACH ROW
DECLARE
  Bookvar  Book_t;
  i        INTEGER;
BEGIN
  INSERT INTO Library_table
  VALUES (:NEW.Section);
 
  FOR i IN 1..:NEW.Booklist.COUNT LOOP
    Bookvar := :NEW.Booklist(i);
 
    INSERT INTO Book_table (
      Booknum, Section, Title, Author, Available      
    )
    VALUES (
      Bookvar.booknum, :NEW.Section, Bookvar.Title,
      Bookvar.Author, bookvar.Available
    );
  END LOOP;
END;
/
</pre>
<p>Insert a new row into <code dir="ltr">Library_view</code>:</p>
<pre dir="ltr">
INSERT INTO Library_view (Section, Booklist)
VALUES (
  'History', 
  book_list_t (book_t (121330, 'Alexander', 'Mirth', 'Y'))
);
</pre>
<p>See the effect on <code dir="ltr">Library_view</code>:</p>
<pre dir="ltr">
SELECT * FROM Library_view ORDER BY Section;
</pre>
<p>Result:</p>
<pre dir="ltr">
SECTION
--------------------
BOOKLIST(BOOKNUM, TITLE, AUTHOR, AVAILABLE)
--------------------------------------------------------------------
 
Classic
BOOK_LIST_T(BOOK_T(121001, 'Iliad', 'Homer', 'Y'))
 
History
BOOK_LIST_T(BOOK_T(121330, 'Alexander', 'Mirth', 'Y'))
 
Novel
BOOK_LIST_T(BOOK_T(121002, 'Gone with the Wind', 'Mitchell M', 'N'))
 
 
3 rows selected.
</pre>
<p>See the effect on <code dir="ltr">Book_table</code>:</p>
<pre dir="ltr">
SELECT * FROM Book_table ORDER BY Booknum;
</pre>
<p>Result:</p>
<pre dir="ltr">
   BOOKNUM SECTION              TITLE                AUTHOR               A
---------- -------------------- -------------------- -------------------- -
    121001 Classic              Iliad                Homer                Y
    121002 Novel                Gone with the Wind   Mitchell M           N
    121330 History              Alexander            Mirth                Y
 
3 rows selected.
</pre>
<p>See the effect on <code dir="ltr">Library_table</code>:</p>
<pre dir="ltr">
SELECT * FROM Library_table ORDER BY Section;
</pre>
<p>Result:</p>
<pre dir="ltr">
SECTION
--------------------
Classic
History
Novel
 
3 rows selected.
</pre>
<p>Similarly, you can also define triggers on the nested table <code dir="ltr">booklist</code> to handle modification of the nested table element.</p>
</div>
<!-- class="sect3" -->
<a id="CIHHHHHI"></a>
<div id="LNPLS789" class="sect3">
<h4 class="sect3">Triggers for Fine-Grained Access Control</h4>
<p>You can use <code dir="ltr">LOGON</code> triggers to run the package associated with an application context. An application context captures session-related information about the user who is logging in to the database. From there, your application can control how much access this user has, based on his or her session information.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have very specific logon requirements, such as preventing users from logging in from outside the firewall or after work hours, consider using Oracle Database Vault instead of <code dir="ltr">LOGON</code> triggers. With Oracle Database Vault, you can create custom rules to strictly control user access.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DBSEG60634" href="../../network.112/e36292/app_context.htm#DBSEG60634"><span class="italic">Oracle Database Security Guide</span></a> for information about creating a <code dir="ltr">LOGON</code> trigger to run a database session application context package</p>
</li>
<li>
<p><a class="olink DVADM" href="../../server.112/e23090/toc.htm"><span class="italic">Oracle Database Vault Administrator's Guide</span></a> for information about Oracle Database Vault</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHEFBJA"></a>
<div id="LNPLS99887" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">System Triggers</h2>
<p>A <a id="sthref799"></a><span class="bold">system trigger</span> is created on either a schema or the database. Its triggering event is composed of either DDL statements (listed in <a href="create_trigger.htm#CIHGCJHC">"<span class="italic">ddl_event</span>"</a>) or database operation statements (listed in <a href="create_trigger.htm#CIHFAEJC">"<span class="italic">database_event</span>"</a>).</p>
<p>A system trigger fires at exactly one of these <a id="sthref800"></a>timing points:</p>
<ul>
<li>
<p>Before the triggering statement runs</p>
<p>(The trigger is called a <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">statement trigger</span> or <span class="italic">statement-level</span> <code dir="ltr"><span class="codeinlineitalic">BEFORE</span></code> <span class="italic">trigger.</span>)</p>
</li>
<li>
<p>After the triggering statement runs</p>
<p>(The trigger is called a <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">statement trigger</span> or <span class="italic">statement-level</span> <code dir="ltr"><span class="codeinlineitalic">AFTER</span></code> <span class="italic">trigger.</span>)</p>
</li>
<li>
<p>Instead of the triggering <code dir="ltr">CREATE</code> statement</p>
<p>(The trigger is called an <code dir="ltr"><span class="codeinlineitalic">INSTEAD</span></code> <code dir="ltr"><span class="codeinlineitalic">OF</span></code> <code dir="ltr"><span class="codeinlineitalic">CREATE</span></code> <span class="italic">trigger</span>.)</p>
</li>
</ul>
<p>Topics</p>
<ul>
<li>
<p><a href="#CIHGCBDG">SCHEMA Triggers</a></p>
</li>
<li>
<p><a href="#CIHGFCDB">DATABASE Triggers</a></p>
</li>
<li>
<p><a href="#CIHIDHED">INSTEAD OF CREATE Triggers</a></p>
</li>
</ul>
<a id="CIHGCBDG"></a>
<div id="LNPLS99886" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SCHEMA Triggers</h3>
<p>A <a id="sthref801"></a><code dir="ltr"><span class="codeinlinebold">SCHEMA</span></code> <span class="bold">trigger</span> is created on a schema and fires whenever the user who owns it is the current user and initiates the triggering event.</p>
<p>Suppose that both user1 and user2 own schema triggers, and user1 invokes a <a id="sthref802"></a>DR unit owned by user2. Inside the DR unit, user2 is the current user. Therefore, if the DR unit initiates the triggering event of a schema trigger that user2 owns, then that trigger fires. However, if the DR unit initiates the triggering event of a schema trigger that user1 owns, then that trigger does not fire.</p>
<p><a href="#CIHFGGEH">Example 9-19</a> creates a <code dir="ltr">BEFORE</code> statement trigger on the sample schema <code dir="ltr">HR</code>. When a user connected as <code dir="ltr">HR</code> tries to drop a database object, the database fires the trigger before dropping the object.</p>
<div id="LNPLS722" class="example">
<p class="titleinexample"><a id="CIHFGGEH"></a>Example 9-19 BEFORE Statement Trigger on Sample Schema HR</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER drop_trigger
  BEFORE DROP ON hr.SCHEMA
  BEGIN
    RAISE_APPLICATION_ERROR (
      num =&gt; -20000,
      msg =&gt; 'Cannot drop object');
  END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHGFCDB"></a>
<div id="LNPLS99885" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DATABASE Triggers</h3>
<p>A <a id="sthref803"></a><code dir="ltr"><span class="codeinlinebold">DATABASE</span></code> <span class="bold">trigger</span> is created on the database and fires whenever any database user initiates the triggering event.</p>
<p><a href="#CIHEBJDD">Example 9-20</a> shows the basic syntax for a trigger to log errors. This trigger fires after an unsuccessful statement execution, such as unsuccessful logon.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An <code dir="ltr">AFTER</code> <code dir="ltr">SERVERERROR</code> trigger fires only if Oracle relational database management system (RDBMS) determines that it is safe to fire error triggers. For more information about <code dir="ltr">AFTER</code> <code dir="ltr">SERVERERROR</code> triggers, see <a href="create_trigger.htm#CIHHJGAJ">"<code dir="ltr">AFTER</code> <code dir="ltr">SERVERERROR</code>"</a>.</div>
<div id="LNPLS725" class="example">
<p class="titleinexample"><a id="CIHEBJDD"></a>Example 9-20 AFTER Statement Trigger on Database</p>
<pre dir="ltr">
CREATE TRIGGER log_errors
  AFTER SERVERERROR ON DATABASE
  BEGIN
    IF (IS_SERVERERROR (1017)) THEN
      NULL;  -- (substitute code that processes logon error)
    ELSE
      NULL;  -- (substitute code that logs error code)
    END IF;
  END;
/
</pre></div>
<!-- class="example" -->
<p>The trigger in <a href="#CIHEFABC">Example 9-21</a> runs the procedure <code dir="ltr">check_user</code> after a user logs onto the database.</p>
<div id="LNPLS745" class="example">
<p class="titleinexample"><a id="CIHEFABC"></a>Example 9-21 Trigger Monitors Logons</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER check_user
  AFTER LOGON ON DATABASE
  BEGIN
    check_user;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR
        (-20000, 'Unexpected error: '|| DBMS_Utility.Format_Error_Stack);
 END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CIHIDHED"></a>
<div id="LNPLS1967" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">INSTEAD OF CREATE Triggers</h3>
<p><a id="sthref804"></a>An <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> <code dir="ltr">CREATE</code> trigger is a <code dir="ltr">SCHEMA</code> trigger whose triggering event is a <code dir="ltr">CREATE</code> statement. The database fires the trigger instead of executing its triggering statement.</p>
<p><a href="#CIHGIHFA">Example 9-22</a> shows the basic syntax for an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> <code dir="ltr">CREATE</code> trigger on the current schema. This trigger fires when the owner of the current schema issues a <code dir="ltr">CREATE</code> statement in the current schema.</p>
<div id="LNPLS1968" class="example">
<p class="titleinexample"><a id="CIHGIHFA"></a>Example 9-22 INSTEAD OF CREATE Trigger on Schema</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER t
  INSTEAD OF CREATE ON SCHEMA
  BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE T (n NUMBER, m NUMBER)';
  END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHEGACF"></a>
<div id="LNPLS99884" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Subprograms Invoked by Triggers</h2>
<p>Triggers can invoke <a id="sthref805"></a>subprograms written in PL/SQL, C, and Java. The trigger in <a href="#CIHGJFAB">Example 9-9</a> invokes a PL/SQL subprogram. The trigger in <a href="#CIHGEEIC">Example 9-23</a> invokes a Java subprogram.</p>
<div id="LNPLS746" class="example">
<p class="titleinexample"><a id="CIHGEEIC"></a>Example 9-23 Trigger Invokes Java Subprogram</p>
<pre dir="ltr">
CREATE OR REPLACE <span class="bold">PROCEDURE Before_delete (Id IN NUMBER, Ename VARCHAR2)</span>
IS <span class="bold">LANGUAGE Java</span>
name 'thjvTriggers.beforeDelete (oracle.sql.NUMBER, oracle.sql.CHAR)';

CREATE OR REPLACE <span class="bold">TRIGGER Pre_del_trigger</span> BEFORE DELETE ON Tab 
FOR EACH ROW
<span class="bold">CALL Before_delete (:OLD.Id, :OLD.Ename)</span>
/
</pre>
<p>The corresponding Java file is <code dir="ltr">thjvTriggers</code>.<code dir="ltr">java</code>:</p>
<pre dir="ltr">
import java.sql.*
import java.io.*
import oracle.sql.*
import oracle.oracore.*
public class thjvTriggers
{
public static void
beforeDelete (NUMBER old_id, CHAR old_name)
Throws SQLException, CoreException
   {
   Connection conn = JDBCConnection.defaultConnection();
   Statement stmt = conn.CreateStatement();
   String sql = "insert into logtab values
   ("+ old_id.intValue() +", '"+ old_ename.toString() + ", BEFORE DELETE');
   stmt.executeUpdate (sql);
   stmt.close();
   return;
   }
}
</pre></div>
<!-- class="example" -->
<p>A subprogram invoked by a trigger cannot run <a id="sthref806"></a>transaction control statements, because the subprogram runs in the context of the trigger body.</p>
<p>If a trigger invokes an invoker rights (IR) subprogram, then the user who created the trigger, not the user who ran the triggering statement, is considered to be the current user. For information about IR subprograms, see <a href="subprograms.htm#i18574">"Invoker's Rights and Definer's Rights (AUTHID Property)"</a>.</p>
<p>If a trigger invokes a remote subprogram, and a time stamp or signature mismatch is found during execution of the trigger, then the remote subprogram does not run and the trigger is invalidated.</p>
</div>
<!-- class="sect1" -->
<a id="i1006994"></a>
<div id="LNPLS2007" class="sect1">
<h2 class="sect1">Trigger Compilation, Invalidation, and Recompilation</h2>
<p>The <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement compiles the trigger and stores its code in the database. If a compilation error occurs, the trigger is still created, but its triggering statement fails, except in these cases:</p>
<ul>
<li>
<p>The trigger was created in the disabled state.</p>
</li>
<li>
<p>The triggering event is <code dir="ltr">AFTER</code> <code dir="ltr">STARTUP</code> <code dir="ltr">ON</code> <code dir="ltr">DATABASE</code>.</p>
</li>
<li>
<p>The triggering event is either <code dir="ltr">AFTER</code> <code dir="ltr">LOGON</code> <code dir="ltr">ON</code> <code dir="ltr">DATABASE</code> or <code dir="ltr">AFTER</code> <code dir="ltr">LOGON</code> <code dir="ltr">ON</code> <code dir="ltr">SCHEMA</code>, and someone logs on as <code dir="ltr">SYSTEM</code>.</p>
</li>
</ul>
<p>To see trigger compilation errors, either use the <code dir="ltr">SHOW</code> <code dir="ltr">ERRORS</code> command in SQL*Plus or Enterprise Manager, or query the static data dictionary view <code dir="ltr">*_ERRORS</code> (described in <a class="olink REFRN26065" href="../../server.112/e40402/statviews_5296.htm#REFRN26065"><span class="italic">Oracle Database Reference</span></a>).</p>
<p>If a trigger does not compile successfully, then its exception handler cannot run. For an example, see <a href="#CIHEAHFI">"Remote Exception Handling"</a>.</p>
<p>If a trigger references another object, such as a subprogram or package, and that object is modified or dropped, then the trigger becomes invalid. The next time the triggering event occurs, the compiler tries to revalidate the trigger (for details, see <a class="olink ADFNS99967" href="../../appdev.112/e41502/adfns_dependencies.htm#ADFNS99967"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the <code dir="ltr">DBMS_AQ</code> package is used to enqueue a message, dependency between triggers and queues cannot be maintained.</div>
<p>To recompile a trigger manually, use the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement, described in <a href="alter_trigger.htm#BABFDCBJ">"ALTER TRIGGER Statement"</a>.</p>
</div>
<!-- class="sect1" -->
<a id="CIHGJCFI"></a>
<div id="LNPLS751" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Exception Handling in Triggers</h2>
<p>In most cases, if a trigger runs a statement that raises an <a id="sthref807"></a>exception, and the exception is not handled by an exception handler, then the database rolls back the effects of both the trigger and its triggering statement.</p>
<p>In the following cases, the database rolls back only the effects of the trigger, not the effects of the triggering statement (and logs the error in trace files and the alert log):</p>
<ul>
<li>
<p>The triggering event is either <code dir="ltr">AFTER</code> <code dir="ltr">STARTUP</code> <code dir="ltr">ON</code> <code dir="ltr">DATABASE</code> or <code dir="ltr">BEFORE</code> <code dir="ltr">SHUTDOWN</code> <code dir="ltr">ON</code> <code dir="ltr">DATABASE</code>.</p>
</li>
<li>
<p>The triggering event is <code dir="ltr">AFTER</code> <code dir="ltr">LOGON</code> <code dir="ltr">ON</code> <code dir="ltr">DATABASE</code> and the user has the <code dir="ltr">ADMINISTER</code> <code dir="ltr">DATABASE</code> <code dir="ltr">TRIGGER</code> privilege.</p>
</li>
<li>
<p>The triggering event is <code dir="ltr">AFTER</code> <code dir="ltr">LOGON</code> <code dir="ltr">ON</code> <code dir="ltr">SCHEMA</code> and the user either owns the schema or has the <code dir="ltr">ALTER</code> <code dir="ltr">ANY</code> <code dir="ltr">TRIGGER</code> privilege.</p>
</li>
</ul>
<p>In the case of a compound DML trigger, the database rolls back only the effects of the triggering statement, not the effects of the trigger. However, variables declared in the trigger are re-initialized, and any values computed before the triggering statement was rolled back are lost.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Triggers that enforce complex security authorizations or constraints typically raise user-defined exceptions, which are explained in <a href="errors.htm#i3329">"User-Defined Exceptions"</a>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="errors.htm#CHDFGBJI">Chapter 11, "PL/SQL Error Handling,"</a> for general information about exception handling</div>
<p class="subhead2"><a id="CIHEAHFI"></a><a id="LNPLS754"></a>Remote Exception Handling</p>
<p>A trigger that accesses a remote database can do <a id="sthref808"></a>remote exception handling only if the remote database is available. If the remote database is unavailable when the local database must compile the trigger, then the local database cannot validate the statement that accesses the remote database, and the compilation fails. If the trigger cannot be compiled, then its exception handler cannot run.</p>
<p>The trigger in <a href="#BCFDBDJH">Example 9-24</a> has an <code dir="ltr">INSERT</code> statement that accesses a remote database. The trigger also has an exception handler. However, if the remote database is unavailable when the local database tries to compile the trigger, then the compilation fails and the exception handler cannot run.</p>
<div id="LNPLS726" class="example">
<p class="titleinexample"><a id="BCFDBDJH"></a>Example 9-24 Trigger Cannot Handle Exception if Remote Database is Unavailable</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER employees_tr
  AFTER INSERT ON employees
  FOR EACH ROW
BEGIN
  <span class="bold">-- When remote database is unavailable, compilation fails here:</span>
  INSERT INTO employees@remote (
    employee_id, first_name, last_name, email, hire_date, job_id
  ) 
  VALUES (
    99, 'Jane', 'Doe', 'jane.doe@example.com', SYSDATE, 'ST_MAN'
  );
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO emp_log (Emp_id, Log_date, New_salary, Action)
      VALUES (99, SYSDATE, NULL, 'Could not insert');
    RAISE;
END;
/
</pre></div>
<!-- class="example" -->
<p><a href="#BCFEHHDA">Example 9-25</a> shows the workaround for the problem in <a href="#BCFDBDJH">Example 9-24</a>: Put the remote <code dir="ltr">INSERT</code> statement and exception handler in a stored subprogram and have the trigger invoke the stored subprogram. The subprogram is stored in the local database in compiled form, with a validated statement for accessing the remote database. Therefore, when the remote <code dir="ltr">INSERT</code> statement fails because the remote database is unavailable, the exception handler in the subprogram can handle it.</p>
<div id="LNPLS728" class="example">
<p class="titleinexample"><a id="BCFEHHDA"></a>Example 9-25 Workaround for <a href="#BCFDBDJH">Example 9-24</a></p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE insert_row_proc AUTHID DEFINER AS
  no_remote_db EXCEPTION;  -- declare exception
  PRAGMA EXCEPTION_INIT (no_remote_db, -20000);
                           -- assign error code to exception
BEGIN
  INSERT INTO employees@remote (
    employee_id, first_name, last_name, email, hire_date, job_id
  ) 
  VALUES (
    99, 'Jane', 'Doe', 'jane.doe@example.com', SYSDATE, 'ST_MAN'
  );
EXCEPTION
  WHEN OTHERS THEN
    INSERT INTO emp_log (Emp_id, Log_date, New_salary, Action)
      VALUES (99, SYSDATE, NULL, 'Could not insert row.');
 
  RAISE_APPLICATION_ERROR (-20000, 'Remote database is unavailable.');
END;
/
 
CREATE OR REPLACE TRIGGER employees_tr
  AFTER INSERT ON employees
  FOR EACH ROW
BEGIN
  <span class="bold">insert_row_proc;</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i1006211"></a>
<div id="LNPLS2002" class="sect1">
<h2 class="sect1">Trigger Design Guidelines</h2>
<ul>
<li>
<p>Use triggers to ensure that whenever a specific event occurs, any necessary actions are done (regardless of which user or application issues the triggering statement).</p>
<p>For example, use a trigger to ensure that whenever anyone updates a table, its log file is updated.</p>
</li>
<li>
<p>Do not create triggers that duplicate database features.</p>
<p>For example, do not create a trigger to reject invalid data if you can do the same with constraints (see <a href="#CIHCEBAE">"How Triggers and Constraints Differ"</a>).</p>
</li>
<li>
<p>Do not create triggers that depend on the order in which a SQL statement processes rows (which can vary).</p>
<p>For example, do not assign a value to a global package variable in a row trigger if the current value of the variable depends on the row being processed by the row trigger. If a trigger updates global package variables, initialize those variables in a <code dir="ltr">BEFORE</code> statement trigger.</p>
</li>
<li>
<p>Use <code dir="ltr">BEFORE</code> row triggers to modify the row before writing the row data to disk.</p>
</li>
<li>
<p>Use <code dir="ltr">AFTER</code> row triggers to obtain the row ID and use it in operations.</p>
<p>An <code dir="ltr">AFTER</code> row trigger fires when the triggering statement results in ORA-2292.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">AFTER</code> row triggers are slightly more efficient than <code dir="ltr">BEFORE</code> row triggers. With <code dir="ltr">BEFORE</code> row triggers, affected data blocks are read first for the trigger and then for the triggering statement. With <code dir="ltr">AFTER</code> row triggers, affected data blocks are read only for the trigger.</div>
</li>
<li>
<p>If the triggering statement of a <code dir="ltr">BEFORE</code> statement trigger is an <a id="sthref809"></a><code dir="ltr">UPDATE</code> or <a id="sthref810"></a><code dir="ltr">DELETE</code> statement that conflicts with an <code dir="ltr">UPDATE</code> statement that is running, then the database does a <a id="sthref811"></a>transparent <code dir="ltr">ROLLBACK</code> to <code dir="ltr">SAVEPOINT</code> and restarts the triggering statement. The database can do this many times before the triggering statement completes successfully. Each time the database restarts the triggering statement, the trigger fires. The <code dir="ltr">ROLLBACK</code> to <code dir="ltr">SAVEPOINT</code> does not undo changes to package variables that the trigger references. To detect this situation, include a counter variable in the package.</p>
</li>
<li>
<p>Do not create <a id="sthref812"></a><a id="sthref813"></a>recursive triggers.</p>
<p>For example, do not create an <code dir="ltr">AFTER</code> <code dir="ltr">UPDATE</code> trigger that issues an <code dir="ltr">UPDATE</code> statement on the table on which the trigger is defined. The trigger fires recursively until it runs out of memory.</p>
</li>
<li>
<p>If you create a trigger that includes a statement that accesses a remote database, then put the exception handler for that statement in a stored subprogram and invoke the subprogram from the trigger.</p>
<p>For more information, see <a href="#CIHEAHFI">"Remote Exception Handling"</a>.</p>
</li>
<li>
<p>Use <code dir="ltr">DATABASE</code> triggers judiciously. They fire every time any database user initiates a triggering event.</p>
</li>
<li>
<p>If a trigger runs the following statement, the statement returns the owner of the trigger, not the user who is updating the table:</p>
<pre dir="ltr">
SELECT Username FROM USER_USERS;
</pre></li>
<li>
<p>Only committed triggers fire.</p>
<p>A trigger is committed, implicitly, after the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement that creates it succeeds. Therefore, the following statement cannot fire the trigger that it creates:</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER my_trigger
  AFTER CREATE ON DATABASE
BEGIN
  NULL;
END;
/
</pre></li>
<li>
<p>To allow the modular installation of applications that have triggers on the same tables, create multiple triggers of the same type, rather than a single trigger that runs a sequence of operations.</p>
<p>Each trigger sees the changes made by the previously fired triggers. Each trigger can see <code dir="ltr">OLD</code> and <code dir="ltr">NEW</code> values.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="g1042050"></a>
<div id="LNPLS755" class="sect1">
<h2 class="sect1">Trigger Restrictions</h2>
<p>In addition to the restrictions that apply to all PL/SQL units (see <a href="limits.htm#BABIHIJG">Table C-1</a>), triggers have these restrictions:</p>
<ul>
<li>
<p><a href="#g1699381">Trigger Size Restriction</a></p>
</li>
<li>
<p><a href="#g1699536">Trigger LONG and LONG RAW Data Type Restrictions</a></p>
</li>
<li>
<p><a href="#g1699708">Mutating-Table Restriction</a></p>
</li>
<li>
<p>Only an autonomous trigger can run TCL or DDL statements.</p>
<p>For information about autonomous triggers, see <a href="static.htm#CIHEHGED">"Autonomous Triggers"</a>.</p>
</li>
<li>
<p>A trigger cannot invoke a subprogram that runs transaction control statements, because the subprogram runs in the context of the trigger body.</p>
<p>For more information about subprograms invoked by triggers, see <a href="#CIHEGACF">"Subprograms Invoked by Triggers"</a>.</p>
</li>
<li>
<p>A trigger cannot access a <code dir="ltr">SERIALLY_REUSABLE</code> package.</p>
<p>For information about <code dir="ltr">SERIALLY_REUSABLE</code> packages, see <a href="packages.htm#CJABACHJ">"SERIALLY_REUSABLE Packages"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CIHIEFAE">"Compound DML Trigger Restrictions"</a></div>
<a id="g1699381"></a>
<div id="LNPLS756" class="sect2">
<h3 class="sect2">Trigger Size Restriction</h3>
<p>The size of the trigger cannot exceed 32K.</p>
<p>If the logic for your trigger requires much more than 60 lines of PL/SQL source text, then put most of the source text in a stored subprogram and invoke the subprogram from the trigger. For information about subprograms invoked by triggers, see <a href="#CIHEGACF">"Subprograms Invoked by Triggers"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="g1699536"></a>
<div id="LNPLS758" class="sect2">
<h3 class="sect2">Trigger LONG and LONG RAW Data Type Restrictions</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle supports the <a id="sthref814"></a><code dir="ltr">LONG</code> and <a id="sthref815"></a><code dir="ltr">LONG</code> <code dir="ltr">RAW</code> data types only for backward compatibility with existing applications.</div>
<p>In addition to the restrictions that apply to all PL/SQL units (see <a href="datatypes.htm#CJAEGDEB">"LONG and LONG RAW Variables"</a>), triggers have these restrictions:</p>
<ul>
<li>
<p>A trigger cannot declare a variable of the <code dir="ltr">LONG</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> data type.</p>
</li>
<li>
<p>A SQL statement in a trigger can reference a <code dir="ltr">LONG</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> column only if the column data can be converted to the data type <code dir="ltr">CHAR</code> or <code dir="ltr">VARCHAR2</code>.</p>
</li>
<li>
<p>A trigger cannot use the <a id="sthref816"></a>correlation name <a id="sthref817"></a><code dir="ltr">NEW</code> or <a id="sthref818"></a><code dir="ltr">PARENT</code> with a <code dir="ltr">LONG</code> or <code dir="ltr">LONG</code> <code dir="ltr">RAW</code> column.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1699708"></a>
<div id="LNPLS759" class="sect2">
<h3 class="sect2">Mutating-Table Restriction</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This topic applies only to row-level simple DML triggers.</div>
<p>A <a id="sthref819"></a><a id="sthref820"></a><span class="bold">mutating table</span> is a table that is being modified by a DML statement (possibly by the effects of a <code dir="ltr">DELETE</code> <code dir="ltr">CASCADE</code> constraint). (A view being modified by an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger is not considered to be mutating.)</p>
<p>The mutating-table restriction prevents the trigger from querying or modifying the table that the triggering statement is modifying. When a row-level trigger encounters a mutating table, <a id="sthref821"></a>ORA-04091 occurs, the effects of the trigger and triggering statement are rolled back, and control returns to the user or application that issued the triggering statement, as <a href="#BCFHJBBE">Example 9-26</a> shows.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Oracle Database does not enforce the mutating-table restriction for a trigger that accesses remote nodes, because the database does not support declarative referential constraints between tables on different nodes of a distributed database.
<p>Similarly, the database does not enforce the mutating-table restriction for tables in the same database that are connected by loop-back database links. A loop-back database link makes a local table appear remote by defining an Oracle Net path back to the database that contains the link.</p>
</div>
<div id="LNPLS729" class="example">
<p class="titleinexample"><a id="BCFHJBBE"></a>Example 9-26 Trigger Causes Mutating-Table Error</p>
<pre dir="ltr">
-- Create log table
 
DROP TABLE log;
CREATE TABLE log (
  emp_id  NUMBER(6),
  l_name  VARCHAR2(25),
  f_name  VARCHAR2(20)
);
 
-- Create trigger that updates log and then reads employees
 
CREATE OR REPLACE TRIGGER log_deletions
  AFTER DELETE ON employees
  FOR EACH ROW
DECLARE
  n INTEGER;
BEGIN
  INSERT INTO log VALUES (
    :OLD.employee_id,
    :OLD.last_name,
    :OLD.first_name
  );
 
  SELECT COUNT(*) INTO n FROM employees;
  DBMS_OUTPUT.PUT_LINE('There are now ' || n || ' employees.');
END;
/
 
-- Issue triggering statement:
 
DELETE FROM employees WHERE employee_id = 197;
</pre>
<p>Result:</p>
<pre dir="ltr">
DELETE FROM employees WHERE employee_id = 197
            *
ERROR at line 1:
<span class="bold">ORA-04091: table HR.EMPLOYEES is mutating, trigger/function might not see it</span>
ORA-06512: at "HR.LOG_DELETIONS", line 10
ORA-04088: error during execution of trigger 'HR.LOG_DELETIONS'
</pre>
<p>Show that effect of trigger was rolled back:</p>
<pre dir="ltr">
SELECT count(*) FROM log;
</pre>
<p>Result:</p>
<pre dir="ltr">
  COUNT(*)
----------
         0
 
1 row selected.
</pre>
<p>Show that effect of triggering statement was rolled back:</p>
<pre dir="ltr">
SELECT employee_id, last_name FROM employees WHERE employee_id = 197;
</pre>
<p>Result:</p>
<pre dir="ltr">
EMPLOYEE_ID LAST_NAME
----------- -------------------------
        197 Feeney
 
1 row selected.
</pre></div>
<!-- class="example" -->
<p>If you must use a trigger to update a mutating table, you can avoid the mutating-table error in either of these ways:</p>
<ul>
<li>
<p>Use a compound DML trigger (see <a href="#CHDFEBFJ">"Using Compound DML Triggers to Avoid Mutating-Table Error"</a>).</p>
</li>
<li>
<p>Use a temporary table.</p>
<p>For example, instead of using one <code dir="ltr">AFTER</code> each row trigger that updates the mutating table, use two triggers&mdash;an <code dir="ltr">AFTER</code> each row trigger that updates the temporary table and an <code dir="ltr">AFTER</code> statement trigger that updates the mutating table with the values from the temporary table.</p>
</li>
</ul>
<p class="subhead2"><a id="LNPLS760"></a>Mutating-Table Restriction Relaxed</p>
<p>As of Oracle Database 8<span class="italic">g</span>, a deletion from the parent table causes <code dir="ltr">BEFORE</code> and <code dir="ltr">AFTER</code> triggers to fire once. Therefore, you can create row-level and statement-level triggers that query and modify the parent and child tables. This allows most foreign key constraint actions to be implemented through their after-row triggers (unless the constraint is self-referential). Update cascade, update set null, update set default, delete set default, inserting a missing parent, and maintaining a count of children can all be implemented easily&mdash;see <a href="#BCFCAIGG">"Triggers for Ensuring Referential Integrity"</a>.</p>
<p>However, cascades require care for multiple-row foreign key updates. The trigger cannot miss rows that were changed but not committed by another transaction, because the foreign key constraint guarantees that no matching foreign key rows are locked before the after-row trigger is invoked.</p>
<p>In <a href="#BCFEFDIA">Example 9-27</a>, the triggering statement updates <code dir="ltr">p</code> correctly but causes problems when the trigger updates <code dir="ltr">f</code>. First, the triggering statement changes (1) to (2) in <code dir="ltr">p</code>, and the trigger updates (1) to (2) in <code dir="ltr">f</code>, leaving two rows of value (2) in <code dir="ltr">f</code>. Next, the triggering statement updates (2) to (3) in <code dir="ltr">p</code>, and the trigger updates both rows of value (2) to (3) in <code dir="ltr">f</code>. Finally, the statement updates (3) to (4) in <code dir="ltr">p</code>, and the trigger updates all three rows in f from (3) to (4). The relationship between the data items in <code dir="ltr">p</code> and <code dir="ltr">f</code> is lost.</p>
<div id="LNPLS730" class="example">
<p class="titleinexample"><a id="BCFEFDIA"></a>Example 9-27 Update Cascade</p>
<pre dir="ltr">
DROP TABLE p;
CREATE TABLE p (p1 NUMBER CONSTRAINT pk_p_p1 PRIMARY KEY);
INSERT INTO p VALUES (1);
INSERT INTO p VALUES (2);
INSERT INTO p VALUES (3);
 
DROP TABLE f;
CREATE TABLE f (f1 NUMBER CONSTRAINT fk_f_f1 REFERENCES p);
INSERT INTO f VALUES (1);
INSERT INTO f VALUES (2);
INSERT INTO f VALUES (3);
 
CREATE TRIGGER pt
  AFTER UPDATE ON p
  FOR EACH ROW
BEGIN
  UPDATE f SET f1 = :NEW.p1 WHERE f1 = :OLD.p1;
END;
/
 
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM p;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
        P1
----------
         1
         2
         3
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM f;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
        F1
----------
         1
         2
         3
</pre>
<p>Issue triggering statement:</p>
<pre dir="ltr">
UPDATE p SET p1 = p1+1;
 
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM p;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
        P1
----------
         2
         3
         4
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM f;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
        F1
----------
         4
         4
         4
</pre></div>
<!-- class="example" -->
<p>To avoid this problem, either forbid multiple-row updates to <code dir="ltr">p</code> that change the primary key and reuse existing primary key values, or track updates to foreign key values and modify the trigger to ensure that no row is updated twice.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="g1041767"></a>
<div id="LNPLS99985" class="sect1">
<h2 class="sect1">Order in Which Triggers Fire</h2>
<p>If two or more triggers <a id="sthref822"></a><span class="italic">with different timing points</span> are defined for the same statement on the same table, then they fire in this order:</p>
<ol>
<li>
<p>All <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> triggers</p>
</li>
<li>
<p>All <code dir="ltr">BEFORE</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> triggers</p>
</li>
<li>
<p>All <code dir="ltr">AFTER</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> triggers</p>
</li>
<li>
<p>All <code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code> triggers</p>
</li>
</ol>
<p>If it is practical, replace the set of individual triggers with different timing points with a single compound trigger that explicitly codes the actions in the order you intend. For information about compound triggers, see <a href="#CIHEFGFD">"Compound DML Triggers"</a>.</p>
<p>If you are creating two or more triggers <span class="italic">with the same timing point</span>, and the order in which they fire is important, then you can control their firing order using the <code dir="ltr">FOLLOWS</code> and <code dir="ltr">PRECEDES</code> clauses (see <a href="create_trigger.htm#CIHEAGIF">"FOLLOWS | PRECEDES"</a>).</p>
<p>If multiple compound triggers are created on a table, then:</p>
<ul>
<li>
<p>All <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> sections run at the <code dir="ltr">BEFORE</code> <code dir="ltr">STATEMENT</code> timing point, <code dir="ltr">BEFORE</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> sections run at the <code dir="ltr">BEFORE</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> timing point, and so forth.</p>
<p>If trigger execution order was specified using the <code dir="ltr">FOLLOWS</code> clause, then the <code dir="ltr">FOLLOWS</code> clause determines the order of execution of compound trigger sections. If <code dir="ltr">FOLLOWS</code> is specified for some but not all triggers, then the order of execution of triggers is guaranteed only for those that are related using the <code dir="ltr">FOLLOWS</code> clause.</p>
</li>
<li>
<p>All <code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code> sections run at the <code dir="ltr">AFTER</code> <code dir="ltr">STATEMENT</code> timing point, <code dir="ltr">AFTER</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> sections run at the <code dir="ltr">AFTER</code> <code dir="ltr">EACH</code> <code dir="ltr">ROW</code> timing point, and so forth.</p>
<p>If trigger execution order was specified using the <code dir="ltr">PRECEDES</code> clause, then the <code dir="ltr">PRECEDES</code> clause determines the order of execution of compound trigger sections . If <code dir="ltr">PRECEDES</code> is specified for some but not all triggers, then the order of execution of triggers is guaranteed only for those that are related using the <code dir="ltr">PRECEDES</code> clause.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">PRECEDES</code> applies only to reverse crossedition triggers, which are described in <a class="olink ADFNS99909" href="../../appdev.112/e41502/adfns_editions.htm#ADFNS99909"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</div>
</li>
</ul>
<p>The firing of compound triggers can be interleaved with the firing of simple triggers.</p>
<p>When one trigger causes another trigger to fire, the triggers are said to be <a id="sthref823"></a><a id="sthref824"></a><span class="bold">cascading</span>. The database allows up to 32 triggers to cascade simultaneously. To limit the number of trigger cascades, use the initialization parameter <code dir="ltr">OPEN_CURSORS</code> (described in <a class="olink REFRN10137" href="../../server.112/e40402/initparams163.htm#REFRN10137"><span class="italic">Oracle Database Reference</span></a>), because a cursor opens every time a trigger fires.</p>
</div>
<!-- class="sect1" -->
<a id="CIHJJJHG"></a>
<div id="LNPLS2011" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Trigger Enabling and Disabling</h2>
<p>By default, the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement creates a trigger in the enabled state. To create a trigger in the disabled state, specify <code dir="ltr">DISABLE</code>. Creating a trigger in the disabled state lets you ensure that it compiles without errors before you enable it.</p>
<p>Some reasons to temporarily disable a trigger are:</p>
<ul>
<li>
<p>The trigger refers to an unavailable object.</p>
</li>
<li>
<p>You must do a large data load, and you want it to proceed quickly without firing triggers.</p>
</li>
<li>
<p>You are reloading data.</p>
</li>
</ul>
<p>To enable or disable a single trigger, use this statement:</p>
<pre dir="ltr">
ALTER TRIGGER [<span class="italic">schema</span>.]<span class="italic">trigger_name</span> { ENABLE | DISABLE };
</pre>
<p>To enable or disable all triggers created on a specific table, use this statement:</p>
<pre dir="ltr">
ALTER TABLE <span class="italic">table_name</span> { ENABLE | DISABLE } ALL TRIGGERS;
</pre>
<p>In both of the preceding statements, <code dir="ltr"><span class="codeinlineitalic">schema</span></code> is the name of the schema containing the trigger, and the default is your schema.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="alter_trigger.htm#BABFDCBJ">"ALTER TRIGGER Statement"</a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement</p>
</li>
<li>
<p><a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1007033"></a>
<div id="LNPLS2008" class="sect1">
<h2 class="sect1">Trigger Changing and Debugging</h2>
<p>To change a trigger, you must either replace or re-create it. (The <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement only enables, disables, compiles, or renames a trigger.)</p>
<p>To replace a trigger, use the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement with the <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> clause.</p>
<p>To re-create a trigger, first drop it with the <code dir="ltr">DROP</code> <code dir="ltr">TRIGGER</code> statement and then create it again with the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement.</p>
<p>To debug a trigger, you can use the facilities available for stored subprograms. For information about these facilities, see <a class="olink ADFNS99873" href="../../appdev.112/e41502/adfns_packages.htm#ADFNS99873"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="create_trigger.htm#i2235611">"CREATE TRIGGER Statement"</a> for more information about the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement</p>
</li>
<li>
<p><a href="drop_trigger.htm#CJAEFCHJ">"DROP TRIGGER Statement"</a> for more information about the <code dir="ltr">DROP</code> <code dir="ltr">TRIGGER</code> statement</p>
</li>
<li>
<p><a href="alter_trigger.htm#BABFDCBJ">"ALTER TRIGGER Statement"</a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="BCFGIDEB"></a>
<div id="LNPLS727" class="sect1">
<h2 class="sect1">Triggers and Oracle Database Data Transfer Utilities</h2>
<p>The Oracle database utilities that transfer data to your database, possibly firing triggers, are:</p>
<ul>
<li>
<p><a id="sthref825"></a><span class="bold">SQL*Loader (</span><code dir="ltr"><span class="codeinlinebold">sqlldr</span></code><span class="bold">)</span></p>
<p>SQL*Loader loads data from external files into tables of an Oracle database.</p>
<p>During a SQL*Loader conventional load, <code dir="ltr">INSERT</code> triggers fire.</p>
<p>Before a SQL*Loader direct load, triggers are disabled.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL003" href="../../server.112/e22490/ldr_concepts.htm#SUTIL003"><span class="italic">Oracle Database Utilities</span></a> for more information about SQL*Loader</div>
</li>
<li>
<p><a id="sthref826"></a><span class="bold">Data Pump Import (</span><code dir="ltr"><span class="codeinlinebold">impdp</span></code><span class="bold">)</span></p>
<p>Data Pump Import (<code dir="ltr">impdp</code>) reads an export dump file set created by Data Pump Export (<code dir="ltr">expdp</code>) and writes it to an Oracle database.</p>
<p>If a table to be imported does not exist on the target database, or if you specify <code dir="ltr">TABLE_EXISTS_ACTION=REPLACE</code>, then <code dir="ltr">impdp</code> creates and loads the table before creating any triggers, so no triggers fire.</p>
<p>If a table to be imported exists on the target database, and you specify either <code dir="ltr">TABLE_EXISTS_ACTION=APPEND</code> or <code dir="ltr">TABLE_EXISTS_ACTION=TRUNCATE</code>, then <code dir="ltr">impdp</code> loads rows into the existing table, and <code dir="ltr">INSERT</code> triggers created on the table fire.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL300" href="../../server.112/e22490/dp_import.htm#SUTIL300"><span class="italic">Oracle Database Utilities</span></a> for more information about Data Pump Import</div>
</li>
<li>
<p><span class="bold">Original Import (</span><code dir="ltr"><span class="codeinlinebold">imp</span></code><span class="bold">)</span></p>
<p><a id="sthref827"></a><a id="sthref828"></a><a id="sthref829"></a>Original Import (the original Import utility, <code dir="ltr">imp</code>) reads object definitions and table data from dump files created by original Export (the original Export utility, <code dir="ltr">exp</code>) and writes them to the target database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To import files that original Export created, you must use original Import. In all other cases, Oracle recommends that you use Data Pump Import instead of original Import.</div>
<p>If a table to be imported does not exist on the target database, then <code dir="ltr">imp</code> creates and loads the table before creating any triggers, so no triggers fire.</p>
<p>If a table to be imported exists on the target database, then the Import <code dir="ltr">IGNORE</code> parameter determines whether triggers fire during import operations. The <code dir="ltr">IGNORE</code> parameter specifies whether object creation errors are ignored or not, resulting in the following behavior:</p>
<ul>
<li>
<p>If <code dir="ltr">IGNORE=n</code> (default), then <code dir="ltr">imp</code> does not change the table and no triggers fire.</p>
</li>
<li>
<p>If <code dir="ltr">IGNORE=y</code>, then <code dir="ltr">imp</code> loads rows into the existing table, and <code dir="ltr">INSERT</code> triggers created on the table fire.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SUTIL001" href="../../server.112/e22490/original_import.htm#SUTIL001"><span class="italic">Oracle Database Utilities</span></a> for more information about the original Import utility</p>
</li>
<li>
<p><a class="olink SUTIL3634" href="../../server.112/e22490/original_export.htm#SUTIL3634"><span class="italic">Oracle Database Utilities</span></a> for more information about the original Export utility</p>
</li>
<li>
<p><a class="olink SUTIL1719" href="../../server.112/e22490/original_import.htm#SUTIL1719"><span class="italic">Oracle Database Utilities</span></a> for more information about <code dir="ltr">IGNORE</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1007895"></a>
<div id="LNPLS2014" class="sect1">
<h2 class="sect1">Triggers for Publishing Events</h2>
<p>To use a trigger to <a id="sthref830"></a><a id="sthref831"></a>publish an event, create a trigger that:</p>
<ul>
<li>
<p>Has the event as its triggering event</p>
</li>
<li>
<p>Invokes the appropriate subprograms in the <code dir="ltr">DBMS_AQ</code> package, which provides an interface to Oracle Streams Advanced Queuing (AQ)</p>
<p>For information about the <code dir="ltr">DBMS_AQ</code> package, see <a class="olink ARPLS004" href="../../appdev.112/e40758/d_aq.htm#ARPLS004"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<p>For information about AQ, see <a class="olink ADQUE1400" href="../../server.112/e11013/jm_pblsh.htm#ADQUE1400"><span class="italic">Oracle Streams Advanced Queuing User's Guide</span></a>.</p>
</li>
</ul>
<p>By enabling and disabling such triggers, you can turn event notification on and off. For information about enabling and disabling triggers, see <a href="#CIHJJJHG">"Trigger Enabling and Disabling"</a>.</p>
<p class="subhead2"><a id="CIHFEBID"></a><a id="LNPLS790"></a>How Triggers Publish Events</p>
<p>When the database detects an event, it fires all enabled triggers that are defined on that event, except:</p>
<ul>
<li>
<p>Any trigger that is the target of the triggering event.</p>
<p>For example, a trigger for all <code dir="ltr">DROP</code> events does not fire when it is dropped itself.</p>
</li>
<li>
<p>Any trigger that was modified, but not committed, in the same transaction as the triggering event.</p>
<p>For example, if a recursive DDL statement in a system trigger modifies another trigger, then events in the same transaction cannot fire the modified trigger.</p>
</li>
</ul>
<p>When a trigger fires and invokes AQ, AQ publishes the event and passes to the trigger the publication context and specified attributes. The trigger can access the attributes by invoking event attribute functions.</p>
<p>The attributes that a trigger can specify to AQ (by passing them to AQ as <code dir="ltr">IN</code> parameters) and then access with event attribute functions depends on the triggering event, which is either a database event or a client event.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>A trigger always behaves like a definer rights (DR) unit. The trigger action of an event runs as the definer of the action (as the definer of the package or function in callouts, or as owner of the trigger in queues). Because the owner of the trigger must have <code dir="ltr">EXECUTE</code> privileges on the underlying queues, packages, or subprograms, this action is consistent. For information about DR units, see <a href="subprograms.htm#i18574">"Invoker's Rights and Definer's Rights (AUTHID Property)"</a>.</p>
</li>
<li>
<p>The database ignores the return status from callback functions for all events. For example, the database does nothing with the return status from a <code dir="ltr">SHUTDOWN</code> event.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="LNPLS732"></a>Topics</p>
<ul>
<li>
<p><a href="#i1006199">Event Attribute Functions</a></p>
</li>
<li>
<p><a href="#g1722284">Event Attribute Functions for Database Event Triggers</a></p>
</li>
<li>
<p><a href="#g1722272">Event Attribute Functions for Client Event Triggers</a></p>
</li>
</ul>
<a id="i1006199"></a>
<div id="LNPLS794" class="sect2">
<h3 class="sect2">Event Attribute Functions</h3>
<p>By invoking system-defined event attribute functions in <a href="#CHDCFDJG">Table 9-4</a>, a trigger can retrieve certain attributes of the triggering event. Not all triggers can invoke all event attribute functions&mdash;for details, see <a href="#g1722284">"Event Attribute Functions for Database Event Triggers"</a> and <a href="#g1722272">"Event Attribute Functions for Client Event Triggers"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>In earlier releases, you had to access these functions through the <code dir="ltr">SYS</code> package. Now Oracle recommends accessing them with their public synonyms (the names starting with <code dir="ltr">ora_</code> in the first column of <a href="#CHDCFDJG">Table 9-4</a>).</p>
</li>
<li>
<p>The function parameter <code dir="ltr">ora_name_list_t</code> is defined in package <code dir="ltr">DBMS_STANDARD</code> as:</p>
<pre dir="ltr">
TYPE ora_name_list_t IS TABLE OF VARCHAR2(64);
</pre></li>
</ul>
</div>
<div id="LNPLS795" class="tblformalwidemax">
<p class="titleintable"><a id="sthref832"></a><a id="CHDCFDJG"></a>Table 9-4 System-Defined Event Attributes</p>
<table class="cellalignment1089" title="System-Defined Event Attributes" summary="This table summarizes system-defined event attributes." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t42">Attribute</th>
<th class="cellalignment1090" id="r1c2-t42">Return Type and Value</th>
<th class="cellalignment1090" id="r1c3-t42">Example</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_client_ip_address
</pre></td>
<td class="cellalignment1091" headers="r2c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2</code>: IP address of client in <code dir="ltr">LOGON</code> event when underlying protocol is TCP/IP</p>
</td>
<td class="cellalignment1091" headers="r2c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  v_addr VARCHAR2(11);
BEGIN
  IF (ora_sysevent = 'LOGON') THEN
    v_addr := <span class="bold">ora_client_ip_address</span>;
  END IF;
END;
/
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_database_name
</pre></td>
<td class="cellalignment1091" headers="r3c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2(50)</code>: Database name</p>
</td>
<td class="cellalignment1091" headers="r3c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  v_db_name VARCHAR2(50);
BEGIN
  v_db_name := <span class="bold">ora_database_name</span>;
END;
/
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_des_encrypted_password
</pre></td>
<td class="cellalignment1091" headers="r4c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2</code>: DES-encrypted password of user being created or altered</p>
</td>
<td class="cellalignment1091" headers="r4c1-t42 r1c3-t42">
<pre dir="ltr">
IF (ora_dict_obj_type = 'USER') THEN
  INSERT INTO event_table
  VALUES (<span class="bold">ora_des_encrypted_password</span>);
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_dict_obj_name
</pre></td>
<td class="cellalignment1091" headers="r5c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2(30)</code>: Name of dictionary object on which DDL operation occurred</p>
</td>
<td class="cellalignment1091" headers="r5c1-t42 r1c3-t42">
<pre dir="ltr">
INSERT INTO event_table 
VALUES ('Changed object is ' ||
        <span class="bold">ora_dict_obj_name</span>);
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r6c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_dict_obj_name_list (
name_list OUT ora_name_list_t
)
</pre></td>
<td class="cellalignment1091" headers="r6c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of object names modified in event</p>
<p><code dir="ltr">OUT</code> parameter: List of object names modified in event</p>
</td>
<td class="cellalignment1091" headers="r6c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  name_list ora_name_list_t;
  number_modified PLS_INTEGER;
BEGIN
  IF (ora_sysevent='ASSOCIATE STATISTICS') THEN
    number_modified :=
     <span class="bold">ora_dict_obj_name_list(name_list)</span>;
  END IF;
END;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r7c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_dict_obj_owner
</pre></td>
<td class="cellalignment1091" headers="r7c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2(30)</code>: Owner of dictionary object on which DDL operation occurred</p>
</td>
<td class="cellalignment1091" headers="r7c1-t42 r1c3-t42">
<pre dir="ltr">
INSERT INTO event_table
VALUES ('object owner is' || 
        <span class="bold">ora_dict_obj_owner</span>);
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r8c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_dict_obj_owner_list (
owner_list OUT ora_name_list_t
)
</pre></td>
<td class="cellalignment1091" headers="r8c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of owners of objects modified in event</p>
<p><code dir="ltr">OUT</code> parameter: List of owners of objects modified in event</p>
</td>
<td class="cellalignment1091" headers="r8c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  owner_list ora_name_list_t;
  number_modified PLS_INTEGER;
BEGIN
  IF (ora_sysevent='ASSOCIATE STATISTICS') THEN
    number_modified :=
      <span class="bold">ora_dict_obj_name_list(owner_list)</span>;
  END IF;
END;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r9c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_dict_obj_type
</pre></td>
<td class="cellalignment1091" headers="r9c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2(20)</code>: Type of dictionary object on which DDL operation occurred</p>
</td>
<td class="cellalignment1091" headers="r9c1-t42 r1c3-t42">
<pre dir="ltr">
INSERT INTO event_table
VALUES ('This object is a ' || 
        <span class="bold">ora_dict_obj_type</span>);
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r10c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_grantee (
user_list OUT ora_name_list_t
)
</pre></td>
<td class="cellalignment1091" headers="r10c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of grantees in grant event</p>
<p><code dir="ltr">OUT</code> parameter: List of grantees in grant event</p>
</td>
<td class="cellalignment1091" headers="r10c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  user_list ora_name_list_t;
  number_of_grantees PLS_INTEGER;
BEGIN
  IF (ora_sysevent = 'GRANT') THEN
    number_of_grantees := 
     <span class="bold">ora_grantee(user_list)</span>;
  END IF;
END;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r11c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_instance_num
</pre></td>
<td class="cellalignment1091" headers="r11c1-t42 r1c2-t42">
<p><code dir="ltr">NUMBER</code>: Instance number</p>
</td>
<td class="cellalignment1091" headers="r11c1-t42 r1c3-t42">
<pre dir="ltr">
IF (<span class="bold">ora_instance_num</span> = 1) THEN
  INSERT INTO event_table VALUES ('1');
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r12c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_is_alter_column (
column_name IN VARCHAR2
)
</pre></td>
<td class="cellalignment1091" headers="r12c1-t42 r1c2-t42">
<p><code dir="ltr">BOOLEAN</code>: <code dir="ltr">TRUE</code> if specified column is altered, <code dir="ltr">FALSE</code> otherwise</p>
</td>
<td class="cellalignment1091" headers="r12c1-t42 r1c3-t42">
<pre dir="ltr">
IF (ora_sysevent = 'ALTER' AND
  ora_dict_obj_type = 'TABLE') THEN 
    alter_column := <span class="bold">ora_is_alter_column('C')</span>;
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r13c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_is_creating_nested_table
</pre></td>
<td class="cellalignment1091" headers="r13c1-t42 r1c2-t42">
<p><code dir="ltr">BOOLEAN</code>: <code dir="ltr">TRUE</code> if current event is creating nested table, <code dir="ltr">FALSE</code> otherwise</p>
</td>
<td class="cellalignment1091" headers="r13c1-t42 r1c3-t42">
<pre dir="ltr">
IF (ora_sysevent = 'CREATE' AND
  ora_dict_obj_type = 'TABLE' AND
  <span class="bold">ora_is_creating_nested_table</span>) THEN
    INSERT INTO event_table
    VALUES ('A nested table is created');
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r14c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_is_drop_column (
column_name IN VARCHAR2
)
</pre></td>
<td class="cellalignment1091" headers="r14c1-t42 r1c2-t42">
<p><code dir="ltr">BOOLEAN</code>: <code dir="ltr">TRUE</code> if specified column is dropped, <code dir="ltr">FALSE</code> otherwise</p>
</td>
<td class="cellalignment1091" headers="r14c1-t42 r1c3-t42">
<pre dir="ltr">
IF (ora_sysevent = 'ALTER' AND
  ora_dict_obj_type = 'TABLE') THEN
    drop_column := <span class="bold">ora_is_drop_column('C')</span>;
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r15c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_is_servererror (
error_number IN VARCHAR2
)
</pre></td>
<td class="cellalignment1091" headers="r15c1-t42 r1c2-t42">
<p><code dir="ltr">BOOLEAN</code>: <code dir="ltr">TRUE</code> if given error is on error stack, <code dir="ltr">FALSE</code> otherwise</p>
</td>
<td class="cellalignment1091" headers="r15c1-t42 r1c3-t42">
<pre dir="ltr">
IF <span class="bold">ora_is_servererror(error_number)</span> THEN
  INSERT INTO event_table
  VALUES ('Server error!!');
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r16c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_login_user
</pre></td>
<td class="cellalignment1091" headers="r16c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2(30)</code>: Login user name</p>
</td>
<td class="cellalignment1091" headers="r16c1-t42 r1c3-t42">
<pre dir="ltr">
SELECT <span class="bold">ora_login_user</span> FROM DUAL;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r17c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_partition_pos
</pre></td>
<td class="cellalignment1091" headers="r17c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: In <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger for <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code>, position in SQL text where you can insert <code dir="ltr">PARTITION</code> clause</p>
</td>
<td class="cellalignment1091" headers="r17c1-t42 r1c3-t42">
<pre dir="ltr">
-- Retrieve ora_sql_txt into  sql_text variable
v_n := <span class="bold">ora_partition_pos</span>;
v_new_stmt := SUBSTR(sql_text,1,v_n - 1)
              || ' ' || my_partition_clause
              || ' ' || SUBSTR(sql_text, v_n));
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r18c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_privilege_list (
privilege_list OUT ora_name_list_t
)
</pre></td>
<td class="cellalignment1091" headers="r18c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of privileges in grant or revoke event</p>
<p><code dir="ltr">OUT</code> parameter: List of privileges granted or revoked in event</p>
</td>
<td class="cellalignment1091" headers="r18c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  privilege_list ora_name_list_t;
  number_of_privileges PLS_INTEGER;
BEGIN
  IF (ora_sysevent = 'GRANT' OR
      ora_sysevent = 'REVOKE') THEN
    number_of_privileges :=
      <span class="bold">ora_privilege_list(privilege_list)</span>;
  END IF;
END;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r19c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_revokee (
user_list OUT ora_name_list_t
)
</pre></td>
<td class="cellalignment1091" headers="r19c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of revokees in revoke event</p>
<p><code dir="ltr">OUT</code> parameter: List of revokees in event</p>
</td>
<td class="cellalignment1091" headers="r19c1-t42 r1c3-t42">
<pre dir="ltr">
DECLARE
  user_list ora_name_list_t;
  number_of_users PLS_INTEGER;
BEGIN
  IF (ora_sysevent = 'REVOKE') THEN
    number_of_users := <span class="bold">ora_revokee(user_list)</span>;
  END IF;
END;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r20c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_server_error (
position IN PLS_INTEGER
)
</pre></td>
<td class="cellalignment1091" headers="r20c1-t42 r1c2-t42">
<p><code dir="ltr">NUMBER</code>: Error code at given position on error stack<a id="CIHHCBGJ" href="#CIHHCBGJ" onclick='footdisplay(1,"Position 1 is the top of the stack.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
</td>
<td class="cellalignment1091" headers="r20c1-t42 r1c3-t42">
<pre dir="ltr">
INSERT INTO event_table
VALUES ('top stack error ' || 
        <span class="bold">ora_server_error(1)</span>);
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r21c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_server_error_depth
</pre></td>
<td class="cellalignment1091" headers="r21c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of error messages on error stack</p>
</td>
<td class="cellalignment1091" headers="r21c1-t42 r1c3-t42">
<pre dir="ltr">
n := <span class="bold">ora_server_error_depth</span>;
-- Use n with functions such as ora_server_error
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r22c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_server_error_msg (
position IN PLS_INTEGER
)
</pre></td>
<td class="cellalignment1091" headers="r22c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2</code>: Error message at given position on error stack<a id="sthref833" href="#sthref833" onclick='footdisplay(1,"Position 1 is the top of the stack.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
<td class="cellalignment1091" headers="r22c1-t42 r1c3-t42">
<pre dir="ltr">
INSERT INTO event_table
VALUES ('top stack error message' ||
        <span class="bold">ora_server_error_msg(1)</span>);
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r23c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_server_error_num_params (
position IN PLS_INTEGER
)
</pre></td>
<td class="cellalignment1091" headers="r23c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of strings substituted into error message (using format like <code dir="ltr">%s</code>) at given position on error stack<a id="sthref834" href="#sthref834" onclick='footdisplay(1,"Position 1 is the top of the stack.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
<td class="cellalignment1091" headers="r23c1-t42 r1c3-t42">
<pre dir="ltr">
n := <span class="bold">ora_server_error_num_params(1)</span>;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r24c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_server_error_param (
position IN PLS_INTEGER,
param IN PLS_INTEGER
)
</pre></td>
<td class="cellalignment1091" headers="r24c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2</code>: Matching substitution value (<code dir="ltr">%s</code>, <code dir="ltr">%d</code>, and so on) in error message at given position and parameter number<a id="sthref835" href="#sthref835" onclick='footdisplay(1,"Position 1 is the top of the stack.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></p>
</td>
<td class="cellalignment1091" headers="r24c1-t42 r1c3-t42">
<pre dir="ltr">
-- Second %s in "Expected %s, found %s":
param := <span class="bold">ora_server_error_param(1,2)</span>;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r25c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_sql_txt (
sql_text OUT ora_name_list_t
)
</pre></td>
<td class="cellalignment1091" headers="r25c1-t42 r1c2-t42">
<p><code dir="ltr">PLS_INTEGER</code>: Number of elements in PL/SQL table</p>
<p><code dir="ltr">OUT</code> parameter: SQL text of triggering statement (broken into multiple collection elements if statement is long)</p>
</td>
<td class="cellalignment1091" headers="r25c1-t42 r1c3-t42">
<pre dir="ltr">
CREATE TABLE event_table (col VARCHAR2(2030));

DECLARE
  sql_text ora_name_list_t;
  n PLS_INTEGER;
  v_stmt VARCHAR2(2000);
BEGIN
  n := <span class="bold">ora_sql_txt(sql_text)</span>;

  FOR i IN 1..n LOOP
    <span class="bold">v_stmt := v_stmt || sql_text(i);</span>
  END LOOP;

  INSERT INTO event_table VALUES ('text of
    triggering statement: ' || <span class="bold">v_stmt</span>);
END;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r26c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_sysevent
</pre></td>
<td class="cellalignment1091" headers="r26c1-t42 r1c2-t42">
<p><code dir="ltr">VARCHAR2(20)</code>: Name of triggering event, as given in syntax</p>
</td>
<td class="cellalignment1091" headers="r26c1-t42 r1c3-t42">
<pre dir="ltr">
INSERT INTO event_table
VALUES (<span class="bold">ora_sysevent</span>);
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r27c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_with_grant_option
</pre></td>
<td class="cellalignment1091" headers="r27c1-t42 r1c2-t42">
<p><code dir="ltr">BOOLEAN</code>: <code dir="ltr">TRUE</code> if privileges are granted with <code dir="ltr">GRANT</code> option, <code dir="ltr">FALSE</code> otherwise</p>
</td>
<td class="cellalignment1091" headers="r27c1-t42 r1c3-t42">
<pre dir="ltr">
IF (ora_sysevent = 'GRANT' AND
  <span class="bold">ora_with_grant_option</span> = TRUE) THEN
    INSERT INTO event_table 
    VALUES ('with grant option');
END IF;
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r28c1-t42" headers="r1c1-t42">
<pre dir="ltr">
ora_space_error_info (
error_number OUT NUMBER,
error_type OUT VARCHAR2,
object_owner OUT VARCHAR2,
table_space_name OUT VARCHAR2,
object_name OUT VARCHAR2,
sub_object_name OUT VARCHAR2
)
</pre></td>
<td class="cellalignment1091" headers="r28c1-t42 r1c2-t42">
<p><code dir="ltr">BOOLEAN</code>: <code dir="ltr">TRUE</code> if error is related to out-of-space condition, <code dir="ltr">FALSE</code> otherwise</p>
<p><code dir="ltr">OUT</code> parameters: Information about object that caused error</p>
</td>
<td class="cellalignment1091" headers="r28c1-t42 r1c3-t42">
<pre dir="ltr">
IF (<span class="bold">ora_space_error_info (</span>
     <span class="bold">eno,typ,owner,ts,obj,subobj) = TRUE)</span> THEN
  DBMS_OUTPUT.PUT_LINE('The object '|| <span class="bold">obj</span>
     || ' owned by ' || <span class="bold">owner</span> ||
     ' has run out of space.');
END IF;
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>Position 1 is the top of the stack.</p>
</div>
<!-- class="sect2" -->
<a id="g1722284"></a>
<div id="LNPLS20141" class="sect2">
<h3 class="sect2">Event Attribute Functions for Database Event Triggers</h3>
<p><a href="#CHDHFBBG">Table 9-5</a> summarizes the database event triggers that can invoke event attribute functions. For more information about the triggering events in <a href="#CHDHFBBG">Table 9-5</a>, see <a href="create_trigger.htm#CIHFAEJC">"<span class="italic">database_event</span>"</a>.</p>
<div id="LNPLS796" class="tblformalwidemax">
<p class="titleintable"><a id="sthref836"></a><a id="CHDHFBBG"></a>Table 9-5 Database Event Triggers</p>
<table class="cellalignment1089" title="Database Event Triggers" summary="This table summarizes system manager events." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t43">Triggering Event</th>
<th class="cellalignment1090" id="r1c2-t43">When Trigger Fires</th>
<th class="cellalignment1090" id="r1c3-t43">WHEN Conditions</th>
<th class="cellalignment1090" id="r1c4-t43">Restrictions</th>
<th class="cellalignment1090" id="r1c5-t43">Transaction</th>
<th class="cellalignment1090" id="r1c6-t43">Attribute Functions</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t43" headers="r1c1-t43">
<pre dir="ltr">
AFTER STARTUP
</pre></td>
<td class="cellalignment1091" headers="r2c1-t43 r1c2-t43">
<p>When database is opened.</p>
</td>
<td class="cellalignment1091" headers="r2c1-t43 r1c3-t43">
<p>None allowed</p>
</td>
<td class="cellalignment1091" headers="r2c1-t43 r1c4-t43">
<p>Trigger cannot do database operations.</p>
</td>
<td class="cellalignment1091" headers="r2c1-t43 r1c5-t43">
<p>Starts a separate transaction and commits it after firing the triggers.</p>
</td>
<td class="cellalignment1091" headers="r2c1-t43 r1c6-t43">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t43" headers="r1c1-t43">
<pre dir="ltr">
BEFORE SHUTDOWN
</pre></td>
<td class="cellalignment1091" headers="r3c1-t43 r1c2-t43">
<p>Just before server starts shutdown of an instance.</p>
<p>This lets the cartridge shutdown completely. For abnormal instance shutdown, this trigger might not fire.</p>
</td>
<td class="cellalignment1091" headers="r3c1-t43 r1c3-t43">
<p>None allowed</p>
</td>
<td class="cellalignment1091" headers="r3c1-t43 r1c4-t43">
<p>Trigger cannot do database operations.</p>
</td>
<td class="cellalignment1091" headers="r3c1-t43 r1c5-t43">
<p>Starts separate transaction and commits it after firing triggers.</p>
</td>
<td class="cellalignment1091" headers="r3c1-t43 r1c6-t43">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t43" headers="r1c1-t43">
<pre dir="ltr">
AFTER DB_ROLE_CHANGE
</pre></td>
<td class="cellalignment1091" headers="r4c1-t43 r1c2-t43">
<p>When database is opened for first time after role change.</p>
</td>
<td class="cellalignment1091" headers="r4c1-t43 r1c3-t43">
<p>None allowed</p>
</td>
<td class="cellalignment1091" headers="r4c1-t43 r1c4-t43">
<p>None</p>
</td>
<td class="cellalignment1091" headers="r4c1-t43 r1c5-t43">
<p>Starts separate transaction and commits it after firing triggers.</p>
</td>
<td class="cellalignment1091" headers="r4c1-t43 r1c6-t43">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t43" headers="r1c1-t43">
<pre dir="ltr">
AFTER SERVERERROR
</pre></td>
<td class="cellalignment1091" headers="r5c1-t43 r1c2-t43">
<p>With condition, whenever specified error occurs. Without condition, whenever any error occurs.</p>
<p>Trigger does not fire for errors listed in <a href="create_trigger.htm#CIHFAEJC">"<span class="italic">database_event</span>"</a>.</p>
</td>
<td class="cellalignment1091" headers="r5c1-t43 r1c3-t43">
<p><code dir="ltr">ERRNO</code> = <code dir="ltr">eno</code></p>
</td>
<td class="cellalignment1091" headers="r5c1-t43 r1c4-t43">
<p>Depends on error.</p>
</td>
<td class="cellalignment1091" headers="r5c1-t43 r1c5-t43">
<p>Starts separate transaction and commits it after firing triggers.</p>
</td>
<td class="cellalignment1091" headers="r5c1-t43 r1c6-t43">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_server_error
ora_is_servererror
ora_space_error_info
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" --></div>
<!-- class="sect2" -->
<a id="g1722272"></a>
<div id="LNPLS797" class="sect2">
<h3 class="sect2">Event Attribute Functions for Client Event Triggers</h3>
<p><a href="#CHDGIJDB">Table 9-6</a> summarizes the client event triggers that can invoke event attribute functions. For more information about the triggering events in <a href="#CHDGIJDB">Table 9-6</a>, see <a href="create_trigger.htm#CIHGCJHC">"<span class="italic">ddl_event</span>"</a> and <a href="create_trigger.htm#CIHFAEJC">"<span class="italic">database_event</span>"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a client event trigger becomes the target of a DDL operation (such as <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr">TRIGGER</code>), then it cannot fire later during the same transaction.</div>
<div id="LNPLS798" class="tblformalwidemax">
<p class="titleintable"><a id="sthref837"></a><a id="CHDGIJDB"></a>Table 9-6 Client Event Triggers</p>
<table class="cellalignment1089" title="Client Event Triggers " summary="This table summarizes client events." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t45">Triggering Event</th>
<th class="cellalignment1090" id="r1c2-t45">When Trigger Fires</th>
<th class="cellalignment1090" id="r1c3-t45">WHEN Conditions</th>
<th class="cellalignment1090" id="r1c4-t45">Restrictions</th>
<th class="cellalignment1090" id="r1c5-t45">Transaction</th>
<th class="cellalignment1090" id="r1c6-t45">Attribute Functions</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE ALTER

AFTER ALTER
</pre></td>
<td class="cellalignment1091" headers="r2c1-t45 r1c2-t45">
<p>When catalog object is altered</p>
</td>
<td class="cellalignment1091" headers="r2c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r2c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r2c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r2c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent 
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_type 
ora_dict_obj_name
ora_dict_obj_owner
ora_des_encrypted_password
 (for ALTER USER events)
ora_is_alter_column
 (for ALTER TABLE events)
ora_is_drop_column
 (for ALTER TABLE events)
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE DROP

AFTER DROP
</pre></td>
<td class="cellalignment1091" headers="r3c1-t45 r1c2-t45">
<p>When catalog object is dropped</p>
</td>
<td class="cellalignment1091" headers="r3c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r3c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r3c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r3c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_type
ora_dict_obj_name
ora_dict_obj_owner
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE ANALYZE

AFTER ANALYZE
</pre></td>
<td class="cellalignment1091" headers="r4c1-t45 r1c2-t45">
<p>When <code dir="ltr">ANALYZE</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r4c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r4c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r4c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r4c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r5c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE ASSOCIATE STATISTICS

AFTER ASSOCIATE STATISTICS
</pre></td>
<td class="cellalignment1091" headers="r5c1-t45 r1c2-t45">
<p>When <code dir="ltr">ASSOCIATE</code> <code dir="ltr">STATISTICS</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r5c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r5c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r5c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r5c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
ora_dict_obj_name_list
ora_dict_obj_owner_list
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r6c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE AUDIT

AFTER AUDIT

BEFORE NOAUDIT

AFTER NOAUDIT
</pre></td>
<td class="cellalignment1091" headers="r6c1-t45 r1c2-t45">
<p>When <code dir="ltr">AUDIT</code> or <code dir="ltr">NOAUDIT</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r6c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r6c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r6c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r6c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r7c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE COMMENT

AFTER COMMENT
</pre></td>
<td class="cellalignment1091" headers="r7c1-t45 r1c2-t45">
<p>When object is commented</p>
</td>
<td class="cellalignment1091" headers="r7c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r7c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r7c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r7c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r8c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE CREATE

AFTER CREATE
</pre></td>
<td class="cellalignment1091" headers="r8c1-t45 r1c2-t45">
<p>When catalog object is created</p>
</td>
<td class="cellalignment1091" headers="r8c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r8c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r8c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r8c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent 
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_type 
ora_dict_obj_name
ora_dict_obj_owner
ora_is_creating_nested_table
 (for CREATE TABLE events)
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r9c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE DDL

AFTER DDL
</pre></td>
<td class="cellalignment1091" headers="r9c1-t45 r1c2-t45">
<p>When most SQL DDL statements are issued. Not fired for <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code>, <code dir="ltr">CREATE</code> <code dir="ltr">CONTROLFILE</code>, <code dir="ltr">CREATE</code> <code dir="ltr">DATABASE</code>, and DDL issued through the PL/SQL subprogram interface, such as creating an advanced queue.</p>
</td>
<td class="cellalignment1091" headers="r9c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r9c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r9c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r9c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r10c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE DISASSOCIATE STATISTICS

AFTER DISASSOCIATE STATISTICS
</pre></td>
<td class="cellalignment1091" headers="r10c1-t45 r1c2-t45">
<p>When <code dir="ltr">DISASSOCIATE</code> <code dir="ltr">STATISTICS</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r10c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r10c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r10c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r10c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
ora_dict_obj_name_list
ora_dict_obj_owner_list
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r11c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE GRANT

AFTER GRANT
</pre></td>
<td class="cellalignment1091" headers="r11c1-t45 r1c2-t45">
<p>When <code dir="ltr">GRANT</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r11c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r11c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r11c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r11c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
ora_grantee
ora_with_grant_option
ora_privilege_list
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r12c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE LOGOFF
</pre></td>
<td class="cellalignment1091" headers="r12c1-t45 r1c2-t45">
<p>At start of user logoff</p>
</td>
<td class="cellalignment1091" headers="r12c1-t45 r1c3-t45">
<p>Simple conditions on <code dir="ltr">UID</code> and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r12c1-t45 r1c4-t45">
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r12c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r12c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r13c1-t45" headers="r1c1-t45">
<pre dir="ltr">
AFTER LOGON
</pre></td>
<td class="cellalignment1091" headers="r13c1-t45 r1c2-t45">
<p>After successful user logon</p>
</td>
<td class="cellalignment1091" headers="r13c1-t45 r1c3-t45">
<p>Simple conditions on <code dir="ltr">UID</code> and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r13c1-t45 r1c4-t45">
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r13c1-t45 r1c5-t45">
<p>Starts separate transaction and commits it after firing triggers.</p>
</td>
<td class="cellalignment1091" headers="r13c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_client_ip_address
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r14c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE RENAME

AFTER RENAME
</pre></td>
<td class="cellalignment1091" headers="r14c1-t45 r1c2-t45">
<p>When <code dir="ltr">RENAME</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r14c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r14c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r14c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r14c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_owner
ora_dict_obj_type
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r15c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE REVOKE

AFTER REVOKE
</pre></td>
<td class="cellalignment1091" headers="r15c1-t45 r1c2-t45">
<p>When <code dir="ltr">REVOKE</code> statement is issued</p>
</td>
<td class="cellalignment1091" headers="r15c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r15c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r15c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r15c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
ora_revokee
ora_privilege_list
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r16c1-t45" headers="r1c1-t45">
<pre dir="ltr">
AFTER SUSPEND
</pre></td>
<td class="cellalignment1091" headers="r16c1-t45 r1c2-t45">
<p>After SQL statement is suspended because of out-of-space condition.</p>
<p>(Trigger must correct condition so statement can be resumed.)</p>
</td>
<td class="cellalignment1091" headers="r16c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r16c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r16c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r16c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_server_error
ora_is_servererror
ora_space_error_info
</pre></td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r17c1-t45" headers="r1c1-t45">
<pre dir="ltr">
BEFORE TRUNCATE

AFTER TRUNCATE
</pre></td>
<td class="cellalignment1091" headers="r17c1-t45 r1c2-t45">
<p>When object is truncated</p>
</td>
<td class="cellalignment1091" headers="r17c1-t45 r1c3-t45">
<p>Simple conditions on type and name of object, <code dir="ltr">UID</code>, and <code dir="ltr">USER</code></p>
</td>
<td class="cellalignment1091" headers="r17c1-t45 r1c4-t45">
<p>Trigger cannot do DDL operations on object that caused event to be generated.</p>
<p>DDL on other objects is limited to compiling an object, creating a trigger, and creating, altering, and dropping a table.</p>
</td>
<td class="cellalignment1091" headers="r17c1-t45 r1c5-t45">
<p>Fires triggers in current transaction.</p>
</td>
<td class="cellalignment1091" headers="r17c1-t45 r1c6-t45">
<pre dir="ltr">
ora_sysevent
ora_login_user
ora_instance_num
ora_database_name
ora_dict_obj_name
ora_dict_obj_type
ora_dict_obj_owner
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007097"></a>
<div id="LNPLS2012" class="sect1">
<h2 class="sect1">Views for Information About Triggers</h2>
<p>The <code dir="ltr">*_TRIGGERS</code> static data dictionary views reveal information about triggers. For information about these views, see <a class="olink REFRN20293" href="../../server.112/e40402/statviews_2121.htm#REFRN20293"><span class="italic">Oracle Database Reference</span></a>.</p>
<p><a href="#BCFHCBGE">Example 9-28</a> creates a trigger and queries the static data dictionary view <code dir="ltr">USER_TRIGGERS</code> twice&mdash;first to show its type, triggering event, and the name of the table on which it is created, and then to show its body.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The query results in <a href="#BCFHCBGE">Example 9-28</a> were formatted by these SQL*Plus commands :
<pre dir="ltr">
COLUMN Trigger_type FORMAT A15
COLUMN Triggering_event FORMAT A16
COLUMN Table_name FORMAT A11
COLUMN Trigger_body FORMAT A50
SET LONG 9999
</pre></div>
<div id="LNPLS733" class="example">
<p class="titleinexample"><a id="BCFHCBGE"></a>Example 9-28 Viewing Information About Triggers</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Emp_count
  AFTER DELETE ON employees
DECLARE
  n  INTEGER;
BEGIN
  SELECT COUNT(*) INTO n FROM employees;
  DBMS_OUTPUT.PUT_LINE('There are now ' || n || ' employees.');
END;
/

COLUMN Trigger_type FORMAT A15
COLUMN Triggering_event FORMAT A16
COLUMN Table_name FORMAT A11
COLUMN Trigger_body FORMAT A50
</pre>
<p>Query:</p>
<pre dir="ltr">
<span class="bold">SELECT Trigger_type, Triggering_event, Table_name</span>
<span class="bold">FROM USER_TRIGGERS</span>
<span class="bold">WHERE Trigger_name = 'EMP_COUNT';</span>
</pre>
<p>Result:</p>
<pre dir="ltr">
TRIGGER_TYPE    TRIGGERING_EVENT TABLE_NAME
--------------- ---------------- -----------
AFTER STATEMENT DELETE           EMPLOYEES
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT Trigger_body
FROM <span class="bold">USER_TRIGGERS</span>
WHERE Trigger_name = 'EMP_COUNT';
</pre>
<p>Result:</p>
<pre dir="ltr">
TRIGGER_BODY
--------------------------------------------------
DECLARE
  n  INTEGER;
BEGIN
  SELECT COUNT(*) INTO n FROM employees;
  DBMS_OUTPUT.PUT_LINE('There are now ' || n || '
employees.');
END;
 
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="subprograms.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="packages.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
