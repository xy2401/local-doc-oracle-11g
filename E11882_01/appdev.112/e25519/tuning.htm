<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>PL/SQL Optimization and Tuning</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-05T11:52:58Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Language Reference" />
<meta name="dcterms.identifier" content="E25519-13" />
<meta name="dcterms.isVersionOf" content="LNPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="errors.htm" title="Previous" type="text/html" />
<link rel="Next" href="langelems.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25519.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/99</span> <!-- End Header -->
<div id="LNPLS012" class="chapter"><a id="CHDJJAGH"></a>
<h1 class="chapter"><span class="secnum">12</span> PL/SQL Optimization and Tuning</h1>
<p>This chapter explains how the PL/SQL compiler optimizes your code and how to write efficient PL/SQL code and <a id="sthref949"></a>improve existing PL/SQL code.</p>
<p class="subhead2"><a id="LNPLS806"></a>Topics</p>
<ul>
<li>
<p><a href="#i53930">PL/SQL Optimizer</a></p>
</li>
<li>
<p><a href="#BCGCIFGH">Candidates for Tuning</a></p>
</li>
<li>
<p><a href="#BABFCJJG">Minimizing CPU Overhead</a></p>
</li>
<li>
<p><a href="#BABFHGHI">Bulk SQL and Bulk Binding</a></p>
</li>
<li>
<p><a href="#i52932">Chaining Pipelined Table Functions for Multiple Transformations</a></p>
</li>
<li>
<p><a href="#BABCFCJC">Updating Large Tables in Parallel</a></p>
</li>
<li>
<p><a href="#g3143398">Collecting Data About User-Defined Identifiers</a></p>
</li>
<li>
<p><a href="#i48283">Profiling and Tracing PL/SQL Programs</a></p>
</li>
<li>
<p><a href="#i48528">Compiling PL/SQL Units for Native Execution</a></p>
</li>
</ul>
<a id="i53930"></a>
<div id="LNPLS01201" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">PL/SQL Optimizer</h2>
<p><a id="sthref950"></a><a id="sthref951"></a>Prior to Oracle Database 10<span class="italic">g</span>, the PL/SQL compiler translated your source text to system code without applying many changes to improve performance. Now, PL/SQL uses an optimizer that can rearrange code for better performance.</p>
<p>The optimizer is enabled by default. In rare cases, if the overhead of the optimizer makes compilation of very large applications too slow, you can lower the optimization by setting the compilation parameter <a id="sthref952"></a><code dir="ltr">PLSQL_OPTIMIZE_LEVEL=1</code> instead of its default value 2. In even rarer cases, PL/SQL might raise an exception earlier than expected or not at all. Setting <code dir="ltr">PLSQL_OPTIMIZE_LEVEL=1</code> prevents the code from being rearranged.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN10255" href="../../server.112/e40402/initparams198.htm#REFRN10255"><span class="italic">Oracle Database Reference</span></a> for information about the <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter</p>
</li>
<li>
<p><a class="olink REFRN20385" href="../../server.112/e40402/statviews_2009.htm#REFRN20385"><span class="italic">Oracle Database Reference</span></a> for information about the static dictionary view <code dir="ltr">ALL_PLSQL_OBJECT_SETTINGS</code></p>
</li>
</ul>
</div>
<a id="BABBHCEI"></a>
<div id="LNPLS99951" class="sect2">
<h3 class="sect2">Subprogram Inlining</h3>
<p>One optimization that the compiler can perform is <a id="sthref953"></a><span class="bold">subprogram inlining</span>. Subprogram inlining replaces a <a id="sthref954"></a>subprogram invocation with a copy of the invoked subprogram (if the invoked and invoking subprograms are in the same program unit). To allow subprogram inlining, either accept the default value of the <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter (which is 2) or set it to 3.</p>
<p>With <code dir="ltr">PLSQL_OPTIMIZE_LEVEL=2</code>, you must specify each subprogram to be inlined with the <a id="sthref955"></a><a id="sthref956"></a><code dir="ltr">INLINE</code> pragma:</p>
<pre dir="ltr">
PRAGMA INLINE (<span class="italic">subprogram</span>, 'YES')
</pre>
<p>If <code dir="ltr"><span class="codeinlineitalic">subprogram</span></code> is <a id="sthref957"></a>overloaded, then the preceding pragma applies to every subprogram with that name.</p>
<p>With <code dir="ltr">PLSQL_OPTIMIZE_LEVEL=3</code>, the PL/SQL compiler seeks opportunities to inline subprograms. You need not specify subprograms to be inlined. However, you can use the <code dir="ltr">INLINE</code> pragma (with the preceding syntax) to give a subprogram a high priority for inlining, and then the compiler inlines it unless other considerations or limits make the inlining undesirable.</p>
<p>If a particular subprogram is inlined, performance almost always improves. However, because the compiler inlines subprograms early in the optimization process, it is possible for subprogram inlining to preclude later, more powerful optimizations.</p>
<p>If subprogram inlining slows the performance of a particular PL/SQL program, then use the PL/SQL hierarchical profiler (explained in <a class="olink ADFNS023" href="../../appdev.112/e41502/adfns_profiler.htm#ADFNS023"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>) to identify subprograms for which you want to turn off inlining. To turn off inlining for a subprogram, use the <code dir="ltr">INLINE</code> pragma:</p>
<pre dir="ltr">
PRAGMA INLINE (<span class="italic">subprogram</span>, 'NO')
</pre>
<p>The <code dir="ltr">INLINE</code> pragma affects only the immediately following declaration or statement, and only some kinds of statements.</p>
<p>When the <code dir="ltr">INLINE</code> pragma immediately precedes a declaration, it affects:</p>
<ul>
<li>
<p>Every invocation of the specified subprogram in that declaration</p>
</li>
<li>
<p>Every initialization value in that declaration except the default initialization values of records</p>
</li>
</ul>
<p>When the <code dir="ltr">INLINE</code> pragma immediately precedes one of these statements, the pragma affects every invocation of the specified subprogram in that statement:</p>
<ul>
<li>
<p>Assignment</p>
</li>
<li>
<p><code dir="ltr">CALL</code></p>
</li>
<li>
<p>Conditional</p>
</li>
<li>
<p><code dir="ltr">CASE</code></p>
</li>
<li>
<p><code dir="ltr">CONTINUE</code> <code dir="ltr">WHEN</code></p>
</li>
<li>
<p><code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code></p>
</li>
<li>
<p><code dir="ltr">EXIT</code> <code dir="ltr">WHEN</code></p>
</li>
<li>
<p><code dir="ltr">LOOP</code></p>
</li>
<li>
<p><code dir="ltr">RETURN</code></p>
</li>
</ul>
<p>The <code dir="ltr">INLINE</code> pragma does not affect statements that are not in the preceding list.</p>
<p>In <a href="#CHDBGJDJ">Example 12-1</a>, if <code dir="ltr">PLSQL_OPTIMIZE_LEVEL=2</code>, the <code dir="ltr">INLINE</code> pragma affects the procedure invocations <code dir="ltr">p1(1)</code> and <code dir="ltr">p1(2)</code>, but not the procedure invocations <code dir="ltr">p1(3)</code> and <code dir="ltr">p1(4)</code>.</p>
<div id="LNPLS1219" class="example">
<p class="titleinexample"><a id="CHDBGJDJ"></a>Example 12-1 Specifying that Subprogram Is To Be Inlined</p>
<pre dir="ltr">
PROCEDURE p1 (x PLS_INTEGER) IS ...
...
<span class="bold">PRAGMA INLINE (p1, 'YES');</span>
x:= p1(1) + p1(2) + 17;    -- These 2 invocations to p1 are inlined
...
x:= p1(3) + p1(4) + 17;    -- These 2 invocations to p1 are not inlined
...
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDIJCGI">Example 12-2</a>, if <code dir="ltr">PLSQL_OPTIMIZE_LEVEL=2</code>, the <code dir="ltr">INLINE</code> pragma affects both functions named <code dir="ltr">p2</code>.</p>
<div id="LNPLS1220" class="example">
<p class="titleinexample"><a id="CHDIJCGI"></a>Example 12-2 Specifying that Overloaded Subprogram Is To Be Inlined</p>
<pre dir="ltr">
FUNCTION p2 (p boolean) return PLS_INTEGER IS ...
FUNCTION p2 (x PLS_INTEGER) return PLS_INTEGER IS ...
...
<span class="bold">PRAGMA INLINE(p2, 'YES');</span>
x := p2(true) + p2(3);
...
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDGAGBH">Example 12-3</a>, the <code dir="ltr">INLINE</code> pragma affects the procedure invocations <code dir="ltr">p1(1)</code> and <code dir="ltr">p1(2)</code>, but not the procedure invocations <code dir="ltr">p1(3)</code> and <code dir="ltr">p1(4)</code>.</p>
<div id="LNPLS1221" class="example">
<p class="titleinexample"><a id="CHDGAGBH"></a>Example 12-3 Specifying that Subprogram Is Not To Be Inlined</p>
<pre dir="ltr">
PROCEDURE p1 (x PLS_INTEGER) IS ...
...
<span class="bold">PRAGMA INLINE (p1, 'NO');</span>
x:= p1(1) + p1(2) + 17;    -- These 2 invocations to p1 are not inlined
...
x:= p1(3) + p1(4) + 17;    -- These 2 invocations to p1 might be inlined
...
</pre></div>
<!-- class="example" -->
<p>Multiple pragmas can affect the same declaration or statement. Each pragma applies its own effect to the statement. If <code dir="ltr">PRAGMA</code> <code dir="ltr">INLINE(</code><code dir="ltr"><span class="codeinlineitalic">subprogram,</span></code><code dir="ltr">'YES')</code> and <code dir="ltr">PRAGMA</code> <code dir="ltr">INLINE(</code><code dir="ltr"><span class="codeinlineitalic">identifier,</span></code><code dir="ltr">'NO')</code> have the same <code dir="ltr"><span class="codeinlineitalic">subprogram</span></code>, then <code dir="ltr">'NO'</code> overrides <code dir="ltr">'YES'</code>. One <code dir="ltr">PRAGMA</code> <code dir="ltr">INLINE(</code><code dir="ltr"><span class="codeinlineitalic">subprogram,</span></code><code dir="ltr">'NO')</code> overrides any number of occurrences of <code dir="ltr">PRAGMA</code> <code dir="ltr">INLINE(</code><code dir="ltr"><span class="codeinlineitalic">subprogram,</span></code><code dir="ltr">'YES')</code>, and the order of these pragmas is not important.</p>
<p>In <a href="#CHDJCIEJ">Example 12-4</a>, the second <code dir="ltr">INLINE</code> pragma overrides both the first and third <code dir="ltr">INLINE</code> pragmas.</p>
<div id="LNPLS1222" class="example">
<p class="titleinexample"><a id="CHDJCIEJ"></a>Example 12-4 PRAGMA INLINE ... 'NO' Overrides PRAGMA INLINE ... 'YES'</p>
<pre dir="ltr">
PROCEDURE p1 (x PLS_INTEGER) IS ...
...
<span class="bold">PRAGMA INLINE (p1, 'YES');</span>
<span class="bold">PRAGMA INLINE (p1, 'NO');</span>
<span class="bold">PRAGMA INLINE (p1, 'YES');</span>
x:= p1(1) + p1(2) + 17;    -- These 2 invocations to p1 are not inlined
...
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN10255" href="../../server.112/e40402/initparams198.htm#REFRN10255"><span class="italic">Oracle Database Reference</span></a> for information about the <code dir="ltr">PLSQL_OPTIMIZE_LEVEL</code> compilation parameter</p>
</li>
<li>
<p><a class="olink REFRN20385" href="../../server.112/e40402/statviews_2009.htm#REFRN20385"><span class="italic">Oracle Database Reference</span></a> for information about the static dictionary view <code dir="ltr">ALL_PLSQL_OBJECT_SETTINGS</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BCGCIFGH"></a>
<div id="LNPLS01212" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Candidates for Tuning</h2>
<p>The following kinds of PL/SQL code are very likely to benefit from tuning:</p>
<ul>
<li>
<p>Older code that does not take advantage of new PL/SQL language features.</p>
<p>For information about new PL/SQL language features, see <a href="whatsnew.htm#CJAEGHHH">"What's New in PL/SQL?"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Before tuning older code, benchmark the current system and profile the older subprograms that your program invokes (see <a href="#i48283">"Profiling and Tracing PL/SQL Programs"</a>). With the many automatic optimizations of the PL/SQL optimizer (described in <a href="#i53930">"PL/SQL Optimizer"</a>), you might see performance improvements before doing any tuning.</div>
</li>
<li>
<p>Older <a id="sthref958"></a>dynamic SQL statements written with the <code dir="ltr">DBMS_SQL</code> package.</p>
<p>If you know at compile time the number and data types of the input and output variables of a dynamic SQL statement, then you can rewrite the statement in native dynamic SQL, which runs noticeably faster than equivalent code that uses the <code dir="ltr">DBMS_SQL</code> package (especially when it can be optimized by the compiler). For more information, see <a href="dynamic.htm#CACDDACH">Chapter 7, "PL/SQL Dynamic SQL."</a></p>
</li>
<li>
<p>Code that spends much time processing SQL statements.</p>
<p>See <a href="#BCGJEGHB">"Tune SQL Statements"</a>.</p>
</li>
<li>
<p>Functions invoked in queries, which might run millions of times.</p>
<p>See <a href="#BCGFFFIF">"Tune Function Invocations in Queries"</a>.</p>
</li>
<li>
<p>Code that spends much time looping through query results.</p>
<p>See <a href="#BCGHBFBH">"Tune Loops"</a>.</p>
</li>
<li>
<p>Code that does many numeric computations.</p>
<p>See <a href="#CACHFCHF">"Tune Computation-Intensive PL/SQL Code"</a>.</p>
</li>
<li>
<p>Code that spends much time processing PL/SQL statements (as opposed to issuing database definition language (DDL) statements that PL/SQL passes directly to SQL).</p>
<p>See <a href="#i48528">"Compiling PL/SQL Units for Native Execution"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BABFCJJG"></a>
<div id="LNPLS863" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Minimizing CPU Overhead</h2>
<p class="subhead2"><a id="LNPLS807"></a>Topics</p>
<ul>
<li>
<p><a href="#BCGJEGHB">Tune SQL Statements</a></p>
</li>
<li>
<p><a href="#BCGFFFIF">Tune Function Invocations in Queries</a></p>
</li>
<li>
<p><a href="#i48500">Tune Subprogram Invocations</a></p>
</li>
<li>
<p><a href="#BCGHBFBH">Tune Loops</a></p>
</li>
<li>
<p><a href="#CACHFCHF">Tune Computation-Intensive PL/SQL Code</a></p>
</li>
<li>
<p><a href="#BABGCFAJ">Use SQL Character Functions</a></p>
</li>
<li>
<p><a href="#BCGIAIHB">Put Least Expensive Conditional Tests First</a></p>
</li>
</ul>
<a id="BCGJEGHB"></a>
<div id="LNPLS864" class="sect2">
<h3 class="sect2">Tune SQL Statements</h3>
<p>The most common cause of slowness in PL/SQL programs is slow SQL statements. To make <a id="sthref959"></a>SQL statements in a PL/SQL program as efficient as possible:</p>
<ul>
<li>
<p>Use appropriate indexes.</p>
<p>For details, see <a class="olink PFGRF004" href="../../server.112/e41573/data_acc.htm#PFGRF004"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</li>
<li>
<p>Use query hints to avoid unnecessary full-table scans.</p>
<p>For details, see <a class="olink PFGRF94943" href="../../server.112/e41573/hintsref.htm#PFGRF94943"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</li>
<li>
<p>Collect current statistics on all tables, using the subprograms in the <code dir="ltr">DBMS_STATS</code> package.</p>
<p>For details, see <a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</li>
<li>
<p>Analyze the execution plans and performance of the SQL statements, using:</p>
<ul>
<li>
<p><code dir="ltr">EXPLAIN</code> <code dir="ltr">PLAN</code> statement</p>
<p>For details, see <a class="olink PFGRF009" href="../../server.112/e41573/ex_plan.htm#PFGRF009"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</li>
<li>
<p>SQL Trace facility with <code dir="ltr">TKPROF</code> utility</p>
<p>For details, see <a class="olink PFGRF01020" href="../../server.112/e41573/sqltrace.htm#PFGRF01020"><span class="italic">Oracle Database Performance Tuning Guide</span></a>.</p>
</li>
</ul>
</li>
<li>
<p>Use bulk SQL, a set of PL/SQL features that minimizes the performance overhead of the communication between PL/SQL and SQL.</p>
<p>For details, see <a href="#BABFHGHI">"Bulk SQL and Bulk Binding"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BCGFFFIF"></a>
<div id="LNPLS865" class="sect2">
<h3 class="sect2">Tune Function Invocations in Queries</h3>
<p>Functions invoked in <a id="sthref960"></a>queries might run millions of times. Do not invoke a function in a query unnecessarily, and make the invocation as efficient as possible.</p>
<p>Create a function-based index on the table in the query. The <code dir="ltr">CREATE</code> <code dir="ltr">INDEX</code> statement (described in <a class="olink SQLRF01209" href="../../server.112/e41084/statements_5012.htm#SQLRF01209"><span class="italic">Oracle Database SQL Language Reference</span></a>) might take a while, but the query can run much faster because the function value for each row is cached.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="subprograms.htm#BABFHACJ">"PL/SQL Function Result Cache"</a> for information about caching the results of PL/SQL functions</div>
<p>If the query passes a column to a function, then the query cannot use user-created indexes on that column, so the query might invoke the function for every row of the table (which might be very large). To minimize the number of function invocations, use a nested query. Have the inner query filter the result set to a small number of rows, and have the outer query invoke the function for only those rows.</p>
<p>In <a href="#BABFCFDB">Example 12-5</a>, the two queries produce the same result set, but the second query is more efficient than the first. (In the example, the times and time difference are very small, because the <code dir="ltr">EMPLOYEES</code> table is very small. For a very large table, they would be significant.)</p>
<div id="LNPLS866" class="example">
<p class="titleinexample"><a id="BABFCFDB"></a>Example 12-5 Nested Query Improves Performance</p>
<pre dir="ltr">
DECLARE
  starting_time  TIMESTAMP WITH TIME ZONE;
  ending_time    TIMESTAMP WITH TIME ZONE;
BEGIN
  <span class="bold">-- Invokes SQRT for every row of employees table:</span>
 
  SELECT SYSTIMESTAMP INTO starting_time FROM DUAL;
 
  FOR item IN (
    SELECT <span class="bold">DISTINCT(SQRT(department_id))</span> col_alias
    FROM employees
    ORDER BY col_alias
  )
  LOOP
    DBMS_OUTPUT.PUT_LINE('Square root of dept. ID = ' || item.col_alias);
  END LOOP;
 
  SELECT SYSTIMESTAMP INTO ending_time FROM DUAL;
 
  DBMS_OUTPUT.PUT_LINE('Time = ' || TO_CHAR(ending_time - starting_time));
 
  <span class="bold">-- Invokes SQRT for every distinct department_id of employees table:</span>
 
  SELECT SYSTIMESTAMP INTO starting_time FROM DUAL;
 
  FOR item IN (
    SELECT <span class="bold">SQRT(department_id)</span> col_alias
    FROM <span class="bold">(SELECT DISTINCT department_id FROM employees)</span>
    ORDER BY col_alias
  )
  LOOP
    IF item.col_alias IS NOT NULL THEN
      DBMS_OUTPUT.PUT_LINE('Square root of dept. ID = ' || item.col_alias);
    END IF;
  END LOOP;
 
  SELECT SYSTIMESTAMP INTO ending_time FROM DUAL;
 
  DBMS_OUTPUT.PUT_LINE('Time = ' || TO_CHAR(ending_time - starting_time));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Square root of dept. ID = 3.16227766016837933199889354443271853372
Square root of dept. ID = 4.47213595499957939281834733746255247088
Square root of dept. ID = 5.47722557505166113456969782800802133953
Square root of dept. ID = 6.32455532033675866399778708886543706744
Square root of dept. ID = 7.07106781186547524400844362104849039285
Square root of dept. ID = 7.74596669241483377035853079956479922167
Square root of dept. ID = 8.36660026534075547978172025785187489393
Square root of dept. ID = 8.94427190999915878563669467492510494176
Square root of dept. ID = 9.48683298050513799599668063329815560116
Square root of dept. ID = 10
Square root of dept. ID = 10.48808848170151546991453513679937598475
<span class="bold">Time = +000000000 00:00:00.046000000</span>
Square root of dept. ID = 3.16227766016837933199889354443271853372
Square root of dept. ID = 4.47213595499957939281834733746255247088
Square root of dept. ID = 5.47722557505166113456969782800802133953
Square root of dept. ID = 6.32455532033675866399778708886543706744
Square root of dept. ID = 7.07106781186547524400844362104849039285
Square root of dept. ID = 7.74596669241483377035853079956479922167
Square root of dept. ID = 8.36660026534075547978172025785187489393
Square root of dept. ID = 8.94427190999915878563669467492510494176
Square root of dept. ID = 9.48683298050513799599668063329815560116
Square root of dept. ID = 10
Square root of dept. ID = 10.48808848170151546991453513679937598475
<span class="bold">Time = +000000000 00:00:00.000000000</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i48500"></a>
<div id="LNPLS01208" class="sect2">
<h3 class="sect2">Tune Subprogram Invocations</h3>
<p><a id="sthref961"></a>If a subprogram has <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameters, you can sometimes decrease its invocation overhead by declaring those parameters with the <a id="sthref962"></a><code dir="ltr">NOCOPY</code> hint (described in <a href="parameter_declaration.htm#CJACJCGJ">"NOCOPY"</a>).</p>
<p>By default, PL/SQL passes <code dir="ltr">OUT</code> and <code dir="ltr">IN</code> <code dir="ltr">OUT</code> subprogram parameters by value. Before running the subprogram, PL/SQL copies each <code dir="ltr">OUT</code> and <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameter to a temporary variable, which holds the value of the parameter during subprogram execution. If the subprogram is exited normally, then PL/SQL copies the value of the temporary variable to the corresponding actual parameter. If the subprogram is exited with an unhandled exception, then PL/SQL does not change the value of the actual parameter.</p>
<p>When <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameters represent large data structures such as collections, records, and instances of ADTs, copying them slows execution and increases memory use&mdash;especially for an instance of an ADT.</p>
<p>For each invocation of an ADT method, PL/SQL copies every attribute of the ADT. If the method is exited normally, then PL/SQL applies any changes that the method made to the attributes. If the method is exited with an unhandled exception, then PL/SQL does not change the attributes.</p>
<p>If your program does not require that an <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameter retain its pre-invocation value if the subprogram ends with an unhandled exception, then include the <code dir="ltr">NOCOPY</code> hint in the parameter declaration. The <code dir="ltr">NOCOPY</code> hint requests (but does not ensure) that the compiler pass the corresponding actual parameter by reference instead of value. For more information about <code dir="ltr">NOCOPY</code>, see <a href="parameter_declaration.htm#CJACJCGJ">"NOCOPY"</a>. For information about using <code dir="ltr">NOCOPY</code> with member methods of ADTs, see <a class="olink ADOBJ00853" href="../../appdev.112/e11822/adobjdes.htm#ADOBJ00853"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Do not rely on <code dir="ltr">NOCOPY</code> (which the compiler might or might not obey for a particular invocation) to ensure that an actual parameter or ADT attribute retains its pre-invocation value if the subprogram is exited with an unhandled exception. Instead, ensure that the subprogram handle all exceptions.</div>
<p>In <a href="#BABDDAFG">Example 12-6</a>, if the compiler obeys the <code dir="ltr">NOCOPY</code> hint for the invocation of <code dir="ltr">do_nothing2</code>, then the invocation of <code dir="ltr">do_nothing2</code> is faster than the invocation of <code dir="ltr">do_nothing1</code>.</p>
<div id="LNPLS908" class="example">
<p class="titleinexample"><a id="BABDDAFG"></a>Example 12-6 NOCOPY Subprogram Parameters</p>
<pre dir="ltr">
DECLARE
  TYPE EmpTabTyp IS TABLE OF employees%ROWTYPE;
  emp_tab EmpTabTyp := EmpTabTyp(NULL);  -- initialize
  t1 NUMBER;
  t2 NUMBER;
  t3 NUMBER;

  PROCEDURE get_time (t OUT NUMBER) IS
  BEGIN
    t := DBMS_UTILITY.get_time;
  END;

  <span class="bold">PROCEDURE do_nothing1 (tab IN OUT EmpTabTyp)</span> IS
  BEGIN
    NULL;
  END;

  <span class="bold">PROCEDURE do_nothing2 (tab IN OUT NOCOPY EmpTabTyp)</span> IS
  BEGIN
    NULL;
  END;

BEGIN
  SELECT * INTO emp_tab(1)
  FROM employees
  WHERE employee_id = 100;

  emp_tab.EXTEND(49999, 1);  -- Copy element 1 into 2..50000
  get_time(t1);
  do_nothing1(emp_tab);  -- Pass IN OUT parameter
  get_time(t2);
  do_nothing2(emp_tab);  -- Pass IN OUT NOCOPY parameter
  get_time(t3);
  DBMS_OUTPUT.PUT_LINE ('Call Duration (secs)');
  DBMS_OUTPUT.PUT_LINE ('--------------------');
  DBMS_OUTPUT.PUT_LINE ('Just IN OUT: ' || TO_CHAR((t2 - t1)/100.0));
  DBMS_OUTPUT.PUT_LINE ('With NOCOPY: ' || TO_CHAR((t3 - t2))/100.0);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BCGHBFBH"></a>
<div id="LNPLS867" class="sect2">
<h3 class="sect2">Tune Loops</h3>
<p><a id="sthref963"></a>Because PL/SQL applications are often built around loops, it is important to optimize both the loops themselves and the code inside them.</p>
<p>If you must loop through a result set more than once, or issue other queries as you loop through a result set, you might be able to change the original query to give you exactly the results you want. Explore the SQL set operators that let you combine multiple queries, described in <a class="olink SQLRF52341" href="../../server.112/e41084/queries004.htm#SQLRF52341"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>You can also use subqueries to do the filtering and sorting in multiple stages&mdash;see <a href="static.htm#i3317">"Query Result Set Processing with Subqueries"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABFHGHI">"Bulk SQL and Bulk Binding"</a></div>
</div>
<!-- class="sect2" -->
<a id="CACHFCHF"></a>
<div id="LNPLS01206" class="sect2">
<h3 class="sect2">Tune Computation-Intensive PL/SQL Code</h3>
<p>These recommendations apply especially (but not only) to <a id="sthref964"></a>computation-intensive PL/SQL code.</p>
<p class="subhead2"><a id="LNPLS808"></a>Topics</p>
<ul>
<li>
<p><a href="#BABEJFDG">Use Data Types that Use Hardware Arithmetic</a></p>
</li>
<li>
<p><a href="#BABFAABE">Avoid Constrained Subtypes in Performance-Critical Code</a></p>
</li>
<li>
<p><a href="#BCGGGIBD">Minimize Implicit Data Type Conversion</a></p>
</li>
</ul>
<a id="BABEJFDG"></a>
<div id="LNPLS99859" class="sect3">
<h4 class="sect3">Use Data Types that Use Hardware Arithmetic</h4>
<p>Avoid using data types in the <a id="sthref965"></a><code dir="ltr">NUMBER</code> data type family (described in <a href="predefined.htm#CDFJEBIF">"NUMBER Data Type Family"</a>). These data types are represented internally in a format designed for portability and arbitrary scale and precision, not for performance. Operations on data of these types use <a id="sthref966"></a>library arithmetic, while operations on data of the types <code dir="ltr">PLS_INTEGER</code>, <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> use <a id="sthref967"></a>hardware arithmetic.</p>
<p>For local integer variables, use <a id="sthref968"></a><code dir="ltr">PLS_INTEGER</code>, described in <a href="datatypes.htm#i10726">"PLS_INTEGER and BINARY_INTEGER Data Types"</a>. For variables that can never have the value <code dir="ltr">NULL</code>, do not need overflow checking, and are not used in performance-critical code, use <a id="sthref969"></a><code dir="ltr">SIMPLE_INTEGER</code>, described in <a href="datatypes.htm#CIHGBFGB">"SIMPLE_INTEGER Subtype of PLS_INTEGER"</a>.</p>
<p>For floating-point variables, use <a id="sthref970"></a><code dir="ltr">BINARY_FLOAT</code> or <a id="sthref971"></a><code dir="ltr">BINARY_DOUBLE</code>, described in <a class="olink SQLRF00209" href="../../server.112/e41084/sql_elements001.htm#SQLRF00209"><span class="italic">Oracle Database SQL Language Reference</span></a>. For variables that can never have the value <code dir="ltr">NULL</code> and are not used in performance-critical code, use <a id="sthref972"></a><code dir="ltr">SIMPLE_FLOAT</code> or <a id="sthref973"></a><code dir="ltr">SIMPLE_DOUBLE</code>, explained in <a href="datatypes.htm#CHDJFIJA">"Additional PL/SQL Subtypes of BINARY_FLOAT and BINARY_DOUBLE"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> and their subtypes are less suitable for financial code where accuracy is critical, because they do not always represent fractional values precisely, and handle rounding differently than the <code dir="ltr">NUMBER</code> types.</div>
<p>Many SQL numeric functions (described in <a class="olink SQLRF20031" href="../../server.112/e41084/functions002.htm#SQLRF20031"><span class="italic">Oracle Database SQL Language Reference</span></a>) are overloaded with versions that accept <code dir="ltr">BINARY_FLOAT</code> and <code dir="ltr">BINARY_DOUBLE</code> parameters. You can speed up computation-intensive code by passing variables of these data types to such functions, and by invoking the conversion functions <code dir="ltr">TO_BINARY_FLOAT</code> (described in <a class="olink SQLRF06310" href="../../server.112/e41084/functions197.htm#SQLRF06310"><span class="italic">Oracle Database SQL Language Reference</span></a>) and <code dir="ltr">TO_BINARY_DOUBLE</code> (described in <a class="olink SQLRF06309" href="../../server.112/e41084/functions196.htm#SQLRF06309"><span class="italic">Oracle Database SQL Language Reference</span></a>) when passing expressions to such functions.</p>
</div>
<!-- class="sect3" -->
<a id="BABFAABE"></a>
<div id="LNPLS99858" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Avoid Constrained Subtypes in Performance-Critical Code</h4>
<p>In performance-critical code, avoid <a id="sthref974"></a>constrained subtypes (described in <a href="datatypes.htm#CHDBBCIE">"Constrained Subtypes"</a>). Each assignment to a variable or parameter of a constrained subtype requires extra checking at run time to ensure that the value to be assigned does not violate the constraint.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="predefined.htm#CJAEFDAD">Appendix E, "PL/SQL Predefined Data Types"</a> includes predefined constrained subtypes</div>
</div>
<!-- class="sect3" -->
<a id="BCGGGIBD"></a>
<div id="LNPLS870" class="sect3">
<h4 class="sect3">Minimize Implicit Data Type Conversion</h4>
<p><a id="sthref975"></a>At run time, PL/SQL converts between different data types implicitly (automatically) if necessary. For example, if you assign a <code dir="ltr">PLS_INTEGER</code> variable to a <code dir="ltr">NUMBER</code> variable, then PL/SQL converts the <code dir="ltr">PLS_INTEGER</code> value to a <code dir="ltr">NUMBER</code> value (because the internal representations of the values differ).</p>
<p>Whenever possible, minimize implicit conversions. For example:</p>
<ul>
<li>
<p>If a variable is to be either inserted into a table column or assigned a value from a table column, then give the variable the same data type as the table column.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Declare the variable with the <code dir="ltr">%TYPE</code> attribute, described in <a href="type_attribute.htm#i36397">"%TYPE Attribute"</a>.</div>
</li>
<li>
<p>Make each literal the same data type as the variable to which it is assigned or the expression in which it appears.</p>
</li>
<li>
<p>Convert values from SQL data types to PL/SQL data types and then use the converted values in expressions.</p>
<p>For example, convert <code dir="ltr">NUMBER</code> values to <code dir="ltr">PLS_INTEGER</code> values and then use the <code dir="ltr">PLS_INTEGER</code> values in expressions. <code dir="ltr">PLS_INTEGER</code> operations use hardware arithmetic, so they are faster than <code dir="ltr">NUMBER</code> operations, which use library arithmetic. For more information about the <code dir="ltr">PLS_INTEGER</code> data type, see <a href="datatypes.htm#i10726">"PLS_INTEGER and BINARY_INTEGER Data Types"</a>.</p>
</li>
<li>
<p>Before assigning a value of one SQL data type to a variable of another SQL data type, explicitly convert the source value to the target data type, using a SQL conversion function (for information about SQL conversion functions, see <a class="olink SQLRF20034" href="../../server.112/e41084/functions002.htm#SQLRF20034"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
</li>
<li>
<p>Overload your subprograms with versions that accept parameters of different data types and optimize each version for its parameter types. For information about overloaded subprograms, see <a href="subprograms.htm#i12352">"Overloaded Subprograms"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF51047" href="../../server.112/e41084/sql_elements002.htm#SQLRF51047"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about implicit conversion of SQL data types (which are also PL/SQL data types)</p>
</li>
<li>
<p><a href="datatypes.htm#CHDEEDIH">"Subtypes with Base Types in Same Data Type Family"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGCFAJ"></a>
<div id="LNPLS868" class="sect2">
<h3 class="sect2">Use SQL Character Functions</h3>
<p><a id="sthref976"></a>SQL has many highly optimized character functions, which use low-level code that is more efficient than PL/SQL code. Use these functions instead of writing PL/SQL code to do the same things.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<ul>
<li>
<p><a class="olink SQLRF20032" href="../../server.112/e41084/functions002.htm#SQLRF20032"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL character functions that return character values</p>
</li>
<li>
<p><a class="olink SQLRF51179" href="../../server.112/e41084/functions002.htm#SQLRF51179"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL character functions that return NLS character values</p>
</li>
<li>
<p><a class="olink SQLRF51180" href="../../server.112/e41084/functions002.htm#SQLRF51180"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL character functions that return number values</p>
</li>
<li>
<p><a href="static.htm#BABCFDJE">Example 6-6</a> for an example of PL/SQL code that uses SQL character function <code dir="ltr">REGEXP_LIKE</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BCGIAIHB"></a>
<div id="LNPLS869" class="sect2">
<h3 class="sect2">Put Least Expensive Conditional Tests First</h3>
<p><a id="sthref977"></a>PL/SQL stops evaluating a logical expression as soon as it can determine the result. Take advantage of this short-circuit evaluation by putting the conditions that are least expensive to evaluate first in logical expressions whenever possible. For example, test the values of PL/SQL variables before testing function return values, so that if the variable tests fail, PL/SQL need not invoke the functions:</p>
<pre dir="ltr">
IF <span class="italic">boolean_variable</span> OR (<span class="italic">number</span> &gt; 10) OR <span class="italic">boolean_function</span>(<span class="italic">parameter</span>) THEN ...
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="fundamentals.htm#CBJIGIFG">"Short-Circuit Evaluation"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFHGHI"></a>
<div id="LNPLS01205" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Bulk SQL and Bulk Binding</h2>
<p><a id="sthref978"></a><a id="sthref979"></a><span class="bold">Bulk SQL</span> minimizes the performance overhead of the communication between PL/SQL and SQL.</p>
<p>PL/SQL and SQL communicate as follows: To run a <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> or DML statement, the PL/SQL engine sends the query or DML statement to the SQL engine. The SQL engine runs the query or DML statement and returns the result to the PL/SQL engine.</p>
<p>The PL/SQL features that comprise bulk SQL are the <code dir="ltr">FORALL</code> statement and the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause. The <a id="sthref980"></a><code dir="ltr">FORALL</code> statement sends DML statements from PL/SQL to SQL in batches rather than one at a time. The <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause returns results from SQL to PL/SQL in batches rather than one at a time. If a query or DML statement affects four or more database rows, then bulk SQL can significantly improve performance.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot perform bulk SQL on remote tables.</div>
<p>Assigning values to PL/SQL variables that appear in SQL statements is called <a id="sthref981"></a><span class="bold">binding</span>. PL/SQL binding operations fall into these categories:</p>
<div class="inftblinformal">
<table class="cellalignment1089" title="PL/SQL Binding Operations" summary="This table summarizes the categories of PL/SQL binding operations." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t15">Binding Category</th>
<th class="cellalignment1090" id="r1c2-t15">When This Binding Occurs</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t15" headers="r1c1-t15"><a id="sthref982"></a>In-bind</td>
<td class="cellalignment1091" headers="r2c1-t15 r1c2-t15">When an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>. or <code dir="ltr">MERGE</code> statement stores a PL/SQL or host variable in the database</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t15" headers="r1c1-t15"><a id="sthref983"></a>Out-bind</td>
<td class="cellalignment1091" headers="r3c1-t15 r1c2-t15">When the <code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause of an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statement assigns a database value to a PL/SQL or host variable</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t15" headers="r1c1-t15"><a id="sthref984"></a><code dir="ltr">DEFINE</code></td>
<td class="cellalignment1091" headers="r4c1-t15 r1c2-t15">When a <code dir="ltr">SELECT</code> or <code dir="ltr">FETCH</code> statement assigns a database value to a PL/SQL or host variable</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>For in-binds and out-binds, bulk SQL uses <a id="sthref985"></a><span class="bold">bulk binding</span>; that is, it binds an entire collection of values at once. For a collection of <span class="italic">n</span> elements, bulk SQL uses a single operation to perform the equivalent of <span class="italic">n</span> <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> or DML statements. A query that uses bulk SQL can return any number of rows, without using a <code dir="ltr">FETCH</code> statement for each one.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref986"></a>Parallel DML is disabled with bulk SQL.</div>
<p class="subhead2"><a id="LNPLS812"></a>Topics</p>
<ul>
<li>
<p><a href="#i54218">FORALL Statement</a></p>
</li>
<li>
<p><a href="#i49139">BULK COLLECT Clause</a></p>
</li>
<li>
<p><a href="#BCGICBDF">Using FORALL Statement and BULK COLLECT Clause Together</a></p>
</li>
<li>
<p><a href="#BCGBCCBG">Client Bulk-Binding of Host Arrays</a></p>
</li>
</ul>
<a id="i54218"></a>
<div id="LNPLS879" class="sect2">
<h3 class="sect2">FORALL Statement</h3>
<p>The <a id="sthref987"></a><a id="sthref988"></a><code dir="ltr">FORALL</code> statement, a feature of bulk SQL, sends DML statements from PL/SQL to SQL in batches rather than one at a time. To understand the <code dir="ltr">FORALL</code> statement, first consider the <a id="sthref989"></a><code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement in <a href="#BABBCECH">Example 12-7</a>. It sends these DML statements from PL/SQL to SQL one at a time:</p>
<pre dir="ltr">
DELETE FROM employees_temp WHERE department_id = depts(10);
DELETE FROM employees_temp WHERE department_id = depts(30);
DELETE FROM employees_temp WHERE department_id = depts(70);
</pre>
<div id="LNPLS814" class="example">
<p class="titleinexample"><a id="BABBCECH"></a>Example 12-7 DELETE Statement in FOR LOOP Statement</p>
<pre dir="ltr">
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS VARRAY(20) OF NUMBER;
  depts NumList := NumList(10, 30, 70);  -- department numbers
BEGIN
  <span class="bold">FOR i IN depts.FIRST..depts.LAST LOOP</span>
    <span class="bold">DELETE FROM employees_temp</span>
    <span class="bold">WHERE department_id = depts(i);</span>
  <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>Now consider the <code dir="ltr">FORALL</code> statement in <a href="#BABDBAAJ">Example 12-8</a>. It sends the same three <a id="sthref990"></a><a id="sthref991"></a>DML statements from PL/SQL to SQL as a batch.</p>
<div id="LNPLS815" class="example">
<p class="titleinexample"><a id="BABDBAAJ"></a>Example 12-8 DELETE Statement in FORALL Statement</p>
<pre dir="ltr">
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS VARRAY(20) OF NUMBER;
  depts NumList := NumList(10, 30, 70);  -- department numbers
BEGIN
  <span class="bold">FORALL i IN depts.FIRST..depts.LAST</span>
    <span class="bold">DELETE FROM employees_temp</span>
    <span class="bold">WHERE department_id = depts(i);</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>A <code dir="ltr">FORALL</code> statement is usually much faster than an equivalent <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement. However, a <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement can contain multiple DML statements, while a <code dir="ltr">FORALL</code> statement can contain only one. The batch of DML statements that a <code dir="ltr">FORALL</code> statement sends to SQL differ only in their <code dir="ltr">VALUES</code> and <code dir="ltr">WHERE</code> clauses. The values in those clauses must come from existing, populated collections.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The DML statement in a <code dir="ltr">FORALL</code> statement can reference multiple collections, but performance benefits apply only to collection references that use the <code dir="ltr">FORALL</code> index variable as an index.</div>
<p><a href="#BABEDFJE">Example 12-9</a> inserts the same collection elements into two database tables, using a <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement for the first table and a <code dir="ltr">FORALL</code> statement for the second table and showing how long each statement takes. (Times vary from run to run.)</p>
<div id="LNPLS881" class="example">
<p class="titleinexample"><a id="BABEDFJE"></a>Example 12-9 Time Difference for INSERT Statement in FOR LOOP and FORALL Statements</p>
<pre dir="ltr">
DROP TABLE parts1;
CREATE TABLE parts1 (
  pnum INTEGER,
  pname VARCHAR2(15)
);
 
DROP TABLE parts2;
CREATE TABLE parts2 (
  pnum INTEGER,
  pname VARCHAR2(15)
);

DECLARE
  TYPE NumTab IS TABLE OF parts1.pnum%TYPE INDEX BY PLS_INTEGER;
  TYPE NameTab IS TABLE OF parts1.pname%TYPE INDEX BY PLS_INTEGER;
  pnums   NumTab;
  pnames  NameTab;
  iterations  CONSTANT PLS_INTEGER := 50000;
  t1  INTEGER;
  t2  INTEGER;
  t3  INTEGER;
BEGIN
  FOR j IN 1..iterations LOOP  -- populate collections
    pnums(j) := j;
    pnames(j) := 'Part No. ' || TO_CHAR(j);
  END LOOP;

  t1 := DBMS_UTILITY.get_time;

  <span class="bold">FOR i IN 1..iterations LOOP</span>
    <span class="bold">INSERT INTO parts1 (pnum, pname)</span>
    <span class="bold">VALUES (pnums(i), pnames(i));</span>
  <span class="bold">END LOOP;</span>

  t2 := DBMS_UTILITY.get_time;

  <span class="bold">FORALL i IN 1..iterations</span>
    <span class="bold">INSERT INTO parts2 (pnum, pname)</span>
    <span class="bold">VALUES (pnums(i), pnames(i));</span>

  t3 := DBMS_UTILITY.get_time;

  DBMS_OUTPUT.PUT_LINE('Execution Time (secs)');
  DBMS_OUTPUT.PUT_LINE('---------------------');
  DBMS_OUTPUT.PUT_LINE('FOR LOOP: ' || TO_CHAR((t2 - t1)/100));
  DBMS_OUTPUT.PUT_LINE('FORALL:   ' || TO_CHAR((t3 - t2)/100));
  COMMIT;
END;
/
</pre>
<p>Result is similar to:</p>
<pre dir="ltr">
Execution Time (secs)
---------------------
FOR LOOP: 2.16
FORALL:   .11
 
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABIIEEI">Example 12-10</a>, the <code dir="ltr">FORALL</code> statement applies to a subset of a collection.</p>
<div id="LNPLS882" class="example">
<p class="titleinexample"><a id="BABIIEEI"></a>Example 12-10 FORALL Statement for Subset of Collection</p>
<pre dir="ltr">
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS VARRAY(10) OF NUMBER;
  depts NumList := NumList(5,10,20,30,50,55,57,60,70,75);
BEGIN
  <span class="bold">FORALL j IN 4..7</span>
    DELETE FROM employees_temp WHERE department_id = depts(j);
END;
/
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS817"></a>Topics</p>
<ul>
<li>
<p><a href="#BABCGAAJ">FORALL Statements for Sparse Collections</a></p>
</li>
<li>
<p><a href="#BABCCBAC">Unhandled Exceptions in FORALL Statements</a></p>
</li>
<li>
<p><a href="#BCGDBDAI">Handling FORALL Exceptions Immediately</a></p>
</li>
<li>
<p><a href="#i49099">Handling FORALL Exceptions After FORALL Statement Completes</a></p>
</li>
<li>
<p><a href="#i49056">Getting Number of Rows Affected by FORALL Statement</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="forall_statement.htm#i34324">"FORALL Statement"</a> for its complete syntax and semantics, including restrictions</p>
</li>
<li>
<p><a href="static.htm#i46192">"Implicit Cursors"</a> for information about implicit cursor attributes in general and other implicit cursor attributes that you can use with the <code dir="ltr">FORALL</code> statement</p>
</li>
</ul>
</div>
<a id="BABCGAAJ"></a>
<div id="LNPLS99862" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">FORALL Statements for Sparse Collections</h4>
<p>If the <a id="sthref992"></a><code dir="ltr">FORALL</code> statement bounds clause references a <a id="sthref993"></a>sparse collection, then specify only existing index values, using either the <code dir="ltr">INDICES</code> <code dir="ltr">OF</code> or <code dir="ltr">VALUES</code> <code dir="ltr">OF</code> clause. You can use <code dir="ltr">INDICES</code> <code dir="ltr">OF</code> for any collection except an associative array indexed by string. You can use <code dir="ltr">VALUES</code> <code dir="ltr">OF</code> only for a collection of <code dir="ltr">PLS_INTEGER</code> elements indexed by <code dir="ltr">PLS_INTEGER</code>.</p>
<p>A collection of <code dir="ltr">PLS_INTEGER</code> elements indexed by <code dir="ltr">PLS_INTEGER</code> can be an <a id="sthref994"></a><span class="bold">index collection</span>; that is, a collection of pointers to elements of another collection (the <span class="bold">indexed collection</span>).</p>
<p>Index collections are useful for processing different <a id="sthref995"></a>subsets of the same collection with different <code dir="ltr">FORALL</code> statements. Instead of copying elements of the original collection into new collections that represent the subsets (which can use significant time and memory), represent each subset with an index collection and then use each index collection in the <code dir="ltr">VALUES</code> <code dir="ltr">OF</code> clause of a different <code dir="ltr">FORALL</code> statement.</p>
<p><a href="#BABJCEFE">Example 12-11</a> uses a <code dir="ltr">FORALL</code> statement with the <code dir="ltr">INDICES</code> <code dir="ltr">OF</code> clause to populate a table with the elements of a sparse collection. Then it uses two <code dir="ltr">FORALL</code> statements with <code dir="ltr">VALUES</code> <code dir="ltr">OF</code> clauses to populate two tables with subsets of a collection.</p>
<div id="LNPLS883" class="example">
<p class="titleinexample"><a id="BABJCEFE"></a>Example 12-11 FORALL Statements for Sparse Collection and Its Subsets</p>
<pre dir="ltr">
DROP TABLE valid_orders;
CREATE TABLE valid_orders (
  cust_name  VARCHAR2(32),
  amount     NUMBER(10,2)
);
 
DROP TABLE big_orders;
CREATE TABLE big_orders AS
  SELECT * FROM valid_orders
  WHERE 1 = 0;
 
DROP TABLE rejected_orders;
CREATE TABLE rejected_orders AS
  SELECT * FROM valid_orders
  WHERE 1 = 0;
 
DECLARE
  SUBTYPE cust_name IS valid_orders.cust_name%TYPE;
  TYPE cust_typ IS TABLE OF cust_name;
  <span class="bold">cust_tab  cust_typ;  -- Collection of customer names</span>
 
  SUBTYPE order_amount IS valid_orders.amount%TYPE;
  TYPE amount_typ IS TABLE OF NUMBER;
  <span class="bold">amount_tab  amount_typ;  -- Collection of order amounts</span>
 
  TYPE index_pointer_t IS TABLE OF PLS_INTEGER;
 
  <span class="bold">/* Collections for pointers to elements of cust_tab collection</span>
     <span class="bold">(to represent two subsets of cust_tab): */</span>
 
  big_order_tab       index_pointer_t := index_pointer_t();
  rejected_order_tab  index_pointer_t := index_pointer_t();
 
  PROCEDURE populate_data_collections IS
  BEGIN
    cust_tab := cust_typ(
      'Company1','Company2','Company3','Company4','Company5'
    );
 
    amount_tab := amount_typ(5000.01, 0, 150.25, 4000.00, NULL);
  END;
 
BEGIN
  <span class="bold">populate_data_collections;</span>
 
  DBMS_OUTPUT.PUT_LINE ('--- Original order data ---');
 
  FOR i IN 1..cust_tab.LAST LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Customer #' || i || ', ' || cust_tab(i) || ': $' || amount_tab(i)
    );
  END LOOP;
 
  <span class="bold">-- Delete invalid orders:</span>
 
  FOR i IN 1..cust_tab.LAST LOOP
    IF amount_tab(i) IS NULL OR amount_tab(i) = 0 THEN
      cust_tab.delete(i);
      amount_tab.delete(i);
    END IF;
  END LOOP;
 
  <span class="bold">-- cust_tab is now a sparse collection.</span>
 
  DBMS_OUTPUT.PUT_LINE ('--- Order data with invalid orders deleted ---');
 
  FOR i IN 1..cust_tab.LAST LOOP
    IF cust_tab.EXISTS(i) THEN
      DBMS_OUTPUT.PUT_LINE (
        'Customer #' || i || ', ' || cust_tab(i) || ': $' || amount_tab(i)
      );
    END IF;
  END LOOP;
 
  <span class="bold">-- Using sparse collection, populate valid_orders table:</span>
 
  <span class="bold">FORALL i IN INDICES OF cust_tab</span>
    INSERT INTO valid_orders (cust_name, amount)
    VALUES (cust_tab(i), amount_tab(i));
 
  <span class="bold">populate_data_collections;  -- Restore original order data</span>
 
  <span class="bold">-- cust_tab is a dense collection again.</span>
 
  <span class="bold">/* Populate collections of pointers to elements of cust_tab collection</span>
     <span class="bold">(which represent two subsets of cust_tab): */</span>
 
  FOR i IN cust_tab.FIRST .. cust_tab.LAST LOOP
    IF amount_tab(i) IS NULL OR amount_tab(i) = 0 THEN
      rejected_order_tab.EXTEND;
      rejected_order_tab(rejected_order_tab.LAST) := i; 
    END IF;
 
    IF amount_tab(i) &gt; 2000 THEN
      big_order_tab.EXTEND;
      big_order_tab(big_order_tab.LAST) := i;
    END IF;
  END LOOP;
 
  <span class="bold">/* Using each subset in a different FORALL statement,</span>
     <span class="bold">populate rejected_orders and big_orders tables: */</span>
 
  <span class="bold">FORALL i IN VALUES OF rejected_order_tab</span>
    INSERT INTO rejected_orders (cust_name, amount)
    VALUES (cust_tab(i), amount_tab(i));
 
  <span class="bold">FORALL i IN VALUES OF big_order_tab</span>
    INSERT INTO big_orders (cust_name, amount)
    VALUES (cust_tab(i), amount_tab(i));
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
--- Original order data ---
Customer #1, Company1: $5000.01
Customer #2, Company2: $0
Customer #3, Company3: $150.25
Customer #4, Company4: $4000
Customer #5, Company5: $
--- Data with invalid orders deleted ---
Customer #1, Company1: $5000.01
Customer #3, Company3: $150.25
Customer #4, Company4: $4000
</pre>
<p>Verify that correct order details were stored:</p>
<pre dir="ltr">
SELECT cust_name "Customer", amount "Valid order amount"
FROM valid_orders
ORDER BY cust_name;
</pre>
<p>Result:</p>
<pre dir="ltr">
Customer                         Valid order amount
-------------------------------- ------------------
Company1                                    5000.01
Company3                                     150.25
Company4                                       4000
 
3 rows selected.
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT cust_name "Customer", amount "Big order amount"
FROM big_orders
ORDER BY cust_name;
</pre>
<p>Result:</p>
<pre dir="ltr">
Customer                         Big order amount
-------------------------------- ----------------
Company1                                  5000.01
Company4                                     4000
 
2 rows selected.
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT cust_name "Customer", amount "Rejected order amount"
FROM rejected_orders
ORDER BY cust_name;
</pre>
<p>Result:</p>
<pre dir="ltr">
Customer                         Rejected order amount
-------------------------------- ---------------------
Company2                                             0
Company5
 
2 rows selected.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABDAFBJ">"Sparse Collections and SQL%BULK_EXCEPTIONS"</a></div>
</div>
<!-- class="sect3" -->
<a id="BABCCBAC"></a>
<div id="LNPLS99861" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Unhandled Exceptions in FORALL Statements</h4>
<p>In a <a id="sthref996"></a><code dir="ltr">FORALL</code> statement without the <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> clause, if one DML statement raises an <a id="sthref997"></a><a id="sthref998"></a>unhandled exception, then PL/SQL stops the <code dir="ltr">FORALL</code> statement and rolls back all changes made by previous DML statements.</p>
<p>For example, the <code dir="ltr">FORALL</code> statement in <a href="#BABDBAAJ">Example 12-8</a> executes these DML statements in this order, unless one of them raises an unhandled exception:</p>
<pre dir="ltr">
DELETE FROM employees_temp WHERE department_id = depts(10);
DELETE FROM employees_temp WHERE department_id = depts(30);
DELETE FROM employees_temp WHERE department_id = depts(70);
</pre>
<p>If the third statement raises an unhandled exception, then PL/SQL rolls back the changes that the first and second statements made. If the second statement raises an unhandled exception, then PL/SQL rolls back the changes that the first statement made and never runs the third statement.</p>
<p>You can <a id="sthref999"></a>handle exceptions raised in a <code dir="ltr">FORALL</code> statement in either of these ways:</p>
<ul>
<li>
<p>As each exception is raised (see <a href="#BCGDBDAI">"Handling FORALL Exceptions Immediately"</a>)</p>
</li>
<li>
<p>After the <code dir="ltr">FORALL</code> statement completes execution, by including the <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> clause (see <a href="#i49099">"Handling FORALL Exceptions After FORALL Statement Completes"</a>)</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BCGDBDAI"></a>
<div id="LNPLS884" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Handling FORALL Exceptions Immediately</h4>
<p>To handle exceptions raised in a <code dir="ltr">FORALL</code> statement <a id="sthref1000"></a>immediately, omit the <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> clause and write the appropriate exception handlers. (For information about exception handlers, see <a href="errors.htm#CHDFGBJI">Chapter 11, "PL/SQL Error Handling."</a>) If one DML statement raises a handled exception, then PL/SQL rolls back the changes made by that statement, but does not roll back changes made by previous DML statements.</p>
<p>In <a href="#BABBBJCF">Example 12-12</a>, the <code dir="ltr">FORALL</code> statement is designed to run three <code dir="ltr">UPDATE</code> statements. However, the second one raises an exception. An exception handler handles the exception, displaying the error message and committing the change made by the first <code dir="ltr">UPDATE</code> statement. The third <code dir="ltr">UPDATE</code> statement never runs.</p>
<div id="LNPLS885" class="example">
<p class="titleinexample"><a id="BABBBJCF"></a>Example 12-12 Handling FORALL Exceptions Immediately</p>
<pre dir="ltr">
DROP TABLE emp_temp;
CREATE TABLE emp_temp (
  deptno NUMBER(2),
  job VARCHAR2(18)
);
 
CREATE OR REPLACE PROCEDURE p AUTHID DEFINER AS
  TYPE NumList IS TABLE OF NUMBER;
 
  depts          NumList := NumList(10, 20, 30);
  error_message  VARCHAR2(100);
 
BEGIN
  -- Populate table:
 
  INSERT INTO emp_temp (deptno, job) VALUES (10, 'Clerk');
  INSERT INTO emp_temp (deptno, job) VALUES (20, 'Bookkeeper');
  INSERT INTO emp_temp (deptno, job) VALUES (30, 'Analyst');
  COMMIT;
 
  -- Append 9-character string to each job:
 
  <span class="bold">FORALL j IN depts.FIRST..depts.LAST</span>
    <span class="bold">UPDATE emp_temp SET job = job || ' (Senior)'</span>
    <span class="bold">WHERE deptno = depts(j);</span>
 
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN OTHERS THEN</span>
    <span class="bold">error_message := SQLERRM;</span>
    <span class="bold">DBMS_OUTPUT.PUT_LINE (error_message);</span>
 
    <span class="bold">COMMIT;  -- Commit results of successful updates</span>
    RAISE;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Procedure created.
</pre>
<p>Invoke procedure:</p>
<pre dir="ltr">
BEGIN
  p;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">ORA-12899: value too large for column "HR"."EMP_TEMP"."JOB" (actual: 19,</span>
<span class="bold">maximum: 18)</span>
<span class="bold">ORA-06512: at "HR.P", line 27</span>
<span class="bold">ORA-06512: at line 2</span>
 
PL/SQL procedure successfully completed.
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM emp_temp;
</pre>
<p>Result:</p>
<pre dir="ltr">
    DEPTNO JOB
---------- ------------------
        10 Clerk <span class="bold">(Senior)</span>
        20 Bookkeeper
        30 Analyst
 
3 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i49099"></a>
<div id="LNPLS889" class="sect3">
<h4 class="sect3">Handling FORALL Exceptions After FORALL Statement Completes</h4>
<p><a id="sthref1001"></a>To allow a <code dir="ltr">FORALL</code> statement to continue even if some of its DML statements fail, include the <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> clause. When a DML statement fails, PL/SQL does not raise an exception; instead, it saves information about the failure. After the <code dir="ltr">FORALL</code> statement completes, PL/SQL raises a single exception for the <code dir="ltr">FORALL</code> statement (ORA-24381). In the exception handler for ORA-24381, you can get information about each individual DML statement failure from the implicit cursor attribute <a id="sthref1002"></a><a id="sthref1003"></a><a id="sthref1004"></a><code dir="ltr">SQL%BULK_EXCEPTIONS</code>.</p>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS</code> is like an associative array of information about the DML statements that failed during the most recently run <code dir="ltr">FORALL</code> statement.</p>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS</code>.<code dir="ltr">COUNT</code> is the number of DML statements that failed. If <code dir="ltr">SQL%BULK_EXCEPTIONS</code>.<code dir="ltr">COUNT</code> is not zero, then for each index value <span class="italic">i</span> from 1 through <code dir="ltr">SQL%BULK_EXCEPTIONS</code>.<code dir="ltr">COUNT</code>:</p>
<ul>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS(</code><code dir="ltr"><span class="codeinlineitalic">i</span></code><code dir="ltr">)</code>.<code dir="ltr">ERROR_INDEX</code> is the number of the DML statement that failed.</p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS(</code><code dir="ltr"><span class="codeinlineitalic">i</span></code><code dir="ltr">)</code>.<code dir="ltr">ERROR_CODE</code> is the Oracle Database error code for the failure.</p>
</li>
</ul>
<p>For example, if a <code dir="ltr">FORALL</code> <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> statement runs 100 DML statements, and the tenth and sixty-fourth ones fail with error codes ORA-12899 and ORA-19278, respectively, then:</p>
<ul>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS</code>.<code dir="ltr">COUNT</code> = 2</p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS(1)</code>.<code dir="ltr">ERROR_INDEX</code> = 10</p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS(1)</code>.<code dir="ltr">ERROR_CODE</code> = 12899</p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS(2)</code>.<code dir="ltr">ERROR_INDEX</code> = 64</p>
</li>
<li>
<p><code dir="ltr">SQL%BULK_EXCEPTIONS(2)</code>.<code dir="ltr">ERROR_CODE</code> = 19278</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
After a <code dir="ltr">FORALL</code> statement <span class="italic">without</span> the <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> clause raises an exception, <code dir="ltr">SQL%BULK_EXCEPTIONS</code>.<code dir="ltr">COUNT</code> = 1.</div>
<p>With the error code, you can get the associated error message with the <a id="sthref1005"></a><a id="sthref1006"></a><a id="sthref1007"></a><code dir="ltr">SQLERRM</code> function (described in <a href="sqlerrm_function.htm#i38980">"SQLERRM Function"</a>):</p>
<pre dir="ltr">
SQLERRM(-(SQL%BULK_EXCEPTIONS(i).ERROR_CODE))
</pre>
<p>However, the error message that <code dir="ltr">SQLERRM</code> returns excludes any substitution arguments (compare the error messages in <a href="#BABBBJCF">Example 12-12</a> and <a href="#BABGBABA">Example 12-13</a>).</p>
<p><a href="#BABGBABA">Example 12-13</a> is like <a href="#BABBBJCF">Example 12-12</a> except:</p>
<ul>
<li>
<p>The <code dir="ltr">FORALL</code> statement includes the <code dir="ltr">SAVE</code> <code dir="ltr">EXCEPTIONS</code> clause.</p>
</li>
<li>
<p>The exception-handling part has an exception handler for ORA-24381, the internally defined exception that PL/SQL raises implicitly when a bulk operation raises and saves exceptions. The example gives ORA-24381 the user-defined name <code dir="ltr">dml_errors</code>.</p>
</li>
<li>
<p>The exception handler for <code dir="ltr">dml_errors</code> uses <code dir="ltr">SQL%BULK_EXCEPTIONS</code> and <code dir="ltr">SQLERRM</code> (and some local variables) to show the error message and which statement, collection item, and string caused the error.</p>
</li>
</ul>
<div id="LNPLS818" class="example">
<p class="titleinexample"><a id="BABGBABA"></a>Example 12-13 Handling FORALL Exceptions After FORALL Statement Completes</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE p AUTHID DEFINER AS
  TYPE NumList IS TABLE OF NUMBER;
  depts        NumList := NumList(10, 20, 30);
 
  error_message  VARCHAR2(100);
  <span class="bold">bad_stmt_no    PLS_INTEGER;</span>
  <span class="bold">bad_deptno     emp_temp.deptno%TYPE;</span>
  <span class="bold">bad_job        emp_temp.job%TYPE;</span>
 
  <span class="bold">dml_errors  EXCEPTION;</span>
  <span class="bold">PRAGMA EXCEPTION_INIT(dml_errors, -24381);</span>
BEGIN
  -- Populate table:
 
  INSERT INTO emp_temp (deptno, job) VALUES (10, 'Clerk');
  INSERT INTO emp_temp (deptno, job) VALUES (20, 'Bookkeeper');
  INSERT INTO emp_temp (deptno, job) VALUES (30, 'Analyst');
  COMMIT;
 
  -- Append 9-character string to each job:
 
  FORALL j IN depts.FIRST..depts.LAST <span class="bold">SAVE EXCEPTIONS</span>
    UPDATE emp_temp SET job = job || ' (Senior)'
    WHERE deptno = depts(j); 
 
EXCEPTION
  WHEN dml_errors THEN
    <span class="bold">FOR i IN 1..SQL%BULK_EXCEPTIONS.COUNT LOOP</span>
      <span class="bold">error_message := SQLERRM(-(SQL%BULK_EXCEPTIONS(i).ERROR_CODE));</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE (error_message);</span>
 
      <span class="bold">bad_stmt_no := SQL%BULK_EXCEPTIONS(i).ERROR_INDEX;</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Bad statement #: ' || bad_stmt_no);</span>
 
      <span class="bold">bad_deptno := depts(bad_stmt_no);</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Bad department #: ' || bad_deptno);</span>
 
      <span class="bold">SELECT job INTO bad_job FROM emp_temp WHERE deptno = bad_deptno;</span>
 
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Bad job: ' || bad_job);</span>
    <span class="bold">END LOOP;</span>
 
    COMMIT;  -- Commit results of successful updates

    <span class="bold">WHEN OTHERS THEN</span>
      <span class="bold">DBMS_OUTPUT.PUT_LINE('Unrecognized error.');</span>
      RAISE;
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
Procedure created.
</pre>
<p>Invoke procedure:</p>
<pre dir="ltr">
BEGIN
  p;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">ORA-12899: value too large for column  (actual: , maximum: )</span>
<span class="bold">Bad statement #: 2</span>
<span class="bold">Bad department #: 20</span>
<span class="bold">Bad job: Bookkeeper</span>
 
PL/SQL procedure successfully completed.
</pre>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM emp_temp;
</pre>
<p>Result:</p>
<pre dir="ltr">
    DEPTNO JOB
---------- ------------------
        10 Clerk (Senior)
        20 Bookkeeper
        30 Analyst <span class="bold">(Senior)</span>
 
3 rows selected.
</pre></div>
<!-- class="example" -->
<a id="BABDAFBJ"></a>
<div id="LNPLS99860" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Sparse Collections and SQL%BULK_EXCEPTIONS</h5>
<p>If the <a id="sthref1008"></a><code dir="ltr">FORALL</code> statement bounds clause references a <a id="sthref1009"></a>sparse collection, then to find the collection element that caused a DML statement to fail, you must step through the elements one by one until you find the element whose index is <code dir="ltr">SQL%BULK_EXCEPTIONS(i)</code>.<code dir="ltr">ERROR_INDEX</code>. Then, if the <code dir="ltr">FORALL</code> statement uses the <code dir="ltr">VALUES</code> <code dir="ltr">OF</code> clause to reference a collection of pointers into another collection, you must find the element of the other collection whose index is <code dir="ltr">SQL%BULK_EXCEPTIONS(i)</code>.<code dir="ltr">ERROR_INDEX</code>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i49056"></a>
<div id="LNPLS886" class="sect3">
<h4 class="sect3">Getting Number of Rows Affected by FORALL Statement</h4>
<p>After a <a id="sthref1010"></a><code dir="ltr">FORALL</code> statement completes, you can get the number of rows that each DML statement affected from the implicit cursor attribute <a id="sthref1011"></a><a id="sthref1012"></a><a id="sthref1013"></a><code dir="ltr">SQL%BULK_ROWCOUNT</code>. (To get the total number of rows affected by the <code dir="ltr">FORALL</code> statement, use the implicit cursor attribute <code dir="ltr">SQL%ROWCOUNT</code>, described in <a href="static.htm#CIHJJJDG">"SQL%ROWCOUNT Attribute: How Many Rows Were Affected?"</a>.)</p>
<p><code dir="ltr">SQL%BULK_ROWCOUNT</code> is like an associative array whose <span class="italic">i</span>th element is the number of rows affected by the <span class="italic">i</span>th DML statement in the most recently completed <code dir="ltr">FORALL</code> statement. The data type of the element is <code dir="ltr">PLS_INTEGER</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the number of rows exceeds the maximum value for a <code dir="ltr">PLS_INTEGER</code>, then the element has a negative value. For information about <code dir="ltr">PLS_INTEGER</code>, see <a href="datatypes.htm#i10726">"PLS_INTEGER and BINARY_INTEGER Data Types"</a>.</div>
<p><a href="#BABDJBDH">Example 12-14</a> uses <code dir="ltr">SQL%BULK_ROWCOUNT</code> to show how many rows each <code dir="ltr">DELETE</code> statement in the <code dir="ltr">FORALL</code> statement deleted and <code dir="ltr">SQL%ROWCOUNT</code> to show the total number of rows deleted.</p>
<div id="LNPLS887" class="example">
<p class="titleinexample"><a id="BABDJBDH"></a>Example 12-14 Showing Number of Rows Affected by Each DELETE in FORALL</p>
<pre dir="ltr">
DROP TABLE emp_temp;
CREATE TABLE emp_temp AS SELECT * FROM employees;

DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  depts NumList := NumList(30, 50, 60);
BEGIN
  FORALL j IN depts.FIRST..depts.LAST
    DELETE FROM emp_temp WHERE department_id = depts(j);

  FOR i IN depts.FIRST..depts.LAST LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Statement #' || i || ' deleted ' ||
      <span class="bold">SQL%BULK_ROWCOUNT(i)</span> || ' rows.'
    );
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('Total rows deleted: ' || <span class="bold">SQL%ROWCOUNT</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Statement #1 deleted 6 rows.
Statement #2 deleted 45 rows.
Statement #3 deleted 5 rows.
Total rows deleted: 56
</pre></div>
<!-- class="example" -->
<p><a href="#BABICGJE">Example 12-15</a> uses <code dir="ltr">SQL%BULK_ROWCOUNT</code> to show how many rows each <code dir="ltr">INSERT</code> <code dir="ltr">SELECT</code> construct in the <code dir="ltr">FORALL</code> statement inserted and <code dir="ltr">SQL%ROWCOUNT</code> to show the total number of rows inserted.</p>
<div id="LNPLS888" class="example">
<p class="titleinexample"><a id="BABICGJE"></a>Example 12-15 Showing Number of Rows Affected by Each INSERT SELECT in FORALL</p>
<pre dir="ltr">
DROP TABLE emp_by_dept;
CREATE TABLE emp_by_dept AS
  SELECT employee_id, department_id
  FROM employees
  WHERE 1 = 0;

DECLARE
  TYPE dept_tab IS TABLE OF departments.department_id%TYPE;
  deptnums  dept_tab;
BEGIN
  SELECT department_id BULK COLLECT INTO deptnums FROM departments;

  <span class="bold">FORALL i IN 1..deptnums.COUNT</span>
    <span class="bold">INSERT INTO emp_by_dept (employee_id, department_id)</span>
      <span class="bold">SELECT employee_id, department_id</span>
      <span class="bold">FROM employees</span>
      <span class="bold">WHERE department_id = deptnums(i)</span>
      <span class="bold">ORDER BY department_id, employee_id;</span>

  FOR i IN 1..deptnums.COUNT LOOP
    -- Count how many rows were inserted for each department; that is,
    -- how many employees are in each department.
    DBMS_OUTPUT.PUT_LINE (
      'Dept '||deptnums(i)||': inserted '||
      <span class="bold">SQL%BULK_ROWCOUNT(i)</span>||' records'
    );
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('Total records inserted: ' || <span class="bold">SQL%ROWCOUNT</span>);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Dept 10: inserted 1 records
Dept 20: inserted 2 records
Dept 30: inserted 6 records
Dept 40: inserted 1 records
Dept 50: inserted 45 records
Dept 60: inserted 5 records
Dept 70: inserted 1 records
Dept 80: inserted 34 records
Dept 90: inserted 3 records
Dept 100: inserted 6 records
Dept 110: inserted 2 records
Dept 120: inserted 0 records
Dept 130: inserted 0 records
Dept 140: inserted 0 records
Dept 150: inserted 0 records
Dept 160: inserted 0 records
Dept 170: inserted 0 records
Dept 180: inserted 0 records
Dept 190: inserted 0 records
Dept 200: inserted 0 records
Dept 210: inserted 0 records
Dept 220: inserted 0 records
Dept 230: inserted 0 records
Dept 240: inserted 0 records
Dept 250: inserted 0 records
Dept 260: inserted 0 records
Dept 270: inserted 0 records
Dept 280: inserted 0 records
Total records inserted: 106
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i49139"></a>
<div id="LNPLS891" class="sect2">
<h3 class="sect2">BULK COLLECT Clause</h3>
<p>The <a id="sthref1014"></a><code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause, a feature of bulk SQL, returns results from SQL to PL/SQL in batches rather than one at a time. The <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause can appear in:</p>
<ul>
<li>
<p><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement</p>
</li>
<li>
<p><code dir="ltr">FETCH</code> statement</p>
</li>
<li>
<p><code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause of:</p>
<ul>
<li>
<p><code dir="ltr">DELETE</code> statement</p>
</li>
<li>
<p><code dir="ltr">INSERT</code> statement</p>
</li>
<li>
<p><code dir="ltr">UPDATE</code> statement</p>
</li>
<li>
<p><code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement</p>
</li>
</ul>
</li>
</ul>
<p>With the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause, each of the preceding statements retrieves an entire result set and stores it in one or more <a id="sthref1015"></a>collection variables in a single operation (which is more efficient than using a loop statement to retrieve one result row at a time).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
PL/SQL processes the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause similar to the way it processes a <code dir="ltr">FETCH</code> statement inside a <code dir="ltr">LOOP</code> statement. PL/SQL does not raise an exception when a statement with a <a id="sthref1016"></a><code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause returns no rows. You must check the target collections for emptiness, as in <a href="#BABCCJCB">Example 12-22</a>.</div>
<p class="subhead2"><a id="LNPLS819"></a>Topics</p>
<ul>
<li>
<p><a href="#BABEIACI">SELECT INTO Statement with BULK COLLECT Clause</a></p>
</li>
<li>
<p><a href="#BCGGAGIF">FETCH Statement with BULK COLLECT Clause</a></p>
</li>
<li>
<p><a href="#BCGHDEJH">RETURNING INTO Clause with BULK COLLECT Clause</a></p>
</li>
</ul>
<a id="BABEIACI"></a>
<div id="LNPLS99877" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SELECT INTO Statement with BULK COLLECT Clause</h4>
<p>The <a id="sthref1017"></a><code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement with the <a id="sthref1018"></a><code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause (also called the <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement) selects an entire result set into one or more collection variables. For more information, see <a href="selectinto_statement.htm#i36066">"SELECT INTO Statement"</a>.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
The <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement is vulnerable to aliasing, which can cause unexpected results. For details, see <a href="#BABHHFIF">"SELECT BULK COLLECT INTO Statements and Aliasing"</a>.</div>
<p><a href="#BABJCBGD">Example 12-16</a> uses a <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement to select two database columns into two collections (nested tables).</p>
<div id="LNPLS892" class="example">
<p class="titleinexample"><a id="BABJCBGD"></a>Example 12-16 Bulk-Selecting Two Database Columns into Two Nested Tables</p>
<pre dir="ltr">
DECLARE
  TYPE NumTab IS TABLE OF employees.employee_id%TYPE;
  TYPE NameTab IS TABLE OF employees.last_name%TYPE;
 
  enums NumTab;
  names NameTab;
 
  PROCEDURE print_first_n (n POSITIVE) IS
  BEGIN
    IF enums.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE ('Collections are empty.');
    ELSE
      DBMS_OUTPUT.PUT_LINE ('First ' || n || ' employees:');
 
      FOR i IN 1 .. n LOOP
        DBMS_OUTPUT.PUT_LINE (
          '  Employee #' || enums(i) || ': ' || names(i));
      END LOOP;
    END IF;
  END;
 
BEGIN
  <span class="bold">SELECT employee_id, last_name</span>
  <span class="bold">BULK COLLECT INTO enums, names</span>
  <span class="bold">FROM employees</span>
  <span class="bold">ORDER BY employee_id;</span>
 
  print_first_n(3);
  print_first_n(6);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
First 3 employees:
Employee #100: King
Employee #101: Kochhar
Employee #102: De Haan
First 6 employees:
Employee #100: King
Employee #101: Kochhar
Employee #102: De Haan
Employee #103: Hunold
Employee #104: Ernst
Employee #105: Austin
</pre></div>
<!-- class="example" -->
<p><a href="#CIHGGBGF">Example 12-17</a> uses a <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement to select a result set into a nested table of records.</p>
<div id="LNPLS820" class="example">
<p class="titleinexample"><a id="CIHGGBGF"></a>Example 12-17 Bulk-Selecting into Nested Table of Records</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT first_name, last_name, hire_date
    FROM employees;
  
  TYPE NameSet IS TABLE OF c1%ROWTYPE;
 
  stock_managers  NameSet;  -- nested table of records
 
BEGIN 
  -- Assign values to nested table of records:
 
  <span class="bold">SELECT first_name, last_name, hire_date</span>
    <span class="bold">BULK COLLECT INTO stock_managers</span>
    <span class="bold">FROM employees</span>
    <span class="bold">WHERE job_id = 'ST_MAN'</span>
    <span class="bold">ORDER BY hire_date;</span>
 
  -- Print nested table of records:
 
    FOR i IN stock_managers.FIRST .. stock_managers.LAST LOOP
      DBMS_OUTPUT.PUT_LINE (
        stock_managers(i).hire_date || ' ' ||
        stock_managers(i).last_name  || ', ' ||
        stock_managers(i).first_name
      );
    END LOOP;END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
01-MAY-03 Kaufling, Payam
18-JUL-04 Weiss, Matthew
10-APR-05 Fripp, Adam
10-OCT-05 Vollman, Shanta
16-NOV-07 Mourgos, Kevin
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="LNPLS821"></a>Topics</p>
<ul>
<li>
<p><a href="#BABHHFIF">SELECT BULK COLLECT INTO Statements and Aliasing</a></p>
</li>
<li>
<p><a href="#BABDBJGH">Row Limits for SELECT BULK COLLECT INTO Statements</a></p>
</li>
<li>
<p><a href="#BABCBCFF">Guidelines for Looping Through Collections</a></p>
</li>
</ul>
<a id="BABHHFIF"></a>
<div id="LNPLS904" class="sect4">
<h5 class="sect4">SELECT BULK COLLECT INTO Statements and Aliasing</h5>
<p>In a statement of the form</p>
<pre dir="ltr">
SELECT <span class="italic">column</span> BULK COLLECT INTO <span class="italic">collection</span> FROM <span class="italic">table</span> ...
</pre>
<p><code dir="ltr"><span class="codeinlineitalic">column</span></code> and <code dir="ltr"><span class="codeinlineitalic">collection</span></code> are analogous to <code dir="ltr">IN</code> <code dir="ltr">NOCOPY</code> and <code dir="ltr">OUT</code> <code dir="ltr">NOCOPY</code> subprogram parameters, respectively, and PL/SQL passes them by reference. As with subprogram parameters that are passed by reference, <a id="sthref1019"></a><a id="sthref1020"></a>aliasing can cause unexpected results.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="subprograms.htm#CHDGBIEC">"Subprogram Parameter Aliasing with Parameters Passed by Reference"</a></div>
<p>In <a href="#BABGIGII">Example 12-18</a>, the intention is to select specific values from a collection, <code dir="ltr">numbers1</code>, and then store them in the same collection. The unexpected result is that all elements of <code dir="ltr">numbers1</code> are deleted. For workarounds, see <a href="#BABCEEDG">Example 12-19</a> and <a href="#BABGHCAJ">Example 12-20</a>.</p>
<div id="LNPLS905" class="example">
<p class="titleinexample"><a id="BABGIGII"></a>Example 12-18 SELECT BULK COLLECT INTO Statement with Unexpected Results</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE numbers_type IS
  TABLE OF INTEGER
/
CREATE OR REPLACE PROCEDURE p (i IN INTEGER) IS
  numbers1  numbers_type := numbers_type(1,2,3,4,5);
BEGIN
  DBMS_OUTPUT.PUT_LINE('Before SELECT statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
  
  FOR j IN 1..numbers1.COUNT() LOOP
    DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
  END LOOP;
 
  --Self-selecting BULK COLLECT INTO clause:
 
  <span class="bold">SELECT a.COLUMN_VALUE</span>
  <span class="bold">BULK COLLECT INTO numbers1</span>
  <span class="bold">FROM TABLE(numbers1) a</span>
  <span class="bold">WHERE a.COLUMN_VALUE &gt; p.i</span>
  <span class="bold">ORDER BY a.COLUMN_VALUE;</span>
 
  DBMS_OUTPUT.PUT_LINE('After SELECT statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
END p;
/
</pre>
<p>Invoke <code dir="ltr">p</code>:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">p(2);</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 0</span>
 
PL/SQL procedure successfully completed.
</pre>
<p>Invoke <code dir="ltr">p</code>:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">p(10);</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 0</span>
</pre></div>
<!-- class="example" -->
<p><a href="#BABCEEDG">Example 12-19</a> uses a cursor to achieve the result intended by <a href="#BABGIGII">Example 12-18</a>.</p>
<div id="LNPLS906" class="example">
<p class="titleinexample"><a id="BABCEEDG"></a>Example 12-19 Cursor Workaround for <a href="#BABGIGII">Example 12-18</a></p>
<pre dir="ltr">
CREATE OR REPLACE TYPE numbers_type IS
  TABLE OF INTEGER
/
CREATE OR REPLACE PROCEDURE p (i IN INTEGER) IS
  numbers1  numbers_type := numbers_type(1,2,3,4,5);
  
  <span class="bold">CURSOR c IS</span>
    <span class="bold">SELECT a.COLUMN_VALUE</span>
    <span class="bold">FROM TABLE(numbers1) a</span>
    <span class="bold">WHERE a.COLUMN_VALUE &gt; p.i</span>
    <span class="bold">ORDER BY a.COLUMN_VALUE;</span>
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Before FETCH statement');
    DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
 
    FOR j IN 1..numbers1.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
    END LOOP;
 
  <span class="bold">OPEN c;</span>
  <span class="bold">FETCH c BULK COLLECT INTO numbers1;</span>
  <span class="bold">CLOSE c;</span>
 
  DBMS_OUTPUT.PUT_LINE('After FETCH statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
 
  IF numbers1.COUNT() &gt; 0 THEN
    FOR j IN 1..numbers1.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
    END LOOP;
  END IF;
END p;
/
</pre>
<p>Invoke <code dir="ltr">p</code>:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">p(2);</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Before FETCH statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After FETCH statement</span>
<span class="bold">numbers1.COUNT() = 3</span>
numbers1(1) = 3
numbers1(2) = 4
numbers1(3) = 5
</pre>
<p>Invoke <code dir="ltr">p</code>:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">p(10);</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Before FETCH statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">After FETCH statement</span>
<span class="bold">numbers1.COUNT() = 0</span>
</pre></div>
<!-- class="example" -->
<p><a href="#BABGHCAJ">Example 12-20</a> selects specific values from a collection, <code dir="ltr">numbers1</code>, and then stores them in a different collection, <code dir="ltr">numbers2</code>. <a href="#BABGHCAJ">Example 12-20</a> runs faster than <a href="#BABCEEDG">Example 12-19</a>.</p>
<div id="LNPLS907" class="example">
<p class="titleinexample"><a id="BABGHCAJ"></a>Example 12-20 Second Collection Workaround for <a href="#BABGIGII">Example 12-18</a></p>
<pre dir="ltr">
CREATE OR REPLACE TYPE numbers_type IS
  TABLE OF INTEGER
/
CREATE OR REPLACE PROCEDURE p (i IN INTEGER) IS
  numbers1  numbers_type := numbers_type(1,2,3,4,5);
 <span class="bold">numbers2  numbers_type := numbers_type(0,0,0,0,0);</span>
  
BEGIN
  DBMS_OUTPUT.PUT_LINE('Before SELECT statement');
  
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
  
  FOR j IN 1..numbers1.COUNT() LOOP
    DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE('numbers2.COUNT() = ' || numbers2.COUNT());
 
  FOR j IN 1..numbers2.COUNT() LOOP
    DBMS_OUTPUT.PUT_LINE('numbers2(' || j || ') = ' || numbers2(j));
  END LOOP;
 
  SELECT a.COLUMN_VALUE
  <span class="bold">BULK COLLECT INTO numbers2      -- numbers2 appears here</span>
  <span class="bold">FROM TABLE(numbers1) a        -- numbers1 appears here</span>
  WHERE a.COLUMN_VALUE &gt; p.i
  ORDER BY a.COLUMN_VALUE;
 
  DBMS_OUTPUT.PUT_LINE('After SELECT statement');
  DBMS_OUTPUT.PUT_LINE('numbers1.COUNT() = ' || numbers1.COUNT());
 
  IF numbers1.COUNT() &gt; 0 THEN
    FOR j IN 1..numbers1.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers1(' || j || ') = ' || numbers1(j));
    END LOOP;
  END IF;
 
  DBMS_OUTPUT.PUT_LINE('numbers2.COUNT() = ' || numbers2.COUNT());
 
  IF numbers2.COUNT() &gt; 0 THEN
    FOR j IN 1..numbers2.COUNT() LOOP
      DBMS_OUTPUT.PUT_LINE('numbers2(' || j || ') = ' || numbers2(j));
    END LOOP;
  END IF;
END p;
/
</pre>
<p>Invoke <code dir="ltr">p</code>:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">p(2);</span>
 END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 5</span>
numbers2(1) = 0
numbers2(2) = 0
numbers2(3) = 0
numbers2(4) = 0
numbers2(5) = 0
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 3</span>
numbers2(1) = 3
numbers2(2) = 4
numbers2(3) = 5
 
PL/SQL procedure successfully completed.
</pre>
<p>Invoke <code dir="ltr">p</code>:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">p(10);</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Before SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 5</span>
numbers2(1) = 0
numbers2(2) = 0
numbers2(3) = 0
numbers2(4) = 0
numbers2(5) = 0
<span class="bold">After SELECT statement</span>
<span class="bold">numbers1.COUNT() = 5</span>
numbers1(1) = 1
numbers1(2) = 2
numbers1(3) = 3
numbers1(4) = 4
numbers1(5) = 5
<span class="bold">numbers2.COUNT() = 0</span>
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="BABDBJGH"></a>
<div id="LNPLS99876" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Row Limits for SELECT BULK COLLECT INTO Statements</h5>
<p>A <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement that returns a large number of rows produces a large collection. To limit the number of rows and the collection size, use either the <a id="sthref1021"></a><code dir="ltr">ROWNUM</code> pseudocolumn (described in <a class="olink SQLRF00255" href="../../server.112/e41084/pseudocolumns009.htm#SQLRF00255"><span class="italic">Oracle Database SQL Language Reference</span></a>) or <a id="sthref1022"></a><code dir="ltr">SAMPLE</code> clause (described in <a class="olink SQLRF55293" href="../../server.112/e41084/statements_10002.htm#SQLRF55293"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
<p>In <a href="#BCGFEDDI">Example 12-21</a>, the first <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement uses <code dir="ltr">ROWNUM</code> to limit the number of rows to 50, and the second <code dir="ltr">SELECT</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> statement uses <code dir="ltr">SAMPLE</code> to limit the number of rows to approximately 10% of the total.</p>
<div id="LNPLS893" class="example">
<p class="titleinexample"><a id="BCGFEDDI"></a>Example 12-21 Limiting Bulk Selection with ROWNUM and SAMPLE</p>
<pre dir="ltr">
DECLARE
  TYPE SalList IS TABLE OF employees.salary%TYPE;
  sals SalList;
BEGIN
  SELECT salary BULK COLLECT INTO sals
  FROM employees
  <span class="bold">WHERE ROWNUM &lt;= 50</span>;

  SELECT salary BULK COLLECT INTO sals FROM employees <span class="bold">SAMPLE (10)</span>;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="BABCBCFF"></a>
<div id="LNPLS99875" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Guidelines for Looping Through Collections</h5>
<p>When a result set is stored in a collection, it is easy to loop through the rows and refer to different columns. This technique can be very fast, but also very memory-intensive. If you use it often:</p>
<ul>
<li>
<p>To loop once through the result set, use a cursor <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> (see <a href="static.htm#CIHCGJAD">"Query Result Set Processing With Cursor FOR LOOP Statements"</a>).</p>
<p>This technique avoids the memory overhead of storing a copy of the result set.</p>
</li>
<li>
<p>Instead of looping through the result set to search for certain values or filter the results into a smaller set, do the searching or filtering in the query of the <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement.</p>
<p>For example, in simple queries, use <code dir="ltr">WHERE</code> clauses; in queries that compare multiple result sets, use set operators such as <code dir="ltr">INTERSECT</code> and <code dir="ltr">MINUS</code>. For information about set operators, see <a class="olink SQLRF52341" href="../../server.112/e41084/queries004.htm#SQLRF52341"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Instead of looping through the result set and running another query for each result row, use a subquery in the query of the <code dir="ltr">SELECT</code> <code dir="ltr">INTO</code> statement (see <a href="static.htm#i3317">"Query Result Set Processing with Subqueries"</a>).</p>
</li>
<li>
<p>Instead of looping through the result set and running another DML statement for each result row, use the <code dir="ltr">FORALL</code> statement (see <a href="#i54218">"FORALL Statement"</a>).</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BCGGAGIF"></a>
<div id="LNPLS894" class="sect3">
<h4 class="sect3">FETCH Statement with BULK COLLECT Clause</h4>
<p>The <a id="sthref1023"></a><code dir="ltr">FETCH</code> statement with the <a id="sthref1024"></a><code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause (also called the <code dir="ltr">FETCH</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> statement) fetches an entire result set into one or more collection variables. For more information, see <a href="fetch_statement.htm#i34221">"FETCH Statement"</a>.</p>
<p><a href="#BABCCJCB">Example 12-22</a> uses a <code dir="ltr">FETCH</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> statement to fetch an entire result set into two collections (nested tables).</p>
<div id="LNPLS895" class="example">
<p class="titleinexample"><a id="BABCCJCB"></a>Example 12-22 Bulk-Fetching into Two Nested Tables</p>
<pre dir="ltr">
DECLARE
  TYPE NameList IS TABLE OF employees.last_name%TYPE;
  TYPE SalList IS TABLE OF employees.salary%TYPE;

  CURSOR c1 IS
    SELECT last_name, salary
    FROM employees
    WHERE salary &gt; 10000
    ORDER BY last_name;

  names  NameList;
  sals   SalList;

  TYPE RecList IS TABLE OF c1%ROWTYPE;
  recs RecList;

  v_limit PLS_INTEGER := 10;

  PROCEDURE print_results IS
  BEGIN
    <span class="bold">-- Check if collections are empty:</span>

    IF names IS NULL OR names.COUNT = 0 THEN
      DBMS_OUTPUT.PUT_LINE('No results!');
    ELSE
      DBMS_OUTPUT.PUT_LINE('Result: ');
      FOR i IN names.FIRST .. names.LAST
      LOOP
        DBMS_OUTPUT.PUT_LINE('  Employee ' || names(i) || ': $' || sals(i));
      END LOOP;
    END IF;
  END;

BEGIN
  DBMS_OUTPUT.PUT_LINE ('--- Processing all results simultaneously ---');
  OPEN c1;
  FETCH c1 BULK COLLECT INTO names, sals;
  CLOSE c1;
  print_results();
  DBMS_OUTPUT.PUT_LINE ('--- Processing ' || v_limit || ' rows at a time ---');
  OPEN c1;
  LOOP
    FETCH c1 BULK COLLECT INTO names, sals LIMIT v_limit;
    EXIT WHEN names.COUNT = 0;
    print_results();
  END LOOP;
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE ('--- Fetching records rather than columns ---');
  OPEN c1;
  FETCH c1 BULK COLLECT INTO recs;
  FOR i IN recs.FIRST .. recs.LAST
  LOOP
    -- Now all columns from result set come from one record
    DBMS_OUTPUT.PUT_LINE (
      '  Employee ' || recs(i).last_name || ': $' || recs(i).salary
    );
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
--- Processing all results simultaneously ---
Result:
Employee Abel: $11000
Employee Cambrault: $11000
Employee De Haan: $17000
Employee Errazuriz: $12000
Employee Fripp: $18540.29
Employee Greenberg: $12008
Employee Hartstein: $13000
Employee Higgins: $12008
Employee Kaufling: $17862
Employee King: $24000
Employee Kochhar: $17000
Employee Mourgos: $13113.87
Employee Ozer: $11500
Employee Partners: $13500
Employee Raphaely: $11000
Employee Russell: $14000
Employee Vishney: $10500
Employee Vollman: $14696.58
Employee Weiss: $22907.66
Employee Zlotkey: $10500
--- Processing 10 rows at a time ---
Result:
Employee Abel: $11000
Employee Cambrault: $11000
Employee De Haan: $17000
Employee Errazuriz: $12000
Employee Fripp: $18540.29
Employee Greenberg: $12008
Employee Hartstein: $13000
Employee Higgins: $12008
Employee Kaufling: $17862
Employee King: $24000
Result:
Employee Kochhar: $17000
Employee Mourgos: $13113.87
Employee Ozer: $11500
Employee Partners: $13500
Employee Raphaely: $11000
Employee Russell: $14000
Employee Vishney: $10500
Employee Vollman: $14696.58
Employee Weiss: $22907.66
Employee Zlotkey: $10500
--- Fetching records rather than columns ---
Employee Abel: $11000
Employee Cambrault: $11000
Employee De Haan: $17000
Employee Errazuriz: $12000
Employee Fripp: $18540.29
Employee Greenberg: $12008
Employee Hartstein: $13000
Employee Higgins: $12008
Employee Kaufling: $17862
Employee King: $24000
Employee Kochhar: $17000
Employee Mourgos: $13113.87
Employee Ozer: $11500
Employee Partners: $13500
Employee Raphaely: $11000
Employee Russell: $14000
Employee Vishney: $10500
Employee Vollman: $14696.58
Employee Weiss: $22907.66
Employee Zlotkey: $10500
</pre></div>
<!-- class="example" -->
<p><a href="#CIHBDHIB">Example 12-23</a> uses a <code dir="ltr">FETCH</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> statement to fetch a result set into a collection (nested table) of records.</p>
<div id="LNPLS822" class="example">
<p class="titleinexample"><a id="CIHBDHIB"></a>Example 12-23 Bulk-Fetching into Nested Table of Records</p>
<pre dir="ltr">
DECLARE
  CURSOR c1 IS
    SELECT first_name, last_name, hire_date
    FROM employees;
  
  TYPE NameSet IS TABLE OF c1%ROWTYPE;
  stock_managers  NameSet;  -- nested table of records
 
  TYPE cursor_var_type is REF CURSOR;
  cv cursor_var_type;
 
BEGIN 
  -- Assign values to nested table of records:
 
  OPEN cv FOR
    SELECT first_name, last_name, hire_date
    FROM employees
    WHERE job_id = 'ST_MAN'
    ORDER BY hire_date;
 
  FETCH cv BULK COLLECT INTO stock_managers;
  CLOSE cv;
 
  -- Print nested table of records:
 
    FOR i IN stock_managers.FIRST .. stock_managers.LAST LOOP
      DBMS_OUTPUT.PUT_LINE (
        stock_managers(i).hire_date || ' ' ||
        stock_managers(i).last_name  || ', ' ||
        stock_managers(i).first_name
      );
    END LOOP;END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
01-MAY-03 Kaufling, Payam
18-JUL-04 Weiss, Matthew
10-APR-05 Fripp, Adam
10-OCT-05 Vollman, Shanta
16-NOV-07 Mourgos, Kevin
</pre></div>
<!-- class="example" -->
<a id="BCGFCBGH"></a>
<div id="LNPLS897" class="sect4">
<h5 class="sect4">Row Limits for FETCH BULK COLLECT Statements</h5>
<p>A <code dir="ltr">FETCH</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> statement that returns a large number of rows produces a large collection. To limit the number of rows and the collection size, use the <a id="sthref1025"></a><code dir="ltr">LIMIT</code> clause.</p>
<p>In <a href="#BABJIAFH">Example 12-24</a>, with each iteration of the <code dir="ltr">LOOP</code> statement, the <code dir="ltr">FETCH</code> statement fetches ten rows (or fewer) into associative array <code dir="ltr">empids</code> (overwriting the previous values).</p>
<div id="LNPLS898" class="example">
<p class="titleinexample"><a id="BABJIAFH"></a>Example 12-24 Limiting Bulk FETCH with LIMIT</p>
<pre dir="ltr">
DECLARE
  TYPE numtab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;

  CURSOR c1 IS
    SELECT employee_id
    FROM employees
    WHERE department_id = 80
    ORDER BY employee_id;

  empids  numtab;
BEGIN
  OPEN c1;
  LOOP  <span class="bold">-- Fetch 10 rows or fewer in each iteration</span>
    FETCH c1 BULK COLLECT INTO empids <span class="bold">LIMIT 10</span>;
    DBMS_OUTPUT.PUT_LINE ('------- Results from One Bulk Fetch --------');
    FOR i IN 1..empids.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE ('Employee Id: ' || empids(i));
    END LOOP;
    <span class="bold">EXIT WHEN c1%NOTFOUND;</span>
  END LOOP;
  CLOSE c1;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
------- Results from One Bulk Fetch --------
Employee Id: 145
Employee Id: 146
Employee Id: 147
Employee Id: 148
Employee Id: 149
Employee Id: 150
Employee Id: 151
Employee Id: 152
Employee Id: 153
Employee Id: 154
------- Results from One Bulk Fetch --------
Employee Id: 155
Employee Id: 156
Employee Id: 157
Employee Id: 158
Employee Id: 159
Employee Id: 160
Employee Id: 161
Employee Id: 162
Employee Id: 163
Employee Id: 164
------- Results from One Bulk Fetch --------
Employee Id: 165
Employee Id: 166
Employee Id: 167
Employee Id: 168
Employee Id: 169
Employee Id: 170
Employee Id: 171
Employee Id: 172
Employee Id: 173
Employee Id: 174
------- Results from One Bulk Fetch --------
Employee Id: 175
Employee Id: 176
Employee Id: 177
Employee Id: 179
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BCGHDEJH"></a>
<div id="LNPLS899" class="sect3">
<h4 class="sect3">RETURNING INTO Clause with BULK COLLECT Clause</h4>
<p>The <a id="sthref1026"></a><code dir="ltr">RETURNING</code> <code dir="ltr">INTO</code> clause with the <a id="sthref1027"></a><code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> clause (also called the <code dir="ltr">RETURNING</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause) can appear in an <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, or <code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code> statement. With the <code dir="ltr">RETURNING</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause, the statement stores its result set in one or more collections. For more information, see <a href="returninginto_clause.htm#CJAGFGDE">"RETURNING INTO Clause"</a>.</p>
<p><a href="#BABHDFDE">Example 12-25</a> uses a <code dir="ltr">DELETE</code> statement with the <code dir="ltr">RETURNING</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause to delete rows from a table and return them in two collections (nested tables).</p>
<div id="LNPLS900" class="example">
<p class="titleinexample"><a id="BABHDFDE"></a>Example 12-25 Returning Deleted Rows in Two Nested Tables</p>
<pre dir="ltr">
DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
SELECT * FROM employees
ORDER BY employee_id;

DECLARE
  TYPE NumList IS TABLE OF employees.employee_id%TYPE;
  enums  NumList;
  TYPE NameList IS TABLE OF employees.last_name%TYPE;
  names  NameList;
BEGIN
  DELETE FROM emp_temp
  WHERE department_id = 30
  <span class="bold">RETURNING employee_id, last_name</span>
  <span class="bold">BULK COLLECT INTO enums, names</span>;

  DBMS_OUTPUT.PUT_LINE ('Deleted ' || SQL%ROWCOUNT || ' rows:');
  FOR i IN enums.FIRST .. enums.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE ('Employee #' || enums(i) || ': ' || names(i));
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Deleted 6 rows:
Employee #114: Raphaely
Employee #115: Khoo
Employee #116: Baida
Employee #117: Tobias
Employee #118: Himuro
Employee #119: Colmenares
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BCGICBDF"></a>
<div id="LNPLS901" class="sect2">
<h3 class="sect2">Using FORALL Statement and BULK COLLECT Clause Together</h3>
<p>In a <a id="sthref1028"></a><code dir="ltr">FORALL</code> statement, the DML statement can have a <a id="sthref1029"></a><a id="sthref1030"></a><code dir="ltr">RETURNING</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause. For each iteration of the <code dir="ltr">FORALL</code> statement, the DML statement stores the specified values in the specified collections&mdash;without overwriting the previous values, as the same DML statement would do in a <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement.</p>
<p>In <a href="#BABEJHDE">Example 12-26</a>, the <code dir="ltr">FORALL</code> statement runs a <code dir="ltr">DELETE</code> statement that has a <code dir="ltr">RETURNING</code> <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause. For each iteration of the <code dir="ltr">FORALL</code> statement, the <code dir="ltr">DELETE</code> statement stores the <code dir="ltr">employee_id</code> and <code dir="ltr">department_id</code> values of the deleted row in the collections <code dir="ltr">e_ids</code> and <code dir="ltr">d_ids</code>, respectively.</p>
<div id="LNPLS902" class="example">
<p class="titleinexample"><a id="BABEJHDE"></a>Example 12-26 DELETE with RETURN BULK COLLECT INTO in FORALL Statement</p>
<pre dir="ltr">
DROP TABLE emp_temp;
CREATE TABLE emp_temp AS
SELECT * FROM employees
ORDER BY employee_id, department_id;

DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  depts  NumList := NumList(10,20,30);

  TYPE enum_t IS TABLE OF employees.employee_id%TYPE;
  e_ids  enum_t;

  TYPE dept_t IS TABLE OF employees.department_id%TYPE;
  d_ids  dept_t;

BEGIN
  <span class="bold">FORALL</span> j IN depts.FIRST..depts.LAST
    DELETE FROM emp_temp
    WHERE department_id = depts(j)
    <span class="bold">RETURNING</span> employee_id, department_id
    <span class="bold">BULK COLLECT INTO</span> e_ids, d_ids;

  DBMS_OUTPUT.PUT_LINE ('Deleted ' || SQL%ROWCOUNT || ' rows:');

  FOR i IN e_ids.FIRST .. e_ids.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Employee #' || e_ids(i) || ' from dept #' || d_ids(i)
    );
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Deleted 9 rows:
Employee #200 from dept #10
Employee #201 from dept #20
Employee #202 from dept #20
Employee #114 from dept #30
Employee #115 from dept #30
Employee #116 from dept #30
Employee #117 from dept #30
Employee #118 from dept #30
Employee #119 from dept #30
</pre></div>
<!-- class="example" -->
<p><a href="#BABDCEBE">Example 12-27</a> is like <a href="#BABEJHDE">Example 12-26</a> except that it uses a <code dir="ltr">FOR</code> <code dir="ltr">LOOP</code> statement instead of a <code dir="ltr">FORALL</code> statement.</p>
<div id="LNPLS823" class="example">
<p class="titleinexample"><a id="BABDCEBE"></a>Example 12-27 DELETE with RETURN BULK COLLECT INTO in FOR LOOP Statement</p>
<pre dir="ltr">
DECLARE
  TYPE NumList IS TABLE OF NUMBER;
  depts  NumList := NumList(10,20,30);
 
  TYPE enum_t IS TABLE OF employees.employee_id%TYPE;
  e_ids  enum_t;
 
  TYPE dept_t IS TABLE OF employees.department_id%TYPE;
  d_ids  dept_t;
 
BEGIN
  <span class="bold">FOR</span> j IN depts.FIRST..depts.LAST <span class="bold">LOOP</span>
    DELETE FROM emp_temp
    WHERE department_id = depts(j)
    <span class="bold">RETURNING</span> employee_id, department_id
    <span class="bold">BULK COLLECT INTO</span> e_ids, d_ids;
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE ('Deleted ' || SQL%ROWCOUNT || ' rows:');
 
  FOR i IN e_ids.FIRST .. e_ids.LAST
  LOOP
    DBMS_OUTPUT.PUT_LINE (
      'Employee #' || e_ids(i) || ' from dept #' || d_ids(i)
    );
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Deleted 6 rows:
Employee #114 from dept #30
Employee #115 from dept #30
Employee #116 from dept #30
Employee #117 from dept #30
Employee #118 from dept #30
Employee #119 from dept #30
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BCGBCCBG"></a>
<div id="LNPLS903" class="sect2">
<h3 class="sect2">Client Bulk-Binding of Host Arrays</h3>
<p>Client programs (such as OCI and Pro*C programs) can use PL/SQL anonymous blocks to bulk-bind input and output host arrays. This is the most efficient way to pass collections to and from the database server.</p>
<p>In the client program, declare and assign values to the <a id="sthref1031"></a>host variables to be referenced in the anonymous block. In the anonymous block, prefix each host variable name with a colon (:) to distinguish it from a PL/SQL collection variable name. When the client program runs, the database server runs the PL/SQL anonymous block.</p>
<p>In <a href="#BABJFFFB">Example 12-28</a>, the anonymous block uses a <code dir="ltr">FORALL</code> statement to bulk-bind a host input array. In the <code dir="ltr">FORALL</code> statement, the <code dir="ltr">DELETE</code> statement refers to four host variables: scalars <code dir="ltr">lower</code>, <code dir="ltr">upper</code>, and <code dir="ltr">emp_id</code> and array <code dir="ltr">depts</code>.</p>
<div id="LNPLS824" class="example">
<p class="titleinexample"><a id="BABJFFFB"></a>Example 12-28 Anonymous Block Bulk-Binds Input Host Array</p>
<pre dir="ltr">
BEGIN
  FORALL i IN <span class="bold">:lower</span>..<span class="bold">:upper</span>
    DELETE FROM employees
    WHERE department_id = <span class="bold">:depts</span>(i);
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i52932"></a>
<div id="LNPLS01210" class="sect1">
<h2 class="sect1">Chaining Pipelined Table Functions for Multiple Transformations</h2>
<p>Chaining pipelined table functions is an efficient way to perform <a id="sthref1032"></a>multiple transformations on data.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot run a pipelined table function over a database link. The reason is that the return type of a pipelined table function is a SQL user-defined type, which can be used only in a single database (as explained in <a class="olink ADOBJ7083" href="../../appdev.112/e11822/adobjbas.htm#ADOBJ7083"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a>). Although the return type of a pipelined table function might appear to be a PL/SQL type, the database actually converts that PL/SQL type to a corresponding SQL user-defined type.</div>
<p class="subhead2"><a id="LNPLS825"></a>Topics</p>
<ul>
<li>
<p><a href="#i52954">Overview of Table Functions</a></p>
</li>
<li>
<p><a href="#i53109">Creating Pipelined Table Functions</a></p>
</li>
<li>
<p><a href="#BABHAABE">Pipelined Table Functions as Transformation Functions</a></p>
</li>
<li>
<p><a href="#BCGCBDGC">Chaining Pipelined Table Functions</a></p>
</li>
<li>
<p><a href="#BCGGEBGI">Fetching from Results of Pipelined Table Functions</a></p>
</li>
<li>
<p><a href="#BCGHHFHJ">Passing CURSOR Expressions to Pipelined Table Functions</a></p>
</li>
<li>
<p><a href="#i53293">DML Statements on Pipelined Table Function Results</a></p>
</li>
<li>
<p><a href="#BCGGJECI">NO_DATA_NEEDED Exception</a></p>
</li>
</ul>
<a id="i52954"></a>
<div id="LNPLS915" class="sect2">
<h3 class="sect2">Overview of Table Functions</h3>
<p>A <a id="sthref1033"></a><span class="bold">table function</span> is a user-defined PL/SQL function that returns a collection of rows (a <a id="sthref1034"></a>nested table or <a id="sthref1035"></a>varray). You can select from this collection as if it were a database table by invoking the table function inside the <code dir="ltr">TABLE</code> clause in a <code dir="ltr">SELECT</code> statement. For example:</p>
<pre dir="ltr">
SELECT * FROM TABLE(<span class="italic">table_function_name</span>(<span class="italic">parameter_list</span>))
</pre>
<p>(For more information about the <code dir="ltr">TABLE</code> clause of the <code dir="ltr">SELECT</code> statement, see <a class="olink SQLRF55241" href="../../server.112/e41084/statements_10002.htm#SQLRF55241"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<p>A table function can take a collection of rows as input (that is, it can have an input parameter that is a nested table, varray, or cursor variable). Therefore, output from table function <code dir="ltr">tf1</code> can be input to table function <code dir="ltr">tf2</code>, and output from <code dir="ltr">tf2</code> can be input to table function <code dir="ltr">tf3</code>, and so on. For more information, see <a href="#BCGCBDGC">"Chaining Pipelined Table Functions"</a>.</p>
<p>To improve the performance of a table function, you can:</p>
<ul>
<li>
<p>Enable the function for parallel execution, with the <a id="sthref1036"></a><code dir="ltr">PARALLEL_ENABLE</code> option.</p>
<p>Functions enabled for parallel execution can run concurrently.</p>
</li>
<li>
<p>Stream the function results directly to the next process, with Oracle Streams.</p>
<p>Streaming eliminates intermediate staging between processes. For information about Oracle Streams, see <a class="olink STRMS001" href="../../server.112/e17069/strms_over.htm#STRMS001"><span class="italic">Oracle Streams Concepts and Administration</span></a>.</p>
</li>
<li>
<p>Pipeline the function results, with the <a id="sthref1037"></a><code dir="ltr">PIPELINED</code> option.</p>
<p>A <a id="sthref1038"></a><span class="bold">pipelined table function</span> returns a row to its invoker immediately after processing that row and continues to process rows. Response time improves because the entire collection need not be constructed and returned to the server before the query can return a single result row. (Also, the function needs less memory, because the object cache need not materialize the entire collection.)</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
A pipelined table function always references the current state of the data. If the data in the collection changes after the cursor opens for the collection, then the cursor reflects the changes. PL/SQL variables are private to a session and are not transactional. Therefore, read consistency, well known for its applicability to table data, does not apply to PL/SQL <a id="sthref1039"></a>collection variables.</div>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADDCI2140" href="../../appdev.112/e10765/pipe_paral_tbl.htm#ADDCI2140"><span class="italic">Oracle Database Data Cartridge Developer's Guide</span></a> for information about using pipelined and parallel table functions</div>
</div>
<!-- class="sect2" -->
<a id="i53109"></a>
<div id="LNPLS916" class="sect2">
<h3 class="sect2">Creating Pipelined Table Functions</h3>
<p>A pipelined table function must be either a standalone function or a package function.</p>
<p class="subhead2"><a id="LNPLS829"></a>PIPELINED Option (Required)</p>
<p>For a standalone function, specify the <a id="sthref1040"></a><code dir="ltr">PIPELINED</code> option in the <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> statement (for syntax, see <a href="create_function.htm#i2153260">"CREATE FUNCTION Statement"</a>). For a package function, specify the <code dir="ltr">PIPELINED</code> option in both the function declaration and function definition (for syntax, see <a href="function.htm#i34368">"Function Declaration and Definition"</a>).</p>
<p class="subhead2"><a id="LNPLS830"></a>PARALLEL_ENABLE Option (Recommended)</p>
<p>To improve its performance, enable the pipelined table function for parallel execution by specifying the <a id="sthref1041"></a><code dir="ltr">PARALLEL_ENABLE</code> option.</p>
<p class="subhead2"><a id="LNPLS831"></a>AUTONOMOUS_TRANSACTION Pragma</p>
<p>If the pipelined table function runs <a id="sthref1042"></a>DML statements, then make it autonomous, with the <a id="sthref1043"></a><a id="sthref1044"></a><code dir="ltr">AUTONOMOUS_TRANSACTION</code> pragma (described in <a href="autotransaction_pragma.htm#i32731">"AUTONOMOUS_TRANSACTION Pragma"</a>). Then, during parallel execution, each instance of the function creates an independent transaction.</p>
<p class="subhead2"><a id="LNPLS832"></a>DETERMINISTIC Option (Recommended)</p>
<p>Multiple invocations of a pipelined table function, in either the same query or separate queries, cause multiple executions of the underlying implementation. If the function is deterministic, specify the <a id="sthref1045"></a><code dir="ltr">DETERMINISTIC</code> option, described in <a href="function.htm#CJAFICJJ">"DETERMINISTIC"</a>.</p>
<p class="subhead2"><a id="LNPLS833"></a>Parameters</p>
<p>Typically, a pipelined table function has one or more cursor variable parameters. For information about cursor variables as function parameters, see <a href="static.htm#CIHIHFCJ">"Cursor Variables as Subprogram Parameters"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="static.htm#i7106">"Cursor Variables"</a> for general information about cursor variables</p>
</li>
<li>
<p><a href="subprograms.htm#i23202">"Subprogram Parameters"</a> for general information about subprogram parameters</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="LNPLS834"></a>RETURN Data Type</p>
<p>The data type of the value that a pipelined table function returns must be a collection type defined either at schema level or inside a package (therefore, it cannot be an <a id="sthref1046"></a>associative array type). The elements of the collection type must be SQL data types, not data types supported only by PL/SQL (such as <code dir="ltr">PLS_INTEGER</code> and <code dir="ltr">BOOLEAN</code>). For information about collection types, see <a href="composites.htm#CHDBHJEI">"Collection Types"</a>. For information about SQL data types, see <a class="olink SQLRF002" href="../../server.112/e41084/sql_elements.htm#SQLRF002"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>You can use SQL data types <a id="sthref1047"></a><code dir="ltr">ANYTYPE</code>, <a id="sthref1048"></a><code dir="ltr">ANYDATA</code>, and <a id="sthref1049"></a><code dir="ltr">ANYDATASET</code> to dynamically encapsulate and access type descriptions, data instances, and sets of data instances of any other SQL type, including object and collection types. You can also use these types to create unnamed types, including anonymous collection types. For information about these types, see <a class="olink ARPLS076" href="../../appdev.112/e40758/d_types.htm#ARPLS076"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<p class="subhead2"><a id="LNPLS835"></a>PIPE ROW Statement</p>
<p>Inside a pipelined table function, use the <a id="sthref1050"></a><code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement to return a collection element to the invoker without returning control to the invoker. See <a href="pipe_row_statement.htm#CJABEHCD">"PIPE ROW Statement"</a> for its syntax and semantics.</p>
<p class="subhead2"><a id="LNPLS836"></a>RETURN Statement</p>
<p>As in every function, every execution path in a pipelined table function must lead to a <code dir="ltr">RETURN</code> statement, which returns control to the invoker. However, in a pipelined table function, a <code dir="ltr">RETURN</code> statement need not return a value to the invoker. See <a href="return_statement.htm#i35913">"RETURN Statement"</a> for its syntax and semantics.</p>
<p class="subhead2"><a id="LNPLS837"></a>Example</p>
<p><a href="#BABDGCDH">Example 12-29</a> creates a package that includes a pipelined table function, <code dir="ltr">f1</code>, and then selects from the collection of rows that <code dir="ltr">f1</code> returns.</p>
<div id="LNPLS917" class="example">
<p class="titleinexample"><a id="BABDGCDH"></a>Example 12-29 Creating and Invoking Pipelined Table Function</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE pkg1 AS
  TYPE numset_t IS TABLE OF NUMBER;
  <span class="bold">FUNCTION f1(x NUMBER) RETURN numset_t PIPELINED;</span>
END pkg1;
/

CREATE PACKAGE BODY pkg1 AS
  -- FUNCTION f1 returns a collection of elements (1,2,3,... x)
  <span class="bold">FUNCTION f1(x NUMBER) RETURN numset_t PIPELINED IS</span>
  BEGIN
    FOR i IN 1..x LOOP
      <span class="bold">PIPE ROW(i);</span>
    END LOOP;
    <span class="bold">RETURN;</span>
  END f1;
END pkg1;
/

SELECT * FROM <span class="bold">TABLE(pkg1.f1(5)</span>);
</pre>
<p>Result:</p>
<pre dir="ltr">
COLUMN_VALUE
------------
           1
           2
           3
           4
           5
 
5 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABHAABE"></a>
<div id="LNPLS918" class="sect2">
<h3 class="sect2">Pipelined Table Functions as Transformation Functions</h3>
<p>A pipelined table function with a cursor variable parameter can serve as a transformation function. Using the cursor variable, the function fetches an input row. Using the <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement, the function pipes the transformed row or rows to the invoker. If the <code dir="ltr">FETCH</code> and <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statements are inside a <code dir="ltr">LOOP</code> statement, the function can transform multiple input rows.</p>
<p>In <a href="#BABIEICA">Example 12-30</a>, the pipelined table function transforms each selected row of the <code dir="ltr">employees</code> table to two nested table rows, which it pipes to the <code dir="ltr">SELECT</code> statement that invokes it. The actual parameter that corresponds to the formal cursor variable parameter is a <code dir="ltr">CURSOR</code> expression; for information about these, see <a href="#BCGHHFHJ">"Passing CURSOR Expressions to Pipelined Table Functions"</a>.</p>
<div id="LNPLS919" class="example">
<p class="titleinexample"><a id="BABIEICA"></a>Example 12-30 Pipelined Table Function Transforms Each Row to Two Rows</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE refcur_pkg IS
  TYPE refcur_t IS REF CURSOR RETURN employees%ROWTYPE;
  TYPE outrec_typ IS RECORD (
    var_num    NUMBER(6),
    var_char1  VARCHAR2(30),
    var_char2  VARCHAR2(30)
  );
  TYPE outrecset IS TABLE OF outrec_typ;
  FUNCTION f_trans (p refcur_t) RETURN outrecset PIPELINED;
END refcur_pkg;
/

CREATE OR REPLACE PACKAGE BODY refcur_pkg IS
  <span class="bold">FUNCTION f_trans (p refcur_t) RETURN outrecset PIPELINED IS</span>
    out_rec outrec_typ;
    in_rec  p%ROWTYPE;
  BEGIN
    LOOP
      <span class="bold">FETCH p INTO in_rec;  -- input row</span>
      EXIT WHEN p%NOTFOUND;

      out_rec.var_num := in_rec.employee_id;
      out_rec.var_char1 := in_rec.first_name;
      out_rec.var_char2 := in_rec.last_name;
      <span class="bold">PIPE ROW(out_rec);  -- first transformed output row</span>

      out_rec.var_char1 := in_rec.email;
      out_rec.var_char2 := in_rec.phone_number;
      <span class="bold">PIPE ROW(out_rec);  -- second transformed output row</span>
    END LOOP;
    CLOSE p;
    RETURN;
  END f_trans;
END refcur_pkg;
/

SELECT * FROM <span class="bold">TABLE (</span>
  <span class="bold">refcur_pkg.f_trans (</span>
    <span class="bold">CURSOR (SELECT * FROM employees WHERE department_id = 60)</span>
  <span class="bold">)</span>
);
</pre>
<p>Result:</p>
<pre dir="ltr">
   VAR_NUM VAR_CHAR1                      VAR_CHAR2
---------- ------------------------------ ------------------------------
       103 Alexander                      Hunold
       103 AHUNOLD                        590.423.4567
       104 Bruce                          Ernst
       104 BERNST                         590.423.4568
       105 David                          Austin
       105 DAUSTIN                        590.423.4569
       106 Valli                          Pataballa
       106 VPATABAL                       590.423.4560
       107 Diana                          Lorentz
       107 DLORENTZ                       590.423.5567

10 rows selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BCGCBDGC"></a>
<div id="LNPLS921" class="sect2">
<h3 class="sect2">Chaining Pipelined Table Functions</h3>
<p>To <span class="bold">chain</span> pipelined table functions <code dir="ltr">tf1</code> and <code dir="ltr">tf2</code> is to make the output of <code dir="ltr">tf1</code> the input of <code dir="ltr">tf2</code>. For example:</p>
<pre dir="ltr">
SELECT * FROM TABLE(tf2(CURSOR(SELECT * FROM TABLE(tf1()))));
</pre>
<p>The rows that <code dir="ltr">tf1</code> pipes out must be compatible actual parameters for the formal input parameters of <code dir="ltr">tf2</code>.</p>
<p>If chained pipelined table functions are enabled for parallel execution, then each function runs in a different process (or set of processes).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BCGHHFHJ">"Passing CURSOR Expressions to Pipelined Table Functions"</a></div>
</div>
<!-- class="sect2" -->
<a id="BCGGEBGI"></a>
<div id="LNPLS923" class="sect2">
<h3 class="sect2">Fetching from Results of Pipelined Table Functions</h3>
<p>You can associate a <a id="sthref1051"></a><a id="sthref1052"></a>named cursor with a query that invokes a pipelined table function. Such a cursor has no special fetch semantics, and such a cursor variable has no special assignment semantics.</p>
<p>However, the <a id="sthref1053"></a><a id="sthref1054"></a>SQL optimizer does not optimize across PL/SQL statements. Therefore, in <a href="#BABFHAIG">Example 12-31</a>, the first PL/SQL statement is slower than the second&mdash;despite the overhead of running two SQL statements in the second PL/SQL statement, and even if function results are piped between the two SQL statements in the first PL/SQL statement.</p>
<p>In <a href="#BABFHAIG">Example 12-31</a>, assume that <code dir="ltr">f</code> and <code dir="ltr">g</code> are pipelined table functions, and that each function accepts a cursor variable parameter. The first PL/SQL statement associates cursor variable <code dir="ltr">r</code> with a query that invokes <code dir="ltr">f</code>, and then passes <code dir="ltr">r</code> to <code dir="ltr">g</code>. The second PL/SQL statement passes <code dir="ltr">CURSOR</code> expressions to both <code dir="ltr">f</code> and <code dir="ltr">g</code>.</p>
<div id="LNPLS847" class="example">
<p class="titleinexample"><a id="BABFHAIG"></a>Example 12-31 Fetching from Results of Pipelined Table Functions</p>
<pre dir="ltr">
DECLARE
  r SYS_REFCURSOR;
  ...
  -- First PL/SQL statement (slower):
BEGIN
  OPEN r FOR SELECT * FROM TABLE(f(CURSOR(SELECT * FROM tab)));
  SELECT * BULK COLLECT INTO rec_tab FROM TABLE(g(r));

  -- NOTE: When g completes, it closes r.
END;

-- Second PL/SQL statement (faster):

SELECT * FROM TABLE(g(CURSOR(SELECT * FROM
  TABLE(f(CURSOR(SELECT * FROM tab))))));
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="static.htm#CIHIHFCJ">"Cursor Variables as Subprogram Parameters"</a></div>
</div>
<!-- class="sect2" -->
<a id="BCGHHFHJ"></a>
<div id="LNPLS924" class="sect2">
<h3 class="sect2">Passing CURSOR Expressions to Pipelined Table Functions</h3>
<p>As <a href="#BABFHAIG">Example 12-31</a> shows, the actual parameter for the cursor variable parameter of a pipelined table function can be either a cursor variable or a <a id="sthref1055"></a><a id="sthref1056"></a><code dir="ltr">CURSOR</code> expression, and the latter is more efficient.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a SQL <code dir="ltr">SELECT</code> statement passes a <code dir="ltr">CURSOR</code> expression to a function, the referenced cursor opens when the function begins to run and closes when the function completes.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="static.htm#i44913">"CURSOR Expressions"</a> for general information about <code dir="ltr">CURSOR</code> expressions</div>
<p><a href="#BABEIAIG">Example 12-32</a> creates a package that includes a pipelined table function with two cursor variable parameters and then invokes the function in a <code dir="ltr">SELECT</code> statement, using <code dir="ltr">CURSOR</code> expressions for actual parameters.</p>
<div id="LNPLS925" class="example">
<p class="titleinexample"><a id="BABEIAIG"></a>Example 12-32 Pipelined Table Function with Two Cursor Variable Parameters</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE refcur_pkg IS
  TYPE refcur_t1 IS REF CURSOR RETURN employees%ROWTYPE;
  TYPE refcur_t2 IS REF CURSOR RETURN departments%ROWTYPE;
  TYPE outrec_typ IS RECORD (
    var_num    NUMBER(6),
    var_char1  VARCHAR2(30),
    var_char2  VARCHAR2(30)
  );
  TYPE outrecset IS TABLE OF outrec_typ;
  <span class="bold">FUNCTION g_trans (p1 refcur_t1, p2 refcur_t2) RETURN outrecset PIPELINED;</span>
END refcur_pkg;
/

CREATE PACKAGE BODY refcur_pkg IS
  FUNCTION g_trans (
    p1 refcur_t1,
    p2 refcur_t2
  ) RETURN outrecset PIPELINED
  IS
    out_rec outrec_typ;
    in_rec1 p1%ROWTYPE;
    in_rec2 p2%ROWTYPE;
  BEGIN
    LOOP
      FETCH p2 INTO in_rec2;
      EXIT WHEN p2%NOTFOUND;
    END LOOP;
    CLOSE p2;
    LOOP
      FETCH p1 INTO in_rec1;
      EXIT WHEN p1%NOTFOUND;
      -- first row
      out_rec.var_num := in_rec1.employee_id;
      out_rec.var_char1 := in_rec1.first_name;
      out_rec.var_char2 := in_rec1.last_name;
      PIPE ROW(out_rec);
      -- second row
      out_rec.var_num := in_rec2.department_id;
      out_rec.var_char1 := in_rec2.department_name;
      out_rec.var_char2 := TO_CHAR(in_rec2.location_id);
      PIPE ROW(out_rec);
    END LOOP;
    CLOSE p1;
    RETURN;
  END g_trans;
END refcur_pkg;
/

SELECT * FROM TABLE (
  refcur_pkg.g_trans (
    <span class="bold">CURSOR (SELECT * FROM employees WHERE department_id = 60)</span>,
    <span class="bold">CURSOR (SELECT * FROM departments WHERE department_id = 60)</span>
  )
);
</pre>
<p>Result:</p>
<pre dir="ltr">
   VAR_NUM VAR_CHAR1                      VAR_CHAR2
---------- ------------------------------ ------------------------------
       103 Alexander                      Hunold
        60 IT                             1400
       104 Bruce                          Ernst
        60 IT                             1400
       105 David                          Austin
        60 IT                             1400
       106 Valli                          Pataballa
        60 IT                             1400
       107 Diana                          Lorentz
        60 IT                             1400
 
10 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#BABEEIHA">Example 12-33</a> uses a pipelined table function as an <a id="sthref1057"></a><a id="sthref1058"></a>aggregate function, which takes a set of input rows and returns a single result. The <code dir="ltr">SELECT</code> statement selects the function result. (For information about the pseudocolumn <code dir="ltr">COLUMN_VALUE</code>, see <a class="olink SQLRF50950" href="../../server.112/e41084/pseudocolumns004.htm#SQLRF50950"><span class="italic">Oracle Database SQL Language Reference</span></a>.)</p>
<div id="LNPLS926" class="example">
<p class="titleinexample"><a id="BABEEIHA"></a>Example 12-33 Pipelined Table Function as Aggregate Function</p>
<pre dir="ltr">
DROP TABLE gradereport;
CREATE TABLE gradereport (
  student VARCHAR2(30),
  subject VARCHAR2(30),
  weight NUMBER,
  grade NUMBER
);

INSERT INTO gradereport (student, subject, weight, grade)
VALUES ('Mark', 'Physics', 4, 4);
 
INSERT INTO gradereport (student, subject, weight, grade) 
VALUES ('Mark','Chemistry', 4, 3);
 
INSERT INTO gradereport (student, subject, weight, grade) 
VALUES ('Mark','Maths', 3, 3);
 
INSERT INTO gradereport (student, subject, weight, grade) 
VALUES ('Mark','Economics', 3, 4);

CREATE PACKAGE pkg_gpa IS
  TYPE gpa IS TABLE OF NUMBER;
  FUNCTION weighted_average(input_values SYS_REFCURSOR)
    RETURN gpa PIPELINED;
END pkg_gpa;
/

CREATE PACKAGE BODY pkg_gpa IS
  <span class="bold">FUNCTION weighted_average (input_values SYS_REFCURSOR)</span>
    <span class="bold">RETURN gpa PIPELINED</span>
  IS
    grade         NUMBER;
    total         NUMBER := 0;
    total_weight  NUMBER := 0;
    weight        NUMBER := 0;
  BEGIN
    <span class="bold">LOOP</span>
      <span class="bold">FETCH input_values INTO weight, grade;</span>
      <span class="bold">EXIT WHEN input_values%NOTFOUND;</span>
      total_weight := total_weight + weight;  -- Accumulate weighted average
      total := total + grade*weight;
    END LOOP;
    <span class="bold">PIPE ROW (total / total_weight);</span>
    RETURN; -- returns single result
  END weighted_average;
END pkg_gpa;
/

SELECT w.<span class="bold">column_value</span> "weighted result" FROM TABLE (
  pkg_gpa.weighted_average (
    <span class="bold">CURSOR (SELECT weight, grade FROM gradereport)</span>
  )
) w;
</pre>
<p>Result:</p>
<pre dir="ltr">
weighted result
---------------
            3.5
 
1 row selected.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i53293"></a>
<div id="LNPLS928" class="sect2">
<h3 class="sect2">DML Statements on Pipelined Table Function Results</h3>
<p><a id="sthref1059"></a>The "table" that a pipelined table function returns cannot be the target table of a <code dir="ltr">DELETE</code>, <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">MERGE</code> statement. However, you can create a view of such a table and create <a id="sthref1060"></a><code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers on the view. For information about <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers, see <a href="triggers.htm#i1006376">"INSTEAD OF DML Triggers"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01504" href="../../server.112/e41084/statements_8004.htm#SQLRF01504"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="BCGGJECI"></a>
<div id="LNPLS929" class="sect2">
<h3 class="sect2">NO_DATA_NEEDED Exception</h3>
<p>You must understand the predefined exception <a id="sthref1061"></a><code dir="ltr">NO_DATA_NEEDED</code> in two cases:</p>
<ul>
<li>
<p>You include an <code dir="ltr">OTHERS</code> <a id="sthref1062"></a>exception handler in a block that includes a <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement</p>
</li>
<li>
<p>Your code that feeds a <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement must be followed by a clean-up procedure</p>
<p>Typically, the clean-up procedure releases resources that the code no longer needs.</p>
</li>
</ul>
<p>When the invoker of a pipelined table function needs no more rows from the function, the <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement raises <code dir="ltr">NO_DATA_NEEDED</code>. If the pipelined table function does not handle <code dir="ltr">NO_DATA_NEEDED</code>, as in <a href="#CHDEEGJD">Example 12-34</a>, then the function invocation terminates but the invoking statement does not terminate. If the pipelined table function handles <code dir="ltr">NO_DATA_NEEDED</code>, its exception handler can release the resources that it no longer needs, as in <a href="#CHDIAFFB">Example 12-35</a>.</p>
<p>In <a href="#CHDEEGJD">Example 12-34</a>, the pipelined table function <code dir="ltr">pipe_rows</code> does not handle the <code dir="ltr">NO_DATA_NEEDED</code> exception. The <code dir="ltr">SELECT</code> statement that invokes <code dir="ltr">pipe_rows</code> needs only four rows. Therefore, during the fifth invocation of <code dir="ltr">pipe_rows</code>, the <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement raises the exception <code dir="ltr">NO_DATA_NEEDED</code>. The fifth invocation of <code dir="ltr">pipe_rows</code> terminates, but the <code dir="ltr">SELECT</code> statement does not terminate.</p>
<div id="LNPLS855" class="example">
<p class="titleinexample"><a id="CHDEEGJD"></a>Example 12-34 Pipelined Table Function Does Not Handle NO_DATA_NEEDED</p>
<pre dir="ltr">
CREATE TYPE t IS TABLE OF NUMBER
/
CREATE OR REPLACE FUNCTION pipe_rows RETURN t PIPELINED IS
  n NUMBER := 0;
BEGIN
  LOOP
    n := n + 1;
    PIPE ROW (n);
  END LOOP;
END pipe_rows;
/
SELECT COLUMN_VALUE
  <span class="bold">FROM TABLE(pipe_rows())</span>
  <span class="bold">WHERE ROWNUM &lt; 5</span>
/
</pre>
<p>Result:</p>
<pre dir="ltr">
COLUMN_VALUE
------------
           1
           2
           3
           4

4 rows selected.
</pre></div>
<!-- class="example" -->
<p>If the exception-handling part of a block that includes a <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement includes an <code dir="ltr">OTHERS</code> exception handler to handle unexpected exceptions, then it must also include an exception handler for the expected <code dir="ltr">NO_DATA_NEEDED</code> exception. Otherwise, the <code dir="ltr">OTHERS</code> exception handler handles the <code dir="ltr">NO_DATA_NEEDED</code> exception, treating it as an unexpected error. The following exception handler reraises the <code dir="ltr">NO_DATA_NEEDED</code> exception, instead of treating it as a irrecoverable error:</p>
<pre dir="ltr">
EXCEPTION
  <span class="bold">WHEN NO_DATA_NEEDED THEN</span>
    <span class="bold">RAISE;</span>
  WHEN OTHERS THEN
    -- (Put error-logging code here)
    RAISE_APPLICATION_ERROR(-20000, 'Fatal error.');
END;
</pre>
<p>In <a href="#CHDIAFFB">Example 12-35</a>, assume that the package <code dir="ltr">External_Source</code> contains these public items:</p>
<ul>
<li>
<p>Procedure <code dir="ltr">Init</code>, which allocates and initializes the resources that <code dir="ltr">Next_Row</code> needs</p>
</li>
<li>
<p>Function <code dir="ltr">Next_Row</code>, which returns some data from a specific external source and raises the user-defined exception <code dir="ltr">Done</code> (which is also a public item in the package) when the external source has no more data</p>
</li>
<li>
<p>Procedure <code dir="ltr">Clean_Up</code>, which releases the resources that <code dir="ltr">Init</code> allocated</p>
</li>
</ul>
<p>The pipelined table function <code dir="ltr">get_external_source_data</code> pipes rows from the external source by invoking <code dir="ltr">External_Source.Next_Row</code> until either:</p>
<ul>
<li>
<p>The external source has no more rows.</p>
<p>In this case, the <code dir="ltr">External_Source.Next_Row</code> function raises the user-defined exception <code dir="ltr">External_Source.Done</code>.</p>
</li>
<li>
<p><code dir="ltr">get_external_source_data</code> needs no more rows.</p>
<p>In this case, the <code dir="ltr">PIPE</code> <code dir="ltr">ROW</code> statement in <code dir="ltr">get_external_source_data</code> raises the <code dir="ltr">NO_DATA_NEEDED</code> exception.</p>
</li>
</ul>
<p>In either case, an exception handler in block <code dir="ltr">b</code> in <code dir="ltr">get_external_source_data</code> invokes <code dir="ltr">External_Source.Clean_Up</code>, which releases the resources that <code dir="ltr">Next_Row</code> was using.</p>
<div id="LNPLS857" class="example">
<p class="titleinexample"><a id="CHDIAFFB"></a>Example 12-35 Pipelined Table Function Handles NO_DATA_NEEDED</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION get_external_source_data
  RETURN t AUTHID DEFINER PIPELINED IS
BEGIN
  External_Source.Init();           -- Initialize.
  &lt;&lt;b&gt;&gt; BEGIN
    LOOP                            -- Pipe rows from external source.
      PIPE ROW (External_Source.Next_Row());
    END LOOP;
  <span class="bold">EXCEPTION</span>
    WHEN External_Source.Done THEN  -- When no more rows are available,
      External_Source.Clean_Up();   --  clean up.
    WHEN <span class="bold">NO_DATA_NEEDED</span> THEN        -- When no more rows are needed,
      External_Source.Clean_Up();   --  clean up.
      RAISE NO_DATA_NEEDED;           -- Optional, equivalent to RETURN.
  END b;
END get_external_source_data;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCFCJC"></a>
<div id="LNPLS930" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Updating Large Tables in Parallel</h2>
<p>The <a id="sthref1063"></a><a id="sthref1064"></a><a id="sthref1065"></a><code dir="ltr">DBMS_PARALLEL_EXECUTE</code> package enables you to incrementally update the data in a large <a id="sthref1066"></a>table in parallel, in two high-level steps:</p>
<ol>
<li>
<p>Group sets of rows in the table into smaller chunks.</p>
</li>
<li>
<p>Apply the desired <code dir="ltr">UPDATE</code> statement to the chunks in parallel, committing each time you have finished processing a chunk.</p>
</li>
</ol>
<p>This technique is recommended whenever you are updating a lot of data. Its advantages are:</p>
<ul>
<li>
<p>You lock only one set of rows at a time, for a relatively short time, instead of locking the entire table.</p>
</li>
<li>
<p>You do not lose work that has been done if something fails before the entire operation finishes.</p>
</li>
<li>
<p>You reduce rollback space consumption.</p>
</li>
<li>
<p>You improve performance.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS233" href="../../appdev.112/e40758/d_parallel_ex.htm#ARPLS233"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> package</div>
</div>
<!-- class="sect1" -->
<a id="g3143398"></a>
<div id="LNPLS01213" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Collecting Data About User-Defined Identifiers</h2>
<p><a id="sthref1067"></a>PL/Scope extracts, organizes, and stores data about <a id="sthref1068"></a><a id="sthref1069"></a>user-defined identifiers from PL/SQL source text. You can retrieve source text identifier data with the static data dictionary views <code dir="ltr">*_IDENTIFIERS</code>. For more information, see <a class="olink ADFNS022" href="../../appdev.112/e41502/adfns_plscope.htm#ADFNS022"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
</div>
<!-- class="sect1" -->
<a id="i48283"></a>
<div id="LNPLS01214" class="sect1"><!-- infotype="Concept" -->
<h2 class="sect1">Profiling and Tracing PL/SQL Programs</h2>
<p><a id="sthref1070"></a><a id="sthref1071"></a>To help you isolate performance problems in large PL/SQL programs, PL/SQL provides these tools, implemented as PL/SQL packages:</p>
<div class="inftblinformal">
<table class="cellalignment1089" title="Profiling and Tracing Tools" summary="This table summarizes the profiling and tracing tools." dir="ltr">
<thead>
<tr class="cellalignment1083">
<th class="cellalignment1090" id="r1c1-t35">Tool</th>
<th class="cellalignment1090" id="r1c2-t35">Package</th>
<th class="cellalignment1090" id="r1c3-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r2c1-t35" headers="r1c1-t35">Profiler API</td>
<td class="cellalignment1091" headers="r2c1-t35 r1c2-t35"><code dir="ltr">DBMS_PROFILER</code></td>
<td class="cellalignment1091" headers="r2c1-t35 r1c3-t35">Computes the time that your PL/SQL program spends at each line and in each subprogram.
<p>You must have <code dir="ltr">CREATE</code> privileges on the units to be profiled.</p>
<p>Saves runtime statistics in database tables, which you can query.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r3c1-t35" headers="r1c1-t35">Trace API</td>
<td class="cellalignment1091" headers="r3c1-t35 r1c2-t35"><code dir="ltr">DBMS_TRACE</code></td>
<td class="cellalignment1091" headers="r3c1-t35 r1c3-t35">Traces the order in which subprograms run.
<p>You can specify the subprograms to trace and the tracing level.</p>
<p>Saves runtime statistics in database tables, which you can query.</p>
</td>
</tr>
<tr class="cellalignment1083">
<td class="cellalignment1091" id="r4c1-t35" headers="r1c1-t35">PL/SQL hierarchical profiler</td>
<td class="cellalignment1091" headers="r4c1-t35 r1c2-t35"><code dir="ltr">DBMS_HPROF</code></td>
<td class="cellalignment1091" headers="r4c1-t35 r1c3-t35">Reports the dynamic execution program profile of your PL/SQL program, organized by subprogram invocations. Accounts for SQL and PL/SQL execution times separately.
<p>Requires no special source or compile-time preparation.</p>
<p>Generates reports in HTML. Provides the option of storing results in relational format in database tables for custom report generation (such as third-party tools offer).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="LNPLS859"></a>Topics</p>
<ul>
<li>
<p><a href="#BABDACHA">Profiler API: Package DBMS_PROFILER</a></p>
</li>
<li>
<p><a href="#BABFBIEJ">Trace API: Package DBMS_TRACE</a></p>
</li>
</ul>
<p>For a detailed description of PL/SQL hierarchical profiler, see <a class="olink ADFNS023" href="../../appdev.112/e41502/adfns_profiler.htm#ADFNS023"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
<a id="BABDACHA"></a>
<div id="LNPLS877" class="sect2">
<h3 class="sect2">Profiler API: Package DBMS_PROFILER</h3>
<p><a id="sthref1072"></a><a id="sthref1073"></a>The Profiler API ("Profiler") is implemented as PL/SQL package <code dir="ltr">DBMS_PROFILER</code>, whose services compute the time that your PL/SQL program spends at each line and in each subprogram and save these statistics in database tables, which you can query.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use Profiler only on units for which you have CREATE privilege. You do not need the CREATE privilege to use the PL/SQL hierarchical profiler (see <a class="olink ADFNS023" href="../../appdev.112/e41502/adfns_profiler.htm#ADFNS023"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>).</div>
<p>To use Profiler:</p>
<ol>
<li>
<p>Start the profiling session.</p>
</li>
<li>
<p>Run your PL/SQL program long enough to get adequate code coverage.</p>
</li>
<li>
<p>Flush the collected data to the database.</p>
</li>
<li>
<p>Stop the profiling session.</p>
</li>
</ol>
<p>After you have collected data with Profiler, you can:</p>
<ol>
<li>
<p>Query the database tables that contain the performance data.</p>
</li>
<li>
<p>Identify the subprograms and packages that use the most execution time.</p>
</li>
<li>
<p>Determine why your program spent more time accessing certain data structures and running certain code segments.</p>
<p>Inspect possible performance bottlenecks such as SQL statements, loops, and recursive functions.</p>
</li>
<li>
<p>Use the results of your analysis to replace inappropriate data structures and rework slow algorithms.</p>
<p>For example, with an exponential growth in data, you might need to replace a linear search with a binary search.</p>
</li>
</ol>
<p>For detailed information about the <code dir="ltr">DBMS_PROFILER</code> subprograms, see <a class="olink ARPLS060" href="../../appdev.112/e40758/d_trace.htm#ARPLS060"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABFBIEJ"></a>
<div id="LNPLS878" class="sect2">
<h3 class="sect2">Trace API: Package DBMS_TRACE</h3>
<p><a id="sthref1074"></a><a id="sthref1075"></a>The Trace API ("Trace") is implemented as PL/SQL package <code dir="ltr">DBMS_TRACE</code>, whose services trace execution by subprogram or exception and save these statistics in database tables, which you can query.</p>
<p>To use Trace:</p>
<ol>
<li>
<p>(Optional) Limit tracing to specific subprograms and choose a tracing level.</p>
<p>Tracing all subprograms and exceptions in a large program can produce huge amounts of data that are difficult to manage.</p>
</li>
<li>
<p>Start the tracing session.</p>
</li>
<li>
<p>Run your PL/SQL program.</p>
</li>
<li>
<p>Stop the tracing session.</p>
</li>
</ol>
<p>After you have collected data with Trace, you can query the database tables that contain the performance data and analyze it in the same way that you analyze the performance data from Profiler (see <a href="#BABDACHA">"Profiler API: Package DBMS_PROFILER"</a>).</p>
<p>For detailed information about the <code dir="ltr">DBMS_TRACE</code> subprograms, see <a class="olink ARPLS060" href="../../appdev.112/e40758/d_trace.htm#ARPLS060"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i48528"></a>
<div id="LNPLS01209" class="sect1">
<h2 class="sect1">Compiling PL/SQL Units for Native Execution</h2>
<p><a id="sthref1076"></a><a id="sthref1077"></a>You can usually speed up PL/SQL units by compiling them into native code (processor-dependent system code), which is stored in the SYSTEM tablespace.</p>
<p>You can natively compile any PL/SQL unit of any type, including those that Oracle Database supplies.</p>
<p>Natively compiled program units work in all server environments, including shared server configuration (formerly called "multithreaded server") and Oracle Real Application Clusters (Oracle RAC).</p>
<p>On most platforms, PL/SQL native compilation requires no special set-up or maintenance. On some platforms, the DBA might want to do some optional configuration.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN002" href="../../server.112/e25494/create.htm#ADMIN002"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about configuring a database</p>
</li>
<li>
<p>Platform-specific configuration documentation for your platform</p>
</li>
</ul>
</div>
<p>You can test to see how much performance gain you can get by enabling PL/SQL native compilation.</p>
<p>If you have determined that PL/SQL native compilation will provide significant performance gains in database operations, Oracle recommends compiling the entire database for native mode, which requires DBA privileges. This speeds up both your own code and calls to the PL/SQL packages that Oracle Database supplies.</p>
<p class="subhead2"><a id="LNPLS871"></a>Topics</p>
<ul>
<li>
<p><a href="#BABIBCBE">Determining Whether to Use PL/SQL Native Compilation</a></p>
</li>
<li>
<p><a href="#BCGFAJCD">How PL/SQL Native Compilation Works</a></p>
</li>
<li>
<p><a href="#BCGFDIEJ">Dependencies, Invalidation, and Revalidation</a></p>
</li>
<li>
<p><a href="#BCGCHEFF">Setting Up a New Database for PL/SQL Native Compilation</a>*</p>
</li>
<li>
<p><a href="#BABEJGDI">Compiling the Entire Database for PL/SQL Native or Interpreted Compilation</a>*</p>
</li>
</ul>
<p>* Requires DBA privileges.</p>
<a id="BABIBCBE"></a>
<div id="LNPLS910" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Determining Whether to Use PL/SQL Native Compilation</h3>
<p>Whether to compile a PL/SQL unit for native or interpreted mode depends on where you are in the development cycle and on what the program unit does.</p>
<p>While you are debugging program units and recompiling them frequently, interpreted mode has these advantages:</p>
<ul>
<li>
<p>You can use PL/SQL debugging tools on program units compiled for interpreted mode (but not for those compiled for native mode).</p>
</li>
<li>
<p>Compiling for interpreted mode is faster than compiling for native mode.</p>
</li>
</ul>
<p>After the debugging phase of development, in determining whether to compile a PL/SQL unit for native mode, consider:</p>
<ul>
<li>
<p>PL/SQL native compilation provides the greatest performance gains for computation-intensive procedural operations. Examples are data warehouse applications and applications with extensive server-side transformations of data for display.</p>
</li>
<li>
<p>PL/SQL native compilation provides the least performance gains for PL/SQL subprograms that spend most of their time running SQL.</p>
</li>
<li>
<p>When many program units (typically over 15,000) are compiled for native execution, and are simultaneously active, the large amount of shared memory required might affect system performance.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BCGFAJCD"></a>
<div id="LNPLS911" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">How PL/SQL Native Compilation Works</h3>
<p>Without native compilation, the PL/SQL statements in a PL/SQL unit are compiled into an intermediate form, system code, which is stored in the catalog and interpreted at run time.</p>
<p>With PL/SQL native compilation, the PL/SQL statements in a PL/SQL unit are compiled into native code and stored in the catalog. The native code need not be interpreted at run time, so it runs faster.</p>
<p>Because native compilation applies only to PL/SQL statements, a PL/SQL unit that uses only SQL statements might not run faster when natively compiled, but it does run at least as fast as the corresponding interpreted code. The compiled code and the interpreted code make the same library calls, so their action is the same.</p>
<p>The first time a natively compiled PL/SQL unit runs, it is fetched from the SYSTEM tablespace into shared memory. Regardless of how many sessions invoke the program unit, shared memory has only one copy it. If a program unit is not being used, the shared memory it is using might be freed, to reduce memory load.</p>
<p>Natively compiled subprograms and interpreted subprograms can invoke each other.</p>
<p>PL/SQL native compilation works transparently in an Oracle Real Application Clusters (Oracle RAC) environment.</p>
<p>The <code dir="ltr">PLSQL_CODE_TYPE</code> compilation parameter determines whether PL/SQL code is natively compiled or interpreted. For information about this compilation parameters, see <a href="overview.htm#BABBDFJF">"PL/SQL Units and Compilation Parameters"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BCGFDIEJ"></a>
<div id="LNPLS912" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Dependencies, Invalidation, and Revalidation</h3>
<p>Recompilation is automatic with invalidated PL/SQL modules. For example, if an object on which a natively compiled PL/SQL subprogram depends changes, the subprogram is invalidated. The next time the same subprogram is called, the database recompiles the subprogram automatically. Because the <code dir="ltr">PLSQL_CODE_TYPE</code> setting is stored inside the library unit for each subprogram, the automatic recompilation uses this stored setting for code type.</p>
<p>Explicit recompilation does not necessarily use the stored <code dir="ltr">PLSQL_CODE_TYPE</code> setting. For the conditions under which explicit recompilation uses stored settings, see <a href="overview.htm#BABBDFJF">"PL/SQL Units and Compilation Parameters"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BCGCHEFF"></a>
<div id="LNPLS913" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Setting Up a New Database for PL/SQL Native Compilation</h3>
<p>If you have DBA privileges, you can set up a new database for PL/SQL native compilation by setting the compilation parameter <code dir="ltr">PLSQL_CODE_TYPE</code> to <code dir="ltr">NATIVE</code>. The performance benefits apply to the PL/SQL packages that Oracle Database supplies, which are used for many database operations.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you compile the whole database as <code dir="ltr">NATIVE</code>, Oracle recommends that you set <code dir="ltr">PLSQL_CODE_TYPE</code> at the system level.</div>
</div>
<!-- class="sect2" -->
<a id="BABEJGDI"></a>
<div id="LNPLS914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Compiling the Entire Database for PL/SQL Native or Interpreted Compilation</h3>
<p>If you have DBA privileges, you can recompile all PL/SQL modules in an existing database to <code dir="ltr">NATIVE</code> or <code dir="ltr">INTERPRETED</code>, using the <a id="sthref1078"></a><code dir="ltr">dbmsupgnv</code>.<code dir="ltr">sql</code> and <a id="sthref1079"></a><code dir="ltr">dbmsupgin</code>.<code dir="ltr">sql</code> scripts respectively during the process explained in this section. Before making the conversion, review <a href="#BABIBCBE">"Determining Whether to Use PL/SQL Native Compilation"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you compile the whole database as <code dir="ltr">NATIVE</code>, Oracle recommends that you set <code dir="ltr">PLSQL_CODE_TYPE</code> at the system level.</div>
<p>During the conversion to native compilation, <code dir="ltr">TYPE</code> specifications are not recompiled by <code dir="ltr">dbmsupgnv</code>.<code dir="ltr">sql</code> to <code dir="ltr">NATIVE</code> because these specifications do not contain executable code.</p>
<p>Package specifications seldom contain executable code so the runtime benefits of compiling to <code dir="ltr">NATIVE</code> are not measurable. You can use the <code dir="ltr">TRUE</code> command-line parameter with the <code dir="ltr">dbmsupgnv</code>.<code dir="ltr">sql</code> script to exclude package specs from recompilation to <code dir="ltr">NATIVE</code>, saving time in the conversion process.</p>
<p>When converting to interpreted compilation, the <code dir="ltr">dbmsupgin</code>.<code dir="ltr">sql</code> script does not accept any parameters and does not exclude any PL/SQL units.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The following procedure describes the conversion to native compilation. If you must recompile all PL/SQL modules to <a id="sthref1080"></a><a id="sthref1081"></a>interpreted compilation, make these changes in the steps.
<ul>
<li>
<p>Skip the first step.</p>
</li>
<li>
<p>Set the <code dir="ltr">PLSQL_CODE_TYPE</code> compilation parameter to <code dir="ltr">INTERPRETED</code> rather than <code dir="ltr">NATIVE</code>.</p>
</li>
<li>
<p>Substitute <code dir="ltr">dbmsupgin</code>.<code dir="ltr">sql</code> for the <code dir="ltr">dbmsupgnv</code>.<code dir="ltr">sql</code> script.</p>
</li>
</ul>
</div>
<ol>
<li>
<p>Ensure that a test PL/SQL unit can be compiled. For example:</p>
<pre dir="ltr">
ALTER PROCEDURE my_proc COMPILE PLSQL_CODE_TYPE=NATIVE REUSE SETTINGS;
</pre></li>
<li>
<p>Shut down application services, the listener, and the database.</p>
<ul>
<li>
<p>Shut down all of the Application services including the Forms Processes, Web Servers, Reports Servers, and Concurrent Manager Servers. After shutting down all of the Application services, ensure that all of the connections to the database were terminated.</p>
</li>
<li>
<p>Shut down the TNS listener of the database to ensure that no new connections are made.</p>
</li>
<li>
<p>Shut down the database in normal or immediate mode as the user <code dir="ltr">SYS</code>. See <a class="olink ADMIN004" href="../../server.112/e25494/start.htm#ADMIN004"><span class="italic">Oracle Database Administrator's Guide</span></a>.</p>
</li>
</ul>
</li>
<li>
<p>Set <code dir="ltr">PLSQL_CODE_TYPE</code> to <code dir="ltr">NATIVE</code> in the compilation parameter file. If the database is using a server parameter file, then set this after the database has started.</p>
<p>The value of <code dir="ltr">PLSQL_CODE_TYPE</code> does not affect the conversion of the PL/SQL units in these steps. However, it does affect all subsequently compiled units, so explicitly set it to the desired compilation type.</p>
</li>
<li>
<p>Start up the database in upgrade mode, using the <code dir="ltr">UPGRADE</code> option. For information about SQL*Plus <code dir="ltr">STARTUP</code>, see <a class="olink SQPUG127" href="../../server.112/e16604/ch_twelve044.htm#SQPUG127"><span class="italic">SQL*Plus User's Guide and Reference</span></a>.</p>
</li>
<li id="BCGJBEHE">
<p>Run this code to list the invalid PL/SQL units. You can save the output of the query for future reference with the SQL <code dir="ltr">SPOOL</code> statement:</p>
<pre dir="ltr">
-- To save the output of the query to a file:
  <span class="bold">SPOOL pre_update_invalid.log</span>
SELECT o.OWNER, o.OBJECT_NAME, o.OBJECT_TYPE 
FROM DBA_OBJECTS o, DBA_PLSQL_OBJECT_SETTINGS s 
WHERE o.OBJECT_NAME = s.NAME AND o.STATUS='INVALID';
-- To stop spooling the output: <span class="bold">SPOOL OFF</span>
</pre>
<p>If any Oracle supplied units are invalid, try to validate them by recompiling them. For example:</p>
<pre dir="ltr">
ALTER PACKAGE SYS.DBMS_OUTPUT COMPILE BODY REUSE SETTINGS;
</pre>
<p>If the units cannot be validated, save the spooled log for future resolution and continue.</p>
</li>
<li id="BCGBFAEE">
<p>Run this query to determine how many objects are compiled <code dir="ltr">NATIVE</code> and <code dir="ltr">INTERPRETED</code> (to save the output, use the SQL <code dir="ltr">SPOOL</code> statement):</p>
<pre dir="ltr">
SELECT TYPE, PLSQL_CODE_TYPE, COUNT(*)
FROM DBA_PLSQL_OBJECT_SETTINGS
WHERE PLSQL_CODE_TYPE IS NOT NULL
GROUP BY TYPE, PLSQL_CODE_TYPE
ORDER BY TYPE, PLSQL_CODE_TYPE;
</pre>
<p>Any objects with a <code dir="ltr">NULL</code> <code dir="ltr">plsql_code_type</code> are special internal objects and can be ignored.</p>
</li>
<li>
<p>Run the <code dir="ltr">$ORACLE_HOME/rdbms/admin/dbmsupgnv</code>.<code dir="ltr">sql</code> script as the user <code dir="ltr">SYS</code> to update the <code dir="ltr">plsql_code_type</code> setting to <code dir="ltr">NATIVE</code> in the dictionary tables for all PL/SQL units. This process also invalidates the units. Use <code dir="ltr">TRUE</code> with the script to exclude package specifications; <code dir="ltr">FALSE</code> to include the package specifications.</p>
<p>This update must be done when the database is in <code dir="ltr">UPGRADE</code> mode. The script is guaranteed to complete successfully or rollback all the changes.</p>
</li>
<li>
<p>Shut down the database and restart in <code dir="ltr">NORMAL</code> mode.</p>
</li>
<li>
<p>Before you run the <code dir="ltr">utlrp</code>.<code dir="ltr">sql</code> script, Oracle recommends that no other sessions are connected to avoid possible problems. You can ensure this with this statement:</p>
<pre dir="ltr">
ALTER SYSTEM ENABLE RESTRICTED SESSION;
</pre></li>
<li>
<p>Run the <a id="sthref1082"></a><code dir="ltr">$ORACLE_HOME/rdbms/admin/utlrp</code>.<code dir="ltr">sql</code> script as the user <code dir="ltr">SYS</code>. This script recompiles all the PL/SQL modules using a default degree of parallelism. See the comments in the script for information about setting the degree explicitly.</p>
<p>If for any reason the script is abnormally terminated, rerun the <code dir="ltr">utlrp</code>.<code dir="ltr">sql</code> script to recompile any remaining invalid PL/SQL modules.</p>
</li>
<li>
<p>After the compilation completes successfully, verify that there are no invalid PL/SQL units using the query in step <a href="#BCGJBEHE">5</a>. You can spool the output of the query to the <code dir="ltr">post_upgrade_invalid</code>.<code dir="ltr">log</code> file and compare the contents with the <code dir="ltr">pre_upgrade_invalid</code>.<code dir="ltr">log</code> file, if it was created previously.</p>
</li>
<li>
<p>Reexecute the query in step <a href="#BCGBFAEE">6</a>. If recompiling with <code dir="ltr">dbmsupgnv</code>.<code dir="ltr">sql</code>, confirm that all PL/SQL units, except <code dir="ltr">TYPE</code> specifications and package specifications if excluded, are <code dir="ltr">NATIVE</code>. If recompiling with <code dir="ltr">dbmsupgin</code>.<code dir="ltr">sql</code>, confirm that all PL/SQL units are <code dir="ltr">INTERPRETED</code>.</p>
</li>
<li>
<p>Disable the restricted session mode for the database, then start the services that you previously shut down. To disable restricted session mode, use this statement:</p>
<pre dir="ltr">
ALTER SYSTEM DISABLE RESTRICTED SESSION;
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1082">
<tr>
<td class="cellalignment1091">
<table class="cellalignment1087">
<tr>
<td class="cellalignment1086"><a href="errors.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1086"><a href="langelems.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1094">
<table class="cellalignment1085">
<tr>
<td class="cellalignment1086"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1086"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1086"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1086"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1086"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1086"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
