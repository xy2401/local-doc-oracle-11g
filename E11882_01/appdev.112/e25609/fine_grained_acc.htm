<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Fine-Grained Access Control for RDF Data</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743" />
<meta name="description" content="Provides usage and reference information about Oracle Database support for semantic technologies, including storage, inference, and query capabilities for data and ontologies based on Resource Description Framework (RDF), RDF Schema (RDFS), and Web Ontology Language (OWL)." />
<meta name="dcterms.created" content="2014-01-26T18:14:11Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Semantic Technologies Developer's Guide" />
<meta name="dcterms.identifier" content="E25609-06" />
<meta name="dcterms.isVersionOf" content="RDFRM" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="sem_glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="indexing_for_docs.htm" title="Previous" type="text/html" />
<link rel="Next" href="workspace_mgr.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25609.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">13/26</span> <!-- End Header -->
<div id="RDFRM99941" class="chapter"><a id="CIHCJDHD"></a>
<h1 class="chapter"><span class="secnum">5</span> Fine-Grained Access Control for RDF Data</h1>
<p>The default control of access to the Oracle Database semantic data store is at the model level: the owner of a model may grant select, delete, and insert privileges on the model to other users by granting appropriate privileges on the view named RDFM_<span class="italic">&lt;model_name&gt;</span>. However, for applications with stringent security requirements, you can enforce a fine-grained access control mechanism by using either the Virtual Private Database feature or the Oracle Label Security option of Oracle Database:</p>
<ul>
<li>
<p>Virtual Private Database (VPD) for RDF data allows security administrators to define policies that conditionally restrict a user's access to triples that involve instances of a specific RDF class or property. Using VPD, the data stored in the RDF models is classified using its metadata and each user query is rewritten to include context-dependent data access constraints that enforce access restrictions.</p>
<p>For information about using VPD, see <a class="olink DBSEG007" href="../../network.112/e36292/vpd.htm#DBSEG007"><span class="italic">Oracle Database Security Guide</span></a>. For information about support for VPD with semantic data, see <a href="#CIHBDJIG">Section 5.1</a>.</p>
</li>
<li>
<p>Oracle Label Security (OLS) for RDF data allows sensitivity labels to be associated with individual triples stored in an RDF model. For each query, access to specific triples is granted by comparing their labels with the user's session labels. Furthermore, a minimum sensitivity label for all triple describing a specific resource or all triples defined with a specific predicate can be enforced by assigning a sensitivity label directly to the resource or the predicate, respectively.</p>
<p>For information about using OLS, see <a class="olink OLSAG" href="../../network.112/e10745/toc.htm"><span class="italic">Oracle Label Security Administrator's Guide</span></a>. For information about support for OLS with semantic data, see <a href="#CIHBBDCI">Section 5.2</a></p>
</li>
</ul>
<p>Some factors to consider in choosing whether use VPD or OLS with RDF data include the following:</p>
<ul>
<li>
<p>OLS, when enabled for RDF data, is enforced at the network level, while VPD can be enforced for individual RDF models.</p>
</li>
<li>
<p>You cannot use both VPD and OLS for RDF data at the same time in an Oracle instance.</p>
</li>
</ul>
<p>The application programming interface (API) for implementing VPD or OLS with semantic data is provided in the SEM_RDFSA PL/SQL package. <a href="sem_rdfsa_ref.htm#BABJCAGA">Chapter 13</a> provides reference information about the programs in the SEM_RDFSA package.</p>
<p>VPD and OLS support for RDF data is included in the semantic technologies support for Release 11.2. (For information about enabling, downgrading, or removing semantic technologies support, see <a href="sem_enable.htm#CHDBFEFI">Appendix A</a>.)</p>
<p>This chapter contains the following major sections:</p>
<ul>
<li>
<p><a href="#CIHBDJIG">Section 5.1, "Virtual Private Database (VPD) for RDF Data"</a></p>
</li>
<li>
<p><a href="#CIHBBDCI">Section 5.2, "Oracle Label Security (OLS) for RDF Data"</a></p>
</li>
</ul>
<a id="CIHBDJIG"></a>
<div id="RDFRM99942" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.1</span> <a id="sthref291"></a>Virtual Private Database (VPD) for RDF Data</h2>
<p>The Virtual Private Database (VPD) feature is a row-level security mechanism that restricts access to specific rows in a relational table or view using a security policy and an application context. The security policy includes a policy function that dynamically generates predicates that are enforced for each row returned for the user query. The security predicates returned by the policy function associated with a table are typically expressed using the columns in the table and are thus dependent on the table metadata. Effectively, the security predicates ensure that the rows returned for a user query satisfy additional conditions that are applied on the contents of the row.</p>
<p>When the relational data is mapped to RDF, the data stored in a specific relational table represent triples describing instances of a specific RDF class. In this representation, the columns in the relational table map to RDF properties that are used to describe a resource. This mapping may be further extended to the application of VPD policies.</p>
<p>A VPD policy applied to RDF data restricts users' access to instances of a specific RDF class or property by applying predicates, in the form of graph patterns and filter conditions, on the instance data. For example, a VPD policy may be defined to restrict access to instances of a <code>Contract</code> RDF class only to the users belonging to a specific department. Furthermore, access to the <code>hasContractValue</code> property for a resource identified as instance of the <code>Contract</code> RDF class may be restricted only to the manager of the contract. VPD support for RDF data allows security conditions or data access constraints to be associated with RDF classes and properties, so that access to corresponding instance data is restricted.</p>
<p>A data access constraint associated with an RDF class or property specifies a graph query pattern that must be enforced for all corresponding data instances that are returned as the query result. For example, a SPARQL query pattern to find the due dates for all instances of a <code>Contract</code> class, <code>{?contract :hasDueDate ?due}</code>, may activate a data access constraint that ensures that the information returned pertains to contracts belonging to a specific department. This is achieved by logically rewriting the user's graph query pattern to include additional graph patterns, as shown in the following example:</p>
<pre>
{ ?contract   :hasDueDate  ?due . 
  ?contract   :drivenBy    dept:Dept1 }
</pre>
<p>Furthermore, the values bound into the rewritten graph query pattern may make use of session context to enforce dynamic access restrictions. In the following example, the <code>sys_context</code> function in the object position of the triple pattern binds the appropriate department value based on the session context:</p>
<pre>
{ ?contract   :hasDueDate   ?due . 
  ?contract   :drivenBy
             <span class="bold">"sys_context('sa$appctx','user_dept'}"^^orardf:instruction</span> }
</pre>
<p>In a relational data model, the metadata, in the form of table definition, always exists along with the data (the rows stored in the table); thus, the VPD policies defined using the metadata are well formed and the security conditions are generated using a procedural logic in the policy function.</p>
<p>However, the RDF data model allows data with no accompanying metadata, and therefore the class information for instance data may not always be available for a given RDF graph. For example, in an RDF graph a resource known to be a contract might not accompany a triple that asserts that the resource is an instance of <code>Contract</code> class. Usually such triples can be inferred using available domain and range specifications for the properties describing the resource.</p>
<p>Similarly, a VPD policy relies on the properties' domain and range specifications for deriving the class information for the instance data and for enforcing appropriate data access constraints. However, to avoid runtime dependencies on the user data, a VPD policy maintains the minimal metadata required to derive the class information in its dictionary, separate from the asserted and inferred triples. This also ensures that the metadata maintained by a VPD policy is complete even when some necessary information is missing from the asserted triples and that a VPD policy, with its data access constraints and the metadata, is self-contained and portable with no external dependencies.</p>
<p>A VPD policy with specific data access constraints and RDF metadata specifications can be used to enforce access restrictions for the data stored in an RDF model. Each SPARQL query issued on the model is analyzed to deduce the class information for the resources accessed in the query, and appropriate data access constraints are applied. To facilitate the compile-time analysis and derivation of class information for instance data, a graph query pattern with an unbound predicate is restricted when a VPD policy is in effect. For example, a graph pattern of the following form, anywhere in a SPARQL query pattern, raises an exception when any underlying model has a VPD policy:</p>
<pre>
{ &lt;contract:projectHLS&gt;  <span class="bold">?pred</span>  ?obj }
</pre>
<p>VPD policies are only enforced for SEM_MATCH queries expressed in SPARQL syntax. All other forms of data access (such as classic syntax for graph pattern or direct query on the model view) are not permitted.</p>
<a id="CIHBGBDB"></a>
<div id="RDFRM99943" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.1</span> VPD Policy for RDF Data</h3>
<p>A VPD policy for RDF data is a named dictionary entity that can be used to enforce access restrictions for the data stored in one or more RDF models. A VPD policy defined for RDF data has unique characteristics, and it cannot be reused to enforce security policies for relational data. An RDF-VPD policy defined in the database includes the following:</p>
<ul>
<li>
<p>The RDF Schema statements or metadata necessary for deriving class information for the data referenced in a SPARQL user query</p>
</li>
<li>
<p>The data access constraints that enforce access restrictions for the instance data</p>
</li>
<li>
<p>Application context that allows conditional inclusions of groups of data access constraints based on the runtime environment</p>
</li>
</ul>
<p>An RDF-VPD policy is defined, owned, and maintained by a user with a security administrator role in an organization. This user must have at least EXECUTE privileges on the SYS.DBMS_RLS package. The owner of an RDF-VPD policy can maintain the metadata associated with the policy, define new data access constraints, and apply the policy to one or more RDF models.</p>
<p>A SPARQL query issued on an RDF model with a VPD policy is analyzed, and zero or more data access constraints defined in the policy are enforced such that the data instances that are returned as the query result also satisfy these constraints. The exact data access constraints enforced for a user query vary, based on the resources referenced in the query and the application context. For example, a policy that restricts a manager's access to the <code>hasContractValue</code> property may be relaxed for a user with the Vice President role.</p>
<p>Based on the role of the user, as captured in the application context, specific constraints to be applied are determined at runtime. To facilitate this dynamic inclusion of subsets of constraints defined in a VPD policy, the data access constraints are arranged into named groups that can be activated and deactivated based on the application context. During query analysis, only the constraints defined in the active groups are considered for enforcement.</p>
<p>The constraint groups within a VPD policy are managed using an application context and its package implementation. Each VPD policy can specify the namespace for a context created with the CREATE CONTEXT command. Each attribute associated with the context is treated as the name of a constraint group that can be activated by initializing its value to 1. For example, setting the value for <code>MANAGER</code> attribute of the context associated with a VPD policy to 1 will activate the constraints associated with <code>MANAGER</code> group for the user session. The logic that initializes specific constraint groups based on the user context is typically embedded in the package associated with the context type. The following example shows an excerpt from a sample implementation for one such package:</p>
<pre>
CREATE CONTEXT contracts_constr_ctx using sec_admin.contracts_ctx_pack;
 
begin
  -- create the VPD policy with a context -- 
  sem_rdfsa.create_vpd_policy(policy_name    =&gt; 'CONTRACTS_POLICY',
                              policy_context =&gt; 'contracts_constr_ctx');
end;
/
 
create or replace package sec_admin.contracts_ctx_pack as
  procedure init_constr_groups;
end;
/
 
create or replace package body sec_admin.contracts_ctx_pack as
  procedure init_contr_groups is 
    hrdata EmpRole%rowtype; 
  begin
    -- specific users with FULL access to the data associated with 
    -- the policy -- 
    if (sys_context('userenv', 'session_user') = 'RDF_ADMIN') then 
      dbms_session.set_context('contracts_constr_ctx',
                                sem_rdfsa.VPD_FULL_ACCESS, 1); 
      return;
    end if; 
 
    SELECT * into hrdata FROM EmpRole WHERE guid = 
                          sys_context('userenv','session_user');
 
    if (hrdata.emprole = 'VP') then 
      -- if the user logged in has VP role, activate the constraint
      -- group named VP and keep all other groups inactive. 
      dbms_session.set_context('contracts_constr_ctx','VP', '1'); 
    elsif (hrdata.emprole = 'MANAGER') then 
      dbms_session.set_context('contracts_constr_ctx', 'MANAGER', '1'); 
    elsif ...
      ...  
    else 
      raise_application_error(-20010, 'unknown user role'); 
    end if;
 
  exception when others then 
    -- enforce constraints for all groups --
    dbms_session.clear_all_context('contracts_constr_ctx');
  end init_contr_groups; 
end;
/
</pre>
<p>By default, when a namespace is not associated with an RDF-VPD policy or when a specific constraint group is not activated in a session, all the constraints defined in the policy are active and they are enforced for each user query. However, when a specific constraint group is activated by setting the corresponding namespace-attribute value to 1, only the constraints belonging to the group and any other constraints that are not associated with any group are enforced. For a given session, one or more constraint groups may be activated, in which case all the applicable constraints are enforced conjunctively.</p>
<p>At the time of creation, the data access constraints defined in a RDF-VPD policy may specify the name of a constraint group (explained in <a href="#CIHBJACI">Section 5.1.3, "Data Access Constraints"</a>). Within a database session, appropriate groups of constraints are activated based on the session context set by the context package. For all subsequent SPARQL queries in the database session, the constraints belonging to the active groups are consulted for enforcing appropriate security policies.</p>
<p>Maintenance operations on an RDF model with a VPD policy require unconditional access to data in the model. These operations include creation of an entailment using at least one VPD protected model, and load or data manipulation operations. You can grant unconditional access to the data stored in an RDF model by initializing a reserved attribute for the namespace associated with the VPD policy. The reserved attribute is defined by the package constant <code>sem_rdfsa.VPD_FULL_ACCESS</code>, and the context package implementation shown in the preceding example grants FULL access to the RDF_ADMIN user.</p>
<p>DML operations on the application table are not validated for VPD constraint violations, so only a user with FULL access to the corresponding model can add or modify existing triples.</p>
<p>You can use the SEM_MATCH operator to query an RDF model with a VPD policy in a standard SQL query, and to perform a multi-model query on a combination of VPD-enabled models and models with no VPD policy. However, when more than one model in a multi-model query is VPD-enabled, they must all be associated with the same VPD policy. A VPD policy associated with an RDF model is automatically extended to any data inferred from the model. When multiple RDF models are specified during inference, all VPD-enabled models within the set should use the same VPD policy.</p>
</div>
<!-- class="sect2" -->
<div id="RDFRM99944" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref292"></a>
<h3 class="sect2"><span class="secnum">5.1.2</span> RDF Metadata for Enforcing VPD Policies</h3>
<p>The types of RDF metadata used to enforce VPD policies include the following:</p>
<ul>
<li>
<p>Domain and range information for the properties used in the graph</p>
</li>
<li>
<p>Subclass relationships in the graph</p>
</li>
<li>
<p>Subproperty relationships in the graph</p>
</li>
<li>
<p>Equivalent properties in the graph</p>
</li>
</ul>
<p>The RDF metadata associated with a VPD policy is specified as one or more RDF Schema statements using one of the following property URIs:</p>
<ul>
<li>
<p><code>http://www.w3.org/2000/01/rdf-schema#domain</code></p>
</li>
<li>
<p><code>http://www.w3.org/2000/01/rdf-schema#range</code></p>
</li>
<li>
<p><code>http://www.w3.org/2000/01/rdf-schema#subClassOf</code></p>
</li>
<li>
<p><code>http://www.w3.org/2000/01/rdf-schema#subPropertyOf</code></p>
</li>
<li>
<p><code>http://www.w3.org/2002/07/owl#equivalentProperty</code></p>
</li>
</ul>
<p>For example, the following RDF Schema statement associated with <code>contracts_policy</code> asserts that the domain of the <code>hasContractValue</code> property is a <code>Contract</code> class. Note that range specification for the predicates can be skipped if they are not relevant or if they are of literal type</p>
<pre>
begin
  sem_rdfsa.maint_vpd_metadata(
        policy_name =&gt; 'contracts_policy',
        t_subject   =&gt; '&lt;http://www.myorg.com/pred/hasContractValue&gt;',
        t_predicate =&gt; '&lt;http://www.w3.org/2000/01/rdf-schema#domain&gt;',
        t_object    =&gt; '&lt;http://www.myorg.com/classes/Contract&gt;');
end;
/
</pre>
<p>An RDF-VPD policy maintains its metadata separate from the asserted and inferred triples. You can derive this metadata programmatically from the RDF models and the corresponding entailments. For example, if the domain and range information for the properties and subclass and subproperty relationships are already established in the asserted or inferred triples, you can use a SQL query on the underlying model views to populate the metadata for an RDF-VPD policy.</p>
<p>The domain and range information for the properties aid the query analysis in determining the RDF class type for the terms and unbound variables referenced in the query. This information is further used to enforce appropriate data access constraints on the data accessed by the query. The metadata relating to the subclass property is used to ensure that a data access constraint defined for a specific class in a class hierarchy is automatically enforced for all its subclasses. Similarly, the subproperty specification in a VPD policy is used to enforce any constraints associated with a property to all its subproperties.</p>
<p>The RDF Schema statements associated with a VPD policy are not used to infer additional statements, and the security administrator should ensure that the metadata captured in a VPD policy is complete by cross checking it with inferred data. For example, a subproperty schema statement does not automatically infer the domain and range information for the property based on the domain and range specified for the super-property.</p>
<p>Certain owl and rdfs properties in the asserted triples, when left unchecked, may be used to infer data that may be used to circumvent the VPD policies. For example, when the new property is defined as a super-property of a property that has a specific data access constraint, the inferred data may duplicate all instances of the subproperty using the super-property. Unless the VPD policy explicitly defines access constraints for the super-property, the inferred data may be used to circumvent the access restrictions.</p>
<p>The ability to infer new data is only granted to users with FULL access, and such users should ensure that the metadata associated with the VPD policy is complete in light of newly inferred data. Specifically, the metadata associated with the VPD policy should be maintained if some new <code>rdfs:subClassOf</code>, <code>rdfs:superClassOf</code>, <code>rdfs:subPropertyOf</code>, <code>rdfs:superPropertyOf</code>, or <code>owl:equivalentProperty</code> assertions are generated during inference. Also, any new properties introduced by the rulebases used for inference may need domain and range specifications, as well as data access constraints, if they are associated with some sensitive information.</p>
<p>In a VPD policy, a property can be declared to be equivalent to another property so that the domain and range information, as well as any constraints defined for the original property, are automatically duplicated for the equivalent property. However, within a VPD policy, additional metadata or data access constraints cannot be directly assigned to the property declared to be an equivalent of another property.</p>
</div>
<!-- class="sect2" -->
<a id="CIHBJACI"></a>
<div id="RDFRM99945" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.3</span> Data Access Constraints</h3>
<p>The data access constraints associated with a VPD policy fall into two general categories, based on the types of access restrictions that they enforce:</p>
<ul>
<li>
<p>Those that restrict access to instances of specific RDF classes</p>
</li>
<li>
<p>Those that restrict to assertions using specific RDF properties</p>
</li>
</ul>
<p>The access restrictions are enforced conditionally, based on the application context and the characteristics of the resources being accessed in a SPARQL query. Data access constraints restrict access to instances of an RDF class or property using some properties associated with the resource. For example, access to a resource that is a member of the <code>Contract</code> class may be restricted only to the users who work on the contract, identified using the <code>hasMember</code> property associated with the resource. Similarly, access to the <code>hasContractValue</code> property for a resource may be restricted to a user identified as the manager of the contract using <code>hasManager</code> property associated with the same resource.</p>
<p>Each data access constraint is expressed using two graph patterns identified as a match pattern and an apply pattern. <a id="sthref293"></a>The <span class="bold">match pattern</span> of a constraint determines the type of access restriction it enforces and binds one or more variables to the corresponding data instances accessed in the user query. For example, the following match pattern is defined for instances of the <code>Contract</code> class, and it binds a variable to all such instances accessed through a SPARQL query:</p>
<pre>
{ ?contract  rdf:type  &lt;http://www.myorg.com/classes/Contract&gt; }
</pre>
<p>Similarly, a match pattern for a constraint involving an RDF property matches the instances of the property accessed in a SPARQL query, and binds two variables to the resources in the subject and object position of such instances. For example, the match pattern for a constraint on the <code>hasContractValue</code> property is defined as follows:</p>
<pre>
{ ?contract  &lt;http://www.myorg.com/pred/hasContractValue&gt;  ?cvalue }
</pre>
<p><a id="sthref294"></a>The <span class="bold">apply pattern</span> of a data access constraint defines additional graph patterns to be applied on the resources that match the match pattern before they can be used to construct the query results. One or more variables defined in the match pattern of a data access constraint are used in the corresponding apply pattern to enforce the access restrictions on the identified resources. For example, the following match pattern and apply pattern combination ensures that the <code>hasContractValue</code> of a contract can be accessed only if <code>Andy</code> is the manager of the contract being accessed.:</p>
<pre>
Match:  { ?contract  pred:hasContractValue  ?cvalue  }
Apply:  { ?contract  pred:hasManager        emp:Andy }
</pre>
<p>A data access constraint with its match and apply patterns expressed in SPARQL syntax can be added to a VPD policy to enforce access restrictions on the data stored in RDF models that are associated with the VPD policy. The following example, which adds a constraint to the VPD policy, assumes that the VPD policy is defined with appropriate namespace map for the <code>pred</code> and <code>emp</code> namespace prefixes. (To associate a namespace map with a VPD policy, use the <a href="sem_rdfsa_ref.htm#BABHFBEE">SEM_RDFSA.CREATE_VPD_POLICY</a> procedure.)</p>
<pre>
begin
  sem_rdfsa.add_vpd_constraint(
          policy_name   =&gt; 'contracts_policy',
          constr_name   =&gt; 'andy_constraint_1',
          <span class="bold">match_pattern =&gt; '{?contract  pred:hasContractValue ?cvalue }'</span>,
          <span class="bold">apply_pattern =&gt; '{?contract  pred:hasManager       emp:Andy }'</span>, 
          constr_group  =&gt; 'andy');
end;
/
</pre>
<p>The ability to arrange data access constraints into groups could ensure that the previous constraint is applied only for the sessions associated with <code>Andy</code>. However, to avoid proliferation of structurally similar constraints for each user, you can define a common constraint that uses the application context in the object position of the apply graph patterns, as shown in the following example:</p>
<pre>
begin
  sem_rdfsa.add_vpd_constraint(
          policy_name   =&gt; 'contracts_policy',
          constr_name   =&gt; 'manager_constraint_1',
          match_pattern =&gt; '{?contract  pred:hasContractValue ?cvalue }',
          apply_pattern =&gt; '{?contract  pred:hasManager     
             <span class="bold">"sys_context(''sa$appctx'',''app_user_uri''}"^^orardf:instruction</span> }',
          constr_group  =&gt; 'manager');
end;
/
</pre>
<p>In the preceding example. the data access constraint, defined within the <code>manager</code> constraint group, can be activated for all sessions involving users with a manager role. In this case, the secure application context can be programmed to initialize the attribute <code>app_user_uri</code> of the <code>sa$appctx</code> namespace with the URI for the user logged in. For example, when user <code>Andy</code> logs into the application, the <code>app_user_uri</code> attribute can be initialized to &lt;http://www.myorg.com/employee/Andy&gt;, in which case the constraint will ensure that user <code>Andy</code> can view the value for a contract only if user <code>Andy</code> manages the contract. Generally, the <code>sys_context</code> function can be used in the object position of any graph pattern to allow dynamic URIs or literal values to be bound at the time of query execution. Note that if the context is not initialized properly, the preceding constraint will fail for all data instances and effectively restrict the user from accessing any data.</p>
<p>A SPARQL query issued on an RDF model with a VPD policy is analyzed using the match patterns of all the active data access constraints that are defined in the policy. In the next example, the SPARQL query refers to the <code>hasContractValue</code> property, thereby enforcing the constraint if the group is active. Logically, the enforcement of a constraint is equivalent to rewriting the original SPARQL graph pattern to include the apply patterns for all the relevant constraints, using appropriate variables and terms from the user query. With the previous access restriction on the <code>hasContractValue</code> property, the following SPARQL graph pattern passed to a SEM_MATCH operator is logically rewritten as shown in the following example:</p>
<pre>
Query:     
{ ?contr  pred:drivenBy         ?dept . 
  ?contr  pred:hasContractValue ?val }
 
Rewritten query:     
{ ?contr  pred:drivenBy         ?dept . 
  ?contr  pred:hasContractValue ?val .
  <span class="bold">?contr  pred:hasManager</span>
                <span class="bold">"sys_context('sa$appctx','app_user_uri'}"^^orardf:instruction }</span>
</pre>
<p>When the match pattern of a data access constraint on an RDF property matches the pattern being accessed in a user query, the equivalent VPD-enforced query appends the corresponding apply patterns to the SPARQL query using the variables and terms appearing in the matched pattern. When a SPARQL query has nested graph patterns, the data access constraints are applied to appropriate basic query graph pattern block. In the following example, the <code>hasContractValue</code> property is referenced in the <code>OPTIONAL</code> graph pattern, and therefore the corresponding apply pattern is enforced just for this block of the graph pattern.</p>
<pre>
Query:     
{ ?contr  pred:drivenBy         ?dept . 
   OPTIONAL { ?contr  pred:hasContractValue ?val } } 
 
Rewritten query:     
{ ?contr  pred:drivenBy         ?dept . 
   OPTIONAL { ?contr  pred:hasContractValue ?val .
              ?contr  pred:hasManager
                "sys_context('sa$appctx','app_user_uri'}"^^orardf:instruction }
</pre>
<p>The apply pattern for a data access constraint can be any valid basic graph pattern with multiple triple patterns and a FILTER clause. For example, the access constraint on the <code>hasContractValue</code> property for a user with <code>VP</code> role may stipulate that the user can access the property only if he or she is the Vice President of the department driving the contract. The match and apply patterns for such constraint can be defined as follows:</p>
<pre>
Match:  { ?contract  pred:hasContractValue  ?cvalue  }
Apply:  { ?contract  pred:drivenBy          <span class="bold">?dept</span> . 
          <span class="bold">?dept</span>      pred:hasVP
               "sys_context('sa$appctx','app_user_uri'}"^^orardf:instruction }
</pre>
<p>A match pattern defined for a data access constraint associated with an RDF class identifies all variables and terms that are known to be instances of the class. The RDF metadata defined in the VPD policy is used to determine the type for each variable and the term in a SPARQL query, and the appropriate access constraints are applied on these variables and terms. For example, the following VPD constraint ensures that a resource that is a member of the <code>Contract</code> class can only be accessed by a user who has a <code>hasMember</code> relationship with the resource:</p>
<pre>
Match:  { ?contract  rdf:type  &lt;http://www.myorg.com/classes/Contract&gt; }
Apply:  { ?contract  pred:hasMember           
               "sys_context('sa$appctx','app_user_uri'}"^^orardf:instruction }
</pre>
<p>The class information for a variable or term appearing in a SPARQL query is derived using the domain and range information for the properties appearing in the query. In the SPARQL query in the next example, if the VPD policy has an RDF Schema statement that asserts that the domain of the <code>drivenBy</code> property is the <code>Contract</code> class, the variable <code>?contr</code> is known to hold instances of the <code>Contract</code> class. Therefore, with the previously defined access restriction for the <code>Contract</code> class, the user query is rewritten to include an appropriate apply pattern, as shown in the following example:</p>
<pre>
Query:     
{ <span class="bold">?contr</span>  pred:drivenBy    ?dept . 
  ?contr  pred:hasDueDate  ?due } 
 
Rewritten query: 
{ ?contr  pred:drivenBy    ?dept . 
  ?contr  pred:hasDueDate  ?due  . 
  ?contr  pred:hasMember           
               "sys_context('sa$appctx','app_user_uri'}"^^orardf:instruction }
</pre>
<p>When a basic graph pattern in a SPARQL query matches multiple data access constraints, the corresponding apply patterns are combined to form a conjunctive graph pattern, which is subsequently enforced for the specific graph pattern by logically rewriting the SPARQL query. While considering the data access constraints to be enforced for a given SPARQL query, the class and property hierarchy associated with the VPD policy is consulted to automatically enforce all applicable constraints.</p>
<ul>
<li>
<p>A variable or term identified as an instance of a specific RDF class enforces constraints associated with the class and all its superclasses.</p>
</li>
<li>
<p>A constraint associated with a property is enforced when the user query references the property or any property defined as its subproperty or an equivalent property.</p>
</li>
</ul>
<p>You can use the <code>sys_context</code> function in a data access constraint to enforce context-dependent access restrictions with structurally similar graph patterns. You can dynamically activate and deactivate constraint groups, based on the application context, to enforce alternate access restrictions using structurally different graph patterns.</p>
</div>
<!-- class="sect2" -->
<a id="CIHEHGCH"></a>
<div id="RDFRM99946" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.4</span> <a id="sthref295"></a><a id="sthref296"></a><a id="sthref297"></a>RDFVPD_POLICIES View</h3>
<p>The MDSYS.RDFVPD_POLICIES view contains information about all VPD policies defined in the schema or the policies to which the user has FULL access. If the same policy is associated with multiple models, this view has one entry for each such association. This view exists only after the semantic network and a VPD policy have been created.</p>
<p>The MDSYS.RDFVPD_POLICIES view contains the columns shown in <a href="#CIHDDGCJ">Table 5-1</a>.</p>
<div id="RDFRM99947" class="tblformal">
<p class="titleintable"><a id="sthref298"></a><a id="CIHDDGCJ"></a>Table 5-1 MDSYS.RDFVPD_POLICIES View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFVPD_POLICIES View Columns" summary="MDSYS.RDFVPD_POLICIES view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t2">Column Name</th>
<th class="cellalignment981" id="r1c2-t2">Data Type</th>
<th class="cellalignment981" id="r1c3-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t2" headers="r1c1-t2">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t2 r1c2-t2">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t2 r1c3-t2">
<p>Owner of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t2" headers="r1c1-t2">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t2 r1c2-t2">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t2 r1c3-t2">
<p>Name of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t2" headers="r1c1-t2">
<p>NAMESPACE_MAP</p>
</td>
<td class="cellalignment982" headers="r4c1-t2 r1c2-t2">
<p>RDF_ALIASES</p>
</td>
<td class="cellalignment982" headers="r4c1-t2 r1c3-t2">
<p>Mapping for namespace entries that are used in the VPD constraint definitions.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t2" headers="r1c1-t2">
<p>CONTEXT_NAME</p>
</td>
<td class="cellalignment982" headers="r5c1-t2 r1c2-t2">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r5c1-t2 r1c3-t2">
<p>Name of the context used to manage constraint groups.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHCCCGA"></a>
<div id="RDFRM99948" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.5</span> <a id="sthref299"></a><a id="sthref300"></a><a id="sthref301"></a>RDFVPD_MODELS View</h3>
<p>The MDSYS.RDFVPD_MODELS view contains information about RDF models and their associated VPD policies. This view exists only after the semantic network and a VPD policy have been created.</p>
<p>The MDSYS.RDFVPD_MODELS view contains the columns shown in <a href="#CIHBJHFH">Table 5-2</a>.</p>
<div id="RDFRM99949" class="tblformal">
<p class="titleintable"><a id="sthref302"></a><a id="CIHBJHFH"></a>Table 5-2 MDSYS.RDFVPD_MODELS View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFVPD_MODELS View Columns" summary="MDSYS.RDFVPD_MODELS view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t3">Column Name</th>
<th class="cellalignment981" id="r1c2-t3">Data Type</th>
<th class="cellalignment981" id="r1c3-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t3" headers="r1c1-t3">
<p>MODEL_NAME</p>
</td>
<td class="cellalignment982" headers="r2c1-t3 r1c2-t3">
<p>VARCHAR2(25)</p>
</td>
<td class="cellalignment982" headers="r2c1-t3 r1c3-t3">
<p>Name of the model.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t3" headers="r1c1-t3">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment982" headers="r3c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t3 r1c3-t3">
<p>Owner of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t3" headers="r1c1-t3">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r4c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r4c1-t3 r1c3-t3">
<p>Name of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t3" headers="r1c1-t3">
<p>OPERATION_TYPE</p>
</td>
<td class="cellalignment982" headers="r5c1-t3 r1c2-t3">
<p>VARCHAR2(9)</p>
</td>
<td class="cellalignment982" headers="r5c1-t3 r1c3-t3">
<p>Type of operation for which the VPD policy is enforced: <code>QUERY</code> or <code>DML</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHHHIAD"></a>
<div id="RDFRM99950" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.6</span> <a id="sthref303"></a><a id="sthref304"></a><a id="sthref305"></a>RDFVPD_POLICY_CONSTRAINTS View</h3>
<p>The MDSYS.RDFVPD_POLICY_CONSTRAINTS view contains information about the constraints defined in the VPD policy that are accessible to the current user. This view exists only after the semantic network and a VPD policy have been created.</p>
<p>The MDSYS.RDFVPD_POLICY_CONSTRAINTS view contains the columns shown in <a href="#CIHHGDIB">Table 5-3</a>.</p>
<div id="RDFRM99951" class="tblformal">
<p class="titleintable"><a id="sthref306"></a><a id="CIHHGDIB"></a>Table 5-3 MDSYS.RDFVPD_POLICY_CONSTRAINTS View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFVPD_POLICY_CONSTRAINTS View Columns" summary="MDSYS.RDFVPD_POLICY_CONSTRAINTS view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t4">Column Name</th>
<th class="cellalignment981" id="r1c2-t4">Data Type</th>
<th class="cellalignment981" id="r1c3-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t4" headers="r1c1-t4">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t4 r1c3-t4">
<p>Owner of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t4" headers="r1c1-t4">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t4 r1c3-t4">
<p>Name of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t4" headers="r1c1-t4">
<p>CONSTRAINT_NAME</p>
</td>
<td class="cellalignment982" headers="r4c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r4c1-t4 r1c3-t4">
<p>Name of the constraint.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t4" headers="r1c1-t4">
<p>MATCH_PATTERN</p>
</td>
<td class="cellalignment982" headers="r5c1-t4 r1c2-t4">
<p>VARCHAR2(1000)</p>
</td>
<td class="cellalignment982" headers="r5c1-t4 r1c3-t4">
<p>Match pattern for the constraint.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t4" headers="r1c1-t4">
<p>APPLY_PATTERN</p>
</td>
<td class="cellalignment982" headers="r6c1-t4 r1c2-t4">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r6c1-t4 r1c3-t4">
<p>Apply pattern for the constraint.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r7c1-t4" headers="r1c1-t4">
<p>CONSTRAINT_GROUP</p>
</td>
<td class="cellalignment982" headers="r7c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r7c1-t4 r1c3-t4">
<p>Name of the constraint group to which the constraint belongs. (Not case-sensitive.).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHIDGEI"></a>
<div id="RDFRM99952" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.7</span> <a id="sthref307"></a><a id="sthref308"></a><a id="sthref309"></a>RDFVPD_PREDICATE_MDATA View</h3>
<p>The MDSYS.RDFVPD_PREDICATE_MDATA view contains information about the predicate metadata associated with a VPD policy. This view exists only after the semantic network and a VPD policy have been created.</p>
<p>The MDSYS.RDFVPD_PREDICATE_MDATA view contains the columns shown in <a href="#CIHEFAIH">Table 5-4</a>.</p>
<div id="RDFRM99953" class="tblformal">
<p class="titleintable"><a id="sthref310"></a><a id="CIHEFAIH"></a>Table 5-4 MDSYS.RDFVPD_PREDICATE_MDATA View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFVPD_PREDICATE_MDATA View Columns" summary="MDSYS.RDFVPD_PREDICATE_MDATA view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t5">Column Name</th>
<th class="cellalignment981" id="r1c2-t5">Data Type</th>
<th class="cellalignment981" id="r1c3-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t5" headers="r1c1-t5">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t5 r1c2-t5">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t5 r1c3-t5">
<p>Owner of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t5" headers="r1c1-t5">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t5 r1c2-t5">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t5 r1c3-t5">
<p>Name of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t5" headers="r1c1-t5">
<p>PREDICATE</p>
</td>
<td class="cellalignment982" headers="r4c1-t5 r1c2-t5">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r4c1-t5 r1c3-t5">
<p>URI for the predicate for which the domain and range information is defined.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t5" headers="r1c1-t5">
<p>HASDOMAIN</p>
</td>
<td class="cellalignment982" headers="r5c1-t5 r1c2-t5">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r5c1-t5 r1c3-t5">
<p>URI representing the domain of the predicate.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t5" headers="r1c1-t5">
<p>HASRANGE</p>
</td>
<td class="cellalignment982" headers="r6c1-t5 r1c2-t5">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r6c1-t5 r1c3-t5">
<p>URI representing the range of the predicate.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="CIHGJHCJ"></a>
<div id="RDFRM99954" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.1.8</span> <a id="sthref311"></a><a id="sthref312"></a><a id="sthref313"></a>RDFVPD_RESOURCE_REL View</h3>
<p>The MDSYS.RDFVPD_RESOURCE_REL view contains information about the subclass, subproperty, and equivalence property relationships that are defined between resources in a VPD policy. This view exists only after the semantic network and a VPD policy have been created.</p>
<p>The MDSYS.RDFVPD_RESOURCE_REL view contains the columns shown in <a href="#CIHGHEII">Table 5-5</a>.</p>
<div id="RDFRM99955" class="tblformal">
<p class="titleintable"><a id="sthref314"></a><a id="CIHGHEII"></a>Table 5-5 MDSYS.RDFVPD_RESOURCE_REL View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFVPD_RESOURCE_REL View Columns" summary="MDSYS.RDFVPD_RESOURCE_REL view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t6">Column Name</th>
<th class="cellalignment981" id="r1c2-t6">Data Type</th>
<th class="cellalignment981" id="r1c3-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t6" headers="r1c1-t6">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t6 r1c2-t6">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t6 r1c3-t6">
<p>Owner of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t6" headers="r1c1-t6">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t6 r1c2-t6">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t6 r1c3-t6">
<p>Name of the VPD policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t6" headers="r1c1-t6">
<p>SUBJECT_RESOURCE</p>
</td>
<td class="cellalignment982" headers="r4c1-t6 r1c2-t6">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r4c1-t6 r1c3-t6">
<p>Subject resource.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t6" headers="r1c1-t6">
<p>OBJECT_RESOURCE</p>
</td>
<td class="cellalignment982" headers="r5c1-t6 r1c2-t6">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r5c1-t6 r1c3-t6">
<p>Object resource.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t6" headers="r1c1-t6">
<p>RELATIONSHIP_TYPE</p>
</td>
<td class="cellalignment982" headers="r6c1-t6 r1c2-t6">
<p>VARCHAR2(4000)</p>
</td>
<td class="cellalignment982" headers="r6c1-t6 r1c3-t6">
<p>Relationship that exists between the subject resource and the object resource.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHBBDCI"></a>
<div id="RDFRM99956" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">5.2</span> <a id="sthref315"></a>Oracle Label Security (OLS) for RDF Data</h2>
<p>Oracle Label Security (OLS) for RDF data provides two options for securing semantic data:</p>
<ul>
<li>
<p>Triple-level security (explained in <a href="#CIHGBFIB">Section 5.2.1</a>), which is highly recommended for its performance and ease of use, but requires that a patch be installed</p>
</li>
<li>
<p>Resource-level security (explained in <a href="#CIHCJAJF">Section 5.2.2</a>)</p>
</li>
</ul>
<p>To specify an option, use the <a href="sem_rdfsa_ref.htm#BABFEEAI">SEM_RDFSA.APPLY_OLS_POLICY</a> procedure with the appropriate <code>rdfsa_options</code> parameter value.</p>
<p>To switch from one option to the other, remove the existing policy by using the <a href="sem_rdfsa_ref.htm#CHEFAFBH">SEM_RDFSA.REMOVE_OLS_POLICY</a> procedure, and then apply the new policy by using the <a href="sem_rdfsa_ref.htm#BABFEEAI">SEM_RDFSA.APPLY_OLS_POLICY</a> procedure with the appropriate <code>rdfsa_options</code> parameter value.</p>
<a id="CIHGBFIB"></a>
<div id="RDFRM232" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.2.1</span> <a id="sthref316"></a><a id="sthref317"></a>Triple-Level Security</h3>
<p>The triple-level security option provides a thin layer of RDF-specific capabilities on top of the Oracle Database native support for label security. This option provides better performance and is easier to use than the resource-level security (described in <a href="#CIHCJAJF">Section 5.2.2</a>), especially for performing inference while using OLS. The main difference is that with triple-level security there is no need to assign labels, explicitly or implicitly, to individual triple resources (subjects, properties, objects).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To use triple-level security, you <span class="bolditalic">must</span> first install Patch 9819833 <span class="italic">SEMANTIC TECHNOLOGIES 11G R2 FIX BUNDLE 2</span> (available from My Oracle Support).</div>
<p>To use triple-level security, specify <code>SEM_RDFSA.TRIPLE_LEVEL_ONLY</code> as the <code>rdfsa_options</code> parameter value when you execute the <a href="sem_rdfsa_ref.htm#BABFEEAI">SEM_RDFSA.APPLY_OLS_POLICY</a> procedure. For example:</p>
<pre>
EXECUTE sem_rdfsa.apply_ols_policy('defense', <span class="bold">SEM_RDFSA.TRIPLE_LEVEL_ONLY</span>);
</pre>
<p>Do not specify any of the other available parameters for the <a href="sem_rdfsa_ref.htm#BABFEEAI">SEM_RDFSA.APPLY_OLS_POLICY</a> procedure.</p>
<p>When you use triple-level security, OLS is applied to each semantic model in the network. That is, label security is applied to the relevant internal tables and to all the application tables; there is no need to manually apply policies to the application tables of existing semantic models. However, if you need to create additional models after applying the OLS policy, you must use the <a href="sem_ols_ref.htm#CHDHFGHD">SEM_OLS.APPLY_POLICY_TO_APP_TAB</a> procedure to apply OLS to the application table before creating the model. Similarly, if you have dropped a semantic model and you no longer need to protect the application table, you can use the <a href="sem_ols_ref.htm#CHDDIJCD">SEM_OLS.REMOVE_POLICY_FROM_APP_TAB</a> procedure. (These procedures are described in <a href="sem_ols_ref.htm#CHDHAGBB">Chapter 10</a>.)</p>
<p>With triple-level security, duplicate triples with different labels can be inserted in the semantic model. (Such duplicates are not allowed with resource-level security.) For example, assume that you have a triple with a very sensitive label, such as:</p>
<pre>
(&lt;urn:X&gt;,&lt;urn:P&gt;,&lt;urn:Y&gt;, "TOPSECRET")
</pre>
<p>This does not prevent a low-privileged (<code>UNCLASSIFIED</code>) user from inserting the triple <code>(&lt;urn:X&gt;,&lt;urn:P&gt;,&lt;urn:Y&gt;, "UNCLASSIFIED")</code>. Because SPARQL and SEM_MATCH do not return label information, a query will return both rows (assuming the user has appropriate privileges), and it will not be easy to distinguish between the <code>TOPSECRET</code> and <code>UNCLASSIFIED</code> triples.</p>
<p>To filter out such low-security triples when querying the semantic models, you can one or more the following options with SEM_MATCH:</p>
<ul>
<li>
<p><code>POLICY_NAME</code> specifies the OLS policy name.</p>
</li>
<li>
<p><code>MIN_LABEL</code> specifies the minimum label for triples that are included in the query</p>
</li>
</ul>
<p>In other words, every triple that contains a label that is strictly dominated by <code>MIN_LABEL</code> is not included in the query. For example, to filter out the "UNCLASSIFIED" triple, you could use the following query (assuming the OLS policy name is <code>DEFENSE</code> and that the query user has read privileges over <code>UNCLASSIFIED</code> and <code>TOPSECRET</code> triples):</p>
<pre>
SELECT s,p,y FROM table(sem_match('{?s ?p ?y}' , 
  sem_models(TEST'), null, null, null, null, 
  'MIN_LABEL=TOPSECRET POLICY_NAME=DEFENSE'));
</pre>
<p>Note that the filtering in the preceding example occurs in addition to the security checks performed by the native OLS software.</p>
<p>After a triple has been inserted, you can view and update the label information can be done through the <code>CTXT1</code> column in the application table for the semantic model (assuming that you have the <code>WRITEUP</code> and <code>WRITEDOWN</code> privileges to modify the labels).</p>
<p>There are no restrictions on who can perform inference or bulk loading with triple-level security; all of the inferred or bulk loaded triples are inserted with the user's session row label. Note that you can change the session labels by using the SA_UTL package. (For more information, see <a class="olink OLSAG" href="../../network.112/e10745/toc.htm"><span class="italic">Oracle Label Security Administrator's Guide</span></a>.)</p>
</div>
<!-- class="sect2" -->
<a id="CIHCJAJF"></a>
<div id="RDFRM233" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">5.2.2</span> <a id="sthref318"></a><a id="sthref319"></a>Resource-Level Security</h3>
<p>The resource-level security option enables you to assign one or more security labels that define a security level for table rows. Conceptually, a table in a relational data model can be mapped to an equivalent RDF graph. Specifically, a row in a relational table can be mapped to a set of triples, each asserting some facts about a specific Subject. In this scenario, the subject represents the primary key for the row and each non-key column-value combination from the row is mapped to a predicate-object value combination for the corresponding triples.</p>
<p>A row in a relational data model is identified by its key, and OLS, as a row-level access control mechanism, effectively restricts access to the values associated with the key. With this conceptual mapping between relational and RDF data models, restricting access to a row in a relational table is equivalent to restricting access to a subgraph involving a specific subject. In a model that supports sensitivity labels for each triple, this is enforced by applying the same label to all the triples involving the given subject. However, you can also achieve greater flexibility by allowing the individual triples to have different labels, while maintaining a minimum bound for all the labels.</p>
<p>OLS support for RDF data employs a multilevel approach in which sensitivity labels associated with the triple components (subject, predicate, object) collectively form a minimum bound for the sensitivity label for the triple. With this approach, a data sensitivity label associated with an RDF resource (used as subject, predicate, or object) restricts unauthorized users from accessing any triples involving the resource and from creating new triples with the resource. For example, <code>projectHLS</code> as a subject may have a minimum sensitivity label, which ensures that all triples describing this subject have a sensitivity label that at least covers the label for <code>projectHLS</code>. Additionally, <code>hasContractValue</code> as a predicate may have a higher sensitivity label; and when this predicate is used with <code>projectHLS</code> to form a triple, that triple minimally has a label that covers both the subject and the predicate labels, as in the following example:</p>
<pre>
Triple 1: &lt;http://www.myorg.com/contract/projectHLS&gt; :<span class="bold">ownedBy</span>
                               &lt;http://www.myorg.com/department/Dept1&gt;
Triple 2: &lt;http://www.myorg.com/contract/projectHLS&gt; :<span class="bold">hasContractValue</span>
                               "100000"^^xsd:integer
</pre>
<p>Sensitivity labels are associated with the RDF resources (URIs) based on the position in which they appear in a triple. For example, the same RDF resource may appear in different positions (subject, predicate, or object) in different triples. Three unique labels can be assigned to each resource, so that the appropriate label is used to determine the label for a triple based on the position of the resource in the triple. You can choose the specific resource positions to be secured in a database instance when you apply an OLS policy to the RDF repository. You can secure subjects, objects, predicates, or any combination, as explained in separate sections to follow. The following example applies an OLS policy named <code>defense</code> to the RDF repository and allows sensitivity labels to be associated with RDF subjects and predicates.</p>
<pre>
begin
  sem_rdfsa.apply_ols_policy(
        policy_name   =&gt; 'defense',
        rdfsa_options =&gt; sem_rdfsa.SECURE_SUBJECT+
                         sem_rdfsa.SECURE_PREDICATE); 
end;
/
</pre>
<p>The same RDF resource can appear in both the subject and object positions (and sometime even as the predicate), and such a resource can have distinct sensitivity labels based on its position. A triple using the resource at a specific position should have a label that covers the label corresponding to the resource's position. In such cases, the triple can be asserted or accessed only by the users with labels that cover the triple and the resource labels.</p>
<p>In a specific RDF repository, security based on data classification techniques can be turned on for subjects, predicates, objects, or a combination of these. This ensures that all the triples added to the repository automatically conform to the label relationships described above.</p>
<div id="RDFRM99957" class="sect3"><a id="sthref320"></a>
<h4 class="sect3"><span class="secnum">5.2.2.1</span> Securing RDF Subjects</h4>
<p>An RDF resource (typically a URI) appears in the subject position of a triple when an assertion is made <span class="italic">about</span> the resource. In this case, a sensitivity label associated with the resource has following characteristics:</p>
<ul>
<li>
<p>The label represents the minimum sensitivity label for any triple using the resource as a subject. In other words, the sensitivity label for the triple should dominate or cover the label for the subject.</p>
</li>
<li>
<p>The label for a newly added triple is initialized to the user initial row label or is generated using the label function, if one is specified. Such operations are successful only if the triple's label dominates the label associated with the triple's subject.</p>
</li>
<li>
<p>Only a user with an access label that dominates the subject's label and the triple's label can read the triple.</p>
</li>
</ul>
<p>By default, the sensitivity label for a subject is derived from the user environment when an RDF resource is used in the subject position of a triple for the first time. The default sensitivity label in this case is set to the user's initial row label (the default that is assigned to all rows inserted by the user).</p>
<p>However, you can categorize an RDF resource as a subject and assign a sensitivity label to it even before it is used in a triple. The following example assigns a sensitivity label named <code>SECRET:HLS:US</code> to the <code>projectHLS</code> resource, thereby restricting the users who are able to define new triples about this resource and who are able to access existing triples with this resource as the subject:</p>
<pre>
begin
  sem_rdfsa.set_resource_label(
         model_name   =&gt; 'contracts',
         resource_uri =&gt; '&lt;http://www.myorg.com/contract/projectHLS&gt;',
         label_string =&gt; 'SECRET:HLS:US',
         <span class="bold">resource_pos =&gt; 'S'</span>);
end;
</pre></div>
<!-- class="sect3" -->
<div id="RDFRM99958" class="sect3"><a id="sthref321"></a>
<h4 class="sect3"><span class="secnum">5.2.2.2</span> Securing RDF Predicates</h4>
<p>An RDF predicate defines the relationship between a subject and an object. You can use sensitivity labels associated with RDF predicates to restrict access to specific types of relationships with all subjects.</p>
<p>RDF predicates are analogous to columns in a relational table, and the ability to restrict access to specific predicates is equivalent to securing relational data at the column level. As in the case of securing the subject, the predicate's sensitivity label creates a minimum bound for any triples using this predicate. It is also the minimum authorization that a user must posses to define a triple with the predicate or to access a triple with the predicate.</p>
<p>The following example assigns the label <code>HSECRET:FIN</code> (in this scenario, a label that is Highly Secret and that also belongs to the Finance department) to triples with the <code>hasContractValue</code> predicate, to ensure that only a user with such clearance can define the triple or access it:</p>
<pre>
begin
  sem_rdfsa.set_predicate_label( 
         model_name   =&gt; 'contracts',
         predicate    =&gt; '&lt;http://www.myorg.com/pred/hasContractValue&gt;',
         label_string =&gt; 'HSECRET:FIN');
end;  
/
</pre>
<p>You can secure predicates in combination with subjects. In such cases, the triples using a subject and a predicate are ensured to have a sensitivity label that at least covers the labels for both the subject and the predicate. Extending the preceding example, if <code>projectHLS</code> as a subject is secured with label <code>SECRET:HLS:US</code> and if <code>hasContractValue</code> as a predicate is secured with label <code>HSECRET:FIN:</code>, a triple assigning a monetary value for <code>projectHLS</code> should at least have a label <code>HSECRET:HLS,FIN:US</code>. Effectively, a user's label must dominate this triple's label to be able to define or access the triple.</p>
</div>
<!-- class="sect3" -->
<div id="RDFRM99959" class="sect3"><a id="sthref322"></a>
<h4 class="sect3"><span class="secnum">5.2.2.3</span> Securing RDF Objects</h4>
<p>An RDF triple can have an URI or a literal in its object position. The URI in object position of a triple represents some resource. You can secure a resource in the object position by associating a sensitivity label to it, to restrict the ability to use the resource as an object in triples.</p>
<p>Typically, a resource (URI or non-literal) appearing in the object position of a triple may itself be described using additional RDF statements. Effectively, an RDF resource in the object position could appear in the subject position in some other triples. When the RDF resources are secured at the object position without explicit sensitivity labels, the label associated with the same resource in the subject position is used as the default label for the object.</p>
</div>
<!-- class="sect3" -->
<a id="CIHDFGCC"></a>
<div id="RDFRM99960" class="sect3">
<h4 class="sect3"><span class="secnum">5.2.2.4</span> Generating Labels for Inferred Triples</h4>
<p>RDF data model allows for specification of declarative rules, enabling it to <span class="italic">infer</span> the presence of RDF statements that are not explicitly added to the repository. The following shows some simple declarative rules associated with the logic that projects can be owned by departments and departments have Vice Presidents, and in such cases the project leader is by default the Vice President of the department that owns the project.</p>
<pre>
RuleID -&gt; projectLedBy
Antecedent Expression -&gt; (?proj :ownedBy ?dept) (?dept :hasVP ?person)
Consequent Expression -&gt; (?proj :isLedBy ?person)
</pre>
<p>An RDF rule uses some explicitly asserted triples as well as previously inferred triples as antecedents, and infers one or more consequent triples. Traditionally, the inference process is executed as an offline operation to pregenerate all the inferred triples and to make them available for subsequent query operations.</p>
<p>When the underlying RDF graph is secured using OLS, any additional data inferred from the graph should also be secured to avoid exposing the data to unauthorized users. Additionally, the inference process should run with higher privileges, specifically with full access to data, in order to ensure completeness.</p>
<p>OLS support for RDF data offers techniques to generate sensitivity labels for inferred triples based on labels associated with one or more RDF artifacts. It provides label generation techniques that you can invoke at the time of inference. Additionally, it provides an extensibility framework, which allows an extensible implementation to receive a set of possible labels for a specific triple and determine the most appropriate sensitivity label for the triple based on some application-specific logic. The techniques that you can use for generating the labels for inferred triples include the following (each technique, except for Use Antecedent Labels, is associated with a SEM_RDFSA package constant):</p>
<ul>
<li>
<p>Use Rule Label (<code>SEM_RDFSA.LABELGEN_RULE</code>): An inferred triple is directly generated by a specific rule, and it may be indirectly dependent on other rules through its antecedents. Each rule may have a sensitivity label, which is used as the sensitivity label for all the triples directly inferred by the rule.</p>
</li>
<li>
<p>Use Subject Label (<code>SEM_RDFSA.LABELGEN_SUBJECT</code>): Derives the label for the inferred triple by considering any sensitivity labels associated with the subject in the new triple. Each inferred triple has a subject, which could in turn be a subject, predicate, or object in any of the triple's antecedents. When such RDF resources are secured, the subject in the newly inferred triple may have one or more labels associated with it. With the Use Subject Label technique, the label for the inferred triple is set to the unique label associated with the RDF resource. When more than one label exists for the resource, you can implement the extensible logic to determine the most relevant label for the new triple.</p>
</li>
<li>
<p>Use Predicate Label (<code>SEM_RDFSA.LABELGEN_PREDICATE</code>): Derives the label for the inferred triple by considering any sensitivity labels associated with the predicate in the new triple. Each inferred triple has a predicate, which could in turn be a subject, predicate, or object in any of the triple's antecedents. When such RDF resources are secured, the predicate in the newly inferred triple may have one or more labels associated with it. With the Use Predicate Label technique, the label for the inferred triple is set to the unique label associated with the RDF resource. When more than one label exists for the resource, you can implement the extensible logic to determine the most relevant label for the new triple.</p>
</li>
<li>
<p>Use Object Label (<code>SEM_RDFSA.LABELGEN_OBJECT</code>): Derives the label for the inferred triple by considering any sensitivity labels associated with the object in the new triple. Each inferred triple has an object, which could in turn be a subject, predicate, or object in any of the triple's antecedents. When such RDF resources are secured, the object in the newly inferred triple may have one or more labels associated with it. With the Use Object Label technique, the label for the inferred triple is set to the unique label associated with the RDF resource. When more than one label exists for the resource, you can implement the extensible logic to determine the most relevant label for the new triple.</p>
</li>
<li>
<p>Use Dominating Label (<code>SEM_RDFSA.LABELGEN_DOMINATING</code>): Each inferred triple minimally has four direct components: subject, predicate, object, and the rule that produced the triple. With the Use Dominating Label technique, at the time of inference the label generator computes the most dominating of the sensitivity labels associated with each of the component and assigns it as the sensitivity label for the inferred triple. Exception labels are assigned when a clear dominating relationship cannot be established between various labels.</p>
</li>
<li>
<p>Use Antecedent Labels: In addition to the four direct components for each inferred triple (subject, predicate, object, and the rule that produced the triple), a triple may have one or more antecedent triples, which are instrumental in deducing the new triple. With the Use Antecedent Labels technique, the labels for all the antecedent triples are considered, and conflict resolution criteria are implemented to determine the most appropriate label for the new triple. Since an inferred triple may be dependent on other inferred triples, a strict order is followed while generating the labels for all the inferred triples.</p>
<p>The Use Antecedent Labels technique requires that you use a custom label generator. For information about creating and using a custom label generator, see <a href="#CIHGJHEB">Section 5.2.2.5</a>.</p>
</li>
</ul>
<p>The following example creates an entailment (rules index) for the contracts data using a specific rule base. This operation can only be performed by a user with FULL access privilege with the OLS policy applied to the RDF repository. In this case, the labels generated for the inferred triples are based on the labels associated with their predicates, as indicated by the use of the <code>SEM_RDFSA.LABELGEN_PREDICATE</code> package constant in the <code>label_gen</code> parameter.</p>
<pre>
begin
  sem_rdfsa.create_entailment(
         index_name_in   =&gt; 'contracts_inf',
         models_in       =&gt; SDO_RDF_Models('contracts'),
         rulebases_in    =&gt; SDO_RDF_Rulebases('contracts_rb'),
         options         =&gt; 'USER_RULES=T',
         label_gen       =&gt; <span class="bold">sem_rdfsa.LABELGEN_PREDICATE</span>);
end;
</pre>
<p>When the predefined or extensible label generation implementation cannot compute a unique label to be applied to an inferred triple, an exception label is set for the triple. Such triples are not accessible by any user other than the user with full access to RDF data (also the user initiating the inference process). The triples with exception labels are clearly marked, so that a privileged user can access them and apply meaningful labels manually. After the sensitivity labels are applied to inferred triples, only users with compatible labels can access these triples. The following example updates the sensitivity label for triples for which an exception label was set:</p>
<pre>
update mdsys.rdfi_contracts_inf 
     set ctxt1 = char_to_label('defense', 'SECRET:HLS:US')
     where ctxt1 = -1;
</pre>
<p>Inferred triples accessed through generated labels might not be same as conceptual triples inferred directly from the user accessible triples and rules. The labels generated using system-defined or custom implementations cannot be guaranteed to be precise. See the information about <a href="sem_apis_ref.htm#CHECCDHJ">Fine-Grained Access Control (VPD and OLS) Considerations</a> in the Usage Notes for the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure in <a href="sem_apis_ref.htm#CHDDAHAF">Chapter 9</a> for details.</p>
</div>
<!-- class="sect3" -->
<a id="CIHGJHEB"></a>
<div id="RDFRM99961" class="sect3">
<h4 class="sect3"><span class="secnum">5.2.2.5</span> Using Labels Based on Application Logic</h4>
<p>The MDSYS.RDFSA_LABELGEN type is used to apply appropriate label generator logic at the time of index creation; however, you can also extend this type to implement a custom label generator and generate labels based on application logic. The label generator is specified using the <code>label_gen</code> parameter with the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure. To use a system-defined label generator, specify a SEM_RDFSA package constant, as explained in <a href="#CIHDFGCC">Section 5.2.2.4</a>; to use a custom label generator, you must implement a custom label generator type and specify an instance of that type instead of a SEM_RDFSA package constant.</p>
<p>To create a custom label generator type, you must have the UNDER privilege on the RDFSA_LABELGEN type. In addition, to create an index for RDF data , you must should have the EXECUTE privilege on this type. The following example grants these privileges to a user named RDF_ADMIN:</p>
<pre>
GRANT under, execute ON mdsys.rdfsa_labelgen TO rdf_admin;
</pre>
<p>The custom label generator type must implement a constructor, which should set the dependent resources and specify the getNumericLabel method to return the label computed from the information passed in, as shown in the following example:</p>
<pre>
CREATE OR REPLACE TYPE CustomSPORALabel UNDER mdsys.rdfsa_labelgen  (
   constructor function CustomSPORALabel return self as result,
   overriding member function getNumericLabel (
                                    subject   rdfsa_resource,
                                    predicate rdfsa_resource,
                                    object    rdfsa_resource,
                                    rule      rdfsa_resource,
                                    anteced   rdfsa_resource)
        return number);
</pre>
<p>The label generator constructor uses a set of constants defined in the SEM_RDFSA package to indicate the list of resources on which the label generator relies. The dependent resources are identified as an inferred triple's subject, its predicate, its object, the rule that produced the triple, and its antecedents. A custom label generator can rely on any subset of these resources for generating the labels, and you can specify this in its constructor by using the constants defined in SEM_RDFSA package : USE_SUBJECT_LABEL, USE_PREDICATE_LABEL, USE_OBJECT_LABEL, USE_RULE_LABEL, USE_ANTCED_LABEL. The following example creates the type body and specifies the constructor:</p>
<p><a href="#CIHFDBFD">Example 5-1</a> creates the type body, specifying the constructor function and the getNumericLabel member function. (Application-specific logic is not included in this example.)</p>
<div id="RDFRM99962" class="example">
<p class="titleinexample"><a id="CIHFDBFD"></a>Example 5-1 Creating a Custom Label Generator Type</p>
<pre>
CREATE OR REPLACE TYPE BODY CustomSPORALabel AS
 
   constructor function CustomSPORALabel return self as result as
   begin
     self.setDepResources(sem_rdfsa.USE_SUBJECT_LABEL+
                          sem_rdfsa.USE_PREDICATE_LABEL+
                          sem_rdfsa.USE_OBJECT_LABEL+
                          sem_rdfsa.USE_RULE_LABEL+
                          sem_rdfsa.USE_ANTECED_LABELS);
     return;
   end CustomSPORALabel;
   
   overriding member function getNumericLabel (
                                    subject   rdfsa_resource,
                                    predicate rdfsa_resource,
                                    object    rdfsa_resource,
                                    rule      rdfsa_resource,
                                    anteced   rdfsa_resource)
        return number as
     labellst mdsys.int_array := mdsys.int_array(); 
   begin
    -- Find dominating label of S P O R A &ndash;
    &ndash;- Application specific logic for computing the triple label &ndash;
    -- Copy over all labels to labellst --
    for li in 1 .. subject.getLabelCount() loop
      labellst.extend; 
      labellst(labellst.COUNT) = subject.getLabel(li); 
    end loop; 
    --- Copy over other labels as well --- 
    --- Find a dominating of all the labels. Generates &ndash;1 if no
    --- dominating label within the set
    return self.findDominatingOf(labellst); 
   end getNumericLabel;
  end CustomSPORALabel;  
  /
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHFDBFD">Example 5-1</a>, the sample label generator implementation uses all the resources contributing to the inferred triple for generating a sensitivity label for the triple. Thus, the constructor uses the <code>setDepResources</code> method defined in the superclass to set all its dependent components. The list of dependent resources set with this step determines the exact list of values passed to the label generating routine.</p>
<p>The <code>getNumericLabel</code> method is the label generation routine that has one argument for each resource that an inferred triple may depend on. Some arguments may be null values if the corresponding dependent resource is not set in the constructor implementation.</p>
<p>The label generator implementation can make use of a general-purpose static routine defined in the RDFSA_LABELGEN type to find a domination label for a given set of labels. A set of labels is passed in an instance of MDSYS.INT_ARRAY type, and the method finds a dominating label among them. If no such label exists, an exception label &ndash;1 is returned.</p>
<p>After you have implemented the custom label generator type, you can use the custom label generator for inferred data by assigning an instance of this type to the <code>label_gen</code> parameter in the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as shown in the following example:</p>
<pre>
begin
  sem_apis.create_entailment(
         index_name_in  =&gt; 'contracts_rdfsinf',
         models_in      =&gt; SDO_RDF_Models('contracts'),
         rulebases_in   =&gt; SDO_RDF_Rulebases('RDFS'),
         options        =&gt; '',
         <span class="bold">label_gen      =&gt; CustomSPORALabel()</span>);
end;
/
</pre></div>
<!-- class="sect3" -->
<a id="CIHDFCAB"></a>
<div id="RDFRM99963" class="sect3">
<h4 class="sect3"><span class="secnum">5.2.2.6</span> <a id="sthref323"></a><a id="sthref324"></a><a id="sthref325"></a>RDFOLS_SECURE_RESOURCE View</h4>
<p>The MDSYS.RDFOLS_SECURE_RESOURCE view contains information about resources secured with Oracle Label Security (OLS) policies and the sensitivity labels associated with these resources.</p>
<p>Select privileges on this view can be granted to appropriate users. To view the resources associated with a specific model, you must also have select privileges on the model (or the corresponding RDFM_<span class="italic">model-name</span> view).</p>
<p>The MDSYS.RDFOLS_SECURE_RESOURCE view contains the columns shown in <a href="#CIHJEJFA">Table 5-6</a>.</p>
<div id="RDFRM99964" class="tblformal">
<p class="titleintable"><a id="sthref326"></a><a id="CIHJEJFA"></a>Table 5-6 MDSYS.RDFOLS_SECURE_RESOURCE View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFOLS_SECURE_RESOURCE View Columns" summary="MDSYS.RDFOLS_SECURE_RESOURCE view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t8">Column Name</th>
<th class="cellalignment981" id="r1c2-t8">Data Type</th>
<th class="cellalignment981" id="r1c3-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t8" headers="r1c1-t8">
<p>MODEL_NAME</p>
</td>
<td class="cellalignment982" headers="r2c1-t8 r1c2-t8">
<p>VARCHAR2(25)</p>
</td>
<td class="cellalignment982" headers="r2c1-t8 r1c3-t8">
<p>Name of the model.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t8" headers="r1c1-t8">
<p>MODEL_ID</p>
</td>
<td class="cellalignment982" headers="r3c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment982" headers="r3c1-t8 r1c3-t8">
<p>Internal identifier for the model.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t8" headers="r1c1-t8">
<p>RESOURCE_ID</p>
</td>
<td class="cellalignment982" headers="r4c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment982" headers="r4c1-t8 r1c3-t8">
<p>Internal identifier for the resource; to be joined with MDSYS.RDF_VALUE$.VALUE_ID column for information about the resource.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t8" headers="r1c1-t8">
<p>RESOURCE_TYPE</p>
</td>
<td class="cellalignment982" headers="r5c1-t8 r1c2-t8">
<p>VARCHAR2(16)</p>
</td>
<td class="cellalignment982" headers="r5c1-t8 r1c3-t8">
<p>One of the following string values to indicate the resource type for which the label is assigned: <code>SUBJECT</code>, <code>PREDICATE</code>, <code>OBJECT</code>, <code>GLOBAL</code>.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t8" headers="r1c1-t8">
<p>CTXT1</p>
</td>
<td class="cellalignment982" headers="r6c1-t8 r1c2-t8">
<p>NUMBER</p>
</td>
<td class="cellalignment982" headers="r6c1-t8 r1c3-t8">
<p>Sensitivity label assigned to the resource.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment973">
<tr>
<td class="cellalignment982">
<table class="cellalignment978">
<tr>
<td class="cellalignment977"><a href="indexing_for_docs.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment977"><a href="workspace_mgr.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment984">
<table class="cellalignment976">
<tr>
<td class="cellalignment977"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment977"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment977"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment977"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment977"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment977"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
