<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Semantic Indexing for Documents</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743" />
<meta name="description" content="Provides usage and reference information about Oracle Database support for semantic technologies, including storage, inference, and query capabilities for data and ontologies based on Resource Description Framework (RDF), RDF Schema (RDFS), and Web Ontology Language (OWL)." />
<meta name="dcterms.created" content="2014-01-26T18:14:11Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Semantic Technologies Developer's Guide" />
<meta name="dcterms.identifier" content="E25609-06" />
<meta name="dcterms.isVersionOf" content="RDFRM" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="sem_glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="skos.htm" title="Previous" type="text/html" />
<link rel="Next" href="fine_grained_acc.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25609.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">12/26</span> <!-- End Header -->
<div id="RDFRM99921" class="chapter"><a id="BEIJDEJI"></a>
<h1 class="chapter"><span class="secnum">4</span> <a id="sthref245"></a><a id="sthref246"></a>Semantic Indexing for Documents</h1>
<p>Information extractors locate and extract meaningful information from unstructured documents. The ability to search for documents based on this extracted information is a significant improvement over the keyword-based searches supported by the full-text search engines.</p>
<p>Semantic indexing for documents introduces an index type that can make use of information extractors and annotators to semantically index documents stored in relational tables. Documents indexed semantically can be searched using SEM_CONTAINS operator within a standard SQL query. The search criteria for these documents are expressed using SPARQL query patterns that operate on the information extracted from the documents, as in the following example.</p>
<pre>
SELECT docId
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
     ' { ?org    rdf:type            typ:Organization  . 
         ?org    pred:hasCategory    cat:BusinessFinance } ', ..) = 1
</pre>
<p>The key components that facilitate Semantic Indexing for documents in an Oracle Database include:</p>
<ul>
<li>
<p>Extensible information extractor framework, which allows third-party information extractors to be plugged into the database</p>
</li>
<li>
<p>SEM_CONTAINS operator to identify documents of interest, based on their extracted information, using standard SQL queries</p>
</li>
<li>
<p>SEM_CONTAINS_SELECT ancillary operator to return relevant information about the documents identified using SEM_CONTAINS operator</p>
</li>
<li>
<p>SemContext index type to interact with the information extractor and manage the information extracted from a document set in an index structure and to facilitate semantically meaningful searches on the documents</p>
</li>
</ul>
<p>The application program interface (API) for managing extractor policies and semantic indexes created for documents is provided in the SEM_RDFCTX PL/SQL package. <a href="sem_rdfctx_ref.htm#BABCGIDJ">Chapter 12</a> provides the reference information about the subprograms in SEM_RDFCTX package.</p>
<p>This chapter contains the following major sections:</p>
<ul>
<li>
<p><a href="#BEIGGFEF">Section 4.1, "Information Extractors for Semantically Indexing Documents"</a></p>
</li>
<li>
<p><a href="#BEIBJJHJ">Section 4.2, "Extractor Policies"</a></p>
</li>
<li>
<p><a href="#BEIICCEI">Section 4.3, "Semantically Indexing Documents"</a></p>
</li>
<li>
<p><a href="#BEIHGJAD">Section 4.4, "SEM_CONTAINS and Ancillary Operators"</a></p>
</li>
<li>
<p><a href="#BEIHEABE">Section 4.5, "Searching for Documents Using SPARQL Query Patterns"</a></p>
</li>
<li>
<p><a href="#BEIGJHID">Section 4.6, "Bindings for SPARQL Variables in Matching Subgraphs in a Document (SEM_CONTAINS_SELECT Ancillary Operator)"</a></p>
</li>
<li>
<p><a href="#BEIGCHDH">Section 4.7, "Improving the Quality of Document Search Operations"</a></p>
</li>
<li>
<p><a href="#BEIIGBIE">Section 4.8, "Indexing External Documents"</a></p>
</li>
<li>
<p><a href="#BEIFGBED">Section 4.9, "Configuring the Calais Extractor type"</a></p>
</li>
<li>
<p><a href="#BEIHCCBD">Section 4.10, "Working with General Architecture for Text Engineering (GATE)"</a></p>
</li>
<li>
<p><a href="#BEICHADJ">Section 4.11, "Creating a New Extractor Type"</a></p>
</li>
<li>
<p><a href="#BEIGCHHJ">Section 4.12, "Creating a Local Semantic Index on a Range-Partitioned Table"</a></p>
</li>
<li>
<p><a href="#BEIHEHEI">Section 4.13, "Altering a Semantic Index"</a></p>
</li>
<li>
<p><a href="#BEIFAFFJ">Section 4.14, "Passing Extractor-Specific Parameters in CREATE INDEX and ALTER INDEX"</a></p>
</li>
<li>
<p><a href="#BEIGEJGI">Section 4.15, "Performing Document-Centric Inference"</a></p>
</li>
<li>
<p><a href="#BEICFJEE">Section 4.16, "Metadata Views for Semantic Indexing"</a></p>
</li>
<li>
<p><a href="#BEICBGHI">Section 4.17, "Default Style Sheet for GATE Extractor Output"</a></p>
</li>
</ul>
<a id="BEIGGFEF"></a>
<div id="RDFRM99922" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.1</span> <a id="sthref247"></a><a id="sthref248"></a>Information Extractors for Semantically Indexing Documents</h2>
<p><span class="bold">Information extractors</span> process unstructured documents and extract meaningful information from them, often using natural-language processing engines with the aid of ontologies. The quality and the completeness of information extracted from a document vary from one extractor to another. Some extractors simply identify the entities (such as names of persons, organizations, and geographic locations from a document), while the others attempt to identify the relationships among the identified entities and additional description for those entities. You can search for a specific document from a large set when the information extracted from the documents is maintained as a semantic index.</p>
<p>You can use an information extractor to create a semantic index on the documents stored in a column of a relational table. An extensible framework allows any third-party information extractor that is accessible from the database to be plugged into the database. An object type created for an extractor encapsulates the extraction logic, and has methods to configure the extractor and receive information extracted from a given document in RDF/XML format.</p>
<p>An abstract type MDSYS.RDFCTX_EXTRACTOR defines the common interfaces to all information extractors. An implementation of this abstract type interacts with a specific information extractor to produce RDF/XML for a given document. An implementation for this type can access a third-party information extractor that either is available as a database application or is installed on the network (accessed using Web service callouts). <a href="#BEIBDDEG">Example 4-1</a> shows the definition of the RDFCTX_EXTRACTOR abstract type.</p>
<div id="RDFRM99923" class="example">
<p class="titleinexample"><a id="BEIBDDEG"></a>Example 4-1 RDFCTX_EXTRACTOR Abstract Type Definition</p>
<pre>
create or replace type rdfctx_extractor authid current_user as object (
  extr_type        VARCHAR2(32),
  member function  getDescription return VARCHAR2,
  member function  rdfReturnType return VARCHAR2,
  member function  getContext(attribute VARCHAR2) return VARCHAR2,
  member procedure startDriver,
  member function  extractRDF(document CLOB,
                              docId    VARCHAR2) return CLOB,
  member function  extractRdf(document CLOB,
                              docId    VARCHAR2,
                              params   VARCHAR2,
                              options  VARCHAR2 default NULL) return CLOB
  member function  batchExtractRdf(docCursor        SYS_REFCURSOR,
                              extracted_info_table  VARCHAR2,
                              params                VARCHAR2,
                              partition_name        VARCHAR2 default NULL,
                              docId                 VARCHAR2 default NULL,
                              preferences           SYS.XMLType default NULL,
                              options               VARCHAR2 default NULL)  
                              return CLOB,
  member procedure closeDriver
) not instantiable not final
/
</pre></div>
<!-- class="example" -->
<p>A specific implementation of the RDFCTX_EXTRACTOR type sets an identifier for the extractor type in the <code>extr_type</code> attribute, and it returns a short description for the extractor type using <code>getDescription</code> method. All implementations of this abstract type return the extracted information as RDF triples. In the current release, the RDF triples are expected to be serialized using RDF/XML format, and therefore the <code>rdfReturnType</code> method should return '<code>RDF/XML</code>'.</p>
<p>An extractor type implementation uses the <code>extractRDF</code> method to encapsulate the extraction logic, possibly by invoking external information extractor using proprietary interfaces, and returns the extracted information in RDF/XML format. When a third-party extractor uses some proprietary XML Schema to capture the extracted information, an XML style sheet can be used to generate an equivalent RDF/XML. The <code>startDriver</code> and <code>closeDriver</code> methods can perform any housekeeping operations pertaining to the information extractor. The optional <code>params</code> parameter allows the extractor to obtain additional information about the type of extraction needed (for example, the desired quality of extraction).</p>
<p>Optionally, an extractor type implementation may support a batch interface by providing an implementation of the <code>batchExtractRdf</code> member function. This function accepts a cursor through the input parameter <code>docCursor</code> and typically uses that cursor to retrieve each document, extract information from the document, and then insert the extracted information into (the specified partition identified by the <code>partition_name</code> partition of the <code>extracted_info_table</code> table. The <code>preferences</code> parameter is used to obtain the preferences value associated with the policy (as described in <a href="#BEIIGBIE">Section 4.8</a> and in the <a href="sem_rdfctx_ref.htm#BABHDHFJ">SEM_RDFCTX.CREATE_POLICY</a> reference section).</p>
<p>The <code>getContext</code> member function accepts an attribute name and returns the value for that attribute. Currently this function is used only for extractors supporting the batch interface. The attribute names and corresponding possible return values are the following:</p>
<ul>
<li>
<p>For the <code>BATCH_SUPPORT</code> attribute, the return values are '<code>YES</code>' or '<code>NO</code>' depending on whether the extractor supports the batch interface.</p>
</li>
<li>
<p>For the <code>DBUSER</code> attribute, the return value is the name of a database user that will connect to the database to retrieve rows from the cursor (identified by the <code>docCursor</code> parameter) and that will write to the table <code>extracted_info_table</code>.</p>
</li>
</ul>
<p>This information is used for granting appropriate privileges to the table being indexed and the table <code>extracted_info_table</code>.</p>
<p>The <code>startDriver</code> and <code>closeDriver</code> methods can perform any housekeeping operations pertaining to the information extractor.</p>
<p>An extractor type for the General Architecture for Text Engineering (GATE) engine is defined as a subtype of the RDFCTX_EXTRACTOR type. The implementation of this extractor type sends the documents to a GATE engine over a TCP connection, receives annotations extracted by the engine in XML format, and converts this proprietary XML document to an RDF/XML document. For more information on configuring a GATE engine to work with Oracle Database, see <a href="#BEIHCCBD">Section 4.10</a>. For an example of creating a new information extractor, see <a href="#BEICHADJ">Section 4.11</a>.</p>
<p>Information extractors that are deployed as Web services can be invoked from the database by extending the RDFCTX_WS_EXTRACTOR type, which is a subtype of the RDFCTX_EXTRACTOR type. The RDFCTX_WS_EXTRACTOR type encapsulates the Web service callouts in the <code>extractRDF</code> method; specific implementations for network-based extractors can reuse this implementation by setting relevant attribute values in the type constructor.</p>
<p>Thomson Reuters Calais is an example of a network-based information extractor that can be accessed using web-service callouts. The CALAIS_EXTRACTOR type, which is a subtype of the RDFCTX_WS_EXTRACTOR type, encapsulates the Calais extraction logic, and it can be used to semantically index the documents. The CALAIS_EXTRACTOR type must be configured for the database instance before it can be used to create semantic indexes, as explained in <a href="#BEIFGBED">Section 4.9</a>.</p>
</div>
<!-- class="sect1" -->
<a id="BEIBJJHJ"></a>
<div id="RDFRM99924" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.2</span> <a id="sthref249"></a><a id="sthref250"></a>Extractor Policies</h2>
<p>An <span class="bold">extractor policy</span> is a named dictionary entity that determines the characteristics of a semantic index that is created using the policy. Each extractor policy refers, directly or indirectly, to an instance of an extractor type. An extractor policy with a direct reference to an extractor type instance can be used to compose other extractor policies that include additional RDF models for ontologies.</p>
<p>The following example creates a basic extractor policy created using the GATE extractor type:</p>
<pre>
begin
  sem_rdfctx.create_policy (policy_name =&gt; 'SEM_EXTR',
                            extractor   =&gt; mdsys.gatenlp_extractor());
end;
/
</pre>
<p>The following example creates a dependent extractor policy that combines the metadata extracted by the policy in the preceding example with a user-defined RDF model named <code>geo_ontology</code>:</p>
<pre>
begin
  sem_rdfctx.create_policy (policy_name =&gt; 'SEM_EXTR_PLUS_GEOONT',
                            base_policy =&gt; 'SEM_EXTR',
                            user_models =&gt; SEM_MODELS ('geo_ontology'));
end;
/
</pre>
<p>You can use an extractor policy to create one or more semantic indexes on columns that store unstructured documents, as explained in <a href="#BEIICCEI">Section 4.3</a>.</p>
</div>
<!-- class="sect1" -->
<a id="BEIICCEI"></a>
<div id="RDFRM99925" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.3</span> <a id="sthref251"></a><a id="sthref252"></a><a id="sthref253"></a>Semantically Indexing Documents</h2>
<p>Textual documents stored in a CLOB or VARCHAR2 column of a relational table can be indexed using the MDSYS.SEMCONTEXT index type, to facilitate semantically meaningful searches. The extractor policy specified at index creation determines the information extractor used to semantically index the documents. The extracted information, captured as a set of RDF triples for each document, is managed in the semantic data store. Each instance of the semantic index is associated with a system-generated RDF model, which maintains the RDF triples extracted from the corresponding documents.</p>
<p>The following example creates a semantic index named <code>ArticleIndex</code> on the textual documents in the ARTICLE column of the NEWSFEED table, using the extractor policy named <code>SEM_EXTR</code>:</p>
<pre>
CREATE INDEX ArticleIndex on Newsfeed (article)
   INDEXTYPE IS mdsys.SemContext PARAMETERS ('SEM_EXTR');
</pre>
<p>The RDF model created for an index is managed internally and it is not associated with an application table. The triples stored in such model are automatically maintained for any modifications (such as update, insert, or delete) made to the documents stored in the table column. Although a single RDF model is used to index all documents stored in a table column, the triples stored in the model maintain references to the documents from which they are extracted; therefore, all the triples extracted from a specific document form an individual graph within the RDF model. The documents that are semantically indexed can then be searched using a SPARQL query pattern that operates on the triples extracted from the documents.</p>
<p>When creating a semantic index for documents, you can use a basic extractor policy or a dependent policy, which may include one or more user-defined RDF models. When you create an index with a dependent extractor policy, the document search pattern specified using SPARQL could span the triples extracted from the documents as well as those defined in user-defined models.</p>
<p>You can create an index using multiple extractor policies, in which case the triples extracted by the corresponding extractors are maintained separately in distinct RDF models. A document search query using one such index can select the specific policy to be used for answering the query. For example, an extractor policy named <code>CITY_EXTR</code> can be created to extract the names of the cities from a given document, and this extractor policy can be used in combination with the SEM_EXTR policy to create a semantic index, as in the following example:</p>
<pre>
CREATE INDEX ArticleIndex on Newsfeed (article)
   INDEXTYPE IS mdsys.SemContext PARAMETERS (<span class="bold">'SEM_EXTR CITY_EXTR'</span>);
</pre>
<p>The first extractor policy in the PARAMETERS list is considered to be the default policy if a query does not refer to a specific policy; however, you can change the default extractor policy for a semantic index by using the <a href="sem_rdfctx_ref.htm#BABEIAII">SEM_RDFCTX.SET_DEFAULT_POLICY</a> procedure, as in the following example:</p>
<pre>
begin
  sem_rdfctx.set_default_policy (index_name =&gt; 'ArticleIndex',
                                 policy_name =&gt; 'CITY_EXTR');
end;
/
</pre></div>
<!-- class="sect1" -->
<a id="BEIHGJAD"></a>
<div id="RDFRM220" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.4</span> <a id="sthref254"></a>SEM_CONTAINS and Ancillary Operators</h2>
<p>You can use the SEM_CONTAINS operator in a standard SQL statement to search for documents or document references that are stored in relational tables. This operator has the following syntax:</p>
<pre>
SEM_CONTAINS(
  column   VARCHAR2 / CLOB,
  sparql   VARCHAR2,
  policy   VARCHAR2,
  aliases  SEM_ALIASES,
  index_status  NUMBER,
  ancoper  NUMBER
 ) RETURN NUMBER;
</pre>
<p>The <code>column</code> and <code>sparql</code> attributes attribute are required. The other attributes are optional (that is, each can be a null value).</p>
<p>The <code>column</code> attribute identifies a VARCHAR2 or CLOB column in a relational table that stores the documents or references to documents that are semantically indexed. An index of type MDSYS.SEMCONTEXT must be defined in this column for the SEM_CONTAINS operator to use.</p>
<p>The <code>sparql</code> attribute is a string literal that defines the document search criteria, expressed in SPARQL format.</p>
<p>The optional <code>policy</code> attribute specifies the name of an extractor policy, usually to override the default policy. A semantic document index can have one or more extractor policies specified at index creation, and one of these policies is the default, which is used if the <code>policy</code> attribute is null in the call to SEM_CONTAINS.</p>
<p><a id="sthref255"></a><a id="sthref256"></a><a id="sthref257"></a>The optional <code>aliases</code> attribute identifies one or more namespaces, including a default namespace, to be used for expansion of qualified names in the query pattern. Its data type is SEM_ALIASES, which has the following definition: <code>TABLE OF SEM_ALIAS</code>, where each SEM_ALIAS element identifies a namespace ID and namespace value. The SEM_ALIAS data type has the following definition: <code>(namespace_id VARCHAR2(30), namespace_val VARCHAR2(4000))</code></p>
<p>The optional <code>index_status</code> attribute is relevant only when a dependent policy involving one or more entailments is being used for the SEM_CONTAINS invocation. The <code>index_status</code> value identifies the minimum required validity status of the entailments. The possible values are <code>0</code> (for VALID, the default), <code>1</code> (for INCOMPLETE), and <code>2</code> (for INVALID).</p>
<p><a id="sthref258"></a>The optional <code>ancoper</code> attribute specifies a number as the binding to be used when the SEM_CONTAINS_SELECT ancillary operator is used with this operator in a query. The number specified for the <code>ancoper</code> attribute should be the same as number specified for the <code>operbind</code> attribute in the SEM_CONTAINS_SELECT ancillary operator.</p>
<p>The SEM_CONTAINS operator returns 1 for each document instance matching the specified search criteria, and returns 0 for all other cases.</p>
<p>For more information about using the SEM_CONTAINS operator, including an example, see <a href="#BEIHEABE">Section 4.5</a>.</p>
<div id="RDFRM221" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref259"></a>
<h3 class="sect2"><span class="secnum">4.4.1</span> <a id="sthref260"></a>SEM_CONTAINS_SELECT Ancillary Operator</h3>
<p>You can use the SEM_CONTAINS_SELECT ancillary operator to return additional information about each document that matches some search criteria. This ancillary operator has a single numerical attribute (<code>operbind</code>) that associates an instance of the SEM_CONTAINS_SELECT ancillary operator with a SEM_CONTAINS operator by using the same value for the binding. This ancillary operator returns an object of type CLOB that contains the additional information from the matching document, formatted in SPARQL Query Results XML format.</p>
<p>The SEM_CONTAINS_SELECT ancillary operator has the following syntax:</p>
<pre>
SEM_CONTAINS_SELECT(
  operbind  NUMBER
 ) RETURN CLOB;
</pre>
<p>For more information about using the SEM_CONTAINS_SELECT ancillary operator, including examples, see <a href="#BEIGJHID">Section 4.6</a>.</p>
</div>
<!-- class="sect2" -->
<div id="RDFRM222" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref261"></a>
<h3 class="sect2"><span class="secnum">4.4.2</span> <a id="sthref262"></a>SEM_CONTAINS_COUNT Ancillary Operator</h3>
<p>You can use the SEM_CONTAINS_COUNT ancillary operator for a SEM_CONTAINS operator invocation. For each matched document, it returns the count of matching subgraphs for the SPARQL graph pattern specified in the SEM_CONTAINS invocation.</p>
<p>The SEM_CONTAINS_COUNT ancillary operator has the following syntax:</p>
<pre>
SEM_CONTAINS_COUNT(
  operbind  NUMBER
 ) RETURN NUMBER;
</pre>
<p>The following example excerpt shows the use of the SEM_CONTAINS_COUNT ancillary operator to return the count of matching subgraphs for each matched document:</p>
<pre>
SELECT docId, SEM_CONTAINS_COUNT(1) as matching_subgraph_count
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
  '{ ?org   rdf:type          class:Organization  . 
     ?org   pred:hasCategory  cat:BusinessFinance }', .., 
   1)= 1;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEIHEABE"></a>
<div id="RDFRM99926" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.5</span> <a id="sthref263"></a>Searching for Documents Using SPARQL Query Patterns</h2>
<p>Documents that are semantically indexed (that is, indexed using the mdsys.SemContext index type) can be searched using SEM_CONTAINS operator within a standard SQL query. In the query, the SEM_CONTAINS operator must have at least two parameters, the first specifying the column in which the documents are stored and the second specifying the document search criteria expressed as a SPARQL query pattern, as in the following example:</p>
<pre>
SELECT docId FROM Newsfeed
WHERE  SEM_CONTAINS (article, 
  '{ ?org  rdf:type  &lt;http://www.example.com/classes/Organization&gt;  . 
     ?org  &lt;http://example.com/pred/hasCategory&gt;  
             &lt;http://www.example.com/category/BusinessFinance&gt; }'
           )= 1;
</pre>
<p>The SPARQL query pattern specified with the SEM_CONTAINS operator is matched against the individual graphs corresponding to each document, and a document is considered to match a search criterion if the triples from the corresponding graph satisfy the query pattern. In the preceding example, the SPARQL query pattern identifies the individual graphs (thus, the documents) that refer to an <code>Organization</code> that belong to <code>BusinessFinance</code> category. The SQL query returns the rows corresponding to the matching documents in its result set. The preceding example assumes that the URIs used in the query are generated by the underlying extractor, and that you (the user searching for documents) are aware of the properties and terms that are generated by the extractor in use.</p>
<p>When you create an index using a dependent extractor policy that includes one or more user-defined RDF models, the triples asserted in the user models are considered to be common to all the documents. Document searches involving such policies test the search criteria against the triples in individual graphs corresponding to the documents, combined with the triples in the user models. For example, the following query identifies all articles referring to organizations in the state of New Hampshire, using the geographical ontology (<code>geo_ontology</code> RDF Model from a preceding example) that maps cities to states:</p>
<pre>
SELECT docId FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
        '{ ?org     rdf:type          class:Organization  . 
           ?org     pred:hasLocation  <span class="bold">?city</span> . 
           <span class="bold">?city    geo:hasState      state:NewHampshire</span> }', 
        'SEM_EXTR_PLUS_GEOONT', 
               sem_aliases(                              
                  sem_alias('class', 'http://www.myorg.com/classes/'),
                  sem_alias('pred', 'http://www.myorg.com/pred/'),
                  sem_alias('geo', 'http://geoont.org/rel/'),
                  sem_alias('state', 'http://geoont.org/state/'))) = 1;
</pre>
<p>The preceding query, with a reference to the extractor policy SEM_EXTR_PLUS_GEOONT (created in an example in <a href="#BEIBJJHJ">Section 4.2</a>), combines the triples extracted from the indexed documents and the triples in the user model to find matching documents. In this example, the name of the extractor policy is optional if the corresponding index is created with just this policy or if this is the default extractor policy for the index. When the query pattern uses some qualified names, an optional parameter to the SEM_CONTAINS operator can specify the namespaces to be used for expanding the qualified names.</p>
<p>SPARQL-based document searches can make use of the SPARQL syntax that is supported through SEM_MATCH queries.</p>
</div>
<!-- class="sect1" -->
<a id="BEIGJHID"></a>
<div id="RDFRM99927" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.6</span> <a id="sthref264"></a>Bindings for SPARQL Variables in Matching Subgraphs in a Document (SEM_CONTAINS_SELECT Ancillary Operator)</h2>
<p>You can use the SEM_CONTAINS_SELECT ancillary operator to return additional information about each document matched using the SEM_CONTAINS operator. Specifically, the bindings for the variables used in SPARQL-based document search criteria can be returned using this operator. This operator is ancillary to the SEM_CONTAINS operator, and a literal number is used as an argument to this operator to associate it with a specific instance of SEM_CONTAINS operator, as in the following example:</p>
<pre>
SELECT docId, <span class="bold">SEM_CONTAINS_SELECT(1)</span> as result
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
  '{ ?org   rdf:type          class:Organization  . 
     ?org   pred:hasCategory  cat:BusinessFinance }', .., 
   <span class="bold">1</span>)= 1;
</pre>
<p>The SEM_CONTAINS_SELECT ancillary operator returns the bindings for the variables in SPARQL Query Results XML format, as CLOB data. The variables may be bound to multiple data instances from a single document, in which case all bindings for the variables are returned. The following example is an excerpt from the output of the preceding query: a value returned by the SEM_CONTAINS_SELECT ancillary operator for a document matching the specified search criteria.</p>
<pre>
&lt;results&gt;
  &lt;result&gt; 
     &lt;binding name="ORG"&gt;
        &lt;uri&gt;http://newscorp.com/Org/AcmeCorp&lt;/uri&gt;
     &lt;/binding&gt;
  &lt;/result&gt; 
  &lt;result&gt;
     &lt;binding name="ORG"&gt;
       &lt;uri&gt;http://newscorp.com/Org/ABCCorp&lt;/uri&gt;
     &lt;/binding&gt;
  &lt;/result&gt;
&lt;/results&gt;
</pre>
<p>You can rank the search results by creating an instance of XMLType for the CLOB value returned by the SEM_CONTAINS_SELECT ancillary operator and applying an XPath expression to sort the results on some attribute values.</p>
<p>By default, the SEM_CONTAINS_SELECT ancillary operator returns bindings for all variables used in the SPARQL-based document search criteria. However, when the values for only a subset of the variables are relevant for a search, the SPARQL pattern can include a SELECT clause with space-separated list of variables for which the values should be returned, as in the following example:</p>
<pre>
SELECT docId, SEM_CONTAINS_SELECT(1) as result
FROM   Newsfeed
WHERE  SEM_CONTAINS (article, 
        '<span class="bold">SELECT ?org  ?city</span> 
         <span class="bold">WHERE</span> { ?org     rdf:type          class:Organization  . 
                 ?org     pred:hasLocation  ?city . 
                 ?city    geo:hasState      state:NewHampshire }', .., 
         1) = 1;
</pre></div>
<!-- class="sect1" -->
<a id="BEIGCHDH"></a>
<div id="RDFRM99928" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.7</span> <a id="sthref265"></a><a id="sthref266"></a>Improving the Quality of Document Search Operations</h2>
<p>The quality of a document search operation depends on the quality of the information produced by the extractor used to index the documents. If the information extracted is incomplete, you may want to add some annotations to a document. You can use the <a href="sem_rdfctx_ref.htm#BABEGEDC">SEM_RDFCTX.MAINTAIN_TRIPLES</a> procedure to add annotations, in the form of RDF triples, to specific documents in order to improve the quality of search, as shown in the following example:</p>
<pre>
begin
  sem_rdfctx.maintain_triples(
     index_name      =&gt; 'ArticleIndex',
     where_clause    =&gt; 'docid in (1,15,20)',  
     rdfxml_content =&gt; sys.xmltype(
      '&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
                xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
                xmlns:pred="http://example.com/pred/"&gt;
       &lt;rdf:Description rdf:about=" http://newscorp.com/Org/ExampleCorp"&gt;
         &lt;pred:hasShortName 
               rdf:datatype="http://www.w3.org/2001/XMLSchema#string"&gt;
             Example
         &lt;/pred:hasShortName&gt;
     &lt;/rdf:Description&gt; 
    &lt;/rdf:RDF&gt;'));
end;
/
</pre>
<p>The index name and the WHERE clause specified in the preceding example identify specific instances of the document to be annotated, and the RDF/XML content passed in is used to add additional triples to the individual graphs corresponding to those documents. This allows domain experts and user communities to improve the quality of search by adding relevant triples to annotate some documents.</p>
</div>
<!-- class="sect1" -->
<a id="BEIIGBIE"></a>
<div id="RDFRM99929" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.8</span> <a id="sthref267"></a>Indexing External Documents</h2>
<p>You can use semantic indexing on documents that are stored in a file system or on the network. In such cases, you store the references to external documents in a table column, and you create a semantic index on the column using an appropriate extractor policy.</p>
<p>To index external documents, define an extractor policy with appropriate preferences, using an XML document that is assigned to the <code>preferences</code> parameter of the <a href="sem_rdfctx_ref.htm#BABHDHFJ">SEM_RDFCTX.CREATE_POLICY</a> procedure, as in the following example:</p>
<pre>
begin
  sem_rdfctx.create_policy (
       policy_name =&gt; 'SEM_EXTR_FROM_FILE',
       extractor   =&gt; mdsys.gatenlp_extractor()),
       preferences =&gt; sys.xmltype('<span class="bold">&lt;RDFCTXPreferences&gt;</span>
                                     <span class="bold">&lt;Datastore type="FILE"&gt;</span> 
                                        <span class="bold">&lt;Path&gt;EXTFILES_DIR&lt;/Path&gt;</span>
                                     <span class="bold">&lt;/Datastore&gt;</span>
                                   <span class="bold">&lt;/RDFCTXPreferences&gt;</span>')); 
end;
/
</pre>
<p>The <code>&lt;Datastore&gt;</code> element in the preferences document specifies the type of repository used for the documents to be indexed. When the value for the <code>type</code> attribute is set to <code>FILE</code>, the <code>&lt;Path&gt;</code> element identifies a directory object in the database (created using the SQL statement CREATE DIRECTORY). A table column indexed using the specified extractor policy is expected to contain relative paths to individual files within the directory object, as shown in the following example:</p>
<pre>
CREATE TABLE newsfeed (docid       number, 
                       articleLoc  VARCHAR2(100)); 
INSERT INTO into newsfeed (docid, articleLoc) values
                     (1, '<span class="bold">article1.txt</span>'); 
INSERT INTO newsfeed (docid, articleLoc) values
                     (2, '<span class="bold">folder/article2.txt</span>'); 
 
CREATE INDEX ArticleIndex on newsfeed (articleLoc)
   INDEXTYPE IS mdsys.SemContext PARAMETERS ('<span class="bold">SEM_EXTR_FROM_FILE</span>');
</pre>
<p>To index documents that are accessed using HTTP protocol, create a extractor policy with preferences that set the <code>type</code> attribute of the <code>&lt;Datastore&gt;</code> element to <code>URL</code> and that list one or more hosts in the <code>&lt;Path&gt;</code> elements, as shown in the following excerpt:</p>
<pre>
&lt;RDFCTXPreferences&gt;
   &lt;Datastore <span class="bold">type="URL"</span>&gt; 
       <span class="bold">&lt;Path&gt;http://cnn.com&lt;/Path&gt;</span>
       <span class="bold">&lt;Path&gt;http://abc.com&lt;/Path&gt;</span>
   &lt;/Datastore&gt;
&lt;/RDFCTXPreferences&gt;
</pre>
<p>The schema in which a semantic index for external documents is created must have the necessary privileges to access the external objects, including access to any proxy server used to access documents outside the firewall, as shown in the following example:</p>
<pre>
-- Grant read access to the directory object for FILE data store -- 
grant read on directory EXTFILES_DIR to SEMUSR;
 
-- Grant connect access to set of hosts for URL data store -- 
begin
  dbms_network_acl_admin.create_acl (
                acl          =&gt; 'network_docs.xml',
                description  =&gt; 'Normal Access',
                principal    =&gt; 'SEMUSR',
                is_grant     =&gt; TRUE,
                privilege    =&gt; 'connect');
end;
/
 
begin
  dbms_network_acl_admin.assign_acl (
               acl        =&gt; 'network_docs.xml',
               host       =&gt;  'cnn.com',
               lower_port =&gt; 1,
               upper_port =&gt; 10000);
end;
/
</pre>
<p>External documents that are semantically indexed in the database may be in one of the well-known formats such as Microsoft Word, RTF, and PDF. This takes advantage of the Oracle Text capability to extract plain text version from formatted documents using filters (see the CTX_DOC.POLICY_FILTER procedure, described in <a class="olink CCREF2116" href="../../text.112/e24436/cdocpkg.htm#CCREF2116"><span class="italic">Oracle Text Reference</span></a>). To semantically index formatted documents, you must specify the name of a CTX policy in the extractor preferences, as shown in the following excerpt:</p>
<pre>
&lt;RDFCTXPreferences&gt;
   &lt;Datastore type="FILE" <span class="bold">filter="CTX_FILTER_POLICY"</span>&gt; 
       &lt;Path&gt;EXTFILES_DIR&lt;/Path&gt;
   &lt;/Datastore&gt;
&lt;/RDFCTXPreferences&gt;
</pre>
<p>In the preceding example, the <code>CTX_FILTER_POLICY</code> policy, created using the CTX_DDL.CREATE_POLICY procedure, must exist in your schema. The table columns that are semantically indexed using this preferences document can store paths to formatted documents, from which plain text is extracted using the specified CTX policy. The information extractor associated with the extractor policy then processes the plain text further, to extract the semantics in RDF/XML format.</p>
</div>
<!-- class="sect1" -->
<a id="BEIFGBED"></a>
<div id="RDFRM99930" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.9</span> <a id="sthref268"></a>Configuring the Calais Extractor type</h2>
<p>The CALAIS_EXTRACTOR type, which is a subtype of the RDFCTX_WS_EXTRACTOR type, enables you to access a Web service end point anywhere on the network, including the one that is publicly accessible (<code>OpenCalais.com</code>). To do so, you must connect with SYSDBA privileges and configure the Calais extractor type with Web service end point, the SOAP action, and the license key by setting corresponding parameters, as shown in the following example:</p>
<pre>
begin
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; 'CALAIS_WS_ENDPOINT',
     param_value =&gt; 'http://api1.opencalais.com/enlighten/calais.asmx',
     param_desc  =&gt; 'Calais web service end-point');
       
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; 'CALAIS_KEY',
     param_value =&gt; '&lt;Calais license key goes here&gt;',
     param_desc  =&gt; 'Calais extractor license key');
 
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; 'CALAIS_WS_SOAPACTION',
     param_value =&gt; 'http://clearforest.com/Enlighten',
     param_desc  =&gt; 'Calais web service SOAP Action');
end;
</pre>
<p>To enable access to a Web service outside the firewall, you must also set the parameter for the proxy host, as in the following example:</p>
<pre>
begin
  sem_rdfctx.set_extractor_param (
      param_key   =&gt; 'HTTP_PROXY',
      param_value =&gt; 'www-proxy.acme.com',
      param_desc  =&gt; 'Proxy server');
end;
</pre></div>
<!-- class="sect1" -->
<a id="BEIHCCBD"></a>
<div id="RDFRM99931" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.10</span> <a id="sthref269"></a><a id="sthref270"></a>Working with General Architecture for Text Engineering (GATE)</h2>
<p>General Architecture for Text Engineering (GATE) is an open source natural language processor and information extractor (see <code><a href="http://gate.ac.uk">http://gate.ac.uk</a></code>). You can use GATE to perform semantic indexing of documents stored in the database. The extractor type <code>mdsys.gatenlp_extractor</code> is defined as a subtype of the RDFCTX_EXTRACTOR type. The implementation of this extractor type sends an unstructured document to a GATE engine over a TCP connection, receives corresponding annotations, and converts them into RDF following a user-specified XML style sheet.</p>
<p>The requests for information extraction are handled by a server socket implementation, which instantiates the GATE components and listens to extraction requests at a pre-determined port. The host and the post for the GATE listener are recorded in the database, as shown in the following example, for all instances of the <code>mdsys.gatenlp_extractor</code> type to use.</p>
<pre>
begin 
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; 'GATE_NLP_HOST',
     param_value =&gt; 'gateserver.acme.com',
     param_desc  =&gt; 'Host for GATE NLP Listener ');
       
  sem_rdfctx.set_extractor_param (
     param_key   =&gt; 'GATE_NLP_PORT',
     param_value =&gt; '7687',
     param_desc  =&gt; 'Port for Gate NLP Listener');
end;
</pre>
<p>The server socket application receives an unstructured document and constructs an annotation set with the desired types of annotations. Each annotation in the set may be customized to include additional features, such as the relevant phrase from the input document and some domain specific features. The resulting annotation set is serialized into XML (using the <code>annotationSetToXml</code> method in the <code>gate.corpora.DocumentXmlUtils</code> Java package) and returned back to the socket client.</p>
<p><a id="sthref271"></a><a id="sthref272"></a><a id="sthref273"></a>A sample Java implementation for the GATE listener is available for download from the code samples and examples page on OTN (see <a href="sdo_rdf_concepts.htm#CIHDIBDE">Section 1.11, "Semantic Data Examples (PL/SQL and Java)"</a> for information about this page).</p>
<p>The <code>mdsys.gatenlp_extractor</code> implementation in the database receives the annotation set encoded in XML, and converts it to RDF/XML using an XML style sheet. You can replace the default style sheet (listed in <a href="#BEICBGHI">Section 4.17</a>) used by the <code>mdsys.gatenlp_extractor</code> implementation with a custom style sheet when you instantiate the type.</p>
<p>The following example creates an extractor policy that uses a custom style sheet to generate RDF from the annotation set produced by the GATE extractor:</p>
<pre>
begin
  sem_rdfctx.create_policy (policy_name =&gt; 'GATE_EXTR',
                            extractor   =&gt; mdsys.gatenlp_extractor(
      sys.XMLType('&lt;?xml version="1.0"?&gt; 
                 &lt;xsl:stylesheet version="2.0" 
                    xmlns:xsl="http://www.w3.org/1999/XSL/Transform" &gt;
                   ..
                 &lt;/xsl:stylesheet&gt;')));
end;
/
</pre></div>
<!-- class="sect1" -->
<a id="BEICHADJ"></a>
<div id="RDFRM99932" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.11</span> Creating a New Extractor Type</h2>
<p>You can create a new extractor type by extending the RDFCTX_EXTRACTOR or RDFCTX_WS_EXTRACTOR extractor type. The extractor type to be extended must be accessible using Web service calls. The schema in which the new extractor type is created must be granted additional privileges to allow creation of the subtype. For example, if a new extractor type is created in the schema RDFCTXU, you must enter the following commands to grant the UNDER and RDFCTX_ADMIN privileges to that schema:</p>
<pre>
GRANT under ON mdsys.rdfctx_extractor TO rdfctxu;
GRANT rdfctx_admin TO rdfctxu;
</pre>
<p>As an example, assume that an information extractor can process an incoming document and return an XML document that contains extracted information. To enable the information extractor to be invoked using a PL/SQL wrapper, you can create the corresponding extractor type implementation, as in the following example:</p>
<pre>
create or replace type rdfctxu.info_extractor under rdfctx_extractor (
  xsl_trans   sys.XMLtype,
  constructor function info_extractor (
                 xsl_trans  sys.XMLType ) return self as result,
  overriding member function getDescription return VARCHAR2,
  overriding member function rdfReturnType return VARCHAR2,
  overriding member function extractRDF(document CLOB,
                                        docId    VARCHAR2) return CLOB
)
/
 
create or replace type body rdfctxu.info_extractor as 
  constructor function info_extractor (
                 xsl_trans  sys.XMLType ) return self as result is
  begin
    self.extr_type := 'Info Extractor Inc.'; 
    -- XML style sheet to generate RDF/XML from proprietary XML documents
    self.xsl_trans := xsl_trans; 
    return;
  end info_extractor; 
 
  overriding member function getDescription return VARCHAR2 is
  begin
    return 'Extactor by Info Extractor Inc.';
  end getDescription;
 
  overriding member function rdfReturnType return VARCHAR2 is
  begin
    return 'RDF/XML';
  end rdfReturnType;
 
  overriding member function extractRDF(document CLOB,
                                        docId    VARCHAR2) return CLOB is
    ce_xmlt  sys.xmltype;
  begin
    EXECUTE IMMEDIATE 
      'begin :1 = info_extract_xml(doc =&gt; :2); end;'
       USING IN OUT ce_xmlt, IN document;
 
    -- Now pass the ce_xmlt through RDF/XML transformation -- 
    return ce_xmlt.transform(self.xsl_trans).getClobVal();
  end extractRdf;
 
end;
</pre>
<p>In the preceding example:</p>
<ul>
<li>
<p>The implementation for the created <code>info_extractor</code> extractor type relies on the XML style sheet, set in the constructor, to generate RDF/XML from the proprietary XML schema used by the underlying information extractor.</p>
</li>
<li>
<p>The <code>extractRDF</code> function assumes that the <code>info_extract_xml</code> function contacts the desired information extractor and returns an XML document with the information extracted from the document that was passed in.</p>
</li>
<li>
<p>The XML style sheet is applied on the XML document to generate equivalent RDF/XML, which is returned by the <code>extractRDF</code> function.</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="BEIGCHHJ"></a>
<div id="RDFRM223" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.12</span> Creating a Local Semantic Index on a Range-Partitioned Table</h2>
<p>A local index can be created on a VARCHAR2 or CLOB column of a range-partitioned table by using the following syntax:</p>
<pre>
CREATE INDEX <span class="italic">&lt;index-name&gt;</span> &hellip; LOCAL;
</pre>
<p>The following example creates a range-partitioned table and a local semantic index on that table:</p>
<pre>
CREATE TABLE part_newsfeed (
  docid number, article CLOB, cdate DATE) 
partition by range (cdate)
(partition p1 values less than (to_date('01-Jan-2001')),
 partition p2 values less than (to_date('01-Jan-2004')),
 partition p3 values less than (to_date('01-Jan-2008')),
 partition p4 values less than (to_date('01-Jan-2012'))
);
 
CREATE INDEX ArticleLocalIndex on part_newsfeed (article)
   INDEXTYPE IS mdsys.SemContext PARAMETERS ('SEM_EXTR')
LOCAL;
</pre>
<p>Note that every partition of the local semantic index will have content generated for the same set of policies. When you use the ALTER INDEX statement on a local index to add or drop policies associated with a semantic index partition, you should try to keep the same set of policies associated with each partition. You can achieve this result by using ALTER INDEX statements in a loop over the set of partitions. (For more information about altering semantic indexes, see <a href="#BEIHEHEI">Section 4.13</a>,)</p>
</div>
<!-- class="sect1" -->
<a id="BEIHEHEI"></a>
<div id="RDFRM224" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.13</span> Altering a Semantic Index</h2>
<p>This section discusses using the ALTER INDEX statement with a semantic index. For a local semantic index, the ALTER INDEX statement applies to a specified partition. The general syntax of the ALTER INDEX command for a semantic index is as follows:</p>
<pre>
ALTER INDEX <span class="italic">&lt;index-name&gt;</span> REBUILD [PARTITION <span class="italic">&lt;index-partition-name&gt;</span>]
  [PARAMETERS ('-<span class="italic">&lt;action_for_policy&gt;</span> <span class="italic">&lt;policy-name&gt;</span>')];
</pre>
<div id="RDFRM225" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref274"></a>
<h3 class="sect2"><span class="secnum">4.13.1</span> Rebuilding Content for All Existing Policies in a Semantic Index</h3>
<p>If the PARAMETERS clause is not included in the ALTER INDEX statement, the content of the semantic index (or index partition) is rebuilt for every policy presently associated with the index. The following are two examples:</p>
<pre>
ALTER INDEX ArticleIndex REBUILD;
ALTER INDEX ArticleLocalIndex REBUILD PARTITION p1;
</pre></div>
<!-- class="sect2" -->
<div id="RDFRM226" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref275"></a>
<h3 class="sect2"><span class="secnum">4.13.2</span> Rebuilding to Add Content for a New Policy to a Semantic Index</h3>
<p>Using <code>add_policy</code> for <span class="italic">&lt;action_for_policy&gt;</span>, you can add content for a new base policy or a dependent policy to a semantic index (or index partition). If a dependent policy is being added and if its base policy is not already a part of the index, then content for the base policy is also added implicitly (by invoking the extractor specified as part of the base policy definition). The following is an example:</p>
<pre>
ALTER INDEX ArticleIndex REBUILD PARAMETERS ('-add_policy MY_POLICY');
</pre></div>
<!-- class="sect2" -->
<div id="RDFRM227" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref276"></a>
<h3 class="sect2"><span class="secnum">4.13.3</span> Rebuilding Content for an Existing Policy from a Semantic Index</h3>
<p>Using <code>rebuild_policy</code> for <span class="italic">&lt;action_for_policy&gt;</span>, you can rebuild the content of the semantic index (or index partition) for an existing policy presently associated with the index. The following is an example:</p>
<pre>
ALTER INDEX ArticleIndex REBUILD PARAMETERS ('-rebuild_policy MY_POLICY');
</pre></div>
<!-- class="sect2" -->
<div id="RDFRM228" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref277"></a>
<h3 class="sect2"><span class="secnum">4.13.4</span> Rebuilding to Drop Content for an Existing Policy from a Semantic Index</h3>
<p>Using <code>drop_policy</code> for <span class="italic">&lt;action_for_policy&gt;</span>, you can drop content corresponding to an existing base policy or a dependent policy from a semantic index (or index partition). Note that dropping the content for a base policy will fail if it is the only policy for the index (or index partition) or if it is used by dependent policies associated with this index (or index partition).</p>
<p>The following example drops the content for a policy from an index:</p>
<pre>
ALTER INDEX ArticleIndex REBUILD PARAMETERS ('-drop_policy MY_POLICY');
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEIFAFFJ"></a>
<div id="RDFRM229" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.14</span> Passing Extractor-Specific Parameters in CREATE INDEX and ALTER INDEX</h2>
<p>The CREATE INDEX and ALTER INDEX statements allow the passing of parameters needed by extractors. These parameters are passed on to the extractor using the <code>params</code> parameter of the <code>extractRdf</code> and <code>batchExtractRdf</code> methods. The following two examples show their use:</p>
<pre>
CREATE INDEX ArticleIndex on Newsfeed (article)
  INDEXTYPE IS mdsys.SemContext PARAMETERS ('SEM_EXTR=(NE_ONLY)');

ALTER INDEX ArticleIndex REBUILD 
  PARAMETERS ('-add_policy MY_POLICY=(NE_ONLY)');
</pre></div>
<!-- class="sect1" -->
<a id="BEIGEJGI"></a>
<div id="RDFRM230" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.15</span> <a id="sthref278"></a><a id="sthref279"></a>Performing Document-Centric Inference</h2>
<p>Document-centric inference refers to the ability to infer from each document individually. It does not allow triples extracted from two different documents to be used together for inference. It contrasts with the more common corpus-centric inference, where new triples can be inferred from combinations of triples extracted from multiple documents.</p>
<p>Document-centric inference can be desirable in document search applications because inclusion of a document in the search result is based on the extracted and/or inferred triples for that document only, that is, triples extracted and/or inferred from any other documents in the corpus do not play any role in the selection of this document. (Document-centric inference might be preferred, for example, if there is inconsistency among documents because of differences in the reliability of the data or in the biases of the document creators.)</p>
<p>To perform document-centric inference, use named graph based local inference (explained in <a href="owl_concepts.htm#CIHIAAGH">Section 2.2.11.2</a>) by specifying <code>options =&gt; 'LOCAL_NG_INF=T'</code> in the call to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure.</p>
<p>Entailments created through document-centric inference can be included as content of a semantic index by creating a dependent policy and adding that policy to the semantic index, as shown in <a href="#BEIEDJCI">Example 4-2</a>.</p>
<div id="RDFRM231" class="example">
<p class="titleinexample"><a id="BEIEDJCI"></a>Example 4-2 Using Document-Centric Inference</p>
<pre>
-- Create entailment 'extr_data_inf' using document-centric inference
-- assuming:
--   model_name for semantic index based on base policy: 'RDFCTX_MOD_1'
--    (model name is available from the RDFCTX_INDEX_POLICIES view; 
--     see <a href="#BEICDBIE">Section 4.16.2, "RDFCTX_INDEX_POLICIES View"</a>)
--   ontology: dataOntology
--   rulebase: OWL2RL
-- options: 'LOCAL_NG_INF=T' (for document-centric inference)
BEGIN
sem_apis.create_entailment('extr_data_inf',
  models_in    =&gt; sem_models('RDFCTX_MOD_1', 'dataOntology'),
  rulebases_in =&gt; sem_rulebases('OWL2RL'),
  options      =&gt; 'LOCAL_NG_INF=T');
END;
/
-- Create a dependent policy to augment data extracted using base policy
-- with content of entailment extr_data_inf (computed in previous statement)
BEGIN
sem_rdfctx.create_policy (
  policy_name =&gt; 'SEM_EXTR_PLUS_DATA_INF',
  base_policy =&gt; 'SEM_EXTR',
  user_models =&gt; NULL,
  user_entailments =&gt; sem_models('extr_data_inf'));
END;
/
-- Add the dependent policy to the ARTICLEINDEX index.
EXECUTE sem_rdfctx.add_dependent_policy('ARTICLEINDEX','SEM_EXTR_PLUS_DATA_INF');
</pre></div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="BEICFJEE"></a>
<div id="RDFRM99933" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.16</span> Metadata Views for Semantic Indexing</h2>
<p>This section describes views that contain metadata about semantic indexing.</p>
<div id="RDFRM99934" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref280"></a>
<h3 class="sect2"><span class="secnum">4.16.1</span> MDSYS.RDFCTX_POLICIES View</h3>
<p><a id="sthref281"></a><a id="sthref282"></a>Information about extractor policies defined in the current schema is maintained in the MDSYS.RDFCTX_POLICIES view, which has the columns shown in <a href="#BEIBBEEF">Table 4-1</a> and one row for each extractor policy.</p>
<div id="RDFRM99935" class="tblformal">
<p class="titleintable"><a id="sthref283"></a><a id="BEIBBEEF"></a>Table 4-1 MDSYS.RDFCTX_POLICIES View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFCTX_POLICIES View Columns" summary="MDSYS.RDFCTX_POLICIES view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t2">Column Name</th>
<th class="cellalignment981" id="r1c2-t2">Data Type</th>
<th class="cellalignment981" id="r1c3-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t2" headers="r1c1-t2">
<p>POLICY_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t2 r1c2-t2">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t2 r1c3-t2">
<p>Owner of the extractor policy</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t2" headers="r1c1-t2">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t2 r1c2-t2">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t2 r1c3-t2">
<p>Name of the extractor policy</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t2" headers="r1c1-t2">
<p>EXTRACTOR</p>
</td>
<td class="cellalignment982" headers="r4c1-t2 r1c2-t2">
<p>MDSYS.RDFCTX_EXTRACTOR</p>
</td>
<td class="cellalignment982" headers="r4c1-t2 r1c3-t2">
<p>Instance of extractor type</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t2" headers="r1c1-t2">
<p>IS_DEPENDENT</p>
</td>
<td class="cellalignment982" headers="r5c1-t2 r1c2-t2">
<p>VARCHAR2(3)</p>
</td>
<td class="cellalignment982" headers="r5c1-t2 r1c3-t2">
<p>Contains <code>YES</code> if the extractor policy is dependent on a base policy; contains <code>NO</code> if the extractor policy is not dependent on a base policy.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t2" headers="r1c1-t2">
<p>BASE_POLICY</p>
</td>
<td class="cellalignment982" headers="r6c1-t2 r1c2-t2">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r6c1-t2 r1c3-t2">
<p>For a dependent policy, the name of the base policy</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r7c1-t2" headers="r1c1-t2">
<p>USER_MODELS</p>
</td>
<td class="cellalignment982" headers="r7c1-t2 r1c2-t2">
<p>MDSYS.RDF_MODELS</p>
</td>
<td class="cellalignment982" headers="r7c1-t2 r1c3-t2">
<p>For a dependent policy, a list of the RDF models included in the policy</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="BEICDBIE"></a>
<div id="RDFRM99936" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">4.16.2</span> RDFCTX_INDEX_POLICIES View</h3>
<p><a id="sthref284"></a><a id="sthref285"></a>Information about semantic indexes defined in the current schema and the extractor policies used to create the index is maintained in the MDSYS.RDFCTX_POLICIES view, which has the columns shown in <a href="#BEIBCCAC">Table 4-2</a> and one row for each combination of semantic index and extractor policy.</p>
<div id="RDFRM99937" class="tblformal">
<p class="titleintable"><a id="sthref286"></a><a id="BEIBCCAC"></a>Table 4-2 MDSYS.RDFCTX_INDEX_POLICIES View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFCTX_INDEX_POLICIES View Columns" summary="MDSYS.RDFCTX_INDEX_POLICIES view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t3">Column Name</th>
<th class="cellalignment981" id="r1c2-t3">Data Type</th>
<th class="cellalignment981" id="r1c3-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t3" headers="r1c1-t3">
<p>INDEX_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t3 r1c3-t3">
<p>Owner of the semantic index</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t3" headers="r1c1-t3">
<p>INDEX_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t3 r1c3-t3">
<p>Name of the semantic index</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t3" headers="r1c1-t3">
<p>INDEX_PARTITION</p>
</td>
<td class="cellalignment982" headers="r4c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r4c1-t3 r1c3-t3">
<p>Name of the index partition (for LOCAL index only)</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t3" headers="r1c1-t3">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r5c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r5c1-t3 r1c3-t3">
<p>Name of the extractor policy</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t3" headers="r1c1-t3">
<p>EXTR_PARAMETERS</p>
</td>
<td class="cellalignment982" headers="r6c1-t3 r1c2-t3">
<p>VARCHAR2(100)</p>
</td>
<td class="cellalignment982" headers="r6c1-t3 r1c3-t3">
<p>Parameters specified for the extractor</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r7c1-t3" headers="r1c1-t3">
<p>IS_DEFAULT</p>
</td>
<td class="cellalignment982" headers="r7c1-t3 r1c2-t3">
<p>VARCHAR2(3)</p>
</td>
<td class="cellalignment982" headers="r7c1-t3 r1c3-t3">
<p>Contains <code>YES</code> if POLICY_NAME is the default extractor policy for the index; contains <code>NO</code> if POLICY_NAME is not the default extractor policy for the index.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r8c1-t3" headers="r1c1-t3">
<p>STATUS</p>
</td>
<td class="cellalignment982" headers="r8c1-t3 r1c2-t3">
<p>VARCHAR2(10)</p>
</td>
<td class="cellalignment982" headers="r8c1-t3 r1c3-t3">
<p>Contains <code>VALID</code> if the index is valid, <code>INPROGRESS</code> if the index is being created, or <code>FAILED</code> if a system failure occurred during the creation of the index.</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r9c1-t3" headers="r1c1-t3">
<p>RDF_MODEL</p>
</td>
<td class="cellalignment982" headers="r9c1-t3 r1c2-t3">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r9c1-t3 r1c3-t3">
<p>Name of the RDF model maintaining the index data</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="RDFRM99938" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref287"></a>
<h3 class="sect2"><span class="secnum">4.16.3</span> RDFCTX_INDEX_EXCEPTIONS View</h3>
<p><a id="sthref288"></a><a id="sthref289"></a>Information about exceptions encountered while creating or maintaining semantic indexes in the current schema is maintained in the MDSYS.RDFCTX_INDEX_EXCEPTIONS view, which has the columns shown in <a href="#BEIFIEDE">Table 4-3</a> and one row for each exception.</p>
<div id="RDFRM99939" class="tblformal">
<p class="titleintable"><a id="sthref290"></a><a id="BEIFIEDE"></a>Table 4-3 MDSYS.RDFCTX_INDEX_EXCEPTIONS View Columns</p>
<table class="cellalignment980" title="MDSYS.RDFCTX_INDEX_EXCEPTIONS View Columns" summary="MDSYS.RDFCTX_INDEX_EXCEPTIONS view columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t4">Column Name</th>
<th class="cellalignment981" id="r1c2-t4">Data Type</th>
<th class="cellalignment981" id="r1c3-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t4" headers="r1c1-t4">
<p>INDEX_OWNER</p>
</td>
<td class="cellalignment982" headers="r2c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r2c1-t4 r1c3-t4">
<p>Owner of the semantic index associated with the exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t4" headers="r1c1-t4">
<p>INDEX_NAME</p>
</td>
<td class="cellalignment982" headers="r3c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r3c1-t4 r1c3-t4">
<p>Name of the semantic index associated with the exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t4" headers="r1c1-t4">
<p>POLICY_NAME</p>
</td>
<td class="cellalignment982" headers="r4c1-t4 r1c2-t4">
<p>VARCHAR2(32)</p>
</td>
<td class="cellalignment982" headers="r4c1-t4 r1c3-t4">
<p>Name of the extractor policy associated with the exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t4" headers="r1c1-t4">
<p>DOC_IDENTIFIER</p>
</td>
<td class="cellalignment982" headers="r5c1-t4 r1c2-t4">
<p>VARCHAR2(38)</p>
</td>
<td class="cellalignment982" headers="r5c1-t4 r1c3-t4">
<p>Row identifier (rowid) of the document associated with the exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r6c1-t4" headers="r1c1-t4">
<p>EXCEPTION_TYPE</p>
</td>
<td class="cellalignment982" headers="r6c1-t4 r1c2-t4">
<p>VARCHAR2(13)</p>
</td>
<td class="cellalignment982" headers="r6c1-t4 r1c3-t4">
<p>Type of exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r7c1-t4" headers="r1c1-t4">
<p>EXCEPTION_CODE</p>
</td>
<td class="cellalignment982" headers="r7c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment982" headers="r7c1-t4 r1c3-t4">
<p>Error code associated with the exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r8c1-t4" headers="r1c1-t4">
<p>EXCEPTION_TEXT</p>
</td>
<td class="cellalignment982" headers="r8c1-t4 r1c2-t4">
<p>CLOB</p>
</td>
<td class="cellalignment982" headers="r8c1-t4 r1c3-t4">
<p>Text associated with the exception</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r9c1-t4" headers="r1c1-t4">
<p>EXTRACTED_AT</p>
</td>
<td class="cellalignment982" headers="r9c1-t4 r1c2-t4">
<p>TIMESTAMP</p>
</td>
<td class="cellalignment982" headers="r9c1-t4 r1c3-t4">
<p>Time at which the exception occurred</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEICBGHI"></a>
<div id="RDFRM99940" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">4.17</span> Default Style Sheet for GATE Extractor Output</h2>
<p>This section lists the default XML style sheet that the <code>mdsys.gatenlp_extractor</code> implementation uses to convert the annotation set (encoded in XML) into RDF/XML. (This extractor is explained in <a href="#BEIHCCBD">Section 4.10</a>.)</p>
<pre>
&lt;?xml version="1.0"?&gt; 
  &lt;xsl:stylesheet version="2.0" 
                   xmlns:xsl="http://www.w3.org/1999/XSL/Transform" &gt; 
     &lt;xsl:output encoding="utf-8" indent="yes"/&gt; 
     &lt;xsl:param name="docbase"&gt;http://xmlns.oracle.com/rdfctx/&lt;/xsl:param&gt;
     &lt;xsl:param name="docident"&gt;0&lt;/xsl:param&gt;
     &lt;xsl:param name="classpfx"&gt;
       &lt;xsl:value-of select="$docbase"/&gt;
       &lt;xsl:text&gt;class/&lt;/xsl:text&gt; 
     &lt;/xsl:param&gt;
     &lt;xsl:template match="/"&gt;
        &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" 
                 xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
                 xmlns:owl="http://www.w3.org/2002/07/owl#" 
                 xmlns:prop="http://xmlns.oracle.com/rdfctx/property/"&gt;  
        &lt;xsl:for-each select="AnnotationSet/Annotation"&gt; 
          &lt;rdf:Description&gt; 
            &lt;xsl:attribute name="rdf:about"&gt; 
              &lt;xsl:value-of select="$docbase"/&gt;
              &lt;xsl:text&gt;docref/&lt;/xsl:text&gt;
              &lt;xsl:value-of select="$docident"/&gt;
              &lt;xsl:text&gt;/&lt;/xsl:text&gt;
              &lt;xsl:value-of select="@Id"/&gt;
            &lt;/xsl:attribute&gt;
            &lt;xsl:for-each select="./Feature"&gt; 
              &lt;xsl:choose&gt;
                &lt;xsl:when test="./Name[text()='majorType']"&gt; 
                  &lt;rdf:type&gt; 
                    &lt;xsl:attribute name="rdf:resource"&gt; 
                       &lt;xsl:value-of select="$classpfx"/&gt;
                       &lt;xsl:text&gt;major/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select="translate(./Value/text(),
                                                       ' ', '#')"/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/rdf:type&gt;
                &lt;/xsl:when&gt;
                &lt;xsl:when test="./Name[text()='minorType']"&gt; 
                  &lt;xsl:element name="prop:hasMinorType"&gt; 
                    &lt;xsl:attribute name="rdf:resource"&gt; 
                       &lt;xsl:value-of select="$docbase"/&gt;
                       &lt;xsl:text&gt;minorType/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select="translate(./Value/text(),
                                                       ' ', '#')"/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:when test="./Name[text()='kind']"&gt; 
                  &lt;xsl:element name="prop:hasKind"&gt; 
                    &lt;xsl:attribute name="rdf:resource"&gt; 
                       &lt;xsl:value-of select="$docbase"/&gt;
                       &lt;xsl:text&gt;kind/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select="translate(./Value/text(),
                                                       ' ', '#')"/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:when test="./Name[text()='locType']"&gt; 
                  &lt;xsl:element name="prop:hasLocType"&gt; 
                    &lt;xsl:attribute name="rdf:resource"&gt; 
                       &lt;xsl:value-of select="$docbase"/&gt;
                       &lt;xsl:text&gt;locType/&lt;/xsl:text&gt;
                       &lt;xsl:value-of select="translate(./Value/text(),
                                                       ' ', '#')"/&gt;
                    &lt;/xsl:attribute&gt;  
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:when test="./Name[text()='entityValue']"&gt; 
                  &lt;xsl:element name="prop:hasEntityValue"&gt; 
                    &lt;xsl:attribute name="rdf:datatype"&gt; 
                      &lt;xsl:text&gt;
                         http://www.w3.org/2001/XMLSchema#string
                      &lt;/xsl:text&gt;
                    &lt;/xsl:attribute&gt; 
                    &lt;xsl:value-of select="./Value/text()"/&gt;
                  &lt;/xsl:element&gt; 
                &lt;/xsl:when&gt;
                &lt;xsl:otherwise&gt; 
                  &lt;xsl:element name="prop:has{translate(
                                        substring(./Name/text(),1,1),
                                        'abcdefghijklmnopqrstuvwxyz',
                                        'ABCDEFGHIJKLMNOPQRSTUVWXYZ')}{
                                      substring(./Name/text(),2)}"&gt; 
                     &lt;xsl:attribute name="rdf:datatype"&gt; 
                        &lt;xsl:text&gt;
                          http://www.w3.org/2001/XMLSchema#string
                        &lt;/xsl:text&gt; 
                     &lt;/xsl:attribute&gt; 
                    &lt;xsl:value-of select="./Value/text()"/&gt;
                  &lt;/xsl:element&gt; 
                &lt;/xsl:otherwise&gt; 
              &lt;/xsl:choose&gt;
            &lt;/xsl:for-each&gt; 
          &lt;/rdf:Description&gt; 
        &lt;/xsl:for-each&gt;
        &lt;/rdf:RDF&gt; 
      &lt;/xsl:template&gt;
   &lt;/xsl:stylesheet&gt;
</pre></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment973">
<tr>
<td class="cellalignment982">
<table class="cellalignment978">
<tr>
<td class="cellalignment977"><a href="skos.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment977"><a href="fine_grained_acc.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment984">
<table class="cellalignment976">
<tr>
<td class="cellalignment977"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment977"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment977"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment977"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment977"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment977"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
