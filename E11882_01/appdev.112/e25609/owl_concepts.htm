<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>OWL Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 743" />
<meta name="description" content="Provides usage and reference information about Oracle Database support for semantic technologies, including storage, inference, and query capabilities for data and ontologies based on Resource Description Framework (RDF), RDF Schema (RDFS), and Web Ontology Language (OWL)." />
<meta name="dcterms.created" content="2014-01-26T18:14:11Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Semantic Technologies Developer's Guide" />
<meta name="dcterms.identifier" content="E25609-06" />
<meta name="dcterms.isVersionOf" content="RDFRM" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="sem_glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="sdo_rdf_concepts.htm" title="Previous" type="text/html" />
<link rel="Next" href="skos.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25609.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/26</span> <!-- End Header -->
<div id="RDFRM200" class="chapter"><a id="CHDJBGFI"></a>
<h1 class="chapter"><span class="secnum">2</span> OWL Concepts</h1>
<p>This chapter describes concepts related to the support for a subset of the Web Ontology Language (OWL). It builds on the information in <a href="sdo_rdf_concepts.htm#CIHHEDAC">Chapter 1</a>, and it assumes that you are familiar with the major concepts associated with OWL, such as ontologies, properties, and relationships. For detailed information about OWL, see the <span class="italic">OWL Web Ontology Language Reference</span> at <code><a href="http://www.w3.org/TR/owl-ref/">http://www.w3.org/TR/owl-ref/</a></code>.</p>
<p>This chapter contains the following major sections:</p>
<ul>
<li>
<p><a href="#CIHIIFAB">Section 2.1, "Ontologies"</a></p>
</li>
<li>
<p><a href="#CIHHIHJI">Section 2.2, "Using OWL Inferencing"</a></p>
</li>
<li>
<p><a href="#CHDBAGBH">Section 2.3, "Using Semantic Operators to Query Relational Data"</a></p>
</li>
</ul>
<a id="CIHIIFAB"></a>
<div id="RDFRM614" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">2.1</span> Ontologies</h2>
<p>An <span class="bold">ontology</span> is a shared conceptualization of knowledge in a particular domain. It consists of a collection of classes, properties, and optionally instances. Classes are typically related by class hierarchy (subclass/ superclass relationship). Similarly, the properties can be related by property hierarchy (subproperty/ superproperty relationship). Properties can be symmetric or transitive, or both. Properties can also have domain, ranges, and cardinality constraints specified for them.</p>
<p>RDFS-based ontologies only allow specification of class hierarchies, property hierarchies, <code>instanceOf</code> relationships, and a domain and a range for properties.</p>
<p>OWL ontologies build on RDFS-based ontologies by additionally allowing specification of property characteristics. OWL ontologies can be further classified as OWL-Lite, OWL-DL, and OWL Full. OWL-Lite restricts the cardinality minimum and maximum values to 0 or 1. OWL-DL relaxes this restriction by allowing minimum and maximum values. OWL Full allows instances to be also defined as a class, which is not allowed in OWL-DL and OWL-Lite ontologies.</p>
<p><a href="#CHDGFFDG">Section 2.1.2</a> describes OWL capabilities that are supported and not supported with semantic data.</p>
<a id="CHDHCIDI"></a>
<div id="RDFRM615" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.1.1</span> Example: Cancer Ontology</h3>
<p><a href="#CHDDIAHC">Figure 2-1</a> shows part of a cancer ontology, which describes the classes and properties related to cancer. One requirement is to have a PATIENTS data table with a column named DIAGNOSIS, which must contain a value from the <code>Diseases_and_Disorders</code> class hierarchy.</p>
<div id="RDFRM616" class="figure">
<p class="titleinfigure"><a id="CHDDIAHC"></a>Figure 2-1 Cancer Ontology Example</p>
<img width="367" height="289" src="img/cancer_ontology.gif" alt="Description of Figure 2-1 follows" /><br />
<a id="sthref192" href="img_text/cancer_ontology.htm">Description of "Figure 2-1 Cancer Ontology Example"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In the cancer ontology shown in <a href="#CHDDIAHC">Figure 2-1</a>, the diagnosis <code>Immune_System_Disorder</code> includes two subclasses, <code>Autoimmune_Disease</code> and <code>Immunodeficiency_Syndrome</code>. The <code>Autoimmune_Disease</code> diagnosis includes the subclass <code>Rheumatoid_Arthritis</code>; and the <code>Immunodeficiency_Syndrome</code> diagnosis includes the subclass <code>T_Cell_Immunodeficiency</code>, which includes the subclass <code>AIDS</code>.</p>
<p>The data in the PATIENTS table might include the PATIENT_ID and DIAGNOSIS column values shown in <a href="#CHDEEGAC">Table 2-1</a>.</p>
<div id="RDFRM617" class="tblformal">
<p class="titleintable"><a id="sthref193"></a><a id="CHDEEGAC"></a>Table 2-1 PATIENTS Table Example Data</p>
<table class="cellalignment980" title="PATIENTS Table Example Data" summary="PATIENTS table example data" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t2">PATIENT_ID</th>
<th class="cellalignment981" id="r1c2-t2">DIAGNOSIS</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t2" headers="r1c1-t2">
<p>1234</p>
</td>
<td class="cellalignment982" headers="r2c1-t2 r1c2-t2">
<p>Rheumatoid_Arthritis</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t2" headers="r1c1-t2">
<p>2345</p>
</td>
<td class="cellalignment982" headers="r3c1-t2 r1c2-t2">
<p>Immunodeficiency_Syndrome</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t2" headers="r1c1-t2">
<p>3456</p>
</td>
<td class="cellalignment982" headers="r4c1-t2 r1c2-t2">
<p>AIDS</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>To query ontologies, you can use the SEM_MATCH table function (described in <a href="sdo_rdf_concepts.htm#CHDJACII">Section 1.6</a>) or the SEM_RELATED operator and its ancillary operators (described in <a href="#CHDBAGBH">Section 2.3</a>).</p>
</div>
<!-- class="sect2" -->
<a id="CHDGFFDG"></a>
<div id="RDFRM618" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.1.2</span> Supported OWL Subsets</h3>
<p>This section describes OWL vocabulary subsets that are supported.</p>
<p>Oracle Database supports the RDFS++, OWLSIF, and OWLPrime vocabularies, which have increasing expressivity, as well as OWL 2 RL. Each supported vocabulary has a corresponding rulebase; however, these rulebases do not need to be populated because the underlying entailment rules of these three vocabularies are internally implemented. The supported vocabularies are as follows:</p>
<ul>
<li>
<p>RDFS++: A minimal extension to RDFS; which is RDFS plus <code>owl:sameAs</code> and <code>owl:InverseFunctionalProperty</code>.</p>
</li>
<li>
<p>OWLSIF: OWL with IF Semantic, with the vocabulary and semantics proposed for pD* semantics in <span class="italic">Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary</span>, by H.J. Horst, Journal of Web Semantics 3, 2 (2005), 79&ndash;115.</p>
</li>
<li>
<p>OWLPrime: The following OWL capabilities:</p>
<ul>
<li>
<p>Basics: class, subclass, property, subproperty, domain, range, type</p>
</li>
<li>
<p>Property characteristics: transitive, symmetric, functional, inverse functional, inverse</p>
</li>
<li>
<p>Class comparisons: equivalence, disjointness</p>
</li>
<li>
<p>Property comparisons: equivalence</p>
</li>
<li>
<p>Individual comparisons: same, different</p>
</li>
<li>
<p>Class expressions: complement</p>
</li>
<li>
<p>Property restrictions: <code>hasValue</code>, <code>someValuesFrom</code>, <code>allValuesFrom</code></p>
<p>As with pD*, the supported semantics for these value restrictions are only intensional (IF semantics).</p>
</li>
</ul>
</li>
<li>
<p><a id="sthref194"></a><a id="sthref195"></a>OWL 2 RL: Described in the "OWL 2 RL" section of the W3C <span class="italic">OWL 2 Web Ontology Language Profiles</span> recommendation (<code><a href="http://www.w3.org/TR/owl-profiles/#OWL_2_RL">http://www.w3.org/TR/owl-profiles/#OWL_2_RL</a></code>) as: "The OWL 2 RL profile is aimed at applications that require scalable reasoning without sacrificing too much expressive power. It is designed to accommodate both OWL 2 applications that can trade the full expressivity of the language for efficiency, and RDF(S) applications that need some added expressivity from OWL 2."</p>
<p>The system-defined rulebase <code>OWL2RL</code> supports all the standard production rules defined for OWL 2 RL. As with <code>OWLPRIME</code>, users will not see any rules in this OWL2RL rulebase. Note that the rulebase <code>OWL2RL</code> will be created automatically if it does not already exist.</p>
<p>The following code excerpt uses the OWL2RL rulebase:</p>
<pre>
CREATE TABLE m1_tpl (triple SDO_RDF_TRIPLE_S) COMPRESS;
EXECUTE sem_apis.create_sem_model('m1','m1_tpl','triple');
-- Insert data into model M1. Details omitted
...
-- Now run inference using the OWL2RL rulebase
EXECUTE sem_apis.create_entailment('m1_inf',sem_models('m1'),<span class="bold">sem_rulebases('owl2rl')</span>);
</pre>
<p>Note that inference-related optimization, such as parallel inference and RAW8, are all applicable when the <code>OWL2RL</code> rulebase is used.</p>
</li>
</ul>
<p><a href="#CIHDFACE">Table 2-2</a> lists the RDFS/OWL vocabulary constructs included in each supported rulebase.</p>
<div id="RDFRM619" class="tblformal">
<p class="titleintable"><a id="sthref196"></a><a id="CIHDFACE"></a>Table 2-2 RDFS/OWL Vocabulary Constructs Included in Each Supported Rulebase</p>
<table class="cellalignment980" title="RDFS/OWL Vocabulary Constructs Included in Each Supported Rulebase" summary="RDFS/OWL Vocabulary Constructs Included in Each Supported Rulebase" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t3">Rulebase Name</th>
<th class="cellalignment981" id="r1c2-t3">RDFS/OWL Constructs Included</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t3" headers="r1c1-t3">
<p>RDFS++</p>
</td>
<td class="cellalignment982" headers="r2c1-t3 r1c2-t3">
<p>all RDFS vocabulary constructs</p>
<p>owl:InverseFunctionalProperty</p>
<p>owl:sameAs</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t3" headers="r1c1-t3">
<p>OWLSIF</p>
</td>
<td class="cellalignment982" headers="r3c1-t3 r1c2-t3">
<p>all RDFS vocabulary constructs</p>
<p>owl:FunctionalProperty</p>
<p>owl:InverseFunctionalProperty</p>
<p>owl:SymmetricProperty</p>
<p>owl:TransitiveProperty</p>
<p>owl:sameAs</p>
<p>owl:inverseOf</p>
<p>owl:equivalentClass</p>
<p>owl:equivalentProperty</p>
<p>owl:hasValue</p>
<p>owl:someValuesFrom</p>
<p>owl:allValuesFrom</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t3" headers="r1c1-t3">
<p>OWLPrime</p>
</td>
<td class="cellalignment982" headers="r4c1-t3 r1c2-t3">
<p>rdfs:subClassOf</p>
<p>rdfs:subPropertyOf</p>
<p>rdfs:domain</p>
<p>rdfs:range</p>
<p>owl:FunctionalProperty</p>
<p>owl:InverseFunctionalProperty</p>
<p>owl:SymmetricProperty</p>
<p>owl:TransitiveProperty</p>
<p>owl:sameAs</p>
<p>owl:inverseOf</p>
<p>owl:equivalentClass</p>
<p>owl:equivalentProperty</p>
<p>owl:hasValue</p>
<p>owl:someValuesFrom</p>
<p>owl:allValuesFrom</p>
<p>owl:differentFrom</p>
<p>owl:disjointWith</p>
<p>owl:complementOf</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r5c1-t3" headers="r1c1-t3">
<p>OWL2RL</p>
</td>
<td class="cellalignment982" headers="r5c1-t3 r1c2-t3">
<p>(As described in <code><a href="http://www.w3.org/TR/owl-profiles/#OWL_2_RL">http://www.w3.org/TR/owl-profiles/#OWL_2_RL</a></code>)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHHIHJI"></a>
<div id="RDFRM620" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">2.2</span> Using OWL Inferencing</h2>
<p>You can use entailment rules to perform native OWL inferencing. This section creates a simple ontology, performs native inferencing, and illustrates some more advanced features.</p>
<div id="RDFRM621" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref197"></a>
<h3 class="sect2"><span class="secnum">2.2.1</span> Creating a Simple OWL Ontology</h3>
<p><a href="#CIHFBIAG">Example 2-1</a> creates a simple OWL ontology, inserts one statement that two URIs refer to the same entity, and performs a query using the SEM_MATCH table function.</p>
<div id="RDFRM622" class="example">
<p class="titleinexample"><a id="CIHFBIAG"></a>Example 2-1 Creating a Simple OWL Ontology</p>
<pre>
SQL&gt; CREATE TABLE owltst(id number, triple sdo_rdf_triple_s);
Table created.
 
SQL&gt; EXECUTE sem_apis.create_sem_model('owltst','owltst','triple');
PL/SQL procedure successfully completed.
 
SQL&gt; INSERT INTO owltst VALUES (1, sdo_rdf_triple_s('owltst',
       'http://example.com/name/John', 'http://www.w3.org/2002/07/owl#sameAs', 
       'http://example.com/name/JohnQ'));
1 row created.
 
SQL&gt; commit;
 
SQL&gt; -- Use SEM_MATCH to perform a simple query.
SQL&gt; select s,p,o from table(SEM_MATCH('(?s ?p  ?o)', SEM_Models('OWLTST'),
           null,  null, null ));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="RDFRM623" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref198"></a>
<h3 class="sect2"><span class="secnum">2.2.2</span> Performing Native OWL inferencing</h3>
<p><a href="#CIHBIEIC">Example 2-2</a> calls the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure. You do not need to create the rulebase and add rules to it, because the OWL rules are already built into the Oracle semantic technologies inferencing engine.</p>
<div id="RDFRM624" class="example">
<p class="titleinexample"><a id="CIHBIEIC"></a>Example 2-2 Performing Native OWL Inferencing</p>
<pre>
SQL&gt; -- Invoke the following command to run native OWL inferencing that
SQL&gt; -- understands the vocabulary defined in the preceding section.
SQL&gt;
SQL&gt;  EXECUTE sem_apis.create_entailment('owltst_idx', sem_models('owltst'), sem_rulebases('OWLPRIME'));
PL/SQL procedure successfully completed.
 
SQL&gt; -- The following view is generated to represent the entailed graph (rules index).
SQL&gt; desc mdsys.semi_owltst_idx;
 
SQL&gt; -- Run the preceding query with an additional rulebase parameter to list
SQL&gt; -- the original graph plus the inferred triples.
SQL&gt; SELECT s,p,o FROM table(SEM_MATCH('(?s ?p  ?o)', SEM_MODELS('OWLTST'),
           SEM_RULEBASES('OWLPRIME'),  null, null ));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="RDFRM625" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref199"></a>
<h3 class="sect2"><span class="secnum">2.2.3</span> Performing OWL and User-Defined Rules inferencing</h3>
<p><a href="#CIHCAHEI">Example 2-3</a> creates a user-defined rulebase, inserts a simplified <code>uncleOf</code> rule (stating that the brother of one's father is one's uncle), and calls the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure.</p>
<div id="RDFRM626" class="example">
<p class="titleinexample"><a id="CIHCAHEI"></a>Example 2-3 Performing OWL and User-Defined Rules Inferencing</p>
<pre>
SQL&gt; -- First, insert the following assertions.
 
SQL&gt; INSERT INTO owltst VALUES (1, sdo_rdf_triple_s('owltst',
       'http://example.com/name/John', 'http://example.com/rel/fatherOf',
       'http://example.com/name/Mary'));
 
 
SQL&gt; INSERT INTO owltst VALUES (1, sdo_rdf_triple_s('owltst',
       'http://example.com/name/Jack', 'http://example.com/rel/brotherOf',
       'http://example.com/name/John'));
 
SQL&gt; -- Create a user-defined rulebase.
 
SQL&gt; EXECUTE sem_apis.create_rulebase('user_rulebase');
 
SQL&gt; -- Insert a simple "uncle" rule.
 
SQL&gt; INSERT INTO mdsys.semr_user_rulebase VALUES ('uncle_rule', 
'(?x &lt;http://example.com/rel/brotherOf&gt; ?y)(?y &lt;http://example.com/rel/fatherOf&gt; ?z)',
NULL, '(?x &lt;http://example.com/rel/uncleOf&gt; ?z)', null);
 
SQL&gt;  -- In the following statement, 'USER_RULES=T' is required, to
SQL&gt; --  include the original graph plus the inferred triples.
SQL&gt; EXECUTE sem_apis.create_entailment('owltst2_idx', sem_models('owltst'),
          sem_rulebases('OWLPRIME','USER_RULEBASE'), 
          SEM_APIS.REACH_CLOSURE, null, 'USER_RULES=T');
 
SQL&gt; -- In the result of the following query, :Jack :uncleOf :Mary is inferred.
SQL&gt; SELECT s,p,o FROM table(SEM_MATCH('(?s ?p  ?o)',
           SEM_MODELS('OWLTST'),
           SEM_RULEBASES('OWLPRIME','USER_RULEBASE'),  null, null ));
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="RDFRM627" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref200"></a>
<h3 class="sect2"><span class="secnum">2.2.4</span> Generating OWL inferencing Proofs</h3>
<p>OWL inference can be complex, depending on the size of the ontology, the actual vocabulary (set of language constructs) used, and the interactions among those language constructs. To enable you to find out how a triple is derived, you can use proof generation during inference. (Proof generation does require additional CPU time and disk resources.)</p>
<p>To generate the information required for proof, specify <code>PROOF=T</code> in the call to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as shown in the following example:</p>
<pre>
EXECUTE sem_apis.create_entailment('owltst_idx', sem_models('owltst'), -
  sem_rulebases('owlprime'), SEM_APIS.REACH_CLOSURE, 'SAM', 'PROOF=T');
</pre>
<p>Specifying <code>PROOF=T</code> causes a view to be created containing proof for each inferred triple. The view name is the entailment name prefixed by <code>MDSYS.SEMI_</code>. Two relevant columns in this view are LINK_ID and EXPLAIN (the proof). The following example displays the LINK_ID value and proof of each generated triple (with LINK_ID values shortened for simplicity):</p>
<pre>
SELECT link_id || ' generated by ' || explain as 
          triple_and_its_proof FROM mdsys.semi_owltst_idx;
 
TRIPLE_AND_ITS_PROOF
--------------------------------------------------------------------
8_5_5_4 generated by 4_D_5_5 : SYMM_SAMH_SYMM
8_4_5_4 generated by 8_5_5_4 4_D_5_5 : SAM_SAMH
. . .
</pre>
<p>A proof consists of one or more triple (link) ID values and the name of the rule that is applied on those triples:</p>
<p><code><span class="codeinlineitalic">link-id1</span></code> [<code><span class="codeinlineitalic">link-id2</span></code> ... l<code><span class="codeinlineitalic">ink-idn</span></code>] : <code><span class="codeinlineitalic">rule-name</span></code></p>
<p>To get the full subject, predicate, and object URIs for proofs, you can query the model view and the entailment (rules index) view. <a href="#CIHGAGID">Example 2-4</a> displays the LINK_ID value and associated triple contents using the model view MDSYS.SEMM_OWLTST and the entailment view MDSYS.SEMI_OWLTST_IDX.</p>
<div id="RDFRM628" class="example">
<p class="titleinexample"><a id="CIHGAGID"></a>Example 2-4 Displaying Proof Information</p>
<pre>
SELECT to_char(x.triple.rdf_m_id, 'FMXXXXXXXXXXXXXXXX') ||'_'||
       to_char(x.triple.rdf_s_id, 'FMXXXXXXXXXXXXXXXX') ||'_'||
       to_char(x.triple.rdf_p_id, 'FMXXXXXXXXXXXXXXXX') ||'_'||
       to_char(x.triple.rdf_c_id, 'FMXXXXXXXXXXXXXXXX'),
       x.triple.get_triple()
  FROM (
   SELECT sdo_rdf_triple_s(
           t.canon_end_node_id,
           t.model_id, 
           t.start_node_id,
           t.p_value_id,
           t.end_node_id) triple
     FROM (select * from mdsys.semm_owltst union all
           select * from mdsys.semi_owltst_idx
          ) t  
    WHERE t.link_id IN ('4_D_5_5','8_5_5_4')
  ) x;
 
   LINK_ID  X.TRIPLE.GET_TRIPLE()(SUBJECT, PROPERTY, OBJECT)
----------  --------------------------------------------------------------
4_D_5_5 SDO_RDF_TRIPLE('&lt;http://example.com/name/John&gt;', '&lt;http://www.w3.org/2002/07/owl#sameAs&gt;', '&lt;http://example.com/name/JohnQ&gt;')
8_5_5_4 SDO_RDF_TRIPLE('&lt;http://example.com/name/JohnQ&gt;', '&lt;http://www.w3.org/2002/07/owl#sameAs&gt;', '&lt;http://example.com/name/John&gt;')
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHGAGID">Example 2-4</a>, for the proof entry 8_5_5_4 generated by 4_D_5_5 : SYMM_SAMH_SYMM for the triple with LINK_ID = 8_5_5_4, it is inferred from the triple with 4_D_5_5 using the symmetricity of <code>owl:sameAs</code>.</p>
<p>If the entailment status is INCOMPLETE and if the last entailment was generated without proof information, you cannot invoke <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> with <code>PROOF=T</code>. In this case, you must first drop the entailment and create it again specifying <code>PROOF=T</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHJGDAI"></a>
<div id="RDFRM629" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.2.5</span> Validating OWL Models and Entailments</h3>
<p>An OWL ontology may contain errors, such as unsatisfiable classes, instances belonging to unsatisfiable classes, and two individuals asserted to be same and different at the same time. You can use the <a href="sem_apis_ref.htm#CHEJBBJD">SEM_APIS.VALIDATE_MODEL</a> and <a href="sem_apis_ref.htm#CHEJFDJG">SEM_APIS.VALIDATE_ENTAILMENT</a> functions to detect inconsistencies in the original data model and in the entailment, respectively.</p>
<p><a href="#CIHIJDFA">Example 2-5</a> shows uses the <a href="sem_apis_ref.htm#CHEJFDJG">SEM_APIS.VALIDATE_ENTAILMENT</a> function, which returns a null value if no errors are detected or a VARRAY of strings if any errors are detected.</p>
<div id="RDFRM630" class="example">
<p class="titleinexample"><a id="CIHIJDFA"></a>Example 2-5 Validating an Entailment</p>
<pre>
SQL&gt;  -- Insert an offending triple.
SQL&gt;  insert into owltst values (1, sdo_rdf_triple_s('owltst',
             'urn:C1', 'http://www.w3.org/2000/01/rdf-schema#subClassOf', 'http://www.w3.org/2002/07/owl#Nothing'));
 
SQL&gt; -- Drop entailment first.
SQL&gt;  exec sem_apis.drop_entailment('owltst_idx');
PL/SQL procedure successfully completed.
 
SQL&gt; -- Perform OWL inferencing.
SQL&gt; exec sem_apis.create_entailment('owltst_idx', sem_models('OWLTST'), sem_rulebases('OWLPRIME'));
PL/SQL procedure successfully completed.
 
SQL &gt; set serveroutput on; 
SQL &gt; -- Now invoke validation API: sem_apis.validate_entailment
SQL &gt; 
declare 
  lva mdsys.rdf_longVarcharArray; 
  idx int; 
begin 
  lva := sem_apis.validate_entailment(sem_models('OWLTST'), sem_rulebases('OWLPRIME')) ; 
 
  if (lva is null) then
   dbms_output.put_line('No errors found.');
  else 
    for idx in 1..lva.count loop 
      dbms_output.put_line('Offending entry := ' || lva(idx)) ; 
    end loop ; 
  end if;
end ; 
/ 
 
SQL&gt; -- NOTE: The LINK_ID value and the numbers in the following
SQL&gt; -- line are shortened for simplicity in this example. -- 

          Offending entry  := <span class="codeinlinebold">1 10001 (4_2_4_8 2 4 8) Unsatisfiable class.</span>
</pre></div>
<!-- class="example" -->
<p>Each item in the validation report array includes the following information:</p>
<ul>
<li>
<p>Number of triples that cause this error (<code>1</code> in <a href="#CIHIJDFA">Example 2-5</a>)</p>
</li>
<li>
<p>Error code (<code>10001</code> <a href="#CIHIJDFA">Example 2-5</a>)</p>
</li>
<li>
<p>One or more triples (shown in parentheses in the output; <code>(4_2_4_8 2 4 8)</code> in <a href="#CIHIJDFA">Example 2-5</a>).</p>
<p>These numbers are the LINK_ID value and the ID values of the subject, predicate, and object.</p>
</li>
<li>
<p>Descriptive error message (<code>Unsatisfiable class.</code> in <a href="#CIHIJDFA">Example 2-5</a>)</p>
</li>
</ul>
<p>The output in <a href="#CIHIJDFA">Example 2-5</a> indicates that the error is caused by one triple that asserts that a class is a subclass of an empty class <code>owl:Nothing</code>.</p>
</div>
<!-- class="sect2" -->
<div id="RDFRM631" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref201"></a>
<h3 class="sect2"><span class="secnum">2.2.6</span> Using SEM_APIS.CREATE_ENTAILMENT for RDFS Inference</h3>
<p>In addition to accepting OWL vocabularies, the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure accepts RDFS rulebases. The following example shows RDFS inference (all standard RDFS rules are defined in <code>http://www.w3.org/TR/rdf-mt/</code>):</p>
<pre>
EXECUTE sem_apis.create_entailment('rdfstst_idx', sem_models('my_model'), sem_rulebases('RDFS'));
</pre>
<p>Because rules RDFS4A, RDFS4B, RDFS6, RDFS8, RDFS10, RDFS13 may not generate meaningful inference for your applications, you can deselect those components for faster inference. The following example deselects these rules.</p>
<pre>
EXECUTE sem_apis.create_entailment('rdfstst_idx', sem_models('my_model'), sem_rulebases('RDFS'), SEM_APIS.REACH_CLOSURE, -
 <span class="bold">'RDFS4A-, RDFS4B-, RDFS6-, RDFS8-, RDFS10-, RDFS13-'</span>);
</pre></div>
<!-- class="sect2" -->
<a id="CIHIAFBB"></a>
<div id="RDFRM632" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.2.7</span> Enhancing Inference Performance</h3>
<p>This section describes suggestions for improving the performance of inference operations.</p>
<ul>
<li>
<p>Collect statistics before inferencing. After you load a large RDF/OWL data model, you should execute the <a href="sem_perf_ref.htm#CHEIJACB">SEM_PERF.GATHER_STATS</a> procedure. See the Usage Notes for that procedure (in <a href="sem_perf_ref.htm#CHEBGBCI">Chapter 11</a>) for important usage information.</p>
</li>
<li>
<p>Allocate sufficient temporary tablespace for inference operations. OWL inference support in Oracle relies heavily on table joins, and therefore uses significant temporary tablespace.</p>
</li>
<li>
<p>Use the appropriate implementations of the SVFH and AVFH inference components.</p>
<p>The default implementations of the SVFH and AVFH inference components work best when the number of restriction classes defined by <code>owl:someValuesFrom</code> and/or <code>owl:allValuesFrom</code> is low (as in the LUBM data sets). However, when the number of such classes is high (as in the Gene Ontology <code><a href="http://www.geneontology.org/">http://www.geneontology.org/</a></code>), using non-procedural implementations of SVFH and AVFH may significantly improve performance.</p>
<p><a id="sthref202"></a><a id="sthref203"></a>To disable the procedural implementations and to select the non-procedural implementations of SVFH and AVFH, include <code>'PROCSVFH=F'</code> and/or <code>'PROCAVFH=F'</code> in the options to <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a>. Using the appropriate implementation for an ontology can provide significant performance benefits. For example, selecting the non-procedural implementation of SVFH for the NCI Thesaurus ontology (<code><a href="https://cabig.nci.nih.gov/community/concepts/EVS/">https://cabig.nci.nih.gov/community/concepts/EVS/</a></code>) produced a 960% performance improvement for the SVFH inference component (tested on a dual-core, 8GB RAM desktop system with 3 SATA disks tied together with Oracle ASM).</p>
</li>
</ul>
<p>See also <a href="#CIHGBHFF">Section 2.2.8, "Optimizing owl:sameAs Inference"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHGBHFF"></a>
<div id="RDFRM99906" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.2.8</span> <a id="sthref204"></a><a id="sthref205"></a><a id="sthref206"></a>Optimizing owl:sameAs Inference</h3>
<p>You can optimize inference performance for large <code>owl:sameAs</code> cliques by specifying <code>'OPT_SAMEAS=T'</code> in the <code>options</code> parameter when performing OWLPrime entailment. (A <span class="bold">clique</span> is a graph in which every node of it is connected to, bidirectionally, every other node in the same graph.)</p>
<p>According to OWL semantics, the <code>owl:sameAs</code> construct is treated as an equivalence relation, so it is reflexive, symmetric, and transitive. As a result, during inference a full materialization of <code>owl:sameAs</code>-related entailments could significantly increase the size of the inferred graph. Consider the following example triple set:</p>
<pre>
:John  owl:sameAs  :John1 .
:John  owl:sameAs  :John2 .
:John2 :hasAge     "32" .
</pre>
<p>Applying OWLPrime inference (with the <code>SAM</code> component specified) to this set would generate the following new triples:</p>
<pre>
:John1  owl:sameAs  :John .
:John2  owl:sameAs  :John .
:John1  owl:sameAs  :John2 .
:John2  owl:sameAs  :John1 .
:John   owl:sameAs  :John .
:John1  owl:sameAs  :John1 .
:John2  owl:sameAs  :John2 .
:John   :hasAge     "32" . 
:John1  :hasAge     "32" .
</pre>
<p>In the preceding example, <code>:John</code>, <code>:John1</code> and <code>:John2</code> are connected to each other with the <code>owl:sameAs</code> relationship; that is, they are members of an <code>owl:sameAs</code> <span class="bold">clique</span>. To provide optimized inference for large <code>owl:sameAs</code> cliques, you can consolidate <code>owl:sameAs</code> triples without sacrificing correctness by specifying <code>'OPT_SAMEAS=T'</code> in the <code>options</code> parameter when performing OWLPrime entailment. For example:</p>
<pre>
EXECUTE sem_apis.create_entailment('M_IDX',sem_models('M'),
   sem_rulebases('OWLPRIME'),null,null,<span class="bold">'OPT_SAMEAS=T'</span>);
</pre>
<p>When you specify this option, for each <code>owl:sameAs</code> clique, one resource from the clique is chosen as a canonical representative and all of the inferences for that clique are consolidated around that resource. Using the preceding example, if <code>:John1</code> is the clique representative, after consolidation the inferred graph would contain only the following triples:</p>
<pre>
:John1 owl:sameAs :John1 .
:John1 :hasAge    "32" .
</pre>
<p>Some overhead is incurred with <code>owl:sameAs</code> consolidation. During inference, all asserted models are copied into the inference partition, where they are consolidated together with the inferred triples. Additionally, for very large asserted graphs, consolidating and removing duplicate triples incurs a large runtime overhead, so the <code>OPT_SAMEAS=T</code> option is recommended only for ontologies that have a large number of <code>owl:sameAs</code> relationships and large clique sizes.</p>
<p>After the OPT_SAMEAS=T option has been used for an entailment, all subsequent uses of <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> for that entailment must also use <code>OPT_SAMEAS=T</code>, or an error will be reported. To disable optimized <code>sameAs</code> handling, you must first drop the entailment.</p>
<p><a id="sthref207"></a><a id="sthref208"></a>Clique membership information is stored in a view named MDSYS.SEMCL_<span class="italic">entailment-name</span>, where <span class="italic">entailment-name</span> is the name of the entailment (rules index). Each MDSYS.SEMCL_<span class="italic">entailment-name</span> view has the columns shown in <a href="#CIHBBCBA">Table 2-3</a>.</p>
<div id="RDFRM99907" class="tblformal">
<p class="titleintable"><a id="sthref209"></a><a id="CIHBBCBA"></a>Table 2-3 MDSYS.SEMCL_entailment_name View Columns</p>
<table class="cellalignment980" title="MDSYS.SEMCL_entailment_name View Columns" summary="RDF_VALUE$ table columns" dir="ltr">
<thead>
<tr class="cellalignment974">
<th class="cellalignment981" id="r1c1-t4">Column Name</th>
<th class="cellalignment981" id="r1c2-t4">Data Type</th>
<th class="cellalignment981" id="r1c3-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment974">
<td class="cellalignment982" id="r2c1-t4" headers="r1c1-t4">
<p>MODEL_ID</p>
</td>
<td class="cellalignment982" headers="r2c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment982" headers="r2c1-t4 r1c3-t4">
<p>ID number of the inferred model</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r3c1-t4" headers="r1c1-t4">
<p>VALUE_ID</p>
</td>
<td class="cellalignment982" headers="r3c1-t4 r1c2-t4">
<p>NUMBER)</p>
</td>
<td class="cellalignment982" headers="r3c1-t4 r1c3-t4">
<p>ID number of a resource that is a member of the <code>owl:sameAs</code> clique identified by CLIQUE_ID</p>
</td>
</tr>
<tr class="cellalignment974">
<td class="cellalignment982" id="r4c1-t4" headers="r1c1-t4">
<p>CLIQUE_ID</p>
</td>
<td class="cellalignment982" headers="r4c1-t4 r1c2-t4">
<p>NUMBER</p>
</td>
<td class="cellalignment982" headers="r4c1-t4 r1c3-t4">
<p>ID number of the clique representative for the VALUE_ID resource</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>To save space, the MDSYS.SEMCL_<span class="italic">entailment-name</span> view does not contain reflexive rows like (CLIQUE_ID, CLIQUE_ID).</p>
<a id="CIHEEJDH"></a>
<div id="RDFRM99908" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">2.2.8.1</span> Querying owl:sameAs Consolidated Inference Graphs</h4>
<p>At query time, if the entailment queried was created using the <code>OPT_SAMEAS=T</code> option, the results are returned from an <code>owl:sameAs</code>-consolidated inference partition. The query results are not expanded to include the full <code>owl:sameAs</code> closure.</p>
<p>In the following example query, the only result returned would be <code>:John1</code>, which is the canonical clique representative.</p>
<pre>
SELECT A FROM TABLE (
  SEM_MATCH ('(?A :hasAge "32")',SEM_MODELS('M'),  
    SEM_RULEBASES('OWLPRIME'),NULL, NULL));
</pre>
<p>With the preceding example, even though <code>:John2 :hasAge "32"</code> occurs in the model, it has been replaced during the inference consolidation phase where redundant triples are removed. However, you can expand the query results by performing a join with the MDSYS.SEMCL_<span class="italic">rules-index-name</span> view that contains the consolidated <code>owl:sameAs</code> information. For example, to get expanded result set for the preceding SEM_MATCH query, you can use the following expanded query:</p>
<pre>
SELECT V.VALUE_NAME A_VAL FROM TABLE (
  SEM_MATCH ('(?A :hasAge "32")',SEM_MODELS('M'), 
    SEM_RULEBASES('OWLPRIME'), NULL, NULL)) Q,
    MDSYS.RDF_VALUE$ V, MDSYS.SEMCL_M_IDX C
  WHERE V.VALUE_ID  = C.VALUE_ID 
     AND C.CLIQUE_ID = Q.A$RDFVID
  UNION ALL
    SELECT A A_VAL FROM TABLE (
      SEM_MATCH ('(?A :hasAge "32")',SEM_MODELS('M'),  
        SEM_RULEBASES('OWLPRIME'),NULL, NULL));
</pre>
<p>Or, you could rewrite the preceding expanded query using a left outer join, as follows:</p>
<pre>
SELECT V.VALUE_NAME A_VAL FROM TABLE (
  SEM_MATCH ('(?A &lt;http://hasAge&gt; "33")',SEM_MODELS('M'), 
   SEM_RULEBASES('OWLPRIME'), NULL, NULL)) Q,
  MDSYS.RDF_VALUE$ V, 
   (SELECT value_id, clique_id FROM MDSYS.SEMCL_M_IDX 
  UNION ALL
    SELECT DISTINCT clique_id, clique_id 
      FROM MDSYS.SEMCL_M_IDX) C
 WHERE Q.A$RDFVID  = c.clique_id  (+)
   AND V.VALUE_ID  = nvl(C.VALUE_ID, Q.A$RDFVID);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHGIADG"></a>
<div id="RDFRM99909" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.2.9</span> <a id="sthref210"></a>Performing Incremental Inference</h3>
<p>Incremental inference can be used to update entailments (rules indexes) efficiently after triple additions. There are two ways to enable incremental inference for an entailment:</p>
<ul>
<li>
<p>Specify the <code>options</code> parameter value <code>INC=T</code> when creating the entailment. For example:</p>
<pre>
EXECUTE sem_apis.create_entailment ('M_IDX',sem_models('M'),
  sem_rulebases('OWLPRIME'),null,null, <span class="bold">'INC=T'</span>);
</pre></li>
<li>
<p>Use the <a href="sem_apis_ref.htm#CHECJGID">SEM_APIS.ENABLE_INC_INFERENCE</a> procedure.</p>
<p>If you use this procedure, the entailment must have a VALID status. Before calling the procedure, if you do not own the models involved in the entailment, you must ensure that the respective model owners have used the <a href="sem_apis_ref.htm#CHECGAAG">SEM_APIS.ENABLE_CHANGE_TRACKING</a> procedure to enable change tracking for those models.</p>
</li>
</ul>
<p>When incremental inference is enabled for an entailment, the parameter <code>INC=T</code> must be specified when invoking the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure for that entailment.</p>
<p>Incremental inference for an entailment depends on triggers for the application tables of the models involved in creating the entailment. This means that incremental inference works only when triples are inserted in the application tables underlying the entailment using conventional path loads, unless you specify the triples by using the <code>delta_in</code> parameter in the call to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure, as in the following example, in which the triples from model <code>M_NEW</code> will be added to model <code>M</code>, and entailment <code>M_IDX</code> will be updated with the new inferences:</p>
<pre>
EXECUTE sem_apis.create_entailment('M_IDX', sem_models('M'),
  sem_rulebases('OWLPRIME''), SEM_APIS.REACH_CLOSURE, null, null,
  <span class="bold">sem_models('M_NEW'</span>));
  
</pre>
<p>If multiple models are involved in the incremental inference call, then to specify the destination model to which the <code>delta_in</code> model or models are to be added, specify <code>DEST_MODEL=</code><code><span class="codeinlineitalic">&lt;model_name&gt;</span></code> in the <code>options</code> parameter. For example, the following causes the semantic data in model <code>M_NEW</code> to be added to model <code>M2</code>:</p>
<pre>
EXECUTE sem_apis.create_entailment('M_IDX', sem_models('M1','M2','M3'),
sem_rulebases('OWLPRIME''), SEM_APIS.REACH_CLOSURE, null, 'DEST_MODEL=M2', <span class="bold">sem_models('M_NEW')</span>);
</pre>
<p>Another way to bypass the conventional path loading requirement when using incremental inference is to set the UNDO_RETENTION parameter to cover the intervals between entailments when you perform bulk loading. For example, if the last entailment was created 6 hours ago, the UNDO_RETENTION value should be set to greater than 6 hours; if it is less than that, then (given a heavy workload and limited undo space) it is not guaranteed that all relevant undo information will be preserved for incremental inference to apply. In such cases, the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure falls back to regular (non-incremental) inference.</p>
<p>To check if change tracking is enabled on a model, use the <a href="sem_apis_ref.htm#CHECCHHA">SEM_APIS.GET_CHANGE_TRACKING_INFO</a> procedure. To get additional information about incremental inference for an entailment, use the <a href="sem_apis_ref.htm#CHEJIIAJ">SEM_APIS.GET_INC_INF_INFO</a> procedure.</p>
<p>The following restrictions apply to incremental inference:</p>
<ul>
<li>
<p>It does not work with optimized <code>owl:sameAs</code> handling (<code>OPT_SAMEAS</code>), user-defined rules, VPD-enabled models, or version-enabled models.</p>
</li>
<li>
<p>It supports only the addition of triples. With updates or deletions, the entailment will be completely rebuilt.</p>
</li>
<li>
<p>It depends on triggers on application tables.</p>
</li>
<li>
<p>Column types (RAW8 or NUMBER) used in incremental inference must be consistent. For instance, if <code>RAW8=T</code> is used to build the entailment initially, then for every subsequent <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> call the same option must be used. To change the column type to NUMBER, you must drop and rebuild the entailment.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHJBICJ"></a>
<div id="RDFRM99910" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.2.10</span> <a id="sthref211"></a>Using Parallel Inference</h3>
<p>Parallel inference can improve inference performance by taking advantage of the capabilities of a multi-core or multi-CPU architectures. To use parallel inference, specify the <code>DOP</code> (degree of parallelism) keyword and an appropriate value when using the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure. For example:</p>
<pre>
EXECUTE sem_apis.create_entailment('M_IDX',sem_models('M'), 
      sem_rulebases('OWLPRIME'), sem_apis.REACH_CLOSURE, null, <span class="bold">'DOP=4'</span>);
</pre>
<p>Specifying the DOP keyword causes parallel execution to be enabled for an Oracle-chosen set of inference components</p>
<p>The success of parallel inference depends heavily on a good hardware configuration of the system on which the database is running. The key is to have a "balanced" system that implements the best practices for database performance tuning and Oracle SQL parallel execution. For example, do not use a single 1 TB disk for an 800 GB database, because executing SQL statements in parallel on a single physical disk can even be slower than executing SQL statements in serial mode. Parallel inference requires ample memory; for each CPU core, you should have at least 4 GB of memory.</p>
<p>Parallel inference is best suited for large ontologies; however, inference performance can also improve for small ontologies.</p>
<p>There is some transient storage overhead associated with using parallel inference. Parallel inference builds a source table that includes all triples based on all the source RDF/OWL models and existing inferred graph. This table might use an additional 10 to 30 percent of storage compared to the space required for storing data and index of the source models.</p>
</div>
<!-- class="sect2" -->
<a id="CIHIDAFB"></a>
<div id="RDFRM214" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.2.11</span> Using Named Graph Based Inferencing (Global and Local)<a id="sthref212"></a><a id="sthref213"></a><a id="sthref214"></a><a id="sthref215"></a></h3>
<p>The default inferencing in Oracle Database takes all asserted triples from all the source model or models provided and applies semantic rules on top of all the asserted triples until an inference closure is reached. Even if the given source models contain one or more multiple named graphs, it makes no difference because all assertions, whether part of a named graph or not, are treated the same as if they come from a single graph. (For an introduction to named graph support in Oracle Database Semantic Technologies, see <a href="sdo_rdf_concepts.htm#CIHJECEF">Section 1.3.9</a>.)</p>
<p>This default inferencing can be thought of as completely "global" in that it does not consider named graphs at all.</p>
<p>However, if you use named graphs, you can override the default inferencing and have named graphs be considered by using either of the following features:</p>
<ul>
<li>
<p>Named graph based <span class="italic">global</span> inference (NGGI), which treats all specified named graphs as a unified graph. NGGI lets you narrow the scope of triples to be considered, while enabling great flexibility; it is explained in <a href="#CIHJGIJC">Section 2.2.11.1</a>.</p>
</li>
<li>
<p>Named graph based <span class="italic">local</span> inference (NGLI), which treats each specified named graph as a separate entity. NGLI is explained in <a href="#CIHIAAGH">Section 2.2.11.2</a>.</p>
</li>
</ul>
<p>For using NGGI and NGLI together, see a recommended usage flow in <a href="#CIHIAHDE">Section 2.2.11.3</a>.</p>
<p>You specify NGGI or NGLI through certain parameters and options to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure when you create an entailment (rules index).</p>
<a id="CIHJGIJC"></a>
<div id="RDFRM215" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">2.2.11.1</span> Named Graph Based Global Inference (NGGI)</h4>
<p>Named graph based global inference (NGGI) enables you to narrow the scope of triples used for inferencing at the named graph level (as opposed to the model level). It also enables great flexibility in selecting the scope; for example, you can include triples from zero or more named graphs and/or from the default graph, and you can include all triples with a null graph name from specified models.</p>
<p>For example, in a hospital application you may only want to apply the inference rules on all the information contained in a set of named graphs describing patients of a particular hospital. If the patient-related named graphs contains only instance-related assertions (ABox), you can specify one or multiple additional schema related-models (TBox), as in <a href="#CIHCDCCD">Example 2-6</a>.</p>
<div id="RDFRM216" class="example">
<p class="titleinexample"><a id="CIHCDCCD"></a>Example 2-6 Named Graph Based Global Inference</p>
<pre>
EXECUTE sem_apis.create_entailment(
  'patients_inf',
  models_in         =&gt; sem_models(<span class="bold">'patients','hospital_ontology'</span>),
  rulebases_in      =&gt; sem_rulebases('owl2rl'),
  passes            =&gt; SEM_APIS.REACH_CLOSURE,
  inf_components_in =&gt; null,
  options           =&gt; 'DOP=4,RAW8=T',
  <span class="bold">include_default_g</span> =&gt; sem_models('hospital_ontology'),
  <span class="bold">include_named_g</span>   =&gt; sem_graphs('&lt;urn:hospital1_patient1&gt;','&lt;urn:hospital1_patient2&gt;'),
  <span class="bold">inf_ng_name</span>       =&gt; '&lt;urn:inf_graph_for_hospital1&gt;'
  );
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHCDCCD">Example 2-6</a>:</p>
<ul>
<li>
<p>Two models are involved: <code>patients</code> contains a set of named graphs where each named graph holds triples relevant to a particular patient, and <code>hospital_ontology</code> contains schema information describing concepts and relationships that are defined for hospitals. These two models together are the source models, and they set up an overall scope for the inference.</p>
</li>
<li>
<p>The <code>include_default_g</code> parameter causes all triples with a NULL graph name in the specified models to participate in NGGI. In this example, all triples with a NULL graph name in model <code>hospital_ontology</code> will be included in NGGI.</p>
</li>
<li>
<p>The <code>include_named_g</code> parameter causes all triples from the specified named graphs (across all source models) to participate in NGGI. In this example, triples from named graphs <code>&lt;urn:hospital1_patient1&gt;</code> and <code>&lt;urn:hospital1_patient2&gt;</code> will be included in NGGI.</p>
</li>
<li>
<p>The <code>inf_ng_name</code> parameter assigns graph name <code>&lt;urn:inf_graph_for_hospital1&gt;</code> to all the new triples inferred by NGGI.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIHIAAGH"></a>
<div id="RDFRM217" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">2.2.11.2</span> Named Graph Based Local Inference (NGLI)</h4>
<p>Named graph based local inference (NGLI) treats each named graph as a separate entity instead of viewing the graphs as a single unified graph. Inference logic is performed within the boundary of each entity. You can specify schema-related assertions (TBox) in a default graph, and that default graph will participate the inference of each named graph. For example, inferred triples based on a graph with name <code>G1</code> will be assigned the same graph name <code>G1</code> in the inferred data partition.</p>
<p>Assertions from any two separate named graphs will never jointly produce any new assertions.</p>
<p>For example, assume the following:</p>
<ul>
<li>
<p>Graph <code>G1</code> includes the following assertion:</p>
<pre>
:John  :hasBirthMother  :Mary .
</pre></li>
<li>
<p>Graph <code>G2</code> includes the following assertion:</p>
<pre>
:John  :hasBirthMother  :Bella .
</pre></li>
<li>
<p>The default graph includes the assertion that <code>:hasBirthMother</code> is an <code>owl:FunctionalProperty</code>. (This assertion has a null graph name.)</p>
</li>
</ul>
<p>In this example, named graph based <span class="italic">local</span> inference (NGLI) will <span class="bolditalic">not</span> infer that <code>:Mary</code> is <code>owl:sameAs :Bella</code> because the two assertions are from two distinct graphs, <code>G1</code> and <code>G2</code>. By contrast, a named graph based <span class="italic">global</span> inference (NGGI) that includes <code>G1</code>, <code>G2</code>, and the functional property definition <span class="italic">would</span> be able to infer that <code>:Mary</code> is <code>owl:sameAs :Bella</code>.</p>
<p><a href="#CIHCAGBF">Example 2-7</a> shows NGLI.</p>
<div id="RDFRM218" class="example">
<p class="titleinexample"><a id="CIHCAGBF"></a>Example 2-7 Named Graph Based Local Inference</p>
<pre>
EXECUTE sem_apis.create_entailment(
  'patients_inf',
  models_in         =&gt; sem_models(<span class="bold">'patients','hospital_ontology'</span>),
  rulebases_in      =&gt; sem_rulebases('owl2rl'),
  passes            =&gt; SEM_APIS.REACH_CLOSURE,
  inf_components_in =&gt; null,
  <span class="bold">options           =&gt; 'LOCAL_NG_INF=T'</span>
);
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHCAGBF">Example 2-7</a>:</p>
<ul>
<li>
<p>The two models patients and hospital_ontology together are the source models, and they set up an overall scope for the inference, similar to the case of global inference in <a href="#CIHCDCCD">Example 2-6</a>. All triples with a null graph name are treated as part of the common schema (TBox). Inference is performed within the boundary of every single named graph combined with the common schema.</p>
</li>
<li>
<p>Then <code>options</code> parameter keyword-value pair <code>LOCAL_NG_INF=T</code> specifies that named graph based local inference (NGLI) is to be performed.</p>
</li>
</ul>
<p>Note that, by design, NGLI does not apply to the default graph itself. However, you can easily apply named graph based global inference (NGGI) on the default graph and set the <code>inf_ng_name</code> parameter to null. In this way, the TBox inference is precomputed, improving the overall performance and storage consumption.</p>
<p>NGLI does not allow the following:</p>
<ul>
<li>
<p>Inferring new relationships based on a mix of triples from multiple named graphs</p>
</li>
<li>
<p>Inferring new relationships using only triples from the default graph.</p>
</li>
</ul>
<p>To get the inference that you would normally expect, you should keep schema assertions and instance assertions separate. Schema assertions (for example, <code>:A rdfs:subClassOf :B</code> and <code>:p1 rdfs:subPropertyOf :p2</code>) should be stored in the default graph as unnamed triples (with null graph names). By contrast, instance assertions (for example, <code>:X :friendOf :Y</code>) should be stored in one of the named graphs.</p>
<p>For a discussion and example of using NGLI to perform document-centric inference with semantically indexed documents, see <a href="indexing_for_docs.htm#BEIGEJGI">Section 4.15, "Performing Document-Centric Inference"</a>.</p>
<p>NGLI currently does not work together with proof generation, user-defined rules, optimized <code>owl:sameAs</code> handling, or incremental inference.</p>
</div>
<!-- class="sect3" -->
<a id="CIHIAHDE"></a>
<div id="RDFRM219" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><span class="secnum">2.2.11.3</span> Using NGGI and NGLI Together</h4>
<p>The following is a recommended usage flow for using NGGI and NGLI together. It assumes that TBox and ABox are stored in two separate models, that TBox contains schema definitions and all triples in the TBox have a null graph name, but that ABox consists of a set of named graphs describing instance-related data.</p>
<ol>
<li>
<p>Invoke NGGI on the TBox by itself. For example:</p>
<pre>
EXECUTE sem_apis.create_entailment(
    'TEST_INF',
    sem_models('abox','tbox'),
    sem_rulebases('owl2rl'),
    SEM_APIS.REACH_CLOSURE,
    <span class="bold">include_default_g=&gt;sem_models('tbox')</span>
);
</pre></li>
<li>
<p>Invoke NGLI for all named graphs. For example:</p>
<pre>
EXECUTE sem_apis.create_entailment(
    'TEST_INF',
    sem_models('abox','tbox'),
    sem_rulebases('owl2rl'),
    SEM_APIS.REACH_CLOSURE,
    <span class="bold">options =&gt; 'LOCAL_NG_INF=T,ENTAIL_ANYWAY=T'</span>
);
</pre>
<p>Note that <code>ENTAIL_ANYWAY=T</code> is specified because the NGGI call in step 1will set the status of inferred graph to <code>VALID</code>, and the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure call in step 2 will quit immediately unless <code>ENTAIL_ANYWAY=T</code> is specified.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="RDFRM633" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref216"></a>
<h3 class="sect2"><span class="secnum">2.2.12</span> Performing Selective Inferencing (Advanced Information)</h3>
<p>Selective inferencing is component-based inferencing, in which you limit the inferencing to specific OWL components that you are interested in. To perform selective inferencing, use the <code>inf_components_in</code> parameter to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure to specify a comma-delimited list of components. The final inferencing is determined by the <span class="italic">union</span> of rulebases specified and the components specified.</p>
<p><a href="#CIHHGFBA">Example 2-8</a> limits the inferencing to the class hierarchy from subclass (SCOH) relationship and the property hierarchy from subproperty (SPOH) relationship. This example creates an empty rulebase and then specifies the two components (<code>'SCOH,SPOH'</code>) in the call to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure.</p>
<div id="RDFRM634" class="example">
<p class="titleinexample"><a id="CIHHGFBA"></a>Example 2-8 Performing Selective Inferencing</p>
<pre>
EXECUTE sem_apis.create_rulebase('my_rulebase');
 
EXECUTE sem_apis.create_entailment('owltst_idx', sem_models('owltst'), sem_rulebases('my_rulebase'), SEM_APIS.REACH_CLOSURE, <span class="bold">'SCOH,SPOH'</span>);
</pre></div>
<!-- class="example" -->
<p>The following component codes are available: <code>SCOH</code>, <code>COMPH</code>, <code>DISJH</code>, <code>SYMMH</code>, <code>INVH</code>, <code>SPIH</code>, <code>MBRH</code>, <code>SPOH</code>, <code>DOMH</code>, <code>RANH</code>, <code>EQCH</code>, <code>EQPH</code>, <code>FPH</code>, <code>IFPH</code>, <code>DOM</code>, <code>RAN</code>, <code>SCO</code>, <code>DISJ</code>, <code>COMP</code>, <code>INV</code>, <code>SPO</code>, <code>FP</code>, <code>IFP</code>, <code>SYMM</code>, <code>TRANS</code>, <code>DIF</code>, <code>SAM</code>, <code>CHAIN</code>, <code>HASKEY</code>, <code>ONEOF</code>, <code>INTERSECT</code>, <code>INTERSECTSCOH</code>, <code>MBRLST</code>, <code>PROPDISJH</code>, <code>SKOSAXIOMS</code>, <code>SNOMED</code>, <code>SVFH</code>, <code>THINGH</code>, <code>THINGSAM</code>, <code>UNION</code>, <code>RDFP1</code>, <code>RDFP2</code>, <code>RDFP3</code>, <code>RDFP4</code>, <code>RDFP6</code>, <code>RDFP7</code>, <code>RDFP8AX</code>, <code>RDFP8BX</code>, <code>RDFP9</code>, <code>RDFP10</code>, <code>RDFP11</code>, <code>RDFP12A</code>, <code>RDFP12B</code>, <code>RDFP12C</code>, <code>RDFP13A</code>, <code>RDFP13B</code>, <code>RDFP13C</code>, <code>RDFP14A</code>, <code>RDFP14BX</code>, <code>RDFP15</code>, <code>RDFP16</code>, <code>RDFS2</code>, <code>RDFS3</code>, <code>RDFS4a</code>, <code>RDFS4b</code>, <code>RDFS5</code>, <code>RDFS6</code>, <code>RDFS7</code>, <code>RDFS8</code>, <code>RDFS9</code>, <code>RDFS10</code>, <code>RDFS11</code>, <code>RDFS12</code>, <code>RDFS13</code></p>
<p>The rules corresponding to components with a prefix of <span class="italic">RDFP</span> can be found in <span class="italic">Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary</span>, by H.J. Horst.</p>
<p>The syntax for deselecting a component is <span class="italic">component_name</span> followed by a minus (-) sign. For example, the following statement performs OWLPrime inference without calculating the <code>subClassOf</code> hierarchy:</p>
<pre>
EXECUTE sem_apis.create_entailment('owltst_idx', sem_models('owltst'), sem_rulebases('OWLPRIME'), SEM_APIS.REACH_CLOSURE, <span class="bold">'SCOH-'</span>);
</pre>
<p>By default, the OWLPrime rulebase implements the transitive semantics of owl:sameAs. OWLPrime does not include the following rules (semantics):</p>
<pre>
U   owl:sameAs   V  .
U     p    X  .        ==&gt;   V  p   X   .
 
U   owl:sameAs   V  .
X     p    U  .        ==&gt;   X   p   V   .
</pre>
<p>The reason for not including these rules is that they tend to generate many assertions. If you need to include these assertions, you can include the <code>SAM</code> component code in the call to the <a href="sem_apis_ref.htm#CHEHDGBD">SEM_APIS.CREATE_ENTAILMENT</a> procedure.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBAGBH"></a>
<div id="RDFRM635" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1"><span class="secnum">2.3</span> <a id="sthref217"></a><a id="sthref218"></a><a id="sthref219"></a>Using Semantic Operators to Query Relational Data</h2>
<p>You can use semantic operators to query relational data in an ontology-assisted manner, based on the semantic relationship between the data in a table column and terms in an ontology. The SEM_RELATED semantic operator retrieves rows based on semantic relatedness. The SEM_DISTANCE semantic operator returns distance measures for the semantic relatedness, so that rows returned by the SEM_RELATED operator can be ordered or restricted using the distance measure. The index type MDSYS.SEM_INDEXTYPE allows efficient execution of such queries, enabling scalable performance over large data sets.</p>
<div id="RDFRM636" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref220"></a>
<h3 class="sect2"><span class="secnum">2.3.1</span> Using the SEM_RELATED Operator</h3>
<p>Referring to the cancer ontology example in <a href="#CHDHCIDI">Section 2.1.1</a>, consider the following query that requires semantic matching: <span class="italic">Find all patients whose diagnosis is of the type 'Immune_System_Disorder'.</span> A typical database query of the PATIENTS table (described in <a href="#CHDHCIDI">Section 2.1.1</a>) involving syntactic match will not return any rows, because no rows have a DIAGNOSIS column containing the exact value <code>Immune_System_Disorder</code>. For example the following query will not return any rows:</p>
<pre>
SELECT diagnosis FROM patients WHERE diagnosis = 'Immune_System_Disorder';
</pre>
<p>However, many rows in the patient data table are relevant, because their diagnoses fall under this class. <a href="#CHDEDECJ">Example 2-9</a> uses the SEM_RELATED operator (instead of lexical equality) to retrieve all the relevant rows from the patient data table. (In this example, the term <code>Immune_System_Disorder</code> is prefixed with a namespace, and the default assumption is that the values in the table column also have a namespace prefix. However, that might not always be the case, as explained in <a href="#CIHDFDIF">Section 2.3.5</a>.)</p>
<div id="RDFRM637" class="example">
<p class="titleinexample"><a id="CHDEDECJ"></a>Example 2-9 SEM_RELATED Operator</p>
<pre>
SELECT diagnosis FROM patients 
  WHERE SEM_RELATED (diagnosis, 
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime')) = 1;
</pre></div>
<!-- class="example" -->
<p>The SEM_RELATED operator has the following attributes:</p>
<pre>
SEM_RELATED(
  sub  VARCHAR2,
  predExpr  VARCHAR2,
  obj  VARCHAR2,
  ontologyName  SEM_MODELS,
  ruleBases  SEM_RULEBASES,
  index_status  VARCHAR2,
  lower_bound INTEGER,
  upper_bound INTEGER
 ) RETURN INTEGER;
</pre>
<p>The <code>sub</code> attribute is the name of table column that is being searched. The terms in the table column are typically the subject in a &lt;subject, predicate, object&gt; triple pattern.</p>
<p>The <code>predExpr</code> attribute represents the predicate that can appear as a label of the edge on the path from the subject node to the object node.</p>
<p>The <code>obj</code> attribute represents the term in the ontology for which related terms (related by the <code>predExpr</code> attribute) have to be found in the table (in the column specified by the <code>sub</code> attribute). This term is typically the object in a &lt;subject, predicate, object&gt; triple pattern. (In a query with the equality operator, this would be the query term.)</p>
<p>The <code>ontologyName</code> attribute is the name of the ontology that contains the relationships between terms.</p>
<p><a id="sthref221"></a>The <code>rulebases</code> attribute identifies one or more rulebases whose rules have been applied to the ontology to infer new relationships. The query will be answered based both on relationships from the ontology and the inferred new relationships when this attribute is specified.</p>
<p><a id="sthref222"></a><a id="sthref223"></a><a id="sthref224"></a>The <code>index_status</code> optional attribute lets you query the data even when the relevant entailment (created when the specified rulebase was applied to the ontology) does not have a valid status. If this attribute is null, the query returns an error if the entailment does not have a valid status. If this attribute is not null, it must be the string <code>VALID</code>, <code>INCOMPLETE</code>, or <code>INVALID</code>, to specify the minimum status of the entailment for the query to succeed. Because OWL does not guarantee monotonicity, the value <code>INCOMPLETE</code> should not be used when an OWL Rulebase is specified.</p>
<p>The <code>lower_bound</code> and <code>upper_bound</code> optional attributes let you specify a bound on the distance measure of the relationship between terms that are related. See <a href="#CIHIEAFJ">Section 2.3.2</a> for the description of the distance measure.</p>
<p>The SEM_RELATED operator returns 1 if the two input terms are related with respect to the specified <code>predExpr</code> relationship within the ontology, and it returns 0 if the two input terms are not related. If the lower and upper bounds are specified, it returns 1 if the two input terms are related with a distance measure that is greater than or equal to <code>lower_bound</code> and less than or equal to <code>upper_bound</code>.</p>
</div>
<!-- class="sect2" -->
<a id="CIHIEAFJ"></a>
<div id="RDFRM638" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.3.2</span> <a id="sthref225"></a><a id="sthref226"></a><a id="sthref227"></a>Using the SEM_DISTANCE Ancillary Operator</h3>
<p>The SEM_DISTANCE ancillary operator computes the distance measure for the rows filtered using the SEM_RELATED operator. The SEM_DISTANCE operator has the following format:</p>
<pre>
SEM_DISTANCE (number) RETURN NUMBER;
</pre>
<p>The <code>number</code> attribute can be any number, as long as it matches the number that is the last attribute specified in the call to the SEM_RELATED operator (see <a href="#CHDGDECA">Example 2-10</a>). The number is used to match the invocation of the ancillary operator SEM_DISTANCE with a specific SEM_RELATED (primary operator) invocation, because a query can have multiple invocations of primary and ancillary operators.</p>
<p><a href="#CHDGDECA">Example 2-10</a> expands <a href="#CHDEDECJ">Example 2-9</a> to show several statements that include the SEM_DISTANCE ancillary operator, which gives a measure of how closely the two terms (here, a patient's diagnosis and the term <code>Immune_System_Disorder</code>) are related by measuring the distance between the terms. Using the cancer ontology described in <a href="#CHDHCIDI">Section 2.1.1</a>, the distance between <code>AIDS</code> and <code>Immune_System_Disorder</code> is 3.</p>
<div id="RDFRM639" class="example">
<p class="titleinexample"><a id="CHDGDECA"></a>Example 2-10 SEM_DISTANCE Ancillary Operator</p>
<pre>
SELECT diagnosis, SEM_DISTANCE(123) FROM patients 
  WHERE SEM_RELATED (diagnosis, 
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime'), 123) = 1;
 
SELECT diagnosis FROM patients 
  WHERE SEM_RELATED (diagnosis,
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime'), 123) = 1
  ORDER BY SEM_DISTANCE(123);
 
SELECT diagnosis, SEM_DISTANCE(123) FROM patients 
  WHERE SEM_RELATED (diagnosis,
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime'), 123) = 1 
  WHERE SEM_DISTANCE(123) &lt;= 3;
</pre></div>
<!-- class="example" -->
<p><a href="#CIHBEGEJ">Example 2-11</a> uses distance information to restrict the number of rows returned by the primary operator. All rows with a term related to the object attribute specified in the SEM_RELATED invocation, but with a distance of greater than or equal to 2 and less than or equal to 4, are retrieved.</p>
<div id="RDFRM640" class="example">
<p class="titleinexample"><a id="CIHBEGEJ"></a>Example 2-11 Using SEM_DISTANCE to Restrict the Number of Rows Returned</p>
<pre>
SELECT diagnosis FROM patients 
  WHERE SEM_RELATED (diagnosis,
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime'), 2, 4) = 1;
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHBEGEJ">Example 2-11</a>, the lower and upper bounds are specified using the <code>lower_bound</code> and <code>upper_bound</code> parameters in the SEM_RELATED operator instead of using the SEM_DISTANCE operator. The SEM_DISTANCE operator can be also be used for restricting the rows returned, as shown in the last SELECT statement in <a href="#CHDGDECA">Example 2-10</a>.</p>
<div id="RDFRM641" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref228"></a>
<h4 class="sect3"><span class="secnum">2.3.2.1</span> Computation of Distance Information</h4>
<p>Distances are generated for the following properties during inference (entailment): OWL properties defined as transitive properties, and RDFS <code>subClassOf</code> and RDFS <code>subPropertyOf</code> properties. The distance between two terms linked through these properties is computed as the shortest distance between them in a hierarchical class structure. Distances of two terms linked through other properties are undefined and therefore set to null.</p>
<p>Each transitive property link in the original model (viewed as a hierarchical class structure) has a distance of 1, and the distance of an inferred triple is generated according to the number of links between the two terms. Consider the following hypothetical sample scenarios:</p>
<ul>
<li>
<p>If the original graph contains <code>C1 rdfs:subClassOf C2</code> and <code>C2 rdfs:subClassOf C3</code>, then <code>C1 rdfs:subClassof of C3</code> will be derived. In this case:</p>
<ul>
<li>
<p><code>C1 rdfs:subClassOf C2</code>: distance = 1, because it exists in the model.</p>
</li>
<li>
<p><code>C2 rdfs:subClassOf C3</code>: distance = 1, because it exists in the model.</p>
</li>
<li>
<p><code>C1 rdfs:subClassOf C3</code>: distance = 2, because it is generated during inference.</p>
</li>
</ul>
</li>
<li>
<p>If the original graph contains <code>P1 rdfs:subPropertyOf P2</code> and <code>P2 rdfs:subPropertyOf P3</code>, then P1 rdfs:subPropertyOf P3 will be derived. In this case:</p>
<ul>
<li>
<p><code>P1 rdfs:subPropertyOf P2</code>: distance = 1, because it exists in the model.</p>
</li>
<li>
<p><code>P2 rdfs:subPropertyOf P3</code>: distance = 1, because it exists in the model.</p>
</li>
<li>
<p><code>P1 rdfs:subPropertyOf P3</code>: distance = 2, because it is generated during inference.</p>
</li>
</ul>
</li>
<li>
<p>If the original graph contains <code>C1 owl:equivalentClass C2</code> and <code>C2 owl:equivalentClass C3</code>, then <code>C1 owl:equivalentClass C3</code> will be derived. In this case:</p>
<ul>
<li>
<p><code>C1 owl:equivalentClass C2</code>: distance = 1, because it exists in the model.</p>
</li>
<li>
<p><code>C2 owl:equivalentClass C3</code>: distance = 1, because it exists in the model.</p>
</li>
<li>
<p><code>C1 owl:equivalentClass C3</code>: distance = 2, because it is generated during inference.</p>
</li>
</ul>
</li>
</ul>
<p>The SEM_RELATED operator works with user-defined rulebases. However, using the SEM_DISTANCE operator with a user-defined rulebase is not yet supported, and will raise an error.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBADED"></a>
<div id="RDFRM642" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.3.3</span> <a id="sthref229"></a><a id="sthref230"></a>Creating a Semantic Index of Type MDSYS.SEM_INDEXTYPE</h3>
<p>When using the SEM_RELATED operator, you can create a semantic index of type MDSYS.SEM_INDEXTYPE on the column that contains the ontology terms. Creating such an index will result in more efficient execution of the queries. The CREATE INDEX statement must contain the <code>INDEXTYPE IS MDSYS.SEM_INDEXTYPE</code> clause, to specify the type of index being created.</p>
<p><a href="#CHDIHJGC">Example 2-12</a> creates a semantic index named DIAGNOSIS_SEM_IDX on the DIAGNOSIS column of the PATIENTS table using the <code>Cancer_Ontology</code> ontology.</p>
<div id="RDFRM643" class="example">
<p class="titleinexample"><a id="CHDIHJGC"></a>Example 2-12 Creating a Semantic Index</p>
<pre>
CREATE INDEX diagnosis_sem_idx
  ON patients (diagnosis) 
  INDEXTYPE IS MDSYS.SEM_INDEXTYPE;
</pre></div>
<!-- class="example" -->
<p>The column on which the index is built (DIAGNOSIS in <a href="#CHDIHJGC">Example 2-12</a>) must be the first parameter to the SEM_RELATED operator, in order for the index to be used. If it not the first parameter, the index is not used during the execution of the query.</p>
<p>To improve the performance of certain semantic queries, you can cause statistical information to be generated for the semantic index by specifying one or more models and rulebases when you create the index. <a href="#CIHHDGDE">Example 2-13</a> creates an index that will also generate statistics information for the specified model and rulebase. The index can be used with other models and rulebases during query, but the statistical information will be used only if the model and rulebase specified during the creation of the index are the same model and rulebase specified in the query.</p>
<div id="RDFRM644" class="example">
<p class="titleinexample"><a id="CIHHDGDE"></a>Example 2-13 Creating a Semantic Index Specifying a Model and Rulebase</p>
<pre>
CREATE INDEX diagnosis_sem_idx
  ON patients (diagnosis) 
  INDEXTYPE IS <span class="bold">MDSYS.SEM_INDEXTYPE('ONTOLOGY_MODEL(medical_ontology),</span> 
    <span class="bold">RULEBASE(OWLPrime)')</span>;
</pre></div>
<!-- class="example" -->
<p>The statistical information is useful for queries that return top-k results sorted by semantic distance. <a href="#CIHGAFIE">Example 2-14</a> shows such a query.</p>
<div id="RDFRM645" class="example">
<p class="titleinexample"><a id="CIHGAFIE"></a>Example 2-14 Query Benefitting from Generation of Statistical Information</p>
<pre>
SELECT /*+ FIRST_ROWS */ diagnosis FROM patients 
  WHERE SEM_RELATED (diagnosis,
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime'), 123) = 1
  ORDER BY SEM_DISTANCE(123);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="RDFRM646" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref231"></a>
<h3 class="sect2"><span class="secnum">2.3.4</span> <a id="sthref232"></a>Using SEM_RELATED and SEM_DISTANCE When the Indexed Column Is Not the First Parameter</h3>
<p>If an index of type MDSYS.SEM_INDEXTYPE has been created on a table column that is the first parameter to the SEM_RELATED operator, the index will be used. For example, the following query retrieves all rows that have a value in the DIAGNOSIS column that is a subclass of (<code>rdfs:subClassOf</code>) <code>Immune_System_Disorder</code>.</p>
<pre>
SELECT diagnosis FROM patients 
  WHERE SEM_RELATED (diagnosis, 
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime')) = 1;
</pre>
<p>Assume, however, that this query instead needs to retrieve all rows that have a value in the DIAGNOSIS column for which <code>Immune_System_Disorder</code> is a subclass. You could rewrite the query as follows:</p>
<pre>
SELECT diagnosis FROM patients 
  WHERE SEM_RELATED
    ('&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    '&lt;http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;', 
    diagnosis, 
    sem_models('medical_ontology'), sem_rulebases('owlprime')) = 1;
</pre>
<p>However, in this case a semantic index on the DIAGNOSIS column will not be used, because it is not the first parameter to the SEM_RELATED operator. To cause the index to be used, you can change the preceding query to use the <code>inverseOf</code> keyword, as follows:</p>
<pre>
SELECT diagnosis FROM patients 
  WHERE SEM_RELATED (diagnosis,
    'inverseOf(http://www.w3.org/2000/01/rdf-schema#subClassOf)',
    '&lt;http://www.example.org/medical_terms/Immune_System_Disorder&gt;', 
    sem_models('medical_ontology'), sem_rulebases('owlprime')) = 1;
</pre>
<p>This form causes the table column (on which the index is built) to be the first parameter to the SEM_RELATED operator, and it retrieves all rows that have a value in the DIAGNOSIS column for which <code>Immune_System_Disorder</code> is a subclass.</p>
</div>
<!-- class="sect2" -->
<a id="CIHDFDIF"></a>
<div id="RDFRM647" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><span class="secnum">2.3.5</span> <a id="sthref233"></a><a id="sthref234"></a>Using URIPREFIX When Values Are Not Stored as URIs</h3>
<p>By default, the semantic operator support assumes that the values stored in the table are URIs. These URIs can be from different namespaces. However, if the values in the table do not have URIs, you can use the URIPREFIX keyword to specify a URI when you create the semantic index. In this case, the specified URI is prefixed to the value in the table and stored in the index structure. (One implication is that multiple URIs cannot be used).</p>
<p><a href="#CIHEBGEI">Example 2-15</a> creates a semantic index that uses a URI prefix.</p>
<div id="RDFRM648" class="example">
<p class="titleinexample"><a id="CIHEBGEI"></a>Example 2-15 Specifying a URI Prefix During Semantic Index Creation</p>
<pre>
CREATE INDEX diagnosis_sem_idx
  ON patients (diagnosis) 
  INDEXTYPE IS MDSYS.SEM_INDEXTYPE
  PARAMETERS('URIPREFIX(&lt;http://www.example.org/medical/&gt;)');
</pre></div>
<!-- class="example" -->
<p>Note that the slash (/) character at the end of the URI is important, because the URI is prefixed to the table value (in the index structure) without any parsing.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment973">
<tr>
<td class="cellalignment982">
<table class="cellalignment978">
<tr>
<td class="cellalignment977"><a href="sdo_rdf_concepts.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment977"><a href="skos.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment984">
<table class="cellalignment976">
<tr>
<td class="cellalignment977"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment977"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment977"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment977"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment977"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment977"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
