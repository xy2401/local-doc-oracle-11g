<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>DBMS_DATA_MINING_TRANSFORM</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 737" />
<meta name="dcterms.created" content="2013-07-19T18:55:6Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference" />
<meta name="dcterms.identifier" content="E40758-03" />
<meta name="dcterms.isVersionOf" content="ARPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="d_datmin.htm" title="Previous" type="text/html" />
<link rel="Next" href="d_datpmp.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e40758.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">49/265</span> <!-- End Header -->
<div id="ARPLS191" class="chapter"><a id="BAJHICDA"></a><a id="i1013223"></a>
<h1 class="chapter"><span class="secnum">45</span> <a id="sthref2600"></a>DBMS_DATA_MINING_TRANSFORM</h1>
<p><code>DBMS_DATA_MINING_TRANSFORM</code> implements a set of transformations that are commonly used in data mining and provides a framework that you can use for specifying your own transformations. <a id="sthref2601"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="d_datmin.htm#BAJBGHGD">Chapter 44, "DBMS_DATA_MINING"</a></p>
</li>
<li>
<p><a class="olink DMCON003" href="../../datamine.112/e16808/xform_data.htm#DMCON003"><span class="italic">Oracle Data Mining Concepts</span></a></p>
</li>
</ul>
</div>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BAJDGFDB">Using DBMS_DATA_MINING_TRANSFORM</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Operational Notes</p>
</li>
<li>
<p>Security Model</p>
</li>
<li>
<p>Types</p>
</li>
<li>
<p>Constants</p>
</li>
</ul>
</li>
<li>
<p><a href="#BABIDHCI">Summary of DBMS_DATA_MINING_TRANSFORM Subprograms</a></p>
</li>
</ul>
<div class="refentry"><a id="BAJDGFDB"></a>
<hr />
<div id="ARPLS197" class="refsect1">
<h2 class="refsect1"><a id="sthref2602"></a>Using DBMS_DATA_MINING_TRANSFORM</h2>
<p>This section contains topics that relate to using the <code>DBMS_DATA_MINING_TRANSFORM</code> package.</p>
<ul>
<li>
<p><a href="#BABFFDFC">Overview</a></p>
</li>
<li>
<p><a href="#BABDIIIC">Operational Notes</a></p>
</li>
<li>
<p><a href="#CACJIABG">Security Model</a></p>
</li>
<li>
<p><a href="#CACGBFDB">Types</a></p>
</li>
<li>
<p><a href="#BABHCGBG">Constants</a></p>
</li>
</ul>
<div id="ARPLS72988" class="refsect2"><a id="BABFFDFC"></a>
<hr />
<h3 class="refsect2">Overview</h3>
<p>A transformation is a SQL expression that modifies the data in one or more columns.</p>
<p>Data must typically undergo certain transformations before it can be used to build a mining model. Many data mining algorithms have specific transformation requirements.</p>
<p>Data that will be scored must be transformed in the same way as the data that was used to create (train) the model.</p>
<div id="ARPLS72989" class="refsect3"><a id="CACBDDFC"></a>
<h4 class="refsect3">External or Embedded Transformations</h4>
<p><code>DBMS_DATA_MINING_TRANSFORM</code> offers two approaches to implementing transformations. For a given model, you can either:</p>
<ul>
<li>
<p>Create a list of transformation expressions and pass it to the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a></p>
<p><span class="italic">or</span></p>
</li>
<li>
<p>Create a view that implements the transformations and pass the name of the view to the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a></p>
</li>
</ul>
<p>If you create a transformation list and pass it to <code>CREATE_MODEL</code>, the transformation expressions are embedded in the model and automatically implemented whenever the model is applied.</p>
<p>If you create a view, the transformation expressions are external to the model. You will need to re-create the transformations whenever you apply the model.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Embedded transformations significantly enhance the model's usability while simplifying the process of model management.</div>
</div>
<!-- class="refsect3" -->
<div id="ARPLS72990" class="refsect3"><a id="CACDCJBE"></a>
<h4 class="refsect3">Automatic Transformations</h4>
<p>Oracle Data Mining supports an Automatic Data Preparation (ADP) mode. When ADP is enabled, most algorithm-specific transformations are <span class="italic">automatically</span> embedded. Any additional transformations must be explicitly provided in an embedded transformation list or in a view.</p>
<p>If ADP is enabled and you create a model with a transformation list, both sets of transformations are embedded. The model will execute the user-specified transformations from the transformation list before executing the automatic transformations specified by ADP.</p>
<p>Within a transformation list, you can selectively disable ADP for individual attributes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="d_datmin.htm#CACEHEDI">"Automatic Data Preparation"</a></p>
<p><a class="olink DMCON380" href="../../datamine.112/e16808/xform_data.htm#DMCON380"><span class="italic">Oracle Data Mining Concepts</span></a> for a list of the algorithm-specific transformations implemented by ADP</p>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</div>
</div>
<!-- class="refsect3" -->
<div id="ARPLS72991" class="refsect3"><a id="CACDAIII"></a>
<h4 class="refsect3">Transformations in DBMS_DATA_MINING_TRANSFORM</h4>
<p>The transformations supported by <code>DBMS_DATA_MINING_TRANSFORM</code> are summarized in this section.</p>
<div id="ARPLS72992" class="refsect4"><a id="BABBCHED"></a>
<h5 class="refsect4">Binning</h5>
<p>Binning refers to the mapping of continuous or discrete values to discrete values of reduced cardinality.</p>
<ul>
<li>
<p>Supervised Binning (Categorical and Numerical)</p>
<p>Binning is based on intrinsic relationships in the data as determined by a decision tree model.</p>
<p>See <a href="#BABEHBCE">"INSERT_BIN_SUPER Procedure"</a>.</p>
</li>
<li>
<p>Top-N Frequency Categorical Binning</p>
<p>Binning is based on the number of cases in each category.</p>
<p>See <a href="#BABCIBEH">"INSERT_BIN_CAT_FREQ Procedure"</a></p>
</li>
<li>
<p>Equi-Width Numerical Binning</p>
<p>Binning is based on equal-range partitions.</p>
<p>See <a href="#BABEFAIC">"INSERT_BIN_NUM_EQWIDTH Procedure"</a>.</p>
</li>
<li>
<p>Quantile Numerical Binning</p>
<p>Binning is based on quantiles computed using the SQL <code>NTILE</code> function.</p>
<p>See <a href="#BABEDFDH">"INSERT_BIN_NUM_QTILE Procedure"</a>.</p>
</li>
</ul>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS72993" class="refsect4"><a id="BABCAFDD"></a>
<h5 class="refsect4">Linear Normalization</h5>
<p>Normalization is the process of scaling continuous values down to a specific range, often between zero and one. Normalization transforms each numerical value by subtracting a number (the <span class="bold">shift</span>) and dividing the result by another number (the <span class="bold">scale</span>).</p>
<pre>
x_new = (x_old-shift)/scale
</pre>
<ul>
<li>
<p>Min-Max Normalization</p>
<p>Normalization is based on the minimum and maximum with the following shift and scale:</p>
<pre>
shift = min
scale = max-min
</pre>
<p>See <a href="#BABDFACD">"INSERT_NORM_LIN_MINMAX Procedure"</a>.</p>
</li>
<li>
<p>Scale Normalization</p>
<p>Normalization is based on the minimum and maximum with the following shift and scale:</p>
<pre>
shift = 0 
scale = max{abs(max), abs(min)}
</pre>
<p>See <a href="#BABHAFJC">"INSERT_NORM_LIN_SCALE Procedure"</a>.</p>
</li>
<li>
<p>Z-Score Normalization</p>
<p>Normalization is based on the mean and standard deviation with the following shift and scale:</p>
<pre>
shift = mean 
scale = standard_deviation
</pre>
<p>See <a href="#BABDCGGH">"INSERT_NORM_LIN_ZSCORE Procedure"</a>.</p>
</li>
</ul>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS72994" class="refsect4"><a id="CACCICGF"></a>
<h5 class="refsect4">Outlier Treatment</h5>
<p>An outlier is a numerical value that is located far from the rest of the data. Outliers can artificially skew the results of data mining.</p>
<ul>
<li>
<p>Winsorizing</p>
<p>Outliers are replaced with the nearest value that is not an outlier.</p>
<p>See <a href="#BABIIFED">"INSERT_CLIP_WINSOR_TAIL Procedure"</a></p>
</li>
<li>
<p>Trimming</p>
<p>Outliers are set to <code>NULL</code>.</p>
<p>See <a href="#BABIIJFA">"INSERT_CLIP_TRIM_TAIL Procedure"</a>.</p>
</li>
</ul>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS72995" class="refsect4"><a id="CACDGBDI"></a>
<h5 class="refsect4">Missing Value Treatment</h5>
<p>Missing data may indicate sparsity or it may indicate that some values are missing at random. <code>DBMS_DATA_MINING_TRANSFORM</code> supports the following transformations for minimizing the effects of missing values:</p>
<ul>
<li>
<p>Missing numerical values are replaced with the mean.</p>
<p>See <a href="#BABHAHEJ">"INSERT_MISS_NUM_MEAN Procedure"</a>.</p>
</li>
<li>
<p>Missing categorical values are replaced with the mode.</p>
<p>See <a href="#BABJCGCA">"INSERT_MISS_CAT_MODE Procedure"</a>.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Data Mining also has default mechanisms for handling missing data. See <a class="olink DMPRG015" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG015"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a> for details.</div>
<br /></div>
<!-- class="refsect4" --></div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72996" class="refsect2"><a id="BABDIIIC"></a>
<hr />
<h3 class="refsect2">Operational Notes</h3>
<p>The <code>DBMS_DATA_MINING_TRANSFORM</code> package offers a flexible framework for specifying data transformations. If you choose to embed transformations in the model (the preferred method), you will create a <span class="bold">transformation list</span> object and pass it to the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a>. If you choose to transform the data without embedding, you will create a view.</p>
<p>When specified in a transformation list, the transformation expressions are executed by the model. When specified in a view, the transformation expressions are executed by the view.</p>
<p class="subhead2"><a id="ARPLS73344"></a>Transformation Definitions</p>
<p>Transformation definitions are used to generate the SQL expressions that transform the data. For example, the transformation definitions for normalizing a numeric column are the shift and scale values for that data.</p>
<p>With the <code>DBMS_DATA_MINING_TRANSFORM</code> package, you can call procedures to compute the transformation definitions, or you can compute them yourself, or you can do both.</p>
<p class="subhead2"><a id="ARPLS73345"></a>Transformation Definition Tables</p>
<p><code>DBMS_DATA_MINING_TRANSFORM</code> provides <code><span class="codeinlinebold">INSERT</span></code> procedures that compute transformation definitions and insert them in transformation definition tables. You can modify the values in the transformation definition tables or populate them yourself.</p>
<p><code><span class="codeinlinebold">XFORM</span></code> routines use populated definition tables to transform data in external views. <code><span class="codeinlinebold">STACK</span></code> routines use populated definition tables to build transformation lists.</p>
<p class="orderedlisttitle">To specify transformations based on definition tables, follow these steps:&nbsp;</p>
<ol>
<li>
<p>Use <code><span class="codeinlinebold">CREATE</span></code> routines to create transformation definition tables.</p>
<p>The tables have columns to hold the transformation definitions for a given type of transformation. For example, the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> creates a definition table that has a column for storing data values and another column for storing the associated bin identifiers.</p>
</li>
<li>
<p>Use <code><span class="codeinlinebold">INSERT</span></code> routines to compute and insert transformation definitions in the tables.</p>
<p>Each <code>INSERT</code> routine uses a specific technique for computing the transformation definitions. For example, the <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> computes bin boundaries by identifying the minimum and maximum values then setting the bin boundaries at equal intervals.</p>
</li>
<li id="CACDAIAI">
<p>Use <code><span class="codeinlinebold">STACK</span></code> or <code><span class="codeinlinebold">XFORM</span></code> routines to generate transformation expressions based on the information in the definition tables:</p>
<ul>
<li>
<p>Use <code><span class="codeinlinebold">STACK</span></code> routines to add the transformation expressions to a transformation list. Pass the transformation list to the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a>. The transformation expressions will be assembled into one long SQL query and embedded in the model.</p>
</li>
<li>
<p>Use <code><span class="codeinlinebold">XFORM</span></code> routines to execute the transformation expressions within a view. The transformations will be external to the model and will need to be re-created whenever the model is applied to new data.</p>
</li>
</ul>
</li>
</ol>
<p class="subhead2"><a id="ARPLS73473"></a>Transformations Without Definition Tables</p>
<p><code>STACK</code> routines are not the only method for adding transformation expressions to a transformation list. You can also build a transformation list without using definition tables.</p>
<p class="orderedlisttitle">To specify transformations without using definition tables, follow these steps:&nbsp;</p>
<ol>
<li id="CACGDDBB">
<p>Write a SQL expression for transforming an attribute.</p>
</li>
<li id="CACHDACC">
<p>Write a SQL expression for reversing the transformation. (See <a href="#CACHAJGE">"Reverse Transformations and Model Transparency"</a>.)</p>
</li>
<li id="CACEJAFF">
<p>Determine whether or not to disable ADP for the attribute. By default ADP is enabled for the attribute if it is specified for the model. (See <a href="#CACDBIFD">"Disabling Automatic Data Preparation"</a>.)</p>
</li>
<li id="CACBCFEB">
<p>Specify the SQL expressions and ADP instructions in a call to the <a href="#BABJIIIE">SET_TRANSFORM Procedure</a>, which adds the information to a transformation list.</p>
</li>
<li>
<p>Repeat steps <a href="#CACGDDBB">1</a> through <a href="#CACBCFEB">4</a> for each attribute that you wish to transform.</p>
</li>
<li id="CACGFBEJ">
<p>Pass the transformation list to the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a>. The transformation expressions will be assembled into one long SQL query and embedded in the model.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL expressions that you specify with <code>SET_TRANSFORM</code> must fit within a <code>VARCHAR2</code>. To specify a longer expression, you can use the <a href="#CACJDFJC">SET_EXPRESSION Procedure</a>. With <code>SET_EXPRESSION</code>, you can build an expression by appending rows to a <code>VARCHAR2</code> array.</div>
</li>
</ol>
<div id="ARPLS73346" class="refsect3"><a id="CACHEGJD"></a>
<h4 class="refsect3">About Transformation Lists</h4>
<p>The elements of a transformation list are <span class="bold">transformation records</span>. Each transformation record provides all the information needed by the model for managing the transformation of a single attribute.</p>
<p class="itemizedlisttitle">Each transformation record includes the following fields:&nbsp;</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">attribute_name</span></code> &mdash; Name of the column of data to be transformed</p>
</li>
<li>
<p><code><span class="codeinlineitalic">attribute_subname</span></code> &mdash; Name of the nested attribute if <code><span class="codeinlineitalic">attribute_name</span></code> is a nested column, otherwise <code>NULL</code></p>
</li>
<li>
<p><code><span class="codeinlineitalic">expression</span></code> &mdash; SQL expression for transforming the attribute</p>
</li>
<li>
<p><code><span class="codeinlineitalic">reverse_expression</span></code> &mdash; SQL expression for reversing the transformation</p>
</li>
<li>
<p><code><span class="codeinlineitalic">attribute_spec</span></code> &mdash; When set to <code>NOPREP</code>, disables ADP for the attribute</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CACEJIHI">Table 45-1</a> for details about the <code>TRANSFORM_LIST</code> and <code>TRANSFORM_REC</code> object types</div>
<div id="ARPLS73427" class="refsect4"><a id="CACHAJGE"></a>
<h5 class="refsect4">Reverse Transformations and Model Transparency</h5>
<p>An algorithm manipulates transformed attributes to train and score a model. The transformed attributes, however, may not be meaningful to an end user. For example, if attribute <span class="italic">x</span> has been transformed into bins 1 &mdash; 4, the bin names 1, 2 , 3, and 4 are manipulated by the algorithm, but a user is probably not interested in the model details about bins 1 &mdash; 4 or in predicting the numbers 1 &mdash; 4.</p>
<p>To return original attribute values in model details and predictions, you can provide a reverse expression in the transformation record for the attribute. For example, if you specify the transformation expression <code><span class="codeinlinebold">'log(10, y)'</span></code> for attribute <span class="italic">y</span>, you could specify the reverse transformation expression <code><span class="codeinlinebold">'power(10, y)'</span></code>.</p>
<p>Reverse transformations enable <a id="sthref2606"></a><span class="bold">model transparency</span>. They make internal processing transparent to the user.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>STACK</code> procedures automatically reverse normalization transformations, but they do not provide a mechanism for reversing binning, clipping, or missing value transformations.
<p>You can use the <code>DBMS_DATA_MINING.ALTER_REVERSE_EXPRESSION</code> procedure to specify or update reverse transformations expressions for an existing model.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#CACFFJCI">Example 45-1, "Stacking a Clipping Transformation"</a></p>
<p><a href="d_datmin.htm#CACCBBJG">"ALTER_REVERSE_EXPRESSION Procedure"</a></p>
<p><a href="d_datmin.htm#i1069667">"Summary of DBMS_DATA_MINING Subprograms"</a> for links to the model details functions</p>
</div>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS73428" class="refsect4"><a id="CACDBIFD"></a>
<h5 class="refsect4">Disabling Automatic Data Preparation</h5>
<p>ADP is controlled by a model-specific setting (<code>PREP_AUTO</code>). The <code>PREP_AUTO</code> setting affects all model attributes unless you disable it for individual attributes.</p>
<p>If ADP is enabled and you set <code><span class="codeinlineitalic">attribute_spec</span></code> to <code>NOPREP</code>, only the transformations that you specify for that attribute will be evaluated. If ADP is enabled and you do <span class="italic">not</span> set <code><span class="codeinlineitalic">attribute_spec</span></code> to <code>NOPREP</code>, the automatic transformations will be evaluated <span class="italic">after</span> the transformations that you specify for the attribute.</p>
<p>If ADP is not enabled for the model, the <code><span class="codeinlineitalic">attribute_spec</span></code> field of the transformation record is ignored.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="d_datmin.htm#CACEHEDI">"Automatic Data Preparation"</a> for information about the <code>PREP_AUTO</code> setting</div>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS73429" class="refsect4"><a id="CACDIDID"></a>
<h5 class="refsect4">Adding Transformation Records to a Transformation List</h5>
<p>A transformation list is a stack of transformation records. When a new transformation record is added, it is appended to the top of the stack. (See <a href="#CACIJGBE">"About Stacking"</a> for details.)</p>
<p>When you use <code>SET_TRANSFORM</code> to add a transformation record to a transformation list, you can specify values for all the fields in the transformation record.</p>
<p>When you use <code>STACK</code> procedures to add transformation records to a transformation list, only the transformation expression field is populated. For normalization transformations, the reverse transformation expression field is also populated.</p>
<p>You can use both <code>STACK</code> procedures and <code>SET_TRANSFORM</code> to build one transformation list. Each <code>STACK</code> procedure call adds transformation records for all the attributes in a specified transformation definition table. Each <code>SET_TRANSFORM</code> call adds a transformation record for a single attribute.</p>
<br /></div>
<!-- class="refsect4" --></div>
<!-- class="refsect3" -->
<div id="ARPLS73347" class="refsect3"><a id="CACIJGBE"></a>
<h4 class="refsect3">About Stacking</h4>
<p>Transformation lists are built by stacking transformation records. Transformation lists are evaluated from bottom to top. Each transformation expression depends on the result of the transformation expression below it in the stack.</p>
<div id="ARPLS73430" class="refsect4"><a id="sthref2607"></a>
<h5 class="refsect4">Stack Procedures</h5>
<p><code>STACK</code> procedures create transformation records from the information in transformation definition tables. For example <code>STACK_BIN_NUM</code> builds a transformation record for each attribute specified in a definition table for numeric binning. <code>STACK</code> procedures stack the transformation records as follows:</p>
<ul>
<li>
<p>If an attribute is specified in the definition table but not in the transformation list, the <code>STACK</code> procedure creates a transformation record, computes the reverse transformation (if possible), inserts the transformation and reverse transformation in the transformation record, and appends the transformation record to the top of the transformation list.</p>
</li>
<li>
<p>If an attribute is specified in the transformation list but not in the definition table, the <code>STACK</code> procedure takes no action.</p>
</li>
<li>
<p>If an attribute is specified in the definition table <span class="italic">and</span> in the transformation list, the <code>STACK</code> procedure stacks the transformation expression from the definition table on top of the transformation expression in the transformation record and updates the reverse transformation. See <a href="#CACFFJCI">Example 45-1, "Stacking a Clipping Transformation"</a>and <a href="#CACGEDBB">Example 45-4, "Stacking a Nested Normalization Transformation"</a>.</p>
</li>
</ul>
<div id="ARPLS73348" class="example">
<p class="titleinexample"><a id="CACFFJCI"></a>Example 45-1 Stacking a Clipping Transformation</p>
<p>This example shows how <a href="#CACHGHIG">STACK_CLIP Procedure</a> would add transformation records to a transformation list. Note that the clipping transformations are not reversed in <code>COL1</code> and <code>COL2</code> after stacking (as described in <a href="#CACHAJGE">"Reverse Transformations and Model Transparency"</a>).</p>
<p class="itemizedlisttitle">Refer to:&nbsp;</p>
<ul>
<li>
<p><a href="#BABCFGBC">CREATE_CLIP Procedure</a> &mdash; Creates the definition table</p>
</li>
<li>
<p><a href="#BABIIJFA">INSERT_CLIP_TRIM_TAIL Procedure</a> &mdash; Inserts definitions in the table</p>
</li>
<li>
<p><a href="#BABIIFED">INSERT_CLIP_WINSOR_TAIL Procedure</a> &mdash; Inserts definitions in the table</p>
</li>
<li>
<p><a href="#CACEJIHI">Table 45-1</a> &mdash; Describes the structure of the transformation list (<code>TRANSFORM_LIST</code> object)</p>
</li>
</ul>
<p><span class="bold">Assume a clipping definition table populated as follows.</span></p>
<div class="inftblinformal">
<table class="cellalignment1226" summary="Sample transformation definition table for clipping" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t11">col</th>
<th class="cellalignment1227" id="r1c2-t11">att</th>
<th class="cellalignment1227" id="r1c3-t11">lcut</th>
<th class="cellalignment1227" id="r1c4-t11">lval</th>
<th class="cellalignment1227" id="r1c5-t11">rcut</th>
<th class="cellalignment1227" id="r1c6-t11">rval</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t11" headers="r1c1-t11"><code><span class="codeinlinebold">COL1</span></code></td>
<td class="cellalignment1228" headers="r2c1-t11 r1c2-t11">null</td>
<td class="cellalignment1228" headers="r2c1-t11 r1c3-t11">-1.5</td>
<td class="cellalignment1228" headers="r2c1-t11 r1c4-t11">-1.5</td>
<td class="cellalignment1228" headers="r2c1-t11 r1c5-t11">4.5</td>
<td class="cellalignment1228" headers="r2c1-t11 r1c6-t11">4.5</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t11" headers="r1c1-t11"><code><span class="codeinlinebold">COL2</span></code></td>
<td class="cellalignment1228" headers="r3c1-t11 r1c2-t11">null</td>
<td class="cellalignment1228" headers="r3c1-t11 r1c3-t11">0</td>
<td class="cellalignment1228" headers="r3c1-t11 r1c4-t11">0</td>
<td class="cellalignment1228" headers="r3c1-t11 r1c5-t11">1</td>
<td class="cellalignment1228" headers="r3c1-t11 r1c6-t11">1</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p><span class="bold">Assume the following transformation list before stacking.</span></p>
<pre>
-------------------------
transformation record #1:
-------------------------
     attribute_name       = <span class="bold">COL1</span>
     attribute_subname    = null
     expression           = log(10, COL1)
     reverse_expression   = power(10, COL1)
-------------------------
transformation record #2:
-------------------------
     attribute_name       = <span class="bold">COL3</span>
     attribute_subname    = null
     expression           = ln(COL3)
     reverse_expression   = exp(COL3)
</pre></div>
<!-- class="example" -->
<p><span class="bold">After stacking, the transformation list is as follows.</span></p>
<pre>
-------------------------
transformation record #1:
-------------------------
     attribute_name       = <span class="bold">COL1</span>
     attribute_subname    = null
     expression           = CASE WHEN log(10, COL1) &lt; -1.5 THEN -1.5
                                 WHEN log(10, COL1) &gt; 4.5  THEN 4.5
                                 ELSE log(10, COL1)
                            END;
     reverse_expression   = power(10, COL1)
-------------------------
transformation record #2:
-------------------------
     attribute_name       = <span class="bold">COL3</span>
     attribute_subname    = null
     expression           = ln(COL3)
     reverse_expression   = exp(COL3)
-------------------------
transformation record #3:
-------------------------
     attribute_name       = <span class="bold">COL2</span>
     attribute_subname    = null
     expression           = CASE WHEN COL2 &lt; 0 THEN 0
                                 WHEN COL2 &gt; 1 THEN 1
                                 ELSE COL2
                            END;
     reverse_expression   = null
</pre>
<br /></div>
<!-- class="refsect4" --></div>
<!-- class="refsect3" -->
<div id="ARPLS73349" class="refsect3"><a id="CACBAGBJ"></a>
<h4 class="refsect3">Nested Data Transformations</h4>
<p>The <code>CREATE</code> routines create transformation definition tables that include two columns, <code>col</code> and <code>att</code>, for identifying attributes. The column <code>col</code> holds the name of a column in the data table. If the data column is not nested, then <code>att</code> is null, and the name of the attribute is <code><span class="codeinlineitalic">col</span></code>. If the data column is nested, then <code>att</code> holds the name of the nested attribute, and the name of the attribute is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>The <code>INSERT</code> and <code>XFORM</code> routines ignore the <code>att</code> column in the definition tables. Neither the <code>INSERT</code> nor the <code>XFORM</code> routines support nested data.</p>
<p>Only the <code>STACK</code> procedures and <code>SET_TRANSFORM</code> support nested data. Nested data transformations are always embedded in the model.</p>
<p>Nested columns in Oracle Data Mining can have either of the following types:</p>
<pre>
DM_NESTED_NUMERICALS
DM_NESTED_CATEGORICALS
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#BABHCGBG">"Constants"</a></p>
<p><a class="olink DMPRG006" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG006"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a> for details about nested attributes in Oracle Data Mining</p>
</div>
<p class="subhead2"><a id="ARPLS73431"></a>Specifying Nested Attributes in a Transformation Record</p>
<p>A transformation record (<code>TRANSFORM_REC</code>) includes two fields, <code>attribute_name</code> and <code>attribute_subname</code>, for identifying the attribute. The field <code>attribute_name</code> holds the name of a column in the data table. If the data column is not nested, then <code>attribute_subname</code> is null, and the name of the attribute is <code><span class="codeinlineitalic">attribute_name</span></code>. If the data column is nested, then <code>attribute_subname</code> holds the name of the nested attribute, and the name of the attribute is <code><span class="codeinlineitalic">attribute_name.attribute_subname</span></code>.</p>
<p class="subhead2"><a id="ARPLS73432"></a>Transforming Individual Nested Attributes</p>
<p>You can specify different transformations for different attributes in a nested column, and you can specify a default transformation for all the remaining attributes in the column. To specify a default nested transformation, specify null in the <code>attribute_name</code> field and the name of the nested column in the <code>attribute_subname</code> field as shown in <a href="#CACDICHD">Example 45-2</a>. Note that the keyword <code>VALUE</code> is used to represent the value of a nested attribute in a transformation expression.</p>
<div id="ARPLS73353" class="example">
<p class="titleinexample"><a id="CACDICHD"></a>Example 45-2 Transforming a Nested Column</p>
<p>The following statement transforms two of the nested attributes in <code>COL_N1</code>. Attribute <code>ATTR1</code> is transformed with normalization; Attribute <code>ATTR2</code> is set to null, which causes attribute removal transformation (<code>ATTR2</code> is not used in training the model). All the remaining attributes in <code>COL_N1</code> are divided by 10.</p>
<pre>
DECLARE
  stk dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
  dbms_data_mining_transform.SET_TRANSFORM(
      stk,'COL_N1', 'ATTR1', '(VALUE - (-1.5))/20', 'VALUE *20 + (-1.5)');
  dbms_data_mining_transform.SET_TRANSFORM(
      stk,'COL_N1', 'ATTR2', NULL, NULL);
  dbms_data_mining_transform.SET_TRANSFORM(
      stk, NULL, 'COL_N1', 'VALUE/10', 'VALUE*10');
END;
/
</pre>
<p>The following SQL is generated from this statement.</p>
<pre>
CAST(MULTISET(SELECT DM_NESTED_NUMERICAL(
                               "ATTRIBUTE_NAME",
                               DECODE("ATTRIBUTE_NAME",
                                 'ATTR1', ("VALUE" - (-1.5))/20,
                                 "VALUE"/10))
                        FROM TABLE("COL_N1")
                       WHERE "ATTRIBUTE_NAME" IS NOT IN ('ATTR2'))
             AS DM_NESTED_NUMERICALS)
</pre>
<p>If transformations are not specified for <code>COL_N1.ATTR1</code> and <code>COL_N1.ATTR2</code>, then the default transformation is used for all the attributes in <code>COL_N1</code>, and the resulting SQL does not include a <code>DECODE</code>.</p>
<pre>
    CAST(MULTISET(SELECT DM_NESTED_NUMERICAL(
                               "ATTRIBUTE_NAME",
                               "VALUE"/10)
                        FROM TABLE("COL_N1"))
             AS DM_NESTED_NUMERICALS)
</pre>
<p>Since <code>DECODE</code> is limited to 256 arguments, multiple <code>DECODE</code> functions are nested to support an arbitrary number of individual nested attribute specifications.</p>
</div>
<!-- class="example" -->
<p class="subhead2"><a id="ARPLS73447"></a>Adding a Nested Column</p>
<p>You can specify a transformation that adds a nested column to the data, as shown in <a href="#CACIHDBG">Example 45-3</a>.</p>
<div id="ARPLS73448" class="example">
<p class="titleinexample"><a id="CACIHDBG"></a>Example 45-3 Adding a Nested Column to a Transformation List</p>
<pre>
DECLARE
    v_xlst dbms_data_mining_transform.TRANSFORM_LIST;
  BEGIN
    dbms_data_mining_transform.SET_TRANSFORM(v_xlst,
      'YOB_CREDLIM', NULL,
      'dm_nested_numericals(
           dm_nested_numerical(
                 ''CUST_YEAR_OF_BIRTH'', cust_year_of_birth),
           dm_nested_numerical(
                 ''CUST_CREDIT_LIMIT'', cust_credit_limit))',
        NULL);
    dbms_data_mining_transform.SET_TRANSFORM(
              v_xlst, 'CUST_YEAR_OF_BIRTH', NULL, NULL, NULL);
    dbms_data_mining_transform.SET_TRANSFORM(
              v_xlst, 'CUST_CREDIT_LIMIT', NULL, NULL, NULL);
    dbms_data_mining_transform.XFORM_STACK(
              v_xlst, 'mining_data', 'mining_data_v');
END;
/

set long 2000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_V';
 
TEXT
---------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_POSTAL_CODE",dm_nested_numericals(
        dm_nested_numerical(
           'CUST_YEAR_OF_BIRTH', cust_year_of_birth),
        dm_nested_numerical(
           'CUST_CREDIT_LIMIT', cust_credit_limit)) "YOB_CREDLIM" FROM mining_data
 
SELECT * FROM mining_data_v WHERE cust_id = 104500;
 
CUST_ID CUST_POSTAL_CODE YOB_CREDLIM(ATTRIBUTE_NAME, VALUE)
------- ---------------- ---------------------------------------------------------
 104500 68524            DM_NESTED_NUMERICALS(DM_NESTED_NUMERICAL(
                        'CUST_YEAR_OF_BIRTH', 1962),
                         DM_NESTED_NUMERICAL('CUST_CREDIT_LIMIT', 15000))
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="ARPLS73449"></a>Stacking Nested Transformations</p>
<p><a href="#CACGEDBB">Example 45-4</a> shows how the <a href="#BABFAFCH">STACK_NORM_LIN Procedure</a> would add transformation records for nested column <code>COL_N</code> to a transformation list.</p>
<p class="itemizedlisttitle">Refer to:&nbsp;</p>
<ul>
<li>
<p><a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a> &mdash; Creates the definition table</p>
</li>
<li>
<p><a href="#BABDFACD">INSERT_NORM_LIN_MINMAX Procedure</a> &mdash; Inserts definitions in the table</p>
</li>
<li>
<p><a href="#BABHAFJC">INSERT_NORM_LIN_SCALE Procedure</a> &mdash; Inserts definitions in the table</p>
</li>
<li>
<p><a href="#BABDCGGH">INSERT_NORM_LIN_ZSCORE Procedure</a> &mdash; Inserts definitions in the table</p>
</li>
<li>
<p><a href="#CACEJIHI">Table 45-1</a> &mdash; Describes the structure of the transformation list</p>
</li>
</ul>
<div id="ARPLS73354" class="example">
<p class="titleinexample"><a id="CACGEDBB"></a>Example 45-4 Stacking a Nested Normalization Transformation</p>
<p><span class="bold">Assume a linear normalization definition table populated as follows.</span></p>
<div class="inftblinformal">
<table class="cellalignment1226" summary="Sample transformation definition table for clipping" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t13">col</th>
<th class="cellalignment1227" id="r1c2-t13">att</th>
<th class="cellalignment1227" id="r1c3-t13">shift</th>
<th class="cellalignment1227" id="r1c4-t13">scale</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t13" headers="r1c1-t13"><code>COL_N</code></td>
<td class="cellalignment1228" headers="r2c1-t13 r1c2-t13"><code>ATT2</code></td>
<td class="cellalignment1228" headers="r2c1-t13 r1c3-t13">0</td>
<td class="cellalignment1228" headers="r2c1-t13 r1c4-t13">20</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t13" headers="r1c1-t13"><code>null</code></td>
<td class="cellalignment1228" headers="r3c1-t13 r1c2-t13"><code>COL_N</code></td>
<td class="cellalignment1228" headers="r3c1-t13 r1c3-t13">0</td>
<td class="cellalignment1228" headers="r3c1-t13 r1c4-t13">10</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p><span class="bold">Assume the following transformation list before stacking.</span></p>
<pre>
-------------------------
transformation record #1:
-------------------------
     attribute_name       = COL_N
     attribute_subname    = ATT1
     expression           = log(10, VALUE)
     reverse_expression   = power(10, VALUE)
-------------------------
transformation record #2:
-------------------------
     attribute_name       = null
     attribute_subname    = COL_N
     expression           = ln(VALUE)
     reverse_expression   = exp(VALUE)
</pre>
<p><span class="bold">After stacking, the transformation list is as follows.</span></p>
<pre>
-------------------------
transformation record #1:
-------------------------
     attribute_name       = COL_N
     attribute_subname    = ATT1
     expression           = (log(10, VALUE) - 0)/10
     reverse_expression   = power(10, VALUE*10 + 0)
-------------------------
transformation record #2:
-------------------------
     attribute_name       = NULL
     attribute_subname    = COL_N
     expression           = (ln(VALUE)- 0)/10
     reverse_expression   = exp(VALUE *10 + 0)
-------------------------
transformation record #3:
-------------------------
     attribute_name       = COL_N
     attribute_subname    = ATT2
     expression           = (ln(VALUE) - 0)/20
     reverse_expression   = exp(VALUE * 20 + 0)
</pre></div>
<!-- class="example" --></div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73295" class="refsect2"><a id="CACJIABG"></a>
<hr />
<h3 class="refsect2">Security Model</h3>
<p>The <code>DBMS_DATA_MINING_TRANSFORM</code> package is owned by user <code>SYS</code> and is installed as part of database installation. Execution privilege on the package is granted to public. The routines in the package are run with invokers' rights (run with the privileges of the current user).</p>
<p>The <code>DBMS_DATA_MINING_TRANSFORM.INSERT</code>_* procedures have a <code><span class="codeinlineitalic">data_table_name</span></code> parameter that enables the user to provide the input data for transformation purposes. The value of <code><span class="codeinlineitalic">data_table_name</span></code> can be the name of a physical table or a view. The <code><span class="codeinlineitalic">data_table_name</span></code> parameter can also accept an inline query.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
Because an inline query can be used to specify the data for transformation, Oracle strongly recommends that the calling routine perform any necessary SQL injection checks on the input string.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABDIIIC">"Operational Notes"</a> for a description of the <code>DBMS_DATA_MINING_TRANSFORM.INSERT</code>_* procedures</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS72997" class="refsect2"><a id="CACGBFDB"></a>
<hr />
<h3 class="refsect2"><a id="sthref2610"></a>Types</h3>
<p><code>DBMS_DATA_MINING_TRANSFORM</code> defines the data types described in <a href="#CACEJIHI">Table 45-1</a>.</p>
<div id="ARPLS73422" class="tblformalwidemax">
<p class="titleintable"><a id="sthref2611"></a><a id="CACEJIHI"></a>Table 45-1 Data Types in DBMS_DATA_MINING_TRANSFORM</p>
<table class="cellalignment1226" title="Data Types in DBMS_DATA_MINING_TRANSFORM" summary="This table describes the defined types in the DBMS_DATA_MINING_TRANSFORM package. They are: COLUMN_LIST, DESCRIBE_LIST, EXPRESSION_REC, TRANSFORM_REC, AND TRANSFORM_LIST." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t16">List Type</th>
<th class="cellalignment1227" id="r1c2-t16">List Elements</th>
<th class="cellalignment1227" id="r1c3-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t16" headers="r1c1-t16">
<pre>
<span class="bold">COLUMN_</span>
<span class="bold">LIST</span>
</pre></td>
<td class="cellalignment1228" headers="r2c1-t16 r1c2-t16">
<pre>
VARRAY(1000) OF varchar2(32)
</pre></td>
<td class="cellalignment1228" headers="r2c1-t16 r1c3-t16">
<p><code>COLUMN_LIST</code> stores quoted and non-quoted identifiers for column names.</p>
<p><code>COLUMN_LIST</code> is the data type of the <code><span class="codeinlineitalic">exclude_list</span></code> parameter in the <code>INSERT</code> procedures. See <a href="#BABJDGIA">"INSERT_AUTOBIN_NUM_EQWIDTH Procedure"</a> for an example.</p>
<p>See <a class="olink LNPLS443" href="../../appdev.112/e25519/composites.htm#LNPLS443"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about populating <code>VARRAY</code> structures.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t16" headers="r1c1-t16">
<pre>
<span class="bold">DESCRIBE_</span>
<span class="bold">LIST</span>
</pre></td>
<td class="cellalignment1228" headers="r3c1-t16 r1c2-t16">
<pre>
DBMS_SQL.DESC_TAB2

TYPE desc_tab2 IS TABLE OF desc_rec2 
INDEX BY BINARY_INTEGER

TYPE desc_rec2 IS RECORD (
col_type            BINARY_INTEGER := 0,
col_max_len         BINARY_INTEGER := 0,
col_name            VARCHAR2(32767):= '',
col_name_len        BINARY_INTEGER := 0,
col_schema_name     VARCHAR2(32)   := '',
col_schema_name_len BINARY_INTEGER := 0,
col_precision       BINARY_INTEGER := 0,
col_scale           BINARY_INTEGER := 0,
col_charsetid       BINARY_INTEGER := 0,
col_charsetform     BINARY_INTEGER := 0,
col_null_ok         BOOLEAN := TRUE);
</pre></td>
<td class="cellalignment1228" headers="r3c1-t16 r1c3-t16">
<p><code>DESCRIBE_LIST</code> describes the columns of the data table after the transformation list has been applied. A <code>DESCRIBE_LIST</code> is returned by the <a href="#BABIIFEF">DESCRIBE_STACK Procedure</a>.</p>
<p>The <code>DESC_TAB2</code> and <code>DESC_REC2</code> types are defined in the <code>DBMS_SQL</code> package. See <a href="d_sql.htm#CHDGJIHF">"DESC_REC2 Record Type"</a>.</p>
<p>The <code>col_type</code> field of <code>DESC_REC2</code> identifies the data type of the column. The data type is expressed as a numeric constant that represents a built-in data type. For example, a 1 indicates a variable length character string. The codes for Oracle built-in data types are listed in <a class="olink SQLRF50972" href="../../server.112/e41084/sql_elements001.htm#SQLRF50972"><span class="italic">Oracle Database SQL Language Reference</span></a>. The codes for the Oracle Data Mining nested types are described in <a href="#BABHCGBG">"Constants"</a>.</p>
<p>The <code>col_name</code> field of <code>DESC_REC2</code> identifies the column name. It may be populated with a column name, an alias, or an expression. If the column name is a <code>SELECT</code> expression, it may be very long. If the expression is longer than 30 bytes, it cannot be used in a view unless it is given an alias.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t16" headers="r1c1-t16">
<pre>
<span class="bold">TRANSFORM_</span>
<span class="bold">LIST</span>
</pre></td>
<td class="cellalignment1228" headers="r4c1-t16 r1c2-t16">
<pre>
<span class="bold">TABLE OF transform_rec</span>

<span class="bold">TYPE transform_rec IS RECORD</span> (
attribute_name      VARCHAR2(30),
attribute_subname   VARCHAR2(4000),
expression          <span class="bold">EXPRESSION_REC</span>,
reverse_expression  <span class="bold">EXPRESSION_REC</span>,
attribute_spec      VARCHAR2(4000));

<span class="bold">TYPE expression_rec IS RECORD</span> (
lstmt       DBMS_SQL.VARCHAR2A,
lb          BINARY_INTEGER DEFAULT 1,
ub          BINARY_INTEGER DEFAULT 0);

TYPE varchar2a IS TABLE OF VARCHAR2(32767)
INDEX BY BINARY_INTEGER;
</pre></td>
<td class="cellalignment1228" headers="r4c1-t16 r1c3-t16">
<p><code>TRANSFORM_LIST</code> is a list of transformations that can be embedded in a model. A <code>TRANSFORM_LIST</code> is accepted as an argument by the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a>.</p>
<p>Each element in a <code>TRANSFORM_LIST</code> is a <code>TRANSFORM_REC</code> that specifies how to transform a single attribute. The <code>attribute_name</code> is a column name. The <code>attribute_subname</code> is the nested attribute name if the column is nested, otherwise <code>attribute_subname</code> is null.</p>
<p>The <code>expression</code> field holds a SQL expression for transforming the attribute. See <a href="#CACHEGJD">"About Transformation Lists"</a> for an explanation of reverse expressions.</p>
<p>The <code>attribute_spec</code> field can be used to disable ADP for this attribute. Specify the keyword <code>NOPREP</code> to disable ADP. By default <code>attribute_spec</code> is null.</p>
<p>The expressions in a <code>TRANSFORM_REC</code> have type <code>EXPRESSION_REC</code>. The <code>lstmt</code> field stores a <code>VARCHAR2A</code>, which is a table of <code>VARCHAR2(32767)</code>. The <code>VARCHAR2A</code> data type allows transformation expressions to be very long, as they can be broken up across multiple rows of <code>VARCHAR2</code>. The <code>VARCHAR2A</code> type is defined in the <code>DBMS_SQL</code> package. See <a href="d_sql.htm#CHDEGGIG">"VARCHAR2A Table Type"</a>.</p>
<p>The <code>ub</code> (upper bound) and <code>lb</code> (lower bound) fields indicate how many rows there are in the <code>VARCHAR2A</code> table. If <code>ub</code> &lt; <code>lb</code> (default) the <code>EXPRESSION_REC</code> is empty; if <code>lb</code>=<code>ub</code>=1 there is one row; if <code>lb</code>=1 and <code>ub</code>=2 there are 2 rows, and so on.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72999" class="refsect2"><a id="BABHCGBG"></a>
<hr />
<h3 class="refsect2">Constants</h3>
<p><code>DBMS_DATA_MINING_TRANSFORM</code> defines the constants described in <a href="#BABJIIGI">Table 45-2</a>.</p>
<div id="ARPLS73000" class="tblformal">
<p class="titleintable"><a id="sthref2612"></a><a id="BABJIIGI"></a>Table 45-2 Constants in DBMS_DATA_MINING_TRANSFORM</p>
<table class="cellalignment1229" title="Constants in DBMS_DATA_MINING_TRANSFORM" summary="This table describes the two constants defined in the DBMS_DATA_MINING_TRANSFORM package. They are: NEST_NUM_COL_TYPE and NEST_CAT_COL_TYPE." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t17">Constant</th>
<th class="cellalignment1227" id="r1c2-t17">Value</th>
<th class="cellalignment1227" id="r1c3-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t17" headers="r1c1-t17">
<p><code>NEST_NUM_COL_TYPE</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t17 r1c2-t17">
<p>100001</p>
</td>
<td class="cellalignment1228" headers="r2c1-t17 r1c3-t17">
<p>Indicates that an attribute in the transformation list comes from a row in a column of <code>DM_NESTED_NUMERICALS</code>.</p>
<p>Nested numerical attributes are defined as follows:</p>
<pre>
attribute_name       VARCHAR2(4000)
value                NUMBER
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t17" headers="r1c1-t17">
<p><code>NEST_CAT_COL_TYPE</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t17 r1c2-t17">
<p>100002</p>
</td>
<td class="cellalignment1228" headers="r3c1-t17 r1c3-t17">
<p>Indicates that an attribute in the transformation list comes from a row in a column of <code>DM_NESTED_CATAGORICALS</code>.</p>
<p>Nested categorical attributes are defined as follows:</p>
<pre>
attribute_name       VARCHAR2(4000)
value                VARCHAR2(4000)
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DMPRG006" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG006"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a> for information about nested data in Oracle Data Mining</div>
</div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="BABIDHCI"></a>
<hr />
<div id="ARPLS73001" class="refsect1">
<h2 class="refsect1">S<a id="sthref2613"></a>ummary of DBMS_DATA_MINING_TRANSFORM Subprograms</h2>
<div id="ARPLS73002" class="tblformal">
<p class="titleintable"><a id="sthref2614"></a><a id="sthref2615"></a>Table 45-3 DBMS_DATA_MINING_TRANSFORM Package Subprograms</p>
<table class="cellalignment1229" title="DBMS_DATA_MINING_TRANSFORM Package Subprograms" summary="This table lists the DBMS_DATA_MINING_TRANSFORM subprograms in alphabetical order and briefly describes them." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t19">Subprogram</th>
<th class="cellalignment1227" id="r1c2-t19">Purpose</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t19" headers="r1c1-t19">
<p><a href="#BABHJHJF">CREATE_BIN_CAT Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r2c1-t19 r1c2-t19">
<p>Creates a transformation definition table for categorical binning</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t19" headers="r1c1-t19">
<p><a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r3c1-t19 r1c2-t19">
<p>Creates a transformation definition table for numerical binning</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t19" headers="r1c1-t19">
<p><a href="#BABCFGBC">CREATE_CLIP Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r4c1-t19 r1c2-t19">
<p>Creates a transformation definition table for clipping</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t19" headers="r1c1-t19">
<p><a href="#BABGCDCC">CREATE_COL_REM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r5c1-t19 r1c2-t19">
<p>Creates a transformation definition table for column removal</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t19" headers="r1c1-t19">
<p><a href="#BABHJFDC">CREATE_MISS_CAT Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r6c1-t19 r1c2-t19">
<p>Creates a transformation definition table for categorical missing value treatment</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t19" headers="r1c1-t19">
<p><a href="#BABIEAGA">CREATE_MISS_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r7c1-t19 r1c2-t19">
<p>Creates a transformation definition table for numerical missing values treatment</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t19" headers="r1c1-t19">
<p><a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r8c1-t19 r1c2-t19">
<p>Creates a transformation definition table for linear normalization</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t19" headers="r1c1-t19">
<p><a href="#BABIIFEF">DESCRIBE_STACK Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r9c1-t19 r1c2-t19">
<p>Describes the transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t19" headers="r1c1-t19">
<p><a href="#BABGDGIA">GET_EXPRESSION Function</a></p>
</td>
<td class="cellalignment1228" headers="r10c1-t19 r1c2-t19">
<p>Returns a <code>VARCHAR2</code> chunk from a transformation expression</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t19" headers="r1c1-t19">
<p><a href="#BABJDGIA">INSERT_AUTOBIN_NUM_EQWIDTH Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r11c1-t19 r1c2-t19">
<p>Inserts numeric automatic equi-width binning definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t19" headers="r1c1-t19">
<p><a href="#BABCIBEH">INSERT_BIN_CAT_FREQ Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r12c1-t19 r1c2-t19">
<p>Inserts categorical frequency-based binning definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r13c1-t19" headers="r1c1-t19">
<p><a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r13c1-t19 r1c2-t19">
<p>Inserts numeric equi-width binning definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r14c1-t19" headers="r1c1-t19">
<p><a href="#BABEDFDH">INSERT_BIN_NUM_QTILE Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r14c1-t19 r1c2-t19">
<p>Inserts numeric quantile binning expressions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r15c1-t19" headers="r1c1-t19">
<p><a href="#BABEHBCE">INSERT_BIN_SUPER Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r15c1-t19 r1c2-t19">
<p>Inserts supervised binning definitions in numerical and categorical transformation definition tables</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r16c1-t19" headers="r1c1-t19">
<p><a href="#BABIIJFA">INSERT_CLIP_TRIM_TAIL Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r16c1-t19 r1c2-t19">
<p>Inserts numerical trimming definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r17c1-t19" headers="r1c1-t19">
<p><a href="#BABIIFED">INSERT_CLIP_WINSOR_TAIL Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r17c1-t19 r1c2-t19">
<p>Inserts numerical winsorizing definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r18c1-t19" headers="r1c1-t19">
<p><a href="#BABJCGCA">INSERT_MISS_CAT_MODE Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r18c1-t19 r1c2-t19">
<p>Inserts categorical missing value treatment definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r19c1-t19" headers="r1c1-t19">
<p><a href="#BABHAHEJ">INSERT_MISS_NUM_MEAN Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r19c1-t19 r1c2-t19">
<p>Inserts numerical missing value treatment definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r20c1-t19" headers="r1c1-t19">
<p><a href="#BABDFACD">INSERT_NORM_LIN_MINMAX Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r20c1-t19 r1c2-t19">
<p>Inserts linear min-max normalization definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r21c1-t19" headers="r1c1-t19">
<p><a href="#BABHAFJC">INSERT_NORM_LIN_SCALE Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r21c1-t19 r1c2-t19">
<p>Inserts linear scale normalization definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r22c1-t19" headers="r1c1-t19">
<p><a href="#BABDCGGH">INSERT_NORM_LIN_ZSCORE Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r22c1-t19 r1c2-t19">
<p>Inserts linear zscore normalization definitions in a transformation definition table</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r23c1-t19" headers="r1c1-t19">
<p><a href="#CACJDFJC">SET_EXPRESSION Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r23c1-t19 r1c2-t19">
<p>Adds a <code>VARCHAR2</code> chunk to an expression</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r24c1-t19" headers="r1c1-t19">
<p><a href="#BABJIIIE">SET_TRANSFORM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r24c1-t19 r1c2-t19">
<p>Adds a transformation record to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r25c1-t19" headers="r1c1-t19">
<p><a href="#CACJCHHI">STACK_BIN_CAT Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r25c1-t19 r1c2-t19">
<p>Adds a categorical binning expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r26c1-t19" headers="r1c1-t19">
<p><a href="#CACEGEHI">STACK_BIN_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r26c1-t19 r1c2-t19">
<p>Adds a numerical binning expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r27c1-t19" headers="r1c1-t19">
<p><a href="#CACHGHIG">STACK_CLIP Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r27c1-t19 r1c2-t19">
<p>Adds a clipping expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r28c1-t19" headers="r1c1-t19">
<p><a href="#CACHCDCH">STACK_COL_REM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r28c1-t19 r1c2-t19">
<p>Adds a column removal expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r29c1-t19" headers="r1c1-t19">
<p><a href="#BABJGBGH">STACK_MISS_CAT Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r29c1-t19 r1c2-t19">
<p>Adds a categorical missing value treatment expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r30c1-t19" headers="r1c1-t19">
<p><a href="#BABFIBFF">STACK_MISS_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r30c1-t19 r1c2-t19">
<p>Adds a numerical missing value treatment expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r31c1-t19" headers="r1c1-t19">
<p><a href="#BABFAFCH">STACK_NORM_LIN Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r31c1-t19 r1c2-t19">
<p>Adds a linear normalization expression to a transformation list</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r32c1-t19" headers="r1c1-t19">
<p><a href="#BABHHBCI">XFORM_BIN_CAT Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r32c1-t19 r1c2-t19">
<p>Creates a view of the data table with categorical binning transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r33c1-t19" headers="r1c1-t19">
<p><a href="#BABJDHDF">XFORM_BIN_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r33c1-t19 r1c2-t19">
<p>Creates a view of the data table with numerical binning transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r34c1-t19" headers="r1c1-t19">
<p><a href="#BABDFGDG">XFORM_CLIP Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r34c1-t19 r1c2-t19">
<p>Creates a view of the data table with clipping transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r35c1-t19" headers="r1c1-t19">
<p><a href="#BABHFHGH">XFORM_COL_REM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r35c1-t19 r1c2-t19">
<p>Creates a view of the data table with column removal transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r36c1-t19" headers="r1c1-t19">
<p><a href="#BABJHGCG">XFORM_EXPR_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r36c1-t19 r1c2-t19">
<p>Creates a view of the data table with the specified numeric transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r37c1-t19" headers="r1c1-t19">
<p><a href="#BABHGAJH">XFORM_EXPR_STR Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r37c1-t19 r1c2-t19">
<p>Creates a view of the data table with the specified categorical transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r38c1-t19" headers="r1c1-t19">
<p><a href="#BABBEDBE">XFORM_MISS_CAT Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r38c1-t19 r1c2-t19">
<p>Creates a view of the data table with categorical missing value treatment</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r39c1-t19" headers="r1c1-t19">
<p><a href="#BABCFDAA">XFORM_MISS_NUM Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r39c1-t19 r1c2-t19">
<p>Creates a view of the data table with numerical missing value treatment</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r40c1-t19" headers="r1c1-t19">
<p><a href="#BABIHHGG">XFORM_NORM_LIN Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r40c1-t19 r1c2-t19">
<p>Creates a view of the data table with linear normalization transformations</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r41c1-t19" headers="r1c1-t19">
<p><a href="#BABIHDCC">XFORM_STACK Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r41c1-t19 r1c2-t19">
<p>Creates a view of the transformation list</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="ARPLS73003" class="refsect2"><a id="BABHJHJF"></a>
<hr />
<h3 class="refsect2"><a id="sthref2616"></a>CREATE_BIN_CAT Procedure</h3>
<p>This procedure creates a transformation definition table for categorical binning. The columns are described in <a href="#BABBHJED">Table 45-4</a>.</p>
<div id="ARPLS73004" class="tblformal">
<p class="titleintable"><a id="sthref2617"></a><a id="BABBHJED"></a>Table 45-4 Columns in a Transformation Definition Table for Categorical Binning</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Categorical Binning" summary="This table describes the transformation definition table for categorical binning" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t20">Name</th>
<th class="cellalignment1227" id="r1c2-t20">Data Type</th>
<th class="cellalignment1227" id="r1c3-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t20" headers="r1c1-t20">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t20 r1c2-t20">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t20 r1c3-t20">
<p>Name of a column of <code>CHAR</code>, <code>VARCHAR2</code>, or <code>DM_NESTED_CATEGORICALS</code> in the data to be mined.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is <code>CHAR</code> or <code>VARCHAR2</code>, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t20" headers="r1c1-t20">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t20 r1c2-t20">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t20 r1c3-t20">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is a nested column of <code>DM_NESTED_CATEGORICALS</code>. If <code><span class="codeinlineitalic">col</span></code> is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t20" headers="r1c1-t20">
<p><code>val</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t20 r1c2-t20">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t20 r1c3-t20">
<p>Values of the attribute</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t20" headers="r1c1-t20">
<p><code>bin</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t20 r1c2-t20">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t20 r1c3-t20">
<p>Bin assignments for the values</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2618"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_BIN_CAT (
     bin_table_name     IN VARCHAR2,
     bin_schema_name    IN VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2619"></a>Parameters</p>
<div id="ARPLS73005" class="tblformal">
<p class="titleintable"><a id="sthref2620"></a><a id="sthref2621"></a>Table 45-5 CREATE_BIN_CAT Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_BIN_CAT Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.CREATE_BIN_CAT." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t21">Parameter</th>
<th class="cellalignment1227" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t21" headers="r1c1-t21">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t21 r1c2-t21">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t21" headers="r1c1-t21">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t21 r1c2-t21">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2622"></a>Usage Notes</p>
<p>You can use the following procedures to populate the transformation definition table:</p>
<ul>
<li id="CACBBGCI">
<p><a href="#BABCIBEH">INSERT_BIN_CAT_FREQ Procedure</a> &mdash; frequency-based binning</p>
</li>
<li>
<p><a href="#BABEHBCE">INSERT_BIN_SUPER Procedure</a> &mdash; supervised binning</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#BABBCHED">"Binning"</a></p>
<p><a href="#BABDIIIC">"Operational Notes"</a></p>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2623"></a>Examples</p>
<p>The following statement creates a table called <code>bin_cat_xtbl</code> in the current schema. The table has columns that can be populated with bin assignments for categorical attributes.</p>
<pre>
BEGIN
   DBMS_DATA_MINING_TRANSFORM.CREATE_BIN_CAT('bin_cat_xtbl');
END;
/
DESCRIBE bin_cat_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
 VAL                                                VARCHAR2(4000)
 BIN                                                VARCHAR2(4000)
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73006" class="refsect2"><a id="BABCJBCG"></a>
<hr />
<h3 class="refsect2"><a id="sthref2624"></a>CREATE_BIN_NUM Procedure</h3>
<p>This procedure creates a transformation definition table for numerical binning. The columns are described in <a href="#BABGAIEI">Table 45-6</a>.</p>
<div id="ARPLS73007" class="tblformal">
<p class="titleintable"><a id="sthref2625"></a><a id="BABGAIEI"></a>Table 45-6 Columns in a Transformation Definition Table for Numerical Binning</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Numerical Binning" summary="This table describes the columns of the transformation definition table for categorical binning" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t23">Name</th>
<th class="cellalignment1227" id="r1c2-t23">Data Type</th>
<th class="cellalignment1227" id="r1c3-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t23" headers="r1c1-t23">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t23 r1c2-t23">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t23 r1c3-t23">
<p>Name of a column of <code>NUMBER</code>, <code>FLOAT</code>, or <code>DM_NESTED_NUMERICALS</code> in the data to be mined.</p>
<p>If the column is <code>NUMBER</code> or <code>FLOAT</code>, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t23" headers="r1c1-t23">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t23 r1c2-t23">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t23 r1c3-t23">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is a nested column of <code>DM_NESTED_NUMERICALS</code>. If <code><span class="codeinlineitalic">col</span></code> is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t23" headers="r1c1-t23">
<p><code>val</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t23 r1c2-t23">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t23 r1c3-t23">
<p>Values of the attribute</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t23" headers="r1c1-t23">
<p><code>bin</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t23 r1c2-t23">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t23 r1c3-t23">
<p>Bin assignments for the values</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2626"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_BIN_NUM (
     bin_table_name    IN VARCHAR2,
     bin_schema_name   IN VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2627"></a>Parameters</p>
<div id="ARPLS73008" class="tblformal">
<p class="titleintable"><a id="sthref2628"></a><a id="sthref2629"></a>Table 45-7 CREATE_BIN_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_BIN_NUM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.CREATE_BIN_NUM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t24">Parameter</th>
<th class="cellalignment1227" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t24" headers="r1c1-t24">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t24 r1c2-t24">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t24" headers="r1c1-t24">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t24 r1c2-t24">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2630"></a>Usage Notes</p>
<p>You can use the following procedures to populate the transformation definition table:</p>
<ul>
<li>
<p><a href="#BABJDGIA">INSERT_AUTOBIN_NUM_EQWIDTH Procedure</a> &mdash; automatic equi-width binning</p>
</li>
<li>
<p><a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> &mdash; user-specified equi-width binning</p>
</li>
<li>
<p><a href="#BABEDFDH">INSERT_BIN_NUM_QTILE Procedure</a> &mdash; quantile binning</p>
</li>
<li>
<p><a href="#BABEHBCE">INSERT_BIN_SUPER Procedure</a> &mdash; supervised binning</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#BABBCHED">"Binning"</a></p>
<p><a href="#BABDIIIC">"Operational Notes"</a></p>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2631"></a>Examples</p>
<p>The following statement creates a table called <code>bin_num_xtbl</code> in the current schema. The table has columns that can be populated with bin assignments for numerical attributes.</p>
<pre>
BEGIN
  DBMS_DATA_MINING_TRANSFORM.CREATE_BIN_NUM('bin_num_xtbl');
END;
/
 
DESCRIBE bin_num_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
 VAL                                                NUMBER
 BIN                                                VARCHAR2(4000)
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73009" class="refsect2"><a id="BABCFGBC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2632"></a>CREATE_CLIP Procedure</h3>
<p>This procedure creates a transformation definition table for clipping or winsorizing to minimize the effect of outliers. The columns are described in <a href="#BABGECBI">Table 45-8</a>.</p>
<div id="ARPLS73010" class="tblformal">
<p class="titleintable"><a id="sthref2633"></a><a id="BABGECBI"></a>Table 45-8 Columns in a Transformation Definition Table for Clipping or Winsorizing</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Clipping or Winsorizing" summary="This table describes the columns of the transformation definition table for clipping" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t26">Name</th>
<th class="cellalignment1227" id="r1c2-t26">Data Type</th>
<th class="cellalignment1227" id="r1c3-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t26" headers="r1c1-t26">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t26 r1c2-t26">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t26 r1c3-t26">
<p>Name of a column of <code>NUMBER</code>, <code>FLOAT</code>, or <code>DM_NESTED_NUMERICALS</code> in the data to be mined.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is <code>NUMBER</code> or <code>FLOAT</code>, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t26" headers="r1c1-t26">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t26 r1c2-t26">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t26 r1c3-t26">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is a nested column of <code>DM_NESTED_NUMERICALS</code>. If <code><span class="codeinlineitalic">col</span></code> is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t26" headers="r1c1-t26">
<p><code>lcut</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t26 r1c2-t26">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t26 r1c3-t26">
<p>The lowest typical value for the attribute.</p>
<p>If the attribute values were plotted on an <span class="italic">xy</span> axis, <code><span class="codeinlineitalic">lcut</span></code> would be the left-most boundary of the range of values considered typical for this attribute.</p>
<p>Any values to the left of <code><span class="codeinlineitalic">lcut</span></code> are outliers.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t26" headers="r1c1-t26">
<p><code>lval</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t26 r1c2-t26">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t26 r1c3-t26">
<p>Value assigned to an outlier to the left of <code><span class="codeinlineitalic">lcut</span></code></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t26" headers="r1c1-t26">
<p><code>rcut</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t26 r1c2-t26">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t26 r1c3-t26">
<p>The highest typical value for the attribute</p>
<p>If the attribute values were plotted on an <span class="italic">xy</span> axis, <code><span class="codeinlineitalic">rcut</span></code> would be the right-most boundary of the range of values considered typical for this attribute.</p>
<p>Any values to the right of <code><span class="codeinlineitalic">rcut</span></code> are outliers.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t26" headers="r1c1-t26">
<p><code>rval</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t26 r1c2-t26">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t26 r1c3-t26">
<p>Value assigned to an outlier to the right of <code><span class="codeinlineitalic">rcut</span></code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2634"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (
     clip_table_name    IN VARCHAR2,
     clip_schema_name   IN VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2635"></a>Parameters</p>
<div id="ARPLS73011" class="tblformal">
<p class="titleintable"><a id="sthref2636"></a><a id="sthref2637"></a>Table 45-9 CREATE_CLIP Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_CLIP Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t27">Parameter</th>
<th class="cellalignment1227" id="r1c2-t27">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t27" headers="r1c1-t27">
<p><code>clip_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t27 r1c2-t27">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t27" headers="r1c1-t27">
<p><code>clip_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t27 r1c2-t27">
<p>Schema of <code><span class="codeinlineitalic">clip_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2638"></a>Usage Notes</p>
<p>You can use the following procedures to populate the transformation definition table:</p>
<ul>
<li>
<p><a href="#BABIIJFA">INSERT_CLIP_TRIM_TAIL Procedure</a> &mdash; replaces outliers with nulls</p>
</li>
<li>
<p><a href="#BABIIFED">INSERT_CLIP_WINSOR_TAIL Procedure</a> &mdash; replaces outliers with an average value</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#CACCICGF">"Outlier Treatment"</a></p>
<p><a href="#BABDIIIC">"Operational Notes"</a></p>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2639"></a>Examples</p>
<p>The following statement creates a table called <code>clip_xtbl</code> in the current schema. The table has columns that can be populated with clipping instructions for numerical attributes.</p>
<pre>
BEGIN
  DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP('clip_xtbl');
END;
/
 
DESCRIBE clip_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
 LCUT                                               NUMBER
 LVAL                                               NUMBER
 RCUT                                               NUMBER
 RVAL                                               NUMBER
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73012" class="refsect2"><a id="BABGCDCC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2640"></a>CREATE_COL_REM Procedure</h3>
<p>This procedure creates a transformation definition table for removing columns from the data table. The columns are described in <a href="#BABBEACJ">Table 45-10</a>.</p>
<div id="ARPLS73013" class="tblformal">
<p class="titleintable"><a id="sthref2641"></a><a id="BABBEACJ"></a>Table 45-10 Columns in a Transformation Definition Table for Column Removal</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Column Removal" summary="This table describes the transformation definition table for column removal" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t29">Name</th>
<th class="cellalignment1227" id="r1c2-t29">Data Type</th>
<th class="cellalignment1227" id="r1c3-t29">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t29" headers="r1c1-t29">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t29 r1c2-t29">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t29 r1c3-t29">
<p>Name of a column in the data to be mined. If <code><span class="codeinlineitalic">col</span></code> is not nested, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t29" headers="r1c1-t29">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t29 r1c2-t29">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t29 r1c3-t29">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is nested (<code>DM_NESTED_NUMERICALS</code> or <code>DM_NESTED_CATEGORICALS</code>). If col is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2642"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_COL_REM (
      rem_table_name           VARCHAR2,
      rem_schema_name          VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2643"></a>Parameters</p>
<div id="ARPLS73014" class="tblformal">
<p class="titleintable"><a id="sthref2644"></a><a id="sthref2645"></a>Table 45-11 CREATE_COL_REM Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_COL_REM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.CREATE_COL_REM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t30">Parameter</th>
<th class="cellalignment1227" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t30" headers="r1c1-t30">
<p><code>rem_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t30 r1c2-t30">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t30" headers="r1c1-t30">
<p><code>rem_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t30 r1c2-t30">
<p>Schema of <code><span class="codeinlineitalic">rem_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2646"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2647"></a>Examples</p>
<p>The following statement creates a table called <code>rem_att_xtbl</code> in the current schema. The table has columns that can be populated with the names of attributes to exclude from the data to be mined.</p>
<pre>
BEGIN
    DBMS_DATA_MINING_TRANSFORM.CREATE_COL_REM ('rem_att_xtbl');
END;
 /
DESCRIBE rem_att_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73015" class="refsect2"><a id="BABHJFDC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2648"></a>CREATE_MISS_CAT Procedure</h3>
<p>This procedure creates a transformation definition table for replacing categorical missing values. The columns are described in <a href="#BABJBBGD">Table 45-12</a>.</p>
<div id="ARPLS73016" class="tblformal">
<p class="titleintable"><a id="sthref2649"></a><a id="BABJBBGD"></a>Table 45-12 Columns in a Transformation Definition Table for Categorical Missing Value Treatment</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Categorical Missing Value Treatment" summary="This table describes the transformation definition table for categorical missing value treatment" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t31">Name</th>
<th class="cellalignment1227" id="r1c2-t31">Data Type</th>
<th class="cellalignment1227" id="r1c3-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t31" headers="r1c1-t31">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t31 r1c2-t31">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t31 r1c3-t31">
<p>Name of a column of <code>CHAR</code>, <code>VARCHAR2</code>, or <code>DM_NESTED_CATEGORICALS</code> in the data to be mined.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is <code>CHAR</code> or <code>VARCHAR2</code>, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t31" headers="r1c1-t31">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t31 r1c2-t31">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t31 r1c3-t31">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is a nested column of <code>DM_NESTED_CATEGORICALS</code>. If <code><span class="codeinlineitalic">col</span></code> is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t31" headers="r1c1-t31">
<p><code>val</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t31 r1c2-t31">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t31 r1c3-t31">
<p>Replacement for missing values in the attribute</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2650"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT (
     miss_table_name       IN VARCHAR2,
     miss_schema_name      IN VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2651"></a>Parameters</p>
<div id="ARPLS73017" class="tblformal">
<p class="titleintable"><a id="sthref2652"></a><a id="sthref2653"></a>Table 45-13 CREATE_MISS_CAT Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_MISS_CAT Procedure Parameters" summary="Lists the parameters in the DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT procedure." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t32">Parameter</th>
<th class="cellalignment1227" id="r1c2-t32">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t32" headers="r1c1-t32">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t32 r1c2-t32">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t32" headers="r1c1-t32">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t32 r1c2-t32">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2654"></a>Usage Notes</p>
<p>You can use the <a href="#BABJCGCA">INSERT_MISS_CAT_MODE Procedure</a> to populate the transformation definition table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#CACDGBDI">"Missing Value Treatment"</a></p>
<p><a href="#BABDIIIC">"Operational Notes"</a></p>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2655"></a>Examples</p>
<p>The following statement creates a table called <code>miss_cat_xtbl</code> in the current schema. The table has columns that can be populated with values for missing data in categorical attributes.</p>
<pre>
BEGIN
</pre>
<pre>
  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT('miss_cat_xtbl');
END;
/
 
DESCRIBE miss_cat_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
 VAL                                                VARCHAR2(4000)
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73018" class="refsect2"><a id="BABIEAGA"></a>
<hr />
<h3 class="refsect2"><a id="sthref2656"></a>CREATE_MISS_NUM Procedure</h3>
<p>This procedure creates a transformation definition table for replacing numerical missing values. The columns are described in <a href="#BABBFJIA">Table 45-14</a>.</p>
<div id="ARPLS73019" class="tblformal">
<p class="titleintable"><a id="sthref2657"></a><a id="BABBFJIA"></a>Table 45-14 Columns in a Transformation Definition Table for Numerical Missing Value Treatment</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Numerical Missing Value Treatment" summary="This table describes the transformation definition table for numerical missing value treatment" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t34">Name</th>
<th class="cellalignment1227" id="r1c2-t34">Data Type</th>
<th class="cellalignment1227" id="r1c3-t34">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t34" headers="r1c1-t34">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t34 r1c2-t34">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t34 r1c3-t34">
<p>Name of a column of <code>NUMBER</code>, <code>FLOAT</code>, or <code>DM_NESTED_NUMERICALS</code> in the data to be mined.</p>
<p>If the column is <code>NUMBER</code> or <code>FLOAT</code>, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t34" headers="r1c1-t34">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t34 r1c2-t34">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t34 r1c3-t34">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is a nested column of <code>DM_NESTED_NUMERICALS</code>. If <code><span class="codeinlineitalic">col</span></code> is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t34" headers="r1c1-t34">
<p><code>val</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t34 r1c2-t34">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t34 r1c3-t34">
<p>Replacement for missing values in the attribute</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2658"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM (
     miss_table_name       IN VARCHAR2,
     miss_schema_name      IN VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2659"></a>Parameters</p>
<div id="ARPLS73020" class="tblformal">
<p class="titleintable"><a id="sthref2660"></a><a id="sthref2661"></a>Table 45-15 CREATE_MISS_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_MISS_NUM Procedure Parameters" summary="Parameters of the DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM procedure." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t35">Parameter</th>
<th class="cellalignment1227" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t35" headers="r1c1-t35">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t35 r1c2-t35">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t35" headers="r1c1-t35">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t35 r1c2-t35">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2662"></a>Usage Notes</p>
<p>You can use the <a href="#BABHAHEJ">INSERT_MISS_NUM_MEAN Procedure</a> to populate the transformation definition table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#CACDGBDI">"Missing Value Treatment"</a></p>
<p><a href="#BABDIIIC">"Operational Notes"</a></p>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2663"></a>Example</p>
<p>The following statement creates a table called <code>miss_num_xtbl</code> in the current schema. The table has columns that can be populated with values for missing data in numerical attributes.</p>
<pre>
BEGIN
    DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM('miss_num_xtbl');
END;
/
 
DESCRIBE miss_num_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
 VAL                                                NUMBER
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73021" class="refsect2"><a id="BABGBDGB"></a>
<hr />
<h3 class="refsect2"><a id="sthref2664"></a>CREATE_NORM_LIN Procedure</h3>
<p>This procedure creates a transformation definition table for linear normalization. The columns are described in <a href="#BABHBHHD">Table 45-16</a>.</p>
<div id="ARPLS73022" class="tblformal">
<p class="titleintable"><a id="sthref2665"></a><a id="BABHBHHD"></a>Table 45-16 Columns in a Transformation Definition Table for Linear Normalization</p>
<table class="cellalignment1229" title="Columns in a Transformation Definition Table for Linear Normalization" summary="This table describes the columns in a transformation definition table for linear normalization" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t37">Name</th>
<th class="cellalignment1227" id="r1c2-t37">Data Type</th>
<th class="cellalignment1227" id="r1c3-t37">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t37" headers="r1c1-t37">
<p><code>col</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t37 r1c2-t37">
<p><code>VARCHAR2(30)</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t37 r1c3-t37">
<p>Name of a column of <code>NUMBER</code>, <code>FLOAT</code>, or <code>DM_NESTED_NUMERICALS</code> in the data to be mined.</p>
<p>If the column is <code>NUMBER</code> or <code>FLOAT</code>, the column name is also the attribute name.</p>
<p>For information about attribute names, see <a class="olink DMPRG010" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG010"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a>. Refer especially to the section, "Scoping of Model Attribute Name".</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t37" headers="r1c1-t37">
<p><code>att</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t37 r1c2-t37">
<p><code>VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t37 r1c3-t37">
<p>The attribute subname if <code><span class="codeinlineitalic">col</span></code> is a nested column of <code>DM_NESTED_NUMERICALS</code>. If <code><span class="codeinlineitalic">col</span></code> is nested, the attribute name is <code><span class="codeinlineitalic">col.att</span></code>.</p>
<p>If <code><span class="codeinlineitalic">col</span></code> is not nested, <code><span class="codeinlineitalic">att</span></code> is null.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t37" headers="r1c1-t37">
<p><code>shift</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t37 r1c2-t37">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t37 r1c3-t37">
<p>A constant to subtract from the attribute values</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t37" headers="r1c1-t37">
<p><code>scale</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t37 r1c2-t37">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t37 r1c3-t37">
<p>A constant by which to divide the shifted values</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2666"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN (
     norm_table_name       IN VARCHAR2,
     norm_schema_name      IN VARCHAR2 DEFAULT NULL );
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2667"></a>Parameters</p>
<div id="ARPLS73023" class="tblformal">
<p class="titleintable"><a id="sthref2668"></a><a id="sthref2669"></a>Table 45-17 CREATE_NORM_LIN Procedure Parameters</p>
<table class="cellalignment1229" title="CREATE_NORM_LIN Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.CREATE_NORMALIZE_LIN." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t38">Parameter</th>
<th class="cellalignment1227" id="r1c2-t38">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t38" headers="r1c1-t38">
<p><code>norm_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t38 r1c2-t38">
<p>Name of the transformation definition table to be created</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t38" headers="r1c1-t38">
<p><code>norm_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t38 r1c2-t38">
<p>Schema of <code><span class="codeinlineitalic">norm_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2670"></a>Usage Notes</p>
<p>You can use the following procedures to populate the transformation definition table:</p>
<ul>
<li>
<p><a href="#BABDFACD">INSERT_NORM_LIN_MINMAX Procedure</a> &mdash; Uses linear min-max normalization</p>
</li>
<li>
<p><a href="#BABHAFJC">INSERT_NORM_LIN_SCALE Procedure</a> &mdash; Uses linear scale normalization</p>
</li>
<li>
<p><a href="#BABDCGGH">INSERT_NORM_LIN_ZSCORE Procedure</a> &mdash; Uses linear zscore normalization</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#BABCAFDD">"Linear Normalization"</a></p>
<p><a href="#BABDIIIC">"Operational Notes"</a></p>
</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2671"></a>Examples</p>
<p>The following statement creates a table called <code>norm_xtbl</code> in the current schema. The table has columns that can be populated with shift and scale values for normalizing numerical attributes.</p>
<pre>
BEGIN
     DBMS_DATA_MINING_TRANSFORM.CREATE_NORM_LIN('norm_xtbl');
END;
/
 
DESCRIBE norm_xtbl
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 COL                                                VARCHAR2(30)
 ATT                                                VARCHAR2(4000)
 SHIFT                                              NUMBER
 SCALE                                              NUMBER
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73024" class="refsect2"><a id="BABIIFEF"></a>
<hr />
<h3 class="refsect2"><a id="sthref2672"></a>DESCRIBE_STACK Procedure</h3>
<p>This procedure describes the columns of the data table after a list of transformations has been applied.Only the columns that are specified in the transformation list are transformed. The remaining columns in the data table are included in the output without changes.</p>
<p>To create a view of the data table after the transformations have been applied, use the <a href="#BABIHDCC">XFORM_STACK Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2673"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.DESCRIBE_STACK (
     xform_list           IN  TRANSFORM_LIST,
     data_table_name      IN  VARCHAR2,
     describe_list        OUT DESCRIBE_LIST,
     data_schema_name     IN  VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2674"></a>Parameters</p>
<div id="ARPLS73025" class="tblformal">
<p class="titleintable"><a id="sthref2675"></a><a id="sthref2676"></a>Table 45-18 DESCRIBE_STACK Procedure Parameters</p>
<table class="cellalignment1229" title="DESCRIBE_STACK Procedure Parameters" summary="Describes the parameters for the DESCRIBE_STACK procedure" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t40">Parameter</th>
<th class="cellalignment1227" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t40" headers="r1c1-t40">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t40 r1c2-t40">
<p>A list of transformations. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t40" headers="r1c1-t40">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t40 r1c2-t40">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t40" headers="r1c1-t40">
<p><code>describe_list</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t40 r1c2-t40">
<p>Descriptions of the columns in the data table after the transformations specified in <code><span class="codeinlineitalic">xform_list</span></code> have been applied. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>DESCRIBE_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t40" headers="r1c1-t40">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t40 r1c2-t40">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2677"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a> for information about transformation lists and embedded transformations.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2678"></a>Examples</p>
<p>This example shows the column name and data type, the column name length, and the column maximum length for the view <code>dmuser.cust_info</code> after the transformation list has been applied. All the transformations are user-specified. The results of <code>DESCRIBE_STACK</code> do not include one of the columns in the original table, because the <code>SET_TRANSFORM</code> procedure sets that column to <code>NULL</code>.</p>
<pre>
CREATE OR REPLACE VIEW cust_info AS
         SELECT a.cust_id, c.country_id, c.cust_year_of_birth,
         CAST(COLLECT(DM_Nested_Numerical(
                  b.prod_name, 1))
                AS DM_Nested_Numericals) custprods
                 FROM sh.sales a, sh.products b, sh.customers c
                  WHERE a.prod_id = b.prod_id AND
                        a.cust_id=c.cust_id and
                        a.cust_id between 100001 AND 105000
         GROUP BY a.cust_id, country_id, cust_year_of_birth;
 
describe cust_info
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 CUST_ID                                   NOT NULL NUMBER
 COUNTRY_ID                                NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                        NOT NULL NUMBER(4)
 CUSTPRODS                                          SYS.DM_NESTED_NUMERICALS
 
DECLARE
  cust_stack   dbms_data_mining_transform.TRANSFORM_LIST;
  cust_cols    dbms_data_mining_transform.DESCRIBE_LIST;
BEGIN
  dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
     'country_id', NULL, 'country_id/10', 'country_id*10');
  dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
      'cust_year_of_birth', NULL, NULL, NULL);
  dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
      'custprods', 'Mouse Pad', 'value*100', 'value/100');
  <span class="bold">dbms_data_mining_transform.DESCRIBE_STACK</span>(
       xform_list =&gt; cust_stack,
       data_table_name =&gt; 'cust_info',
       describe_list =&gt; cust_cols);
  dbms_output.put_line('====');
  for i in 1..cust_cols.COUNT loop
    dbms_output.put_line('COLUMN_NAME:     '||cust_cols(i).col_name);
    dbms_output.put_line('COLUMN_TYPE:     '||cust_cols(i).col_type);
    dbms_output.put_line('COLUMN_NAME_LEN: '||cust_cols(i).col_name_len);
    dbms_output.put_line('COLUMN_MAX_LEN:  '||cust_cols(i).col_max_len);
    dbms_output.put_line('====');
  END loop;
END;
/
====
COLUMN_NAME:     CUST_ID
COLUMN_TYPE:     2
COLUMN_NAME_LEN: 7
COLUMN_MAX_LEN:  22
====
COLUMN_NAME:     COUNTRY_ID
COLUMN_TYPE:     2
COLUMN_NAME_LEN: 10
COLUMN_MAX_LEN:  22
====
COLUMN_NAME:     CUSTPRODS
COLUMN_TYPE:     100001
COLUMN_NAME_LEN: 9
COLUMN_MAX_LEN:  40
====
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73026" class="refsect2"><a id="BABGDGIA"></a>
<hr />
<h3 class="refsect2"><a id="sthref2679"></a> GET_EXPRESSION Function</h3>
<p>This function returns a row from a <code>VARCHAR2</code> array that stores a transformation expression. The array is built by calls to the <a href="#CACJDFJC">SET_EXPRESSION Procedure</a>.</p>
<p>The array can be used for specifying SQL expressions that are too long to be used with the <a href="#BABJIIIE">SET_TRANSFORM Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2680"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.GET_EXPRESSION (
     expression           IN EXPRESSION_REC,
     chunk_num            IN PLS_INTEGER DEFAULT NULL);
 RETURN VARCHAR2;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2681"></a>Parameters</p>
<div id="ARPLS73027" class="tblformal">
<p class="titleintable"><a id="sthref2682"></a><a id="sthref2683"></a>Table 45-19 GET_EXPRESSION Function Parameters</p>
<table class="cellalignment1229" title=" GET_EXPRESSION Function Parameters" summary="Describes the parameters for the GET_EXPRESSION function" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t41">Parameter</th>
<th class="cellalignment1227" id="r1c2-t41">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t41" headers="r1c1-t41">
<p><code>expression</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t41 r1c2-t41">
<p>An expression record (<code>EXPRESSION_REC</code>) that specifies a transformation expression or a reverse transformation expression for an attribute. Each expression record includes a <code>VARCHAR2</code> array and index fields for specifying upper and lower boundaries within the array.</p>
<p>There are two <code>EXPRESSION_REC</code> fields within a transformation record (<code>TRANSFORM_REC</code>): one for the transformation expression; the other for the reverse transformation expression.</p>
<p>See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>EXPRESSION_REC</code> type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t41" headers="r1c1-t41">
<p><code>chunk</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t41 r1c2-t41">
<p>A <code>VARCHAR2</code> chunk (row) to be appended to <code><span class="codeinlineitalic">expression</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2684"></a>Usage Notes</p>
<ol>
<li>
<p>Chunk numbering starts with one. For chunks outside of the range, the return value is null. When a chunk number is null the whole expression is returned as a string. If the expression is too big, a <code>VALUE_ERROR</code> is raised.</p>
</li>
<li>
<p>See <a href="#CACHEGJD">"About Transformation Lists"</a>.</p>
</li>
<li>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2685"></a>Examples</p>
<p>See the example for the <a href="#CACJDFJC">SET_EXPRESSION Procedure</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73028" class="refsect2"><a id="BABJDGIA"></a>
<hr />
<h3 class="refsect2"><a id="sthref2686"></a>INSERT_AUTOBIN_NUM_EQWIDTH Procedure</h3>
<p>This procedure performs numerical binning and inserts the transformation definitions in a transformation definition table. The procedure identifies the minimum and maximum values and computes the bin boundaries at equal intervals.</p>
<p><code>INSERT_AUTOBIN_NUM_EQWIDTH</code> computes the number of bins separately for each column. If you want to use equi-width binning with the same number of bins for each column, use the <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a>.</p>
<p><code>INSERT_AUTOBIN_NUM_EQWIDTH</code> bins all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2687"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_AUTOBIN_NUM_EQWIDTH (
     bin_table_name        IN VARCHAR2,
     data_table_name       IN VARCHAR2,
     bin_num               IN PLS_INTEGER DEFAULT 3,
     max_bin_num           IN PLS_INTEGER DEFAULT 100,
     exclude_list          IN COLUMN_LIST DEFAULT NULL,
     round_num             IN PLS_INTEGER DEFAULT 6,
     sample_size           IN PLS_INTEGER DEFAULT 50000,
     bin_schema_name       IN VARCHAR2 DEFAULT NULL,
     data_schema_name      IN VARCHAR2 DEFAULT NULL,
     rem_table_name        IN VARCHAR2 DEFAULT NULL,
     rem_schema_name       IN VARCHAR2 DEFAULT NULL));
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2688"></a>Parameters</p>
<div id="ARPLS73029" class="tblformal">
<p class="titleintable"><a id="sthref2689"></a><a id="sthref2690"></a>Table 45-20 INSERT_AUTOBIN_NUM_EQWIDTH Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_AUTOBIN_NUM_EQWIDTH Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_AUTOBIN_EQWIDTH." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t42">Parameter</th>
<th class="cellalignment1227" id="r1c2-t42">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t42" headers="r1c1-t42">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t42 r1c2-t42">
<p>Name of the transformation definition table for numerical binning. You can use the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
COL       VARCHAR2(30)
VAL       NUMBER
BIN       VARCHAR2(4000)
</pre>
<p><code>CREATE_BIN_NUM</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_AUTOBIN_NUM_EQWIDTH</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t42" headers="r1c1-t42">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t42 r1c2-t42">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t42" headers="r1c1-t42">
<p><code>bin_num</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t42 r1c2-t42">
<p>Minimum number of bins. If <code><span class="codeinlineitalic">bin_num</span></code> is 0 or <code>NULL</code>, it is ignored.</p>
<p>The default value of <code><span class="codeinlineitalic">bin_num</span></code> is 3.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t42" headers="r1c1-t42">
<p><code>max_bin_num</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t42 r1c2-t42">
<p>Maximum number of bins. If <code><span class="codeinlineitalic">max_bin_num</span></code> is 0 or <code>NULL</code>, it is ignored.</p>
<p>The default value of <code><span class="codeinlineitalic">max_bin_num</span></code> is 100.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t42" headers="r1c1-t42">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t42 r1c2-t42">
<p>List of numeric columns to be excluded from the binning process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all numeric columns in the data source are binned.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                              ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t42" headers="r1c1-t42">
<p><code>round_num</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t42 r1c2-t42">
<p>Specifies how to round the number in the <code>VAL</code> column of the transformation definition table.</p>
<p>When <code><span class="codeinlineitalic">round_num</span></code> is positive, it specifies the most significant digits to retain. When <code><span class="codeinlineitalic">round_num</span></code> is negative, it specifies the least significant digits to remove. In both cases, the result is rounded to the specified number of digits. See the Usage Notes for an example.</p>
<p>The default value of <code><span class="codeinlineitalic">round_num</span></code> is 6.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t42" headers="r1c1-t42">
<p><code>sample_size</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t42 r1c2-t42">
<p>Size of the data sample. If <code><span class="codeinlineitalic">sample_size</span></code> is less than the total number of non-<code>NULL</code> values in the column, then <code><span class="codeinlineitalic">sample_size</span></code> is used instead of the SQL <code>COUNT</code> function in computing the number of bins. If <code><span class="codeinlineitalic">sample_size</span></code> is 0 or <code>NULL</code>, it is ignored. See the Usage Notes.</p>
<p>The default value of <code><span class="codeinlineitalic">sample_size</span></code> is 50,000.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t42" headers="r1c1-t42">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t42 r1c2-t42">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t42" headers="r1c1-t42">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r10c1-t42 r1c2-t42">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t42" headers="r1c1-t42">
<p><code>rem_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r11c1-t42 r1c2-t42">
<p>Name of a transformation definition table for column removal. The table must have the columns described in <a href="#BABGCDCC">"CREATE_COL_REM Procedure"</a>.</p>
<p><code>INSERT_AUTOBIN_NUM_EQWIDTH</code> ignores columns with all nulls or only one unique value. If you specify a value for <code><span class="codeinlineitalic">rem_table_name</span></code>, these columns are removed from the mining data. If you do not specify a value for <code><span class="codeinlineitalic">rem_table_name</span></code>, these unbinned columns remain in the data.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t42" headers="r1c1-t42">
<p><code>rem_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r12c1-t42 r1c2-t42">
<p>Schema of <code><span class="codeinlineitalic">rem_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2691"></a>Usage Notes</p>
<ol>
<li>
<p><code>INSERT_AUTOBIN_NUM_EQWIDTH</code> computes the number of bins for a column based on the number of non-null values (<code>COUNT</code>), the maximum (<code>MAX</code>), the minimum (<code>MIN</code>), the standard deviation (<code>STDDEV</code>), and the constant C=3.49/0.9:</p>
<pre>
N=floor(power(COUNT,1/3)*(max-min)/(c*dev))
</pre>
<p>If the <code><span class="codeinlineitalic">sample_size</span></code> parameter is specified, it is used instead of <code>COUNT</code>.</p>
<p>See <a class="olink SQLRF006" href="../../server.112/e41084/functions.htm#SQLRF006"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code>COUNT</code>, <code>MAX</code>, <code>MIN</code>, <code>STDDEV</code>, <code>FLOOR</code>, and <code>POWER</code> functions.</p>
</li>
<li>
<p><code>INSERT_AUTOBIN_NUM_EQWIDTH</code> uses absolute values to compute the number of bins. The sign of the parameters <code><span class="codeinlineitalic">bin_num</span></code>, <code><span class="codeinlineitalic">max_bin_num</span></code>, and <code><span class="codeinlineitalic">sample_size</span></code> has no effect on the result.</p>
</li>
<li>
<p>In computing the number of bins, <code>INSERT_AUTOBIN_NUM_EQWIDTH</code> evaluates the following criteria in the following order:</p>
<ol>
<li>
<p>The minimum number of bins (<code><span class="codeinlineitalic">bin_num</span></code>)</p>
</li>
<li>
<p>The maximum number of bins (<code><span class="codeinlineitalic">max_bin_num</span></code>)</p>
</li>
<li>
<p>The maximum number of bins for integer columns, calculated as the number of distinct values in the range <code><span class="codeinlineitalic">max-min+1</span></code>.</p>
</li>
</ol>
</li>
<li>
<p>The <code><span class="codeinlineitalic">round_num</span></code> parameter controls the rounding of column values in the transformation definition table, as follows:</p>
<pre>
<span class="bold">For a value of 308.162:</span>
when round_num =  1       result is 300
when round_num =  2       result is 310
when round_num =  3       result is 308
when round_num =  0       result is 308.162
when round_num = -1       result is 308.16
when round_num = -2       result is 308.2
</pre></li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2692"></a>Examples</p>
<p>In this example, <code>INSERT_AUTOBIN_NUM_EQWIDTH</code> computes the bin boundaries for the <code>cust_year_of_birth</code> column in <code>sh.customers</code> and inserts the transformations in a transformation definition table. The <a href="#CACEGEHI">STACK_BIN_NUM Procedure</a> creates a transformation list from the contents of the definition table. The <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a> embeds the transformation list in a new model called <code>nb_model</code>.</p>
<p>The transformation and reverse transformation expressions embedded in <code>nb_model</code> are returned by the <a href="d_datmin.htm#CACJDBCE">GET_MODEL_TRANSFORMATIONS Function</a>.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, cust_year_of_birth, cust_postal_code
       FROM sh.customers;
 
DESCRIBE mining_data
 Name                          Null?    Type
 ----------------------------- -------- ----------------------------
 CUST_ID                       NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH            NOT NULL NUMBER(4)
 CUST_POSTAL_CODE              NOT NULL VARCHAR2(10)
 
BEGIN
  dbms_data_mining_transform.CREATE_BIN_NUM(
     bin_table_name   =&gt; 'bin_tbl');
  dbms_data_mining_transform.INSERT_AUTOBIN_NUM_EQWIDTH (
     bin_table_name   =&gt; 'bin_tbl',
     data_table_name  =&gt; 'mining_data',
     bin_num          =&gt; 3,
     max_bin_num      =&gt; 5,
     exclude_list     =&gt; dbms_data_mining_transform.COLUMN_LIST('cust_id'));
END;
/

set numwidth 4
column val off
SELECT col, val, bin FROM bin_tbl
      ORDER BY val ASC;
 
COL                        VAL BIN
------------------------- ---- -----
CUST_YEAR_OF_BIRTH        1913
CUST_YEAR_OF_BIRTH        1928 1
CUST_YEAR_OF_BIRTH        1944 2
CUST_YEAR_OF_BIRTH        1959 3
CUST_YEAR_OF_BIRTH        1975 4
CUST_YEAR_OF_BIRTH        1990 5

DECLARE
     year_birth_xform   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
     dbms_data_mining_transform.STACK_BIN_NUM (
         bin_table_name           =&gt; 'bin_tbl',
         xform_list               =&gt;  year_birth_xform);
     dbms_data_mining.CREATE_MODEL(
         model_name              =&gt; 'nb_model',
         mining_function         =&gt; dbms_data_mining.classification,
         data_table_name         =&gt; 'mining_data',
         case_id_column_name     =&gt; 'cust_id',
         target_column_name      =&gt; 'cust_postal_code',
         settings_table_name     =&gt; null,
         data_schema_name        =&gt; null,
         settings_schema_name    =&gt; null,
         xform_list              =&gt; year_birth_xform);
END;
/
 
SELECT attribute_name 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('nb_model'));
 
ATTRIBUTE_NAME
------------------------
CUST_YEAR_OF_BIRTH
 
SELECT expression 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('nb_model'));
 
EXPRESSION
--------------------------------------------------------------------------------
CASE WHEN "CUST_YEAR_OF_BIRTH"&lt;1913 THEN NULL WHEN "CUST_YEAR_OF_BIRTH"&lt;=1928.4
 THEN '1' WHEN "CUST_YEAR_OF_BIRTH"&lt;=1943.8 THEN '2' WHEN "CUST_YEAR_OF_BIRTH"
&lt;=1959.2 THEN '3' WHEN "CUST_YEAR_OF_BIRTH"&lt;=1974.6 THEN '4' WHEN
"CUST_YEAR_OF_BIRTH" &lt;=1990 THEN '5' END
 
SELECT reverse_expression 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('nb_model'));
 
REVERSE_EXPRESSION
--------------------------------------------------------------------------------
DECODE("CUST_YEAR_OF_BIRTH",'5','(1974.6; 1990]','1','[1913; 1928.4]','2','(1928
.4; 1943.8]','3','(1943.8; 1959.2]','4','(1959.2; 1974.6]',NULL,'( ; 1913), (199
0;  ), NULL')
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73030" class="refsect2"><a id="BABCIBEH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2693"></a>INSERT_BIN_CAT_FREQ Procedure</h3>
<p>This procedure performs categorical binning and inserts the transformation definitions in a transformation definition table. The procedure computes the bin boundaries based on frequency.</p>
<p><code>INSERT_BIN_CAT_FREQ</code> bins all the <code>CHAR</code> and <code>VARCHAR2</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2694"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_CAT_FREQ (
     bin_table_name       IN VARCHAR2,
     data_table_name      IN VARCHAR2,
     bin_num              IN PLS_INTEGER DEFAULT 9,
     exclude_list         IN COLUMN_LIST DEFAULT NULL,
     default_num          IN PLS_INTEGER DEFAULT 2,
     bin_support          IN NUMBER DEFAULT NULL,
     bin_schema_name      IN VARCHAR2 DEFAULT NULL,
     data_schema_name     IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2695"></a>Parameters</p>
<div id="ARPLS73031" class="tblformal">
<p class="titleintable"><a id="sthref2696"></a><a id="sthref2697"></a>Table 45-21 INSERT_BIN_CAT_FREQ Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_BIN_CAT_FREQ Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_CAT_FREQ." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t43">Parameter</th>
<th class="cellalignment1227" id="r1c2-t43">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t43" headers="r1c1-t43">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t43 r1c2-t43">
<p>Name of the transformation definition table for categorical binning. You can use the <a href="#BABHJHJF">CREATE_BIN_CAT Procedure</a> to create the definition table.The following columns are required:</p>
<pre>
COL       VARCHAR2(30)
VAL       VARCHAR2(4000)
BIN       VARCHAR2(4000)
</pre>
<p><code>CREATE_BIN_CAT</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_BIN_CAT_FREQ</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t43" headers="r1c1-t43">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t43 r1c2-t43">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t43" headers="r1c1-t43">
<p><code>bin_num</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t43 r1c2-t43">
<p>The number of bins to fill using frequency-based binning The total number of bins will be <code><span class="codeinlineitalic">bin_num</span></code>+1. The additional bin is the default bin. Classes that are not assigned to a frequency-based bin will be assigned to the default bin.</p>
<p>The default binning order is from highest to lowest: the most frequently occurring class is assigned to the first bin, the second most frequently occurring class is assigned to the second bin, and so on.You can reverse the binning order by specifying a negative number for <code><span class="codeinlineitalic">bin_num</span></code>. The negative sign causes the binning order to be from lowest to highest.</p>
<p>If the total number of distinct values (classes) in the column is less than <code><span class="codeinlineitalic">bin_num</span></code>, then a separate bin will be created for each value and the default bin will be empty.</p>
<p>If you specify <code>NULL</code> or <code>0</code> for <code><span class="codeinlineitalic">bin_num</span></code>, no binning is performed.</p>
<p>The default value of <code><span class="codeinlineitalic">bin_num</span></code> is 9.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t43" headers="r1c1-t43">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t43 r1c2-t43">
<p>List of <code>CHAR</code> and <code>VARCHAR2</code> columns to be excluded from the binning process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>CHAR</code> and <code>VARCHAR2</code> columns in the data source are binned.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t43" headers="r1c1-t43">
<p><code>default_num</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t43 r1c2-t43">
<p>The number of class occurrences (rows of the same class) required for assignment to the default bin</p>
<p>By default, <code><span class="codeinlineitalic">default_num</span></code> is the minimum number of occurrences required for assignment to the default bin. For example, if <code><span class="codeinlineitalic">default_num</span></code> is 3 and a given class occurs only once, it will not be assigned to the default bin. You can change the occurrence requirement from minimum to maximum by specifying a negative number for <code><span class="codeinlineitalic">default_num</span></code>. For example, if <code><span class="codeinlineitalic">default_num</span></code> is -3 and a given class occurs only once, it <span class="italic">will</span> be assigned to the default bin, but a class that occurs four or more times will not be included.</p>
<p>If you specify <code>NULL</code> or <code>0</code> for <code><span class="codeinlineitalic">default_bin</span></code>, there are no requirements for assignment to the default bin.</p>
<p>The default value of <code><span class="codeinlineitalic">default_num</span></code> is 2.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t43" headers="r1c1-t43">
<p><code>bin_support</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t43 r1c2-t43">
<p>The number of class occurrences (rows of the same class) required for assignment to a frequency-based bin. <code><span class="codeinlineitalic">bin_support</span></code> is expressed as a fraction of the total number of rows.</p>
<p>By default, <code><span class="codeinlineitalic">bin_support</span></code> is the minimum percentage required for assignment to a frequency-based bin. For example, if there are twenty rows of data and you specify.2 for <code><span class="codeinlineitalic">bin_support</span></code>, then there must be four or more occurrences of a class (.2*20) in order for it to be assigned to a frequency-based bin. You can change <code><span class="codeinlineitalic">bin_support</span></code> from a minimum percentage to a maximum percentage by specifying a negative number for <code><span class="codeinlineitalic">bin_support</span></code>. For example, if there are twenty rows of data and you specify -.2 for <code><span class="codeinlineitalic">bin_support</span></code>, then there must be four or less occurrences of a class in order for it to be assigned to a frequency-based bin.</p>
<p>Classes that occur less than a positive <code><span class="codeinlineitalic">bin_support</span></code> or more than a negative <code><span class="codeinlineitalic">bin_support</span></code> will be assigned to the default bin.</p>
<p>If you specify <code>NULL</code> or <code>0</code> for <code><span class="codeinlineitalic">bin_support</span></code>, then there is no support requirement for frequency-based binning.</p>
<p>The default value of <code><span class="codeinlineitalic">bin_support</span></code> is <code>NULL</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t43" headers="r1c1-t43">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t43 r1c2-t43">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t43" headers="r1c1-t43">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t43 r1c2-t43">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2698"></a>Usage Notes</p>
<p>If values occur with the same frequency, <code>INSERT_BIN_CAT_FREQ</code> assigns them in descending order when binning is from most to least frequent, or in ascending order when binning is from least to most frequent.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2699"></a>Examples</p>
<ol>
<li id="CACCEDGF">
<p>In this example, <code>INSERT_BIN_CAT_FREQ</code> computes the bin boundaries for the <code>cust_postal_code</code> and <code>cust_city</code> columns in <code>sh.customers</code> and inserts the transformations in a transformation definition table. The <a href="#CACJCHHI">STACK_BIN_CAT Procedure</a> creates a transformation list from the contents of the definition table, and the <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a> embeds the transformation list in a new model called <code>nb_model</code>.</p>
<p>The transformation and reverse transformation expressions embedded in <code>nb_model</code> are returned by the <a href="d_datmin.htm#CACJDBCE">GET_MODEL_TRANSFORMATIONS Function</a>.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
          SELECT cust_id, cust_year_of_birth, cust_postal_code, cust_city
          FROM sh.customers;
 
DESCRIBE mining_data
 Name                                  Null?    Type
 ------------------------------------- -------- -----------------------------
 CUST_ID                               NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                    NOT NULL NUMBER(4)
 CUST_POSTAL_CODE                      NOT NULL VARCHAR2(10)
 CUST_CITY                             NOT NULL VARCHAR2(30)
 
BEGIN
    dbms_data_mining_transform.CREATE_BIN_CAT(
       bin_table_name   =&gt; 'bin_tbl_1');
    dbms_data_mining_transform.INSERT_BIN_CAT_FREQ (
       bin_table_name   =&gt; 'bin_tbl_1',
       data_table_name  =&gt; 'mining_data',
       bin_num          =&gt; 4);
END;
/
 
column col format a18
column val format a15
column bin format a10
SELECT col, val, bin 
       FROM bin_tbl_1
       ORDER BY col ASC, bin ASC;
 
COL                VAL             BIN
------------------ --------------- ----------
CUST_CITY          Los Angeles     1
CUST_CITY          Greenwich       2
CUST_CITY          Killarney       3
CUST_CITY          Montara         4
CUST_CITY                          5
CUST_POSTAL_CODE   38082           1
CUST_POSTAL_CODE   63736           2
CUST_POSTAL_CODE   55787           3
CUST_POSTAL_CODE   78558           4
CUST_POSTAL_CODE                   5
 
DECLARE
      city_xform   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
      dbms_data_mining_transform.STACK_BIN_CAT (
          bin_table_name           =&gt; 'bin_tbl_1',
          xform_list               =&gt;  city_xform);
      dbms_data_mining.CREATE_MODEL(
           model_name              =&gt; 'nb_model',
           mining_function         =&gt; dbms_data_mining.classification,
           data_table_name         =&gt; 'mining_data',
           case_id_column_name     =&gt; 'cust_id',
           target_column_name      =&gt; 'cust_city',
           settings_table_name     =&gt; null,
           data_schema_name        =&gt; null,
           settings_schema_name    =&gt; null,
           xform_list              =&gt; city_xform);
END;
/
 
SELECT attribute_name 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('nb_model'));
 
ATTRIBUTE_NAME
-----------------------------------------------------------------------------
CUST_CITY
CUST_POSTAL_CODE
 
SELECT expression 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('nb_model'));
 
EXPRESSION
-----------------------------------------------------------------------------
DECODE("CUST_CITY",'Greenwich','2','Killarney','3','Los Angeles','1',
'Montara','4',NULL,NULL,'5')
DECODE("CUST_POSTAL_CODE",'38082','1','55787','3','63736','2','78558','4',NULL,NULL,'5')

SELECT reverse_expression 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('nb_model'));

REVERSE_EXPRESSION
-----------------------------------------------------------------------------
DECODE("CUST_CITY",'2','''Greenwich''','3','''Killarney''','1',
'''Los Angeles''','4','''Montara''',NULL,'NULL','5','DEFAULT')
DECODE("CUST_POSTAL_CODE",'1','''38082''','3','''55787''','2','''63736''',
'4','''78558''',NULL,'NULL','5','DEFAULT')
</pre></li>
<li>
<p>The binning order in example <a href="#CACCEDGF">1</a> is from most frequent to least frequent. The following example shows reverse order binning (least frequent to most frequent). The binning order is reversed by setting <code><span class="codeinlineitalic">bin_num</span></code> to -4 instead of 4.</p>
<pre>
BEGIN
    dbms_data_mining_transform.CREATE_BIN_CAT(
        bin_table_name   =&gt; 'bin_tbl_reverse');
    dbms_data_mining_transform.INSERT_BIN_CAT_FREQ (
        bin_table_name   =&gt; 'bin_tbl_reverse',
        data_table_name  =&gt; 'mining_data',
        bin_num          =&gt; -4);
 END;
 /
 
column col format a20
SELECT col, val, bin 
       FROM bin_tbl_reverse
       ORDER BY col ASC, bin ASC;
 
COL                  VAL             BIN
-------------------- --------------- ----------
CUST_CITY            Tokyo           1
CUST_CITY            Sliedrecht      2
CUST_CITY            Haarlem         3
CUST_CITY            Diemen          4
CUST_CITY                            5
CUST_POSTAL_CODE     49358           1
CUST_POSTAL_CODE     80563           2
CUST_POSTAL_CODE     74903           3
CUST_POSTAL_CODE     71349           4
CUST_POSTAL_CODE                     5
</pre></li>
</ol>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73032" class="refsect2"><a id="BABEFAIC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2700"></a>INSERT_BIN_NUM_EQWIDTH Procedure</h3>
<p>This procedure performs numerical binning and inserts the transformation definitions in a transformation definition table. The procedure identifies the minimum and maximum values and computes the bin boundaries at equal intervals.</p>
<p><code>INSERT_BIN_NUM_EQWIDTH</code> computes a specified number of bins (<code><span class="codeinlineitalic">n</span></code>) and assigns <code><span class="codeinlineitalic">(max-min)/n</span></code> values to each bin. The number of bins is the same for each column. If you want to use equi-width binning, but you want the number of bins to be calculated on a per-column basis, use the <a href="#BABJDGIA">INSERT_AUTOBIN_NUM_EQWIDTH Procedure</a>.</p>
<p><code>INSERT_BIN_NUM_EQWIDTH</code> bins all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2701"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_NUM_EQWIDTH (
     bin_table_name        IN VARCHAR2,
     data_table_name       IN VARCHAR2,
     bin_num               IN PLS_INTEGER DEFAULT 10,
     exclude_list          IN COLUMN_LIST DEFAULT NULL,
     round_num             IN PLS_INTEGER DEFAULT 6,
     bin_schema_name       IN VARCHAR2 DEFAULT NULL,
     data_schema_name      IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2702"></a>Parameters</p>
<div id="ARPLS73033" class="tblformal">
<p class="titleintable"><a id="sthref2703"></a><a id="sthref2704"></a>Table 45-22 INSERT_BIN_NUM_EQWIDTH Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_BIN_NUM_EQWIDTH Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_EQWIDTH." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t44">Parameter</th>
<th class="cellalignment1227" id="r1c2-t44">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t44" headers="r1c1-t44">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t44 r1c2-t44">
<p>Name of the transformation definition table for numerical binning. You can use the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
COL       VARCHAR2(30)
VAL       NUMBER
BIN       VARCHAR2(4000)
</pre>
<p><code>CREATE_BIN_NUM</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_BIN_NUM_EQWIDTH</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t44" headers="r1c1-t44">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t44 r1c2-t44">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t44" headers="r1c1-t44">
<p><code>bin_num</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t44 r1c2-t44">
<p>Number of bins. No binning occurs if <code><span class="codeinlineitalic">bin_num</span></code> is <code>0</code> or <code>NULL</code>.</p>
<p>The default number of bins is 10.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t44" headers="r1c1-t44">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t44 r1c2-t44">
<p>List of numeric columns to be excluded from the binning process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all numeric columns in the data source are binned.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t44" headers="r1c1-t44">
<p><code>round_num</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t44 r1c2-t44">
<p>Specifies how to round the number in the <code>VAL</code> column of the transformation definition table.</p>
<p>When <code><span class="codeinlineitalic">round_num</span></code> is positive, it specifies the most significant digits to retain. When <code><span class="codeinlineitalic">round_num</span></code> is negative, it specifies the least significant digits to remove. In both cases, the result is rounded to the specified number of digits. See the Usage Notes for an example.</p>
<p>The default value of <code><span class="codeinlineitalic">round_num</span></code> is 6.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t44" headers="r1c1-t44">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t44 r1c2-t44">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t44" headers="r1c1-t44">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t44 r1c2-t44">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2705"></a>Usage Notes</p>
<ol>
<li>
<p>The <code><span class="codeinlineitalic">round_num</span></code> parameter controls the rounding of column values in the transformation definition table, as follows:</p>
<pre>
<span class="bold">For a value of 308.162:</span>
when round_num =  1       result is 300
when round_num =  2       result is 310
when round_num =  3       result is 308
when round_num =  0       result is 308.162
when round_num = -1       result is 308.16
when round_num = -2       result is 308.2
</pre></li>
<li>
<p><code>INSERT_BIN_NUM_EQWIDTH</code> ignores columns with all <code>NULL</code> values or only one unique value.</p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2706"></a>Examples</p>
<p>In this example, <code>INSERT_BIN_NUM_EQWIDTH</code> computes the bin boundaries for the <code>affinity_card</code> column in <code>mining_data_build</code> and inserts the transformations in a transformation definition table. The <a href="#CACEGEHI">STACK_BIN_NUM Procedure</a> creates a transformation list from the contents of the definition table. The <a href="d_datmin.htm#i1038828">CREATE_MODEL Procedure</a> embeds the transformation list in a new model called <code>glm_model</code>.</p>
<p>The transformation and reverse transformation expressions embedded in <code>glm_model</code> are returned by the <a href="d_datmin.htm#CACJDBCE">GET_MODEL_TRANSFORMATIONS Function</a>.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, cust_income_level, cust_gender, affinity_card
       FROM mining_data_build;
 
DESCRIBE mining_data
 Name                      Null?    Type
 ------------------------- -------- -----------------
 CUST_ID                   NOT NULL NUMBER
 CUST_INCOME_LEVEL                  VARCHAR2(30)
 CUST_GENDER                        VARCHAR2(1)
 AFFINITY_CARD                      NUMBER(10)
 
BEGIN
    dbms_data_mining_transform.CREATE_BIN_NUM(
        bin_table_name   =&gt; 'bin_tbl');
    dbms_data_mining_transform.INSERT_BIN_NUM_EQWIDTH (
        bin_table_name   =&gt; 'bin_tbl',
        data_table_name  =&gt; 'mining_data',
        bin_num          =&gt; 4,
        exclude_list     =&gt; dbms_data_mining_transform.COLUMN_LIST('cust_id'));
END;
/
 
set numwidth 10
column val off
column col format a20
column bin format a10
SELECT col, val, bin FROM bin_tbl
    ORDER BY val ASC;
 
COL                         VAL  BIN
-------------------- ----------  ----------
AFFINITY_CARD                 0
AFFINITY_CARD               .25  1
AFFINITY_CARD                .5  2
AFFINITY_CARD               .75  3
AFFINITY_CARD                 1  4
 
CREATE TABLE glmsettings(
        setting_name  VARCHAR2(30),
        setting_value VARCHAR2(30));
 
BEGIN
   INSERT INTO glmsettings (setting_name, setting_value) VALUES
         (dbms_data_mining.algo_name, dbms_data_mining.algo_generalized_linear_model);
   COMMIT;
END;
/
 
DECLARE
     xforms   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
     dbms_data_mining_transform.STACK_BIN_NUM (
         bin_table_name           =&gt; 'bin_tbl',
         xform_list               =&gt;  xforms,
         literal_flag             =&gt;  TRUE);
     dbms_data_mining.CREATE_MODEL(
         model_name              =&gt; 'glm_model',
         mining_function         =&gt; dbms_data_mining.regression,
         data_table_name         =&gt; 'mining_data',
         case_id_column_name     =&gt; 'cust_id',
         target_column_name      =&gt; 'affinity_card',
         settings_table_name     =&gt; 'glmsettings',
         data_schema_name        =&gt; null,
         settings_schema_name    =&gt; null,
         xform_list              =&gt; xforms);
END;
/
 
SELECT attribute_name 
      FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('glm_model'));
 
ATTRIBUTE_NAME
------------------------
AFFINITY_CARD
 
SELECT expression 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('glm_model'));
 
EXPRESSION
--------------------------------------------------------------------------------
CASE WHEN "AFFINITY_CARD"&lt;0 THEN NULL WHEN "AFFINITY_CARD"&lt;=.25 THEN 1 WHEN
"AFFINITY_CARD"&lt;=.5 THEN 2 WHEN "AFFINITY_CARD"&lt;=.75 THEN 3 WHEN
"AFFINITY_CARD"&lt;=1 THEN 4 END
 
SELECT reverse_expression 
       FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('glm_model'));
 
REVERSE_EXPRESSION
--------------------------------------------------------------------------------
DECODE("AFFINITY_CARD",4,'(.75; 1]',1,'[0; .25]',2,'(.25; .5]',3,'(.5; .75]',
NULL,'( ; 0), (1;  ), NULL')
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73034" class="refsect2"><a id="BABEDFDH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2707"></a>INSERT_BIN_NUM_QTILE Procedure</h3>
<p>This procedure performs numerical binning and inserts the transformation definitions in a transformation definition table. The procedure calls the SQL <code>NTILE</code> function to order the data and divide it equally into the specified number of bins (quantiles).</p>
<p><code>INSERT_BIN_NUM_QTILE</code> bins all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2708"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_NUM_QTILE (
    bin_table_name       IN VARCHAR2,
    data_table_name      IN VARCHAR2,
    bin_num              IN PLS_INTEGER DEFAULT 10,
    exclude_list         IN COLUMN_LIST DEFAULT NULL,
    bin_schema_name      IN VARCHAR2 DEFAULT NULL,
    data_schema_name     IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2709"></a>Parameters</p>
<div id="ARPLS73035" class="tblformal">
<p class="titleintable"><a id="sthref2710"></a><a id="sthref2711"></a>Table 45-23 INSERT_BIN_NUM_QTILE Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_BIN_NUM_QTILE Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_NUM_QTILE." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t45">Parameter</th>
<th class="cellalignment1227" id="r1c2-t45">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t45" headers="r1c1-t45">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t45 r1c2-t45">
<p>Name of the transformation definition table for numerical binning. You can use the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
COL       VARCHAR2(30)
VAL       NUMBER
BIN       VARCHAR2(4000)
</pre>
<p><code>CREATE_BIN_NUM</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_BIN_NUM_QTILE</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t45" headers="r1c1-t45">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t45 r1c2-t45">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t45" headers="r1c1-t45">
<p><code>bin_num</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t45 r1c2-t45">
<p>Number of bins. No binning occurs if <code><span class="codeinlineitalic">bin_num</span></code> is <code>0</code> or <code>NULL</code>.</p>
<p>The default number of bins is 10.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t45" headers="r1c1-t45">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t45 r1c2-t45">
<p>List of numeric columns to be excluded from the binning process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all numeric columns in the data source are binned.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t45" headers="r1c1-t45">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t45 r1c2-t45">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t45" headers="r1c1-t45">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t45 r1c2-t45">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2712"></a>Usage Notes</p>
<ol>
<li>
<p>After dividing the data into quantiles, the <code>NTILE</code> function distributes any remainder values one for each quantile, starting with the first. See <a class="olink SQLRF006" href="../../server.112/e41084/functions.htm#SQLRF006"><span class="italic">Oracle Database SQL Language Reference</span> for details.</a></p>
</li>
<li>
<p>Columns with all <code>NULL</code> values are ignored by <code>INSERT_BIN_NUM_QTILE</code>.</p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2713"></a>Examples</p>
<p>In this example, <code>INSERT_BIN_NUM_QTILE</code> computes the bin boundaries for the <code>cust_year_of_birth</code> and <code>cust_credit_limit</code> columns in <code>sh.customers</code> and inserts the transformations in a transformation definition table. The <a href="#CACEGEHI">STACK_BIN_NUM Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in <code>STACK_VIEW</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
        SELECT cust_id, cust_year_of_birth, cust_credit_limit, cust_city
        FROM sh.customers;
 
DESCRIBE mining_data
 Name                                    Null?    Type
 --------------------------------------- -------- -----------------------------
 CUST_ID                                 NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                      NOT NULL NUMBER(4)
 CUST_CREDIT_LIMIT                       NUMBER
 CUST_CITY                               NOT NULL VARCHAR2(30)
 
BEGIN
   dbms_data_mining_transform.CREATE_BIN_NUM(
        bin_table_name   =&gt; 'bin_tbl');
   dbms_data_mining_transform.INSERT_BIN_NUM_QTILE (
        bin_table_name   =&gt; 'bin_tbl',
        data_table_name  =&gt; 'mining_data',
        bin_num          =&gt; 3,
        exclude_list     =&gt; dbms_data_mining_transform.COLUMN_LIST('cust_id'));
END;
/
 
set numwidth 8
column val off
column col format a20
column bin format a10
SELECT col, val, bin
      FROM bin_tbl
      ORDER BY col ASC, val ASC;
 
COL                       VAL BIN
-------------------- -------- ----------
CUST_CREDIT_LIMIT        1500
CUST_CREDIT_LIMIT        3000 1
CUST_CREDIT_LIMIT        9000 2
CUST_CREDIT_LIMIT       15000 3
CUST_YEAR_OF_BIRTH       1913
CUST_YEAR_OF_BIRTH       1949 1
CUST_YEAR_OF_BIRTH       1965 2
CUST_YEAR_OF_BIRTH       1990 3
 
DECLARE
   xforms   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
   dbms_data_mining_transform.STACK_BIN_NUM (
        bin_table_name        =&gt; 'bin_tbl',
        xform_list            =&gt;  xforms);
   dbms_data_mining_transform.XFORM_STACK (
        xform_list            =&gt;  xforms,
        data_table_name       =&gt; 'mining_data',
        xform_view_name       =&gt; 'stack_view');
END;
/
 
set long 3000
SELECT text FROM user_views WHERE view_name in 'STACK_VIEW';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID",CASE WHEN "CUST_YEAR_OF_BIRTH"&lt;1913 THEN NULL WHEN "CUST_YEAR_O
F_BIRTH"&lt;=1949 THEN '1' WHEN "CUST_YEAR_OF_BIRTH"&lt;=1965 THEN '2' WHEN "CUST_YEAR
_OF_BIRTH"&lt;=1990 THEN '3' END "CUST_YEAR_OF_BIRTH",CASE WHEN "CUST_CREDIT_LIMIT"
&lt;1500 THEN NULL WHEN "CUST_CREDIT_LIMIT"&lt;=3000 THEN '1' WHEN "CUST_CREDIT_LIMIT"
&lt;=9000 THEN '2' WHEN "CUST_CREDIT_LIMIT"&lt;=15000 THEN '3' END "CUST_CREDIT_LIMIT"
,"CUST_CITY" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73036" class="refsect2"><a id="BABEHBCE"></a>
<hr />
<h3 class="refsect2"><a id="sthref2714"></a>INSERT_BIN_SUPER Procedure</h3>
<p>This procedure performs numerical and categorical binning and inserts the transformation definitions in transformation definition tables. The procedure computes bin boundaries based on intrinsic relationships between predictors and a target.</p>
<p><code>INSERT_BIN_SUPER</code> uses an intelligent binning technique known as <span class="bold">supervised binning</span>. It builds a single-predictor decision tree and derives the bin boundaries from splits within the tree.</p>
<p><code>INSERT_BIN_SUPER</code> bins all the <code>VARCHAR2</code>, <code>CHAR</code>, <code>NUMBER</code>, and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2715"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_SUPER (
    num_table_name        IN VARCHAR2,
    cat_table_name        IN VARCHAR2,
    data_table_name       IN VARCHAR2,
    target_column_name    IN VARCHAR2,
    max_bin_num           IN PLS_INTEGER  DEFAULT 1000,
    exclude_list          IN COLUMN_LIST  DEFAULT NULL,
    num_schema_name       IN VARCHAR2     DEFAULT NULL,
    cat_schema_name       IN VARCHAR2     DEFAULT NULL,
    data_schema_name      IN VARCHAR2     DEFAULT NULL,
    rem_table_name        IN VARCHAR2     DEFAULT NULL,
    rem_schema_name       IN VARCHAR2     DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2716"></a>Parameters</p>
<div id="ARPLS73037" class="tblformal">
<p class="titleintable"><a id="sthref2717"></a><a id="sthref2718"></a>Table 45-24 INSERT_BIN_SUPER Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_BIN_SUPER Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_SUPER." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t46">Parameter</th>
<th class="cellalignment1227" id="r1c2-t46">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t46" headers="r1c1-t46">
<p><code>num_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t46 r1c2-t46">
<p>Name of the transformation definition table for numerical binning. You can use the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
COL       VARCHAR2(30)
VAL       VNUMBER
BIN       VARCHAR2(4000)
</pre>
<p><code>CREATE_BIN_NUM</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_BIN_SUPER</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t46" headers="r1c1-t46">
<p><code>cat_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t46 r1c2-t46">
<p>Name of the transformation definition table for categorical binning. You can use the <a href="#BABHJHJF">CREATE_BIN_CAT Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
COL       VARCHAR2(30)
VAL       VARCHAR2(4000)
BIN       VARCHAR2(4000)
</pre>
<p><code>CREATE_BIN_CAT</code> creates an additional column, <code>ATT</code>, which is used for specifying nested attributes. This column is not used by <code>INSERT_BIN_SUPER</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t46" headers="r1c1-t46">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t46 r1c2-t46">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t46" headers="r1c1-t46">
<p><code>target_column_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t46 r1c2-t46">
<p>Name of a column to be used as the target for the decision tree models</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t46" headers="r1c1-t46">
<p><code>max_bin_num</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t46 r1c2-t46">
<p>The maximum number of bins. The default is 1000.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t46" headers="r1c1-t46">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t46 r1c2-t46">
<p>List of columns to be excluded from the binning process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>CHAR</code>, <code>VARCHAR2</code>, <code>NUMBER</code>, and <code>FLOAT</code> columns in the data source are binned.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t46" headers="r1c1-t46">
<p><code>num_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t46 r1c2-t46">
<p>Schema of <code><span class="codeinlineitalic">num_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t46" headers="r1c1-t46">
<p><code>cat_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t46 r1c2-t46">
<p>Schema of <code><span class="codeinlineitalic">cat_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t46" headers="r1c1-t46">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r10c1-t46 r1c2-t46">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t46" headers="r1c1-t46">
<p><code>rem_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r11c1-t46 r1c2-t46">
<p>Name of a column removal definition table. The table must have the columns described in <a href="#BABGCDCC">"CREATE_COL_REM Procedure"</a>. You can use <code>CREATE_COL_REM</code> to create the table. See Usage Notes.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t46" headers="r1c1-t46">
<p><code>rem_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r12c1-t46 r1c2-t46">
<p>Schema of <code><span class="codeinlineitalic">rem_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2719"></a>Usage Notes</p>
<ol>
<li>
<p>Columns that have no significant splits are not binned. You can remove the unbinned columns from the mining data by specifying a column removal definition table. If you do not specify a column removal definition table, the unbinned columns remain in the mining data.</p>
</li>
<li>
<p>See <a class="olink DMCON019" href="../../datamine.112/e16808/algo_decisiontree.htm#DMCON019"><span class="italic">Oracle Data Mining Concepts</span></a> to learn more about decision trees in Oracle Data Mining</p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2720"></a>Examples</p>
<p>In this example, <code>INSERT_BIN_SUPER</code> computes the bin boundaries for predictors of <code>cust_credit_limit</code> and inserts the transformations in transformation definition tables. One predictor is numerical, the other is categorical. (<code>INSERT_BIN_SUPER</code> determines that the <code>cust_postal_code</code> column is not a significant predictor.) <code>STACK</code> procedures create transformation lists from the contents of the definition tables.</p>
<p>The SQL expressions that compute the transformations are shown in the views <code>MINING_DATA_STACK_NUM</code> and <code>MINING_DATA_STACK_CAT</code>. The views are for display purposes only; they cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
     SELECT cust_id, cust_year_of_birth, cust_marital_status,
            cust_postal_code, cust_credit_limit
     FROM sh.customers;
 
DESCRIBE mining_data
 Name                             Null?    Type
 -------------------------------- -------- ------------------------------------
 CUST_ID                          NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH               NOT NULL NUMBER(4)
 CUST_MARITAL_STATUS                       VARCHAR2(20)
 CUST_POSTAL_CODE                 NOT NULL VARCHAR2(10)
 CUST_CREDIT_LIMIT                         NUMBER
 
BEGIN
    dbms_data_mining_transform.CREATE_BIN_NUM(
         bin_table_name      =&gt; 'bin_num_tbl');
    dbms_data_mining_transform.CREATE_BIN_CAT(
         bin_table_name      =&gt; 'bin_cat_tbl');
    dbms_data_mining_transform.CREATE_COL_REM(
         rem_table_name      =&gt; 'rem_tbl');
END;
/
 
BEGIN
   COMMIT;
   dbms_data_mining_transform.INSERT_BIN_SUPER (
      num_table_name      =&gt; 'bin_num_tbl',
      cat_table_name      =&gt; 'bin_cat_tbl',
      data_table_name     =&gt; 'mining_data',
      target_column_name  =&gt; 'cust_credit_limit',
      max_bin_num         =&gt;  4,
      exclude_list        =&gt;  dbms_data_mining_transform.COLUMN_LIST('cust_id'),
      num_schema_name     =&gt; 'dmuser',
      cat_schema_name     =&gt; 'dmuser',
      data_schema_name    =&gt; 'dmuser',
      rem_table_name      =&gt; 'rem_tbl',
      rem_schema_name     =&gt; 'dmuser');
   COMMIT;
END;
/
 
set numwidth 8
column val off
SELECT col, val, bin FROM bin_num_tbl
      ORDER BY bin ASC;
 
COL                       VAL BIN
-------------------- -------- ----------
CUST_YEAR_OF_BIRTH     1923.5 1
CUST_YEAR_OF_BIRTH     1923.5 1
CUST_YEAR_OF_BIRTH     1945.5 2
CUST_YEAR_OF_BIRTH     1980.5 3
CUST_YEAR_OF_BIRTH            4
 
column val on
column val format a20
SELECT col, val, bin FROM bin_cat_tbl
      ORDER BY bin ASC;
 
COL                  VAL                  BIN
-------------------- -------------------- ----------
CUST_MARITAL_STATUS  married              1
CUST_MARITAL_STATUS  single               2
CUST_MARITAL_STATUS  Mar-AF               3
CUST_MARITAL_STATUS  Mabsent              3
CUST_MARITAL_STATUS  Divorc.              3
CUST_MARITAL_STATUS  Married              3
CUST_MARITAL_STATUS  Widowed              3
CUST_MARITAL_STATUS  NeverM               3
CUST_MARITAL_STATUS  Separ.               3
CUST_MARITAL_STATUS  divorced             4
CUST_MARITAL_STATUS  widow                4
 
SELECT col from rem_tbl;
 
COL
--------------------
CUST_POSTAL_CODE
 
DECLARE
    xforms_num      dbms_data_mining_transform.TRANSFORM_LIST;
    xforms_cat      dbms_data_mining_transform.TRANSFORM_LIST;
    BEGIN
       dbms_data_mining_transform.STACK_BIN_NUM (
            bin_table_name    =&gt; 'bin_num_tbl',
            xform_list        =&gt; xforms_num);
       dbms_data_mining_transform.XFORM_STACK (
            xform_list         =&gt; xforms_num,
            data_table_name    =&gt; 'mining_data',
            xform_view_name    =&gt; 'mining_data_stack_num');
       dbms_data_mining_transform.STACK_BIN_CAT (
             bin_table_name    =&gt; 'bin_cat_tbl',
             xform_list        =&gt; xforms_cat);
       dbms_data_mining_transform.XFORM_STACK (
             xform_list         =&gt; xforms_cat,
             data_table_name    =&gt; 'mining_data',
             xform_view_name    =&gt; 'mining_data_stack_cat');
   END;
 /
 
set long 3000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK_NUM';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID",CASE WHEN "CUST_YEAR_OF_BIRTH"&lt;1923.5 THEN '1' WHEN "CUST_YEAR_
OF_BIRTH"&lt;=1923.5 THEN '1' WHEN "CUST_YEAR_OF_BIRTH"&lt;=1945.5 THEN '2' WHEN "CUST
_YEAR_OF_BIRTH"&lt;=1980.5 THEN '3' WHEN "CUST_YEAR_OF_BIRTH" IS NOT NULL THEN '4'
END "CUST_YEAR_OF_BIRTH","CUST_MARITAL_STATUS","CUST_POSTAL_CODE","CUST_CREDIT_L
IMIT" FROM mining_data
 
 
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK_CAT';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_YEAR_OF_BIRTH",DECODE("CUST_MARITAL_STATUS",'Divorc.','3'
,'Mabsent','3','Mar-AF','3','Married','3','NeverM','3','Separ.','3','Widowed','3
','divorced','4','married','1','single','2','widow','4') "CUST_MARITAL_STATUS","
CUST_POSTAL_CODE","CUST_CREDIT_LIMIT" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73038" class="refsect2"><a id="BABIIJFA"></a>
<hr />
<h3 class="refsect2"><a id="sthref2721"></a>INSERT_CLIP_TRIM_TAIL Procedure</h3>
<p>This procedure replaces numeric outliers with nulls and inserts the transformation definitions in a transformation definition table.</p>
<p><code>INSERT_CLIP_TRIM_TAIL</code> computes the boundaries of the data based on a specified percentage. It removes the values that fall outside the boundaries (tail values) from the data. If you wish to replace the tail values instead of removing them, use the <a href="#BABIIFED">INSERT_CLIP_WINSOR_TAIL Procedure</a>.</p>
<p><code>INSERT_CLIP_TRIM_TAIL</code> clips all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2722"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_TRIM_TAIL (
    clip_table_name     IN VARCHAR2,
    data_table_name     IN VARCHAR2,
    tail_frac           IN NUMBER DEFAULT 0.025,
    exclude_list        IN COLUMN_LIST DEFAULT NULL,
    clip_schema_name    IN VARCHAR2 DEFAULT NULL,
    data_schema_name    IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2723"></a>Parameters</p>
<div id="ARPLS73039" class="tblformal">
<p class="titleintable"><a id="sthref2724"></a><a id="sthref2725"></a>Table 45-25 INSERT_CLIP_TRIM_TAIL Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_CLIP_TRIM_TAIL Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_TRIM_TAIL." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t47">Parameter</th>
<th class="cellalignment1227" id="r1c2-t47">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t47" headers="r1c1-t47">
<p><code>clip_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t47 r1c2-t47">
<p>Name of the transformation definition table for numerical clipping. You can use the <a href="#BABCFGBC">CREATE_CLIP Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
 COL         VARCHAR2(30)
 LCUT        NUMBER
 LVAL        NUMBER
 RCUT        NUMBER
 RVAL        NUMBER
</pre>
<p><code>CREATE_CLIP</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_CLIP_TRIM_TAIL</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t47" headers="r1c1-t47">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t47 r1c2-t47">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t47" headers="r1c1-t47">
<p><code>tail_frac</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t47 r1c2-t47">
<p>The percentage of non-null values to be designated as outliers at each end of the data. For example, if <code><span class="codeinlineitalic">tail_frac</span></code> is .01, then 1% of the data at the low end and 1% of the data at the high end will be treated as outliers.</p>
<p>If <code><span class="codeinlineitalic">tail_frac</span></code> is greater than or equal to .5, no clipping occurs.</p>
<p>The default value of <code><span class="codeinlineitalic">tail_frac</span></code> is 0.025.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t47" headers="r1c1-t47">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t47 r1c2-t47">
<p>List of <code>NUMBER</code> columns to be excluded from the clipping process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>NUMBER</code> columns in the data are clipped.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t47" headers="r1c1-t47">
<p><code>clip_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t47 r1c2-t47">
<p>Schema of <code><span class="codeinlineitalic">clip_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t47" headers="r1c1-t47">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t47 r1c2-t47">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2726"></a>Usage Notes</p>
<p>The <code>DBMS_DATA_MINING_TRANSFORM</code> package provides two clipping procedures: <code>INSERT_CLIP_TRIM_TAIL</code> and <code>INSERT_CLIP_WINSOR_TAIL</code>. Both procedures compute the boundaries as follows:</p>
<ul>
<li>
<p>Count the number of non-null values, <code><span class="codeinlineboldital">n</span></code>, and sort them in ascending order</p>
</li>
<li>
<p>Calculate the number of outliers, <code><span class="codeinlineboldital">t</span></code>, as <code><span class="codeinlineboldital">n*tail_frac</span></code></p>
</li>
<li>
<p>Define the lower boundary <code><span class="codeinlineboldital">lcut</span></code> as the value at position <code><span class="codeinlineboldital">1+</span></code><code><span class="codeinlinebold">floor</span></code><code><span class="codeinlineboldital">(t)</span></code></p>
</li>
<li>
<p>Define the upper boundary <span class="bolditalic">rcut</span> as the value at position <code><span class="codeinlineboldital">n-</span></code><code><span class="codeinlinebold">floor</span></code><code><span class="codeinlineboldital">(t)</span></code></p>
<p>(The SQL <code>FLOOR</code> function returns the largest integer less than or equal to <code><span class="codeinlineboldital">t</span></code>.)</p>
</li>
<li>
<p>All values that are &lt;= <code><span class="codeinlineboldital">lcut</span></code> or =&gt; <code><span class="codeinlineboldital">rcut</span></code> are designated as outliers.</p>
</li>
</ul>
<p><code>INSERT_CLIP_TRIM_TAIL</code> replaces the outliers with nulls, effectively removing them from the data.</p>
<p><code>INSERT_CLIP_WINSOR_TAIL</code> assigns <code><span class="codeinlineboldital">lcut</span></code> to the low outliers and <code><span class="codeinlineboldital">rcut</span></code> to the high outliers.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2727"></a>Examples</p>
<p>In this example, <code>INSERT_CLIP_TRIM_TAIL</code> trims 10% of the data in two columns (5% from the high end and 5% from the low end) and inserts the transformations in a transformation definition table. The <a href="#CACHGHIG">STACK_CLIP Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the trimming is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, cust_year_of_birth, cust_credit_limit, cust_city
       FROM sh.customers;
 
DESCRIBE mining_data
 Name                            Null?    Type
 ------------------------------- -------- -------------------
 CUST_ID                         NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH              NOT NULL NUMBER(4)
 CUST_CREDIT_LIMIT                        NUMBER
 CUST_CITY                       NOT NULL VARCHAR2(30)

BEGIN
   dbms_data_mining_transform.CREATE_CLIP(
      clip_table_name    =&gt; 'clip_tbl');
   dbms_data_mining_transform.INSERT_CLIP_TRIM_TAIL(
      clip_table_name    =&gt; 'clip_tbl',
      data_table_name    =&gt; 'mining_data',
      tail_frac          =&gt; 0.05,
      exclude_list       =&gt; DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST('cust_id'));
END;
/
 
SELECT col, lcut, lval, rcut, rval
      FROM clip_tbl
      ORDER BY col ASC;
 
COL                      LCUT     LVAL     RCUT     RVAL
-------------------- -------- -------- -------- --------
CUST_CREDIT_LIMIT        1500             11000
CUST_YEAR_OF_BIRTH       1934              1982
 
DECLARE
     xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
     dbms_data_mining_transform.STACK_CLIP (
          clip_table_name    =&gt; 'clip_tbl',
          xform_list         =&gt; xforms);
     dbms_data_mining_transform.XFORM_STACK (
          xform_list         =&gt; xforms,
          data_table_name    =&gt; 'mining_data',
          xform_view_name    =&gt; 'mining_data_stack');
 END;
 /
 
set long 3000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID",CASE WHEN "CUST_YEAR_OF_BIRTH" &lt; 1934 THEN NULL WHEN "CUST_YEAR
_OF_BIRTH" &gt; 1982 THEN NULL ELSE "CUST_YEAR_OF_BIRTH" END "CUST_YEAR_OF_BIRTH",C
ASE WHEN "CUST_CREDIT_LIMIT" &lt; 1500 THEN NULL WHEN "CUST_CREDIT_LIMIT" &gt; 11000 T
HEN NULL ELSE "CUST_CREDIT_LIMIT" END "CUST_CREDIT_LIMIT","CUST_CITY" FROM minin
g_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73040" class="refsect2"><a id="BABIIFED"></a>
<hr />
<h3 class="refsect2"><a id="sthref2728"></a>INSERT_CLIP_WINSOR_TAIL Procedure</h3>
<p>This procedure replaces numeric outliers with the upper or lower boundary values. It inserts the transformation definitions in a transformation definition table.</p>
<p><code>INSERT_CLIP_WINSOR_TAIL</code> computes the boundaries of the data based on a specified percentage. It replaces the values that fall outside the boundaries (tail values) with the related boundary value. If you wish to set tail values to null, use the <a href="#BABIIJFA">INSERT_CLIP_TRIM_TAIL Procedure</a>.</p>
<p><code>INSERT_CLIP_WINSOR_TAIL</code> clips all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2729"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (
    clip_table_name    IN VARCHAR2,
    data_table_name    IN VARCHAR2,
    tail_frac          IN NUMBER DEFAULT 0.025,
    exclude_list       IN COLUMN_LIST DEFAULT NULL,
    clip_schema_name   IN VARCHAR2 DEFAULT NULL,
    data_schema_name   IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2730"></a>Parameters</p>
<div id="ARPLS73041" class="tblformal">
<p class="titleintable"><a id="sthref2731"></a><a id="sthref2732"></a>Table 45-26 INSERT_CLIP_WINSOR_TAIL Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_CLIP_WINSOR_TAIL Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t48">Parameter</th>
<th class="cellalignment1227" id="r1c2-t48">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t48" headers="r1c1-t48">
<p><code>clip_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t48 r1c2-t48">
<p>Name of the transformation definition table for numerical clipping. You can use the <a href="#BABCFGBC">CREATE_CLIP Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
 COL         VARCHAR2(30)
 LCUT        NUMBER
 LVAL        NUMBER
 RCUT        NUMBER
 RVAL        NUMBER
</pre>
<p><code>CREATE_CLIP</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_CLIP_WINSOR_TAIL</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t48" headers="r1c1-t48">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t48 r1c2-t48">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t48" headers="r1c1-t48">
<p><code>tail_frac</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t48 r1c2-t48">
<p>The percentage of non-null values to be designated as outliers at each end of the data. For example, if <code><span class="codeinlineitalic">tail_frac</span></code> is .01, then 1% of the data at the low end and 1% of the data at the high end will be treated as outliers.</p>
<p>If <code><span class="codeinlineitalic">tail_frac</span></code> is greater than or equal to .5, no clipping occurs.</p>
<p>The default value of <code><span class="codeinlineitalic">tail_frac</span></code> is 0.025.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t48" headers="r1c1-t48">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t48 r1c2-t48">
<p>List of <code>NUMBER</code> columns to be excluded from the clipping process. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>NUMBER</code> columns in the data are clipped.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t48" headers="r1c1-t48">
<p><code>clip_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t48 r1c2-t48">
<p>Schema of <code><span class="codeinlineitalic">clip_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t48" headers="r1c1-t48">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t48 r1c2-t48">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2733"></a>Usage Notes</p>
<p>The <code>DBMS_DATA_MINING_TRANSFORM</code> package provides two clipping procedures: <code>INSERT_CLIP_WINSOR_TAIL</code> and <code>INSERT_CLIP_TRIM_TAIL</code>. Both procedures compute the boundaries as follows:</p>
<ul>
<li>
<p>Count the number of non-null values, <code><span class="codeinlineboldital">n</span></code>, and sort them in ascending order</p>
</li>
<li>
<p>Calculate the number of outliers, <code><span class="codeinlineboldital">t</span></code>, as <code><span class="codeinlineboldital">n*tail_frac</span></code></p>
</li>
<li>
<p>Define the lower boundary <code><span class="codeinlineboldital">lcut</span></code> as the value at position <code><span class="codeinlineboldital">1+</span></code><code><span class="codeinlinebold">floor</span></code><code><span class="codeinlineboldital">(t)</span></code></p>
</li>
<li>
<p>Define the upper boundary <span class="bolditalic">rcut</span> as the value at position <code><span class="codeinlineboldital">n-</span></code><code><span class="codeinlinebold">floor</span></code><code><span class="codeinlineboldital">(t)</span></code></p>
<p>(The SQL <code>FLOOR</code> function returns the largest integer less than or equal to <code><span class="codeinlineboldital">t</span></code>.)</p>
</li>
<li>
<p>All values that are &lt;= <code><span class="codeinlineboldital">lcut</span></code> or =&gt; <code><span class="codeinlineboldital">rcut</span></code> are designated as outliers.</p>
</li>
</ul>
<p><code>INSERT_CLIP_WINSOR_TAIL</code> assigns <code><span class="codeinlineboldital">lcut</span></code> to the low outliers and <code><span class="codeinlineboldital">rcut</span></code> to the high outliers.</p>
<p><code>INSERT_CLIP_TRIM_TAIL</code> replaces the outliers with nulls, effectively removing them from the data.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2734"></a>Examples</p>
<p>In this example, <code>INSERT_CLIP_WINSOR_TAIL</code> winsorizes 10% of the data in two columns (5% from the high end, and 5% from the low end) and inserts the transformations in a transformation definition table. The <a href="#CACHGHIG">STACK_CLIP Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
        SELECT cust_id, cust_year_of_birth, cust_credit_limit, cust_city
        FROM sh.customers;

describe mining_data
 Name                                     Null?    Type
 ---------------------------------------- -------- -------------
 CUST_ID                                  NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                       NOT NULL NUMBER(4)
 CUST_CREDIT_LIMIT                                 NUMBER
 CUST_CITY                                NOT NULL VARCHAR2(30)
 
BEGIN
  dbms_data_mining_transform.CREATE_CLIP(
      clip_table_name   =&gt; 'clip_tbl');
  dbms_data_mining_transform.INSERT_CLIP_WINSOR_TAIL(
      clip_table_name   =&gt; 'clip_tbl',
      data_table_name   =&gt; 'mining_data',
      tail_frac         =&gt; 0.05,
      exclude_list      =&gt; DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST('cust_id'));
END;
/

SELECT col, lcut, lval, rcut, rval FROM clip_tbl
   ORDER BY col ASC;
COL                                LCUT     LVAL     RCUT     RVAL
------------------------------ -------- -------- -------- --------
CUST_CREDIT_LIMIT                  1500     1500    11000    11000
CUST_YEAR_OF_BIRTH                 1934     1934     1982     1982

DECLARE
   xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
   dbms_data_mining_transform.STACK_CLIP (
   clip_table_name    =&gt; 'clip_tbl',
   xform_list        =&gt; xforms);
dbms_data_mining_transform.XFORM_STACK (
   xform_list         =&gt; xforms,
   data_table_name    =&gt; 'mining_data',
   xform_view_name    =&gt; 'mining_data_stack');
END;
/
 
set long 3000
SQL&gt; SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID",CASE WHEN "CUST_YEAR_OF_BIRTH" &lt; 1934 THEN 1934 WHEN "CUST_YEAR
_OF_BIRTH" &gt; 1982 THEN 1982 ELSE "CUST_YEAR_OF_BIRTH" END "CUST_YEAR_OF_BIRTH",C
ASE WHEN "CUST_CREDIT_LIMIT" &lt; 1500 THEN 1500 WHEN "CUST_CREDIT_LIMIT" &gt; 11000 T
HEN 11000 ELSE "CUST_CREDIT_LIMIT" END "CUST_CREDIT_LIMIT","CUST_CITY" FROM mini
ng_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73042" class="refsect2"><a id="BABJCGCA"></a>
<hr />
<h3 class="refsect2"><a id="sthref2735"></a>INSERT_MISS_CAT_MODE Procedure</h3>
<p>This procedure replaces missing categorical values with the value that occurs most frequently in the column (the mode). It inserts the transformation definitions in a transformation definition table.</p>
<p><code>INSERT_MISS_CAT_MODE</code> replaces missing values in all <code>VARCHAR2</code> and <code>CHAR</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2736"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
    miss_table_name    IN VARCHAR2,
    data_table_name    IN VARCHAR2,
    exclude_list       IN COLUMN_LIST DEFAULT NULL,
    miss_schema_name   IN VARCHAR2 DEFAULT NULL,
    data_schema_name   IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2737"></a>Parameters</p>
<div id="ARPLS73043" class="tblformal">
<p class="titleintable"><a id="sthref2738"></a><a id="CACFGAGB"></a>Table 45-27 INSERT_MISS_CAT_MODE Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_MISS_CAT_MODE Procedure Parameters" summary="This table lists the parameters of the DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE procedure." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t49">Parameter</th>
<th class="cellalignment1227" id="r1c2-t49">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t49" headers="r1c1-t49">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t49 r1c2-t49">
<p>Name of the transformation definition table for categorical missing value treatment. You can use the <a href="#BABHJFDC">CREATE_MISS_CAT Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
 COL         VARCHAR2(30)
 VAL         VARCHAR2(4000)
</pre>
<p><code>CREATE_MISS_CAT</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_MISS_CAT_MODE</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t49" headers="r1c1-t49">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t49 r1c2-t49">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t49" headers="r1c1-t49">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t49 r1c2-t49">
<p>List of <code>VARCHAR2</code> and <code>CHAR</code> columns to be excluded from missing value treatment. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>VARCHAR2</code> and <code>CHAR</code> columns are transformed.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t49" headers="r1c1-t49">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t49 r1c2-t49">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t49" headers="r1c1-t49">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t49 r1c2-t49">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2739"></a>Usage Notes</p>
<p>If you wish to replace categorical missing values with a value other than the mode, you can edit the transformation definition table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DMPRG015" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG015"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a> for information about default missing value treatment in Oracle Data Mining</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2740"></a>Example</p>
<p>In this example, <code>INSERT_MISS_CAT_MODE</code> computes missing value treatment for <code>cust_city</code> and inserts the transformation in a transformation definition table. The <a href="#BABJGBGH">STACK_MISS_CAT Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
         SELECT cust_id, cust_year_of_birth, cust_city
         FROM sh.customers;
 
describe mining_data
 Name                             Null?    Type
 -------------------------------- -------- ----------------
 CUST_ID                          NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH               NOT NULL NUMBER(4)
 CUST_CITY                        NOT NULL VARCHAR2(30)
 
BEGIN
  dbms_data_mining_transform.create_miss_cat(
      miss_table_name   =&gt; 'missc_tbl');
  dbms_data_mining_transform.insert_miss_cat_mode(
      miss_table_name   =&gt; 'missc_tbl',
      data_table_name   =&gt; 'mining_data');
END;
/

SELECT stats_mode(cust_city) FROM mining_data;
 
STATS_MODE(CUST_CITY)
------------------------------
Los Angeles

SELECT col, val
    from missc_tbl;

COL                            VAL
------------------------------ ------------------------------
CUST_CITY                      Los Angeles

DECLARE
    xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
    dbms_data_mining_transform.STACK_MISS_CAT (
        miss_table_name    =&gt; 'missc_tbl',
        xform_list        =&gt; xforms);
    dbms_data_mining_transform.XFORM_STACK (
         xform_list         =&gt; xforms,
         data_table_name    =&gt; 'mining_data',
         xform_view_name    =&gt; 'mining_data_stack');
END;
/
 
set long 3000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_YEAR_OF_BIRTH",NVL("CUST_CITY",'Los Angeles') "CUST_CITY"
 FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73044" class="refsect2"><a id="BABHAHEJ"></a>
<hr />
<h3 class="refsect2"><a id="sthref2741"></a>INSERT_MISS_NUM_MEAN Procedure</h3>
<p>This procedure replaces missing numerical values with the average (the mean) and inserts the transformation definitions in a transformation definition table.</p>
<p><code>INSERT_MISS_NUM_MEAN</code> replaces missing values in all <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2742"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
    miss_table_name    IN VARCHAR2,
    data_table_name    IN VARCHAR2,
    exclude_list       IN COLUMN_LIST DEFAULT NULL,
    round_num          IN PLS_INTEGER DEFAULT 6,
    miss_schema_name   IN VARCHAR2 DEFAULT NULL,
    data_schema_name   IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2743"></a>Parameters</p>
<div id="ARPLS73045" class="tblformal">
<p class="titleintable"><a id="sthref2744"></a><a id="sthref2745"></a>Table 45-28 INSERT_MISS_NUM_MEAN Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_MISS_NUM_MEAN Procedure Parameters" summary="Parameters of the DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN procedure." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t51">Parameter</th>
<th class="cellalignment1227" id="r1c2-t51">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t51" headers="r1c1-t51">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t51 r1c2-t51">
<p>Name of the transformation definition table for numerical missing value treatment. You can use the <a href="#BABIEAGA">CREATE_MISS_NUM Procedure</a> to create the definition table.</p>
<p>The following columns are required by <code>INSERT_MISS_NUM_MEAN</code>:</p>
<pre>
 COL          VARCHAR2(30)
 VAL          NUMBER
</pre>
<p><code>CREATE_MISS_NUM</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_MISS_NUM_MEAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t51" headers="r1c1-t51">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t51 r1c2-t51">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t51" headers="r1c1-t51">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t51 r1c2-t51">
<p>List of <code>NUMBER</code> columns to be excluded from missing value treatment. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>NUMBER</code> columns are transformed.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t51" headers="r1c1-t51">
<p><code>round_num</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t51 r1c2-t51">
<p>The number of significant digits to use for the mean.</p>
<p>The default number is 6.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t51" headers="r1c1-t51">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t51 r1c2-t51">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t51" headers="r1c1-t51">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t51 r1c2-t51">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2746"></a>Usage Notes</p>
<p>If you wish to replace numerical missing values with a value other than the mean, you can edit the transformation definition table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DMPRG015" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG015"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a> for information about default missing value treatment in Oracle Data Mining</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2747"></a>Example</p>
<p>In this example, <code>INSERT_MISS_NUM_MEAN</code> computes missing value treatment for <code>cust_year_of_birth</code> and inserts the transformation in a transformation definition table. The <a href="#BABFIBFF">STACK_MISS_NUM Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
    SELECT cust_id, cust_year_of_birth, cust_city
    FROM sh.customers;

DESCRIBE mining_data
 Name                                       Null?    Type
 ------------------------------------------ -------- -------------------
 CUST_ID                                    NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                         NOT NULL NUMBER(4)
 CUST_CITY                                  NOT NULL VARCHAR2(30)
 
BEGIN
   dbms_data_mining_transform.create_miss_num(
       miss_table_name   =&gt; 'missn_tbl');
   dbms_data_mining_transform.insert_miss_num_mean(
       miss_table_name   =&gt; 'missn_tbl',
       data_table_name   =&gt; 'mining_data',
       exclude_list      =&gt; DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST('cust_id'));
END;
/
 
set numwidth 4
column val off
SELECT col, val
  FROM missn_tbl;
 
COL                   VAL
-------------------- ----
CUST_YEAR_OF_BIRTH   1957
 
SELECT avg(cust_year_of_birth) FROM mining_data;
 
AVG(CUST_YEAR_OF_BIRTH)
-----------------------
                   1957
 
DECLARE
    xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
    dbms_data_mining_transform.STACK_MISS_NUM (
         miss_table_name    =&gt; 'missn_tbl',
         xform_list        =&gt; xforms);
    dbms_data_mining_transform.XFORM_STACK (
         xform_list         =&gt; xforms,
         data_table_name    =&gt; 'mining_data',
         xform_view_name    =&gt; 'mining_data_stack');
END;
/
 
set long 3000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID",NVL("CUST_YEAR_OF_BIRTH",1957.4) "CUST_YEAR_OF_BIRTH","CUST_CIT
Y" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73046" class="refsect2"><a id="BABDFACD"></a>
<hr />
<h3 class="refsect2">INSERT_NORM_LIN_MINMAX Procedure<a id="sthref2748"></a></h3>
<p>This procedure performs linear normalization and inserts the transformation definitions in a transformation definition table. <code>INSERT_NORM_LIN_MINMAX</code> computes the minimum and maximum values from the data and sets the value of <code><span class="codeinlineitalic">shift</span></code> and <code><span class="codeinlineitalic">scale</span></code> as follows:</p>
<pre>
<span class="italic">shift</span> = min
<span class="italic">scale</span> = max - min
</pre>
<p>Normalization is computed as:</p>
<pre>
<span class="italic">x_new</span> = (<span class="italic">x_old - shift</span>)/<span class="italic">scale</span>
</pre>
<p><code>INSERT_NORM_LIN_MINMAX</code> rounds the value of <code><span class="codeinlineitalic">scale</span></code> to a specified number of significant digits before storing it in the transformation definition table.</p>
<p><code>INSERT_NORM_LIN_MINMAX</code> normalizes all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2749"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX (
     norm_table_name     IN VARCHAR2,
     data_table_name     IN VARCHAR2,
     exclude_list        IN COLUMN_LIST DEFAULT NULL,
     round_num           IN PLS_INTEGER DEFAULT 6,
     norm_schema_name    IN VARCHAR2 DEFAULT NULL,
     data_schema_name    IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2750"></a>Parameters</p>
<div id="ARPLS73047" class="tblformal">
<p class="titleintable"><a id="sthref2751"></a><a id="sthref2752"></a>Table 45-29 <span class="bolditalic">INSERT_NORM_LIN_MINMAX Procedure Parameters</span></p>
<table class="cellalignment1229" title="INSERT_NORM_LIN_MINMAX Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_MINMAX." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t53">Parameter</th>
<th class="cellalignment1227" id="r1c2-t53">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t53" headers="r1c1-t53">
<p><code>norm_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t53 r1c2-t53">
<p>Name of the transformation definition table for linear normalization. You can use the <a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
 COL          VARCHAR2(30)
 SHIFT        NUMBER
 SCALE        NUMBER
</pre>
<p><code>CREATE_NORM_LIN</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_NORM_LIN_MINMAX</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t53" headers="r1c1-t53">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t53 r1c2-t53">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t53" headers="r1c1-t53">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t53 r1c2-t53">
<p>List of <code>NUMBER</code> columns to be excluded from normalization. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>NUMBER</code> columns are transformed.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t53" headers="r1c1-t53">
<p><code>round_num</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t53 r1c2-t53">
<p>The number of significant digits to use for the minimum and maximum. The default number is 6.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t53" headers="r1c1-t53">
<p><code>norm_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t53 r1c2-t53">
<p>Schema of <code><span class="codeinlineitalic">norm_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t53" headers="r1c1-t53">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t53 r1c2-t53">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2753"></a>Examples</p>
<p>In this example, <code>INSERT_NORM_LIN_MINMAX</code> normalizes the <code>cust_year_of_birth</code> column and inserts the transformation in a transformation definition table. The <a href="#BABFAFCH">STACK_NORM_LIN Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
         SELECT cust_id, cust_gender, cust_year_of_birth
         FROM sh.customers;

describe mining_data
 Name                                 Null?    Type
 ------------------------------------ -------- ----------------
 CUST_ID                              NOT NULL NUMBER
 CUST_GENDER                          NOT NULL CHAR(1)
 CUST_YEAR_OF_BIRTH                   NOT NULL NUMBER(4)
 
BEGIN
       dbms_data_mining_transform.CREATE_NORM_LIN(
         norm_table_name  =&gt; 'norm_tbl');
       dbms_data_mining_transform.INSERT_NORM_LIN_MINMAX(
         norm_table_name  =&gt; 'norm_tbl',
         data_table_name  =&gt; 'mining_data',
         exclude_list     =&gt; dbms_data_mining_transform.COLUMN_LIST( 'cust_id'),
         round_num        =&gt; 3);
END;
/
 
SELECT col, shift, scale FROM norm_tbl;
 
COL                                 SHIFT      SCALE
------------------------------ ---------- ----------
CUST_YEAR_OF_BIRTH                   1910         77

DECLARE
     xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
     dbms_data_mining_transform.STACK_NORM_LIN (
          norm_table_name    =&gt; 'norm_tbl',
          xform_list        =&gt; xforms);
     dbms_data_mining_transform.XFORM_STACK (
          xform_list         =&gt; xforms,
          data_table_name    =&gt; 'mining_data',
          xform_view_name    =&gt; 'mining_data_stack');
END;
/
 
set long 3000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_GENDER",("CUST_YEAR_OF_BIRTH"-1910)/77 "CUST_YEAR_OF_BIRT
H" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73048" class="refsect2"><a id="BABHAFJC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2754"></a>INSERT_NORM_LIN_SCALE Procedure</h3>
<p>This procedure performs linear normalization and inserts the transformation definitions in a transformation definition table. <code>INSERT_NORM_LIN_SCALE</code> computes the minimum and maximum values from the data and sets the value of <code><span class="codeinlineitalic">shift</span></code> and <code><span class="codeinlineitalic">scale</span></code> as follows:</p>
<pre>
<span class="italic">shift</span> = 0
<span class="italic">scale</span> = max(abs(max), abs(min))
</pre>
<p>Normalization is computed as:</p>
<pre>
<span class="italic">x_new</span> = (<span class="italic">x_old</span>)/<span class="italic">scale</span>
</pre>
<p><code>INSERT_NORM_LIN_SCALE</code> rounds the value of <code><span class="codeinlineitalic">scale</span></code> to a specified number of significant digits before storing it in the transformation definition table.</p>
<p><code>INSERT_NORM_LIN_SCALE</code> normalizes all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data source unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2755"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_SCALE (
     norm_table_name     IN VARCHAR2,
     data_table_name     IN VARCHAR2,
     exclude_list        IN COLUMN_LIST DEFAULT NULL,
     round_num           IN PLS_INTEGER DEFAULT 6,
     norm_schema_name    IN VARCHAR2 DEFAULT NULL,
     data_schema_name    IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2756"></a>Parameters</p>
<div id="ARPLS73049" class="tblformal">
<p class="titleintable"><a id="sthref2757"></a><a id="sthref2758"></a>Table 45-30 INSERT_NORM_LIN_SCALE Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_NORM_LIN_SCALE Procedure Parameters" summary="This table summarizes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_SCALE." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t54">Parameter</th>
<th class="cellalignment1227" id="r1c2-t54">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t54" headers="r1c1-t54">
<p><code>norm_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t54 r1c2-t54">
<p>Name of the transformation definition table for linear normalization. You can use the <a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
 COL       VARCHAR2(30)
 SHIFT     NUMBER
 SCALE     NUMBER
</pre>
<p><code>CREATE_NORM_LIN</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_NORM_LIN_SCALE</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t54" headers="r1c1-t54">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t54 r1c2-t54">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t54" headers="r1c1-t54">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t54 r1c2-t54">
<p>List of <code>NUMBER</code> columns to be excluded from normalization. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>NUMBER</code> columns are transformed.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t54" headers="r1c1-t54">
<p><code>round_num</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t54 r1c2-t54">
<p>The number of significant digits to use for <code><span class="codeinlineitalic">scale</span></code>. The default number is 6.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t54" headers="r1c1-t54">
<p><code>norm_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t54 r1c2-t54">
<p>Schema of <code><span class="codeinlineitalic">norm_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t54" headers="r1c1-t54">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t54 r1c2-t54">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2759"></a>Examples</p>
<p>In this example, <code>INSERT_NORM_LIN_SCALE</code> normalizes the <code>cust_year_of_birth</code> column and inserts the transformation in a transformation definition table. The <a href="#BABFAFCH">STACK_NORM_LIN Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
      SELECT cust_id, cust_gender, cust_year_of_birth
      FROM sh.customers;

DESCRIBE mining_data
 Name                               Null?    Type
 ---------------------------------- -------- ------------------
 CUST_ID                            NOT NULL NUMBER
 CUST_GENDER                        NOT NULL CHAR(1)
 CUST_YEAR_OF_BIRTH                 NOT NULL NUMBER(4)
 
BEGIN
   dbms_data_mining_transform.CREATE_NORM_LIN(
       norm_table_name  =&gt; 'norm_tbl');
       dbms_data_mining_transform.INSERT_NORM_LIN_SCALE(
       norm_table_name  =&gt; 'norm_tbl',
       data_table_name  =&gt; 'mining_data',
       exclude_list     =&gt; dbms_data_mining_transform.COLUMN_LIST( 'cust_id'),
       round_num        =&gt; 3);
 END;
 /
 
SELECT col, shift, scale FROM norm_tbl;
 
COL                  SHIFT SCALE
-------------------- ----- -----
CUST_YEAR_OF_BIRTH       0  1990
 
DECLARE
    xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
    dbms_data_mining_transform.STACK_NORM_LIN (
        norm_table_name    =&gt; 'norm_tbl',
        xform_list        =&gt; xforms);
    dbms_data_mining_transform.XFORM_STACK (
        xform_list         =&gt; xforms,
        data_table_name    =&gt; 'mining_data',
        xform_view_name    =&gt; 'mining_data_stack');
END;
/
 
set long 3000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_GENDER",("CUST_YEAR_OF_BIRTH"-0)/1990 "CUST_YEAR_OF_BIRTH
" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73050" class="refsect2"><a id="BABDCGGH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2760"></a>INSERT_NORM_LIN_ZSCORE Procedure</h3>
<p>This procedure performs linear normalization and inserts the transformation definitions in a transformation definition table. <code>INSERT_NORM_LIN_ZSCORE</code> computes the mean and the standard deviation from the data and sets the value of <code><span class="codeinlineitalic">shift</span></code> and <code><span class="codeinlineitalic">scale</span></code> as follows:</p>
<pre>
<span class="italic">shift</span> = mean
<span class="italic">scale</span> = stddev
</pre>
<p>Normalization is computed as:</p>
<pre>
<span class="italic">x_new</span> = (<span class="italic">x_old - shift</span>)/<span class="italic">scale</span>
</pre>
<p><code>INSERT_NORM_LIN_ZSCORE</code> rounds the value of <code><span class="codeinlineitalic">scale</span></code> to a specified number of significant digits before storing it in the transformation definition table.</p>
<p><code>INSERT_NORM_LIN_ZSCORE</code> normalizes all the <code>NUMBER</code> and <code>FLOAT</code> columns in the data unless you specify a list of columns to ignore.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2761"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.INSERT_NORM_LIN_ZSCORE (
     norm_table_name     IN VARCHAR2,
     data_table_name     IN VARCHAR2,
     exclude_list        IN COLUMN_LIST DEFAULT NULL,
     round_num           IN PLS_INTEGER DEFAULT 6,
     norm_schema_name    IN VARCHAR2 DEFAULT NULL,
     data_schema_name    IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2762"></a>Parameters</p>
<div id="ARPLS73051" class="tblformal">
<p class="titleintable"><a id="sthref2763"></a><a id="sthref2764"></a>Table 45-31 INSERT_NORM_LIN_ZSCORE Procedure Parameters</p>
<table class="cellalignment1229" title="INSERT_NORM_LIN_ZSCORE Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.INSERT_BIN_NORM_LIN_ZSCORE." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t55">Parameter</th>
<th class="cellalignment1227" id="r1c2-t55">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t55" headers="r1c1-t55">
<p><code>norm_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t55 r1c2-t55">
<p>Name of the transformation definition table for linear normalization. You can use the <a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a> to create the definition table. The following columns are required:</p>
<pre>
 COL       VARCHAR2(30)
 SHIFT     NUMBER
 SCALE     NUMBER
</pre>
<p><code>CREATE_NORM_LIN</code> creates an additional column, <code>ATT</code>, which may be used for specifying nested attributes. This column is not used by <code>INSERT_NORM_LIN_ZSCORE</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t55" headers="r1c1-t55">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t55 r1c2-t55">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t55" headers="r1c1-t55">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t55 r1c2-t55">
<p>List of <code>NUMBER</code> columns to be excluded from normalization. If you do not specify <code><span class="codeinlineitalic">exclude_list</span></code>, all <code>NUMBER</code> columns are transformed.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t55" headers="r1c1-t55">
<p><code>round_num</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t55 r1c2-t55">
<p>The number of significant digits to use for <code><span class="codeinlineitalic">scale</span></code>. The default number is 6.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t55" headers="r1c1-t55">
<p><code>norm_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t55 r1c2-t55">
<p>Schema of <code><span class="codeinlineitalic">norm_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t55" headers="r1c1-t55">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t55 r1c2-t55">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2765"></a>Examples</p>
<p>In this example, <code>INSERT_NORM_LIN_ZSCORE</code> normalizes the <code>cust_year_of_birth</code> column and inserts the transformation in a transformation definition table. The <a href="#BABFAFCH">STACK_NORM_LIN Procedure</a> creates a transformation list from the contents of the definition table.</p>
<p>The SQL expression that computes the transformation is shown in the view <code>MINING_DATA_STACK</code>. The view is for display purposes only; it cannot be used to embed the transformations in a model.</p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, cust_gender, cust_year_of_birth
       FROM sh.customers;
 
DESCRIBE mining_data
 Name                                Null?    Type
 ----------------------------------- -------- --------------------
 CUST_ID                             NOT NULL NUMBER
 CUST_GENDER                         NOT NULL CHAR(1)
 CUST_YEAR_OF_BIRTH                  NOT NULL NUMBER(4)
 
BEGIN
    dbms_data_mining_transform.CREATE_NORM_LIN(
       norm_table_name  =&gt; 'norm_tbl');
       dbms_data_mining_transform.INSERT_NORM_LIN_ZSCORE(
       norm_table_name  =&gt; 'norm_tbl',
       data_table_name  =&gt; 'mining_data',
       exclude_list     =&gt; dbms_data_mining_transform.COLUMN_LIST( 'cust_id'),
       round_num        =&gt; 3);
END;
/
 
SELECT col, shift, scale FROM norm_tbl;
 
COL                  SHIFT SCALE
-------------------- ----- -----
CUST_YEAR_OF_BIRTH    1960    15
 
DECLARE
    xforms      dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
    dbms_data_mining_transform.STACK_NORM_LIN (
        norm_table_name    =&gt; 'norm_tbl',
        xform_list        =&gt; xforms);
    dbms_data_mining_transform.XFORM_STACK (
        xform_list         =&gt; xforms,
        data_table_name    =&gt; 'mining_data',
        xform_view_name    =&gt; 'mining_data_stack');
END;
/
 
set long 3000
SQL&gt; SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_STACK';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_GENDER",("CUST_YEAR_OF_BIRTH"-1960)/15 "CUST_YEAR_OF_BIRT
H" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73052" class="refsect2"><a id="CACJDFJC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2766"></a>SET_EXPRESSION Procedure</h3>
<p>This procedure appends a row to a <code>VARCHAR2</code> array that stores a SQL expression. The array can be used for specifying a transformation expression that is too long to be used with the <a href="#BABJIIIE">SET_TRANSFORM Procedure</a>.</p>
<p>The <a href="#BABGDGIA">GET_EXPRESSION Function</a> returns a row in the array.</p>
<p>When you use <code>SET_EXPRESSION</code> to build a transformation expression, you must build a corresponding reverse transformation expression, create a transformation record, and add the transformation record to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2767"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.SET_EXPRESSION (
           expression    IN OUT NOCOPY EXPRESSION_REC,
           chunk                       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2768"></a>Parameters</p>
<div id="ARPLS73053" class="tblformal">
<p class="titleintable"><a id="sthref2769"></a><a id="sthref2770"></a>Table 45-32 SET_EXPRESSION Procedure Parameters</p>
<table class="cellalignment1229" title="SET_EXPRESSION Procedure Parameters" summary="Description of parameters of SET_EXPRESSION procedure" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t56">Parameter</th>
<th class="cellalignment1227" id="r1c2-t56">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t56" headers="r1c1-t56">
<p><code>expression</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t56 r1c2-t56">
<p>An expression record (<code>EXPRESSION_REC</code>) that specifies a transformation expression or a reverse transformation expression for an attribute. Each expression record includes a <code>VARCHAR2</code> array and index fields for specifying upper and lower boundaries within the array.</p>
<p>There are two <code>EXPRESSION_REC</code> fields within a transformation record (<code>TRANSFORM_REC</code>): one for the transformation expression; the other for the reverse transformation expression.</p>
<p>See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>EXPRESSION_REC</code> type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t56" headers="r1c1-t56">
<p><code>chunk</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t56 r1c2-t56">
<p>A <code>VARCHAR2</code> chunk (row) to be appended to <code><span class="codeinlineitalic">expression</span></code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2771"></a>Notes</p>
<ol>
<li>
<p>You can pass <code>NULL</code> in the <code><span class="codeinlineitalic">chunk</span></code> argument to <code>SET_EXPRESSION</code> to clear the previous chunk. The default value of <code><span class="codeinlineitalic">chunk</span></code> is <code>NULL</code>.</p>
</li>
<li>
<p>See <a href="#CACHEGJD">"About Transformation Lists"</a>.</p>
</li>
<li>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2772"></a>Examples</p>
<p>In this example, two calls to <code>SET_EXPRESSION</code> construct a transformation expression and two calls construct the reverse transformation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example is for illustration purposes only. It shows how <code>SET_EXPRESSION</code> appends the text provided in <code><span class="codeinlineitalic">chunk</span></code> to the text that already exists in <code><span class="codeinlineitalic">expression</span></code>. The <code>SET_EXPRESSION</code> procedure is meant for constructing very long transformation expressions that cannot be specified in a <code>VARCHAR2</code> argument to <code>SET_TRANSFORM</code>.
<p>Similarly while transformation lists are intended for embedding in a model, the transformation list <code>v_xlst</code> is shown in an external view for illustration purposes.</p>
</div>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, cust_year_of_birth, cust_postal_code, cust_credit_limit
       FROM sh.customers;
 
DECLARE
        v_expr dbms_data_mining_transform.EXPRESSION_REC;
        v_rexp dbms_data_mining_transform.EXPRESSION_REC;
        v_xrec dbms_data_mining_transform.TRANSFORM_REC;
        v_xlst dbms_data_mining_transform.TRANSFORM_LIST :=
                                dbms_data_mining_transform.TRANSFORM_LIST(NULL);
BEGIN
    dbms_data_mining_transform.SET_EXPRESSION(
         EXPRESSION  =&gt; v_expr,
         CHUNK       =&gt; '("CUST_YEAR_OF_BIRTH"-1910)');
    dbms_data_mining_transform.SET_EXPRESSION(
          EXPRESSION  =&gt; v_expr,
          CHUNK       =&gt; '/77');
    dbms_data_mining_transform.SET_EXPRESSION(
          EXPRESSION  =&gt; v_rexp,
          CHUNK       =&gt; '"CUST_YEAR_OF_BIRTH"*77');
    dbms_data_mining_transform.SET_EXPRESSION(
          EXPRESSION  =&gt; v_rexp,
          CHUNK       =&gt; '+1910');
 
    v_xrec := null;
    v_xrec.attribute_name := 'CUST_YEAR_OF_BIRTH';
    v_xrec.expression := v_expr;
    v_xrec.reverse_expression := v_rexp;
    v_xlst.TRIM;
    v_xlst.extend(1);
    v_xlst(1) := v_xrec;
 
    dbms_data_mining_transform.XFORM_STACK (
        xform_list           =&gt;  v_xlst,
        data_table_name      =&gt; 'mining_data',
        xform_view_name      =&gt; 'v_xlst_view');
 
    dbms_output.put_line('====');
    FOR i IN 1..v_xlst.count LOOP
      dbms_output.put_line('ATTR: '||v_xlst(i).attribute_name);
      dbms_output.put_line('SUBN: '||v_xlst(i).attribute_subname);
      FOR j IN v_xlst(i).expression.lb..v_xlst(i).expression.ub LOOP
        dbms_output.put_line('EXPR: '||v_xlst(i).expression.lstmt(j));
      END LOOP;
      FOR j IN v_xlst(i).reverse_expression.lb..
                v_xlst(i).reverse_expression.ub LOOP
        dbms_output.put_line('REXP: '||v_xlst(i).reverse_expression.lstmt(j));
      END LOOP;
      dbms_output.put_line('====');
    END LOOP;
  END;
/
====
ATTR: CUST_YEAR_OF_BIRTH
SUBN:
EXPR: ("CUST_YEAR_OF_BIRTH"-1910)
EXPR: /77
REXP: "CUST_YEAR_OF_BIRTH"*77
REXP: +1910
====
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73054" class="refsect2"><a id="BABJIIIE"></a>
<hr />
<h3 class="refsect2"><a id="sthref2773"></a>SET_TRANSFORM Procedure</h3>
<p>This procedure appends the transformation instructions for an attribute to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2774"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.SET_TRANSFORM (
          xform_list               IN OUT NOCOPY TRANSFORM_LIST,
          attribute_name           VARCHAR2,
          attribute_subname        VARCHAR2,
          expression               VARCHAR2,
          reverse_expression       VARCHAR2,
          attribute_spec           VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2775"></a>Parameters</p>
<div id="ARPLS73055" class="tblformal">
<p class="titleintable"><a id="sthref2776"></a><a id="sthref2777"></a>Table 45-33 SET_TRANSFORM Procedure Parameters</p>
<table class="cellalignment1229" title="SET_TRANSFORM Procedure Parameters" summary="Parameters of the SET_TRANSFORM procedure" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t58">Parameter</th>
<th class="cellalignment1227" id="r1c2-t58">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t58" headers="r1c1-t58">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t58 r1c2-t58">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a>for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t58" headers="r1c1-t58">
<p><code>attribute_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t58 r1c2-t58">
<p>Name of the attribute to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t58" headers="r1c1-t58">
<p><code>attribute_subname</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t58 r1c2-t58">
<p>Name of the nested attribute if <code><span class="codeinlineitalic">attribute_name</span></code> is a nested column, otherwise <code>NULL</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t58" headers="r1c1-t58">
<p><code>expression</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t58 r1c2-t58">
<p>A SQL expression that specifies the transformation of the attribute.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t58" headers="r1c1-t58">
<p><code>reverse_expression</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t58 r1c2-t58">
<p>A SQL expression that reverses the transformation for readability in model details and in the target of a supervised model (if the attribute is a target)</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t58" headers="r1c1-t58">
<p><code>attribute_spec</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t58 r1c2-t58">
<p>You can specify the value <code>NOPREP</code> for <code>attribute_spec</code> to prevent this attribute from being automatically transformed when Automatic Data Preparation is being used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2778"></a>Usage Notes</p>
<ol>
<li>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</li>
<li>
<p>As shown in the following example, you can eliminate an attribute by specifying a null transformation expression and reverse expression. You can also use the STACK interface to remove a column (<a href="#BABGCDCC">CREATE_COL_REM Procedure</a> and <a href="#CACHCDCH">STACK_COL_REM Procedure</a>).</p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div id="ARPLS73355" class="refsect3"><a id="sthref2779"></a>
<h4 class="refsect3">Examples</h4>
<p>This example uses <code>SET_TRANSFORM</code> to append transformations to <code>cust_stack</code> for the data set <code>cust_info</code> and displays one row of the transformed data.</p>
<p><code>SET_TRANSFORM</code> divides the <code>country_id</code> column by 10, removes the <code>cust_year_of_birth</code> column, and multiplies the nested attribute'<code>custprods.mouse pad</code>' by 10. (See <a href="#BABIIFEF">"DESCRIBE_STACK Procedure"</a> for the definition of <code>cust_info</code>.)</p>
<pre>
describe cust_info
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 CUST_ID                                   NOT NULL NUMBER
 COUNTRY_ID                                NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                        NOT NULL NUMBER(4)
 CUSTPRODS                                          SYS.DM_NESTED_NUMERICALS

DECLARE
  cust_stack   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
  dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
     'country_id', NULL, 'country_id/10', 'country_id*10');
  dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
      'cust_year_of_birth', NULL, NULL, NULL);
  dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
      'custprods', 'Mouse Pad', 'value*100', 'value/100');
  dbms_data_mining_transform.XFORM_STACK (cust_stack,
     'cust_info', 'xform_cust_view');
END;
/

select * from xform_cust_view where cust_id = 100004;
 
CUST_ID  COUNTRY_ID  CUSTPRODS(ATTRIBUTE_NAME, VALUE)
-------  ----------  ----------------------------------------------
100004         5279  DM_NESTED_NUMERICALS(DM_NESTED_NUMERICAL
                     ('External 8X CD-ROM', 1),
                     DM_NESTED_NUMERICAL('Keyboard Wrist Rest', 1))
</pre></div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73137" class="refsect2"><a id="CACJCHHI"></a>
<hr />
<h3 class="refsect2"><a id="sthref2780"></a>STACK_BIN_CAT Procedure</h3>
<p>This procedure adds categorical binning transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2781"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_BIN_CAT (
     bin_table_name     IN            VARCHAR2,
     xform_list         IN OUT NOCOPY TRANSFORM_LIST,
     literal_flag       IN            BOOLEAN  DEFAULT FALSE,
     bin_schema_name    IN            VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2782"></a>Parameters</p>
<div id="ARPLS73138" class="tblformal">
<p class="titleintable"><a id="sthref2783"></a><a id="sthref2784"></a>Table 45-34 STACK_BIN_CAT Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_BIN_CAT Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.STACK_BIN_CAT." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t59">Parameter</th>
<th class="cellalignment1227" id="r1c2-t59">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t59" headers="r1c1-t59">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t59 r1c2-t59">
<p>Name of the transformation definition table for categorical binning. You can use the <a href="#BABHJHJF">CREATE_BIN_CAT Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>STACK_BIN_CAT</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for categorical binning or you can write your own SQL.</p>
<p>See <a href="#BABBHJED">Table 45-4, "Columns in a Transformation Definition Table for Categorical Binning"</a></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t59" headers="r1c1-t59">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t59 r1c2-t59">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t59" headers="r1c1-t59">
<p><code>literal_flag</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t59 r1c2-t59">
<p>Indicates whether the values in the <code>bin</code> column in the transformation definition table are valid SQL literals. When <code><span class="codeinlineitalic">literal_flag</span></code> is <code>FALSE</code> (the default), the bin identifiers will be transformed to SQL literals by surrounding them with single quotes.</p>
<p>Set literal_flag to <code>TRUE</code> if the bin identifiers are numbers that should have a numeric data type, as is the case for an O-Cluster model.</p>
<p>See <a href="#BABEFAIC">"INSERT_BIN_NUM_EQWIDTH Procedure"</a> for an example.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t59" headers="r1c1-t59">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t59 r1c2-t59">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2785"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2786"></a>Examples</p>
<p>This example shows how a binning transformation for the categorical column <code>cust_postal_code</code> could be added to a stack called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
CREATE or REPLACE VIEW mining_data AS
    SELECT cust_id, cust_postal_code, cust_credit_limit
       FROM sh.customers
       WHERE cust_id BETWEEN 100050 AND 100100;
BEGIN
   dbms_data_mining_transform.CREATE_BIN_CAT ('bin_cat_tbl');
   dbms_data_mining_transform.INSERT_BIN_CAT_FREQ (
        bin_table_name   =&gt; 'bin_cat_tbl',
        data_table_name  =&gt; 'mining_data',
        bin_num          =&gt;  3);
  END;
/
DECLARE
  MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
  dbms_data_mining_transform.STACK_BIN_CAT (
    bin_table_name       =&gt; 'bin_cat_tbl',
    xform_list           =&gt;  mining_data_stack);
  dbms_data_mining_transform.XFORM_STACK (
    xform_list           =&gt;  mining_data_stack,
    data_table_name      =&gt; 'mining_data',
    xform_view_name      =&gt; 'mining_data_stack_view');
  END;
/
-- Before transformation
column cust_postal_code format a16
SELECT * from mining_data 
              WHERE cust_id BETWEEN 100050 AND 100053
              ORDER BY cust_id;

  CUST_ID CUST_POSTAL_CODE CUST_CREDIT_LIMIT
---------- ---------------- -----------------
    100050 76486                         1500
    100051 73216                         9000
    100052 69499                         5000
    100053 45704                         7000

-- After transformation
SELECT * FROM mining_data_stack_view
              WHERE cust_id BETWEEN 100050 AND 100053
              ORDER BY cust_id;
 
  CUST_ID CUST_POSTAL_CODE CUST_CREDIT_LIMIT
---------- ---------------- -----------------
    100050 4                             1500
    100051 1                             9000
    100052 4                             5000
    100053 4                             7000
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73139" class="refsect2"><a id="CACEGEHI"></a>
<hr />
<h3 class="refsect2"><a id="sthref2787"></a>STACK_BIN_NUM Procedure</h3>
<p>This procedure adds numerical binning transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2788"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_BIN_NUM (
     bin_table_name     IN             VARCHAR2,
     xform_list         IN OUT  NOCOPY TRANSFORM_LIST,
     literal_flag       IN             BOOLEAN  DEFAULT FALSE,
     bin_schema_name    IN             VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2789"></a>Parameters</p>
<div id="ARPLS73140" class="tblformal">
<p class="titleintable"><a id="sthref2790"></a><a id="sthref2791"></a>Table 45-35 STACK_BIN_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_BIN_NUM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.STACK_BIN_NUM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t61">Parameter</th>
<th class="cellalignment1227" id="r1c2-t61">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t61" headers="r1c1-t61">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t61 r1c2-t61">
<p>Name of the transformation definition table for numerical binning. You can use the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>STACK_BIN_NUM</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for numerical binning or you can write your own SQL.</p>
<p>See <a href="#BABGAIEI">Table 45-6, "Columns in a Transformation Definition Table for Numerical Binning"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t61" headers="r1c1-t61">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t61 r1c2-t61">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t61" headers="r1c1-t61">
<p><code>literal_flag</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t61 r1c2-t61">
<p>Indicates whether the values in the <code>bin</code> column in the transformation definition table are valid SQL literals. When <code><span class="codeinlineitalic">literal_flag</span></code> is <code>FALSE</code> (the default), the bin identifiers will be transformed to SQL literals by surrounding them with single quotes.</p>
<p>Set literal_flag to <code>TRUE</code> if the bin identifiers are numbers that should have a numeric data type, as is the case for an O-Cluster model.</p>
<p>See <a href="#BABEFAIC">"INSERT_BIN_NUM_EQWIDTH Procedure"</a> for an example.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t61" headers="r1c1-t61">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t61 r1c2-t61">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2792"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2793"></a>Examples</p>
<p>This example shows how a binning transformation for the numerical column <code>cust_credit_limit</code> could be added to a stack called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
CREATE OR REPLACE VIEW mining_data AS
    SELECT cust_id, cust_postal_code, cust_credit_limit
      FROM sh.customers
      WHERE cust_id BETWEEN 100050 and 100100;
BEGIN
  dbms_data_mining_transform.create_bin_num ('bin_num_tbl');
  dbms_data_mining_transform.insert_bin_num_qtile (
  bin_table_name    =&gt; 'bin_num_tbl',
  data_table_name   =&gt; 'mining_data',
  bin_num                   =&gt; 5,
  exclude_list      =&gt;  dbms_data_mining_transform.COLUMN_LIST('cust_id'));
END;
/
DECLARE
   MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
   dbms_data_mining_transform.STACK_BIN_CAT (
      bin_table_name          =&gt; 'bin_num_tbl',
      xform_list         =&gt;  mining_data_stack);
   dbms_data_mining_transform.XFORM_STACK (
      xform_list         =&gt;  mining_data_stack,
      data_table_name   =&gt; 'mining_data',
      xform_view_name   =&gt; 'mining_data_stack_view');
END;
/
-- Before transformation
SELECT cust_id, cust_postal_code, ROUND(cust_credit_limit) FROM mining_data
   WHERE cust_id BETWEEN 100050 AND 100055
   ORDER BY cust_id;
CUST_ID   CUST_POSTAL_CODE   ROUND(CUST_CREDIT_LIMIT)
-------   -----------------  -------------------------
100050    76486                                 1500
100051    73216                                 9000 
100052    69499                                 5000
100053    45704                                 7000
100055    74673                                11000
100055    74673                                11000

-- After transformation
SELECT cust_id, cust_postal_code, ROUND(cust_credit_limit)
   FROM mining_data_stack_view
   WHERE cust_id BETWEEN 100050 AND 100055
   ORDER BY cust_id;
CUST_ID   CUST_POSTAL_CODE   ROUND(CUST_CREDIT_LIMITT)
-------   ----------------   -------------------------
100050    76486                                     
100051    73216                                   2
100052    69499                                   1
100053    45704                                   
100054    88021                                   3
100055    74673                                   3
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73141" class="refsect2"><a id="CACHGHIG"></a>
<hr />
<h3 class="refsect2"><a id="sthref2794"></a>STACK_CLIP Procedure</h3>
<p>This procedure adds clipping transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2795"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_CLIP (
          clip_table_name     IN            VARCHAR2,
          xform_list          IN OUT NOCOPY TRANSFORM_LIST,
          clip_schema_name    IN            VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2796"></a>Parameters</p>
<div id="ARPLS73142" class="tblformal">
<p class="titleintable"><a id="sthref2797"></a><a id="sthref2798"></a>Table 45-36 STACK_CLIP Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_CLIP Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.STACK_CLIP." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t63">Parameter</th>
<th class="cellalignment1227" id="r1c2-t63">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t63" headers="r1c1-t63">
<p><code>clip_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t63 r1c2-t63">
<p>Name of the transformation definition table for clipping.You can use the <a href="#BABCFGBC">CREATE_CLIP Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>STACK_CLIP</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for clipping or you can write your own SQL.</p>
<p>See <a href="#BABGECBI">Table 45-8, "Columns in a Transformation Definition Table for Clipping or Winsorizing"</a></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t63" headers="r1c1-t63">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t63 r1c2-t63">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t63" headers="r1c1-t63">
<p><code>clip_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t63 r1c2-t63">
<p>Schema of <code><span class="codeinlineitalic">clip_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2799"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2800"></a>Examples</p>
<p>This example shows how a clipping transformation for the numerical column <code>cust_credit_limit</code> could be added to a stack called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, cust_postal_code, cust_credit_limit
       FROM sh.customers
       WHERE cust_id BETWEEN 100050 AND 100100;
BEGIN
   dbms_data_mining_transform.create_clip ('clip_tbl');
   dbms_data_mining_transform.insert_clip_winsor_tail (
       clip_table_name   =&gt; 'clip_tbl',
       data_table_name   =&gt; 'mining_data',
       tail_frac         =&gt; 0.25,
       exclude_list      =&gt; dbms_data_mining_transform.COLUMN_LIST('cust_id'));
END;
/
DECLARE
      MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
      dbms_data_mining_transform.STACK_CLIP (
         clip_table_name     =&gt; 'clip_tbl',
         xform_list          =&gt;  mining_data_stack);
      dbms_data_mining_transform.XFORM_STACK (
          xform_list        =&gt;  mining_data_stack,
          data_table_name   =&gt; 'mining_data',
          xform_view_name   =&gt; 'mining_data_stack_view');
END;
/
-- Before transformation
SELECT cust_id, cust_postal_code, round(cust_credit_limit) 
  FROM mining_data
    WHERE cust_id BETWEEN 100050 AND 100054
    ORDER BY cust_id;
    
CUST_ID   CUST_POSTAL_CODE   ROUND(CUST_CREDIT_LIMIT)
-------   ----------------   ------------------------ 
100050    76486                                 1500 
100051    73216                                 9000 
100052    69499                                 5000 
100053    45704                                 7000 
100054    88021                                11000 
 
-- After transformation
SELECT cust_id, cust_postal_code, round(cust_credit_limit)  
  FROM mining_data_stack_view
    WHERE cust_id BETWEEN 100050 AND 100054
    ORDER BY cust_id;
    
CUST_ID   CUST_POSTAL_CODE   ROUND(CUST_CREDIT_LIMIT)
-------   ----------------   ------------------------
100050    76486                                 5000
100051    73216                                 9000
100052    69499                                 5000
100053    45704                                 7000
100054    88021                                11000
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73143" class="refsect2"><a id="CACHCDCH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2801"></a>STACK_COL_REM Procedure</h3>
<p>This procedure adds column removal transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2802"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_COL_REM (
     rem_table_name     IN            VARCHAR2,
     xform_list         IN OUT NOCOPY TRANSFORM_LIST,
     rem_schema_name    IN            VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2803"></a>Parameters</p>
<div id="ARPLS73144" class="tblformal">
<p class="titleintable"><a id="sthref2804"></a><a id="sthref2805"></a>Table 45-37 STACK_COL_REM Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_COL_REM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.STACK_COL_REM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t65">Parameter</th>
<th class="cellalignment1227" id="r1c2-t65">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t65" headers="r1c1-t65">
<p><code>rem_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t65 r1c2-t65">
<p>Name of the transformation definition table for column removal. You can use the <a href="#BABGCDCC">CREATE_COL_REM Procedure</a> to create the definition table. See <a href="#BABBEACJ">Table 45-10, "Columns in a Transformation Definition Table for Column Removal"</a>.</p>
<p>The table must be populated with column names before you call <code>STACK_COL_REM</code>. The <a href="#BABEHBCE">INSERT_BIN_SUPER Procedure</a> and the <a href="#BABJDGIA">INSERT_AUTOBIN_NUM_EQWIDTH Procedure</a> can optionally be used to populate the table. You can also use SQL <code>INSERT</code> statements.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t65" headers="r1c1-t65">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t65 r1c2-t65">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t65" headers="r1c1-t65">
<p><code>rem_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t65 r1c2-t65">
<p>Schema of <code><span class="codeinlineitalic">rem_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2806"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2807"></a>Examples</p>
<p>This example shows how the column <code>cust_credit_limit</code> could be removed in a transformation list called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
CREATE OR REPLACE VIEW mining_data AS
     SELECT cust_id, country_id, cust_postal_code, cust_credit_limit
        FROM sh.customers;
 
BEGIN
    dbms_data_mining_transform.create_col_rem ('rem_tbl');
END;
/

INSERT into rem_tbl VALUES (upper('cust_postal_code'), null);
 
DECLARE
  MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
     dbms_data_mining_transform.stack_col_rem (
          rem_table_name     =&gt; 'rem_tbl',
          xform_list         =&gt;  mining_data_stack);
      dbms_data_mining_transform.XFORM_STACK (
          xform_list         =&gt;  mining_data_stack,
          data_table_name    =&gt; 'mining_data',
          xform_view_name    =&gt; 'mining_data_stack_view');
END;
/
 
SELECT *  FROM mining_data
  WHERE cust_id BETWEEN 100050 AND 100051
  ORDER BY cust_id;
 
CUST_ID   COUNTRY_ID   CUST_POSTAL_CODE   CUST_CREDIT_LIMIT
-------   ----------   ----------------   -----------------
100050         52773   76486                          1500
100051         52790   73216                          9000
 
SELECT *  FROM mining_data_stack_view
  WHERE cust_id BETWEEN 100050 AND 100051
  ORDER BY cust_id;
 
CUST_ID   COUNTRY_ID   CUST_CREDIT_LIMIT
-------   ----------   -----------------
100050         52773              1500
100051         52790              9000
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73064" class="refsect2"><a id="BABJGBGH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2808"></a>STACK_MISS_CAT Procedure</h3>
<p>This procedure adds categorical missing value transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2809"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_MISS_CAT (
     miss_table_name     IN       VARCHAR2,
     xform_list          IN OUT   NOCOPY TRANSFORM_LIST,
     miss_schema_name    IN       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2810"></a>Parameters</p>
<div id="ARPLS73065" class="tblformal">
<p class="titleintable"><a id="sthref2811"></a><a id="sthref2812"></a>Table 45-38 STACK_MISS_CAT Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_MISS_CAT Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.STACK_MISS_CAT." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t67">Parameter</th>
<th class="cellalignment1227" id="r1c2-t67">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t67" headers="r1c1-t67">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t67 r1c2-t67">
<p>Name of the transformation definition table for categorical missing value treatment. You can use the <a href="#BABHJFDC">CREATE_MISS_CAT Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>STACK_MISS_CAT</code>. To populate the table, you can use the <a href="#BABJCGCA">INSERT_MISS_CAT_MODE Procedure</a> or you can write your own SQL.</p>
<p>See <a href="#BABJBBGD">Table 45-12, "Columns in a Transformation Definition Table for Categorical Missing Value Treatment"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t67" headers="r1c1-t67">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t67 r1c2-t67">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t67" headers="r1c1-t67">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t67 r1c2-t67">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2813"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2814"></a>Examples</p>
<p>This example shows how the missing values in the column <code>cust_marital_status</code> could be replaced with the mode in a transformation list called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
CREATE OR REPLACE VIEW mining_data AS
      SELECT cust_id, country_id, cust_marital_status
         FROM sh.customers
         where cust_id BETWEEN 1 AND 10;
 
BEGIN
  dbms_data_mining_transform.create_miss_cat ('miss_cat_tbl');
  dbms_data_mining_transform.insert_miss_cat_mode ('miss_cat_tbl', 'mining_data');
END;
/
 
DECLARE
  MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
     dbms_data_mining_transform.stack_miss_cat (
          miss_table_name   =&gt; 'miss_cat_tbl',
          xform_list        =&gt; mining_data_stack);
      dbms_data_mining_transform.XFORM_STACK (
          xform_list        =&gt;  mining_data_stack,
          data_table_name   =&gt; 'mining_data',
          xform_view_name   =&gt; 'mining_data_stack_view');
END;
/
SELECT * FROM mining_data
  ORDER BY cust_id;
 
CUST_ID   COUNTRY_ID   CUST_MARITAL_STATUS
-------   ----------   --------------------
      1      52789
      2      52778
      3      52770
      4      52770
      5      52789
      6      52769     single
      7      52790     single
      8      52790     married
      9      52770     divorced
     10      52790     widow
 
SELECT * FROM mining_data_stack_view
   ORDER By cust_id;
 
CUST_ID   COUNTRY_ID   CUST_MARITAL_STATUS
-------   -----------  --------------------
      1       52789    single
      2       52778    single
      3       52770    single
      4       52770    single
      5       52789    single
      6       52769    single
      7       52790    single
      8       52790    married
      9       52770    divorced
     10       52790    widow
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73066" class="refsect2"><a id="BABFIBFF"></a>
<hr />
<h3 class="refsect2"><a id="sthref2815"></a>STACK_MISS_NUM Procedure</h3>
<p>This procedure adds numeric missing value transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2816"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_MISS_NUM (
     miss_table_name     IN       VARCHAR2,
     xform_list          IN OUT   NOCOPY TRANSFORM_LIST,
     miss_schema_name    IN       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2817"></a>Parameters</p>
<div id="ARPLS73067" class="tblformal">
<p class="titleintable"><a id="sthref2818"></a><a id="sthref2819"></a>Table 45-39 STACK_MISS_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_MISS_NUM Procedure Parameters" summary="DBMS_DATA_MINING_TRANSFORM.STACK_MISS_NUM parameters" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t69">Parameter</th>
<th class="cellalignment1227" id="r1c2-t69">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t69" headers="r1c1-t69">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t69 r1c2-t69">
<p>Name of the transformation definition table for numerical missing value treatment. You can use the <a href="#BABIEAGA">CREATE_MISS_NUM Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>STACK_MISS_NUM</code>. To populate the table, you can use the <a href="#BABHAHEJ">INSERT_MISS_NUM_MEAN Procedure</a> or you can write your own SQL.</p>
<p>See <a href="#BABBFJIA">Table 45-14, "Columns in a Transformation Definition Table for Numerical Missing Value Treatment"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t69" headers="r1c1-t69">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t69 r1c2-t69">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t69" headers="r1c1-t69">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t69 r1c2-t69">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2820"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2821"></a>Examples</p>
<p>This example shows how the missing values in the column <code>cust_credit_limit</code> could be replaced with the mean in a transformation list called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
describe mining_data
 Name                                                  Null?    Type
 ----------------------------------------------------- -------- -----
 CUST_ID                                               NOT NULL NUMBER
 CUST_CREDIT_LIMIT                                              NUMBER

BEGIN
   dbms_data_mining_transform.create_miss_num ('miss_num_tbl');
   dbms_data_mining_transform.insert_miss_num_mean ('miss_num_tbl','mining_data');
END;
/
SELECT * FROM miss_num_tbl;
 
COL                  ATT      VAL
-------------------- ----- ------
CUST_ID                       5.5
CUST_CREDIT_LIMIT          185.71
 
DECLARE
    MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
  BEGIN
    dbms_data_mining_transform.STACK_MISS_NUM (
          miss_table_name   =&gt; 'miss_num_tbl',
          xform_list        =&gt; mining_data_stack);
    dbms_data_mining_transform.XFORM_STACK (
          xform_list        =&gt;  mining_data_stack,
          data_table_name   =&gt; 'mining_data',
          xform_view_name   =&gt; 'mining_data_stack_view');
END;
/
-- Before transformation
SELECT * FROM mining_data
  ORDER BY cust_id;
CUST_ID CUST_CREDIT_LIMIT
------- -----------------
      1               100
      2
      3               200
      4
      5               150
      6               400
      7               150
      8
      9               100
     10               200
 
-- After transformation
SELECT * FROM mining_data_stack_view
  ORDER BY cust_id;
CUST_ID CUST_CREDIT_LIMIT
------- -----------------
      1               100
      2            185.71
      3               200
      4            185.71
      5               150
      6               400
      7               150
      8            185.71
      9               100
     10               200
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73068" class="refsect2"><a id="BABFAFCH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2822"></a>STACK_NORM_LIN Procedure</h3>
<p>This procedure adds linear normalization transformations to a transformation list.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2823"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.STACK_NORM_LIN (
     norm_table_name     IN       VARCHAR2,
     xform_list          IN OUT   NOCOPY TRANSFORM_LIST,
     norm_schema_name    IN       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2824"></a>Parameters</p>
<div id="ARPLS73069" class="tblformal">
<p class="titleintable"><a id="sthref2825"></a><a id="sthref2826"></a>Table 45-40 STACK_NORM_LIN Procedure Parameters</p>
<table class="cellalignment1229" title="STACK_NORM_LIN Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.STACK_NORM_LIN." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t71">Parameter</th>
<th class="cellalignment1227" id="r1c2-t71">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t71" headers="r1c1-t71">
<p><code>norm_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t71 r1c2-t71">
<p>Name of the transformation definition table for linear normalization. You can use the <a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>STACK_NORM_LIN</code>.To populate the table, you can use one of the <code>INSERT</code> procedures for normalization or you can write your own SQL.</p>
<p>See <a href="#BABHBHHD">Table 45-16, "Columns in a Transformation Definition Table for Linear Normalization"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t71" headers="r1c1-t71">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t71 r1c2-t71">
<p>A transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t71" headers="r1c1-t71">
<p><code>norm_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t71 r1c2-t71">
<p>Schema of <code><span class="codeinlineitalic">norm_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2827"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2828"></a>Examples</p>
<p>This example shows how the column <code>cust_credit_limit</code> could be normalized in a transformation list called <code>mining_data_stack</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example invokes the <a href="#BABIHDCC">XFORM_STACK Procedure</a> to show how the data is transformed by the stack. <code>XFORM_STACK</code> simply generates an external view of the transformed data. The actual purpose of the <code>STACK</code> procedures is to assemble a list of transformations for embedding in a model. The transformations are passed to <code>CREATE_MODEL</code> in the <code>xform_list</code> parameter. See <a href="#BABEFAIC">INSERT_BIN_NUM_EQWIDTH Procedure</a> for an example.</div>
<pre>
CREATE OR REPLACE VIEW mining_data AS
       SELECT cust_id, country_id, cust_postal_code, cust_credit_limit
          FROM sh.customers;
BEGIN
   dbms_data_mining_transform.create_norm_lin ('norm_lin_tbl');
   dbms_data_mining_transform.insert_norm_lin_minmax (
       norm_table_name   =&gt; 'norm_lin_tbl',
       data_table_name   =&gt; 'mining_data',
       exclude_list      =&gt;  dbms_data_mining_transform.COLUMN_LIST('cust_id',
                                                             'country_id'));
END;
/
SELECT * FROM norm_lin_tbl;
COL                  ATT    SHIFT  SCALE
-------------------- ----- ------ ------
CUST_CREDIT_LIMIT            1500  13500

DECLARE
   MINING_DATA_STACK   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
   dbms_data_mining_transform.stack_norm_lin (
        norm_table_name   =&gt; 'norm_lin_tbl',
        xform_list        =&gt; mining_data_stack);
   dbms_data_mining_transform.XFORM_STACK (
        xform_list        =&gt;  mining_data_stack,
        data_table_name   =&gt; 'mining_data',
        xform_view_name   =&gt; 'mining_data_stack_view');
END;
/
SELECT * FROM mining_data
  WHERE cust_id between 1 and 10
  ORDER BY cust_id;
CUST_ID COUNTRY_ID CUST_POSTAL_CODE     CUST_CREDIT_LIMIT
------- ---------- -------------------- -----------------
      1      52789 30828                             9000
      2      52778 86319                            10000
      3      52770 88666                             1500
      4      52770 87551                             1500
      5      52789 59200                             1500
      6      52769 77287                             1500
      7      52790 38763                             1500
      8      52790 58488                             3000
      9      52770 63033                             3000
     10      52790 52602                             3000
 
SELECT * FROM mining_data_stack_view
  WHERE cust_id between 1 and 10
  ORDER BY cust_id;
CUST_ID COUNTRY_ID CUST_POSTAL_CODE     CUST_CREDIT_LIMIT
------- ---------- -------------------- -----------------
      1      52789 30828                           .55556
      2      52778 86319                           .62963
      3      52770 88666                                0
      4      52770 87551                                0
      5      52789 59200                                0
      6      52769 77287                                0
      7      52790 38763                                0
      8      52790 58488                           .11111
      9      52770 63033                           .11111
     10      52790 52602                           .11111
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73070" class="refsect2"><a id="BABHHBCI"></a>
<hr />
<h3 class="refsect2"><a id="sthref2829"></a>XFORM_BIN_CAT Procedure</h3>
<p>This procedure creates a view that implements the categorical binning transformations specified in a definition table. Only the columns that are specified in the definition table are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2830"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_BIN_CAT (
     bin_table_name       IN VARCHAR2,
     data_table_name      IN VARCHAR2,
     xform_view_name      IN VARCHAR2,
     literal_flag         IN BOOLEAN DEFAULT FALSE,
     bin_schema_name      IN VARCHAR2 DEFAULT NULL,
     data_schema_name     IN VARCHAR2 DEFAULT NULL,
     xform_schema_name    IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2831"></a>Parameters</p>
<div id="ARPLS73071" class="tblformal">
<p class="titleintable"><a id="sthref2832"></a><a id="sthref2833"></a>Table 45-41 XFORM_BIN_CAT Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_BIN_CAT Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_BIN_CAT." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t73">Parameter</th>
<th class="cellalignment1227" id="r1c2-t73">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t73" headers="r1c1-t73">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t73 r1c2-t73">
<p>Name of the transformation definition table for categorical binning. You can use the <a href="#BABHJHJF">CREATE_BIN_CAT Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>XFORM_BIN_CAT</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for categorical binning or you can write your own SQL.</p>
<p>See <a href="#BABBHJED">Table 45-4, "Columns in a Transformation Definition Table for Categorical Binning"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t73" headers="r1c1-t73">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t73 r1c2-t73">
<p>Name of the table containing the data to be transformed.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t73" headers="r1c1-t73">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t73 r1c2-t73">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">bin_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t73" headers="r1c1-t73">
<p><code>literal_flag</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t73 r1c2-t73">
<p>Indicates whether the values in the <code>bin</code> column in the transformation definition table are valid SQL literals. When <code><span class="codeinlineitalic">literal_flag</span></code> is <code>FALSE</code> (the default), the bin identifiers will be transformed to SQL literals by surrounding them with single quotes.</p>
<p>Set literal_flag to <code>TRUE</code> if the bin identifiers are numbers that should have a numeric data type, as is the case for an O-Cluster model.</p>
<p>See <a href="#BABEFAIC">"INSERT_BIN_NUM_EQWIDTH Procedure"</a> for an example.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t73" headers="r1c1-t73">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t73 r1c2-t73">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t73" headers="r1c1-t73">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t73 r1c2-t73">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t73" headers="r1c1-t73">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t73 r1c2-t73">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2834"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2835"></a>Examples</p>
<p>This example creates a view that bins the <code>cust_postal_code</code> column. The data source consists of three columns from <code>sh.customer.</code></p>
<pre>
describe mining_data
 Name                                   Null?    Type
 -------------------------------------- -------- ------------------------
 CUST_ID                                NOT NULL NUMBER
 CUST_POSTAL_CODE                       NOT NULL VARCHAR2(10)
 CUST_CREDIT_LIMIT                               NUMBER
 
SELECT * FROM mining_data WHERE cust_id between 104066 and 104069;
 
   CUST_ID CUST_POSTAL_CODE     CUST_CREDIT_LIMIT                                                   
--------- -------------------- -----------------                                                   
    104066 69776                             7000                                                   
    104067 52602                             9000                                                   
    104068 55787                            11000                                                   
    104069 55977                             5000                                                   
 
BEGIN
  dbms_data_mining_transform.create_bin_cat(
     bin_table_name     =&gt; 'bin_cat_tbl');
  dbms_data_mining_transform.insert_bin_cat_freq(
     bin_table_name     =&gt; 'bin_cat_tbl',
     data_table_name    =&gt; 'mining_data',
     bin_num           =&gt; 10);
   dbms_data_mining_transform.xform_bin_cat(
     bin_table_name     =&gt; 'bin_cat_tbl',
     data_table_name    =&gt; 'mining_data',
     xform_view_name    =&gt; 'bin_cat_view');
END;
/
 
SELECT * FROM bin_cat_view WHERE cust_id between 104066 and 104069;
 
   CUST_ID CUST_POSTAL_CODE     CUST_CREDIT_LIMIT                                                   
---------- -------------------- -----------------                                                   
    104066 6                                 7000                                                   
    104067 11                                9000                                                   
    104068 3                                11000                                                   
    104069 11                                5000                                                   
 
SELECT text FROM user_views WHERE view_name IN 'BIN_CAT_VIEW';
 
TEXT                                                                                                
--------------------------------------------------------------------------------                    
SELECT "CUST_ID",DECODE("CUST_POSTAL_CODE",'38082','1','45704','9','48346','5','                    
55787','3','63736','2','67843','7','69776','6','72860','10','78558','4','80841',                    
'8',NULL,NULL,'11') "CUST_POSTAL_CODE","CUST_CREDIT_LIMIT" FROM mining_data                         
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73072" class="refsect2"><a id="BABJDHDF"></a>
<hr />
<h3 class="refsect2"><a id="sthref2836"></a>XFORM_BIN_NUM Procedure</h3>
<p>This procedure creates a view that implements the numerical binning transformations specified in a definition table. Only the columns that are specified in the definition table are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2837"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_BIN_NUM (
     bin_table_name     IN VARCHAR2,
     data_table_name    IN VARCHAR2,
     xform_view_name    IN VARCHAR2,
     literal_flag       IN BOOLEAN DEFAULT FALSE,
     bin_schema_name    IN VARCHAR2 DEFAULT NULL,
     data_schema_name   IN VARCHAR2 DEFAULT NULL,
     xform_schema_name  IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2838"></a>Parameters</p>
<div id="ARPLS73073" class="tblformal">
<p class="titleintable"><a id="sthref2839"></a><a id="sthref2840"></a>Table 45-42 XFORM_BIN_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_BIN_NUM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_BIN_NUM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t74">Parameter</th>
<th class="cellalignment1227" id="r1c2-t74">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t74" headers="r1c1-t74">
<p><code>bin_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t74 r1c2-t74">
<p>Name of the transformation definition table for numerical binning. You can use the <a href="#BABCJBCG">CREATE_BIN_NUM Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>XFORM_BIN_NUM</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for numerical binning or you can write your own SQL.</p>
<p>See <a href="#BABGAIEI">"Columns in a Transformation Definition Table for Numerical Binning"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t74" headers="r1c1-t74">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t74 r1c2-t74">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t74" headers="r1c1-t74">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t74 r1c2-t74">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">bin_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t74" headers="r1c1-t74">
<p><code>literal_flag</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t74 r1c2-t74">
<p>Indicates whether the values in the <code>bin</code> column in the transformation definition table are valid SQL literals. When <code><span class="codeinlineitalic">literal_flag</span></code> is <code>FALSE</code> (the default), the bin identifiers will be transformed to SQL literals by surrounding them with single quotes.</p>
<p>Set literal_flag to <code>TRUE</code> if the bin identifiers are numbers that should have a numeric data type, as is the case for an O-Cluster model.</p>
<p>See <a href="#BABEFAIC">"INSERT_BIN_NUM_EQWIDTH Procedure"</a> for an example.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t74" headers="r1c1-t74">
<p><code>bin_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t74 r1c2-t74">
<p>Schema of <code><span class="codeinlineitalic">bin_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t74" headers="r1c1-t74">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t74 r1c2-t74">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t74" headers="r1c1-t74">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t74 r1c2-t74">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2841"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2842"></a>Examples</p>
<p>This example creates a view that bins the <code>cust_credit_limit</code> column. The data source consists of three columns from <code>sh.customer.</code></p>
</div>
<!-- class="refsubsect" -->
<pre>
describe mining_data
 Name                                   Null?    Type
 -------------------------------------- -------- ------------------------
 CUST_ID                                NOT NULL NUMBER
 CUST_POSTAL_CODE                       NOT NULL VARCHAR2(10)
 CUST_CREDIT_LIMIT                               NUMBER
 
column cust_credit_limit off
SELECT * FROM mining_data WHERE cust_id between 104066 and 104069;
 
   CUST_ID CUST_POSTAL_CODE   CUST_CREDIT_LIMIT                                         
---------  ------------------  --------------------                                        
    104066 69776                           7000                                         
    104067 52602                           9000                                         
    104068 55787                          11000                                         
    104069 55977                           5000                                         
 
BEGIN
   dbms_data_mining_transform.create_bin_num(
           bin_table_name     =&gt; 'bin_num_tbl');
   dbms_data_mining_transform.insert_autobin_num_eqwidth(
           bin_table_name     =&gt; 'bin_num_tbl',
           data_table_name    =&gt; 'mining_data',
           bin_num                   =&gt; 5,
           max_bin_num            =&gt; 10,
           exclude_list       =&gt; dbms_data_mining_transform.COLUMN_LIST('cust_id'));
  dbms_data_mining_transform.xform_bin_num(
           bin_table_name      =&gt; 'bin_num_tbl',
           data_table_name     =&gt; 'mining_data',
           xform_view_name     =&gt; 'mining_data_view');
END;
/
describe mining_data_view
 Name                                 Null?    Type
 ------------------------------------ -------- ------------------------
 CUST_ID                              NOT NULL NUMBER
 CUST_POSTAL_CODE                     NOT NULL VARCHAR2(10)
 CUST_CREDIT_LIMIT                             VARCHAR2(2)
 
col cust_credit_limit on
col cust_credit_limit format a25
SELECT * FROM mining_data_view WHERE cust_id between 104066 and 104069;
 
   CUST_ID CUST_POSTAL_CODE     CUST_CREDIT_LIMIT                                         
---------- -------------------- -------------------------                                 
    104066 69776                5                                                         
    104067 52602                6                                                         
    104068 55787                8                                                         
    104069 55977                3                                                         
 
set long 2000
SELECT text FROM user_views WHERE view_name IN 'MINING_DATA_VIEW';
 
TEXT                                                                                      
--------------------------------------------------------------------------------          
SELECT "CUST_ID","CUST_POSTAL_CODE",CASE WHEN "CUST_CREDIT_LIMIT"&lt;1500 THEN NULL          
 WHEN "CUST_CREDIT_LIMIT"&lt;=2850 THEN '1' WHEN "CUST_CREDIT_LIMIT"&lt;=4200 THEN '2'          
 WHEN "CUST_CREDIT_LIMIT"&lt;=5550 THEN '3' WHEN "CUST_CREDIT_LIMIT"&lt;=6900 THEN '4'          
 WHEN "CUST_CREDIT_LIMIT"&lt;=8250 THEN '5' WHEN "CUST_CREDIT_LIMIT"&lt;=9600 THEN '6'          
 WHEN "CUST_CREDIT_LIMIT"&lt;=10950 THEN '7' WHEN "CUST_CREDIT_LIMIT"&lt;=12300 THEN '          
8' WHEN "CUST_CREDIT_LIMIT"&lt;=13650 THEN '9' WHEN "CUST_CREDIT_LIMIT"&lt;=15000 THEN          
 '10' END "CUST_CREDIT_LIMIT" FROM mining_data                                            
</pre></div>
<!-- class="refsect2" -->
<div id="ARPLS73074" class="refsect2"><a id="BABDFGDG"></a>
<hr />
<h3 class="refsect2"><a id="sthref2843"></a>XFORM_CLIP Procedure</h3>
<p>This procedure creates a view that implements the clipping transformations specified in a definition table. Only the columns that are specified in the definition table are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2844"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP (
    clip_table_name       IN VARCHAR2, 
    data_table_name       IN VARCHAR2,
    xform_view_name       IN VARCHAR2,
    clip_schema_name      IN VARCHAR2 DEFAULT NULL,
    data_schema_name      IN VARCHAR2,DEFAULT NULL,
    xform_schema_name     IN VARCHAR2,DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2845"></a>Parameters</p>
<div id="ARPLS73075" class="tblformal">
<p class="titleintable"><a id="sthref2846"></a><a id="sthref2847"></a>Table 45-43 XFORM_CLIP Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_CLIP Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t75">Parameter</th>
<th class="cellalignment1227" id="r1c2-t75">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t75" headers="r1c1-t75">
<p><code>clip_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t75 r1c2-t75">
<p>Name of the transformation definition table for clipping. You can use the <a href="#BABCFGBC">CREATE_CLIP Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>XFORM_CLIP</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for clipping you can write your own SQL.</p>
<p>See <a href="#BABGECBI">Table 45-8, "Columns in a Transformation Definition Table for Clipping or Winsorizing"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t75" headers="r1c1-t75">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t75 r1c2-t75">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t75" headers="r1c1-t75">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t75 r1c2-t75">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">clip_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t75" headers="r1c1-t75">
<p><code>clip_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t75 r1c2-t75">
<p>Schema of <code><span class="codeinlineitalic">clip_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t75" headers="r1c1-t75">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t75 r1c2-t75">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t75" headers="r1c1-t75">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t75 r1c2-t75">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2848"></a>Examples</p>
<p>This example creates a view that clips the <code>cust_credit_limit</code> column. The data source consists of three columns from <code>sh.customer.</code></p>
<pre>
describe mining_data
 Name                           Null?    Type
 ------------------------------ -------- -------------------------
 CUST_ID                        NOT NULL NUMBER
 CUST_POSTAL_CODE               NOT NULL VARCHAR2(10)
 CUST_CREDIT_LIMIT                        NUMBER
 
BEGIN
   dbms_data_mining_transform.create_clip(
      clip_table_name    =&gt; 'clip_tbl');
   dbms_data_mining_transform.insert_clip_trim_tail(
      clip_table_name   =&gt; 'clip_tbl',
      data_table_name   =&gt; 'mining_data',
      tail_frac         =&gt; 0.05,
      exclude_list      =&gt; dbms_data_mining_transform.COLUMN_LIST('cust_id'));
   dbms_data_mining_transform.xform_clip(
      clip_table_name     =&gt; 'clip_tbl',
      data_table_name    =&gt; 'mining_data',
      xform_view_name    =&gt; 'clip_view');
END;
/
describe clip_view
 Name                          Null?    Type
 ----------------------------- -------- --------------------------
 CUST_ID                       NOT NULL NUMBER
 CUST_POSTAL_CODE              NOT NULL VARCHAR2(10)
 CUST_CREDIT_LIMIT                      NUMBER
 
SELECT MIN(cust_credit_limit), MAX(cust_credit_limit) FROM mining_data;
 
MIN(CUST_CREDIT_LIMIT) MAX(CUST_CREDIT_LIMIT)
---------------------- ----------------------
                  1500                  15000
 
SELECT MIN(cust_credit_limit), MAX(cust_credit_limit) FROM clip_view;
 
MIN(CUST_CREDIT_LIMIT) MAX(CUST_CREDIT_LIMIT)
---------------------- ----------------------
                  1500                  11000
 
set long 2000
SELECT text FROM user_views WHERE view_name IN 'CLIP_VIEW';
 
TEXT
--------------------------------------------------------------------------------
SELECT "CUST_ID","CUST_POSTAL_CODE",CASE WHEN "CUST_CREDIT_LIMIT" &lt; 1500 THEN NU
LL WHEN "CUST_CREDIT_LIMIT" &gt; 11000 THEN NULL ELSE "CUST_CREDIT_LIMIT" END "CUST
_CREDIT_LIMIT" FROM mining_data
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73076" class="refsect2"><a id="BABHFHGH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2849"></a>XFORM_COL_REM Procedure</h3>
<p>This procedure creates a view that implements the column removal transformations specified in a definition table. Only the columns that are specified in the definition table are removed; the remaining columns from the data table are present in the view.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2850"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_COL_REM (
     rem_table_name     IN       VARCHAR2,
     data_table_name    IN       VARCHAR2,
     xform_view_name    IN       VARCHAR2,
     rem_schema_name    IN       VARCHAR2 DEFAULT NULL,
     data_schema_name   IN       VARCHAR2 DEFAULT NULL,
     xform_schema_name  IN       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2851"></a>Parameters</p>
<div id="ARPLS73077" class="tblformal">
<p class="titleintable"><a id="sthref2852"></a><a id="sthref2853"></a>Table 45-44 XFORM_COL_REM Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_COL_REM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_COL_REM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t76">Parameter</th>
<th class="cellalignment1227" id="r1c2-t76">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t76" headers="r1c1-t76">
<p><code>rem_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t76 r1c2-t76">
<p>Name of the transformation definition table for column removal. You can use the <a href="#BABGCDCC">CREATE_COL_REM Procedure</a> to create the definition table. See <a href="#BABBEACJ">Table 45-10, "Columns in a Transformation Definition Table for Column Removal"</a>.</p>
<p>The table must be populated with column names before you call <code>XFORM_COL_REM</code>. The <a href="#BABEHBCE">INSERT_BIN_SUPER Procedure</a> and the <a href="#BABJDGIA">INSERT_AUTOBIN_NUM_EQWIDTH Procedure</a> can optionally be used to populate the table. You can also use SQL <code>INSERT</code> statements.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t76" headers="r1c1-t76">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t76 r1c2-t76">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t76" headers="r1c1-t76">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t76 r1c2-t76">
<p>Name of the view to be created. The view presents the columns in <code><span class="codeinlineitalic">data_table_name</span></code> that are not specified in <code><span class="codeinlineitalic">rem_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t76" headers="r1c1-t76">
<p><code>rem_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t76 r1c2-t76">
<p>Schema of <code><span class="codeinlineitalic">rem_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t76" headers="r1c1-t76">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t76 r1c2-t76">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t76" headers="r1c1-t76">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t76 r1c2-t76">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2854"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2855"></a>Examples</p>
<p>This example creates a view that includes all but one column from the table <code>customers</code> in the current schema.</p>
<pre>
describe customers
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 CUST_ID                                   NOT NULL NUMBER
 CUST_MARITAL_STATUS                                VARCHAR2(20)
 OCCUPATION                                         VARCHAR2(21)
 AGE                                                NUMBER
 YRS_RESIDENCE                                      NUMBER

BEGIN
    DBMS_DATA_MINING_TRANSFORM.CREATE_COL_REM ('colrem_xtbl');
END;
 /
INSERT INTO colrem_xtbl VALUES('CUST_MARITAL_STATUS', null);

BEGIN
   DBMS_DATA_MINING_TRANSFORM.XFORM_COL_REM (
     rem_table_name        =&gt; 'colrem_xtbl',
     data_table_name       =&gt; 'customers',
     xform_view_name       =&gt; 'colrem_view');
END;
/
describe colrem_view

 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 CUST_ID                                   NOT NULL NUMBER
 OCCUPATION                                         VARCHAR2(21)
 AGE                                                NUMBER
 YRS_RESIDENCE                                      NUMBER
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73078" class="refsect2"><a id="BABJHGCG"></a>
<hr />
<h3 class="refsect2"><a id="sthref2856"></a>XFORM_EXPR_NUM Procedure</h3>
<p>This procedure creates a view that implements the specified numeric transformations. Only the columns that you specify are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2857"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_EXPR_NUM (
     expr_pattern       IN       VARCHAR2,
     data_table_name    IN       VARCHAR2,
     xform_view_name    IN       VARCHAR2,
     exclude_list       IN       COLUMN_LIST DEFAULT NULL,
     include_list       IN       COLUMN_LIST DEFAULT NULL,
     col_pattern        IN       VARCHAR2 DEFAULT ':col',
     data_schema_name   IN       VARCHAR2 DEFAULT NULL,
     xform_schema_name  IN       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2858"></a>Parameters</p>
<div id="ARPLS73079" class="tblformal">
<p class="titleintable"><a id="sthref2859"></a><a id="sthref2860"></a>Table 45-45 XFORM_EXPR_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_EXPR_NUM Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_EXPR_NUM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t77">Parameter</th>
<th class="cellalignment1227" id="r1c2-t77">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t77" headers="r1c1-t77">
<p><code>expr_pattern</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t77 r1c2-t77">
<p>A numeric transformation expression</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t77" headers="r1c1-t77">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t77 r1c2-t77">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t77" headers="r1c1-t77">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t77 r1c2-t77">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">expr_pattern</span></code> and <code><span class="codeinlineitalic">col_pattern</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t77" headers="r1c1-t77">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t77 r1c2-t77">
<p>List of numeric columns to exclude. If <code>NULL</code>, no numeric columns are excluded.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t77" headers="r1c1-t77">
<p><code>include_list</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t77 r1c2-t77">
<p>List of numeric columns to include. If <code>NULL</code>, all numeric columns are included.</p>
<p>The format of <code><span class="codeinlineitalic">include_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t77" headers="r1c1-t77">
<p><code>col_pattern</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t77 r1c2-t77">
<p>The value within <code><span class="codeinlineitalic">expr_pattern</span></code> that will be replaced with a column name. The value of <code><span class="codeinlineitalic">col_pattern</span></code> is case-sensitive.</p>
<p>The default value of <code><span class="codeinlineitalic">col_pattern</span></code> is <code>':col'</code></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t77" headers="r1c1-t77">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t77 r1c2-t77">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t77" headers="r1c1-t77">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t77 r1c2-t77">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2861"></a>Usage Notes</p>
<ol>
<li>
<p>The <code>XFORM_EXPR_NUM</code> procedure constructs numeric transformation expressions from the specified expression pattern (<code><span class="codeinlineitalic">expr_pattern</span></code>) by replacing every occurrence of the specified column pattern (<code><span class="codeinlineitalic">col_pattern</span></code>) with an actual column name.</p>
<p><code>XFORM_EXPR_NUM</code> uses the SQL <code>REPLACE</code> function to construct the transformation expressions.</p>
<pre>
REPLACE (<span class="italic">expr_pattern</span>,<span class="italic">col_pattern</span>,'"<span class="italic">column_name</span>"') || '"<span class="italic">column_name</span>"'
</pre>
<p>If there is a column match, then the replacement is made in the transformation expression; if there is not a match, then the column is used without transformation.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink SQLRF51707" href="../../server.112/e41084/functions153.htm#SQLRF51707"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code>REPLACE</code> function</div>
</li>
<li>
<p>Because of the include and exclude list parameters, the <code>XFORM_EXPR_NUM</code> and <code>XFORM_EXPR_STR</code> procedures allow you to easily specify individual columns for transformation within large data sets. The other <code>XFORM_</code>* procedures support an exclude list only. In these procedures, you must enumerate every column that you do not want to transform.</p>
</li>
<li>
<p>See <a href="#BABDIIIC">"Operational Notes"</a></p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2862"></a>Examples</p>
<p>This example creates a view that transforms the data type of numeric columns.</p>
<pre>
describe customers
 Name                                Null?    Type
 ----------------------------------- -------- ------------------------
 CUST_ID                             NOT NULL NUMBER
 CUST_MARITAL_STATUS                          VARCHAR2(20)
 OCCUPATION                                   VARCHAR2(21)
 AGE                                          NUMBER
 YRS_RESIDENCE                                NUMBER

BEGIN
  DBMS_DATA_MINING_TRANSFORM.XFORM_EXPR_NUM(
    expr_pattern         =&gt; 'to_char(:col)',
    data_table_name      =&gt; 'customers',
    xform_view_name      =&gt; 'cust_nonum_view',
    exclude_list         =&gt; dbms_data_mining_transform.COLUMN_LIST( 'cust_id'),
    include_list         =&gt; null,
    col_pattern          =&gt; ':col');
END;
/
describe cust_nonum_view
 Name                                Null?    Type
 ----------------------------------- -------- ------------------------
 CUST_ID                             NOT NULL NUMBER
 CUST_MARITAL_STATUS                          VARCHAR2(20)
 OCCUPATION                                   VARCHAR2(21)
 AGE                                          VARCHAR2(40)
 YRS_RESIDENCE                                VARCHAR2(40)
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73080" class="refsect2"><a id="BABHGAJH"></a>
<hr />
<h3 class="refsect2"><a id="sthref2863"></a>XFORM_EXPR_STR Procedure</h3>
<p>This procedure creates a view that implements the specified categorical transformations. Only the columns that you specify are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2864"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_EXPR_STR (
     expr_pattern       IN       VARCHAR2,
     data_table_name    IN       VARCHAR2,
     xform_view_name    IN       VARCHAR2,
     exclude_list       IN       COLUMN_LIST DEFAULT NULL,
     include_list       IN       COLUMN_LIST DEFAULT NULL,
     col_pattern        IN       VARCHAR2 DEFAULT ':col',
     data_schema_name   IN       VARCHAR2 DEFAULT NULL,
     xform_schema_name  IN       VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2865"></a>Parameters</p>
<div id="ARPLS73081" class="tblformal">
<p class="titleintable"><a id="sthref2866"></a><a id="sthref2867"></a>Table 45-46 XFORM_EXPR_STR Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_EXPR_STR Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_EXPR_STR" dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t79">Parameter</th>
<th class="cellalignment1227" id="r1c2-t79">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t79" headers="r1c1-t79">
<p><code>expr_pattern</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t79 r1c2-t79">
<p>A character transformation expression</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t79" headers="r1c1-t79">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t79 r1c2-t79">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t79" headers="r1c1-t79">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t79 r1c2-t79">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">expr_pattern</span></code> and <code><span class="codeinlineitalic">col_pattern</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t79" headers="r1c1-t79">
<p><code>exclude_list</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t79 r1c2-t79">
<p>List of character columns to exclude. If <code>NULL</code>, no character columns are excluded.</p>
<p>The format of <code><span class="codeinlineitalic">exclude_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t79" headers="r1c1-t79">
<p><code>include_list</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t79 r1c2-t79">
<p>List of character columns to include. If <code>NULL</code>, all character columns are included.</p>
<p>The format of <code><span class="codeinlineitalic">include_list</span></code> is:</p>
<pre>
dbms_data_mining_transform.COLUMN_LIST('col<span class="italic">1</span>','col<span class="italic">2</span>',
                                       ...'col<span class="italic">n</span>')
</pre></td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t79" headers="r1c1-t79">
<p><code>col_pattern</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t79 r1c2-t79">
<p>The value within <code><span class="codeinlineitalic">expr_pattern</span></code> that will be replaced with a column name. The value of <code><span class="codeinlineitalic">col_pattern</span></code> is case-sensitive.</p>
<p>The default value of <code><span class="codeinlineitalic">col_pattern</span></code> is <code>':col'</code></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t79" headers="r1c1-t79">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t79 r1c2-t79">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t79" headers="r1c1-t79">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t79 r1c2-t79">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2868"></a>Usage Notes</p>
<ol>
<li>
<p>The <code>XFORM_EXPR_STR</code> procedure constructs character transformation expressions from the specified expression pattern (<code><span class="codeinlineitalic">expr_pattern</span></code>) by replacing every occurrence of the specified column pattern (<code><span class="codeinlineitalic">col_pattern</span></code>) with an actual column name.</p>
<p><code>XFORM_EXPR_STR</code> uses the SQL <code>REPLACE</code> function to construct the transformation expressions.</p>
<pre>
REPLACE (<span class="italic">expr_pattern</span>,<span class="italic">col_pattern</span>,'"<span class="italic">column_name</span>"') || '"<span class="italic">column_name</span>"'
</pre>
<p>If there is a column match, then the replacement is made in the transformation expression; if there is not a match, then the column is used without transformation.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink SQLRF51707" href="../../server.112/e41084/functions153.htm#SQLRF51707"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code>REPLACE</code> function</div>
</li>
<li>
<p>Because of the include and exclude list parameters, the <code>XFORM_EXPR_STR</code> and <code>XFORM_EXPR_NUM</code> procedures allow you to easily specify individual columns for transformation within large data sets. The other <code>XFORM_</code>* procedures support an exclude list only. In these procedures, you must enumerate every column that you do not want to transform.</p>
</li>
<li>
<p>See <a href="#BABDIIIC">"Operational Notes"</a></p>
</li>
</ol>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2869"></a>Examples</p>
<p>This example creates a view that transforms character columns to upper case.</p>
<pre>
describe customers
 Name                                Null?    Type
 ----------------------------------- -------- ------------------------
 CUST_ID                             NOT NULL NUMBER
 CUST_MARITAL_STATUS                          VARCHAR2(20)
 OCCUPATION                                   VARCHAR2(21)
 AGE                                          NUMBER
 YRS_RESIDENCE                                NUMBER

SELECT cust_id,  cust_marital_status, occupation FROM customers
    WHERE   cust_id &gt; 102995
    ORDER BY cust_id desc;
 
CUST_ID CUST_MARITAL_STATUS  OCCUPATION
------- -------------------- ---------------------
 103000 Divorc.              Cleric.
 102999 Married              Cleric.
 102998 Married              Exec.
 102997 Married              Exec.
 102996 NeverM               Other
 
BEGIN
  DBMS_DATA_MINING_TRANSFORM.XFORM_EXPR_STR(
       expr_pattern            =&gt; 'upper(:col)',
       data_table_name         =&gt; 'customers',
       xform_view_name         =&gt; 'cust_upcase_view');
END;
/
describe cust_upcase_view
 Name                          Null?    Type
 ----------------------------- -------- --------------------
 CUST_ID                       NOT NULL NUMBER
 CUST_MARITAL_STATUS                    VARCHAR2(20)
 OCCUPATION                             VARCHAR2(21)
 AGE                                    NUMBER
 YRS_RESIDENCE                          NUMBER
 
SELECT cust_id,  cust_marital_status, occupation FROM cust_upcase_view
   WHERE   cust_id &gt; 102995
   ORDER BY cust_id desc;
 
CUST_ID CUST_MARITAL_STATUS  OCCUPATION
------- -------------------- ---------------------
 103000 DIVORC.              CLERIC.
 102999 MARRIED              CLERIC.
 102998 MARRIED              EXEC.
 102997 MARRIED              EXEC.
 102996 NEVERM               OTHER
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73082" class="refsect2"><a id="BABBEDBE"></a>
<hr />
<h3 class="refsect2"><a id="sthref2870"></a>XFORM_MISS_CAT Procedure</h3>
<p>This procedure creates a view that implements the categorical missing value treatment transformations specified in a definition table. Only the columns that are specified in the definition table are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2871"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT (
    miss_table_name       IN VARCHAR2, 
    data_table_name       IN VARCHAR2,
    xform_view_name       IN VARCHAR2,
    miss_schema_name      IN VARCHAR2 DEFAULT NULL,
    data_schema_name      IN VARCHAR2 DEFAULT NULL,
    xform_schema_name     IN VARCHAR2 DEFAULT NULL;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2872"></a>Parameters</p>
<div id="ARPLS73083" class="tblformal">
<p class="titleintable"><a id="sthref2873"></a><a id="sthref2874"></a>Table 45-47 XFORM_MISS_CAT Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_MISS_CAT Procedure Parameters" summary="This table lists the parameters in DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT procedure." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t81">Parameter</th>
<th class="cellalignment1227" id="r1c2-t81">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t81" headers="r1c1-t81">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t81 r1c2-t81">
<p>Name of the transformation definition table for categorical missing value treatment. You can use the <a href="#BABHJFDC">CREATE_MISS_CAT Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>XFORM_MISS_CAT</code>. To populate the table, you can use the <a href="#BABJCGCA">INSERT_MISS_CAT_MODE Procedure</a> or you can write your own SQL.</p>
<p>See <a href="#BABJBBGD">Table 45-12, "Columns in a Transformation Definition Table for Categorical Missing Value Treatment"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t81" headers="r1c1-t81">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t81 r1c2-t81">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t81" headers="r1c1-t81">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t81 r1c2-t81">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">miss_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t81" headers="r1c1-t81">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t81 r1c2-t81">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t81" headers="r1c1-t81">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t81 r1c2-t81">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t81" headers="r1c1-t81">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t81 r1c2-t81">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2875"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2876"></a>Examples</p>
<p>This example creates a view that replaces missing categorical values with the mode.</p>
<pre>
SELECT * FROM geog;

REG_ID REGION
------ ------------------------------
     1 NE
     2 SW
     3 SE
     4 SW
     5
     6 NE
     7 NW
     8 NW
     9
    10
    11 SE
    12 SE
    13 NW
    14 SE
    15 SE
 
SELECT STATS_MODE(region) FROM geog;

STATS_MODE(REGION)
------------------------------
SE
 
BEGIN
  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_CAT('misscat_xtbl');
  DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_CAT_MODE (
    miss_table_name         =&gt; 'misscat_xtbl',
    data_table_name         =&gt; 'geog' );
END;
/

SELECT col, val FROM misscat_xtbl;

COL        VAL
---------- ----------
REGION     SE
 
BEGIN
  DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT (
     miss_table_name        =&gt; 'misscat_xtbl',
     data_table_name        =&gt; 'geog',
     xform_view_name        =&gt; 'geogxf_view');
END;
/

SELECT * FROM geogxf_view;

REG_ID REGION
------ ------------------------------
     1 NE
     2 SW
     3 SE
     4 SW
     5 SE
     6 NE
     7 NW
     8 NW
     9 SE
    10 SE
    11 SE
    12 SE
    13 NW
    14 SE
    15 SE

</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73084" class="refsect2"><a id="BABCFDAA"></a>
<hr />
<h3 class="refsect2"><a id="sthref2877"></a>XFORM_MISS_NUM Procedure</h3>
<p>This procedure creates a view that implements the numerical missing value treatment transformations specified in a definition table. Only the columns that are specified in the definition table are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2878"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM (
    miss_table_name       IN VARCHAR2, 
    data_table_name       IN VARCHAR2,
    xform_view_name       IN VARCHAR2,
    miss_schema_name      IN VARCHAR2 DEFAULT NULL,
    data_schema_name      IN VARCHAR2 DEFAULT NULL,
    xform_schema_name     IN VARCHAR2 DEFAULT NULL;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2879"></a>Parameters</p>
<div id="ARPLS73085" class="tblformal">
<p class="titleintable"><a id="sthref2880"></a><a id="sthref2881"></a>Table 45-48 XFORM_MISS_NUM Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_MISS_NUM Procedure Parameters" summary="This table lists the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t82">Parameter</th>
<th class="cellalignment1227" id="r1c2-t82">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t82" headers="r1c1-t82">
<p><code>miss_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t82 r1c2-t82">
<p>Name of the transformation definition table for numerical missing value treatment. You can use the <a href="#BABIEAGA">CREATE_MISS_NUM Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>XFORM_MISS_NUM</code>. To populate the table, you can use the <a href="#BABHAHEJ">INSERT_MISS_NUM_MEAN Procedure</a> or you can write your own SQL.</p>
<p>See <a href="#BABBFJIA">Table 45-14, "Columns in a Transformation Definition Table for Numerical Missing Value Treatment"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t82" headers="r1c1-t82">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t82 r1c2-t82">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t82" headers="r1c1-t82">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t82 r1c2-t82">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">miss_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t82" headers="r1c1-t82">
<p><code>miss_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t82 r1c2-t82">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t82" headers="r1c1-t82">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t82 r1c2-t82">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t82" headers="r1c1-t82">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t82 r1c2-t82">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2882"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2883"></a>Examples</p>
<p>This example creates a view that replaces missing numerical values with the mean.</p>
<pre>
SELECT * FROM items;
 
ITEM_ID       QTY
---------- ------
aa            200
bb            200
cc            250
dd
ee
ff            100
gg            250
hh            200
ii
jj            200
 
SELECT AVG(qty) FROM items;
 
AVG(QTY)
--------
     200
 
BEGIN
  DBMS_DATA_MINING_TRANSFORM.CREATE_MISS_NUM('missnum_xtbl');
  DBMS_DATA_MINING_TRANSFORM.INSERT_MISS_NUM_MEAN (
     miss_table_name          =&gt; 'missnum_xtbl',
     data_table_name         =&gt; 'items' );
END;
/
 
SELECT col, val FROM missnum_xtbl;
 
COL           VAL
---------- ------
QTY           200
 
BEGIN
    DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM (
        miss_table_name        =&gt; 'missnum_xtbl',
        data_table_name        =&gt; 'items',
        xform_view_name        =&gt; 'items_view');
END;
/
 
SELECT * FROM items_view;
 
ITEM_ID       QTY
---------- ------
aa            200
bb            200
cc            250
dd            200
ee            200
ff            100
gg            250
hh            200
ii            200
jj            200
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73086" class="refsect2"><a id="BABIHHGG"></a>
<hr />
<h3 class="refsect2"><a id="sthref2884"></a>XFORM_NORM_LIN Procedure</h3>
<p>This procedure creates a view that implements the linear normalization transformations specified in a definition table. Only the columns that are specified in the definition table are transformed; the remaining columns from the data table are present in the view, but they are not changed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2885"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
     norm_table_name      IN VARCHAR2,
     data_table_name      IN VARCHAR2,
     xform_view_name      IN VARCHAR2,
     norm_schema_name     IN VARCHAR2 DEFAULT NULL,
     data_schema_name     IN VARCHAR2 DEFAULT NULL,
     xform_schema_name    IN VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2886"></a>Parameters</p>
<div id="ARPLS73087" class="tblformal">
<p class="titleintable"><a id="sthref2887"></a><a id="sthref2888"></a>Table 45-49 XFORM_NORM_LIN Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_NORM_LIN Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t83">Parameter</th>
<th class="cellalignment1227" id="r1c2-t83">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t83" headers="r1c1-t83">
<p><code>norm_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t83 r1c2-t83">
<p>Name of the transformation definition table for linear normalization. You can use the <a href="#BABGBDGB">CREATE_NORM_LIN Procedure</a> to create the definition table. The table must be populated with transformation definitions before you call <code>XFORM_NORM_LIN</code>. To populate the table, you can use one of the <code>INSERT</code> procedures for normalization or you can write your own SQL.</p>
<p>See <a href="#BABJBBGD">Table 45-12, "Columns in a Transformation Definition Table for Categorical Missing Value Treatment"</a>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t83" headers="r1c1-t83">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t83 r1c2-t83">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t83" headers="r1c1-t83">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t83 r1c2-t83">
<p>Name of the view to be created. The view presents columns in <code><span class="codeinlineitalic">data_table_name</span></code> with the transformations specified in <code><span class="codeinlineitalic">miss_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t83" headers="r1c1-t83">
<p><code>norm_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t83 r1c2-t83">
<p>Schema of <code><span class="codeinlineitalic">miss_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t83" headers="r1c1-t83">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t83 r1c2-t83">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t83" headers="r1c1-t83">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t83 r1c2-t83">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2889"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2890"></a>Examples</p>
<p>This example creates a view that normalizes the <code>cust_year_of_birth</code> and <code>cust_credit_limit</code> columns. The data source consists of three columns from <code>sh.customer.</code></p>
<pre>
CREATE OR REPLACE VIEW mining_data AS
     SELECT cust_id, cust_year_of_birth, cust_credit_limit
     FROM sh.customers;

describe mining_data
 Name                                   Null?    Type
 -------------------------------------- -------- --------------------------
 CUST_ID                                NOT NULL NUMBER
 CUST_YEAR_OF_BIRTH                     NOT NULL NUMBER(4)
 CUST_CREDIT_LIMIT                               NUMBER
 
SELECT * FROM mining_data WHERE cust_id &gt; 104495
        ORDER BY cust_year_of_birth;
 
 CUST_ID CUST_YEAR_OF_BIRTH CUST_CREDIT_LIMIT
-------- ------------------ -----------------
  104496               1947              3000
  104498               1954             10000
  104500               1962             15000
  104499               1970              3000
  104497               1976              3000
 
BEGIN
  dbms_data_mining_transform.CREATE_NORM_LIN(
       norm_table_name            =&gt; 'normx_tbl');
 dbms_data_mining_transform.INSERT_NORM_LIN_MINMAX(
      norm_table_name      =&gt; 'normx_tbl',
      data_table_name      =&gt; 'mining_data',
      exclude_list        =&gt; dbms_data_mining_transform.COLUMN_LIST( 'cust_id'),
      round_num   =&gt; 3);
END;
/
 
SELECT col, shift, scale FROM normx_tbl;
 
COL                               SHIFT    SCALE                           
------------------------------ -------- --------                           
CUST_YEAR_OF_BIRTH                 1910       77                           
CUST_CREDIT_LIMIT                  1500    13500                           
 
BEGIN
  DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (
     norm_table_name       =&gt; 'normx_tbl',
     data_table_name       =&gt; 'mining_data',
     xform_view_name       =&gt; 'norm_view');
END;
/
 
SELECT * FROM norm_view WHERE cust_id &gt; 104495
        ORDER BY cust_year_of_birth;
 
 CUST_ID CUST_YEAR_OF_BIRTH CUST_CREDIT_LIMIT
-------- ------------------ -----------------
  104496           .4805195          .1111111
  104498           .5714286          .6296296
  104500           .6753247                 1
  104499           .7792208          .1111111
  104497           .8571429          .1111111
 
 
set long 2000
SQL&gt; SELECT text FROM user_views WHERE view_name IN 'NORM_VIEW';
 
TEXT                                                                       
---------------------------------------------------------------------------
SELECT "CUST_ID",("CUST_YEAR_OF_BIRTH"-1910)/77 "CUST_YEAR_OF_BIRTH",("CUST
_CREDIT_LIMIT"-1500)/13500 "CUST_CREDIT_LIMIT" FROM mining_data            
                                                                           
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS73088" class="refsect2"><a id="BABIHDCC"></a>
<hr />
<h3 class="refsect2"><a id="sthref2891"></a>XFORM_STACK Procedure</h3>
<p>This procedure creates a view that implements the transformations specified by the stack. Only the columns and nested attributes that are specified in the stack are transformed. Any remaining columns and nested attributes from the data table appear in the view without changes.</p>
<p>To create a list of objects that describe the transformed columns, use the <a href="#BABIIFEF">DESCRIBE_STACK Procedure</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<p><a href="#BABFFDFC">"Overview"</a></p>
<p><a class="olink DMPRG005" href="../../datamine.112/e12218/xform_casetbl.htm#DMPRG005"><span class="italic">Oracle Data Mining Application Developer's Guide</span></a> for more information about data mining attributes</p>
</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2892"></a>Syntax</p>
<pre>
DBMS_DATA_MINING_TRANSFORM.XFORM_STACK (
     xform_list         IN     TRANSFORM_list,
     data_table_name    IN     VARCHAR2,
     xform_view_name    IN     VARCHAR2,
     data_schema_name   IN     VARCHAR2 DEFAULT NULL,
     xform_schema_name  IN     VARCHAR2 DEFAULT NULL);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2893"></a>Parameters</p>
<div id="ARPLS73089" class="tblformal">
<p class="titleintable"><a id="sthref2894"></a><a id="sthref2895"></a>Table 45-50 XFORM_STACK Procedure Parameters</p>
<table class="cellalignment1229" title="XFORM_STACK Procedure Parameters" summary="This table describes the parameters of DBMS_DATA_MINING_TRANSFORM.XFORM_STACK." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t85">Parameter</th>
<th class="cellalignment1227" id="r1c2-t85">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t85" headers="r1c1-t85">
<p><code>xform_list</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t85 r1c2-t85">
<p>The transformation list. See <a href="#CACEJIHI">Table 45-1</a> for a description of the <code>TRANSFORM_LIST</code> object type.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t85" headers="r1c1-t85">
<p><code>data_table_name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t85 r1c2-t85">
<p>Name of the table containing the data to be transformed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t85" headers="r1c1-t85">
<p><code>xform_view_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t85 r1c2-t85">
<p>Name of the view to be created. The view applies the transformations in <code><span class="codeinlineitalic">xform_list</span></code> to <code><span class="codeinlineitalic">data_table_name</span></code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t85" headers="r1c1-t85">
<p><code>data_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t85 r1c2-t85">
<p>Schema of <code><span class="codeinlineitalic">data_table_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t85" headers="r1c1-t85">
<p><code>xform_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t85 r1c2-t85">
<p>Schema of <code><span class="codeinlineitalic">xform_view_name</span></code>. If no schema is specified, the current schema is used.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2896"></a>Usage Notes</p>
<p>See <a href="#BABDIIIC">"Operational Notes"</a>. The following sections are especially relevant:</p>
<ul>
<li>
<p><a href="#CACHEGJD">"About Transformation Lists"</a></p>
</li>
<li>
<p><a href="#CACIJGBE">"About Stacking"</a></p>
</li>
<li>
<p><a href="#CACBAGBJ">"Nested Data Transformations"</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref2897"></a>Examples</p>
<p>This example applies a transformation list to the view <code>dmuser.cust_info</code> and shows how the data is transformed.The <code>CREATE</code> statement for <code>cust_info</code> is shown in <a href="#BABIIFEF">"DESCRIBE_STACK Procedure"</a>.</p>
<pre>
BEGIN
  dbms_data_mining_transform.CREATE_BIN_NUM ('birth_yr_bins');
  dbms_data_mining_transform.INSERT_BIN_NUM_QTILE (
        bin_table_name   =&gt; 'birth_yr_bins',
        data_table_name  =&gt;  'cust_info',
        bin_num          =&gt;   6,
        exclude_list     =&gt;  dbms_data_mining_transform.column_list(
                                 'cust_id','country_id'));
END;
/
SELECT * FROM birth_yr_bins;

COL                  ATT      VAL BIN
-------------------- ----- ------ ----------
CUST_YEAR_OF_BIRTH           1922
CUST_YEAR_OF_BIRTH           1951 1
CUST_YEAR_OF_BIRTH           1959 2
CUST_YEAR_OF_BIRTH           1966 3
CUST_YEAR_OF_BIRTH           1973 4
CUST_YEAR_OF_BIRTH           1979 5
CUST_YEAR_OF_BIRTH           1986 6

DECLARE
      cust_stack   dbms_data_mining_transform.TRANSFORM_LIST;
BEGIN
      dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
          'country_id', NULL, 'country_id/10', 'country_id*10');
      dbms_data_mining_transform.STACK_BIN_NUM ('birth_yr_bins',
          cust_stack);
      dbms_data_mining_transform.SET_TRANSFORM (cust_stack,
          'custprods', 'Mouse Pad', 'value*100', 'value/100');
      <span class="bold">dbms_data_mining_transform.XFORM_STACK</span>(
          xform_list        =&gt; cust_stack,
          data_table_name   =&gt; 'cust_info',
          xform_view_name   =&gt;  'cust_xform_view');
  END;
/

-- Two rows of data without transformations
SELECT * from cust_info WHERE cust_id BETWEEN 100010 AND 100011;

CUST_ID COUNTRY_ID CUST_YEAR_OF_BIRTH CUSTPRODS(ATTRIBUTE_NAME, VALUE)
------- ---------- ------------------ -----------------------------------------
 100010      52790               <span class="bold">1975</span> DM_NESTED_NUMERICALS(
                                        DM_NESTED_NUMERICAL(
                                         '18" Flat Panel Graphics Monitor', 1),
                                        DM_NESTED_NUMERICAL(
                                         'SIMM- 16MB PCMCIAII card', 1))
 100011      52775               <span class="bold">1972</span> DM_NESTED_NUMERICALS(
                                       DM_NESTED_NUMERICAL(
                                         'External 8X CD-ROM', 1),
                                       DM_NESTED_NUMERICAL(
                                         <span class="bold">'Mouse Pad', 1</span>),
                                       DM_NESTED_NUMERICAL(
                                        'SIMM- 16MB PCMCIAII card', 1),
                                       DM_NESTED_NUMERICAL(
                                         'Keyboard Wrist Rest', 1),
                                       DM_NESTED_NUMERICAL(
                                         '18" Flat Panel Graphics Monitor', 1),
                                       DM_NESTED_NUMERICAL(
                                         'O/S Documentation Set - English', 1))

-- Same two rows of data with transformations
SELECT * FROM cust_xform_view WHERE cust_id BETWEEN 100010 AND 100011;
 
CUST_ID  COUNTRY_ID  C  CUSTPRODS(ATTRIBUTE_NAME, VALUE)
-------  ----------  -  --------------------------------------------------------
 100010       5279   <span class="bold">5</span>  DM_NESTED_NUMERICALS(
                          DM_NESTED_NUMERICAL(
                           '18" Flat Panel Graphics Monitor', 1),
                          DM_NESTED_NUMERICAL(
                            'SIMM- 16MB PCMCIAII card', 1))
 100011     5277.5   <span class="bold">4</span>  DM_NESTED_NUMERICALS(
                          DM_NESTED_NUMERICAL(
                            'External 8X CD-ROM', 1),
                          DM_NESTED_NUMERICAL(
                            <span class="bold">'Mouse Pad', 100</span>),
                          DM_NESTED_NUMERICAL(
                            'SIMM- 16MB PCMCIAII card', 1),
                          DM_NESTED_NUMERICAL(
                            'Keyboard Wrist Rest', 1),
                          DM_NESTED_NUMERICAL(
                            '18" Flat Panel Graphics Monitor', 1),
                          DM_NESTED_NUMERICAL(
                            'O/S Documentation Set - English', 1))
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1219">
<tr>
<td class="cellalignment1228">
<table class="cellalignment1224">
<tr>
<td class="cellalignment1223"><a href="d_datmin.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1223"><a href="d_datpmp.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1231">
<table class="cellalignment1222">
<tr>
<td class="cellalignment1223"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1223"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1223"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1223"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1223"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1223"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
