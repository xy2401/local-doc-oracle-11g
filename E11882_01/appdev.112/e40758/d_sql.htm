<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>DBMS_SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 737" />
<meta name="dcterms.created" content="2013-07-19T18:55:30Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database PL/SQL Packages and Types Reference" />
<meta name="dcterms.identifier" content="E40758-03" />
<meta name="dcterms.isVersionOf" content="ARPLS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="d_spm.htm" title="Previous" type="text/html" />
<link rel="Next" href="d_sqldiag.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e40758.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">141/265</span> <!-- End Header -->
<div id="ARPLS058" class="chapter"><a id="BABEDAHF"></a>
<h1 class="chapter"><span class="secnum">137</span> DBMS_SQL</h1>
<p>The <code><a id="sthref9091"></a>DBMS_SQL</code> package provides an interface to use dynamic SQL to parse any data manipulation language (DML) or data definition language (DDL) statement using PL/SQL. For example, you can enter a <code>DROP</code> <code>TABLE</code> statement from within a stored procedure by using the <code>PARSE</code> procedure supplied with the <code>DBMS_SQL</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information on native dynamic SQL, see <a class="olink LNPLS" href="../e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference.</span></a></div>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABCIDIB">Using DBMS_SQL</a></p>
<ul>
<li>
<p>Overview</p>
</li>
<li>
<p>Security Model</p>
</li>
<li>
<p>Constants</p>
</li>
<li>
<p>Exceptions</p>
</li>
<li>
<p>Operational Notes</p>
</li>
<li>
<p>Examples</p>
</li>
</ul>
</li>
<li>
<p><a href="#CHDEEDCH">Data Structures</a></p>
<ul>
<li>
<p>RECORD TYPES</p>
</li>
<li>
<p>TABLE TYPES</p>
</li>
</ul>
</li>
<li>
<p><a href="#i997453">Summary of DBMS_SQL Subprograms</a></p>
</li>
</ul>
<div class="refentry"><a id="BABCIDIB"></a>
<hr />
<div id="ARPLS68176" class="refsect1">
<h2 class="refsect1">Using DBMS_SQL <a id="sthref9092"></a></h2>
<ul>
<li>
<p><a href="#i1028953">Overview</a></p>
</li>
<li>
<p><a href="#i1027587">Security Model</a></p>
</li>
<li>
<p><a href="#i1027592">Constants</a></p>
</li>
<li>
<p><a href="#i1027597">Exceptions</a></p>
</li>
<li>
<p><a href="#i1027602">Operational Notes</a></p>
</li>
<li>
<p><a href="#i996963">Examples</a></p>
</li>
</ul>
<div id="ARPLS68177" class="refsect2"><a id="i1028953"></a>
<hr />
<h3 class="refsect2">Overview</h3>
<p>Oracle lets you write stored procedures and anonymous PL/SQL blocks that use dynamic SQL. Dynamic SQL statements are not embedded in your source program; rather, they are stored in character strings that are input to, or built by, the program at runtime. This enables you to create more general-purpose procedures. For example, dynamic SQL lets you create a procedure that operates on a table whose name is not known until runtime.</p>
<p>Native Dynamic SQL is an alternative to <code>DBMS_SQL</code> that lets you place dynamic SQL statements directly into PL/SQL blocks. In most situations, Native Dynamic SQL is easier to use and performs better than <code>DBMS_SQL</code>. However, Native Dynamic SQL itself has certain limitations:</p>
<ul>
<li>
<p>There is no support for so-called Method 4 (for dynamic SQL statements with an unknown number of inputs or outputs)</p>
</li>
</ul>
<p>Also, there are some tasks that can only be performed using <code>DBMS_SQL.</code></p>
<p>The ability to use dynamic SQL from within stored procedures generally follows the model of the Oracle Call Interface (OCI).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a></div>
<p>PL/SQL differs somewhat from other common programming languages, such as C. For example, addresses (also called pointers) are not user-visible in PL/SQL. As a result, there are some differences between the Oracle Call Interface and the <code>DBMS_SQL</code> package. These differences include the following:</p>
<ul>
<li>
<p>The OCI uses bind by address, while the <code>DBMS_SQL</code> package uses bind by value.</p>
</li>
<li>
<p><a id="sthref9093"></a><a id="sthref9094"></a>With <code>DBMS_SQL</code> you must call <code>VARIABLE_VALUE</code> to retrieve the value of an <code>OUT</code> parameter for an anonymous block, and you must call <code>COLUMN_VALUE</code> after fetching rows to actually retrieve the values of the columns in the rows into your program.</p>
</li>
<li>
<p>The current release of the <code>DBMS_SQL</code> package does not provide <code>CANCEL</code> cursor procedures.</p>
</li>
<li>
<p>Indicator variables are not required, because <code>NULLs</code> are fully supported as values of a PL/SQL variable.</p>
</li>
</ul>
<p>A sample usage of the <code>DBMS_SQL</code> package follows. For users of the Oracle Call Interface, this code should seem fairly straightforward.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68178" class="refsect2"><a id="i1027587"></a>
<hr />
<h3 class="refsect2">Security Model</h3>
<p><code>DBMS_SQL</code> is a <code>SYS</code>-owned package compiled with <code>AUTHID</code> <code>CURRENT_USER</code>. Any <code>DBMS_SQL</code> subprogram called from an anonymous PL/SQL block is run using the privileges of the current user.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00809" href="../../appdev.112/e25519/subprograms.htm#LNPLS00809"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about using Invoker Rights or Definer Rights</div>
<p>In Oracle Database 11g, Release 1 (11.1), Oracle introduces a number of enhancements to DBMS_SQL to improve the security of the package.</p>
<p class="subhead2"><a id="ARPLS68179"></a>Preventing Malicious or Accidental Access of Open Cursor Numbers</p>
<p>An error, <code>ORA-29471</code>, is raised when any <code>DBMS_SQL</code> subprogram is called with a cursor number that does not denote an open cursor. When the error is raised, an alert is issued to the alert log and DBMS_SQL becomes inoperable for the life of the session.</p>
<p>If the actual value for the cursor number in a call to the <a href="#i1026423">IS_OPEN Function</a> denotes a cursor currently open in the session, the return value is <code>TRUE</code>. If the actual value is <code>NULL</code>, then the return value is <code>FALSE</code>. Otherwise, this raises an <code>ORA-29471</code> error.</p>
<p>Note that the <a href="#i997665">OPEN_CURSOR Function</a> is the only <code>DBMS_SQL</code> subprogram that has no formal parameter for the cursor number; rather, it returns a cursor number. Therefore it is not within the scope of these rules.</p>
<p class="subhead2"><a id="ARPLS68180"></a>Preventing Inappropriate Use of a Cursor</p>
<p>Cursors are protected from security breaches that subvert known existing cursors.</p>
<p>Checks are made when binding and executing. Optionally, checks may be performed for every single DBMS_SQL subprogram call. The check is:</p>
<ul>
<li>
<p>The <code>current_user</code> is the same on calling the subprogram as it was on calling the most recent parse.</p>
</li>
<li>
<p>The enabled roles on calling the subprogram must be a superset of the enabled roles on calling the most recent parse.</p>
</li>
</ul>
<p>Consistent with the use of definer's rights subprograms, roles do not apply.</p>
<p>If either check fails, and <code>ORA-29470</code> error is raised.</p>
<p>The mechanism for defining when checks are performed is a new overload for the <code>OPEN_CURSOR</code> subprogram which takes a formal parameter, <code>security_level</code>, with allowed values <code>NULL</code>, <code>1</code> and <code>2</code>.</p>
<ul>
<li>
<p>When <code>security_level</code> = <code>1</code> (or is <code>NULL</code>), the checks are made only when binding and executing.</p>
</li>
<li>
<p>When <code>security_level</code> = <code>2</code>, the checks are always made.</p>
</li>
</ul>
<p class="subhead2"><a id="ARPLS68181"></a>Upgrade Considerations</p>
<p>This security regime is stricter than those in Oracle Database 10g, Release 2 (10.2) and previous releases. As a consequence, users of DBMS_SQL may encounter runtime errors on upgrade. While these security enhancements make for more secure applications, users may wish to relax the security checks temporarily as they migrate to Oracle Database 11g, Release 1 (11.1). If so, please consult with Oracle Support on steps to relax the above security restrictions.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68182" class="refsect2"><a id="i1027592"></a>
<hr />
<h3 class="refsect2">Constants</h3>
<p>The constants described in <a href="#CIHHIABA">Table 137-1</a> are used with the <code>language_flag</code> parameter of the <a href="#i997676">PARSE Procedures</a>.</p>
<div id="ARPLS68183" class="tblformal">
<p class="titleintable"><a id="sthref9095"></a><a id="CIHHIABA"></a>Table 137-1 DBMS_SQL Constants</p>
<table class="cellalignment1229" title="DBMS_SQL Constants" summary="This table describes constants used by DBMS_SQL subprograms." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t5">Name</th>
<th class="cellalignment1227" id="r1c2-t5">Type</th>
<th class="cellalignment1227" id="r1c3-t5">Value</th>
<th class="cellalignment1227" id="r1c4-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t5" headers="r1c1-t5">
<p><code>V6</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t5 r1c2-t5">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t5 r1c3-t5">
<p><code>0</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t5 r1c4-t5">
<p>Specifies Oracle database version 6 behavior</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t5" headers="r1c1-t5">
<p>NATIVE</p>
</td>
<td class="cellalignment1228" headers="r3c1-t5 r1c2-t5">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t5 r1c3-t5">
<p><code>1</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t5 r1c4-t5">
<p>Specifies normal behavior for the database to which the program is connected</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t5" headers="r1c1-t5">
<p><code>V7</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t5 r1c2-t5">
<p><code>INTEGER</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t5 r1c3-t5">
<p>2</p>
</td>
<td class="cellalignment1228" headers="r4c1-t5 r1c4-t5">
<p>Specifies Oracle database version 7 behavior</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68184" class="refsect2"><a id="i1027597"></a>
<hr />
<h3 class="refsect2">Exceptions</h3>
<pre>
inconsistent_type EXCEPTION;
  pragma exception_init(inconsistent_type, -6562);
</pre>
<p>This exception is raised by the <a href="#i1025449">COLUMN_VALUE Procedure</a> or the <a href="#i998371">VARIABLE_VALUE Procedures</a> when the type of the given <code>OUT</code> parameter (for where to put the requested value) is different from the type of the value.</p>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68185" class="refsect2"><a id="i1027602"></a>
<hr />
<h3 class="refsect2">Operational Notes</h3>
<ul>
<li>
<p><a href="#BABGFFAI">Execution Flow</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#BABECIBG">Processing Queries</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#BABFJHJF">Processing Updates, Inserts, and Deletes</a></p>
</li>
</ul>
<ul>
<li>
<p><a href="#i1027496">Locating Errors</a></p>
</li>
</ul>
<div id="ARPLS68186" class="refsect3"><a id="BABGFFAI"></a>
<h4 class="refsect3">Execution Flow</h4>
<ol>
<li>
<p><a href="#i1027364">OPEN_CURSOR</a></p>
</li>
<li>
<p><a href="#i996870">PARSE</a></p>
</li>
<li>
<p><a href="#i996891">BIND_VARIABLE or BIND_ARRAY</a></p>
</li>
<li>
<p><a href="#i996897">DEFINE_COLUMN, DEFINE_COLUMN_LONG, or DEFINE_ARRAY</a></p>
</li>
<li>
<p><a href="#BABBFFFJ">EXECUTE</a></p>
</li>
<li>
<p><a href="#i996905">FETCH_ROWS or EXECUTE_AND_FETCH</a></p>
</li>
<li>
<p><a href="#i996908">VARIABLE_VALUE, COLUMN_VALUE, or COLUMN_VALUE_LONG</a></p>
</li>
<li>
<p><a href="#i996912">CLOSE_CURSOR</a></p>
</li>
</ol>
<div id="ARPLS68187" class="refsect4"><a id="i1027364"></a>
<h5 class="refsect4"><a id="sthref9096"></a><a id="sthref9097"></a>OPEN_CURSOR</h5>
<p><a id="sthref9098"></a>To process a SQL statement, you must have an open cursor. When you call the&nbsp;<a href="#i997665">OPEN_CURSOR Function</a>, you receive a cursor <code>ID</code> number for the data structure representing a valid cursor maintained by Oracle. These cursors are distinct from cursors defined at the precompiler, OCI, or PL/SQL level, and are used only by the <code>DBMS_SQL</code> package.</p>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68188" class="refsect4"><a id="i996870"></a>
<h5 class="refsect4">PARSE</h5>
<p>Every SQL statement must be parsed by calling the <a href="#i997676">PARSE Procedures</a>. Parsing the statement checks the statement's syntax and associates it with the cursor in your program.</p>
<p>You can parse any DML or DDL statement. DDL statements are run on the parse, which performs the implied commit.</p>
<p>The execution flow of <code>DBMS_SQL</code> is shown in <a href="#BABDJEBE">Figure 137-1</a>.</p>
<div id="ARPLS68189" class="figure">
<p class="titleinfigure"><a id="BABDJEBE"></a>Figure 137-1 DBMS_SQL Execution Flow</p>
<img width="496" height="608" src="img/arpls008.gif" alt="Description of Figure 137-1 follows" /><br />
<a id="sthref9099" href="img_text/arpls008.htm">Description of "Figure 137-1 DBMS_SQL Execution Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68190" class="refsect4"><a id="i996891"></a>
<h5 class="refsect4">BIND_VARIABLE or BIND_ARRAY</h5>
<p>Many DML statements require that data in your program be input to Oracle. When you define a SQL statement that contains input data to be supplied at runtime, you must use placeholders in the SQL statement to mark where data must be supplied.</p>
<p><a id="sthref9100"></a>For each placeholder in the SQL statement, you must call one of the bind procedures, the <a href="#i1025085">BIND_ARRAY Procedures</a> or the <a href="#i1030093">BIND_VARIABLE Procedures</a>, to supply the value of a variable in your program (or the values of an array) to the placeholder. When the SQL statement is subsequently run, Oracle uses the data that your program has placed in the output and input, or bind, variables.</p>
<p><code>DBMS_SQL</code> can run a DML statement multiple times &mdash; each time with a different bind variable. The <code>BIND_ARRAY</code> procedure lets you bind a collection of scalars, each value of which is used as an input variable once for each <code>EXECUTE</code>. This is similar to the array interface supported by the OCI.</p>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68191" class="refsect4"><a id="i996897"></a>
<h5 class="refsect4">DEFINE_COLUMN, DEFINE_COLUMN_LONG, or DEFINE_ARRAY</h5>
<p>The columns of the row being selected in a <code>SELECT</code> statement are identified by their relative positions as they appear in the select list, from left to right. For a query, you must call one of the define procedures (<code>DEFINE_COLUMN</code>, <code>DEFINE_COLUMN_LONG</code>, or <code>DEFINE_ARRAY</code>) to specify the variables that are to receive the <code>SELECT</code> values, much the way an <code>INTO</code> clause does for a static query.</p>
<p>Use the <code>DEFINE_COLUMN_LONG</code> procedure to define <code>LONG</code> columns, in the same way that <code>DEFINE_COLUMN</code> is used to define non-<code>LONG</code> columns. You must call <code>DEFINE_COLUMN_LONG</code> before using the <code>COLUMN_VALUE_LONG</code> procedure to fetch from the <code>LONG</code> column.</p>
<p>Use the <code>DEFINE_ARRAY</code> procedure to define a PL/SQL collection into which you want to fetch rows in a single <code>SELECT</code> statement. <code>DEFINE_ARRAY</code> provides an interface to fetch multiple rows at one fetch. You must call <code>DEFINE_ARRAY</code> before using the <code>COLUMN_VALUE</code> procedure to fetch the&nbsp;rows.</p>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68192" class="refsect4"><a id="BABBFFFJ"></a>
<h5 class="refsect4">EXECUTE</h5>
<p>Call the <code>EXECUTE</code> function to run your SQL statement.</p>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68193" class="refsect4"><a id="i996905"></a>
<h5 class="refsect4">FETCH_ROWS or EXECUTE_AND_FETCH</h5>
<p>The <code>FETCH_ROWS</code> function retrieves the rows that satisfy the query. Each successive fetch retrieves another set of rows, until the fetch is unable to retrieve anymore rows. Instead of calling <code>EXECUTE</code> and then <code>FETCH_ROWS</code>, you may find it more efficient to call <code>EXECUTE_AND_FETCH</code> if you are calling <code>EXECUTE</code> for a single execution.</p>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68194" class="refsect4"><a id="i996908"></a>
<h5 class="refsect4">VARIABLE_VALUE, COLUMN_VALUE, or COLUMN_VALUE_LONG</h5>
<p>For queries, call <code>COLUMN_VALUE</code> to determine the value of a column retrieved by the <code>FETCH_ROWS</code> call. For anonymous blocks containing calls to <code>PL</code>/<code>SQL</code> procedures or DML statements with <code>returning</code> clause, call <code>VARIABLE_VALUE</code> to retrieve the values assigned to the output variables when statements were run.</p>
<p>To fetch just part of a <code>LONG</code> database column (which can be up to two gigabytes in size), use the <code>COLUMN_VALUE_LONG</code> procedure. You can specify the offset (in bytes) into the column value, and the number of bytes to&nbsp;fetch.</p>
<br /></div>
<!-- class="refsect4" -->
<div id="ARPLS68195" class="refsect4"><a id="i996912"></a>
<h5 class="refsect4">CLOSE_CURSOR</h5>
<p>When you no longer need a cursor for a session, close the cursor by calling <code>CLOSE_CURSOR</code>. If you are using an Oracle Open Gateway, then you may need to close cursors at other times as well. Consult your <span class="italic">Oracle Open Gateway</span> documentation for additional information.</p>
<p>If you neglect to close a cursor, then the memory used by that cursor remains allocated even though it is no longer needed.</p>
<br /></div>
<!-- class="refsect4" --></div>
<!-- class="refsect3" -->
<div id="ARPLS68196" class="refsect3"><a id="BABECIBG"></a>
<h4 class="refsect3">Processing Queries</h4>
<p>If you are using dynamic SQL to process a query, then you must perform the following steps:</p>
<ol>
<li>
<p>Specify the variables that are to receive the values returned by the&nbsp;<code>SELECT</code> statement by calling the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, the <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, or the <a href="#i1025685">DEFINE_ARRAY Procedure</a>.</p>
</li>
<li>
<p>Run your <code>SELECT</code> statement by calling the <a href="#i1025983">EXECUTE Function</a>.</p>
</li>
<li>
<p>Call the <a href="#i1026065">FETCH_ROWS Function</a> (or <code>EXECUTE_AND_FETCH</code>) to retrieve the rows&nbsp;that satisfied your query.</p>
</li>
<li>
<p>Call <a href="#i1025449">COLUMN_VALUE Procedure</a> or <a href="#i1025399">COLUMN_VALUE_LONG Procedure</a> to determine the&nbsp;value of a column retrieved by the <a href="#i1026065">FETCH_ROWS Function</a> for your query. If you used anonymous blocks containing calls to PL/SQL procedures, then you must call the <a href="#i998371">VARIABLE_VALUE Procedures</a> to retrieve the values assigned to the output variables of these procedures.</p>
</li>
</ol>
</div>
<!-- class="refsect3" -->
<div id="ARPLS68197" class="refsect3"><a id="BABFJHJF"></a>
<h4 class="refsect3">Processing Updates, Inserts, and Deletes</h4>
<p>If you are using dynamic SQL to process an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, then you must perform the following steps:</p>
<ol>
<li>
<p>You must first run your <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code> statement by calling the <a href="#i1025983">EXECUTE Function</a>.</p>
</li>
<li>
<p>If statements have the <code>returning</code> clause, then you must call the <a href="#i998371">VARIABLE_VALUE Procedures</a> to retrieve the values assigned to the output variables.</p>
</li>
</ol>
</div>
<!-- class="refsect3" -->
<div id="ARPLS68198" class="refsect3"><a id="i1027496"></a>
<h4 class="refsect3">Locating Errors</h4>
<p>There are additional functions in the DBMS_SQL package for obtaining information about the last referenced cursor in the session. The values returned by these functions are only meaningful immediately after a SQL statement is run. In addition, some error-locating functions are only meaningful after certain DBMS_SQL calls. For example, you call the <a href="#i1026408">LAST_ERROR_POSITION Function</a> immediately after a PARSE.</p>
</div>
<!-- class="refsect3" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68199" class="refsect2"><a id="i996963"></a>
<hr />
<h3 class="refsect2">Examples</h3>
<p>This section provides example procedures that make use of the <code>DBMS_SQL</code> package.</p>
<p class="subhead2"><a id="ARPLS68200"></a>Example 1</p>
<p>This example does not require the use of dynamic SQL because the text of the statement is known at compile time, but it illustrate the basic concept underlying the package.</p>
<p>The <code>DEMO</code> procedure deletes all of the employees from the <code>EMP</code> table whose salaries are greater than the salary that you specify when you run <code>DEMO</code>.</p>
<pre>
CREATE OR REPLACE PROCEDURE demo(salary IN NUMBER) AS
    cursor_name INTEGER;
    rows_processed INTEGER;
BEGIN
    cursor_name := dbms_sql.open_cursor;
    DBMS_SQL.PARSE(cursor_name, 'DELETE FROM emp WHERE sal &gt; :x',
                   DBMS_SQL.NATIVE);
    DBMS_SQL.BIND_VARIABLE(cursor_name, ':x', salary);
    rows_processed := DBMS_SQL.EXECUTE(cursor_name);
    DBMS_SQL.CLOSE_CURSOR(cursor_name);
EXCEPTION
WHEN OTHERS THEN
    DBMS_SQL.CLOSE_CURSOR(cursor_name);
END;
</pre>
<p class="subhead2"><a id="ARPLS68201"></a>Example 2</p>
<p>The following sample procedure is passed a SQL statement, which it then parses and runs:</p>
<pre>
CREATE OR REPLACE PROCEDURE exec(STRING IN varchar2) AS
    cursor_name INTEGER;
    ret INTEGER;
BEGIN
   cursor_name := DBMS_SQL.OPEN_CURSOR;
  
</pre>
<p>DDL statements are run by the parse call, which performs the implied commit.</p>
<pre>
   DBMS_SQL.PARSE(cursor_name, string, DBMS_SQL.NATIVE);
   ret := DBMS_SQL.EXECUTE(cursor_name);
   DBMS_SQL.CLOSE_CURSOR(cursor_name);
END;
</pre>
<p>Creating such a procedure enables you to perform the following operations:</p>
<ul>
<li>
<p>The SQL statement can be dynamically generated at runtime by the calling program.</p>
</li>
<li>
<p>The SQL statement can be a DDL statement or a DML without binds.</p>
</li>
</ul>
<p>For example, after creating this procedure, you could make the following call:</p>
<pre>
exec('create table acct(c1 integer)');
</pre>
<p>You could even call this procedure remotely, as shown in the following example. This lets you perform remote DDL.</p>
<pre>
exec@hq.com('CREATE TABLE acct(c1 INTEGER)');
</pre>
<p class="subhead2"><a id="ARPLS68202"></a>Example 3</p>
<p>The following sample procedure is passed the names of a source and a destination table, and copies the rows from the source table to the destination table. This sample procedure assumes that both the source and destination tables have the following columns:</p>
<pre>
id        of type NUMBER
name      of type VARCHAR2(30)
birthdate of type DATE
</pre>
<p>This procedure does not specifically require the use of dynamic SQL; however, it illustrates the concepts of this package.</p>
<pre>
CREATE OR REPLACE PROCEDURE copy ( 
     source      IN VARCHAR2, 
     destination IN VARCHAR2) IS 
     id_var             NUMBER; 
     name_var           VARCHAR2(30); 
     birthdate_var      DATE; 
     source_cursor      INTEGER; 
     destination_cursor INTEGER; 
     ignore             INTEGER; 
  BEGIN 
 
  -- Prepare a cursor to select from the source table: 
     source_cursor := dbms_sql.open_cursor; 
     DBMS_SQL.PARSE(source_cursor, 
         'SELECT id, name, birthdate FROM ' || source, 
          DBMS_SQL.NATIVE); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 1, id_var); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 2, name_var, 30); 
     DBMS_SQL.DEFINE_COLUMN(source_cursor, 3, birthdate_var); 
     ignore := DBMS_SQL.EXECUTE(source_cursor); 
 
  -- Prepare a cursor to insert into the destination table: 
     destination_cursor := DBMS_SQL.OPEN_CURSOR; 
     DBMS_SQL.PARSE(destination_cursor, 
                  'INSERT INTO ' || destination || 
                  ' VALUES (:id_bind, :name_bind, :birthdate_bind)', 
                   DBMS_SQL.NATIVE); 
 
  -- Fetch a row from the source table and insert it into the destination table: 
     LOOP 
       IF DBMS_SQL.FETCH_ROWS(source_cursor)&gt;0 THEN 
         -- get column values of the row 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 1, id_var); 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 2, name_var); 
         DBMS_SQL.COLUMN_VALUE(source_cursor, 3, birthdate_var); 
 
  -- Bind the row into the cursor that inserts into the destination table. You 
  -- could alter this example to require the use of dynamic SQL by inserting an 
  -- if condition before the bind. 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, ':id_bind', id_var); 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, ':name_bind', name_var); 
        DBMS_SQL.BIND_VARIABLE(destination_cursor, ':birthdate_bind', 
birthdate_var); 
        ignore := DBMS_SQL.EXECUTE(destination_cursor); 
      ELSE 
 
  -- No more rows to copy: 
        EXIT; 
      END IF; 
    END LOOP; 
 
  -- Commit and close all cursors: 
     COMMIT; 
     DBMS_SQL.CLOSE_CURSOR(source_cursor); 
     DBMS_SQL.CLOSE_CURSOR(destination_cursor); 
   EXCEPTION 
     WHEN OTHERS THEN 
       IF DBMS_SQL.IS_OPEN(source_cursor) THEN 
         DBMS_SQL.CLOSE_CURSOR(source_cursor); 
       END IF; 
       IF DBMS_SQL.IS_OPEN(destination_cursor) THEN 
         DBMS_SQL.CLOSE_CURSOR(destination_cursor); 
       END IF; 
       RAISE; 
  END; 
/ 
</pre>
<p class="subhead2"><a id="i997061"></a><a id="ARPLS68203"></a>Examples 3, 4, and 5:&nbsp;Bulk DML</p>
<p>This series of examples shows how to use bulk array binds (table items) in the SQL DML statements <code>INSERT</code>, <code>UPDATE</code> and <code>DELETE</code>.</p>
<p>Here is an example of a bulk <code>INSERT</code> statement that demonstrates adding seven new employees to the <code>emp</code> table:</p>
<pre>
DECLARE
  stmt VARCHAR2(200);
  empno_array      DBMS_SQL.NUMBER_TABLE;
  empname_array    DBMS_SQL.VARCHAR2_TABLE;
  jobs_array       DBMS_SQL.VARCHAR2_TABLE;
  mgr_array        DBMS_SQL.NUMBER_TABLE;
  hiredate_array   DBMS_SQL.VARCHAR2_TABLE;
  sal_array        DBMS_SQL.NUMBER_TABLE;
  comm_array       DBMS_SQL.NUMBER_TABLE;
  deptno_array     DBMS_SQL.NUMBER_TABLE;
  c                NUMBER;
  dummy            NUMBER;
BEGIN
  empno_array(1):= 9001;
  empno_array(2):= 9002;
  empno_array(3):= 9003;
  empno_array(4):= 9004;
  empno_array(5):= 9005;
  empno_array(6):= 9006;
  empno_array(7):= 9007;

  empname_array(1) := 'Dopey';
  empname_array(2) := 'Grumpy';
  empname_array(3) := 'Doc';
  empname_array(4) := 'Happy';
  empname_array(5) := 'Bashful';
  empname_array(6) := 'Sneezy';
  empname_array(7) := 'Sleepy';

  jobs_array(1) := 'Miner';
  jobs_array(2) := 'Miner';
  jobs_array(3) := 'Miner';
  jobs_array(4) := 'Miner';
  jobs_array(5) := 'Miner';
  jobs_array(6) := 'Miner';
  jobs_array(7) := 'Miner';

  mgr_array(1) := 9003;
  mgr_array(2) := 9003;
  mgr_array(3) := 9003;
  mgr_array(4) := 9003;
  mgr_array(5) := 9003;
  mgr_array(6) := 9003;
  mgr_array(7) := 9003;

  hiredate_array(1) := '06-DEC-2006';
  hiredate_array(2) := '06-DEC-2006';
  hiredate_array(3) := '06-DEC-2006';
  hiredate_array(4) := '06-DEC-2006';
  hiredate_array(5) := '06-DEC-2006';
  hiredate_array(6) := '06-DEC-2006';
  hiredate_array(7) := '06-DEC-2006';

  sal_array(1):= 1000;
  sal_array(2):= 1000;
  sal_array(3):= 1000;
  sal_array(4):= 1000;
  sal_array(5):= 1000;
  sal_array(6):= 1000;
  sal_array(7):= 1000;

  comm_array(1):= 0;
  comm_array(2):= 0;
  comm_array(3):= 0;
  comm_array(4):= 0;
  comm_array(5):= 0;
  comm_array(6):= 0;
  comm_array(7):= 0;

  deptno_array(1):= 11;
  deptno_array(2):= 11;
  deptno_array(3):= 11;
  deptno_array(4):= 11;
  deptno_array(5):= 11;
  deptno_array(6):= 11;
  deptno_array(7):= 11;

  stmt := 'INSERT INTO emp VALUES(
     :num_array, :name_array, :jobs_array, :mgr_array, :hiredate_array, 
     :sal_array, :comm_array, :deptno_array)';
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, ':num_array', empno_array);
  DBMS_SQL.BIND_ARRAY(c, ':name_array', empname_array);
  DBMS_SQL.BIND_ARRAY(c, ':jobs_array', jobs_array);
  DBMS_SQL.BIND_ARRAY(c, ':mgr_array', mgr_array);
  DBMS_SQL.BIND_ARRAY(c, ':hiredate_array', hiredate_array);
  DBMS_SQL.BIND_ARRAY(c, ':sal_array', sal_array);
  DBMS_SQL.BIND_ARRAY(c, ':comm_array', comm_array);
  DBMS_SQL.BIND_ARRAY(c, ':deptno_array', deptno_array);

  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
SHOW ERRORS;
</pre>
<p>Here is an example of a bulk <code>UPDATE</code> statement that demonstrates updating salaries for four existing employees in the <code>emp</code> table:</p>
<pre>
DECLARE
  stmt VARCHAR2(200);
  empno_array     DBMS_SQL.NUMBER_TABLE;
  salary_array    DBMS_SQL.NUMBER_TABLE;
  c               NUMBER;
  dummy           NUMBER;
BEGIN
 
  empno_array(1):= 7369;
  empno_array(2):= 7876;
  empno_array(3):= 7900;
  empno_array(4):= 7934;
 
  salary_array(1) := 10000;
  salary_array(2) := 10000;
  salary_array(3) := 10000;
  salary_array(4) := 10000;
 
  stmt := 'update emp set sal = :salary_array
    WHERE empno = :num_array';
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, ':num_array', empno_array);
  DBMS_SQL.BIND_ARRAY(c, ':salary_array', salary_array);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
 
  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
</pre>
<p>In a <code>DELETE</code> statement, for example, you could bind in an array in the <code>WHERE</code> clause and have the statement be run for each element in the&nbsp;array:</p>
<pre>
DECLARE
  stmt VARCHAR2(200);
  dept_no_array DBMS_SQL.NUMBER_TABLE;
  c NUMBER;
  dummy NUMBER;
begin
  dept_no_array(1) := 10; dept_no_array(2) := 20;
  dept_no_array(3) := 30; dept_no_array(4) := 40;
  dept_no_array(5) := 30; dept_no_array(6) := 40;
  stmt := 'delete from emp where deptno = :dept_array';
  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_ARRAY(c, ':dept_array', dept_no_array, 1, 4);
  dummy := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c); 

  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/ 
</pre>
<p>In the preceding example, only elements 1 through 4 are used as specified by the <code>BIND_ARRAY</code> call. Each element of the array potentially deletes a large number of employees from the database.</p>
<p class="subhead2"><a id="i997149"></a><a id="ARPLS68204"></a>Examples 6 and 7:&nbsp;Defining an Array</p>
<p>The following examples show how to use the <code>DEFINE_ARRAY</code> procedure:</p>
<pre>
declare
  c       NUMBER;
  d       NUMBER;
  n_tab   DBMS_SQL.NUMBER_TABLE;
  indx    NUMBER := -10;
BEGIN
  c := DBMS_SQL.OPEN_CURSOR;
  dBMS_SQL.PARSE(c, 'select n from t order by 1', DBMS_SQL.NATIVE);

  DBMS_SQL.DEFINE_ARRAY(c, 1, n_tab, 10, indx);

  d := DBMS_SQL.EXECUTE(c);
  loop
    d := DBMS_SQL.FETCH_ROWS(c);

    DBMS_SQL.COLUMN_VALUE(c, 1, n_tab);

    EXIT WHEN d != 10;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(c);

  EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
</pre>
<p>Each time the preceding example does a <a href="#i1026065">FETCH_ROWS Function</a> call, it fetches 10 rows that are kept in <code>DBMS_SQL</code> buffers. When the <a href="#i1025449">COLUMN_VALUE Procedure</a> call is run, those rows move into the PL/SQL table specified (in this case <code>n_tab</code>), at positions -10 to -1, as specified in the <code>DEFINE</code> statements. When the second batch is fetched in the loop, the rows go to positions 0 to 9; and so on.</p>
<p>A current index into each array is maintained automatically. This index is initialized to "indx" at <code>EXECUTE</code> and keeps getting updated every time a <code>COLUMN_VALUE</code> call is made. If you re-execute at any point, then the current index for each <code>DEFINE</code> is re-initialized to "indx".</p>
<p>In this way the entire result of the query is fetched into the table. When <code>FETCH_ROWS</code> cannot fetch 10 rows, it returns the number of rows actually fetched (if no rows could be fetched, then it returns zero) and exits the loop.</p>
<p>Here is another example of using the <code>DEFINE_ARRAY</code> procedure:</p>
<p>Consider a table <code>MULTI_TAB</code> defined as:</p>
<pre>
CREATE TABLE multi_tab (num NUMBER, 
                        dat1 DATE, 
                        var VARCHAR2(24), 
                        dat2 DATE) 
</pre>
<p>To select everything from this table and move it into four PL/SQL tables, you could use the following simple program:</p>
<pre>
declare
  c       NUMBER;
  d       NUMBER;
  n_tab  DBMS_SQL.NUMBER_TABLE;
  d_tab1 DBMS_SQL.DATE_TABLE;
  v_tab  DBMS_SQL.VARCHAR2_TABLE;
  d_tab2 DBMS_SQL.DATE_TABLE;
  indx NUMBER := 10;
BEGIN

  c := DBMS_SQL.OPEN_CURSOR;
  DBMS_SQL.PARSE(c, 'select * from multi_tab order by 1', DBMS_SQL.NATIVE);

  DBMS_SQL.DEFINE_ARRAY(c, 1, n_tab,  5, indx);
  DBMS_SQL.DEFINE_ARRAY(c, 2, d_tab1, 5, indx);
  DBMS_SQL.DEFINE_ARRAY(c, 3, v_tab,  5, indx);
  DBMS_SQL.DEFINE_ARRAY(c, 4, d_tab2, 5, indx);

  d := DBMS_SQL.EXECUTE(c);

  loop
    d := DBMS_SQL.FETCH_ROWS(c);

    DBMS_SQL.COLUMN_VALUE(c, 1, n_tab);
    DBMS_SQL.COLUMN_VALUE(c, 2, d_tab1);
    DBMS_SQL.COLUMN_VALUE(c, 3, v_tab);
    DBMS_SQL.COLUMN_VALUE(c, 4, d_tab2);
  
    EXIT WHEN d != 5;
  END LOOP;

  DBMS_SQL.CLOSE_CURSOR(c);

/* 
</pre>
<p>The four tables can be used for anything. One usage might be to use <code>BIND_ARRAY</code> to move the rows to another table by using a statement such as '<code>INSERT</code> into <code>SOME_T</code> values (:a, :b, :c, :d);</p>
<pre>
*/

EXCEPTION WHEN OTHERS THEN
    IF DBMS_SQL.IS_OPEN(c) THEN
      DBMS_SQL.CLOSE_CURSOR(c);
    END IF;
    RAISE;
END;
/
</pre>
<p class="subhead2"><a id="i997238"></a><a id="ARPLS68205"></a>Example 8:&nbsp;Describe Columns</p>
<p>This can be used as a substitute to the SQL*Plus <code>DESCRIBE</code> call by using a <code>SELECT</code> * query on the table that you want to describe.</p>
<pre>
DECLARE
  c           NUMBER;
  d           NUMBER;
  col_cnt     INTEGER;
  f           BOOLEAN;
  rec_tab     DBMS_SQL.DESC_TAB;
  col_num    NUMBER;
  PROCEDURE print_rec(rec in DBMS_SQL.DESC_REC) IS
  BEGIN
    DBMS_OUTPUT.NEW_LINE;
    DBMS_OUTPUT.PUT_LINE('col_type            =    '
                         || rec.col_type);
    DBMS_OUTPUT.PUT_LINE('col_maxlen          =    '
                         || rec.col_max_len);
    DBMS_OUTPUT.PUT_LINE('col_name            =    '
                         || rec.col_name);
    DBMS_OUTPUT.PUT_LINE('col_name_len        =    '
                         || rec.col_name_len);
    DBMS_OUTPUT.PUT_LINE('col_schema_name     =    '
                         || rec.col_schema_name);
    DBMS_OUTPUT.PUT_LINE('col_schema_name_len =    '
                         || rec.col_schema_name_len);
    DBMS_OUTPUT.PUT_LINE('col_precision       =    '
                         || rec.col_precision);
    DBMS_OUTPUT.PUT_LINE('col_scale           =    '
                         || rec.col_scale);
    DBMS_OUTPUT.PUT('col_null_ok         =    ');
    IF (rec.col_null_ok) THEN
      DBMS_OUTPUT.PUT_LINE('true');
    ELSE
      DBMS_OUTPUT.PUT_LINE('false');
    END IF;
  END;
BEGIN
  c := DBMS_SQL.OPEN_CURSOR;

  DBMS_SQL.PARSE(c, 'SELECT * FROM scott.bonus', DBMS_SQL.NATIVE);
 
  d := DBMS_SQL.EXECUTE(c);
 
  DBMS_SQL.DESCRIBE_COLUMNS(c, col_cnt, rec_tab);

/*
 * Following loop could simply be for j in 1..col_cnt loop.
 * Here we are simply illustrating some of the PL/SQL table
 * features.
 */
  col_num := rec_tab.first;
  IF (col_num IS NOT NULL) THEN
    LOOP
      print_rec(rec_tab(col_num));
      col_num := rec_tab.next(col_num);
      EXIT WHEN (col_num IS NULL);
    END LOOP;
  END IF;
 
  DBMS_SQL.CLOSE_CURSOR(c);
END;
/
</pre>
<p class="subhead2"><a id="ARPLS68206"></a>Example 9: RETURNING clause</p>
<p>The <code>RETURNING</code> clause was added to DML statements in an earlier Oracle database release. With this clause, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements can return values of expressions. These values are returned in bind variables.</p>
<p><code>DBMS_SQL</code>.<code>BIND_VARIABLE</code> is used to bind these outbinds if a single row is inserted, updated, or deleted. If multiple rows are inserted, updated, or deleted, then <code>DBMS_SQL</code>.<code>BIND_ARRAY</code> is used. <code>DBMS_SQL</code>.<code>VARIABLE_VALUE</code> must be called to get the values in these bind variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is similar to <code>DBMS_SQL</code>.<code>VARIABLE_VALUE</code>, which must be called after running a PL/SQL block with an out-bind inside <code>DBMS_SQL</code>.</div>
<p>i) Single row insert</p>
<pre>
      CREATE OR REPLACE PROCEDURE single_Row_insert
           (c1 NUMBER, c2 NUMBER, r OUT NUMBER) is
      c NUMBER;
      n NUMBER;
      begin
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'INSERT INTO tab VALUES (:bnd1, :bnd2) ' ||
                          'RETURNING c1*c2 INTO :bnd3', DBMS_SQL.NATIVE);
     DBMS_SQL.BIND_VARIABLE(c, 'bnd1', c1);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd2', c2);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd3', r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd3', r); -- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
 
</pre>
<p>ii) Single row update</p>
<pre>
      CREATE OR REPLACE PROCEDURE single_Row_update
           (c1 NUMBER, c2 NUMBER, r out NUMBER) IS
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'UPDATE tab SET c1 = :bnd1, c2 = :bnd2 ' ||
                          'WHERE rownum &lt; 2 ' || 
                          'RETURNING c1*c2 INTO :bnd3', DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd1', c1);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd2', c2);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd3', r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd3', r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<p>iii) Single row delete</p>
<pre>
      CREATE OR REPLACE PROCEDURE single_Row_Delete
           (c1 NUMBER, r OUT NUMBER) is
      c NUMBER;
      n number;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'DELETE FROM tab WHERE ROWNUM = :bnd1 ' ||
                      'RETURNING c1*c2 INTO :bnd2', DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd1', c1);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd2', r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd2', r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
 
</pre>
<p>iv) Multiple row insert</p>
<pre>
      CREATE OR REPLACE PROCEDURE multi_Row_insert
           (c1 DBMS_SQL.NUMBER_TABLE, c2 DBMS_SQL.NUMBER_TABLE, 
            r OUT DBMS_SQL.NUMBER_TABLE) is
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'insert into tab VALUES (:bnd1, :bnd2) ' ||
                          'RETURNING c1*c2 INTO :bnd3', DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, 'bnd1', c1);
        DBMS_SQL.BIND_ARRAY(c, 'bnd2', c2);
        DBMS_SQL.BIND_ARRAY(c, 'bnd3', r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd3', r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<p>v) Multiple row Update.</p>
<pre>
      CREATE OR REPLACE PROCEDURE multi_Row_update
           (c1 NUMBER, c2 NUMBER, r OUT DBMS_SQL.NUMBER_TABLE) IS
      c NUMBER;
      n NUMBER;
     BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'UPDATE tab SET c1 = :bnd1 WHERE c2 = :bnd2 ' ||
                          'RETURNING c1*c2 INTO :bnd3', DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd1', c1);
        DBMS_SQL.BIND_VARIABLE(c, 'bnd2', c2);
        DBMS_SQL.BIND_ARRAY(c, 'bnd3', r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd3', r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
bnd1 and bnd2 can be arrays as well. The value of the expression for all the rows updated will be in bnd3. There is no way of differentiating which rows were updated of each value of bnd1 and bnd2.</div>
<p>vi) Multiple row delete</p>
<pre>
      CREATE OR REPLACE PROCEDURE multi_row_delete
           (c1 DBMS_SQL.NUMBER_TABLE,
            r OUT DBMS_SQL.NUMBER_TABLE) is
      c NUMBER;
      n NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'DELETE FROM tab WHERE c1 = :bnd1' ||
                          'RETURNING c1*c2 INTO :bnd2', DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, 'bnd1', c1);
        DBMS_SQL.BIND_ARRAY(c, 'bnd2', r);
        n := DBMS_SQL.EXECUTE(c); 
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd2', r);-- get value of outbind variable
        DBMS_SQL.CLOSE_CURSOR(c);
      END;
      /
</pre>
<p>vii) Out-bind in bulk PL/SQL</p>
<pre>
      CREATE OR REPLACE PROCEDURE foo (n NUMBER, square OUT NUMBER) IS
      BEGIN square := n * n; END;/
 
      CREATE OR REPLACE PROCEDURE bulk_plsql 
         (n DBMS_SQL.NUMBER_TABLE, square OUT DBMS_SQL.NUMBER_TABLE) IS
      c NUMBER;
      r NUMBER;
      BEGIN
        c := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(c, 'BEGIN foo(:bnd1, :bnd2); END;', DBMS_SQL.NATIVE);
        DBMS_SQL.BIND_ARRAY(c, 'bnd1', n);
        DBMS_SQL.BIND_ARRAY(c, 'bnd2', square);
        r := DBMS_SQL.EXECUTE(c);
        DBMS_SQL.VARIABLE_VALUE(c, 'bnd2', square);
     END;
     /
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>DBMS_SQL</code>.<code>BIND_ARRAY</code> of <code>number_Table</code> internally binds a number. The number of times statement is run depends on the number of elements in an inbind array.</div>
<p class="subhead2"><a id="ARPLS68207"></a>Example 10: Binds and Defines of User-defined Types in DBMS_SQL</p>
<pre>
CREATE TYPE dnames_var IS VARRAY(7) OF VARCHAR2(30)
/
 
CREATE TABLE depts (region VARCHAR2(25), dept_names dnames_var)
/
 
INSERT INTO depts VALUES('Europe', dnames_var('Shipping','Sales','Finance'))
/
INSERT INTO depts VALUES('Americas', dnames_var('Sales','Finance','Shipping'))
/
INSERT INTO depts 
     VALUES('Asia', dnames_var('Finance','Payroll','Shipping','Sales'))
/
 
CREATE OR REPLACE PROCEDURE update_depts(new_dnames dnames_var, region VARCHAR2) IS
   some_dnames dnames_var;
   c      NUMBER;
   r      NUMBER;
   sql_stmt VARCHAR2(32767) :=
    'UPDATE depts SET dept_names = :b1 WHERE region = :b2 RETURNING dept_names INTO :b3';
 
BEGIN
 
   c := DBMS_SQL.OPEN_CURSOR;
 
   DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
 
   DBMS_SQL.BIND_VARIABLE(c, 'b1', new_dnames);
   DBMS_SQL.BIND_VARIABLE(c, 'b2', region);
   DBMS_SQL.BIND_VARIABLE(c, 'b3', some_dnames);
 
   r := DBMS_SQL.EXECUTE(c);
 
   -- Get value of outbind variable
   DBMS_SQL.VARIABLE_VALUE(c, 'b3', some_dnames);
 
   DBMS_SQL.CLOSE_CURSOR(c);
 
   -- select dept_names
   sql_stmt := 'SELECT dept_names FROM depts WHERE region = :b1';
 
   c := DBMS_SQL.OPEN_CURSOR;
   DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
 
   DBMS_SQL.DEFINE_COLUMN(c, 1, some_dnames);
   DBMS_SQL.BIND_VARIABLE(c, 'b1', region);
 
   r := DBMS_SQL.EXECUTE_AND_FETCH(c);
 
   DBMS_SQL.COLUMN_VALUE(c, 1, some_dnames);
 
   DBMS_SQL.CLOSE_CURSOR(c);
 
    -- loop through some_dnames collections
    FOR i IN some_dnames.FIRST .. some_dnames.LAST  LOOP
        DBMS_OUTPUT.PUT_LINE('Dept. Name = ' || some_dnames(i) || ' Updated!');
    END LOOP;
END;
/
 
DECLARE
  new_dnames dnames_var;
BEGIN
  new_dnames := dnames_var('Benefits', 'Advertising', 'Contracting', 
                           'Executive', 'Marketing');
  update_depts(new_dnames, 'Asia');
END;
/
</pre></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="CHDEEDCH"></a>
<hr />
<div id="ARPLS68208" class="refsect1"><!-- infolevel="all" infotype="General" -->
<h2 class="refsect1">Data Structures</h2>
<p>The <code>DBMS_SQL</code> package defines the following <code>RECORD</code> types and <code>TABLE</code> types.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9101"></a>RECORD Types</p>
<ul>
<li>
<p><a href="#CHDCIIBF">DESC_REC Record Type</a></p>
</li>
<li>
<p><a href="#CHDGJIHF">DESC_REC2 Record Type</a></p>
</li>
<li>
<p><a href="#CHDDFEGC">DESC_REC3 Record Type</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9102"></a>TABLE Types</p>
<ul>
<li>
<p><a href="#CHDBDAGH">BFILE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHGBCF">BINARY_DOUBLE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHIDEF">BINARY_FLOAT_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDFBBED">BLOB_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDBIGIC">CLOB_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHGGFH">DATE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDFBCDE">DESC_TAB Table Type</a></p>
</li>
<li>
<p><a href="#CHDIJCJA">DESC_TAB2 Table Type</a></p>
</li>
<li>
<p><a href="#CHDBGCBE">DESC_TAB3 Table Type</a></p>
</li>
<li>
<p><a href="#CHDIGEGH">INTERVAL_DAY_TO_SECOND_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDEHFCI">INTERVAL_YEAR_TO_MONTH_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDGFFAD">NUMBER_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDJHAEC">TIME_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CIHCABIA">TIME_WITH_TIME_ZONE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDCEDDD">TIMESTAMP_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDEDCEA">TIMESTAMP_WITH_LTZ_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CIHHGCBF">TIMESTAMP_WITH_TIME_ZONE_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDICIBC">UROWID_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDHHECG">VARCHAR2_TABLE Table Type</a></p>
</li>
<li>
<p><a href="#CHDEGGIG">VARCHAR2A Table Type</a></p>
</li>
<li>
<p><a href="#CHDICCED">VARCHAR2S Table Type</a></p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div id="ARPLS68209" class="refsect2"><a id="CHDCIIBF"></a>
<hr />
<h3 class="refsect2"><a id="sthref9103"></a>DESC_REC Record Type</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This type has been deprecated in favor of the <a href="#CHDGJIHF">DESC_REC2 Record Type</a>.</div>
<p>This record type holds the describe information for a single column in a dynamic query. It is the element type of the <code>DESC_TAB</code> table type and the <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9104"></a>Syntax</p>
<pre>
TYPE desc_rec IS RECORD (
      col_type            BINARY_INTEGER := 0,
      col_max_len         BINARY_INTEGER := 0,
      col_name            VARCHAR2(32)   := '',
      col_name_len        BINARY_INTEGER := 0,
      col_schema_name     VARCHAR2(32)   := '',
      col_schema_name_len BINARY_INTEGER := 0,
      col_precision       BINARY_INTEGER := 0,
      col_scale           BINARY_INTEGER := 0,
      col_charsetid       BINARY_INTEGER := 0,
      col_charsetform     BINARY_INTEGER := 0,
      col_null_ok         BOOLEAN        := TRUE);
TYPE desc_tab IS TABLE OF desc_rec INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9105"></a>Fields</p>
<div id="ARPLS68210" class="tblformal">
<p class="titleintable"><a id="sthref9106"></a><a id="sthref9107"></a>Table 137-2 DESC_REC Fields</p>
<table class="cellalignment1229" title="DESC_REC Fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t10">Field</th>
<th class="cellalignment1227" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t10" headers="r1c1-t10">
<p><code>col_type</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t10 r1c2-t10">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t10" headers="r1c1-t10">
<p><code>col_max_len</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t10 r1c2-t10">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t10" headers="r1c1-t10">
<p><code>col_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t10 r1c2-t10">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t10" headers="r1c1-t10">
<p><code>col_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t10 r1c2-t10">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t10" headers="r1c1-t10">
<p><code>col_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t10 r1c2-t10">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t10" headers="r1c1-t10">
<p><code>col_schema_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t10 r1c2-t10">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t10" headers="r1c1-t10">
<p><code>col_precision</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t10 r1c2-t10">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t10" headers="r1c1-t10">
<p><code>col_scale</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t10 r1c2-t10">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t10" headers="r1c1-t10">
<p><code>col_charsetid</code></p>
</td>
<td class="cellalignment1228" headers="r10c1-t10 r1c2-t10">
<p>Column character set id</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t10" headers="r1c1-t10">
<p><code>col_charsetform</code></p>
</td>
<td class="cellalignment1228" headers="r11c1-t10 r1c2-t10">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t10" headers="r1c1-t10">
<p><code>col_null_ok</code></p>
</td>
<td class="cellalignment1228" headers="r12c1-t10 r1c2-t10">
<p><code>NULL</code> column flag; <code>TRUE</code>, if <code>NULL</code> possible</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68211" class="refsect2"><a id="CHDGJIHF"></a>
<hr />
<h3 class="refsect2"><a id="sthref9108"></a>DESC_REC2 Record Type</h3>
<p><code>DESC_REC2</code> is the element type of the <code>DESC_TAB2</code> table type and the <a href="#i1029368">DESCRIBE_COLUMNS2 Procedure</a>.</p>
<p>This record type is identical to <code>DESC_REC</code> except for the <code>col_name</code> field, which has been expanded to the maximum possible size for <code>VARCHAR2</code>. It is therefore preferred to <code>DESC_REC</code> because column name values can be greater than 32 characters. <code>DESC_REC</code> is deprecated as a result.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9109"></a>Syntax</p>
<pre>
TYPE desc_rec2 IS RECORD (
   col_type            binary_integer := 0,
   col_max_len         binary_integer := 0,
   col_name            varchar2(32767) := '',
   col_name_len        binary_integer := 0,
   col_schema_name     varchar2(32)   := '',
   col_schema_name_len binary_integer := 0,
   col_precision       binary_integer := 0,
   col_scale           binary_integer := 0,
   col_charsetid       binary_integer := 0,
   col_charsetform     binary_integer := 0,
   col_null_ok         boolean        := TRUE);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9110"></a>Fields</p>
<div id="ARPLS68212" class="tblformal">
<p class="titleintable"><a id="sthref9111"></a><a id="sthref9112"></a>Table 137-3 DESC_REC2 Fields</p>
<table class="cellalignment1229" title="DESC_REC2 Fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t11">Field</th>
<th class="cellalignment1227" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t11" headers="r1c1-t11">
<p><code>col_type</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t11 r1c2-t11">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t11" headers="r1c1-t11">
<p><code>col_max_len</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t11 r1c2-t11">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t11" headers="r1c1-t11">
<p><code>col_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t11 r1c2-t11">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t11" headers="r1c1-t11">
<p><code>col_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t11 r1c2-t11">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t11" headers="r1c1-t11">
<p><code>col_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t11 r1c2-t11">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t11" headers="r1c1-t11">
<p><code>col_schema_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t11 r1c2-t11">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t11" headers="r1c1-t11">
<p><code>col_precision</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t11 r1c2-t11">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t11" headers="r1c1-t11">
<p><code>col_scale</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t11 r1c2-t11">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t11" headers="r1c1-t11">
<p><code>col_charsetid</code></p>
</td>
<td class="cellalignment1228" headers="r10c1-t11 r1c2-t11">
<p>Column character set id</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t11" headers="r1c1-t11">
<p><code>col_charsetform</code></p>
</td>
<td class="cellalignment1228" headers="r11c1-t11 r1c2-t11">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t11" headers="r1c1-t11">
<p><code>col_null_ok</code></p>
</td>
<td class="cellalignment1228" headers="r12c1-t11 r1c2-t11">
<p><code>NULL</code> column flag; <code>TRUE</code>, if <code>NULL</code> possible</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68213" class="refsect2"><a id="CHDDFEGC"></a>
<hr />
<h3 class="refsect2"><a id="sthref9113"></a>DESC_REC3 Record Type</h3>
<p><code>DESC_REC3</code> is the element type of the <code>DESC_TAB3</code> table type and the <a href="#CHDJBBFH">DESCRIBE_COLUMNS3 Procedure</a>.</p>
<p><code>DESC_REC3</code> is identical to <code>DESC_REC2</code> except for two additional fields to hold the type name (<code>type_name</code>) and type name len (<code>type_name_len</code>) of a column in a dynamic query. These two fields hold the type name and type name length when the column is a user-defined type (a collection or object type). The <code>col_type_name</code> and <code>col_type_name_len</code> fields are only populated when the <code>col_type</code> field's value is 109, the Oracle type number for user-defined types.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9114"></a>Syntax</p>
<pre>
TYPE desc_rec3 IS RECORD (
   col_type               binary_integer := 0,
   col_max_len            binary_integer := 0,
   col_name               varchar2(32767) := '',
   col_name_len           binary_integer := 0,
   col_schema_name        varchar2(32) := '',
   col_schema_name_len    binary_integer := 0,
   col_precision          binary_integer := 0,
   col_scale              binary_integer := 0,
   col_charsetid          binary_integer := 0,
   col_charsetform        binary_integer := 0,
   col_null_ok            boolean := TRUE,
   col_type_name          varchar2(32767)   := '',
   col_type_name_len      binary_integer := 0);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9115"></a>Fields</p>
<div id="ARPLS68214" class="tblformal">
<p class="titleintable"><a id="sthref9116"></a><a id="sthref9117"></a>Table 137-4 DESC_REC3 Fields</p>
<table class="cellalignment1229" title="DESC_REC3 Fields" summary="This table describes the parameters of the DBMS_DEBUG.BREAKPOINT_INFO subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t12">Field</th>
<th class="cellalignment1227" id="r1c2-t12">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t12" headers="r1c1-t12">
<p><code>col_type</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t12 r1c2-t12">
<p>Type of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t12" headers="r1c1-t12">
<p><code>col_max_len</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t12 r1c2-t12">
<p>Maximum column length</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t12" headers="r1c1-t12">
<p><code>col_name</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t12 r1c2-t12">
<p>Name of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t12" headers="r1c1-t12">
<p><code>col_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t12 r1c2-t12">
<p>Length of column name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t12" headers="r1c1-t12">
<p><code>col_schema_name</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t12 r1c2-t12">
<p>Column schema name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t12" headers="r1c1-t12">
<p><code>col_schema_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t12 r1c2-t12">
<p>Length of column schema name</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t12" headers="r1c1-t12">
<p><code>col_precision</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t12 r1c2-t12">
<p>Precision of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t12" headers="r1c1-t12">
<p><code>col_scale</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t12 r1c2-t12">
<p>Scale of column</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t12" headers="r1c1-t12">
<p><code>col_charsetid</code></p>
</td>
<td class="cellalignment1228" headers="r10c1-t12 r1c2-t12">
<p>Column character set ID</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t12" headers="r1c1-t12">
<p><code>col_charsetform</code></p>
</td>
<td class="cellalignment1228" headers="r11c1-t12 r1c2-t12">
<p>Column character set form</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t12" headers="r1c1-t12">
<p><code>col_null_ok</code></p>
</td>
<td class="cellalignment1228" headers="r12c1-t12 r1c2-t12">
<p><code>NULL</code> column flag; <code>TRUE</code>, if <code>NULL</code> possible</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r13c1-t12" headers="r1c1-t12">
<p><code>col_type_name</code></p>
</td>
<td class="cellalignment1228" headers="r13c1-t12 r1c2-t12">
<p>User-define type column type name, this field is valid when <code>col_type</code> is 109</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r14c1-t12" headers="r1c1-t12">
<p><code>col_type_name_len</code></p>
</td>
<td class="cellalignment1228" headers="r14c1-t12 r1c2-t12">
<p>Length of user-define type column type name, this field is valid when <code>col_type</code> is 109</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68215" class="refsect2"><a id="CHDBDAGH"></a>
<hr />
<h3 class="refsect2"><a id="sthref9118"></a>BFILE_TABLE Table Type</h3>
<p>This is a table of <code>BFILE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9119"></a>Syntax</p>
<pre>
TYPE bfile_table IS TABLE OF BFILE INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68216" class="refsect2"><a id="CHDHGBCF"></a>
<hr />
<h3 class="refsect2"><a id="sthref9120"></a>BINARY_DOUBLE_TABLE Table Type</h3>
<p>This is a table of <code>BINARY_DOUBLE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9121"></a>Syntax</p>
<pre>
TYPE binary_double_table IS TABLE OF BINARY_DOUBLE INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68217" class="refsect2"><a id="CHDHIDEF"></a>
<hr />
<h3 class="refsect2"><a id="sthref9122"></a>BINARY_FLOAT_TABLE Table Type</h3>
<p>This is a table of <code>BINARY_FLOAT</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9123"></a>Syntax</p>
<pre>
TYPE binary_float_table IS TABLE OF BINARY_FLOAT INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68218" class="refsect2"><a id="CHDFBBED"></a>
<hr />
<h3 class="refsect2"><a id="sthref9124"></a>BLOB_TABLE Table Type</h3>
<p>This is a table of <code>BLOB</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9125"></a>Syntax</p>
<pre>
TYPE blob_table IS TABLE OF BLOB INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68219" class="refsect2"><a id="CHDBIGIC"></a>
<hr />
<h3 class="refsect2"><a id="sthref9126"></a>CLOB_TABLE Table Type</h3>
<p>This is a table of <code>CLOB</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9127"></a>Syntax</p>
<pre>
TYPE clob_table IS TABLE OF CLOB INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68220" class="refsect2"><a id="CHDHGGFH"></a>
<hr />
<h3 class="refsect2"><a id="sthref9128"></a>DATE_TABLE Table Type</h3>
<p>This is a table of <code>DATE</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9129"></a>Syntax</p>
<pre>
type date_table IS TABLE OF DATE INDEX BY BINARY_INTEGER; 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68221" class="refsect2"><a id="CHDFBCDE"></a>
<hr />
<h3 class="refsect2"><a id="sthref9130"></a>DESC_TAB Table Type</h3>
<p>This is a table of <a href="#CHDCIIBF">DESC_REC Record Type</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9131"></a>Syntax</p>
<pre>
TYPE desc_tab IS TABLE OF desc_rec INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68222" class="refsect2"><a id="CHDIJCJA"></a>
<hr />
<h3 class="refsect2"><a id="sthref9132"></a>DESC_TAB2 Table Type</h3>
<p>This is a table of <a href="#CHDGJIHF">DESC_REC2 Record Type</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9133"></a>Syntax</p>
<pre>
TYPE desc_tab2 IS TABLE OF desc_rec2 INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68223" class="refsect2"><a id="CHDBGCBE"></a>
<hr />
<h3 class="refsect2"><a id="sthref9134"></a>DESC_TAB3 Table Type</h3>
<p>This is a table of <a href="#CHDDFEGC">DESC_REC3 Record Type</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9135"></a>Syntax</p>
<pre>
TYPE desc_tab3 IS TABLE OF desc_rec3 INDEX BY BINARY_INTEGER; 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68224" class="refsect2"><a id="CHDIGEGH"></a>
<hr />
<h3 class="refsect2"><a id="sthref9136"></a>INTERVAL_DAY_TO_SECOND_TABLE Table Type</h3>
<p>This is a table of <code>DSINTERVAL_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9137"></a>Syntax</p>
<pre>
 TYPE interval_day_to_second_Table IS TABLE OF
    DSINTERVAL_UNCONSTRAINED INDEX BY binary_integer;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68225" class="refsect2"><a id="CHDEHFCI"></a>
<hr />
<h3 class="refsect2"><a id="sthref9138"></a>INTERVAL_YEAR_TO_MONTH_TABLE Table Type</h3>
<p>This is a table of <code>YMINTERVAL_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9139"></a>Syntax</p>
<pre>
TYPE interval_year_to_month_table IS TABLE OF YMINTERVAL_UNCONSTRAINED 
   INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68226" class="refsect2"><a id="CHDGFFAD"></a>
<hr />
<h3 class="refsect2"><a id="sthref9140"></a>NUMBER_TABLE Table Type</h3>
<p>This is a table of <code>NUMBER</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9141"></a>Syntax</p>
<pre>
TYPE number_table IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68227" class="refsect2"><a id="CHDJHAEC"></a>
<hr />
<h3 class="refsect2"><a id="sthref9142"></a>TIME_TABLE Table Type</h3>
<p>This is a table of <code>TIME_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9143"></a>Syntax</p>
<pre>
TYPE time_table IS TABLE OF TIME_UNCONSTRAINED INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68228" class="refsect2"><a id="CIHCABIA"></a>
<hr />
<h3 class="refsect2"><a id="sthref9144"></a>TIME_WITH_TIME_ZONE_TABLE Table Type</h3>
<p>This is a table of <code>TIME_TZ_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9145"></a>Syntax</p>
<pre>
TYPE time_with_time_zone_table IS TABLE OF TIME_TZ_UNCONSTRAINED 
   INDEX BY BINARY_INTEGER;;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68229" class="refsect2"><a id="CHDCEDDD"></a>
<hr />
<h3 class="refsect2"><a id="sthref9146"></a>TIMESTAMP_TABLE Table Type</h3>
<p>This is a table of <code>TIMESTAMP_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9147"></a>Syntax</p>
<pre>
TYPE timestamp_table IS TABLE OF TIMESTAMP_UNCONSTRAINED INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68230" class="refsect2"><a id="CHDEDCEA"></a>
<hr />
<h3 class="refsect2"><a id="sthref9148"></a>TIMESTAMP_WITH_LTZ_TABLE Table Type</h3>
<p>This is a table of TIMESTAMP_LTZ_UNCONSTRAINED</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9149"></a>Syntax</p>
<pre>
TYPE timestamp_with_ltz_table IS TABLE OF
    TIMESTAMP_LTZ_UNCONSTRAINED INDEX BY binary_integer;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68231" class="refsect2"><a id="CIHHGCBF"></a>
<hr />
<h3 class="refsect2"><a id="sthref9150"></a>TIMESTAMP_WITH_TIME_ZONE_TABLE Table Type</h3>
<p>This is a table of <code>TIMESTAMP_TZ_UNCONSTRAINED</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9151"></a>Syntax</p>
<pre>
TYPE timestamp_with_time_zone_Table IS TABLE OF 
    TIMESTAMP_TZ_UNCONSTRAINED INDEX BY binary_integer;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68232" class="refsect2"><a id="CHDICIBC"></a>
<hr />
<h3 class="refsect2"><a id="sthref9152"></a>UROWID_TABLE Table Type</h3>
<p>This is a table of <code>UROWID</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9153"></a>Syntax</p>
<pre>
TYPE urowid_table IS TABLE OF UROWID INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68233" class="refsect2"><a id="CHDHHECG"></a>
<hr />
<h3 class="refsect2"><a id="sthref9154"></a>VARCHAR2_TABLE Table Type</h3>
<p>This is table of <code>VARCHAR2(2000)</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9155"></a>Syntax</p>
<pre>
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68234" class="refsect2"><a id="CHDEGGIG"></a>
<hr />
<h3 class="refsect2"><a id="sthref9156"></a>VARCHAR2A Table Type</h3>
<p>This is table of <code>VARCHAR2(32767)</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9157"></a>Syntax</p>
<pre>
TYPE varchar2a IS TABLE OF VARCHAR2(32767) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68235" class="refsect2"><a id="CHDICCED"></a>
<hr />
<h3 class="refsect2"><a id="sthref9158"></a>VARCHAR2S Table Type</h3>
<p>This is table of <code>VARCHAR2(256)</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This type has been superseded by the <a href="#CHDEGGIG">VARCHAR2A Table Type</a>. Although it is currently retained for backward compatibility of legacy code, it is in the process of deprecation and will be de-supported in a future release.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9159"></a>Syntax</p>
<pre>
TYPE varchar2s IS TABLE OF VARCHAR2(256) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" -->
<a id="i997453"></a>
<hr />
<div id="ARPLS68236" class="refsect1">
<h2 class="refsect1">Summary of DBMS_SQL Subprograms</h2>
<div id="ARPLS68237" class="tblformal">
<p class="titleintable"><a id="sthref9160"></a><a id="sthref9161"></a>Table 137-5 <span class="bold">DBMS_SQL</span> Package Subprograms</p>
<table class="cellalignment1229" title="DBMS_SQL Package Subprograms" summary="This table lists the DBMS_SQL subprograms in alphabetical order and briefly describes them." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t14">Subprogram</th>
<th class="cellalignment1227" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t14" headers="r1c1-t14">
<p><a href="#i1025085">BIND_ARRAY Procedures</a></p>
</td>
<td class="cellalignment1228" headers="r2c1-t14 r1c2-t14">
<p>Binds a given value to a given collection</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t14" headers="r1c1-t14">
<p><a href="#i1030093">BIND_VARIABLE Procedures</a></p>
</td>
<td class="cellalignment1228" headers="r3c1-t14 r1c2-t14">
<p>Binds a given value to a given variable</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t14" headers="r1c1-t14">
<p><a href="#i1026299">CLOSE_CURSOR Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r4c1-t14 r1c2-t14">
<p>Closes given cursor and frees memory</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t14" headers="r1c1-t14">
<p><a href="#i1025449">COLUMN_VALUE Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r5c1-t14 r1c2-t14">
<p>Returns value of the cursor element for a given position in a cursor</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t14" headers="r1c1-t14">
<p><a href="#i1025399">COLUMN_VALUE_LONG Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r6c1-t14 r1c2-t14">
<p>Returns a selected part of a <code>LONG</code> column, that has been defined using <code>DEFINE_COLUMN_LONG</code></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t14" headers="r1c1-t14">
<p><a href="#i1025685">DEFINE_ARRAY Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r7c1-t14 r1c2-t14">
<p>Defines a collection to be selected from the given cursor, used only with <code>SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t14" headers="r1c1-t14">
<p><a href="#i1025686">DEFINE_COLUMN Procedures</a></p>
</td>
<td class="cellalignment1228" headers="r8c1-t14 r1c2-t14">
<p>Defines a column to be selected from the given cursor, used only with <code>SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t14" headers="r1c1-t14">
<p><a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r9c1-t14 r1c2-t14">
<p>Defines a column of type <code>CHAR</code> to be selected from the given cursor, used only with <code>SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t14" headers="r1c1-t14">
<p><a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r10c1-t14 r1c2-t14">
<p>Defines a <code>LONG</code> column to be selected from the given cursor, used only with <code>SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r11c1-t14" headers="r1c1-t14">
<p><a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r11c1-t14 r1c2-t14">
<p>Defines a column of type <code>RAW</code> to be selected from the given cursor, used only with <code>SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r12c1-t14" headers="r1c1-t14">
<p><a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r12c1-t14 r1c2-t14">
<p>Defines a column of type <code>ROWID</code> to be selected from the given cursor, used only with <code>SELECT</code> statements</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r13c1-t14" headers="r1c1-t14">
<p><a href="#i1026120">DESCRIBE_COLUMNS Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r13c1-t14 r1c2-t14">
<p>Describes the columns for a cursor opened and parsed through <code>DBMS_SQL</code></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r14c1-t14" headers="r1c1-t14">
<p><a href="#i1029368">DESCRIBE_COLUMNS2 Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r14c1-t14 r1c2-t14">
<p>Describes describes the specified column, an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r15c1-t14" headers="r1c1-t14">
<p><a href="#CHDJBBFH">DESCRIBE_COLUMNS3 Procedure</a></p>
</td>
<td class="cellalignment1228" headers="r15c1-t14 r1c2-t14">
<p>Describes describes the specified column, an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a></p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r16c1-t14" headers="r1c1-t14">
<p><a href="#i1025983">EXECUTE Function</a></p>
</td>
<td class="cellalignment1228" headers="r16c1-t14 r1c2-t14">
<p>Executes a given cursor</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r17c1-t14" headers="r1c1-t14">
<p><a href="#i1025711">EXECUTE_AND_FETCH Function</a></p>
</td>
<td class="cellalignment1228" headers="r17c1-t14 r1c2-t14">
<p>Executes a given cursor and fetch rows</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r18c1-t14" headers="r1c1-t14">
<p><a href="#i1026065">FETCH_ROWS Function</a></p>
</td>
<td class="cellalignment1228" headers="r18c1-t14 r1c2-t14">
<p>Fetches a row from a given cursor</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r19c1-t14" headers="r1c1-t14">
<p><a href="#i1026423">IS_OPEN Function</a></p>
</td>
<td class="cellalignment1228" headers="r19c1-t14 r1c2-t14">
<p>Returns <code>TRUE</code> if given cursor is open</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r20c1-t14" headers="r1c1-t14">
<p><a href="#i1026408">LAST_ERROR_POSITION Function</a></p>
</td>
<td class="cellalignment1228" headers="r20c1-t14 r1c2-t14">
<p>Returns byte offset in the SQL statement text where the error occurred</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r21c1-t14" headers="r1c1-t14">
<p><a href="#i1026354">LAST_ROW_COUNT Function</a></p>
</td>
<td class="cellalignment1228" headers="r21c1-t14 r1c2-t14">
<p>Returns cumulative count of the number of rows fetched</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r22c1-t14" headers="r1c1-t14">
<p><a href="#i1026364">LAST_ROW_ID Function</a></p>
</td>
<td class="cellalignment1228" headers="r22c1-t14 r1c2-t14">
<p>Returns <code>ROWID</code> of last row processed</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r23c1-t14" headers="r1c1-t14">
<p><a href="#i1026374">LAST_SQL_FUNCTION_CODE Function</a></p>
</td>
<td class="cellalignment1228" headers="r23c1-t14 r1c2-t14">
<p>Returns SQL function code for statement</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r24c1-t14" headers="r1c1-t14">
<p><a href="#i997665">OPEN_CURSOR Function</a></p>
</td>
<td class="cellalignment1228" headers="r24c1-t14 r1c2-t14">
<p>Returns cursor ID number of new cursor</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r25c1-t14" headers="r1c1-t14">
<p><a href="#i997676">PARSE Procedures</a></p>
</td>
<td class="cellalignment1228" headers="r25c1-t14 r1c2-t14">
<p>Parses given statement</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r26c1-t14" headers="r1c1-t14">
<p><a href="#CHDJDGDG">TO_CURSOR_NUMBER Function</a></p>
</td>
<td class="cellalignment1228" headers="r26c1-t14 r1c2-t14">
<p>Takes an <code>OPEN</code>ed strongly or weakly-typed ref cursor and transforms it into a <code>DBMS_SQL</code> cursor number</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r27c1-t14" headers="r1c1-t14">
<p><a href="#CHDFDCDE">TO_REFCURSOR Function</a></p>
</td>
<td class="cellalignment1228" headers="r27c1-t14 r1c2-t14">
<p>Takes an <code>OPEN</code>ed, <code>PARSE</code>d, and <code>EXECUTE</code>d cursor and transforms/migrates it into a PL/SQL manageable <code>REF</code> <code>CURSOR</code> (a weakly-typed cursor) that can be consumed by PL/SQL native dynamic SQL switched to use native dynamic SQL</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r28c1-t14" headers="r1c1-t14">
<p><a href="#i998371">VARIABLE_VALUE Procedures</a></p>
</td>
<td class="cellalignment1228" headers="r28c1-t14 r1c2-t14">
<p>Returns value of named variable for given cursor</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="ARPLS68238" class="refsect2"><a id="i1025085"></a>
<hr />
<h3 class="refsect2"><a id="sthref9162"></a>BIND_ARRAY Procedures</h3>
<p>This procedure binds a given value or set of values to a given variable in a cursor, based on the name of the variable in the statement.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9163"></a>Syntax</p>
<pre>
DBMS_SQL.BIND_ARRAY ( 
   c                   IN INTEGER, 
   name                IN VARCHAR2, 
   &lt;table_variable&gt;    IN &lt;datatype&gt; 
 [,index1              IN INTEGER, 
   index2              IN INTEGER)] ); 
</pre>
<p>Where the &lt;<code>table_variable</code>&gt; and its corresponding &lt;datatype&gt; can be any one of the following matching pairs:</p>
<pre>
&lt;clob_tab&gt;     Clob_Table
&lt;bflt_tab&gt;     Binary_Float_Table
&lt;bdbl_tab&gt;     Binary_Double_Table
&lt;blob_tab&gt;     Blob_Table
&lt;bfile_tab&gt;    Bfile_Table
&lt;date_tab&gt;     Date_Table
&lt;num_tab&gt;      Number_Table
&lt;urowid_tab&gt;   Urowid_Table
&lt;vchr2_tab&gt;    Varchar2_Table
&lt;tm_tab&gt;       Time_Table
&lt;ttz_tab&gt;      Time_With_Time_Zone_Table
&lt;tms_tab&gt;      Timestamp_Table
&lt;tstz_tab&gt;     Timestamp_With_ltz_Table;
&lt;tstz_tab&gt;     Timestamp_With_Time_Zone_Table
&lt;ids_tab&gt;      Interval_Day_To_Second_Table
&lt;iym_tab&gt;      Interval_Year_To_Month_Table
</pre>
<p>Notice that the <code>BIND_ARRAY</code> procedure is overloaded to accept different datatypes.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9164"></a>Parameters</p>
<div id="ARPLS68239" class="tblformal">
<p class="titleintable"><a id="sthref9165"></a><a id="sthref9166"></a>Table 137-6 BIND_ARRAY Procedure Parameters</p>
<table class="cellalignment1229" title="BIND_ARRAY Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.BIND_ARRAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t15">Parameter</th>
<th class="cellalignment1227" id="r1c2-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t15" headers="r1c1-t15">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t15 r1c2-t15">
<p>ID number of the cursor to which you want to bind a value.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t15" headers="r1c1-t15">
<p><code>name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t15 r1c2-t15">
<p>Name of the collection in the statement.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t15" headers="r1c1-t15">
<p><code>table_variable</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t15 r1c2-t15">
<p>Local variable that has been declared as &lt;<code>datatype</code>&gt;.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t15" headers="r1c1-t15">
<p><code>index1</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t15 r1c2-t15">
<p>Index for the table element that marks the lower bound of the range.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t15" headers="r1c1-t15">
<p><code>index2</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t15 r1c2-t15">
<p>Index for the table element that marks the upper bound of the range.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9167"></a>Usage Notes</p>
<p>The length of the bind variable name should be &lt;=30 bytes.</p>
<p>For binding a range, the table must contain the elements that specify the range &mdash; tab(index1) and tab(index2) &mdash; but the range does not have to be dense. Index1 must be less than or equal to index2. All elements between tab(index1) and tab(index2) are used in the bind.</p>
<p>If you do not specify indexes in the bind call, and two different binds in a statement specify tables that contain a different number of elements, then the number of elements actually used is the minimum number between all tables. This is also the case if you specify indexes &mdash; the minimum range is selected between the two indexes for all tables.</p>
<p>Not all bind variables in a query have to be array binds. Some can be regular binds and the same value are used for each element of the collections in expression evaluations (and so forth).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997061">"Examples 3, 4, and 5:&nbsp;Bulk DML"</a> for examples of how to bind collections.</div>
<p class="subhead2"><a id="ARPLS68240"></a>Bulk Array Binds</p>
<p><a id="sthref9168"></a>Bulk selects, inserts, updates, and deletes can enhance the performance of applications by bundling many calls into one. The <code>DBMS_SQL</code> package lets you work on collections of data using the PL/SQL table type.</p>
<p><span class="italic"><a id="sthref9169"></a><a id="sthref9170"></a>Table items</span> are unbounded homogeneous collections. In persistent storage, they are like other relational tables and have no intrinsic ordering. But when a table item is brought into the workspace (either by querying or by navigational access of persistent data), or when it is created as the value of a PL/SQL variable or parameter, its elements are given subscripts that can be used with array-style syntax to get and set the values of elements.</p>
<p>The subscripts of these elements need not be dense, and can be any number including negative numbers. For example, a table item can contain elements at locations -10, 2, and 7 only.</p>
<p>When a table item is moved from transient workspace to persistent storage, the subscripts are not stored; the table item is unordered in persistent storage.</p>
<p>At bind time the table is copied out from the PL/SQL buffers into local <code>DBMS_SQL</code> buffers (the same as for all scalar types) and then the table is manipulated from the local <code>DBMS_SQL</code> buffers. Therefore, if you change the table after the bind call, then that change does not affect the way the execute acts.</p>
<p class="subhead2"><a id="ARPLS68241"></a>Types for Scalar and LOB Collections</p>
<p>You can declare a local variable as one of the following table-item types, which are defined as public types in <code>DBMS_SQL</code>.</p>
<pre>
TYPE binary_double_table 
                    IS TABLE OF BINARY_DOUBLE  INDEX BY BINARY_INTEGER;
TYPE binary_float_table 
                    IS TABLE OF BINARY_FLOAT   INDEX BY BINARY_INTEGER;
TYPE bfile_table    IS TABLE OF BFILE          INDEX BY BINARY_INTEGER;
TYPE blob_table     IS TABLE OF BLOB           INDEX BY BINARY_INTEGER;
TYPE clob_table     IS TABLE OF CLOB           INDEX BY BINARY_INTEGER;
TYPE date_table     IS TABLE OF DATE           INDEX BY BINARY_INTEGER;
TYPE interval_day_to_second_Table 
                    IS TABLE OF dsinterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE interval_year_to_MONTH_Table 
                    IS TABLE OF yminterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE number_table   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;
TYPE time_table     IS TABLE OF time_unconstrained           
                                               INDEX BY BINARY_INTEGER;
TYPE time_with_time_zone_table 
                    IS TABLE OF time_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_table 
                    IS TABLE OF timestamp_unconstrained   
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_ltz_Table 
                    IS TABLE OF timestamp_ltz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_time_zone_Table 
                    IS TABLE OF timestamp_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE urowid_table   IS TABLE OF UROWID         INDEX BY BINARY_INTEGER;
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68242" class="refsect2"><a id="i1030093"></a>
<hr />
<h3 class="refsect2"><a id="sthref9171"></a>BIND_VARIABLE Procedures</h3>
<p>This procedures binds a given value or set of values to a given variable in a cursor, based on the name of the variable in the statement.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9172"></a>Syntax</p>
<pre>
DBMS_SQL.BIND_VARIABLE (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN &lt;datatype&gt;);
</pre>
<p>Where &lt;datatype&gt; can be any one of the following types:</p>
<pre>
BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_UNCONSTRAINED
TIME_TZ_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
VARCHAR2 CHARACTER SET ANY_CS
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre>
<p>Notice that <code>BIND_VARIABLE</code> is overloaded to accept different datatypes.</p>
<p>The following syntax is also supported for <code>BIND_VARIABLE</code>. The square brackets [] indicate an optional parameter for the <code>BIND_VARIABLE</code> function.</p>
<pre>
DBMS_SQL.BIND_VARIABLE (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN VARCHAR2 CHARACTER SET ANY_CS [,out_value_size IN INTEGER]);
</pre>
<p>To bind <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the syntax:</p>
<pre>
DBMS_SQL.BIND_VARIABLE_CHAR (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN CHAR CHARACTER SET ANY_CS [,out_value_size IN INTEGER]);

DBMS_SQL.BIND_VARIABLE_RAW (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN RAW [,out_value_size IN INTEGER]);

DBMS_SQL.BIND_VARIABLE_ROWID (
   c              IN INTEGER,
   name           IN VARCHAR2,
   value          IN ROWID);
</pre>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9173"></a>Pragmas</p>
<pre>
pragma restrict_references(bind_variable,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9174"></a>Parameters</p>
<div id="ARPLS68243" class="tblformal">
<p class="titleintable"><a id="sthref9175"></a><a id="sthref9176"></a>Table 137-7 BIND_VARIABLE Procedure Parameters</p>
<table class="cellalignment1229" title="BIND_VARIABLE Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.BIND_VARIABLE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t18">Parameter</th>
<th class="cellalignment1227" id="r1c2-t18">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t18" headers="r1c1-t18">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t18 r1c2-t18">
<p>ID number of the cursor to which you want to bind a value.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t18" headers="r1c1-t18">
<p><code>name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t18 r1c2-t18">
<p>Name of the variable in the statement.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t18" headers="r1c1-t18">
<p><code>value</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t18 r1c2-t18">
<p>Value that you want to bind to the variable in the cursor.</p>
<p>For <code>IN</code> and <code>IN</code>/<code>OUT</code> variables, the value has the same type as the type of the value being passed in for this parameter.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t18" headers="r1c1-t18">
<p><code>out_value_size</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t18 r1c2-t18">
<p>Maximum expected <code>OUT</code> value size, in bytes, for the <code>VARCHAR2</code>, <code>RAW</code>, <code>CHAR</code> <code>OUT</code> or <code>IN</code>/<code>OUT</code> variable.</p>
<p>If no size is given, then the length of the current value is used. This parameter must be specified if the <code>value</code> parameter is not initialized.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9177"></a>Usage Notes</p>
<p>If the variable is an <code>IN</code> or <code>IN</code>/<code>OUT</code> variable or an <code>IN</code> collection, then the given bind value must be valid for the variable or array type. Bind values for <code>OUT</code> variables are ignored.</p>
</div>
<!-- class="refsubsect" -->
<p>The bind variables or collections of a SQL statement are identified by their names. When binding a value to a bind variable or bind array, the string identifying it in the statement must contain a leading colon, as shown in the following example:</p>
<pre>
SELECT emp_name FROM emp WHERE SAL &gt; :X;
</pre>
<p>For this example, the corresponding bind call would look similar to</p>
<pre>
BIND_VARIABLE(cursor_name, ':X', 3500); 

or

BIND_VARIABLE (cursor_name, 'X', 3500);
</pre>
<p>The length of the bind variable name should be &lt;=30 bytes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997061">"Examples 3, 4, and 5:&nbsp;Bulk DML"</a> for examples of how to bind collections.</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68244" class="refsect2"><a id="i1026299"></a>
<hr />
<h3 class="refsect2"><a id="sthref9178"></a>CLOSE_CURSOR Procedure</h3>
<p>This procedure closes a given cursor.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9179"></a>Syntax</p>
<pre>
DBMS_SQL.CLOSE_CURSOR (
   c    IN OUT INTEGER);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9180"></a>Pragmas</p>
<pre>
pragma restrict_references(close_cursor,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9181"></a>Parameters</p>
<div id="ARPLS68245" class="tblformal">
<p class="titleintable"><a id="sthref9182"></a><a id="sthref9183"></a>Table 137-8 CLOSE_CURSOR Procedure Parameters</p>
<table class="cellalignment1229" title="CLOSE_CURSOR Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.CLOSE_CURSOR subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t20">Parameter</th>
<th class="cellalignment1227" id="r1c2-t20">Mode</th>
<th class="cellalignment1227" id="r1c3-t20">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t20" headers="r1c1-t20">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t20 r1c2-t20">
<p><code>IN</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t20 r1c3-t20">
<p>ID number of the cursor that you want to close.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t20" headers="r1c1-t20">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t20 r1c2-t20">
<p><code>OUT</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t20 r1c3-t20">
<p>Cursor is set to null.</p>
<p>After you call <code>CLOSE_CURSOR</code>, the memory allocated to the cursor is released and you can no longer fetch from that cursor.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68246" class="refsect2"><a id="i1025449"></a>
<hr />
<h3 class="refsect2"><a id="sthref9184"></a>COLUMN_VALUE Procedure</h3>
<p>This procedure returns the value of the cursor element for a given position in a given cursor. This procedure is used to access the data fetched by calling <code>FETCH_ROWS</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9185"></a>Syntax</p>
<pre>
DBMS_SQL.COLUMN_VALUE (
   c                 IN  INTEGER,
   position          IN  INTEGER,
   value             OUT &lt;datatype&gt; 
 [,column_error      OUT NUMBER] 
 [,actual_length     OUT INTEGER]);
</pre>
<p>Where square brackets [ ] indicate optional parameters and &lt;<code>datatype</code>&gt; can be any one of the following types:</p>
<pre>
BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_TZ_UNCONSTRAINED
TIME_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
VARCHAR2 CHARACTER SET ANY_CS
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre></div>
<!-- class="refsubsect" -->
<p>For variables containing <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the syntax:</p>
<pre>
DBMS_SQL.COLUMN_VALUE_CHAR (
   c               IN  INTEGER,
   position        IN  INTEGER,
   value           OUT CHAR CHARACTER SET ANY_CS
 [,column_error    OUT NUMBER]
 [,actual_length   OUT INTEGER]);
 
DBMS_SQL.COLUMN_VALUE_RAW (
   c               IN  INTEGER,
   position        IN  INTEGER,
   value           OUT RAW
 [,column_error    OUT NUMBER]
 [,actual_length   OUT INTEGER]);

DBMS_SQL.COLUMN_VALUE_ROWID (
   c               IN  INTEGER,
   position        IN  INTEGER,
   value           OUT ROWID
 [,column_error    OUT NUMBER]
 [,actual_length   OUT INTEGER]);
</pre>
<p>The following syntax enables the <code>COLUMN_VALUE</code> procedure to accommodate bulk operations:</p>
<pre>
DBMS_SQL.COLUMN_VALUE( 
   c                 IN             INTEGER, 
   position          IN             INTEGER, 
   &lt;param_name&gt;      IN OUT NOCOPY  &lt;table_type&gt;);  
</pre>
<p>Where the &lt;<code>param_name</code>&gt; and its corresponding &lt;<code>table_type</code>&gt; can be any one of these matching pairs:</p>
<pre>
bdbl_tab     Binary_Double_Table
bflt_tab     Binary_Float_Table
bf_tab       Bfile_Table
bl_tab       Blob_Table
cl_tab       Clob_Table
d_tab        Date_Table
ids_tab      Interval_Day_To_Second_Table
iym_tab      Interval_Year_To_Month_Table
n_tab        Number_Table
tm_tab       Time_Table
ttz_tab      Time_With_Time_Zone_Table
tms_tab      Timestamp_Table
tstz_tab     Timestamp_With_ltz_Table;
tstz_tab     Timestamp_With_Time_Zone_Table
ur_tab       Urowid_Table
c_tab        Varchar2_Table
</pre>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9186"></a>Pragmas</p>
<pre>
pragma restrict_references(column_value,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9187"></a>Parameters</p>
<div id="ARPLS68247" class="tblformal">
<p class="titleintable"><a id="sthref9188"></a><a id="sthref9189"></a>Table 137-9 COLUMN_VALUE Procedure Parameters (Single Row)</p>
<table class="cellalignment1229" title="COLUMN_VALUE Procedure Parameters (Single Row)" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t21">Parameter</th>
<th class="cellalignment1227" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t21" headers="r1c1-t21">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t21 r1c2-t21">
<p>ID number of the cursor from which you are fetching the values.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t21" headers="r1c1-t21">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t21 r1c2-t21">
<p>Relative position of the column in the cursor.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t21" headers="r1c1-t21">
<p><code>value</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t21 r1c2-t21">
<p>Returns the value at the specified column.</p>
<p>Oracle raises exception <code>ORA-06562</code>, <code>inconsistent_type</code>, if the type of this output parameter differs from the actual type of the value, as defined by the call to <code>DEFINE_COLUMN</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t21" headers="r1c1-t21">
<p><code>column_error</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t21 r1c2-t21">
<p>Returns any error code for the specified column value.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t21" headers="r1c1-t21">
<p><code>actual_length</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t21 r1c2-t21">
<p>The actual length, before any truncation, of the value in the specified column.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="ARPLS68248" class="tblformal">
<p class="titleintable"><a id="sthref9190"></a><a id="sthref9191"></a>Table 137-10 COLUMN_VALUE Procedure Parameters (Bulk)</p>
<table class="cellalignment1229" title="COLUMN_VALUE Procedure Parameters (Bulk)" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t22">Parameter</th>
<th class="cellalignment1227" id="r1c2-t22">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t22" headers="r1c1-t22">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t22 r1c2-t22">
<p>ID number of the cursor from which you are fetching the values.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t22" headers="r1c1-t22">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t22 r1c2-t22">
<p>Relative position of the column in the cursor.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t22" headers="r1c1-t22">
<p><code>&lt;param_name&gt;</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t22 r1c2-t22">
<p>Local variable that has been declared &lt;<code>table_type</code>&gt;. &lt;<code>param_name</code>&gt; is an <code>IN</code> <code>OUT</code> <code>NOCOPY</code> parameter for bulk operations.</p>
<p>For bulk operations, the subprogram appends the new elements at the appropriate (implicitly maintained) index. For instance if on utilizing the <a href="#i1025685">DEFINE_ARRAY Procedure</a> a batch size (the <code>cnt</code> parameter) of 10 rows was specified and a start index (<code>lower_bound</code>) of 1 was specified, then the first call to this subprogram after calling the <a href="#i1026065">FETCH_ROWS Function</a> will populate elements at index 1..10, and the next call will populate elements 11..20, and so on.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9192"></a>Exceptions</p>
<p><code>INCONSISTENT_TYPE</code> (<code>ORA</code>-<code>06562</code>) is raised if the type of the given <code>OUT</code> parameter <code>value</code> is different from the actual type of the value. This type was the given type when the column was defined by calling procedure <code>DEFINE_COLUMN</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68249" class="refsect2"><a id="i1025399"></a>
<hr />
<h3 class="refsect2"><a id="sthref9193"></a>COLUMN_VALUE_LONG Procedure</h3>
<p>This procedure gets part of the value of a long column.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9194"></a>Syntax</p>
<pre>
DBMS_SQL.COLUMN_VALUE_LONG (
   c            IN  INTEGER, 
   position     IN  INTEGER, 
   length       IN  INTEGER, 
   offset       IN  INTEGER,
   value        OUT VARCHAR2,
   value_length OUT INTEGER);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9195"></a>Pragmas</p>
<pre>
pragma restrict_references(column_value_long,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9196"></a>Parameters</p>
<div id="ARPLS68250" class="tblformal">
<p class="titleintable"><a id="sthref9197"></a><a id="sthref9198"></a>Table 137-11 COLUMN_VALUE_LONG Procedure Parameters</p>
<table class="cellalignment1229" title="COLUMN_VALUE_LONG Procedure Parameters" summary="This table describes Parameters used by the DBMS_SQL.COLUMN_VALUE_LONG subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t24">Parameter</th>
<th class="cellalignment1227" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t24" headers="r1c1-t24">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t24 r1c2-t24">
<p>Cursor ID number of the cursor from which to get the value.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t24" headers="r1c1-t24">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t24 r1c2-t24">
<p>Position of the column of which to get the value.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t24" headers="r1c1-t24">
<p><code>length</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t24 r1c2-t24">
<p>Number of bytes of the long value to fetch.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t24" headers="r1c1-t24">
<p><code>offset</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t24 r1c2-t24">
<p>Offset into the long field for start of fetch.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t24" headers="r1c1-t24">
<p><code>value</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t24 r1c2-t24">
<p>Value of the column as a <code>VARCHAR2</code>.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t24" headers="r1c1-t24">
<p><code>value_length</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t24 r1c2-t24">
<p>Number of bytes actually returned in value.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68251" class="refsect2"><a id="i1025685"></a>
<hr />
<h3 class="refsect2"><a id="sthref9199"></a>DEFINE_ARRAY Procedure</h3>
<p>This procedure defines the collection for column into which you want to fetch rows (with a <code>FETCH_ROWS</code> call). This procedure lets you do batch fetching of rows from a single <code>SELECT</code> statement. A single fetch call brings over a number of rows into the PL/SQL aggregate object.</p>
<p>When you fetch the&nbsp;rows, they are copied into <code>DBMS_SQL</code> buffers until you run a <code>COLUMN_VALUE</code> call, at which time the rows are copied into the table that was passed as an argument to the <code>COLUMN_VALUE</code> call.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9200"></a>Scalar and LOB Types for Collections</p>
<p>You can declare a local variable as one of the following table-item types, and then fetch any number of rows into it using <code>DBMS_SQL</code>. (These are the same types as you can specify for the <code>BIND_ARRAY</code> procedure.)</p>
<pre>
TYPE binary_double_table 
                    IS TABLE OF BINARY_DOUBLE  INDEX BY BINARY_INTEGER;
TYPE binary_float_table 
                    IS TABLE OF BINARY_FLOAT   INDEX BY BINARY_INTEGER;
TYPE bfile_table    IS TABLE OF BFILE          INDEX BY BINARY_INTEGER;
TYPE blob_table     IS TABLE OF BLOB           INDEX BY BINARY_INTEGER;
TYPE clob_table     IS TABLE OF CLOB           INDEX BY BINARY_INTEGER;
TYPE date_table     IS TABLE OF DATE           INDEX BY BINARY_INTEGER;
TYPE interval_day_to_second_Table 
                    IS TABLE OF dsinterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE interval_year_to_MONTH_Table 
                    IS TABLE OF yminterval_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE number_table   IS TABLE OF NUMBER         INDEX BY BINARY_INTEGER;
TYPE time_table     IS TABLE OF time_unconstrained           
                                               INDEX BY BINARY_INTEGER;
TYPE time_with_time_zone_table 
                    IS TABLE OF time_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_table 
                    IS TABLE OF timestamp_unconstrained   
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_ltz_Table 
                    IS TABLE OF timestamp_ltz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE timestamp_with_time_zone_Table 
                    IS TABLE OF timestamp_tz_unconstrained 
                                               INDEX BY BINARY_INTEGER;
TYPE urowid_table   IS TABLE OF UROWID         INDEX BY BINARY_INTEGER;
TYPE varchar2_table IS TABLE OF VARCHAR2(2000) INDEX BY BINARY_INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9201"></a>Syntax</p>
<pre>
DBMS_SQL.DEFINE_ARRAY (
   c           IN INTEGER, 
   position    IN INTEGER,
   &lt;table_variable&gt;    IN &lt;datatype&gt; 
   cnt         IN INTEGER, 
   lower_bnd   IN INTEGER);
</pre>
<p>Where &lt;<code>table_variable</code>&gt; and its corresponding &lt;datatype&gt; can be any one of the following matching pairs, <code>DEFINE_ARRAY</code> being overloaded to accept different datatypes:</p>
<pre>
&lt;clob_tab&gt;     Clob_Table
&lt;bflt_tab&gt;     Binary_Float_Table
&lt;bdbl_tab&gt;     Binary_Double_Table
&lt;blob_tab&gt;     Blob_Table
&lt;bfile_tab&gt;    Bfile_Table
&lt;date_tab&gt;     Date_Table
&lt;num_tab&gt;      Number_Table
&lt;urowid_tab&gt;   Urowid_Table
&lt;vchr2_tab&gt;    Varchar2_Table
&lt;tm_tab&gt;       Time_Table
&lt;ttz_tab&gt;      Time_With_Time_Zone_Table
&lt;tms_tab&gt;      Timestamp_Table
&lt;tstz_tab&gt;     Timestamp_With_ltz_Table;
&lt;tstz_tab&gt;     Timestamp_With_Time_Zone_Table
&lt;ids_tab&gt;      Interval_Day_To_Second_Table
&lt;iym_tab&gt;      Interval_Year_To_Month_Table
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9202"></a>Pragmas</p>
<pre>
pragma restrict_references(define_array,RNDS,WNDS);
</pre>
<p>The subsequent <code>FETCH_ROWS</code> call fetch "count" rows. When the <code>COLUMN_VALUE</code> call is made, these rows are placed in positions <code>lower_bnd</code>, <code>lower_bnd</code>+1, <code>lower_bnd</code>+2, and so on. While there are still rows coming, the user keeps issuing <code>FETCH_ROWS</code>/<code>COLUMN_VALUE</code> calls. The rows keep accumulating in the table specified as an argument in the <code>COLUMN_VALUE</code> call.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9203"></a>Parameters</p>
<div id="ARPLS68252" class="tblformal">
<p class="titleintable"><a id="sthref9204"></a><a id="sthref9205"></a>Table 137-12 DEFINE_ARRAY Procedure Parameters</p>
<table class="cellalignment1229" title="DEFINE_ARRAY Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_ARRAY subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t25">Parameter</th>
<th class="cellalignment1227" id="r1c2-t25">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t25" headers="r1c1-t25">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t25 r1c2-t25">
<p>ID number of the cursor to which you want to bind an&nbsp;array.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t25" headers="r1c1-t25">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t25 r1c2-t25">
<p>Relative position of the column in the array being defined.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t25" headers="r1c1-t25">
<p><code>table_variable</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t25 r1c2-t25">
<p>Local variable that has been declared as &lt;<code>datatype</code>&gt;.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t25" headers="r1c1-t25">
<p><code>cnt</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t25 r1c2-t25">
<p>Number of rows that must be fetched.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t25" headers="r1c1-t25">
<p><code>lower_bnd</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t25 r1c2-t25">
<p>Results are copied into the collection, starting at this lower bound index.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9206"></a>Usage Notes</p>
<p>The count <code>(cnt)</code> must be an integer greater than zero; otherwise an exception is raised. The <code>lower_bnd</code> can be positive, negative, or zero. A query on which a <code>DEFINE_ARRAY</code> call was issued cannot contain array binds.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9207"></a>Examples</p>
<pre>
PROCEDURE BULK_PLSQL(deptid NUMBER)
    TYPE namelist IS TABLE OF employees.last_name%TYPE;
    TYPE sallist IS TABLE OF employees.salary%TYPE;
    names    namelist;
    sals     sallist;
    c        NUMBER;
    r        NUMBER;
    sql_stmt VARCHAR2(32767) :=
        'SELECT last_name, salary FROM employees WHERE department_id = :b1';
 
BEGIN
    c := DBMS_SQL.OPEN_CURSOR;
    DBMS_SQL.PARSE(c, sql_stmt, dbms_sql.native);
 
    DBMS_SQL.BIND_VARIABLE(c, 'b1', deptid);
 
    DBMS_SQL.DEFINE_ARRAY(c, 1, names, 5);
    DBMS_SQL.DEFINE_ARRAY(c, 2, sals, 5);
 
    r := DBMS_SQL.EXECUTE(c);
 
    LOOP
      r := DBMS_SQL.FETCH_ROWS(c);
      DBMS_SQL.COLUMN_VALUE(c, 1, names);
      DBMS_SQL.COLUMN_VALUE(c, 2, sals);
      EXIT WHEN r != 5;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(c);
 
    -- loop through the names and sals collections
    FOR i IN names.FIRST .. names.LAST  LOOP
      DBMS_OUTPUT.PUT_LINE('Name = ' || names(i) || ', salary = ' || sals(i));
    END LOOP;
END;
/
</pre></div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997149">"Examples 6 and 7:&nbsp;Defining an Array"</a> for examples of how to define collections.</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68253" class="refsect2"><a id="i1025686"></a>
<hr />
<h3 class="refsect2"><a id="sthref9208"></a>DEFINE_COLUMN Procedures</h3>
<p>This procedure defines a column to be selected from the given cursor. This procedure is only used with <code>SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code>SELECT</code> list of the statement in the given cursor. The type of the <code>COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9209"></a>Syntax</p>
<pre>
DBMS_SQL.DEFINE_COLUMN (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN &lt;datatype&gt;);
</pre>
<p>Where &lt;<code>datatype</code>&gt; can be any one of the following types:</p>
<pre>
BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_UNCONSTRAINED
TIME_TZ_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre>
<p>Note that <code>DEFINE_COLUMN</code> is overloaded to accept different datatypes.</p>
<p>The following syntax is also supported for the <code>DEFINE_COLUMN</code> procedure:</p>
<pre>
DBMS_SQL.DEFINE_COLUMN (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN VARCHAR2 CHARACTER SET ANY_CS,
   column_size    IN INTEGER);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9210"></a>Pragmas</p>
<pre>
pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9211"></a>Parameters</p>
<div id="ARPLS68254" class="tblformal">
<p class="titleintable"><a id="sthref9212"></a><a id="sthref9213"></a>Table 137-13 DEFINE_COLUMN Procedure Parameters</p>
<table class="cellalignment1229" title="DEFINE_COLUMN Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t28">Parameter</th>
<th class="cellalignment1227" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t28" headers="r1c1-t28">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t28 r1c2-t28">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t28" headers="r1c1-t28">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t28 r1c2-t28">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t28" headers="r1c1-t28">
<p><code>column</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t28 r1c2-t28">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t28" headers="r1c1-t28">
<p><code>column_size</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t28 r1c2-t28">
<p>Maximum expected size of the column value in bytes for columns of type <code>VARCHAR2</code>, and <code>RAW</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9214"></a>Usage Notes</p>
<p>When using character length semantics the maximum number of bytes that can be returned for a column value of type <code>VARCHAR2</code> is calculated as: <code>column_size</code> <code>*</code> maximum character byte size for the current characterset. For example, specifying the <code>column_size</code> as 10 means that a maximum of 30 (10*3) bytes can be returned when using character length semantics with a UTF8 character set regardless of the number of characters this represents.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72007" class="refsect2"><a id="CIHGCGBF"></a>
<hr />
<h3 class="refsect2"><a id="sthref9215"></a>DEFINE_COLUMN_CHAR Procedure</h3>
<p>This procedure defines a column with <code>CHAR</code> data to be selected from the given cursor. This procedure is only used with <code>SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code>SELECT</code> list of the statement in the given cursor. The type of the <code>COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a>, <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9216"></a>Syntax</p>
<pre>
DBMS_SQL.DEFINE_COLUMN_CHAR (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN CHAR CHARACTER SET ANY_CS,
   column_size    IN INTEGER);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9217"></a>Pragmas</p>
<pre>
pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9218"></a>Parameters</p>
<div id="ARPLS72008" class="tblformal">
<p class="titleintable"><a id="sthref9219"></a><a id="sthref9220"></a>Table 137-14 DEFINE_COLUMN_CHAR Procedure Parameters</p>
<table class="cellalignment1229" title="DEFINE_COLUMN_CHAR Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN_CHAR subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t30">Parameter</th>
<th class="cellalignment1227" id="r1c2-t30">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t30" headers="r1c1-t30">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t30 r1c2-t30">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t30" headers="r1c1-t30">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t30 r1c2-t30">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t30" headers="r1c1-t30">
<p><code>column</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t30 r1c2-t30">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t30" headers="r1c1-t30">
<p><code>column_size</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t30 r1c2-t30">
<p>Maximum expected size of the column value in characters for columns of type <code>CHAR</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68255" class="refsect2"><a id="i1025656"></a>
<hr />
<h3 class="refsect2"><a id="sthref9221"></a>DEFINE_COLUMN_LONG Procedure</h3>
<p>This procedure defines a <code>LONG</code> column for a <code>SELECT</code> cursor. The column being defined is identified by its relative position in the <code>SELECT</code> list of the statement for the given cursor. The type of the <code>COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9222"></a>Syntax</p>
<pre>
DBMS_SQL.DEFINE_COLUMN_LONG (
   c              IN INTEGER,
   position       IN INTEGER); 
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9223"></a>Parameters</p>
<div id="ARPLS68256" class="tblformal">
<p class="titleintable"><a id="sthref9224"></a><a id="sthref9225"></a>Table 137-15 DEFINE_COLUMN_LONG Procedure Parameters</p>
<table class="cellalignment1229" title="DEFINE_COLUMN_LONG Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN_LONG subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t31">Parameter</th>
<th class="cellalignment1227" id="r1c2-t31">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t31" headers="r1c1-t31">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t31 r1c2-t31">
<p>ID number of the cursor for the row being defined to be selected.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t31" headers="r1c1-t31">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t31 r1c2-t31">
<p>Relative position of the column in the row being defined.</p>
<p>The first column in a statement has position 1.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72009" class="refsect2"><a id="CIHECACB"></a>
<hr />
<h3 class="refsect2"><a id="sthref9226"></a>DEFINE_COLUMN_RAW Procedure</h3>
<p>This procedure defines a column of type <code>RAW</code> to be selected from the given cursor. This procedure is only used with <code>SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code>SELECT</code> list of the statement in the given cursor. The type of the <code>COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a> and <a href="#CIHJJFJD">DEFINE_COLUMN_ROWID Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9227"></a>Syntax</p>
<pre>
DBMS_SQL.DEFINE_COLUMN_RAW (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN RAW,
   column_size    IN INTEGER);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9228"></a>Pragmas</p>
<pre>
pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9229"></a>Parameters</p>
<div id="ARPLS72010" class="tblformal">
<p class="titleintable"><a id="sthref9230"></a><a id="sthref9231"></a>Table 137-16 DEFINE_COLUMN Procedure Parameters</p>
<table class="cellalignment1229" title="DEFINE_COLUMN Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN_RAW subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t33">Parameter</th>
<th class="cellalignment1227" id="r1c2-t33">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t33" headers="r1c1-t33">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t33 r1c2-t33">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t33" headers="r1c1-t33">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t33 r1c2-t33">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t33" headers="r1c1-t33">
<p><code>column</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t33 r1c2-t33">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t33" headers="r1c1-t33">
<p><code>column_size</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t33 r1c2-t33">
<p>Maximum expected size of the column value in bytes for columns of and <code>RAW</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS72011" class="refsect2"><a id="CIHJJFJD"></a>
<hr />
<h3 class="refsect2"><a id="sthref9232"></a>DEFINE_COLUMN_ROWID Procedure</h3>
<p>This procedure defines a column of type <code>ROWID</code> to be selected from the given cursor. This procedure is only used with <code>SELECT</code> cursors.</p>
<p>The column being defined is identified by its relative position in the <code>SELECT</code> list of the statement in the given cursor. The type of the <code>COLUMN</code> value determines the type of the column being defined.</p>
<p>See also the <a href="#i1025686">DEFINE_COLUMN Procedures</a>, <a href="#CIHGCGBF">DEFINE_COLUMN_CHAR Procedure</a>, <a href="#i1025656">DEFINE_COLUMN_LONG Procedure</a> and <a href="#CIHECACB">DEFINE_COLUMN_RAW Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9233"></a>Syntax</p>
<pre>
DBMS_SQL.DEFINE_COLUMN_ROWID (
   c              IN INTEGER,
   position       IN INTEGER,
   column         IN ROWID); 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9234"></a>Pragmas</p>
<pre>
pragma restrict_references(define_column,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9235"></a>Parameters</p>
<div id="ARPLS72012" class="tblformal">
<p class="titleintable"><a id="sthref9236"></a><a id="sthref9237"></a>Table 137-17 DEFINE_COLUMN Procedure Parameters</p>
<table class="cellalignment1229" title="DEFINE_COLUMN Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DEFINE_COLUMN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t35">Parameter</th>
<th class="cellalignment1227" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t35" headers="r1c1-t35">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t35 r1c2-t35">
<p>ID number of the cursor for the row being defined to be selected</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t35" headers="r1c1-t35">
<p><code>position</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t35 r1c2-t35">
<p>Relative position of the column in the row being defined.The first column in a statement has position 1.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t35" headers="r1c1-t35">
<p><code>column</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t35 r1c2-t35">
<p>Value of the column being defined. The type of this value determines the type for the column being defined.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68257" class="refsect2"><a id="i1026120"></a>
<hr />
<h3 class="refsect2"><a id="sthref9238"></a>DESCRIBE_COLUMNS Procedure</h3>
<p>This procedure describes the columns for a cursor opened and parsed through <code>DBMS_SQL</code>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9239"></a>Syntax</p>
<pre>
DBMS_SQL.DESCRIBE_COLUMNS ( 
   c              IN  INTEGER, 
   col_cnt        OUT INTEGER, 
   desc_t         OUT DESC_TAB);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9240"></a>Parameters</p>
<div id="ARPLS68258" class="tblformal">
<p class="titleintable"><a id="sthref9241"></a><a id="sthref9242"></a>Table 137-18 DESCRIBE_COLUMNS Procedure Parameters</p>
<table class="cellalignment1229" title=" DESCRIBE_COLUMNS Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t36">Parameter</th>
<th class="cellalignment1227" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t36" headers="r1c1-t36">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t36 r1c2-t36">
<p>ID number of the cursor for the columns being described</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t36" headers="r1c1-t36">
<p><code>col_cnt</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t36 r1c2-t36">
<p>Number of columns in the select list of the query</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t36" headers="r1c1-t36">
<p><code>desc_t</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t36 r1c2-t36">
<p>Describe table to fill in with the description of each of the columns of the query</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i997238">"Example 8:&nbsp;Describe Columns"</a> illustrates how to use <code>DESCRIBE_COLUMNS</code>.</div>
</div>
<!-- class="refsect2" -->
<div id="ARPLS68259" class="refsect2"><a id="i1029368"></a>
<hr />
<h3 class="refsect2"><a id="sthref9243"></a>DESCRIBE_COLUMNS2 Procedure</h3>
<p>This procedure describes the specified column. This is an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9244"></a>Syntax</p>
<pre>
DBMS_SQL.DESCRIBE_COLUMNS2 ( 
   c              IN  INTEGER, 
   col_cnt        OUT INTEGER, 
   desc_t         OUT DESC_TAB2);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9245"></a>Pragmas</p>
<pre>
PRAGMA RESTRICT_REFERENCES(describe_columns2,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9246"></a>Parameters</p>
<div id="ARPLS68260" class="tblformal">
<p class="titleintable"><a id="sthref9247"></a><a id="sthref9248"></a>Table 137-19 DESCRIBE_COLUMNS2 Procedure Parameters</p>
<table class="cellalignment1229" title="DESCRIBE_COLUMNS2 Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS2 subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t38">Parameter</th>
<th class="cellalignment1227" id="r1c2-t38">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t38" headers="r1c1-t38">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t38 r1c2-t38">
<p>ID number of the cursor for the columns being described.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t38" headers="r1c1-t38">
<p><code>col_cnt</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t38 r1c2-t38">
<p>Number of columns in the select list of the query.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t38" headers="r1c1-t38">
<p><code>desc_t</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t38 r1c2-t38">
<p>Describe table to fill in with the description of each of the columns of the query. This table is indexed from one to the number of elements in the select list of the query.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68261" class="refsect2"><a id="CHDJBBFH"></a>
<hr />
<h3 class="refsect2"><a id="sthref9249"></a>DESCRIBE_COLUMNS3 Procedure</h3>
<p>This procedure describes the specified column. This is an alternative to <a href="#i1026120">DESCRIBE_COLUMNS Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9250"></a>Syntax</p>
<pre>
DBMS_SQL.DESCRIBE_COLUMNS3 ( 
   c              IN  INTEGER, 
   col_cnt        OUT INTEGER, 
   desc_t         OUT DESC_TAB3);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9251"></a>Pragmas</p>
<pre>
PRAGMA RESTRICT_REFERENCES(describe_columns3,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9252"></a>Parameters</p>
<div id="ARPLS68262" class="tblformal">
<p class="titleintable"><a id="sthref9253"></a><a id="sthref9254"></a>Table 137-20 DESCRIBE_COLUMNS3 Procedure Parameters</p>
<table class="cellalignment1229" title="DESCRIBE_COLUMNS3 Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.DESCRIBE_COLUMNS3 subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t39">Parameter</th>
<th class="cellalignment1227" id="r1c2-t39">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t39" headers="r1c1-t39">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t39 r1c2-t39">
<p>ID number of the cursor for the columns being described.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t39" headers="r1c1-t39">
<p><code>col_cnt</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t39 r1c2-t39">
<p>Number of columns in the select list of the query.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t39" headers="r1c1-t39">
<p><code>desc_t</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t39 r1c2-t39">
<p>Describe table to fill in with the description of each of the columns of the query. This table is indexed from one to the number of elements in the select list of the query.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9255"></a>Usage Notes</p>
<p>The cursor passed in by the cursor ID has to be <code>OPEN</code>ed and <code>PARSE</code>d, otherwise an "invalid cursor id" error is raised.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9256"></a>Examples</p>
<pre>
CREATE TYPE PROJECT_T AS OBJECT
      ( projname          VARCHAR2(20),
        mgr               VARCHAR2(20))
/
 
CREATE TABLE projecttab(deptno NUMBER, project HR.PROJECT_T)
/
 
DECLARE
  curid      NUMBER;
  desctab    DBMS_SQL.DESC_TAB3;
  colcnt     NUMBER;
  sql_stmt   VARCHAR2(200) := 'select * from projecttab';
BEGIN
 
    curid := DBMS_SQL.OPEN_CURSOR;
 
    DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);
 
    DBMS_SQL.DESCRIBE_COLUMNS3(curid, colcnt, desctab);
 
    FOR i IN 1 .. colcnt LOOP
      IF desctab(i).col_type = 109 THEN
        DBMS_OUTPUT.PUT(desctab(i).col_name || ' is user-defined type: ');
        DBMS_OUTPUT.PUT_LINE(desctab(i).col_schema_name || '.' ||
                             desctab(i).col_type_name);
      END IF;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(curid);
END;
/
 
Output:
 
PROJECT is user-defined type: HR.PROJECT_T
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68263" class="refsect2"><a id="i1025983"></a>
<hr />
<h3 class="refsect2"><a id="sthref9257"></a>EXECUTE Function</h3>
<p>This function executes a given cursor. This function accepts the <code>ID</code> number of the cursor and returns the number of rows processed. The return value is only valid for <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements; for other types of statements, including DDL, the return value is undefined and should be ignored.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9258"></a>Syntax</p>
<pre>
DBMS_SQL.EXECUTE (
   c   IN INTEGER)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9259"></a>Parameters</p>
<div id="ARPLS73184" class="tblformal">
<p class="titleintable"><a id="sthref9260"></a><a id="sthref9261"></a>Table 137-21 EXECUTE Function Parameters</p>
<table class="cellalignment1229" title="EXECUTE Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.EXECUTE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t40">Parameter</th>
<th class="cellalignment1227" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t40" headers="r1c1-t40">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t40 r1c2-t40">
<p>Cursor ID number of the cursor to execute.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9262"></a>Return Values</p>
<p>Returns number of rows processed</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9263"></a>Usage Notes</p>
<p>The <code>DBMS_SQL</code> cursor that is returned by the <a href="#CHDJDGDG">TO_CURSOR_NUMBER Function</a> performs in the same way as a <code>DBMS_SQL</code> cursor that has already been executed. Consequently, calling <code>EXECUTE</code> for this cursor will cause an error.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68265" class="refsect2"><a id="i1025711"></a>
<hr />
<h3 class="refsect2"><a id="sthref9264"></a>EXECUTE_AND_FETCH Function</h3>
<p>This function executes the given cursor and fetches rows. This function provides the same functionality as calling <code>EXECUTE</code> and then calling <code>FETCH_ROWS</code>. Calling <code>EXECUTE_AND_FETCH</code> instead, however, may reduce the number of network round-trips when used against a remote database.</p>
<p>The <code>EXECUTE_AND_FETCH</code> function returns the number of rows actually fetched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9265"></a>Syntax</p>
<pre>
DBMS_SQL.EXECUTE_AND_FETCH (
   c              IN INTEGER,
   exact          IN BOOLEAN DEFAULT FALSE)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9266"></a>Pragmas</p>
<pre>
pragma restrict_references(execute_and_fetch,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9267"></a>Parameters</p>
<div id="ARPLS68266" class="tblformal">
<p class="titleintable"><a id="sthref9268"></a><a id="sthref9269"></a>Table 137-22 EXECUTE_AND_FETCH Function Parameters</p>
<table class="cellalignment1229" title="EXECUTE_AND_FETCH Function Parameters " summary="This table describes Parameters used by the DBMS_SQL.EXECUTE_AND_FETCH subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t41">Parameter</th>
<th class="cellalignment1227" id="r1c2-t41">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t41" headers="r1c1-t41">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t41 r1c2-t41">
<p>ID number of the cursor to execute and fetch.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t41" headers="r1c1-t41">
<p><code>exact</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t41 r1c2-t41">
<p>Set to <code>TRUE</code> to raise an exception if the number of rows actually matching the query differs from one.</p>
<p>Note: Oracle does not support the exact fetch TRUE option with LONG columns.</p>
<p>Even if an exception is raised, the rows are still fetched and available.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9270"></a>Return Values</p>
<p>Returns designated rows</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68267" class="refsect2"><a id="i1026065"></a>
<hr />
<h3 class="refsect2"><a id="sthref9271"></a>FETCH_ROWS Function</h3>
<p>This function fetches a row from a given cursor. You can call <code>FETCH_ROWS</code> repeatedly as long as there are rows remaining to be fetched. These rows are retrieved into a buffer, and must be read by calling <code>COLUMN_VALUE</code>, for each column, after each call to <code>FETCH_ROWS</code>.</p>
<p>The <code>FETCH_ROWS</code> function accepts the ID number of the cursor to fetch, and returns the number of rows actually fetched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9272"></a>Syntax</p>
<pre>
DBMS_SQL.FETCH_ROWS (
   c              IN INTEGER)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9273"></a>Pragmas</p>
<pre>
pragma restrict_references(fetch_rows,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9274"></a>Parameters</p>
<div id="ARPLS68268" class="tblformal">
<p class="titleintable"><a id="sthref9275"></a><a id="sthref9276"></a>Table 137-23 FETCH_ROWS Function Parameters</p>
<table class="cellalignment1229" title="FETCH_ROWS Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.FETCH_ROWS subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t42">Parameter</th>
<th class="cellalignment1227" id="r1c2-t42">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t42" headers="r1c1-t42">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t42 r1c2-t42">
<p>ID number.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9277"></a>Return Values</p>
<p>Returns a row from a given cursor</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68269" class="refsect2"><a id="i1026423"></a>
<hr />
<h3 class="refsect2"><a id="sthref9278"></a>IS_OPEN Function</h3>
<p>This function checks to see if the given cursor is currently open.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9279"></a>Syntax</p>
<pre>
DBMS_SQL.IS_OPEN (
   c              IN INTEGER)
  RETURN BOOLEAN;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9280"></a>Pragmas</p>
<pre>
pragma restrict_references(is_open,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9281"></a>Parameters</p>
<div id="ARPLS68270" class="tblformal">
<p class="titleintable"><a id="sthref9282"></a><a id="sthref9283"></a>Table 137-24 IS_OPEN Function Parameters</p>
<table class="cellalignment1229" title="IS_OPEN Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t43">Parameter</th>
<th class="cellalignment1227" id="r1c2-t43">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t43" headers="r1c1-t43">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t43 r1c2-t43">
<p>Cursor ID number of the cursor to check.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9284"></a>Return Values</p>
<p>Returns <code>TRUE</code> for any cursor number that has been opened but not closed, and <code>FALSE</code> for a <code>NULL</code> cursor number. Note that the <a href="#i1026299">CLOSE_CURSOR Procedure</a> Procedure <code>NULL</code>s out the cursor variable passed to it.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9285"></a>Exceptions</p>
<p><code>ORA-29471 DBMS_SQL access denied:</code> This is raised if an invalid cursor ID number is detected. Once a session has encountered and reported this error, every subsequent DBMS_SQL call in the same session will raise this error, meaning that DBMS_SQL is non-operational for this session.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68271" class="refsect2"><a id="i1026408"></a>
<hr />
<h3 class="refsect2"><a id="sthref9286"></a>LAST_ERROR_POSITION Function</h3>
<p>This function returns the byte offset in the SQL statement text where the error occurred. The first character in the SQL statement is at position 0.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9287"></a>Syntax</p>
<pre>
DBMS_SQL.LAST_ERROR_POSITION 
   RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9288"></a>Pragmas</p>
<pre>
pragma restrict_references(last_error_position,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9289"></a>Return Values</p>
<p>Returns the byte offset in the SQL statement text where the error occurred</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9290"></a>Usage Notes</p>
<p>Call this function after a <code>PARSE</code> call, before any other <code>DBMS_SQL</code> procedures or functions are called.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68272" class="refsect2"><a id="i1026354"></a>
<hr />
<h3 class="refsect2"><a id="sthref9291"></a>LAST_ROW_COUNT Function</h3>
<p>This function returns the cumulative count of the number of rows fetched.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9292"></a>Syntax</p>
<pre>
DBMS_SQL.LAST_ROW_COUNT 
   RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9293"></a>Pragmas</p>
<pre>
pragma restrict_references(last_row_count,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9294"></a>Return Values</p>
<p>Returns the cumulative count of the number of rows fetched</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9295"></a>Usage Notes</p>
<p>Call this function after a <code>FETCH_ROWS</code> or an <code>EXECUTE_AND_FETCH</code> call. If called after an <code>EXECUTE</code> call, then the value returned is zero.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68273" class="refsect2"><a id="i1026364"></a>
<hr />
<h3 class="refsect2"><a id="sthref9296"></a>LAST_ROW_ID Function</h3>
<p>This function returns the <code>ROWID</code> of the last row processed.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9297"></a>Syntax</p>
<pre>
DBMS_SQL.LAST_ROW_ID 
   RETURN ROWID;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9298"></a>Pragmas</p>
<pre>
pragma restrict_references(last_row_id,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9299"></a>Return Values</p>
<p>Returns the <code>ROWID</code> of the last row processed</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9300"></a>Usage Notes</p>
<p>Call this function after a <code>FETCH_ROWS</code> or an <code>EXECUTE_AND_FETCH</code> call.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68274" class="refsect2"><a id="i1026374"></a>
<hr />
<h3 class="refsect2"><a id="sthref9301"></a>LAST_SQL_FUNCTION_CODE Function</h3>
<p>This function returns the SQL function code for the statement. These codes are listed in the <a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide.</span></a></p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9302"></a>Syntax</p>
<pre>
DBMS_SQL.LAST_SQL_FUNCTION_CODE 
   RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9303"></a>Pragmas</p>
<pre>
pragma restrict_references(last_sql_function_code,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9304"></a>Return Values</p>
<p>Returns the SQL function code for the statement</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9305"></a>Usage Notes</p>
<p>You should call this function immediately after the SQL statement is run; otherwise, the return value is undefined.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68275" class="refsect2"><a id="i997665"></a>
<hr />
<h3 class="refsect2"><a id="sthref9306"></a>OPEN_CURSOR Function</h3>
<p>This procedure opens a new cursor. The second overload takes a <code>security_level</code> parameter to apply fine-grained control to the security of the opened cursor.</p>
<p>When you no longer need this cursor, you must close it explicitly by calling the <a href="#i1026299">CLOSE_CURSOR Procedure</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9307"></a>Syntax</p>
<pre>
DBMS_SQL.OPEN_CURSOR 
  RETURN INTEGER;

DBMS_SQL.OPEN_CURSOR (
   security_level   IN   INTEGER) 
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9308"></a>Parameters</p>
<div id="ARPLS68276" class="tblformal">
<p class="titleintable"><a id="sthref9309"></a><a id="sthref9310"></a>Table 137-25 OPEN_CURSOR Function Parameters</p>
<table class="cellalignment1229" title="OPEN_CURSOR Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t44">Parameter</th>
<th class="cellalignment1227" id="r1c2-t44">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t44" headers="r1c1-t44">
<p><code>security_level</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t44 r1c2-t44">
<p>Specifies the level of security protection to enforce on the opened cursor. Valid security level values are <code>0</code>, <code>1</code>, and <code>2</code>. When a <code>NULL</code> argument value is provided to this overload, as well as for cursors opened using the overload of open_cursor without the security_level parameter, the default security level value <code>1</code> will be enforced on the opened cursor.</p>
<ul>
<li>
<p><code>Level</code> <code>0</code> - allows all <code>DBMS_SQL</code> operations on the cursor without any security checks. The cursor may be fetched from, and even re-bound and re-executed, by code running with a different effective userid or roles than those in effect at the time the cursor was parsed. This level of security is off by default.</p>
</li>
<li>
<p><code>Level</code> <code>1</code> - requires that the effective userid and roles of the caller to <code>DBMS_SQL</code> for bind and execute operations on this cursor must be the same as those of the caller of the most recent parse operation on this cursor.</p>
</li>
<li>
<p><code>Level</code> <code>2</code> - requires that the effective userid and roles of the caller to <code>DBMS_SQL</code> for all bind, execute, define, describe, and fetch operations on this cursor must be the same as those of the caller of the most recent parse operation on this cursor.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9311"></a>Pragmas</p>
<pre>
pragma restrict_references(open_cursor,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9312"></a>Return Values</p>
<p>Returns the cursor ID number of the new cursor</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9313"></a>Usage Notes</p>
<p>You can use cursors to run the same SQL statement repeatedly or to run a new SQL statement. When a cursor is reused, the contents of the corresponding cursor data area are reset when the new SQL statement is parsed. It is never necessary to close and reopen a cursor before reusing it.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68277" class="refsect2"><a id="i997676"></a>
<hr />
<h3 class="refsect2"><a id="sthref9314"></a>PARSE Procedures</h3>
<p>This procedure parses the given statement in the given cursor. All statements are parsed immediately. In addition, DDL statements are run immediately when parsed.</p>
<p>There are three versions of the <code>PARSE</code> procedure:</p>
<ul>
<li>
<p>Taking a <code>VARCHAR2</code> statement as an argument</p>
</li>
</ul>
<ul>
<li>
<p>Taking <code>VARCHAR2a</code>, table of <code>VARCHAR2</code>(32767), as an argument. The <code>VARCHAR2A</code> overload version of the procedure concatenates elements of a PL/SQL table statement and parses the resulting string. You can use this procedure to parse a statement that is longer than the limit for a single <code>VARCHAR2</code> variable by splitting up the statement.</p>
</li>
</ul>
<ul>
<li>
<p>Taking a <code>CLOB</code> statement as an argument. You can use the <code>CLOB</code> overload version of the parse procedure to parse a SQL statement larger than 32K bytes.</p>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9315"></a>Syntax</p>
<pre>
DBMS_SQL.PARSE (
   c                           IN   INTEGER,
   statement                   IN   VARCHAR2,
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE);
</pre>
<pre>
DBMS_SQL.PARSE (
   c                           IN   INTEGER,
   statement                   IN   CLOB,
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE);
</pre>
<pre>
DBMS_SQL.PARSE (
   c                           IN   INTEGER, 
   statement                   IN   VARCHAR2A,
   lb                          IN   INTEGER, 
   ub                          IN   INTEGER,
   lfflg                       IN   BOOLEAN, 
   language_flag               IN   INTEGER,
   edition                     IN   VARCHAR2 DEFAULT NULL,
   apply_crossedition_trigger  IN   VARCHAR2 DEFAULT NULL,
   fire_apply_trigger          IN   BOOLEAN DEFAULT TRUE);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9316"></a>Parameters</p>
<div id="ARPLS68278" class="tblformal">
<p class="titleintable"><a id="sthref9317"></a><a id="sthref9318"></a>Table 137-26 PARSE Procedure Parameters</p>
<table class="cellalignment1229" title="PARSE Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.PARSE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t45">Parameter</th>
<th class="cellalignment1227" id="r1c2-t45">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t45" headers="r1c1-t45">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t45 r1c2-t45">
<p>ID number of the cursor in which to parse the statement.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t45" headers="r1c1-t45">
<p><code>statement</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t45 r1c2-t45">
<p>SQL statement to be parsed. SQL statements larger than 32K that may be stored in <code>CLOB</code>s.</p>
<p>Unlike PL/SQL statements, your SQL statement should not include a final semicolon. For example:</p>
<p><code>DBMS_SQL.PARSE</code>(cursor1, '<code>BEGIN</code> proc; <code>END</code>;', 2);</p>
<p><code>DBMS_SQL.PARSE</code>(cursor1, '<code>INSERT</code> <code>INTO</code> tab <code>VALUES</code>(1)', 2);</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t45" headers="r1c1-t45">
<p><code>lb</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t45 r1c2-t45">
<p>Lower bound for elements in the statement</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r5c1-t45" headers="r1c1-t45">
<p><code>ub</code></p>
</td>
<td class="cellalignment1228" headers="r5c1-t45 r1c2-t45">
<p>Upper bound for elements in the statement</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r6c1-t45" headers="r1c1-t45">
<p><code>lfflg</code></p>
</td>
<td class="cellalignment1228" headers="r6c1-t45 r1c2-t45">
<p>If <code>TRUE</code>, then insert a linefeed after each element on concatenation.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r7c1-t45" headers="r1c1-t45">
<p><code>language_flag</code></p>
</td>
<td class="cellalignment1228" headers="r7c1-t45 r1c2-t45">
<p>Determines how Oracle handles the SQL statement. The following options are recognized:</p>
<ul>
<li>
<p><code>V6</code> (or <code>0</code>) specifies version 6 behavior.</p>
</li>
<li>
<p><code>NATIVE</code> (or <code>1</code>) specifies normal behavior for the database to which the program is connected.</p>
</li>
<li>
<p><code>V7</code> (or <code>2</code>) specifies Oracle database version 7 behavior.</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r8c1-t45" headers="r1c1-t45">
<p><code>edition</code></p>
</td>
<td class="cellalignment1228" headers="r8c1-t45 r1c2-t45">
<p>Specifies the edition to run the statement in. Passing <code>NULL</code> indicates the statement should to run in the caller's current edition. The contents of the string are processed as a SQL identifier; double-quotes must surround the remainder of the string if special characters or lower case characters are present in the edition's actual name, and if double-quotes are not used the contents will be uppercased. If the edition is specified with a non-<code>NULL</code> value, the user with which the statement is to be executed must have <code>USE</code> privilege on the named edition.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r9c1-t45" headers="r1c1-t45">
<p><code>apply_crossedition_trigger</code></p>
</td>
<td class="cellalignment1228" headers="r9c1-t45 r1c2-t45">
<p>Specifies the unqualified name of a forward crossedition trigger that is to be applied to the specified SQL. The name is resolved using the edition and <code>current_schema</code> setting in which the statement is to be executed. The trigger must be owned by the user that will execute the statement.If a non-<code>NULL</code> value is specified, the specified crossedition trigger will be executed assuming <code>fire_apply_trigger</code> is <code>TRUE</code>, the trigger is enabled, the trigger is defined on the table which is the target of the statement, the type of the statement matches the trigger's <code>dml_event_clause</code>, any effective <code>WHEN</code> and <code>UPDATE</code> <code>OF</code> restrictions are satisfied, and so on. Other forward crossedition triggers may also be executed, selected using the "crossedition trigger DML rules" applied as if the specified trigger was doing a further DML to the table that is the target of the statement. Non-crossedition triggers and reverse crossedition triggers will not be executed.The contents of the string are processed as a SQL identifier; double-quotes must surround the remainder of the string if special characters or lower case characters are present in the trigger's actual name, and if double-quotes are not used, the contents will be uppercased.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r10c1-t45" headers="r1c1-t45">
<p><code>fire_apply_trigger</code></p>
</td>
<td class="cellalignment1228" headers="r10c1-t45 r1c2-t45">
<p>Indicates whether the specified <code>apply_crossedition_trigger</code> is itself to be executed, or should only be a guide used in selecting other triggers. This is typically set <code>FALSE</code> when the statement is a replacement for the actions the <code>apply_crossedition_trigger</code> would itself perform. If <code>FALSE</code>, the specified trigger is not executed, but other triggers are still selected for firing as if the specified trigger was doing a DML to the table that is the target of the statement. The <code>apply_crossedition_trigger</code> and <code>fire_apply_trigger</code> parameters are ignored if the statement is not a DML.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9319"></a>Usage Notes</p>
<ul>
<li>
<p>Using <code>DBMS_SQL</code> to dynamically run DDL statements can result in the program hanging. For example, a call to a procedure in a package results in the package being locked until the execution returns to the user side. Any operation that results in a conflicting lock, such as dynamically trying to drop the package before the first lock is released, results in a hang.</p>
</li>
<li>
<p>Because client-side code cannot reference remote package variables or constants, you must explicitly use the values of the constants.</p>
<p>For example, the following code does <span class="italic">not</span> compile on the client:</p>
<p><code>DBMS_SQL.PARSE</code>(<code>cur_hdl</code>, <code>stmt_str</code>, <code>DBMS_SQL</code>.<code>NATIVE</code>); -- uses constant <code>DBMS_SQL.NATIVE</code></p>
<p>The following code works on the client, because the argument is explicitly provided:</p>
<p><code>DBMS_SQL</code>.<code>PARSE</code>(<code>cur_hdl</code>, <code>stmt_str</code>, <code>1</code>); -- compiles on the client</p>
</li>
<li>
<p>The VARCHAR2S type is currently supported for backward compatibility of legacy code. However, you are advised to use VARCHAR2A both for its superior capability and because VARCHAR2S will be deprecated in a future release.</p>
</li>
<li>
<p>To parse SQL statements larger than 32 KB, the new CLOB overload version of the PARSE procedure can be used instead of the VARCHAR2A overload</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9320"></a>Exceptions</p>
<p>If you create a type/procedure/function/package using <code>DBMS_SQL</code> that has compilation warnings, an <code>ORA-24344</code> exception is raised, and the procedure is still created.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68279" class="refsect2"><a id="CHDJDGDG"></a>
<hr />
<h3 class="refsect2"><a id="sthref9321"></a>TO_CURSOR_NUMBER Function</h3>
<p>This function takes an <code>OPEN</code>ed strongly or weakly-typed ref cursor and transforms it into a <code>DBMS_SQL</code> cursor number.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9322"></a>Syntax</p>
<pre>
DBMS_SQL.TO_CURSOR_NUMBER(
   rc IN OUT SYS_REFCURSOR)
  RETURN INTEGER;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9323"></a>Parameters</p>
<div id="ARPLS68280" class="tblformal">
<p class="titleintable"><a id="sthref9324"></a><a id="sthref9325"></a>Table 137-27 TO_CURSOR_NUMBER Function Parameters</p>
<table class="cellalignment1229" title="TO_CURSOR_NUMBER Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.TO_CURSOR_NUMBER subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t46">Parameter</th>
<th class="cellalignment1227" id="r1c2-t46">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t46" headers="r1c1-t46">
<p><code>rc</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t46 r1c2-t46">
<p><code>REF</code> <code>CURSOR</code> to be transformed into a cursor number</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9326"></a>Return Values</p>
<p>Returns a DBMS_SQL manageable cursor number transformed from a <code>REF</code> <code>CURSOR</code></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9327"></a>Usage Notes</p>
<ul>
<li>
<p>The <code>REF</code> <code>CURSOR</code> passed in has to be <code>OPEN</code>ed, otherwise an error is raised.</p>
</li>
<li>
<p>Once the <code>REF</code> <code>CURSOR</code> is transformed into a <code>DBMS_SQL</code> cursor number, the <code>REF</code> <code>CURSOR</code> is no longer accessible by any native dynamic SQL operations.</p>
</li>
<li>
<p>The <code>DBMS_SQL</code> cursor that is returned by this subprogram performs in the same way as a <code>DBMS_SQL</code> cursor that has already been executed.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9328"></a>Examples</p>
<pre>
CREATE OR REPLACE PROCEDURE DO_QUERY(sql_stmt VARCHAR2) IS
  TYPE CurType IS REF CURSOR;
  src_cur         CurType;
  curid           NUMBER;
  desctab         DBMS_SQL.DESC_TAB;
  colcnt          NUMBER;
  namevar         VARCHAR2(50);
  numvar          NUMBER;
  datevar         DATE;
  empno           NUMBER := 100;
BEGIN
 
 
    -- sql_stmt := 'select ...... from employees where employee_id = :b1';
    OPEN src_cur FOR sql_stmt USING empno;
 
    -- Switch from native dynamic SQL to DBMS_SQL
    curid := DBMS_SQL.TO_CURSOR_NUMBER (src_cur);
 
    DBMS_SQL.DESCRIBE_COLUMNS(curid, colcnt, desctab);
 
    -- Define columns
    FOR i IN 1 .. colcnt LOOP
        IF desctab(i).col_type = 2 THEN
           DBMS_SQL.DEFINE_COLUMN(curid, i, numvar);
        ELSIF desctab(i).col_type = 12 THEN
            DBMS_SQL.DEFINE_COLUMN(curid, i, datevar);
.......
         ELSE
            DBMS_SQL.DEFINE_COLUMN(curid, i, namevar, 25);
         END IF;
    END LOOP;
 
  -- Fetch Rows
    WHILE DBMS_SQL.FETCH_ROWS(curid) &gt; 0 LOOP
        FOR i IN 1 .. colcnt LOOP
          IF (desctab(i).col_type = 1) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, namevar);
         ELSIF (desctab(i).col_type = 2) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, numvar);
          ELSIF (desctab(i).col_type = 12) THEN
            DBMS_SQL.COLUMN_VALUE(curid, i, datevar);
....
          END IF;
        END LOOP;
    END LOOP;
 
    DBMS_SQL.CLOSE_CURSOR(curid);
END;
/ 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68281" class="refsect2"><a id="CHDFDCDE"></a>
<hr />
<h3 class="refsect2"><a id="sthref9329"></a>TO_REFCURSOR Function</h3>
<p>This function takes an <code>OPEN</code>ed, <code>PARSE</code>d, and <code>EXECUTE</code>d cursor and transforms/migrates it into a PL/SQL manageable <code>REF</code> <code>CURSOR</code> (a weakly-typed cursor) that can be consumed by PL/SQL native dynamic SQLswitched to use native dynamic SQL. This subprogram is only used with <code>SELECT</code> cursors.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9330"></a>Syntax</p>
<pre>
DBMS_SQL.TO_REFCURSOR(
   cursor_number IN OUT INTEGER)
  RETURN SYS_REFCURSOR;
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9331"></a>Parameters</p>
<div id="ARPLS68282" class="tblformal">
<p class="titleintable"><a id="sthref9332"></a><a id="sthref9333"></a>Table 137-28 TO_REFCURSOR Function Parameters</p>
<table class="cellalignment1229" title="TO_REFCURSOR Function Parameters" summary="This table describes Parameters used by the DBMS_SQL.IS_OPEN subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t47">Parameter</th>
<th class="cellalignment1227" id="r1c2-t47">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t47" headers="r1c1-t47">
<p><code>cursor_number</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t47 r1c2-t47">
<p>Cursor number of the cursor to be transformed into <code>REF</code> <code>CURSOR</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9334"></a>Return Values</p>
<p>Returns a PL/SQL <code>REF</code> <code>CURSOR</code> transformed from a <code>DBMS_SQL</code> cursor number</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9335"></a>Usage Notes</p>
<ul>
<li>
<p>The cursor passed in by the cursor_number has to be <code>OPEN</code>ed, <code>PARSE</code>d, and <code>EXECUTE</code>d; otherwise an error is raised.</p>
</li>
<li>
<p>Once the cursor_number is transformed into a <code>REF</code> <code>CURSOR</code>, the <code>cursor_number</code> is no longer accessible by any <code>DBMS_SQL</code> operations.</p>
</li>
<li>
<p>After a cursor_number is transformed into a <code>REF</code> <code>CURSOR</code>, using <code>DBMS_SQL</code>.<code>IS_OPEN</code> to check to see if the <code>cursor_number</code> is still open results in an error.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9336"></a>Examples</p>
<pre>
CREATE OR REPLACE PROCEDURE DO_QUERY(mgr_id NUMBER) IS
  TYPE CurType IS REF CURSOR;
  src_cur         CurType;
  curid           NUMBER;
  sql_stmt        VARCHAR2(200);
  ret             INTEGER;
  empnos          DBMS_SQL.Number_Table;
  depts           DBMS_SQL.Number_Table;
BEGIN

  -- DBMS_SQL.OPEN_CURSOR
  curid := DBMS_SQL.OPEN_CURSOR;
 
  sql_stmt :=    'SELECT EMPLOYEE_ID, DEPARTMENT_ID from employees where MANAGER_ID = :b1';

  DBMS_SQL.PARSE(curid, sql_stmt, DBMS_SQL.NATIVE);
  DBMS_SQL.BIND_VARIABLE(curid, 'b1', mgr_id);
  ret := DBMS_SQL.EXECUTE(curid);

  -- Switch from DBMS_SQL to native dynamic SQL
  src_cur := DBMS_SQL.TO_REFCURSOR(curid);

  -- Fetch with native dynamic SQL
  FETCH src_cur BULK COLLECT INTO empnos, depts;

  IF empnos.COUNT &gt; 0 THEN
    DBMS_OUTPUT.PUT_LINE('EMPNO DEPTNO');
    DBMS_OUTPUT.PUT_LINE('----- ------');
    -- Loop through the empnos and depts collections
    FOR i IN 1 .. empnos.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE(empnos(i) || '   ' || depts(i));
    END LOOP;
  END IF;
   -- Close cursor
  CLOSE src_cur;
END;
/ 
</pre></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="ARPLS68283" class="refsect2"><a id="i998371"></a>
<hr />
<h3 class="refsect2"><a id="sthref9337"></a>VARIABLE_VALUE Procedures</h3>
<p>This procedure returns the value of the named variable for a given cursor. It is used to return the values of bind variables inside PL/SQL blocks or DML statements with <code>returning</code> clause.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9338"></a>Syntax</p>
<pre>
DBMS_SQL.VARIABLE_VALUE (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT NOCOPY &lt;datatype&gt;);
 
</pre>
<p>Where &lt;datatype&gt; can be any one of the following types:</p>
<pre>
BINARY_DOUBLE
BINARY_FLOAT
BFILE
BLOB
CLOB CHARACTER SET ANY_CS
DATE
DSINTERVAL_UNCONSTRAINED
NUMBER
TIME_TZ_UNCONSTRAINED
TIME_UNCONSTRAINED
TIMESTAMP_LTZ_UNCONSTRAINED
TIMESTAMP_TZ_UNCONSTRAINED
TIMESTAMP_UNCONSTRAINED
UROWID
VARCHAR2 CHARACTER SET ANY_CS
YMINTERVAL_UNCONSTRAINED
user-defined object types
collections (VARRAYs and nested tables)
REFs
Opaque types
</pre>
<p>For variables containing <code>CHAR</code>, <code>RAW</code>, and <code>ROWID</code> data, you can use the following variations on the syntax:</p>
<pre>
DBMS_SQL.VARIABLE_VALUE_CHAR (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT CHAR CHARACTER SET ANY_CS);

DBMS_SQL.VARIABLE_VALUE_RAW (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT RAW);

DBMS_SQL.VARIABLE_VALUE_ROWID (
   c               IN  INTEGER,
   name            IN  VARCHAR2,
   value           OUT ROWID);
</pre>
<p>The following syntax enables the <code>VARIABLE_VALUE</code> procedure to accommodate bulk operations:</p>
<pre>
DBMS_SQL.VARIABLE_VALUE ( 
   c                 IN   INTEGER, 
   name              IN   VARCHAR2,
   value             OUT NOCOPY &lt;table_type&gt;); 
</pre>
<p>For bulk operations, &lt;<code>table_type</code>&gt; can be:</p>
<pre>
Binary_Double_Table
Binary_Float_Table
Bfile_Table
Blob_Table
Clob_Table
Date_Table
Interval_Day_To_Second_Table
Interval_Year_To_Month_Table
Number_Table
Time_Table
Time_With_Time_Zone_Table
Timestamp_Table
Timestamp_With_ltz_Table;
Timestamp_With_Time_Zone_Table
Urowid_Table
Varchar2_Table
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9339"></a>Pragmas</p>
<pre>
pragma restrict_references(variable_value,RNDS,WNDS);
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref9340"></a>Parameters</p>
<div id="ARPLS68284" class="tblformal">
<p class="titleintable"><a id="sthref9341"></a><a id="sthref9342"></a>Table 137-29 VARIABLE_VALUE Procedure Parameters</p>
<table class="cellalignment1229" title="VARIABLE_VALUE Procedure Parameters " summary="This table describes Parameters used by the DBMS_SQL.VARIABLE_VALUE subprogram." dir="ltr">
<thead>
<tr class="cellalignment1220">
<th class="cellalignment1227" id="r1c1-t48">Parameter</th>
<th class="cellalignment1227" id="r1c2-t48">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r2c1-t48" headers="r1c1-t48">
<p><code>c</code></p>
</td>
<td class="cellalignment1228" headers="r2c1-t48 r1c2-t48">
<p>ID number of the cursor from which to get the values.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r3c1-t48" headers="r1c1-t48">
<p><code>name</code></p>
</td>
<td class="cellalignment1228" headers="r3c1-t48 r1c2-t48">
<p>Name of the variable for which you are retrieving the value.</p>
</td>
</tr>
<tr class="cellalignment1220">
<td class="cellalignment1228" id="r4c1-t48" headers="r1c1-t48">
<p><code>value</code></p>
</td>
<td class="cellalignment1228" headers="r4c1-t48 r1c2-t48">
<ul>
<li>
<p>Single row option: Returns the value of the variable for the specified position. Oracle raises the exception <code>ORA-06562</code>, <code>inconsistent_type</code>, if the type of this output parameter differs from the actual type of the value, as defined by the call to <code>BIND_VARIABLE</code>.</p>
</li>
<li>
<p>Array option: Local variable that has been declared &lt;<code>table_type</code>&gt;. For bulk operations, <code>value</code> is an <code>OUT</code> <code>NOCOPY</code> parameter.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="refentry" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1219">
<tr>
<td class="cellalignment1228">
<table class="cellalignment1224">
<tr>
<td class="cellalignment1223"><a href="d_spm.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1223"><a href="d_sqldiag.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1231">
<table class="cellalignment1222">
<tr>
<td class="cellalignment1223"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1223"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1223"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1223"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1223"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1223"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
