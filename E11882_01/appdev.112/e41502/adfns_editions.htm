<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Edition-Based Redefinition</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-06T1:49:51Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Advanced Application Developer's Guide" />
<meta name="dcterms.identifier" content="E41502-06" />
<meta name="dcterms.isVersionOf" content="ADFNS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="adfns_dependencies.htm" title="Previous" type="text/html" />
<link rel="Next" href="adfns_extproc.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41502.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">29/31</span> <!-- End Header -->
<div id="ADFNS020" class="chapter"><a id="CEGGJDAE"></a>
<h1 class="chapter"><span class="secnum">19</span> Edition-Based Redefinition</h1>
<p><a id="sthref1154"></a><a id="sthref1155"></a><span class="bold">Edition-based redefinition</span> enables you to upgrade the database component of an application while it is in use, thereby minimizing or eliminating down time.</p>
<p>To upgrade an application while it is in use, you copy the database objects that comprise the application and redefine the copied objects in isolation. Your changes do not affect users of the application&mdash;they continue to run the unchanged application. When you are sure that your changes are correct, you make the upgraded application available to all users.</p>
<p>Using edition-based redefinition means using one or more of its component features. The features you use, and the down time, depend on these factors:</p>
<ul>
<li>
<p>What kind of database objects you redefine</p>
</li>
<li>
<p>How available the database objects must be to users while you are redefining them</p>
</li>
<li>
<p>Whether you make the upgraded application available to some users while others continue to use the older version of the application</p>
</li>
</ul>
<p>You always use the <span class="bold">edition</span> feature to copy the database objects and redefine the copied objects in isolation; that is why the procedure that this chapter describes for upgrading applications online is called edition-based redefinition.</p>
<p>If the object type of every object you will redefine is <span class="bold">editionable</span> (defined in <a href="#g5086774">"Editionable and Noneditionable Schema Object Types"</a>), the edition is the only feature you use.</p>
<p>Table is not an editionable type. If you change the structure of one or more tables, you also use the <span class="bold">editioning view</span> feature.</p>
<p>If other users must be able to change data in the tables while you are changing their structure, you also use <span class="bold">forward crossedition triggers</span>. If the pre- and post-upgrade applications will be in ordinary use at the same time (<a id="sthref1156"></a><span class="bold">hot rollover</span>), you also use <span class="bold">reverse crossedition triggers</span>. Crossedition triggers are not a permanent part of the application&mdash;you drop them when all users are using the post-upgrade application.</p>
<p class="subhead2"><a id="sthref1157"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDEIJDH">Editions</a></p>
</li>
<li>
<p><a href="#CHDJEECI">Editioning Views</a></p>
</li>
<li>
<p><a href="#CHDJCDFF">Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#CHDCEEEA">Displaying Information About Editions, Editioning Views, and Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#BABEHGAF">Using Edition-Based Redefinition to Upgrade an Application</a></p>
</li>
</ul>
<a id="CHDEIJDH"></a>
<div id="ADFNS0201" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Editions</h2>
<p><a id="sthref1158"></a>Editions are nonschema objects; as such, they do not have owners. Editions are created in a single namespace, and multiple editions can coexist in the database.</p>
<p>The database must have at least one edition. Every newly created or upgraded Oracle Database starts with one edition named <a id="sthref1159"></a><a id="sthref1160"></a><code dir="ltr">ora$base</code>.</p>
<p class="subhead2"><a id="sthref1161"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDGBJHF">Editioned and Noneditioned Objects</a></p>
</li>
<li>
<p><a href="#CHDGIGIF">Creating an Edition</a></p>
</li>
<li>
<p><a href="#CHDEDBFB">Inherited and Actual Objects</a></p>
</li>
<li>
<p><a href="#BABJFDCH">Making an Edition Available to Some Users</a></p>
</li>
<li>
<p><a href="#BABJFDDG">Making an Edition Available to All Users</a></p>
</li>
<li>
<p><a href="#CHDFGIAA">Current Edition and Session Edition</a></p>
</li>
<li>
<p><a href="#CHDEEIBA">Retiring an Edition</a></p>
</li>
<li>
<p><a href="#CHDJCDCA">Dropping an Edition</a></p>
</li>
</ul>
<a id="CHDGBJHF"></a>
<div id="ADFNS99923" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Editioned and Noneditioned Objects</h3>
<p>An <a id="sthref1162"></a><a id="sthref1163"></a><span class="bold">editioned object</span> is a schema object that has both an editionable type and an editions-enabled owner. (A schema object that has an editionable type but not an editions-enabled owner is <a id="sthref1164"></a><a id="sthref1165"></a><span class="bold">potentially editioned</span>.) An edition can have its own copy of an editioned object, in which case only the copy is visible to the edition.</p>
<p>A <a id="sthref1166"></a><a id="sthref1167"></a><span class="bold">noneditioned object</span> is a schema object that has a noneditionable type. An edition cannot have its own copy of a noneditioned object. A noneditioned object is identical in, and visible to, all editions.</p>
<p>An editioned object is uniquely identified by its <code dir="ltr">OBJECT_NAME</code>, <code dir="ltr">OWNER</code>, and <code dir="ltr">EDITION_NAME</code>. A noneditioned object is uniquely identified by its <code dir="ltr">OBJECT_NAME</code> and <code dir="ltr">OWNER</code>&mdash;its <code dir="ltr">EDITION_NAME</code> is <code dir="ltr">NULL</code>. (Strictly speaking, the <code dir="ltr">NAMESPACE</code> of an object is also required to uniquely identify the object, but you can ignore this fact, because any statement that references the object implicitly or explicitly specifies its <code dir="ltr">NAMESPACE</code>.)</p>
<p>You can display the <code dir="ltr">OBJECT_NAME</code>, <code dir="ltr">OWNER</code>, and <code dir="ltr">EDITION_NAME</code> of an object with the static data dictionary views <code dir="ltr">*_OBJECTS</code> and <code dir="ltr">*_OBJECTS_AE</code> (described in <a href="#g4932472">Table 19-1</a>).</p>
<p>You need not know the <code dir="ltr">EDITION_NAME</code> of an object to refer to that object (and if you do know it, you cannot specify it). The context of the reference implicitly specifies the edition. If the context is a data definition language (DDL) statement, the edition is the current edition of the session that issued the command (for information about the current edition, see <a href="#CHDFGIAA">"Current Edition and Session Edition"</a>). If the context is source code, the edition is the one in which the object is actual (see <a href="#CHDEDBFB">"Inherited and Actual Objects"</a>).</p>
<p class="subhead2"><a id="sthref1168"></a>Topics:</p>
<ul>
<li>
<p><a href="#g5086774">Editionable and Noneditionable Schema Object Types</a></p>
</li>
<li>
<p><a href="#BABBCBDC">Rules for Editioned Objects</a></p>
</li>
<li>
<p><a href="#g5086786">Enabling Editions for a User</a></p>
</li>
</ul>
<a id="g5086774"></a>
<div id="ADFNS898" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Editionable and Noneditionable Schema Object Types</h4>
<p>These schema objects types are <a id="sthref1169"></a><a id="sthref1170"></a><span class="bold">editionable</span>:</p>
<ul>
<li>
<p><code dir="ltr">SYNONYM</code></p>
</li>
<li>
<p><code dir="ltr">VIEW</code></p>
</li>
<li>
<p>All PL/SQL object types:</p>
<ul>
<li>
<p><code dir="ltr">FUNCTION</code></p>
</li>
<li>
<p><code dir="ltr">LIBRARY</code></p>
</li>
<li>
<p><code dir="ltr">PACKAGE</code> and <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code></p>
</li>
<li>
<p><code dir="ltr">PROCEDURE</code></p>
</li>
<li>
<p><code dir="ltr">TRIGGER</code></p>
</li>
<li>
<p><code dir="ltr">TYPE</code> and <code dir="ltr">TYPE</code> <code dir="ltr">BODY</code></p>
</li>
</ul>
</li>
</ul>
<p>All other schema object types are <a id="sthref1171"></a><a id="sthref1172"></a><span class="bold">noneditionable</span>. Table is an example of an noneditionable type.</p>
<p>A schema object of an editionable type is editioned if its owner is editions-enabled; otherwise, it is <span class="bold">potentially editioned</span>.</p>
<p>A schema object of a noneditionable type is always noneditioned, even if its owner is editions-enabled. A table is an example of an noneditioned object.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is one exception to the rules: Although <code dir="ltr">SYNONYM</code> is an editionable type, a public synonym is a noneditioned object.</div>
</div>
<!-- class="sect3" -->
<a id="BABBCBDC"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Rules for Editioned Objects</h4>
<ul>
<li>
<p>A noneditioned object cannot depend on an editioned object.</p>
<p>For example:</p>
<ul>
<li>
<p>A public <a id="sthref1173"></a>synonym cannot refer to an editioned object.</p>
</li>
<li>
<p>A <a id="sthref1174"></a>function-based index cannot depend on an editioned function.</p>
</li>
<li>
<p>A materialized view cannot depend on an <a id="sthref1175"></a>editioned view.</p>
</li>
<li>
<p>A table cannot have a column of a user-defined data type (<a id="sthref1176"></a>collection or <a id="sthref1177"></a><a id="sthref1178"></a>Abstract Data Type (ADT)) whose owner is editions-enabled.</p>
</li>
<li>
<p>A noneditioned <a id="sthref1179"></a>subprogram cannot have a static reference to a subprogram whose owner is editions-enabled.</p>
</li>
</ul>
<p>For the reason for this rule, see <a href="#BABGGBID">"Actualizing Referenced Objects"</a>.</p>
</li>
<li>
<p>An ADT cannot be both editioned and evolved.</p>
<p>For information about type evolution, see <a class="olink ADOBJ00603" href="../../appdev.112/e11822/adobjadv.htm#ADOBJ00603"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a>.</p>
</li>
<li>
<p>An editioned object cannot be the starting or ending point of a <a id="sthref1180"></a><code dir="ltr">FOREIGN</code> <code dir="ltr">KEY</code> constraint.</p>
<p>The only editioned object that this rule affects is an editioned <a id="sthref1181"></a>view. An editioned view can be either an ordinary view or an editioning view.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="g5086786"></a>
<div id="ADFNS99878" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Enabling Editions for a User</h4>
<p><a id="sthref1182"></a><a id="sthref1183"></a><a id="sthref1184"></a>To enable editions for a user, use the <code dir="ltr">ENABLE</code> <code dir="ltr">EDITIONS</code> clause of either the <code dir="ltr">CREATE</code> <code dir="ltr">USER</code> or <code dir="ltr">ALTER</code> <code dir="ltr">USER</code> statement.</p>
<p>The <code dir="ltr">EDITIONS_ENABLED</code> column of the static data dictionary view <code dir="ltr">DBA_USERS</code> or <code dir="ltr">USER_USERS</code> shows which users have editions enabled.</p>
<p>Enabling editions is retroactive and irreversible. When a user is editions-enabled, every editionable-type object that the user has owned or will own is an editioned object. You cannot enable editions for a user who owns a potentially editioned object with noneditioned dependents unless you specify <a id="sthref1185"></a><code dir="ltr">FORCE</code>:</p>
<pre dir="ltr">
ALTER USER <span class="italic">user_name</span> ENABLE EDITIONS <span class="bold">FORCE</span>;
</pre>
<p><code dir="ltr">FORCE</code> is useful in the following situation: You must editions-enable users <code dir="ltr">A</code> and <code dir="ltr">B</code>. User <code dir="ltr">A</code> owns potentially editioned objects <code dir="ltr">a1</code> and <code dir="ltr">a2</code>. User <code dir="ltr">B</code> owns potentially editioned objects <code dir="ltr">b1</code> and <code dir="ltr">b2</code>. Object <code dir="ltr">a1</code> depends on object <code dir="ltr">b1</code>. Object <code dir="ltr">b2</code> depends on object <code dir="ltr">a2</code>. Editions-enable users <code dir="ltr">A</code> and <code dir="ltr">B</code> like this:</p>
<ol>
<li>
<p>Using <code dir="ltr">FORCE</code>, enable editions for user <code dir="ltr">A</code>:</p>
<pre dir="ltr">
ALTER USER A ENABLE EDITIONS FORCE;
</pre>
<p>Now <code dir="ltr">a1</code> and <code dir="ltr">a2</code> are editioned objects, and <code dir="ltr">b2</code> (which depends on <code dir="ltr">a2</code>) is invalid.</p>
</li>
<li>
<p>Enable editions for user <code dir="ltr">B</code>:</p>
<pre dir="ltr">
ALTER USER B ENABLE EDITIONS;
</pre></li>
<li>
<p>Recompile <code dir="ltr">b2</code>, using the appropriate <code dir="ltr">ALTER</code> statement with <code dir="ltr">COMPILE</code>. For a PL/SQL object, also specify <code dir="ltr">REUSE</code> <code dir="ltr">SETTINGS</code>.</p>
<p>For example, if <code dir="ltr">b2</code> is a procedure, use this statement:</p>
<pre dir="ltr">
ALTER PROCEDURE b2 COMPILE REUSE SETTINGS
</pre>
<p>For information about the <code dir="ltr">ALTER</code> statements for PL/SQL objects, see <a class="olink LNPLS99974" href="../../appdev.112/e25519/sqlstatements.htm#LNPLS99974"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>For information about the <code dir="ltr">ALTER</code> statements for SQL objects, see <a class="olink SQLRF008" href="../../server.112/e41084/statements_1.htm#SQLRF008"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ol>
<p><code dir="ltr">FORCE</code> is unnecessary in the following situation: You must editions-enable user <code dir="ltr">C</code>, who owns potentially editioned object <code dir="ltr">c1</code>. Object <code dir="ltr">c1</code> has dependent <code dir="ltr">d1</code>, a potentially editioned object owned by user <code dir="ltr">D</code>. User <code dir="ltr">D</code> owns no potentially editioned objects that have dependents owned by <code dir="ltr">C</code>. If you editions-enable <code dir="ltr">D</code> first, making <code dir="ltr">d1</code> an editioned object, then you can editions-enable <code dir="ltr">C</code> without violating the rule that a noneditioned object cannot depend on an editioned object.</p>
<p>You cannot enable editions for a user who owns one or more <a id="sthref1186"></a><a id="sthref1187"></a>evolved ADTs. Trying to do so causes error ORA-38820. If an ADT has no table dependents, you can use the <code dir="ltr">ALTER</code> <code dir="ltr">TYPE</code> <code dir="ltr">RESET</code> statement to reset its version to 1, so that it is no longer considered to be evolved. (Resetting the version of an ADT to 1 invalidates its dependents.)</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><span class="italic">Oracle Database SQL Language Reference</span> for the syntax of the <a class="olink SQLRF01503" href="../../server.112/e41084/statements_8003.htm#SQLRF01503"><code dir="ltr">CREATE</code> <code dir="ltr">USER</code></a>and <a class="olink SQLRF01103" href="../../server.112/e41084/statements_4003.htm#SQLRF01103"><code dir="ltr">ALTER</code> <code dir="ltr">USER</code></a> statements</p>
</li>
<li>
<p><a class="olink REFRN20302" href="../../server.112/e40402/statviews_2130.htm#REFRN20302"><span class="italic">Oracle Database Reference</span></a> for more information about the static data dictionary views <code dir="ltr">*_USERS</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGIGIF"></a>
<div id="ADFNS899" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating an Edition</h3>
<p><a id="sthref1188"></a>To create an edition, use the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">EDITION</code>.</p>
<p>You must create the edition as the child of an existing edition. The parent of the first edition created with a <code dir="ltr">CREATE</code> <code dir="ltr">EDITION</code> statement is <a id="sthref1189"></a><a id="sthref1190"></a><code dir="ltr">ora$base</code>. This statement creates the edition <code dir="ltr">e2</code> as the child of <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">
CREATE EDITION e2
</pre>
<p>(<a href="#BABFFCHG">Example 19-1</a> and others use the preceding statement.)</p>
<p>At Oracle Database 11<span class="italic">g</span> Release 2, an edition can have at most one child.</p>
<p>The <a id="sthref1191"></a><a id="sthref1192"></a><span class="bold">descendents</span> of an edition are its child, its child's child, and so on. The <a id="sthref1193"></a><a id="sthref1194"></a><span class="bold">ancestors</span> of an edition are its parent, its parent's parent, and so on. The <a id="sthref1195"></a><a id="sthref1196"></a><span class="bold">root edition</span> has no parent, and a <a id="sthref1197"></a><a id="sthref1198"></a><span class="bold">leaf edition</span> has no child.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF20017" href="../../server.112/e41084/statements_5009.htm#SQLRF20017"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CREATE</code> <code dir="ltr">EDITION</code> statement, including the privileges required to use it</div>
</div>
<!-- class="sect2" -->
<a id="CHDEDBFB"></a>
<div id="ADFNS99922" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Inherited and Actual Objects</h3>
<p>Each database session uses exactly one edition at a time. Upon creation, a child edition inherits from its parent edition all editioned objects in the database that are visible in the parent edition. Each <a id="sthref1199"></a><a id="sthref1200"></a><span class="bold">inherited object</span> is visible in the child edition.</p>
<p>An inherited object is <span class="bold">copied on change</span><a id="sthref1201"></a> or <a id="sthref1202"></a><span class="bold">actualized</span>; that is, when a user of the child edition references an inherited object in a DDL statement (other than <code dir="ltr">DROP</code>), the inherited object is copied and the DDL statement affects only the copy&mdash;the <a id="sthref1203"></a><a id="sthref1204"></a><span class="bold">actual object</span>. The unchanged object in the parent edition is no longer visible in the child edition.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When the DDL statement <a id="sthref1205"></a><code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr"><span class="codeinlineitalic">object</span></code> has no effect, it does not actualize <code dir="ltr"><span class="codeinlineitalic">object</span></code> (for details, see <a href="adfns_dependencies.htm#CHDJIIFC">"Invalidation of Dependent Objects"</a>). The DDL statement <code dir="ltr">ALTER</code> <code dir="ltr"><span class="codeinlineitalic">object</span></code> <code dir="ltr">COMPILE</code> always actualizes <code dir="ltr"><span class="codeinlineitalic">object</span></code>.</div>
<p><a href="#BABFFCHG">Example 19-1</a> creates a procedure named <code dir="ltr">hello</code> in the edition <code dir="ltr">ora$base</code>, and then creates the edition <code dir="ltr">e2</code> as a child of <code dir="ltr">ora$base</code>. When <code dir="ltr">e2</code> invokes <code dir="ltr">hello</code>, it invokes the inherited procedure. Then <code dir="ltr">e2</code> changes <code dir="ltr">hello</code>, actualizing it. The procedure <code dir="ltr">hello</code> in the edition <code dir="ltr">ora$base</code> remains unchanged, and is no longer visible in <code dir="ltr">e2</code>. Now when <code dir="ltr">e2</code> invokes <code dir="ltr">hello</code>, it invokes the actual procedure.</p>
<div id="ADFNS900" class="example">
<p class="titleinexample"><a id="BABFFCHG"></a>Example 19-1 Inherited and Actual Objects</p>
<ol>
<li>
<p>Create procedure in parent edition:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE hello IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello, edition 1.');
  END hello;
/
</pre></li>
<li>
<p>Invoke procedure in parent edition:</p>
<pre dir="ltr">
BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Hello, edition 1.</span>
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Create child edition:</p>
<pre dir="ltr">
CREATE EDITION e2;
</pre></li>
<li>
<p>Use child edition:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = e2;
</pre>
<p>For information about <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code>, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li>
<p>In child edition, invoke procedure:</p>
<pre dir="ltr">
BEGIN hello(); END;
/
</pre>
<p>Child edition inherits procedure from parent edition. Child edition invokes inherited procedure. Result:</p>
<pre dir="ltr">
<span class="bold">Hello, edition 1.</span>
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Change procedure in child edition:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE hello IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Hello, edition <span class="bold">2</span>.');
  END hello;
/
</pre>
<p>Child changes only its own copy of procedure. Child's copy is an actual object.</p>
</li>
<li>
<p>Invoke procedure:</p>
<pre dir="ltr">
BEGIN hello(); END;
/
</pre>
<p>Child invokes its own copy, the actual procedure:</p>
<pre dir="ltr">
<span class="bold">Hello, edition 2.</span>

PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Return to parent:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = ora$base;
</pre></li>
<li>
<p>Invoke procedure and see that it has not changed:</p>
<pre dir="ltr">
BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Hello, edition 1.</span>
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p class="subhead2"><a id="sthref1206"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABEJIHB">Dropping Inherited Objects</a></p>
</li>
<li>
<p><a href="#BABGGBID">Actualizing Referenced Objects</a></p>
</li>
</ul>
<a id="BABEJIHB"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Dropping Inherited Objects</h4>
<p>If a user of the child edition drops an <a id="sthref1207"></a><a id="sthref1208"></a>inherited object, that object is no longer visible in the child edition, but it continues to be visible in the parent edition.</p>
<p><a href="#BABHACJF">Example 19-2</a> creates a procedure named <code dir="ltr">goodbye</code> in the edition <code dir="ltr">ora$base</code>, and then creates edition <code dir="ltr">e2</code> as a child of <code dir="ltr">ora$base</code>. After <code dir="ltr">e2</code> drops <code dir="ltr">goodbye</code>, it can no longer invoke it, but <code dir="ltr">ora$base</code> can still invoke it. (For more information about the <code dir="ltr">DROP</code> <code dir="ltr">PROCEDURE</code> statement, including the privileges required to use it, see <a class="olink LNPLS99991" href="../../appdev.112/e25519/drop_procedure.htm#LNPLS99991"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.)</p>
<div id="ADFNS901" class="example">
<p class="titleinexample"><a id="BABHACJF"></a>Example 19-2 Dropping an Inherited Object</p>
<ol>
<li>
<p>Create procedure in edition <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE goodbye IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Good-bye!');
  END goodbye;
/
</pre></li>
<li>
<p>Invoke procedure:</p>
<pre dir="ltr">
BEGIN goodbye; END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Create edition <code dir="ltr">e2</code> as a child of <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">
CREATE EDITION e2;
</pre></li>
<li>
<p>Use edition <code dir="ltr">e2</code>:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = e2;
</pre>
<p><code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code> must be a top-level SQL statement. For more information, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li>
<p>In <code dir="ltr">e2</code>, invoke procedure:</p>
<pre dir="ltr">
BEGIN goodbye; END;
/
</pre>
<p><code dir="ltr">e2</code> invokes inherited procedure:</p>
<pre dir="ltr">
Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>In <code dir="ltr">e2</code>, drop procedure:</p>
<pre dir="ltr">
DROP PROCEDURE goodbye;
</pre></li>
<li>
<p>In <code dir="ltr">e2</code>, try to invoke dropped procedure:</p>
<pre dir="ltr">
BEGIN goodbye; END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
BEGIN goodbye; END;
      *
ERROR at line 1:
ORA-06550: line 1, column 7:
PLS-00201: identifier 'GOODBYE' must be declared
ORA-06550: line 1, column 7:
PL/SQL: Statement ignored
</pre></li>
<li>
<p>Return to parent:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = ora$base;
</pre></li>
<li>
<p>In parent, invoke procedure:</p>
<pre dir="ltr">
BEGIN goodbye; END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>Because <code dir="ltr">e2</code> dropped the procedure <code dir="ltr">goodbye</code>:</p>
<ul>
<li>
<p>Its descendents do not inherit the procedure <code dir="ltr">goodbye</code>.</p>
</li>
<li>
<p>No object named <code dir="ltr">goodbye</code> is visible in <code dir="ltr">e2</code>, so <code dir="ltr">e2</code> can create an object named <code dir="ltr">goodbye</code> of any editionable type. If <code dir="ltr">e2</code> creates this object, the descendents of <code dir="ltr">e2</code> inherit that object.</p>
</li>
</ul>
<p>In <a href="#BABEADAA">Example 19-3</a>, <code dir="ltr">e2</code> creates a function named <code dir="ltr">goodbye</code> and then an edition named <code dir="ltr">e3</code> as a child of <code dir="ltr">e2</code>. When <code dir="ltr">e3</code> tries to invoke the <span class="italic">procedure</span> <code dir="ltr">goodbye</code> (which <code dir="ltr">e2</code> dropped), an error occurs, but <code dir="ltr">e3</code> successfully invokes the <span class="italic">function</span> <code dir="ltr">goodbye</code> (which <code dir="ltr">e2</code> created).</p>
<div id="ADFNS902" class="example">
<p class="titleinexample"><a id="BABEADAA"></a>Example 19-3 Creating an Object with the Name of a Dropped Inherited Object</p>
<ol>
<li>
<p>Return to <code dir="ltr">e2</code>:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = e2;
</pre>
<p>For information about <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code>, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li>
<p>In <code dir="ltr">e2</code>, create function named <code dir="ltr">goodbye</code>:</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION goodbye
  RETURN BOOLEAN
IS
BEGIN
  RETURN(TRUE);
END goodbye;
/
</pre></li>
<li>
<p>Create edition <code dir="ltr">e3</code>:</p>
<pre dir="ltr">
CREATE EDITION e3 AS CHILD OF e2;
</pre></li>
<li>
<p>Use edition <code dir="ltr">e3</code>:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = e3;
</pre></li>
<li>
<p>In <code dir="ltr">e3</code>, try to invoke <span class="italic">procedure</span> <code dir="ltr">goodbye</code>:</p>
<pre dir="ltr">
BEGIN
  goodbye;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
  goodbye;
  *
ERROR at line 2:
ORA-06550: line 2, column 3:
PLS-00221: 'GOODBYE' is not a procedure or is undefined
ORA-06550: line 2, column 3:
PL/SQL: Statement ignored
</pre></li>
<li>
<p>In <code dir="ltr">e3</code>, invoke <span class="italic">function</span> <code dir="ltr">goodbye</code>:</p>
<pre dir="ltr">
BEGIN
  IF goodbye THEN
    DBMS_OUTPUT.PUT_LINE('Good-bye!');
  END IF;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Good-bye!
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABGGBID"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Actualizing Referenced Objects</h4>
<p>When a referenced object is <a id="sthref1209"></a><a id="sthref1210"></a>actualized in an edition, all of its dependents (direct and indirect) that are not yet actualized in that edition become actualized in that edition in an invalid state. Therefore, an editioned object cannot have dependents that cannot be actualized. In other words, a noneditioned object cannot depend on an editioned object (for examples, see <a href="#BABBCBDC">"Rules for Editioned Objects"</a>).</p>
<p>When an invalid object is referenced, the database automatically validates it, which requires <a id="sthref1211"></a>name resolution. The database looks for the object name first in the current edition, then in the parent edition, and so on.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adfns_dependencies.htm#CHDFADFI">Chapter 18, "Schema Object Dependency,"</a> for general information about dependencies among schema objects, including invalidation, revalidation, and name resolution</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABJFDCH"></a>
<div id="ADFNS903" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a class="olink ADFNS99877" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ADFNS99877">Making an Edition Available to Some Users</a></h3>
<p><a id="sthref1212"></a>As the creator of the edition, you automatically have the <code dir="ltr">USE</code> privilege <code dir="ltr">WITH</code> <code dir="ltr">GRANT</code> <code dir="ltr">OPTION</code> on it. To grant the <code dir="ltr">USE</code> privilege on the edition to other users, use the SQL statement <code dir="ltr">GRANT</code> <code dir="ltr">USE</code> <code dir="ltr">ON</code> <code dir="ltr">EDITION</code>. For information about the <code dir="ltr">GRANT</code> statement, see <a class="olink SQLRF01603" href="../../server.112/e41084/statements_9013.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABJFDDG"></a>
<div id="ADFNS99876" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Making an Edition Available to All Users</h3>
<p><a id="sthref1213"></a>To make an edition available to all users, either:</p>
<ul>
<li>
<p>Grant the <code dir="ltr">USE</code> privilege on the edition to <code dir="ltr">PUBLIC</code>:</p>
<pre dir="ltr">
GRANT USE ON EDITION <span class="italic">edition_name</span> TO PUBLIC
</pre>
<p>For information about the <code dir="ltr">GRANT</code> statement, see <a class="olink SQLRF01603" href="../../server.112/e41084/statements_9013.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Make the edition the database default edition:</p>
<pre dir="ltr">
ALTER DATABASE DEFAULT EDITION = <span class="italic">edition_name</span>
</pre>
<p>This has the side effect of granting the <code dir="ltr">USE</code> privilege on <code dir="ltr"><span class="codeinlineitalic">edition_name</span></code> to <code dir="ltr">PUBLIC</code>.</p>
<p>For information about the <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code> statement, see <a class="olink SQLRF00802" href="../../server.112/e41084/statements_1004.htm#SQLRF00802"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFGIAA"></a>
<div id="ADFNS99921" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Current Edition and Session Edition</h3>
<p><a id="sthref1214"></a><a id="sthref1215"></a><a id="sthref1216"></a><a id="sthref1217"></a>Each database session uses exactly one edition at a time. The edition that a database session is using at any one time is called its <span class="bold">current edition</span>. When a database session begins, its current edition is its <span class="bold">session edition</span>, which is the edition in which it begins. If you change the session edition, the current edition changes to the same thing. However, there are situations in which the current edition and session edition differ.</p>
<p class="subhead2"><a id="sthref1218"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDECHDA">Your Initial Session Edition</a></p>
</li>
<li>
<p><a href="#CHDBFJGF">Changing Your Session Edition</a></p>
</li>
<li>
<p><a href="#CHDCBIJG">Displaying the Names of the Current and Session Editions</a></p>
</li>
<li>
<p><a href="#CHDGIDBB">When the Current Edition Might Differ from the Session Edition</a></p>
</li>
</ul>
<a id="CHDECHDA"></a>
<div id="ADFNS904" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Your Initial Session Edition</h4>
<p>When you connect to the database, you can specify your initial session edition. Your initial session edition can be any edition on which you have the <code dir="ltr">USE</code> privilege. To see the names of the editions that are available to you, use this query:</p>
<pre dir="ltr">
SELECT EDITION_NAME FROM ALL_EDITIONS;
</pre>
<p>How you specify your initial session edition at connection time depends on how you connect to the database&mdash;see the documentation for your interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN13170" href="../../server.112/e25494/general.htm#ADMIN13170"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about setting the database default edition</p>
</li>
<li>
<p><a class="olink SQPUG013" href="../../server.112/e16604/ch_three.htm#SQPUG013"><span class="italic">SQL*Plus User's Guide and Reference</span></a> for information about connecting to the database with SQL*Plus</p>
</li>
<li>
<p><a class="olink LNOCI08100" href="../../appdev.112/e10646/oci08sca.htm#LNOCI08100"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for information about connecting to the database with Oracle Call Interface (OCI)</p>
</li>
<li>
<p><a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> for information about connecting to the database with JDBC</p>
</li>
</ul>
</div>
<p>As of Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), if you do not specify your session edition at connection time, then:</p>
<ul>
<li>
<p>If you use a database service to connect to the database, and an initial session edition was specified for that service, then the initial session edition for the service is your initial session edition.</p>
</li>
<li>
<p>Otherwise, your initial session edition is the database default edition.</p>
</li>
</ul>
<p>As of Release 11.2.0.2, when you create or modify a database service, you can specify its initial session edition.</p>
<p>To create or modify a database service, Oracle recommends using the <code dir="ltr">srvctl</code> <code dir="ltr">add</code> <code dir="ltr">service</code> or <code dir="ltr">srvctl</code> <code dir="ltr">modify</code> <code dir="ltr">service</code> command. To specify the default initial session edition of the service, use the <code dir="ltr">-t</code> option.</p>
<p>Alternatively, you can create or modify a database service with the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">CREATE_SERVICE</code> or <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">MODIFY_SERVICE</code> procedure, and specify the default initial session edition of the service with the <code dir="ltr">EDITION</code> attribute.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As of Oracle Database 11<span class="italic">g</span> Release 2, the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">CREATE_SERVICE</code> and <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">MODIFY_SERVICE</code> procedures are deprecated in databases managed by Oracle Clusterware and Oracle Restart.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN12956" href="../../server.112/e25494/restart.htm#ADMIN12956"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about the <code dir="ltr">-t</code> option of the <code dir="ltr">srvctl</code> <code dir="ltr">add</code> <code dir="ltr">service</code> command</p>
</li>
<li>
<p><a class="olink ADMIN12980" href="../../server.112/e25494/restart.htm#ADMIN12980"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about the <code dir="ltr">-t</code> option of the <code dir="ltr">srvctl</code> <code dir="ltr">modify</code> <code dir="ltr">service</code> command</p>
</li>
<li>
<p><a class="olink ARPLS68021" href="../../appdev.112/e40758/d_serv.htm#ARPLS68021"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code dir="ltr">EDITION</code> attribute of the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">CREATE_SERVICE</code> procedure</p>
</li>
<li>
<p><a class="olink ARPLS68027" href="../../appdev.112/e40758/d_serv.htm#ARPLS68027"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code dir="ltr">EDITION</code> attribute of the <code dir="ltr">DBMS_SERVICE</code>.<code dir="ltr">MODIFY_SERVICE</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDBFJGF"></a>
<div id="ADFNS905" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Changing Your Session Edition</h4>
<p>After connecting to the database, you can change your session edition with the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code>. You can change your session edition to any edition on which you have the <code dir="ltr">USE</code> privilege. When you change your session edition, your current edition changes to the same thing.</p>
<p>These statements from <a href="#BABFFCHG">Example 19-1</a> and <a href="#BABHACJF">Example 19-2</a> change the session edition (and current edition) first to <code dir="ltr">e2</code> and later to <code dir="ltr">ora$base</code>:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = e2
...
ALTER SESSION SET EDITION = ora$base
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code> must be a top-level SQL statement. To defer an edition change (in a logon trigger, for example), use the <code dir="ltr">DBMS_SESSION</code>.<code dir="ltr">SET_EDITION_DEFERRED</code> procedure.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF00901" href="../../server.112/e41084/statements_2013.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">SET</code> <code dir="ltr">EDITION</code> statement</p>
</li>
<li>
<p><a class="olink ARPLS72968" href="../../appdev.112/e40758/d_sessio.htm#ARPLS72968"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_SESSION</code>.<code dir="ltr">SET_EDITION_DEFERRED</code> procedure</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDCBIJG"></a>
<div id="ADFNS906" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Displaying the Names of the Current and Session Editions</h4>
<p>This statement returns the name of the current edition:</p>
<pre dir="ltr">
SELECT SYS_CONTEXT('USERENV', 'CURRENT_EDITION_NAME') FROM DUAL;
</pre>
<p>This statement returns the name of the session edition:</p>
<pre dir="ltr">
SELECT SYS_CONTEXT('USERENV', 'SESSION_EDITION_NAME') FROM DUAL;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF06117" href="../../server.112/e41084/functions184.htm#SQLRF06117"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">SYS_CONTEXT</code> function</div>
</div>
<!-- class="sect3" -->
<a id="CHDGIDBB"></a>
<div id="ADFNS907" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">When the Current Edition Might Differ from the Session Edition</h4>
<p>The current edition might differ from the session edition in these situations:</p>
<ul>
<li>
<p>A crossedition trigger fires.</p>
<p>For details, see <a href="#CHDFBHBI">"Crossedition Trigger Interaction with Editions"</a>.</p>
</li>
<li>
<p>You run a statement by calling the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure, specifying the edition in which the statement is to run, as in <a href="#CHDBCBEF">Example 19-4</a>.</p>
<p>While the statement is running, the current edition is the specified edition, but the session edition does not change. For information about the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure, see <a class="olink ARPLS68277" href="../../appdev.112/e40758/d_sql.htm#ARPLS68277"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ul>
<p><a href="#CHDBCBEF">Example 19-4</a> creates a function that returns the names of the session edition and current edition. Then it creates a child edition, which invokes the function twice. The first time, the session edition and current edition are the same. The second time, they are not, because a different edition is passed as a parameter to the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure.</p>
<div id="ADFNS908" class="example">
<p class="titleinexample"><a id="CHDBCBEF"></a>Example 19-4 Current Edition Differs from Session Edition</p>
<ol>
<li>
<p>Create function that returns the names of the session edition and current edition:</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION session_and_current_editions
  RETURN VARCHAR2
IS
BEGIN
  RETURN
  'Session: '|| SYS_CONTEXT('USERENV', 'SESSION_EDITION_NAME') ||
  ' / ' ||
  'Current: '|| SYS_CONTEXT('USERENV', 'CURRENT_EDITION_NAME');
END session_and_current_editions;
/
</pre></li>
<li>
<p>Create child edition:</p>
<pre dir="ltr">
CREATE EDITION e2 AS CHILD OF ora$base;
</pre></li>
<li>
<p>Use child edition:</p>
<pre dir="ltr">
<span class="bold">ALTER SESSION SET EDITION = e2;</span>
</pre></li>
<li>
<p>Invoke function:</p>
<pre dir="ltr">
BEGIN
  DBMS_OUTPUT.PUT_LINE (session_and_current_editions());
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Session: E2 / Current: E2</span>
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Invoke function again:</p>
<pre dir="ltr">
DECLARE
  c     NUMBER := DBMS_SQL.OPEN_CURSOR();
  v     VARCHAR2(200);
  dummy NUMBER;
  <span class="bold">stmt  CONSTANT VARCHAR2(32767)</span>
    <span class="bold">:= 'SELECT session_and_current_editions() FROM DUAL';</span>
BEGIN
  <span class="bold">DBMS_SQL.PARSE</span> (c =&gt; c,
                  <span class="bold">statement =&gt; stmt</span>,
                  language_flag =&gt; DBMS_SQL.NATIVE,
                  <span class="bold">edition =&gt; 'ora$base'</span>);
 
  DBMS_SQL.DEFINE_COLUMN (c, 1, v, 200);
  dummy := DBMS_SQL.EXECUTE_AND_FETCH (c, true);
  DBMS_SQL.COLUMN_VALUE (c, 1, v);
  DBMS_SQL.CLOSE_CURSOR(c);
  DBMS_OUTPUT.PUT_LINE (v);
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Session: E2 / Current: ORA$BASE</span>
 
PL/SQL procedure successfully completed.
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEEIBA"></a>
<div id="ADFNS99920" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Retiring an Edition</h3>
<p><a id="sthref1219"></a>After making a new edition (an upgraded application) available to all users, you want to retire the old edition (the original application), so that no user except <code dir="ltr">SYS</code> can use the retired edition.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the old edition is the database default edition, make another edition the database default edition before you retire the old edition:
<pre dir="ltr">
ALTER DATABASE DEFAULT EDITION = <span class="italic">edition_name</span>
</pre>
<p>For information about the <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code> statement, see <a class="olink SQLRF00802" href="../../server.112/e41084/statements_1004.htm#SQLRF00802"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<p>To retire an edition, you must revoke the <code dir="ltr">USE</code> privilege on the edition from every grantee. To list the grantees, use this query, where :<code dir="ltr">e</code> is a placeholder for the name of the edition to be dropped:</p>
<pre dir="ltr">
SELECT GRANTEE, PRIVILEGE
FROM DBA_TAB_PRIVS
WHERE TABLE_NAME = :e
/
</pre>
<p>For information about the <code dir="ltr">REVOKE</code> statement, see <a class="olink SQLRF01609" href="../../server.112/e41084/statements_9020.htm#SQLRF01609"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJCDCA"></a>
<div id="ADFNS99919" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Dropping an Edition</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the edition includes crossedition triggers, see <a href="#BABGHBBF">"Dropping the Crossedition Triggers"</a> before you drop the edition.</div>
<p>To drop an edition, use the <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> statement, described in <a class="olink SQLRF20019" href="../../server.112/e41084/statements_8014.htm#SQLRF20019"><span class="italic">Oracle Database SQL Language Reference</span></a>. If the edition has actual objects, you must specify the <code dir="ltr">CASCADE</code> clause, which drops the actual objects.</p>
<p>If a <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> <code dir="ltr"><span class="codeinlineitalic">edition</span></code> <code dir="ltr">CASCADE</code> statement is interrupted before finishing normally (from a power failure, for example), the static data dictionary view <code dir="ltr">*_EDITIONS</code> shows that the value of <code dir="ltr">USABLE</code> for <code dir="ltr"><span class="codeinlineitalic">edition</span></code> is <code dir="ltr">NO</code>. The only operation that you can perform on such an unusable <code dir="ltr"><span class="codeinlineitalic">edition</span></code> is <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> <code dir="ltr">CASCADE</code>.</p>
<p>You drop an edition in these situations:</p>
<ul>
<li>
<p>You want to roll back the application upgrade.</p>
</li>
<li>
<p>(Optional) You have retired the edition.</p>
</li>
</ul>
<p>You can drop an edition only if all of these statements are true:</p>
<ul>
<li>
<p>The edition is either the root edition or a leaf edition.</p>
</li>
<li>
<p>If the edition is the root, it has no objects that its descendents inherit. (That is, each object inherited from the root edition was either actualized or dropped.)</p>
</li>
<li>
<p>The edition is not in use (that is, it is not the current edition or session edition of a session).</p>
</li>
<li>
<p>The edition is not the database default edition.</p>
</li>
</ul>
<p>To explicitly actualize an inherited object in the child edition:</p>
<ol>
<li>
<p>Make the child edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li>
<p>Recompile the object, using the appropriate <code dir="ltr">ALTER</code> statement with <code dir="ltr">COMPILE</code>. For a PL/SQL object, also specify <code dir="ltr">REUSE</code> <code dir="ltr">SETTINGS</code>.</p>
<p>For example, this statement actualizes the procedure <code dir="ltr">p1</code>:</p>
<pre dir="ltr">
ALTER PROCEDURE p1 COMPILE REUSE SETTINGS
</pre>
<p>For information about the <code dir="ltr">ALTER</code> statements for PL/SQL objects, see <a class="olink LNPLS99974" href="../../appdev.112/e25519/sqlstatements.htm#LNPLS99974"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>For information about the <code dir="ltr">ALTER</code> statements for SQL objects, see <a class="olink SQLRF008" href="../../server.112/e41084/statements_1.htm#SQLRF008"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF00818" href="../../server.112/e41084/statements_2001.htm#SQLRF00818"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">LIBRARY</code> statement</p>
</li>
<li>
<p><a class="olink SQLRF01104" href="../../server.112/e41084/statements_4004.htm#SQLRF01104"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99999" href="../../appdev.112/e25519/alter_function.htm#LNPLS99999"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">FUNCTION</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99998" href="../../appdev.112/e25519/alter_package.htm#LNPLS99998"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">PACKAGE</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99997" href="../../appdev.112/e25519/alter_procedure.htm#LNPLS99997"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">PROCEDURE</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99996" href="../../appdev.112/e25519/alter_trigger.htm#LNPLS99996"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS99995" href="../../appdev.112/e25519/alter_type.htm#LNPLS99995"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">TYPE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJEECI"></a>
<div id="ADFNS0202" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Editioning Views</h2>
<p>The owner of an <a id="sthref1220"></a>editioning view must be editions-enabled before the editioning view is created.</p>
<p>On a noneditioning view, the only type of trigger that you can define is an <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> trigger. On an editioning view, you can define every type of trigger that you can define on a table (except crossedition triggers, which are temporary, and <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers). Therefore, and because they can be editioned, editioning views let you treat their base tables as if the base tables were editioned. However, you cannot add indexes or constraints to an editioning view; if your upgraded application requires new indexes or constraints, you must add them to the base table.</p>
<p>An editioning view selects a subset of the columns from a single base table and, optionally, provides aliases for them. In providing aliases, the editioning view maps physical column names (used by the base table) to logical column names (used by the application). An editioning view is like an API for a table.</p>
<p>There is no performance penalty for accessing a table through an editioning view, rather than directly. That is, if a SQL <code dir="ltr">SELECT</code>, <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, or <code dir="ltr">MERGE</code> statement uses one or more editioning views, one or more times, and you replace each editioning view name with the name of its base table and adjust the column names if necessary, performance does not change.</p>
<p>The static data dictionary view <code dir="ltr">*_EDITIONING_VIEWS</code> describes every editioning view in the database that is visible (actual or inherited) in the session edition. <code dir="ltr">*_EDITIONING_VIEWS_AE</code> describes every actual object in every editioning view in the database, in every edition.</p>
<p class="subhead2"><a id="sthref1221"></a>Topics:</p>
<ul>
<li>
<p><a href="#CHDHIDGF">Creating an Editioning View</a></p>
</li>
<li>
<p><a href="#CHDEGDGI">Partition-Extended Editioning View Names</a></p>
</li>
<li>
<p><a href="#CHDFDBDE">Changing the 'Write-ability' of an Editioning View</a></p>
</li>
<li>
<p><a href="#CHDIAEIE">Replacing an Editioning View</a></p>
</li>
<li>
<p><a href="#CHDCABBF">Dropping or Renaming the Base Table</a></p>
</li>
<li>
<p><a href="#BABIECFF">Adding Indexes and Constraints to the Base Table</a></p>
</li>
<li>
<p><a href="#CHDBHHEC">SQL Optimizer Index Hints</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic">Oracle Database Reference</span> for more information about the static data dictionary views <a class="olink REFRN20668" href="../../server.112/e40402/statviews_1082.htm#REFRN20668"><code dir="ltr">*_EDITIONING_VIEWS</code></a> and <a class="olink REFRN20683" href="../../server.112/e40402/statviews_1081.htm#REFRN20683"><code dir="ltr">*_EDITIONING_VIEWS_AE</code></a>.</div>
<a id="CHDHIDGF"></a>
<div id="ADFNS99916" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating an Editioning View</h3>
<p><a id="sthref1222"></a>To create an editioning view, use the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> with the keyword <code dir="ltr">EDITIONING</code>. To make the editioning view read-only, specify <code dir="ltr">WITH</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>; to make it read-write, omit <code dir="ltr">WITH</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>.</p>
<p>If an editioning view is <a id="sthref1223"></a><a id="sthref1224"></a><span class="bold">read-only</span>, users of the unchanged application can see the data in the base table, but cannot change it. The base table has <a id="sthref1225"></a><a id="sthref1226"></a><span class="bold">semi-availability</span>. Semi-availability is acceptable for applications such as online dictionaries, which users read but do not change. Make the editioning view read-only if you do not define <a id="sthref1227"></a>crossedition triggers on the base table.</p>
<p>If an editioning view is <a id="sthref1228"></a><a id="sthref1229"></a><span class="bold">read-write</span>, users of the unchanged application can both see and change the data in the base table. The base table has <a id="sthref1230"></a><a id="sthref1231"></a><span class="bold">maximum availability</span>. Maximum availability is required for applications such as online stores, where users submit purchase orders. If you define <a id="sthref1232"></a>crossedition triggers on the base table, make the editioning view read-write.</p>
<p>Because an editioning view must do no more than select a subset of the columns from the base table and provide aliases for them, the <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> statement that creates an editioning view has restrictions. Violating the restrictions causes the creation of the view to fail, even if you specify <code dir="ltr">FORCE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01504" href="../../server.112/e41084/statements_8004.htm#SQLRF01504"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about using the <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> statement to create editioning views, including the restrictions</div>
</div>
<!-- class="sect2" -->
<a id="CHDEGDGI"></a>
<div id="ADFNS913" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Partition-Extended Editioning View Names</h3>
<p><a id="sthref1233"></a><a id="sthref1234"></a>An editioning view defined on a partitioned table can have a partition-extended name, with partition and subpartition names that refer to the partitions and subpartitions of the base table.</p>
<p>The data manipulation language (DML) statements that support partition-extended table names also support partition-extended editioning view names. These statements are:</p>
<ul>
<li>
<p><code dir="ltr">DELETE</code></p>
</li>
<li>
<p><code dir="ltr">INSERT</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code></p>
</li>
<li>
<p><code dir="ltr">UPDATE</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00223" href="../../server.112/e41084/sql_elements008.htm#SQLRF00223"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about referring to partitioned tables</div>
</div>
<!-- class="sect2" -->
<a id="CHDFDBDE"></a>
<div id="ADFNS99915" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Changing the 'Write-ability' of an Editioning View</h3>
<p><a id="sthref1235"></a><a id="sthref1236"></a>To change an existing editioning view from read-only to read-write, use the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> <code dir="ltr">READ</code> <code dir="ltr">WRITE</code>. To change an existing editioning view from read-write to read-only, use the SQL statement <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01104" href="../../server.112/e41084/statements_4004.htm#SQLRF01104"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">VIEW</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="CHDIAEIE"></a>
<div id="ADFNS911" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Replacing an Editioning View</h3>
<p><a id="sthref1237"></a>To replace an editioning view, use the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">VIEW</code> with the <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> clause and the keyword <code dir="ltr">EDITIONING</code>.</p>
<p>You can replace an editioning view only with another editioning view. Any triggers defined on the replaced editioning view are retained.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCABBF"></a>
<div id="ADFNS912" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Dropping or Renaming the Base Table</h3>
<p><a id="sthref1238"></a>If you drop or rename the base table on which an editioning view is defined, the editioning view is not dropped, but the editioning view and its dependents become invalid. However, any triggers defined on the editioning view remain.</p>
</div>
<!-- class="sect2" -->
<a id="BABIECFF"></a>
<div id="ADFNS914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Adding Indexes and Constraints to the Base Table</h3>
<p>If your upgraded application requires new <a id="sthref1239"></a>indexes or <a id="sthref1240"></a>constraints, you must add them to the base table. You cannot add them to the editioning view.</p>
<p>If the new indexes might negatively impact the old edition (the original application), make them invisible. In the crossedition triggers that must use the new indexes, specify them in <code dir="ltr">INDEX</code> hints.</p>
<p>When all users are using only the upgraded application:</p>
<ul>
<li>
<p>If the new indexes were used only by the crossedition triggers, drop them.</p>
</li>
<li>
<p>If the new indexes are helpful in the upgraded application, make them visible.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="adfns_indexes.htm#i1007888">"Guidelines for Managing Indexes"</a> for information about when to use indexes</p>
</li>
<li>
<p><a class="olink SQLRF50405" href="../../server.112/e41084/sql_elements006.htm#SQLRF50405"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about <code dir="ltr">INDEX</code> hints</p>
</li>
<li>
<p><a href="#CHDBHHEC">"SQL Optimizer Index Hints"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDBHHEC"></a>
<div id="ADFNS918" class="sect2">
<h3 class="sect2">SQL Optimizer Index Hints</h3>
<p><a id="sthref1241"></a><a id="sthref1242"></a><a id="sthref1243"></a>SQL optimizer index hints are specified in terms of the logical names of the columns participating in the index. Any SQL optimizer index hints specified on an editioning view using logical column names must be mapped to an index on the corresponding physical column in the base table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00219" href="../../server.112/e41084/sql_elements006.htm#SQLRF00219"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about using hints</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJCDFF"></a>
<div id="ADFNS0203" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Crossedition Triggers</h2>
<p><a id="sthref1244"></a>The most important difference between crossedition triggers and noncrossedition triggers is how they interact with editions. A crossedition trigger is visible only in the edition in which it is actual, never in a descendent edition. Forward crossedition triggers move data from columns used by the old edition to columns used by the new edition; reverse crossedition triggers do the reverse.</p>
<p>Other important differences are:</p>
<ul>
<li>
<p>Crossedition triggers can be ordered with triggers defined on other tables, while noncrossedition triggers can be ordered only with other triggers defined on the same table.</p>
</li>
<li>
<p>Crossedition triggers are temporary&mdash;you drop them after you have made the restructured tables available to all users.</p>
</li>
</ul>
<p class="subhead2"><a id="sthref1245"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABHEHAH">Forward Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#BABGHHJB">Reverse Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#CHDFBHBI">Crossedition Trigger Interaction with Editions</a></p>
</li>
<li>
<p><a href="#CHDBJEFC">Creating a Crossedition Trigger</a></p>
</li>
<li>
<p><a href="#CHDGAGCH">Transforming Data from Pre- to Post-Upgrade Representation</a></p>
</li>
<li>
<p><a href="#BABGHBBF">Dropping the Crossedition Triggers</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS020" href="../../appdev.112/e25519/triggers.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for general information about triggers</div>
<a id="BABHEHAH"></a>
<div id="ADFNS99910" class="sect2">
<h3 class="sect2">Forward Crossedition Triggers</h3>
<p><a id="sthref1246"></a><a id="sthref1247"></a>The DML changes that you make to the table in the post-upgrade edition are written only to new columns or new tables, never to columns that users of pre-upgrade (ancestor) editions might be reading or writing. However, if the user of an ancestor edition changes the table data, the editioning view that you see must accurately reflect these changes. This is accomplished with forward crossedition triggers.</p>
<p>A forward crossedition trigger defines a <a id="sthref1248"></a><span class="bold">transform</span>, which is a rule for transforming an old row to one or more new rows. An <span class="bold">old row</span> is a row of data in the pre-upgrade representation. A <span class="bold">new row</span> is a row of data in the post-upgrade representation. The name of the trigger refers to the trigger itself and to the transform that the trigger defines.</p>
</div>
<!-- class="sect2" -->
<a id="BABGHHJB"></a>
<div id="ADFNS99909" class="sect2">
<h3 class="sect2">Reverse Crossedition Triggers</h3>
<p>If the pre- and post-upgrade editions will be in ordinary use at the same time (hot rollover), use <a id="sthref1249"></a><a id="sthref1250"></a>reverse crossedition triggers to ensure that when users of the post-upgrade edition make changes to the table data, the changes are accurately reflected in the pre-upgrade editions.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFBHBI"></a>
<div id="ADFNS99908" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Crossedition Trigger Interaction with Editions</h3>
<p><a id="sthref1251"></a><a id="sthref1252"></a>The most important difference between crossedition triggers and noncrossedition triggers is how they interact with editions.</p>
<p>In this topic, the <span class="bold">current edition</span> is the edition in which the triggering DML statement runs. The current edition might differ from the session edition (for details, see <a href="#CHDGIDBB">"When the Current Edition Might Differ from the Session Edition"</a>).</p>
<ul>
<li>
<p><a href="#CHDDICFE">Which Triggers Are Visible</a></p>
</li>
<li>
<p><a href="#CHDFAEHG">What Kind of Triggers Can Fire</a></p>
</li>
<li>
<p><a href="#CHDCGHCD">Firing Order</a></p>
</li>
<li>
<p><a href="#CHDJGGAB">Crossedition Trigger Execution</a></p>
</li>
</ul>
<a id="CHDDICFE"></a>
<div id="ADFNS921" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Which Triggers Are Visible</h4>
<p><a id="sthref1253"></a><a id="sthref1254"></a>Editions inherit noncrossedition triggers in the same way that they inherit other editioned objects (see <a href="#CHDEDBFB">"Inherited and Actual Objects"</a>).</p>
<p>Editions do not inherit crossedition triggers. A crossedition trigger might fire in response to a DML statement that another edition runs, but its name is visible only in the edition in which it was created. Therefore, an edition can reuse the name of a crossedition trigger created in an ancestor edition. Reusing the name of a crossedition trigger does not change the conditions under which the older trigger fires.</p>
<p>Crossedition triggers that appear in static data dictionary views are actual objects in the current edition.</p>
</div>
<!-- class="sect3" -->
<a id="CHDFAEHG"></a>
<div id="ADFNS922" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">What Kind of Triggers Can Fire</h4>
<p><a id="sthref1255"></a>What kind of triggers can fire depends on the category of the triggering DML statement. The categories are:</p>
<ul>
<li>
<p><a href="#BABIEBCG">"Forward Crossedition Trigger SQL"</a></p>
</li>
<li>
<p><a href="#BABFBFHH">"Reverse Crossedition Trigger SQL"</a></p>
</li>
<li>
<p><a href="#BABFEJAH">"Application SQL"</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">APPEND</code> hint on a SQL <code dir="ltr">INSERT</code> statement does not prevent crossedition triggers from firing. For information about the <code dir="ltr">APPEND</code> hint, see <a class="olink SQLRF50901" href="../../server.112/e41084/sql_elements006.htm#SQLRF50901"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
<a id="BABIEBCG"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Forward Crossedition Trigger SQL</h5>
<p><a id="sthref1256"></a><a id="sthref1257"></a><a id="sthref1258"></a><span class="bold">Forward crossedition trigger SQL</span> is SQL that is executed in either of these ways:</p>
<ul>
<li>
<p>Directly from the body of a forward crossedition trigger</p>
<p>This category includes SQL in an invoked subprogram only if the subprogram is local to the forward crossedition trigger.</p>
</li>
<li>
<p>By invoking the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure with a non-<code dir="ltr">NULL</code> value for the <code dir="ltr">apply_crossedition_trigger</code> parameter</p>
<p>The only valid non-<code dir="ltr">NULL</code> value for the <code dir="ltr">apply_crossedition_trigger</code> parameter is the unqualified name of a forward crossedition trigger. For more information about the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure, see <a class="olink ARPLS058" href="../../appdev.112/e40758/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ul>
<p>If a forward crossedition trigger invokes a subprogram in another compilation unit, the SQL in the subprogram is forward crossedition trigger SQL only if it is invoked by the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure with a non-<code dir="ltr">NULL</code> value for the <code dir="ltr">apply_crossedition_trigger</code> parameter.</p>
<p>Forward crossedition trigger SQL can fire only triggers that satisfy all of these conditions:</p>
<ul>
<li>
<p>They are forward crossedition triggers.</p>
</li>
<li>
<p>They were created either in the current edition or in a descendent of the current edition.</p>
</li>
<li>
<p>They explicitly follow the running forward crossedition trigger.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BABFBFHH"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Reverse Crossedition Trigger SQL</h5>
<p><a id="sthref1259"></a><a id="sthref1260"></a><a id="sthref1261"></a><span class="bold">Reverse crossedition trigger SQL</span> is SQL that is executed directly from the body of a reverse crossedition trigger. This category includes SQL in an invoked subprogram only if the subprogram is local to the reverse crossedition trigger.</p>
<p>Reverse crossedition trigger SQL can fire only triggers that satisfy all of these conditions:</p>
<ul>
<li>
<p>They are reverse crossedition triggers.</p>
</li>
<li>
<p>They were created either in the current edition or in an ancestor of the current edition.</p>
</li>
<li>
<p>They explicitly precede the running reverse crossedition trigger.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="BABFEJAH"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Application SQL</h5>
<p><a id="sthref1262"></a><a id="sthref1263"></a><span class="bold">Application SQL</span> is all SQL except crossedition trigger SQL, including these DML statements:</p>
<ul>
<li>
<p>Dynamic SQL DML statements coded with the <code dir="ltr">DBMS_SQL</code> package (for information about these statements, see <a class="olink LNPLS01108" href="../../appdev.112/e25519/dynamic.htm#LNPLS01108"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>).</p>
</li>
<li>
<p>DML statements executed by Java stored procedures and external procedures (even when these procedures are invoked by <code dir="ltr">CALL</code> triggers)</p>
</li>
</ul>
<p>Application SQL fires both noncrossedition and crossedition triggers, according to these rules:</p>
<div class="inftblinformal">
<table class="cellalignment1273" title="Conditions Under Which Triggers Can Fire" summary="This table summarizes the conditions under which the different kinds of triggers can fire." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t24">Kind of Trigger</th>
<th class="cellalignment1274" id="r1c2-t24">Conditions Under Which Trigger Can Fire</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t24" headers="r1c1-t24">Noncrossedition</td>
<td class="cellalignment1275" headers="r2c1-t24 r1c2-t24">Trigger is both visible and enabled in the current edition.</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t24" headers="r1c1-t24">Forward crossedition</td>
<td class="cellalignment1275" headers="r3c1-t24 r1c2-t24">Trigger was created in a descendent of the current edition.</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t24" headers="r1c1-t24">Reverse crossedition</td>
<td class="cellalignment1275" headers="r4c1-t24 r1c2-t24">Trigger was created either in the current edition or in an ancestor of the current edition.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDCGHCD"></a>
<div id="ADFNS926" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Firing Order</h4>
<p><a id="sthref1264"></a><a id="sthref1265"></a>For a trigger to fire in response to a specific DML statement, the trigger must:</p>
<ul>
<li>
<p>Be the right kind (see <a href="#CHDFAEHG">"What Kind of Triggers Can Fire"</a>)</p>
</li>
<li>
<p>Satisfy the selection criteria (for example, the type of DML statement and the <code dir="ltr">WHEN</code> clause)</p>
</li>
<li>
<p>Be enabled</p>
</li>
</ul>
<p>For the triggers that meet these requirements, firing order depends on:</p>
<ul>
<li>
<p><a href="#BABBADEG">FOLLOWS and PRECEDES Clauses</a></p>
</li>
<li>
<p><a href="#BABFFCAH">Trigger Type and Edition</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS99985" href="../../appdev.112/e25519/triggers.htm#LNPLS99985"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for general information about trigger firing order</div>
<a id="BABBADEG"></a>
<div id="ADFNS927" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">FOLLOWS and PRECEDES Clauses</h5>
<p>When triggers A and B are to be fired at the same timing point, A fires before B fires if either of these is true:</p>
<ul>
<li>
<p>A explicitly precedes B.</p>
</li>
<li>
<p>B explicitly follows A.</p>
</li>
</ul>
<p>This rule is independent of conditions such as:</p>
<ul>
<li>
<p>Whether the triggers are enabled or disabled</p>
</li>
<li>
<p>Whether the columns specified in the <code dir="ltr">UPDATE</code> <code dir="ltr">OF</code> clause are modified</p>
</li>
<li>
<p>Whether the <code dir="ltr">WHEN</code> clauses are satisfied</p>
</li>
<li>
<p>Whether the triggers are associated with the same kinds of DML statements (<code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code>)</p>
</li>
<li>
<p>Whether the triggers have overlapping timing points</p>
</li>
</ul>
<p>The firing order of triggers that do not explicitly follow or precede each other is unpredictable.</p>
</div>
<!-- class="sect4" -->
<a id="BABFFCAH"></a>
<div id="ADFNS928" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Trigger Type and Edition</h5>
<p>For each timing point associated with a triggering DML statement, eligible triggers fire in this order. In categories <a href="#g5068739">1</a> through <a href="#g5068945">3</a>, <code dir="ltr">FOLLOWS</code> relationships apply; in categories <a href="#g5069005">4</a> and <a href="#g5069209">5</a>, <code dir="ltr">PRECEDES</code> relationships apply.</p>
<ol>
<li id="g5068739">
<p>Noncrossedition triggers</p>
</li>
<li>
<p>Forward crossedition triggers created in the current edition</p>
</li>
<li id="g5068945">
<p>Forward crossedition triggers created in descendents of the current edition, in the order that the descendents were created (child, grandchild, and so on)</p>
</li>
<li id="g5069005">
<p>Reverse crossedition triggers created in the current edition</p>
</li>
<li id="g5069209">
<p>Reverse crossedition triggers created in the ancestors of the current edition, in the reverse order that the ancestors were created (parent, grandparent, and so on)</p>
</li>
</ol>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDJGGAB"></a>
<div id="ADFNS929" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Crossedition Trigger Execution</h4>
<p><a id="sthref1266"></a>A crossedition trigger runs using the edition in which it was created. Any code that the crossedition trigger calls (including package references, PL/SQL subprogram calls, and SQL statements) also runs in the edition in which the crossedition trigger was created.</p>
<p>If a PL/SQL package is actual in multiple editions, then the package variables and other state are private in each edition, even within a single session. Because each crossedition trigger and the code that it calls run using the edition in which the crossedition trigger was created, the same session can instantiate two or more versions of the package, with the same name.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBJEFC"></a>
<div id="ADFNS99912" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating a Crossedition Trigger</h3>
<p><a id="sthref1267"></a>To create a crossedition trigger, you must be editions-enabled (for information about enabling editions for a user, see <a href="#g5086786">"Enabling Editions for a User"</a>).</p>
<p>Create a crossedition trigger with the SQL statement <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code>, observing these rules:</p>
<ul>
<li>
<p>A crossedition trigger must be defined on a table, not a view.</p>
</li>
<li>
<p>A crossedition trigger must be a DML trigger (simple or compound).</p>
<p>The DML statement in a crossedition trigger body can be either a static SQL statement (described in <a class="olink LNPLS00601" href="../../appdev.112/e25519/static.htm#LNPLS00601"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>) or a native dynamic SQL statement (described in <a class="olink LNPLS01102" href="../../appdev.112/e25519/dynamic.htm#LNPLS01102"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>).</p>
</li>
<li>
<p>A crossedition trigger is forward unless you specify <code dir="ltr">REVERSE</code>. (Specifying <code dir="ltr">FORWARD</code> is optional.)</p>
</li>
<li>
<p>The <code dir="ltr">FOLLOWS</code> clause is allowed only when creating a forward crossedition trigger or a noncrossedition trigger. (The <code dir="ltr">FOLLOWS</code> clause indicates that the trigger being created is to fire after the specified triggers fire.)</p>
</li>
<li>
<p>The <code dir="ltr">PRECEDES</code> clause is allowed only when creating a reverse crossedition trigger. (The <code dir="ltr">PRECEDES</code> clause indicates that the trigger being created is to fire before the specified triggers fire.)</p>
</li>
<li>
<p>The triggers specified in the <code dir="ltr">FOLLOWS</code> or <code dir="ltr">PRECEDES</code> clause must exist, but need not be enabled or successfully compiled.</p>
</li>
<li>
<p>Like a noncrossedition trigger, a crossedition trigger is created in the enabled state unless you specify <code dir="ltr">DISABLE</code>. (Specifying <code dir="ltr">ENABLE</code> is optional.)</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Create crossedition triggers in the disabled state, and enable them after you are sure that they compile successfully. If you create them in the enabled state, and they fail to compile, the failure affects users of the existing application.</div>
</li>
<li>
<p>The operation in a crossedition trigger body must be <span class="bold">idempotent</span> (that is, performing the operation multiple times is redundant; it does not change the result).</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01374" href="../../appdev.112/e25519/create_trigger.htm#LNPLS01374"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about using the <code dir="ltr">CREATE</code> <code dir="ltr">TRIGGER</code> statement to create crossedition triggers</div>
<a id="BABIEHHA"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Coding the Forward Crossedition Trigger Body</h4>
<p>The operation in the body of a forward crossedition trigger must be idempotent, because it is impossible to predict:</p>
<ul>
<li>
<p>The context in which the body will first run for an old row.</p>
<p>The possibilities are:</p>
<ul>
<li>
<p>When a user of an ancestor edition runs a DML statement that fires the trigger (a <span class="bold">serendipitous change</span>)</p>
</li>
<li>
<p>When you <span class="bold">apply the transform</span> that the trigger defines</p>
<p>For information about applying transforms, see <a href="#CHDGAGCH">"Transforming Data from Pre- to Post-Upgrade Representation"</a>.</p>
</li>
</ul>
</li>
<li>
<p>How many times the body will run for each old row.</p>
</li>
</ul>
<p class="subhead2"><a id="sthref1268"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABJCHCC">Handling Data Transformation Collisions</a></p>
</li>
<li>
<p><a href="#BABIFCCJ">Handling Changes to Other Tables</a></p>
</li>
</ul>
<a id="BABJCHCC"></a>
<div class="sect4">
<h5 class="sect4">Handling Data Transformation Collisions</h5>
<p>If a forward crossedition trigger populates a new table (rather than new columns of a table), its body must handle data transformation collisions.</p>
<p>For example, suppose that a column of the new table has a <a id="sthref1269"></a><a id="sthref1270"></a><code dir="ltr">UNIQUE</code> constraint. A <a id="sthref1271"></a>serendipitous change fires the forward crossedition trigger, which inserts a row in the new table. Later, another serendipitous change fires the forward crossedition trigger, or you apply the transform defined by the trigger. The trigger tries to insert a row in the new table, violating the <code dir="ltr">UNIQUE</code> constraint.</p>
<p>If your collision-handling strategy depends on why the trigger is running, you can determine the reason with the function <a id="sthref1272"></a><code dir="ltr">APPLYING_CROSSEDITION_TRIGGER</code>. When called directly from a trigger body, this function returns the <code dir="ltr">BOOLEAN</code> value <code dir="ltr">TRUE</code> if the trigger is running because of a <a id="sthref1273"></a>serendipitous change and <code dir="ltr">FALSE</code> if the trigger is running because you are applying the transform. (<code dir="ltr">APPLYING_CROSSEDITION_TRIGGER</code> is defined in the package <code dir="ltr">DBMS_STANDARD</code>. It has no parameters.)</p>
<p>To ignore collisions and insert the rows that do not collide with existing rows, put the <a id="sthref1274"></a><code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code> hint in the <code dir="ltr">INSERT</code> statement.</p>
<p>If you do not want to ignore such collisions, but want to know where they occur so that you can handle them, put the <a id="sthref1275"></a><code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code> hint in the <code dir="ltr">INSERT</code> or <code dir="ltr">UPDATE</code> statement, specifying either an index or set of columns. Then, when a unique key violation occurs for that index or set of columns, ORA-38911 is reported instead of ORA-00001. You can write an exception handler for ORA-38911.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although they have the syntax of hints, <code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code> and <code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code> are mandates. The optimizer always uses them.</div>
<p><a href="#BABEDEFI">Example 19-5</a> creates a crossedition trigger that uses the <code dir="ltr">APPLYING_CROSSEDITION_TRIGGER</code> function and the <code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code> and <code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code> hints to handle data transformation collisions. The trigger transforms old rows in <code dir="ltr">table1</code> to new rows in <code dir="ltr">table2</code>. The tables were created as follows:</p>
<pre dir="ltr">
CREATE TABLE table1 (key NUMBER, value VARCHAR2(20));

CREATE TABLE table2 (key NUMBER, value VARCHAR2(20), last_updated TIMESTAMP);
CREATE UNIQUE INDEX i2 on table2(key);
</pre>
<div class="example">
<p class="titleinexample"><a id="BABEDEFI"></a>Example 19-5 Crossedition Trigger that Handles Data Transformation Collisions</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER trigger1
  BEFORE INSERT OR UPDATE ON table1
  FOR EACH ROW
  CROSSEDITION
DECLARE
  row_already_present  EXCEPTION;
  PRAGMA EXCEPTION_INIT(row_already_present, -38911);
BEGIN
  IF <span class="bold">APPLYING_CROSSEDITION_TRIGGER</span> THEN
    /* Trigger is running because of serendipitous change.
       Insert new row into table2 unless it is already there. */
    <span class="bold">INSERT /*+ IGNORE_ROW_ON_DUPKEY_INDEX(table2(key)) */</span>
    INTO table2
    VALUES(:new.key, :new.value, to_date('1900-01-01', 'YYYY-MM-DD'));
  ELSE
    /* Trigger is running because you are applying transform.
       If tranform has not yet inserted new row in table2, insert new row;
       otherwise, update new row. */
    BEGIN
      <span class="bold">INSERT /*+ CHANGE_DUPKEY_ERROR_INDEX(table2(key)) */</span>
      INTO table2
      VALUES(:new.key, :new.value, SYSTIMESTAMP);
    EXCEPTION WHEN row_already_present THEN
      UPDATE table2
      SET value = :new.value, last_updated = SYSTIMESTAMP
      WHERE key = :new.key;
    END;
  END IF;
END;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF30052" href="../../server.112/e41084/sql_elements006.htm#SQLRF30052"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">IGNORE_ROW_ON_DUPKEY_INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF30053" href="../../server.112/e41084/sql_elements006.htm#SQLRF30053"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code dir="ltr">CHANGE_DUPKEY_ERROR_INDEX</code></p>
</li>
<li>
<p><a class="olink SQLRF00219" href="../../server.112/e41084/sql_elements006.htm#SQLRF00219"><span class="italic">Oracle Database SQL Language Reference</span></a> for general information about hints</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="BABIFCCJ"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Handling Changes to Other Tables</h5>
<p>If the body of a forward crossedition trigger includes explicit SQL statements that change tables other than the one on which the trigger is defined, and if the rows of those tables do not have a one-to-one correspondence with the rows of the table on which the trigger is defined, then the body code must implement a locking mechanism that correctly handles these situations:</p>
<ul>
<li>
<p>Two or more users of ancestor editions simultaneously issue DML statements for the table on which the trigger is defined.</p>
</li>
<li>
<p>At least one user of an ancestor edition issues a DML statement for the table on which the trigger is defined.</p>
</li>
</ul>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGAGCH"></a>
<div id="ADFNS99907" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Transforming Data from Pre- to Post-Upgrade Representation</h3>
<p>After redefining the database objects that comprise the application that you are upgrading (in the new edition), you must transform the application data from its pre-upgrade representation (in the old edition) to its post-upgrade representation (in the new edition). The rules for this transformation are called <span class="bold">transforms</span>, and they are defined by forward crossedition triggers. (For general information about forward crossedition triggers, see <a href="#BABHEHAH">"Forward Crossedition Triggers"</a>.)</p>
<p>Some old rows might have been transformed to new rows by <a id="sthref1276"></a><span class="bold">serendipitous changes</span>; that is, by changes that users of the pre-upgrade application made, which fired forward crossedition triggers. However, any rows that were not transformed by serendipitous changes are still in their pre-upgrade representation. To ensure that all old rows are transformed to new rows, you must <a id="sthref1277"></a><span class="bold">apply the transforms</span> that you defined on the tables that store the application data.</p>
<p>There are two ways to apply a transform:</p>
<ul>
<li>
<p>Fire the trigger that defines the transform on every row of the table, one row at a time.</p>
</li>
<li>
<p>Instead of firing the trigger, run a SQL statement that does what the trigger would do, but faster, and then fire any triggers that follow that trigger.</p>
<p>This second way is recommended if you have replaced an entire table or created a new table.</p>
</li>
</ul>
<p>For either way of applying the transform, invoke either the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure or the subprograms in the <a id="sthref1278"></a><code dir="ltr">DBMS_PARALLEL_EXECUTE</code> package. The latter is recommended if you have a lot of data. The subprograms enable you to incrementally update the data in a large table in parallel, in two high-level steps:</p>
<ol>
<li>
<p>Group sets of rows in the table into smaller chunks.</p>
</li>
<li>
<p>Apply the desired <code dir="ltr">UPDATE</code> statement to the chunks in parallel, committing each time you have finished processing a chunk.</p>
</li>
</ol>
<p>The advantages are:</p>
<ul>
<li>
<p>You lock only one set of rows at a time, for a relatively short time, instead of locking the entire table.</p>
</li>
<li>
<p>You do not lose work that has been done if something fails before the entire operation finishes.</p>
</li>
</ul>
<p>For both the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure and the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> subprograms, the actual parameter values for <code dir="ltr">apply_crossedition_trigger</code>, <code dir="ltr">fire_apply_trigger</code>, and <code dir="ltr">sql_stmt</code> are the same:</p>
<ul>
<li>
<p>For <code dir="ltr">apply_crossedition_trigger</code>, specify the name of the forward crossedition trigger that defines the transform to be applied.</p>
</li>
<li>
<p>To fire the trigger on every row of the table, one row at a time:</p>
<ul>
<li>
<p>For the value of <code dir="ltr">fire_apply_trigger</code>, specify <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p>For <code dir="ltr">sql_stmt</code>, supply a SQL statement whose only significant effect is to select the forward crossedition trigger to be fired; for example, an <code dir="ltr">UPDATE</code> statement that sets some column to its own existing value in each row.</p>
</li>
</ul>
</li>
<li>
<p>To run a SQL statement that does what the trigger would do, and then fire any triggers that follow that trigger:</p>
<ul>
<li>
<p>For the value of <code dir="ltr">fire_apply_trigger</code>, specify <code dir="ltr">FALSE</code>.</p>
</li>
<li>
<p>For <code dir="ltr">sql_stmt</code>, supply a SQL statement that does what the forward crossedition trigger would do, but faster&mdash;for example, a PL/SQL anonymous block that calls one or more PL/SQL subprograms.</p>
</li>
</ul>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS058" href="../../appdev.112/e40758/d_sql.htm#ARPLS058"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_SQL</code>.<code dir="ltr">PARSE</code> procedure</p>
</li>
<li>
<p><a class="olink ARPLS233" href="../../appdev.112/e40758/d_parallel_ex.htm#ARPLS233"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> package</p>
</li>
</ul>
</div>
<a id="BABJEAFE"></a>
<div class="sect3">
<h4 class="sect3">Preventing Lost Updates</h4>
<p>To prevent lost updates when applying a transform, use this procedure:</p>
<ol>
<li>
<p>Enable crossedition triggers.</p>
</li>
<li>
<p>Wait until pending changes to the affected tables are either committed or rolled back.</p>
<p>Use the procedure <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">WAIT_ON_PENDING_DML</code>, described in <a class="olink ARPLS064" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS064"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li>
<p>Apply the transform.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
This scenario, where the forward crossedition trigger changes only the table on which it is defined, is sufficient to illustrate the risk. Suppose that Session One issues an <code dir="ltr">UPDATE</code> statement against the table when the crossedition trigger is not yet enabled; and that Session Two then enables the crossedition trigger and immediately applies the transformation.
<p>A race condition can now occur when both Session One and Session Two will change the same row (row <span class="italic">n</span>). Chance determines which session reaches row <span class="italic">n</span> first. Both updates succeed, even if the session that reaches row <span class="italic">n</span> second must wait until the session that reached it first commits its change and releases its lock.</p>
<p>The problem occurs when Session Two wins the race. Because its SQL statement was compiled after the trigger was enabled, the program that implements the statement also implements the trigger action; therefore, the intended post-upgrade column values are set for row <span class="italic">n</span>. Now Session One reaches row <span class="italic">n</span>, and because its SQL statement was compiled before the trigger was enabled, the program that implements the statement does not implement the trigger action. Therefore, the values that Session Two set in the post-upgrade columns do not change&mdash;they reflect the values that the source columns had before Session One updated row <span class="italic">n</span>. That is, the intended side-effect of Session One's update is lost.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGHBBF"></a>
<div id="ADFNS930" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Dropping the Crossedition Triggers</h3>
<p><a id="sthref1279"></a>To drop a crossedition trigger, use the <code dir="ltr">DROP</code> <code dir="ltr">TRIGGER</code> statement, described in <a class="olink LNPLS99990" href="../../appdev.112/e25519/drop_trigger.htm#LNPLS99990"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>. Alternatively, you can drop crossedition triggers by dropping the edition in which they are actual, by using the <code dir="ltr">DROP</code> <code dir="ltr">EDITION</code> statement with the <code dir="ltr">CASCADE</code> clause. For information about dropping editions, see <a href="#CHDJCDCA">"Dropping an Edition"</a>.</p>
<p>You drop crossedition triggers in these situations:</p>
<ul>
<li>
<p>You are rolling back the application upgrade (dropping the post-upgrade edition).</p>
<p>Before dropping the post-upgrade edition, you must disable or drop any <a id="sthref1280"></a>constraints on the new columns.</p>
</li>
<li>
<p>You have finished the application upgrade and made the post-upgrade edition available to all users.</p>
<p>When all sessions are using the post-upgrade edition, you can drop the forward crossedition triggers. However, before dropping the reverse crossedition triggers, you must disable or drop any constraints on the old columns.</p>
</li>
</ul>
<p>To disable or drop constraints, use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement with the <code dir="ltr">DISABLE</code> <code dir="ltr">CONSTRAINT</code> or <code dir="ltr">DROP</code> <code dir="ltr">CONSTRAINT</code> clause. For information about the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement, see <a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDCEEEA"></a>
<div id="ADFNS0204" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Displaying Information About Editions, Editioning Views, and Crossedition Triggers</h2>
<p><a id="sthref1281"></a><a id="sthref1282"></a><a id="sthref1283"></a><a href="#g4932472">Table 19-1</a> and <a href="#g4942508">Table 19-2</a> describe the static data dictionary views that display information about editions and editioning views, respectively. For more information about a view in either table, see <a class="olink REFRN002" href="../../server.112/e40402/statviews_part.htm#REFRN002"><span class="italic">Oracle Database Reference</span></a>.</p>
<p>The static data dictionary views that display information about triggers are described in <a class="olink REFRN002" href="../../server.112/e40402/statviews_part.htm#REFRN002"><span class="italic">Oracle Database Reference</span></a>. Crossedition triggers that appear in static data dictionary views are actual objects in the session edition.</p>
<p>Child cursors cannot be shared if the set of <a id="sthref1284"></a><a id="sthref1285"></a>crossedition triggers that might run differs. The dynamic performance views <code dir="ltr">V$SQL_SHARED_CURSOR</code> and <code dir="ltr">GV$SQL_SHARED_CURSOR</code> have a <code dir="ltr">CROSSEDITION_TRIGGER_MISMATCH</code> column that tells whether this is true. For information about <code dir="ltr">V$SQL_SHARED_CURSOR</code>, see <a class="olink REFRN30254" href="../../server.112/e40402/dynviews_3059.htm#REFRN30254"><span class="italic">Oracle Database Reference</span></a>.</p>
<div id="ADFNS932" class="tblformal">
<p class="titleintable"><a id="sthref1286"></a><a id="g4932472"></a>Table 19-1 *_ Dictionary Views with Edition Information</p>
<table class="cellalignment1278" title="*_ Dictionary Views with Edition Information" summary="This table summarizes the DBA_ dictionary views that provide information about Editions." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t32">View</th>
<th class="cellalignment1274" id="r1c2-t32">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20634" href="../../server.112/e40402/statviews_1084.htm#REFRN20634"><code dir="ltr">*_EDITIONS</code></a></p>
</td>
<td class="cellalignment1275" headers="r2c1-t32 r1c2-t32">
<p>Describe every edition in the database.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20635" href="../../server.112/e40402/statviews_1079.htm#REFRN20635"><code dir="ltr">*_EDITION_COMMENTS</code></a></p>
</td>
<td class="cellalignment1275" headers="r3c1-t32 r1c2-t32">
<p>Show the comments associated with every edition in the database.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20146" href="../../server.112/e40402/statviews_1158.htm#REFRN20146"><code dir="ltr">*_OBJECTS</code></a></p>
</td>
<td class="cellalignment1275" headers="r4c1-t32 r1c2-t32">
<p>Describe every object in the database that is visible (actual or inherited) in the session edition.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t32" headers="r1c1-t32">
<p><a id="g4936767"></a><a class="olink REFRN20578" href="../../server.112/e40402/statviews_1159.htm#REFRN20578"><code dir="ltr">*_OBJECTS_AE</code></a></p>
</td>
<td class="cellalignment1275" headers="r5c1-t32 r1c2-t32">
<p>Describe every actual object in the database, in every edition.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r6c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20065" href="../../server.112/e40402/statviews_1086.htm#REFRN20065"><code dir="ltr">*_ERRORS</code></a></p>
</td>
<td class="cellalignment1275" headers="r6c1-t32 r1c2-t32">
<p>Describe every error in the database in the session edition.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r7c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20577" href="../../server.112/e40402/statviews_1087.htm#REFRN20577"><code dir="ltr">*_ERRORS_AE</code></a></p>
</td>
<td class="cellalignment1275" headers="r7c1-t32 r1c2-t32">
<p>Describe every error in the database, in every edition.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r8c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20302" href="../../server.112/e40402/statviews_2130.htm#REFRN20302"><code dir="ltr">*_USERS</code></a></p>
</td>
<td class="cellalignment1275" headers="r8c1-t32 r1c2-t32">
<p>Describe every user in the database. Useful for showing which users have editions enabled.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r9c1-t32" headers="r1c1-t32">
<p><a class="olink REFRN20465" href="../../server.112/e40402/statviews_2063.htm#REFRN20465"><code dir="ltr">*_SERVICES</code></a></p>
</td>
<td class="cellalignment1275" headers="r9c1-t32 r1c2-t32">
<p>Describe every service in the database.</p>
<p>As of Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2), the <code dir="ltr">EDITIONS</code> column shows the default initial session edition.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">*_OBJECTS</code> and <code dir="ltr">*_OBJECTS_AE</code> include dependent objects that are invalidated by operations in <a href="adfns_dependencies.htm#g1008856">Table 18-2</a> only after one of the following:
<ul>
<li>
<p>A reference to the object (either during compilation or execution)</p>
</li>
<li>
<p>An invocation of <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">COMPILE_SCHEMA</code> (described in <a class="olink ARPLS380" href="../../appdev.112/e40758/u_recomp.htm#ARPLS380"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>)</p>
</li>
<li>
<p>An invocation of any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS064" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS064"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>)</p>
</li>
</ul>
</div>
<div id="ADFNS933" class="tblformal">
<p class="titleintable"><a id="sthref1287"></a><a id="g4942508"></a>Table 19-2 *_ Dictionary Views with Editioning View Information</p>
<table class="cellalignment1278" title="*_ Dictionary Views with Editioning View Information" summary="This table summarizes the DBA_ dictionary views that provide information about Editioning Views." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t34">View</th>
<th class="cellalignment1274" id="r1c2-t34">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t34" headers="r1c1-t34">
<p><a class="olink REFRN20305" href="../../server.112/e40402/statviews_2133.htm#REFRN20305"><code dir="ltr">*_VIEWS</code></a></p>
</td>
<td class="cellalignment1275" headers="r2c1-t34 r1c2-t34">
<p>Describes every view in the database that is visible (actual or inherited) in the session edition, including editioning views.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t34" headers="r1c1-t34">
<p><a class="olink REFRN20668" href="../../server.112/e40402/statviews_1082.htm#REFRN20668"><code dir="ltr">*_EDITIONING_VIEWS</code></a></p>
</td>
<td class="cellalignment1275" headers="r3c1-t34 r1c2-t34">
<p>Describes every editioning view in the database that is visible (actual or inherited) in the session edition. Useful for showing relationships between editioning views and their base tables. Join with <a href="#g4936767"><code dir="ltr">*_OBJECTS_AE</code></a> for additional information.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t34" headers="r1c1-t34">
<p><a class="olink REFRN20681" href="../../server.112/e40402/statviews_1083.htm#REFRN20681"><code dir="ltr">*_EDITIONING_VIEWS_AE</code></a></p>
</td>
<td class="cellalignment1275" headers="r4c1-t34 r1c2-t34">
<p>Describes every actual object in every editioning view in the database, in every edition.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t34" headers="r1c1-t34">
<p><a class="olink REFRN20669" href="../../server.112/e40402/statviews_1080.htm#REFRN20669"><code dir="ltr">*_EDITIONING_VIEW_COLS</code></a></p>
</td>
<td class="cellalignment1275" headers="r5c1-t34 r1c2-t34">
<p>Describes the columns of every editioning view in the database that is visible (actual or inherited) in the session edition. Useful for showing relationships between the columns of editioning views and the table columns to which they map. Join with <a href="#g4936767"><code dir="ltr">*_OBJECTS_AE</code></a>, <code dir="ltr">*_TAB_COL</code>, or both, for additional information.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r6c1-t34" headers="r1c1-t34">
<p><a class="olink REFRN20683" href="../../server.112/e40402/statviews_1081.htm#REFRN20683"><code dir="ltr">*_EDITIONING_VIEW_COLS_AE</code></a></p>
</td>
<td class="cellalignment1275" headers="r6c1-t34 r1c2-t34">
<p>Describes the columns of every editioning view in the database, in every edition.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Each row of <code dir="ltr">*_EDITIONING_VIEWS</code> matches exactly one row of <code dir="ltr">*_VIEWS</code>, and each row of <code dir="ltr">*_VIEWS</code> that has <code dir="ltr">EDITIONING_VIEW</code> = <code dir="ltr">'Y'</code> matches exactly one row of <code dir="ltr">*_EDITIONING_VIEWS</code>. Therefore, in this example, the <code dir="ltr">WHERE</code> clause is redundant:</p>
<pre dir="ltr">
SELECT ...
  FROM DBA_EDITIONING_VIEWS INNER JOIN DBA_VIEWS
  USING (OWNER, VIEW_NAME)
  <span class="bold">WHERE EDITIONING_VIEW = 'Y'</span>
  AND ...
</pre>
<p>The row of <code dir="ltr">*_VIEWS</code> that matches a row of <code dir="ltr">*_EDITIONING_VIEWS</code> has <code dir="ltr">EDITIONING_VIEW</code> = <code dir="ltr">'Y</code>' by definition. Conversely, no row of <code dir="ltr">*_VIEWS</code> that has <code dir="ltr">EDITIONING_VIEW</code> = <code dir="ltr">'N'</code> has a counterpart in <code dir="ltr">*_ EDITIONING_VIEWS</code>.</p>
</div>
<!-- class="sect1" -->
<a id="BABEHGAF"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Edition-Based Redefinition to Upgrade an Application</h2>
<p>To use edition-based redefinition to upgrade your application online, you must first ready your application:</p>
<ol>
<li>
<p>Editions-enable the appropriate users.</p>
<p>For instructions, see <a href="#g5086786">"Enabling Editions for a User"</a>.</p>
<p>The reason for this step is that only editions-enabled users can own editioning views, which you create in the next step.</p>
</li>
<li>
<p>Prepare your application to use editioning views.</p>
<p>For instructions, see <a href="#BABCFGHJ">"Preparing Your Application to Use Editioning Views"</a>.</p>
</li>
</ol>
<p>With the editioning views in place, you can use edition-based redefinition to upgrade your application online as often as necessary. For each upgrade:</p>
<ul>
<li>
<p>If the type of every object that you will redefine is editionable (tables are not editionable), use the <a href="#CHDIGDGF">"Procedure for Edition-Based Redefinition Using Only Editions"</a>.</p>
</li>
<li>
<p>If you will change the structure of one or more tables, and while you are doing so, other users <span class="italic">do not</span> need to be able to change data in those tables, use the <a href="#CHDDFEJC">"Procedure for Edition-Based Redefinition Using Editioning Views"</a>.</p>
</li>
<li>
<p>If you will change the structure of one or more tables, and while you are doing so, other users must be able to change data in those tables, use the <a href="#BABGGADB">"Procedure for Edition-Based Redefinition Using Crossedition Triggers"</a>.</p>
</li>
</ul>
<p class="subhead2"><a id="sthref1288"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABCFGHJ">Preparing Your Application to Use Editioning Views</a></p>
</li>
<li>
<p><a href="#CHDIGDGF">Procedure for Edition-Based Redefinition Using Only Editions</a></p>
</li>
<li>
<p><a href="#CHDDFEJC">Procedure for Edition-Based Redefinition Using Editioning Views</a></p>
</li>
<li>
<p><a href="#BABGGADB">Procedure for Edition-Based Redefinition Using Crossedition Triggers</a></p>
</li>
<li>
<p><a href="#BABFDHIG">Rolling Back the Application Upgrade</a></p>
</li>
<li>
<p><a href="#BABFIAEF">Reclaiming Space Occupied by Unused Table Columns</a></p>
</li>
<li>
<p><a href="#BABFFEDD">Example: Using Edition-Based Redefinition to Upgrade an Application</a></p>
</li>
</ul>
<a id="BABCFGHJ"></a>
<div id="ADFNS99917" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Preparing Your Application to Use Editioning Views</h3>
<p><a id="sthref1289"></a>An application that uses one or more tables must cover each table with an editioning view. An editioning view <a id="sthref1290"></a><span class="bold">covers</span> a table when all of these statements are true:</p>
<ul>
<li>
<p>Every ordinary object in the application references the table only through the editioning view. (An <span class="bold">ordinary object</span> is any object except an editioning view or crossedition trigger. Editioning views and crossedition triggers must reference tables.)</p>
</li>
<li>
<p>Application users are granted object privileges only on the editioning view, not on the table.</p>
</li>
<li>
<p><a id="sthref1291"></a><a id="sthref1292"></a>Oracle Virtual Private Database (VPD) policies are attached only to the editioning view, not to the table. (<a id="sthref1293"></a><a id="sthref1294"></a>Regular auditing and <a id="sthref1295"></a>fine-grained auditing (FGA) policies are attached only to the table.)</p>
</li>
</ul>
<p>When the editioning view is actualized, a copy of the VPD policy is attached to the actualized editioning view. (A policy is uniquely identified by its name and the object to which is it attached.) If the policy function is also actualized, the copy of the policy uses the actualized policy function; otherwise, it uses the original policy function.</p>
<p>The static data dictionary views <code dir="ltr">*_POLICIES</code>, which describe the VPD policies, can have different results in different editions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink DBSEG007" href="../../network.112/e36292/vpd.htm#DBSEG007"><span class="italic">Oracle Database Security Guide</span></a> for information about VPD, including that static data dictionary views that show information about VPD policies</p>
</li>
<li>
<p><a class="olink REFRN20164" href="../../server.112/e40402/statviews_2010.htm#REFRN20164"><span class="italic">Oracle Database Reference</span></a> for information about <code dir="ltr">*_POLICIES</code></p>
</li>
</ul>
</div>
<p>If an existing application does not use editioning views, prepare it to use them by following this procedure for each table that it uses:</p>
<ol>
<li>
<p>Give the table a new name (so that you can give its current name to its editioning view).</p>
<p>Oracle recommends choosing a new name that is related to the original name and reflects the change history. For example, if the original table name is <code dir="ltr">Data</code>, the new table name might be <code dir="ltr">Data_1</code>.</p>
</li>
<li id="BABGCHAC">
<p>(Optional) Give each column of the table a new name.</p>
<p>Again, Oracle recommends choosing new names that are related to the original names and reflect the change history. For example, <code dir="ltr">Name</code> and <code dir="ltr">Number</code> might be changed to <code dir="ltr">Name_1</code> and <code dir="ltr">Number_1</code>.</p>
<p>Any triggers that depend on renamed columns are now invalid. For details, see the entry for <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr"><span class="codeinlineitalic">table</span></code> <code dir="ltr">RENAME</code> <code dir="ltr"><span class="codeinlineitalic">column</span></code> in <a href="adfns_dependencies.htm#g1008856">Table 18-2</a>.</p>
</li>
<li>
<p>Create the editioning view, giving it the original name of the table.</p>
<p>For instructions, see <a href="#CHDHIDGF">"Creating an Editioning View"</a>.</p>
<p>Because the editioning view has the name that the table had, objects that reference that name now reference the editioning view.</p>
</li>
<li>
<p>If triggers are defined on the table, drop them, and rerun the code that created them.</p>
<p>Now the triggers that were defined on the table are defined on the editioning view.</p>
</li>
<li>
<p>If VPD policies are attached to the table, drop the policies and policy functions and rerun the code that created them.</p>
<p>Now the VPD policies that were attached to the table are attached to the editioning view.</p>
</li>
<li id="BABHGIGB">
<p>Revoke all object privileges on the table from all application users.</p>
<p>To see which application users have which object privileges on the table, use this query:</p>
<pre dir="ltr">
SELECT GRANTEE, PRIVILEGE
FROM DBA_TAB_PRIVS
WHERE TABLE_NAME='<span class="italic">table_name</span>';
</pre></li>
<li id="BABBGFEE">
<p>For every privilege revoked in step&nbsp;<a href="#BABHGIGB">6</a>, grant the same privilege on the editioning view.</p>
</li>
<li id="BABCGJIB">
<p>Enable editions for users who own private synonyms that refer to the table (for instructions, see <a href="#g5086786">"Enabling Editions for a User"</a>) and notify those users that they must re-create those synonyms.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
Public synonyms that refer to the table now fail with ORA-00980, and you cannot re-create them on the editioning view (for the reason, see <a href="#BABGGBID">"Actualizing Referenced Objects"</a>).</div>
</div>
<!-- class="sect2" -->
<a id="CHDIGDGF"></a>
<div id="ADFNS99918" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Procedure for Edition-Based Redefinition Using Only Editions</h3>
<p>Use this procedure only if the type of every object that you will redefine is editionable (as defined in <a href="#g5086774">"Editionable and Noneditionable Schema Object Types"</a>). Table is not an editionable type.</p>
<ol>
<li id="BABIIJJI">
<p>Create a new edition.</p>
<p>For instructions, see <a href="#CHDGIGIF">"Creating an Edition"</a>.</p>
</li>
<li>
<p>Make the new edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li id="BABIDGGJ">
<p>Make the necessary changes to the editioned objects of the application.</p>
</li>
<li>
<p>Ensure that all objects are valid.</p>
<p>Query the static data dictionary <code dir="ltr">*_OBJECTS_AE</code>, which describes every actual object in the database, in every edition. If invalid objects remain, recompile them, using any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS064" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS064"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li>
<p>Check that the changes work as intended.</p>
<p>If so, go to step&nbsp;<a href="#BABIABAI">6</a>.</p>
<p>If not, either make further changes (return to step&nbsp;<a href="#BABIDGGJ">3</a>) or roll back the application upgrade (for instructions, see <a href="#BABFDHIG">"Rolling Back the Application Upgrade"</a>).</p>
</li>
<li id="BABIABAI">
<p>Make the new edition (the upgraded application) available to all users.</p>
<p>For instructions, see <a href="#BABJFDDG">"Making an Edition Available to All Users"</a>.</p>
</li>
<li id="BABFGDFG">
<p>Retire the old edition (the original application), so that all users except <code dir="ltr">SYS</code> use only the upgraded application.</p>
<p>For instructions, see <a href="#CHDEEIBA">"Retiring an Edition"</a>.</p>
</li>
</ol>
<p><a href="#CHDGEDCC">Example 19-6</a> shows how to use the preceding procedure to change a very simple PL/SQL procedure.</p>
<div id="ADFNS910" class="example">
<p class="titleinexample"><a id="CHDGEDCC"></a>Example 19-6 Edition-Based Redefinition of Very Simple Procedure</p>
<ol>
<li>
<p>Create PL/SQL procedure for this example:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE hello IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, edition 1.');
END hello;
/
</pre></li>
<li>
<p>Invoke PL/SQL procedure:</p>
<pre dir="ltr">
BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Hello, edition 1.
 
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Do edition-based redefinition of procedure:</p>
<ol>
<li>
<p>Create new edition:</p>
<pre dir="ltr">
CREATE EDITION e2 AS CHILD OF ora$base;
</pre>
<p>Result:</p>
<pre dir="ltr">
Edition created.
</pre></li>
<li>
<p>Make new edition your session edition:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = e2;
</pre>
<p>Result:</p>
<pre dir="ltr">
Session altered.
</pre></li>
<li>
<p>Change procedure:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE hello IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello, edition 2.');
END hello;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Procedure created.
</pre></li>
<li>
<p>Check that change works as intended:</p>
<pre dir="ltr">
BEGIN hello(); END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Hello, edition 2.
PL/SQL procedure successfully completed.
</pre></li>
<li>
<p>Make new edition available to all users (requires system privileges):</p>
<pre dir="ltr">
ALTER DATABASE DEFAULT EDITION = e2;
</pre></li>
<li>
<p>Retire old edition (requires system privileges):</p>
<p>List grantees:</p>
<pre dir="ltr">
SELECT GRANTEE, PRIVILEGE
FROM DBA_TAB_PRIVS
WHERE TABLE_NAME = UPPER('ora$base')
/
</pre>
<p>Result:</p>
<pre dir="ltr">
GRANTEE                        PRIVILEGE
------------------------------ ---------
PUBLIC                         USE
 
1 row selected.
</pre>
<p>Revoke use on old edition from all grantees:</p>
<pre dir="ltr">
REVOKE USE ON EDITION ora$base FROM PUBLIC;
</pre></li>
</ol>
</li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="CHDDFEJC"></a>
<div id="ADFNS99914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Procedure for Edition-Based Redefinition Using Editioning Views</h3>
<p>Use this procedure only if you will change the structure of one or more tables, and while you are doing so, other users <span class="italic">do not</span> need to be able to change data in those tables.</p>
<ol>
<li id="BABEDHHJ">
<p>Create a new edition.</p>
<p>For instructions, see <a href="#CHDGIGIF">"Creating an Edition"</a>.</p>
</li>
<li>
<p>Make the new edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li>
<p>In the new edition, if the editioning views are read-only, make them read-write.</p>
<p>For instructions, see <a href="#CHDFDBDE">"Changing the 'Write-ability' of an Editioning View"</a>.</p>
</li>
<li>
<p>In every edition except the new edition, make the editioning views read-only.</p>
</li>
<li id="BABIFHFC">
<p>Make the necessary changes to the objects of the application.</p>
</li>
<li>
<p>Ensure that all objects are valid.</p>
<p>Query the static data dictionary <code dir="ltr">*_OBJECTS_AE</code>, which describes every actual object in the database, in every edition. If invalid objects remain, recompile them, using any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS064" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS064"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li>
<p>Check that the changes work as intended.</p>
<p>If so, go to step&nbsp;<a href="#BABDECFA">8</a>.</p>
<p>If not, either make further changes (return to step&nbsp;<a href="#BABIFHFC">5</a>) or roll back the application upgrade (for instructions, see <a href="#BABFDHIG">"Rolling Back the Application Upgrade"</a>).</p>
</li>
<li id="BABDECFA">
<p>Make the upgraded application available to all users.</p>
<p>For instructions, see <a href="#BABJFDDG">"Making an Edition Available to All Users"</a>.</p>
</li>
<li id="BABHFGED">
<p>Retire the old edition (the original application), so that all users except <code dir="ltr">SYS</code> use only the upgraded application.</p>
<p>For instructions, see <a href="#CHDEEIBA">"Retiring an Edition"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABGGADB"></a>
<div id="ADFNS99906" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Procedure for Edition-Based Redefinition Using Crossedition Triggers</h3>
<p>Use this procedure only if you will change the structure of one or more tables, and while you are doing so, other users must be able to change data in those tables.</p>
<ol>
<li id="BABEGGDA">
<p>Create a new edition.</p>
<p>For instructions, see <a href="#CHDGIGIF">"Creating an Edition"</a>.</p>
</li>
<li id="BABIFJDC">
<p>Make the new edition your session edition.</p>
<p>For instructions, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li id="BABCEBJI">
<p>Make the permanent changes to the objects of the application.</p>
<p>For example, add new columns to the tables and create any new permanent subprograms.</p>
<p>Objects that depend on objects that you changed might now be invalid. For more information, see <a href="adfns_dependencies.htm#g1008856">Table 18-2</a>.</p>
</li>
<li>
<p>Ensure that all objects are valid.</p>
<p>Query the static data dictionary <code dir="ltr">*_OBJECTS_AE</code>, which describes every actual object in the database, in every edition. If invalid objects remain, recompile them, using any <code dir="ltr">UTL_RECOMP</code> subprogram (described in <a class="olink ARPLS064" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS064"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li id="BABCHBFB">
<p>Create the temporary objects&mdash;the crossedition triggers (in the disabled state) and any subprograms that they need.</p>
<p>For instructions, see <a href="#CHDBJEFC">"Creating a Crossedition Trigger"</a>.</p>
<p>You need reverse crossedition triggers only if you do step <a href="#BABDHEFG">10</a>, which is optional.</p>
</li>
<li id="BABBHAFA">
<p>When the crossedition triggers compile successfully, enable them.</p>
<p>Use the <code dir="ltr">ALTER</code> <code dir="ltr">TRIGGER</code> statement with the <code dir="ltr">ENABLE</code> option. For information about this statement, see <a class="olink LNPLS99996" href="../../appdev.112/e25519/alter_trigger.htm#LNPLS99996"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Wait until pending changes are either committed or rolled back.</p>
<p>Use the procedure <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">WAIT_ON_PENDING_DML</code>, described in <a class="olink ARPLS064" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS064"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li id="BABDHHED">
<p>Apply the transforms.</p>
<p>For instructions, see <a href="#CHDGAGCH">"Transforming Data from Pre- to Post-Upgrade Representation"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is impossible to predict whether this step visits an existing row before a user of an ancestor edition updates, inserts, or deletes data from that row.</div>
</li>
<li id="BABGCFIC">
<p>Check that the changes work as intended.</p>
<p>If so, go to step&nbsp;<a href="#BABDHEFG">10</a>.</p>
<p>If not, either make further changes (return to step&nbsp;<a href="#BABCEBJI">3</a>) or roll back the application upgrade (for instructions, see <a href="#BABFDHIG">"Rolling Back the Application Upgrade"</a>).</p>
</li>
<li id="BABDHEFG">
<p>(Optional) Grant the <code dir="ltr">USE</code> privilege on your session edition to the early users of the upgraded application.</p>
<p>For instructions, see <a href="#BABJFDCH">"Making an Edition Available to Some Users"</a>.</p>
</li>
<li id="BABECJBE">
<p>Make the upgraded application available to all users.</p>
<p>For instructions, see <a href="#BABJFDDG">"Making an Edition Available to All Users"</a>.</p>
</li>
<li id="BABFFFAG">
<p>Disable or drop the constraints and then drop the crossedition triggers.</p>
<p>For instructions, see <a href="#BABGHBBF">"Dropping the Crossedition Triggers"</a>.</p>
</li>
<li id="BABIIIHE">
<p>Retire the old edition (the original application), so that all users except <code dir="ltr">SYS</code> use only the upgraded application.</p>
<p>For instructions, see <a href="#CHDEEIBA">"Retiring an Edition"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABFDHIG"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Rolling Back the Application Upgrade</h3>
<p>To roll back the application upgrade:</p>
<ol>
<li>
<p>Change your session edition to something other than the new edition that you created for the upgrade.</p>
<p>For instructions, see <a href="#CHDBFJGF">"Changing Your Session Edition"</a>.</p>
</li>
<li>
<p>Drop the new edition that you created for the upgrade.</p>
<p>For instructions, see <a href="#CHDJCDCA">"Dropping an Edition"</a>.</p>
</li>
<li>
<p>If you created new table columns during the upgrade, reclaim the space that they occupy (for instructions, see <a href="#BABFIAEF">"Reclaiming Space Occupied by Unused Table Columns"</a>).</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABFIAEF"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Reclaiming Space Occupied by Unused Table Columns</h3>
<p>If you roll back an upgrade for which you created new table columns,</p>
<p>To reclaim the space that unused columns occupy:</p>
<ol>
<li>
<p>Set the values of the unused columns to <code dir="ltr">NULL</code>.</p>
<p>To avoid locking out other users while doing this operation, use the <code dir="ltr">DBMS_PARALLEL_EXECUTE</code> procedure (described in <a class="olink ARPLS233" href="../../appdev.112/e40758/d_parallel_ex.htm#ARPLS233"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>).</p>
</li>
<li>
<p>Set the unused columns to <code dir="ltr">UNUSED</code>.</p>
<p>Use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement (described in <a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a>) with the <code dir="ltr">SET</code> <code dir="ltr">UNUSED</code> clause (described in <a class="olink SQLRF53205" href="../../server.112/e41084/statements_3001.htm#SQLRF53205"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
</li>
<li>
<p>Shrink the table.</p>
<p>Use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement (described in <a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a>) with the <code dir="ltr">SHRINK</code> <code dir="ltr">SPACE</code> clause (described in <a class="olink SQLRF53181" href="../../server.112/e41084/statements_3001.htm#SQLRF53181"><span class="italic">Oracle Database SQL Language Reference</span></a>).</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABFFEDD"></a>
<div id="ADFNS99913" class="sect2">
<h3 class="sect2">Example: Using Edition-Based Redefinition to Upgrade an Application</h3>
<p>This example uses an edition, an editioning view, a forward crossedition trigger, and a reverse crossedition trigger.</p>
<p class="subhead2"><a id="sthref1296"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABCHJHF">Existing Application</a></p>
</li>
<li>
<p><a href="#BABGFBHF">Preparing the Application to Use Editioning Views</a></p>
</li>
<li>
<p><a href="#BABFGCBC">Using Edition-Based Redefinition to Upgrade the Application</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before you can use edition-based redefinition to upgrade an application, you must enable editions for every schema that the application uses. For instructions, see <a href="#g5086786">"Enabling Editions for a User"</a>.</div>
<a id="BABCHJHF"></a>
<div id="ADFNS934" class="sect3">
<h4 class="sect3">Existing Application</h4>
<p>The existing application&mdash;the application to be upgraded&mdash;consists of a single table on which a trigger is defined. The application was created as in <a href="#BABEDAGA">Example 19-7</a>.</p>
<div id="ADFNS935" class="example">
<p class="titleinexample"><a id="BABEDAGA"></a>Example 19-7 Creating the Existing Application</p>
<ol>
<li>
<p>Create table:</p>
<pre dir="ltr">
CREATE TABLE Contacts(
  ID            NUMBER(6,0) CONSTRAINT Contacts_PK PRIMARY KEY,
  Name          VARCHAR2(47),
  Phone_Number  VARCHAR2(20)
);
</pre></li>
<li>
<p>Populate table (not shown).</p>
</li>
<li>
<p>Prepare to create trigger on table:</p>
<pre dir="ltr">
ALTER TABLE Contacts ENABLE VALIDATE CONSTRAINT Contacts_PK;
 
DECLARE Max_ID INTEGER;
BEGIN
  SELECT MAX(ID) INTO Max_ID FROM Contacts;
  EXECUTE IMMEDIATE '
    CREATE SEQUENCE Contacts_Seq
      START WITH '||To_Char(Max_ID + 1);
END;
/
</pre></li>
<li>
<p>Create trigger:</p>
<pre dir="ltr">
CREATE TRIGGER Contacts_BI
  BEFORE INSERT ON Contacts FOR EACH ROW
BEGIN
  :NEW.ID := Contacts_Seq.NEXTVAL;
END;
/
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p><a href="#BABJEBDB">Example 19-8</a> shows how the table <code dir="ltr">Contacts</code> looks after being populated with data.</p>
<div id="ADFNS936" class="example">
<p class="titleinexample"><a id="BABJEBDB"></a>Example 19-8 Viewing Data in Existing Table</p>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM Contacts
ORDER BY Name;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
        ID NAME                                            PHONE_NUMBER
---------- ----------------------------------------------- --------------------
       174 Abel, Ellen                                     011.44.1644.429267
       166 Ande, Sundar                                    011.44.1346.629268
       130 Atkinson, Mozhe                                 650.124.6234
       105 Austin, David                                   590.423.4569
       204 Baer, Hermann                                   515.123.8888
       116 Baida, Shelli                                   515.127.4563
       167 Banda, Amit                                     011.44.1346.729268
       172 Bates, Elizabeth                                011.44.1343.529268
       192 Bell, Sarah                                     650.501.1876
       151 Bernstein, David                                011.44.1344.345268
       129 Bissot, Laura                                   650.124.5234
       169 Bloom, Harrison                                 011.44.1343.829268
       185 Bull, Alexis                                    650.509.2876
       187 Cabrio, Anthony                                 650.509.4876
       148 Cambrault, Gerald                               011.44.1344.619268
       154 Cambrault, Nanette                              011.44.1344.987668
       110 Chen, John                                      515.124.4269
       ...
       120 Weiss, Matthew                                  650.123.1234
       200 Whalen, Jennifer                                515.123.4444
       149 Zlotkey, Eleni                                  011.44.1344.429018

107 rows selected.
</pre></div>
<!-- class="example" -->
<p>Suppose that you must redefine <code dir="ltr">Contacts</code>, replacing the <code dir="ltr">Name</code> column with the columns <code dir="ltr">First_Name</code> and <code dir="ltr">Last_Name</code>, and adding the column <code dir="ltr">Country_Code</code>. Also suppose that while you are making this structural change, other users must be able to change the data in <code dir="ltr">Contacts</code>.</p>
<p>You need all features of edition-based redefinition: the edition, which is always needed; the editioning view, because you are redefining a table; and crossedition triggers, because other users must be able to change data in the table while you are redefining it.</p>
</div>
<!-- class="sect3" -->
<a id="BABGFBHF"></a>
<div id="ADFNS937" class="sect3">
<h4 class="sect3">Preparing the Application to Use Editioning Views</h4>
<p><a href="#BABJFGJD">Example 19-9</a> shows how to create the editioning view from which other users will access the table <code dir="ltr">Contacts</code> while you are redefining it in the new edition.</p>
<div id="ADFNS938" class="example">
<p class="titleinexample"><a id="BABJFGJD"></a>Example 19-9 Creating an Editioning View for the Existing Table</p>
<ol>
<li>
<p>Give table a new name (so that you can give its current name to editioning view):</p>
<pre dir="ltr">
ALTER TABLE Contacts RENAME TO Contacts_Table;
</pre></li>
<li>
<p>(Optional) Give columns of table new names:</p>
<pre dir="ltr">
ALTER TABLE Contacts_Table
  RENAME COLUMN Name TO Name_1;

ALTER TABLE Contacts_Table
  RENAME COLUMN Phone_Number TO Phone_Number_1;
</pre></li>
<li>
<p>Create editioning view:</p>
<pre dir="ltr">
CREATE OR REPLACE EDITIONING VIEW Contacts AS
  SELECT
    ID                 ID,
    Name_1             Name,
    Phone_Number_1     Phone_Number
  FROM Contacts_Table;
</pre></li>
<li id="BABHBBHF">
<p>Move trigger <code dir="ltr">Contacts_BI</code> from table to editioning view:</p>
<pre dir="ltr">
DROP TRIGGER Contacts_BI;
 
CREATE TRIGGER Contacts_BI
  BEFORE INSERT ON Contacts FOR EACH ROW
BEGIN
  :NEW.ID := Contacts_Seq.NEXTVAL;
END;
/
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BABFGCBC"></a>
<div id="ADFNS939" class="sect3">
<h4 class="sect3">Using Edition-Based Redefinition to Upgrade the Application</h4>
<p><a href="#BABBAEFA">Example 19-10</a> shows how to create an edition in which to upgrade the <a href="#BABCHJHF">"Existing Application"</a>, make the new edition the session edition, and check that the new edition really is the session edition.</p>
<div id="ADFNS940" class="example">
<p class="titleinexample"><a id="BABBAEFA"></a>Example 19-10 Creating Edition in Which to Upgrade the Application</p>
<ol>
<li>
<p>Create new edition:</p>
<pre dir="ltr">
CREATE EDITION Post_Upgrade AS CHILD OF Ora$Base;
</pre></li>
<li>
<p>Make new edition your session edition:</p>
<pre dir="ltr">
ALTER SESSION SET EDITION = Post_Upgrade;
</pre></li>
<li>
<p>Check session edition:</p>
<pre dir="ltr">
SELECT
SYS_CONTEXT('Userenv', 'Current_Edition_Name') "Current_Edition"
FROM DUAL;
</pre>
<p>Result:</p>
<pre dir="ltr">
Current_Edition
-----------------------------------------------------------------------------
POST_UPGRADE
 
1 row selected.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABBJGBJ">Example 19-11</a> shows how to add the new columns to the physical table and recompile the trigger that was invalidated by adding the columns. Then, it shows how to replace the editioning view <code dir="ltr">Contacts</code> so that it selects the columns of the table by their desired logical names.</p>
<div id="ADFNS941" class="example">
<p class="titleinexample"><a id="BABBJGBJ"></a>Example 19-11 Changing the Table and Replacing the Editioning View</p>
<ol>
<li>
<p>Add new columns to physical table:</p>
<pre dir="ltr">
ALTER TABLE Contacts_Table ADD (
  First_Name_2     varchar2(20),
  Last_Name_2      varchar2(25),
  Country_Code_2   varchar2(20),
  Phone_Number_2   varchar2(20)
);
</pre>
<p>(This is nonblocking DDL.)</p>
</li>
<li>
<p>Recompile invalidated trigger:</p>
<pre dir="ltr">
ALTER TRIGGER Contacts_BI COMPILE REUSE SETTINGS;
</pre></li>
<li>
<p>Replace editioning view so that it selects replacement columns with their desired logical names:</p>
<pre dir="ltr">
CREATE OR REPLACE EDITIONING VIEW Contacts AS
  SELECT
    ID                 ID,
    First_Name_2       First_Name,
    Last_Name_2        Last_Name,
    Country_Code_2     Country_Code,
    Phone_Number_2     Phone_Number
  FROM Contacts_Table;
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABEGFDD">Example 19-12</a> shows how to create two procedures for the forward crossedition trigger to use, create both the forward and reverse crossedition triggers in the disabled state, and enable them.</p>
<div id="ADFNS942" class="example">
<p class="titleinexample"><a id="BABEGFDD"></a>Example 19-12 Creating and Enabling the Crossedition Triggers</p>
<ol>
<li>
<p>Create first procedure that forward crossedition trigger uses:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE Set_First_And_Last_Name (
  Name        IN  VARCHAR2,
  First_Name  OUT VARCHAR2,
  Last_Name   OUT VARCHAR2)
IS
  Comma_Pos NUMBER := INSTR(Name, ',');
BEGIN
  IF Comma_Pos IS NULL OR Comma_Pos &lt; 2 THEN
    RAISE Program_Error;
  END IF;
 
  Last_Name := SUBSTR(Name, 1, Comma_Pos-1);
  Last_Name := RTRIM(Ltrim(Last_Name));
 
  First_Name := SUBSTR(Name, Comma_Pos+1);
  First_Name := RTRIM(LTRIM(First_Name));
END Set_First_And_Last_Name;
/
</pre></li>
<li>
<p>Create second procedure that forward crossedition trigger uses:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE Set_Country_Code_And_Phone_No (
  Phone_Number     IN  VARCHAR2,
  Country_Code     OUT VARCHAR2,
  Phone_Number_V2  OUT VARCHAR2)
IS
  Char_To_Number_Error EXCEPTION;
  PRAGMA EXCEPTION_INIT(Char_To_Number_Error, -06502);
  Bad_Phone_Number EXCEPTION;
  Nmbr VARCHAR2(30) := REPLACE(Phone_Number, '.', '-');
 
  FUNCTION Is_US_Number(Nmbr IN VARCHAR2)
    RETURN BOOLEAN
  IS
    Len NUMBER := LENGTH(Nmbr);
    Dash_Pos NUMBER := INSTR(Nmbr, '-');
    n PLS_INTEGER;
  BEGIN
    IF Len IS NULL OR Len &lt;&gt; 12 THEN
      RETURN FALSE;
    END IF;
    IF Dash_Pos IS NULL OR Dash_Pos &lt;&gt; 4 THEN
      RETURN FALSE;
    END IF;
    BEGIN
      n := TO_NUMBER(SUBSTR(Nmbr, 1, 3));
    EXCEPTION WHEN Char_To_Number_Error THEN
      RETURN FALSE;
    END;
 
    Dash_Pos := INSTR(Nmbr, '-', 5);
 
    IF Dash_Pos IS NULL OR Dash_Pos &lt;&gt; 8 THEN
      RETURN FALSE;
    END IF;
 
    BEGIN
      n := TO_NUMBER(SUBSTR(Nmbr, 5, 3));
    EXCEPTION WHEN Char_To_Number_Error THEN
      RETURN FALSE;
    END;
 
    BEGIN
      n := TO_NUMBER(SUBSTR(Nmbr, 9));
    EXCEPTION WHEN Char_To_Number_Error THEN
      RETURN FALSE;
    END;
 
    RETURN TRUE;
  END Is_US_Number;
 
BEGIN
  IF Nmbr LIKE '011-%' THEN
    DECLARE
      Dash_Pos NUMBER := INSTR(Nmbr, '-', 5);
    BEGIN
      Country_Code := '+'|| TO_NUMBER(SUBSTR(Nmbr, 5, Dash_Pos-5));
      Phone_Number_V2 := SUBSTR(Nmbr, Dash_Pos+1);
    EXCEPTION WHEN Char_To_Number_Error THEN
      raise Bad_Phone_Number;
    END;
  ELSIF Is_US_Number(Nmbr) THEN
    Country_Code := '+1';
    Phone_Number_V2 := Nmbr;
  ELSE
    RAISE Bad_Phone_Number;
  END IF;
EXCEPTION WHEN Bad_Phone_Number THEN
  Country_Code := '+0';
  Phone_Number_V2 := '000-000-0000';
END Set_Country_Code_And_Phone_No;
/
</pre></li>
<li>
<p>Create forward crossedition trigger in disabled state:</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Contacts_Fwd_Xed
  BEFORE INSERT OR UPDATE ON Contacts_Table
  FOR EACH ROW
  <span class="bold">FORWARD CROSSEDITION</span>
  <span class="bold">DISABLE</span>
BEGIN
  Set_First_And_Last_Name(
    :NEW.Name_1,
    :NEW.First_Name_2,
    :NEW.Last_Name_2
  );
  Set_Country_Code_And_Phone_No(
    :NEW.Phone_Number_1,
    :NEW.Country_Code_2,
    :NEW.Phone_Number_2
  );
END Contacts_Fwd_Xed;
/
</pre></li>
<li>
<p>Enable forward crossedition trigger:</p>
<pre dir="ltr">
ALTER TRIGGER Contacts_Fwd_Xed <span class="bold">ENABLE</span>;
</pre></li>
<li>
<p>Create reverse crossedition trigger in disabled state:</p>
<pre dir="ltr">
CREATE OR REPLACE TRIGGER Contacts_Rvrs_Xed
  BEFORE INSERT OR UPDATE ON Contacts_Table
  FOR EACH ROW
  <span class="bold">REVERSE CROSSEDITION</span>
  <span class="bold">DISABLE</span>
BEGIN
  :NEW.Name_1 := :NEW.Last_Name_2||', '||:NEW.First_Name_2;
  :NEW.Phone_Number_1 :=
  CASE :New.Country_Code_2
    WHEN '+1' THEN
      REPLACE(:NEW.Phone_Number_2, '-', '.')
    ELSE
      '011.'||LTRIM(:NEW.Country_Code_2, '+')||'.'||
      REPLACE(:NEW.Phone_Number_2, '-', '.')
  END;
END Contacts_Rvrs_Xed;
/
</pre></li>
<li>
<p>Enable reverse crossedition trigger:</p>
<pre dir="ltr">
ALTER TRIGGER Contacts_Rvrs_Xed <span class="bold">ENABLE</span>;
</pre></li>
<li>
<p>Wait until pending changes are either committed or rolled back:</p>
<pre dir="ltr">
DECLARE
  scn              NUMBER  := NULL;
  timeout CONSTANT INTEGER := NULL;
BEGIN
  IF NOT DBMS_UTILITY.WAIT_ON_PENDING_DML(Tables  =&gt; 'Contacts_Table',
                                          timeout =&gt; timeout,
                                          scn     =&gt; scn)
  THEN
    RAISE_APPLICATION_ERROR(-20000,
     'Wait_On_Pending_DML() timed out. CETs were enabled before SCN: '||SCN);
  END IF;
END;
/
</pre>
<p>For information about the <code dir="ltr">DBMS_UTILITY</code>.<code dir="ltr">WAIT_ON_PENDING_DML</code> procedure, see <a class="olink ARPLS69021" href="http://www.oracle.com/pls/topic/lookup?ctx=db112&amp;id=ARPLS69021"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
</ol>
</div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABHAFBD">Example 19-13</a> shows how to apply the transforms.</p>
<div id="ADFNS943" class="example">
<p class="titleinexample"><a id="BABHAFBD"></a>Example 19-13 Applying the Transforms</p>
<pre dir="ltr">
DECLARE
  c NUMBER := DBMS_SQL.OPEN_CURSOR();
  x NUMBER;
BEGIN
  DBMS_SQL.PARSE(
    c                          =&gt; c,
    Language_Flag              =&gt; DBMS_SQL.NATIVE,
    Statement                  =&gt; 'UPDATE Contacts_Table SET ID = ID',
    Apply_Crossedition_Trigger =&gt; 'Contacts_Fwd_Xed'
  );
  x := DBMS_SQL.EXECUTE(c);
  DBMS_SQL.CLOSE_CURSOR(c);
  COMMIT;
END;
/
 
</pre></div>
<!-- class="example" -->
<p>In the <code dir="ltr">Post_Upgrade</code> edition, <a href="#BABHACHI">Example 19-14</a> shows how to check that the change worked as intended. Compare <a href="#BABHACHI">Example 19-14</a> to <a href="#BABJEBDB">Example 19-8</a>.</p>
<div id="ADFNS944" class="example">
<p class="titleinexample"><a id="BABHACHI"></a>Example 19-14 Viewing Data in Changed Table</p>
<ol>
<li>
<p>Format columns for readability:</p>
<pre dir="ltr">
COLUMN ID FORMAT 999
COLUMN Last_Name FORMAT A15
COLUMN First_Name FORMAT A15
COLUMN Country_Code FORMAT A12
COLUMN Phone_Number FORMAT A12
</pre></li>
<li>
<p>Query:</p>
<pre dir="ltr">
SELECT * FROM Contacts
ORDER BY Last_Name;
</pre>
<p>Result:</p>
<pre dir="ltr">
  ID FIRST_NAME      LAST_NAME       COUNTRY_CODE PHONE_NUMBER
---- --------------- --------------- ------------ ------------
 174 Ellen           Abel            +44          1644-429267
 166 Sundar          Ande            +44          1346-629268
 130 Mozhe           Atkinson        +1           650-124-6234
 105 David           Austin          +1           590-423-4569
 204 Hermann         Baer            +1           515-123-8888
 116 Shelli          Baida           +1           515-127-4563
 167 Amit            Banda           +44          1346-729268
 172 Elizabeth       Bates           +44          1343-529268
 192 Sarah           Bell            +1           650-501-1876
 151 David           Bernstein       +44          1344-345268
 129 Laura           Bissot          +1           650-124-5234
 169 Harrison        Bloom           +44          1343-829268
 185 Alexis          Bull            +1           650-509-2876
 187 Anthony         Cabrio          +1           650-509-4876
 154 Nanette         Cambrault       +44          1344-987668
 148 Gerald          Cambrault       +44          1344-619268
 110 John            Chen            +1           515-124-4269
       ...
 120 Matthew         Weiss           +1           650-123-1234
 200 Jennifer        Whalen          +1           515-123-4444
 149 Eleni           Zlotkey         +44          1344-429018
 
107 rows selected.
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>If the change worked as intended, you can now follow steps <a href="#BABDHEFG">10</a> through <a href="#BABIIIHE">13</a> of the <a href="#BABGGADB">"Procedure for Edition-Based Redefinition Using Crossedition Triggers"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1266">
<tr>
<td class="cellalignment1275">
<table class="cellalignment1271">
<tr>
<td class="cellalignment1270"><a href="adfns_dependencies.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1270"><a href="adfns_extproc.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1277">
<table class="cellalignment1269">
<tr>
<td class="cellalignment1270"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1270"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1270"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1270"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1270"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1270"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
