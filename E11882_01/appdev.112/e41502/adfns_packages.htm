<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Coding PL/SQL Subprograms and Packages</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-06T1:49:48Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Advanced Application Developer's Guide" />
<meta name="dcterms.identifier" content="E41502-06" />
<meta name="dcterms.isVersionOf" content="ADFNS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="adfns_part_plsql.htm" title="Previous" type="text/html" />
<link rel="Next" href="adfns_plscope.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41502.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/31</span> <!-- End Header -->
<div id="ADFNS009" class="chapter"><a id="g1044585"></a>
<h1 class="chapter"><span class="secnum">6</span> Coding PL/SQL Subprograms and Packages</h1>
<p>This chapter describes some procedural capabilities of Oracle Database for application development.</p>
<p class="subhead2"><a id="sthref524"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1006224">Overview of PL/SQL Units</a></p>
</li>
<li>
<p><a href="#i1007058">Compiling PL/SQL Subprograms for Native Execution</a></p>
</li>
<li>
<p><a href="#i1007323">Cursor Variables</a></p>
</li>
<li>
<p><a href="#i1007459">Handling PL/SQL Compile-Time Errors</a></p>
</li>
<li>
<p><a href="#i1007532">Handling Runtime PL/SQL Errors</a></p>
</li>
<li>
<p><a href="#i1007648">Debugging Stored Subprograms</a></p>
</li>
<li>
<p><a href="#i1007682">Invoking Stored Subprograms</a></p>
</li>
<li>
<p><a href="#i1007858">Invoking Remote Subprograms</a></p>
</li>
<li>
<p><a href="#i1007943">Invoking Stored PL/SQL Functions from SQL Statements</a></p>
</li>
<li>
<p><a href="#i1008519">Returning Large Amounts of Data from a Function</a></p>
</li>
<li>
<p><a href="#i1008575">Coding Your Own Aggregate Functions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS008" href="../../appdev.112/e25519/subprograms.htm#LNPLS008"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about PL/SQL subprograms</p>
</li>
<li>
<p><a class="olink LNPLS009" href="../../appdev.112/e25519/packages.htm#LNPLS009"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about PL/SQL packages</p>
</li>
<li>
<p><a class="olink PFGRF010" href="../../server.112/e41573/sqltrace.htm#PFGRF010"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about application tracing tools, which can help you find problems in PL/SQL code</p>
</li>
</ul>
</div>
<a id="i1006224"></a>
<div id="ADFNS00901" class="sect1">
<h2 class="sect1">Overview of PL/SQL Units</h2>
<p><a id="sthref525"></a>PL/SQL is a modern, block-structured programming language. It provides several features that make developing powerful database applications very convenient. For example, PL/SQL provides procedural constructs, such as loops and conditional statements, that are not available in standard SQL.</p>
<p>You can directly enter SQL data manipulation language (DML) statements inside PL/SQL blocks, and you can use subprograms supplied by Oracle to perform data definition language (DDL) statements.</p>
<p>PL/SQL code runs on the server, so using PL/SQL lets you centralize significant parts of your database applications for increased maintainability and security. It also enables you to achieve a significant reduction of network overhead in client/server applications.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Some Oracle tools, such as Oracle Forms, contain a PL/SQL engine that lets you run PL/SQL locally.</div>
<p>You can even use PL/SQL for some database applications instead of 3GL programs that use embedded SQL or Oracle Call Interface (OCI).</p>
<p>PL/SQL units include:</p>
<ul>
<li>
<p><a href="#i1006270">Anonymous Blocks</a></p>
</li>
<li>
<p><a href="#i1006378">Stored PL/SQL Units</a></p>
</li>
<li>
<p><a href="#i1007026">Triggers</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS009" href="../../appdev.112/e25519/packages.htm#LNPLS009"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for syntax and examples of operations on PL/SQL packages</p>
</li>
<li>
<p><a class="olink ARPLS" href="../e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the PL/SQL packages that come with Oracle Database</p>
</li>
<li>
<p><a href="adfns_dependencies.htm#CHDIBBDE">"Dependencies Among Local and Remote Database Procedures"</a> for information about dependencies among stored PL/SQL units</p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i1006270"></a>
<div id="ADFNS311" class="sect2">
<h3 class="sect2">Anonymous Blocks</h3>
<p><a id="sthref526"></a><a id="sthref527"></a>An anonymous block is a PL/SQL unit that has no name. An anonymous block consists of an optional declarative part, an executable part, and one or more optional exception handlers.</p>
<p>The declarative part declares PL/SQL variables, exceptions, and cursors. The executable part contains PL/SQL code and SQL statements, and can contain nested blocks.</p>
<p>Exception handlers contain code that is invoked when the exception is raised, either as a predefined PL/SQL exception (such as <code dir="ltr">NO_DATA_FOUND</code> or <code dir="ltr">ZERO_DIVIDE</code>) or as an exception that you define.</p>
<p>Anonymous blocks are usually used interactively from a tool, such as SQL*Plus, or in a precompiler, OCI, or SQL*Module application. They are usually used to invoke stored subprograms or to open cursor variables.</p>
<p>The anonymous block in <a href="#CIHGJABC">Example 6-1</a> uses the <code dir="ltr">DBMS_OUTPUT</code> package to print the names of all employees in the <code dir="ltr">HR</code>.<code dir="ltr">EMPLOYEES</code> table who are in department 20.</p>
<div id="ADFNS312" class="example">
<p class="titleinexample"><a id="CIHGJABC"></a>Example 6-1 Anonymous Block</p>
<pre dir="ltr">
DECLARE
  last_name  VARCHAR2(10);
  cursor     c1 IS
               SELECT LAST_NAME
               FROM EMPLOYEES
               WHERE DEPARTMENT_ID = 20
               ORDER BY LAST_NAME;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO last_name;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(last_name);
  END LOOP;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
Fay
Hartstein
</pre></div>
<!-- class="example" -->
<p>Exceptions let you handle Oracle Database error conditions with PL/SQL program logic, enabling your application to prevent the server from issuing an error that can cause the client application to end. The anonymous block in <a href="#CIHHHHDE">Example 6-2</a> handles the predefined Oracle Database exception <code dir="ltr">NO_DATA_FOUND</code> (which results in ORA-01403 if not handled).</p>
<div id="ADFNS313" class="example">
<p class="titleinexample"><a id="CIHHHHDE"></a>Example 6-2 Anonymous Block with Exception Handler for Predefined Error</p>
<pre dir="ltr">
DECLARE
  Emp_number  INTEGER := 9999
  Emp_name    VARCHAR2(10);
BEGIN
  SELECT LAST_NAME INTO Emp_name
    FROM EMPLOYEES
      WHERE EMPLOYEE_ID = Emp_number;
  DBMS_OUTPUT.PUT_LINE('Employee name is ' || Emp_name);
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN NO_DATA_FOUND THEN</span>
    <span class="bold">DBMS_OUTPUT.PUT_LINE('No such employee: ' || Emp_number);</span>
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">No such employee: 9999</span>
</pre></div>
<!-- class="example" -->
<p>You can also define your own exceptions; that is, you can declare them in the declaration part of a block and define them in the exception part of the block, as in <a href="#CIHIFCJB">Example 6-3</a>.</p>
<div id="ADFNS314" class="example">
<p class="titleinexample"><a id="CIHIFCJB"></a>Example 6-3 Anonymous Block with Exception Handler for User-Defined Exception</p>
<pre dir="ltr">
DECLARE
  Emp_name            VARCHAR2(10);
  Emp_number          INTEGER;
  <span class="bold">Empno_out_of_range  EXCEPTION;</span>
BEGIN
  Emp_number := 10001;
  IF Emp_number &gt; 9999 OR Emp_number &lt; 1000 THEN
    <span class="bold">RAISE Empno_out_of_range;</span>
  ELSE
    SELECT LAST_NAME INTO Emp_name
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = Emp_number;
    DBMS_OUTPUT.PUT_LINE('Employee name is ' || Emp_name);
 END IF;
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN Empno_out_of_range THEN</span>
    DBMS_OUTPUT.PUT_LINE('Employee number ' || Emp_number || 
      ' is out of range.');
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Employee number 10001 is out of range.</span>
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS036" href="../../appdev.112/e40758/d_output.htm#ARPLS036"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for complete information about the <code dir="ltr">DBMS_OUTPUT</code> package</p>
</li>
<li>
<p><a class="olink LNPLS007" href="../../appdev.112/e25519/errors.htm#LNPLS007"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> and <a href="#i1007532">"Handling Runtime PL/SQL Errors"</a></p>
</li>
<li>
<p><a href="#i1007323">"Cursor Variables"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006378"></a>
<div id="ADFNS315" class="sect2">
<h3 class="sect2">Stored PL/SQL Units</h3>
<p><a id="sthref528"></a><a id="sthref529"></a>A stored PL/SQL unit is a subprogram (procedure or function) or package that:</p>
<ul>
<li>
<p>Has a name.</p>
</li>
<li>
<p>Can take parameters, and can return values.</p>
</li>
<li>
<p>Is stored in the data dictionary.</p>
</li>
<li>
<p>Can be invoked by many users.</p>
</li>
</ul>
<p>If a subprogram belongs to a package, it is called a <a id="sthref530"></a><a id="sthref531"></a><a id="sthref532"></a><a id="sthref533"></a><span class="bold">package subprogram</span>; if not, it is called a <span class="bold">standalone subprogram</span>.</p>
<p class="subhead2"><a id="sthref534"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1006392">Naming Subprograms</a></p>
</li>
<li>
<p><a href="#i1006401">Subprogram Parameters</a></p>
</li>
<li>
<p><a href="#g1041863">Creating Subprograms</a></p>
</li>
<li>
<p><a href="#g1041906">Altering Subprograms</a></p>
</li>
<li>
<p><a href="#g1041928">Dropping Subprograms and Packages</a></p>
</li>
<li>
<p><a href="#g1041951">External Subprograms</a></p>
</li>
<li>
<p><a href="#CIHBDCEF">PL/SQL Function Result Cache</a></p>
</li>
<li>
<p><a href="#i1006718">PL/SQL Packages</a></p>
</li>
<li>
<p><a href="#g1041980">PL/SQL Object Size Limits</a></p>
</li>
<li>
<p><a href="#g1041988">Creating Packages</a></p>
</li>
<li>
<p><a href="#g1042025">Naming Packages and Package Objects</a></p>
</li>
<li>
<p><a href="#g1042030">Package Invalidations and Session State</a></p>
</li>
<li>
<p><a href="#i1020010">Packages Supplied with Oracle Database</a></p>
</li>
<li>
<p><a href="#i1006920">Overview of Bulk Binding</a></p>
</li>
<li>
<p><a href="#g1042051">When to Use Bulk Binds</a></p>
</li>
</ul>
<a id="i1006392"></a>
<div id="ADFNS316" class="sect3">
<h4 class="sect3">Naming Subprograms</h4>
<p><a id="sthref535"></a>Because a subprogram is stored in the database, it must be named. This distinguishes it from other stored subprograms and makes it possible for applications to invoke it. Each publicly-visible subprogram in a schema must have a unique name, and the name must be a legal PL/SQL identifier.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you plan to invoke a stored subprogram using a stub generated by SQL*Module, then the stored subprogram name must also be a legal identifier in the invoking host 3GL language, such as Ada or C.</div>
</div>
<!-- class="sect3" -->
<a id="i1006401"></a>
<div id="ADFNS317" class="sect3">
<h4 class="sect3">Subprogram Parameters</h4>
<p><a id="sthref536"></a>Stored subprograms can take parameters. In the procedure in <a href="#BABDBEHF">Example 6-4</a>, the department number is an input parameter that is used when the parameterized cursor <code dir="ltr">c1</code> is opened.</p>
<div id="ADFNS318" class="example">
<p class="titleinexample"><a id="BABDBEHF"></a>Example 6-4 Stored Procedure with Parameters</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE get_emp_names (
  <span class="bold">dept_num IN NUMBER</span>
)
IS
  emp_name  VARCHAR2(10);
  CURSOR    c1 (<span class="bold">dept_num</span> NUMBER) IS
                SELECT LAST_NAME FROM EMPLOYEES
                WHERE DEPARTMENT_ID = <span class="bold">dept_num</span>;
BEGIN
  OPEN c1(<span class="bold">dept_num</span>);
  LOOP
    FETCH c1 INTO emp_name;
    EXIT WHEN C1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(emp_name);
  END LOOP;
  CLOSE c1;
END;
/
</pre></div>
<!-- class="example" -->
<p>The formal parameters of a subprogram have three major attributes, described in <a href="#g1025069">Table 6-1</a>.</p>
<div id="ADFNS319" class="tblformal">
<p class="titleintable"><a id="sthref537"></a><a id="g1025069"></a>Table 6-1 Attributes of Subprogram Parameters</p>
<table class="cellalignment1278" title=" Attributes of Subprogram Parameters" summary="This table summarizes the attributes of procedure parameters." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t7">Parameter Attribute</th>
<th class="cellalignment1274" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t7" headers="r1c1-t7">
<p>Name</p>
</td>
<td class="cellalignment1275" headers="r2c1-t7 r1c2-t7">
<p>This must be a legal PL/SQL identifier.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t7" headers="r1c1-t7">
<p>Mode</p>
</td>
<td class="cellalignment1275" headers="r3c1-t7 r1c2-t7">
<p>This indicates whether the parameter is an input-only parameter (<code dir="ltr">IN</code>), an output-only parameter (<code dir="ltr">OUT</code>), or is both an input and an output parameter (<code dir="ltr">IN</code> <code dir="ltr">OUT</code>). If the mode is not specified, then <code dir="ltr">IN</code> is assumed.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t7" headers="r1c1-t7">
<p>Data Type</p>
</td>
<td class="cellalignment1275" headers="r4c1-t7 r1c2-t7">
<p>This is a standard PL/SQL data type.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="sthref538"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1041493">Parameter Modes</a></p>
</li>
<li>
<p><a href="#g1041507">Parameter Data Types</a></p>
</li>
<li>
<p><a href="#i1006528">%TYPE and %ROWTYPE Attributes</a></p>
</li>
<li>
<p><a href="#g1041556">Passing Composite Variables as Parameters</a></p>
</li>
<li>
<p><a href="#g1041561">Initial Parameter Values</a></p>
</li>
</ul>
<a id="g1041493"></a>
<div id="ADFNS320" class="sect4">
<h5 class="sect4">Parameter Modes</h5>
<p><a id="sthref539"></a><a id="sthref540"></a><a id="sthref541"></a>Parameter modes define the action of formal parameters. You can use the three parameter modes, <a id="sthref542"></a><code dir="ltr">IN</code> (the default), <a id="sthref543"></a><code dir="ltr">OUT</code>, and <a id="sthref544"></a><code dir="ltr">IN</code> <code dir="ltr">OUT</code>, with any subprogram. Avoid using the <code dir="ltr">OUT</code> and <code dir="ltr">IN</code> <code dir="ltr">OUT</code> modes with functions. Good programming practice dictates that a function returns a single value and does not change the values of variables that are not local to the subprogram.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS659" href="../../appdev.112/e25519/subprograms.htm#LNPLS659"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for details about parameter modes</div>
</div>
<!-- class="sect4" -->
<a id="g1041507"></a>
<div id="ADFNS322" class="sect4">
<h5 class="sect4">Parameter Data Types</h5>
<p><a id="sthref545"></a><a id="sthref546"></a><a id="sthref547"></a>The data type of a formal parameter consists of one of these:</p>
<ul>
<li>
<p>An unconstrained type name, such as <code dir="ltr">NUMBER</code> or <code dir="ltr">VARCHAR2</code>.</p>
</li>
<li>
<p>A type that is constrained using the <code dir="ltr">%TYPE</code> or <code dir="ltr">%ROWTYPE</code> attributes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Numerically constrained types such as <code dir="ltr">NUMBER</code>(<code dir="ltr">2</code>) or <code dir="ltr">VARCHAR2</code>(<code dir="ltr">20</code>) are not allowed in a parameter list.</div>
</li>
</ul>
</div>
<!-- class="sect4" -->
<a id="i1006528"></a>
<div id="ADFNS323" class="sect4">
<h5 class="sect4">%TYPE and %ROWTYPE Attributes</h5>
<p><a id="sthref548"></a><a id="sthref549"></a><a id="sthref550"></a><a id="sthref551"></a><a id="sthref552"></a>Use the type attributes <code dir="ltr">%TYPE</code> and <code dir="ltr">%ROWTYPE</code> to constrain the parameter. For example, the procedure heading in <a href="#BABDBEHF">Example 6-4</a> can be written as follows:</p>
<pre dir="ltr">
PROCEDURE get_emp_names(dept_num IN <span class="bold">EMPLOYEES.DEPARTMENT_ID%TYPE</span>)
</pre>
<p>This gives the <code dir="ltr">dept_num</code> parameter the same data type as the <code dir="ltr">DEPARTMENT_ID</code> column in the <code dir="ltr">EMPLOYEES</code> table. The column and table must be available when a declaration using <code dir="ltr">%TYPE</code> (or <code dir="ltr">%ROWTYPE</code>) is elaborated.</p>
<p>Using <code dir="ltr">%TYPE</code> is recommended, because if the type of the column in the table changes, it is not necessary to change the application code.</p>
<p>If the <code dir="ltr">get_emp_names</code> procedure is part of a package, you can use previously-declared public (package) variables to constrain its parameter data types. For example:</p>
<pre dir="ltr">
dept_number  NUMBER(2);
...
PROCEDURE get_emp_names(dept_num IN dept_number%TYPE);
</pre>
<p>Use the <code dir="ltr">%ROWTYPE</code> attribute to create a record that contains all the columns of the specified table. The procedure in <a href="#BABEHBIJ">Example 6-5</a> returns all the columns of the <code dir="ltr">EMPLOYEES</code> table in a PL/SQL record for the given employee ID.</p>
<div id="ADFNS324" class="example">
<p class="titleinexample"><a id="BABEHBIJ"></a>Example 6-5 %TYPE and %ROWTYPE Attributes</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE get_emp_rec (
  emp_number  IN  <span class="bold">EMPLOYEES.EMPLOYEE_ID%TYPE</span>,
  emp_info    OUT <span class="bold">EMPLOYEES%ROWTYPE</span>
)
IS
BEGIN
  SELECT * INTO emp_info
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_number;
END;
/
 
</pre>
<p>Invoke procedure from PL/SQL block:</p>
<pre dir="ltr">
DECLARE
  emp_row  <span class="bold">EMPLOYEES%ROWTYPE</span>;
BEGIN
  get_emp_rec(206, emp_row);
  DBMS_OUTPUT.PUT('EMPLOYEE_ID: ' || emp_row.EMPLOYEE_ID);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('FIRST_NAME: ' || emp_row.FIRST_NAME);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('LAST_NAME: ' || emp_row.LAST_NAME);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('EMAIL: ' || emp_row.EMAIL);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('PHONE_NUMBER: ' || emp_row.PHONE_NUMBER);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('HIRE_DATE: ' || emp_row.HIRE_DATE);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('JOB_ID: ' || emp_row.JOB_ID);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('SALARY: ' || emp_row.SALARY);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('COMMISSION_PCT: ' || emp_row.COMMISSION_PCT);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('MANAGER_ID: ' || emp_row.MANAGER_ID);
  DBMS_OUTPUT.NEW_LINE;
  DBMS_OUTPUT.PUT('DEPARTMENT_ID: ' || emp_row.DEPARTMENT_ID);
  DBMS_OUTPUT.NEW_LINE;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
EMPLOYEE_ID: 206
FIRST_NAME: William
LAST_NAME: Gietz
EMAIL: WGIETZ
PHONE_NUMBER: 515.123.8181
HIRE_DATE: 07-JUN-02
JOB_ID: AC_ACCOUNT
SALARY: 8300
COMMISSION_PCT:
MANAGER_ID: 205
DEPARTMENT_ID: 110
</pre></div>
<!-- class="example" -->
<p>Stored functions can return values that are declared using <code dir="ltr">%ROWTYPE</code>. For example:</p>
<pre dir="ltr">
FUNCTION get_emp_rec (dept_num IN <span class="bold">EMPLOYEES.DEPARTMENT_ID%TYPE</span>)
   RETURN <span class="bold">EMPLOYEES%ROWTYPE</span> IS ...
</pre></div>
<!-- class="sect4" -->
<a id="g1041556"></a>
<div id="ADFNS325" class="sect4">
<h5 class="sect4">Passing Composite Variables as Parameters</h5>
<p><a id="sthref553"></a><a id="sthref554"></a>You can pass PL/SQL composite variables (collections and records) as parameters to stored subprograms.</p>
<p>If the subprogram is remote, you must create a redundant loop-back DBLINK, so that when the remote subprogram compiles, the type checker that verifies the source uses the same definition of the user-defined composite variable type as the invoker uses.</p>
</div>
<!-- class="sect4" -->
<a id="g1041561"></a>
<div id="ADFNS326" class="sect4">
<h5 class="sect4">Initial Parameter Values</h5>
<p><a id="sthref555"></a><a id="sthref556"></a>Parameters can take initial values. Use either the assignment operator or the <code dir="ltr">DEFAULT</code> keyword to give a parameter an initial value. For example, these are equivalent:</p>
<pre dir="ltr">
PROCEDURE Get_emp_names (Dept_num IN NUMBER <span class="bold">:= 20</span>) IS ...
PROCEDURE Get_emp_names (Dept_num IN NUMBER <span class="bold">DEFAULT 20</span>) IS ...
</pre>
<p>When a parameter takes an initial value, it can be omitted from the actual parameter list when you invoke the subprogram. When you do specify the parameter value on the invocation, it overrides the initial value.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Unlike in an anonymous PL/SQL block, you do not use the keyword <code dir="ltr">DECLARE</code> before the declarations of variables, cursors, and exceptions in a stored subprogram. In fact, it is an error to use it.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="g1041863"></a>
<div id="ADFNS327" class="sect3">
<h4 class="sect3">Creating Subprograms</h4>
<p><a id="sthref557"></a>Use a text editor to write the subprogram. Then, using an interactive tool such as SQL*Plus, load the text file containing the procedure by entering:</p>
<pre dir="ltr">
@get_emp
</pre>
<p>This loads the procedure into the current schema from the <code dir="ltr">get_emp</code>.<code dir="ltr">sql</code> file (<code dir="ltr">.sql</code> is the default file extension). The slash (/) after the code is not part of the code, it only activates the loading of the procedure.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
When developing a subprogram, it is usually preferable to use the statement <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr">PROCEDURE</code> or <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr">FUNCTION</code>. This statement replaces any previous version of that subprogram in the same schema with the newer version, but without warning.</div>
<p>You can use either the keyword <code dir="ltr">IS</code> or <code dir="ltr">AS</code> after the subprogram parameter list.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS01370" href="../../appdev.112/e25519/create_function.htm#LNPLS01370"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of the <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> statement</p>
</li>
<li>
<p><a class="olink LNPLS01373" href="../../appdev.112/e25519/create_procedure.htm#LNPLS01373"><span class="italic">Oracle Database SQL Language Reference</span></a> for the syntax of the <code dir="ltr">CREATE</code> <code dir="ltr">PROCEDURE</code> statement</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="ADFNS328"></a>Privileges Needed</p>
<p><a id="sthref558"></a><a id="sthref559"></a>To create a subprogram, a package specification, or a package body, you must meet these prerequisites:</p>
<ul>
<li>
<p>You must have the <code dir="ltr">CREATE</code> <code dir="ltr">PROCEDURE</code> system privilege to create a subprogram or package in your schema, or the <code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege to create a subprogram or package in another user's schema. In either case, the package body must be created in the same schema as the package.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To create without errors (to compile the subprogram or package successfully) requires these additional privileges:
<ul>
<li>
<p>The owner of the subprogram or package must be explicitly granted the necessary object privileges for all objects referenced within the body of the code.</p>
</li>
<li>
<p>The owner cannot obtain required privileges through roles.</p>
</li>
</ul>
</div>
</li>
</ul>
<p>If the privileges of the owner of a subprogram or package change, then the subprogram must be reauthenticated before it is run. If a necessary privilege to a referenced object is revoked from the owner of the subprogram or package, then the subprogram cannot be run.</p>
<p>The <code dir="ltr">EXECUTE</code> privilege on a subprogram gives a user the right to run a subprogram owned by another user. Privileged users run the subprogram under the security domain of the owner of the subprogram. Therefore, users need not be granted the privileges to the objects referenced by a subprogram. This allows for more disciplined and efficient security strategies with database applications and their users. Furthermore, all subprograms and packages are stored in the data dictionary (in the <code dir="ltr">SYSTEM</code> tablespace). No quota controls the amount of space available to a user who creates subprograms and packages.</p>
</div>
<!-- class="sect3" -->
<a id="g1041906"></a>
<div id="ADFNS329" class="sect3">
<h4 class="sect3">Altering Subprograms</h4>
<p>To alter a subprogram, you must first drop it using the <code dir="ltr">DROP</code> <code dir="ltr">PROCEDURE</code> or <code dir="ltr">DROP</code> <code dir="ltr">FUNCTION</code> statement, then re-create it using the <code dir="ltr">CREATE</code> <code dir="ltr">PROCEDURE</code> or <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> statement. Alternatively, use the <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr">PROCEDURE</code> or <code dir="ltr">CREATE</code> <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> <code dir="ltr">FUNCTION</code> statement, which first drops the subprogram if it exists, then re-creates it as specified.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
The subprogram is dropped without warning.</div>
</div>
<!-- class="sect3" -->
<a id="g1041928"></a>
<div id="ADFNS330" class="sect3">
<h4 class="sect3">Dropping Subprograms and Packages</h4>
<p>A standalone subprogram, a standalone function, a package body, or an entire package can be dropped using the SQL statements <code dir="ltr">DROP</code> <code dir="ltr">PROCEDURE</code>, <code dir="ltr">DROP</code> <code dir="ltr">FUNCTION</code>, <code dir="ltr">DROP</code> <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code>, and <code dir="ltr">DROP</code> <code dir="ltr">PACKAGE</code>, respectively. A <code dir="ltr">DROP</code> <code dir="ltr">PACKAGE</code> statement drops both the specification and body of a package.</p>
<p>This statement drops the <code dir="ltr">Old_sal_raise</code> procedure in your schema:</p>
<pre dir="ltr">
DROP PROCEDURE Old_sal_raise;
</pre>
<p class="subhead2"><a id="ADFNS331"></a>Privileges Needed</p>
<p><a id="sthref560"></a><a id="sthref561"></a>To drop a subprogram or package, the subprogram or package must be in your schema, or you must have the <code dir="ltr">DROP</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> privilege. An individual subprogram within a package cannot be dropped; the containing package specification and body must be re-created without the subprograms to be dropped.</p>
</div>
<!-- class="sect3" -->
<a id="g1041951"></a>
<div id="ADFNS332" class="sect3">
<h4 class="sect3">External Subprograms</h4>
<p>A PL/SQL subprogram running on an Oracle Database instance can invoke an external subprogram written in a third-generation language (3GL). The 3GL subprogram runs in a separate address space from that of the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="adfns_externproc.htm#g1040439">Chapter 14, "Developing Applications with Multiple Programming Languages,"</a> for information about external subprograms</div>
</div>
<!-- class="sect3" -->
<a id="CIHBDCEF"></a>
<div id="ADFNS333" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">PL/SQL Function Result Cache</h4>
<p><a id="sthref562"></a><a id="sthref563"></a><a id="sthref564"></a><a id="sthref565"></a><a id="sthref566"></a>Using the PL/SQL function result cache can save significant space and time. Each time a <span class="bold">result-cached</span> PL/SQL function is invoked with different parameter values, those parameters and their result are stored in the cache. Subsequently, when the same function is invoked with the same parameter values, the result is retrieved from the cache, instead of being recomputed. Because the cache is stored in a shared global area (SGA), it is available to any session that runs your application.</p>
<p>If a database object that was used to compute a cached result is updated, the cached result becomes invalid and must be recomputed.</p>
<p>The best candidates for result-caching are functions that are invoked frequently but depend on information that changes infrequently or never.</p>
<p>For more information about the PL/SQL function result cache, see <a class="olink LNPLS00817" href="../../appdev.112/e25519/subprograms.htm#LNPLS00817"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect3" -->
<a id="i1006718"></a>
<div id="ADFNS334" class="sect3">
<h4 class="sect3">PL/SQL Packages</h4>
<p>A <span class="bold"><a id="sthref567"></a>package</span> is a collection of related program objects (for example, subprogram, variables, constants, cursors, and exceptions) stored as a unit in the database.</p>
<p>Using packages is an alternative to creating subprograms as standalone schema objects. Packages have many <a id="sthref568"></a>advantages over standalone subprograms. For example, they:</p>
<ul>
<li>
<p>Let you organize your application development more efficiently.</p>
</li>
<li>
<p>Let you grant privileges more efficiently.</p>
</li>
<li>
<p>Let you modify package objects without recompiling dependent schema objects.</p>
</li>
<li>
<p>Enable Oracle Database to read multiple package objects into memory at once.</p>
</li>
<li>
<p>Can contain global variables and cursors that are available to all subprograms in the package.</p>
</li>
<li>
<p>Let you <span class="glossaryterm"><a id="sthref569"></a><a id="sthref570"></a>overload</span> subprograms. Overloading a subprogram means creating multiple subprograms with the same name in the same package, each taking arguments of different number or data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00807" href="../../appdev.112/e25519/subprograms.htm#LNPLS00807"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about subprogram name overloading</div>
</li>
</ul>
<p>The <span class="glossaryterm"><a id="sthref571"></a>specification</span> part of a package declares the public types, variables, constants, and subprograms that are visible outside the immediate scope of the package. The <span class="glossaryterm"><a id="sthref572"></a>body</span> of a package defines both the objects declared in the specification and private objects that are not visible to applications outside the package.</p>
<p><a href="#BABEBDEG">Example 6-6</a> creates a package that contains one stored function and two stored procedures, and then invokes a procedure.</p>
<div id="ADFNS335" class="example">
<p class="titleinexample"><a id="BABEBDEG"></a>Example 6-6 Creating PL/SQL Package and Invoking Package Subprogram</p>
<pre dir="ltr">
-- Sequence that package function needs:
 
CREATE SEQUENCE emp_sequence
START WITH 8000
INCREMENT BY 10;
 
<span class="bold">-- Package specification:</span>
 
CREATE or REPLACE <span class="bold">PACKAGE employee_management</span> IS
  <span class="bold">FUNCTION hire_emp</span> (
  firstname  VARCHAR2,
  lastname   VARCHAR2,
  email      VARCHAR2,
  phone      VARCHAR2,
  hiredate   DATE,
  job        VARCHAR2,
  sal        NUMBER,
  comm       NUMBER,
  mgr        NUMBER,
  deptno     NUMBER
) RETURN NUMBER;
 
 <span class="bold">PROCEDURE fire_emp</span>(
    emp_id IN NUMBER
 );
 
 <span class="bold">PROCEDURE sal_raise</span> (
    emp_id IN NUMBER,
    sal_incr IN NUMBER
 );
END employee_management;
/
 
<span class="bold">-- Package body:</span>
 
CREATE or REPLACE <span class="bold">PACKAGE BODY employee_management</span> IS
  <span class="bold">FUNCTION hire_emp</span> (
    firstname  VARCHAR2,
    lastname   VARCHAR2,
    email      VARCHAR2,
    phone      VARCHAR2,
    hiredate   DATE,
    job        VARCHAR2,
    sal        NUMBER,
    comm       NUMBER,
    mgr        NUMBER,
    deptno     NUMBER
  ) RETURN NUMBER
 IS
   new_empno  NUMBER(10);
 BEGIN
   new_empno := emp_sequence.NEXTVAL;
 
    INSERT INTO EMPLOYEES (
      employee_id,
      first_name,
      last_name,
      email,
      phone_number,
      hire_date,
      job_id,
      salary,
      commission_pct,
      manager_id,
      department_id
    )
    VALUES (
      new_empno,
      firstname,
      lastname,
      email,
      phone,
      hiredate,  
      job,
      sal, 
      comm,
      mgr,
      deptno
    );

   RETURN (new_empno);
 END hire_emp;
 
 <span class="bold">PROCEDURE fire_emp</span> (
   emp_id IN NUMBER
 ) IS
 BEGIN
   DELETE FROM EMPLOYEES
   WHERE EMPLOYEE_ID = emp_id;
 
   IF SQL%NOTFOUND THEN
     raise_application_error(
       -20011,
       'Invalid Employee Number: ' || TO_CHAR(Emp_id)
     );
   END IF;
 END fire_emp;
 
 <span class="bold">PROCEDURE sal_raise</span> (
    emp_id IN NUMBER,
    sal_incr IN NUMBER
  ) IS
  BEGIN
    UPDATE EMPLOYEES
    SET SALARY = SALARY + sal_incr
    WHERE EMPLOYEE_ID = emp_id;
 
    IF SQL%NOTFOUND THEN
      raise_application_error(
        -20011,
        'Invalid Employee Number: ' || TO_CHAR(Emp_id)
      );
    END IF;
  END sal_raise;
END employee_management;
/
</pre>
<p>Invoke package procedures:</p>
<pre dir="ltr">
DECLARE
  empno  NUMBER(6);
  sal    NUMBER(6);
  temp   NUMBER(6);
BEGIN
  empno := <span class="bold">employee_management.hire_emp</span>(
            'John',
            'Doe',
            'john.doe@company.com',
            '555-0100',
            '20-SEP-07',
            'ST_CLERK',
            2500,
            0,
            100,
            20);
 
  DBMS_OUTPUT.PUT_LINE('New employee ID is ' || TO_CHAR(empno));
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="g1041980"></a>
<div id="ADFNS336" class="sect3">
<h4 class="sect3">PL/SQL Object Size Limits</h4>
<p><a id="sthref573"></a>The size limit for PL/SQL stored database objects such as <a id="sthref574"></a><a id="sthref575"></a><a id="sthref576"></a>subprograms, triggers, and packages is the size of the <span class="bold">Descriptive Intermediate Attributed Notation for Ada (DIANA)</span> code in the shared pool in bytes. The Linux and UNIX limit on the size of the flattened DIANA/code size is 64K but the limit might be 32K on desktop platforms.</p>
<p>The most closely related number that a user can access is the <code dir="ltr">PARSED_SIZE</code> in the static data dictionary view <code dir="ltr">*_OBJECT_SIZE</code>. That gives the size of the DIANA in bytes as stored in the <code dir="ltr">SYS.IDL_xxx$</code> tables. This is not the size in the shared pool. The size of the DIANA part of PL/SQL code (used during compilation) is significantly larger in the shared pool than it is in the system table.</p>
</div>
<!-- class="sect3" -->
<a id="g1041988"></a>
<div id="ADFNS337" class="sect3">
<h4 class="sect3">Creating Packages</h4>
<p><a id="sthref577"></a>Each part of a package is created with a different statement. Create the package specification using the <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> statement. The <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> statement declares public package objects.</p>
<p>To create a package body, use the <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code> statement. The <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code> statement defines the procedural code of the public subprograms declared in the package specification.</p>
<p>You can also define private, or local, package subprograms, and variables in a package body. These objects can only be accessed by other subprograms in the body of the same package. They are not visible to external users, regardless of the privileges they hold.</p>
<p>It is often more convenient to add the <code dir="ltr">OR</code> <code dir="ltr">REPLACE</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> or <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code> statements when you are first developing your application. The effect of this option is to drop the package or the package body without warning. The <code dir="ltr">CREATE</code> statements are:</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE Package_name AS ...
</pre>
<p>and</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE BODY Package_name AS ...
</pre>
<div id="ADFNS338" class="sect4"><a id="sthref578"></a>
<h5 class="sect4">Creating Package Objects</h5>
<p>The body of a package can contain:</p>
<ul>
<li>
<p>Subprograms declared in the package specification.</p>
</li>
<li>
<p>Definitions of cursors declared in the package specification.</p>
</li>
<li>
<p>Local subprograms, not declared in the package specification.</p>
</li>
<li>
<p>Local variables.</p>
</li>
</ul>
<p>Subprograms, cursors, and variables that are declared in the package specification are <span class="glossaryterm">global</span>. They can be invoked, or used, by external users that have <code dir="ltr">EXECUTE</code> permission for the package or that have <code dir="ltr">EXECUTE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> privileges.</p>
<p>When you create the package body, ensure that each subprogram that you define in the body has the same parameters, by name, data type, and mode, as the declaration in the package specification. For functions in the package body, the parameters and the return type must agree in name and type.</p>
</div>
<!-- class="sect4" -->
<div id="ADFNS339" class="sect4"><a id="sthref579"></a>
<h5 class="sect4">Privileges to Needed to Create or Drop Packages</h5>
<p><a id="sthref580"></a><a id="sthref581"></a><a id="sthref582"></a>The privileges required to create or drop a package specification or package body are the same as those required to create or drop a standalone subprogram. See <a href="#g1041863">"Creating Subprograms"</a> and <a href="#g1041928">"Dropping Subprograms and Packages"</a>.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="g1042025"></a>
<div id="ADFNS340" class="sect3">
<h4 class="sect3">Naming Packages and Package Objects</h4>
<p><a id="sthref583"></a>The names of a package and all public objects in the package must be unique within a given schema. The package specification and its body must have the same name. All package constructs must have unique names within the scope of the package, unless overloading of subprogram names is desired.</p>
</div>
<!-- class="sect3" -->
<a id="g1042030"></a>
<div id="ADFNS341" class="sect3">
<h4 class="sect3">Package Invalidations and Session State</h4>
<p><a id="sthref584"></a><a id="sthref585"></a><a id="sthref586"></a>Each session that references a package object has its own instance of the corresponding package, including persistent state for any public and private variables, cursors, and constants. If any of the session's instantiated packages (specification or body) are invalidated, then all package instances in the session are invalidated and recompiled. Therefore, the session state is lost for all package instances in the session.</p>
<p>When a package in a given session is invalidated, the session receives ORA-04068 the first time it attempts to use any object of the invalid package instance. The second time a session makes such a package call, the package is reinstantiated for the session without error. However, if you handle this error in your application, be aware of the following:</p>
<ul>
<li>
<p>For optimal performance, Oracle Database returns this error message only when the package state is discarded. When a subprogram in one package invokes a subprogram in another package, the session state is lost for both packages.</p>
</li>
<li>
<p>If a server session traps ORA-04068, then ORA-04068 is not raised for the client session. Therefore, when the client session attempts to use an object in the package, the package is not reinstantiated. To reinstantiate the package, the client session must either reconnect to the database or recompile the package.</p>
</li>
</ul>
<p>In <a href="#BABCFFEC">Example 6-7</a>, the <code dir="ltr">RAISE</code> statement raises the current exception, ORA-04068, which is the cause of the exception being handled, ORA-06508. ORA-04068 is not trapped.</p>
<div class="example">
<p class="titleinexample"><a id="BABCFFEC"></a>Example 6-7 Raising ORA-04068</p>
<pre dir="ltr">
PROCEDURE p IS
  package_exception EXCEPTION;
  PRAGMA EXCEPTION_INIT (package_exception, -6508);
BEGIN
 ...
EXCEPTION
  WHEN package_exception THEN
    <span class="bold">RAISE;</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#BABIFBBB">Example 6-8</a>, the <code dir="ltr">RAISE</code> statement raises the exception ORA-20001 in response to ORA-06508, instead of the current exception, ORA-04068. ORA-04068 is trapped. When this happens, the ORA-04068 error is masked, which stops the package from being reinstantiated.</p>
<div class="example">
<p class="titleinexample"><a id="BABIFBBB"></a>Example 6-8 Trapping ORA-04068</p>
<pre dir="ltr">
PROCEDURE p IS
  package_exception EXCEPTION;
  other_exception   EXCEPTION;
  PRAGMA EXCEPTION_INIT (package_exception, -6508);
  PRAGMA EXCEPTION_INIT (other_exception, -20001);
BEGIN
 ...
EXCEPTION
  WHEN package_exception THEN
    ...
    <span class="bold">RAISE other_exception;</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>In most production environments, DDL operations that can cause invalidations are usually performed during inactive working hours; therefore, this situation might not be a problem for end-user applications. However, if package invalidations are common in your system during working hours, then you might want to code your applications to handle this error when package calls are made.</p>
</div>
<!-- class="sect3" -->
<a id="i1020010"></a>
<div id="ADFNS342" class="sect3">
<h4 class="sect3">Packages Supplied with Oracle Database</h4>
<p><a id="sthref587"></a><a id="sthref588"></a>There are many packages provided with Oracle Database, either to extend the functionality of the database or to give PL/SQL access to SQL features. You can invoke these packages from your application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS139" href="../../appdev.112/e40758/intro.htm#ARPLS139"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for an overview of these Oracle Database packages</div>
</div>
<!-- class="sect3" -->
<a id="i1006920"></a>
<div id="ADFNS343" class="sect3">
<h4 class="sect3">Overview of Bulk Binding</h4>
<p><a id="sthref589"></a>Oracle Database uses two engines to run PL/SQL blocks and subprograms. The PL/SQL engine runs procedural statements, while the SQL engine runs SQL statements. During execution, every SQL statement causes a context switch between the two engines, resulting in performance overhead.</p>
<p>Performance can be improved substantially by minimizing the number of context switches required to run a particular block or subprogram. When a SQL statement runs inside a loop that uses collection elements as bind variables, the large number of context switches required by the block can cause poor performance. Collections include:</p>
<ul>
<li>
<p>Varrays</p>
</li>
<li>
<p>Nested tables</p>
</li>
<li>
<p>Index-by tables</p>
</li>
<li>
<p>Host arrays</p>
</li>
</ul>
<p><span class="glossaryterm">Binding</span> is the assignment of values to PL/SQL variables in SQL statements. <span class="glossaryterm">Bulk binding</span> is binding an entire collection at once. Bulk binds pass the entire collection back and forth between the two engines in a single operation.</p>
<p>Typically, using bulk binds improves performance for SQL statements that affect four or more database rows. The more rows affected by a SQL statement, the greater the performance gain from bulk binds.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This section provides an overview of bulk binds to help you decide whether to use them in your PL/SQL applications. For detailed information about using bulk binds, including ways to handle exceptions that occur in the middle of a bulk bind operation, see <a class="olink LNPLS01205" href="../../appdev.112/e25519/tuning.htm#LNPLS01205"><span class="italic">Oracle Database PL/SQL Language Reference.</span></a>
<p>Parallel DML statements are disabled with bulk binds.</p>
</div>
</div>
<!-- class="sect3" -->
<a id="g1042051"></a>
<div id="ADFNS344" class="sect3">
<h4 class="sect3">When to Use Bulk Binds</h4>
<p><a id="sthref590"></a>Consider using bulk binds to improve the performance of:</p>
<ul>
<li>
<p><a href="#CIHCHADH">DML Statements that Reference Collections</a></p>
</li>
<li>
<p><a href="#CIHCHIBG">SELECT Statements that Reference Collections</a></p>
</li>
<li>
<p><a href="#CIHCAGJE">FOR Loops that Reference Collections and Return DML</a></p>
</li>
</ul>
<a id="CIHCHADH"></a>
<div id="ADFNS345" class="sect4">
<h5 class="sect4">DML Statements that Reference Collections</h5>
<p><a id="sthref591"></a><a id="sthref592"></a><a id="sthref593"></a>A bulk bind, which uses the <code dir="ltr">FORALL</code> keyword, can improve the performance of <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> statements that reference collection elements.</p>
<p>The PL/SQL block in <a href="#BABDJIJG">Example 6-9</a> increases the salary for employees whose manager's ID number is 7902, 7698, or 7839, with and without bulk binds. Without bulk bind, PL/SQL sends a SQL statement to the SQL engine for each updated employee, leading to context switches that slow performance.</p>
<div id="ADFNS346" class="example">
<p class="titleinexample"><a id="BABDJIJG"></a>Example 6-9 DML Statements that Reference Collections</p>
<pre dir="ltr">
DECLARE
  TYPE numlist IS VARRAY (100) OF NUMBER;
  id NUMLIST := NUMLIST(7902, 7698, 7839);
BEGIN
  <span class="bold">-- Efficient method, using bulk bind:</span>
  
  <span class="bold">FORALL</span> i IN id.FIRST..id.LAST
  UPDATE EMPLOYEES
  SET SALARY = 1.1 * SALARY
  WHERE MANAGER_ID = id(i);
 
 <span class="bold">-- Slower method:</span>
 
 <span class="bold">FOR</span> i IN id.FIRST..id.LAST <span class="bold">LOOP</span>
    UPDATE EMPLOYEES
    SET SALARY = 1.1 * SALARY
    WHERE MANAGER_ID = id(i);
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CIHCHIBG"></a>
<div id="ADFNS347" class="sect4">
<h5 class="sect4">SELECT Statements that Reference Collections</h5>
<p><a id="sthref594"></a><a id="sthref595"></a><a id="sthref596"></a>The <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> clause can improve the performance of queries that reference collections. You can use <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> with tables of scalar values, or tables of <code dir="ltr">%TYPE</code> values.</p>
<p>The PL/SQL block in <a href="#BABGEDJB">Example 6-10</a> queries multiple values into PL/SQL tables, with and without bulk binds. Without bulk bind, PL/SQL sends a SQL statement to the SQL engine for each selected employee, leading to context switches that slow performance.</p>
<div id="ADFNS348" class="example">
<p class="titleinexample"><a id="BABGEDJB"></a>Example 6-10 SELECT Statements that Reference Collections</p>
<pre dir="ltr">
DECLARE
  TYPE var_tab IS TABLE OF VARCHAR2(20)
  INDEX BY PLS_INTEGER;
  
  empno    VAR_TAB;
  ename    VAR_TAB;
  counter  NUMBER;
  
  CURSOR c IS
    SELECT EMPLOYEE_ID, LAST_NAME
    FROM EMPLOYEES
    WHERE MANAGER_ID = 7698;
BEGIN
 <span class="bold">-- Efficient method, using bulk bind:</span>
 
 SELECT EMPLOYEE_ID, LAST_NAME <span class="bold">BULK COLLECT</span>
 INTO empno, ename
 FROM EMPLOYEES
 WHERE MANAGER_ID = 7698;
 
 <span class="bold">-- Slower method:</span>
 
 counter := 1;
 
 <span class="bold">FOR</span> rec IN c <span class="bold">LOOP</span>
    empno(counter) := rec.EMPLOYEE_ID;
    ename(counter) := rec.LAST_NAME;
    counter := counter + 1;
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CIHCAGJE"></a>
<div id="ADFNS99880" class="sect4">
<h5 class="sect4">FOR Loops that Reference Collections and Return DML</h5>
<p><a id="sthref597"></a><a id="sthref598"></a><a id="sthref599"></a>You can use the <code dir="ltr">FORALL</code> keyword with the <code dir="ltr">BULK</code> <code dir="ltr">COLLECT</code> <code dir="ltr">INTO</code> keywords to improve the performance of <code dir="ltr">FOR</code> loops that reference collections and return DML.</p>
<p>The PL/SQL block in <a href="#BABIBDGI">Example 6-11</a> updates the <code dir="ltr">EMPLOYEES</code> table by computing bonuses for a collection of employees. Then it returns the bonuses in a column called <code dir="ltr">bonus_list_inst</code>. The actions are performed with and without bulk binds. Without bulk bind, PL/SQL sends a SQL statement to the SQL engine for each updated employee, leading to context switches that slow performance.</p>
<div id="ADFNS350" class="example">
<p class="titleinexample"><a id="BABIBDGI"></a>Example 6-11 FOR Loops that Reference Collections and Return DML</p>
<pre dir="ltr">
DECLARE
  TYPE emp_list IS VARRAY(100) OF EMPLOYEES.EMPLOYEE_ID%TYPE;
  empids emp_list := emp_list(182, 187, 193, 200, 204, 206);
  
  TYPE bonus_list IS TABLE OF EMPLOYEES.SALARY%TYPE;
  bonus_list_inst  bonus_list;
  
BEGIN
  <span class="bold">-- Efficient method, using bulk bind:</span>
 
 <span class="bold">FORALL</span> i IN empids.FIRST..empids.LAST
 UPDATE EMPLOYEES
 SET SALARY = 0.1 * SALARY
 WHERE EMPLOYEE_ID = empids(i)
 <span class="bold">RETURNING SALARY BULK COLLECT INTO bonus_list_inst;</span>
 
 -- Slower method:
 
 <span class="bold">FOR</span> i IN empids.FIRST..empids.LAST <span class="bold">LOOP</span>
   UPDATE EMPLOYEES
   SET SALARY = 0.1 * SALARY
   WHERE EMPLOYEE_ID = empids(i)
   <span class="bold">RETURNING SALARY INTO bonus_list_inst(i);</span>
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1007026"></a>
<div id="ADFNS351" class="sect3">
<h4 class="sect3">Triggers</h4>
<p><a id="sthref600"></a>A trigger is a special kind of PL/SQL anonymous block. You can define triggers to fire before or after SQL statements, either on a statement level or for each row that is affected. You can also define <code dir="ltr">INSTEAD</code> <code dir="ltr">OF</code> triggers or system triggers (triggers on <code dir="ltr">DATABASE</code> and <code dir="ltr">SCHEMA</code>).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS020" href="../../appdev.112/e25519/triggers.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about triggers</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007058"></a>
<div id="ADFNS00902" class="sect1">
<h2 class="sect1">Compiling PL/SQL Subprograms for Native Execution</h2>
<p><a id="sthref601"></a><a id="sthref602"></a>You can speed up PL/SQL subprograms by compiling them into native code residing in shared libraries.</p>
<p>You can use native compilation with both the supplied packages and the subprograms you write yourself. Subprograms compiled this way work in all server environments, such as the shared server configuration (formerly known as multithreaded server) and Oracle Real Application Clusters (Oracle RAC).</p>
<p>This technique is most effective for computation-intensive subprograms that do not spend much time running SQL, because it can do little to speed up SQL statements invoked from these subprograms.</p>
<p>With Java, you can use the <code dir="ltr">ncomp</code> tool to compile your own packages and classes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink LNPLS01209" href="../../appdev.112/e25519/tuning.htm#LNPLS01209"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for details on PL/SQL native compilation</p>
</li>
<li>
<p><a class="olink JJDEV01200" href="../../java.112/e10588/chone.htm#JJDEV01200"><span class="italic">Oracle Database Java Developer's Guide</span></a> for details on Java native compilation</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1007323"></a>
<div id="ADFNS00903" class="sect1">
<h2 class="sect1">Cursor Variables</h2>
<p><a id="sthref603"></a>A cursor is a static object; a cursor variable is a pointer to a cursor. Because cursor variables are pointers, they can be passed and returned as parameters to subprograms. A cursor variable can also refer to different cursors in its lifetime.</p>
<p>Additional advantages of cursor variables include:</p>
<ul>
<li>
<p>Encapsulation</p>
<p>Queries are centralized in the stored subprogram that opens the cursor variable.</p>
</li>
<li>
<p>Easy maintenance</p>
<p>If you must change the cursor, then you only make the change in the stored subprogram, not in each application.</p>
</li>
<li>
<p>Convenient security</p>
<p>The user of the application is the user name used when the application connects to the server. The user must have <code dir="ltr">EXECUTE</code> permission on the stored subprogram that opens the cursor. But, the user need not have <code dir="ltr">READ</code> permission on the tables used in the query. Use this capability to limit access to the columns in the table and access to other stored subprograms.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00605" href="../../appdev.112/e25519/static.htm#LNPLS00605"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about cursor variables</div>
<p class="subhead2"><a id="sthref604"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1007342">Declaring and Opening Cursor Variables</a></p>
</li>
<li>
<p><a href="#g1042951">Examples of Cursor Variables</a></p>
</li>
</ul>
<a id="i1007342"></a>
<div id="ADFNS352" class="sect2">
<h3 class="sect2">Declaring and Opening Cursor Variables</h3>
<p><a id="sthref605"></a><a id="sthref606"></a>Memory is usually allocated for a cursor variable in the client application using the appropriate <code dir="ltr">ALLOCATE</code> statement. In Pro*C, use the <code dir="ltr">EXEC</code> <code dir="ltr">SQL</code> <code dir="ltr">ALLOCATE</code> <code dir="ltr"><span class="codeinlineitalic">cursor_name</span></code> statement. In OCI, use the Cursor Data Area.</p>
<p>You can also use cursor variables in applications that run entirely in a single server session. You can declare cursor variables in PL/SQL subprograms, open them, and use them as parameters for other PL/SQL subprograms.</p>
</div>
<!-- class="sect2" -->
<a id="g1042951"></a>
<div id="ADFNS353" class="sect2">
<h3 class="sect2">Examples of Cursor Variables</h3>
<p><a id="sthref607"></a>This section has these examples of cursor variable usage in PL/SQL:</p>
<ul>
<li>
<p><a href="#CIHJAEDI">Example 6-12, "Fetching Data with Cursor Variable"</a></p>
</li>
<li>
<p><a href="#CIHEFIIC">Example 6-13, "Cursor Variable with Discriminator"</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For additional cursor variable examples that use programmatic interfaces:
<ul>
<li>
<p><a class="olink LNPCB006" href="../../appdev.112/e10826/pco06pls.htm#LNPCB006"><span class="italic">Pro*COBOL Programmer's Guide</span></a></p>
</li>
<li>
<p><a class="olink LNOCI040" href="../../appdev.112/e10646/oci04sql.htm#LNOCI040"><span class="italic">Oracle Call Interface Programmer's Guide</span></a></p>
</li>
</ul>
</div>
<p><a href="#CIHJAEDI">Example 6-12</a> creates a package that defines a PL/SQL cursor variable type and two procedures, and then invokes the procedures from a PL/SQL block. The first procedure opens a cursor variable using a bind variable in the <code dir="ltr">WHERE</code> clause. The second procedure uses a cursor variable to fetch rows from the <code dir="ltr">EMPLOYEES</code> table.</p>
<div id="ADFNS354" class="example">
<p class="titleinexample"><a id="CIHJAEDI"></a>Example 6-12 Fetching Data with Cursor Variable</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE emp_data AS
  <span class="bold">TYPE emp_val_cv_type IS REF CURSOR</span>
  <span class="bold">RETURN EMPLOYEES%ROWTYPE;</span>
  
  PROCEDURE open_emp_cv (
    <span class="bold">emp_cv       IN OUT emp_val_cv_type</span>,
    dept_number  IN     EMPLOYEES.DEPARTMENT_ID%TYPE
  );
 
 PROCEDURE fetch_emp_data (
   <span class="bold">emp_cv   IN  emp_val_cv_type</span>,
   emp_row  OUT EMPLOYEES%ROWTYPE
 );
END emp_data;
/
CREATE OR REPLACE PACKAGE BODY emp_data AS
  PROCEDURE open_emp_cv (
    emp_cv       IN OUT emp_val_cv_type,
    dept_number  IN     EMPLOYEES.DEPARTMENT_ID%TYPE
  )
  IS
  BEGIN
    <span class="bold">OPEN emp_cv FOR</span>
    <span class="bold">SELECT * FROM EMPLOYEES</span>
    <span class="bold">WHERE DEPARTMENT_ID = dept_number</span>
    <span class="bold">ORDER BY last_name;</span>
  END open_emp_cv;
  
  PROCEDURE fetch_emp_data (
    emp_cv   IN  emp_val_cv_type,
    emp_row  OUT EMPLOYEES%ROWTYPE
  )
  IS
  BEGIN
    <span class="bold">FETCH emp_cv INTO emp_row;</span>
  END fetch_emp_data;
END emp_data;
/
 
</pre>
<p>Invoke package procedures:</p>
<pre dir="ltr">
DECLARE
  emp_curs     emp_data.emp_val_cv_type;
  dept_number  EMPLOYEES.DEPARTMENT_ID%TYPE;
  emp_row      EMPLOYEES%ROWTYPE;
  
BEGIN
  dept_number := 20;
  
  <span class="bold">-- Open cursor, using variable:</span>
 
 <span class="bold">emp_data.open_emp_cv(emp_curs, dept_number);</span>
 
 <span class="bold">-- Fetch and display data:</span>
 
 <span class="bold">LOOP</span>
   <span class="bold">emp_data.fetch_emp_data(emp_curs, emp_row);</span>
   <span class="bold">EXIT WHEN emp_curs%NOTFOUND;</span>
   DBMS_OUTPUT.PUT(emp_row.LAST_NAME || '  ');
   DBMS_OUTPUT.PUT_LINE(emp_row.SALARY);
 <span class="bold">END LOOP;</span>
END;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHEFIIC">Example 6-13</a>, the procedure opens a cursor variable for either the <code dir="ltr">EMPLOYEES</code> table or the <code dir="ltr">DEPARTMENTS</code> table, depending on the value of the parameter <code dir="ltr">discrim</code>. The anonymous block invokes the procedure to open the cursor variable for the <code dir="ltr">EMPLOYEES</code> table, but fetches from the <code dir="ltr">DEPARTMENTS</code> table, which raises the predefined exception <code dir="ltr">ROWTYPE_MISMATCH</code>.<a id="sthref608"></a></p>
<div id="ADFNS355" class="example">
<p class="titleinexample"><a id="CIHEFIIC"></a>Example 6-13 Cursor Variable with Discriminator</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE emp_dept_data AS
  TYPE cv_type IS REF CURSOR;
  
  PROCEDURE open_cv (
    cv       IN OUT cv_type,
    discrim  IN     POSITIVE
  );
  END emp_dept_data;
/
 
CREATE OR REPLACE PACKAGE BODY emp_dept_data AS
  PROCEDURE open_cv (
    cv      IN OUT cv_type,
    <span class="bold">discrim</span> IN     POSITIVE) IS
  BEGIN
    <span class="bold">IF discrim = 1 THEN</span>
    <span class="bold">OPEN cv FOR</span>
      <span class="bold">SELECT * FROM EMPLOYEES ORDER BY employee_id;</span>
    <span class="bold">ELSIF discrim = 2 THEN</span>
      <span class="bold">OPEN cv FOR</span>
        <span class="bold">SELECT * FROM DEPARTMENTS ORDER BY department_id;</span>
    <span class="bold">END IF;</span>
  END open_cv;
END emp_dept_data;
/
</pre>
<p>Invoke procedure <code dir="ltr">open_cv</code> from anonymous block:</p>
<pre dir="ltr">
DECLARE
  emp_rec   EMPLOYEES%ROWTYPE;
  dept_rec  DEPARTMENTS%ROWTYPE;
  cv        Emp_dept_data.CV_TYPE;
BEGIN
  <span class="bold">emp_dept_data.open_cv(cv, 1);  -- Open cv for EMPLOYEES fetch.</span>
  <span class="bold">FETCH cv INTO dept_rec;        -- Fetch from DEPARTMENTS.</span>
  DBMS_OUTPUT.PUT(dept_rec.DEPARTMENT_ID);
  DBMS_OUTPUT.PUT_LINE('  ' || dept_rec.LOCATION_ID);
<span class="bold">EXCEPTION</span>
  <span class="bold">WHEN ROWTYPE_MISMATCH THEN</span>
     BEGIN
       DBMS_OUTPUT.PUT_LINE
         ('Row type mismatch, fetching EMPLOYEES data ...');
       FETCH cv INTO emp_rec;
       DBMS_OUTPUT.PUT(emp_rec.DEPARTMENT_ID);
       DBMS_OUTPUT.PUT_LINE('  ' || emp_rec.LAST_NAME);
     END;
END;
/
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Row type mismatch, fetching EMPLOYEES data ...</span>
90  King
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007459"></a>
<div id="ADFNS00904" class="sect1">
<h2 class="sect1">Handling PL/SQL Compile-Time Errors</h2>
<p><a id="sthref609"></a><a id="sthref610"></a>To list compile-time errors, query the static data dictionary view <code dir="ltr">*_ERRORS</code>. From these views, you can retrieve original source code. The error text associated with the compilation of a subprogram is updated when the subprogram is replaced, and it is deleted when the subprogram is dropped.</p>
<p>SQL*Plus issues a warning message for compile-time errors, but for more information about them, you must use the command <code dir="ltr">SHOW</code> <code dir="ltr">ERRORS</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before issuing the <code dir="ltr">SHOW</code> <code dir="ltr">ERRORS</code> statement, use the <code dir="ltr">SET</code> <code dir="ltr">LINESIZE</code> statement to get long lines on output. The value 132 is usually a good choice. For example:
<pre dir="ltr">
SET LINESIZE 132
</pre></div>
<p><a href="#BABIFFGF">Example 6-14</a> has two compile-time errors: <code dir="ltr">WHER</code> should be <code dir="ltr">WHERE</code>, and <code dir="ltr">END</code> should be followed by a semicolon. <code dir="ltr">SHOW</code> <code dir="ltr">ERRORS</code> shows the line, column, and description of each error.</p>
<div id="ADFNS356" class="example">
<p class="titleinexample"><a id="BABIFFGF"></a>Example 6-14 Compile-Time Errors</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE fire_emp (
  emp_id NUMBER
) AS
BEGIN
  DELETE FROM EMPLOYEES
  <span class="bold">WHER</span> EMPLOYEE_ID = Emp_id;
<span class="bold">END</span>
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">Warning: Procedure created with compilation errors.</span>
 
</pre>
<p>Command:</p>
<pre dir="ltr">
<span class="bold">SHOW ERRORS;</span>
</pre>
<p>Result:</p>
<pre dir="ltr">
Errors for PROCEDURE FIRE_EMP:
 
LINE/COL ERROR
-------- -----------------------------------------------------------------
5/3      PL/SQL: SQL Statement ignored
<span class="bold">6</span>/8    PL/SQL: ORA-00933: SQL command not properly ended
<span class="bold">7</span>/3    PLS-00103: Encountered the symbol "end-of-file" when expecting
         one of the following:
         ; &lt;an identifier&gt; &lt;a double-quoted delimited-identifier&gt;
         current delete exists prior &lt;a single-quoted SQL string&gt;
         The symbol ";" was substituted for "end-of-file" to continue.
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN20251" href="../../server.112/e40402/statviews_2066.htm#REFRN20251"><span class="italic">Oracle Database Reference</span></a> for more information about the static data dictionary view <code dir="ltr">*_SOURCE</code></p>
</li>
<li>
<p><a class="olink SQPUG123" href="../../server.112/e16604/ch_twelve040.htm#SQPUG123"><span class="italic">SQL*Plus User's Guide and Reference</span></a> for more information about the <code dir="ltr">SHOW</code> <code dir="ltr">ERRORS</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1007532"></a>
<div id="ADFNS00905" class="sect1">
<h2 class="sect1">Handling Runtime PL/SQL Errors</h2>
<p><a id="sthref611"></a>Oracle Database allows user-defined errors in PL/SQL code to be handled so that user-specified error numbers and messages are returned to the client application, which can handle the error.</p>
<p>User-specified error messages are returned using the <code dir="ltr">RAISE_APPLICATION_ERROR</code> procedure. For example:</p>
<pre dir="ltr">
RAISE_APPLICATION_ERROR(error_number, 'text', keep_error_stack)
</pre>
<p>This procedure stops subprogram execution, rolls back any effects of the subprogram, and returns a user-specified error number and message (unless the error is trapped by an exception handler). <code dir="ltr">error_number</code> must be in the range of -20000 to -20999.</p>
<p>Use error number -20000 as a generic number for messages where it is important to relay information to the user, but having a unique error number is not required. <code dir="ltr">Text</code> must be a character expression, 2 KB or less (longer messages are ignored). To add the error to errors on the stack, set <code dir="ltr">Keep_error_stack</code> to <code dir="ltr">TRUE</code>; to replace the existing errors, set it to <code dir="ltr">FALSE</code> (the default).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Some <a id="sthref612"></a><a id="sthref613"></a>Oracle Database packages, such as <code dir="ltr">DBMS_OUTPUT</code>, <code dir="ltr">DBMS_DESCRIBE</code>, and <code dir="ltr">DBMS_ALERT</code>, use application error numbers in the range -20000 to -20005. See the descriptions of these packages for more information.</div>
<p>The <code dir="ltr">RAISE_APPLICATION_ERROR</code> procedure is often used in exception handlers or in the logic of PL/SQL code. For example, this exception handler selects the string for the associated user-defined error message and invokes the <code dir="ltr">RAISE_APPLICATION_ERROR</code> procedure:</p>
<pre dir="ltr">
...
WHEN NO_DATA_FOUND THEN
   SELECT Error_string INTO Message
   FROM Error_table,
   V$NLS_PARAMETERS V
   WHERE Error_number = -20101 AND Lang = v.value AND
      v.parameter = "NLS_LANGUAGE";
   Raise_application_error(-20101, Message);
...
</pre>
<p class="subhead2"><a id="sthref614"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1007573">Declaring Exceptions and Exception Handlers</a></p>
</li>
<li>
<p><a href="#g1042987">Unhandled Exceptions</a></p>
</li>
<li>
<p><a href="#g1042996">Handling Errors in Distributed Queries</a></p>
</li>
<li>
<p><a href="#i1007618">Handling Errors in Remote Subprograms</a></p>
</li>
</ul>
<a id="i1007573"></a>
<div id="ADFNS357" class="sect2">
<h3 class="sect2">Declaring Exceptions and Exception Handlers</h3>
<p><a id="sthref615"></a><a id="sthref616"></a><a id="sthref617"></a><a id="sthref618"></a>User-defined exceptions are explicitly defined and raised within the PL/SQL block, to process errors specific to the application. When an exception is raised, the usual execution of the PL/SQL block stops, and an exception handler is invoked. Specific exception handlers can be written to handle any internal or user-defined exception.</p>
<p>Application code can check for a condition that requires special attention using an <code dir="ltr">IF</code> statement. If there is an error condition, then two options are available:</p>
<ul>
<li>
<p>Enter a <a id="sthref619"></a><code dir="ltr">RAISE</code> statement that names the appropriate exception. A <code dir="ltr">RAISE</code> statement stops the execution of the subprogram, and control passes to an exception handler (if any).</p>
</li>
<li>
<p>Invoke the <code dir="ltr">RAISE_APPLICATION_ERROR</code> procedure to return a user-specified error number and message.</p>
</li>
</ul>
<p>You can also define an exception handler to handle user-specified error messages. For example, <a href="#i1007596">Figure 6-1</a> shows:</p>
<ul>
<li>
<p>An exception and associated exception handler in a subprogram</p>
</li>
<li>
<p>A conditional statement that checks for an error (such as transferring funds not available) and enters a user-specified error number and message within a trigger</p>
</li>
<li>
<p>How user-specified error numbers are returned to the invoking environment (in this case, a subprogram), and how that application can define an exception that corresponds to the user-specified error number</p>
</li>
</ul>
<p>Declare a user-defined exception in a subprogram or package body (private exceptions), or in the specification of a package (public exceptions). Define an exception handler in the body of a subprogram (standalone or package).</p>
<div id="ADFNS358" class="figure">
<p class="titleinfigure"><a id="i1007596"></a>Figure 6-1 Exceptions and User-Defined Errors</p>
<img width="458" height="315" src="img/adfns062.gif" alt="Description of Figure 6-1 follows" /><br />
<a id="sthref620" href="img_text/adfns062.htm">Description of "Figure 6-1 Exceptions and User-Defined Errors"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="g1042987"></a>
<div id="ADFNS359" class="sect2">
<h3 class="sect2">Unhandled Exceptions</h3>
<p><a id="sthref621"></a><a id="sthref622"></a>In database PL/SQL units, an unhandled user-error condition or internal error condition that is not trapped by an appropriate exception handler causes the implicit rollback of the program unit. If the program unit includes a <code dir="ltr">COMMIT</code> statement before the point at which the unhandled exception is observed, then the implicit rollback of the program unit can only be completed back to the previous <code dir="ltr">COMMIT</code>.</p>
<p>Additionally, unhandled exceptions in database-stored PL/SQL units propagate back to client-side applications that invoke the containing program unit. In such an application, only the application program unit invocation is rolled back (not the entire application program unit), because it is submitted to the database as a SQL statement.</p>
<p>If unhandled exceptions in database PL/SQL units are propagated back to database applications, modify the database PL/SQL code to handle the exceptions. Your application can also trap for unhandled exceptions when invoking database program units and handle such errors appropriately.</p>
</div>
<!-- class="sect2" -->
<a id="g1042996"></a>
<div id="ADFNS360" class="sect2">
<h3 class="sect2">Handling Errors in Distributed Queries</h3>
<p><a id="sthref623"></a><a id="sthref624"></a><a id="sthref625"></a>You can use a trigger or a stored subprogram to create a distributed query. This distributed query is decomposed by the local Oracle Database instance into a corresponding number of remote queries, which are sent to the remote nodes for execution. The remote nodes run the queries and send the results back to the local node. The local node then performs any necessary post-processing and returns the results to the user or application.</p>
<p>If a portion of a distributed statement fails, possibly from a constraint violation, then Oracle Database returns ORA-02055. Subsequent statements, or subprogram invocations, return ORA-02067 until a rollback or a rollback to savepoint is entered.</p>
<p>Design your application to check for any returned error messages that indicates that a portion of the distributed update has failed. If you detect a failure, rollback the entire transaction (or rollback to a savepoint) before allowing the application to proceed.</p>
</div>
<!-- class="sect2" -->
<a id="i1007618"></a>
<div id="ADFNS361" class="sect2">
<h3 class="sect2">Handling Errors in Remote Subprograms</h3>
<p><a id="sthref626"></a>When a subprogram is run locally or at a remote location, these types of exceptions can occur:<a id="sthref627"></a></p>
<ul>
<li>
<p>PL/SQL user-defined exceptions, which must be declared using the keyword <code dir="ltr">EXCEPTION</code></p>
</li>
<li>
<p>PL/SQL predefined exceptions, such as <code dir="ltr">NO_DATA_FOUND</code></p>
</li>
<li>
<p>SQL errors, such as ORA-00900</p>
</li>
<li>
<p>Application exceptions, which are generated using the <code dir="ltr">RAISE_APPLICATION_ERROR</code> procedure.</p>
</li>
</ul>
<p>When using local subprograms, all of these messages can be trapped by writing an exception handler, such as:</p>
<pre dir="ltr">
EXCEPTION
    WHEN ZERO_DIVIDE THEN
    /* Handle the exception */
</pre>
<p>The <code dir="ltr">WHEN</code> clause requires an exception name. If the exception that is raised does not have a name, such as those generated with <code dir="ltr">RAISE_APPLICATION_ERROR</code>, then one can be assigned using <code dir="ltr">PRAGMA_EXCEPTION_INIT</code>. For example:</p>
<pre dir="ltr">
DECLARE
    ...
    Null_salary EXCEPTION;
    PRAGMA EXCEPTION_INIT(Null_salary, -20101);
BEGIN
    ...
    RAISE_APPLICATION_ERROR(-20101, 'salary is missing');
    ...
EXCEPTION
    WHEN Null_salary THEN
        ...
</pre>
<p>When invoking a remote subprogram, exceptions are also handled by creating a local exception handler. The remote subprogram must return an error number to the local invoking subprogram, which then handles the exception, as shown in the previous example. Because PL/SQL user-defined exceptions always return ORA-06510 to the local subprogram, these exceptions cannot be handled. All other remote exceptions can be handled in the same manner as local exceptions.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007648"></a>
<div id="ADFNS99873" class="sect1">
<h2 class="sect1">Debugging Stored Subprograms</h2>
<p><a id="sthref628"></a>Compiling a stored subprogram involves fixing any syntax errors in the code. You might need to do additional debugging to ensure that the subprogram works correctly, performs well, and recovers from errors. Such debugging might involve:</p>
<ul>
<li>
<p>Adding extra output statements to verify execution progress and check data values at certain points within the subprogram.</p>
</li>
<li>
<p>Running a separate debugger to analyze execution in greater detail.</p>
</li>
</ul>
<p class="subhead2"><a id="sthref629"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHHJJIF">PL/Scope</a></p>
</li>
<li>
<p><a href="#CIHCCIAC">PL/SQL Hierarchical Profiler</a></p>
</li>
<li>
<p><a href="#g1878613">Oracle JDeveloper</a></p>
</li>
<li>
<p><a href="#g1878707">DBMS_OUTPUT Package</a></p>
</li>
<li>
<p><a href="#g1878754">Privileges for Debugging PL/SQL and Java Stored Subprograms</a></p>
</li>
<li>
<p><a href="#g1879028">Writing Low-Level Debugging Code</a></p>
</li>
<li>
<p><a href="#g1879071">DBMS_DEBUG_JDWP Package</a></p>
</li>
<li>
<p><a href="#g1879122">DBMS_DEBUG Package</a></p>
</li>
</ul>
<a id="CIHHJJIF"></a>
<div id="ADFNS362" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">PL/Scope</h3>
<p>PL/Scope is a compiler-driven tool that collects and organizes data about user-defined identifiers from PL/SQL source code. Because PL/Scope is a compiler-driven tool, you use it through interactive development environments (such as SQL Developer and JDeveloper), rather than directly.</p>
<p>PL/Scope enables the development of powerful and effective PL/Scope source code browsers that increase PL/SQL developer productivity by minimizing time spent browsing and understanding source code.</p>
<p>For more information about PL/Scope, see <a href="adfns_plscope.htm#g1010526">Chapter 7, "Using PL/Scope."</a></p>
</div>
<!-- class="sect2" -->
<a id="CIHCCIAC"></a>
<div id="ADFNS363" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">PL/SQL Hierarchical Profiler</h3>
<p>The PL/SQL hierarchical profiler reports the dynamic execution profile of your PL/SQL program, organized by subprogram calls. It accounts for SQL and PL/SQL execution times separately. Each subprogram-level summary in the dynamic execution profile includes information such as number of calls to the subprogram, time spent in the subprogram itself, time spent in the subprogram's subtree (that is, in its descendent subprograms), and detailed parent-children information.</p>
<p>You can browse the generated HTML reports in any browser. The browser's navigational capabilities, combined with well chosen links, provide a powerful way to analyze performance of large applications, improve application performance, and lower development costs.</p>
<p>For a detailed description of PL/SQL hierarchical profiler, see <a href="adfns_profiler.htm#CHDBHDFE">Chapter 8, "Using the PL/SQL Hierarchical Profiler."</a></p>
</div>
<!-- class="sect2" -->
<a id="g1878613"></a>
<div id="ADFNS364" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle JDeveloper</h3>
<p><a id="sthref630"></a>Recent releases of Oracle JDeveloper have extensive features for debugging PL/SQL, Java, and multi-language programs. You can get Oracle JDeveloper as part of various Oracle product suites. Often, a more recent release is available as a download at:</p>
<pre dir="ltr">
<a href="http://www.oracle.com/technetwork/developer-tools/jdev/downloads/index.html">http://www.oracle.com/technetwork/developer-tools/jdev/downloads/index.html</a>
</pre></div>
<!-- class="sect2" -->
<a id="g1878707"></a>
<div id="ADFNS365" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DBMS_OUTPUT Package</h3>
<p>You can also debug stored subprograms and triggers using the Oracle package <a id="sthref631"></a><code dir="ltr">DBMS_OUTPUT</code>. Put <code dir="ltr">PUT</code> and <code dir="ltr">PUT_LINE</code> statements in your code to output the value of variables and expressions to your terminal.</p>
</div>
<!-- class="sect2" -->
<a id="g1878754"></a>
<div id="ADFNS366" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Privileges for Debugging PL/SQL and Java Stored Subprograms</h3>
<p><a id="sthref632"></a><a id="sthref633"></a>Starting with Oracle Database&nbsp;10<span class="italic">g</span>, a new privilege model applies to debugging PL/SQL and Java code running within the database. This model applies whether you are using Oracle JDeveloper, Oracle Developer, or any of the various third-party PL/SQL or Java development environments, and it affects both the <code dir="ltr">DBMS_DEBUG</code> and <code dir="ltr">DBMS_DEBUG_JDWP</code> APIs.</p>
<p>For a session to connect to a debugger, the effective user at the time of the connect operation must have the <code dir="ltr">DEBUG</code> <code dir="ltr">CONNECT</code> <code dir="ltr">SESSION</code> system privilege. This effective user might be the owner of a DR subprogram involved in making the connect call.</p>
<p>When a debugger becomes connected to a session, the session login user and the enabled session-level roles are fixed as the privilege environment for that debugging connection. Any <code dir="ltr">DEBUG</code> or <code dir="ltr">EXECUTE</code> privileges needed for debugging must be granted to that combination of user and roles.</p>
<ul>
<li>
<p>To be able to display and change Java public variables or variables declared in a PL/SQL package specification, the debugging connection must be granted either <code dir="ltr">EXECUTE</code> or <code dir="ltr">DEBUG</code> privilege on the relevant code.</p>
</li>
<li>
<p>To be able to either display and change private variables or breakpoint and run code lines step by step, the debugging connection must be granted <code dir="ltr">DEBUG</code> privilege on the relevant code</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
The <code dir="ltr">DEBUG</code> privilege allows a debugging session to do anything that the subprogram being debugged could have done if that action had been included in its code.</div>
</li>
</ul>
<p>In addition to these privilege requirements, the ability to stop on individual code lines and debugger access to variables are allowed only in code compiled with debug information generated. Use the PL/SQL compilation parameter <code dir="ltr">PLSQL_DEBUG</code> and the <code dir="ltr">DEBUG</code> keyword on statements such as <code dir="ltr">ALTER</code> <code dir="ltr">PACKAGE</code> to control whether the PL/SQL compiler includes debug information in its results. If not, variables are not accessible, and neither stepping nor breakpoints stop on code lines. The PL/SQL compiler never generates debug information for code hidden with the PL/SQL <a id="sthref634"></a><code dir="ltr">wrap</code> utility.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS016" href="../../appdev.112/e25519/wrap.htm#LNPLS016"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>, for information about the <code dir="ltr">wrap</code> utility</div>
<p>The <code dir="ltr">DEBUG</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege is equivalent to the <code dir="ltr">DEBUG</code> privilege granted on all objects in the database. Objects owned by <code dir="ltr">SYS</code> are included if the value of the <code dir="ltr">O7_DICTIONARY_ACCESSIBILITY</code> parameter is <code dir="ltr">TRUE</code>.</p>
<p>A debug role mechanism is available to carry privileges needed for debugging that are not normally enabled in the session. See the documentation on the <code dir="ltr">DBMS_DEBUG</code> and <code dir="ltr">DBMS_DEBUG_JDWP</code> packages for details on how to specify a debug role and any necessary related password.</p>
<p>The <code dir="ltr">JAVADEBUGPRIV</code> role carries the <code dir="ltr">DEBUG</code> <code dir="ltr">CONNECT</code> <code dir="ltr">SESSION</code> and <code dir="ltr">DEBUG</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> privileges. Grant it only with the care those privileges warrant.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Granting <code dir="ltr">DEBUG</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> privilege, or granting <code dir="ltr">DEBUG</code> privilege on any object owned by <code dir="ltr">SYS</code>, means granting complete rights to the database.</div>
</div>
<!-- class="sect2" -->
<a id="g1879028"></a>
<div id="ADFNS367" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Writing Low-Level Debugging Code</h3>
<p><a id="sthref635"></a><a id="sthref636"></a>If you are writing code for part of a debugger, you might need to use packages such as <code dir="ltr">DBMS_DEBUG_JDWP</code> or <code dir="ltr">DBMS_DEBUG</code>.</p>
</div>
<!-- class="sect2" -->
<a id="g1879071"></a>
<div id="ADFNS368" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DBMS_DEBUG_JDWP Package</h3>
<p>The <a id="sthref637"></a><code dir="ltr">DBMS_DEBUG_JDWP</code> package, provided starting with Oracle Database 9<span class="italic">g</span> Release 2, provides a framework for multi-language debugging that is expected to supersede the <code dir="ltr">DBMS_DEBUG</code> package over time. It is especially useful for programs that combine PL/SQL and Java.</p>
</div>
<!-- class="sect2" -->
<a id="g1879122"></a>
<div id="ADFNS369" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">DBMS_DEBUG Package</h3>
<p><a id="sthref638"></a>The <code dir="ltr">DBMS_DEBUG</code> package, provided starting with Oracle8<span class="italic">i</span>, implements server-side debuggers and provides a way to debug server-side PL/SQL units. Several of the debuggers available, such as Oracle Procedure Builder and various third-party vendor solutions, use this API.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><span class="italic">Oracle Procedure Builder Developer's Guide</span></p>
</li>
<li>
<p><a class="olink ARPLS009" href="../../appdev.112/e40758/d_debug.htm#ARPLS009"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_DEBUG</code> package and associated privileges</p>
</li>
<li>
<p><a class="olink ARPLS036" href="../../appdev.112/e40758/d_output.htm#ARPLS036"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code dir="ltr">DBMS_OUTPUT</code> package and associated privileges</p>
</li>
<li>
<p>The Oracle JDeveloper documentation for information about using package <code dir="ltr">DBMS_DEBUG_JDWP</code></p>
</li>
<li>
<p><a class="olink SQLRF01603" href="../../server.112/e41084/statements_9013.htm#SQLRF01603"><span class="italic">Oracle Database SQL Language Reference</span></a> for more details on privileges</p>
</li>
<li>
<p><code dir="ltr"><a href="http://www.oracle.com/technetwork/database/features/plsql/index.html">http://www.oracle.com/technetwork/database/features/plsql/index.html</a></code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007682"></a>
<div id="ADFNS00906" class="sect1">
<h2 class="sect1">Invoking Stored Subprograms</h2>
<p><a id="sthref639"></a>Stored PL/SQL subprograms can be invoked from many different environments. For example:</p>
<ul>
<li>
<p>Interactively, using an Oracle Database tool</p>
</li>
<li>
<p>From the body of another subprogram</p>
</li>
<li>
<p>From within an application (such as a SQL*Forms or a precompiler)</p>
</li>
<li>
<p>From the body of a trigger</p>
</li>
</ul>
<p>Stored PL/SQL functions (but not procedures) can also be invoked from within SQL statements. For details, see <a href="#i1007943">"Invoking Stored PL/SQL Functions from SQL Statements"</a>.</p>
<p class="subhead2"><a id="sthref640"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1879512">Privileges Required to Invoke a Subprogram</a></p>
</li>
<li>
<p><a href="#g1043032">Invoking a Subprogram Interactively from Oracle Tools</a></p>
</li>
<li>
<p><a href="#g1043025">Invoking a Subprogram from Another Subprogram</a></p>
</li>
<li>
<p><a href="#g1043043">Invoking a Subprogram from a 3GL Application</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li><a class="olink LNPLS008" href="../../appdev.112/e25519/subprograms.htm#LNPLS008"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about invoking PL/SQL subprograms, including passing parameters.</li>
<li>
<p><a class="olink LNPLS2006" href="../../appdev.112/e25519/create_trigger.htm#LNPLS2006"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for information about coding the body of a trigger</p>
</li>
</ul>
</div>
<a id="g1879512"></a>
<div id="ADFNS370" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Privileges Required to Invoke a Subprogram</h3>
<p><a id="sthref641"></a><a id="sthref642"></a>You do not need privileges to invoke:</p>
<ul>
<li>
<p>Standalone subprograms that you own</p>
</li>
<li>
<p>Subprograms in packages that you own</p>
</li>
<li>
<p>Public standalone subprograms</p>
</li>
<li>
<p>Subprograms in public packages</p>
</li>
</ul>
<p>To invoke a standalone or package subprogram owned by another user:</p>
<ul>
<li>
<p>You must have the <code dir="ltr">EXECUTE</code> privilege for the standalone subprogram or for the package containing the subprogram, or you must have the <code dir="ltr">EXECUTE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege.</p>
</li>
<li>
<p>When running a remote subprogram, you must be granted the <code dir="ltr">EXECUTE</code> privilege or <code dir="ltr">EXECUTE</code> <code dir="ltr">ANY</code> <code dir="ltr">PROCEDURE</code> system privilege directly, not through a role.</p>
</li>
<li>
<p>You must include the name of the owner in the invocation. For example:</p>
<pre dir="ltr">
EXECUTE <span class="bold">jdoe</span>.Fire_emp (1043);
EXECUTE <span class="bold">jdoe</span>.Hire_fire.Fire_emp (1043);
</pre></li>
<li>
<p>If the subprogram is a <span class="glossaryterm"><a id="sthref643"></a><a id="sthref644"></a>definer's-rights (DR) subprogram</span>, then it runs with the privileges of the owner. The owner must have all the necessary object privileges for any referenced objects.</p>
</li>
<li>
<p>If the subprogram is an <span class="glossaryterm"><a id="sthref645"></a><a id="sthref646"></a>invoker's-rights (IR) subprogram</span>, then it runs with your privileges. You must have all the necessary object privileges for any referenced objects; that is, all objects accessed by the subprogram through external references that are resolved in your schema. You can hold these privileges either directly or through a role. Roles are enabled unless an IR subprogram is invoked directly or indirectly by a DR subprogram.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1043032"></a>
<div id="ADFNS371" class="sect2">
<h3 class="sect2">Invoking a Subprogram Interactively from Oracle Tools</h3>
<p><a id="sthref647"></a>You can invoke a subprogram interactively from an Oracle Database tool, such as SQL*Plus. <a href="#BABFDDBJ">Example 6-15</a> uses SQL*Plus to create a procedure and then invokes it in two different ways.</p>
<div id="ADFNS372" class="example">
<p class="titleinexample"><a id="BABFDDBJ"></a>Example 6-15 Invoking a Subprogram Interactively with SQL*Plus</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE salary_raise (
  employee  EMPLOYEES.EMPLOYEE_ID%TYPE,
  increase  EMPLOYEES.SALARY%TYPE
)
IS
BEGIN
  UPDATE EMPLOYEES
  SET SALARY = SALARY + increase
  WHERE EMPLOYEE_ID = employee;
END;
/
 
</pre>
<p>Invoke procedure from within PL/SQL block:</p>
<pre dir="ltr">
BEGIN
  <span class="bold">salary_raise(205, 200);</span>
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
PL/SQL procedure successfully completed.
 
</pre>
<p>Invoke procedure with <code dir="ltr">EXECUTE</code> statement:</p>
<pre dir="ltr">
<span class="bold">EXECUTE salary_raise(205, 200);</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr">
PL/SQL procedure successfully completed.
</pre></div>
<!-- class="example" -->
<p>Some interactive tools allow you to create <a id="sthref648"></a>session variables, which you can use for the duration of the session. Using SQL*Plus, <a href="#BABFJFJC">Example 6-16</a> creates, uses, and prints a session variable.</p>
<div id="ADFNS373" class="example">
<p class="titleinexample"><a id="BABFJFJC"></a>Example 6-16 Creating and Using a Session Variable with SQL*Plus</p>
<pre dir="ltr">
-- Create function for later use:

CREATE OR REPLACE FUNCTION get_job_id (
  emp_id  EMPLOYEES.EMPLOYEE_ID%TYPE
) RETURN EMPLOYEES.JOB_ID%TYPE
IS
  job_id  EMPLOYEES.JOB_ID%TYPE;
BEGIN
  SELECT JOB_ID INTO job_id
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_id;
 
  RETURN job_id;
END;
/
<span class="bold">-- Create session variable:</span>
 
<span class="bold">VARIABLE job VARCHAR2(10);</span>
 
<span class="bold">-- Run function and store returned value in session variable:</span>
 
<span class="bold">EXECUTE :job := get_job_id(204);</span>
 
PL/SQL procedure successfully completed.
 
</pre>
<p>SQL*Plus command:</p>
<pre dir="ltr">
<span class="bold">PRINT job;</span>
 
</pre>
<p>Result:</p>
<pre dir="ltr">
<span class="bold">JOB</span>
<span class="bold">--------------------------------</span>
<span class="bold">PR_REP</span>
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQPUG043" href="../../server.112/e16604/ch_twelve022.htm#SQPUG043"><span class="italic">SQL*Plus User's Guide and Reference</span></a> for information about the <code dir="ltr">EXECUTE</code> command</p>
</li>
<li>
<p>Your tools documentation for information about performing similar operations using your development tool</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="g1043025"></a>
<div id="ADFNS374" class="sect2">
<h3 class="sect2">Invoking a Subprogram from Another Subprogram</h3>
<p><a id="sthref649"></a><a id="sthref650"></a><a id="sthref651"></a>A subprogram or a trigger can invoke another stored subprogram. In <a href="#BABGJHII">Example 6-17</a>, the procedure <code dir="ltr">print_mgr_name</code> invokes the procedure <code dir="ltr">print_emp_name</code>.</p>
<p>Recursive subprogram invocations are allowed (that is, a subprogram can invoke itself).</p>
<div id="ADFNS375" class="example">
<p class="titleinexample"><a id="BABGJHII"></a>Example 6-17 Invoking a Subprogram from Within Another Subprogram</p>
<pre dir="ltr">
-- Create procedure that takes employee's ID and prints employee's name:
 
CREATE OR REPLACE <span class="bold">PROCEDURE print_emp_name</span> (
  emp_id  EMPLOYEES.EMPLOYEE_ID%TYPE
)
IS
  fname  EMPLOYEES.FIRST_NAME%TYPE;
  lname  EMPLOYEES.LAST_NAME%TYPE;
BEGIN
  SELECT FIRST_NAME, LAST_NAME
  INTO fname, lname
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_id;
 
  DBMS_OUTPUT.PUT_LINE (
    'Employee #' || emp_id || ':  ' || fname || ' ' || lname
  );
END;
/
 
-- Create procedure that takes employee's ID and prints manager's name:
 
CREATE OR REPLACE <span class="bold">PROCEDURE print_mgr_name</span> (
  emp_id  EMPLOYEES.EMPLOYEE_ID%TYPE
)
IS
  mgr_id  EMPLOYEES.MANAGER_ID%TYPE;
BEGIN
  SELECT MANAGER_ID
  INTO mgr_id
  FROM EMPLOYEES
  WHERE EMPLOYEE_ID = emp_id;
 
 DBMS_OUTPUT.PUT_LINE (
   'Manager of employee #' || emp_id || ' is:  '
 );
 
 <span class="bold">print_emp_name(mgr_id);</span>
END;
/
 
</pre>
<p>Invoke procedures:</p>
<pre dir="ltr">
BEGIN
  print_emp_name(200);
  print_mgr_name(200);
END;
/
 
</pre>
<p>Result:</p>
<pre dir="ltr">
Employee #200:  Jennifer Whalen
Manager of employee #200 is:
Employee #101:  Neena Kochhar
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="g1043043"></a>
<div id="ADFNS376" class="sect2">
<h3 class="sect2">Invoking a Subprogram from a 3GL Application</h3>
<p><a id="sthref652"></a>A 3GL database application, such as a precompiler or an OCI application, can invoke a subprogram from within its own code.<a id="sthref653"></a><a id="sthref654"></a></p>
<p>Assume that the procedure <code dir="ltr">Fire_emp1</code> was created as follows:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE fire_emp1 (Emp_id NUMBER) AS
  BEGIN
    DELETE FROM Emp_tab WHERE Empno = Emp_id;
  END;
</pre>
<p>To run a subprogram within the code of a precompiler application, you must use the <code dir="ltr">EXEC</code> call interface. For example, this statement invokes the <code dir="ltr">Fire_emp</code> procedure in the code of a precompiler application:</p>
<pre dir="ltr">
EXEC SQL EXECUTE
  BEGIN
    Fire_emp1(:Empnum);
  END;
END-EXEC;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI020" href="../../appdev.112/e10646/oci02bas.htm#LNOCI020"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for information about invoking PL/SQL subprograms from within 3GL applications</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007858"></a>
<div id="ADFNS00907" class="sect1">
<h2 class="sect1">Invoking Remote Subprograms</h2>
<p>Remote subprograms (standalone and package) can be invoked from within a subprogram, OCI application, or precompiler by specifying the remote subprogram name, a database link, and the parameters for the remote subprogram.</p>
<p>For example, this SQL*Plus statement invokes the procedure <code dir="ltr">fire_emp1</code>, which is located in the database and referenced by the local database link named <code dir="ltr">boston_server</code>:</p>
<pre dir="ltr">
EXECUTE fire_emp1@boston_server(1043);
</pre>
<p>You must specify values for all remote subprogram parameters, even if there are defaults. You cannot access remote package variables and constants.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<ul>
<li>
<p>Remote subprogram invocations use runtime binding. The user account to which you connect depends on the database link. (Stored subprograms use compile-time binding.)</p>
</li>
<li>
<p>If a local subprogram invokes a remote subprogram, and a time stamp mismatch is found during execution of the local subprogram, then the remote subprogram is not run, and the local subprogram is invalidated.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="sthref655"></a>Topics:</p>
<ul>
<li>
<p><a href="#BABGHIBF">Synonyms for Remote Subprograms</a></p>
</li>
<li>
<p><a href="#BABCDDHJ">Committing Transactions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007618">"Handling Errors in Remote Subprograms"</a> for information about exception handling when invoking remote subprograms</div>
<a id="BABGHIBF"></a>
<div id="ADFNS377" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Synonyms for Remote Subprograms</h3>
<p><a id="sthref656"></a><a id="sthref657"></a><a id="sthref658"></a><a id="sthref659"></a>You can create a synonym for a remote subprogram name and database link, and then use the synonym to invoke the subprogram. For example:</p>
<pre dir="ltr">
<span class="bold">CREATE SYNONYM synonym1 for fire_emp1@boston_server;</span>

EXECUTE <span class="bold">synonym1</span>(1043);
/
</pre>
<p>The synonym enables you to invoke the remote subprogram from an Oracle Database tool application, such as a SQL*Forms application, as well from within a subprogram, OCI application, or precompiler.</p>
<p>Synonyms provide both data independence and location transparency. Synonyms permit applications to function without modification regardless of which user owns the object and regardless of which database holds the object. However, synonyms are not a substitute for privileges on database objects. Appropriate privileges must be granted to a user before the user can use the synonym.</p>
<p>Because subprograms defined within a package are not individual objects (the package is the object), synonyms cannot be created for individual subprograms within a package.</p>
<p>If you do not want to use a synonym, you can create a local subprogram to invoke the remote subprogram. For example:</p>
<pre dir="ltr">
CREATE OR REPLACE PROCEDURE local_procedure
  (arg IN NUMBER)
AS
BEGIN
  fire_emp1@boston_server(arg);
END;
/
DECLARE
  arg NUMBER;
BEGIN
  local_procedure(arg);
END;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT711" href="../../server.112/e40540/schemaob.htm#CNCPT711"><span class="italic">Oracle Database Concepts</span></a> for general information about synonyms</p>
</li>
<li>
<p><a class="olink SQLRF01401" href="../../server.112/e41084/statements_7001.htm#SQLRF01401"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CREATE</code> <code dir="ltr">SYNONYM</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABCDDHJ"></a>
<div id="ADFNS378" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Committing Transactions</h3>
<p>All invocations to remotely stored subprograms are assumed to perform updates; therefore, this type of referencing always requires two-phase commit of that transaction (even if the remote subprogram is read-only). Furthermore, if a transaction that includes a remote subprogram invocation is rolled back, then the work done by the remote subprogram is also rolled back.</p>
<p>A subprogram invoked remotely can usually run a <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or <code dir="ltr">SAVEPOINT</code> statement, the same as a local subprogram. However, there are some differences in action:</p>
<ul>
<li>
<p>If the transaction was originated by a database that is not an Oracle database, as might be the case in XA applications, these operations are not allowed in the remote subprogram.</p>
</li>
<li>
<p>After doing one of these operations, the remote subprogram cannot start any distributed transactions of its own.</p>
</li>
<li>
<p>If the remote subprogram does not commit or roll back its work, the commit is done implicitly when the database link is closed. In the meantime, further invocations to the remote subprogram are not allowed because it is still considered to be performing a transaction.</p>
</li>
</ul>
<p>A <a id="sthref660"></a><a id="sthref661"></a><span class="glossaryterm">distributed transaction</span> modifies data on two or more databases. A distributed transaction is possible using a subprogram that includes two or more remote updates that access data on different databases. Statements in the construct are sent to the remote databases, and the execution of the construct succeeds or fails as a unit. If part of a distributed update fails and part succeeds, then a rollback (of the entire transaction or to a savepoint) is required to proceed. Consider this when creating subprograms that perform distributed updates.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007943"></a>
<div id="ADFNS00908" class="sect1">
<h2 class="sect1">Invoking Stored PL/SQL Functions from SQL Statements</h2>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Because SQL is a declarative language, rather than an imperative (or procedural) one, you cannot know how many times a function invoked from a SQL statement will run&mdash;even if the function is written in PL/SQL, an imperative language.
<p>If your application requires that a function be executed a certain number of times, do not invoke that function from a SQL statement. Use a cursor instead.</p>
<p>For example, if your application requires that a function be called for each selected row, then open a cursor, select rows from the cursor, and call the function for each row. This guarantees that the number of calls to the function is the number of rows fetched from the cursor.</p>
</div>
<p><a id="sthref662"></a><a id="sthref663"></a>To be invoked from a SQL statement, a stored PL/SQL function must be declared either at schema level or in a package specification.</p>
<p>These SQL statements can invoke stored PL/SQL functions:</p>
<ul>
<li>
<p><code dir="ltr">INSERT</code></p>
</li>
<li>
<p><code dir="ltr">UPDATE</code></p>
</li>
<li>
<p><code dir="ltr">DELETE</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code></p>
</li>
<li>
<p><code dir="ltr">CALL</code></p>
<p>(<code dir="ltr">CALL</code> can also invoke a stored PL/SQL procedure.)</p>
</li>
</ul>
<p>To invoke a PL/SQL subprogram from SQL, you must either own or have <code dir="ltr">EXECUTE</code> privileges on the subprogram. To select from a view defined with a PL/SQL function, you must have <code dir="ltr">SELECT</code> privileges on the view. No separate <code dir="ltr">EXECUTE</code> privileges are necessary to select from the view.</p>
<p>For general information about invoking subprograms, including passing parameters, see <a class="olink LNPLS008" href="../../appdev.112/e25519/subprograms.htm#LNPLS008"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p class="subhead2"><a id="sthref664"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHGEHJA">Why Invoke Stored PL/SQL Subprograms from SQL Statements?</a></p>
</li>
<li>
<p><a href="#CIHHBAJB">Where PL/SQL Functions Can Appear in SQL Statements</a></p>
</li>
<li>
<p><a href="#g1043220">When PL/SQL Functions Can Appear in SQL Expressions</a></p>
</li>
<li>
<p><a href="#g1043241">Controlling Side Effects</a></p>
</li>
</ul>
<a id="CIHGEHJA"></a>
<div id="ADFNS379" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Why Invoke Stored PL/SQL Subprograms from SQL Statements?</h3>
<p>Invoking PL/SQL subprograms in SQL statements can:</p>
<ul>
<li>
<p>Increase user productivity by extending SQL</p>
<p>Expressiveness of the SQL statement increases where activities are too complex, too awkward, or unavailable with SQL.</p>
</li>
<li>
<p>Increase query efficiency</p>
<p>Functions used in the <code dir="ltr">WHERE</code> clause of a query can filter data using criteria that must otherwise be evaluated by the application.</p>
</li>
<li>
<p>Manipulate character strings to represent special data types (for example, latitude, longitude, or temperature).</p>
</li>
<li>
<p>Provide parallel query execution</p>
<p>If the query is parallelized, then SQL statements in your PL/SQL subprogram might also be run in parallel (using the parallel query option).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHHBAJB"></a>
<div id="ADFNS380" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Where PL/SQL Functions Can Appear in SQL Statements</h3>
<p>A PL/SQL function can appear in a SQL statement wherever a SQL function or an expression can appear in a SQL statement. For example:</p>
<ul>
<li>
<p>Select list of the <code dir="ltr">SELECT</code> statement</p>
</li>
<li>
<p>Condition of the <code dir="ltr">WHERE</code> or <code dir="ltr">HAVING</code> clause</p>
</li>
<li>
<p><code dir="ltr">CONNECT</code> <code dir="ltr">BY</code>, <code dir="ltr">START</code> <code dir="ltr">WITH</code>, <code dir="ltr">ORDER</code> <code dir="ltr">BY</code>, or <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause</p>
</li>
<li>
<p><code dir="ltr">VALUES</code> clause of the <code dir="ltr">INSERT</code> statement</p>
</li>
<li>
<p><code dir="ltr">SET</code> clause of the <code dir="ltr">UPDATE</code> statement</p>
</li>
</ul>
<p>A PL/SQL table function (which returns a collection of rows) can appear in a <code dir="ltr">SELECT</code> statement instead of:</p>
<ul>
<li>
<p>Column name in the <code dir="ltr">SELECT</code> list</p>
</li>
<li>
<p>Table name in the <code dir="ltr">FROM</code> clause</p>
</li>
</ul>
<p>A PL/SQL function cannot appear in these contexts, which require unchanging definitions:</p>
<ul>
<li>
<p><code dir="ltr">CHECK</code> constraint clause of a <code dir="ltr">CREATE</code> or <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement</p>
</li>
<li>
<p>Default value specification for a column</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="g1043220"></a>
<div id="ADFNS381" class="sect2">
<h3 class="sect2">When PL/SQL Functions Can Appear in SQL Expressions</h3>
<p>To be invoked from a SQL expression, a PL/SQL function must satisfy these requirements:</p>
<ul>
<li>
<p>It must be a row function, not a column (group) function; that is, its argument cannot be an entire column.</p>
</li>
<li>
<p>Its formal parameters must be <code dir="ltr">IN</code> parameters, not <code dir="ltr">OUT</code> or <code dir="ltr">IN</code> <code dir="ltr">OUT</code> parameters.</p>
</li>
<li>
<p>Its formal parameters and its return value (if any) must have Oracle built-in data types (such as <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, or <code dir="ltr">NUMBER</code>), not PL/SQL data types (such as <code dir="ltr">BOOLEAN</code>, <code dir="ltr">RECORD</code>, or <code dir="ltr">TABLE</code>).</p>
<p>There is an exception to this rule: A formal parameter can have a PL/SQL data type if the corresponding actual parameter is implicitly converted to the data type of the formal parameter (as in <a href="#CIHCCGGF">Example 6-19</a>).</p>
</li>
</ul>
<p>The function in <a href="#CIHGHHCE">Example 6-18</a> satisfies the preceding requirements.</p>
<div id="ADFNS382" class="example">
<p class="titleinexample"><a id="CIHGHHCE"></a>Example 6-18 PL/SQL Function in SQL Expression (Follows Rules)</p>
<pre dir="ltr">
DROP TABLE payroll;  -- in case it exists
CREATE TABLE payroll (
  srate  NUMBER,
  orate  NUMBER,
  acctno NUMBER
);
 
CREATE OR REPLACE <span class="bold">FUNCTION gross_pay</span> (
  emp_id  <span class="bold">IN NUMBER</span>,
  st_hrs  <span class="bold">IN NUMBER</span> := 40,
  ot_hrs  <span class="bold">IN NUMBER</span> := 0
) <span class="bold">RETURN NUMBER</span>
IS
  st_rate  NUMBER;
  ot_rate  NUMBER;
BEGIN
  SELECT srate, orate
  INTO st_rate, ot_rate
  FROM payroll
  WHERE acctno = emp_id;
 
 RETURN st_hrs * st_rate + ot_hrs * ot_rate;
END gross_pay;
/
</pre></div>
<!-- class="example" -->
<p>In <a href="#CIHCCGGF">Example 6-19</a>, the SQL statement <code dir="ltr">CALL</code> invokes the PL/SQL function <code dir="ltr">f1</code>, whose formal parameter and return value have PL/SQL data type <code dir="ltr">PLS_INTEGER</code>. The <code dir="ltr">CALL</code> statement succeeds because the actual parameter, 2, is implicitly converted to the data type <code dir="ltr">PLS_INTEGER</code>. If the actual parameter had a value outside the range of <code dir="ltr">PLS_INTEGER</code>, the <code dir="ltr">CALL</code> statement would fail.</p>
<div id="ADFNS383" class="example">
<p class="titleinexample"><a id="CIHCCGGF"></a>Example 6-19 PL/SQL Function in SQL Expression (Exception to Rule)</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION f1 (
  b IN <span class="bold">PLS_INTEGER</span>
) RETURN <span class="bold">PLS_INTEGER</span>
IS
BEGIN
  RETURN
    CASE
      WHEN b &gt; 0  THEN  1
      WHEN b &lt;= 0 THEN -1
      ELSE NULL
    END;
END f1;
/
 
<span class="bold">VARIABLE x NUMBER;</span>
<span class="bold">CALL f1(b=&gt;2) INTO :x;</span>
PRINT x;
 
</pre>
<p>Result:</p>
<pre dir="ltr">
         X
----------
         1
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="g1043241"></a>
<div id="ADFNS384" class="sect2">
<h3 class="sect2">Controlling Side Effects</h3>
<p><a id="sthref665"></a><a id="sthref666"></a>The <span class="glossaryterm"><a id="sthref667"></a><a id="sthref668"></a>purity</span> of a stored subprogram refers to the side effects of that subprogram on database tables or package variables. Side effects can prevent the parallelization of a query, yield order-dependent (and therefore, indeterminate) results, or require that package state be maintained across user sessions. Various side effects are not allowed when a function is invoked from a SQL query or DML statement.</p>
<p>Before Oracle Database 8<span class="italic">g</span> Release 1, Oracle Database leveraged the PL/SQL compiler to enforce restrictions during the compilation of a stored subprogram or a SQL statement. As of Oracle Database 8<span class="italic">g</span> Release 1, the compile-time restrictions were relaxed, and a smaller set of restrictions are enforced during execution.</p>
<p>This change provides uniform support for stored subprograms written in PL/SQL, Java, and C, and it allows programmers the most flexibility possible.</p>
<p class="subhead2"><a id="sthref669"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1008107">Restrictions</a></p>
</li>
<li>
<p><a href="#BABIGDGE">Declaring a Function</a></p>
</li>
<li>
<p><a href="#g1042309">Parallel Query and Parallel DML</a></p>
</li>
<li>
<p><a href="#i1008174">PRAGMA RESTRICT_REFERENCES for Backward Compatibility</a></p>
</li>
</ul>
<a id="i1008107"></a>
<div id="ADFNS385" class="sect3">
<h4 class="sect3">Restrictions</h4>
<p>When a new SQL statement is run, checks are made to see if it is logically embedded within the execution of a running SQL statement. This occurs if the statement is run from a trigger or from a subprogram that was in turn invoked from the running SQL statement. In these cases, further checks determine if the new SQL statement is safe in the specific context.</p>
<p>These restrictions are enforced on subprograms:</p>
<ul>
<li>
<p>A subprogram invoked from a query (<code dir="ltr">SELECT</code> statement) or DML statement cannot end the current transaction, create or rollback to a savepoint, or <code dir="ltr">ALTER</code> the system or session.</p>
</li>
<li>
<p>A subprogram invoked from a query or parallelized DML statement cannot run a DML statement or otherwise modify the database.</p>
</li>
<li>
<p>A subprogram invoked from a DML statement cannot read or modify the particular table being modified by that DML statement.</p>
</li>
</ul>
<p>These restrictions apply regardless of what mechanism is used to run the SQL statement inside the subprogram or trigger. For example:</p>
<ul>
<li>
<p>They apply to a SQL statement invoked from PL/SQL, whether embedded directly in a subprogram or trigger body, run using the native dynamic mechanism (<code dir="ltr">EXECUTE</code> <code dir="ltr">IMMEDIATE</code>), or run using the <code dir="ltr">DBMS_SQL</code> package.</p>
</li>
<li>
<p>They apply to statements embedded in Java with SQLJ syntax or run using JDBC.</p>
</li>
<li>
<p>They apply to statements run with OCI using the callback context from within an "external" C function.</p>
</li>
</ul>
<p>You can avoid these restrictions if the execution of the new SQL statement is not logically embedded in the context of the running statement. PL/SQL autonomous transactions provide one escape (see <a href="adfns_sqlproc.htm#i1007356">"Autonomous Transactions"</a> ). Another escape is available using OCI from an external C function, if you create a new connection rather than using the handle available from the <code dir="ltr">OCIExtProcContext</code> argument.</p>
</div>
<!-- class="sect3" -->
<a id="BABIGDGE"></a>
<div id="ADFNS386" class="sect3">
<h4 class="sect3">Declaring a Function</h4>
<p>You can use the keywords <a id="sthref670"></a><a id="sthref671"></a><code dir="ltr">DETERMINISTIC</code> and <a id="sthref672"></a><a id="sthref673"></a><a id="sthref674"></a><code dir="ltr">PARALLEL_ENABLE</code> in the syntax for declaring a function. These are optimization hints that inform the query optimizer and other software components about:</p>
<ul>
<li>
<p>Functions that need not be invoked redundantly</p>
</li>
<li>
<p>Functions permitted within a parallelized query or parallelized DML statement</p>
</li>
</ul>
<p>Only functions that are <code dir="ltr">DETERMINISTIC</code> are allowed in function-based indexes and in certain snapshots and materialized views.</p>
<p>A deterministic function depends solely on the values passed into it as arguments and does not reference or modify the contents of package variables or the database or have other side-effects. Such a function produces the same result value for any combination of argument values passed into it.</p>
<p>You place the <code dir="ltr">DETERMINISTIC</code> keyword after the return value type in a declaration of the function. For example:</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION f1 (
  p1 NUMBER
) RETURN NUMBER <span class="bold">DETERMINISTIC</span>
IS
BEGIN
  RETURN p1 * 2;
END;
/
</pre>
<p>You might place this keyword in these places:</p>
<ul>
<li>
<p>On a function defined in a <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> statement</p>
</li>
<li>
<p>In a function declaration in a <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> statement</p>
</li>
<li>
<p>On a method declaration in a <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> statement</p>
</li>
</ul>
<p>Do not repeat the keyword on the function or method body in a <code dir="ltr">CREATE</code> <code dir="ltr">PACKAGE</code> <code dir="ltr">BODY</code> or <code dir="ltr">CREATE</code> <code dir="ltr">TYPE</code> <code dir="ltr">BODY</code> statement.</p>
<p>Certain performance optimizations occur on invocations of functions that are marked <code dir="ltr">DETERMINISTIC</code> without any other action being required. These features require that any function used with them be declared <code dir="ltr">DETERMINISTIC</code>:</p>
<ul>
<li>
<p>Any user-defined function used in a function-based index.</p>
</li>
<li>
<p>Any function used in a materialized view, if that view is to qualify for Fast Refresh or is marked <code dir="ltr">ENABLE</code> <code dir="ltr">QUERY</code> <code dir="ltr">REWRITE</code>.</p>
</li>
</ul>
<p>The preceding functions features attempt to use previously calculated results rather than invoking the function when it is possible to do so.</p>
<p>It is good programming practice to make functions that fall into these categories <code dir="ltr">DETERMINISTIC</code>:</p>
<ul>
<li>
<p>Functions used in a <code dir="ltr">WHERE</code>, <code dir="ltr">ORDER</code> <code dir="ltr">BY</code>, or <code dir="ltr">GROUP</code> <code dir="ltr">BY</code> clause</p>
</li>
<li>
<p>Functions that <code dir="ltr">MAP</code> or <code dir="ltr">ORDER</code> methods of a SQL type</p>
</li>
<li>
<p>Functions that help determine whether or where a row appears in a result set</p>
</li>
</ul>
<p>Keep these points in mind when you create <code dir="ltr">DETERMINISTIC</code> functions:</p>
<ul>
<li>
<p>The database cannot recognize if the action of the function is indeed deterministic. If the <code dir="ltr">DETERMINISTIC</code> keyword is applied to a function whose action is not truly deterministic, then the result of queries involving that function is unpredictable.</p>
</li>
<li>
<p>If you change the semantics of a <code dir="ltr">DETERMINISTIC</code> function and recompile it, then existing function-based indexes and materialized views report results for the prior version of the function. Thus, if you change the semantics of a function, you must manually rebuild any dependent function-based indexes and materialized views.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink LNPLS01370" href="../../appdev.112/e25519/create_function.htm#LNPLS01370"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> restrictions</div>
</div>
<!-- class="sect3" -->
<a id="g1042309"></a>
<div id="ADFNS387" class="sect3">
<h4 class="sect3">Parallel Query and Parallel DML</h4>
<p><a id="sthref675"></a><a id="sthref676"></a><a id="sthref677"></a><a id="sthref678"></a>Oracle Database's parallel execution feature divides the work of running a SQL statement across multiple processes. Functions invoked from a SQL statement that is run in parallel might have a separate copy run in each of these processes, with each copy invoked for only the subset of rows that are handled by that process.</p>
<p>Each process has its own copy of package variables. When parallel execution begins, these are initialized based on the information in the package specification and body as if a user is logging into the system; the values in package variables are not copied from the original login session. And changes made to package variables are not automatically propagated between the various sessions or back to the original session. <a id="sthref679"></a><a id="sthref680"></a>Java <code dir="ltr">STATIC</code> class attributes are similarly initialized and modified independently in each process. Because a function can use package (or Java <code dir="ltr">STATIC</code>) variables to accumulate some value across the various rows it encounters, Oracle Database cannot assume that it is safe to parallelize the execution of all user-defined functions.</p>
<p>For <code dir="ltr">SELECT</code> statements in Oracle Database versions before 8.1.5, the parallel query optimization allowed functions noted as both <code dir="ltr">RNPS</code> and <code dir="ltr">WNPS</code> in a <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> declaration to run in parallel. Functions defined with <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> statements had their code implicitly examined to determine if they were pure enough; parallelized execution might occur even though a pragma cannot be specified on these functions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008174">"PRAGMA RESTRICT_REFERENCES for Backward Compatibility"</a></div>
<p>For DML statements in Oracle Database versions before 8.1.5, the parallelization optimization looked to see if a function was noted as having all four of <code dir="ltr">RNDS</code>, <code dir="ltr">WNDS</code>, <code dir="ltr">RNPS</code> and <code dir="ltr">WNPS</code> specified in a <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> declaration; those functions that were marked as neither reading nor writing to either the database or package variables could run in parallel. Again, those functions defined with a <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> statement had their code implicitly examined to determine if they were actually pure enough; parallelized execution might occur even though a pragma cannot be specified on these functions.</p>
<p>Oracle Database versions 8.1.5 and later continue to parallelize those functions that earlier versions recognize as parallelizable. The <code dir="ltr">PARALLEL_ENABLE</code> keyword is the preferred way to mark your code as safe for parallel execution. This keyword is syntactically similar to <code dir="ltr">DETERMINISTIC</code> as described in <a href="#BABIGDGE">"Declaring a Function"</a>; it is placed after the return value type in a declaration of the function, as in:</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION f1 (
  p1 NUMBER
) RETURN NUMBER <span class="bold">PARALLEL_ENABLE</span>
IS
BEGIN
  RETURN p1 * 2;
END;
/
</pre>
<p>A PL/SQL function defined with <code dir="ltr">CREATE</code> <code dir="ltr">FUNCTION</code> might still be run in parallel without any explicit declaration that it is safe to do so, if the system can determine that it neither reads nor writes package variables nor invokes any function that might do so. A Java method or C function is never seen by the system as safe to run in parallel, unless the programmer explicitly indicates <code dir="ltr">PARALLEL_ENABLE</code> on the call specification, or provides a <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> indicating that the function is sufficiently pure.</p>
<p>An additional runtime restriction is imposed on functions run in parallel as part of a parallelized DML statement. Such a function is not permitted to in turn run a DML statement; it is subject to the same restrictions that are enforced on functions that are run inside a query (<code dir="ltr">SELECT</code>) statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008107">Restrictions</a></div>
</div>
<!-- class="sect3" -->
<a id="i1008174"></a>
<div id="ADFNS388" class="sect3">
<h4 class="sect3">PRAGMA RESTRICT_REFERENCES for Backward Compatibility</h4>
<p><a id="sthref681"></a><a id="sthref682"></a>In Oracle Database versions before 8.1.5 (Oracle8<span class="italic">i</span>), programmers used <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> to assert the purity level of a subprogram. In subsequent versions, use the hints <code dir="ltr">PARALLEL_ENABLE</code> and <code dir="ltr">DETERMINISTIC</code>, instead, to communicate subprogram purity to Oracle Database.</p>
<p>You can remove <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> from your code. However, this pragma remains available for backward compatibility in these situations:</p>
<ul>
<li>
<p>When it is impossible or impractical to edit existing code to completely remove <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code>.</p>
<p>For example, if subprogram S1 depends on subprogram S2, and you do not remove the pragma from S1, then you might need the pragma in S2 to compile S1.</p>
</li>
<li>
<p>When replacing <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> in existing code with hints <code dir="ltr">PARALLEL_ENABLE</code> and <code dir="ltr">DETERMINISTIC</code> would negatively affect the action of new, dependent code. (Use <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> to preserve the action of the existing code.)</p>
</li>
</ul>
<p>An existing PL/SQL application can thus continue using the pragma even on new functionality, to ease integration with the existing code. Do not use the pragma in a new application.</p>
<p>If you use <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code>, place it in a package specification, not in a package body. It must follow the declaration of a subprogram, but it need not follow immediately. Only one pragma can reference a given subprogram declaration.</p>
<p>To code the <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code>, use this syntax:</p>
<pre dir="ltr">
PRAGMA RESTRICT_REFERENCES ( 
    Function_name, WNDS [, WNPS] [, RNDS] [, RNPS] [, TRUST] ); 
</pre>
<p>Where:</p>
<div class="inftblinformal">
<table class="cellalignment1273" title="RESTRICT_REFERENCES keywords" summary="This table summarizes the options of the RESTRICT_REFERENCES pragma." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t40">Option</th>
<th class="cellalignment1274" id="r1c2-t40">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t40" headers="r1c1-t40"><code dir="ltr">WNDS</code></td>
<td class="cellalignment1275" headers="r2c1-t40 r1c2-t40">The subprogram writes no database state (does not modify database tables).</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t40" headers="r1c1-t40"><code dir="ltr">RNDS</code></td>
<td class="cellalignment1275" headers="r3c1-t40 r1c2-t40">The subprogram reads no database state (does not query database tables).</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t40" headers="r1c1-t40"><code dir="ltr">WNPS</code></td>
<td class="cellalignment1275" headers="r4c1-t40 r1c2-t40">The subprogram writes no package state (does not change the values of package variables).</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t40" headers="r1c1-t40"><code dir="ltr">RNPS</code></td>
<td class="cellalignment1275" headers="r5c1-t40 r1c2-t40">The subprogram reads no package state (does not reference the values of package variables)</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r6c1-t40" headers="r1c1-t40"><code dir="ltr">TRUST</code></td>
<td class="cellalignment1275" headers="r6c1-t40 r1c2-t40">The other restrictions listed in the pragma are not enforced; they are simply assumed to be true. This allows easy invocation from functions that have <code dir="ltr">RESTRICT_REFERENCES</code> declarations to those that do not.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>You can pass the arguments in any order. If any SQL statement inside the subprogram body violates a rule, then you get an error when the statement is parsed.</p>
<p>In <a href="#CIHEIHCD">Example 6-20</a>, the function <code dir="ltr">compound_</code> neither reads nor writes database or package state; therefore, you can assert the maximum purity level. Always assert the highest purity level that a subprogram allows, so that the PL/SQL compiler never rejects the subprogram unnecessarily.</p>
<div id="ADFNS389" class="example">
<p class="titleinexample"><a id="CIHEIHCD"></a>Example 6-20 PRAGMA RESTRICT_REFERENCES</p>
<pre dir="ltr">
DROP TABLE accounts; -- in case it exists
CREATE TABLE accounts (
  acctno   INTEGER,
  balance  NUMBER
);
 
INSERT INTO accounts (acctno, balance)
VALUES (12345, 1000.00);
 
CREATE OR REPLACE PACKAGE finance AS
  <span class="bold">FUNCTION compound_</span> (
    years  IN NUMBER,
    amount IN NUMBER,
    rate   IN NUMBER
   ) RETURN NUMBER;
  <span class="bold">PRAGMA RESTRICT_REFERENCES (compound_, WNDS, WNPS, RNDS, RNPS)</span>;
END finance;
/
CREATE PACKAGE BODY finance AS
  <span class="bold">FUNCTION compound_</span> (
    years  IN NUMBER,
    amount IN NUMBER,
    rate   IN NUMBER
   ) RETURN NUMBER
   IS
   BEGIN
     RETURN amount * POWER((rate / 100) + 1, years);
   END compound_;
  <span class="bold">-- No pragma in package body</span>
END finance;
/
DECLARE
  interest NUMBER;
BEGIN
  SELECT finance.compound_(5, 1000, 6)
  INTO interest
  FROM accounts
  WHERE acctno = 12345;
END;
/
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="sthref683"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1041703">Using the Keyword TRUST</a></p>
</li>
<li>
<p><a href="#g1041730">Differences between Static and Dynamic SQL Statements</a></p>
</li>
<li>
<p><a href="#g1041754">Overloading Package Functions</a></p>
</li>
</ul>
<a id="g1041703"></a>
<div id="ADFNS390" class="sect4">
<h5 class="sect4">Using the Keyword TRUST</h5>
<p><a id="sthref684"></a>When <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT</code> <code dir="ltr">REFERENCES</code> includes the keyword <code dir="ltr">TRUST</code>, the restrictions listed in the pragma are assumed to be true, and not enforced.</p>
<p>When you invoke a subprogram that is in a section of code that does not use pragmas (such as a Java method), from a section of PL/SQL code that does use pragmas, specify <code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT</code> <code dir="ltr">REFERENCES</code> with <code dir="ltr">TRUST</code> for either the invoked subprogram or the invoking subprogram.</p>
<p>In both <a href="#BABDCDFI">Example 6-21</a> and <a href="#BABBAGBC">Example 6-22</a>, the PL/SQL function <code dir="ltr">f</code> invokes the Java procedure <code dir="ltr">java_sleep</code>. In <a href="#BABDCDFI">Example 6-21</a>, this is possible because <code dir="ltr">java_sleep</code> is declared to be <code dir="ltr">WNDS</code> with <code dir="ltr">TRUST</code>. In <a href="#BABBAGBC">Example 6-22</a>, it is possible because <code dir="ltr">f</code> is declared to be <code dir="ltr">WNDS</code> with <code dir="ltr">TRUST</code>, which allows it to invoke any subprogram.</p>
<div id="ADFNS391" class="example">
<p class="titleinexample"><a id="BABDCDFI"></a>Example 6-21 PRAGMA RESTRICT REFERENCES with TRUST on Invokee</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE p IS
  <span class="bold">PROCEDURE java_sleep</span> (milli_seconds IN NUMBER)
  AS LANGUAGE JAVA NAME 'java.lang.Thread.sleep(long)';
  <span class="bold">PRAGMA RESTRICT_REFERENCES(java_sleep,WNDS,TRUST)</span>;
  
  FUNCTION f (n NUMBER) RETURN NUMBER;
END p;
/
CREATE OR REPLACE PACKAGE BODY p IS
  <span class="bold">FUNCTION f</span> (
    n NUMBER
   ) RETURN NUMBER
   IS
   BEGIN
     <span class="bold">java_sleep(n);</span>
     RETURN n;
   END f;
END p;
/
</pre></div>
<!-- class="example" -->
<div id="ADFNS392" class="example">
<p class="titleinexample"><a id="BABBAGBC"></a>Example 6-22 PRAGMA RESTRICT REFERENCES with TRUST on Invoker</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE p IS
  PROCEDURE java_sleep (milli_seconds IN NUMBER)
  AS LANGUAGE JAVA NAME 'java.lang.Thread.sleep(long)';
  
  <span class="bold">FUNCTION f</span> (n NUMBER) RETURN NUMBER;
  <span class="bold">PRAGMA RESTRICT_REFERENCES(f,WNDS,TRUST);</span>
END p;
/
CREATE OR REPLACE PACKAGE BODY p IS
  <span class="bold">FUNCTION f</span> (
    n NUMBER
  ) RETURN NUMBER
  IS
  BEGIN
    <span class="bold">java_sleep(n);</span>
     RETURN n;
  END f;
END p;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="g1041730"></a>
<div id="ADFNS393" class="sect4">
<h5 class="sect4">Differences between Static and Dynamic SQL Statements</h5>
<p><a id="sthref685"></a>Static <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> statements do not violate <code dir="ltr">RNDS</code><a id="sthref686"></a><a id="sthref687"></a><a id="sthref688"></a><a id="sthref689"></a> if these statements do not explicitly read any database states, such as columns of a table. However, dynamic <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> statements always violate <code dir="ltr">RNDS</code>, regardless of whether the statements explicitly read database states.</p>
<p>This <code dir="ltr">INSERT</code> statement violates <code dir="ltr">RNDS</code> if it is executed dynamically, but it does not violate <code dir="ltr">RNDS</code> if it is executed statically.</p>
<pre dir="ltr">
INSERT INTO my_table values(3, 'BOB'); 
</pre>
<p>This <code dir="ltr">UPDATE</code> statement always violates <code dir="ltr">RNDS</code> statically and dynamically, because it explicitly reads the column <code dir="ltr">name</code> of <code dir="ltr">my_table</code>.</p>
<pre dir="ltr">
UPDATE my_table SET id=777 WHERE name='BOB';
</pre></div>
<!-- class="sect4" -->
<a id="g1041754"></a>
<div id="ADFNS394" class="sect4">
<h5 class="sect4">Overloading Package Functions</h5>
<p>If a subprogram is overloaded, <a id="sthref690"></a><code dir="ltr">PRAGMA</code> <code dir="ltr">RESTRICT_REFERENCES</code> applies only to the most recently declared version.</p>
<p>In <a href="#BABGEAJF">Example 6-23</a>, the pragma applies to the second declaration of <code dir="ltr">valid</code>.</p>
<div id="ADFNS395" class="example">
<p class="titleinexample"><a id="BABGEAJF"></a>Example 6-23 Overloaded Package Function with PRAGMA RESTRICT_REFERENCES</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE tests AS
  FUNCTION valid (x NUMBER) RETURN CHAR;
  <span class="bold">FUNCTION valid (x DATE) RETURN CHAR;</span>
  <span class="bold">PRAGMA RESTRICT_REFERENCES (valid, WNDS);</span>
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008519"></a>
<div id="ADFNS00909" class="sect1">
<h2 class="sect1">Returning Large Amounts of Data from a Function</h2>
<p><a id="sthref691"></a>In a data warehousing environment, you might use PL/SQL functions to transform large amounts of data. Perhaps the data is passed through a series of transformations, each performed by a different function. PL/SQL table functions let you perform such transformations without significant memory overhead or the need to store the data in tables between each transformation stage. These functions can accept and return multiple rows, can return rows as they are ready rather than all at once, and can be parallelized.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01210" href="../../appdev.112/e25519/tuning.htm#LNPLS01210"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about performing multiple transformations with pipelined table functions</div>
</div>
<!-- class="sect1" -->
<a id="i1008575"></a>
<div id="ADFNS00910" class="sect1">
<h2 class="sect1">Coding Your Own Aggregate Functions</h2>
<p><a id="sthref692"></a><a id="sthref693"></a>To analyze a set of rows and compute a result value, you can code your own aggregate function that works the same as a SQL aggregate function like <code dir="ltr">SUM</code>:</p>
<ul>
<li>
<p>Define an ADT that defines these member functions:</p>
<ul>
<li>
<p><code dir="ltr">ODCIAggregateInitialize</code></p>
</li>
<li>
<p><code dir="ltr">ODCIAggregateIterate</code></p>
</li>
<li>
<p><code dir="ltr">ODCIAggregateMerge</code></p>
</li>
<li>
<p><code dir="ltr">ODCIAggregateTerminate</code></p>
</li>
</ul>
</li>
<li>
<p>Code the member functions. In particular, <code dir="ltr">ODCIAggregateIterate</code> accumulates the result as it is invoked for each row that is processed. Store any intermediate results using the attributes of the ADT.</p>
</li>
<li>
<p>Create the aggregate function, and associate it with the ADT.</p>
</li>
<li>
<p>Call the aggregate function from SQL queries, DML statements, or other places that you might use the SQL aggregate functions. You can include typical options such as <code dir="ltr">DISTINCT</code> and <code dir="ltr">ALL</code> in the invocation of the aggregate function.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADDCI2120" href="../../appdev.112/e10765/aggr_functions.htm#ADDCI2120"><span class="italic">Oracle Database Data Cartridge Developer's Guide</span></a> for more information about user-defined aggregate functions</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1266">
<tr>
<td class="cellalignment1275">
<table class="cellalignment1271">
<tr>
<td class="cellalignment1270"><a href="adfns_part_plsql.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1270"><a href="adfns_plscope.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1277">
<table class="cellalignment1269">
<tr>
<td class="cellalignment1270"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1270"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1270"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1270"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1270"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1270"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
