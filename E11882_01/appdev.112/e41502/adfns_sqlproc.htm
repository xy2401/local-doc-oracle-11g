<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL Processing for Application Developers</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1032" />
<meta name="dcterms.created" content="2014-12-06T1:49:48Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Advanced Application Developer's Guide" />
<meta name="dcterms.identifier" content="E41502-06" />
<meta name="dcterms.isVersionOf" content="ADFNS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="adfns_sqltypes.htm" title="Previous" type="text/html" />
<link rel="Next" href="adfns_regexp.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e41502.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">10/31</span> <!-- End Header -->
<div id="ADFNS007" class="chapter"><a id="g1034534"></a> <a id="i1019774"></a>
<h1 class="chapter"><span class="secnum">2</span> SQL Processing for Application Developers</h1>
<p>This chapter explains what application developers must know about how Oracle Database processes SQL statements. Before reading this chapter, read the basic information about SQL processing in <a class="olink CNCPT216" href="../../server.112/e40540/sqllangu.htm#CNCPT216"><span class="italic">Oracle Database Concepts</span></a>.</p>
<p class="subhead2"><a id="sthref204"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJHJIAG">Description of SQL Statement Processing</a></p>
</li>
<li>
<p><a href="#i1024556">Grouping Operations into Transactions</a></p>
</li>
<li>
<p><a href="#i1024718">Ensuring Repeatable Reads with Read-Only Transactions</a></p>
</li>
<li>
<p><a href="#i1024748">Using Cursors</a></p>
</li>
<li>
<p><a href="#i1024830">Locking Tables Explicitly</a></p>
</li>
<li>
<p><a href="#i1025030">Using Oracle Lock Management Services (User Locks)</a></p>
</li>
<li>
<p><a href="#i1025370">Using Serializable Transactions for Concurrency Control</a></p>
</li>
<li>
<p><a href="#i1007356">Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#i1007522">Resuming Execution After Storage Allocation Errors</a></p>
</li>
</ul>
<a id="BEJHJIAG"></a>
<div id="ADFNS99995" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Description of SQL Statement Processing</h2>
<p><a id="sthref205"></a>This topic explains what happens during each stage of processing the execution of a SQL statement, using a DML statement as an example.</p>
<p>Assume that you are using a Pro*C program to increase the salary for all employees in a department. The program has connected to Oracle Database and you are connected to the HR schema, which owns the <code dir="ltr">employees</code> table. You can embed this SQL statement in your program:</p>
<pre dir="ltr">
EXECUTE SQL UPDATE employees SET salary = 1.10 * salary
  WHERE department_id = :department_id;
</pre>
<p>The program provides a value for the bind variable placeholder <code dir="ltr">:department_id</code>, which the SQL statement uses when it runs.</p>
<p class="subhead2"><a id="ADFNS134"></a>Stages of SQL Statement Processing</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
DML statements use all stages. Transaction management, session management, and <a id="sthref206"></a><a id="sthref207"></a>system management SQL statements use only stages&nbsp;<a href="#BEJFIGBJ">2</a> and <a href="#BEJCJIBH">8</a>.</div>
<ol>
<li>
<p><span class="bold">Open or create a cursor.</span></p>
<p>A program interface call opens or creates a cursor, in expectation of a SQL statement. Most applications create the cursor implicitly (automatically). Precompiler programs can create the cursor either implicitly or explicitly.</p>
</li>
<li id="BEJFIGBJ">
<p><span class="bold">Parse the statement.</span></p>
<p>The user process passes the SQL statement to Oracle Database, which loads a parsed representation of the statement into the shared SQL area. Oracle Database can catch many errors during parsing.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref208"></a><a id="sthref209"></a>For a DDL statement, parsing includes data dictionary lookup and execution.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT1740" href="../../server.112/e40540/sqllangu.htm#CNCPT1740"><span class="italic">Oracle Database Concepts</span></a> for information about parsing</p>
</li>
<li>
<p><a href="#BEJFIEIB">"Shared SQL Areas"</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="bold">Determine if the statement is a query.</span></p>
</li>
<li>
<p><span class="bold">If the statement is a query, describe its results.</span></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This stage is necessary only if the characteristics of the result are unknown; for example, when a user enters the query interactively.</div>
<p>Oracle Database determines the characteristics (data types, lengths, and names) of the result.</p>
</li>
<li>
<p><span class="bold">If the statement is a query, define its output.</span></p>
<p>You specify the location, size, and data type of variables defined to receive each fetched value. These variables are called <span class="glossaryterm">define variables</span>. Oracle Database performs data type conversion if necessary.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT1741" href="../../server.112/e40540/sqllangu.htm#CNCPT1741"><span class="italic">Oracle Database Concepts</span></a> for information about the <code dir="ltr">DEFINE</code> stage</div>
</li>
<li>
<p><span class="bold">Bind any variables.</span></p>
<p>Oracle Database has determined the meaning of the SQL statement but does not have enough information to run it. Oracle Database needs values for any bind variable placeholders in the statement. In the example, Oracle Database needs a value for <code dir="ltr">:department_id</code>. The process of obtaining these values is called <span class="bold">binding variables</span>.</p>
<p>A program must specify the location (memory address) of the value. End users of applications may be unaware that they are specifying values for bind variable placeholders, because the Oracle Database utility can prompt them for the values.</p>
<p>Because the program specifies the location of the value (that is, binds by reference), it need not rebind the variable before rerunning the statement, even if the value changes. Each time Oracle Database runs the statement, it gets the value of the variable from its address.</p>
<p>You must also specify a data type and length for each value (unless they are implied or defaulted) if Oracle Database must perform data type conversion.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about specifying a data type and length for a value:
<ul>
<li>
<p><a class="olink LNOCI" href="../e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a></p>
</li>
<li>
<p><a class="olink LNPCC015" href="../../appdev.112/e10825/pc_15ody.htm#LNPCC015"><span class="italic">Pro*C/C++ Programmer's Guide</span></a></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="bold">(Optional) Parallelize the statement.</span></p>
<p>Oracle Database can parallelize queries and some data definition language (DDL) operations (for example, index creation, creating a table with a subquery, and operations on partitions). Parallelization causes multiple server processes to perform the work of the SQL statement so that it can complete faster.</p>
</li>
<li id="BEJCJIBH">
<p><span class="bold">Run the statement.</span></p>
<p>Oracle Database runs the statement. If the statement is a query or an <code dir="ltr">INSERT</code> statement, the database locks no rows, because no data is changing. If the statement is an <code dir="ltr">UPDATE</code> or <code dir="ltr">DELETE</code> statement, the database locks all rows that the statement affects, until the next <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or <code dir="ltr">SAVEPOINT</code> for the transaction, thereby ensuring data integrity.</p>
<p>For some statements, you can specify multiple executions to be performed. This is called <span class="bold">array processing</span>. Given <span class="italic">n</span> number of executions, the bind and define locations are assumed to be the beginning of an array of size <span class="italic">n</span>.</p>
</li>
<li>
<p><span class="bold">If the statement is a query, fetch its rows.</span></p>
<p>Oracle Database selects rows and, if the query has an <code dir="ltr">ORDER</code> <code dir="ltr">BY</code> clause, orders the rows. Each successive fetch retrieves another row of the result set, until the last row has been fetched.</p>
</li>
<li>
<p><span class="bold">Close the cursor.</span></p>
<p>Oracle Database closes the cursor.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
To rerun a transaction management, session management, or <a id="sthref210"></a><a id="sthref211"></a>system management SQL statement, use another <code dir="ltr">EXECUTE</code> statement.</div>
<p class="subhead1"><a id="BEJFIEIB"></a><a id="ADFNS99965"></a>Shared SQL Areas</p>
<p><a id="sthref212"></a><a id="sthref213"></a>Oracle Database automatically detects when applications send similar SQL statements to the database. The SQL area used to process the first occurrence of the statement is <span class="italic">shared</span>&mdash;that is, used for processing subsequent occurrences of that same statement. Therefore, only one shared SQL area exists for a unique statement. Because shared SQL areas are shared memory areas, any Oracle Database process can use a shared SQL area. The sharing of SQL areas reduces memory use on the database server, thereby increasing system throughput.</p>
<p>In determining whether statements are similar or identical, Oracle Database compares both SQL statements issued directly by users and applications and recursive SQL statements issued internally by DDL statements.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF" href="../../server.112/e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about shared SQL</div>
</div>
<!-- class="sect1" -->
<a id="i1024556"></a>
<div id="ADFNS00201" class="sect1">
<h2 class="sect1">Grouping Operations into Transactions</h2>
<p class="subhead2"><a id="sthref214"></a>Topics:</p>
<ul>
<li>
<p><a href="#CIHBEDID">Deciding How to Group Operations in Transactions</a></p>
</li>
<li>
<p><a href="#CIHIJGDD">Improving Transaction Performance</a></p>
</li>
<li>
<p><a href="#CIHEDGBF">Committing Transactions</a></p>
</li>
<li>
<p><a href="#g1691118">Managing Commit Redo Action</a></p>
</li>
<li>
<p><a href="#CIHJEIFD">Rolling Back Transactions</a></p>
</li>
<li>
<p><a href="#CIHIJIBH">Defining Transaction Savepoints</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT016" href="../../server.112/e40540/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for basic information about transactions</div>
<a id="CIHBEDID"></a>
<div id="ADFNS99953" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Deciding How to Group Operations in Transactions</h3>
<p><a id="sthref215"></a>Typically, deciding how to group operations in transactions is the concern of application designers who use programming interfaces to Oracle Database. When deciding how to group transactions:</p>
<ul>
<li>
<p>Define transactions such that work is accomplished in logical units and data remains consistent.</p>
</li>
<li>
<p>Ensure that data in all referenced tables is in a consistent state before the transaction begins and after it ends.</p>
</li>
<li>
<p>Ensure that each transaction consists only of the SQL statements or PL/SQL blocks that comprise one consistent change to the data.</p>
</li>
</ul>
<p>For example, suppose that you write a web application that enables users to transfer funds between accounts. The transaction must include the debit to one account, executed by one SQL statement, and the credit to another account, executed by another SQL statement. Both statements must fail or succeed as a unit of work; one statement must not be committed without the other. Do not include unrelated actions, such as a deposit to one account, in the transaction.</p>
</div>
<!-- class="sect2" -->
<a id="CIHIJGDD"></a>
<div id="ADFNS99952" class="sect2">
<h3 class="sect2">Improving Transaction Performance</h3>
<p><a id="sthref216"></a>As an application developer, you must try to improve performance. Consider using these performance enhancement techniques when designing and writing your application:</p>
<ul>
<li>
<p>For each transaction:</p>
<ol>
<li>
<p>If you can use a single SQL statement, then do so.</p>
</li>
<li>
<p>If you cannot use a single SQL statement but you can use PL/SQL, then use as little PL/SQL as possible.</p>
<p>For information about PL/SQL, see <a href="adfns_part_plsql.htm#CHDGEBHI">Part II, "PL/SQL for Application Developers"</a>.</p>
</li>
<li>
<p>If you cannot use PL/SQL (because it cannot do what you must do; for example, send email), then use Java.</p>
</li>
<li>
<p>If you cannot use Java (for example, if it is too slow) or you have existing third-generation language (3GL) code, then use an external C subprogram.</p>
</li>
</ol>
<p>For information about using Java and C in your application, see <a href="adfns_externproc.htm#g1040439">Chapter 14, "Developing Applications with Multiple Programming Languages."</a></p>
</li>
<li>
<p>Establish standards for writing SQL statements so that you can take advantage of shared SQL areas.</p>
<p>Oracle Database recognizes identical SQL statements and enables them to share memory areas, reducing memory usage on the database server and increasing system throughput.</p>
</li>
<li>
<p>Collect statistics that Oracle Database can use to implement a cost-based approach to SQL statement optimization, and use additional hints to the optimizer as needed.</p>
<p>To collect most statistics, use the <code dir="ltr">DBMS_STATS</code> package, which lets you collect statistics in parallel, collect global statistics for partitioned objects, and fine-tune your statistics collection in other ways. For more information about this package, see <a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<p>To collect statistics unrelated to the cost-based optimizer (such as information about free list blocks), use the SQL statement <code dir="ltr">ANALYZE</code>. For more information about this statement, see <a class="olink SQLRF01105" href="../../server.112/e41084/statements_4005.htm#SQLRF01105"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>For more information about hints, see <a class="olink SQLRF00219" href="../../server.112/e41084/sql_elements006.htm#SQLRF00219"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Before beginning a transaction, invoke <code dir="ltr">DBMS_APPLICATION_INFO</code> procedures to record the name of the transaction in the database for later use when tracking its performance with Oracle Trace and the SQL trace facility. For information about the <code dir="ltr">DBMS_APPLICATION_INFO</code> package, see <a class="olink ARPLS003" href="../../appdev.112/e40758/d_appinf.htm#ARPLS003"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
</li>
<li>
<p>Increase user productivity and query efficiency by including user-written PL/SQL functions in SQL expressions. For details, see <a href="adfns_packages.htm#i1007943">"Invoking Stored PL/SQL Functions from SQL Statements"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT016" href="../../server.112/e40540/transact.htm#CNCPT016"><span class="italic">Oracle Database Concepts</span></a> for more information about transaction management</div>
</div>
<!-- class="sect2" -->
<a id="CIHEDGBF"></a>
<div id="ADFNS1018" class="sect2">
<h3 class="sect2">Committing Transactions</h3>
<p><a id="sthref217"></a><a id="sthref218"></a>To commit a transaction, use the <a id="sthref219"></a><code dir="ltr">COMMIT</code> statement. These two statements are equivalent and commit the current transaction:</p>
<pre dir="ltr">
COMMIT WORK;
COMMIT;
</pre>
<p>The <code dir="ltr">COMMIT</code> statement lets you include the <code dir="ltr">COMMENT</code> parameter with a comment that provides information about the transaction being committed. A comment is useful for including information about the origin of the transaction when you commit distributed transactions:</p>
<pre dir="ltr">
COMMIT COMMENT 'Dallas/Accts_pay/Trans_type 10B';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01110" href="../../server.112/e41084/statements_4010.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">COMMIT</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="g1691118"></a>
<div id="ADFNS99951" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Managing Commit Redo Action</h3>
<p><a id="sthref220"></a><a id="sthref221"></a><a id="sthref222"></a><a id="sthref223"></a>When a transaction updates Oracle Database, it generates a corresponding redo entry. Oracle Database buffers the redo entry to the redo log until the transaction completes. When the transaction commits, the <a id="sthref224"></a><a id="sthref225"></a><a id="sthref226"></a>log writer process (LGWR) writes redo records to disk for the buffered redo entries of all changes in the transaction. By default, Oracle Database writes the redo entries to disk before the call returns to the client. This action causes a latency in the commit, because the application must wait for the redo entries to be persistent on disk.</p>
<p>Oracle Database lets you change the handling of commit redo to fit the needs of your application. If your application requires very high transaction throughput and you are willing to trade commit durability for lower commit latency, then you can change the default <code dir="ltr">COMMIT</code> options so that the application need not wait for the database to write data to the online redo logs.</p>
<p><a href="#CIHGDFJC">Table 2-1</a> describes the <code dir="ltr">COMMIT</code> options.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
With the <code dir="ltr">NOWAIT</code> option, a failure that occurs after the commit message is received, but before the redo log records are written, can falsely indicate to a transaction that its changes are persistent.</div>
<div id="ADFNS135" class="tblhruleformal">
<p class="titleintable"><a id="sthref227"></a><a id="CIHGDFJC"></a>Table 2-1 COMMIT Statement Options</p>
<table class="cellalignment1273" title="COMMIT Statement Options" summary="This table lists and describes the options that you can use for both the COMMIT statement and the COMMIT_WRITE initialization parameter." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t14">Option</th>
<th class="cellalignment1274" id="r1c2-t14">Effect</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t14" headers="r1c1-t14">
<p><a id="sthref228"></a><code dir="ltr">WAIT</code><br />
(default)</p>
</td>
<td class="cellalignment1275" headers="r2c1-t14 r1c2-t14">
<p>Ensures that the <code dir="ltr">COMMIT</code> statement returns only after the corresponding redo information is persistent in the online redo log. When the client receives a successful return from this <code dir="ltr">COMMIT</code> statement, the transaction has been committed to durable media.</p>
<p>A failure that occurs after a successful write to the log might prevent the success message from returning to the client, in which case the client cannot tell whether the transaction committed.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t14" headers="r1c1-t14">
<p><a id="sthref229"></a><code dir="ltr">NOWAIT</code><br />
(alternative to<br />
<code dir="ltr">WAIT</code>)</p>
</td>
<td class="cellalignment1275" headers="r3c1-t14 r1c2-t14">
<p>The <code dir="ltr">COMMIT</code> statement returns to the client regardless of whether the write to the redo log has completed. This behavior can increase transaction throughput.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t14" headers="r1c1-t14">
<p><a id="sthref230"></a><code dir="ltr">BATCH</code><br />
(alternative to<br />
<code dir="ltr">IMMEDIATE</code>)</p>
</td>
<td class="cellalignment1275" headers="r4c1-t14 r1c2-t14">
<p>Buffers the redo information to the redo log with concurrently running transactions. After collecting sufficient redo information, initiates a disk write to the redo log. This behavior is called <a id="sthref231"></a><span class="bold">group commit</span>, because it writes redo information for multiple transactions to the log in a single I/O operation.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t14" headers="r1c1-t14">
<p><a id="sthref232"></a><code dir="ltr">IMMEDIATE</code><br />
(default)</p>
</td>
<td class="cellalignment1275" headers="r5c1-t14 r1c2-t14">
<p>LGWR writes the transaction redo information to the log. Because this operation option forces a disk I/O, it can reduce transaction throughput.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>To change the <code dir="ltr">COMMIT</code> options, use either the <code dir="ltr">COMMIT</code> statement (described in <a class="olink SQLRF01110" href="../../server.112/e41084/statements_4010.htm#SQLRF01110"><span class="italic">Oracle Database SQL Language Reference</span></a>) or the appropriate initialization parameter. For information about initialization parameters, see <a class="olink REFRN00102" href="../../server.112/e40402/initparams004.htm#REFRN00102"><span class="italic">Oracle Database Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot change the default <code dir="ltr">IMMEDIATE</code> and <code dir="ltr">WAIT</code> action for distributed transactions.</div>
<p><a id="sthref233"></a>If your application uses Oracle Call Interface (OCI), then you can modify redo action by setting these flags in the <code dir="ltr">OCITransCommit</code> function in your application:</p>
<ul>
<li>
<p><code dir="ltr">OCI_TRANS_WRITEWAIT</code></p>
</li>
<li>
<p><code dir="ltr">OCI_TRANS_WRITENOWAIT</code></p>
</li>
<li>
<p><code dir="ltr">OCI_TRANS_WRITEBATCH</code></p>
</li>
<li>
<p><code dir="ltr">OCI_TRANS_WRITEIMMED</code></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<code dir="ltr">OCI_TRANS_WRITENOWAIT</code> can cause silent transaction loss with shutdown termination, startup force, and any instance or node failure. On an Oracle RAC system, asynchronously committed changes might not be immediately available to read on other instances.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI13112" href="../../appdev.112/e10646/oci17msc006.htm#LNOCI13112"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for information about the <code dir="ltr">OCITransCommit</code> function</div>
<p>The specification of the <code dir="ltr">NOWAIT</code> and <code dir="ltr">BATCH</code> options has a small window of vulnerability in which Oracle Database can roll back a transaction that your application views as committed. Your application must be able to tolerate these scenarios:</p>
<ul>
<li>
<p>The database host fails, which causes the database to lose redo entries that were buffered but not yet written to the online redo logs.</p>
</li>
<li>
<p>A file I/O problem prevents LGWR from writing buffered redo entries to disk. If the redo logs are not multiplexed, then the commit is lost.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CIHJEIFD"></a>
<div id="ADFNS99950" class="sect2">
<h3 class="sect2">Rolling Back Transactions</h3>
<p><a id="sthref234"></a><a id="sthref235"></a><a id="sthref236"></a><a id="sthref237"></a>To roll back an entire transaction, or to roll back part of a transaction to a savepoint, use the <code dir="ltr">ROLLBACK</code> statement. For example, either of these statements rolls back the entire current transaction:</p>
<pre dir="ltr">
ROLLBACK WORK;
ROLLBACK;
</pre>
<p><a id="sthref238"></a>The <code dir="ltr">WORK</code> option of the <code dir="ltr">ROLLBACK</code> statement has no function.</p>
<p>To roll back to a savepoint defined in the current transaction, use the <code dir="ltr">TO</code> option of the <code dir="ltr">ROLLBACK</code> statement. For example, either of these statements rolls back the current transaction to the savepoint named <code dir="ltr">POINT1</code>:</p>
<pre dir="ltr">
SAVEPOINT Point1;
...
ROLLBACK TO SAVEPOINT Point1;
ROLLBACK TO Point1;
</pre></div>
<!-- class="sect2" -->
<a id="CIHIJIBH"></a>
<div id="ADFNS99949" class="sect2">
<h3 class="sect2">Defining Transaction Savepoints</h3>
<p><a id="sthref239"></a><a id="sthref240"></a>To define a savepoint in a transaction, use the <a id="sthref241"></a><code dir="ltr">SAVEPOINT</code> statement. This statement creates the savepoint named <code dir="ltr">ADD_EMP1</code> in the current transaction:</p>
<pre dir="ltr">
SAVEPOINT Add_emp1;
</pre>
<p>Creating a savepoint with the same identifier as an earlier savepoint deletes the earlier savepoint. After creating a savepoint, you can roll back to it.</p>
<p>An <span class="bold">active savepoint</span> is one that was created after the last <code dir="ltr">COMMIT</code> or <code dir="ltr">ROLLBACK</code> statement. The number of active savepoints for each session is unlimited.</p>
<p><a href="#CHDIGGGE">Table 2-2</a> shows a series of SQL statements that illustrates the use of <code dir="ltr">COMMIT</code>, <code dir="ltr">SAVEPOINT</code>, and <code dir="ltr">ROLLBACK</code> statements within a <a id="sthref242"></a>transaction.</p>
<div id="ADFNS136" class="tblformal">
<p class="titleintable"><a id="sthref243"></a><a id="CHDIGGGE"></a>Table 2-2 Use of COMMIT, SAVEPOINT, and ROLLBACK</p>
<table class="cellalignment1278" title=" Use of COMMIT, SAVEPOINT, and ROLLBACK" summary="shows a series of SQL statements that illustrates the use of This table shows a series of COMMIT, SAVEPOINT, and ROLLBACK statements within a transaction, and gives the result of each statement." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t18">SQL Statement</th>
<th class="cellalignment1274" id="r1c2-t18">Results</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t18" headers="r1c1-t18">
<p><code dir="ltr">SAVEPOINT a;</code></p>
</td>
<td class="cellalignment1275" headers="r2c1-t18 r1c2-t18">
<p>First savepoint of this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t18" headers="r1c1-t18">
<p><code dir="ltr">DELETE</code>...;</p>
</td>
<td class="cellalignment1275" headers="r3c1-t18 r1c2-t18">
<p>First DML statement of this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t18" headers="r1c1-t18">
<p><code dir="ltr">SAVEPOINT b;</code></p>
</td>
<td class="cellalignment1275" headers="r4c1-t18 r1c2-t18">
<p>Second savepoint of this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t18" headers="r1c1-t18">
<p><code dir="ltr">INSERT</code> <code dir="ltr">INTO</code>...;</p>
</td>
<td class="cellalignment1275" headers="r5c1-t18 r1c2-t18">
<p>Second DML statement of this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r6c1-t18" headers="r1c1-t18">
<p><code dir="ltr">SAVEPOINT c;</code></p>
</td>
<td class="cellalignment1275" headers="r6c1-t18 r1c2-t18">
<p>Third savepoint of this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r7c1-t18" headers="r1c1-t18">
<p><code dir="ltr">UPDATE</code>...;</p>
</td>
<td class="cellalignment1275" headers="r7c1-t18 r1c2-t18">
<p>Third DML statement of this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r8c1-t18" headers="r1c1-t18">
<p><code dir="ltr">ROLLBACK TO c;</code></p>
</td>
<td class="cellalignment1275" headers="r8c1-t18 r1c2-t18">
<p><code dir="ltr">UPDATE</code> statement is rolled back, savepoint C remains defined.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r9c1-t18" headers="r1c1-t18">
<p><code dir="ltr">ROLLBACK TO b;</code></p>
</td>
<td class="cellalignment1275" headers="r9c1-t18 r1c2-t18">
<p><code dir="ltr">INSERT</code> statement is rolled back, savepoint C is lost, savepoint B remains defined.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r10c1-t18" headers="r1c1-t18">
<p><code dir="ltr">ROLLBACK TO c;</code></p>
</td>
<td class="cellalignment1275" headers="r10c1-t18 r1c2-t18">
<p>ORA-01086</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r11c1-t18" headers="r1c1-t18">
<p><code dir="ltr">INSERT</code> <code dir="ltr">INTO</code>...;</p>
</td>
<td class="cellalignment1275" headers="r11c1-t18 r1c2-t18">
<p>New DML statement in this transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r12c1-t18" headers="r1c1-t18">
<p><code dir="ltr">COMMIT;</code></p>
</td>
<td class="cellalignment1275" headers="r12c1-t18 r1c2-t18">
<p>Commits all actions performed by the first DML statement (the <code dir="ltr">DELETE</code> statement) and the last DML statement (the second <code dir="ltr">INSERT</code> statement).</p>
<p>All other statements (the second and the third statements) of the transaction were rolled back before the <code dir="ltr">COMMIT</code>. The savepoint A is no longer active.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1024718"></a>
<div id="ADFNS00202" class="sect1">
<h2 class="sect1">Ensuring Repeatable Reads with Read-Only Transactions</h2>
<p>By default, Oracle Database guarantees statement-level read consistency, but not transaction-level read consistency. With <a id="sthref244"></a><a id="sthref245"></a><span class="bold">statement-level read consistency</span>, queries in a statement produce consistent data for the duration of the statement, not reflecting changes by other statements. With <a id="sthref246"></a><a id="sthref247"></a><span class="bold">transaction-level read consistency</span> (<a id="sthref248"></a><a id="sthref249"></a><span class="bold">repeatable reads</span>), queries in the transaction produce consistent data for the duration of the transaction, not reflecting changes by other transactions.</p>
<p>To ensure <a id="sthref250"></a><a id="sthref251"></a>transaction-level read consistency for a transaction that does not include DML statements, specify that the transaction is read-only. The queries in a <a id="sthref252"></a><a id="sthref253"></a>read-only transaction see only changes committed before the transaction began, so query results are consistent for the duration of the transaction.</p>
<p>A read-only transaction provides transaction-level read consistency without acquiring additional data locks. Therefore, while the read-only transaction is querying data, other transactions can query and update the same data.</p>
<p><a id="sthref254"></a>A read-only transaction begins with this statement:</p>
<pre dir="ltr">
SET TRANSACTION READ ONLY [ NAME <span class="italic">string</span> ];
</pre>
<p>Only DDL statements can precede the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> statement. After the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> statement successfully runs, the transaction can include only <code dir="ltr">SELECT</code> (without <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>), <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or non-DML statements (such as <code dir="ltr">SET</code> <code dir="ltr">ROLE</code>, <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code>, and <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code>). A <code dir="ltr">COMMIT</code>, <code dir="ltr">ROLLBACK</code>, or DDL statement ends the read-only transaction.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement</div>
<p>Long-running queries sometimes fail because undo information required for consistent read (CR) operations is no longer available. This situation occurs when active transactions overwrite committed undo blocks.</p>
<p>Automatic undo management lets your database administrator (DBA) explicitly control how long the database retains undo information, using the parameter <a id="sthref255"></a><code dir="ltr">UNDO_RETENTION</code>. For example, if <code dir="ltr">UNDO_RETENTION</code> is set to 30 minutes, then the database retains all committed undo information for at least 30 minutes, ensuring that all queries running for 30 minutes or less do not encounter the OER error "snapshot too old."</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN014" href="../../server.112/e25494/schema.htm#ADMIN014"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about long-running queries and resumable space allocation</div>
</div>
<!-- class="sect1" -->
<a id="i1024748"></a>
<div id="ADFNS99874" class="sect1">
<h2 class="sect1">Using Cursors</h2>
<p><a id="sthref256"></a>PL/SQL implicitly declares a cursor for all SQL data manipulation statements, including queries that return only one row. For queries that return multiple rows, you can explicitly declare a cursor to process the rows individually.</p>
<p>You can think of a <span class="bold">cursor</span> as a name for a specific private SQL area. A PL/SQL <span class="glossaryterm">cursor variable</span> lets you retrieve multiple rows from a stored subprogram. You can pass cursor variables as parameters in your 3GL application. For more information about cursor variables, see <a class="olink LNPLS00605" href="../../appdev.112/e25519/static.htm#LNPLS00605"><span class="italic">Oracle Database PL/SQL Language Reference.</span></a></p>
<p>Most Oracle Database users rely on the automatic cursor handling of the database utilities, but programmatic interfaces offer application designers more control over cursors. In application development, a cursor is a named resource available to a program, which can be specifically used for parsing SQL statements embedded within the application.</p>
<p class="subhead2"><a id="sthref257"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033639">How Many Cursors Can a Session Have?</a></p>
</li>
<li>
<p><a href="#g1033649">Using a Cursor to Reexecute a Statement</a></p>
</li>
<li>
<p><a href="#BEJCGEFI">Scrollable Cursors</a></p>
</li>
<li>
<p><a href="#g1033671">Closing a Cursor</a></p>
</li>
<li>
<p><a href="#g1033677">Canceling a Cursor</a></p>
</li>
</ul>
<a id="g1033639"></a>
<div id="ADFNS99948" class="sect2">
<h3 class="sect2">How Many Cursors Can a Session Have?</h3>
<p><a id="sthref258"></a>The number of cursors that a session can have open simultaneously is determined by:</p>
<ul>
<li>
<p>The amount of memory available to the session</p>
</li>
<li>
<p>The value of the initialization parameter <a id="sthref259"></a><a id="sthref260"></a><code dir="ltr">OPEN_CURSORS</code>, described in <a class="olink REFRN10137" href="../../server.112/e40402/initparams163.htm#REFRN10137"><span class="italic">Oracle Database Reference</span></a></p>
</li>
</ul>
<p>Explicitly creating cursors for precompiler programs has advantages in tuning those applications. For example, increasing the number of cursors can reduce the frequency of parsing and improve performance. If you know how many cursors might be required at a given time, you can open that many cursors simultaneously.</p>
</div>
<!-- class="sect2" -->
<a id="g1033649"></a>
<div id="ADFNS99947" class="sect2">
<h3 class="sect2">Using a Cursor to Reexecute a Statement</h3>
<p><a id="sthref261"></a><a id="sthref262"></a><a id="sthref263"></a>After each stage of execution, the cursor retains enough information about the SQL statement to reexecute the statement without starting over, if no other SQL statement was associated with that cursor. The statement can be reexecuted without including the parse stage.</p>
<p>By opening several cursors, the parsed representation of several SQL statements can be saved. Repeated execution of the same SQL statements can thus begin at the describe, define, bind, or run step, saving the repeated cost of opening cursors and parsing.</p>
<p>To understand the performance characteristics of a cursor, the DBA can use the <code dir="ltr">V$SQL</code> dynamic performance view to display the text of the associated query (see <a class="olink REFRN30246" href="../../server.112/e40402/dynviews_3043.htm#REFRN30246"><span class="italic">Oracle Database Reference</span></a>). Because the results of <code dir="ltr">EXPLAIN</code> <code dir="ltr">PLAN</code> for the original query might differ from the way the database actually processes the query, the DBA can get more precise information by examining these dynamic performance views:</p>
<div class="inftblinformal">
<table class="cellalignment1273" title="Dynamic Performance Views for Cursor Characteristics" summary="This table briefly describes the dynamic performance views that show cursor performance characteristics." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t21">View</th>
<th class="cellalignment1274" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t21" headers="r1c1-t21"><code dir="ltr">V$SQL_PLAN</code></td>
<td class="cellalignment1275" headers="r2c1-t21 r1c2-t21">Execution plan information for each child cursor loaded in the library cache. For more information, see <a class="olink REFRN30250" href="../../server.112/e40402/dynviews_3054.htm#REFRN30250"><span class="italic">Oracle Database Reference</span></a>.</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t21" headers="r1c1-t21"><code dir="ltr">V$SQL_PLAN_STATISTICS</code></td>
<td class="cellalignment1275" headers="r3c1-t21 r1c2-t21">Execution statistics at the row source level for each child cursor. For more information, see <a class="olink REFRN30251" href="../../server.112/e40402/dynviews_3056.htm#REFRN30251"><span class="italic">Oracle Database Reference</span></a>.</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t21" headers="r1c1-t21"><code dir="ltr">V$SQL_PLAN_STATISTICS_ALL</code></td>
<td class="cellalignment1275" headers="r4c1-t21 r1c2-t21">Memory usage statistics for row sources that use SQL memory (sort or hash-join). This view concatenates information in <code dir="ltr">V$SQL_PLAN</code> with execution statistics from <code dir="ltr">V$SQL_PLAN_STATISTICS</code> and <code dir="ltr">V$SQL_WORKAREA</code>. For more information, see <a class="olink REFRN30252" href="../../server.112/e40402/dynviews_3057.htm#REFRN30252"><span class="italic">Oracle Database Reference</span></a>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect2" -->
<a id="BEJCGEFI"></a>
<div id="ADFNS99875" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Scrollable Cursors</h3>
<p><a id="sthref264"></a><a id="sthref265"></a>Execution of a cursor puts the results of the query into a set of rows called the result set. A <span class="bold">scrollable cursor</span> is one whose result rows need not be fetched in forward sequential order. For a scrollable cursor, interfaces exist to fetch previously fetched rows, to fetch the <span class="italic">n</span>th row in the result set, and to fetch the <span class="italic">n</span>th row from the current position in the result set.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic">Oracle Call Interface Programmer's Guide</span> for more information about using scrollable cursors in OCI</div>
</div>
<!-- class="sect2" -->
<a id="g1033671"></a>
<div id="ADFNS99946" class="sect2">
<h3 class="sect2">Closing a Cursor</h3>
<p><a id="sthref266"></a>Closing a cursor makes its information inaccessible and deallocates the memory that it uses. After a cursor opens, it does not close until the user program terminates its connection to the server.</p>
<p>An OCI program or precompiler application that follows good programming practice explicitly closes open cursors during program execution. If the program terminates without closing an open cursor, then that cursor closes implicitly.</p>
</div>
<!-- class="sect2" -->
<a id="g1033677"></a>
<div id="ADFNS99945" class="sect2">
<h3 class="sect2">Canceling a Cursor</h3>
<p><a id="sthref267"></a>Canceling a cursor frees resources from the current fetch.The information in the associated private area is lost but the cursor remains open, parsed, and associated with its bind variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot cancel cursors using Pro*C/C++ or PL/SQL.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI161" href="../../appdev.112/e10646/oci17msc001.htm#LNOCI161"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for information about canceling a cursor with the <code dir="ltr">OCIStmtFetch2</code> statement</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1024830"></a>
<div id="ADFNS00203" class="sect1">
<h2 class="sect1">Locking Tables Explicitly</h2>
<p><a id="sthref268"></a><a id="sthref269"></a>Oracle Database has default locking mechanisms that ensure data concurrency, data integrity, and statement-level read consistency. However, you can override these mechanisms by locking tables explicitly. Locking tables explicitly is useful in situations such as these:</p>
<ul>
<li>
<p>A transaction in your application needs exclusive access to a resource, so that the transaction does not have to wait for other transactions to complete.</p>
</li>
<li>
<p>Your application needs <a id="sthref270"></a><a id="sthref271"></a>transaction-level read consistency (<a id="sthref272"></a>repeatable reads).</p>
<p>For other ways to ensure transaction-level read consistency, see <a href="#i1024718">"Ensuring Repeatable Reads with Read-Only Transactions"</a>) and <a href="#i1025370">"Using Serializable Transactions for Concurrency Control"</a>.</p>
</li>
</ul>
<p>To override default locking at the transaction level, use any of these SQL statements:</p>
<ul>
<li>
<p><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> (described in <a class="olink SQLRF01605" href="../../server.112/e41084/statements_9015.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause (described in <a class="olink SQLRF01702" href="../../server.112/e41084/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
<li>
<p><code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> with the <code dir="ltr">READ</code> <code dir="ltr">ONLY</code> or <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> <code dir="ltr">SERIALIZABLE</code> option (described in <a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a>)</p>
</li>
</ul>
<p>Locks acquired by these statements are released after the transaction is committed or rolled back.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF00901" href="../../server.112/e41084/statements_2013.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ISOLATION_LEVEL</code> parameter of the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statement</div>
<p>The initialization parameter <a id="sthref273"></a><a id="sthref274"></a><a id="sthref275"></a><code dir="ltr">DML_LOCKS</code> (described in <a class="olink REFRN10051" href="../../server.112/e40402/initparams082.htm#REFRN10051"><span class="italic">Oracle Database Reference</span></a>) determines the maximum number of DML locks. Although its default value is usually enough, you might need to increase it if you use explicit locks.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
If you override the default locking of Oracle Database at any level, ensure that data integrity is guaranteed, data concurrency is acceptable, and deadlocks are either impossible or appropriately handled.</div>
<p class="subhead2"><a id="sthref276"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1692678">Privileges Required to Acquire Table Locks</a></p>
</li>
<li>
<p><a href="#i1024882">Choosing a Locking Strategy</a></p>
</li>
<li>
<p><a href="#i1024981">Letting Oracle Database Control Table Locking</a></p>
</li>
<li>
<p><a href="#i1025003">Explicitly Acquiring Row Locks</a></p>
</li>
<li>
<p><a href="#BEJFACAJ">Examples of Concurrency Under Explicit Locking</a></p>
</li>
</ul>
<a id="g1692678"></a>
<div id="ADFNS99944" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Privileges Required to Acquire Table Locks</h3>
<p>No special privileges are required to acquire any type of table lock on a table in your own schema. To acquire a table lock on a table in another schema, you must have either the <code dir="ltr">LOCK</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> system privilege or any object privilege (for example, <code dir="ltr">SELECT</code> or <code dir="ltr">UPDATE</code>) for the table.</p>
</div>
<!-- class="sect2" -->
<a id="i1024882"></a>
<div id="ADFNS99943" class="sect2">
<h3 class="sect2">Choosing a Locking Strategy</h3>
<p>A transaction explicitly acquires the specified table locks when a <a id="sthref277"></a><a id="sthref278"></a><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement is executed. A <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement explicitly overrides default locking. When a <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement is issued on a view, the underlying base tables are locked. This statement acquires exclusive table locks for the <code dir="ltr">employees</code> and <code dir="ltr">departments</code> tables on behalf of the containing transaction:</p>
<pre dir="ltr">
LOCK TABLE employees, departments
   IN EXCLUSIVE MODE NOWAIT;
</pre>
<p>You can specify several tables or views to lock in the same mode; however, only a single <a id="sthref279"></a>lock mode can be specified for each <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a table is locked, all rows of the table are locked. No other user can modify the table. For information about locking individual rows, see <a href="#i1025003">"Explicitly Acquiring Row Locks"</a>.</div>
<p>In the <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement, you can also indicate how long you want to wait for the table lock:</p>
<ul>
<li>
<p>If you do not want to wait, specify either <a id="sthref280"></a><a id="sthref281"></a><code dir="ltr">NOWAIT</code> or <a id="sthref282"></a><code dir="ltr">WAIT 0</code>.</p>
<p>You acquire the table lock only if it is immediately available; otherwise, an error notifies you that the lock is not available now.</p>
</li>
<li>
<p>To wait up to <span class="italic">n</span> seconds to acquire the table lock, specify <code dir="ltr">WAIT</code>&nbsp;<code dir="ltr"><span class="codeinlineitalic">n</span></code>, where <span class="italic">n</span> is greater than 0 and less than or equal to 100000.</p>
<p>If the table lock is still unavailable after <span class="italic">n</span> seconds, an error notifies you that the lock is not available now.</p>
</li>
<li>
<p>To wait indefinitely to acquire the lock, specify neither <code dir="ltr">NOWAIT</code> nor <code dir="ltr">WAIT</code>.</p>
<p>The database waits indefinitely until the table is available, locks it, and returns control to you. When the database is running DDL statements concurrently with DML statements, a timeout or deadlock can sometimes result. The database detects such timeouts and deadlocks and returns an error.</p>
</li>
</ul>
<p class="subhead2"><a id="sthref283"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033397">When to Lock with ROW SHARE MODE and ROW EXCLUSIVE MODE</a></p>
</li>
<li>
<p><a href="#g1033404">When to Lock with SHARE MODE</a></p>
</li>
<li>
<p><a href="#g1033427">When to Lock with SHARE ROW EXCLUSIVE MODE</a></p>
</li>
<li>
<p><a href="#g1033439">When to Lock with EXCLUSIVE MODE</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01605" href="../../server.112/e41084/statements_9015.htm#SQLRF01605"><span class="italic">Oracle Database SQL Language Reference</span></a> for <code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement syntax</div>
<a id="g1033397"></a>
<div id="ADFNS99942" class="sect3">
<h4 class="sect3">When to Lock with ROW SHARE MODE and ROW EXCLUSIVE MODE</h4>
<p><a id="sthref284"></a><a id="sthref285"></a><code dir="ltr">ROW</code> <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> and <a id="sthref286"></a><code dir="ltr">ROW</code> <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">MODE</code> table locks offer the highest degree of concurrency. You might use these locks if:</p>
<ul>
<li>
<p>Your transaction must prevent another transaction from acquiring an intervening share, share row, or exclusive table lock for a table before your transaction can update that table.</p>
<p>If another transaction acquires an intervening share, share row, or exclusive table lock, no other transactions can update the table until the locking transaction commits or rolls back.</p>
</li>
<li>
<p>Your transaction must prevent a table from being altered or dropped before your transaction can modify that table.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="g1033404"></a>
<div id="ADFNS99941" class="sect3">
<h4 class="sect3">When to Lock with SHARE MODE</h4>
<p><a id="sthref287"></a><code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> table locks are rather restrictive data locks. You might use these locks if:</p>
<ul>
<li>
<p>Your transaction only queries the table, and requires a consistent set of the table data for the duration of the transaction.</p>
</li>
<li>
<p>You can hold up other transactions that try to update the locked table, until all transactions that hold <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> locks on the table either commit or roll back.</p>
</li>
<li>
<p>Other transactions might acquire concurrent <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code> table locks on the same table, also giving them the option of transaction-level read consistency.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Your transaction might not update the table later in the same transaction. However, if multiple transactions concurrently hold share table locks for the same table, no transaction can update the table (even if row locks are held as the result of a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement). Therefore, if concurrent share table locks on the same table are common, updates cannot proceed and deadlocks are common. In this case, use share row exclusive or exclusive table locks instead.</div>
</li>
</ul>
<p><span class="bold">Scenario:</span> Tables <code dir="ltr">employees</code> and <code dir="ltr">budget_tab</code> require a consistent set of data in a third table, <code dir="ltr">departments</code>. For a given department number, you want to update the information in <code dir="ltr">employees</code> and <code dir="ltr">budget_tab</code>, and ensure that no members are added to the department between these two transactions.</p>
<p><span class="bold">Solution:</span> Lock the <code dir="ltr">departments</code> table in <code dir="ltr">SHARE</code> <code dir="ltr">MODE</code>, as shown in <a href="#CHDBHJJD">Example 2-1</a>. Because the <code dir="ltr">departments</code> table is rarely updated, locking it probably does not cause many other transactions to wait long.</p>
<div id="ADFNS137" class="example">
<p class="titleinexample"><a id="CHDBHJJD"></a>Example 2-1 LOCK TABLE with SHARE MODE</p>
<pre dir="ltr">
-- Create and populate table:
 
DROP TABLE budget_tab;
CREATE TABLE budget_tab (
  sal     NUMBER(8,2),
  deptno  NUMBER(4)
);
 
INSERT INTO budget_tab (sal, deptno)
  SELECT salary, department_id
  FROM employees;
 
-- Lock departments and update employees and budget_tab:
 
<span class="bold">LOCK TABLE departments IN SHARE MODE;</span>
 
<span class="bold">UPDATE employees</span>
  SET salary = salary * 1.1
  WHERE department_id IN
    (SELECT department_id FROM departments WHERE location_id = 1700);
 
<span class="bold">UPDATE budget_tab</span>
SET sal = sal * 1.1
WHERE deptno IN
  (SELECT department_id FROM departments WHERE location_id = 1700);
 
<span class="bold">COMMIT;</span>  -- COMMIT releases lock
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="g1033427"></a>
<div id="ADFNS99940" class="sect3">
<h4 class="sect3">When to Lock with SHARE ROW EXCLUSIVE MODE</h4>
<p><a id="sthref288"></a>You might use a <code dir="ltr">SHARE</code> <code dir="ltr">ROW</code> <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">MODE</code> table lock if:</p>
<ul>
<li>
<p>Your transaction requires both transaction-level read consistency for the specified table and the ability to update the locked table.</p>
</li>
<li>
<p>You do not care if other transactions acquire explicit row locks (using <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code>), which might make <code dir="ltr">UPDATE</code> and <code dir="ltr">INSERT</code> statements in the locking transaction wait and might cause deadlocks.</p>
</li>
<li>
<p>You only want a single transaction to have this action.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="g1033439"></a>
<div id="ADFNS99939" class="sect3">
<h4 class="sect3">When to Lock with EXCLUSIVE MODE</h4>
<p><a id="sthref289"></a>You might use an <code dir="ltr">EXCLUSIVE</code> <code dir="ltr">MODE</code> table if:</p>
<ul>
<li>
<p>Your transaction requires immediate update access to the locked table. When your transaction holds an exclusive table lock, other transactions cannot lock specific rows in the locked table.</p>
</li>
<li>
<p>Your transaction also ensures transaction-level read consistency for the locked table until the transaction is committed or rolled back.</p>
</li>
<li>
<p>You are not concerned about low levels of data concurrency, making transactions that request exclusive table locks wait in line to update the table sequentially.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1024981"></a>
<div id="ADFNS99938" class="sect2">
<h3 class="sect2">Letting Oracle Database Control Table Locking</h3>
<p><a id="sthref290"></a><a id="sthref291"></a>If you let Oracle Database control table locking, your application needs less programming logic, but also has less control than if you manage the table locks yourself.</p>
<p>Issuing the statement <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> <code dir="ltr">SERIALIZABLE</code> or <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> <code dir="ltr">SERIALIZABLE</code> preserves ANSI serializability without changing the underlying locking protocol. This technique gives concurrent access to the table while providing ANSI serializability. Getting table locks greatly reduces concurrency.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement</p>
</li>
<li>
<p><a class="olink SQLRF00901" href="../../server.112/e41084/statements_2013.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statements</p>
</li>
</ul>
</div>
<p>Change the settings for these parameters only when an instance is shut down. If multiple instances are accessing a single database, then all instances must use the same setting for these parameters.</p>
</div>
<!-- class="sect2" -->
<a id="i1025003"></a>
<div id="ADFNS99937" class="sect2">
<h3 class="sect2">Explicitly Acquiring Row Locks</h3>
<p><a id="sthref292"></a><a id="sthref293"></a>You can override default locking with a <a id="sthref294"></a><code dir="ltr">SELECT</code> statement that includes the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause. This statement acquires exclusive row locks for selected rows (as an <code dir="ltr">UPDATE</code> statement does), in anticipation of updating the selected rows in a subsequent statement.</p>
<p>You can use a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement to lock a row without actually changing it. For example, several triggers in <a class="olink LNPLS020" href="../../appdev.112/e25519/triggers.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> show how to implement referential integrity. In the <code dir="ltr">EMP_DEPT_CHECK</code> trigger, the row that contains the referenced parent key value is locked to guarantee that it remains for the duration of the transaction; if the parent key is updated or deleted, referential integrity is violated.</p>
<p><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statements are often used by interactive programs that enable a user to modify fields of one or more specific rows (which might take some time); row locks are acquired so that only a single interactive program user is updating the rows at any given time.</p>
<p>If a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement is used when defining a cursor, the rows in the return set are locked when the cursor is opened (before the first fetch) rather than being locked as they are fetched from the cursor. Locks are only released when the transaction that opened the cursor is committed or rolled back, not when the cursor is closed.</p>
<p>Each row in the return set of a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement is locked individually; the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement waits until the other transaction releases the conflicting row lock. If a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement locks many rows in a table, and if the table experiences a lot of update activity, it might be faster to acquire an <code dir="ltr">EXCLUSIVE</code> table lock instead.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The return set for a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement might change while the query is running; for example, if columns selected by the query are updated or rows are deleted after the query started. When this happens, <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> acquires locks on the rows that did not change, gets a read-consistent snapshot of the table using these locks, and then restarts the query to acquire the remaining locks.
<p>If your application uses the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement and cannot guarantee that a conflicting locking request will not result in user-caused deadlocks&mdash;for example, through ensuring that concurrent DML statements on a table never affect the return set of the query of a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement&mdash;then code the application always to handle such a deadlock (ORA-00060) in an appropriate manner.</p>
</div>
<p>By default, the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement waits until the requested row lock is acquired. To change this behavior, use the <code dir="ltr">NOWAIT</code>, <code dir="ltr">WAIT</code>, or <code dir="ltr">SKIP</code> <code dir="ltr">LOCKED</code> clause of the <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement. For information about these clauses, see <a class="olink SQLRF01702" href="../../server.112/e41084/statements_10002.htm#SQLRF01702"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BEJFACAJ"></a>
<div id="ADFNS99936" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Examples of Concurrency Under Explicit Locking</h3>
<p><a href="#BEJHACAH">Table 2-3</a> shows how Oracle Database maintains data <a id="sthref295"></a>concurrency, integrity, and consistency when the <a id="sthref296"></a><code dir="ltr">LOCK</code> <code dir="ltr">TABLE</code> statement and the <a id="sthref297"></a><code dir="ltr">SELECT</code> statement with the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause are used. For brevity, the message text for ORA-00054 ("resource busy and acquire with <code dir="ltr">NOWAIT</code> specified") is not included. User-entered text is <span class="bold">bold</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In tables compressed with Hybrid Columnar Compression (HCC), DML statements lock compression units rather than rows. HCC, a feature of certain Oracle storage systems, is described in <a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
<div id="ADFNS138" class="tblformal">
<p class="titleintable"><a id="sthref298"></a><a id="BEJHACAH"></a>Table 2-3 Examples of Concurrency Under Explicit Locking</p>
<table class="cellalignment1278" title="Examples of Concurrency Under Explicit Locking" summary="This table shows how Oracle Database maintains data concurrency, integrity, and consistency when the LOCK TABLE statement and the SELECT statement with the FOR UPDATE clause are used. For brevity, the message text for ORA-00054 (&quot;resource busy and acquire with NOWAIT specified&quot;) is not included. User-entered text is bold." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t33">Transaction 1</th>
<th class="cellalignment1274" id="r1c2-t33">Time Point</th>
<th class="cellalignment1274" id="r1c3-t33">Transaction 2</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW SHARE MODE;</span>

Statement processed.
</pre></td>
<td class="cellalignment1275" headers="r2c1-t33 r1c2-t33">
<p>1</p>
</td>
<td class="cellalignment1275" headers="r2c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r3c1-t33 r1c2-t33">
<p>2</p>
</td>
<td class="cellalignment1275" headers="r3c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">DROP TABLE hr.departments;</span>

DROP TABLE hr.departments
* 
ORA-00054
</pre>
<p>(Exclusive DDL lock not possible because Transaction 1 has table locked.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r4c1-t33 r1c2-t33">
<p>3</p>
</td>
<td class="cellalignment1275" headers="r4c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r5c1-t33 r1c2-t33">
<p>4</p>
</td>
<td class="cellalignment1275" headers="r5c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r6c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 2 locked same rows.)</p>
</td>
<td class="cellalignment1275" headers="r6c1-t33 r1c2-t33">
<p>5</p>
</td>
<td class="cellalignment1275" headers="r6c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r7c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r7c1-t33 r1c2-t33">
<p>6</p>
</td>
<td class="cellalignment1275" headers="r7c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">ROLLBACK;</span>
</pre>
<p>(Releases row locks.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r8c1-t33" headers="r1c1-t33">
<pre dir="ltr">
1 row processed.

<span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment1275" headers="r8c1-t33 r1c2-t33">
<p>7</p>
</td>
<td class="cellalignment1275" headers="r8c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r9c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE;</span>
 
Statement processed.
</pre></td>
<td class="cellalignment1275" headers="r9c1-t33 r1c2-t33">
<p>8</p>
</td>
<td class="cellalignment1275" headers="r9c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r10c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r10c1-t33 r1c2-t33">
<p>9</p>
</td>
<td class="cellalignment1275" headers="r10c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r11c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r11c1-t33 r1c2-t33">
<p>10</p>
</td>
<td class="cellalignment1275" headers="r11c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r12c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r12c1-t33 r1c2-t33">
<p>11</p>
</td>
<td class="cellalignment1275" headers="r12c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r13c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r13c1-t33 r1c2-t33">
<p>12</p>
</td>
<td class="cellalignment1275" headers="r13c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 20;</span>
 
1 row processed.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r14c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r14c1-t33 r1c2-t33">
<p>13</p>
</td>
<td class="cellalignment1275" headers="r14c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">ROLLBACK;</span>
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r15c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
<td class="cellalignment1275" headers="r15c1-t33 r1c2-t33">
<p>14</p>
</td>
<td class="cellalignment1275" headers="r15c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r16c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r16c1-t33 r1c2-t33">
<p>15</p>
</td>
<td class="cellalignment1275" headers="r16c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 20;</span>
 
1 row processed.
</pre>
<p>(Waits because Transaction 1 locked same rows.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r17c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment1275" headers="r17c1-t33 r1c2-t33">
<p>16</p>
</td>
<td class="cellalignment1275" headers="r17c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r18c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r18c1-t33 r1c2-t33">
<p>17</p>
</td>
<td class="cellalignment1275" headers="r18c1-t33 r1c3-t33">
<pre dir="ltr">
1 row processed.
</pre>
<p>(Conflicting locks were released.)</p>
<pre dir="ltr">
<span class="bold">ROLLBACK;</span>
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r19c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW SHARE MODE</span>
 
Statement processed.
</pre></td>
<td class="cellalignment1275" headers="r19c1-t33 r1c2-t33">
<p>18</p>
</td>
<td class="cellalignment1275" headers="r19c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r20c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r20c1-t33 r1c2-t33">
<p>19</p>
</td>
<td class="cellalignment1275" headers="r20c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r21c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r21c1-t33 r1c2-t33">
<p>20</p>
</td>
<td class="cellalignment1275" headers="r21c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r22c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r22c1-t33 r1c2-t33">
<p>21</p>
</td>
<td class="cellalignment1275" headers="r22c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE;</span>
 
Statement processed.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r23c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r23c1-t33 r1c2-t33">
<p>22</p>
</td>
<td class="cellalignment1275" headers="r23c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r24c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r24c1-t33 r1c2-t33">
<p>23</p>
</td>
<td class="cellalignment1275" headers="r24c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r25c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r25c1-t33 r1c2-t33">
<p>24</p>
</td>
<td class="cellalignment1275" headers="r25c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 1 has conflicting table lock.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r26c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment1275" headers="r26c1-t33 r1c2-t33">
<p>25</p>
</td>
<td class="cellalignment1275" headers="r26c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r27c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r27c1-t33 r1c2-t33">
<p>26</p>
</td>
<td class="cellalignment1275" headers="r27c1-t33 r1c3-t33">
<pre dir="ltr">
1 row processed.
</pre>
<p>(Conflicting table lock released.)</p>
<pre dir="ltr">
<span class="bold">ROLLBACK;</span>
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r28c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE;</span>
 
Statement processed.
</pre></td>
<td class="cellalignment1275" headers="r28c1-t33 r1c2-t33">
<p>27</p>
</td>
<td class="cellalignment1275" headers="r28c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r29c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r29c1-t33 r1c2-t33">
<p>28</p>
</td>
<td class="cellalignment1275" headers="r29c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r30c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r30c1-t33 r1c2-t33">
<p>29</p>
</td>
<td class="cellalignment1275" headers="r30c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r31c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r31c1-t33 r1c2-t33">
<p>30</p>
</td>
<td class="cellalignment1275" headers="r31c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r32c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r32c1-t33 r1c2-t33">
<p>31</p>
</td>
<td class="cellalignment1275" headers="r32c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r33c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r33c1-t33 r1c2-t33">
<p>32</p>
</td>
<td class="cellalignment1275" headers="r33c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE</span>
<span class="bold">NOWAIT;</span>
 
ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r34c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r34c1-t33 r1c2-t33">
<p>33</p>
</td>
<td class="cellalignment1275" headers="r34c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r35c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r35c1-t33 r1c2-t33">
<p>34</p>
</td>
<td class="cellalignment1275" headers="r35c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r36c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r36c1-t33 r1c2-t33">
<p>35</p>
</td>
<td class="cellalignment1275" headers="r36c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 1 has conflicting table lock.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r37c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 20;</span>
</pre>
<p>(Waits because Transaction 2 locked same rows.)</p>
</td>
<td class="cellalignment1275" headers="r37c1-t33 r1c2-t33">
<p>36</p>
</td>
<td class="cellalignment1275" headers="r37c1-t33 r1c3-t33">
<p>(Deadlock.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r38c1-t33" headers="r1c1-t33">
<pre dir="ltr">
Cancel operation.

<span class="bold">ROLLBACK;</span>
</pre></td>
<td class="cellalignment1275" headers="r38c1-t33 r1c2-t33">
<p>37</p>
</td>
<td class="cellalignment1275" headers="r38c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r39c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r39c1-t33 r1c2-t33">
<p>38</p>
</td>
<td class="cellalignment1275" headers="r39c1-t33 r1c3-t33">
<pre dir="ltr">
1 row processed.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r40c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE;</span>
</pre></td>
<td class="cellalignment1275" headers="r40c1-t33 r1c2-t33">
<p>39</p>
</td>
<td class="cellalignment1275" headers="r40c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r41c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r41c1-t33 r1c2-t33">
<p>40</p>
</td>
<td class="cellalignment1275" headers="r41c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN EXCLUSIVE MODE;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r42c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r42c1-t33 r1c2-t33">
<p>41</p>
</td>
<td class="cellalignment1275" headers="r42c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r43c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r43c1-t33 r1c2-t33">
<p>42</p>
</td>
<td class="cellalignment1275" headers="r43c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN SHARE MODE;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r44c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r44c1-t33 r1c2-t33">
<p>43</p>
</td>
<td class="cellalignment1275" headers="r44c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW EXCLUSIVE MODE</span>
<span class="bold">NOWAIT;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r45c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r45c1-t33 r1c2-t33">
<p>44</p>
</td>
<td class="cellalignment1275" headers="r45c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">LOCK TABLE hr.departments</span>
<span class="bold">IN ROW SHARE MODE</span>
<span class="bold">NOWAIT;</span>

ORA-00054
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r46c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r46c1-t33 r1c2-t33">
<p>45</p>
</td>
<td class="cellalignment1275" headers="r46c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20;</span>
 
LOCATION_ID
-----------
DALLAS
 
1 row selected.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r47c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r47c1-t33 r1c2-t33">
<p>46</p>
</td>
<td class="cellalignment1275" headers="r47c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 20</span>
<span class="bold">FOR UPDATE OF location_id;</span>
</pre>
<p>(Waits because Transaction 1 has conflicting table lock.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r48c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET department_id = 30</span>
<span class="bold">WHERE department_id = 20;</span>
 
1 row processed.
</pre></td>
<td class="cellalignment1275" headers="r48c1-t33 r1c2-t33">
<p>47</p>
</td>
<td class="cellalignment1275" headers="r48c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r49c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">COMMIT;</span>
</pre></td>
<td class="cellalignment1275" headers="r49c1-t33 r1c2-t33">
<p>48</p>
</td>
<td class="cellalignment1275" headers="r49c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r50c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r50c1-t33 r1c2-t33">
<p>49</p>
</td>
<td class="cellalignment1275" headers="r50c1-t33 r1c3-t33">
<pre dir="ltr">
0 rows selected.
</pre>
<p>(Transaction 1 released conflicting lock.)</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r51c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">SET TRANSACTION READ ONLY;</span>
</pre></td>
<td class="cellalignment1275" headers="r51c1-t33 r1c2-t33">
<p>50</p>
</td>
<td class="cellalignment1275" headers="r51c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r52c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
BOSTON
</pre></td>
<td class="cellalignment1275" headers="r52c1-t33 r1c2-t33">
<p>51</p>
</td>
<td class="cellalignment1275" headers="r52c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r53c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r53c1-t33 r1c2-t33">
<p>52</p>
</td>
<td class="cellalignment1275" headers="r53c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">UPDATE hr.departments</span>
<span class="bold">SET location_id = 'NEW YORK'</span>
<span class="bold">WHERE department_id = 10</span>;
 
1 row processed.
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r54c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
BOSTON
</pre>
<p>(Transaction 1 does not see uncommitted data.)</p>
</td>
<td class="cellalignment1275" headers="r54c1-t33 r1c2-t33">
<p>53</p>
</td>
<td class="cellalignment1275" headers="r54c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r55c1-t33" headers="r1c1-t33">&nbsp;</td>
<td class="cellalignment1275" headers="r55c1-t33 r1c2-t33">
<p>54</p>
</td>
<td class="cellalignment1275" headers="r55c1-t33 r1c3-t33">
<pre dir="ltr">
<span class="bold">COMMIT;</span>
</pre></td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r56c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
BOSTON
</pre>
<p>(Same result even after Transaction 2 commits.)</p>
</td>
<td class="cellalignment1275" headers="r56c1-t33 r1c2-t33">
<p>55</p>
</td>
<td class="cellalignment1275" headers="r56c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r57c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">COMMIT;</span>
</pre></td>
<td class="cellalignment1275" headers="r57c1-t33 r1c2-t33">
<p>56</p>
</td>
<td class="cellalignment1275" headers="r57c1-t33 r1c3-t33">&nbsp;</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r58c1-t33" headers="r1c1-t33">
<pre dir="ltr">
<span class="bold">SELECT location_id</span>
<span class="bold">FROM hr.departments</span>
<span class="bold">WHERE department_id = 10;</span>
 
LOCATION_ID
-----------
NEW YORK
</pre>
<p>(Sees committed data.)</p>
</td>
<td class="cellalignment1275" headers="r58c1-t33 r1c2-t33">
<p>57</p>
</td>
<td class="cellalignment1275" headers="r58c1-t33 r1c3-t33">&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1025030"></a>
<div id="ADFNS1002" class="sect1">
<h2 class="sect1">Using Oracle Lock Management Services (User Locks)</h2>
<p><a id="i1025635"></a>Your applications can use <a id="sthref299"></a>Oracle Lock Management services (<a id="sthref300"></a>user locks) by invoking subprograms the <a id="sthref301"></a><code dir="ltr">DBMS_LOCK</code> package. An application can request a lock of a specific mode, give it a unique name (recognizable in another subprogram in the same or another instance), change the lock mode, and release it. Because a reserved user lock is an Oracle Database lock, it has all the features of a database lock, such as deadlock detection. Ensure that any user locks used in distributed transactions are released upon <code dir="ltr">COMMIT</code>, otherwise an <a id="sthref302"></a><a id="sthref303"></a>undetected deadlock can occur.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS021" href="../../appdev.112/e40758/d_lock.htm#ARPLS021"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about the <code dir="ltr">DBMS_LOCK</code> package</div>
<p class="subhead2"><a id="sthref304"></a>Topics:</p>
<ul>
<li>
<p><a href="#i1025052">When to Use User Locks</a></p>
</li>
<li>
<p><a href="#i1025438">Viewing and Monitoring Locks</a></p>
</li>
</ul>
<a id="i1025052"></a>
<div id="ADFNS99935" class="sect2">
<h3 class="sect2">When to Use User Locks</h3>
<p>User locks can help:</p>
<ul>
<li>
<p>Provide exclusive access to a device, such as a terminal</p>
</li>
<li>
<p>Provide application-level enforcement of read locks</p>
</li>
<li>
<p>Detect when a lock is released and clean up after the application</p>
</li>
<li>
<p>Synchronize applications and enforce sequential processing</p>
</li>
</ul>
<p><a href="#BEJFEIIH">Example 2-2</a> shows how the Pro*COBOL precompiler uses locks to ensure that there are no conflicts when multiple people must access a single device.</p>
<div id="ADFNS139" class="example">
<p class="titleinexample"><a id="BEJFEIIH"></a>Example 2-2 How the Pro*COBOL Precompiler Uses Locks</p>
<pre dir="ltr">
****************************************************************** 
* Print Check                                                    * 
* Any cashier may issue a refund to a customer returning goods.  * 
* Refunds under $50 are given in cash, more than $50 by check.   * 
* This code prints the check. One printer is opened by all       * 
* the cashiers to avoid the overhead of opening and closing it   * 
* for every check, meaning that lines of output from multiple    * 
* cashiers can become interleaved if you do not ensure exclusive * 
* access to the printer. The DBMS_LOCK package is used to        * 
* ensure exclusive access.                                       * 
****************************************************************** 
CHECK-PRINT 
*    Get the lock "handle" for the printer lock. 
   MOVE "CHECKPRINT" TO LOCKNAME-ARR. 
   MOVE 10 TO LOCKNAME-LEN. 
   EXEC SQL EXECUTE 
      BEGIN DBMS_LOCK.ALLOCATE_UNIQUE ( :LOCKNAME, :LOCKHANDLE ); 
      END; END-EXEC. 
*   Lock the printer in exclusive mode (default mode).
   EXEC SQL EXECUTE 
      BEGIN DBMS_LOCK.REQUEST ( :LOCKHANDLE ); 
      END; END-EXEC. 
*   You now have exclusive use of the printer, print the check. 
  ... 
*   Unlock the printer so other people can use it 
EXEC SQL EXECUTE 
      BEGIN DBMS_LOCK.RELEASE ( :LOCKHANDLE ); 
      END; END-EXEC.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1025438"></a>
<div id="ADFNS99934" class="sect2">
<h3 class="sect2">Viewing and Monitoring Locks</h3>
<p><a href="#BEJFHIIJ">Table 2-4</a> describes the Oracle Database facilities that display locking information for ongoing transactions within an instance.</p>
<div id="ADFNS140" class="tblformal">
<p class="titleintable"><a id="sthref305"></a><a id="BEJFHIIJ"></a>Table 2-4 Ways to Display Locking Information</p>
<table class="cellalignment1278" title=" Ways to Display Locking Information" summary="This table describes the Oracle Database facilities that display locking information for on-going transactions within an instance." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t35">Tool</th>
<th class="cellalignment1274" id="r1c2-t35">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t35" headers="r1c1-t35">
<p>Oracle Enterprise Manager Database Control</p>
</td>
<td class="cellalignment1275" headers="r2c1-t35 r1c2-t35">
<p>The Database Locks page shows user locks, all database locks, or locks that are blocking other users or applications. For more information, see <a class="olink TDPRC348" href="../../rac.112/e17264/racmon2.htm#TDPRC348"><span class="italic">Oracle Database 2 Day + Real Application Clusters Guide</span></a>.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t35" headers="r1c1-t35">
<p>Performance Monitoring Data Dictionary Views</p>
</td>
<td class="cellalignment1275" headers="r3c1-t35 r1c2-t35">
<p>See <a class="olink ADMIN11256" href="../../server.112/e25494/monitoring.htm#ADMIN11256"><span class="italic">Oracle Database Administrator's Guide</span></a>.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t35" headers="r1c1-t35">
<p><code dir="ltr">UTLLOCKT</code>.<code dir="ltr">SQL</code></p>
</td>
<td class="cellalignment1275" headers="r4c1-t35 r1c2-t35">
<p><a id="sthref306"></a>The <code dir="ltr">UTLLOCKT</code>.<code dir="ltr">SQL</code> script displays a simple character lock wait-for graph in tree structured fashion. Using any SQL tool (such as SQL*Plus) to run the script, it prints the sessions in the system that are waiting for locks and the corresponding blocking locks. The location of this script file is operating system dependent. (You must have run the <code dir="ltr">CATBLOCK</code>.<code dir="ltr">SQL</code> script before using <code dir="ltr">UTLLOCKT</code>.<code dir="ltr">SQL</code>.)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1025370"></a>
<div id="ADFNS00204" class="sect1">
<h2 class="sect1">Using Serializable Transactions for Concurrency Control</h2>
<p><a id="sthref307"></a><a id="sthref308"></a>By default, Oracle Database permits concurrently running transactions to modify, add, or delete rows in the same table, and in the same data block. When transaction A changes a table, the changes are invisible to concurrently running transactions until transaction A commits them. If transaction A tries to update or delete a row that transaction B has locked (by issuing a DML or <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement), then the DML statement that A issued waits until B either commits or rolls back the transaction. This concurrency model, which provides higher concurrency and thus better performance, is appropriate for most applications.</p>
<p>However, some rare applications require serializable transactions. <span class="bold">Serializable transactions</span> run concurrently in serialized mode. In <span class="bold">serialized mode</span>, concurrent transactions can make only the database changes that they could make if they were running serially (that is, one at a time). If a serialized transaction tries to change data that another transaction changed after the serialized transaction began, then error ORA-08177 occurs.</p>
<p>When a serializable transaction fails with ORA-08177, the application can take any of these actions:</p>
<ul>
<li>
<p>Commit the work executed to that point.</p>
</li>
<li>
<p>Run additional, different, statements, perhaps after rolling back to a prior savepoint in the transaction.</p>
</li>
<li>
<p>Roll back the transaction and then rerun it.</p>
<p>The transaction gets a transaction snapshot and the operation is likely to succeed.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
To minimize the performance overhead of rolling back and re running transactions, put DML statements that might conflict with concurrent transactions near the beginning of the transaction.</div>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Serializable transactions do not work with deferred segment creation or interval partitioning. Trying to insert data into an empty table with no segment created, or into a partition of an interval partitioned table that does not yet have a segment, causes an error.</div>
<p class="subhead2"><a id="sthref309"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJDDAGA">Transaction Interaction and Isolation Level</a></p>
</li>
<li>
<p><a href="#i1007165">Setting Isolation Levels</a></p>
</li>
<li>
<p><a href="#g1033864">Serializable Transactions and Referential Integrity</a></p>
</li>
<li>
<p><a href="#g1033897">READ COMMITTED and SERIALIZABLE Isolation Levels</a></p>
</li>
</ul>
<a id="BEJDDAGA"></a>
<div id="ADFNS99871" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Transaction Interaction and Isolation Level</h3>
<p>The ANSI/ISO SQL standard defines three kinds of <a id="sthref310"></a>transaction interaction:</p>
<div class="inftblinformal">
<table class="cellalignment1273" title="ANSI/ISO SQL Transaction Interactions" summary="This table lists and defines the three kinds of transaction interactions that the ANSI/ISO SQL standard defines." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t38">Transaction Interaction</th>
<th class="cellalignment1274" id="r1c2-t38">Definition</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t38" headers="r1c1-t38"><a id="sthref311"></a>Dirty read</td>
<td class="cellalignment1275" headers="r2c1-t38 r1c2-t38">Transaction A reads uncommitted changes made by transaction B.</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t38" headers="r1c1-t38"><a id="sthref312"></a>Unrepeatable read</td>
<td class="cellalignment1275" headers="r3c1-t38 r1c2-t38">Transaction A reads data, transaction B changes the data and commits the changes, and transaction A rereads the data and sees the changes.</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t38" headers="r1c1-t38"><a id="sthref313"></a>Phantom read</td>
<td class="cellalignment1275" headers="r4c1-t38 r1c2-t38">Transaction A runs a query, transaction B inserts new rows and commits the change, and transaction A repeats the query and sees the new rows.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The kinds of interactions that a transaction can have is determined by its isolation level. The ANSI/ISO SQL standard defines four transaction isolation levels. <a href="#g1026777">Table 2-5</a> shows what kind of interactions are possible at each <a id="sthref314"></a><a id="sthref315"></a>isolation level.</p>
<div id="ADFNS141" class="tblformal">
<p class="titleintable"><a id="sthref316"></a><a id="g1026777"></a>Table 2-5 ANSI/ISO SQL Isolation Levels and Possible Transaction Interactions</p>
<table class="cellalignment1278" title=" ANSI/ISO SQL Isolation Levels and Possible Transaction Interactions" summary="This table lists the four transaction isolation levels that the ANSI/ISO SQL standard defines and shows the kinds of transaction interactions possible at each level." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t39">Isolation Level</th>
<th class="cellalignment1274" id="r1c2-t39">Dirty Read</th>
<th class="cellalignment1274" id="r1c3-t39">Unrepeatable Read</th>
<th class="cellalignment1274" id="r1c4-t39">Phantom Read</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t39" headers="r1c1-t39">
<p><a id="sthref317"></a><code dir="ltr">READ</code> <code dir="ltr">UNCOMMITTED</code></p>
</td>
<td class="cellalignment1275" headers="r2c1-t39 r1c2-t39">
<p>Possible</p>
</td>
<td class="cellalignment1275" headers="r2c1-t39 r1c3-t39">
<p>Possible</p>
</td>
<td class="cellalignment1275" headers="r2c1-t39 r1c4-t39">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t39" headers="r1c1-t39">
<p><a id="sthref318"></a><code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code></p>
</td>
<td class="cellalignment1275" headers="r3c1-t39 r1c2-t39">
<p>Not possible</p>
</td>
<td class="cellalignment1275" headers="r3c1-t39 r1c3-t39">
<p>Possible</p>
</td>
<td class="cellalignment1275" headers="r3c1-t39 r1c4-t39">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t39" headers="r1c1-t39">
<p><a id="sthref319"></a><code dir="ltr">REPEATABLE</code> <code dir="ltr">READ</code></p>
</td>
<td class="cellalignment1275" headers="r4c1-t39 r1c2-t39">
<p>Not possible</p>
</td>
<td class="cellalignment1275" headers="r4c1-t39 r1c3-t39">
<p>Not possible</p>
</td>
<td class="cellalignment1275" headers="r4c1-t39 r1c4-t39">
<p>Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t39" headers="r1c1-t39">
<p><a id="sthref320"></a><code dir="ltr">SERIALIZABLE</code></p>
</td>
<td class="cellalignment1275" headers="r5c1-t39 r1c2-t39">
<p>Not possible</p>
</td>
<td class="cellalignment1275" headers="r5c1-t39 r1c3-t39">
<p>Not possible</p>
</td>
<td class="cellalignment1275" headers="r5c1-t39 r1c4-t39">
<p>Not possible</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#g1026806">Table 2-6</a> shows which ANSI/ISO SQL transaction isolation levels Oracle Database provides.</p>
<div id="ADFNS142" class="tblformal">
<p class="titleintable"><a id="sthref321"></a><a id="g1026806"></a>Table 2-6 ANSI/ISO SQL Isolation Levels Provided by Oracle Database</p>
<table class="cellalignment1278" title=" ANSI/ISO SQL Isolation Levels Provided by Oracle Database" summary="This table describes the action of Oracle Database with respect to the isolation levels that the ANSI/ISO SQL standard SQL92 defines." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t40">Isolation Level</th>
<th class="cellalignment1274" id="r1c2-t40">Provided by Oracle Database</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t40" headers="r1c1-t40">
<p><a id="sthref322"></a><code dir="ltr">READ</code> <code dir="ltr">UNCOMMITTED</code></p>
</td>
<td class="cellalignment1275" headers="r2c1-t40 r1c2-t40">
<p>No. Oracle Database never permits "dirty reads." Some other database products use this undesirable technique to improve thoughput, but it is not required for high throughput with Oracle Database.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t40" headers="r1c1-t40">
<p><a id="sthref323"></a><code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code></p>
</td>
<td class="cellalignment1275" headers="r3c1-t40 r1c2-t40">
<p>Yes, by default. In fact, because an Oracle Database query sees only data that was committed at the beginning of the query (the snapshot time), Oracle Database offers more consistency than the ANSI/ISO SQL standard for <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation requires.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t40" headers="r1c1-t40">
<p><a id="sthref324"></a><code dir="ltr">REPEATABLE</code> <code dir="ltr">READ</code></p>
</td>
<td class="cellalignment1275" headers="r4c1-t40 r1c2-t40">
<p>Yes, if you set the transaction isolation level to <code dir="ltr">SERIALIZABLE</code>.</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t40" headers="r1c1-t40">
<p><a id="sthref325"></a><code dir="ltr">SERIALIZABLE</code></p>
</td>
<td class="cellalignment1275" headers="r5c1-t40 r1c2-t40">
<p>Yes, if you set the transaction isolation level to <code dir="ltr">SERIALIZABLE</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#i1025588">Figure 2-1</a> shows how an arbitrary transaction (that is, one that is either <code dir="ltr">SERIALIZABLE</code> or <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code>) <a id="sthref326"></a><a id="sthref327"></a>interacts with a serializable transaction.</p>
<div id="ADFNS143" class="figure">
<p class="titleinfigure"><a id="i1025588"></a>Figure 2-1 Interaction Between Serializable Transaction and Another Transaction</p>
<img width="460" height="596" src="img/adfns053.gif" alt="Description of Figure 2-1 follows" /><br />
<a id="sthref328" href="img_text/adfns053.htm">Description of "Figure 2-1 Interaction Between Serializable Transaction and Another Transaction"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="i1007165"></a>
<div id="ADFNS99932" class="sect2">
<h3 class="sect2">Setting Isolation Levels</h3>
<p><a id="sthref329"></a>To set the transaction isolation level for every transaction in your session, use the <code dir="ltr">ALTER</code> <code dir="ltr">SESSION</code> statement, described in <a class="olink SQLRF00901" href="../../server.112/e41084/statements_2013.htm#SQLRF00901"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<p>To set the transaction isolation level for a specific transaction, use the <code dir="ltr">ISOLATION</code> <code dir="ltr">LEVEL</code> clause of the <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement. The <code dir="ltr">SET</code> <code dir="ltr">TRANSACTION</code> statement, described in <a class="olink SQLRF01705" href="../../server.112/e41084/statements_10005.htm#SQLRF01705"><span class="italic">Oracle Database SQL Language Reference</span></a>, must be the first statement in the transaction.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you set the transaction isolation level to <code dir="ltr">SERIALIZABLE</code>, then you must use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement to set the <code dir="ltr">INITRANS</code> parameter to at least 3. Use higher values for tables for which many transactions update the same blocks. For more information about <code dir="ltr">INITRANS</code>, see <a class="olink SQLRF52296" href="../../server.112/e41084/clauses007.htm#SQLRF52296"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
</div>
<!-- class="sect2" -->
<a id="g1033864"></a>
<div id="ADFNS99996" class="sect2">
<h3 class="sect2">Serializable Transactions and Referential Integrity</h3>
<p><a id="sthref330"></a><a id="sthref331"></a>Because Oracle Database does not use <a id="sthref332"></a>read locks, even in <code dir="ltr">SERIALIZABLE</code> transactions, data read by one transaction can be overwritten by another. Therefore, transactions that perform database consistency checks at the application level must not assume that the data they read does not change during the transaction (even though such changes are invisible to the transaction). Code your application-level consistency checks carefully, even when using <code dir="ltr">SERIALIZABLE</code> transactions.</p>
<p>In <a href="#i1020116">Figure 2-2</a>, transactions A and B (which are either <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> or <code dir="ltr">SERIALIZABLE</code>) perform application-level checks to maintain the referential integrity of the parent/child relationship between two tables. Transaction A queries the parent table to check that it has a row with a specific primary key value before inserting corresponding child rows into the child table. Transaction B queries the child table to check that no child rows exist for a specific primary key value before deleting the corresponding parent row from the parent table. Both transactions assume (but do not ensure) that the data they read does not change before the transaction completes.</p>
<div id="ADFNS144" class="figure">
<p class="titleinfigure"><a id="i1020116"></a>Figure 2-2 Referential Integrity Check</p>
<img width="426" height="331" src="img/adfns054.gif" alt="Description of Figure 2-2 follows" /><br />
<a id="sthref333" href="img_text/adfns054.htm">Description of "Figure 2-2 Referential Integrity Check"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The query by transaction A does not prevent transaction B from deleting the parent row, and the query by transaction B does not prevent transaction A from inserting child rows. Therefore, this can happen:</p>
<ol>
<li>
<p>Transaction A queries the parent table and finds the specified parent row.</p>
</li>
<li>
<p>Transaction B queries the child table and finds no child rows for the specified parent row.</p>
</li>
<li id="BEJDJJFC">
<p>Having found the specified parent row, transaction A inserts the corresponding child rows into the child table.</p>
</li>
<li>
<p>Having found no child rows for the specified parent row, transaction B deletes the specified parent row from the parent table.</p>
<p>Now the child rows that transaction A inserted in step&nbsp;<a href="#BEJDJJFC">3</a> have no parent row.</p>
</li>
</ol>
<p>The preceding result can occur even if both A and B are <code dir="ltr">SERIALIZABLE</code> transactions, because neither transaction prevents the other from changing the data that it reads to check consistency.</p>
<p>Ensuring that data queried by one transaction is not concurrently changed or deleted by another requires more transaction isolation than the ANSI/ISO SQL standard <code dir="ltr">SERIALIZABLE</code> isolation level provides. However, in Oracle Database:</p>
<ul>
<li>
<p>Transaction A can use a <a id="sthref334"></a><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement to query and lock the parent row, thereby preventing transaction B from deleting it.</p>
<p>For information about the <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> clause of the <code dir="ltr">SELECT</code> statement, see <a class="olink SQLRF55370" href="../../server.112/e41084/statements_10002.htm#SQLRF55370"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>Transaction B can prevent transaction A from finding the parent row (thereby preventing A from inserting the child rows) by reversing the order of its processing steps. That is, transaction B can:</p>
<ol>
<li>
<p>Delete the parent row.</p>
</li>
<li>
<p>Query the child table.</p>
</li>
<li>
<p>If the deleted parent row has child rows in the child table, then roll back the deletion of the parent row.</p>
</li>
</ol>
</li>
</ul>
<p>Alternatively, you can enforce referential integrity with a <a id="sthref335"></a><a id="sthref336"></a>trigger. Instead of having transaction A query the parent table, define on the child table a row-level <code dir="ltr">BEFORE</code> <code dir="ltr">INSERT</code> trigger that does this:</p>
<ul>
<li>
<p>Queries the parent table with a <code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> statement, thereby ensuring that if the parent row exists, then it remains in the database for the duration of the transaction that inserts the child rows.</p>
</li>
<li>
<p>Rejects the insertion of the child rows if the parent row does not exist.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS770" href="../../appdev.112/e25519/triggers.htm#LNPLS770"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about using triggers to maintain referential integrity between parent and child tables</div>
<p>A trigger runs SQL statements in the context of the triggering statement (that is, the triggering and triggered statements see the database in the same state). Therefore, if a <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> transaction runs the triggering statement, then the triggered statements see the database as it was when the triggering statement began to execute. If a <code dir="ltr">SERIALIZABLE</code> transaction runs the triggering statement, then the triggered statements see the database as it was at the beginning of the transaction. In either case, using <a id="sthref337"></a><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code> in the trigger correctly enforces referential integrity.</p>
</div>
<!-- class="sect2" -->
<a id="g1033897"></a>
<div id="ADFNS99999" class="sect2">
<h3 class="sect2">READ COMMITTED and SERIALIZABLE Isolation Levels</h3>
<p>Oracle Database provides two transaction isolation levels, <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> and <code dir="ltr">SERIALIZABLE</code>. Both levels provide a high degree of consistency and concurrency, reduce contention, and are designed for real-world applications. This topic compares them and explains how to choose between them.</p>
<p class="subhead2"><a id="sthref338"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033487">Transaction Set Consistency Differences</a></p>
</li>
<li>
<p><a href="#g1033520">Choosing Transaction Isolation Levels</a></p>
</li>
</ul>
<a id="g1033487"></a>
<div id="ADFNS99997" class="sect3">
<h4 class="sect3">Transaction Set Consistency Differences</h4>
<p>An operation (query or transaction) is <a id="sthref339"></a><span class="glossaryterm">transaction set consistent</span> if all of its read operations return data written by the same set of committed transactions. When an operation is not transaction set consistent, some of its read operations reflect the changes of one set of transactions and others reflect the changes of other sets of transactions; that is, the operation sees the database in a state that reflects no single set of committed transactions.</p>
<p class="subhead2"><a id="sthref340"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJHEJBE">Oracle Database</a></p>
</li>
<li>
<p><a href="#BEJJHEJE">Other Database Systems</a></p>
</li>
</ul>
<a id="BEJHEJBE"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Oracle Database</h5>
<p>Oracle Database transactions with <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation level are transaction set consistent on an individual-statement basis, because all rows that a query reads must be committed before the query begins.</p>
<p>Oracle Database transactions with <code dir="ltr">SERIALIZABLE</code> isolation level are transaction set consistent on an individual-transaction basis, because all statements in a <code dir="ltr">SERIALIZABLE</code> transaction run on an image of the database as it was at the beginning of the transaction.</p>
</div>
<!-- class="sect4" -->
<a id="BEJJHEJE"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Other Database Systems</h5>
<p>In other database systems, a single query with <code dir="ltr">READ</code> <code dir="ltr">UNCOMMITTED</code> isolation level is not transaction set consistent, because it might see only a subset of the changes made by another transaction. For example, a join of a master table with a detail table can see a master record inserted by another transaction, but not the corresponding details inserted by that transaction (or the reverse). <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation level avoids this problem, providing more consistency than read-locking systems do.</p>
<p>In read-locking systems, at the cost of preventing concurrent updates, the <code dir="ltr">REPEATABLE</code> <code dir="ltr">READ</code> isolation level provides transaction set consistency at the statement level, but not at the transaction level. Due to the absence of phantom read protection, two queries in the same transaction can see data committed by different sets of transactions. In these systems, only the throughput-limiting and deadlock-susceptible <code dir="ltr">SERIALIZABLE</code> isolation level provides transaction set consistency at the transaction level.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="g1033520"></a>
<div id="ADFNS99998" class="sect3">
<h4 class="sect3">Choosing Transaction Isolation Levels</h4>
<p><a id="sthref341"></a><a id="sthref342"></a>The choice of transaction isolation level depends on performance and consistency needs and application coding requirements. There is a trade-off between concurrency (transaction throughput) and consistency. Consider the application and workload when choosing isolation levels for its transactions. Different transactions can have different isolation levels.</p>
<p>For environments with many concurrent users rapidly submitting transactions, consider expected transaction arrival rate, response time demands, and required degree of consistency.</p>
<p><a id="sthref343"></a><code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> isolation can provide considerably more concurrency with a somewhat increased risk of inconsistent results (from unrepeatable and phantom reads) for some transactions.</p>
<p><a id="sthref344"></a><code dir="ltr">SERIALIZABLE</code> isolation provides somewhat more consistency (by protecting against phantoms and unrepeatable reads), which might be important where a read/write transaction runs a query more than once. However, <code dir="ltr">SERIALIZABLE</code> isolation requires applications to check for the "cannot serialize access" error, and this checking can significantly reduce throughput in an environment with many concurrent transactions accessing the same data for update.</p>
<p>As explained in <a href="#g1033864">"Serializable Transactions and Referential Integrity"</a> reads do not block writes in either <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> or <code dir="ltr">SERIALIZABLE</code> transactions.</p>
<p><a href="#g1026829">Table 2-7</a> summarizes the similarities and differences between <code dir="ltr">READ</code> <code dir="ltr">COMMITTED</code> and <code dir="ltr">SERIALIZABLE</code> transactions.</p>
<div id="ADFNS145" class="tblformal">
<p class="titleintable"><a id="sthref345"></a><a id="g1026829"></a>Table 2-7 Comparison of READ COMMITTED and SERIALIZABLE Transactions</p>
<table class="cellalignment1278" title=" Comparison of READ COMMITTED and SERIALIZABLE Transactions" summary="This table summarizes the key similarities and differences between READ COMMITTED and SERIALIZABLE transactions." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t43">Operation</th>
<th class="cellalignment1274" id="r1c2-t43">READ COMMITTED</th>
<th class="cellalignment1274" id="r1c3-t43">SERIALIZABLE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t43" headers="r1c1-t43">
<p>Dirty write</p>
</td>
<td class="cellalignment1275" headers="r2c1-t43 r1c2-t43">
<p>Not Possible</p>
</td>
<td class="cellalignment1275" headers="r2c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t43" headers="r1c1-t43">
<p>Dirty read</p>
</td>
<td class="cellalignment1275" headers="r3c1-t43 r1c2-t43">
<p>Not Possible</p>
</td>
<td class="cellalignment1275" headers="r3c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t43" headers="r1c1-t43">
<p>Unrepeatable read</p>
</td>
<td class="cellalignment1275" headers="r4c1-t43 r1c2-t43">
<p>Possible</p>
</td>
<td class="cellalignment1275" headers="r4c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t43" headers="r1c1-t43">
<p>Phantom read</p>
</td>
<td class="cellalignment1275" headers="r5c1-t43 r1c2-t43">
<p>Possible</p>
</td>
<td class="cellalignment1275" headers="r5c1-t43 r1c3-t43">
<p>Not Possible</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r6c1-t43" headers="r1c1-t43">
<p>Compliant with ANSI/ISO SQL 92</p>
</td>
<td class="cellalignment1275" headers="r6c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment1275" headers="r6c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r7c1-t43" headers="r1c1-t43">
<p>Read snapshot time</p>
</td>
<td class="cellalignment1275" headers="r7c1-t43 r1c2-t43">
<p>Statement</p>
</td>
<td class="cellalignment1275" headers="r7c1-t43 r1c3-t43">
<p>Transaction</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r8c1-t43" headers="r1c1-t43">
<p>Transaction set consistency</p>
</td>
<td class="cellalignment1275" headers="r8c1-t43 r1c2-t43">
<p>Statement level</p>
</td>
<td class="cellalignment1275" headers="r8c1-t43 r1c3-t43">
<p>Transaction level</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r9c1-t43" headers="r1c1-t43">
<p>Row-level locking</p>
</td>
<td class="cellalignment1275" headers="r9c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment1275" headers="r9c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r10c1-t43" headers="r1c1-t43">
<p>Readers block writers</p>
</td>
<td class="cellalignment1275" headers="r10c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment1275" headers="r10c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r11c1-t43" headers="r1c1-t43">
<p>Writers block readers</p>
</td>
<td class="cellalignment1275" headers="r11c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment1275" headers="r11c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r12c1-t43" headers="r1c1-t43">
<p>Different-row writers block writers</p>
</td>
<td class="cellalignment1275" headers="r12c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment1275" headers="r12c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r13c1-t43" headers="r1c1-t43">
<p>Same-row writers block writers</p>
</td>
<td class="cellalignment1275" headers="r13c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment1275" headers="r13c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r14c1-t43" headers="r1c1-t43">
<p>Waits for blocking transaction</p>
</td>
<td class="cellalignment1275" headers="r14c1-t43 r1c2-t43">
<p>Yes</p>
</td>
<td class="cellalignment1275" headers="r14c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r15c1-t43" headers="r1c1-t43">
<p>Subject to "cannot serialize access" error</p>
</td>
<td class="cellalignment1275" headers="r15c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment1275" headers="r15c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r16c1-t43" headers="r1c1-t43">
<p>Error after blocking transaction terminates</p>
</td>
<td class="cellalignment1275" headers="r16c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment1275" headers="r16c1-t43 r1c3-t43">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r17c1-t43" headers="r1c1-t43">
<p>Error after blocking transaction commits</p>
</td>
<td class="cellalignment1275" headers="r17c1-t43 r1c2-t43">
<p>No</p>
</td>
<td class="cellalignment1275" headers="r17c1-t43 r1c3-t43">
<p>Yes</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007356"></a>
<div id="ADFNS00205" class="sect1">
<h2 class="sect1">Autonomous Transactions</h2>
<p>An <a id="sthref346"></a><a id="sthref347"></a><span class="glossaryterm">autonomous transaction</span> (AT) is an independent transaction started by another transaction, the <a id="sthref348"></a><a id="sthref349"></a><a id="sthref350"></a><span class="glossaryterm">main transaction</span> (MT). An autonomous transaction lets you suspend the main transaction, do SQL operations, commit or roll back those operations, and then resume the main transaction.</p>
<p>For example, in a stock purchase transaction, you might want to commit customer information regardless of whether the purchase succeeds. Or, you might want to log error messages to a debug table even if the transaction rolls back. Autonomous transactions enable you to do such tasks.</p>
<p>An autonomous transaction runs within an <span class="glossaryterm">autonomous scope</span>; that is, within the scope of an <span class="bold">autonomous routine</span>&mdash;a routine that you mark with the <code dir="ltr">AUTONOMOUS_TRANSACTION</code> pragma. For the definition of <span class="bold">routine</span> in this context, see <a class="olink LNPLS01302" href="../../appdev.112/e25519/autotransaction_pragma.htm#LNPLS01302"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p><a href="#i1025816">Figure 2-3</a> shows how control flows from the main transaction (MT) to an autonomous transaction (AT) and back again. As you can see, the autonomous transaction can commit multiple transactions (AT1 and AT2) before control returns to the main transaction.</p>
<div id="ADFNS146" class="figure">
<p class="titleinfigure"><a id="i1025816"></a>Figure 2-3 Transaction Control Flow</p>
<img width="513" height="233" src="img/adfns055.gif" alt="Description of Figure 2-3 follows" /><br />
<a id="sthref351" href="img_text/adfns055.htm">Description of "Figure 2-3 Transaction Control Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When you enter the executable section of an autonomous transaction, the main transaction suspends. When you exit the transaction, the main transaction resumes. <code dir="ltr">COMMIT</code> and <code dir="ltr">ROLLBACK</code> end the active autonomous transaction but do not exit the autonomous transaction. As <a href="#i1025816">Figure 2-3</a> shows, when one transaction ends, the next SQL statement begins another transaction.</p>
<p>More characteristics of autonomous transactions:</p>
<ul>
<li>
<p>The changes an autonomous transaction effects do not depend on the state or the eventual disposition of the main transaction. For example:</p>
<ul>
<li>
<p>An autonomous transaction does not see changes made by the main transaction.</p>
</li>
<li>
<p>When an autonomous transaction commits or rolls back, it does not affect the outcome of the main transaction.</p>
</li>
</ul>
</li>
<li>
<p>The changes an autonomous transaction effects are visible to other transactions as soon as that autonomous transaction commits. Therefore, users can access the updated information without having to wait for the main transaction to commit.</p>
</li>
<li>
<p>Autonomous transactions can start other autonomous transactions.</p>
</li>
</ul>
<p><a href="#i1020443">Figure 2-4</a> shows some possible sequences that autonomous transactions can follow.</p>
<div id="ADFNS147" class="figure">
<p class="titleinfigure"><a id="i1020443"></a>Figure 2-4 Possible Sequences of Autonomous Transactions</p>
<img width="586" height="584" src="img/adfns056.gif" alt="Description of Figure 2-4 follows" /><br />
<a id="sthref352" href="img_text/adfns056.htm">Description of "Figure 2-4 Possible Sequences of Autonomous Transactions"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="subhead2"><a id="sthref353"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJDBBEA">Examples of Autonomous Transactions</a></p>
</li>
<li>
<p><a href="#BEJICBBD">Defining Autonomous Transactions</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS00609" href="../../appdev.112/e25519/static.htm#LNPLS00609"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for detailed information about autonomous transactions</div>
<a id="BEJDBBEA"></a>
<div id="ADFNS99929" class="sect2">
<h3 class="sect2">Examples of Autonomous Transactions</h3>
<ul>
<li>
<p><a href="#g1033531">Ordering a Product</a></p>
</li>
<li>
<p><a href="#g1033537">Withdrawing Money from a Bank Account</a></p>
</li>
</ul>
<p>As these examples show, there are four possible outcomes when you use autonomous and main transactions (see <a href="#g1026901">Table 2-8</a>). There is no dependency between the outcome of an autonomous transaction and that of a main transaction.</p>
<div id="ADFNS148" class="tblformal">
<p class="titleintable"><a id="sthref354"></a><a id="g1026901"></a>Table 2-8 Possible Transaction Outcomes</p>
<table class="cellalignment1278" title=" Possible Transaction Outcomes" summary="This table summarizes the four possible outcomes of autonomous and main transactions." dir="ltr">
<thead>
<tr class="cellalignment1267">
<th class="cellalignment1274" id="r1c1-t45">Autonomous Transaction</th>
<th class="cellalignment1274" id="r1c2-t45">Main Transaction</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r2c1-t45" headers="r1c1-t45">
<p>Commits</p>
</td>
<td class="cellalignment1275" headers="r2c1-t45 r1c2-t45">
<p>Commits</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r3c1-t45" headers="r1c1-t45">
<p>Commits</p>
</td>
<td class="cellalignment1275" headers="r3c1-t45 r1c2-t45">
<p>Rolls back</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r4c1-t45" headers="r1c1-t45">
<p>Rolls back</p>
</td>
<td class="cellalignment1275" headers="r4c1-t45 r1c2-t45">
<p>Commits</p>
</td>
</tr>
<tr class="cellalignment1267">
<td class="cellalignment1275" id="r5c1-t45" headers="r1c1-t45">
<p>Rolls back</p>
</td>
<td class="cellalignment1275" headers="r5c1-t45 r1c2-t45">
<p>Rolls back</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="g1033531"></a>
<div id="ADFNS99928" class="sect3">
<h4 class="sect3">Ordering a Product</h4>
<p><a href="#i1019975">Figure 2-5</a> shows an example of a customer ordering a product. The customer information (such as name, address, phone) is committed to a customer information table&mdash;even though the sale does not go through.</p>
<div id="ADFNS149" class="figure">
<p class="titleinfigure"><a id="i1019975"></a>Figure 2-5 Example: A Buy Order</p>
<img width="320" height="220" src="img/adfns057.gif" alt="Description of Figure 2-5 follows" /><br />
<a id="sthref355" href="img_text/adfns057.htm">Description of "Figure 2-5 Example: A Buy Order"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="g1033537"></a>
<div id="ADFNS99927" class="sect3">
<h4 class="sect3">Withdrawing Money from a Bank Account</h4>
<p>In this example, a customer tries to withdraw money from a bank account. In the process, a main transaction invokes one of two autonomous transaction scopes (AT Scope&nbsp;1 or AT Scope 2).</p>
<p>The possible scenarios for this transaction are:</p>
<ul>
<li>
<p><a href="#g1693454">Scenario 1: Sufficient Funds</a></p>
</li>
<li>
<p><a href="#g1693442">Scenario 2: Insufficient Funds with Overdraft Protection</a></p>
</li>
<li>
<p><a href="#g1693412">Scenario 3: Insufficient Funds Without Overdraft Protection</a></p>
</li>
</ul>
<a id="g1693454"></a>
<div id="ADFNS150" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Scenario 1: Sufficient Funds</h5>
<p>There are sufficient funds to cover the withdrawal, so the bank releases the funds (see <a href="#i1007457">Figure 2-6</a>).</p>
<div id="ADFNS151" class="figure">
<p class="titleinfigure"><a id="i1007457"></a>Figure 2-6 Bank Withdrawal&mdash;Sufficient Funds</p>
<img width="416" height="367" src="img/adfns058.gif" alt="Description of Figure 2-6 follows" /><br />
<a id="sthref356" href="img_text/adfns058.htm">Description of "Figure 2-6 Bank Withdrawal&mdash;Sufficient Funds"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<a id="g1693442"></a>
<div id="ADFNS152" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Scenario 2: Insufficient Funds with Overdraft Protection</h5>
<p>There are insufficient funds to cover the withdrawal, but the customer has overdraft protection, so the bank releases the funds (see <a href="#i1007467">Figure 2-7</a>).</p>
<div id="ADFNS153" class="figure">
<p class="titleinfigure"><a id="i1007467"></a>Figure 2-7 Bank Withdrawal&mdash;Insufficient Funds with Overdraft Protection</p>
<img width="416" height="391" src="img/adfns059.gif" alt="Description of Figure 2-7 follows" /><br />
<a id="sthref357" href="img_text/adfns059.htm">Description of "Figure 2-7 Bank Withdrawal&mdash;Insufficient Funds with Overdraft Protection"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<a id="g1693412"></a>
<div id="ADFNS154" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Scenario 3: Insufficient Funds Without Overdraft Protection</h5>
<p>There are insufficient funds to cover the withdrawal and the customer does not have overdraft protection, so the bank withholds the requested funds (see <a href="#i1007477">Figure 2-8</a>).</p>
<div id="ADFNS155" class="figure">
<p class="titleinfigure"><a id="i1007477"></a>Figure 2-8 Bank Withdrawal&mdash;Insufficient Funds Without Overdraft Protection</p>
<img width="416" height="391" src="img/adfns060.gif" alt="Description of Figure 2-8 follows" /><br />
<a id="sthref358" href="img_text/adfns060.htm">Description of "Figure 2-8 Bank Withdrawal&mdash;Insufficient Funds Without Overdraft Protection"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEJICBBD"></a>
<div id="ADFNS99926" class="sect2">
<h3 class="sect2">Defining Autonomous Transactions</h3>
<p>To define an autonomous transaction, use <code dir="ltr">PRAGMA</code> <code dir="ltr">AUTONOMOUS_TRANSACTION</code>, which instructs the PL/SQL compiler to mark the subprogram as autonomous.</p>
<p>In <a href="#BEJHCBDJ">Example 2-3</a>, the function <code dir="ltr">balance</code> is autonomous.</p>
<div id="ADFNS156" class="example">
<p class="titleinexample"><a id="BEJHCBDJ"></a>Example 2-3 Marking a Package Subprogram as Autonomous</p>
<pre dir="ltr">
-- Create table for package to use:
 
DROP TABLE accounts;
CREATE TABLE accounts (account INTEGER, balance REAL);
 
-- Create package:
 
CREATE OR REPLACE PACKAGE banking AS
  FUNCTION balance (acct_id INTEGER) RETURN REAL;
  -- Additional functions and packages
END banking;
/
CREATE OR REPLACE PACKAGE BODY banking AS
  FUNCTION balance (acct_id INTEGER) RETURN REAL IS
    <span class="bold">PRAGMA AUTONOMOUS_TRANSACTION</span>;
    my_bal  REAL;
  BEGIN
    SELECT balance INTO my_bal FROM accounts WHERE account=acct_id;
    RETURN my_bal;
  END;
  -- Additional functions and packages
END banking;
/
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNPLS01302" href="../../appdev.112/e25519/autotransaction_pragma.htm#LNPLS01302"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about <code dir="ltr">PRAGMA</code> <code dir="ltr">AUTONOMOUS_TRANSACTION</code></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007522"></a>
<div id="ADFNS00206" class="sect1">
<h2 class="sect1">Resuming Execution After Storage Allocation Errors</h2>
<p>When a long-running transaction is interrupted by a storage allocation error, the application can suspend the statement that encountered the problem, correct the problem, and then resume executing the statement. This capability, called <a id="sthref359"></a><a id="sthref360"></a><a id="sthref361"></a><a id="sthref362"></a><span class="glossaryterm">resumable storage allocation</span>, avoids time-consuming rollbacks. It also makes it unnecessary to split the operation into smaller pieces and write code to track its progress.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN014" href="../../server.112/e25494/schema.htm#ADMIN014"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about resumable storage allocation</div>
<p class="subhead2"><a id="sthref363"></a>Topics:</p>
<ul>
<li>
<p><a href="#g1033977">What Operations Have Resumable Storage Allocation?</a></p>
</li>
<li>
<p><a href="#g1033989">Handling Suspended Storage Allocation</a></p>
</li>
</ul>
<a id="g1033977"></a>
<div id="ADFNS99925" class="sect2">
<h3 class="sect2">What Operations Have Resumable Storage Allocation?</h3>
<p>Queries, DML statements, and some DDL statements have resumable storage allocation after these kinds of errors:</p>
<ul>
<li>
<p>Out-of-space errors, such as ORA-01653.</p>
</li>
<li>
<p>Space-limit errors, such as ORA-01628.</p>
</li>
<li>
<p>Space-quota errors, such as ORA-01536.</p>
</li>
</ul>
<p>Resumable storage allocation is possible whether the operation is performed directly by a SQL statement or within SQL*Loader, a stored subprogram, an anonymous PL/SQL block, or an OCI call such as <code dir="ltr">OCIStmtExecute</code>.</p>
<p>In dictionary-managed tablespaces, you cannot resume an index- or table-creating operation that encounters the limit for rollback segments or the maximum number of extents. You must use locally managed tablespaces and automatic undo management in combination with resumable storage allocation.</p>
</div>
<!-- class="sect2" -->
<a id="g1033989"></a>
<div id="ADFNS99924" class="sect2">
<h3 class="sect2">Handling Suspended Storage Allocation</h3>
<p>When a statement in an application is suspended because of a storage allocation error, the application does not receive an error code. Therefore, either the application must use an <code dir="ltr">AFTER</code> <code dir="ltr">SUSPEND</code> trigger or the DBA must periodically check for suspended statements.</p>
<p>After the problem is corrected (usually by the DBA), the suspended statement automatically resumes execution. If the timeout period expires before the problem is corrected, then the statement raises a <code dir="ltr">SERVERERROR</code> exception.</p>
<p class="subhead2"><a id="sthref364"></a>Topics:</p>
<ul>
<li>
<p><a href="#BEJDJAHA">Using an AFTER SUSPEND Trigger in the Application</a></p>
</li>
<li>
<p><a href="#BEJCIHHI">Checking for Suspended Statements</a></p>
</li>
</ul>
<a id="BEJDJAHA"></a>
<div id="ADFNS99870" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using an AFTER SUSPEND Trigger in the Application</h4>
<p>In the application, an <a id="sthref365"></a><a id="sthref366"></a><code dir="ltr">AFTER</code> <code dir="ltr">SUSPEND</code> trigger can get information about the problem by invoking subprograms in the <code dir="ltr">DBMS_RESUMABLE</code> package (described in <a class="olink ARPLS143" href="../../appdev.112/e40758/d_resuma.htm#ARPLS143"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>). Then the trigger can send the information to an operator, using email (for example).</p>
<p>To reduce the chance of out-of-space errors within the trigger itself, declare the trigger as an <a id="sthref367"></a><a id="sthref368"></a><a id="sthref369"></a>autonomous transaction. As an autonomous transaction, the trigger uses a rollback segment in the <code dir="ltr">SYSTEM</code> tablespace. If the trigger encounters a deadlock condition because of locks held by the suspended statement, then the trigger terminates and the application receives the original error code, as if the statement were never suspended. If the trigger encounters an out-of-space condition, then both the trigger and the suspended statement are rolled back. To prevent rollback, use an exception handler in the trigger to wait for the statement to resume.</p>
<p>For general information about triggers, see <a class="olink LNPLS020" href="../../appdev.112/e25519/triggers.htm#LNPLS020"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>The trigger in <a href="#CHDFBBJE">Example 2-4</a> handles storage errors within the database. For some kinds of errors, the trigger terminates the statement and alerts the DBA, using e-mail. For other errors, which might be temporary, the trigger specifies that the statement waits for eight hours before resuming, expecting the storage problem to be fixed by then. To run this example, you must connect to the database as <code dir="ltr">SYSDBA</code>.</p>
<div id="ADFNS157" class="example">
<p class="titleinexample"><a id="CHDFBBJE"></a>Example 2-4 AFTER SUSPEND Trigger Handles Suspended Storage Allocation</p>
<pre dir="ltr">
-- Create table used by trigger body
 
DROP TABLE rbs_error;
CREATE TABLE rbs_error (
  SQL_TEXT VARCHAR2(64),
  ERROR_MSG VARCHAR2(64),
  SUSPEND_TIME VARCHAR2(64)
);
 
-- Resumable Storage Allocation

CREATE OR REPLACE TRIGGER suspend_example
  <span class="bold">AFTER SUSPEND</span>
  <span class="bold">ON DATABASE</span>
DECLARE
  cur_sid           NUMBER;
  cur_inst          NUMBER;
  err_type          VARCHAR2(64);
  object_owner      VARCHAR2(64);
  object_type       VARCHAR2(64);
  table_space_name  VARCHAR2(64);
  object_name       VARCHAR2(64);
  sub_object_name   VARCHAR2(64);
  msg_body          VARCHAR2(64);
  ret_value         BOOLEAN;
  error_txt         VARCHAR2(64);
  mail_conn         UTL_SMTP.CONNECTION;
BEGIN
 SELECT DISTINCT(SID) INTO cur_sid FROM V$MYSTAT;
 cur_inst := USERENV('instance');
 ret_value := <span class="bold">DBMS_RESUMABLE.SPACE_ERROR_INFO</span>
              <span class="bold">(err_type,</span>
              <span class="bold">object_owner,</span>
              <span class="bold">object_type,</span>
              <span class="bold">table_space_name,</span>
              <span class="bold">object_name,</span>
              <span class="bold">sub_object_name);</span>
 IF object_type = 'ROLLBACK SEGMENT' THEN
   INSERT INTO rbs_error
     (SELECT SQL_TEXT, ERROR_MSG, SUSPEND_TIME
      FROM DBA_RESUMABLE
      WHERE SESSION_ID = cur_sid
      AND INSTANCE_ID = cur_inst);

    SELECT ERROR_MSG INTO error_txt
    FROM DBA_RESUMABLE
    WHERE SESSION_ID = cur_sid
    AND INSTANCE_ID = cur_inst;

    msg_body :=
     'Space error occurred: Space limit reached for rollback segment '
     || object_name || ' on ' || to_char(SYSDATE, 'Month dd, YYYY, HH:MIam')
     || '. Error message was: ' || error_txt;

    mail_conn := UTL_SMTP.OPEN_CONNECTION('localhost', 25);
    UTL_SMTP.HELO(mail_conn, 'localhost');
    UTL_SMTP.MAIL(mail_conn, 'sender@localhost');
    UTL_SMTP.RCPT(mail_conn, 'recipient@localhost');
    UTL_SMTP.DATA(mail_conn, msg_body);
    UTL_SMTP.QUIT(mail_conn);
    <span class="bold">DBMS_RESUMABLE.ABORT(cur_sid);</span>
  ELSE
    <span class="bold">DBMS_RESUMABLE.SET_TIMEOUT(3600*8);</span>
  END IF;
  COMMIT;
END;
/
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="BEJCIHHI"></a>
<div id="ADFNS99869" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Checking for Suspended Statements</h4>
<p>If the application does not use an <code dir="ltr">AFTER</code> <code dir="ltr">SUSPEND</code> trigger, then the DBA must periodically check for suspended statements, using the static data dictionary view <code dir="ltr">DBA_RESUMABLE</code> (described in <a class="olink REFRN23228" href="../../server.112/e40402/statviews_4216.htm#REFRN23228"><span class="italic">Oracle Database Reference</span></a>).</p>
<p>The DBA can get additional information from the dynamic performance view <code dir="ltr">V$_SESSION_WAIT</code> (described in <a class="olink REFRN30229" href="../../server.112/e40402/dynviews_3024.htm#REFRN30229"><span class="italic">Oracle Database Reference</span></a>).</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1266">
<tr>
<td class="cellalignment1275">
<table class="cellalignment1271">
<tr>
<td class="cellalignment1270"><a href="adfns_sqltypes.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1270"><a href="adfns_regexp.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2014,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1277">
<table class="cellalignment1269">
<tr>
<td class="cellalignment1270"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1270"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1270"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1270"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1270"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1270"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
