<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Performing Flashback and Database Point-in-Time Recovery</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1054" />
<meta name="description" content="A guide to backup and recovery of Oracle databases, including RMAN backup and recovery, RMAN data transfer, Oracle Flashback Technology, and user-managed backup and recovery" />
<meta name="dcterms.created" content="2015-05-13T14:1:11Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Backup and Recovery User's Guide" />
<meta name="dcterms.identifier" content="E10642-08" />
<meta name="dcterms.isVersionOf" content="BRADV" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="rcmcomre.htm" title="Previous" type="text/html" />
<link rel="Next" href="rcmblock.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10642.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">30/47</span> <!-- End Header -->
<div id="BRADV80055" class="chapter"><a id="g1016666"></a>
<h1 class="chapter"><span class="secnum">18</span> Performing Flashback and Database Point-in-Time Recovery</h1>
<p>This chapter explains how to investigate unwanted database changes, and select and perform an appropriate recovery strategy based upon Oracle Flashback Technology and database backups. It includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDDACBJ">Overview of Oracle Flashback Technology and Database Point-in-Time Recovery</a></p>
</li>
<li>
<p><a href="#i1018669">Rewinding a Table with Flashback Table</a></p>
</li>
<li>
<p><a href="#i1016939">Rewinding a DROP TABLE Operation with Flashback Drop</a></p>
</li>
<li>
<p><a href="#BGBDCAFA">Rewinding a Database with Flashback Database</a></p>
</li>
<li>
<p><a href="#i1011846">Performing Database Point-in-Time Recovery</a></p>
</li>
<li>
<p><a href="#CHDBDIGH">Flashback and Database Point-in-Time Recovery Scenarios</a></p>
</li>
</ul>
<a id="CHDDACBJ"></a>
<div id="BRADV89737" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of Oracle Flashback Technology and Database Point-in-Time Recovery</h2>
<p><a id="sthref1560"></a>This section explains the purpose and basic concepts of Flashback Technology and database point-in-time recovery.</p>
<div id="BRADV89738" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1561"></a>
<h3 class="sect2">Purpose of Flashback and Database Point-in-Time-Recovery</h3>
<p><a id="sthref1562"></a>Typically, the following situations call for flashback features or point-in-time recovery:</p>
<ul>
<li>
<p>A user error or corruption removes needed data or introduces corrupted data. For example, a user or DBA might erroneously delete or update the contents of one or more tables, drop database objects that are still needed during an update to an application, or run a large batch update that fails midway.</p>
</li>
<li>
<p>A database upgrade fails or an upgrade script goes awry.</p>
</li>
<li>
<p>A complete database recovery after a media failure cannot succeed because you do not have all of the needed redo logs or incremental backups.</p>
</li>
</ul>
<p>In either situation, you can use point-in-time recovery or flashback features to return the database or database object to its state at a previous point in time.</p>
</div>
<!-- class="sect2" -->
<a id="BGBCIEGG"></a>
<div id="BRADV89739" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Basic Concepts of Point-in-Time Recovery and Flashback Features</h3>
<p>The most basic solution to unwanted database changes is RMAN <a href="glossary.htm#i999787"><span class="xrefglossterm">database point-in-time recovery (DBPITR)</span></a>. DBPITR is sometimes called <a href="glossary.htm#i432744"><span class="xrefglossterm">incomplete recovery</span></a> because it does not use all of the available redo or completely recover all changes to your database. In this case, you restore a whole database backup and then apply redo logs or incremental backups to re-create all changes up to a point in time before the unwanted change.</p>
<p>If unwanted database changes are extensive but confined to specific tablespaces, then you can use<a id="sthref1563"></a><a id="sthref1564"></a> <a href="glossary.htm#i433562"><span class="xrefglossterm">tablespace point-in-time recovery (TSPITR)</span></a> to return these tablespaces to an earlier SCN while the unaffected tablespaces remain available. RMAN TSPITR is an advanced technique described in <a href="rcmtspit.htm#CIHGGAFH">Chapter 21, "Performing RMAN Tablespace Point-in-Time Recovery (TSPITR)"</a>.</p>
<p>Oracle Database also provides a set of features collectively known as <a id="sthref1565"></a>Flashback Technology that supports viewing past states of data, and winding and rewinding data back and forth in time, without requiring the restore of the database from backup. Depending on the changes to your database, Flashback Technology can often reverse the unwanted changes more quickly and with less impact on database availability.</p>
<div id="BRADV89740" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1566"></a>
<h4 class="sect3">Basic Concepts of Database Point-in-Time Recovery</h4>
<p><a id="sthref1567"></a>DBPITR works at the physical level to return the data files to their state at a target time in the past. In an RMAN DBPITR operation, you specify a target SCN, log sequence, restore point, or time. RMAN restores the database from backups created before the target time, and then applies incremental backups and logs to re-create all changes between the time of the data file backups and the end point of recovery. When the end point is specified as an SCN, the database applies the redo logs and stops at the end of each redo thread or the specified SCN, whichever occurs first. When the end point is specified as a time, the database internally determines a suitable SCN for the specified time and then recovers to this SCN.</p>
<p>If your backup strategy is properly designed and your database is running in <code dir="ltr">ARCHIVELOG</code> mode, then DBPITR is an option in nearly all circumstances. RMAN simplifies DBPITR in comparison to the user-managed DBPITR described in <a href="osrecvry.htm#i1007175">"Performing Incomplete Database Recovery"</a>. Given a target SCN, data files are restored from backup and recovered efficiently with no intervention from the user. Nevertheless, RMAN DBPITR has the following disadvantages:</p>
<ul>
<li>
<p>You cannot return selected objects to their earlier state, only the entire database.</p>
</li>
<li>
<p>Your entire database is unavailable during the DBPITR.</p>
</li>
<li>
<p>DBPITR can be time-consuming because RMAN must restore all data files. Also, RMAN may need to restore redo logs and incremental backups to recover the data files. If backups are on tape, then this process can take even longer.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="BRADV8702" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1568"></a>
<h4 class="sect3">Basic Concepts of Flashback Technology</h4>
<p>The flashback features of Oracle are more efficient than media recovery in most circumstances in which they are available. You can use them to investigate past states of the database.</p>
<div id="BRADV89741" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1569"></a>
<h5 class="sect4">Physical Flashback Features Useful in Backup and Recovery</h5>
<p><a href="glossary.htm#CHDHJFEH"><span class="xrefglossterm">Oracle Flashback Database</span></a>, which is explained in <a href="#BGBDCAFA">"Rewinding a Database with Flashback Database"</a>, is the most efficient alternative to DBPITR. Unlike the other flashback features, it operates at a physical level and reverts the current data files to their contents at a past time. The result is like the result of a DBPITR, including the <code dir="ltr">OPEN RESETLOGS</code>, but Flashback Database is typically faster because it does not require you to restore data files and requires only limited application of redo compared to media recovery.</p>
<p>As explained in <a href="rcmconfb.htm#i1019160">"Configuring the Fast Recovery Area"</a>, a <a href="glossary.htm#i999320"><span class="xrefglossterm">fast recovery area</span></a> is required for Flashback Database. To enable logging for Flashback Database, you must set the <a class="olink REFRN10233" href="../../server.112/e40402/initparams061.htm#REFRN10233"><code dir="ltr">DB_FLASHBACK_RETENTION_TARGET</code></a> initialization parameter and issue the <code dir="ltr">ALTER</code> <code dir="ltr">DATABASE</code> <code dir="ltr">FLASHBACK</code> <code dir="ltr">ON</code> statement.</p>
<p>During normal operation, the database periodically writes old images of data file blocks to the <a href="glossary.htm#CHDFHAAE"><span class="xrefglossterm">flashback logs</span></a>. Flashback logs are written sequentially and often in bulk. In some respects, flashback logging is like a continuous backup. The database automatically creates, deletes, and resizes flashback logs in the recovery area<a id="sthref1570"></a>. Flashback logs are not archived. You need only be aware of flashback logs for monitoring performance and determining disk space allocation for the recovery area.</p>
<p>When you perform a Flashback Database operation, the database uses flashback logs<a id="sthref1571"></a> to access past versions of data blocks and also uses some data in the archived redo logs. Consequently, you cannot enable Flashback Database <span class="italic">after</span> a failure is discovered and then use Flashback Database to rewind through this failure. You can use the related capability of guaranteed restore points to protect the contents of your database at a fixed point in time, such as immediately before a risky database change.</p>
</div>
<!-- class="sect4" -->
<div id="BRADV89742" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1572"></a>
<h5 class="sect4">Logical Flashback Features Useful in Backup and Recovery</h5>
<p>The remaining <a id="sthref1573"></a>flashback features operate at the logical level. The logical features documented in this chapter are as follows:</p>
<ul>
<li>
<p><a id="sthref1574"></a>Flashback Table</p>
<p>You can recover a table or set of tables to a specified point in time in the past without taking any part of the database offline. In many cases, Flashback Table eliminates the need to perform more complicated point-in-time recovery operations. Flashback Table restores tables while automatically maintaining associated attributes such as current indexes, triggers and constraints, and not requiring you to find and restore application-specific properties.</p>
<p><a href="#i1018669">"Rewinding a Table with Flashback Table"</a> explains how to use this feature.</p>
</li>
<li>
<p><a id="sthref1575"></a>Flashback Drop</p>
<p>You can reverse the effects of a <code dir="ltr">DROP</code> <code dir="ltr">TABLE</code> statement.</p>
<p><a href="#i1016939">"Rewinding a DROP TABLE Operation with Flashback Drop"</a> explains how to use this feature.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the logical flashback features have uses not specific to backup and recovery, some documentation for them is located elsewhere in the documentation set.</div>
<p>All logical flashback features except Flashback Drop rely on <span class="glossaryterm">undo data</span>. Used primarily for providing read consistency for SQL queries and rolling back transactions, undo records contain the information required to reconstruct data as it existed at a past time and examine the record of changes since that past time.</p>
<p>Flashback Drop relies on a mechanism called the <a id="sthref1576"></a><a href="glossary.htm#CHDHHCDC"><span class="xrefglossterm">recycle bin</span></a>, which the database uses to manage dropped database objects until the space they occupied is needed for new data. There is no fixed amount of space allocated to the recycle bin, and no guarantee about how long dropped objects remain in the recycle bin. Depending on system activity, a dropped object may remain in the recycle bin for seconds or for months.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a class="olink CNCPT305" href="../../server.112/e40540/logical.htm#CNCPT305"><span class="italic">Oracle Database Concepts</span></a> and <a class="olink ADMIN013" href="../../server.112/e25494/undo.htm#ADMIN013"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about undo data and automatic undo management</p>
</li>
<li>
<p><a class="olink ADFNS1008" href="../../appdev.112/e41502/adfns_flashback.htm#ADFNS1008"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> to learn how to use the logical flashback features</p>
</li>
<li>
<p><a href="flashdb.htm#CFHCEIHB">"Understanding Flashback Database, Restore Points and Guaranteed Restore Points"</a> for more information on setting up your database to use Flashback Database, and on the related restore points feature</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1018669"></a>
<div id="BRADV81517" class="sect1">
<h2 class="sect1">Rewinding a Table with Flashback Table</h2>
<p>Flashback Table uses information in the undo tablespace rather than restored backups to retrieve the table. When a Flashback Table operation occurs, new rows are deleted and old rows are reinserted. The rest of your database remains available while the flashback of the table is being performed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN013" href="../../server.112/e25494/undo.htm#ADMIN013"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on Automatic Undo Management</div>
<div id="BRADV89743" class="sect2"><a id="sthref1577"></a>
<h3 class="sect2">Prerequisites of Flashback Table<a id="sthref1578"></a></h3>
<p><a id="sthref1579"></a>To use the Flashback Table feature on one or more tables, use <a id="sthref1580"></a>the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> SQL statement with a target time or SCN.</p>
<p>You must have the following privileges to use the Flashback Table feature:</p>
<ul>
<li>
<p>You must have been granted the <code dir="ltr">FLASHBACK ANY TABLE</code> system privilege or you must have the <code dir="ltr">FLASHBACK</code> object privilege on the table.</p>
</li>
<li>
<p>You must have <code dir="ltr">SELECT</code>, <code dir="ltr">INSERT</code>, <code dir="ltr">DELETE</code>, and <code dir="ltr">ALTER</code> privileges on the table.</p>
</li>
<li>
<p>To flash back a table to a restore point, you must have the <code dir="ltr">SELECT ANY DICTIONARY</code> or <code dir="ltr">FLASHBACK ANY TABLE</code> system privilege or the <code dir="ltr">SELECT_CATALOG_ROLE</code> role.</p>
</li>
</ul>
<p>For an object to be eligible to be flashed back, the following prerequisites must be met:</p>
<ul>
<li>
<p>The object must <span class="bold">not</span> be included the following categories: tables that are part of a cluster, materialized views, Advanced Queuing (AQ) tables, static data dictionary tables, system tables, remote tables, object tables, nested tables, or individual table partitions or subpartitions.</p>
</li>
<li>
<p>The structure of the table must not have been changed between the current time and the target flash back time.</p>
<p>The following DDL operations change the structure of a table: upgrading, moving, or truncating a table; adding a constraint to a table, adding a table to a cluster; modifying or dropping a column; adding, dropping, merging, splitting, coalescing, or truncating a partition or subpartition (except adding a range partition).</p>
</li>
<li>
<p>Row movement must be enabled on the table, which indicates that rowids will change after the flashback occurs.</p>
<p>This restriction exists because if rowids before the flashback were stored by the application, then there is no guarantee that the rowids correspond to the same rows after the flashback. If your application depends on rowids, then you cannot use Flashback Table.</p>
</li>
<li>
<p>The undo data in the <a href="glossary.htm#i433663"><span class="xrefglossterm">undo tablespace</span></a> must extend far enough back in time to satisfy the flashback target time or SCN.</p>
<p>The point to which you can perform Flashback Table is determined by the <a href="glossary.htm#CHDHADBG"><span class="xrefglossterm">undo retention period</span></a>, which is the minimal time for which undo data is kept before being recycled, and tablespace characteristics. The undo data contains information about data blocks before they were changed. The flashback operation uses undo to re-create the original data.</p>
<p>To ensure that the undo information is retained for Flashback Table operations, Oracle suggests setting the <code dir="ltr">UNDO_RETENTION</code> parameter to 86400 seconds (24 hours) or greater for the undo tablespace.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> <code dir="ltr">...</code> <code dir="ltr">TO</code> <code dir="ltr">BEFORE</code> <code dir="ltr">DROP</code> is a use of the Flashback Drop feature, not Flashback Table, and therefore is not subject to these prerequisites. See <a href="#i1016939">"Rewinding a DROP TABLE Operation with Flashback Drop"</a> for more information.</div>
</div>
<!-- class="sect2" -->
<div id="BRADV89744" class="sect2"><a id="sthref1581"></a>
<h3 class="sect2">Performing a Flashback Table Operation<a id="sthref1582"></a><a id="sthref1583"></a></h3>
<p>In this scenario, assume that you want to perform a flashback of the <code dir="ltr">hr.temp_employees</code> table after a user made some incorrect updates.</p>
<p class="subhead2"><a id="BRADV341"></a>The perform a flashback of <code dir="ltr">temp_employees</code>:</p>
<ol>
<li>
<p>Connect SQL*Plus to the target database and identify the current SCN.</p>
<p>You cannot roll back a <code dir="ltr">FLASHBACK TABLE</code> statement, but you can issue another <code dir="ltr">FLASHBACK TABLE</code> statement and specify a time just before the current time. Therefore, it is advisable to record the current SCN. You can obtain it by <a id="sthref1584"></a>querying <code dir="ltr">V$DATABASE</code> as follows:</p>
<pre dir="ltr">
SELECT CURRENT_SCN
FROM   V$DATABASE;
</pre></li>
<li>
<p>Identify the time, SCN, or restore point to which you want to return the table.</p>
<p>If you have created restore points, then you can list available restore points by executing the following <a id="sthref1585"></a>query:</p>
<pre dir="ltr">
SELECT NAME, SCN, TIME 
FROM   V$RESTORE_POINT;
</pre></li>
<li>
<p>Ensure that enough undo data exists to rewind the table to the specified target.</p>
<p>If the <code dir="ltr">UNDO_RETENTION</code> intialization parameter is set, and the undo retention guarantee is on, then you can use the following query to determine how long undo data is being <a id="sthref1586"></a>retained:</p>
<pre dir="ltr">
SELECT NAME, VALUE/60 MINUTES_RETAINED
FROM   V$PARAMETER
WHERE  NAME = 'undo_retention';
</pre></li>
<li>
<p>Ensure that row movement is enabled for all objects that you are rewinding with Flashback Table.</p>
<p>You can enable row movement for a table with the following SQL statement, where <span class="italic">table</span> is the name of the table that you are rewinding:</p>
<pre dir="ltr">
ALTER TABLE <span class="italic">table </span>ENABLE ROW MOVEMENT;
</pre></li>
<li>
<p>Determine whether the table that you intend to flash back has dependencies on other tables. If dependencies exist, then decide whether to flash back these tables as well.</p>
<p>You can issue the following SQL query to determine the dependencies, where <span class="italic">schema_name</span> is the schema for the table to be flashed back and <span class="italic">table_name</span> is the name of the table:</p>
<pre dir="ltr">
SELECT other.owner, other.table_name
FROM   sys.all_constraints this, sys.all_constraints other
WHERE  this.owner = <span class="italic">schema_name</span>
AND    this.table_name = <span class="italic">table_name</span>
AND    this.r_owner = other.owner
AND    this.r_constraint_name = other.constraint_name
AND    this.constraint_type='R';
</pre></li>
<li id="CHDHCAGI">
<p>Execute a <code dir="ltr">FLASHBACK TABLE</code> statement for the objects that you want to flash back.</p>
<p>The following SQL statement returns the <code dir="ltr">hr.temp_employees</code> table to the restore point named <code dir="ltr">temp_employees_update</code>:</p>
<pre dir="ltr">
FLASHBACK TABLE hr.temp_employees
  TO RESTORE POINT temp_employees_update;
</pre>
<p>The following SQL statement rewinds the <code dir="ltr">hr.temp_employees</code> table to its state when the database was at the time specified by the SCN:</p>
<pre dir="ltr">
FLASHBACK TABLE hr.temp_employees
  TO SCN 123456;
</pre>
<p>As shown in the following example, you can also specify the target point in time with <code dir="ltr">TO_TIMESTAMP</code>:</p>
<pre dir="ltr">
FLASHBACK TABLE hr.temp_employees
  TO TIMESTAMP TO_TIMESTAMP('2007-10-17 09:30:00', 'YYYY-MM-DD HH:MI:SS');
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The mapping of timestamps to SCNs is not always exact. When using timestamps with the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> statement, the time to which the table is flashed back can vary by up to approximately three seconds of the time specified for <code dir="ltr">TO_TIMESTAMP</code>. If an exact point in time is required, then use an SCN rather than a time.</div>
</li>
<li>
<p>Optionally, query the table to check the data.</p>
</li>
</ol>
<div id="BRADV89745" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1587"></a>
<h4 class="sect3">Keeping Triggers Enabled During Flashback Table</h4>
<p>By default, the database disables triggers on the affected table before performing a <code dir="ltr">FLASHBACK TABLE</code> operation. After the operation, the database returns the triggers to the state they were in before the operation (enabled or disabled). To keep triggers enabled during the flashback of the table, add an <code dir="ltr">ENABLE TRIGGERS</code> clause to the <code dir="ltr">FLASHBACK TABLE</code> statement in Step <a href="#CHDHCAGI">6</a>.</p>
<p>For example, assume that at 17:00 an HR administrator discovers that an employee is missing from the <code dir="ltr">hr.temp_employees</code> table. This employee was included in the table at 14:00, the last time the report was run. Therefore, someone accidentally deleted the record for this employee between 14:00 and 17:00. She uses Flashback Table to return the table to its state at 14:00, respecting any triggers set on the <code dir="ltr">hr.temp_employees</code> table, by using the SQL statement in the following example:</p>
<pre dir="ltr">
FLASHBACK TABLE temp_employees
  TO TIMESTAMP TO_TIMESTAMP('2005-03-03 14:00:00' , 'YYYY-MM-DD HH:MI:SS') 
  ENABLE TRIGGERS;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN01512" href="../../server.112/e25494/tables.htm#ADMIN01512"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to recover tables with the Flashback Table feature</p>
</li>
<li>
<p><a class="olink SQLRF01802" href="../../server.112/e41084/statements_9012.htm#SQLRF01802"><span class="italic">Oracle Database SQL Language Reference</span></a> for a simple Flashback Table scenario</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1016939"></a>
<div id="BRADV81511" class="sect1">
<h2 class="sect1">Rewinding a DROP TABLE Operation with Flashback Drop</h2>
<p>This section explains how to retrieve objects from the recycle bin with the <code dir="ltr">FLASHBACK TABLE ... TO BEFORE DROP</code> statement.</p>
<div id="BRADV89746" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1588"></a>
<h3 class="sect2">About Flashback Drop</h3>
<p><a id="sthref1589"></a><a id="sthref1590"></a>Flashback Drop reverses the effects of a <code dir="ltr">DROP TABLE</code> operation. Flashback Drop is faster than other recovery mechanisms that can be used in this situation, such as point-in-time recovery, and does not lead to downtime or loss of recent transactions.</p>
<p>When you drop a table, the database does not immediately remove the space associated with the table. Instead, the table is renamed and, along with any associated objects, placed in the recycle bin. System-generated recycle bin object names are unique. You can query objects in the recycle bin, just as you can query other objects.</p>
<p>A flashback operation retrieves the table from the recycle bin. When retrieving dropped tables, you can specify either the original user-specified name of the table or the system-generated name.</p>
<p>When you drop a table, the table and all of its dependent objects go into the recycle bin together. Likewise, when you perform Flashback Drop, the objects are generally all retrieved together. When you restore a table from the recycle bin, dependent objects such as indexes do not get their original names back; they retain their system-generated recycle bin names. Oracle Database retrieves all indexes defined on the table except for bitmap join indexes, and all triggers and constraints defined on the table except for referential integrity constraints that reference other tables.</p>
<p>Some dependent objects such as indexes may have been reclaimed because of space pressure. In such cases, the reclaimed dependent objects are not retrievable from the recycle bin.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCEGJG"></a>
<div id="BRADV89747" class="sect2">
<h3 class="sect2">Prerequisites of Flashback Drop</h3>
<p>The following list summarizes the user privileges required for the operations related to Flashback Drop and the recycle bin:</p>
<ul>
<li>
<p><code dir="ltr">DROP</code></p>
<p>Any user with drop privileges over an object can drop the object, placing it in the recycle bin.</p>
</li>
<li>
<p><code dir="ltr">FLASHBACK TABLE ... TO BEFORE DROP</code></p>
<p>Privileges for this statement are tied to the privileges for <code dir="ltr">DROP</code>. That is, any user who can drop an object can perform Flashback Drop to retrieve the dropped object from the recycle bin.</p>
</li>
<li>
<p><code dir="ltr">PURGE</code></p>
<p>Privileges for a purge of the recycle bin are tied to the <code dir="ltr">DROP</code> privileges. Any user having <code dir="ltr">DROP</code> <code dir="ltr">TABLE</code> or <code dir="ltr">DROP</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> privileges can purge the objects from the recycle bin.</p>
</li>
<li>
<p><code dir="ltr">SELECT</code> for objects in the Recycle Bin</p>
<p>Users must have <code dir="ltr">SELECT</code> and <code dir="ltr">FLASHBACK</code> privileges over an object in the recycle bin to query the object in the recycle bin. Any users who had the <code dir="ltr">SELECT</code> privilege over an object before it was dropped continue to have the <code dir="ltr">SELECT</code> privilege over the object in the recycle bin. Users must have <code dir="ltr">FLASHBACK</code> privilege to query any object in the recycle bin because these are objects from a past state of the database.</p>
</li>
</ul>
<p>Objects must meet the following prerequisites to be eligible for retrieval from the recycle bin:</p>
<ul>
<li>
<p>The <a id="sthref1591"></a>recycle bin is only available for non-system, locally managed tablespaces. If a table is in a non-system, locally managed tablespace, but one or more of its dependent segments (objects) is in a dictionary-managed tablespace, then these objects are protected by the recycle bin.</p>
</li>
<li>
<p>Tables that have Fine-Grained Auditing (FGA) and Virtual Private Database (VPD) policies defined over them are not protected by the recycle bin.</p>
</li>
<li>
<p>Partitioned index-organized tables are not protected by the recycle bin.</p>
</li>
<li>
<p>The table must not have been purged, either by a user or by Oracle Database because of a space reclamation operation.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDDACBI"></a>
<div id="BRADV89748" class="sect2">
<h3 class="sect2">Performing a Flashback Drop Operation</h3>
<p>Use the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> <code dir="ltr">...</code> <code dir="ltr">TO</code> <code dir="ltr">BEFORE</code> <code dir="ltr">DROP</code> statement to recover objects from the recycle bin. You can specify either the name of the table in the <a id="sthref1592"></a><a id="sthref1593"></a>recycle bin or the original table name.</p>
<p>This section assumes a scenario in which you drop the wrong table. Many times you have been asked to drop tables in the test databases, but in this case you accidentally connect to the production database instead and drop <code dir="ltr">hr.employee_demo</code>. You decide to use <code dir="ltr">FLASHBACK TABLE</code> to retrieve the dropped object.</p>
<p class="subhead2"><a id="BRADV342"></a>To retrieve a dropped table:</p>
<ol>
<li>
<p>Connect SQL*Plus to the target database and obtain the name of the dropped table in the recycle bin.</p>
<p>You can use the SQL*Plus command <code dir="ltr">SHOW RECYCLEBIN</code> as follows:</p>
<pre dir="ltr">
SHOW RECYCLEBIN;

ORIGINAL NAME    RECYCLEBIN NAME                   TYPE         DROP TIME
---------------- --------------------------------- ------------ -------------
EMPLOYEE_DEMO    BIN$gk3lsj/3akk5hg3j2lkl5j3d==$0  TABLE    2005-04-11:17:08:54
</pre>
<p>The <code dir="ltr">ORIGINAL NAME</code> column shows the original name of the object, while the <code dir="ltr">RECYCLEBIN NAME</code> column shows the name of the object as it exists in the bin.</p>
<p>Alternatively, you can query <code dir="ltr">USER_RECYCLEBIN</code> or <code dir="ltr">DBA_RECYCLEBIN</code> to obtain the table name. The following example queries the views to determine the original names of dropped objects:</p>
<pre dir="ltr">
SELECT object_name AS recycle_name, original_name, type 
FROM   recyclebin;

RECYCLE_NAME                      ORIGINAL_NAME          TYPE
--------------------------------  ---------------------  ----------
BIN$gk3lsj/3akk5hg3j2lkl5j3d==$0  EMPLOYEE_DEMO          TABLE
BIN$JKS983293M1dsab4gsz/I249==$0  I_EMP_DEMO             INDEX
</pre>
<p>If you plan to manually restore original names for dependent objects, then ensure that you make note of each dependent object's system-generated recycle bin name before you restore the table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Object views such as <code dir="ltr">DBA_TABLES</code> do not display the recycle bin objects.</div>
</li>
<li>
<p>Optionally, query the table in the recycle bin.</p>
<p>You must use the recycle bin name of the object in your query rather than the object's original name. The following example queries the table with the recycle bin name of <code dir="ltr">BIN$KSD8DB9L345KLA==$0</code>:</p>
<pre dir="ltr">
SELECT * 
FROM   "BIN$gk3lsj/3akk5hg3j2lkl5j3d==$0";
</pre>
<p>Quotes are required because of the special characters in the recycle bin name.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have the necessary privileges, then you can also use Flashback Query on tables in the recycle bin, but only by using the recycle bin name rather than the original table name. You cannot use DML or DDL statements on objects in the recycle bin.</div>
</li>
<li>
<p>Retrieve the dropped table.</p>
<p>Use the <code dir="ltr">FLASHBACK TABLE ... TO BEFORE DROP</code> statement. The following example restores the <code dir="ltr">BIN$gk3lsj/3akk5hg3j2lkl5j3d==$0</code> table, changes its name back to <code dir="ltr">hr.employee_demo</code>, and purges its entry from the recycle bin:</p>
<pre dir="ltr">
FLASHBACK TABLE "BIN$gk3lsj/3akk5hg3j2lkl5j3d==$0" TO BEFORE DROP;
</pre>
<p>The table name is enclosed in quotes because of the possibility of special characters appearing in the recycle bin object names.</p>
<p>Alternatively, you can use the original name of the table:</p>
<pre dir="ltr">
FLASHBACK TABLE HR.EMPLOYEE_DEMO TO BEFORE DROP;
</pre>
<p>You can also assign a new name to the restored table by specifying the <code dir="ltr">RENAME TO</code> clause. For example:</p>
<pre dir="ltr">
FLASHBACK TABLE "BIN$KSD8DB9L345KLA==$0" TO BEFORE DROP 
  RENAME TO hr.emp_demo;
</pre></li>
<li>
<p>Optionally, verify that all dependent objects retained their system-generated recycle bin names.</p>
<p>The following query determines the names of the indexes of the retrieved <code dir="ltr">hr.employee_demo</code> table:</p>
<pre dir="ltr">
SELECT INDEX_NAME 
FROM   USER_INDEXES 
WHERE  TABLE_NAME = 'EMPLOYEE_DEMO';

INDEX_NAME
------------------------------
BIN$JKS983293M1dsab4gsz/I249==$0
</pre></li>
<li>
<p>Optionally, rename the retrieved indexes to their original names.</p>
<p>The following statement renames the index to its original name of <code dir="ltr">i_emp_demo</code>:</p>
<pre dir="ltr">
ALTER INDEX "BIN$JKS983293M1dsab4gsz/I249==$0" RENAME TO I_EMP_DEMO;
</pre></li>
<li>
<p>If the retrieved table had referential constraints before it was placed in the recycle bin, then re-create them.</p>
<p>This step must be performed manually because the recycle bin does not preserve referential constraints on a table.</p>
</li>
</ol>
<div id="BRADV89749" class="sect3"><a id="sthref1594"></a>
<h4 class="sect3">Retrieving Objects When Multiple Objects Share the Same Original Name</h4>
<p>You can create, and then drop, several objects with the same original name. All the dropped objects are stored in the recycle bin. For example, consider the SQL statements in the following example.</p>
<div id="BRADV343" class="example">
<p class="titleinexample"><a id="CHDHFEHA"></a>Example 18-1 Dropping Multiple Objects with the Same Name</p>
<pre dir="ltr">
CREATE TABLE temp_employees ( <span class="italic">...columns</span> ); # temp_employees version 1
DROP TABLE temp_employees;

CREATE TABLE temp_employees ( <span class="italic">...columns</span> ); # temp_employees version 2
DROP TABLE temp_employees;

CREATE TABLE temp_employees ( <span class="italic">...columns</span> ); # temp_employees version 3
DROP TABLE temp_employees;
</pre></div>
<!-- class="example" -->
<p>In <a href="#CHDHFEHA">Example 18-1</a>, each table <code dir="ltr">temp_employees</code> is assigned a unique name in the recycle bin when it is dropped. You can use a <code dir="ltr">FLASHBACK TABLE ... TO BEFORE DROP</code> statement with the original name of the table, as shown in this example:</p>
<pre dir="ltr">
FLASHBACK TABLE temp_employees TO BEFORE DROP;
</pre>
<p>The most recently dropped table with this original name is retrieved from the recycle bin, with its original name. <a href="#CHDHFEBA">Example 18-2</a> shows the retrieval from the recycle bin of all three dropped <code dir="ltr">temp_employees</code> tables from the previous example, with each assigned a new name.</p>
<div id="BRADV344" class="example">
<p class="titleinexample"><a id="CHDHFEBA"></a>Example 18-2 Renaming Dropped Tables</p>
<pre dir="ltr">
FLASHBACK TABLE temp_employees TO BEFORE DROP 
  RENAME TO temp_employees_VERSION_3;
FLASHBACK TABLE temp_employees TO BEFORE DROP 
  RENAME TO temp_employees_VERSION_2;
FLASHBACK TABLE temp_employees TO BEFORE DROP 
  RENAME TO temp_employees_VERSION_1;
</pre></div>
<!-- class="example" -->
<p>Because the original name in <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> refers to the most recently dropped table with this name, the last table dropped is the first retrieved.</p>
<p>You can also retrieve any table from the recycle bin, regardless of any collisions among original names, by using the unique recycle bin name of the table. For example, assume that you query the recycle bin as follows (sample output included):</p>
<pre dir="ltr">
SELECT object_name, original_name, createtime 
FROM   recyclebin;    

OBJECT_NAME                    ORIGINAL_NAME   CREATETIME
------------------------------ --------------- -------------------
BIN$yrMKlZaLMhfgNAgAIMenRA==$0 TEMP_EMPLOYEES  2007-02-05:21:05:52
BIN$yrMKlZaVMhfgNAgAIMenRA==$0 TEMP_EMPLOYEES  2007-02-05:21:25:13
BIN$yrMKlZaQMhfgNAgAIMenRA==$0 TEMP_EMPLOYEES  2007-02-05:22:05:53
</pre>
<p>You can use the following command to retrieve the middle table:</p>
<pre dir="ltr">
FLASHBACK TABLE BIN$yrMKlZaVMhfgNAgAIMenRA==$0 TO BEFORE DROP;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN01511" href="../../server.112/e25494/tables.htm#ADMIN01511"><span class="italic">Oracle Database Administrator's Guide</span></a> to learn how to use Flashback Drop and manage the recycle bin</p>
</li>
<li>
<p><a class="olink SQLRF01802" href="../../server.112/e41084/statements_9012.htm#SQLRF01802"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">FLASHBACK TABLE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BGBDCAFA"></a>
<div id="BRADV81330" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Rewinding a Database with Flashback Database</h2>
<p>This section explains the most common scenario for using Flashback Database to reverse unwanted changes to your database.</p>
<a id="BABCFHAG"></a>
<div id="BRADV89751" class="sect2">
<h3 class="sect2">Prerequisites of Flashback Database</h3>
<p><a id="sthref1595"></a>To use the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command to return your database contents to points in time within the flashback window, your database must be configured for flashback logging as described in <a href="flashdb.htm#CFHCEIHB">"Understanding Flashback Database, Restore Points and Guaranteed Restore Points"</a>. To return the database to a guaranteed restore point, you must have defined a guaranteed restore point as described in <a href="flashdb.htm#CFHGFGFH">"Using Normal and Guaranteed Restore Points"</a>.</p>
<p>Flashback Database works by undoing changes to the data files that exist at the moment that you run the command. Note the following important prerequisites:</p>
<ul>
<li>
<p>No current data files are lost or damaged. You can only use <code dir="ltr">FLASHBACK DATABASE</code> to rewind changes to a data file made by an Oracle database, not to repair media failures.</p>
</li>
<li>
<p>You are not trying to recover from accidental deletion of data files, undo a shrink data file operation, or undo a change to the database name.</p>
</li>
<li>
<p>You are not trying to use <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> to return to a point in time before the restore or re-creation of a control file. If the database control file is restored from backup or re-created, then all accumulated flashback log information is discarded.</p>
</li>
<li>
<p>You are not trying to use <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> to undo a compatibility change.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink RCMRF194" href="../../backup.112/e10643/rcmsynta023.htm#RCMRF194"><span class="italic">Oracle Database Backup and Recovery Reference</span></a> for a complete list of command prerequisites and usage notes for <code dir="ltr">FLASHBACK DATABASE</code></div>
</div>
<!-- class="sect2" -->
<a id="BGBEGGFJ"></a>
<div id="BRADV89752" class="sect2">
<h3 class="sect2">Performing a Flashback Database Operation</h3>
<p>This section presents a basic technique for performing a flashback of the database, specifying the desired target point in time with a time expression, the name of a normal or guaranteed restore point, or an SCN.</p>
<p>This scenario assumes that you are rewinding the database to a point in time within the current database <a id="sthref1596"></a><a href="glossary.htm#i432741"><span class="xrefglossterm">incarnation</span></a>. To return the database to the point in time immediately before the most <a id="sthref1597"></a>recent <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code>, see <a href="#BABHGDDE">"Rewinding an OPEN RESETLOGS Operation with Flashback Database"</a>.</p>
<p>By default, an SCN used in a <code dir="ltr">FLASHBACK DATABASE</code> command refers to an SCN in the <a id="sthref1598"></a><a href="glossary.htm#CHDEEABB"><span class="xrefglossterm">direct ancestral path</span></a> of the database incarnations. As explained in <a href="rcmrvcon.htm#BGBBAJII">"Database Incarnations"</a>, an incarnation is in this path if it was not abandoned after the database was previously opened with the <code dir="ltr">RESETLOGS</code> option. To retrieve changes in abandoned incarnations, see <a href="#BGBJECBF">"Rewinding the Database to an SCN in an Abandoned Incarnation Branch"</a>.</p>
<p class="subhead2"><a id="BRADV345"></a>To perform a Flashback Database operation:</p>
<ol>
<li>
<p>Connect SQL*Plus to the target database and determine the desired SCN, restore point, or point in time for <a id="sthref1599"></a>the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command.</p>
<p><a id="sthref1600"></a>Obtain the earliest SCN in the flashback database window as <a id="sthref1601"></a>follows:</p>
<pre dir="ltr">
SELECT OLDEST_FLASHBACK_SCN, OLDEST_FLASHBACK_TIME
FROM   V$FLASHBACK_DATABASE_LOG;
</pre>
<p>The most recent SCN that can be reached with Flashback Database is the current SCN of the database. The following query returns the current SCN:</p>
<pre dir="ltr">
SELECT CURRENT_SCN
FROM   V$DATABASE;
</pre>
<p>You can query available guaranteed restore points as follows (sample output included):</p>
<pre dir="ltr">
SELECT NAME, SCN, TIME, DATABASE_INCARNATION#,
       GUARANTEE_FLASHBACK_DATABASE
FROM   V$RESTORE_POINT
WHERE  GUARANTEE_FLASHBACK_DATABASE='YES';
 
NAME                   SCN TIME                  DATABASE_INCARNATION# GUA
--------------- ---------- --------------------- --------------------- ---
BEFORE_CHANGES     5753126 04-MAR-05 12.39.45 AM                     2 YES
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the flashback window does not extend far enough back into the past to reach the desired target time, and if you do not have a guaranteed restore point at the desired time, then you can achieve similar results by using database point-in-time recovery, as described in <a href="#i1011846">"Performing Database Point-in-Time Recovery"</a>.</div>
</li>
<li>
<p>Shut down the database consistently, ensure that it is not opened by any instance, and then mount it:</p>
<pre dir="ltr">
SHUTDOWN IMMEDIATE;
STARTUP MOUNT;
</pre></li>
<li>
<p>Repeat the query in Step 1 of this procedure.</p>
<p>Some flashback logging data is generated when the database is shut down. If flashback logs were deleted due to space pressure in the fast recovery area, then your target SCN may not be reachable.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you run <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> when your target SCN is outside the flashback window, then <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> fails with an <code dir="ltr">ORA-38729</code> error. In this case your database does not change.</div>
</li>
<li>
<p>Start RMAN and connect to the target database.</p>
</li>
<li>
<p>Run the <code dir="ltr">SHOW</code> command to see which channels are preconfigured.</p>
<p>During the flashback operation, RMAN may need to restore archived redo logs from backup. Enter the following command to see whether channels are configured (sample output is included):</p>
<pre dir="ltr">
SHOW ALL;

RMAN configuration parameters for database with db_unique_name PROD1 are:
.
.
.
CONFIGURE DEFAULT DEVICE TYPE TO DISK; # default
CONFIGURE DEVICE TYPE DISK PARALLELISM 1 BACKUP TYPE TO BACKUPSET; # default
CONFIGURE DEVICE TYPE SBT_TAPE PARALLELISM 1 BACKUP TYPE TO BACKUPSET; # default
CONFIGURE CHANNEL DEVICE TYPE 'SBT_TAPE' PARMS  "SBT_LIBRARY=/usr/local/oracle/backup/lib/libobk.so";
</pre>
<p>If the necessary devices and channels are already configured, then no action is necessary. Otherwise, use the <code dir="ltr">CONFIGURE</code> command to configure automatic channels, or include <code dir="ltr">ALLOCATE CHANNEL</code> commands within a <code dir="ltr">RUN</code> block.</p>
</li>
<li>
<p>Run the RMAN <code dir="ltr">FLASHBACK DATABASE</code> command.</p>
<p>You can specify the target time by using one of the forms of the command shown in the following examples:</p>
<pre dir="ltr">
FLASHBACK DATABASE TO SCN 46963;

FLASHBACK DATABASE 
  TO RESTORE POINT BEFORE_CHANGES;

FLASHBACK DATABASE TO TIME   
  "TO_DATE('09/20/05','MM/DD/YY')";
</pre>
<p>When the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command completes, the database is left mounted and recovered to the specified target time.</p>
</li>
<li>
<p>Open the database read-only in SQL*Plus and run some queries to verify the database contents.</p>
<p>Open the database read-only as follows:</p>
<pre dir="ltr">
ALTER DATABASE OPEN READ ONLY;
</pre>
<p>If you are satisfied with the state of the database, then end the procedure with Step <a href="#CHDGDJAC">8</a>. If you are <span class="italic">not</span> satisfied with the state of the database, skip to Step <a href="#CHDHCDBD">9</a>.</p>
</li>
<li id="CHDGDJAC">
<p>If satisfied with the results, then perform either of the following mutually exclusive actions:</p>
<ul>
<li>
<p>Make the database available for updates by opening the database with the <code dir="ltr">RESETLOGS</code> option. If the database is currently open read-only, then execute the following commands in SQL*Plus:</p>
<pre dir="ltr">
SHUTDOWN IMMEDIATE
STARTUP MOUNT
ALTER DATABASE OPEN RESETLOGS;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
After you perform this <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code> operation, all changes to the database after the target SCN for <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> are abandoned. Nevertheless, you can use the technique in <a href="#BGBJECBF">"Rewinding the Database to an SCN in an Abandoned Incarnation Branch"</a> to return the database to that range of SCNs while they remain in the flashback window.</div>
</li>
<li>
<p>Use Oracle Data Pump Export to make a logical backup of the objects whose state was corrupted. Afterward, use RMAN to recover the database to the present time:</p>
<pre dir="ltr">
RECOVER DATABASE;
</pre>
<p>This step undoes the effect of the Flashback Database by re-applying all changes in the redo logs to the database, returning it to the most recent SCN.</p>
<p>After re-opening the database read/write, you can import the exported objects with the <a id="sthref1602"></a>Data Pump Import utility. See <a class="olink SUTIL100" href="../../server.112/e22490/dp_overview.htm#SUTIL100"><span class="italic">Oracle Database Utilities</span></a> to learn how to use Data Pump.</p>
</li>
</ul>
</li>
<li id="CHDHCDBD">
<p>If you find that you used the wrong restore point, time, or SCN for the flashback, then mount the database and perform one of the following mutually exclusive options:</p>
<ul>
<li>
<p>If your chosen target time was not far enough in the past, then use another <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command to rewind the database further back in time:</p>
<pre dir="ltr">
FLASHBACK DATABASE TO SCN 42963;  #earlier than current SCN 
</pre></li>
</ul>
<ul>
<li>
<p>If you chose a target SCN that is too far in the past, then use <code dir="ltr">RECOVER</code> <code dir="ltr">DATABASE</code> <code dir="ltr">UNTIL</code> to wind the database forward in time to the desired SCN:</p>
<pre dir="ltr">
RECOVER DATABASE UNTIL SCN 56963; #later than current SCN 
</pre></li>
</ul>
<ul>
<li>
<p>If you want to completely undo the effect of the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command, then you can perform complete recovery of the database by using the <code dir="ltr">RECOVER</code> <code dir="ltr">DATABASE</code> command without an <code dir="ltr">UNTIL</code> clause or <code dir="ltr">SET UNTIL</code> command:</p>
<pre dir="ltr">
RECOVER DATABASE;
</pre>
<p>The <code dir="ltr">RECOVER DATABASE</code> command reapplies all changes to the database, returning it to the most recent SCN.</p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect2" -->
<div id="BRADV603" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1603"></a>
<h3 class="sect2">Monitoring Flashback Database</h3>
<p>When you use Flashback Database to rewind a database to a past target time, Flashback Database determines which blocks changed after the target time and restores them from the flashback logs. This is called the restore phase. After this phase completes, Flashback Database then uses redo logs to reapply changes that were made after these blocks were written to the flashback logs. This is called the recovery phase.</p>
<p>The progress of Flashback Database during the restore phase can be monitored by querying the <code dir="ltr">V$SESSION_LONGOPS</code> view. The <code dir="ltr">opname</code> is <code dir="ltr">Flashback Database</code>. Under the column <code dir="ltr">TOTALWORK</code> is the number of megabytes of flashback logs that must be read. The column <code dir="ltr">SOFAR</code> in Example 18-3 lists the number of megabytes that have been currently read.</p>
<div id="BRADV604" class="example">
<p class="titleinexample"><a id="sthref1604"></a>Example 18-3 Tracking Flashback Database Progress - Restore Phase</p>
<pre dir="ltr">
SQL&gt; select sofar, totalwork, units from v$session_longops where opname = 'Flashback Database';
 
SOFAR  TOTALWORK  UNITS
-----  ---------- --------------------------------
   17          60 Megabytes
</pre></div>
<!-- class="example" -->
<p>The progress of Flashback Database during the recovery phase can be monitored by querying the view <code dir="ltr">V$RECOVERY_PROGRESS</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The <a class="olink REFRN30199" href="../../server.112/e40402/dynviews_2128.htm#REFRN30199"><span class="italic">Oracle Database Reference</span></a> for information on the view <code dir="ltr">V$RECOVERY_PROGRESS</code>.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1011846"></a>
<div id="BRADV84152" class="sect1">
<h2 class="sect1">Performing Database Point-in-Time Recovery</h2>
<p><a id="i1006147"></a><a id="sthref1605"></a><a id="sthref1606"></a><a id="sthref1607"></a>RMAN DBPITR restores the database from backups before the target time for recovery, then uses incremental backups and redo to roll the database forward to the target time. You can recover to an SCN, time, log sequence number, or restore point. Oracle recommends that you create restore points at important times to make point-in-time recovery more manageable if it ever becomes necessary.</p>
<p>Oracle recommends that you perform Flashback Database rather than database point-in-time recovery if possible. Media recovery with backups should be the last option when flashback technologies cannot be used to undo the most recent changes.</p>
<div id="BRADV89753" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1608"></a>
<h3 class="sect2">Prerequisites of Database Point-in-Time Recovery</h3>
<p><a id="sthref1609"></a>The prerequisites for database point-in-time recovery are as follows:</p>
<ul>
<li>
<p>Your database must be running in <code dir="ltr">ARCHIVELOG</code> mode.</p>
</li>
<li>
<p>You must have backups of all data files from before the target SCN for DBPITR and archived logs for the period between the SCN of the backups and the target SCN.</p>
</li>
</ul>
<p>For a complete account of command prerequisites and usage notes, refer to the <code dir="ltr">RECOVER</code> entry in <a class="olink RCMRF140" href="../../backup.112/e10643/rcmsynta2001.htm#RCMRF140"><span class="italic">Oracle Database Backup and Recovery Reference</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1006154"></a>
<div id="BRADV89754" class="sect2">
<h3 class="sect2">Performing Database Point-in-Time Recovery</h3>
<p>This section explains the basic steps of DBPITR. The procedure makes the following assumptions:</p>
<ul>
<li>
<p>You are performing <a id="sthref1610"></a>DBPITR within the current database <a href="glossary.htm#i432741"><span class="xrefglossterm">incarnation</span></a>. If your target time is not in the current incarnation, then see <a href="#i1006192">"Recovering the Database to an Ancestor Incarnation"</a> for more information on DBPITR to ancestor incarnations.</p>
</li>
<li>
<p>The control file is current. If you need to restore a backup control file, then see <a href="rcmadvre.htm#i1006245">"Performing Recovery with a Backup Control File"</a>.</p>
</li>
<li>
<p>Your database is using the current server parameter file. If you must restore a backup server parameter file, then see <a href="rcmadvre.htm#CHDBEDCH">"Restoring the Server Parameter File"</a>.</p>
</li>
</ul>
<p>When performing DBPITR, you can avoid errors by using the <code dir="ltr">SET</code> <code dir="ltr">UNTIL</code> command to set the target time at the beginning of the procedure, rather than specifying the <code dir="ltr">UNTIL</code> clause on the <code dir="ltr">RESTORE</code> and <code dir="ltr">RECOVER</code> commands individually. This ensures that the data files restored from backup have timestamps early enough to be used in the subsequent <code dir="ltr">RECOVER</code> operation.</p>
<p class="subhead2"><a id="BRADV346"></a>To perform DBPITR:</p>
<ol>
<li>
<p>Determine the time, SCN, restore point, or log sequence that should end recovery.</p>
<p>You can use the Flashback Query features to help you identify when the logical corruption occurred. If you have a <a href="glossary.htm#CHDCEBEG"><span class="xrefglossterm">flashback data archive</span></a> enabled for a table, then you can query data that existed far in the past.</p>
<p>You can also use the alert log to try to determine the time of the event from which you must recover.</p>
<p>Alternatively, you can use a SQL query to determine the log sequence number that contains the target SCN and then recover through this log. For example, run the following query to list the logs in the current database incarnation (sample output included)<a id="sthref1611"></a>:</p>
<pre dir="ltr">
SELECT RECID, STAMP, THREAD#, SEQUENCE#, FIRST_CHANGE#
       FIRST_TIME, NEXT_CHANGE#
FROM   V$ARCHIVED_LOG
WHERE  RESETLOGS_CHANGE# =
       ( SELECT RESETLOGS_CHANGE#
         FROM   V$DATABASE_INCARNATION
         WHERE  STATUS = 'CURRENT');

RECID      STAMP      THREAD#    SEQUENCE#  FIRST_CHAN FIRST_TIM NEXT_CHANG
---------- ---------- ---------- ---------- ---------- --------- ----------
         1  344890611          1          1      20037 24-SEP-05      20043
         2  344890615          1          2      20043 24-SEP-05      20045
         3  344890618          1          3      20045 24-SEP-05      20046
</pre>
<p>For example, if you discover that a user accidentally dropped a tablespace at 9:02 a.m., then you can recover to 9 a.m., just before the drop occurred. You lose all changes to the database made after this time.</p>
</li>
<li>
<p>If you are using a target time expression instead of a target SCN, then make sure the time format environment variables are appropriate before invoking RMAN.</p>
<p>The following are sample Globalization Support settings:</p>
<pre dir="ltr">
NLS_LANG = american_america.us7ascii
NLS_DATE_FORMAT="Mon DD YYYY HH24:MI:SS"
</pre></li>
<li>
<p>Connect RMAN to the target database and, if applicable, the recovery catalog database. Bring the database to a mounted state:</p>
<pre dir="ltr">
SHUTDOWN IMMEDIATE;
STARTUP MOUNT;
</pre></li>
<li>
<p>Perform the following operations within a <code dir="ltr">RUN</code> block:</p>
<ol>
<li>
<p>Use <code dir="ltr">SET</code> <code dir="ltr">UNTIL</code> to specify the target time, restore point, SCN, or log sequence number for DBPITR. If specifying a time, then use the date format specified in the <code dir="ltr">NLS_LANG</code> and <code dir="ltr">NLS_DATE_FORMAT</code> environment variables.</p>
</li>
<li>
<p>If automatic channels are not configured, then manually allocate disk and tape channels as needed.</p>
</li>
<li>
<p>Restore and recover the database.</p>
</li>
</ol>
<p>The following example performs DBPITR on the target database until SCN 1000:</p>
<pre dir="ltr">
RUN
{ 
  SET UNTIL SCN 1000;    
  RESTORE DATABASE;
  RECOVER DATABASE;
}
</pre>
<p>As shown in the following examples, you can also use time expressions, restore points, or log sequence numbers to specify the <code dir="ltr">SET</code> <code dir="ltr">UNTIL</code> time:</p>
<pre dir="ltr">
SET UNTIL TIME 'Nov 15 2004 09:00:00';
SET UNTIL SEQUENCE 9923;  
SET UNTIL RESTORE POINT before_update;
</pre>
<p>If the operation completes without errors, then DBPITR has succeeded.</p>
</li>
<li id="CHDDBIJB">
<p>Perform either of the following mutually exclusive actions:</p>
<ul>
<li>
<p>Open your database for read/write, abandoning all changes after the target SCN. In this case, you must shut down the database, mount it, and then execute the following command:</p>
<pre dir="ltr">
ALTER DATABASE OPEN RESETLOGS;
</pre>
<p>The <code dir="ltr">OPEN RESETLOGS</code> operation fails if a data file is offline unless the data file went offline normally or is read-only. You can bring files in read-only or offline normal tablespaces online after the <code dir="ltr">RESETLOGS</code> because they do not need any redo.</p>
</li>
<li>
<p>Export one or more objects from your database with Data Pump Export. You can then recover the database to the current point in time and re-import the exported objects, thus returning these objects to their state before the unwanted change without abandoning all other changes.</p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBDIGH"></a>
<div id="BRADV89755" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Flashback and Database Point-in-Time Recovery Scenarios</h2>
<p>This section describes variations on the basic scenarios described in <a href="#BGBDCAFA">"Rewinding a Database with Flashback Database"</a> and <a href="#i1011846">"Performing Database Point-in-Time Recovery"</a>.</p>
<a id="BABHGDDE"></a>
<div id="BRADV85442" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Rewinding an OPEN RESETLOGS Operation with Flashback Database</h3>
<p><a id="sthref1612"></a>The procedure for using Flashback Database to reverse an unwanted <code dir="ltr">ALTER DATABASE OPEN RESETLOGS</code> statement is similar to the general case described in <a href="#BGBEGGFJ">"Performing a Flashback Database Operation"</a>. Rather than specifying a particular SCN or point in time for the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command, however, you use <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> <code dir="ltr">TO</code> <code dir="ltr">BEFORE</code> <code dir="ltr">RESETLOGS</code>.</p>
<p class="subhead2"><a id="BRADV347"></a>To undo an <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code> operation:</p>
<ol>
<li>
<p>Connect SQL*Plus to the target database and verify that the beginning of the flashback window is earlier than the time of the most recent <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code>.</p>
<p>Run the following queries<a id="sthref1613"></a><a id="sthref1614"></a>:</p>
<pre dir="ltr">
SELECT RESETLOGS_CHANGE# 
FROM   V$DATABASE;

SELECT OLDEST_FLASHBACK_SCN 
FROM   V$FLASHBACK_DATABASE_LOG;
</pre>
<p>If <code dir="ltr">V$DATABASE.RESETLOGS_CHANGE#</code> is greater than <code dir="ltr">V$FLASHBACK_DATABASE_LOG.OLDEST_FLASHBACK_SCN</code>, then you can use Flashback Database to reverse the <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code>.</p>
</li>
<li>
<p>Shut down the database, mount it, and recheck the flashback window. If the resetlogs SCN is still within the flashback window, then proceed to the next step.</p>
</li>
<li>
<p>Connect RMAN to the target database and perform a flashback to the SCN immediately before the <code dir="ltr">RESETLOGS</code>.</p>
<p>Use the following form of the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command:</p>
<pre dir="ltr">
FLASHBACK DATABASE TO BEFORE RESETLOGS;
</pre>
<p>As with other uses of <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code>, if the target SCN is before the beginning of the flashback database window, an error is returned and the database is not modified. If the command completes successfully, then the database is left mounted and recovered to the most recent SCN before the <code dir="ltr">OPEN RESETLOGS</code> in the previous incarnation.</p>
</li>
<li>
<p>Open the database read-only in SQL*Plus and perform queries as needed to ensure that the effects of the logical corruption have been reversed.</p>
<p>Open the database read-only as follows:</p>
<pre dir="ltr">
ALTER DATABASE OPEN READ ONLY;
</pre></li>
<li>
<p>To make the database available for updates again, shut down the database, mount it, and then execute the following command:</p>
<pre dir="ltr">
ALTER DATABASE OPEN RESETLOGS;
</pre></li>
</ol>
<a id="BABFFBEH"></a>
<div id="BRADV89757" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Undoing an OPEN RESETLOGS on Standby Databases with Flashback Database</h4>
<p>Flashback Database across <code dir="ltr">OPEN RESETLOGS</code> may be used to perform the following functions in a Data Guard environment:</p>
<ul>
<li>
<p>Flashback to undo logical standby switchovers</p>
<p>In this case, the database reverts to its role (primary or standby) at the target time for the Flashback Database operation.</p>
</li>
<li>
<p>Undo of a physical standby activation</p>
<p>You can temporarily activate a physical standby database, use it for testing or reporting purposes, and then use Flashback Database to return it to its role as a physical standby.</p>
</li>
<li>
<p>Ongoing use of a standby database for testing</p>
<p>The use of Flashback Database means that you do are not require the use of storage snapshots.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SBYDB00717" href="../../server.112/e41134/role_management.htm#SBYDB00717"><span class="italic">Oracle Data Guard Concepts and Administration</span></a> for details on these advanced applications of Flashback Database with Data Guard</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BGBJECBF"></a>
<div id="BRADV89758" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Rewinding the Database to an SCN in an Abandoned Incarnation Branch</h3>
<p><a id="sthref1615"></a>The effect of Flashback Database or DBPITR followed by an <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code> is to return the database to a previous SCN, and to abandon changes after this point. Therefore, some SCNs after that point can refer either to changes that were abandoned or changes in the current history of the database. In this way, a target SCN specified in <code dir="ltr">FLASHBACK DATABASE</code> can be ambiguous.</p>
<p>Unlike SCNs, time expressions and restore points are not ambiguous. A time expression is always associated with the incarnation that was current at that time. A restore point is always associated with the current incarnation when it was created. This is true even for times and restore points that correspond to abandoned database incarnations. The database incarnation is automatically reset to the incarnation that was current at the specified time or when the restore point was created.</p>
<p>You may want to use Flashback Database to rewind the database to an SCN in the parent incarnation that is later than the SCN of the <code dir="ltr">OPEN RESETLOGS</code> at which the current incarnation path branched from the old incarnation. <a href="rcmrvcon.htm#CHDCJGGD">Figure 14-1, "Database Incarnation History"</a> shows how SCNs can be generated in an incarnation branch even after an <code dir="ltr">OPEN RESETLOGS</code> creates a new incarnation. As shown in the diagram, the database could be at SCN 3000 in incarnation 3 when you must return to the abandoned SCN 1500 in incarnation 1.</p>
<p>If the SCN to which you are rewinding is in the <a id="sthref1616"></a><a href="glossary.htm#CHDEEABB"><span class="xrefglossterm">direct ancestral path</span></a>, or if you are rewinding the database to a <a id="sthref1617"></a><a href="glossary.htm#CHDEBAAG"><span class="xrefglossterm">restore point</span></a>, then an explicit <code dir="ltr">RESET DATABASE</code> is not necessary for Flashback Database. However, an explicit <code dir="ltr">RESET</code> <code dir="ltr">DATABASE</code> <code dir="ltr">TO</code> <code dir="ltr">INCARNATION</code> command is required when using <code dir="ltr">FLASHBACK DATABASE</code> to rewind the database to an SCN in an abandoned database incarnation.</p>
<p class="subhead2"><a id="BRADV348"></a>To rewind the database to an SCN in an abandoned incarnation branch:</p>
<ol>
<li>
<p>Use SQL*Plus to connect to the target database and verify that the flashback logs contain enough information to flash back to the SCN.</p>
<p>For example, execute the following query:</p>
<pre dir="ltr">
SELECT OLDEST_FLASHBACK_SCN
FROM   V$FLASHBACK_DATABASE_LOG;
</pre></li>
<li>
<p>Determine the target incarnation number for the Flashback Database operation, that is, the incarnation key for the parent incarnation.</p>
<p>For example, execute the following query:</p>
<pre dir="ltr">
SELECT PRIOR_INCARNATION# 
FROM   V$DATABASE_INCARNATION 
WHERE  STATUS = 'CURRENT';
</pre></li>
<li>
<p>Start RMAN and connect to the target database.</p>
</li>
<li>
<p>Shut down the database, and then mount it as follows:</p>
<pre dir="ltr">
SHUTDOWN IMMEDIATE;
STARTUP MOUNT;
</pre></li>
<li>
<p>Set the database incarnation to the parent incarnation.</p>
<p>For example, use the following command to return to incarnation 1:</p>
<pre dir="ltr">
RESET DATABASE TO INCARNATION 1;
</pre></li>
<li>
<p>Run the <code dir="ltr">FLASHBACK</code> <code dir="ltr">DATABASE</code> command, specifying the target SCN.</p>
<p>For example, use the following command to rewind the database to SCN 1500:</p>
<pre dir="ltr">
FLASHBACK DATABASE TO SCN 1500;
</pre></li>
<li>
<p>Open the database read-only in SQL*Plus and perform queries as needed to ensure that the effects of the logical corruption have been reversed.</p>
<p>Open the database read-only as follows:</p>
<pre dir="ltr">
ALTER DATABASE OPEN READ ONLY;
</pre></li>
<li>
<p>To make the database available for updates again, shut down the database, mount it, and then execute the following command:</p>
<pre dir="ltr">
ALTER DATABASE OPEN RESETLOGS;
</pre></li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="rcmrvcon.htm#BGBBAJII">"Database Incarnations"</a> for useful background information about database incarnations, abandoned changes, and the effects of <code dir="ltr">ALTER DATABASE OPEN</code> <code dir="ltr">RESETLOGS</code></p>
</li>
<li>
<p><a class="olink RCMRF148" href="../../backup.112/e10643/rcmsynta2007.htm#RCMRF148"><span class="italic">Oracle Database Backup and Recovery Reference</span></a> for details about the <code dir="ltr">RESET</code> <code dir="ltr">DATABASE</code> command</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006192"></a>
<div id="BRADV84153" class="sect2">
<h3 class="sect2">Recovering the Database to an Ancestor Incarnation</h3>
<p>The procedure for DBPITR within the current incarnation is different from DBPITR to an SCN in a noncurrent incarnation. In the latter case, you must explicitly execute the <code dir="ltr">RESET DATABASE</code> to reset the database to the incarnation that was current at the target SCN. Also, you must restore a control file from the database incarnation containing the target SCN.</p>
<p>When RMAN is connected to a recovery catalog, a <code dir="ltr">RESTORE CONTROLFILE</code> command only searches the current database incarnation for the closest time specified in the <code dir="ltr">UNTIL</code> clause. To restore a control file from a noncurrent incarnation, you must execute <code dir="ltr">LIST INCARNATION</code> to identify the target database incarnation and specify this incarnation in the <code dir="ltr">RESET DATABASE TO INCARNATION</code> command.</p>
<p>When RMAN is connected to a recovery catalog, you cannot execute the <code dir="ltr">RESET DATABASE TO INCARNATION</code> command before the database is mounted. Thus, you must execute <code dir="ltr">SET UNTIL</code>, restore the control file from autobackup, and then mount it.</p>
<p><a id="sthref1618"></a><a id="sthref1619"></a>Assume the following situation:</p>
<ul>
<li>
<p>RMAN is connected to a recovery catalog.</p>
</li>
<li>
<p>You have a backup of target database <code dir="ltr">trgt</code> from October 2, 2007.</p>
</li>
<li>
<p>DBPITR was performed on this database on October 10, 2007 to correct an earlier error. The <code dir="ltr">OPEN</code> <code dir="ltr">RESETLOGS</code> operation at the end of that DBPITR started a new incarnation.</p>
</li>
</ul>
<p>On October 25, you discover that you need crucial data that was dropped from the database at 8:00 a.m. on October 8, 2007. This time is before the beginning of the current incarnation.</p>
<p class="subhead2"><a id="BRADV349"></a>To perform DBPITR to a noncurrent incarnation:</p>
<ol>
<li>
<p>Start RMAN and connect to a target database and recovery catalog.</p>
</li>
<li>
<p>Determine which database incarnation was current at the time of the backup.</p>
<p>Use <code dir="ltr">LIST</code> <code dir="ltr">INCARNATION</code> to find the primary key of the incarnation that was current at the target time:</p>
<pre dir="ltr">
LIST INCARNATION OF DATABASE trgt;

List of Database Incarnations
DB Key  Inc Key   DB Name   DB ID       STATUS     Reset SCN    Reset Time
------- -------   -------   ------      -------    ----------   ----------
1       2         TRGT      1224038686  PARENT     1            02-OCT-06
1       582       TRGT      1224038686  CURRENT    59727        10-OCT-06
</pre>
<p>Look at the <code dir="ltr">Reset SCN</code> and <code dir="ltr">Reset Time</code> columns to identify the correct incarnation, and note the incarnation key in the <code dir="ltr">Inc</code> <code dir="ltr">Key</code> column. In this example, the backup was made 2 October 2007. In this case, the incarnation key value is 2.</p>
</li>
<li>
<p>Make sure the database is started but not mounted.</p>
<pre dir="ltr">
STARTUP FORCE NOMOUNT
</pre></li>
<li>
<p>Reset the target database to the incarnation obtained in Step 2.</p>
<p>In this example, specify the incarnation current at the time of the backup of 2 October. Use the value from the <code dir="ltr">Inc Key</code> column to identify the incarnation.</p>
<pre dir="ltr">
RESET DATABASE TO INCARNATION 2;
</pre></li>
<li>
<p>Restore and recover the database, performing the following actions in the <code dir="ltr">RUN</code> command:</p>
<ul>
<li>
<p>Set the end time for recovery to the time just before the loss of the data.</p>
</li>
<li>
<p>Allocate any channels required that are not already configured.</p>
</li>
<li>
<p>Restore the control file from the October 2 backup and mount it.</p>
</li>
<li>
<p>Restore the data files and recover the database. Use the <code dir="ltr">RECOVER DATABASE</code> <code dir="ltr">...</code> <code dir="ltr">UNTIL</code> command to perform DBPITR, bringing the database to the target time of 7:55 a.m. on October 8, just before the data was lost.</p>
</li>
</ul>
<p>The following example shows all of the steps required in this case:</p>
<pre dir="ltr">
RUN
{
  SET UNTIL TIME 'Oct 8 2007 07:55:00'; 
  RESTORE CONTROLFILE;
  # without recovery catalog, use RESTORE CONTROLFILE FROM AUTOBACKUP
  ALTER DATABASE MOUNT; 
  RESTORE DATABASE;
  RECOVER DATABASE;
}
ALTER DATABASE OPEN RESETLOGS;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink RCMRF148" href="../../backup.112/e10643/rcmsynta2007.htm#RCMRF148"><span class="italic">Oracle Database Backup and Recovery Reference</span></a> for details about the <code dir="ltr">RESET</code> <code dir="ltr">DATABASE</code> command</div>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1933">
<tr>
<td class="cellalignment1942">
<table class="cellalignment1938">
<tr>
<td class="cellalignment1937"><a href="rcmcomre.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1937"><a href="rcmblock.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1944">
<table class="cellalignment1936">
<tr>
<td class="cellalignment1937"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1937"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1937"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1937"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1937"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1937"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
