<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Tuning RMAN Performance</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1054" />
<meta name="description" content="A guide to backup and recovery of Oracle databases, including RMAN backup and recovery, RMAN data transfer, Oracle Flashback Technology, and user-managed backup and recovery" />
<meta name="dcterms.created" content="2015-05-13T14:1:11Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Backup and Recovery User's Guide" />
<meta name="dcterms.identifier" content="E10642-08" />
<meta name="dcterms.isVersionOf" content="BRADV" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="part_tun.htm" title="Previous" type="text/html" />
<link rel="Next" href="rcmtroub.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10642.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">35/47</span> <!-- End Header -->
<div id="BRADV011" class="chapter"><a id="CACJCBDB"></a>
<h1 class="chapter"><span class="secnum">22</span> Tuning RMAN Performance</h1>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABJGIJB">Purpose of RMAN Performance Tuning</a></p>
</li>
<li>
<p><a href="#i1006104">Basic Concepts of RMAN Performance Tuning</a></p>
</li>
<li>
<p><a href="#BABCFFJB">Using V$ Views to Diagnose RMAN Performance Problems</a></p>
</li>
<li>
<p><a href="#i1006329">Tuning RMAN Backup Performance</a></p>
</li>
</ul>
<a id="BABJGIJB"></a>
<div id="BRADV89842" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Purpose of RMAN Performance Tuning</h2>
<p>An RMAN backup or restore job can be divided into separate phases or components. The slowest of these phases in any RMAN job is called the <span class="glossaryterm">bottleneck</span>. The purpose of RMAN tuning is to identify the bottlenecks for a given job and use RMAN commands, initialization parameters, or adjustments to physical media to improve performance.</p>
</div>
<!-- class="sect1" -->
<a id="i1006104"></a>
<div id="BRADV170" class="sect1">
<h2 class="sect1">Basic Concepts of RMAN Performance Tuning</h2>
<p>Tuning RMAN performance requires a detailed understanding of how RMAN creates a backup. As explained in <a href="rcmarchi.htm#i1012864">"RMAN Channels"</a>, the work of a backup is performed by one or more channels. A <a href="glossary.htm#i432240"><span class="xrefglossterm">channel</span></a> represents a stream of bytes to a storage device.</p>
<p>For the purposes of illustration, you can think of the byte stream as passing from the input buffers in memory through the CPU to the output buffers, and from there to the storage device. To direct a backup to two tape devices, you allocate two tape channels so that each byte stream goes to a different device.</p>
<p>The work of each channel, whether of type disk or System Backup Tape (SBT), is subdivided into the following distinct phases:</p>
<ol>
<li>
<p><a href="#BABFEAEA">Read Phase</a></p>
<p>A channel reads blocks from disk into input I/O buffers.</p>
</li>
<li>
<p><a href="#BABHGECD">Copy Phase</a></p>
<p>A channel copies blocks from input buffers to output buffers and performs additional processing on the blocks.</p>
</li>
<li>
<p>Write Phase</p>
<p>A channel writes the blocks from output buffers to storage media. The write phase can take either of the following mutually exclusive forms, depending on the type of backup media:</p>
<ul>
<li>
<p><a href="#BABFJAJI">Write Phase for System Backup Tape (SBT)</a></p>
</li>
<li>
<p><a href="#BABDAFCI">Write Phase for Disk</a></p>
</li>
</ul>
</li>
</ol>
<p><a href="#BABDJHBJ">Figure 22-1</a> depicts two channels backing up data stored on three disks. Each channel reads the data into the input buffers, processes the data while copying it from the input to the output buffers, and the writes the data from the output buffers to disk.</p>
<div id="BRADV393" class="figure">
<p class="titleinfigure"><a id="BABDJHBJ"></a>Figure 22-1 Phases of a Multichannel Backup to Disk</p>
<img width="539" height="390" src="img/bradv042.gif" alt="Description of Figure 22-1 follows" /><br />
<a id="sthref1696" href="img_text/bradv042.htm">Description of "Figure 22-1 Phases of a Multichannel Backup to Disk"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BABEDGBI">Figure 22-2</a> also depicts two channels backing up data stored on three disks, but one disk is mounted remotely over the network. Each channel reads the data into the input buffers, processes the data while copying it from the input buffers to the output buffers, and then writes the data from the output buffers to tape. Channel 1 writes the data to a locally attached tape drive, whereas channel 2 sends the data over the network to a remote media server.</p>
<div id="BRADV394" class="figure">
<p class="titleinfigure"><a id="BABEDGBI"></a>Figure 22-2 Phases of a Multichannel Backup to Tape</p>
<img width="594" height="495" src="img/bradv041.gif" alt="Description of Figure 22-2 follows" /><br />
<a id="sthref1697" href="img_text/bradv041.htm">Description of "Figure 22-2 Phases of a Multichannel Backup to Tape"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When restoring data, a channel performs these steps in reverse order and reverses the reading and writing operations. The following sections explain RMAN tuning concepts in terms of a backup.</p>
<a id="BABFEAEA"></a>
<div id="BRADV90067" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Read Phase</h3>
<p>This section explains factors that affect performance when an RMAN channel is reading data from disk:</p>
<ul>
<li>
<p><a href="#BABDCIHI">Allocation of Input Disk Buffers</a></p>
</li>
<li>
<p><a href="#BABBGAHE">Synchronous and Asynchronous Disk I/O</a></p>
</li>
<li>
<p><a href="#BABBDHHE">Disk I/O Slaves</a></p>
</li>
<li>
<p><a href="#BABDCEHG">RATE Channel Parameter</a></p>
</li>
</ul>
<a id="BABDCIHI"></a>
<div id="BRADV89845" class="sect3">
<h4 class="sect3">Allocation of Input Disk Buffers</h4>
<p>During a backup, an RMAN channel reads the blocks from the input files into I/O disk buffers. The database files on the disk subsystem can be managed by either <a href="glossary.htm#CHDBDJIJ"><span class="xrefglossterm">Automatic Storage Management (ASM)</span></a> or an alternative volume manager or file system. The considerations for backup tuning change depending on whether you manage database files with ASM.</p>
<p>The allocation of the input buffers depends on how the files are multiplexed. <a id="sthref1698"></a><a id="sthref1699"></a>Backup <a href="glossary.htm#i999499"><span class="xrefglossterm">multiplexing</span></a> is RMAN's ability to read several files in a backup simultaneously from different sources and then write them to a single backup piece. The <a href="glossary.htm#CHDFBDDG"><span class="xrefglossterm">level of multiplexing</span></a>, which is the number of input files simultaneously read and then written into the same <a href="glossary.htm#i432114"><span class="xrefglossterm">backup piece</span></a>, is determined by the algorithm described in <a href="rcmcncpt.htm#i1015964">"Multiplexed Backup Sets"</a>. Review this section before proceeding.</p>
<p>When an RMAN channel backs up files from disk, it uses the rules described in <a href="#CACCAJJB">Table 22-1</a> to determine how large to make the input disk buffers.</p>
<div id="BRADV395" class="tblruleformal">
<p class="titleintable"><a id="sthref1700"></a><a id="CACCAJJB"></a>Table 22-1 Data File Read Buffer Sizing Algorithm</p>
<table class="cellalignment1945" title="Data File Read Buffer Sizing Algorithm" summary="This tabel describes buffer sizes RMAN uses depending upon the level of multiplexing." dir="ltr">
<thead>
<tr class="cellalignment1934">
<th class="cellalignment1941" id="r1c1-t2">Level of Multiplexing</th>
<th class="cellalignment1941" id="r1c2-t2">Input Disk Buffer Size</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r2c1-t2" headers="r1c1-t2">
<p>Less than or equal to 4</p>
</td>
<td class="cellalignment1942" headers="r2c1-t2 r1c2-t2">
<p>The RMAN channel allocates 16 buffers of size 1 megabyte (MB) so that the total buffer size for all the input files is 16 MB.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r3c1-t2" headers="r1c1-t2">
<p>Greater than 4 but less than or equal to 8</p>
</td>
<td class="cellalignment1942" headers="r3c1-t2 r1c2-t2">
<p>The RMAN channel allocates a variable number of disk buffers of size 512 kilobytes (KB) so that the total buffer size for all the input files is less than 16 MB.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r4c1-t2" headers="r1c1-t2">
<p>Greater than 8</p>
</td>
<td class="cellalignment1942" headers="r4c1-t2 r1c2-t2">
<p>The RMAN channel allocates 4 disk buffers of 128 KB for each file, so that the total buffer size for each input file is 512 KB.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>In the example shown in <a href="#BABICCGE">Figure 22-3</a>, one channel is backing up four data files. <code dir="ltr">MAXOPENFILES</code> is set to 4 and <code dir="ltr">FILESPERSET</code> is set to 4. Thus, the level of multiplexing is 4. So, the total size of the buffers for each data file is 4 MB. The combined size of all the buffers is 16 MB.</p>
<div id="BRADV396" class="figure">
<p class="titleinfigure"><a id="BABICCGE"></a>Figure 22-3 Disk Buffer Allocation</p>
<img width="389" height="391" src="img/bradv011.gif" alt="Description of Figure 22-3 follows" /><br />
<a id="sthref1701" href="img_text/bradv011.htm">Description of "Figure 22-3 Disk Buffer Allocation"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If a channel is backing up files stored in ASM, then the number of input disk buffers equals the number of physical disks in the ASM disk group. For example, if a data file is stored in an ASM disk group that contains 16 physical disks, then the channel allocates 16 input buffers for the data file backup.</p>
<p>If a channel is restoring a backup from disk, then 4 buffers are allocated. The size of the buffers is dependent on the operating system.</p>
</div>
<!-- class="sect3" -->
<a id="BABBGAHE"></a>
<div id="BRADV90068" class="sect3">
<h4 class="sect3"><a id="sthref1702"></a>Synchronous and Asynchronous Disk I/O</h4>
<p>When a channel reads from or writes to disk, the I/O is either <a href="glossary.htm#CHDDCBGC"><span class="xrefglossterm">synchronous I/O</span></a> or <a href="glossary.htm#CHDIIJAC"><span class="xrefglossterm">asynchronous I/O</span></a>. When the disk I/O is synchronous, a server process can perform only one task at a time. When the disk I/O is asynchronous, a server process can begin an I/O operation and then perform other work while waiting for the I/O to complete. RMAN can also begin multiple I/O operations before waiting for the first to complete.</p>
<p>When reading from an ASM <a href="glossary.htm#CHDHIIBA"><span class="xrefglossterm">disk group</span></a>, you should use asynchronous disk I/O if possible. Also, if a channel reads from a <a href="glossary.htm#CHDHBJAG"><span class="xrefglossterm">raw device</span></a> managed with a volume manager, then asynchronous disk I/O also works well. Some operating systems support native asynchronous disk I/O. The database takes advantage of this feature if it is available.</p>
</div>
<!-- class="sect3" -->
<a id="BABBDHHE"></a>
<div id="BRADV90069" class="sect3">
<h4 class="sect3"><a id="sthref1703"></a>Disk I/O Slaves</h4>
<p>On operating systems that do not support native asynchronous I/O, the database can simulate it with special I/O slave processes. These processes are dedicated to performing I/O on behalf of another process.</p>
<p>You can control disk I/O slaves by setting the <code dir="ltr">DBWR_IO_SLAVES</code> initialization parameter, which is not dynamic. The parameter specifies the number of I/O server processes used by the database writer process (DBWR). By default, the value is 0 and I/O server processes are not used. If asynchronous I/O is disabled, then RMAN allocates four backup disk I/O slaves for any nonzero value of <code dir="ltr">DBWR_IO_SLAVES</code>.</p>
<p>When attempting to get shared buffers for I/O slaves, the database does the following:</p>
<ul>
<li>
<p>If the <code dir="ltr">LARGE_POOL_SIZE</code> initialization parameter is set, and if the <code dir="ltr">DBWR_IO_SLAVES</code> parameter is set to a nonzero value, then the database attempts to get memory from the large pool. If this value is not large enough, then an error is recorded in the alert log, the database does not try to get buffers from the shared pool, and asynchronous I/O is not used.</p>
</li>
<li>
<p>If the <code dir="ltr">LARGE_POOL_SIZE</code> initialization parameter is not set or is set to zero, then the database attempts to get memory from the shared pool.</p>
</li>
<li>
<p>If the database cannot get enough memory, then it obtains I/O buffer memory from the Program Global Area (PGA) and writes a message to the <code dir="ltr">alert</code>.<code dir="ltr">log</code> file indicating that synchronous I/O is used for this backup.</p>
</li>
</ul>
<p>The memory from the large pool is used for many features, including the shared server, parallel query, and RMAN I/O slave buffers. Configuring the large pool prevents RMAN from competing with other subsystems for the same memory.</p>
<p>Requests for contiguous memory allocations from the shared pool are usually small (under 5 KB). However, a request for a large contiguous memory allocation can either fail or require significant memory housekeeping to release the required amount of contiguous memory. Although the shared pool may be unable to satisfy this memory request, the large pool can do so. The large pool does not have a least recently used (LRU) list; the database does not attempt to age memory out of the large pool.</p>
</div>
<!-- class="sect3" -->
<a id="BABDCEHG"></a>
<div id="BRADV90070" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">RATE Channel Parameter</h4>
<p>In the <code dir="ltr">ALLOCATE</code> and <code dir="ltr">CONFIGURE CHANNEL</code> commands, the <code dir="ltr">RATE</code> parameter specifies the bytes per second that are read on a channel. You can use this parameter to set an upper limit for bytes read so that RMAN does not consume excessive disk bandwidth and degrade online performance. Essentially, <code dir="ltr">RATE</code> serves as a backup throttle. For example, if you set <code dir="ltr">RATE 1500K</code>, and if each disk drive delivers 3 megabytes per second, then the channel leaves some disk bandwidth available to the online system.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABHGECD"></a>
<div id="BRADV90071" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Copy Phase</h3>
<p>In this phase, a channel copies blocks from the input buffers to the output buffers and performs additional processing. For example, if a channel reads data from disk and backs up to tape, then the channel copies the data from the disk buffers to the output tape buffers.</p>
<p>The copy phase involves the following types of processing:</p>
<ul>
<li>
<p>Validation</p>
</li>
<li>
<p>Compression</p>
</li>
<li>
<p>Encryption</p>
</li>
</ul>
<p>When performing <a href="glossary.htm#i433696"><span class="xrefglossterm">validation</span></a> of the blocks, RMAN checks them for corruption. Validation is explained in <a href="rcmvalid.htm#CHDBFAIF">Chapter 16, "Validating Database Files and Backups"</a> Typically, this processing is not CPU-intensive.</p>
<p>When performing <a href="glossary.htm#CHDEEEDG"><span class="xrefglossterm">binary compression</span></a>, RMAN applies a compression algorithm to the data in backup sets. Binary compression can be CPU-intensive. You can choose which compression algorithm RMAN uses for backups. The basic compression level for RMAN has a good compression ratio for most scenarios. If you have the Advanced Compression Option enabled, there are several different levels to choose from that provide trade-offs between compression ratios and required CPU resources. Binary compression is explained in <a href="rcmcncpt.htm#CIHFEBFI">"Binary Compression for Backup Sets"</a> and in <a href="rcmbckba.htm#i1034440">"Making Compressed Backups"</a>.</p>
<p>When performing <a href="glossary.htm#CHDJDIEJ"><span class="xrefglossterm">backup encryption</span></a>, RMAN encrypts backup sets by using an algorithm listed <a id="sthref1704"></a>in <code dir="ltr">V$RMAN_ENCRYPTION_ALGORITHMS</code>. RMAN offers three modes of encryption: transparent, password-protected, and dual-mode. Backup encryption is explained in <a href="rcmbckad.htm#CEGEJABH">"Encrypting RMAN Backups"</a>. Backup encryption can be CPU-intensive.</p>
</div>
<!-- class="sect2" -->
<a id="BABFJAJI"></a>
<div id="BRADV90072" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Write Phase for System Backup Tape (SBT)</h3>
<p>When backing up to SBT, RMAN gives the <a href="glossary.htm#i432922"><span class="xrefglossterm">media manager</span></a> a stream of bytes and associates a unique name with this stream. All details of how and where that stream is stored are handled entirely by the media manager. Thus, a backup to tape involves the interaction of both RMAN and the media manager.</p>
<div id="BRADV90073" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1705"></a>
<h4 class="sect3">RMAN Component of the Write Phase for SBT</h4>
<p>The RMAN-specific factors affecting the SBT write phase are analogous to the factors affecting disk reads. In both cases, the buffer allocation, slave processes, and synchronous or asynchronous I/O affect performance.</p>
<a id="i1006186"></a>
<div id="BRADV89846" class="sect4">
<h5 class="sect4"><a id="sthref1706"></a>Allocation of Tape Buffers</h5>
<p>If you back up to or restore from an <a href="glossary.htm#CHDCCBFI"><span class="xrefglossterm">SBT</span></a> device, then by default the database allocates four buffers for each channel for the tape writers (or reads if restoring data as shown in <a href="#CACEAIIF">Table 22-1</a>). The size of the tape I/O buffers is platform-dependent. You can change this value with the <code dir="ltr">PARMS</code> and <code dir="ltr">BLKSIZE</code> parameters of the <code dir="ltr">ALLOCATE CHANNEL</code> or <code dir="ltr">CONFIGURE CHANNEL</code> command.</p>
<div id="BRADV397" class="figure">
<p class="titleinfigure"><a id="CACEAIIF"></a>Figure 22-4 Allocation of Tape Buffers</p>
<img width="335" height="184" src="img/bradv013.gif" alt="Description of Figure 22-4 follows" /><br />
<a id="sthref1707" href="img_text/bradv013.htm">Description of "Figure 22-4 Allocation of Tape Buffers"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<div id="BRADV90074" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref1708"></a>
<h5 class="sect4">Tape I/O Slaves</h5>
<p>RMAN allocates the tape buffers in the System Global Area (SGA) or the Program Global Area (PGA), depending on whether I/O slaves are used. If you set the initialization parameter <code dir="ltr">BACKUP_TAPE_IO_SLAVES=true</code>, then RMAN allocates tape buffers from the SGA. Tape devices can only be accessed by one process at a time, so RMAN starts as many slaves as necessary for the number of tape devices. If the <code dir="ltr">LARGE_POOL_SIZE</code> initialization parameter is also set, then RMAN allocates buffers from the large pool. If you set <code dir="ltr">BACKUP_TAPE_IO_SLAVES=false</code>, then RMAN allocates the buffers from the PGA.</p>
<p>If you use I/O slaves, then set the <code dir="ltr">LARGE_POOL_SIZE</code> initialization parameter to dedicate SGA memory to holding these large memory allocations. This parameter prevents RMAN I/O buffers from competing with the library cache for SGA memory. If I/O slaves for tape I/O were requested but there is not enough space in the SGA for them, slaves are not used, and a message appears in the alert log.</p>
<p>The parameter <code dir="ltr">BACKUP_TAPE_IO_SLAVES</code> specifies whether RMAN uses slave processes rather than the number of slave processes. Tape devices can only be accessed by one process at a time, and RMAN uses the number of slaves necessary for the number of tape devices.</p>
</div>
<!-- class="sect4" -->
<a id="i1006195"></a>
<div id="BRADV89847" class="sect4">
<h5 class="sect4"><a id="sthref1709"></a>Synchronous and Asynchronous I/O</h5>
<p>When an SBT channel reads or writes data to tape, the I/O is always synchronous. For tape I/O, each channel allocated (whether manually or automatically) corresponds to a server process, called here a channel process.</p>
<p><a href="#BABEBGFD">Table 22-1</a> shows synchronous I/O in a backup to tape.</p>
<div id="BRADV398" class="figure">
<p class="titleinfigure"><a id="BABEBGFD"></a>Figure 22-5 Synchronous Tape I/O</p>
<img width="496" height="191" src="img/bradv015.gif" alt="Description of Figure 22-5 follows" /><br />
<a id="sthref1710" href="img_text/bradv015.htm">Description of "Figure 22-5 Synchronous Tape I/O"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The following steps occur:</p>
<ol>
<li>
<p>The channel process composes a tape buffer.</p>
</li>
<li>
<p>The channel process executes media manager code that processes the tape buffer and internalizes it for further processing and storage by the media manager.</p>
</li>
<li>
<p>The media manager code returns a message to the server process stating that it has completed writing.</p>
</li>
<li>
<p>The channel process can initiate a new task.</p>
</li>
</ol>
<p><a href="#BABCJEEI">Table 22-1</a> shows asynchronous I/O in a tape backup. Asynchronous I/O to tape is simulated by using tape slaves. In this case, each allocated channel corresponds to a server process, which in the explanation that follows is identified as a channel process. For each channel process, one tape slave is started (or more than one, if multiple copies exist).</p>
<div id="BRADV399" class="figure">
<p class="titleinfigure"><a id="BABCJEEI"></a>Figure 22-6 Asynchronous Tape I/O</p>
<img width="496" height="240" src="img/bradv012.gif" alt="Description of Figure 22-6 follows" /><br />
<a id="sthref1711" href="img_text/bradv012.htm">Description of "Figure 22-6 Asynchronous Tape I/O"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The following steps occur:</p>
<ol>
<li>
<p>A channel process writes blocks to a tape buffer.</p>
</li>
<li>
<p>The channel process sends a message to the tape slave process to process the tape buffer. The tape slave process executes media manager code that processes the tape buffer and internalizes it so that the media manager can process it.</p>
</li>
<li>
<p>While the tape slave process is writing, the channel process is free to read data from the data files and prepare more output buffers.</p>
</li>
<li>
<p>After the tape slave channel returns from the media manager code, it requests a new tape buffer, which usually is ready. Thus waiting time for the channel process is reduced, and the backup is completed faster.</p>
</li>
</ol>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006228"></a>
<div id="BRADV99979" class="sect3">
<h4 class="sect3">Media Manager Component of the Write Phase for SBT</h4>
<p>The following factors affect the speed of the backup to tape:</p>
<ul>
<li>
<p><a href="#BABDDHAG">Network Throughput</a></p>
</li>
<li>
<p><a href="#i1006247">Native Transfer Rate</a></p>
</li>
<li>
<p><a href="#i1006250">Tape Compression</a></p>
</li>
<li>
<p><a href="#i1006253">Tape Streaming</a></p>
</li>
<li>
<p><a href="#i1006256">Physical Tape Block Size</a></p>
</li>
</ul>
<a id="BABDDHAG"></a>
<div id="BRADV99980" class="sect4">
<h5 class="sect4">Network Throughput</h5>
<p>If the tape device is remote, then the media manager must transfer data over the network. For example, an administrative domain in Oracle Secure Backup can contain multiple networked client hosts, media servers, and tape devices. If the database is on one host, but the output tape drive is attached to a different host, then Oracle Secure Backup manages the data transfer over the network. The network throughput is the upper limit for backup performance.</p>
</div>
<!-- class="sect4" -->
<a id="i1006247"></a>
<div id="BRADV89850" class="sect4">
<h5 class="sect4">Native Transfer Rate</h5>
<p>The tape <a href="glossary.htm#CHDDDBEG"><span class="xrefglossterm">native transfer rate</span></a> is the speed of writing to a tape without compression. This speed represents the upper limit of the backup rate. The upper limit of your backup performance should be the aggregate transfer rate of all of your tape drives. If your backup is already performing at that rate, and if it is not using an excessive amount of CPU, then RMAN performance tuning does not help.</p>
</div>
<!-- class="sect4" -->
<a id="i1006250"></a>
<div id="BRADV89851" class="sect4">
<h5 class="sect4">Tape Compression</h5>
<p>The level of tape compression is very important for backup performance. If the tape has good compression, then the sustained backup rate is faster. For example, if the compression ratio is 2:1 and native transfer rate of the tape drive is 6 megabytes per second, then the resulting backup speed is 12 megabytes per second. In this case, RMAN must be able to read disks with a throughput of more than 12 megabytes per second or the disk becomes the bottleneck for the backup.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
You should not use both tape compression provided by the media manager and binary compression provided by RMAN. If the media manager compression is efficient, then it is usually the better choice. Using RMAN-compressed backup sets can be an effective alternative to reduce bandwidth used to move uncompressed backup sets over a network to the media manager, if the CPU overhead required to compress the data in RMAN is acceptable.</div>
</div>
<!-- class="sect4" -->
<a id="i1006253"></a>
<div id="BRADV89852" class="sect4">
<h5 class="sect4">Tape Streaming</h5>
<p>Tape streaming during write operations has a major effect on tape backup performance. Many tape drives are fixed-speed, streaming tape drives. Because such drives can write data at only one speed, when they run out of data to write to tape, the tape must slow and stop. Typically, when the drive's buffer empties, the tape is moving so quickly that it actually overshoots; to continue writing, the drive must rewind the tape to locate the point where it stopped writing. Multiple speed tape drives are now available that alleviate this problem.</p>
</div>
<!-- class="sect4" -->
<a id="i1006256"></a>
<div id="BRADV89853" class="sect4">
<h5 class="sect4">Physical Tape Block Size</h5>
<p>The physical tape block size can affect backup performance. The block size is the amount of data written by media management software to a tape in one write operation. In general, the larger the tape block size, the faster the backup. The physical tape block size is not controlled by RMAN or Oracle database, but by media management software. See your media management software's documentation for details.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDAFCI"></a>
<div id="BRADV90075" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Write Phase for Disk</h3>
<p>The principal factor affecting the write phase for disk is the buffer size. When the output of the backup resides on disk, each channel allocates four output buffers of 1 MB each. The disk channel writes the blocks to the disk subsystem. When restoring files, the read phase is similar to the write phase when backing up files, except the blocks move in the opposite direction.</p>
<p>If RMAN reads from a disk asynchronously, then it writes to the disk asynchronously. When writing to disk, you can make use of disk I/O slaves just as when reading from disk.</p>
<p>If RMAN is backing up files to a disk-based output destination striped over multiple disks, then you can allocate multiple channels. The number of channels is limited only to the number of disks over which the destination is striped. ASM is one example of a destination striped over multiple disks.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCFFJB"></a>
<div id="BRADV90076" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using V$ Views to Diagnose RMAN Performance Problems</h2>
<p>Typically, you begin the tuning process by using <code dir="ltr">V$</code> views to determine where RMAN backup and restore operations are encountering problems.</p>
<a id="i1008231"></a>
<div id="BRADV99981" class="sect2">
<h3 class="sect2">Monitoring RMAN Job Progress with V$SESSION_LONGOPS</h3>
<p><a id="i1008234"></a><a id="sthref1712"></a>You <a id="sthref1713"></a>can monitor the progress of backups and restore jobs by querying the view <code dir="ltr">V$SESSION_LONGOPS</code>. RMAN uses two types of rows <a id="sthref1714"></a>in <code dir="ltr">V$SESSION_LONGOPS</code>: detail rows and aggregate rows.</p>
<p>Detail rows describe the files being processed by one job step, whereas aggregate rows describe the files processed by all job steps in an RMAN command. A job step is the creation or restoration of one backup set or data file copy. Detail rows are updated with every buffer that is read or written during the backup step, so their granularity of update is small. Aggregate rows are updated when each job step completes, so their granularity of update is large.</p>
<p><a href="#g1013679">Table 22-2</a> describes the columns in <code dir="ltr">V$SESSION_LONGOPS</code> that are most relevant for RMAN. Typically, you view the detail rows rather than the aggregate rows to determine the progress of each backup set.</p>
<div id="BRADV400" class="tblruleformal">
<p class="titleintable"><a id="sthref1715"></a><a id="g1013679"></a>Table 22-2 Columns of V$SESSION_LONGOPS Relevant for RMAN</p>
<table class="cellalignment1945" title="Columns of V$SESSION_LONGOPS Relevant for RMAN" summary="This table is described in the preceding paragraph." dir="ltr">
<thead>
<tr class="cellalignment1934">
<th class="cellalignment1941" id="r1c1-t4">Column</th>
<th class="cellalignment1941" id="r1c2-t4">Description for Detail Rows</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r2c1-t4" headers="r1c1-t4">
<p><code dir="ltr">SID</code></p>
</td>
<td class="cellalignment1942" headers="r2c1-t4 r1c2-t4">
<p>The server session ID corresponding to an RMAN channel</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r3c1-t4" headers="r1c1-t4">
<p><code dir="ltr">SERIAL#</code></p>
</td>
<td class="cellalignment1942" headers="r3c1-t4 r1c2-t4">
<p>The server session serial number. This value changes each time a server session is reused.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r4c1-t4" headers="r1c1-t4">
<p><code dir="ltr">OPNAME</code></p>
</td>
<td class="cellalignment1942" headers="r4c1-t4 r1c2-t4">
<p>A text description of the row. Examples of details rows include <code dir="ltr">RMAN:</code> <code dir="ltr">datafile</code> <code dir="ltr">copy</code>, <code dir="ltr">RMAN:</code> <code dir="ltr">full</code> <code dir="ltr">datafile</code> <code dir="ltr">backup</code>, and <code dir="ltr">RMAN:</code> <code dir="ltr">full</code> <code dir="ltr">datafile</code> <code dir="ltr">restore</code>.</p>
<p><span class="bold">Note:</span> <code dir="ltr">RMAN:</code> <code dir="ltr">aggregate</code> <code dir="ltr">input</code> and <code dir="ltr">RMAN:</code> <code dir="ltr">aggregate</code> <code dir="ltr">output</code> are the only aggregate rows.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r5c1-t4" headers="r1c1-t4">
<p><code dir="ltr">CONTEXT</code></p>
</td>
<td class="cellalignment1942" headers="r5c1-t4 r1c2-t4">
<p>For backup output rows, this value is <code dir="ltr">2</code>. For all other rows except proxy copy (which does not update this column), the value is <code dir="ltr">1</code>.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r6c1-t4" headers="r1c1-t4">
<p><code dir="ltr">SOFAR</code></p>
</td>
<td class="cellalignment1942" headers="r6c1-t4 r1c2-t4">
<p>The meaning of this column depends on the type of operation described by this row:</p>
<ul>
<li>
<p>For image copies, the number of blocks that have been read</p>
</li>
<li>
<p>For backup input rows, the number of blocks that have been read from the files being backed up</p>
</li>
<li>
<p>For backup output rows, the number of blocks that have been written to the backup piece</p>
</li>
<li>
<p>For restores, the number of blocks that have been processed to the files that are being restored in this one job step</p>
</li>
<li>
<p>For proxy copies, the number of files that have been copied</p>
</li>
</ul>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r7c1-t4" headers="r1c1-t4">
<p><code dir="ltr">TOTALWORK</code></p>
</td>
<td class="cellalignment1942" headers="r7c1-t4 r1c2-t4">
<p>The meaning of this column depends on the type of operation described by this row:</p>
<ul>
<li>
<p>For image copies, the total number of blocks in the file.</p>
</li>
<li>
<p>For backup input rows, the total number of blocks to be read from all files processed in this job step.</p>
</li>
<li>
<p>For backup output rows, the value is <code dir="ltr">0</code> because RMAN does not know how many blocks that it will write into any backup piece.</p>
</li>
<li>
<p>For restores, the total number of blocks in all files restored in this job step.</p>
</li>
<li>
<p>For proxy copies, the total number of files to be copied in this job step.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p>Each server session performing a backup or restore job reports its progress compared to the total work required for a job step. For example, if you restore the database with two channels, and each channel has two backup sets to restore (a total of four sets), then each server session reports its progress through a single backup set. When a set is completely restored, RMAN begins reporting progress on the next set to restore.</p>
<p class="subhead2"><a id="BRADV401"></a>To monitor RMAN job progress:</p>
<ol>
<li>
<p>Before starting the RMAN job, create a script file (called, for this example, <code dir="ltr">longops</code>) containing the following SQL statement:</p>
<pre dir="ltr">
SELECT SID, SERIAL#, CONTEXT, SOFAR, TOTALWORK,
       ROUND(SOFAR/TOTALWORK*100,2) "%_COMPLETE"
FROM   V$SESSION_LONGOPS
WHERE  OPNAME LIKE 'RMAN%'
AND    OPNAME NOT LIKE '%aggregate%'
AND    TOTALWORK != 0
AND    SOFAR &lt;&gt; TOTALWORK;
</pre></li>
<li>
<p>Start RMAN and connect to the target database and recovery catalog (if used).</p>
</li>
<li>
<p>Start an RMAN job. For example, enter:</p>
<pre dir="ltr">
RMAN&gt; RESTORE DATABASE;
</pre></li>
<li>
<p>While the RMAN job is running, start SQL*Plus and connect to the target database, and execute the <code dir="ltr">longops</code> script to check the progress of the RMAN job. If you repeat the query while the RMAN job progresses, then you see output such as the following:</p>
<pre dir="ltr">
SQL&gt; @longops
       SID    SERIAL#    CONTEXT      SOFAR  TOTALWORK %_COMPLETE
---------- ---------- ---------- ---------- ---------- ----------
         8         19          1      10377      36617      28.34

SQL&gt; @longops
       SID    SERIAL#    CONTEXT      SOFAR  TOTALWORK % COMPLETE
---------- ---------- ---------- ---------- ---------- ----------
         8         19          1      21513      36617      58.75

SQL&gt; @longops
       SID    SERIAL#    CONTEXT      SOFAR  TOTALWORK % COMPLETE
---------- ---------- ---------- ---------- ---------- ----------
         8         19          1      29641      36617      80.95

SQL&gt; @longops
       SID    SERIAL#    CONTEXT      SOFAR  TOTALWORK % COMPLETE
---------- ---------- ---------- ---------- ---------- ----------
         8         19          1      35849      36617       97.9

SQL&gt; @longops
no rows selected
</pre></li>
<li>
<p>If you run the <code dir="ltr">longops</code> script at intervals of 2 minutes or more and the <code dir="ltr">%</code>_<code dir="ltr">COMPLETE</code> column does not increase, then RMAN is encountering a problem. See <a href="rcmtroub.htm#i1008347">"Monitoring RMAN Interaction with the Media Manager"</a> to obtain more information.</p>
</li>
</ol>
<p>If you frequently monitor the execution of long-running tasks, then you could create a shell script or batch file under your host operating system that runs SQL*Plus to execute this query repeatedly.</p>
</div>
<!-- class="sect2" -->
<a id="i1006406"></a>
<div id="BRADV89862" class="sect2">
<h3 class="sect2">Identifying Bottlenecks with V$BACKUP_SYNC_IO and V$BACKUP_ASYNC_IO</h3>
<p>You can use <a id="sthref1716"></a>the <code dir="ltr">V$BACKUP_SYNC_IO</code> <a id="sthref1717"></a>and <code dir="ltr">V$BACKUP_ASYNC_IO</code> views to determine the source of backup or restore bottlenecks and to see detailed progress of backup jobs.</p>
<p><code dir="ltr">V$BACKUP_SYNC_IO</code> contains rows when the I/O is synchronous to the process (or thread on some platforms) performing the backup. <code dir="ltr">V$BACKUP_ASYNC_IO</code> contains rows when the I/O is asynchronous. Asynchronous I/O is obtained either with I/O processes or because it is supported by the underlying operating system.</p>
<p>The results of a backup or restore job remain in memory until the database instance shuts down. Thus, you can query the views after the job completes.</p>
<p class="subhead2"><a id="BRADV402"></a>To determine whether the tape is streaming when the I/O is synchronous:</p>
<ol>
<li>
<p>Start SQL*Plus and connect to the target database.</p>
</li>
<li>
<p>Query the <code dir="ltr">EFFECTIVE_BYTES_PER_SECOND</code> column in the <code dir="ltr">V$BACKUP_SYNC_IO</code> or <code dir="ltr">V$BACKUP_ASYNC_IO</code> view.</p>
<p>If <code dir="ltr">EFFECTIVE_BYTES_PER_SECOND</code> is less than the raw capacity of the hardware, then the tape is not streaming. If <code dir="ltr">EFFECTIVE_BYTES_PER_SECOND</code> is greater than the raw capacity of the hardware, the tape may or may not be streaming. Compression may cause the <code dir="ltr">EFFECTIVE_BYTES_PER_SECOND</code> to be greater than the speed of real I/O.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink REFRN" href="../../server.112/e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for more information about these views</div>
<a id="i1008624"></a>
<div id="BRADV89863" class="sect3">
<h4 class="sect3">Identifying Bottlenecks with Synchronous I/O</h4>
<p>With synchronous I/O, it is difficult to identify specific bottlenecks because all synchronous I/O is a bottleneck to the process. The only way to tune synchronous I/O is to compare the rate (in bytes per second) with the device's maximum throughput rate. If the rate is lower than the rate that the device specifies, then consider tuning this aspect of the backup and restore process.</p>
<p class="subhead2"><a id="BRADV403"></a>To determine the rate of synchronous I/O:</p>
<ol>
<li>
<p>Start SQL*Plus and connect to the target database.</p>
</li>
<li>
<p>Query the <code dir="ltr">DISCRETE_BYTES_PER_SECOND</code> column in the <code dir="ltr">V$BACKUP_SYNC_IO</code> view to display the I/O rate.</p>
<p>If you see data in <code dir="ltr">V$BACKUP_SYNC_IO</code>, then the problem is that you have not enabled asynchronous I/O or you are not using disk I/O slaves.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="i1006455"></a>
<div id="BRADV89864" class="sect3">
<h4 class="sect3">Identifying Bottlenecks with Asynchronous I/O</h4>
<p><span class="glossaryterm"><a id="sthref1718"></a><a id="sthref1719"></a>Long waits</span> are the number of times the backup or restore process told the operating system to wait until an I/O was complete. <a id="sthref1720"></a><a id="sthref1721"></a><span class="glossaryterm">Short waits</span> are the number of times the backup or restore process made an operating system call to poll for I/O completion in a nonblocking mode. <span class="glossaryterm">Ready</span> indicates the number of times when I/O was already ready for use, so there was no need to make an operating system call to poll for I/O completion.</p>
<p class="subhead2"><a id="BRADV404"></a>To determine the rate of asynchronous I/O:</p>
<ol>
<li>
<p>Start SQL*Plus and connect to the target database.</p>
</li>
<li>
<p>Query the <code dir="ltr">LONG_WAITS</code> and <code dir="ltr">IO_COUNT</code> columns in the <code dir="ltr">V$BACKUP_SYNC_IO</code> view to display the I/O rate.</p>
<p>The simplest way to identify the bottleneck is to find the data file that has the largest ratio for <code dir="ltr">LONG_WAITS</code> divided by <code dir="ltr">IO_COUNT</code>. For example, you can use the following query:</p>
<pre dir="ltr">
SELECT   LONG_WAITS/IO_COUNT, FILENAME
FROM     V$BACKUP_ASYNC_IO
WHERE    LONG_WAITS/IO_COUNT &gt; 0
ORDER BY LONG_WAITS/IO_COUNT DESC;
</pre></li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have synchronous I/O but you have set <code dir="ltr">BACKUP_DISK_IO_SLAVES</code>, then the I/O is displayed in <code dir="ltr">V$BACKUP_ASYNC_IO</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN003" href="../../server.112/e40402/dynviews_part.htm#REFRN003"><span class="italic">Oracle Database Reference</span></a> for descriptions of the <code dir="ltr">V$BACKUP_SYNC_IO</code> and <code dir="ltr">V$BACKUP_ASYNC_IO</code> views</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006329"></a>
<div id="BRADV172" class="sect1">
<h2 class="sect1">Tuning RMAN Backup Performance<a id="sthref1722"></a></h2>
<p>Many factors can affect backup performance. Often, finding the solution to a slow backup is a process of trial and error. To obtain the best performance for a backup, follow the steps in this section in sequential order.</p>
<p>This section contains the following steps:</p>
<ul>
<li>
<p><a href="#CACEBICE">Step 1: Remove the RATE Parameter from Channel Settings</a></p>
</li>
<li>
<p><a href="#CACCDFFB">Step 2: If You Use Synchronous Disk I/O, Set DBWR_IO_SLAVES</a></p>
</li>
<li>
<p><a href="#CACHJFED">Step 3: If You Fail to Allocate Shared Memory, Set LARGE_POOL_SIZE</a></p>
</li>
<li>
<p><a href="#i1006396">Step 4: Tune the Read, Write, and Copy Phases</a></p>
</li>
</ul>
<a id="CACEBICE"></a>
<div id="BRADV89855" class="sect2">
<h3 class="sect2">Step 1: Remove the RATE Parameter from Channel Settings</h3>
<p>As explained in <a href="#BABDCEHG">"RATE Channel Parameter"</a>, the <code dir="ltr">RATE</code> parameter on a channel is intended to reduce, rather than increase, backup throughput so that more disk bandwidth is available for other database operations. If the backup is not streaming to tape, then confirm that the <code dir="ltr">RATE</code> parameter is not set.</p>
<p class="subhead2"><a id="BRADV405"></a>To remove the RATE parameter:</p>
<ol>
<li>
<p>Examine your backup script.</p>
</li>
<li>
<p>Do one of the following:</p>
<ul>
<li>
<p>If the backup is in a <code dir="ltr">RUN</code> command, then remove the <code dir="ltr">RATE</code> parameter, if it is specified, from the <code dir="ltr">ALLOCATE</code> command. Skip the remaining steps.</p>
</li>
<li>
<p>If the backup is not in a <code dir="ltr">RUN</code> command, then start RMAN, connect to the target database, and proceed to the next step.</p>
</li>
</ul>
</li>
<li>
<p>Execute the <code dir="ltr">SHOW ALL</code> command to show the currently configured settings.</p>
</li>
<li>
<p>Remove the <code dir="ltr">RATE</code> parameter, if it is set, from the <code dir="ltr">CONFIGURE CHANNEL</code> command.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CACCDFFB"></a>
<div id="BRADV89856" class="sect2">
<h3 class="sect2">Step 2: If You Use Synchronous Disk I/O, Set DBWR_IO_SLAVES</h3>
<p>As explained in <a href="#BABBGAHE">"Synchronous and Asynchronous Disk I/O"</a>, some operating systems support native asynchronous I/O. If and only if your disk does <span class="italic">not</span> support asynchronous I/O, then set <code dir="ltr">DBWR_IO_SLAVES</code>. Any nonzero value for <code dir="ltr">DBWR_IO_SLAVES</code> causes a fixed number of disk I/O slaves to be used for backup and restore, which simulates asynchronous I/O.</p>
<p class="subhead2"><a id="BRADV406"></a>To enable disk I/O slaves:</p>
<ol>
<li>
<p>Start SQL*Plus and connect to the target database.</p>
</li>
<li>
<p>Shut down the database.</p>
</li>
<li>
<p>Set <code dir="ltr">DBWR_IO_SLAVES</code> initialization parameter to a nonzero value.</p>
<p>Setting <code dir="ltr">DBWR_IO_SLAVES</code> enables the database writer processes to use slaves. Thus, you may need to increase the value of the <code dir="ltr">PROCESSES</code> initialization parameter.</p>
</li>
<li>
<p>Restart the database.</p>
</li>
<li>
<p>Restart the RMAN backup.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CACHJFED"></a>
<div id="BRADV89857" class="sect2">
<h3 class="sect2">Step 3: If You Fail to Allocate Shared Memory, Set LARGE_POOL_SIZE</h3>
<p>Set the <code dir="ltr">LARGE_POOL_SIZE</code> initialization parameter if the database reports an error in the alert log stating that it does not have enough memory and that it cannot start I/O slaves. The message should resemble the following:</p>
<pre dir="ltr">
ksfqxcre: failure to allocate shared memory means sync I/O will be used whenever
async I/O to file not supported natively
</pre>
<p>The large pool is used for RMAN and for other purposes, so its total size should accommodate all uses. This is especially true if <code dir="ltr">DBWR_IO_SLAVES</code> has been set and the DBWR process needs buffers.</p>
<p class="subhead2"><a id="BRADV407"></a>To set the large pool size:</p>
<ol>
<li>
<p>Start SQL*Plus and connect to the target database.</p>
</li>
<li>
<p>Optionally, <a id="sthref1723"></a>query <code dir="ltr">V$SGASTAT.POOL</code> to determine in which pool (shared pool or large pool) the memory for an object resides.</p>
</li>
<li>
<p>Set the <code dir="ltr"><a id="sthref1724"></a><a id="sthref1725"></a>LARGE_POOL_SIZE</code> initialization parameter in the target database.</p>
<p>You can execute an <code dir="ltr">ALTER SYSTEM SET</code> statement to set the parameter dynamically. The formula for setting <code dir="ltr">LARGE_POOL_SIZE</code> is as follows:</p>
<pre dir="ltr">
LARGE_POOL_SIZE =  <span class="codeinlineitalic">number_of_allocated_channels</span> * 
                   (16 MB + ( 4 *  <span class="italic">size_of_tape_buffer </span>) )
</pre></li>
<li>
<p>Restart the RMAN backup.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink CNCPT" href="../../server.112/e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> for more information about the large pool, and <a class="olink REFRN" href="../../server.112/e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for complete information about initialization parameters</div>
</div>
<!-- class="sect2" -->
<a id="i1006396"></a>
<div id="BRADV89858" class="sect2">
<h3 class="sect2">Step 4: Tune the Read, Write, and Copy Phases</h3>
<p>There are several tasks that you can perform to identify and remedy bottlenecks that affect backup performance.</p>
<div id="BRADV89859" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1726"></a>
<h4 class="sect3">Using Backup Validation To Distinguish Between Read and Write Bottlenecks</h4>
<p>One reliable way to determine whether the output device or input disk I/O is the bottleneck in a given backup job is to compare the time required to run backup tasks with the time required to run <code dir="ltr">BACKUP VALIDATE</code> of the same tasks. <code dir="ltr">BACKUP VALIDATE</code> of a backup performs the same disk reads as a real backup but performs no I/O to an output device.</p>
<p class="subhead2"><a id="BRADV408"></a>To compare backup and validation times:</p>
<ol>
<li>
<p>Ensure your NLS environment date format variable is set to show the time. For example, set the NLS variables as follows:</p>
<pre dir="ltr">
setenv NLS_LANG  AMERICAN_AMERICA.WE8DEC;
setenv NLS_DATE_FORMAT "MM/DD/YYYY HH24:MI:SS"
</pre></li>
<li>
<p>Edit your backup script to use the <code dir="ltr">BACKUP VALIDATE</code> command instead of the <code dir="ltr">BACKUP</code> command.</p>
</li>
<li>
<p>Run the backup script.</p>
</li>
<li>
<p>Examine the RMAN output and calculate the difference between the times displayed in the <code dir="ltr">Starting backup at</code> and <code dir="ltr">Finished backup at</code> messages.</p>
</li>
<li>
<p>Edit the backup script to use the <code dir="ltr">BACKUP</code> command instead of the <code dir="ltr">BACKUP VALIDATE</code> command.</p>
</li>
<li>
<p>Run the backup script.</p>
</li>
<li>
<p>Examine the RMAN output and calculate the difference between the times displayed in the <code dir="ltr">Starting backup at</code> and <code dir="ltr">Finished backup at</code> messages.</p>
</li>
<li>
<p>Compare the backup times for the validation and real backup.</p>
<p>If the time for the <code dir="ltr">BACKUP VALIDATE</code> to tape is about the same as the time for a real backup to tape, then reading from disk is the likely bottleneck. See <a href="#BABGEIJG">"Tuning the Read Phase"</a>.</p>
<p>If the time for the <code dir="ltr">BACKUP VALIDATE</code> to tape is significantly less than the time for a real backup to tape, then writing to the output device is the likely bottleneck. See <a href="#BABEJEGC">"Tuning the Copy and Write Phases"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="BABGEIJG"></a>
<div id="BRADV89860" class="sect3">
<h4 class="sect3">Tuning the Read Phase</h4>
<p>RMAN may not be able to send data blocks to the output device fast enough to keep it occupied. For example, during an <a href="glossary.htm#i432786"><span class="xrefglossterm">incremental backup</span></a>, RMAN only backs up blocks changed since a previous data file backup as part of the same strategy. If you do not turn on <a href="glossary.htm#CHDIFJHF"><span class="xrefglossterm">block change tracking</span></a>, then RMAN must scan whole data files for changed blocks, and fill output buffers as it finds such blocks. If few blocks changed, and if RMAN is making an SBT backup, then RMAN may not fill output buffers fast enough to keep the tape drive streaming.</p>
<p>You can improve backup performance by adjusting the <a href="glossary.htm#CHDFBDDG"><span class="xrefglossterm">level of multiplexing</span></a>, which is number of input files simultaneously read and then written into the same RMAN backup piece. The level of multiplexing is the minimum of the <code dir="ltr">MAXOPENFILES</code> setting on the channel and the number of input files placed in each backup set. The following table makes recommendations for adjusting the level of multiplexing.</p>
<div id="BRADV409" class="tblformal">
<p class="titleintable"><a id="sthref1727"></a><a id="sthref1728"></a>Table 22-3 Adjusting the Level of Multiplexing</p>
<table class="cellalignment1940" title="Adjusting the Level of Multiplexing" summary="Leve of multiplexing" dir="ltr">
<thead>
<tr class="cellalignment1934">
<th class="cellalignment1941" id="r1c1-t9">ASM</th>
<th class="cellalignment1941" id="r1c2-t9">Striped Disk</th>
<th class="cellalignment1941" id="r1c3-t9">Recommendation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r2c1-t9" headers="r1c1-t9">
<p>No</p>
</td>
<td class="cellalignment1942" headers="r2c1-t9 r1c2-t9">
<p>Yes</p>
</td>
<td class="cellalignment1942" headers="r2c1-t9 r1c3-t9">
<p>Increase the level of multiplexing. Determine which is the minimum, <code dir="ltr">MAXOPENFILES</code> or the number of files in each backup set, and then increase this value.</p>
<p>In this way, you increase the rate at which RMAN fills tape buffers, which makes it more likely that buffers are sent to the media manager fast enough to maintain streaming.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r3c1-t9" headers="r1c1-t9">
<p>No</p>
</td>
<td class="cellalignment1942" headers="r3c1-t9 r1c2-t9">
<p>No</p>
</td>
<td class="cellalignment1942" headers="r3c1-t9 r1c3-t9">
<p>Increase the <code dir="ltr">MAXOPENFILES</code> setting on the channel.</p>
</td>
</tr>
<tr class="cellalignment1934">
<td class="cellalignment1942" id="r4c1-t9" headers="r1c1-t9">
<p>Yes</p>
</td>
<td class="cellalignment1942" headers="r4c1-t9 r1c2-t9">
<p>Not applicable</p>
</td>
<td class="cellalignment1942" headers="r4c1-t9 r1c3-t9">
<p>Set the <code dir="ltr">MAXOPENFILES</code> parameter on the channel to <code dir="ltr">1</code> or <code dir="ltr">2</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="rcmcncpt.htm#i1015964">"Multiplexed Backup Sets"</a> to learn how the <code dir="ltr">MAXOPENFILES</code> and <code dir="ltr">FILESPERSET</code> settings affect the level of multiplexing</p>
</li>
<li>
<p><a href="rcmcncpt.htm#i1007616">"Incremental Backups"</a> for a conceptual overview</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABEJEGC"></a>
<div id="BRADV89861" class="sect3">
<h4 class="sect3">Tuning the Copy and Write Phases</h4>
<p>If the read phase is performing well, then the copy or write phases are probably the bottleneck. In particular, if RMAN is sending data blocks to the tape drive fast enough to support streaming, but the tape is not streaming, then the SBT write phase is the bottleneck. Try to improve performance as follows:</p>
<ul>
<li>
<p>If the backup is a <a href="glossary.htm#i432658"><span class="xrefglossterm">full backup</span></a>, then consider using incremental backups.</p>
<p>Incremental level 1 backups write only the changed blocks from data files to tape, so that any bottleneck on writing to tape has less impact on your overall backup strategy. In particular, if tape drives are not locally attached to the node of the database being backed up, then incremental backups can be faster. See <a href="rcmbckba.htm#i1034163">"Making and Updating Incremental Backups"</a>.</p>
</li>
<li>
<p>If the backup uses the basic compression algorithm, then consider using an Advanced Compression Option.</p>
<p>See <a href="rcmconfa.htm#CHDEHCEB">"Configuring Compression Options"</a> or <a href="rcmcncpt.htm#CIHFEBFI">"Binary Compression for Backup Sets"</a>.</p>
</li>
<li>
<p>If the database host uses multiple CPUs, and if the backup uses binary compression, then increase the number of channels.</p>
</li>
<li>
<p>If the backup is encrypted, then change the encryption algorithm to <code dir="ltr">AES128</code>.</p>
<p>The <code dir="ltr">AES128</code> algorithm is the least CPU-intensive algorithm. See <a href="rcmconfa.htm#CHDFAHHJ">"Configuring the Backup Encryption Algorithm"</a>.</p>
</li>
<li>
<p>If RMAN is backing up to tape, then try the following adjustments:</p>
<ul>
<li>
<p>Adjust the size of the tape I/O buffers.</p>
<p>Use the <code dir="ltr">PARMS</code> and <code dir="ltr">BLKSIZE</code> parameters of the <code dir="ltr">ALLOCATE CHANNEL</code> or <code dir="ltr">CONFIGURE CHANNEL</code> command to set the size. The size of the tape I/O buffers is platform-dependent. The <code dir="ltr">BLKSIZE</code> setting overrides the default.</p>
</li>
<li>
<p>Adjust settings in the media management software.</p>
<p>Some media manager settings, including the tape block size, may affect backup performance.</p>
</li>
</ul>
</li>
<li>
<p>If RMAN is backing up files to ASM, then increase the number of channels.</p>
<p>For example, if RMAN is backing up the database to a single disk group with 16 physical disks, then allocate or configure at least 4 disk channels, up to a maximum of 16.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1933">
<tr>
<td class="cellalignment1942">
<table class="cellalignment1938">
<tr>
<td class="cellalignment1937"><a href="part_tun.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1937"><a href="rcmtroub.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2003, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1944">
<table class="cellalignment1936">
<tr>
<td class="cellalignment1937"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1937"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1937"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1937"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1937"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1937"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
