<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>The Data Mining Java API</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 025" />
<meta name="dcterms.created" content="2011-06-30T14:1:10Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Data Mining Application Developer's Guide" />
<meta name="dcterms.identifier" content="E12218-07" />
<meta name="dcterms.isVersionOf" content="DMPRG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2005, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="models_deploying.htm" title="Previous" type="text/html" />
<link rel="Next" href="index.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e12218.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/15</span> <!-- End Header --><a id="BGBBBDEA"></a><a id="DMPRG009"></a>
<h1 class="chapter"><span class="secnum">7</span> The Data Mining Java API</h1>
<p>This chap<a id="sthref371"></a>ter presents an overview of the Oracle Data Mining Java API. The Java API is based on JDM, the industry-standard Java API for data mining.</p>
<p>The Java API is layered on the PL/SQL and SQL language interfaces to Oracle Data Mining. All the SQL-based functionality described in this manual is also implemented in the Java API.</p>
<p>However, the Java API supports several features not implemented in SQL, such as asynchronous execution of mining tasks and text transformation.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle Data Mining Java API is deprecated in this release.
<p>Oracle recommends that you not use deprecated features in new applications. Support for deprecated features is for backward compatibility only</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DMJAV" href="../e12219/toc.htm"><span class="italic">Oracle Data Mining Java API Reference</span></a> (javadoc)</div>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BABJBAHD">The Java Environment</a></p>
</li>
<li>
<p><a href="#BABGGECJ">Connecting to the Data Mining Engine</a></p>
</li>
<li>
<p><a href="#BABJFEFJ">API Design Overview</a></p>
</li>
</ul>
<a id="BABJBAHD"></a><a id="DMPRG249"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">The Java Environment</h2>
<p>The Oracle Data Mining Java API requires Oracle Database 11<span class="italic">g</span> Release 2 (11.2) and J2SE 1.5. It is backward compatible and can be used with Oracle Database 10.2.</p>
<p>To use the Oracle Data Mining Java API, include the following libraries in your <code>CLASSPATH</code>:</p>
<pre>
$ORACLE_HOME/rdbms/jlib/jdm.jar
$ORACLE_HOME/rdbms/jlib/ojdm_api.jar
$ORACLE_HOME/rdbms/jlib/xdb.jar
$ORACLE_HOME/jdbc/lib/ojdbc5.jar
$ORACLE_HOME//oc4j/j2ee/home/lib/connector.jar 
$ORACLE_HOME/jlib/orai18n.jar
$ORACLE_HOME/jlib/orai18n-mapping.jar 
$ORACLE_HOME/lib/xmlparserv2.jar
</pre></div>
<!-- class="sect1" -->
<a id="BABGGECJ"></a><a id="DMPRG250"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Connecting to the Data Mining Engine</h2>
<p>The Data Mining Engine (DME) is the infrastructure that offers a set of data mining services to its JDM clients. The Oracle Database provides the in-database data mining functionality for JDM through the core Oracle Data Mining option. So in the rest of this document the Oracle Database is referred to as the DME.</p>
<p>To access data mining functionality in the database, a DME Connection needs to be created. To connect to the DME, OJDM supports following different options.</p>
<p>The DME <code>Connection</code> object is described in detail in <a href="#BABIFIHD">"Features of a DME Connection"</a>.</p>
<a id="BABBAIIG"></a><a id="DMPRG251"></a>
<div class="sect2">
<h3 class="sect2">Connection Factory</h3>
<p>The Connection factory is used to create a DME connection. The JDM standard defines ConnectionFactory as a Java interface to provide a vendor neutral approach to create a DME Connection. In this approach, the application infrastructure needs to register the instance of ConnectionFactory in a JNDI server. Applications can lookup for ConnectionFactory in the JNDI server to instantiate a Connection using this factory.</p>
<p>OJDM provides <code>oracle.dmt.jdm.resource.OraConnectionFactory</code> class, which can either be instantiated and accessed to create the connection or can be registered in JNDI server. Following code illustrates these two approaches to create a connection factory.</p>
<a id="DMPRG252"></a>
<div class="sect3"><a id="sthref372"></a>
<h4 class="sect3">Create ConnectionFactory Using OraConnectionFactory</h4>
<pre>
//Create OraConnectionFactory
javax.datamining.resource.ConnectionFactory connFactory = 
                 oracle.dmt.jdm.resource.OraConnectionFactory();
</pre></div>
<!-- class="sect3" -->
<a id="DMPRG253"></a>
<div class="sect3"><a id="sthref373"></a>
<h4 class="sect3">Lookup ConnectionFactory From the JNDI Server</h4>
<pre>
//Setup the initial context to connect to the JNDI server
Hashtable env = new Hashtable();
env.put( Context.INITIAL_CONTEXT_FACTORY,
"oracle.dmt.jdm.resource.OraConnectionFactory" );
env.put( Context.PROVIDER_URL, "http://myHost:myPort/myService" );
env.put( Context.SECURITY_PRINCIPAL, "user" );
env.put( Context.SECURITY_CREDENTIALS, "password" );
InitialContext jndiContext = new javax.naming.InitialContext( env );
// Perform JNDI lookup to obtain the connection factory
javax.datamining.resource.ConnectionFactory dmeConnFactory =
(ConnectionFactory) jndiContext.lookup("java:comp/env/jdm/MyServer");
//Lookup ConnectionFactory
javax.datamining.resource.ConnectionFactory connFactory = 
  (ConnectionFactory) jndiContext.lookup("java:comp/env/jdm/MyServer");
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="DMPRG254"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref374"></a>
<h3 class="sect2">Connect Using JDBC</h3>
<p>This option is useful when the applications want to control the JDBC Connections outside the OJDM and allow the OraConnectionFactory to use the specified OracleDataSource to create the database connection. This approach gives applications the ability to use the implicit connection caching features as required. By default, OJDM doesn't enable the implicit connection caching. <a class="olink JJDBC" href="../../java.112/e16548/toc.htm"><span class="italic">Oracle Database JDBC Developer's Guide</span></a> for information about connection caching.</p>
<pre>
//Create an OracleDataSource
OracleDataSource ods = new OracleDataSource();
ods.setURL(URL);
ods.setUser(user);
ods.setPassword(password);
 
//Create a connection factory using the OracleDataSource
javax.datamining.resource.ConnectionFactory connFactory = 
  oracle.dmt.jdm.resource.OraConnectionFactory(ods);
//Create DME Connection
javax.datamining.resource.Connection dmeConn = 
    connFactory.getConnection();
</pre></div>
<!-- class="sect2" -->
<a id="DMPRG255"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref375"></a>
<h3 class="sect2">Connect Using ConnectionSpec</h3>
<p>This option is useful when the application doesn't want to pre-create the JDBC Connection and allow OJDM to maintain the JDBC Connection. Here the user needs to create an empty <code>ConnectionSpec</code> instance using <code>getConnectionSpec</code>() method in the <code>oracle.dmt.jdm.resource.OraConnectionFactory</code> class and create a DME Connection using the connection spec. The following code illustrates the usage.</p>
<pre>
//Create ConnectionSpec
ConnectionSpec connSpec = m_dmeConnFactory.getConnectionSpec();
connSpec.setURI("jdbc:oracle:thin:@host:port:sid");
connSpec.setName("user");
connSpec.setPassword("password");          
 
//Create DME Connection
javax.datamining.resource.Connection m_dmeConn = 
m_dmeConnFactory.getConnection(connSpec);
</pre></div>
<!-- class="sect2" -->
<a id="BABIFIHD"></a><a id="DMPRG256"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Features of a DME Connection</h3>
<p>In the Oracle Data Mining Java API, the DME <code>Connection</code> is the primary factory object. The <code>Connection</code> instantiates the object factories using the <code>getFactory</code> method. The <code>Connection</code> object provides named object lookup, persistence, and task execution features.</p>
<a id="DMPRG257"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref376"></a>
<h4 class="sect3">Create Object Factories</h4>
<p>The <code>Connection.getFactory</code> method creates a factory object. For example, to create a factory for the <code>PhysicalDataSet</code> object, pass the absolute name of the object to this method. The <code>getFactory</code> method creates an instance of <code>PhysicalDataSetFactory</code>.</p>
<pre>
javax.datamining.data.PhysicalDataSetFactory pdsFactory =
                dmeConn.getFactory("javax.datamining.data.PhysicalDataSet");
</pre></div>
<!-- class="sect3" -->
<a id="DMPRG258"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref377"></a>
<h4 class="sect3">Provide Access to Mining Object Metadata</h4>
<p>The <code>Connection</code> object provides methods for retrieving metadata about mining objects.</p>
<div class="inftblinformal">
<table class="cellalignment1308" title="Retrieving metadata about mining objects." summary="Connection methods for retrieving metadata about mining objects." dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t4">Method</th>
<th class="cellalignment1304" id="r1c2-t4">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t4" headers="r1c1-t4"><code>getCreationDate</code></td>
<td class="cellalignment1305" headers="r2c1-t4 r1c2-t4">Returns the creation date of the specified named object.
<pre>
getCreationDate(java.lang.String objectName,
                 NamedObject objectType)
     returns java.util.Date
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t4" headers="r1c1-t4"><code>getDescription</code></td>
<td class="cellalignment1305" headers="r3c1-t4 r1c2-t4">Returns the description of the specified mining object.
<pre>
getDescription(java.lang.String objectName,
                NamedObject objectType)
     returns java.lang.String 
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r4c1-t4" headers="r1c1-t4"><code>getObjectNames</code></td>
<td class="cellalignment1305" headers="r4c1-t4 r1c2-t4">Returns a collection of the names of the objects of the specified type.
<pre>
getObjectNames(NamedObject objectType)
     returns java.util.Collection
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r5c1-t4" headers="r1c1-t4"><code>getObjectNames</code></td>
<td class="cellalignment1305" headers="r5c1-t4 r1c2-t4">This is an Oracle JDM extension method that is added in 11.1 to provide a listing of mining object names across schemas or within a schema. It provides various optional method arguments that can be used to get a filtered list of arguments.
<pre>
getObjectNames(
java.lang.String schemaPattern, 
NamedObject objectType, 
java.lang.String objectNamePattern, 
javax.datamining.Enum minorType_1,
javax.datamining.Enum minorType_2 ): 
returns java.sql.ResultSet
</pre>
<p>See <a href="#BGBECBJH">Example 7-1</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="example">
<p class="titleinexample"><a id="BGBECBJH"></a><a id="DMPRG259"></a>Example 7-1 Oracle JDM Extension Method getObjectNames</p>
<p>This example illustrates the <code>getObjectNames</code> method.</p>
<p>To list the names of classification test metrics computed by the user <code>SCOTT</code>, specify:</p>
<br />
the <code>schemaPattern</code> as "SCOTT"<br />
<code>objectType</code> as <code>NamedObject.testMetrics</code><br />
<code>objectPattern</code> as null<br />
<code>minorType_1</code> as <code>MiningFunction.classification</code><br />
<code>minorType_2</code> as null<br /></div>
<!-- class="example" -->
<p>Irrespective of the type of filters specified, the <code>getObjectNames</code> method returns the <code>java.sql.ResultSet</code> object with the following columns.</p>
<div class="inftblhruleinformal">
<table class="cellalignment1308" title="Columns returned by GetObjectNames method" summary="java.sql.ResultSet object columns returned by getObjectNames Oracle JDM extension method" dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t5">Column Name</th>
<th class="cellalignment1304" id="r1c2-t5">Data Type</th>
<th class="cellalignment1304" id="r1c3-t5">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t5" headers="r1c1-t5"><code>SCHEMA_NAME</code></td>
<td class="cellalignment1305" headers="r2c1-t5 r1c2-t5">String</td>
<td class="cellalignment1305" headers="r2c1-t5 r1c3-t5">Name of the schema (can be null)</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t5" headers="r1c1-t5"><code>TYPE</code></td>
<td class="cellalignment1305" headers="r3c1-t5 r1c2-t5">String</td>
<td class="cellalignment1305" headers="r3c1-t5 r1c3-t5">Type of the mining object</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r4c1-t5" headers="r1c1-t5"><code>NAME</code></td>
<td class="cellalignment1305" headers="r4c1-t5 r1c2-t5">String</td>
<td class="cellalignment1305" headers="r4c1-t5 r1c3-t5">Name of the mining object</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r5c1-t5" headers="r1c1-t5"><code>MINOR_TYPE_1</code></td>
<td class="cellalignment1305" headers="r5c1-t5 r1c2-t5">String</td>
<td class="cellalignment1305" headers="r5c1-t5 r1c3-t5">Mining objects can have minor/sub types. For example, model objects can have function and algorithm as minor types.</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r6c1-t5" headers="r1c1-t5"><code>MINOR_TYPE_2</code></td>
<td class="cellalignment1305" headers="r6c1-t5 r1c2-t5">String</td>
<td class="cellalignment1305" headers="r6c1-t5 r1c3-t5">Mining objects can have more than one minor type. If they have a second minor type, then this column is used.</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r7c1-t5" headers="r1c1-t5"><code>CREATION_DATE</code></td>
<td class="cellalignment1305" headers="r7c1-t5 r1c2-t5">Timestamp</td>
<td class="cellalignment1305" headers="r7c1-t5 r1c3-t5">Date when this object was created</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r8c1-t5" headers="r1c1-t5"><code>DESCRIPTION</code></td>
<td class="cellalignment1305" headers="r8c1-t5 r1c2-t5">String</td>
<td class="cellalignment1305" headers="r8c1-t5 r1c3-t5">Description of the object</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect3" -->
<a id="DMPRG260"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref378"></a>
<h4 class="sect3">Persistence and Retrieval of Mining Objects</h4>
<p>The <code>Connection</code> object provides methods for retrieving mining objects and saving them in the DME. Persistent objects are stored as database objects. Transient objects are stored in memory by the <code>Connection</code> object.</p>
<div class="inftblinformal">
<table class="cellalignment1308" title="Saving and retrieving mining objects" summary="Connection methods for saving and retrieving mining objects." dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t6">Method</th>
<th class="cellalignment1304" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t6" headers="r1c1-t6"><code>saveObject</code></td>
<td class="cellalignment1305" headers="r2c1-t6 r1c2-t6">Saves the named object in the metadata repository associated with the connection.
<pre>
saveObject(java.lang.String name, MiningObject object,
            boolean replace)
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t6" headers="r1c1-t6"><code>retrieveObject</code></td>
<td class="cellalignment1305" headers="r3c1-t6 r1c2-t6">Retrieves a copy of the specified named object from the metadata repository associated with the connection.
<pre>
retrieveObject(java.lang.String objectIdentifier)
    returns MiningObject 
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r4c1-t6" headers="r1c1-t6"><code>retrieveObject</code></td>
<td class="cellalignment1305" headers="r4c1-t6 r1c2-t6">Retrieves a copy of the named object from the metadata repository associated with the connection.
<pre>
retrieveObject(java.lang.String name, 
                NamedObject objectType)
     returns MiningObject 
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r5c1-t6" headers="r1c1-t6"><code>retrieveObjects</code></td>
<td class="cellalignment1305" headers="r5c1-t6 r1c2-t6">Returns a collection of mining objects of the given type that were created within the specified time interval (from createAfter to createBefore).
<pre>
(java.util.Date createdAfter, java.util.Date createdBefore,
 NamedObject objectType):
 returns java.util.Collection
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r6c1-t6" headers="r1c1-t6"><code>retrieveObjects</code></td>
<td class="cellalignment1305" headers="r6c1-t6 r1c2-t6">Returns a collection of mining objects of the specified type that were created within the specified time interval (from createAfter to createBefore)
<pre>
retrieveObjects(java.util.Date createdAfter, 
java.util.Date createdBefore, NamedObject objectType, 
Enum minorType): 
returns java.util.Collection
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="api_tour.htm#BGBDEJFB">Chapter 2, "A Tour of the Data Mining APIs"</a>.</p>
</li>
<li>
<p><a href="#BABJFEFJ">"API Design Overview"</a>.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="DMPRG261"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref379"></a>
<h4 class="sect3">Execute Mining Tasks</h4>
<p>The <code>Connection</code> object provides an <code>execute</code> method, which can execute mining tasks either asynchronously or synchronously. The DME uses the database Scheduler to execute mining tasks, which are stored in the user's schema as Scheduler jobs. The following methods are used to execute the tasks.</p>
<div class="inftblinformal">
<table class="cellalignment1308" title="Synchronous and asynchronous task execution" summary="Execute method for asynchronous and synchonous task exection." dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t8">Task Execution</th>
<th class="cellalignment1304" id="r1c2-t8">execute method syntax</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t8" headers="r1c1-t8">asynchronous</td>
<td class="cellalignment1305" headers="r2c1-t8 r1c2-t8">
<pre>
execute(java.lang.String taskName)
     returns ExecutionHandle                 
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t8" headers="r1c1-t8">synchronous</td>
<td class="cellalignment1305" headers="r3c1-t8 r1c2-t8">
<pre>
execute(Task task,java.lang.Long timeout))
     returns ExecutionHandle                 
</pre>
Typically to be used with single record scoring, but it may be used in other contexts as well.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="api_tour.htm#BABFCDAE">"Task"</a></p>
</li>
<li>
<p><a href="#BABCHGDA">"Executing Mining Tasks"</a></p>
</li>
<li>
<p><a class="olink ADMIN035" href="../../server.112/e25494/schedadmin.htm#ADMIN035"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about the Oracle Database Scheduler.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="DMPRG262"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref380"></a>
<h4 class="sect3">Retrieve DME Capabilities and Metadata</h4>
<p>The <code>Connection</code> interface provides a <code>ConnectionMetaData</code> and <code>supportsCapability</code> retrieval methods. This feature is useful for applications to know more about the DME at runtime. The following methods are used for retrieving this information from the connection.</p>
<div class="inftblinformal">
<table class="cellalignment1308" title="Obtaining information about the DMS" summary="Connection methods for obtaining information about the DMS" dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t10">Method</th>
<th class="cellalignment1304" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t10" headers="r1c1-t10"><code>getMetaData</code></td>
<td class="cellalignment1305" headers="r2c1-t10 r1c2-t10">Returns information about the underlying DME instance represented through an active connection. <code>ConnectionMetaData</code> provides version information for the JDM implementation and Oracle Database.
<pre>
getMetaData()
      returns ConnectionMetaData
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t10" headers="r1c1-t10"><code>getSupportedFunctions</code></td>
<td class="cellalignment1305" headers="r3c1-t10 r1c2-t10">Returns an array of mining functions that are supported by the implementation.
<pre>
getSupportedFunctions()
     returns MiningFunction[]
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r4c1-t10" headers="r1c1-t10"><code>getSupportedAlgorithms</code></td>
<td class="cellalignment1305" headers="r4c1-t10 r1c2-t10">Returns an array of mining algorithms that are supported by the specified mining function.
<pre>
getSupportedAlgorithms(MiningFunction function)
     returns MiningAlgorithm[]
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r5c1-t10" headers="r1c1-t10"><code>supportsCapability</code></td>
<td class="cellalignment1305" headers="r5c1-t10 r1c2-t10">Returns true if the specified combination of mining capabilities is supported. If an algorithm is not specified, returns true if the specified function is supported.
<pre>
supportsCapability(MiningFunction function,
                    MiningAlgorithm algorithm, 
                    MiningTask taskType)
     returns boolean
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect3" -->
<a id="DMPRG263"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref381"></a>
<h4 class="sect3">Retrieve Version Information</h4>
<p>The <code>ConnectionMetaData</code> object provides methods for retrieving JDM standard version information and Oracle version information.</p>
<div class="inftblinformal">
<table class="cellalignment1308" title="Retrieving version information" summary="Connection methods for retrieving version information" dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t11">Method</th>
<th class="cellalignment1304" id="r1c2-t11">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t11" headers="r1c1-t11"><code>getVersion</code></td>
<td class="cellalignment1305" headers="r2c1-t11 r1c2-t11">Returns the version of the JDM Standard API. It must be "JDM 1.0" for the first release of JDM.
<pre>
getVersion()
     returns String
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t11" headers="r1c1-t11"><code>getMajorVersion</code></td>
<td class="cellalignment1305" headers="r3c1-t11 r1c2-t11">Returns the major version number. For the first release of JDM, this is "1".
<pre>
getMajorVersion()
     returns int
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r4c1-t11" headers="r1c1-t11"><code>getMinorVersion</code></td>
<td class="cellalignment1305" headers="r4c1-t11 r1c2-t11">Returns the minor version number. For the first release of JDM, this is "0".
<pre>
getMinorVersion()
     returns int
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r5c1-t11" headers="r1c1-t11"><code>getProviderName</code></td>
<td class="cellalignment1305" headers="r5c1-t11 r1c2-t11">Returns the provider name as "Oracle Corporation".
<pre>
getProviderName()
     returns String
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r6c1-t11" headers="r1c1-t11"><code>getProviderVersion</code></td>
<td class="cellalignment1305" headers="r6c1-t11 r1c2-t11">Returns the version of the Oracle Database that shipped the Oracle Data Mining Java API jar file.
<pre>
getProviderVersion()
     returns String       
</pre></td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r7c1-t11" headers="r1c1-t11"><code>getProviderDMEVersion</code></td>
<td class="cellalignment1305" headers="r7c1-t11 r1c2-t11">Returns the DME version of the provider
<pre>
getProviderDMEVersion()
     returns String       
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABJFEFJ"></a><a id="DMPRG264"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">API Design Overview</h2>
<p>This section briefly describes the OJDM design principles to familiarize the developers with the API. The JDM standard uses the factory method pattern as the core design pattern for the API. User can instantiate a JDM object using its factory. This enables JDM vendors like Oracle to implement a vendor neutral API. OJDM follows the same factory method pattern for its extensions. <code>javax.datamining</code> is the base package for the JDM standard defined classes and <span class="bold">oracle.dmt.jdm</span> is the base package for the Oracle extensions to the JDM standard</p>
<p>The JDM standard organizes its packages by the mining functions and mining algorithms. For example, <span class="bold">javax.datamining.supervised</span> package has all the supervised functions related classes and sub-packages <span class="bold">java.datamining.supervised.classification</span> and <span class="bold">java.datamining.supervised.regression</span>. Each function sub-package has the classes related to that function. Similarly, <span class="bold">javax.datamining.algorithm</span> is the base package for all algorithms and each algorithm has its sub-package under this package, for example, <span class="bold">javax.datamining.algorithm.naivebayes</span> is the sub-package for Na&iuml;ve Bayes algorithm related classes. OJDM follows a similar package structure for the extensions, for example, feature extraction is a non-JDM standard function supported by the OJDM, here <span class="bold">oracle.dmt.jdm.featureextraction</span> is the package for this function and <span class="bold">oracle.dmt.jdm.algorithm.nmf</span> package for the Non-Negative Matrix Factorization algorithm used for feature extraction.</p>
<p>The JDM standard has some core packages that define common classes and packages for tasks, model details, rules and statistics. For more details refer to the JDM javadoc. The class diagram in <a href="#BABDBBHG">Figure 7-1</a> illustrates the inheritance hierarchy of the named mining objects that are discussed in <a href="api_tour.htm#BGBDEJFB">Chapter 2</a>. In the subsequent sections more class diagrams are used to illustrate other OJDM objects. Note that the classes/interfaces shown in gray color are oracle JDM extension interfaces/classes. In <a href="#BABDBBHG">Figure 7-1</a>, <span class="bold">oracle.dmt.jdm.transform.OraTransformationSequence</span> is an Oracle extension to the mining objects defined in JDM 1.1 standard.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABDBBHG"></a><a id="DMPRG265"></a>Figure 7-1 JDM Named Objects Class Diagram</p>
<img width="766" height="226" src="img/named_object.gif" alt="Named objects class diagram." /><br />
<a id="sthref382" href="img_text/named_object.htm">Description of "Figure 7-1 JDM Named Objects Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="BGBEIJDH"></a><a id="DMPRG266"></a>
<div class="sect2">
<h3 class="sect2">Describing the Mining Data</h3>
<p>The JDM standard defines physical and logical data objects to describe the mining attribute characteristics of the data as well as statistical computations for describing the data.</p>
<p>The <code>javax.datamining.data</code> package contains all the data-related classes. The class diagram in <a href="#BABHAAGF">Figure 7-2</a> illustrates the class relationships of the data objects supported by the Oracle Data Mining Java API.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABHAAGF"></a><a id="DMPRG267"></a>Figure 7-2 Data Objects in Oracle Data Mining Java API</p>
<img width="624" height="226" src="img/data_objects.gif" alt="Data objects class diagram" /><br />
<a id="sthref383" href="img_text/data_objects.htm">Description of "Figure 7-2 Data Objects in Oracle Data Mining Java API"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The <code>PhysicalDataSet</code> object is used to specify the name and location of the dataset used for mining operations. For example, to represent a model build input dataset <code>MINING_DATA_BUILD_V</code> in a <code>DMUSER</code> schema account, <code>PhysicalDataSet</code> object is created with the data <code>URI DMUSER.MINING_DATA_BUILD_V</code>. The schema name prefix is optional when accessing the datasets in the same user account.</p>
<p>Note that in the class diagram in <a href="#BABHAAGF">Figure 7-2</a> a <code>PhysicalDataSet</code> can have <code>PhysicalAttribute</code> objects. A <code>PhysicalAttribute</code> represents physical characteristics of the columns of the input dataset; optionally physical attributes can specify the roles of the column. For example, in the <code>MINING_DATA_BUILD_V</code> dataset, <code>CUST_ID</code> uniquely identifies each case used for mining. So the role of the <code>CUST_ID</code> column is specified as case id.</p>
<p><a href="#BGBJCJGG">Example 7-2</a> illustrates the code sample that creates the <code>PhysicalDataSet</code> object. Note that the <code>PhysicalDataSet</code> object is saved with the name <code>JDM_BUILD_PDS</code> that can be specified as input to model build that we discuss later in <a href="#BABIADDC">"Build Settings"</a></p>
<p>The <code>PhysicalDataRecord</code> object shown in <a href="#BABHAAGF">Figure 7-2</a> is used to specify a single record of a dataset. It is used for single record apply that we will discuss in a later section of this Chapter. The <code>SignatureAttribute</code> is used to specify the model signature of a mining model that will be discussed in later section of this Chapter.In OJDM attribute data types are used to implicitly specify the mining attribute types. For example, all <code>VARCHAR2</code> columns are treated as categorical and all <code>NUMBER</code> columns are treated as numerical. So there is no need to specify logical data details in OJDM. However, to rename attributes of a column, a user can specify the embedded transformations that are discussed in the next section.</p>
<div class="example">
<p class="titleinexample"><a id="BGBJCJGG"></a><a id="DMPRG268"></a>Example 7-2 Creation of a Physical Dataset</p>
<pre>
//Create PhysicalDataSetFactory
PhysicalDataSetFactory pdsFactory = 
(PhysicalDataSetFactory)m_dmeConn.getFactory("javax.datamining.data.PhysicalDataSet");
//Create a PhysicalDataSet object
PhysicalDataSet buildData = pdsFactory.create("DMUSER.MINING_DATA_BUILD_V", false);
//Create PhysicalAttributeFactory 
PhysicalAttributeFactory paFactory =
(PhysicalAttributeFactory)m_dmeConn.getFactory("javax.datamining.data.PhysicalAttribute");
//Create PhysicalAttribute object
PhysicalAttribute pAttr = paFactory.create(
"cust_id", AttributeDataType.integerType, PhysicalAttributeRole.caseId );
//Add the attribute to the PhysicalDataSet object
buildData.addAtribute(pAttr);
//Save the physical data set object
dmeConn.saveObject("JDM_BUILD_PDS", buildData, true);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABIADDC"></a><a id="DMPRG269"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Build Settings</h3>
<p>In the Oracle Data Mining Java API, the <code>BuildSettings</code> object is saved as a table in the database. The settings table is compatible with the <code>DBMS_DATA_MINING.CREATE_MODEL</code> procedure. The name of the settings table must be unique in the user's schema. <a href="#CEGEBHCE">Figure 7-3</a> illustrates the build settings class hierarchy.</p>
<div class="figure">
<p class="titleinfigure"><a id="CEGEBHCE"></a><a id="DMPRG270"></a>Figure 7-3 Build Settings Class Diagram.</p>
<img width="721" height="357" src="img/build_settings.gif" alt="Build settings class diagram" /><br />
<a id="sthref384" href="img_text/build_settings.htm">Description of "Figure 7-3 Build Settings Class Diagram."</a><br />
<br /></div>
<!-- class="figure" -->
<p>The code in <a href="#BGBIJIDI">Example 7-3</a> illustrates the creation and storing of a classification settings object with a tree algorithm.</p>
<div class="example">
<p class="titleinexample"><a id="BGBIJIDI"></a><a id="DMPRG271"></a>Example 7-3 Creation of a Classification Settings with Decision Tree Algorithm</p>
<pre>
//Create a classification settings factory
ClassificationSettingsFactory clasFactory = 
(ClassificationSettingsFactory)dmeConn.getFactory
     ("javax.datamining.supervised.classification.ClassificationSettings");
//Create a ClassificationSettings object
ClassificationSettings clas = clasFactory.create();
//Set target attribute name
clas.setTargetAttributeName("AFFINITY_CARD");
//Create a TreeSettingsFactory
TreeSettingsFactory treeFactory =
(TreeSettingsFactory)dmeConn.getFactory
     ("javax.datamining.algorithm.tree.TreeSettings");
//Create TreeSettings instance
TreeSettings treeAlgo = treeFactory.create();
treeAlgo.setBuildHomogeneityMetric(TreeHomogeneityMetric.entropy);
treeAlgo.setMaxDepth(10);
treeAlgo.setMinNodeSize( 10, SizeUnit.count );
//Set algorithm settings in the classification settings
clas.setAlgorithmSettings(treeAlgo);
//Save the build settings object in the database
dmeConn.saveObject("JDM_TREE_CLAS", clas, true);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="DMPRG272"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref385"></a>
<h3 class="sect2">Enable Automated Data Preparation</h3>
<p>In 11.1, all mining algorithms support automated data preparations (ADP). By default for decision tree and GLM algorithms, ADP is enabled. For other algorithms it is disabled by default for backward compatibility reasons. To enable ADP explicitly for the algorithms that do not enable by default, invoke the following function, by specifying the <code>useAutomatedDataPreparations</code> boolean flag as true.</p>
<pre>
OraBuildSettings.useAutomatedDataPreparations
          (boolean useAutomatedDataPreparations)
</pre>
<p>For more information about automatic data preparation, see <a class="olink DMCON014" href="../../datamine.112/e16808/xform_data.htm#DMCON014"><span class="italic">Oracle Data Mining Concepts</span></a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABCHGDA"></a><a id="DMPRG273"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Executing Mining Tasks</h3>
<p>OJDM uses the <code>DBMS_SCHEDULER</code> infrastructure for executing mining tasks either synchronously or asynchronously in the database. A mining task is saved as a <code>DBMS_SCHEDULER</code> job in the user schema and is set to <code>DISABLED</code> state. When user calls the execute method in DME Connection, the job state will be changed to <code>ENABLED</code> and scheduler starts executing the mining task by creating a new database session for asynchronous executions. For synchronous executions scheduler uses the same database session opened by the DME connection.</p>
<p>The class diagram in <a href="#CEGHEGIF">Figure 7-4</a> illustrates the different types of tasks that are available in OJDM and its class hierarchy. Subsequent sections will discuss more about the individual tasks shown in this diagram</p>
<div class="figure">
<p class="titleinfigure"><a id="CEGHEGIF"></a><a id="DMPRG274"></a>Figure 7-4 Task Class Diagram</p>
<img width="751" height="579" src="img/execute_tasks.gif" alt="Class diagram of different types of tasks." /><br />
<a id="sthref386" href="img_text/execute_tasks.htm">Description of "Figure 7-4 Task Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p><code>DBMS_SCHEDULER</code> provides additional scheduling and resource management features. You can extend the capabilities of Oracle Data Mining tasks by using the Scheduler infrastructure.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN035" href="../../server.112/e25494/schedadmin.htm#ADMIN035"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about the database scheduler.</div>
</div>
<!-- class="sect2" -->
<a id="DMPRG275"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref387"></a>
<h3 class="sect2">Creating Mining Task Workflows</h3>
<p>In Oracle Data Mining 11.1, the task infrastructure supports applications to specify dependent tasks through the API and deploy the execution of the tasks to the database server. The server executes complete workflow of tasks specified through the API and once deployed it does not depend on client. Client can monitor the execution process using OJDM API. For example, typically after the completion of data preparations, model is built and then tested and applied. Both test and apply can be done in parallel after model build is successful.</p>
<p>To build a task flow invoke the method <code>OraTask.addDependency</code>(String <code>parentTaskName</code>). For example, the code in <a href="#BGBBHGEC">Example 7-4</a> illustrates how to setup a mining task workflow, where first run the transformations task and then model build task. After successful completion of the build task run apply and test tasks in parallel.</p>
<div class="example">
<p class="titleinexample"><a id="BGBBHGEC"></a><a id="DMPRG276"></a>Example 7-4 Building Mining Task Workflows</p>
<pre>
//Task objects declarations
private TransformationTask xformTask;
private BuildTask buildTask;
private TestTask testTask;
private DataSetApplyTask applyTask;
//Creation of the tasks and task input objects are skipped for this example
&hellip;
//Save the first task in the workflow (the transformations task)
dmeConn.saveObject("transformationTask", xformTask, true);
//Specify dependencies before saving of the tasks
buildTask.addDependency("transformationTask");
dmeConn.saveObject("modelBuildTask", buildTask, true);
testTask.addDependency("modelBuildTask");
dmeConn.saveObject("modelTestTask", testTask, true);
applyTask.addDependency("modelBuildTask");
dmeConn.saveObject("modelApplyTask", applyTask, true);
//Execute the first task in the workflow to initiate the execution of the whole workflow
dmeConn.execute("transformationTask");
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABHDBBB"></a><a id="DMPRG277"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Building a Mining Model</h3>
<p>The <code>javax.datamining.task.BuildTask</code> class is used to build a mining model. Prior to building a model, a <code>PhysicalDataSet</code> object and a <code>BuildSettings</code> object must be saved.</p>
<p><a href="#BGBHIBEG">Example 7-5</a> illustrates the building of a tree model using the <code>PhysicalDataSet</code> described in <a href="#BGBEIJDH">"Describing the Mining Data"</a> and the <code>BuildSettings</code> described in <a href="#BABIADDC">"Build Settings"</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BGBHIBEG"></a><a id="DMPRG278"></a>Example 7-5 Building a Model</p>
<pre>
//Create BuildTaskFactory
BuildTaskFactory buildTaskFactory =
     dmeConn.getFactory("javax.datamining.task.BuildTask");
//Create BuildTask object
BuildTask buildTask = buildTaskFactory.create
     ( "JDM_BUILD_PDS","JDM_TREE_CLAS","JDM_TREE_MODEL"); 
//Save BuildTask object
dmeConn.saveObject("JDM_BUILD_TASK", buildTask, true);
//Execute build task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_BUILD_TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion(Integer.MAX_VALUE);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABDJJDE"></a><a id="DMPRG279"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Exploring Model Details</h3>
<p>After building a model using the <code>BuildTask</code>, a model object is persisted in the database. It can be retrieved to explore the model details.</p>
<p>The class diagram in <a href="#BABJFFED">Figure 7-5</a> illustrates the different types of model objects and model details objects supported by the Oracle Data Mining Java API.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABJFFED"></a><a id="DMPRG280"></a>Figure 7-5 Model and Model Detail Class Diagram</p>
<img width="834" height="646" src="img/model_details.gif" alt="Class diagram of Model objects and model details" /><br />
<a id="sthref388" href="img_text/model_details.htm">Description of "Figure 7-5 Model and Model Detail Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BGBCCGEF">Example 7-6</a> illustrates the retrieval of the classification tree model built in <a href="#BABHDBBB">"Building a Mining Model"</a> and its <code>TreeModelDetail</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BGBCCGEF"></a><a id="DMPRG281"></a>Example 7-6 Retrieve Model Details</p>
<pre>
//Retrieve classification model from the DME
ClassificationModel treeModel = (ClassificationModel)dmeConn.retrieveObject
     ( "JDM_TREE_MODEL", NamedObject.model);
//Retrieve tree model detail from the model
TreeModelDetail treeDetail = (TreeModelDetail)treeModel.getModelDetail();
//Get the root node
TreeNode rootNode = treeDetail.getRootNode();
//Get child nodes
TreeNode[] childNodes = rootNode.getChildren();
//Get details of the first child node
int nodeId = childNodes[0].getIdentifier();
long caseCount = childNodes[0].getCaseCount();
Object prediction = childNodes[0].getPrediction();
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJHJDC"></a><a id="DMPRG282"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Testing a Model</h3>
<p>Once a supervised model has been built, it can be evaluated using a test operation. The JDM standard defines two types of test operations: one that takes the mining model as input, and the other that takes the apply output table with the actual and predicted value columns.</p>
<p><code>javax.datamining.supervised.TestTask</code> is the base class for the model- based test tasks, and <code>javax.datamining.supervised.TestMetricsTask</code> is the base class for the apply output table-based test tasks.</p>
<p>The test operation creates and persists a test metrics object in the DME. For classification model testing, either of the following can be used.</p>
<pre>
javax.datamining.supervised.classification.ClassificationTestTask
javax.datamining.supervised.classification.ClassificationTestMetricsTask
</pre>
<p>Both of these tasks create the named object <code>javax.datamining.supervised.classification.ClassificationTestMetrics</code> and store it as a table in the user's schema.</p>
<p>The classification test metrics components, confusion matrix, lift results, and ROC associated with the <code>ClassificationTestMetrics</code> object are stored in separate tables whose names are the <code>ClassificationTestMetrics</code> object name followed by the suffix <code>_CFM</code>, <code>_LFT</code>, or <code>_ROC</code>. These tables can be used to display test results in dashboards, BI platforms such as Oracle BI, Business Objects, and so on.</p>
<p>Similarly for regression model testing, either of the following can be used:</p>
<pre>
javax.datamining.supervised.regression.RegressionTestTask
javax.datamining.supervised.regression.RegressionTestMtericsTask
</pre>
<p>Both these tasks create a named object <code>javax.datamining.supervised.regression.RegressionTestMetrics</code> and store it as a table in the user's schema.</p>
<p>The class diagram in <a href="#BABBFJED">Figure 7-6</a> illustrates the test metrics class hierarchy. It refers to <a href="#CEGHEGIF">Figure 7-4, "Task Class Diagram"</a> for the class hierarchy of test tasks.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABBFJED"></a><a id="DMPRG283"></a>Figure 7-6 Test Metrics Class Hierarchy</p>
<img width="635" height="139" src="img/test_metrics.gif" alt="Test metrics class hierarchy" /><br />
<a id="sthref389" href="img_text/test_metrics.htm">Description of "Figure 7-6 Test Metrics Class Hierarchy"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#BGBHEDBG">Example 7-7</a> illustrates the test of a tree model <code>JDM_TREE_MODEL</code> using the <code>ClassificationTestTask</code> on the dataset <code>MINING_DATA_TEST_V</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BGBHEDBG"></a><a id="DMPRG284"></a>Example 7-7 Testing a Model</p>
<pre>
//Create &amp; save PhysicalDataSpecification      
PhysicalDataSet testData = m_pdsFactory.create(
        "MINING_DATA_TEST_V", false );
PhysicalAttribute pa = m_paFactory.create("cust_id", 
        AttributeDataType.integerType, PhysicalAttributeRole.caseId );
testData.addAttribute( pa );
m_dmeConn.saveObject( "JDM_TEST_PDS", testData, true );
//Create ClassificationTestTaskFactory
ClassificationTestTaskFactory testTaskFactory =  
  (ClassificationTestTaskFactory)dmeConn.getFactory(
     "javax.datamining.supervised.classification.ClassificationTestTask");
//Create, store &amp; execute Test Task
ClassificationTestTask testTask = testTaskFactory.create( 
        "JDM_TEST_PDS", "JDM_TREE_MODEL", "JDM_TREE_TESTMETRICS" );
testTask.setNumberOfLiftQuantiles(10);
testTask.setPositiveTargetValue(new Integer(1));
//Save TestTask object
dmeConn.saveObject("JDM_TEST_TASK", testTask, true);
//Execute test task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_TEST_TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion(Integer.MAX_VALUE);
//Explore the test metrics after successful completion of the task
if(ExecutionState.success.equals(execStatus.getState())) {
  //Retrieve the test metrics object
  ClassificationTestMetrics testMetrics =  
          (ClassificationTestMetrics)dmeConn.getObject("JDM_TREE_TESTMETRICS");
  //Retrieve confusion matrix and accuracy
  Double accuracy = testMetrics.getAccuracy();
  ConfusionMatrix cfm = testMetrics.getConfusionMatrix();
  //Retrieve lift 
  Lift lift = testMetrics.getLift();
  //Retrieve ROC
  ReceiverOperatingCharacterics roc = testMetrics.getROC();
}  
</pre></div>
<!-- class="example" -->
<p>In <a href="#BGBHEDBG">Example 7-7</a>, a test metrics object is stored as a table called <code>JDM_TREE_TESTMETRICS</code>. The confusion matrix is stored in the <code>JDM_TREE_TESTMETRICS_CFM</code> table, lift is stored in the <code>JDB_TREE_TESTMETRICS_LFT</code> table, and <code>ROC</code> is stored in the <code>JDM_TREE_TESTMETRICS_ROC</code> table. You can use BI tools like Oracle Discoverer to query these tables and create reports.</p>
</div>
<!-- class="sect2" -->
<a id="BABFBGAH"></a><a id="DMPRG285"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Applying a Model for Scoring Data</h3>
<p>All supervised models can be applied to data to find the prediction. Some of the unsupervised models, such as clustering and feature extraction, support the apply operation to find the cluster id or feature id for new records.</p>
<p>The JDM standard API provides an <code>ApplySettings</code> object to specify the type of output for the scored results. <code>javax.datamining.task.apply.ApplySettings</code> is the base class for all apply settings. In the Oracle Data Mining Java API, the <code>ApplySettings</code> object is transient; it is stored in the <code>Connection</code> context, not in the database.</p>
<p>The class diagram in <a href="#BABEBJAC">Figure 7-7</a> illustrates the class hierarchy of the apply settings available in the Oracle Data Mining Java API.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABEBJAC"></a><a id="DMPRG286"></a>Figure 7-7 Apply Settings</p>
<img width="696" height="229" src="img/apply_settings.gif" alt="Apply settings class diagram" /><br />
<a id="sthref390" href="img_text/apply_settings.htm">Description of "Figure 7-7 Apply Settings"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In the Oracle Data Mining Java API, default apply settings produce the apply output table in fixed format. The list in <a href="#BABEGCIF">Table 7-1</a> illustrates the default output formats for different functions.</p>
<div class="tblformal">
<p class="titleintable"><a id="DMPRG287"></a><a id="sthref391"></a><a id="BABEGCIF"></a>Table 7-1 Default Output Formats for Different Functions</p>
<table class="cellalignment1303" title="Default Output Formats for Different Functions" summary="Default output formats for different functions." dir="ltr">
<thead>
<tr class="cellalignment1297">
<th class="cellalignment1304" id="r1c1-t13">Mining Function</th>
<th class="cellalignment1304" id="r1c2-t13"><br /></th>
<th class="cellalignment1304" id="r1c3-t13"><br /></th>
<th class="cellalignment1304" id="r1c4-t13"><br /></th>
<th class="cellalignment1304" id="r1c5-t13"><br /></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r2c1-t13" headers="r1c1-t13">
<p>Classification without Cost</p>
</td>
<td class="cellalignment1305" headers="r2c1-t13 r1c2-t13">
<p>Case ID</p>
</td>
<td class="cellalignment1305" headers="r2c1-t13 r1c3-t13">
<p>Prediction</p>
</td>
<td class="cellalignment1305" headers="r2c1-t13 r1c4-t13">
<p>Probability</p>
</td>
<td class="cellalignment1305" headers="r2c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r3c1-t13" headers="r1c1-t13">
<p>Classification with Cost</p>
</td>
<td class="cellalignment1305" headers="r3c1-t13 r1c2-t13">
<p>Case ID</p>
</td>
<td class="cellalignment1305" headers="r3c1-t13 r1c3-t13">
<p>Prediction</p>
</td>
<td class="cellalignment1305" headers="r3c1-t13 r1c4-t13">
<p>Probability</p>
</td>
<td class="cellalignment1305" headers="r3c1-t13 r1c5-t13">
<p>Cost</p>
</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r4c1-t13" headers="r1c1-t13">
<p>Regression</p>
</td>
<td class="cellalignment1305" headers="r4c1-t13 r1c2-t13">
<p>Case ID</p>
</td>
<td class="cellalignment1305" headers="r4c1-t13 r1c3-t13">
<p>Prediction</p>
</td>
<td class="cellalignment1305" headers="r4c1-t13 r1c4-t13">&nbsp;</td>
<td class="cellalignment1305" headers="r4c1-t13 r1c5-t13">&nbsp;</td>
</tr>
<tr class="cellalignment1297">
<td class="cellalignment1305" id="r5c1-t13" headers="r1c1-t13">
<p>Feature extraction</p>
</td>
<td class="cellalignment1305" headers="r5c1-t13 r1c2-t13">
<p>Case ID</p>
</td>
<td class="cellalignment1305" headers="r5c1-t13 r1c3-t13">
<p>Feature ID</p>
</td>
<td class="cellalignment1305" headers="r5c1-t13 r1c4-t13">
<p>Value</p>
</td>
<td class="cellalignment1305" headers="r5c1-t13 r1c5-t13">&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>All types of apply settings support source and destination attribute mappings. For example, if the original apply table has customer name and age columns that need to be carried forward to the apply output table, it can be done by specifying the source destination mappings in the apply settings.</p>
<p>In the Oracle Data Mining Java API, classification apply settings support map by rank, top prediction, map by category, and map all predictions. Regression apply settings support map prediction value. Clustering apply settings support map by rank, map by cluster id, map top cluster, and map all clusters. Feature extraction apply settings support map by rank, map by feature id, map top feature, and map all features.</p>
<p><a href="#BGBFEEGF">Example 7-8</a> illustrates the applying of a tree model <code>JDM_TREE_MODEL</code> using <code>ClassificationApplyTask</code> on the dataset <code>MINING_DATA_APPLY_V</code>.</p>
<div class="example">
<p class="titleinexample"><a id="BGBFEEGF"></a><a id="DMPRG288"></a>Example 7-8 Applying a Model</p>
<pre>
//Create &amp; save PhysicalDataSpecification      
PhysicalDataSet applyData = m_pdsFactory.create( "MINING_DATA_APPLY_V", false );
PhysicalAttribute pa = m_paFactory.create("cust_id", 
        AttributeDataType.integerType, PhysicalAttributeRole.caseId );
applyData.addAttribute( pa );
m_dmeConn.saveObject( "JDM_APPLY_PDS", applyData, true );
//Create ClassificationApplySettingsFactory
ClassificationApplySettingsFactory applySettingsFactory =  
  (ClassificationApplySettingsFactory)dmeConn.getFactory(
     "javax.datamining.supervised.classification. ClassificationApplySettings");
//Create &amp; save ClassificationApplySettings
ClassificationApplySettings clasAS = applySettingsFactory.create();
m_dmeConn.saveObject( "JDM_APPLY_SETTINGS", clasAS, true);
//Create DataSetApplyTaskFactory
DataSetApplyTaskFactory applyTaskFactory =  
  (DataSetApplyTaskFactory)dmeConn.getFactory(
     "javax.datamining.task.apply.DataSetApplyTask");
//Create, store &amp; execute apply Task
DataSetApplyTask applyTask = m_dsApplyFactory.create(
        " JDM_APPLY_PDS ", "JDM_TREE_MODEL", " JDM_APPLY_SETTINGS ", 
        "JDM_APPLY_OUTPUT_TABLE");
//Save ApplyTask object
dmeConn.saveObject("JDM_APPLY_TASK", applyTask, true);
//Execute test task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_APPLY_TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion(Integer.MAX_VALUE);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABHGBDG"></a><a id="DMPRG289"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using a Cost Matrix</h3>
<p>The class <code>javax.datamining.supervised.classification.CostMatrix</code> is used to represent the costs of the false positive and false negative predictions. It is used for classification problems to specify the costs associated with the false predictions.</p>
<p>In the Oracle Data Mining Java API, cost matrix is supported in apply and test operations for all classification models. For the decision tree algorithm, a cost matrix can be specified at build time. For more information about cost matrix, see <a class="olink DMCON005" href="../../datamine.112/e16808/regress.htm#DMCON005"><span class="italic">Oracle Data Mining Concepts</span></a>.</p>
<p><a href="#BGBFDGDG">Example 7-9</a> illustrates how to create a cost matrix object where the target has two classes: <code>YES</code> (1) and <code>NO</code> (0). Suppose a positive (<code>YES</code>) response to the promotion generates $2 and the cost of the promotion is $1. Then the cost of misclassifying a positive responder is $2. The cost of misclassifying a non-responder is $1.</p>
<div class="example">
<p class="titleinexample"><a id="BGBFDGDG"></a><a id="DMPRG290"></a>Example 7-9 Creating a Cost Matrix</p>
<pre>
//Create category set factory &amp; cost matrix factory
CategorySetFactory catSetFactory = (CategorySetFactory)m_dmeConn.getFactory(
      "javax.datamining.data.CategorySet" );
CostMatrixFactory costMatrixFactory = (CostMatrixFactory)m_dmeConn.getFactory(
      "javax.datamining.supervised.classification.CostMatrix");
//Create categorySet
CategorySet catSet = m_catSetFactory.create(AttributeDataType.integerType);
//Add category values
catSet.addCategory(new Integer(0), CategoryProperty.valid);
catSet.addCategory(new Integer(1), CategoryProperty.valid);
//create cost matrix
CostMatrix costMatrix = m_costMatrixFactory.create(catSet);
costMatrix.setCellValue(new Integer(0), new Integer(0), 0);
costMatrix.setCellValue (new Integer(1), new Integer(1), 0);
costMatrix.setCellValue (new Integer(0), new Integer(1), 2);
costMatrix.setCellValue (new Integer(1), new Integer(0), 1);
//Save cost matrix in the DME
dmeConn.saveObject("JDM_COST_MATRIX", costMatrix);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABIJFGF"></a><a id="DMPRG291"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using Prior Probabilities</h3>
<p>Prior probabilities are used for classification problems if the actual data has a different distribution for target values than the data provided for the model build. A user can specify the prior probabilities in the classification function settings, using <code>setPriorProbabilitiesMap</code>. For more information about prior probabilities, see <a class="olink DMCON005" href="../../datamine.112/e16808/regress.htm#DMCON005"><span class="italic">Oracle Data Mining Concepts</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Priors are not supported with decision trees.</div>
<p><a href="#BGBCFIDG">Example 7-10</a> illustrates how to create a <code>PriorProbabilities</code> object, when the target has two classes: <code>YES</code> (1) and <code>NO</code> (0), and probability of <code>YES</code> is 0.05, probability of <code>NO</code> is 0.95.</p>
<div class="example">
<p class="titleinexample"><a id="BGBCFIDG"></a><a id="DMPRG292"></a>Example 7-10 Creating Prior Probabilities</p>
<pre>
//Set target prior probabilities
Map priorMap = new HashMap();
priorMap.put(new Double(0), new Double(0.7));
priorMap.put(new Double(1), new Double(0.3));
buildSettings.setPriorProbabilitiesMap("affinity_card", priorMap);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BGBJBBJI"></a><a id="DMPRG293"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Embedded Transformations</h3>
<p>In 11.1, OJDM supports embedding transformations with the model metadata. When the transformations are embedded with the model, they are implicitly applied to apply and test datasets. For example, user can embed a transformation that recodes the response attributes value representation from 1/0 to Yes/No; model uses this transformation when applying the model to the new data.</p>
<p>Users can specify these transformations as SQL expressions or can use the OJDM transformations discussed in Section 2.13 and build a transformation sequence.</p>
<p>In this section, the first example discusses the simple expression transformation using the oracle.dmt.jdm.transform.OraExpressionTransform class specified as input for model build.</p>
<p>The second example illustrates how to build a sequence of complex transformations and persist them as a transformation sequence and embed them into the model.</p>
<a id="DMPRG294"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref392"></a>
<h4 class="sect3">Embed Single-Expression Transformations</h4>
<p>Using <code>OraTransformationFactory</code> user can create transformation objects such as <code>OraTransformationSequence</code>, <code>OraExpressionTransform</code>, <code>OraBinningTransform</code>, <code>OraNormalizationTransform</code> and <code>OraClippingTransform</code>.</p>
<p>In <a href="#BGBIEBID">Example 7-11</a>, we create an expression transform that defines a simple log transformation for age attribute, recode transformation for affinity_card attribute and explicit exclusion of original age attribute from the model build. The code illustrates using OJDM API how one can embed these simple SQL expression transformations with the model.</p>
<div class="example">
<p class="titleinexample"><a id="BGBIEBID"></a><a id="DMPRG295"></a>Example 7-11 Simple Expression Transformation</p>
<pre>
//Create OraTransformationFactory
OraTransformationFactory m_xformFactory = (OraTransformationFactory)m_dmeConn.getFactory(
      "oracle.dmt.jdm.transform.OraTransformation" );
//Create OraExpressionTransform from the transformation factory
OraExpressionTransform exprXform = m_xformFactory.createExpressionTransform();
  //1) Specify log transformation of age attribute and create a new attribute call log_age
  //   that can be used for mining
  exprXform.addAttributeExpression("log_age", //Expression output attribute name
                                  "log(10, age) as log_age", //Expression
                                  "power(10, log_age)" //Reverse expression
                                  );
  //2) Recode 1/0 values of the affinity card attribute with the yes/no values and replace 
  //   existing attribute with the new recoded attribute
  exprXform.addAttributeExpression("affinity_card", //Expression output attribute name
                                  "CASE WHEN AFFINITY_CARD = 1 THEN 'YES' ELSE 'NO' END ", 
                                  null //No explicit reverse expression
                                  );
  //3) Exclude age attribute from mining
  exprXform.addAttributeExpression("age", //Expression output attribute name
                                  null, //Specify expression as null 
                                //to exclude attribute from mining 
                                  null 
                                  );
//Create transformation sequence object using expression transformation
OraTransformationSequence xformSeq = m_xformFactory.createTransformationSequence(
        "MINING_DATA_BUILD_V", //Input table
        exprXform, //Expressions to be defined
        null //Output transformed view is specified as null as we are trying to 
             //embed the transformations to the model
      );
//Save transformation sequence object
m_dmeConn.saveObject("simpleExprXForm_jdm", xformSeq, true);
//Create build Task  with transformation sequence
BuildTask buildTask = m_buildFactory.create(
                     "inputPDS", //Build data specification
                     "inputBuildSettings", //Mining function settings name
                     "outputModel" //Mining model name
                     );                          
//Specify transformation sequence as one of the input to enable embedding
//of the transformations defined in the sequence with the model
//In this example only expression transformations are specified
((OraBuildTask)buildTask).setTransformationSequenceName("simpleExprXForm_jdm");
//Save and execute the build task
... 
//After successful model build specified transformations are embedded with the model
//User can retrieve the transformation details that are embedded with the model by calling 
//the following function in OraModel
OraExpressionTransform modelExmbeededTransforms = 
                     ((OraModel)model). GetModelTransformations();
</pre></div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="DMPRG296"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref393"></a>
<h4 class="sect3">Embed Complex Sequence of Transformations</h4>
<p>In the previous example, we explored how to embed simple SQL expression transformations for trivial business transformations. In this section we will detail how a complex transformation sequence can be built using OJDM and embed these with the model.</p>
<p>OJDM 10.2 provides typical mining related individual transformations such as binning, normalization and outlier treatment (clipping). In 10.2 users have to maintain these transformations outside the modeling process and do the consistent transformations for the build, apply and test datasets outside the mining operations. This requires significant additional coding and maintenance of the transformation related objects by the end-user applications.</p>
<p>With the model embedded transformations capability, users can embed even complex transformation sequences such as first add business transformations and new attributes using the expression transforms (as discussed in the previous example), second treat outliers with the user specified clipping definitions and lastly normalize the data with the user specified normalization technique.</p>
<p>In OJDM new <code>OraTransformationSequence</code> object supports ability to specify sequence of transformations and convert these transformations into per attribute SQL expressions to embed them to the model. <a href="#BGBIACJC">Example 7-12</a> illustrates using OJDM API how one can build a transformation sequence which uses the expression transform created in the previous example and extends it with the outlier and normalization data mining transformations and embed these complex transformation sequence with the model.</p>
<div class="example">
<p class="titleinexample"><a id="BGBIACJC"></a><a id="DMPRG297"></a>Example 7-12 Complex Sequence Transformations</p>
<pre>
//Create a list of transformations to be performed on the input mining data
List xformList = new ArrayList();
xfromList.add( exprXform );     //Expression transformation
xformList.add( clippingXform ); //Clipping transformation to treat outliers
xformList.add( normalizeXform );//Normalization transformation
//Create transformation sequence object using list of transformation
OraTransformationSequence xformSeq = m_xformFactory.createTransformationSequence(
        "MINING_DATA_BUILD_V", //Input table
        xformList, //List of transformations
        null //Output transformed view is specified as null as we are trying to 
             //embed the transformations to the model
      );
//Save transformation sequence object
m_dmeConn.saveObject("complexXFormSeq_jdm", xformSeq, true);
//Create transformation task with the transformation sequence
OraTransformationTaskFactory m_xformTaskFactory = 
       (OraTransformationTaskFactory)m_dmeConn.getFactory(
                   "oracle.dmt.jdm.task.OraTransformationTask");         
OraTransformationTask xformTask =  m_xformTaskFactory .create(
                 "complexXFormSeq_jdm",,   
                 false //boolean flag useTransformDefinitionTables
                 );
//Save and execute transformation task to populate transformation sequence with the
//SQL expressions necessary before embedding them to the build task
. . . .
//Create build Task with transformation sequence
. . . .
((OraBuildTask)buildTask).setTransformationSequenceName("complexXFormSeq_jdm ");
//Save and execute the build task with the embedded transformations
... 
</pre></div>
<!-- class="example" -->
<p>Note that in both the examples we specified the output view of the transformation sequence as null to avoid creation of the database view that includes the transformations in the sequence. However, one can specify the view name to create a database view with the transformations and use this view as input to the model build to maintain the transformations outside the modeling process. OJDM API provides flexibility for the applications to choose the approach that best fits the need.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDCDHI"></a><a id="DMPRG298"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using Predictive Analytics Tasks: Predict, Explain, and Profile</h3>
<p>OJDM has <code>oracle.dmt.jdm.task.OraPredictTask</code>, <code>OraExplainTask</code> and <code>OraProfileTask</code> for data mining novice users to get predictions, to explain attributes importance and to discover profiles from the data.</p>
<p>Using <code>OraPredictTask</code> predictions are computed by just specifying the data location and the target column. This task learns from the known values in the target column and other columns in the input table and fills the unknown values in the target column with the predictions. This task hides all the data mining process done inside the database and produces the predictions and accuracy of the predictions.</p>
<p>Using <code>OraExplainTask</code> attributes ranking/importance with respect to an explain column. By just specifying the data location and explain column this task produces the attribute ranking table.</p>
<p>Using <code>OraProfileTask</code> profiles are discovered from the data for a given target attribute. For example, to find the profiles of the customers who respond to a product promotion, give the customers dataset with the customer attributes and promotion response attribute to the profile task. Profile task outputs a table with the profile definitions that applications can display to the users.</p>
<p>Both the tasks do automated data preparation where needed.</p>
<p><a href="#BGBJCIDJ">Example 7-13</a> illustrates how to execute predict, explain, and profile tasks.</p>
<div class="example">
<p class="titleinexample"><a id="BGBJCIDJ"></a><a id="DMPRG299"></a>Example 7-13 Predictive Analytics</p>
<pre>
//Get Predictive Analytics Task Factory object
   OraPredictiveAnalyticsTaskFactory  m_paFactory =
     (OraPredictiveAnalyticsTaskFactory)m_dmeConn.getFactory(
          "oracle.dmt.jdm.task.OraPredictiveAnalyticsTask");
//Predict task
   //Create predict task object
   OraPredictTask predictTask = m_paFactory.createPredictTask (
                     "MINING_DATA_BUILD_V", //Input table
                     "cust_id", //Case id column
                     "affinity_card", //target column
                     "JDM_PREDICTION_RESULTS"); //prediction output table
   //Save predict task object
   dmeConn.saveObject("JDM_PREDICT_TASK", predictTask, true);
   //Execute test task asynchronously in the database
   ExecutionHandle execHandle1 = dmeConn.execute("JDM_PREDICT_TASK");
   //Wait for completion of the task
   ExecutionStatus execStatus1 = execHandle1.waitForCompletion(Integer.MAX_VALUE);                         
//Explain task
   //Create explain task object
   OraExplainTask explainTask = m_paFactory.createExplainTask (
                     "MINING_DATA_BUILD_V", //Input table
                     "affinity_card", //explain column
                     "JDM_EXPLAIN_RESULTS"); //explain output table
   //Save predict task object
   dmeConn.saveObject("JDM_EXPLAIN_TASK", explainTask, true);
   //Execute test task asynchronously in the database
   ExecutionHandle execHandle2 = dmeConn.execute("JDM_ EXPLAIN_TASK");
   //Wait for completion of the task
   ExecutionStatus execStatus2 = execHandle2.waitForCompletion(Integer.MAX_VALUE);                         
//Profile task
   //Create profile task 
    OraProfileTask profileTask = m_paFactory.createProfileTask(
                         "MINING_DATA_BUILD_V", //Input table
                         "affinity_card", //Target column
                                 "JDM_PROFILE_RESULTS); //Profile output table
   //Save predict task object
   dmeConn.saveObject("JDM_PROFILE_TASK", profileTask, true);
   //Execute test task asynchronously in the database
   ExecutionHandle execHandle3 = dmeConn.execute("JDM_PROFILE_TASK");
   //Wait for completion of the task
   ExecutionStatus execStatus3 = execHandle3.waitForCompletion(Integer.MAX_VALUE);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="BABJJIJH"></a><a id="DMPRG300"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Preparing the Data</h3>
<p>In the Oracle Data Mining Java API, data must be prepared before building, applying, or testing a model. The <code>oracle.dmt.jdm.task.OraTransformationTask</code> class supports common transformations used in data mining: binning, normalization, clipping, and text transformations. For more information about transformations, see <a class="olink DMCON013" href="../../datamine.112/e16808/glossary.htm#DMCON013"><span class="italic">Oracle Data Mining Concepts</span></a>.</p>
<p>The class diagram in <a href="#CEGHBJHA">Figure 7-8</a> illustrates the <code>OraTransformationTask</code> and its relationship with other objects.</p>
<div class="figure">
<p class="titleinfigure"><a id="CEGHBJHA"></a><a id="DMPRG301"></a>Figure 7-8 OraTransformationTask Class Diagram</p>
<img width="274" height="155" src="img/oratransformationtask.gif" alt="Class diagram of transformation objects" /><br />
<a id="sthref394" href="img_text/oratransformationtask.htm">Description of "Figure 7-8 OraTransformationTask Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="DMPRG302"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref395"></a>
<h4 class="sect3">Using Binning/Discretization Transformation</h4>
<p>Binning is the process of grouping related values together, thus reducing the number of distinct values for an attribute. Having fewer distinct values typically leads to a more compact model and one that builds faster, but it can also lead to some loss in accuracy.</p>
<p>The class diagram in <a href="#BABFHCHF">Figure 7-9</a> illustrates the binning transformation classes.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABFHCHF"></a><a id="DMPRG303"></a>Figure 7-9 OraBinningTransformation Class Diagram</p>
<img width="754" height="456" src="img/binning.gif" alt="Binning transformation class diagram." /><br />
<a id="sthref396" href="img_text/binning.htm">Description of "Figure 7-9 OraBinningTransformation Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Here, <code>OraBinningTransformation</code> contains all the settings required for binning. The Oracle Data Mining Java API supports top-n, custom binning for categorical attributes, and equi-width, quantile and custom binning for numerical attributes. After running the binning transformations, it creates a transformed table and bin boundary tables in the user's schema. The user can specify the bin boundary table names, or the system will generate the names for the bin boundary tables. This facilitates the reusing of the bin boundary tables that are created for binning build data for apply and test data.</p>
<p>The following code illustrates the binning operation on the view <code>MINING_BUILD_DATA_V</code></p>
<pre>
//Create binning transformation instance
OraBinningTransformFactory binXformFactory = 
   (OraBinningTransformFactory)dmeConn.getFactory(
      "oracle.dmt.jdm.transform.binning.OraBinningTransform");
OraBinningTransform binTransform = m_binXformFactory.create(
      "MINING_DATA_BUILD_V", // name of the input data set
      "BINNED_DATA_BUILD_V", // name of the transformation result 
      true); // result of the transformation is a view  
// Specify the number of numeric bins
binTransform.setNumberOfBinsForNumerical(10);
// Specify the number of categoric bins
binTransform.setNumberOfBinsForCategorical(8);
// Specify the list of excluded attributes
String[] excludedList = new String[]{"CUST_ID", "CUST_GENDER"};
binTransform.setExcludeColumnList(excludedList);
// Specify the type of numeric binning: equal-width or quantile
       ( default is quantile )
binTransform.setNumericalBinningType(binningType);
// Specify the type of categorical binning as Top-N: by default it is none   
binTransform.setCategoricalBinningType(OraCategoricalBinningType.top_n);
//Create transformation task
OraTransformationTask xformTask = m_xformTaskFactory.create(binTransform);
//Save transformation task object
dmeConn.saveObject("JDM_BINNING_TASK", xformTask, true);
//Execute transformation task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_ BINNING _TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion(Integer.MAX_VALUE); 
</pre></div>
<!-- class="sect3" -->
<a id="DMPRG304"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref397"></a>
<h4 class="sect3">Using Normalization Transformation</h4>
<p>Normalizing converts individual attribute values in such a way that all attribute values lie in the same range. Normally, values are converted to be in the range 0.0 to 1.0 or the range -1 to +1. Normalization ensures that attributes do not receive artificial weighting caused by differences in the ranges that they span.</p>
<p>The class diagram in <a href="#BABCBFJD">Figure 7-10</a> illustrates the normalization transformation classes.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABCBFJD"></a><a id="DMPRG305"></a>Figure 7-10 OraNormalizeTransformation Class Diagram</p>
<img width="613" height="139" src="img/normalization.gif" alt="Normalization transformation related classes." /><br />
<a id="sthref398" href="img_text/normalization.htm">Description of "Figure 7-10 OraNormalizeTransformation Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Here, <code>OraNormalizeTransformation</code> contains all the settings required for normalization. The Oracle Data Mining Java API supports z-Score, min-max, and linear scale normalizations. Normalization is required for SVM, NMF, and <span class="italic">k</span>-Means algorithms.</p>
<p>The following code illustrates normalization on the view <code>MINING_BUILD_DATA_V</code>.</p>
<pre>
//Create OraNormalizationFactory
OraNormalizeTransformFactory normalizeXformFactory = 
  (OraNormalizeTransformFactory)m_dmeConn.getFactory(
      "oracle.dmt.jdm.transform.normalize.OraNormalizeTransform");
//Create OraNormalization
OraNormalizeTransform normalizeTransform = m_normalizeXformFactory.create(
      "MINING_DATA_BUILD_V", // name of the input data set
      "NORMALIZED_DATA_BUILD_V", // name of the transformation result 
      true, // result of the transformation is a view
      OraNormalizeType.z_Score, //Normalize type
      new Integer(6) ); //Rounding number    
// Specify the list of excluded attributes
String[] excludedList = new String[]{"CUST_ID", "CUST_GENDER"};
normalizeTransform.setExcludeColumnList(excludedList);
//Create transformation task
OraTransformationTask xformTask = m_xformTaskFactory.create(normalizeTransform);
//Save transformation task object
dmeConn.saveObject("JDM_NORMALIZE_TASK", xformTask, true);
//Execute transformation task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_NORMALIZE_TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion(Integer.MAX_VALUE);
</pre></div>
<!-- class="sect3" -->
<a id="DMPRG306"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref399"></a>
<h4 class="sect3">Using Clipping Transformation</h4>
<p>Some computations on attribute values can be significantly affected by extreme values. One approach to achieving a more robust computation is to either winsorize or trim the data using clipping transformations.</p>
<p>Winsorizing involves setting the tail values of a particular attribute to some specified value. For example, for a 90% winsorization, the bottom 5% are set equal to the minimum value in the 6th percentile, while the upper 5% are set equal to the value corresponding to the maximum value in the 95th percentile.</p>
<p>Trimming "removes" the tails in the sense that trimmed values are ignored in further values. This is achieved by setting the tails to NULL.</p>
<p>The class diagram in <a href="#BABDFIDB">Figure 7-11</a> illustrates the clipping transformation classes.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABDFIDB"></a><a id="DMPRG307"></a>Figure 7-11 OraClippingTransformation Class Diagram</p>
<img width="543" height="139" src="img/clipping.gif" alt="Clipping transformation class diagram" /><br />
<a id="sthref400" href="img_text/clipping.htm">Description of "Figure 7-11 OraClippingTransformation Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Here, <code>OraClippingTransformation</code> contains all the settings required for clipping. The Oracle Data Mining Java API supports winsorize and trim types of clipping.</p>
<p>The following code illustrates clipping on the view <code>MINING_BUILD_DATA_V</code>.</p>
<pre>
//Create OraClippingTransformFactory
OraClippingTransformFactory clipXformFactory = 
  (OraClippingTransformFactory)dmeConn.getFactory(
      "oracle.dmt.jdm.transform.clipping.OraClippingTransform");
//Create OraClippingTransform
OraClippingTransform clipTransform = clipXformFactory.create(
      "MINING_DATA_BUILD_V", // name of the input data set
      "WINSORISED_DATA_BUILD_V", // name of the transformation result 
      true );// result of the transformation is a view    
//Specify the list of excluded attributes
String[] excludedList = new String[]{"CUST_ID", "CUST_GENDER"};
clipTransform.setExcludeColumnList(excludedList);
//Specify the type of clipping
clipTransform.setClippingType(OraClippingType.winsorize);
// Specify the tail fraction as 3% of values on both ends
clipTransform.setTailFraction(0.03);
//Create and save transformation task
OraTransformationTask xformTask = xformTaskFactory.create(clipTransform);
//Save transformation task object
dmeConn.saveObject("JDM_CLIPPING_TASK", xformTask, true);
//Execute transformation task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_CLIPPING_TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion(Integer.MAX_VALUE);
</pre></div>
<!-- class="sect3" -->
<a id="BABJIIAC"></a><a id="DMPRG308"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Using Text Transformation</h4>
<p>Text columns need to be transformed to nested table structure to do the mining on text columns. This transformation converts the text columns to nested table columns. A features table is created by text transformation. A model build text data column features table must be used for apply and test tasks to get the correct results.</p>
<p>The class diagram in <a href="#BABDGEAH">Figure 7-12</a> illustrates the text transformation classes.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABDGEAH"></a><a id="DMPRG309"></a>Figure 7-12 Text Transformation Class Diagram</p>
<img width="248" height="139" src="img/text_transform.gif" alt="Text transformation class diagram" /><br />
<a id="sthref401" href="img_text/text_transform.htm">Description of "Figure 7-12 Text Transformation Class Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Here, <code>OraTextTransformation</code> is used to specify the text columns and the feature tables associated with the text columns.</p>
<p>The following code illustrates clipping on the table <code>MINING_BUILD_TEXT</code>.</p>
<pre>
//Create OraTextTransformFactory
OraTextTransformFactory textXformFactory = dmeConn.getFactory(
      "oracle.dmt.jdm.transform.text.OraTextTransform");
//Create OraTextTransform
OraTextTransform txtXform = (OraTextTransformImpl)textXformFactory.create(
      "MINING_BUILD_TEXT", // name of the input data set
      "NESTED_TABLE_BUILD_TEXT ", // name of the transformation result
      "CUST_ID", //Case id column
      new String[] { "COMMENTS" } ); //Text column names 
      );
//Create transformation task
OraTransformationTask xformTask = m_xformTaskFactory.create(txtXform);
//Save transformation task object
dmeConn.saveObject("JDM_TEXTXFORM_TASK", xformTask, true);
//Execute transformation task asynchronously in the database
ExecutionHandle execHandle = dmeConn.execute("JDM_TEXTXFORM_TASK");
//Wait for completion of the task
ExecutionStatus execStatus = execHandle.waitForCompletion
     (Integer.MAX_VALUE);
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1296">
<tr>
<td class="cellalignment1305">
<table class="cellalignment1301">
<tr>
<td class="cellalignment1300"><a href="models_deploying.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1300"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2005, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1307">
<table class="cellalignment1299">
<tr>
<td class="cellalignment1300"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1300"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1300"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1300"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1300"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1300"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
