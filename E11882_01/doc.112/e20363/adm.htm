<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Access Layer Customization</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 710" />
<meta name="dcterms.created" content="2013-01-30T11:7:35Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Retail Data Model Implementation and Operations Guide" />
<meta name="dcterms.identifier" content="E20363-03" />
<meta name="dcterms.isVersionOf" content="RBIOG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="pdm.htm" title="Previous" type="text/html" />
<link rel="Next" href="etlmap.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e20363.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">8/14</span> <!-- End Header --><a id="CHDDHGHC"></a><a id="RBIOG184"></a>
<h1 class="chapter"><span class="secnum">3</span> Access Layer Customization</h1>
<p><a id="sthref88"></a><a id="sthref89"></a><a id="sthref90"></a><a id="sthref91"></a>This chapter provides information about customizing the access layer of Oracle Retail Data Model. It includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDECHGE">Introduction to Customizing the Access Layer of Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDIIDHC">Derived Tables in the Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BABIJFEA">Dimensional Components in the Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BABCCDIJ">Materialized Views in the Oracle Retail Data Model</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="pdm.htm#CHDFIAJJ">Chapter 2, "Physical Model Customization"</a></div>
<a id="CHDECHGE"></a><a id="RBIOG185"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Introduction to Customizing the Access Layer of Oracle Retail Data Model</h2>
<p><a id="sthref92"></a>The access layer of Oracle Retail Data Model provides the calculated and summarized ("flattened") perspectives of the data needed by business intelligence tools. Access layer objects are populated using the data from the foundation layer 3NF objects.</p>
<p>The access layer objects in the <code>ordm_sys</code> schema include: derived tables, aggregate objects, OLAP cubes, and materialized views. This layer also contains data mining models. The results of the these models are stored in derived tables.</p>
<p>When designing and customizing access layer objects:</p>
<ul>
<li>
<p>Follow the general guidelines for customizing physical objects given in <a href="pdm.htm#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a>.</p>
</li>
<li>
<p>Design the access layer objects to support the business intelligence reports and queries that your site makes. See <a href="rep_quer.htm#BGBDEIJE">Chapter 5, "Report and Query Customization."</a></p>
</li>
</ul>
<p>The following topics provide specialized information about designing and customizing access layer objects:</p>
<ul>
<li>
<p><a href="#CHDIIDHC">Derived Tables in the Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BABIJFEA">Dimensional Components in the Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BABCCDIJ">Materialized Views in the Oracle Retail Data Model</a></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDIIDHC"></a><a id="RBIOG186"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Derived Tables in the Oracle Retail Data Model</h2>
<p><a id="sthref93"></a><a id="sthref94"></a>Derived tables contain data which is generated from foundation tables using transformation or aggregation operations (or sometimes, both). There are some derived tables such as <code>DWD_RTL_SL_RETRN_ITEM_DAY</code> which are populated after performing minimal aggregations as well as transformations on Foundation layer data. Derived tables have a <code>DWD_</code> prefix and typically contain data at a specific granularity of time (typically, at DAY level of the time dimension).</p>
<p>There are two main types of derived tables in the default Oracle Retail Data Model and the way you customize these tables varies by type:</p>
<ul>
<li>
<p>Tables that hold the results of a calculation such as the <code>DWD_EMP_LBR</code> table that contains employee labor details at the day level. For information on customizing these tables, see <a href="#CHDFHCJI">"Creating New Derived Tables for Calculated Data"</a>.</p>
</li>
<li>
<p>Result tables for the data mining models (for example, <code>DWD_CUST_MNNG</code>). For information on customizing data mining models, see <a href="#CHDFIJBJ">"Customizing Oracle Retail Data Model Data Mining Models"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
The Derived Tables topic in <a class="olink RBIRF489" href="../../doc.112/e20361/physical_rdm.htm#RBIRF489"><span class="italic">Oracle Retail Data Model Reference</span></a> for a list of all of the derived tables in the default Oracle Retail Data Model. For a list of only those derived tables that are results tables for the data mining models, see the chapter on Data Mining Models in <a class="olink RBIRF893" href="../../doc.112/e20361/data_mining_rdm.htm#RBIRF893"><span class="italic">Oracle Retail Data Model Reference</span></a>.</div>
<a id="CHDFHCJI"></a><a id="RBIOG187"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Creating New Derived Tables for Calculated Data</h3>
<p>If, during fit-gap analysis, you identified a need for calculated data that is not provided by the default derived tables, you can meet this need by defining new tables. When designing these tables, name the tables following the convention of using the <code>DWD_</code> prefix for derived tables.</p>
</div>
<!-- class="sect2" -->
<a id="CHDFIJBJ"></a><a id="RBIOG188"></a>
<div class="sect2">
<h3 class="sect2">Customizing Oracle Retail Data Model Data Mining Models</h3>
<p><a id="sthref95"></a>Some derived (<code>DWD_</code>) tables in the default <code>ordm_sys</code> schema are the results of data mining models defined in the default Oracle Retail Data Model. Those models are also defined in the default <code>ordm_sys</code> schema.</p>
<p>All Oracle Retail Data Model mining models use materialized views as source input. Those materialized views are defined in <code>ordm_mining_etl.sql</code> file in <code>$ORACLE_HOME/ordm/pdm/mining/src</code>. Each mining model uses a different materialized view as its source.</p>
<p>When creating a customized Oracle Retail Data Model warehouse, data mining models may be customized as follows:</p>
<ul>
<li>
<p>Create a model as discussed in <a href="#CHDFJFHG">"Creating a New Data Mining Model for Oracle Retail Data Model"</a>.</p>
</li>
<li>
<p>Modify an existing model as discussed in <a href="#CHDJBGGD">"Modifying Oracle Retail Data Model Data Mining Models"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#BABGIJBD">"Tutorial: Customizing the Customer Life Time Value Prediction Data Mining Model"</a>.</div>
<a id="CHDFJFHG"></a><a id="RBIOG189"></a>
<div class="sect3">
<h4 class="sect3">Creating a New Data Mining Model for Oracle Retail Data Model</h4>
<p><a id="sthref96"></a>To write a new data mining model:</p>
<ol>
<li>
<p>Ensure that the <code>ordm_sys</code> schema includes a definition for a materialized view that you can use as input to the model. Define a new materialized view, if necessary.</p>
</li>
<li>
<p>Create the model as you would any data mining model. Follow the instructions given in <a class="olink DMCON046" href="../../datamine.112/e16808/process.htm#DMCON046"><span class="italic">Oracle Data Mining Concepts</span></a>. Add the model to the <code>ordm_sys</code> schema.</p>
</li>
<li>
<p>Add any physical tables needed by the model into the <code>ordm_sys</code> schema. Follow the naming conventions outlined in <a href="pdm.htm#CHDFGAAG">"Conventions When Customizing the Physical Model"</a> and use a <code>DWD_</code> prefix for results tables.</p>
</li>
<li>
<p>In the <code>ordm_sys</code> schema, grant <code>SELECT</code> privileges to the results tables created in Step 3.</p>
</li>
<li>
<p>Modify the intra-ETL to support the use of the data mining model.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="CHDJBGGD"></a><a id="RBIOG190"></a>
<div class="sect3">
<h4 class="sect3">Modifying Oracle Retail Data Model Data Mining Models</h4>
<p>To customize Oracle Retail Data Model mining models, take the following steps:</p>
<ol>
<li>
<p>Change the definition for source materialized views used as input to the mining model.</p>
</li>
<li>
<p>Train the model again by calling Oracle Retail Data Model mining package.</p>
</li>
<li>
<p>Ensure that the model reflects the new definition (for example, that a new column has been added).</p>
</li>
</ol>
<div class="example">
<p class="titleinexample"><a id="RBIOG334"></a><a id="sthref97"></a>Example 3-1 Adding a New Column to a Mining Model in Oracle Retail Data Model</p>
<p>To add a new column to <code>create_cust_ltv_glmr</code>, take the following steps:</p>
<ol>
<li>
<p>Add the new column to the following materialized view that is used as input to <code>create_cust_ltv_glmr</code>.</p>
<pre>
DMV_CUST_ACCT_SRC
</pre></li>
<li>
<p>Train the model by issuing the following statement:</p>
<pre>
exec pkg_ordm_mining.create_cust_ltv_glmr;
</pre></li>
<li>
<p>Execute the following statement to query the result table and ensure the new column name is included in the query result:</p>
</li>
</ol>
</div>
<!-- class="example" -->
<pre>
SELECT DISTINCT <span class="codeinlineitalic">attribute_name</span> FROM TABLE(DBMS_DATA_MINING.GET_MODEL_DETAILS_GLM('CUST_LTV_GLMR'));
</pre>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="etlmap.htm#BEHEBIDC">"Refreshing Oracle Retail Data Model Data Mining Models"</a>, and <a href="etlmap.htm#BEHJAHDE">"Troubleshooting Data Mining Model Creation"</a>.</div>
</div>
<!-- class="sect3" -->
<a id="BABGIJBD"></a><a id="RBIOG1004"></a>
<div class="sect3">
<h4 class="sect3">Tutorial: Customizing the Customer Life Time Value Prediction Data Mining Model</h4>
<p>After you have populated Oracle Retail Data Model foundation layer and executed the intra-ETL to populate derived tables, you can leverage the prebuilt Oracle Retail Data Model data mining models for more advanced analysis and predictions.</p>
<p>This tutorial shows how to predict the Life Time Value of customers who are registered members at a retail store, for the next three years based on populated Oracle Retail Data Model warehouse. Using prebuilt Oracle Retail Data Model data mining models you can easily and very quickly see the prediction results of your customers, without having to go through all of the data preparation, training, testing, and applying process that you must perform in a traditional from-scratch mining project. See <a class="olink DMCON046" href="../../datamine.112/e16808/process.htm#DMCON046"><span class="italic">Oracle Data Mining Concepts</span></a> for more information about the Oracle Database mining training and scoring (applying) process.</p>
<p>After initially generating a data mining model, as time goes by, the customer information, behavior, and purchase history change. Consequently, you must refresh the previously trained data mining models based on the latest customer and usage data. You can follow the process in this tutorial to refresh the data mining models to acquire predictions based the on latest customer information.</p>
<p>This tutorial shows you how to investigate the Customer Life Time Value Prediction model through Oracle Retail Data Model mining APIs. To use different parameters in the training process, or customize the model in more advanced fashion, you can either modify mining settings tables, the tables with DM_ as prefix, or use the Oracle Data Miner GUI tool (an extension to Oracle SQL Developer).</p>
<p>This tutorial consists of the following:</p>
<ul>
<li>
<p><a href="#BABFHJBE">Tutorial Prerequisites</a></p>
</li>
<li>
<p><a href="#BABDGAII">Preparing Your Environment</a></p>
</li>
<li>
<p><a href="#BABCGJGG">Generating the Model</a></p>
</li>
<li>
<p><a href="#BABDJGDD">Checking the Result</a></p>
</li>
</ul>
<a id="BABFHJBE"></a><a id="RBIOG1005"></a>
<div class="sect4">
<h5 class="sect4">Tutorial Prerequisites</h5>
<p>Before starting this tutorial:</p>
<ol>
<li>
<p>Review the Oracle by Example (OBE) tutorial "Using Oracle Data Miner 11g Release 2." To access this tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</li>
<li>
<p>Install Oracle Retail Data Model.</p>
</li>
<li>
<p>Populate the base, reference, and lookup tables.</p>
</li>
<li>
<p>Execute the intra-ETL.</p>
</li>
</ol>
<p>Ensure that the following tables contain valid data:</p>
<p><code>DWB_RTL_TRX</code></p>
<p><code>DWR_CUST</code></p>
<p><code>DWR_BSNS_MO</code></p>
<p><code>DWR_CUST_ACCT</code></p>
<p><code>DWR_CUST_RSTRCT_INFO</code></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you have not populated Oracle Retail Data Model with data from operational systems using sample data will not result in meaningful mining model outcomes. To understand the data mining models, you can use the sample data provided with Oracle Retail Data Model by taking the following steps:
<ul>
<li>
<p>Ensure that during the install, you generated the calendar data covering range of 2005-2012. For example, the parameters of starting from 20050101 for 8 years satisfy this condition.</p>
</li>
<li>
<p>Download the sample data (ordm_mining_sample.zip) and import the data into your new <code>ordm_sys</code> schema.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="BABDGAII"></a><a id="RBIOG1006"></a>
<div class="sect4">
<h5 class="sect4">Preparing Your Environment</h5>
<p>This tutorial requires a valid, populated Oracle Retail Data Model warehouse.</p>
<p>To prepare the environment, do the following:</p>
<ol>
<li>
<p>In Oracle SQL Developer, connect to the <code>ordm_sys</code> schema, as shown in <a href="#BABDGFAC">Figure 3-1</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABDGFAC"></a><a id="RBIOG1047"></a>Figure 3-1 Oracle SQL Developer with ORDM_SYS Schema</p>
<img width="776" height="419" src="img/rbiog_cdm_sys.png" alt="Description of Figure 3-1 follows" /><br />
<a id="sthref98" href="img_text/rbiog_cdm_sys.htm">Description of "Figure 3-1 Oracle SQL Developer with ORDM_SYS Schema"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>After you connect to the <code>ordm_sys</code> schema, you can see all of the tables. You can narrow down the list by right clicking "Tables" and then applying filters, as shown in <a href="#BABEAGFH">Figure 3-2</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABEAGFH"></a><a id="RBIOG1048"></a>Figure 3-2 Applying Filters</p>
<img width="1218" height="847" src="img/rbiog_cdm_filter.png" alt="Description of Figure 3-2 follows" /><br />
<a id="sthref99" href="img_text/rbiog_cdm_filter.htm">Description of "Figure 3-2 Applying Filters"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>(Optional) As mentioned in "Tutorial Prerequisites", if you have not populated the tables with your own data, you can use the sample data. After you download the sample data, take the following steps to import the data:</p>
<ol>
<li>
<p>Grant dba to <code>ordm_sys</code> using the following statement:</p>
<pre>
grant dba to ordm_sys
</pre></li>
<li>
<p>Disable all foreign keys on those tables required by the tutorial. First, issue the following statement that generates SQL statements:</p>
<pre>
SELECT 'ALTER TABLE ' || table_name || ' DISABLE CONSTRAINT ' ||
CONSTRAINT_NAME || ' CASCADE;' FROM all_constraints
WHERE status='ENABLED' AND owner='ORDM_SYS'
AND constraint_type=
'R' and table_name IN
('DWB_RTL_TRX','DWR_CUST','DWR_BSNS_MO',
'DWR_CUST_ACCT','DWR_CUST_RSTRCT_INFO') ;
</pre>
<p>Then, to actually disable the foreign keys for the following tables, execute the SQL statements generated by the previous SELECT statement:</p>
<pre>
DWB_RTL_TRX
DWR_CUST
DWR_BSNS_MO
DWR_CUST_ACCT
DWR_CUST_RSTRCT_INFO
</pre></li>
<li>
<p>Ensure that the sample dump, <code>ordm_mining_sample.dmp</code>, is in default data dump directory, DATA_PUMP_DIR. Then, import the sample mining dump into <code>ordm_sys</code> schema by issuing the following statement (replace <span class="italic">password</span> with your password for <code>ordm_sys</code>):</p>
<pre>
impdp ordm_sys/<span class="italic">password</span> directory=DATA_DUMP_DIR dumpfile=ordm_mining_sample.dmp content=DATA_ONLY table_exist_action=truncate TABLES=ordm_sys.DWB_RTL_TRX, ordm_sys.DWR_CUST, ordm_sys.DWR_BSNS_MO, ordm_sys.DWR_CUST_ACCT , ordm_sys.DWR_CUST_RSTRCT_INFO
</pre></li>
</ol>
</li>
<li>
<p>Review the tables to ensure that they contain valid data (using either your customer data or the sample mining data), as shown in <a href="#BABEFGGH">Figure 3-3</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABEFGGH"></a><a id="RBIOG1009"></a>Figure 3-3 Review Tables to Ensure Valid Data</p>
<img width="1438" height="831" src="img/rbiog_cdm_valid.png" alt="Description of Figure 3-3 follows" /><br />
<a id="sthref100" href="img_text/rbiog_cdm_valid.htm">Description of "Figure 3-3 Review Tables to Ensure Valid Data"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>Check the mining result table DWD_CUST_MNNG is empty before executing the model procedure in Oracle Retail Data Model Mining APIs.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<a id="BABCGJGG"></a><a id="RBIOG1010"></a>
<div class="sect4">
<h5 class="sect4">Generating the Model</h5>
<p>This tutorial uses two procedures from Oracle Retail Data Model APIs:</p>
<ul>
<li>
<p><code>pkg_ordm_mining.refresh_mining_source</code>: refreshes all mining source materialized views.</p>
</li>
<li>
<p><code>pkg_ordm_mining.create_cust_ltv_glmr</code>: generates the Customer Life Time Value Prediction Model.</p>
</li>
</ul>
<p>Take the following steps to use these procedures:</p>
<ol>
<li>
<p>Refresh the Oracle Retail Data Model mining source materialized views by executing the following SQL statements:</p>
<pre>
SELECT count(*) FROM dmv_cust_acct_src;
EXEC pkg_ordm_mining.refresh_mining_source;
SELECT count(*)FROM dmv_cust_acct_src;
</pre>
<p>These statements do the following:</p>
<ul>
<li>
<p>Display the number of records in <code>DMV_CUST_ACCT_SRC</code> materialized view before materialized view refresh.</p>
</li>
<li>
<p>Refresh the mining source materialized views.</p>
</li>
<li>
<p>Display the number of records in <code>DMV_CUST_ACCT_SRC</code> materialized view after materialized view refresh.</p>
</li>
</ul>
</li>
<li>
<p>Generate the Customer Life Time Value Prediction Model by executing the following statements:</p>
<pre>
SELECT count(*) FROM dwd_cust_mnng;
EXEC pkg_ordm_mining. create_cust_ltv_glmr;
SELECT count(*) FROM dwd_cust_mnng;
</pre>
<p>These statements do the following:</p>
<ul>
<li>
<p>Show the records count in <code>dwd_cust_mnng</code> table before data mining model build.</p>
</li>
<li>
<p>Train the data mining model.</p>
</li>
<li>
<p>Show the records count in the <code>dwd_cust_mnng</code> table after data mining model build.</p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect4" -->
<a id="BABDJGDD"></a><a id="RBIOG1011"></a>
<div class="sect4">
<h5 class="sect4">Checking the Result</h5>
<p>After refreshing the mining source materialized views and building the data mining model, check the mining prediction results in the <code>dwd_cust_mnng</code> table as shown in the following steps:</p>
<ol>
<li>
<p>Issue the following query:</p>
<pre>
SELECT cust_key,ltv_val,ltv_band_cd FROM dwd_cust_mnng;
</pre>
<div class="figure">
<p class="titleinfigure"><a id="RBIOG1012"></a><a id="sthref101"></a>Figure 3-4 Checking the Result</p>
<img width="1438" height="865" src="img/rbiog_cdm_check.png" alt="Description of Figure 3-4 follows" /><br />
<a id="sthref102" href="img_text/rbiog_cdm_check.htm">Description of "Figure 3-4 Checking the Result"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>For each customer identified by cust_key, the ltv_val column gives the prediction of customer life time value, a continuous value. The ltv_band_cd column is populated by binning the prediction value, ltv_val.</p>
</li>
</ol>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIJFEA"></a><a id="RBIOG197"></a>
<div class="sect1">
<h2 class="sect1">Dimensional Components in the Oracle Retail Data Model</h2>
<p><a id="sthref103"></a><a id="sthref104"></a>There is often much discussion regarding the 'best' modeling approach to take for any given data warehouse with each style, classic 3NF and dimensional having their own strengths and weaknesses. It is likely that data warehouses must do more to embrace the benefits of each model type rather than rely on just one - this is the approach that was adopted in designing the Oracle Retail Data Model. The foundation layer of the Oracle Retail Data Model is a 3NF model. The default Oracle Retail Data Model also provides a dimensional model of the data. This dimensional model of the data is a perspective that summarizes and aggregates data, rather than preserving detailed transaction information.</p>
<p>Familiarize yourself with dimensional modeling by reading the following topics before you begin to customize the dimensional model of the default Oracle Retail Data Model:</p>
<ul>
<li>
<p><a href="#CHDDDGHD">Characteristics of a Dimensional Model</a></p>
</li>
<li>
<p><a href="#CHDGJHFH">Characteristics of Relational Star and Snowflake Tables</a></p>
</li>
<li>
<p><a href="#CHDBIIIE">Characteristics of the OLAP Dimensional Model</a></p>
</li>
<li>
<p><a href="#CHDBCJJA">Characteristics of the OLAP Cubes in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDGECFG">Defining New Oracle OLAP Cubes for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDHBBAJ">Changing an Oracle OLAP Cube in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDIJCGJ">Creating a Forecast Cube for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDHEGCC">Choosing a Cube Partitioning Strategy for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDFAHED">Choosing a Cube Data Maintenance Method for Oracle Retail Data Model</a></p>
</li>
</ul>
<a id="CHDDDGHD"></a><a id="RBIOG198"></a>
<div class="sect2">
<h3 class="sect2">Characteristics of a Dimensional Model</h3>
<p>The simplicity of a dimensional model is inherent because it defines objects that represent real-world business entities. Analysts know which business measures they are interested in examining, which dimensions and attributes make the data meaningful, and how the dimensions of their business are organized into levels and hierarchies.</p>
<p>In the simplest terms, a dimensional model identifies the following objects:</p>
<ul>
<li>
<p><span class="bold">Measures.</span> Measures store quantifiable business data (such as sales, expenses, and inventory). Measures are sometimes called "facts". Measures are organized by one or more dimensions and may be stored or calculated at query time:</p>
<ul>
<li>
<p><span class="bold">Stored Measures</span>. Stored measures are loaded and stored at the leaf level. Commonly, there is also a percentage of summary data that is stored. Summary data that is not stored is dynamically aggregated when queried.</p>
</li>
<li>
<p><span class="bold">Calculated Measures.</span> Calculated measures are measures whose values are calculated dynamically at query time. Only the calculation rules are stored in the database. Common calculations include measures such as ratios, differences, moving totals, and averages. Calculations do not require disk storage space, and they do not extend the processing time required for data maintenance.</p>
</li>
</ul>
</li>
<li>
<p><span class="bold">Dimensions.</span> A dimension is a structure that categorizes data to enable users to answer business questions. Commonly used dimensions are Customers, Products, and Time. A dimension's structure is organized hierarchically based on parent-child relationships. These relationships enable:</p>
<ul>
<li>
<p>Navigation between levels.</p>
<p>Hierarchies on dimensions enable drilling down to lower levels or navigation (rolling up) to higher levels. Drilling down on the Time dimension member 2011 typically navigates you to the quarters Q1 2011 through Q4 2011. In a calendar year hierarchy, drilling down on Q1 2011 would navigate you to the months, January 2011 through March 2011. These kinds of relationships make it easy for users to navigate large volumes of multidimensional data.</p>
</li>
<li>
<p>Aggregation from child values to parent values.</p>
<p>The parent represents the aggregation of its children. Data values at lower levels aggregate into data values at higher levels. Dimensions are structured hierarchically so that data at different levels of aggregation are manipulated efficiently for analysis and display.</p>
</li>
<li>
<p>Allocation from parent values to child values.</p>
<p>The reverse of aggregation is allocation and is heavily used by planning budgeting, and similar applications. Here, the role of the hierarchy is to identify the children and descendants of particular dimension members of "top-down" allocation of budgets (among other uses).</p>
</li>
<li>
<p>Grouping of members for calculations.</p>
<p>Share and index calculations take advantage of hierarchical relationships (for example, the percentage of total profit contributed by each product, or the percentage share of product revenue for a certain category, or costs as a percentage of the geographical region for a retail location).</p>
</li>
</ul>
</li>
</ul>
<p>A dimension object helps to organize and group dimensional information into hierarchies. This represents natural 1:n relationships between columns or column groups (the levels of a hierarchy) that cannot be represented with constraint conditions. Going up a level in the hierarchy is called rolling up the data and going down a level in the hierarchy is called drilling down the data.</p>
<p>There are two ways that you can implement a dimensional model:</p>
<ul>
<li>
<p><span class="bold">Relational tables in a star schema configuration.</span> This traditional method of implementing a dimensional model is discussed in <a href="#CHDGJHFH">"Characteristics of Relational Star and Snowflake Tables"</a>.</p>
</li>
<li>
<p><span class="bold">Oracle OLAP Cubes</span>. The physical model provided with Oracle Retail Data Model provides a dimensional perspective of the data using Oracle OLAP cubes. This dimensional model is discussed in <a href="#CHDBIIIE">"Characteristics of the OLAP Dimensional Model"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDGJHFH"></a><a id="RBIOG199"></a>
<div class="sect2">
<h3 class="sect2">Characteristics of Relational Star and Snowflake Tables</h3>
<p>In the case of relational tables, the dimensional model has historically been implemented as a star or snowflake schema. Dimension tables (which contain information about hierarchies, levels, and attributes) join to one or more fact tables. Fact tables are the large tables that store quantifiable business measurements (such as sales, expenses, and inventory) and typically have foreign keys to the dimension tables. Dimension tables, also known as lookup or reference tables. contain the relatively static or descriptive data in the data warehouse.</p>
<p>A star schema borders on a physical model, as drill paths, hierarchy and query profile are embedded in the data model itself rather than the data. This in part at least, is what makes navigation of the model so straightforward for end users. Star schemas usually have a large fact table surrounded by smaller dimension tables. Dimension tables do not change very much. Most of the information that the users need are in the fact tables. Therefore, star schemas have fewer table joins than do 3NF models.</p>
<p>A star schema is so called because the diagram resembles a star, with points radiating from a center. The center of the star consists of one or more fact tables and the points of the star are the dimension tables, as shown in <a href="#CHDFJADI">Figure 3-5</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDFJADI"></a><a id="RBIOG200"></a>Figure 3-5 Star Schema Diagram</p>
<img width="380" height="178" src="img/starschm.gif" alt="Description of Figure 3-5 follows" /><br />
<a id="sthref105" href="img_text/starschm.htm">Description of "Figure 3-5 Star Schema Diagram"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Snowflake schemas are slight variants of a simple star schema where the dimension tables are further normalized and broken down into multiple tables. The snowflake aspect only affects the dimensions and not the fact table and is therefore considered conceptually equivalent to star schemas. Snowflake dimensions are useful and indeed necessary when there are fact tables of differing granularity. A month-level derived or aggregate table (or materialized view) must be associated with a month level snowflake dimension table rather than the default (lower) Day level star dimension table.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDFGFEB">"Declaring Relational Dimension Tables"</a> and <a href="#CHDIFFEH">"Validating Relational Dimension Tables"</a>.</div>
<a id="CHDFGFEB"></a><a id="RBIOG201"></a>
<div class="sect3">
<h4 class="sect3">Declaring Relational Dimension Tables</h4>
<p>When a relational table acts as a dimension to a fact table, it is recommended that you declare that table as a dimension (even though it is not necessary). Defined dimensions can yield significant performance benefits, and support the use of more complex types of rewrite.</p>
<p>To define and declare the structure of the dimension use the <code>CREATE DIMENSION</code> command. Use the <code>LEVEL</code> clause to identify the names of the dimension levels.</p>
</div>
<!-- class="sect3" -->
<a id="CHDIFFEH"></a><a id="RBIOG202"></a>
<div class="sect3">
<h4 class="sect3">Validating Relational Dimension Tables</h4>
<p>To improve the data quality of the dimension data in the data warehouse, it is recommended that you validate the declarative information about the relationships between the dimension members after any modification to the dimension data.</p>
<p>To perform this validation, use the <code>VALIDATE_DIMENSION</code> procedure of the <code>DBMS_DIMENSION</code> package. When the <code>VALIDATE_DIMENSION</code> procedure encounters any errors, the procedure places the errors into the <code>DIMENSION_EXCEPTIONS</code> table. To find the exceptions identified by the <code>VALIDATE_DIMENSION</code> procedure, query the <code>DIMENSION_EXCEPTIONS</code> table.</p>
<p>You can schedule a call to the <code>VALIDATE_DIMENSION</code> procedure as a post-process step to the regular Incremental Dimension load script. This can be done before the call to refresh the derived or aggregate tables of the data model through materialized view refresh, intra-ETL package calls.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBIIIE"></a><a id="RBIOG203"></a>
<div class="sect2">
<h3 class="sect2">Characteristics of the OLAP Dimensional Model</h3>
<p>Oracle OLAP Cubes logically represent data similar to relational star tables, although the data is actually stored in multidimensional arrays. Like dimension tables, cube dimensions organize members into hierarchies, levels, and attributes. The cube stores the measure (fact) data. The dimensions form the edges of the cube.</p>
<p>Oracle OLAP is an OLAP server embedded in the Oracle Database. Oracle OLAP provides native multidimensional storage and speed-of-thought response times when analyzing data across multiple dimensions. The database provides rich support for analytics such as time series calculations, forecasting, advanced aggregation with additive and nonadditive operators, and allocation operations.</p>
<p>By integrating multidimensional objects and analytics into the database, Oracle Database provides the best of both worlds: the power of multidimensional analysis along with the reliability, availability, security, and scalability of the Oracle Database.</p>
<p>Oracle OLAP is fully integrated into Oracle Database. At a technical level, this means:</p>
<ul>
<li>
<p>The OLAP engine runs within the kernel of Oracle Database.</p>
</li>
<li>
<p>Dimensional objects are stored in Oracle Database in their native multidimensional format.</p>
</li>
<li>
<p>Cubes and other dimensional objects are first class data objects represented in the Oracle data dictionary.</p>
</li>
<li>
<p>Data security is administered in the standard way, by granting and revoking privileges to Oracle Database users and roles.</p>
</li>
<li>
<p>OLAP cubes, dimensions, and hierarchies are exposed to applications as relational views. Consequently, applications can query OLAP objects using SQL as described in <a href="#CHDGEBHI">"Oracle OLAP Cube Views"</a> and <a href="rep_quer.htm#BGBDEIJE">Chapter 5, "Report and Query Customization."</a></p>
</li>
<li>
<p>Oracle OLAP cubes can be enhanced so that they are materialized views as described in <a href="#CHDBBCEC">"Cube Materialized Views"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a class="olink OLAUG100" href="../../olap.112/e17123/overview.htm#OLAUG100"><span class="italic">Oracle OLAP User's Guide</span></a> and<a href="#CHDBCJJA">"Characteristics of the OLAP Cubes in Oracle Retail Data Model"</a>.</div>
<p class="subhead2"><a id="RBIOG204"></a>Benefits of Using Oracle OLAP</p>
<p>Using Oracle OLAP provides significant benefits; Oracle OLAP offers the power of simplicity with One database, standard administration and security, and standard interfaces and development tools.</p>
<p>The Oracle OLAP dimensional data model is highly structured. Structure implies rules that govern the relationships among the data and control how the data can be queried. Cubes are the physical implementation of the dimensional model, and thus are highly optimized for dimensional queries. The OLAP engine leverages this innate dimensionality in performing highly efficient cross-cube joins for inter-row calculations, outer joins for time series analysis, and indexing. Dimensions are pre-joined to the measures. The technology that underlies cubes is based on an indexed multidimensional array model, which provides direct cell access.</p>
<p>The OLAP engine manipulates dimensional objects in the same way that the SQL engine manipulates relational objects. However, because the OLAP engine is optimized to calculate analytic functions, and dimensional objects are optimized for analysis, analytic and row functions can be calculated much faster in OLAP than in SQL.</p>
<p>The dimensional model enables Oracle OLAP to support high-end business intelligence tools and applications such as OracleBI Discoverer Plus OLAP, OracleBI Spreadsheet Add-In, Oracle Business Intelligence Suite Enterprise Edition, BusinessObjects Enterprise, and Cognos ReportNet.</p>
<p class="subhead2"><a id="RBIOG205"></a>Oracle OLAP Dimensional Objects</p>
<p>Oracle OLAP dimensional objects include cubes, measures, dimensions, hierarchies, levels and attributes. The OLAP dimensional objects are described in detail in <a class="olink OLAUG9109" href="../../olap.112/e17123/overview.htm#OLAUG9109"><span class="italic">Oracle OLAP User's Guide</span></a>. <a href="#CHDFCCDJ">Figure 3-6</a> shows the general relationships among the objects.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDFCCDJ"></a><a id="RBIOG206"></a>Figure 3-6 Diagram of the OLAP Dimensional Model</p>
<img width="580" height="315" src="img/logicalm.gif" alt="Description of Figure 3-6 follows" /><br />
<a id="sthref106" href="img_text/logicalm.htm">Description of "Figure 3-6 Diagram of the OLAP Dimensional Model"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="CHDGEBHI"></a><a id="RBIOG207"></a>
<div class="sect3">
<h4 class="sect3">Oracle OLAP Cube Views</h4>
<p>When you define an OLAP cube, Oracle OLAP automatically generates a set of relational views on the cube and its dimensions and hierarchies</p>
<ul>
<li>
<p>Cube view. Each cube has a cube view that presents the data for all the measures and calculated measures in the cube. You can use a cube view like a fact table in a star or snowflake schema. However, the cube view contains all the summary data in addition to the detail level data. The default name of a cube view is <code><span class="codeinlineitalic">cube</span></code><code>_VIEW</code>.</p>
</li>
<li>
<p>Dimension and hierarchy views. Each dimension has one dimension view plus a hierarchy view for each hierarchy associated with the dimension. The default name for a dimension view is <code><span class="codeinlineitalic">dimension</span></code><code>_VIEW</code>. For a hierarchy view, the default name is <code><span class="codeinlineitalic">dimension_hierarchy</span></code><code>_VIEW</code>.</p>
</li>
</ul>
<p>These views are related in the same way as fact and dimension tables in a star schema. Cube views serve the same function as fact tables, and hierarchy views and dimension views serve the same function as dimension tables. Typical queries join a cube view with either a hierarchy view or a dimension view.</p>
<p>SQL applications query these views to display the information-rich contents of these objects to analysts and decision makers. You can also create custom views that follow the structure expected by your applications, using the system-generated views like base tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
The discussion on querying dimensional objects in <a class="olink OLAUG400" href="../../olap.112/e17123/query.htm#OLAUG400"><span class="italic">Oracle OLAP User's Guide</span></a> and <a href="rep_quer.htm#BGBDEIJE">Chapter 5, "Report and Query Customization."</a></div>
</div>
<!-- class="sect3" -->
<a id="CHDBBCEC"></a><a id="RBIOG208"></a>
<div class="sect3">
<h4 class="sect3">Cube Materialized Views</h4>
<p>Oracle OLAP cubes can be enhanced so that they also contain materialized views as part of the underlying implementation. A cube that has been enhanced in this way is said to contain a cube materialized view and the cube materialized view is identified with a CB$ prefix (for example: the SLSQR cube contains a cube materialized view <code>CB$SLSQR</code>). Cube materialized views can be incrementally refreshed through the Oracle Database materialized view subsystem, and if the option "Enable Query Rewrite" has been enabled for the cube, they can also serve as targets for transparent rewrite of queries against the source tables.</p>
<p>The OLAP dimensions associated with a cube materialized view are also defined with materialized view capabilities.</p>
<p class="subhead2"><a id="RBIOG209"></a>Necessary Cube Characteristics for Cube Materialized Views</p>
<p>A cube must conform to the following requirements before it can be designated as a cube materialized view:</p>
<ul>
<li>
<p>All dimensions of the cube have at least one level and one level-based hierarchy. Ragged and skip-level hierarchies are not supported. The dimensions must be mapped.</p>
</li>
<li>
<p>All dimensions of the cube use the same aggregation operator, which is either <code>SUM</code>, <code>MIN</code>, or <code>MAX</code>.</p>
</li>
<li>
<p>The cube has one or more dimensions and one or more measures.</p>
</li>
<li>
<p>The cube is fully defined and mapped. For example, if the cube has five measures, then all five are mapped to the source tables.</p>
</li>
<li>
<p>The data type of the cube is <code>NUMBER</code>, <code>VARCHAR2</code>, <code>NVARCHAR2</code>, or <code>DATE</code>.</p>
</li>
<li>
<p>The source detail tables support dimension and rely constraints. If they have not been defined, then use the Relational Schema Advisor to generate a script that defines them on the detail tables.</p>
</li>
<li>
<p>The cube is compressed.</p>
</li>
<li>
<p>The cube can be enriched with calculated measures, but it cannot support more advanced analytics in a cube script.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDDABHH"></a><a id="RBIOG210"></a>Adding Materialized View Capabilities</p>
<p><a id="sthref107"></a>To add materialized view capabilities to an OLAP cube, take the following steps:</p>
<ol>
<li>
<p>In the Analytic Workspace Manager, connect to the <code>ordm_sys</code> schema.</p>
</li>
<li>
<p>From the cube list, select the cube which to enable.</p>
</li>
<li>
<p>In the right pane, select the <span class="gui-object-action">Materialized Views</span> tab.</p>
</li>
<li>
<p>Select the option <span class="bold">Enable Materialized View Refresh</span> <span class="bold">of the Cube</span>, and select the <span class="bold">Refresh Method</span>: <span class="bold">Fast</span> and <span class="bold">Constraints</span>: <span class="bold">Trusted</span> and also select the option Include a count of measure values in the materialized view, then click <span class="bold">Apply</span>. Leave the option <span class="bold">Enable for Query Rewrite</span> unchecked by default.</p>
</li>
<li>
<p>For certain cubes, for example the SLSQR cube, enable the option <span class="bold">Enable for Query Rewrite</span>. This is the only cube in Oracle Retail Data Model which is setup for cube based Materialized View Query Rewrite capability.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot enable the cube materialized view for a forecast cube. The cubes SLS, INV and SLSQR are the only cubes in Oracle Retail Data Model which use this Cube based Materialized View functionality.</div>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
For more information on working with OLAP cubes, see the following OBE tutorials:
<ul>
<li>
<p>"Querying OLAP 11<span class="italic">g</span> Cubes"</p>
</li>
<li>
<p>"Using Oracle OLAP 11<span class="italic">g</span> With Oracle BI Enterprise Edition"</p>
</li>
</ul>
<p>To access the tutorials, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorials by name.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a class="olink OLAUG100" href="../../olap.112/e17123/overview.htm#OLAUG100"><span class="italic">Oracle OLAP User's Guide</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBCJJA"></a><a id="RBIOG211"></a>
<div class="sect2">
<h3 class="sect2">Characteristics of the OLAP Cubes in Oracle Retail Data Model</h3>
<p><a id="sthref108"></a>The default access layer of Oracle Retail Data Model provides a dimensional perspective of the data using Oracle OLAP cubes.</p>
<p>There are OLAP cubes defined in the default <code>ordm_sys</code> schema. These cubes have the general characteristics described in <a href="#CHDBIIIE">"Characteristics of the OLAP Dimensional Model"</a>. Specifically, OLAP cubes in the Oracle Retail Data Model have the following characteristics:</p>
<ul>
<li>
<p>The cubes were defined and built using the Analytical Workspace Manager (AWM) client tool.</p>
</li>
<li>
<p>OLAP cubes are loaded with data from DWB, DWD, and DWV tables (objects).</p>
</li>
<li>
<p>Some OLAP Cubes are related to the Sales and Inventory Forecast process. They are not mapped to any relational source and data for these cubes is generated from within the Oracle Retail Data Model OLAP Analytical Workspace.</p>
</li>
<li>
<p>A relational view (with a <code>_VIEW</code> suffix) is defined over each of the OLAP cubes.</p>
</li>
<li>
<p>Several of the OLAP cubes in the Oracle Retail Data Model have cube materialized views enabled (that is, contain CB$ objects). These are the cubes: SLS, INV, and SLSQR.</p>
</li>
</ul>
<p><a id="sthref109"></a><a id="sthref110"></a>For information on the using OLAP cubes in your customized version of Oracle Retail Data Model, see <a class="olink OLAUG300" href="../../olap.112/e17123/cubes.htm#OLAUG300"><span class="italic">Oracle OLAP User's Guide</span></a> and the following topics:</p>
<ul>
<li>
<p><a href="#CHDGECFG">Defining New Oracle OLAP Cubes for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDHBBAJ">Changing an Oracle OLAP Cube in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDIJCGJ">Creating a Forecast Cube for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDHEGCC">Choosing a Cube Partitioning Strategy for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDFAHED">Choosing a Cube Data Maintenance Method for Oracle Retail Data Model</a></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDGECFG"></a><a id="RBIOG212"></a>
<div class="sect2">
<h3 class="sect2">Defining New Oracle OLAP Cubes for Oracle Retail Data Model</h3>
<p><a id="sthref111"></a>You can add new OLAP cubes to the <code>ordm_sys</code> schema. For consistency's sake, design and define these new cubes as described in <a href="#CHDBCJJA">"Characteristics of the OLAP Cubes in Oracle Retail Data Model"</a>.</p>
<p>Take the following steps to define new cubes:</p>
<ol>
<li>
<p>Ensure that there is an appropriate relational object (table or view: either <code>DWB_</code> , or <code>DWD_</code>, or <code>DWA_</code>, or even a <code>DWV_</code>) to use as the "lowest leaf" level data for the cube. Essentially this step is to ensure that the task of adding new cubes has been designed correctly and that the implementation team is aware of the various candidate source objects in Oracle Retail Data Model.</p>
</li>
<li>
<p>Use the AWM to define new Cubes for a customized version of Oracle Retail Data Model. Follow the instructions given for creating cubes and dimensions in <a class="olink OLAUG300" href="../../olap.112/e17123/cubes.htm#OLAUG300"><span class="italic">Oracle OLAP User's Guide</span></a>.</p>
<p>Use the information provided in <a href="#CHDBIIIE">"Characteristics of the OLAP Dimensional Model"</a>. and the Oracle OLAP User's Guide to guide you when you design and define new OLAP cubes. Also, if you are familiar with a relational star schema design as outlined in <a href="#CHDGJHFH">"Characteristics of Relational Star and Snowflake Tables"</a>, then you can use this understanding to help you design an OLAP Cube:</p>
<ul>
<li>
<p>Fact tables correspond to cubes.</p>
</li>
<li>
<p>Data columns in the fact tables correspond to measures.</p>
</li>
<li>
<p>Foreign key constraints in the fact tables identify the dimension tables.</p>
</li>
<li>
<p>Dimension tables identify the dimensions.</p>
</li>
<li>
<p>Primary keys in the dimension tables identify the base-level dimension members.</p>
</li>
<li>
<p>Parent columns in the dimension tables identify the higher level dimension members.</p>
</li>
<li>
<p>Columns in the dimension tables containing descriptions and characteristics of the dimension members identify the attributes.</p>
</li>
</ul>
<p>You can also get insights into the dimensional model by looking at the reports included with Oracle Retail Data Model.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink RBIIG222" href="../../doc.112/e20362/intro.htm#RBIIG222"><span class="italic">Oracle Retail Data Model Installation Guide</span></a> for more information on installing the sample reports and deploying the Oracle Retail Data Model RPD and webcat on the Business Intelligence Suite Enterprise Edition instance.</div>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
While investigating your source data, you may decide to create relational views that more closely match the dimensional model that you plan to create.</div>
</li>
<li>
<p>Add materialized view capabilities to the OLAP cubes as described in <a href="#CHDDABHH">"Adding Materialized View Capabilities"</a>.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a class="olink OLAUG300" href="../../olap.112/e17123/cubes.htm#OLAUG300"><span class="italic">Oracle OLAP User's Guide</span></a>, <a href="#CHDGECFG">"Defining New Oracle OLAP Cubes for Oracle Retail Data Model"</a>, and the sample reports in <a class="olink RBIRF1000" href="../../doc.112/e20361/sample_reports_rdm.htm#RBIRF1000"><span class="italic">Oracle Retail Data Model Reference</span></a>.</div>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
For more information on creating OLAP cubes, see the "Building OLAP 11<span class="italic">g</span> Cubes" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDHBBAJ"></a><a id="RBIOG213"></a>
<div class="sect2">
<h3 class="sect2">Changing an Oracle OLAP Cube in Oracle Retail Data Model</h3>
<p><a id="sthref112"></a><a id="sthref113"></a>Common customizations to Oracle Retail Data Model cubes are changing the dimensions or the measures of the cube.</p>
<p>To change the measures or dimensions of one cube, you must take the following steps:</p>
<ol>
<li>
<p>Use the information in <a class="olink RBIRF880" href="../../doc.112/e20361/olap_cubes_rdm.htm#RBIRF880"><span class="italic">Oracle Retail Data Model Reference</span></a> to identify the relational object, that is the table or view, from which the OLAP cube is populated.</p>
</li>
<li>
<p>Change the structure of the object identified in Step 1.</p>
</li>
<li>
<p>Change the OLAP cube and cube materialized views to reflect the new structure.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDIJCGJ"></a><a id="RBIOG214"></a>
<div class="sect2">
<h3 class="sect2">Creating a Forecast Cube for Oracle Retail Data Model</h3>
<p><a id="sthref114"></a><a id="sthref115"></a>To create a forecast cube for Oracle Retail Data Model:</p>
<ol>
<li>
<p>Create a cube to contain the results of the forecast as described in <a href="#CHDGECFG">"Defining New Oracle OLAP Cubes for Oracle Retail Data Model"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot enable materialized views for an Oracle Retail Data Model forecast cube.</div>
</li>
<li>
<p>Write an OLAP DML forecasting context program as described in <a class="olink OLADM308" href="../../olap.112/e17122/dml_program.htm#OLADM308"><span class="italic">Oracle OLAP DML Reference</span></a>.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CHDHEGCC"></a><a id="RBIOG215"></a>
<div class="sect2">
<h3 class="sect2">Choosing a Cube Partitioning Strategy for Oracle Retail Data Model</h3>
<p><a id="sthref116"></a><a id="sthref117"></a>Partitioning is a method of physically storing the contents of a cube. It improves the performance of large cubes in the following ways:</p>
<ul>
<li>
<p>Improves scalability by keeping data structures small. Each partition functions like a smaller measure.</p>
</li>
<li>
<p>Keeps the working set of data smaller both for queries and maintenance, since the relevant data is stored together.</p>
</li>
<li>
<p>Enables parallel aggregation during data maintenance. Each partition can be aggregated by a separate process.</p>
</li>
<li>
<p>Simplifies removal of old data from storage. Old partitions can be dropped, and new partitions can be added.</p>
</li>
</ul>
<p>The number of partitions affects the database resources that can be allocated to loading and aggregating the data in a cube. Partitions can be aggregated simultaneously when sufficient resources have been allocated.</p>
<p>The Cube Partitioning Advisor analyzes the source tables and develops a partitioning strategy. You can accept the recommendations of the Cube Partitioning Advisor, or you can make your own decisions about partitioning.</p>
<p>If your partitioning strategy is driven primarily by life-cycle management considerations, then you should partition the cube on the Time dimension. Old time periods can then be dropped as a unit, and new time periods added as a new partition. The Cube Partitioning Advisor has a Time option, which recommends a hierarchy and a level in the Time dimension for partitioning.</p>
<p>The level on which to partition a cube is determined based on a trade off between load performance and query performance.</p>
<p>Typically, you do not want to partition on too low a level (for example, on the DAY level of a TIME dimension) because if you do then too many partitions must be defined at load time which slows down an initial or historical load. Also, a large number of partitions can result in unusually long Analytic Workspace attach times and slows down the Time Series-based calculations. Also, a Quarterly Cumulative measure (Quarter to Date Measure) needs to access 90 or 91 partitions to calculate a value for one Customer and Organization. All dimension members above the partition level of partition dimension (including those belonging to nondefault hierarchies) would be present in a single default template. Day level partitioning makes this very heavy since all higher level members are stored in default template. However, the advantage of partitioning <code>DAY</code> if the OLAP Cube load frequency is daily then there you must only load from a new partition in fact table into a single partition in the OLAP cube every day. This greatly improves the load performance since percentage-based refresh can be enabled if the cube is materialized-view enabled and has materialized-view logs.</p>
<p class="subhead2"><a id="RBIOG216"></a>Recommendations: Cube Partitioning Strategy</p>
<p>Usually a good compromise between the differing load and query performance requirements is to use an intermediate level like <code>MONTH</code> as the partition level. Time series calculations within a month (week to date, month to date, and so on) are fast and higher level calculations such as year to date need to refer to 12 partitions at most. Also this way the monthly partition is defined and created only one time (that is during the initial load on first of each month) and is then reused for each subsequent load that month. The aggregation process may be triggered off at the month level (instead of specific day level) and some redundant aggregations (of previously loaded dates of current month) may occur each time but it should result in satisfactory load and query performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
"The discussion on choosing a partition strategy in <a class="olink OLAUG9148" href="../../olap.112/e17123/cubes.htm#OLAUG9148"><span class="italic">Oracle OLAP User's Guide</span></a>, <a href="pdm.htm#CHDJBEFG">"Indexes and Partitioned Indexes in Oracle Retail Data Model"</a>, and <a href="#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDFAHED"></a><a id="RBIOG217"></a>
<div class="sect2">
<h3 class="sect2">Choosing a Cube Data Maintenance Method for Oracle Retail Data Model</h3>
<p><a id="sthref118"></a>While developing a dimensional model of your data, it is a good idea to map and load each object immediately after you create it so that you can immediately detect and correct any errors that you made to the object definition or the mapping.</p>
<p>However, in a production environment, you should perform routine maintenance as quickly and easily as possible. For this stage, you can choose among data maintenance methods. You can refresh all cubes using the Maintenance Wizard. This wizard enables you to refresh a cube immediately, or submit the refresh as a job to the Oracle job queue, or generate a PL/SQL script. You can run the script manually or using a scheduling utility, such as Oracle Enterprise Manager Scheduler or the <code>DBMS_SCHEDULER</code> PL/SQL package. The generated script calls the <code>BUILD</code> procedure of the <code>DBMS_CUBE</code> PL/SQL package. You can modify this script or develop one from the start using this package.</p>
<p>The data for a partitioned cube is loaded and aggregated in parallel when multiple processes have been allocated to the build. You are able to see this in the build log.</p>
<p>In addition, each cube can support these data maintenance methods:</p>
<ul>
<li>
<p>Custom cube scripts</p>
</li>
<li>
<p>Cube materialized views</p>
</li>
</ul>
<p>If you are defining cubes to replace existing materialized views, then you use the materialized views as an integral part of data maintenance. Note, however, that materialized view capabilities restrict the types of analytics that can be performed by a custom cube script.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a class="olink OLAUG9154" href="../../olap.112/e17123/cubes.htm#OLAUG9154"><span class="italic">Oracle OLAP User's Guide</span></a> and <a href="#CHDIJEDJ">"Types of Materialized Views and Refresh options"</a></div>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
See the following OBE tutorial for an example of how Oracle uses cube materialized views for transparent access to a relational star schema:
<ul>
<li>
<p>"Querying OLAP 11<span class="italic">g</span> Cubes"</p>
</li>
</ul>
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABCCDIJ"></a><a id="RBIOG218"></a>
<div class="sect1">
<h2 class="sect1">Materialized Views in the Oracle Retail Data Model</h2>
<p><a id="sthref119"></a>Materialized views are query results that have been stored or "materialized" in advance as schema objects. From a physical design point of view, materialized views resemble tables or partitioned tables and behave like indexes in that they are used transparently and improve performance.</p>
<p>In the past, organizations using summaries spent a significant amount of time and effort creating summaries manually, identifying which summaries to create, indexing the summaries, updating them, and advising their users on which ones to use. With the advent of materialized views, a database administrator creates one or more materialized views, which are the equivalent of a summary. Thus, the workload of the database administrator is eased and the user no longer needed to be aware of the summaries that had been defined. Instead, the end user queries the tables and views at the detail data level. The query rewrite mechanism in the Oracle server automatically rewrites the SQL query to use the summary tables and reduces response time for returning results from the query.</p>
<p>Materialized views improve query performance by precalculating expensive join and aggregation operations on the database before executing and storing the results in the database. The query optimizer automatically recognizes when it can use an existing materialized view to satisfy a request.</p>
<p>The default Oracle Retail Data Model defines many materialized views. In the default <code>ordm_sys</code> schema, you can identify these materialized views by looking at objects with the prefixes listed in the following table.</p>
<div class="inftblinformal">
<table class="cellalignment2111" summary="Prefixes and suffixes used when naming objects" dir="ltr">
<thead>
<tr class="cellalignment2105">
<th class="cellalignment2112" id="r1c1-t21">Prefix</th>
<th class="cellalignment2112" id="r1c2-t21">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r2c1-t21" headers="r1c1-t21"><code>DWA_</code></td>
<td class="cellalignment2113" headers="r2c1-t21 r1c2-t21">Aggregate table or relational materialized view. This prefix is generalized for aggregate tables. Aggregate objects are implemented using either Materialized Views or tables.
<p>See: Aggregate tables in <a class="olink RBIRF492" href="../../doc.112/e20361/physical_rdm.htm#RBIRF492"><span class="italic">Oracle Retail Data Model Reference</span></a> for a list of these objects in the default data model.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r3c1-t21" headers="r1c1-t21"><code>CB$</code></td>
<td class="cellalignment2113" headers="r3c1-t21 r1c2-t21">Materialized view used to support/deliver required functionality for an Oracle OLAP cube. This is an internal object built and maintained automatically by the Oracle OLAP server in the database.
<p>See: OLAP cube materialized views in <a class="olink RBIRF1128" href="../../doc.112/e20361/physical_rdm.htm#RBIRF1128"><span class="italic">Oracle Retail Data Model Reference</span></a> for a list of these objects in the default data model.</p>
<p><a href="#CHDBCJJA">"Characteristics of the OLAP Cubes in Oracle Retail Data Model"</a> for information on OLAP cubes.</p>
<p>Note: Do not report or query against this object. Instead access the relational view of an OLAP cube (that is, the object with the <code>_VIEW</code> suffix).</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r4c1-t21" headers="r1c1-t21"><code>DMV_</code></td>
<td class="cellalignment2113" headers="r4c1-t21 r1c2-t21">Data mining views that are <span class="italic">not</span> an aggregate table or a cube materialized view.
<p>See: <a class="olink RBIRF1893" href="../../doc.112/e20361/physical_rdm.htm#RBIRF1893"><span class="italic">Oracle Retail Data Model Reference</span></a> to identify these objects in the default data model.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The following topics provide more information on using and creating materialized views in your customized Oracle Retail Data Model:</p>
<ul>
<li>
<p><a href="#CHDIJEDJ">Types of Materialized Views and Refresh options</a></p>
</li>
<li>
<p><a href="#CHDHFGEH">Choosing Indexes for Materialized Views</a></p>
</li>
<li>
<p><a href="#CHDCGHCG">Partitioning and Materialized Views</a></p>
</li>
<li>
<p><a href="#CHDHIGBI">Compressing Materialized Views</a></p>
</li>
</ul>
<a id="CHDIJEDJ"></a><a id="RBIOG219"></a>
<div class="sect2">
<h3 class="sect2">Types of Materialized Views and Refresh options</h3>
<p><a id="sthref120"></a>Refresh option vary by the type of materialized view:</p>
<ul>
<li>
<p><a href="#BABFJIEA">Refresh Options for Materialized Views with Aggregates</a></p>
</li>
<li>
<p><a href="#BABDBJHA">Refresh Options for Materialized Views Containing Only Joins</a></p>
</li>
<li>
<p><a href="#CHDEHFEI">Refresh Options for Nested Materialized Views</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink OLAUG9156" href="../../olap.112/e17123/cubes.htm#OLAUG9156"><span class="italic">Oracle OLAP User's Guide</span></a> for a discussion of creating materialized views of Oracle OLAP cubes.</div>
<a id="BABFJIEA"></a><a id="RBIOG220"></a>
<div class="sect3">
<h4 class="sect3">Refresh Options for Materialized Views with Aggregates</h4>
<p>In data warehouses, materialized views normally contain aggregates. The <code>DWA_</code> tables in the default Oracle Retail Data Model are this type of materialized view.</p>
<p>For a materialized view with aggregates, for fast refresh to be possible:</p>
<ul>
<li>
<p>The <code>SELECT</code> list must contain all of the <code>GROUP BY</code> columns (if present)</p>
</li>
<li>
<p>There must be a <code>COUNT(*)</code> and a <code>COUNT(</code><code><span class="codeinlineitalic">column</span></code><code>)</code> on any aggregated columns.</p>
</li>
<li>
<p>Materialized view logs must be present on all tables referenced in the query that defines the materialized view. The valid aggregate functions are: <code>SUM</code>, <code>COUNT(</code><code><span class="codeinlineitalic">x</span></code><code>)</code>, <code>COUNT(*)</code>, <code>AVG</code>, <code>VARIANCE</code>, <code>STDDEV</code>, <code>MIN</code>, and <code>MAX</code>, and the expression to be aggregated can be any SQL value expression.</p>
</li>
</ul>
<p>Fast refresh for a materialized view containing joins and aggregates is possible after any type of DML to the base tables (direct load or conventional <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>).</p>
<p>You can define that the materialized view be refreshed <code>ON COMMIT</code> or <code>ON DEMAND</code>. A <code>REFRESH ON COMMIT</code> materialized view is automatically refreshed when a transaction that does DML to a materialized view's detail tables commits.</p>
<p>When you specify <code>REFRESH ON COMMIT</code>, the table commit can take more time than if you have not. This is because the refresh operation is performed as part of the commit process. Therefore, this method may not be suitable if many users are concurrently changing the tables upon which the materialized view is based.</p>
</div>
<!-- class="sect3" -->
<a id="BABDBJHA"></a><a id="RBIOG221"></a>
<div class="sect3">
<h4 class="sect3">Refresh Options for Materialized Views Containing Only Joins</h4>
<p>Some materialized views contain only joins and no aggregates (for example, when a materialized view is created that joins the sales table to the times and customers tables). The advantage of creating this type of materialized view is that expensive joins are precalculated.</p>
<p>Fast refresh for a materialized view containing only joins is possible after any type of DML to the base tables (direct-path or conventional <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>).</p>
<p>A materialized view containing only joins can be defined to be refreshed <code>ON COMMIT</code> or <code>ON DEMAND</code>. If it is ON COMMIT, the refresh is performed at commit time of the transaction that does DML on the materialized view's detail table.</p>
<p>If you specify <code>REFRESH FAST</code>, Oracle Database performs further verification of the query definition to ensure that fast refresh can be performed if any of the detail tables change. These additional checks are:</p>
<ul>
<li>
<p>A materialized view log must be present for each detail table unless the table supports partition change tracking. Also, when a materialized view log is required, the <code>ROWID</code> column must be present in each materialized view log.</p>
</li>
<li>
<p>The rowids of all the detail tables must appear in the <code>SELECT</code> list of the materialized view query definition.</p>
</li>
</ul>
<p>If some of these restrictions are not met, you can create the materialized view as <code>REFRESH FORCE</code> to take advantage of fast refresh when it is possible. If one table does not meet all of the criteria, but the other tables do the materialized view is still fast refreshable with respect to the other tables for which all the criteria are met.</p>
<p>To achieve an optimally efficient refresh:</p>
<ul>
<li>
<p>Ensure that the defining query does not use an outer join that behaves like an inner join. If the defining query contains such a join, consider rewriting the defining query to contain an inner join.</p>
</li>
<li>
<p>If the materialized view contains <span class="italic">only</span> joins, the <code>ROWID</code> columns for each table (and each instance of a table that occurs multiple times in the <code>FROM</code> list) must be present in the <code>SELECT</code> list of the materialized view.</p>
</li>
<li>
<p>If the materialized view has remote tables in the <code>FROM</code> clause, all tables in the <code>FROM</code> clause must be located on that same site. Further, <code>ON COMMIT</code> refresh is not supported for materialized view with remote tables. Except for SCN-based materialized view logs, materialized view logs must be present on the remote site for each detail table of the materialized view and ROWID columns must be present in the SELECT list of the materialized view.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDEHFEI"></a><a id="RBIOG222"></a>
<div class="sect3">
<h4 class="sect3">Refresh Options for Nested Materialized Views</h4>
<p>A nested materialized view is a materialized view whose definition is based on another materialized view. A nested materialized view can reference other relations in the database in addition to referencing materialized views.</p>
<p>In a data warehouse, you typically create many aggregate views on a single join (for example, rollups along different dimensions). Incrementally maintaining these distinct materialized aggregate views can take a long time, because the underlying join has to be performed many times.</p>
<p>Using nested materialized views, you can create multiple single-table materialized views based on a joins-only materialized view and the join is performed just one time. In addition, optimizations can be performed for this class of single-table aggregate materialized view and thus refresh is very efficient.</p>
<p>Some types of nested materialized views cannot be fast refreshed. Use <code>EXPLAIN_MVIEW</code> to identify those types of materialized views.</p>
<p>You can refresh a tree of nested materialized views in the appropriate dependency order by specifying the <code>nested</code> <code>=TRUE</code> parameter with the <code>DBMS_MVIEW.REFRESH</code> parameter.</p>
<div class="example">
<p class="titleinexample"><a id="RBIOG335"></a><a id="sthref121"></a>Example 3-2 Refreshing Oracle Retail Data Model Nested Materialized Views</p>
<p>For example, if you call <code>DBMS_MVIEW.REFRESH ('DWA_CUST_TYP_ORDR_DEPT_MO', nested =&gt; TRUE)</code>, the <code>REFRESH</code> procedure first refreshes the <code>DWA_CUST_TYP_ORDR_SBC_WK</code> materialized view, and then refreshes the <code>DWA_CUST_TYP_ORDR_DEPT_MO</code> materialized view.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHFGEH"></a><a id="RBIOG223"></a>
<div class="sect2">
<h3 class="sect2">Choosing Indexes for Materialized Views</h3>
<p><a id="sthref122"></a><a id="sthref123"></a>The two most common operations on a materialized view are query execution and fast refresh, and each operation has different performance requirements:</p>
<ul>
<li>
<p>Query execution might need to access any subset of the materialized view key columns, and might need to join and aggregate over a subset of those columns. Consequently, for best performance, create a single-column bitmap index on each materialized view key column.</p>
</li>
<li>
<p>In the case of materialized views containing only joins using fast refresh, create indexes on the columns that contain the rowids to improve the performance of the refresh operation.</p>
</li>
<li>
<p>If a materialized view using aggregates is fast refreshable, then an index appropriate for the fast refresh procedure is created unless <code>USING NO INDEX</code> is specified in the <code>CREATE MATERIALIZED VIEW</code> statement.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="pdm.htm#CHDJBEFG">"Indexes and Partitioned Indexes in Oracle Retail Data Model"</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDCGHCG"></a><a id="RBIOG224"></a>
<div class="sect2">
<h3 class="sect2">Partitioning and Materialized Views</h3>
<p><a id="sthref124"></a><a id="sthref125"></a>Because of the large volume of data held in a data warehouse, partitioning is an extremely useful option when designing a database. Partitioning the fact tables improves scalability, simplifies system administration, and makes it possible to define local indexes that can be efficiently rebuilt. Partitioning the fact tables also improves the opportunity of fast refreshing the materialized view because this may enable partition change tracking refresh on the materialized view.</p>
<p>Partitioning a materialized view has the same benefits as partitioning fact tables. When a materialized view is partitioned a refresh procedure can use parallel DML in more scenarios and partition change tracking-based refresh can use truncate partition to efficiently maintain the materialized view.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a class="olink VLDBG1359" href="../../server.112/e25523/part_warehouse.htm#VLDBG1359"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a>, <a href="pdm.htm#CHDEDHHJ">"Partitioned Tables in Oracle Retail Data Model"</a>, <a href="pdm.htm#CHDJBEFG">"Indexes and Partitioned Indexes in Oracle Retail Data Model"</a>, and <a href="#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Retail Data Model"</a></div>
<p class="subhead2"><a id="RBIOG225"></a>Using Partition Change Tracking</p>
<p><a id="sthref126"></a><a id="sthref127"></a>It is possible and advantageous to track freshness to a finer grain than the entire materialized view. The ability to identify which rows in a materialized view are affected by a certain detail table partition, is known as partition change tracking. When one or more of the detail tables are partitioned, it may be possible to identify the specific rows in the materialized view that correspond to a modified detail partition(s). those rows become stale when a partition is modified while all other rows remain fresh.</p>
<p>You can use partition change tracking to identify which materialized view rows correspond to a particular partition. Partition change tracking is also used to support fast refresh after partition maintenance operations on detail tables. For instance, if a detail table partition is truncated or dropped, the affected rows in the materialized view are identified and deleted. Identifying which materialized view rows are fresh or stale, rather than considering the entire materialized view as stale, allows query rewrite to use those rows that refresh while in <code>QUERY_REWRITE_INTEGRITY = ENFORCED</code> or <code>TRUSTED</code> modes.</p>
<p>Several views, such as <code>DBA_MVIEW_DETAIL_PARTITION</code>, detail which partitions are stale or fresh. Oracle does not rewrite against partial stale materialized views if partition change tracking on the changed table is enabled by the presence of join dependent expression in the materialized view.</p>
<p>To support partition change tracking, a materialized view must satisfy the following requirements:</p>
<ul>
<li>
<p>At least one detail table referenced by the materialized view must be partitioned.</p>
</li>
<li>
<p>Partitioned tables must use either range, list or composite partitioning.</p>
</li>
<li>
<p>The top level partition key must consist of only a single column.</p>
</li>
<li>
<p>The materialized view must contain either the partition key column or a partition marker or <code>ROWID</code> or join dependent expression of the detail table.</p>
</li>
<li>
<p>If you use a <code>GROUP BY</code> clause, the partition key column or the partition marker or <code>ROWID</code> or join dependent expression must be present in the <code>GROUP BY</code> clause.</p>
</li>
<li>
<p>If you use an analytic window function or the <code>MODEL</code> clause, the partition key column or the partition marker or <code>ROWID</code> or join dependent expression must be present in their respective <code>PARTITION BY</code> subclauses.</p>
</li>
<li>
<p>Data modifications can only occur on the partitioned table. If partition change tracking refresh is being done for a table which has join dependent expression in the materialized view, then data modifications should not have occurred in any of the join dependent tables.</p>
</li>
<li>
<p>The <code>COMPATIBILITY</code> initialization parameter must be a minimum of <code>9.0.0.0.0</code>.</p>
</li>
<li>
<p>Partition change tracking is not supported for a materialized view that refers to views, remote tables, or outer joins.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDHIGBI"></a><a id="RBIOG226"></a>
<div class="sect2">
<h3 class="sect2">Compressing Materialized Views</h3>
<p><a id="sthref128"></a><a id="sthref129"></a>Using data compression for a materialized view brings you a additional dramatic performance improvement.</p>
<p>Consider data compression when using highly redundant data, such as tables with many foreign keys. In particular, likely candidates are materialized views created with the <code>ROLLUP</code> clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="pdm.htm#CHDFJDEE">"Data Compression in Oracle Retail Data Model"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2104">
<tr>
<td class="cellalignment2113">
<table class="cellalignment2109">
<tr>
<td class="cellalignment2108"><a href="pdm.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2108"><a href="etlmap.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2116">
<table class="cellalignment2107">
<tr>
<td class="cellalignment2108"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2108"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2108"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2108"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2108"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2108"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
