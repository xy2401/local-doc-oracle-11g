<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>ETL Implementation and Customization</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 710" />
<meta name="dcterms.created" content="2013-01-30T11:7:36Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Retail Data Model Implementation and Operations Guide" />
<meta name="dcterms.identifier" content="E20363-03" />
<meta name="dcterms.isVersionOf" content="RBIOG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="adm.htm" title="Previous" type="text/html" />
<link rel="Next" href="rep_quer.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e20363.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/14</span> <!-- End Header --><a id="BEHJFAFF"></a><a id="RBIOG227"></a>
<h1 class="chapter"><span class="secnum">4</span> ETL Implementation and Customization</h1>
<p>This chapter discusses the ETL (Extraction, Transformation and Loading) procedures you use to populate an Oracle Retail Data Model warehouse. It includes the following topics:</p>
<ul>
<li>
<p><a href="#BEHCJJIH">The Role of ETL in the Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BEHFIHBE">Creating Source-ETL for Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BEHHEIEE">Customizing Intra-ETL for the Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#BEHBGBGC">Performing an Initial Load of an Oracle Retail Data Model Warehouse</a></p>
</li>
<li>
<p><a href="#BEHIEGJH">Refreshing the Data in Oracle Retail Data Model Warehouse</a></p>
</li>
<li>
<p><a href="#BEHGGCGC">Managing Errors During Oracle Retail Data Model Intra-ETL Execution</a></p>
</li>
</ul>
<a id="BEHCJJIH"></a><a id="RBIOG228"></a>
<div class="sect1">
<h2 class="sect1">The Role of ETL in the Oracle Retail Data Model</h2>
<p><a id="sthref130"></a><a id="sthref131"></a><a href="pdm.htm#BABCEHEI">Figure 2-1</a> shows the three layers in Oracle Retail Data Model warehouse environment: the optional staging layer, the foundation layer, and the access layer. As shown in <a href="#BEHBEGGA">Figure 4-1</a>, you use two types of ETL (extraction, transformation and loading) to populate these layers:</p>
<ul>
<li>
<p><a id="sthref132"></a><a id="sthref133"></a><span class="bold">Source-ETL</span>. ETL that populates the staging layer (if any) or the foundation layer with data from the transactional system is known as source ETL.</p>
<p>Oracle Retail Data Model does <span class="italic">not</span> include source-ETL. You must create source-ETL yourself using your understanding of your transactional system and your customized Oracle Retail Data Model. See <a href="#BEHFIHBE">"Creating Source-ETL for Oracle Retail Data Model"</a> for more information on creating source-ETL.</p>
</li>
<li>
<p><a id="sthref134"></a><a id="sthref135"></a><span class="bold">Intra-ETL</span>. ETL that populates the access layer using the data in the foundation layer is known as intra-ETL.</p>
<p>Oracle Retail Data Model <span class="italic">does</span> include intra-ETL. You can modify the default intra-ETL to populate a customized access layer from a customized foundation layer. See <a href="#BEHHEIEE">"Customizing Intra-ETL for the Oracle Retail Data Model"</a> for more information on the intra-ETL.</p>
</li>
</ul>
<div class="figure">
<p class="titleinfigure"><a id="BEHBEGGA"></a><a id="RBIOG229"></a>Figure 4-1 ETL Flow Diagram</p>
<img width="412" height="712" src="img/etlflow.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref136" href="img_text/etlflow.htm">Description of "Figure 4-1 ETL Flow Diagram"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="BEHFIHBE"></a><a id="RBIOG230"></a>
<div class="sect1">
<h2 class="sect1">Creating Source-ETL for Oracle Retail Data Model</h2>
<p><a id="sthref137"></a><a id="sthref138"></a>ETL that populates the staging layer or the foundation layer of an Oracle Retail Data Model warehouse with data from a transactional system is known as source-ETL.</p>
<p>Due to the large number of available transactional applications and multiple versions that may be in use, source-ETL is not provided with Oracle Retail Data Model. You must write your own source-ETL scripts using Oracle Warehouse Builder or another ETL tool or mapping tool.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a class="olink WBETL04000" href="../../owb.112/e10935/transformdata_intro.htm#WBETL04000"><span class="italic">Oracle Warehouse Builder Data Modeling, ETL, and Data Quality Guide</span></a>.</div>
<div class="infobox-note">
<p class="notep1">Oracle By Example:</p>
See the following OBE tutorials for more information on Oracle Warehouse Builder:
<ul>
<li>
<p>"Setting Up the Oracle Warehouse Builder 11<span class="italic">g</span> Release 2 Environment"</p>
</li>
<li>
<p>"Improved User Interface, Usability, and Productivity With OWB 11<span class="italic">g</span>"</p>
</li>
<li>
<p>"Using Data Transformation Operators with Source and Target Operators"</p>
</li>
<li>
<p>"Working with Pluggable Mappings"</p>
</li>
<li>
<p>"Examining Source Data Using Data Profiling with Database 11<span class="italic">g</span> Release 2"</p>
</li>
</ul>
<p>To access the tutorials, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorials by name.</p>
</div>
<p>The following topics provide general information about writing source-ETL:</p>
<ul>
<li>
<p><a href="#BEHFHCBG">Source-ETL Design Considerations</a></p>
</li>
<li>
<p><a href="#BEHCBAHB">ETL Architecture for Oracle Retail Data Model Source-ETL</a></p>
</li>
<li>
<p><a href="#BEHEIJAB">Creating a Source to Target Mapping Document for the Source-ETL</a></p>
</li>
<li>
<p><a href="#BEHEIDDG">Designing a Plan for Rectifying Source-ETL Data Quality Problems</a></p>
</li>
<li>
<p><a href="#BEHJBGGI">Designing Source-ETL Workflow and Jobs Control</a></p>
</li>
<li>
<p><a href="#BEHEDEDI">Designing Source-ETL Exception Handling</a></p>
</li>
<li>
<p><a href="#BEHGBCAJ">Writing Source-ETL that Loads Efficiently</a></p>
</li>
</ul>
<a id="BEHFHCBG"></a><a id="RBIOG351"></a>
<div class="sect2">
<h3 class="sect2">Source-ETL Design Considerations</h3>
<p>Keep the following points in mind when designing and writing source-ETL for Oracle Retail Data Model:</p>
<ul>
<li>
<p>You can populate the calendar data using the calendar population scripts provided with Oracle Retail Data Model (the calendar population scripts populate data for the business and gregorian calendars, other calendars need to be populated using source ETL). See <a class="olink RBIRF994" href="../../doc.112/e20361/utility_scripts_rdm.htm#RBIRF994"><span class="italic">Oracle Retail Data Model Reference</span></a> for more information on the Oracle Retail Data Model calendar population scripts.</p>
</li>
<li>
<p>Populate the tables in the following order:</p>
<ol>
<li>
<p>Lookup tables</p>
</li>
<li>
<p>Reference tables</p>
</li>
<li>
<p>Base tables</p>
</li>
</ol>
</li>
<li>
<p>Analyze the tables in one category before loading the tables in the next category (for example, analyze the reference tables before loading the lookup tables). Additionally, you must analyze all of the tables loaded by the source-ETL process before executing the intra-ETL processes).</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
The topic about analyzing tables, indexes and clusters in <a class="olink ADMIN11524" href="../../server.112/e25494/general.htm#ADMIN11524"><span class="italic">Oracle Database Administrator's Guide</span></a>.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEHCBAHB"></a><a id="RBIOG231"></a>
<div class="sect2">
<h3 class="sect2">ETL Architecture for Oracle Retail Data Model Source-ETL</h3>
<p><a id="sthref139"></a><a id="sthref140"></a>ETL typically extracts data from the transactional system, checks for data quality, cleanses the data and ensures consistency of terms, currency, units of measures, and so on, as it consolidates and populates the physical objects in the data warehouse with 'clean' data.</p>
<p>The fundamental services upon which data acquisition is constructed are as follows:</p>
<ul>
<li>
<p>Data sourcing</p>
</li>
<li>
<p>Data movement</p>
</li>
<li>
<p>Data transformation</p>
</li>
<li>
<p>Data loading</p>
</li>
</ul>
<p>From a logical architecture perspective, there are many different ways to configure these building blocks for delivering data acquisition services. The major architectural styles available that cover a range of options to be targeted within a data warehousing architecture include:</p>
<ul>
<li>
<p><span class="bold">Batch Extract, Transform, and Load</span> and <span class="bold">Batch Extract, Load, Transform, Load</span></p>
<p>Batch Extract, Transform and Load (ETL) and Batch Extract, Load, Transform, Load (ELTL) are the traditional architectures in a data warehouse implementation. The difference between these is where the transformation proceeds, in or out of the database.</p>
</li>
<li>
<p><span class="bold">Batch Hybrid Extract, Transform, Load, Transform, Load</span></p>
<p>Batch Hybrid Extract, Transform, Load, Transform, Load (ETLTL) is a hybrid strategy. This strategy provides the most flexibility to remove hand coding approaches to transformation design, apply a metadata-driven approach, and still be able to leverage the data processing capabilities of the enterprise warehouse. In this targeted design, the transformation processing is first performed outside the warehouse as a pre-processing step before loading the staging tables, and then further transformation processing is performed within the data warehouse before the final load into the target tables.</p>
</li>
<li>
<p><span class="bold">Real-time Extract, Transform, Load</span></p>
<p>Real-time Extract, Transform, Load (rETL) is appropriate when service levels for data freshness demand more up-to-date information in the data warehousing environment. In this approach, the transactional system must actively publish events of interest so that the rETL processes can extract them from a message bus (queue) on a timely basis. A message-based paradigm is used with publish and subscribe message bus structures or point-to-point messaging with reliable queues.</p>
</li>
</ul>
<p>When designing source-ETL for Oracle Retail Data Model, use the architecture that best meets your business needs.</p>
</div>
<!-- class="sect2" -->
<a id="BEHEIJAB"></a><a id="RBIOG232"></a>
<div class="sect2">
<h3 class="sect2">Creating a Source to Target Mapping Document for the Source-ETL</h3>
<p><a id="sthref141"></a><a id="sthref142"></a>Before you begin building your extract systems, create a logical data interface document that maps the relationship between original source columns and target destination columns in the tables. This document ties the very beginning of the ETL system to the very end.</p>
<p>Columns in the data mapping document are sometimes combined. For example, the source database, table name, and column name could be combined into a single target column. The information within the concatenated column would be delimited with a period. Regardless of the format, the content of the logical data mapping document has been proven to be the critical element required to sufficiently plan ETL processes.</p>
</div>
<!-- class="sect2" -->
<a id="BEHEIDDG"></a><a id="RBIOG233"></a>
<div class="sect2">
<h3 class="sect2">Designing a Plan for Rectifying Source-ETL Data Quality Problems</h3>
<p><a id="sthref143"></a><a id="sthref144"></a>Data cleaning consists of all the steps required to clean and validate the data feeding a table and to apply known business rules to make the data consistent. The perspectives of the cleaning and conforming steps are less about the upside potential of the data and more about containment and control.</p>
<p>If there are data quality problems, then build a plan, in agreement with IT and business users, for how to rectify these problems.</p>
<p>Answer the following questions:</p>
<ul>
<li>
<p>Is data missing?</p>
</li>
<li>
<p>Is the data wrong or inconsistent?</p>
</li>
<li>
<p>Should the problem be fixed in the source systems?</p>
</li>
</ul>
<p>Set up the following processes and programs:</p>
<ul>
<li>
<p>Data quality measurement process.</p>
</li>
<li>
<p>Data quality reporting and action program and people responsibility.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEHJBGGI"></a><a id="RBIOG234"></a>
<div class="sect2">
<h3 class="sect2">Designing Source-ETL Workflow and Jobs Control</h3>
<p><a id="sthref145"></a><a id="sthref146"></a><a id="sthref147"></a><a id="sthref148"></a>All data movement among ETL processes are composed of jobs. An ETL workflow executes these jobs in the proper sequence and with regard to the necessary dependencies. General ETL tools, such as Oracle Warehouse Builder, support this kind of workflow, job design, and execution control.</p>
<p>The following list includes tips for when you design ETL jobs and workflow:</p>
<ul>
<li>
<p>Use common structure across all jobs (source system to transformer to target data warehouse).</p>
</li>
<li>
<p>Have a one-to-one mapping from source to target.</p>
</li>
<li>
<p>Define one job per Source table.</p>
</li>
<li>
<p>Apply generic job structure and template jobs to allow for rapid development and consistency.</p>
</li>
<li>
<p>Use an optimized job design to leverage Oracle load performance based on data volumes.</p>
</li>
<li>
<p>Design parameterized job to allow for greater control over job performance and behavior.</p>
</li>
<li>
<p>Maximize Jobs parallelism execution.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEHEDEDI"></a><a id="RBIOG235"></a>
<div class="sect2">
<h3 class="sect2">Designing Source-ETL Exception Handling</h3>
<p><a id="sthref149"></a>Your ETL tool or your developed mapping scripts generate status and error handling tables. All ETL procedures log status and errors into a log table. Execution status may be monitored using an ETL tool or by examining the log table.</p>
</div>
<!-- class="sect2" -->
<a id="BEHGBCAJ"></a><a id="RBIOG236"></a>
<div class="sect2">
<h3 class="sect2"><a id="sthref150"></a>Writing Source-ETL that Loads Efficiently</h3>
<p><a id="sthref151"></a>Whether you are developing mapping scripts and loading into a staging layer or directly into the foundation layer the goal is to get the data into the warehouse in the most expedient manner. To achieve good performance during the load you must begin by focusing on where the data to be loaded resides and how you load it into the database. For example, you should not use a serial database link or a single JDBC connection to move large volumes of data. The most common and preferred mechanism for loading large volumes of data is loading from flat files.</p>
<p>The following topics discuss best practices for ensuring your source-ETL loads efficiently:</p>
<ul>
<li>
<p><a href="#BEHGIGJI">Using a Staging Area for Flat Files</a></p>
</li>
<li>
<p><a href="#BEHGCGCC">Preparing Raw Data Files for Source-ETL</a></p>
</li>
<li>
<p><a href="#BEHDJCEF">Source-ETL Data Loading Options</a></p>
</li>
<li>
<p><a href="#BEHJEGJC">Parallel Direct Path Load Source-ETL</a></p>
</li>
<li>
<p><a href="#BEHDJCEF">Source-ETL Data Loading Options</a></p>
</li>
</ul>
<a id="BEHGIGJI"></a><a id="RBIOG237"></a>
<div class="sect3">
<h4 class="sect3">Using a Staging Area for Flat Files</h4>
<p>The area where flat files are stored before being loaded into the staging layer of a data warehouse system is commonly known as staging area. The overall speed of your load is determined by:</p>
<ul>
<li>
<p>How quickly the raw data can be read from staging area.</p>
</li>
<li>
<p>How quickly the raw data can be processed and inserted into the database.</p>
</li>
</ul>
<p class="subhead2"><a id="RBIOG238"></a>Recommendations: Using a Staging Area</p>
<p>Stage the raw data across as many physical disks as possible to ensure that reading it is not a bottleneck during the load.</p>
<p>Also, if you are using the Oracle Exadata Database Machine, the best place to stage the data is in an Oracle Database File System (DBFS) stored on the Exadata storage cells. DBFS creates a mountable cluster file system which can you can use to access files stored in the database. Create the DBFS in a separate database on the Database Machine. This allows the DBFS to be managed and maintained separately from the data warehouse.</p>
<p>Mount the file system using the <code>DIRECT_IO</code> option to avoid thrashing the system page cache while moving the raw data files in and out of the file system.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink ADLOB45943" href="../../appdev.112/e18294/adlob_fs.htm#ADLOB45943"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for more information on setting up DBFS.</div>
</div>
<!-- class="sect3" -->
<a id="BEHGCGCC"></a><a id="RBIOG239"></a>
<div class="sect3">
<h4 class="sect3">Preparing Raw Data Files for Source-ETL</h4>
<p>To parallelize the data load Oracle Database must be able to logically break up the raw data files into chunks, known as granules. To ensure balanced parallel processing, the number of granules is typically much higher than the number of parallel server processes. At any given point in time, a parallel server process is allocated one granule to work on. After a parallel server process completes working on its granule, another granule is allocated until all of the granules are processed and the data is loaded.</p>
<p class="subhead2"><a id="RBIOG240"></a>Recommendations: Preparing Raw Data Files for Source-ETL</p>
<p>Follow these recommendations:</p>
<ul>
<li>
<p>Deliminate each row using a known character such as a new line or a semicolon. This ensures that Oracle can look inside the raw data file and determine where each row of data begins and ends to create multiple granules within a single file.</p>
</li>
<li>
<p>If a file is not position-able and seek-able (for example the file is compressed or zip file), then the files cannot be broken up into granules and the entire file is treated as a single granule. In this case, only one parallel server process can work on the entire file. To parallelize the loading of compressed data files, use multiple compressed data files. The number of compressed data files used determines the maximum parallel degree used by the load.</p>
</li>
<li>
<p>When loading multiple data files (compressed or uncompressed):</p>
<ul>
<li>
<p>Use a single external table, if at all possible</p>
</li>
<li>
<p>Make the files similar in size</p>
</li>
<li>
<p>Make the size of the files a multiple of 10 MB</p>
</li>
</ul>
</li>
<li>
<p>If you must have files of different sizes, list the files from largest to smallest. By default, Oracle assumes that the flat file has the same character set as the database. If this is not the case, specify the character set of the flat file in the external table definition to ensure the proper character set conversions can take place.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BEHDJCEF"></a><a id="RBIOG241"></a>
<div class="sect3">
<h4 class="sect3">Source-ETL Data Loading Options</h4>
<p>Oracle offers several data loading options</p>
<ul>
<li>
<p>External table or SQL*Loader</p>
</li>
<li>
<p>Oracle Data Pump (import and export)</p>
</li>
<li>
<p>Change Data Capture and Trickle feed mechanisms (such as Oracle GoldenGate)</p>
</li>
<li>
<p>Oracle Database Gateways to open systems and mainframes</p>
</li>
<li>
<p>Generic Connectivity (ODBC and JDBC)</p>
</li>
</ul>
<p>The approach that you take depends on the source and format of the data you receive.</p>
<p class="subhead2"><a id="RBIOG242"></a>Recommendations: Loading Flat Files</p>
<p>If you are loading from files into Oracle Database you have two options: SQL*Loader or external tables.</p>
<p>Using external tables offers the following advantages:</p>
<ul>
<li>
<p>Allows transparent parallelization inside the database.You can avoid staging data and apply transformations directly on the file data using arbitrary SQL or PL/SQL constructs when accessing external tables. SQL Loader requires you to load the data as-is into the database first.</p>
</li>
<li>
<p>Parallelizing loads with external tables enables a more efficient space management compared to SQL*Loader, where each individual parallel loader is an independent database sessions with its own transaction. For highly partitioned tables this could potentially lead to a lot of wasted space.</p>
</li>
</ul>
<p>Create an external table using the standard <code>CREATE TABLE</code> statement. However, to load from flat files the statement must include information about where the flat files reside outside the database. The most common approach when loading data from an external table is to issue a <code>CREATE TABLE AS SELECT (CTAS)</code> statement or an <code>INSERT AS SELECT (IAS)</code> statement into an existing table.</p>
</div>
<!-- class="sect3" -->
<a id="BEHJEGJC"></a><a id="RBIOG243"></a>
<div class="sect3">
<h4 class="sect3">Parallel Direct Path Load Source-ETL</h4>
<p><a id="sthref152"></a>A direct path load parses the input data according to the description given in the external table definition, converts the data for each input field to its corresponding Oracle Database data type, then builds a column array structure for the data. These column array structures are used to format Oracle data blocks and build index keys. The newly formatted database blocks are then written directly to the database, bypassing the standard SQL processing engine and the database buffer cache.</p>
<p>The key to good load performance is to use direct path loads wherever possible:</p>
<ul>
<li>
<p>A <code>CREATE TABLE AS SELECT (CTAS)</code> statement always uses direct path load.</p>
</li>
<li>
<p>A simple <code>INSERT AS SELECT (IAS)</code> statement does <span class="italic">not</span> use direct path load. In order to achieve direct path load with an IAS statement you must add the <code>APPEND</code> hint to the command.</p>
</li>
</ul>
<p>Direct path loads can also run in parallel. To set the parallel degree for a direct path load, either:</p>
<ul>
<li>
<p>Add the <code>PARALLEL</code> hint to the CTAS statement or an IAS statement.</p>
</li>
<li>
<p>Set the <code>PARALLEL</code> clause on both the external table and the table into which the data is loaded.</p>
<p>After the parallel degree is set:</p>
<ul>
<li>
<p>A <code>CTAS</code> statement automatically performs a direct path load in parallel.</p>
</li>
<li>
<p>An <code>IAS</code> statement does not automatically perform a direct path load in parallel. To enable an <code>IAS</code> statement to perform direct path load in parallel, you must alter the session to enable parallel DML by executing the following statement.</p>
<pre>
alter session enable parallel DML;
</pre></li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="RBIOG352"></a>
<div class="sect3"><a id="sthref153"></a>
<h4 class="sect3">Partition Exchange Load for Oracle Retail Data Model Source-ETL</h4>
<p><a id="sthref154"></a><a id="sthref155"></a><a id="sthref156"></a>A benefit of partitioning is the ability to load data quickly and easily with minimal impact on the business users by using the <code>EXCHANGE PARTITION</code> command. The <code>EXCHANGE PARTITION</code> command enables swapping the data in a nonpartitioned table into a particular partition in your partitioned table. The <code>EXCHANGE PARTITION</code> command does not physically move data, instead it updates the data dictionary to exchange a pointer from the partition to the table and vice versa.</p>
<p>Because there is no physical movement of data, an exchange does not generate redo and undo. In other words, an exchange is a sub-second operation and far less likely to impact performance than any traditional data-movement approaches such as <code>INSERT</code>.</p>
<p class="subhead2"><a id="RBIOG353"></a>Recommendations: Partitioning Tables</p>
<p>Partition the larger tables and fact tables in the Oracle Retail Data Model warehouse.</p>
<div class="example">
<p class="titleinexample"><a id="RBIOG354"></a><a id="sthref157"></a>Example 4-1 Using Exchange Partition Statement with a Partitioned Table</p>
<p>Assume that there is a large table called <code>Sales</code>, which is range partitioned by day. At the end of each business day, data from the online sales system is loaded into the <code>Sales</code> table in the warehouse.</p>
<p>The following steps ensure the daily data gets loaded into the correct partition with minimal impact to the business users of the data warehouse and optimal speed:</p>
<ol>
<li>
<p>Create external table for the flat file data coming from the online system</p>
</li>
<li>
<p>Using a <code>CTAS</code> statement, create a nonpartitioned table called <code>tmp_sales</code> that has the same column structure as <code>Sales</code> table</p>
</li>
<li>
<p>Build any indexes that are on the <code>Sales</code> table on the <code>tmp_sales</code> table</p>
</li>
<li>
<p>Issue the <code>EXCHANGE PARTITION</code> command.</p>
<pre>
Alter table Sales exchange partition p2 with
    table top_sales including indexes without validation;
</pre></li>
<li>
<p>Gather optimizer statistics on the newly exchanged partition using incremental statistics.</p>
</li>
</ol>
<p>The <code>EXCHANGE PARTITION</code> command in this example, swaps the definitions of the named partition and the <code>tmp_sales</code> table, so the data instantaneously exists in the right place in the partitioned table. Moreover, with the inclusion of the <code>INCLUDING INDEXES</code> and <code>WITHOUT VALIDATION</code> clauses, Oracle swaps index definitions and does not check whether the data actually belongs in the partition - therefore, the exchange is very quick.</p>
</div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
The assumption being made in this example is that the data integrity was verified at date extraction time. If you are unsure about the data integrity, omit the <code>WITHOUT VALIDATION</code> clause so that the Database checks the validity of the data.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEHHEIEE"></a><a id="RBIOG247"></a>
<div class="sect1">
<h2 class="sect1">Customizing Intra-ETL for the Oracle Retail Data Model</h2>
<p>The Oracle Retail Data Model supports the use of ETL tools such as Oracle Warehouse Builder to define the workflow to execute the intra-ETL process. You can, of course, write your own Intra-ETL. However, an intra-ETL component is delivered with Oracle Retail Data Model that is a process flow designed using the Oracle Warehouse Builder Workflow component. This process flow is named <code>ORDM_INTRA_ETL_FLW</code>.</p>
<p>As shown in <a href="#BEHDHEJE">Figure 4-2</a>, the <code>ORDM_INTRA_ETL_FLW</code> process flow uses the data in the Oracle Retail Data Model base, reference, and lookup tables to populate all of the other Oracle Retail Data Model structures. Within this package the dependency of each individual program is implemented and enforced so that each program executes in the proper order.</p>
<div class="figure">
<p class="titleinfigure"><a id="BEHDHEJE"></a><a id="RBIOG1013"></a>Figure 4-2 ORDM Main Intra-ETL Process Flow</p>
<img width="1295" height="575" src="img/rbiog_intra_flow1.png" alt="Description of Figure 4-2 follows" /><br />
<a id="sthref158" href="img_text/rbiog_intra_flow1.htm">Description of "Figure 4-2 ORDM Main Intra-ETL Process Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<p>You can change the original intra-ETL script for your specific requirements. However, perform a complete impact analysis before you make the change. Package the changes as a patch to the original Oracle Retail Data Model intra-ETL mapping.</p>
<p>The <code>ORDM_INTRA_ETL_FLW</code> process flow consists of the following sub-processes and includes the dependency of individual sub-process flows and executes them in the proper order:</p>
<ul>
<li>
<p><a href="#BEHCDEBG">ORDM_DERIVED_FLW</a></p>
</li>
<li>
<p><a href="#BEHEIAIA">ORDM_AGG_N_DEP_FLW</a></p>
</li>
<li>
<p><a href="#BEHHCEIA">ORDM_AGG_DEP_FLW</a></p>
</li>
<li>
<p><a href="#BEHGJAHI">OLAP_MAP Mapping Flow</a></p>
</li>
<li>
<p><a href="#BEHHCJED">ORDM_MNNG_FLW</a></p>
</li>
</ul>
<a id="BEHCDEBG"></a><a id="RBIOG1014"></a>
<div class="sect2">
<h3 class="sect2">ORDM_DERIVED_FLW</h3>
<p>The <code>ORDM_DERIVED_FLW</code> sub-process flow contains all the PL/SQL package code for populating derived tables, based on the content of the base, reference, and lookup tables.</p>
<p><a href="#BEHCGHHB">Figure 4-3</a> shows the <code>ORDM_DERIVED_FLW</code> sub-process flow for populating derived tables.</p>
<div class="figure">
<p class="titleinfigure"><a id="BEHCGHHB"></a><a id="RBIOG1015"></a>Figure 4-3 Intra-ETL Derived Process Flow</p>
<img width="640" height="577" src="img/rbiog_intra_flow2.png" alt="Description of Figure 4-3 follows" /><br />
<a id="sthref159" href="img_text/rbiog_intra_flow2.htm">Description of "Figure 4-3 Intra-ETL Derived Process Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<p>After the <code>ORDM_DERIVED_FLW</code> starts successfully, it moves to the fork. The sub-process FORK performs the derived ETL execution (these run in parallel). For each activity, a record is inserted into a control table and the state is set to <code>RUNNING</code> and the respective ETL is executed. Once ETL execution completes successfully, the control table record that was inserted before ETL execution is updated with <code>COMPLETED-SUCCESS</code> status; otherwise it is updated with <code>COMPLETED-ERROR</code> status.</p>
<p>The AND activity specifies whether all the parallel activities run to completion. Then the flow switches to the next activity, for example <code>END_SUCCESS</code>.</p>
<p>This sub-process uses the following technologies:</p>
<ul>
<li>
<p>Table: Whenever ETL package is executed, data is inserted into a derived table based on the values of ETL parameters in the <code>DWC_ETL_PARAMETER</code> control table.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEHEIAIA"></a><a id="RBIOG1016"></a>
<div class="sect2">
<h3 class="sect2">ORDM_AGG_N_DEP_FLW</h3>
<p>For each activity, the <code>ORDM_AGG_N_DEP_FLW</code> sub-process flow invokes a PL/SQL procedure for refreshing materialized views. The activities in the sub-process flow are all independent, and hence can run in parallel. This sub-process flow has dependency on <code>ORDM_DERIVED_FLW</code> sub-process, that is, <code>ORDM_AGG_N_DEP_FLW</code> is executed only <code>ORDM_DERIVED_FLW</code> is executed successfully.</p>
<p><a href="#BEHDGBEC">Figure 4-4</a> shows the <code>ORDM_AGG_N_DEP_FLW</code> sub-process flow for refreshing all independent materialized views.</p>
<div class="figure">
<p class="titleinfigure"><a id="BEHDGBEC"></a><a id="RBIOG1017"></a>Figure 4-4 Intra-ETL Independent MV Process Flow</p>
<img width="657" height="616" src="img/rbiog_intra_flow_indep.png" alt="Description of Figure 4-4 follows" /><br />
<a id="sthref160" href="img_text/rbiog_intra_flow_indep.htm">Description of "Figure 4-4 Intra-ETL Independent MV Process Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<p>After the <code>ORDM_AGG_N_DEP_FLW</code> is initiated and starts successfully the flow moves to the Fork. The <code>FORK</code> process makes the aggregates run in parallel. The <code>AND</code> activity specifies all the parallel aggregates must complete; the flow then switches over to the next activity, (for example, <code>END_SUCCESS</code>).</p>
<p>This sub-process uses the following technologies:</p>
<ul>
<li>
<p>Materialized View: A materialized view is used to hold the aggregation data. Whenever this is refreshed then the modified data are reflected in the corresponding aggregate table and this leads to a significant increase in the query execution performance. Moreover usage of materialized view allows Oracle Retail Data Model to make use of the Oracle Query Rewrite feature for better SQL optimization and hence improved performance.</p>
</li>
</ul>
<ul>
<li>
<p>FAST Refresh: This refresh type is used to refresh the aggregates with only the incremental data (inserted and modified) in base and derived tables after the immediately previous refresh and this incremental refresh leads to much better performance and hence shorter intra-ETL window.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEHHCEIA"></a><a id="RBIOG1018"></a>
<div class="sect2">
<h3 class="sect2">ORDM_AGG_DEP_FLW</h3>
<p>For each activity, the <code>ORDM_AGG_DEP_FLW</code> sub-process flow invokes a PL/SQL procedure for refreshing materialized views. The activities in the sub-process flow have dependencies. This sub-process flow has dependency on <code>ORDM_DERIVED_FLW</code> sub-process, that is, <code>ORDM_AGG_DEP_FLW</code> is executed only after <code>ORDM_DERIVED_FLW</code> runs successfully.</p>
<p><a href="#BEHEIHEA">Figure 4-5</a> shows the <code>ORDM_AGG_DEP_FLW</code> sub-process flow for refreshing all independent materialized views.</p>
<div class="figure">
<p class="titleinfigure"><a id="BEHEIHEA"></a><a id="RBIOG1019"></a>Figure 4-5 Intra-ETL Aggregate Process Flow</p>
<img width="887" height="489" src="img/rbiog_intra_flow_agg.png" alt="Description of Figure 4-5 follows" /><br />
<a id="sthref161" href="img_text/rbiog_intra_flow_agg.htm">Description of "Figure 4-5 Intra-ETL Aggregate Process Flow"</a><br />
<br /></div>
<!-- class="figure" -->
<p>After the <code>ORDM_AGG_DEP_FLW</code> is initiated and starts successfully the process flow moves to the Fork. The FORK process makes the aggregates to run in parallel. The <code>AND</code> activity specifies all the parallel aggregates must complete, then the flow switches over to the next activity, (for example, <code>END_SUCCESS</code>).</p>
<p>This sub-process uses the following technologies:</p>
<ul>
<li>
<p>Materialized View: A materialized view holds the aggregation data. Whenever this is refreshed then the modified data is reflected in the corresponding aggregate table and this leads to a significant increase in the query execution performance. Moreover usage of materialized view allows Oracle Retail Data Model to make use of the Oracle Query Rewrite feature for better SQL optimization and hence improved performance.</p>
</li>
</ul>
<ul>
<li>
<p>FAST Refresh: This refresh type is used to refresh the aggregates with only the incremental data (inserted and modified) in base and derived tables after the immediately previous refresh and this incremental refresh leads to much better performance and hence shorter intra-ETL window.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BEHGJAHI"></a><a id="RBIOG1039"></a>
<div class="sect2">
<h3 class="sect2">OLAP_MAP Mapping Flow</h3>
<p>The OLAP_MAP mapping invokes <code>PKG_ORDM_OLAP_ETL_AW_LOAD.OLAP_ETL_AW_BUILD</code> function of OLAP ETL package that can load from Oracle Retail Data Model reference and derived tables to Oracle Retail Data Model Analytical Workspace dimensions and cubes respectively and calculate the forecast data. It reads OLAP ETL parameters from <code>DWC_OLAP_ETL_PARAMETER</code> table.</p>
<p><a href="#BEHIEDEA">Figure 4-6</a> shows the OLAP_MAP mapping that invokes the OLAP ETL package.</p>
<div class="figure">
<p class="titleinfigure"><a id="BEHIEDEA"></a><a id="RBIOG1040"></a>Figure 4-6 OLAP Map Process Flow</p>
<img width="604" height="294" src="img/rbiog_intra_flowolap.png" alt="Description of Figure 4-6 follows" /><br />
<a id="sthref162" href="img_text/rbiog_intra_flowolap.htm">Description of "Figure 4-6 OLAP Map Process Flow"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="BEHHCJED"></a><a id="RBIOG1041"></a>
<div class="sect2">
<h3 class="sect2">ORDM_MNNG_FLW</h3>
<p>The mining process flow, ORDM_MNNG_FLW, first refreshes mining source materialized views then refreshes the mining models.</p>
<p><a href="#BEHGEHBE">Figure 4-7</a> shows the mining process flow, ORDM_MNNG_FLW.</p>
<div class="figure">
<p class="titleinfigure"><a id="BEHGEHBE"></a><a id="RBIOG1042"></a>Figure 4-7 Mining Flow Process</p>
<img width="787" height="345" src="img/rbiog_intra_flowmine.png" alt="Description of Figure 4-7 follows" /><br />
<a id="sthref163" href="img_text/rbiog_intra_flowmine.htm">Description of "Figure 4-7 Mining Flow Process"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEHBGBGC"></a><a id="RBIOG249"></a>
<div class="sect1">
<h2 class="sect1">Performing an Initial Load of an Oracle Retail Data Model Warehouse</h2>
<p><a id="sthref164"></a><a id="sthref165"></a>Performing an initial load of an Oracle Retail Data Model is a multistep process:</p>
<ol>
<li>
<p>Load the reference, lookup, and base tables Oracle Retail Data Model warehouse by executing the source-ETL that you have written using the guidelines given in <a href="#BEHFIHBE">"Creating Source-ETL for Oracle Retail Data Model"</a>.</p>
</li>
<li>
<p>Load the remaining structures in the Oracle Retail Data Model, by taking the following steps:</p>
<ol>
<li>
<p>Update the parameters in <code>DWC_ETL_PARAMETER</code> control table in the <code>ordm_sys</code> schema so that the ETL can use this information (that is, the beginning and end date of the ETL period) when loading the derived and aggregate tables and views.</p>
<p>For an initial load of an Oracle Retail Data Model warehouse, specify the values shown in the following table.</p>
<div class="inftblinformal">
<table class="cellalignment2111" summary="Parameter values for DWC_ETL_PARAMETER table" dir="ltr">
<thead>
<tr class="cellalignment2105">
<th class="cellalignment2112" id="r1c1-t7">Columns</th>
<th class="cellalignment2112" id="r1c2-t7">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r2c1-t7" headers="r1c1-t7"><code>PROCESS_NAME</code></td>
<td class="cellalignment2113" headers="r2c1-t7 r1c2-t7"><code>'ORDM-INTRA-ETL'</code></td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r3c1-t7" headers="r1c1-t7"><code>FROM_DATE_ETL</code></td>
<td class="cellalignment2113" headers="r3c1-t7 r1c2-t7">The beginning date of the ETL period.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r4c1-t7" headers="r1c1-t7"><code>TO_DATE_ETL</code></td>
<td class="cellalignment2113" headers="r4c1-t7 r1c2-t7">The ending date of the ETL period.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink RBIRF1003" href="../../doc.112/e20361/control_rdm.htm#RBIRF1003"><span class="italic">Oracle Retail Data Model Reference</span></a> for more information on the <code>DWC_ETL_PARAMETER</code> control table.</div>
</li>
<li>
<p>Update the Oracle Retail Data Model OLAP ETL parameters in <code>DWC_OLAP_ETL_PARAMETER</code> control table in the <code>ordm_sys</code> schema to specify the build method and other build characteristics so that the ETL can use this information when loading the OLAP cube data.</p>
<p>For an initial load of the analytic workspace, specify values following the guidelines in <a href="#BEHFGIAB">Table 4-1</a>.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="RBIOG1020"></a><a id="sthref166"></a><a id="BEHFGIAB"></a>Table 4-1 Explanation of Load Parameters in DWC_OLAP_ETL_PARAMETER Along with (typical) Initial Load Values</p>
<table class="cellalignment2111" title="Explanation of Load Parameters in DWC_OLAP_ETL_PARAMETER Along with (typical) Initial Load Values" summary="initial load values" dir="ltr">
<thead>
<tr class="cellalignment2105">
<th class="cellalignment2112" id="r1c1-t9">Column Name</th>
<th class="cellalignment2112" id="r1c2-t9">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r2c1-t9" headers="r1c1-t9">
<p><code>BUILD_METHOD</code></p>
</td>
<td class="cellalignment2113" headers="r2c1-t9 r1c2-t9">
<p>Use the build method parameter to indicate a full or a fast (partial) refresh. The following are the possible values for BUILD_METHOD:</p>
<ul>
<li>
<p><code>C</code>: Complete refresh clears all dimension values before loading. (Default value).</p>
</li>
<li>
<p><code>F</code>: Fast refresh of a cube materialized view, which performs an incremental refresh and re-aggregation of only changed rows in the source table.</p>
</li>
<li>
<p><code>?</code>: Fast refresh if possible, and otherwise a complete refresh.</p>
</li>
<li>
<p><code>P</code>: Recomputes rows in a cube materialized view that are affected by changed partitions in the detail tables.</p>
</li>
<li>
<p><code>S</code>: Fast solve of a compressed cube. A fast solve reloads all the detail data and re-aggregates only the changed values.</p>
</li>
</ul>
<p>Note:</p>
<p>In a fast refresh, only changed rows are inserted in the cube and the affected areas of the cube are re-aggregated.</p>
<p>The <code>C</code>, <code>S</code>, and <code>?</code> methods always succeed and can be used on any cube.</p>
<p>The <code>F</code> and <code>P</code> methods require that the cube have a materialized view that was created as a fast or a rewrite materialized view.</p>
<p>For initial load, specify <code>C</code> which specifies a complete refresh which clears all dimension values before loading.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r3c1-t9" headers="r1c1-t9">
<p><code>BUILD_METHOD_TYPE</code></p>
</td>
<td class="cellalignment2113" headers="r3c1-t9 r1c2-t9">
<p><code>HISTORICAL</code> or <code>INCREMENTAL</code> indicating whether this is an initial load of OLAP AW or an incremental load of the OLAP AW.</p>
<p>For initial load, specify <code>HISTORICAL</code></p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r4c1-t9" headers="r1c1-t9">
<p><code>CALC_FCST</code></p>
</td>
<td class="cellalignment2113" headers="r4c1-t9 r1c2-t9">
<p>One of the following values depending on whether you calculate forecast cubes:</p>
<ul>
<li>
<p><code>Y</code> specifies calculate forecast cubes.</p>
</li>
<li>
<p><code>N</code> specifies do not calculate forecast cubes.</p>
</li>
</ul>
<p>For initial load, specify <code>Y</code>.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r5c1-t9" headers="r1c1-t9">
<p><code>CUBENAME</code></p>
</td>
<td class="cellalignment2113" headers="r5c1-t9 r1c2-t9">
<p>One of the following values that specifies the cubes you build:</p>
<ul>
<li>
<p><code>ALL</code> specifies a build of the cubes in the Oracle Retail Data Model analytic workspace.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">cubename</span></code>[[<code>|</code><code><span class="codeinlineitalic">cubename</span></code>]...] specifies one or more cubes to build.</p>
</li>
</ul>
<p>For initial load, specify <code>ALL</code>.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r6c1-t9" headers="r1c1-t9">
<p><code>FCST_MTHD</code></p>
</td>
<td class="cellalignment2113" headers="r6c1-t9 r1c2-t9">
<p>If the value for the <code>CALC_FCST</code> column is <code>Y</code>, then specify <code>AUTO</code>; otherwise, specify <code>NULL</code>. Another valid value is <code>MANUAL</code> which sets the forecasting approach to <code>APPMANUAL</code> instead of <code>APPAUTO</code> (<code>APPAUTO</code> and <code>APPMANUAL</code> are internal terms used by Oracle OLAP Forecasting command). This parameter is ignored if <code>CALC_FCST</code> column is <code>N</code>.</p>
<p>For initial load, specify <code>AUTO</code>.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r7c1-t9" headers="r1c1-t9">
<p><code>FCST_ST_MO</code></p>
</td>
<td class="cellalignment2113" headers="r7c1-t9 r1c2-t9">
<p>If the value for the <code>CALC_FCST</code> column is <code>Y</code>, then specify value specified as <code>BY</code> <code><span class="codeinlineitalic">YYYY</span></code> M<code><span class="codeinlineitalic">X</span></code> which is the "end business month" of a historical period; otherwise, specify <code>NULL</code>. This parameter is ignored if <code>CALC_FCST</code> column is <code>N</code>. <code><span class="codeinlineitalic">X</span></code> is month number in a year.</p>
<p>For example:</p>
<p><code>BY 2011 M</code><code>7</code>, or <code>BY 2011 M11</code></p>
<p>For the sample data present in the sample schema installed with Oracle Retail Data Model Sample Reports, for initial load, specify:</p>
<p><code>BY 2012 M1</code></p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r8c1-t9" headers="r1c1-t9">
<p><code>HIST_ST_MO</code></p>
</td>
<td class="cellalignment2113" headers="r8c1-t9 r1c2-t9">
<p>If the value for the <code>CALC_FCST</code> column is <code>Y</code>, then specify value specified as <code>BY</code> <code><span class="codeinlineitalic">YYYY</span></code> <code>M</code><code><span class="codeinlineitalic">X</span></code> which is the "start business month" of historical data; otherwise, specify <code>NULL</code>. This parameter is ignored if <code>CALC_FCST</code> column is <code>N</code>. <code><span class="codeinlineitalic">X</span></code> is the month number in a year.</p>
<p>For example: <code>BY 2011 M7</code>, or <code>BY 2011 M11</code></p>
<p>For the sample data present in the sample schema installed with Oracle Retail Data Model Sample Reports, for initial load, specify:</p>
<p><code>BY 2010 M1</code></p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r9c1-t9" headers="r1c1-t9">
<p><code>MAXJOBQUEUES</code></p>
</td>
<td class="cellalignment2113" headers="r9c1-t9 r1c2-t9">
<p>A decimal value that specifies the number of parallel processes to allocate to this job. (Default value is <code>4</code>.) The value that you specify varies depending on the setting of the <code>JOB_QUEUE_PROCESSES</code> database initialization parameter.</p>
<p>For initial load, specify <code>4</code></p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r10c1-t9" headers="r1c1-t9">
<p><code>NO_FCST_YRS</code></p>
</td>
<td class="cellalignment2113" headers="r10c1-t9 r1c2-t9">
<p>If the value for the <code>CALC_FCST</code> column is <code>Y</code>, specify a decimal value that specifies how many years forecast data to calculate; otherwise, specify <code>NULL</code>. This parameter is ignored if <code>CALC_FCST</code> column is <code>N</code>.</p>
<p>For initial load, specify <code>2</code></p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r11c1-t9" headers="r1c1-t9">
<p><code>OTHER1</code></p>
</td>
<td class="cellalignment2113" headers="r11c1-t9 r1c2-t9">
<p>Not used. Specify NULL.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r12c1-t9" headers="r1c1-t9">
<p><code>OTHER2</code></p>
</td>
<td class="cellalignment2113" headers="r12c1-t9 r1c2-t9">
<p>Not used. Specify NULL.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r13c1-t9" headers="r1c1-t9">
<p><code>PROCESS_NAME</code></p>
</td>
<td class="cellalignment2113" headers="r13c1-t9 r1c2-t9">
<p><code>'ORDM-OLAP-ETL'</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></li>
<li>
<p>Execute the intra-ETL as described in <a href="#BEHFIJIC">"Executing the Default Oracle Retail Data Model Intra-ETL"</a>.</p>
</li>
</ol>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#BEHIEGJH">"Refreshing the Data in Oracle Retail Data Model Warehouse"</a></div>
<a id="BEHFIJIC"></a><a id="RBIOG251"></a>
<div class="sect2">
<h3 class="sect2">Executing the Default Oracle Retail Data Model Intra-ETL</h3>
<p>Oracle Retail Data Model provides you with a database package named PKG_INTRA_ETL_PROCESS that is a complete Intra-ETL process. This intra-ETL process is composed of individual population programs (database packages and MV refresh scripts). This package includes the dependency for each individual program and executes the programs in the proper order.</p>
<p>You can execute the intra-ETL packages provided with Oracle Retail Data Model in the following ways.</p>
<ul>
<li>
<p>As a Workflow within Oracle Warehouse Builder as described in <a href="#BEHFEBHH">"Executing the ORDM_INTRA_ETL_FLW Workflow from Oracle Warehouse Builder"</a>.</p>
</li>
<li>
<p>Without using Oracle Warehouse Builder Workflow as described in <a href="#BEHGEIEG">"Executing the Intra-ETL Without Using Oracle Warehouse Builder"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a href="#BEHDFIBB">"Monitoring the Execution of the Intra-ETL Process"</a>, <a href="#BEHJIAJC">"Recovering an Intra ETL Process"</a>, and <a href="#BEHGFFIB">"Troubleshooting Intra-ETL Performance"</a>.</div>
<a id="BEHFEBHH"></a><a id="RBIOG252"></a>
<div class="sect3">
<h4 class="sect3">Executing the ORDM_INTRA_ETL_FLW Workflow from Oracle Warehouse Builder</h4>
<p>You can execute the <code>ORDM_INTRA_ETL_FLW</code> process from within Oracle Warehouse Builder.</p>
<p class="orderedlisttitle">To deploy the ORDM_INTRA_ETL_FLW process flow, take the following steps:&nbsp;</p>
<ol>
<li>
<p>Confirm that Oracle Warehouse Builder Workflow has been installed as described in <span class="italic">Oracle Retail Data Model Installation Guide</span>.</p>
</li>
<li>
<p>Within Oracle Warehouse Builder, go to the <span class="gui-object-action">Control Center Manager</span>.</p>
</li>
<li>
<p>Select <code>OLAP_PFLW</code>, then select <code>AGR_PFLW</code>, then select the main process flow <code>ORDM_INTRA_ETL_FLW</code>.</p>
</li>
<li>
<p>Right-click <code>ORDM_INTRA_ETL_FLW</code> and select <span class="bold">set action</span>.</p>
<ul>
<li>
<p>If this is the first deployment, set action to <span class="bold">Create</span>.</p>
</li>
<li>
<p>If this is a later deployment, set action to <span class="bold">Replace</span>.</p>
</li>
</ul>
<p>Deploy the process flow.</p>
</li>
</ol>
<p>After the deployment finishes successfully, <code>ORDM_INTRA_ETL_FLW</code> is ready to execute.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<span class="italic">Oracle Warehouse Builder Sources and Targets Guide</span> for information about Oracle Warehouse Builder.</div>
</div>
<!-- class="sect3" -->
<a id="BEHGEIEG"></a><a id="RBIOG542"></a>
<div class="sect3">
<h4 class="sect3">Executing the Intra-ETL Without Using Oracle Warehouse Builder</h4>
<p>You do not have to execute the Intra-ETL as a workflow in Oracle Warehouse Builder. You can, instead, execute it as follows:</p>
<ul>
<li>
<p><a href="#BEHGEABJ">Executing the Intra-ETL by Using the PKG_INTRA_ETL_PROCESS.RUN Procedure</a></p>
</li>
</ul>
<a id="BEHGEABJ"></a><a id="RBIOG543"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Executing the Intra-ETL by Using the PKG_INTRA_ETL_PROCESS.RUN Procedure</h5>
<p>You can use the <code>PKG_INTRA_ETL_PROCESS.RUN</code> procedure to start the Intra-ETL process. This procedure can be invoked manually, or by another process such as Source-ETL, or according to a predefined schedule such as Oracle Job Scheduling.</p>
<p><a id="sthref168"></a>The database package <code>PKG_INTRA_ETL_PROCESS</code> is a complete Intra-ETL process composed of individual population programs (database packages and MV refresh scripts). This package includes dependency for each individual program and executes the programs in the proper order.</p>
<p><code>PKG_INTRA_ETL_PROCESS.RUN</code> does not accept parameters. This procedure calls other programs in the correct order to load the data for current day (according to the Oracle system date). The <code>PKG_INTRA_ETL_PROCESS.RUN</code> procedure uses the <code>DWC_</code> control tables to track the loading progress and results.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEHIEGJH"></a><a id="RBIOG355"></a>
<div class="sect1">
<h2 class="sect1">Refreshing the Data in Oracle Retail Data Model Warehouse</h2>
<p>The section, <a id="sthref169"></a><a id="sthref170"></a><a href="#BEHBGBGC">"Performing an Initial Load of an Oracle Retail Data Model Warehouse"</a> describes how to perform an initial load of an Oracle Retail Data Model data warehouse. After this initial load, you must load new data into your Oracle Retail Data Model data warehouse regularly so that it can serve its purpose of facilitating business analysis.</p>
<p>To load new data into your Oracle Retail Data Model warehouse, you extract the data from one or more operational systems and copy that data into the warehouse. The challenge in data warehouse environments is to integrate, rearrange and consolidate large volumes of data over many systems, thereby providing a new unified information base for business intelligence.</p>
<p>The successive loads and transformations must be scheduled and processed in a specific order that is determined by your business needs. Depending on the success or failure of the operation or parts of it, the result must be tracked and subsequent, alternative processes might be started.</p>
<p>You can do a full incremental load of the relational tables and views, OLAP cubes, and data mining models simultaneously, or you can refresh the data sequentially, as follows:</p>
<ol>
<li>
<p><a href="#BEHFEEGG">Refreshing Oracle Retail Data Model Relational Tables and Views</a></p>
</li>
<li>
<p><a href="#BEHFGDFA">Refreshing Oracle Retail Data Model OLAP Cubes</a></p>
</li>
<li>
<p><a href="#BEHEBIDC">Refreshing Oracle Retail Data Model Data Mining Models</a></p>
</li>
</ol>
<p>In either case, you can manage errors during the execution of the intra-ETL as described in <a href="#BEHGGCGC">"Managing Errors During Oracle Retail Data Model Intra-ETL Execution"</a>.</p>
<a id="BEHFEEGG"></a><a id="RBIOG356"></a>
<div class="sect2">
<h3 class="sect2">Refreshing Oracle Retail Data Model Relational Tables and Views</h3>
<p>Refreshing the relational tables and views in an Oracle Retail Data Model is a multi-step process:</p>
<ol>
<li>
<p>Refresh the reference, lookup, and base tables in the Oracle Retail Data Model warehouse with transactional data by executing the source-ETL that you have written.</p>
</li>
<li>
<p>Update the parameters of the <code>DWC_ETL_PARAMETER</code> control table in the <code>ordm_sys</code> schema. For an incremental load of an Oracle Retail Data Model warehouse, specify the values shown in the following table (that is, the beginning and end date of the ETL period).</p>
<div class="inftblinformal">
<table class="cellalignment2111" summary="Parameter values for DWC_ETL_PARAMETER table" dir="ltr">
<thead>
<tr class="cellalignment2105">
<th class="cellalignment2112" id="r1c1-t13">Columns</th>
<th class="cellalignment2112" id="r1c2-t13">Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r2c1-t13" headers="r1c1-t13"><code>PROCESS_NAME</code></td>
<td class="cellalignment2113" headers="r2c1-t13 r1c2-t13"><code>'ORDM-INTRA-ETL'</code></td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r3c1-t13" headers="r1c1-t13"><code>FROM_DATE_ETL</code></td>
<td class="cellalignment2113" headers="r3c1-t13 r1c2-t13">The beginning date of the ETL period.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r4c1-t13" headers="r1c1-t13"><code>TO_DATE_ETL</code></td>
<td class="cellalignment2113" headers="r4c1-t13 r1c2-t13">The ending date of the ETL period.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink RBIRF1003" href="../../doc.112/e20361/control_rdm.htm#RBIRF1003"><span class="italic">Oracle Retail Data Model Reference</span></a> for more information on the <code>DWC_ETL_PARAMETER</code> control table.</div>
</li>
<li>
<p>Refresh the derived tables and aggregate tables which are materialized views in Oracle Retail Data Model by executing the <code>DRVD_FLOW</code> and <code>AGGR_FLOW</code> subprocess of the <code>ORDM_INTRA_ETL_FLW</code> process flow. See <a href="#BEHFIJIC">"Executing the Default Oracle Retail Data Model Intra-ETL"</a> for more information.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<span class="italic">Oracle Warehouse Builder Sources and Targets Guide</span></div>
</div>
<!-- class="sect2" -->
<a id="BEHFGDFA"></a><a id="RBIOG357"></a>
<div class="sect2">
<h3 class="sect2">Refreshing Oracle Retail Data Model OLAP Cubes</h3>
<p>On a scheduled basis you must update the OLAP cube data with the relational data that has been added to the Oracle Retail Data Model data warehouse since the initial load of the OLAP cubes.</p>
<p>You can execute the Oracle Retail Data Model ETL to update the OLAP cubes in the following ways</p>
<ul>
<li>
<p>Refresh <span class="italic">all</span> of the data in the warehouse by executing the Oracle Warehouse Builder Workflow <code>ORDM_INTRA_ETL_FLW</code> in one of the ways that are described in <a href="#BEHFIJIC">"Executing the Default Oracle Retail Data Model Intra-ETL"</a>.</p>
<p>The OLAP Cubes are populated through <code>OLAP_MAP</code> which is a part of Oracle Retail Data Model intra-ETL main workflow <code>ORDM_INTRA_ETL_FLW</code>.</p>
</li>
<li>
<p>Refresh <span class="italic">only</span> the OLAP cube data by executing the <code>OLAP_MAP</code> Oracle Warehouse Builder mapping in the Oracle Warehouse Builder control center.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must refresh the corresponding materialized view of the OLAP cubes you are refreshing before you execute <code>OLAP_MAP</code>. (For the mapping between OLAP cube and materialized views, refer to <a class="olink RBIRF1128" href="../../doc.112/e20361/physical_rdm.htm#RBIRF1128"><span class="italic">Oracle Retail Data Model Reference</span></a>.</div>
</li>
</ul>
<p>Take these steps to perform an incremental load of the analytic workspace that is part of the Oracle Retail Data Model warehouse:</p>
<ol>
<li>
<p>Update the aggregate tables which are materialized views in Oracle Retail Data Model. See <a href="#BEHFEEGG">"Refreshing Oracle Retail Data Model Relational Tables and Views"</a> for more information.</p>
</li>
<li>
<p>Execute the intra-ETL to load the cube data in one of the ways described in <a href="#BEHFIJIC">"Executing the Default Oracle Retail Data Model Intra-ETL"</a>.</p>
</li>
<li>
<p>If necessary, to recover from errors during the execution of <code>OLAP_MAP</code> take the following steps.</p>
<ol>
<li>
<p>Change the value of the <code>BUILD_METHOD</code> column of the <code>ordm_sys.DWC_OLAP_ETL_PARAMETER</code> table to <code>"C"</code>.</p>
</li>
<li>
<p>In Oracle Warehouse Builder, rerun the <code>OLAP_MAP</code> map.</p>
</li>
</ol>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BEHEBIDC"></a><a id="RBIOG358"></a>
<div class="sect2">
<h3 class="sect2">Refreshing Oracle Retail Data Model Data Mining Models</h3>
<p>The <code>MINING_FLW</code> sub-process flow of the <code>ORDM_INTRA_ETL_FLW</code> process flow triggers the data mining model refreshment. After the initial load of the warehouse, it is recommended to refresh the data mining models monthly. Refreshing the data models is integrated into the <code>MINING_FLW</code> sub-process flow. You can also manually refresh the data models.</p>
<p>The way you refresh a data mining model varies depending on whether you want to refresh all of the models or only one model:</p>
<ul>
<li>
<p>To manually refresh <span class="italic">all</span> mining models, call the following procedure.</p>
<pre>
PKG_ordm_mining.REFRESH_MODEL( MONTH_CODE,P_PROCESS_NO)
</pre>
<p>This procedure performs the following tasks for each model:</p>
<ol>
<li>
<p>Refreshes the mining source materialized views based on the latest data from ordm_sys schema.</p>
</li>
<li>
<p>Trains each model on the new training data.</p>
</li>
<li>
<p>Applies each model onto the new apply data set.</p>
</li>
</ol>
</li>
<li>
<p>To manually re-create only one mining model, you can call the corresponding procedure. For example, to re-create the employee combination model, you can call the following procedure.</p>
<pre>
create_emp_cmbntn_glmr_model;
</pre>
<p><a href="adm.htm#BABGIJBD">"Tutorial: Customizing the Customer Life Time Value Prediction Data Mining Model"</a> provides detailed instructions for refreshing a single data mining model.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#BEHJAHDE">"Troubleshooting Data Mining Model Creation"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BEHGGCGC"></a><a id="RBIOG359"></a>
<div class="sect1">
<h2 class="sect1">Managing Errors During Oracle Retail Data Model Intra-ETL Execution</h2>
<p><a id="sthref171"></a><a id="sthref172"></a>This topic discusses how you can identify and manage errors during intra-ETL execution. It contains the following topics:</p>
<ul>
<li>
<p><a href="#BEHDFIBB">Monitoring the Execution of the Intra-ETL Process</a></p>
</li>
<li>
<p><a href="#BEHJIAJC">Recovering an Intra ETL Process</a></p>
</li>
<li>
<p><a href="#BEHGFFIB">Troubleshooting Intra-ETL Performance</a></p>
</li>
</ul>
<a id="BEHDFIBB"></a><a id="RBIOG360"></a>
<div class="sect2">
<h3 class="sect2">Monitoring the Execution of the Intra-ETL Process</h3>
<p><a id="sthref173"></a>Two <code>ordm_sys</code> schema control tables, <code>DWC_INTRA_ETL_PROCESS</code> and <code>DWC_INTRA_ETL_ACTIVITY</code>, monitor the execution of the intra-ETL process. These tables are documented in <a class="olink RBIRF1002" href="../../doc.112/e20361/control_rdm.htm#RBIRF1002"><span class="italic">Oracle Retail Data Model Reference</span></a>.</p>
<p>Each normal run (as opposed to an error-recovery run) of a separate intra-ETL execution performs the following steps:</p>
<ol>
<li>
<p>Inserts a record into the <code>DWC_INTRA_ETL_PROCESS</code> table with a monotonically increasing system generated unique process key, <code>SYSDATE</code> as process start time, <code>RUNNING</code> as the process status, and an input date range in the <code>FROM_DATE_ETL</code> and <code>TO_DATE_ETL</code> columns.</p>
</li>
<li>
<p>Invokes each of the individual intra-ETL programs in the appropriate order of dependency. Before the invocation of each program, the procedure inserts a record into the intra-ETL Activity detail table, <code>DWC_INTRA_ETL_ACTIVITY</code>, with values for:</p>
<ul>
<li>
<p><code>ACTIVITY_KEY</code>, a system generated unique activity key.</p>
</li>
<li>
<p><code>PROCESS_KEY</code>, the process key value corresponding to the intra-ETL process.</p>
</li>
<li>
<p><code>ACTIVITY_NAME</code>, an individual program name.</p>
</li>
<li>
<p><code>ACTIVITY_DESC</code>, a suitable activity description.</p>
</li>
<li>
<p><code>ACTIVITY_START_TIME</code>, the value of <code>SYSDATE</code>.</p>
</li>
<li>
<p><code>ACTIVITY_STATUS</code>, the value of <code>RUNNING</code>.</p>
</li>
</ul>
</li>
<li>
<p>Updates the corresponding record in the <code>DWC_INTRA_ETL_ACTIVITY</code> table for the activity end time and activity status after the completion of each individual ETL program (either successfully or with errors). For successful completion of the activity, the procedure updates the status as <code>'COMPLETED-SUCCESS'</code>. When an error occurs, the procedure updates the activity status as <code>'COMPLETED-ERROR'</code>, and also updates the corresponding error detail in the <code>ERROR_DTL</code> column.</p>
</li>
<li>
<p>Updates the record corresponding to the process in the <code>DWC_INTRA_ETL_ PROCESS</code> table for the process end time and status, after the completion of all individual intra-ETL programs. When all the individual programs succeed, the procedure updates the status to <code>'COMPLETED-SUCCESS'</code>, otherwise it updates the status to <code>'COMPLETED-ERROR'</code>.</p>
</li>
</ol>
<p>You can monitor the execution state of the intra-ETL, including current process progress, time taken by individual programs, or the complete process, by viewing the contents of the <code>DWC_INTRA_ETL_PROCESS</code> and <code>DWC_INTRA_ETL_ACTIVITY</code> tables corresponding to the maximum process key. Monitoring can be done both during and after the execution of the intra-ETL procedure.</p>
</div>
<!-- class="sect2" -->
<a id="BEHJIAJC"></a><a id="RBIOG361"></a>
<div class="sect2">
<h3 class="sect2">Recovering an Intra ETL Process</h3>
<p><a id="sthref174"></a>To recover an intra-ETL process</p>
<ol>
<li>
<p>Identify the errors by looking at the corresponding error details that are tracked against the individual programs in the <code>DWC_INTRA_ETL_ACTIVITY</code> table.</p>
</li>
<li>
<p>Correct the causes of the errors.</p>
</li>
<li>
<p>Re-invoke the intra-ETL process.</p>
</li>
</ol>
<p>The <code>ORDM_INTRA_ETL_FLW</code> process identifies whether it is a normal run or recovery run by referring the <code>DWC_INTRA_ETL_ACTIVITY</code> table. During a recovery run, <code>ORDM_INTRA_ETL_FLW</code> executes only the necessary programs. For example, in the case of a derived population error as a part of the previous run, this recovery run executes the individual derived population programs which produced errors in the previous run. After their successful completion, the run executes the aggregate population programs and materialized view refresh in the appropriate order.</p>
<p>In this way, the intra-ETL error recovery is almost transparent, without involving the data warehouse or ETL administrator. The administrator must only correct the causes of the errors and re-invoke the intra-ETL process. The intra-ETL process identifies and executes the programs that generated errors.</p>
</div>
<!-- class="sect2" -->
<a id="BEHGFFIB"></a><a id="RBIOG362"></a>
<div class="sect2">
<h3 class="sect2">Troubleshooting Intra-ETL Performance</h3>
<p><a id="sthref175"></a>To troubleshoot the performance of the intra-ETL:</p>
<ul>
<li>
<p>Check the execution plan as described in <a href="#BEHEEHIC">"Checking the Execution Plan"</a>.</p>
</li>
<li>
<p>Monitor parallel DML executions as described in <a href="#BEHFCFCJ">"Monitoring PARALLEL DML Executions"</a>.</p>
</li>
<li>
<p>Check that data mining models were created correctly as described in <a href="#BEHJAHDE">"Troubleshooting Data Mining Model Creation"</a>.</p>
</li>
</ul>
<a id="BEHEEHIC"></a><a id="RBIOG363"></a>
<div class="sect3">
<h4 class="sect3">Checking the Execution Plan</h4>
<p>Use SQLDeveloper or other tools to view the package body of the code generated by Oracle Warehouse Builder.</p>
<p>For example, take the following steps to examine a map:</p>
<ol>
<li>
<p>Copy out the main query statement from code viewer.</p>
<p>Copy from <code>"CURSOR "AGGREGATOR_c" IS &hellip;."</code> to end of the query, which is right above another <code>"CURSOR "AGGREGATOR_c$1" IS"</code>.</p>
</li>
<li>
<p>In SQLDeveloper worksheet, issue the following statement to turn on the parallel DML:</p>
<pre>
Alter session enable parallel dml;
</pre></li>
<li>
<p>Paste the main query statement into another SQL Developer worksheet and view the execution plan by clicking <code>F6</code>.</p>
<p>Carefully examine the execution plan to make the mapping runs according to a valid plan.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="BEHFCFCJ"></a><a id="RBIOG364"></a>
<div class="sect3">
<h4 class="sect3">Monitoring PARALLEL DML Executions</h4>
<p>Check that you run the mapping in parallel mode by executing the following SQL statement to count the executed "Parallel DML/Query" operations:</p>
<pre>
column name format a50
column value format 999,999
SELECT NAME, VALUE 
FROM GV$SYSSTAT
WHERE UPPER (NAME) LIKE '%PARALLEL OPERATIONS%'
  OR UPPER (NAME) LIKE '%PARALLELIZED%'
  OR UPPER (NAME) LIKE '%PX%'
;
</pre>
<p>If you run mapping in parallel mode, you should see "DML statements parallelized" increased by 1 (one) every time the mapping was invoked. If not, you do not see this increase, then the mapping was not invoked as "parallel DML".</p>
<p>If you see "queries parallelized" increased by 1 (one) instead, then typically it means that the <code>SELECT</code> statement inside of the <code>INSERT</code> was parallelized, but that <code>INSERT</code> itself was not parallelized.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="pdm.htm#CHDEFFJH">"Parallel Execution in Oracle Retail Data Model"</a></div>
</div>
<!-- class="sect3" -->
<a id="BEHJAHDE"></a><a id="RBIOG365"></a>
<div class="sect3">
<h4 class="sect3">Troubleshooting Data Mining Model Creation</h4>
<p>After the data mining models are created, check the error log in <code>ordm_sys.dwc_intra_etl_activity</code> table. For example, execute the following code.</p>
<pre>
set line 160
col ACTIVITY_NAME format a30
col ACTIVITY_STATUS format a20
col error_dtl format a80
select activity_name, activity_status,  error_dtl from dwc_intra_etl_activity;
</pre>
<p>If all models are created successfully, the activity_status is all <code>"COMPLETED-SUCCESS"</code>. If the activity_status is <code>"COMPLETED-ERROR"</code> for a certain step, check the ERROR_DTL column, and fix the problem accordingly.</p>
<p>The following examples illustrate how to troubleshoot some common error messages returned in <code>ERROR_DTL</code> and <code>ACTIVITY_NAME</code> when working with Oracle Retail Data Model:</p>
<ul>
<li>
<p><a href="#BEHFCDGJ">Example 4-2, "Troubleshooting an ORA-20991 Error for Oracle Retail Data Model"</a></p>
</li>
<li>
<p><a href="#BEHGIJEC">Example 4-3, "Troubleshooting the "Message not available ... [Language=ZHS]" Error"</a></p>
</li>
<li>
<p><a href="#BEHHBJJH">Example 4-4, "Troubleshooting an ORA-40113 Error for Oracle Retail Data Model"</a></p>
</li>
<li>
<p><a href="#BEHBCAEF">Example 4-5, "Troubleshooting an ORA-40112 Error for Oracle Retail Data Model"</a></p>
</li>
<li>
<p><a href="#BEHIHAJF">Example 4-6, "Troubleshooting an ORG-11130 Error for Oracle Retail Data Model"</a></p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="BEHFCDGJ"></a><a id="RBIOG366"></a>Example 4-2 Troubleshooting an ORA-20991 Error for Oracle Retail Data Model</p>
<p>Assume that the returned error is <code>ORA-20991: Message not available ... [Language=ZHS]CURRENT_MONTH_KEY</code>.</p>
<p>This error may happen when there is not enough data in the <code>DWR_BSNS_MO</code> table. For example, if the calendar data is populated with 2004~2009 data, the mining model refresh for Year 2010 may result in this error.</p>
<p>To fix this error, execute the Oracle Retail Data Model calendar utility script again to populate the calendar with sufficient data. For example:</p>
<pre>
Execute Calendar_Population.run('2005-01-01',10);
</pre>
<p>See <a class="olink RBIRF994" href="../../doc.112/e20361/utility_scripts_rdm.htm#RBIRF994"><span class="italic">Oracle Retail Data Model Reference</span></a> for information on the calendar population utility script.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEHGIJEC"></a><a id="RBIOG367"></a>Example 4-3 Troubleshooting the "Message not available ... [Language=ZHS]" Error</p>
<p>Assume that the returned error is <code>Message not available ... [Language=ZHS]</code>.</p>
<p>'ZHS' is a code for a language. The language name it relates to can appear as different name depending on the database environment. This error happens when <code>ordm_sys.DWC_MESSAGE.LANGUAGE</code> does not contain messages for the current language.</p>
<p>Check the values in the <code>DWC_MESSAGE</code> table and, if required, update to the language code specified by the Oracle session variable <code>USERENV('lang')</code>.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEHHBJJH"></a><a id="RBIOG368"></a>Example 4-4 Troubleshooting an ORA-40113 Error for Oracle Retail Data Model</p>
<p>Assume that the returned error is <code>ORA-40113: insufficient number of distinct target values, for 'create_chrn_dt_model</code>.</p>
<p>This error happens when the target column for the training model contains only one value or no value when it is expecting more than one value.</p>
<p>For example, for the customer churn prediction model, the target column is: <code>dmv_cust_acct_src.chrn_ind</code></p>
<p>To troubleshoot this error:</p>
<ol>
<li>
<p>Execute a SQL query to check if there are enough values in this column.</p>
<p>Using the customer churn prediction model as an example, issue the following statement.</p>
<pre>
select chrn_ind, count(*) from DMV_CUST_ACCT_SRC  group by chrn_ind;
</pre>
<p>The following is a result of the query.</p>
<pre>
CHRN_IND   COUNT(*)
-- -----------
0         10000

</pre></li>
<li>
<p>Check whether <code>dwr_cust.prmry_eff_to_dt</code> column has few non-null values.</p>
</li>
<li>
<p>Execute the following statement to refresh the mining source materialized views:</p>
<pre>
exec pkg_ordm_mining.refresh_mining_source;
</pre></li>
</ol>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEHBCAEF"></a><a id="RBIOG369"></a>Example 4-5 Troubleshooting an ORA-40112 Error for Oracle Retail Data Model</p>
<p>Assume that the returned error is:</p>
<pre>
ORA-40112:insufficient number of valid data rows, for " create_chrn_dt_model "
</pre>
<p>For this model, the target column is <code>dmv_cust_acct_src.chrn_ind</code>.</p>
<p>To troubleshoot this error:</p>
<ol>
<li>
<p>Execute the following SQL statement:</p>
<pre>
select count(chrn_ind) from dmv_cust_acct_src;
</pre></li>
<li>
<p>Check to see that the value returned by this query is greater than 0 (zero) and similar to number of customers. If the number is 0 or too small, check the data in source tables of mining source materialized view, <code>dmv_cust_acct_src</code> :</p>
<pre>
DWB_RTL_TRX
DWR_CUST
</pre></li>
</ol>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="BEHIHAJF"></a><a id="RBIOG370"></a>Example 4-6 Troubleshooting an ORG-11130 Error for Oracle Retail Data Model</p>
<p>Assume that the returned error is <code>ORG-11130:no data found in the collection, for "create_sentiment_svm_model"</code>.</p>
<p>This error occurs when there is not enough data in the source table for customer sentiment model training: <code>dm_cust_cmnt</code> .</p>
<p>To ensure that some text is loaded for customer sentiment analysis:</p>
<ol>
<li>
<p>Issue the following SQL statement:</p>
<pre>
SELECT cust_key, count(cust_cmmnt)
from dm_cust_cmnt
group by cust_key;
</pre></li>
<li>
<p>Check the number of text comments from the <code>dm_cust_cmnt</code>.</p>
</li>
<li>
<p>If there is not enough data in the dm_cust_cmnt table, check the ETL logic of <code>dm_cust_intrqacn_cmnt</code> table first, then check data in the base interaction event tables.</p>
</li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2104">
<tr>
<td class="cellalignment2113">
<table class="cellalignment2109">
<tr>
<td class="cellalignment2108"><a href="adm.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2108"><a href="rep_quer.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2116">
<table class="cellalignment2107">
<tr>
<td class="cellalignment2108"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2108"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2108"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2108"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2108"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2108"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
