<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Physical Model Customization</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 710" />
<meta name="dcterms.created" content="2013-01-30T11:7:35Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Retail Data Model Implementation and Operations Guide" />
<meta name="dcterms.identifier" content="E20363-03" />
<meta name="dcterms.isVersionOf" content="RBIOG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="impintro.htm" title="Previous" type="text/html" />
<link rel="Next" href="adm.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e20363.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/14</span> <!-- End Header --><a id="CHDFIAJJ"></a><a id="RBIOG147"></a>
<h1 class="chapter"><span class="secnum">2</span> Physical Model Customization</h1>
<p><a id="sthref34"></a>This chapter provides general information about customizing the physical model of Oracle Retail Data Model and more detailed information about customizing the foundation layer of the physical model. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDCJJCJ">Characteristics of the Default Physical Model</a></p>
</li>
<li>
<p><a href="#CHDFEDEF">Customizing the Oracle Retail Data Model Physical Model</a></p>
</li>
<li>
<p><a href="#CHDDJFDJ">Foundation Layer Customization</a></p>
</li>
<li>
<p><a href="#CHDDFHCA">General Recommendations When Designing Physical Structures</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="adm.htm#CHDDHGHC">Chapter 3, "Access Layer Customization"</a></div>
<a id="CHDCJJCJ"></a><a id="RBIOG148"></a>
<div class="sect1">
<h2 class="sect1">Characteristics of the Default Physical Model</h2>
<p><a id="sthref35"></a><a id="sthref36"></a>The default physical model of Oracle Retail Data Model defines:</p>
<ul>
<li>
<p>Over 1,250 tables and 18,500 attributes</p>
</li>
<li>
<p>Over 1,800 industry measures and KPIs</p>
</li>
<li>
<p>12 pre-built data mining models</p>
</li>
<li>
<p>30 OLAP dimensions and 28 pre-built OLAP cubes</p>
</li>
</ul>
<p>The default physical model of Oracle Retail Data Model shares characteristics of a multischema "traditional" data warehouse, as described in <a href="#CHDDDDDD">"Layers in a "Traditional" Data Warehouse"</a>, but defines all data structures in a single schema as described in <a href="#CHDIJHEF">"Layers in the Default Oracle Retail Data Model Warehouse"</a>.</p>
<p class="subhead2"><a id="CHDDDDDD"></a><a id="RBIOG149"></a>Layers in a "Traditional" Data Warehouse</p>
<p><a id="sthref37"></a>Historically, three layers are defined for a data warehouse environment:</p>
<ul>
<li>
<p><span class="bold">Staging layer.</span> This layer is used when moving data from the transactional system and other data sources into the data warehouse itself. It consists of temporary loading structures and rejected data. Having a staging layer enables the speedy extraction, transformation and loading (ETL) of data from your operational systems into data warehouse without disturbing any of the business users. It is in this layer the much of the complex data transformation and data quality processing occurs. The most basic approach for the design of the staging layer is as a schema identical to the one that exists in the source operational system.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In some implementations this layer is not necessary, because all data transformation processing is done "on the fly" as data is extracted from the source system before it is inserted directly into the foundation layer.</div>
</li>
<li>
<p><a id="sthref38"></a><span class="bold">Foundation or integration layer.</span> This layer is traditionally implemented as a Third Normal Form (3NF) schema. A 3NF schema is a neutral schema design independent of any application, and typically has a large number of tables. It preserves a detailed record of each transaction without any data redundancy and allows for rich encoding of attributes and all relationships between data elements. Users typically require a solid understanding of the data to navigate the more elaborate structure reliably. In this layer data begins to take shape and it is not uncommon to have some end-user application access data from this layer especially if they are time sensitive, as data becomes available here before it is transformed into the Access and Performance layer.</p>
</li>
<li>
<p><a id="sthref39"></a><span class="bold">Access layer.</span> This layer is traditionally defined as a snowflake or star schema that describes a "flattened" or dimensional view of the data.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDIJHEF"></a><a id="RBIOG150"></a>Layers in the Default Oracle Retail Data Model Warehouse</p>
<p><a id="sthref40"></a>Oracle Retail Data Model warehouse environment also consists of three layers, as shown in <a href="#BABCEHEI">Figure 2-1</a>. Note, in the Oracle Retail Data Model the definitions of the foundation and access layers are combined in a single schema.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABCEHEI"></a><a id="RBIOG1095"></a>Figure 2-1 Layers of an Oracle Retail Data Model Warehouse</p>
<img width="564" height="316" src="img/rbiog_players.png" alt="Description of Figure 2-1 follows" /><br />
<a id="sthref41" href="img_text/rbiog_players.htm">Description of "Figure 2-1 Layers of an Oracle Retail Data Model Warehouse"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The layers in the Oracle Retail Data Model warehouse are:</p>
<ul>
<li>
<p><span class="bold"><a id="sthref42"></a><a id="sthref43"></a>Staging layer</span>. As in a "traditional" data warehouse environment, an Oracle Retail Data Model warehouse environment can have a staging layer. See the <a class="olink RBIRN107" href="../../doc.112/e20364/index.html#RBIRN107"><span class="italic">Oracle Retail Data Model Release Notes</span></a> for more details on the staging layer.</p>
</li>
<li>
<p><span class="bold">Foundation and Access layers.</span> The physical objects for these layers are defined in a single schema, the <code>ordm_sys</code> schema:</p>
<ul>
<li>
<p><a id="sthref44"></a><a id="sthref45"></a><span class="bold">Foundation layer.</span> The foundation layer of the Oracle Retail Data Model is defined by base (<code>DWB_</code>) and Reference (<code>DWR</code>_) tables that present the data in 3NF; this layer also includes the lookup and control tables defined in the <code>ordm_sys</code> schema (that is, the tables that have the <code>DWL_</code> and <code>DWC_</code> prefixes).</p>
</li>
<li>
<p><a id="sthref46"></a><a id="sthref47"></a><span class="bold">Access layer.</span> The Access layer of Oracle Retail Data Model is defined by derived and aggregate tables (defined with <code>DWD_</code> and <code>DWA_</code> prefixes), cubes (defined with a <code>CB$</code> prefix), and views (that is, views defined with the <code>_VIEW</code> suffix). These structures provide a summarized or "flattened" perspective of the data in the foundation layer.</p>
<p>This layer also contains the results of the data mining models which are stored in derived (<code>DWD_</code>) tables.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink RBIRF480" href="../../doc.112/e20361/physical_rdm.htm#RBIRF480"><span class="italic">Oracle Retail Data Model Reference</span></a> for detailed information on the <code>ordm_sys</code> schema.</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDFEDEF"></a><a id="RBIOG152"></a>
<div class="sect1">
<h2 class="sect1">Customizing the Oracle Retail Data Model Physical Model</h2>
<p><a id="sthref48"></a><a id="sthref49"></a>The starting point for the Oracle Retail Data Model physical data model is the 3NF logical data model. The physical data model mirrors the logical model as much as possible, although some changes in the structure of the tables or columns may be necessary, and defines database objects (such as tables, cubes, and views).</p>
<p>To customize the default physical model of Oracle Retail Data Model take the following steps:</p>
<ol>
<li>
<p>Answer the questions outlined in <a href="#CHDFDDGD">"Questions to Answer Before You Customize the Physical Model"</a>.</p>
</li>
<li>
<p>Familiarize yourself with the characteristics of the logical and physical model of Oracle Retail Data Model as outlined in<a href="#CHDCJJCJ">"Characteristics of the Default Physical Model"</a> and presented in detail in <a class="olink RBIRF112" href="../../doc.112/e20361/intro_rdm.htm#RBIRF112"><span class="italic">Oracle Retail Data Model Reference</span></a>.</p>
</li>
<li>
<p>Modify the foundation level of your physical model of Oracle Retail Data Model, as needed. See <a href="#CHDHEHDA">"Common Change Scenarios When Customizing the Foundation Layer of Oracle Retail Data Model"</a> for a discussion of when customization might be necessary.</p>
<p>When defining physical structures:</p>
<ul>
<li>
<p>Keep the foundation layer in 3NF form.</p>
</li>
<li>
<p>Use the information presented in <a href="#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a> to guide you when designing the physical objects.</p>
</li>
<li>
<p>Follow the conventions used when creating the default physical model of Oracle Retail Data Model as outlined in <a href="#CHDFGAAG">"Conventions When Customizing the Physical Model"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Package the changes you make to the physical data model as a patch to the <code>ordm_sys</code> schema.</div>
</li>
<li>
<p>Modify the access layer of your physical model of Oracle Retail Data Model as discussed in <a href="adm.htm#CHDDHGHC">Chapter 3, "Access Layer Customization"</a>.</p>
</li>
</ol>
<a id="CHDFDDGD"></a><a id="RBIOG153"></a>
<div class="sect2">
<h3 class="sect2">Questions to Answer Before You Customize the Physical Model</h3>
<p><a id="sthref50"></a><a id="sthref51"></a>When designing the physical model, remember that the logical data model is not one-to-one with the physical data model. Consider the load, query, and maintenance requirements when you are designing the physical model customizations. For example, answer the following questions before you design the physical data model:</p>
<ul>
<li>
<p>Identify the scope of the changes. See <a href="#CHDHEHDA">"Common Change Scenarios When Customizing the Foundation Layer of Oracle Retail Data Model"</a> for an overview discussion of making physical data model changes when your business needs do not result in a logical model that is the same as the Oracle Retail Data Model logical model.</p>
</li>
<li>
<p>What is the result of the source data profile?</p>
</li>
<li>
<p>What is the data load frequency for each table?</p>
</li>
<li>
<p>How many large tables are there and which tables are these?</p>
</li>
<li>
<p>How will the tables and columns be accessed? What are the common joins?</p>
</li>
<li>
<p>What is your data backup strategy?</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFGAAG"></a><a id="RBIOG154"></a>
<div class="sect2">
<h3 class="sect2">Conventions When Customizing the Physical Model</h3>
<p><a id="sthref52"></a><a id="sthref53"></a><a id="sthref54"></a>When developing the physical model for Oracle Retail Data Model, the following conventions were used. Continue to follow these conventions as you customize the physical model.</p>
<p class="subhead2"><a id="CHDDEGEF"></a><a id="RBIOG155"></a>General Naming Conventions for Physical Objects</p>
<p><a id="sthref55"></a>Follow these guidelines for naming physical objects that you define:</p>
<ul>
<li>
<p>When naming the physical objects follow the naming guidelines for naming objects within an Oracle Database schema. For example:</p>
<ul>
<li>
<p>Table and column names must start with a letter, can use only 30 alphanumeric characters or less, cannot contain spaces or some special characters such as "!" and cannot use reserved words.</p>
</li>
<li>
<p>Table names must be unique within a schema that is shared with views and synonyms.</p>
</li>
<li>
<p>Column names must be unique within a table.</p>
</li>
</ul>
</li>
<li>
<p>Although it is common to use abbreviations in the physical modeling stage, as much as possible, use names for the physical objects that correspond to the names of the entities in the logical model. Use consistent abbreviations to avoid programmer and user confusion.</p>
</li>
<li>
<p>When naming columns, use short names if possible. Short column names reduce the time required for SQL command parsing.</p>
</li>
<li>
<p>The <code>ordm_sys</code> schema delivered with Oracle Retail Data Model uses the prefixes and suffixes shown in the following table to identify object types.</p>
<div class="inftblinformal">
<table class="cellalignment2111" summary="Prefixes and suffixes used when naming objects" dir="ltr">
<thead>
<tr class="cellalignment2105">
<th class="cellalignment2112" id="r1c1-t6">Prefix or Suffix</th>
<th class="cellalignment2112" id="r1c2-t6">Used for Name of These Objects</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r2c1-t6" headers="r1c1-t6"><code>CB$</code></td>
<td class="cellalignment2113" headers="r2c1-t6 r1c2-t6">Materialized view used to support/deliver required functionality for an Oracle OLAP cube. This is an internal object built and maintained automatically by the Oracle OLAP server in the database.
<p><span class="bold">Note:</span> Do not report or query against this object. Instead access the corresponding <code>_VIEW</code> object.</p>
</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r3c1-t6" headers="r1c1-t6"><code>DMV_</code></td>
<td class="cellalignment2113" headers="r3c1-t6 r1c2-t6">Materialized view created for performance reasons (that is, <span class="italic">not</span> an aggregate table or an OLAP cube).</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r4c1-t6" headers="r1c1-t6"><code>DWA_</code></td>
<td class="cellalignment2113" headers="r4c1-t6 r1c2-t6">Aggregate tables or relational materialized views (aggregate objects)</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r5c1-t6" headers="r1c1-t6"><code>DWB_</code></td>
<td class="cellalignment2113" headers="r5c1-t6 r1c2-t6">Base transaction data (3NF) tables.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r6c1-t6" headers="r1c1-t6"><code>DWC_</code></td>
<td class="cellalignment2113" headers="r6c1-t6 r1c2-t6">Control tables.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r7c1-t6" headers="r1c1-t6"><code>DWD_</code></td>
<td class="cellalignment2113" headers="r7c1-t6 r1c2-t6">Derived tables -- including data mining result tables.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r8c1-t6" headers="r1c1-t6"><code>DWL_</code></td>
<td class="cellalignment2113" headers="r8c1-t6 r1c2-t6">Lookup tables.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r9c1-t6" headers="r1c1-t6"><code>DWV_</code></td>
<td class="cellalignment2113" headers="r9c1-t6 r1c2-t6">Relational view of time dimension</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r10c1-t6" headers="r1c1-t6"><code>DWR_</code></td>
<td class="cellalignment2113" headers="r10c1-t6 r1c2-t6">Reference data tables.</td>
</tr>
<tr class="cellalignment2105">
<td class="cellalignment2113" id="r11c1-t6" headers="r1c1-t6"><code>_VIEW</code></td>
<td class="cellalignment2113" headers="r11c1-t6 r1c2-t6">A relational view of an OLAP cube, dimension, or hierarchy.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
You should use a similar prefix and suffix, combined with an indicator for your company or project name for any new tables, views, and cubes that you define during customization. For example, if your customization project chooses a standard prefix of '<code>AZ</code>', then new base tables would be created with the prefix '<code>AZB_</code>', new reference tables would use the prefix '<code>AZR_</code>'.</div>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink RBIRF112" href="../../doc.112/e20361/intro_rdm.htm#RBIRF112"><span class="italic">Oracle Retail Data Model Reference</span></a> for detailed information about the objects in the default Oracle Retail Data Model.</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDJFDJ"></a><a id="RBIOG327"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Foundation Layer Customization</h2>
<p>The first step in customizing the physical model of Oracle Retail Data Model is customizing the foundation layer of the physical data model. Since, as mentioned in <a href="#CHDIJHEF">"Layers in the Default Oracle Retail Data Model Warehouse"</a>, the foundation layer of the physical model mirrors the 3NF logical model of Oracle Retail Data Model, you might choose to customize the foundation layer to reflect differences between your logical model needs and the default logical model of Oracle Retail Data Model. Additionally, you might need to customize the physical objects in the foundation layer to improve performance (for example, you might choose to compress some foundation layer tables).</p>
<p>When making changes to the foundation layer, keep the following points in mind:</p>
<ul>
<li>
<p>When changing the foundation layer objects to reflect your logical model design, make as few changes as possible. <a href="#CHDHEHDA">"Common Change Scenarios When Customizing the Foundation Layer of Oracle Retail Data Model"</a> outlines the most common customization changes you will make in this regard.</p>
</li>
<li>
<p>When defining new foundation layer objects or when redesigning existing foundation layer objects for improved performance, follow the <a href="#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a> and <a href="#CHDFGAAG">"Conventions When Customizing the Physical Model"</a>.</p>
</li>
<li>
<p>Remember that changes to the foundation layer objects can also impact the access layer objects.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Approach any attempt to change the Oracle Retail Data Model with caution. The foundation layer of the physical model of Oracle Retail Data Model has (at its core) a set of generic structures that allow it to be flexible and extensible. Before making extensive additions, deletions, or changes, ensure that you understand the full range of capabilities of Oracle Retail Data Model and that you cannot handle your requirements using the default objects in the foundation layer.</div>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CACFJEEC">"Example of Changing the Foundation Layer of the Oracle Retail Data Model"</a></div>
<a id="CHDHEHDA"></a><a id="RBIOG328"></a>
<div class="sect2">
<h3 class="sect2">Common Change Scenarios When Customizing the Foundation Layer of Oracle Retail Data Model</h3>
<p><a id="sthref56"></a>There are several common change scenarios when customizing the foundation layer of the physical data model:</p>
<ul>
<li>
<p><span class="bold">Additions to Existing Structures</span></p>
<p>If you identify business areas or processes that are not supported in the default foundation layer of the physical data model of Oracle Retail Data Model, add new tables and columns.</p>
<p>Carefully study the default foundation layer of the physical data model of Oracle Retail Data Model (and the underlying logical data model) to avoid building redundant structures when making additions. If these additions add high value to your business value, communicate the additions back to the Oracle Retail Data Model Development Team for possible inclusion in future releases of Oracle Retail Data Model.</p>
</li>
<li>
<p><span class="bold">Deletions of Existing Structures</span></p>
<p>If there are areas of the model that cannot be matched to any of the business requirements of your legacy systems, it is safer to keep these structures and not populate that part of the warehouse.</p>
<p>Deleting a table in the foundation layer of the physical data model can destroy relationships needed in other parts of the model or by applications based on the it. Some tables may not be needed during the initial implementation, but you may want to use these structures at a later time. If this is a possibility, keeping the structures now saves re-work later. If tables are deleted, perform a thorough analysis to identify all relationships originating from that entity.</p>
</li>
<li>
<p><span class="bold">Changes to Existing Structures</span></p>
<p>In some situations some structures in the foundation layer of the physical data model of Oracle Retail Data Model may not exactly match the corresponding structures that you use. Before implementing changes, identify the impact that the changes would have on the database design of Oracle Retail Data Model. Also identify the impact on any applications based on the new design.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CACFJEEC">"Example of Changing the Foundation Layer of the Oracle Retail Data Model"</a></div>
</div>
<!-- class="sect2" -->
<a id="CACFJEEC"></a><a id="RBIOG347"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Example of Changing the Foundation Layer of the Oracle Retail Data Model</h3>
<p>As an example, let's examine how Oracle Retail Data Model supports the various retail services, what you might discover during fit-gap analysis, and how you might extend Oracle Retail Data Model to fit the discovered gaps.</p>
<p class="subhead2"><a id="RBIOG1043"></a>Entities supporting Retail services</p>
<p>The entities provided with the logical model of Oracle Retail Data Model that support the retail services are:</p>
<ul>
<li>
<p><span class="bold">Customer</span>: An individual or organization that purchases, may purchase, or did purchase goods and or services from a store.</p>
</li>
<li>
<p><span class="bold">Customer Order</span>: The entity captures information about an order placed by a customer for merchandise or services to be provided at some future date and time.</p>
</li>
<li>
<p><span class="bold">SKU Item</span>: Stock Keeping Unit or unit identification, typically the UPC, used to track store inventory and sales. Each SKU is associated with an item, variant, product line, bundle, service, fee, or attachment. This is the lowest level of merchandise for which inventory and sales records are retained within the retail store.</p>
</li>
<li>
<p><span class="bold">Item Category</span>: Category within a subclass in the product hierarchy, as it was at a given point in time.</p>
</li>
</ul>
<p class="subhead2"><a id="RBIOG1044"></a>The differences discovered during fit-gap analysis</p>
<p>Assume that during the fit-gap analysis, you discover the following need that is not supported by the logical model delivered with Oracle Retail Data Model:</p>
<p>Your company wants to add a new section in the retail domain. For example, if you want to add a book section in your store to other existing departments.</p>
<p class="subhead2"><a id="RBIOG1045"></a>Extending the physical model to support the differences</p>
<p>For example, to extend the physical data model, do the following:</p>
<ol>
<li>
<p>Create a table named <code>DWR_AUTHOR</code> to hold the Author's information by executing the following statements:</p>
<pre>
CREATE TABLE DWR_AUTHOR
(
AUTHOR _ID INTEGER NOT NULL,
AUTHOR _FIRST_NAME VARCHAR2 (50) NOT NULL,
AUTHOR _LAST_NAME VARCHAR2 (50) 
);
ALTER TABLE DWR_AUTHOR ADD CONSTRAINT AUTHOR_PK PRIMARY KEY (AUTHOR _ID);
</pre></li>
<li>
<p>Add columns in the <code>DWR_SKU_ITEM</code> table using the following statement:</p>
<pre>
ALTER TABLE DWR_SKU_ITEM ADD COLUMN ISBN INTEGER NULL
</pre></li>
<li>
<p>Create another new table named <code>DWR_AUTHOR_ITEM_ASGN</code>:</p>
<pre>
CREATE TABLE DWR_AUTHOR_ITEM_ASGN
(
AUTHOR _ID INTEGER NOT NULL,
SKU_ITEM_KEY NUMBER (30) NOT NULL
);
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDFHCA"></a><a id="RBIOG157"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">General Recommendations When Designing Physical Structures</h2>
<p><a id="sthref57"></a><a id="sthref58"></a>The <code>ordm_sys</code> schema delivered with Oracle Retail Data Model was designed and defined following best practices for data access and performance. Continue to use these practices when you add new physical objects. This section provides information about how decisions about the following physical design aspects were made to the default Oracle Retail Data Model:</p>
<ul>
<li>
<p><a href="#CHDGHEEC">Tablespaces in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDFJDEE">Data Compression in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDIHHFJ">Surrogate Keys in the Physical Model</a></p>
</li>
<li>
<p><a href="#CHDBADHG">Integrity Constraints in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDJBEFG">Indexes and Partitioned Indexes in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDEDHHJ">Partitioned Tables in Oracle Retail Data Model</a></p>
</li>
<li>
<p><a href="#CHDEFFJH">Parallel Execution in Oracle Retail Data Model</a></p>
</li>
</ul>
<a id="CHDGHEEC"></a><a id="RBIOG158"></a>
<div class="sect2">
<h3 class="sect2">Tablespaces in Oracle Retail Data Model</h3>
<p><a id="sthref59"></a><a id="sthref60"></a>A tablespace consists of one or more data files, which are physical structures within the operating system you are using.</p>
<p class="subhead2"><a id="RBIOG159"></a>Recommendations: Defining Tablespaces</p>
<p>If possible, define tablespaces so that they represent logical business units.</p>
<p>Use ultra large data files for a significant improvement in very large Oracle Retail Data Model warehouse.</p>
<p class="subhead2"><a id="RBIOG160"></a>Changing the Tablespace and Partitions Used by Tables</p>
<p><a id="sthref61"></a>You can change the tablespace and partitions used by Oracle Retail Data Model tables. What you do depends on whether the Oracle Retail Data Model table has partitions:</p>
<ul>
<li>
<p>For tables that do not have partitions (that is, lookup tables and reference tables), you can change the existing tablespace for a table.</p>
<p>By default, Oracle Retail Data Model defines the partitioned tables as interval partitioning, which means the partitions are created only when new data arrives.</p>
<p>Consequently, for Oracle Retail Data Model tables that have partitions (that is, Base, Derived, and Aggregate tables), for the new interval partitions to be generated in new tablespaces rather than current ones, issue the following statements.</p>
<pre>
ALTER TABLE <span class="italic">table_name</span> MODIFY DEFAULT ATTRIBUTES 
TABLESPACE <span class="italic">new_tablespace_name</span>;
 
</pre>
<p>When new data is inserted in the table specified by <span class="italic">table_name</span>, a new partition is automatically created in the tablespace specified as <span class="italic">new_tablespace_name</span>.</p>
</li>
<li>
<p>For tables that have partitions (that is, base, derived, and aggregate tables), you can specify that new interval partitions be generated into new tablespaces.</p>
<p>For Oracle Retail Data Model tables that do not have partitions, that is lookup tables and reference tables, change the existing tablespace for a table with the following statement.</p>
<pre>
ALTER TABLE <span class="italic">table_name</span> MOVE TABLESPACE <span class="italic">new_tablespace_name</span>;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFJDEE"></a><a id="RBIOG161"></a>
<div class="sect2">
<h3 class="sect2">Data Compression in Oracle Retail Data Model</h3>
<p><a id="sthref62"></a><a id="sthref63"></a>A key decision that you must make is whether to compress your data. Using table compression reduces disk and memory usage, often resulting in better scale-up performance for read-only operations. Table compression can also speed up query execution by minimizing the number of round trips required to retrieve data from the disks. Compressing data however imposes a performance penalty on the load speed of the data.</p>
<p class="subhead2"><a id="RBIOG162"></a>Recommendations: Data Compression</p>
<p>In general, choose to compress the data. The overall performance gain typically outweighs the cost of compression.</p>
<p>If you decide to use compression, consider sorting your data before loading it to achieve the best possible compression rate. The easiest way to sort incoming data is to load it using an <code>ORDER BY</code> clause on either your <code>CTAS</code> or <code>IAS</code> statement. Specify an <code>ORDER BY</code> a <code>NOT NULL</code> column (ideally non numeric) that has a large number of distinct values (1,000 to 10,000).</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDIBBIA">"Types of Data Compression Available"</a> and <a href="adm.htm#CHDHIGBI">"Compressing Materialized Views"</a>.</div>
<a id="CHDIBBIA"></a><a id="RBIOG163"></a>
<div class="sect3">
<h4 class="sect3">Types of Data Compression Available</h4>
<p><a id="sthref64"></a><a id="sthref65"></a>Oracle Database offers the following types of compression:</p>
<ul>
<li>
<p><a href="#CHDFJADH">Basic or Standard Compression</a></p>
</li>
<li>
<p><a href="#CHDFIAJD">OLTP Compression</a></p>
</li>
<li>
<p><a href="#CACIIFAE">Hybrid Columnar Compression (HCC)</a></p>
</li>
</ul>
<a id="CHDFJADH"></a><a id="RBIOG329"></a>
<div class="sect4">
<h5 class="sect4">Basic or Standard Compression</h5>
<p>With standard compression Oracle Database compresses data by eliminating duplicate values in a database block. Standard compression only works for direct path operations (CTAS or IAS). If the data is modified using any kind of conventional DML operation (for example updates), the data within that database block is uncompressed to make the modifications and is written back to disk uncompressed.</p>
<p><a id="sthref66"></a><a id="sthref67"></a>By using a compression algorithm specifically designed for relational data, Oracle Database can compress data effectively and in such a way that Oracle Database incurs virtually no performance penalty for SQL queries accessing compressed tables.</p>
<p>Oracle Retail Data Model leverages this compress feature which reduces the amount of data being stored, reduces memory usage, and increases query performance.</p>
<p>You can specify table compression using the <code>COMPRESS</code> clause of the <code>CREATE TABLE</code> statement or you can enable compression for an existing table using <code>ALTER TABLE</code> statement as shown:</p>
<pre>
alter table &lt;tablename&gt; move compress;
</pre></div>
<!-- class="sect4" -->
<a id="CHDFIAJD"></a><a id="RBIOG331"></a>
<div class="sect4">
<h5 class="sect4">OLTP Compression</h5>
<p>OLTP compression is a component of the Advanced Compression option. With OLTP compression, just like standard compression, Oracle Database compresses data by eliminating duplicate values in a database block. But unlike standard compression OLTP compression allows data to remain compressed during all types of data manipulation operations, including conventional DML such as <code>INSERT</code> and <code>UPDATE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink ADMIN11630" href="../../server.112/e25494/tables.htm#ADMIN11630"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on OLTP table compression features.</div>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
For more information on Oracle Advanced Compression, see the "Using Table Compression to Save Storage Costs" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
</div>
<!-- class="sect4" -->
<a id="CACIIFAE"></a><a id="RBIOG350"></a>
<div class="sect4">
<h5 class="sect4">Hybrid Columnar Compression (HCC) <a id="sthref68"></a><a id="sthref69"></a></h5>
<p>HCC is available with some storage formats and achieves its compression using a logical construct called the compression unit which is used to store a set of hybrid columnar-compressed rows. When data is loaded, a set of rows is pivoted into a columnar representation and compressed. After the column data for a set of rows has been compressed, it is fit into the compression unit. If conventional DML is issued against a table with HCC, the necessary data is uncompressed to do the modification and then written back to disk using a block-level compression algorithm.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
If your data set is frequently modified using conventional DML, then the use of HCC is not recommended; instead, the use of OLTP compression is recommended.</div>
<p>HCC provides different levels of compression, focusing on query performance or compression ratio respectively. With HCC optimized for query, fewer compression algorithms are applied to the data to achieve good compression with little to no performance impact. However, compression for archive tries to optimize the compression on disk, irrespective of its potential impact on the query performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
The discussion on HCC in <a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIHHFJ"></a><a id="RBIOG167"></a>
<div class="sect2">
<h3 class="sect2">Surrogate Keys in the Physical Model</h3>
<p><a id="sthref70"></a><a id="sthref71"></a>The surrogate key method for primary key construction involves taking the natural key components from the source systems and mapping them through a process of assigning a unique key value to each unique combination of natural key components (including source system identifier). The resulting primary key value is completely non-intelligent and is typically a numeric data type for maximum performance and storage efficiency.</p>
<p class="subhead2"><a id="RBIOG168"></a>Advantages of Surrogate keys include:</p>
<ul>
<li>
<p>Ensure uniqueness: data distribution</p>
</li>
<li>
<p>Independent of source systems</p>
</li>
<li>
<p>Re-numbering</p>
</li>
<li>
<p>Overlapping ranges</p>
</li>
<li>
<p>Uses the numeric data type which is the most performant data type for primary keys and joins</p>
</li>
</ul>
<p class="subhead2"><a id="RBIOG169"></a>Disadvantages of Surrogate keys:</p>
<ul>
<li>
<p>Requires allocation during ETL</p>
</li>
<li>
<p>Complex and expensive re-processing and data quality correction</p>
</li>
<li>
<p>Not used in queries &ndash; performance impact</p>
</li>
<li>
<p>The operational business intelligence requires natural keys to join or trace back to source operational systems</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDBADHG"></a><a id="RBIOG170"></a>
<div class="sect2">
<h3 class="sect2">Integrity Constraints in Oracle Retail Data Model</h3>
<p><a id="sthref72"></a>Integrity constraints are used to enforce business rules associated with your database and to prevent having invalid information in the tables. The most common types of constraints include:</p>
<ul>
<li>
<p><code>PRIMARY KEY</code> constraints, this is usually defined on the surrogate key column to ensure uniqueness of the record identifiers. In general, it is recommended that you specify the <code>ENFORCED ENABLED RELY</code> mode.</p>
</li>
<li>
<p><code>UNIQUE</code> constraints, to ensure that a given column (or set of columns) is unique. For slowly changing dimensions, it is recommended that you add a unique constraint on the Business Key and the Effective From Date columns to allow tracking multiple versions (based on surrogate key) of the same Business Key record.</p>
</li>
<li>
<p><code>NOT NULL</code> constraints, to ensure that no null values are allowed. For query rewrite scenarios, it is recommended that you have an inline explicit <code>NOT NULL</code> constraint on the primary key column in addition to the primary key constraint.</p>
</li>
<li>
<p><code>FOREIGN KEY</code> constraints, to ensure that relation between tables are being honored by the data. Usually in data warehousing environments, the foreign key constraint is present in <code>RELY DISABLE NOVALIDATE</code> mode.</p>
</li>
</ul>
<p>The Oracle Database uses constraints when optimizing SQL queries. Although constraints can be useful in many aspects of query optimization, constraints are particularly important for query rewrite of materialized views. Under some specific circumstances, constraints need space in the database. These constraints are in the form of the underlying unique index.</p>
<p>Unlike data in many relational database environments, data in a data warehouse is typically added or modified under controlled circumstances during the extraction, transformation, and loading (ETL) process.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJBEFG"></a><a id="RBIOG171"></a>
<div class="sect2">
<h3 class="sect2">Indexes and Partitioned Indexes in Oracle Retail Data Model</h3>
<p><a id="sthref73"></a><a id="sthref74"></a>Indexes are optional structures associated with tables or clusters. In addition to the classical B-tree indexes, bitmap indexes are very common in data warehousing environments</p>
<ul>
<li>
<p>Bitmap indexes are optimized index structures for set-oriented operations. Additionally, they are necessary for some optimized data access methods such as star transformations. Bitmap indexes are typically only a fraction of the size of the indexed data in the table.</p>
</li>
<li>
<p>B-tree indexes are most effective for high-cardinality data: that is, for data with many possible values, such as <code>customer_name</code> or <code>phone_number</code>. However, fully indexing a large table with a traditional B-tree index can be prohibitively expensive in terms of disk space because the indexes can be several times larger than the data in the table. B-tree indexes can be stored specifically in a compressed manner to enable huge space savings, storing more keys in each index block, which also leads to less I/O and better performance.</p>
</li>
</ul>
<p class="subhead2"><a id="RBIOG172"></a>Recommendations: Indexes and Partitioned Indexes</p>
<p>Make the majority of the indexes in your customized Oracle Retail Data Model bitmap indexes.</p>
<p>Use B-tree indexes only for unique columns or other columns with very high cardinalities (that is, columns that are almost unique). Store the B-tree indexes in a compressed manner.</p>
<p><a id="sthref75"></a><a id="sthref76"></a>Partition the indexes. Indexes are just like tables in that you can partition them, although the partitioning strategy is not dependent upon the table structure. Partitioning indexes makes it easier to manage the data warehouse during refresh and improves query performance.</p>
<p>Typically, specify the index on a partitioned table as local. Bitmap indexes on partitioned tables must always be local. B-tree indexes on partitioned tables can be global or local. However, in a data warehouse environment, local indexes are more common than global indexes. Use global indexes only when there is a specific requirement which cannot be met by local indexes (for example, a unique index on a nonpartitioning key, or a performance requirement).</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDEDHHJ">"Partitioned Tables in Oracle Retail Data Model"</a>, <a href="adm.htm#CHDHFGEH">"Choosing Indexes for Materialized Views"</a>, <a href="adm.htm#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Retail Data Model"</a>, and <a href="adm.htm#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEDHHJ"></a><a id="RBIOG173"></a>
<div class="sect2">
<h3 class="sect2">Partitioned Tables in Oracle Retail Data Model</h3>
<p><a id="sthref77"></a><a id="sthref78"></a>Partitioning allows a table, index or index-organized table to be subdivided into smaller pieces. Each piece of the database object is called a partition. Each partition has its own name, and may optionally have its own storage characteristics. From the perspective of a database administrator, a partitioned object has multiple pieces that can be managed either collectively or individually. This gives the administrator considerable flexibility in managing partitioned objects. However, from the perspective of the application, a partitioned table is identical to a nonpartitioned table. No modifications are necessary when accessing a partitioned table using SQL DML commands.</p>
<p>As discussed in the following topics, partitioning can provide tremendous benefits to a wide variety of applications by improving manageability, availability, and performance:</p>
<ul>
<li>
<p><a href="#CHDFFJCG">Partitioning the Oracle Retail Data Model for Manageability</a></p>
</li>
<li>
<p><a href="#CHDEDIDJ">Partitioning the Oracle Retail Data Model for Easier Data Access</a></p>
</li>
<li>
<p><a href="#CHDDEEAA">Partitioning the Oracle Retail Data Model for Join Performance</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
To understand the various partitioning techniques in Oracle Database, see the "Manipulating Partitions in Oracle Database 11<span class="italic">g</span>" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDJBEFG">"Indexes and Partitioned Indexes in Oracle Retail Data Model"</a>, <a href="adm.htm#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Retail Data Model"</a>, and <a href="adm.htm#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
<a id="CHDFFJCG"></a><a id="RBIOG174"></a>
<div class="sect3">
<h4 class="sect3">Partitioning the Oracle Retail Data Model for Manageability</h4>
<p><a id="sthref79"></a>Range partitioning helps improve the manageability and availability of large volumes of data (Oracle Retail Data Model uses Interval partitioning which is an extension to range partitioning). For more information, see <a class="olink VLDBG1269" href="../../server.112/e25523/part_avail.htm#VLDBG1269"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a>.</p>
<p>Consider the case where two year's worth of sales data or 100 terabytes (TB) is stored in a table. At the end of each day a new batch of data must be to loaded into the table and the oldest days worth of data must be removed. If the <code>Sales</code> table is range partitioned by day then the new data can be loaded using a partition exchange load. This is a sub-second operation that has little or no impact on end user queries.</p>
</div>
<!-- class="sect3" -->
<a id="CHDEDIDJ"></a><a id="RBIOG175"></a>
<div class="sect3">
<h4 class="sect3">Partitioning the Oracle Retail Data Model for Easier Data Access</h4>
<p>Range partitioning also helps ensure that only the necessary data to answer a query is scanned (Oracle Retail Data Model uses Interval partitioning which is an extension to range partitioning). Consider the case where business users predominately accesses the sales data on a weekly basis (for example, total sales per week) then range partitioning this table by day ensures that the data is accessed in the most efficient manner, as only seven partitions must be scanned to answer the business users query instead of the entire table. The ability to avoid scanning irrelevant partitions is known as partition pruning. For more information, see <a class="olink VLDBG00401" href="../../server.112/e25523/part_avail.htm#VLDBG00401"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a>.</p>
</div>
<!-- class="sect3" -->
<a id="CHDDEEAA"></a><a id="RBIOG176"></a>
<div class="sect3">
<h4 class="sect3">Partitioning the Oracle Retail Data Model for Join Performance</h4>
<p><a id="sthref80"></a><a id="sthref81"></a>Sub-partitioning by hash is used predominately for performance reasons. Oracle Database uses a linear hashing algorithm to create sub-partitions.</p>
<p>A major performance benefit of hash partitioning is partition-wise joins. Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves both CPU and memory resource usage. In a clustered data warehouse, this significantly reduces response times by limiting the data traffic over the interconnect (IPC), which is the key to achieving good scalability for massive join operations. Partition-wise joins can be full or partial, depending on the partitioning scheme of the tables to be joined.</p>
<p>As illustrated in <a href="#CHDBECGI">Figure 2-2</a>, a full partition-wise join divides a join between two large tables into multiple smaller joins. Each smaller join, performs a joins on a pair of partitions, one for each of the tables being joined. For the optimizer to choose the full partition-wise join method, both tables must be equi-partitioned on their join keys. That is, they have to be partitioned on the same column with the same partitioning method. Parallel execution of a full partition-wise join is similar to its serial execution, except that instead of joining one partition pair at a time, multiple partition pairs are joined in parallel by multiple parallel query servers. The number of partitions joined in parallel is determined by the Degree of Parallelism (DOP).</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDBECGI"></a><a id="RBIOG177"></a>Figure 2-2 Partitioning for Join Performance</p>
<img width="404" height="280" src="img/join1.gif" alt="Description of Figure 2-2 follows" /><br />
<a id="sthref82" href="img_text/join1.htm">Description of "Figure 2-2 Partitioning for Join Performance"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="subhead2"><a id="RBIOG333"></a>Recommendations: Number of Hash Partitions</p>
<p>To ensure that the data gets evenly distributed among the hash partitions it is highly recommended that the number of hash partitions is a power of 2 (for example, 2, 4, 8, and so on). A good rule of thumb to follow when deciding the number of hash partitions a table should have is <code>2 X # of CPUs</code> rounded to up to the nearest power of 2.</p>
<p>If your system has 12 CPUs, then 32 would be a good number of hash partitions. On a clustered system the same rules apply. If you have 3 nodes each with 4 CPUs, then 32 would still be a good number of hash partitions. However, ensure that each hash partition is at least 16MB. Many small partitions do not have efficient scan rates with parallel query. Consequently, if using the number of CPUs makes the size of the hash partitions too small, use the number of Oracle RAC nodes in the environment (rounded to the nearest power of 2) instead.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEFFJH"></a><a id="RBIOG178"></a>
<div class="sect2">
<h3 class="sect2">Parallel Execution in Oracle Retail Data Model</h3>
<p><a id="sthref83"></a>Parallel Execution enables a database task to be parallelized or divided into smaller units of work, thus allowing multiple processes to work concurrently. By using parallelism, a terabyte of data can be scanned and processed in minutes or less, not hours or days.</p>
<p><a href="#CHDJFAIC">Figure 2-3</a> illustrates the parallel execution of a full partition-wise join between two tables, Sales and Customers. Both tables have the same degree of parallelism and the same number of partitions. They are range partitioned on a date field and sub partitioned by hash on the cust_id field. As illustrated in the picture, each partition pair is read from the database and joined directly.</p>
<p>There is no data redistribution necessary, thus minimizing IPC communication, especially across nodes. <a href="#CHDJFAIC">Figure 2-3</a> shows the execution plan you would see for this join.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDJFAIC"></a><a id="RBIOG179"></a>Figure 2-3 Parallel Execution of a Full Partition-Wise Join Between Two Tables</p>
<img width="476" height="286" src="img/parthash.gif" alt="Description of Figure 2-3 follows" /><br />
<a id="sthref84" href="img_text/parthash.htm">Description of "Figure 2-3 Parallel Execution of a Full Partition-Wise Join Between Two Tables"</a><br />
<br /></div>
<!-- class="figure" -->
<p>To ensure that you get optimal performance when executing a partition-wise join in parallel, use the degree of parallelism as a multiple of the number of partitions. The number of partitions should be multiple of the number of cores. To get best performance use degree of parallelism that is the same as the number of partitions to be processed in a query (this should be equal to number of CPU cores).</p>
<p>What happens if only one table that you are joining is partitioned? In this case the optimizer could pick a partial partition-wise join. Unlike full partition-wise joins, partial partition-wise joins can be applied if only one table is partitioned on the join key. Hence, partial partition-wise joins are more common than full partition-wise joins. To execute a partial partition-wise join, Oracle Database dynamically repartitions the other table based on the partitioning strategy of the partitioned table.</p>
<p>After the other table is repartitioned, the execution is similar to a full partition-wise join. The redistribution operation involves exchanging rows between parallel execution servers. This operation leads to interconnect traffic in Oracle RAC environments, since data must be repartitioned across node boundaries.</p>
<p><a href="#CHDJBDDH">Figure 2-4</a> illustrates a partial partition-wise join. It uses the same example as in <a href="#CHDJFAIC">Figure 2-3</a>, except that the customer table is not partitioned. Before the join operation is executed, the rows from the customers table are dynamically redistributed on the join key.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDJBDDH"></a><a id="RBIOG180"></a>Figure 2-4 Partial Partition-Wise Join</p>
<img width="404" height="275" src="img/partjoin2.gif" alt="Description of Figure 2-4 follows" /><br />
<a id="sthref85" href="img_text/partjoin2.htm">Description of "Figure 2-4 Partial Partition-Wise Join"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="CHDEDGDD"></a><a id="RBIOG181"></a>
<div class="sect3">
<h4 class="sect3">Enabling Parallel Execution for a Session</h4>
<p><a id="sthref86"></a>Parallel query is the most commonly used parallel execution feature in Oracle Database. Parallel execution can significantly reduce the elapsed time for large queries. To enable parallelization for an entire session, execute the following statement.</p>
<pre>
alter session enable parallel query; 
</pre></div>
<!-- class="sect3" -->
<a id="CHDCAFBJ"></a><a id="RBIOG182"></a>
<div class="sect3">
<h4 class="sect3">Enabling Parallel Execution of DML Operations</h4>
<p><a id="sthref87"></a>Data Manipulation Language (DML) operations such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> can be parallelized by Oracle Database. Parallel execution can speed up large DML operations and is particularly advantageous in data warehousing environments. To enable parallelization of DML statements, execute the following statement.</p>
<pre>
alter session enable parallel dml;
</pre>
<p>When you issue a DML statement such as an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, Oracle Database applies a set of rules to determine whether that statement can be parallelized. The rules vary depending on whether the statement is a DML <code>INSERT</code> statement, or a DML <code>UPDATE</code> or <code>DELETE</code> statement.</p>
<ul>
<li>
<p>The following rules apply when determining how to parallelize DML <code>UPDATE</code> and <code>DELETE</code> statements:</p>
<ul>
<li>
<p>Oracle Database can parallelize <code>UPDATE</code> and <code>DELETE</code> statements on partitioned tables, but only when multiple partitions are involved.</p>
</li>
<li>
<p>You cannot parallelize <code>UPDATE</code> or <code>DELETE</code> operations on a nonpartitioned table or when such operations affect only a single partition.</p>
</li>
</ul>
</li>
<li>
<p>The following rules apply when determining how to parallelize DML <code>INSERT</code> statements:</p>
<ul>
<li>
<p>Standard <code>INSERT</code> statements using a <code>VALUES</code> clause cannot be parallelized.</p>
</li>
<li>
<p>Oracle Database can parallelize only <code>INSERT . . . SELECT . . . FROM</code> statements.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDEBFJD"></a><a id="RBIOG183"></a>
<div class="sect3">
<h4 class="sect3">Enabling Parallel Execution at the Table Level</h4>
<p>The setting of parallelism for a table influences the optimizer. Consequently, when using parallel query, also enable parallelism at the table level by issuing the following statement.</p>
<pre>
alter table &lt;table_name&gt; parallel 32;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2104">
<tr>
<td class="cellalignment2113">
<table class="cellalignment2109">
<tr>
<td class="cellalignment2108"><a href="impintro.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2108"><a href="adm.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2116">
<table class="cellalignment2107">
<tr>
<td class="cellalignment2108"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2108"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2108"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2108"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2108"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2108"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
