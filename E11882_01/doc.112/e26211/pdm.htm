<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Physical Model Customization</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 040" />
<meta name="dcterms.created" content="2011-12-07T8:30:9Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Airlines Data Model Implementation and Operations Guide" />
<meta name="dcterms.identifier" content="E26211-02" />
<meta name="dcterms.isVersionOf" content="DMAOG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="impintro.htm" title="Previous" type="text/html" />
<link rel="Next" href="adm.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e26211.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/12</span> <!-- End Header --><a id="CHDFIAJJ"></a><a id="DMAOG147"></a>
<h1 class="chapter"><span class="secnum">2</span> Physical Model Customization</h1>
<p><a id="sthref30"></a>This chapter provides general information about customizing the physical model of Oracle Airlines Data Model and more detailed information about customizing the foundation layer of the physical model. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDCJJCJ">Characteristics of the Default Physical Model</a></p>
</li>
<li>
<p><a href="#CHDFEDEF">Customizing the Oracle Airlines Data Model Physical Model</a></p>
</li>
<li>
<p><a href="#CHDDJFDJ">Foundation Layer Customization</a></p>
</li>
<li>
<p><a href="#CHDDFHCA">General Recommendations When Designing Physical Structures</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="adm.htm#CHDDHGHC">Chapter 3, "Access Layer Customization"</a></div>
<a id="CHDCJJCJ"></a><a id="DMAOG148"></a>
<div class="sect1">
<h2 class="sect1">Characteristics of the Default Physical Model</h2>
<p><a id="sthref31"></a><a id="sthref32"></a>The default physical data model of Oracle Airlines Data Model defines approximately:</p>
<dl>
<dd>370 tables and 8,500 columns</dd>
<dd>220 industry-specific measures and KPIs</dd>
<dd>6 pre-built data mining models</dd>
<dd>7 pre-built OLAP cubes</dd>
</dl>
<p>The default physical model of the Oracle Airlines Data Model shares characteristics of a multischema "traditional" data warehouse, as described in <a href="#CHDDDDDD">"Layers in a "Traditional" Data Warehouse"</a>, but defines all data structures in a single schema as described in <a href="#CHDIJHEF">"Layers in the Default Oracle Airlines Data Model Warehouse"</a>.</p>
<p class="subhead2"><a id="CHDDDDDD"></a><a id="DMAOG149"></a>Layers in a "Traditional" Data Warehouse</p>
<p><a id="sthref33"></a>Historically, three layers are defined for a data warehouse environment:</p>
<ul>
<li>
<p><span class="bold">Staging layer.</span> This layer is used when moving data from the OLTP system and other data sources into the data warehouse itself. It consists of temporary loading structures and rejected data. Having a staging layer enables the speedy extraction, transformation and loading (ETL) of data from your operational systems into data warehouse without disturbing any of the business users. It is in this layer that much of the complex data transformation and data quality processing occurs. The most basic approach for the design of the staging layer is as a schema identical to the one that exists in the source operational system.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In some implementations this layer is not necessary, because all data transformation processing is done "on the fly" as data is extracted from the source system before it is inserted directly into the foundation layer.</div>
</li>
<li>
<p><a id="sthref34"></a><span class="bold">Foundation or integration layer.</span> This layer is traditionally implemented as a Third Normal Form (3NF) schema. A 3NF schema is a neutral schema design independent of any application, and typically has a large number of tables. It preserves a detailed record of each transaction without any data redundancy and allows for rich encoding of attributes and all relationships between data elements. Users typically require a solid understanding of the data to navigate the more elaborate structure reliably. In this layer data begins to take shape and it is not uncommon to have some end-user application access data from this layer especially if they are time sensitive, as data becomes available here before it is transformed into the Access and Performance layer.</p>
</li>
<li>
<p><a id="sthref35"></a><span class="bold">Access layer.</span> This layer is traditionally defined as a snowflake or star schema that describes a "flattened" or dimensional view of the data.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDIJHEF"></a><a id="DMAOG150"></a>Layers in the Default Oracle Airlines Data Model Warehouse</p>
<p><a id="sthref36"></a>Oracle Airlines Data Model warehouse environment also consists of three layers. However, as indicated by the dotted line in <a href="#CHDFJJGA">Figure 2-1, "Layers of an Oracle Airlines Data Model Warehouse"</a>, in the Oracle Airlines Data Model the definitions of the foundation and access layers are combined in a single schema.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDFJJGA"></a><a id="DMAOG151"></a>Figure 2-1 Layers of an Oracle Airlines Data Model Warehouse</p>
<img width="818" height="766" src="img/physlayers.gif" alt="Description of Figure 2-1 follows" /><br />
<a id="sthref37" href="img_text/physlayers.htm">Description of "Figure 2-1 Layers of an Oracle Airlines Data Model Warehouse"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The layers in the Oracle Airlines Data Model warehouse are:</p>
<ul>
<li>
<p><span class="bold"><a id="sthref38"></a><a id="sthref39"></a>Staging layer</span>. As in a "traditional" data warehouse environment, an Oracle Airlines Data Model warehouse environment can have a staging layer. Because the definition of this layer varies by customer, a definition of this area is not provided as part of Oracle Airlines Data Model.</p>
</li>
<li>
<p><span class="bold">Foundation and Access layers.</span> The physical objects for these layers are defined in a single schema, the <code>oadm_sys</code> schema:</p>
<ul>
<li>
<p><a id="sthref40"></a><a id="sthref41"></a><span class="bold">Foundation layer.</span> The foundation layer of the Oracle Airlines Data Model is defined by base tables that present the data in 3NF (that is, tables that have the <code>DWB_</code> prefix). This layer also includes reference, lookup, and control tables defined in the <code>oadm_sys</code> schema (that is, the tables that have the <code>DWR_</code> , <code>DWL_</code>, <code>DWC_</code> prefixes).</p>
</li>
<li>
<p><a id="sthref42"></a><a id="sthref43"></a><span class="bold">Access layer.</span> The access layer of Oracle Airlines Data Model is defined by dimension tables (defined with a <code>DWM_</code> prefix), derived and aggregate tables (defined with <code>DWD_</code> and <code>DWA_</code> prefixes), cubes (defined with a <code>CB$</code> prefix), and views (that is, views defined with the <code>_VIEW</code> suffix). These structures provide a summarized or "flattened" perspectives of the data in the foundation layer.</p>
<p>This layer also contains the results of the data mining models which are stored in derived (<code>DWD_</code>) tables.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink DMARF" href="../e26208/toc.htm"><span class="italic">Oracle Airlines Data Model Reference</span></a> for detailed information on the <code>oadm_sys</code> schema.</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDFEDEF"></a><a id="DMAOG152"></a>
<div class="sect1">
<h2 class="sect1">Customizing the Oracle Airlines Data Model Physical Model</h2>
<p><a id="sthref44"></a><a id="sthref45"></a>The starting point for the Oracle Airlines Data Model physical data model is the 3NF logical data model. The physical data model mirrors the logical model as much as possible, (although some changes in the structure of the tables or columns may be necessary) and defines database objects (such as tables, cubes, views).</p>
<p>To customize the default physical model of the Oracle Airlines Data Model take the following steps:</p>
<ol>
<li>
<p>Answer the questions outlined in <a href="#CHDFDDGD">"Questions to Answer Before You Customize the Physical Model"</a>.</p>
</li>
<li>
<p>Familiarize yourself with the characteristics of the logical and physical model of Oracle Airlines Data Model as outlined in<a href="#CHDCJJCJ">"Characteristics of the Default Physical Model"</a> and presented in detail in <span class="italic">Oracle Airlines Data Model Reference</span>.</p>
</li>
<li>
<p>Modify the foundation level of your physical model of Oracle Airlines Data Model, as needed. See <a href="#CHDHEHDA">"Common Change Scenarios When Customizing the Foundation Layer of Oracle Airlines Data Model"</a> for a discussion of when customization might be necessary.</p>
<p>When defining physical structures:</p>
<ul>
<li>
<p>Keep the foundation layer in 3NF form.</p>
</li>
<li>
<p>Use the information presented in <a href="#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a> to guide you when designing the physical objects.</p>
</li>
<li>
<p>Follow the conventions used when creating the default physical model of Oracle Airlines Data Model as outlined in <a href="#CHDFGAAG">"Conventions When Customizing the Physical Model"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Package the changes you make to the physical data model as a patch to the <code>oadm_sys</code> schema.</div>
</li>
<li>
<p>Modify the access layer of your physical model of Oracle Airlines Data Model as discussed in <a href="adm.htm#CHDDHGHC">Chapter 3, "Access Layer Customization"</a>.</p>
</li>
</ol>
<a id="CHDFDDGD"></a><a id="DMAOG153"></a>
<div class="sect2">
<h3 class="sect2">Questions to Answer Before You Customize the Physical Model</h3>
<p><a id="sthref46"></a><a id="sthref47"></a>When designing the physical model, remember that the logical data model is not one-to-one with the physical data model. Consider the load, query, and maintenance requirements when you convert the logical data model into the physical layer. For example, answer the following questions before you design the physical data model:</p>
<ul>
<li>
<p>Do you need the physical data model to cover the full scope of the logical data model, or only part of the scope?</p>
<p><a href="#CHDHEHDA">"Common Change Scenarios When Customizing the Foundation Layer of Oracle Airlines Data Model"</a> provides an overview discussion of making physical data model changes when your business needs do not result in a logical model that is the same as the Oracle Airlines Data Model logical model.</p>
</li>
<li>
<p>What is the result of the source data profile?</p>
</li>
<li>
<p>What is the data load frequency for each table?</p>
</li>
<li>
<p>How many large tables are there and which tables are these?</p>
</li>
<li>
<p>How will the tables and columns be accessed? What are the common joins?</p>
</li>
<li>
<p>What is your data backup strategy?</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFGAAG"></a><a id="DMAOG154"></a>
<div class="sect2">
<h3 class="sect2">Conventions When Customizing the Physical Model</h3>
<p><a id="sthref48"></a><a id="sthref49"></a><a id="sthref50"></a>When developing the physical model for Oracle Airlines Data Model, the conventions outlined below were followed. Continue to follow these conventions as you customize the physical model.</p>
<ul>
<li>
<p><a href="#CHDIEHAF">General Naming Conventions for Physical Objects</a></p>
</li>
<li>
<p><a href="#CHDHCDDE">Use of History (_H) Tables</a></p>
</li>
<li>
<p><a href="#CHDCJEJC">Domain Definition Standards</a></p>
</li>
</ul>
<a id="CHDIEHAF"></a><a id="DMAOG381"></a>
<div class="sect3"><a id="CHDDEGEF"></a>
<h4 class="sect3">General Naming Conventions for Physical Objects</h4>
<p><a id="sthref51"></a>Follow these guidelines for naming physical objects that you define:</p>
<ul>
<li>
<p>When naming the physical objects follow the naming guidelines for naming objects within an Oracle Database schema. For example:</p>
<ul>
<li>
<p>Table and column names must start with a letter, can use only 30 alphanumeric characters or less, cannot contain spaces or some special characters such as "!" and cannot use reserved words.</p>
</li>
<li>
<p>Table names must be unique within a schema that is shared with views and synonyms.</p>
</li>
<li>
<p>Column names must be unique within a table.</p>
</li>
</ul>
</li>
<li>
<p>Although it is common to use abbreviations in the physical modeling stage, as much as possible, use names for the physical objects that correspond to the names of the entities in the logical model. Use consistent abbreviations to avoid programmer and user confusion.</p>
</li>
<li>
<p>When naming columns, use short names if possible. Short column names reduce the time required for SQL command parsing.</p>
</li>
<li>
<p>The <code>oadm_sys</code> schema delivered with Oracle Airlines Data Model uses the prefixes and suffixes shown in the following table to identify object types.</p>
<div class="inftblinformal">
<table class="cellalignment2042" summary="Prefixes and suffixes used when naming objects" dir="ltr">
<thead>
<tr class="cellalignment2036">
<th class="cellalignment2043" id="r1c1-t6">Prefix or Suffix</th>
<th class="cellalignment2043" id="r1c2-t6">Used for Name of These Objects</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r2c1-t6" headers="r1c1-t6"><code>CB$</code></td>
<td class="cellalignment2044" headers="r2c1-t6 r1c2-t6">Materialized view of an OLAP cube. This materialized view is automatically created by the OLAP server.
<p><span class="bold">Note:</span> Do not report or query against this object. Instead access the corresponding <code>_VIEW</code> object.</p>
</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r3c1-t6" headers="r1c1-t6"><code>DMV_</code></td>
<td class="cellalignment2044" headers="r3c1-t6 r1c2-t6">Materialized views used for as the source data of data mining model.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r4c1-t6" headers="r1c1-t6"><code>DWA_</code></td>
<td class="cellalignment2044" headers="r4c1-t6 r1c2-t6">Aggregate tables.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r5c1-t6" headers="r1c1-t6"><code>DWB_</code></td>
<td class="cellalignment2044" headers="r5c1-t6 r1c2-t6">Base transaction data (3NF) tables.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r6c1-t6" headers="r1c1-t6"><code>DWC_</code></td>
<td class="cellalignment2044" headers="r6c1-t6 r1c2-t6">Control tables.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r7c1-t6" headers="r1c1-t6"><code>DWD_</code></td>
<td class="cellalignment2044" headers="r7c1-t6 r1c2-t6">Derived tables -- including data mining result tables.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r8c1-t6" headers="r1c1-t6"><code>DWL_</code></td>
<td class="cellalignment2044" headers="r8c1-t6 r1c2-t6">Lookup tables.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r9c1-t6" headers="r1c1-t6"><code>DWM_</code></td>
<td class="cellalignment2044" headers="r9c1-t6 r1c2-t6">Dimension tables in an access layer fact table (that is, for a <code>DWD_</code> or a <code>DWA_</code> table).</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r10c1-t6" headers="r1c1-t6"><code>DWV_</code></td>
<td class="cellalignment2044" headers="r10c1-t6 r1c2-t6">Relational view of time dimension.</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r11c1-t6" headers="r1c1-t6"><code>DWR_</code></td>
<td class="cellalignment2044" headers="r11c1-t6 r1c2-t6">Reference data tables used as dimension tables in a foundation layer fact table (that is, for a <code>DWB_</code> table).</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r12c1-t6" headers="r1c1-t6"><code>_H</code></td>
<td class="cellalignment2044" headers="r12c1-t6 r1c2-t6">"Classic" data warehouse table that is used to store both the most recent data and the historical data of a certain entity. (See <a href="#CHDHCDDE">"Use of History (_H) Tables"</a>.)</td>
</tr>
<tr class="cellalignment2036">
<td class="cellalignment2044" id="r13c1-t6" headers="r1c1-t6"><code>_VIEW</code></td>
<td class="cellalignment2044" headers="r13c1-t6 r1c2-t6">Relational views of OLAP cubes, dimensions, or hierarchies.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>Use these prefixes and suffixes for any new tables, views, and cubes that you define.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink DMARF" href="../e26208/toc.htm"><span class="italic">Oracle Airlines Data Model Reference</span></a> for detailed information about the objects in the default Oracle Airlines Data Model.</div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDHCDDE"></a><a id="DMAOG382"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Use of History (_H) Tables</h4>
<p>The physical data model of the default Oracle Airlines Data Model was designed to function both as an Operational Data Store (ODS) and a data warehouse. To support this dual functionality, the logical entities are implemented as two different types of physical tables:</p>
<ul>
<li>
<p><code><span class="codeinlineitalic">tablename</span></code><code>_H</code> tables are "classic" data warehouse tables. These tables are designed to store both the most recent data and the historical data for an entity. These are the tables that provide the data for the access layer objects (that is, derived and aggregate tables, and OLAP cubes). When <code>_H</code> tables are populated with new data, the data is added to the table; data is never overwritten.</p>
</li>
<li>
<p><code><span class="codeinlineitalic">tablename</span></code> tables are ODS tables. These tables are designed to store <span class="italic">only</span> the most recent data for an entity. These are the tables that an application accesses when making real-time (or near real-time) queries. When these tables are populated with new data, the new data overwrites data already in the table.</p>
</li>
</ul>
<p>For example, when you look at the physical tables that represent the logical entity Service, you see that there are two tables: <code>DWR_SERVICE</code> and <code>DWR_SERVICE_H</code>. The function of the <code>DWR_SERVICE</code> table is to hold the most recent data; while the function of <code>DWR_SERVICE_H</code> is to hold both the most recent data and the historical data.</p>
</div>
<!-- class="sect3" -->
<a id="CHDCJEJC"></a><a id="DMAOG383"></a>
<div class="sect3">
<h4 class="sect3">Domain Definition Standards</h4>
<p>A domain is a set of values allowed for a column. The domain can be enforced by a foreign key, check constraints, or the application on top of the database. Define the standards for each domain across the model such as:</p>
<ul>
<li>
<p>Date and time type, such as <code>'YYYY-MM-DD'</code>.</p>
</li>
<li>
<p>Numeric value in different situations.</p>
</li>
<li>
<p>Character string length in different situations.</p>
</li>
<li>
<p>Coded value definition such as key or description.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDJFDJ"></a><a id="DMAOG327"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Foundation Layer Customization</h2>
<p>The first step in customizing the physical model of Oracle Airlines Data Model is customizing the foundation layer of the physical data model. Since, as mentioned in <a href="#CHDIJHEF">"Layers in the Default Oracle Airlines Data Model Warehouse"</a>, the foundation layer of the physical model mirrors the 3NF logical model of Oracle Airlines Data Model, you might choose to customize the foundation layer to reflect differences between your logical model needs and the default logical model of Oracle Airlines Data Model. Additionally, you might need to customize the physical objects in the foundation layer to improve performance (for example, you might choose to compress some foundation layer tables).</p>
<p>When making changes to the foundation layer, keep the following points in mind:</p>
<ul>
<li>
<p>When changing the foundation layer objects to reflect your logical model design, make as few changes as possible. <a href="#CHDHEHDA">"Common Change Scenarios When Customizing the Foundation Layer of Oracle Airlines Data Model"</a> outlines the most common customization changes you will make in this regard.</p>
</li>
<li>
<p>When defining new foundation layer objects or when redesigning existing foundation layer objects for improved performance, follow the <a href="#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a> and <a href="#CHDFGAAG">"Conventions When Customizing the Physical Model"</a>.</p>
</li>
<li>
<p>Remember that changes to the foundation layer objects can also impact the access layer objects.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Approach any attempt to change the Oracle Airlines Data Model with caution. The foundation layer of the physical model of the Oracle Airlines Data Model has (at its core) a set of generic structures that allow it to be flexible and extensible. Before making extensive additions, deletions, or changes, ensure that you understand the full range of capabilities of Oracle Airlines Data Model and that you cannot handle your requirements using the default objects in the foundation layer</div>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CACFJEEC">"Example: Changing the Foundation Layer of the Oracle Airlines Data Model"</a></div>
<a id="CHDHEHDA"></a><a id="DMAOG328"></a>
<div class="sect2">
<h3 class="sect2">Common Change Scenarios When Customizing the Foundation Layer of Oracle Airlines Data Model</h3>
<p>There are several common change scenarios when customizing the foundation layer of the physical data model:</p>
<ul>
<li>
<p><span class="bold">Additions to Existing Structures</span></p>
<p>If you identify business areas or processes that are not supported in the default foundation layer of the physical data model of Oracle Airlines Data Model, add new tables and columns.</p>
<p>Carefully study the default foundation layer of the physical data model of Oracle Airlines Data Model (and the underlying logical data model) to avoid building redundant structures when making additions. If these additions add high value to your business value, communicate the additions back to the Oracle Airlines Data Model Development Team for possible inclusion in future releases of Oracle Airlines Data Model.</p>
</li>
<li>
<p><span class="bold">Deletions of Existing Structures</span></p>
<p>If there are areas of the model that cannot be matched to any of the business requirements of your legacy systems, it is safer to keep these structures and not populate that part of the warehouse.</p>
<p>Deleting a table in the foundation layer of the physical data model can destroy relationships needed in other parts of the model or by applications based on it. Some tables may not be needed during the initial implementation, however you may want to use these structures at a later time. If this is a possibility, keeping the structures now saves re-work later. If tables are deleted, perform a thorough analysis to identify all relationships originating from that entity.</p>
</li>
<li>
<p><span class="bold">Changes to Existing Structures</span></p>
<p>In some situations some structures in the foundation layer of the physical data model of the Oracle Airlines Data Model may not exactly match the corresponding structures that you use.Before implementing changes, identify the impact that the changes would have on the database design of Oracle Airlines Data Model. Also identify the impact on any applications based on the new design.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CACFJEEC">"Example: Changing the Foundation Layer of the Oracle Airlines Data Model"</a></div>
</div>
<!-- class="sect2" -->
<a id="CACFJEEC"></a><a id="DMAOG347"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Example: Changing the Foundation Layer of the Oracle Airlines Data Model</h3>
<p>As an example, let's take a look how Oracle Airlines Data Model supports the various airlines services, what a sample customer might discover during fit-gap analysis, and how that customer might extend Oracle Airlines Data Model to fit the discovered gaps.</p>
<p class="subhead2"><a id="DMAOG375"></a>Entities supporting airline services</p>
<p>The entities provided with the logical model of Oracle Airlines Data Model that support the airline services are:</p>
<ul>
<li>
<p>AIRPORT: Airport means an IATA recognized location that serves as an origin or destination of one or more flights. This entity stores the details of the airport like city, country, region of the airport.</p>
</li>
<li>
<p>FLIGHT: This entity stores information about the flight (for example, the carrier to which it belongs, and the flight number).</p>
</li>
<li>
<p>AIRCRAFT: This entity stores the type of aircraft (for example. Boeing 737).</p>
</li>
<li>
<p>AIRCRAFT VERSION: This entity stores the details of the aircraft version used for flights. For example, if the aircraft type is Boeing 737 then the version will be Boeing 737-800.</p>
</li>
<li>
<p>CARRIER: This entity stores the details about the carrier (for example, carrier code and description).</p>
</li>
<li>
<p>CARRIER TYPE: This entity stores Carrier type details (for example, airline, railway, on road transport, and ship).</p>
</li>
</ul>
<p class="subhead2"><a id="DMAOG376"></a>The differences discovered during fit-gap analysis</p>
<p>Assume that during the fit-gap analysis, you discover the following needs that are not supported by the logical model delivered with Oracle Airlines Data Model:</p>
<ul>
<li>
<p>Your company serves more than one service in airline arena. In other words, you discover that you track not only airports as represented in the standard logical model of Oracle Airlines Data Model, but also you need to define airports by categories of airport activities (that is, airport categories). These airport categories are, for example, commercial service, primary, cargo service, reliever, and general aviation airports.</p>
</li>
<li>
<p>In the flight operations, the airline needs to maintain a history of airport categories used to operate the various lines of services (for example, commercial, cargo, reliever or general aviation).</p>
</li>
</ul>
<p class="subhead2"><a id="DMAOG377"></a>Extending the logical and physical model to support the differences</p>
<p>To support the differences, you need to extend the logical and physical model in the following ways:</p>
<ul>
<li>
<p>To store details about category of the airport you will need to modify the logical model. The classic way to do this is to add another entity to hold this information. For example, you can add an entity named AIRPORT CATEGORY that has a 1:M relationship with the AIRPORT entity. Then, you extend the physical data model in a corresponding manner. The specific steps to extend the physical model are given in <a href="#CHDDJAJG">Example 2-1, "Extending the Physical Data Model of Oracle Airlines Data Model to Support Multiple Categories for AIRPORT"</a>.</p>
</li>
<li>
<p>To maintain the history of flight operations which are operated from respective airport categories, you can find the same based on the existing relationship between flight schedule and AIRPORT entity for corresponding Leg entity.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="CHDDJAJG"></a><a id="DMAOG348"></a>Example 2-1 Extending the Physical Data Model of Oracle Airlines Data Model to Support Multiple Categories for AIRPORT</p>
<p>To extend the design of the foundation layer of Oracle Airlines Data Model to support multiple categories for <code>AIRPORT</code>, take the following steps:</p>
<ol>
<li>
<p>Create a new table named <code>DWL_ARPRT_CTGRS</code> to hold the multiple categories information for airport by executing the following statements.</p>
<pre>
CREATE TABLE DWL_ARPRT_CTGRS
(
    ARPRT_CTGRS_ID          INTEGER NOT NULL ,
    ARPRT_CTGRS_NM          VARCHAR2(50) NULL ,
    ARPRT_CTGRS_DESC        VARCHAR2(500) NULL ,
    ARPRT_CTGRS_CD          CHAR(18) NULL ,
    DWFEED_ID               INTEGER NULL ,
    SRC_SYS_ID              VARCHAR2(30) NULL ,
    SRC_SYS_CRTD_TMSTMP     TIMESTAMP NULL ,
    SRC_SYS_UPD_TMSTMP      TIMESTAMP NULL ,
    SRC_SYS_DEL_IND         VARCHAR2(1) NULL
);

</pre>
<pre>
ALTER TABLE DWL_ARPRT_CTGRS    ADD CONSTRAINT  XPKARPRT_CTGRS PRIMARY KEY (ARPRT_CTGRS_ID);
</pre>
<pre>
</pre></li>
<li>
<p>Create a new table named <code>DWL_ARPRT_CTGRS_H</code> to hold the history information for <code>DWL_ARPRT_CTGRS</code> by executing the following statement.</p>
<pre>
CREATE TABLE DWL_ARPRT_CTGRS_H
(
    ARPRT_CTGRS_ID          INTEGER NOT NULL ,
    ARPRT_CTGRS_NM          VARCHAR2(50) NULL ,
    ARPRT_CTGRS_DESC        VARCHAR2(500) NULL ,
    ARPRT_CTGRS_CD          CHAR(18) NULL ,
    DWFEED_ID               INTEGER NULL ,
    SRC_SYS_ID              VARCHAR2(30) NULL ,
    SRC_SYS_CRTD_TMSTMP     TIMESTAMP NULL ,
    SRC_SYS_UPD_TMSTMP      TIMESTAMP NULL ,
    SRC_SYS_DEL_IND         VARCHAR2(1) NULL ,
    ETL_BATCH_ID            INTEGER NULL ,
    ETL_BATCH_CRTD_BY       VARCHAR2(60) NULL ,
    ETL_BATCH_CRTD_TMSTMP   TIMESTAMP NULL ,
    ETL_BATCH_UPD_BY        VARCHAR2(60) NULL ,
    ETL_BATCH_UPD_TMSTMP    TIMESTAMP NULL ,
    DATA_MVT_STS_CD         VARCHAR2(25) NULL ,
    VLD_FRM                 TIMESTAMP NULL ,
    VLD_UPTO                TIMESTAMP NULL ,
    CURR_STS                VARCHAR2(1) NULL ,
    DWL_ARPRT_CTGRS_H_SKEY  INTEGER NOT NULL
);
</pre></li>
<li>
<p>Add a column named <code>ARPRT_CTGRS_ID</code> to the <code>DWR_AIP</code> table by issuing the following statement.</p>
<pre>
ALTER TABLE DWR_AIP ADD COLUMN ARPRT_CTGRS_ID INTEGER NULL;
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDFHCA"></a><a id="DMAOG157"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">General Recommendations When Designing Physical Structures</h2>
<p><a id="sthref52"></a><a id="sthref53"></a>The <code>oadm_sys</code> schema delivered with Oracle Airlines Data Model was designed and defined following best practices for data access and performance. Continue to use these practices when you add new physical objects. This section provides information about how decisions about the following physical design aspects were made to the default Oracle Airlines Data Model:</p>
<ul>
<li>
<p><a href="#CHDGHEEC">Tablespaces in the Oracle Airlines Data Model</a></p>
</li>
<li>
<p><a href="#CHDFJDEE">Data Compression in the Oracle Airlines Data Model</a></p>
</li>
<li>
<p><a href="#CHDBAIJE">Tables for Supertype and Subtype Entities in Oracle Airlines Data Model</a></p>
</li>
<li>
<p><a href="#CHDIHHFJ">Surrogate Keys in the Physical Model</a></p>
</li>
<li>
<p><a href="#CHDBADHG">Integrity Constraints in Oracle Airlines Data Model</a></p>
</li>
<li>
<p><a href="#CHDJBEFG">Indexes and Partitioned Indexes in Oracle Airlines Data Model</a></p>
</li>
<li>
<p><a href="#CHDEDHHJ">Partitioned Tables in the Oracle Airlines Data Model</a></p>
</li>
<li>
<p><a href="#CHDEFFJH">Parallel Execution in the Oracle Airlines Data Model</a></p>
</li>
</ul>
<a id="CHDGHEEC"></a><a id="DMAOG158"></a>
<div class="sect2">
<h3 class="sect2">Tablespaces in the Oracle Airlines Data Model</h3>
<p><a id="sthref54"></a><a id="sthref55"></a>A tablespace consists of one or more data files, which are physical structures within the operating system you are using.</p>
<p class="subhead2"><a id="DMAOG159"></a>Recommendations: Defining Tablespaces</p>
<p>If possible, define tablespaces so that they represent logical business units.</p>
<p>Use ultra large data files for a significant improvement in very large Oracle Airlines Data Model warehouse.</p>
<p class="subhead2"><a id="DMAOG160"></a>Changing the Tablespace and Partitions Used by Tables</p>
<p><a id="sthref56"></a>You can change the tablespace and partitions used by Oracle Airlines Data Model tables. What you do depends on whether the Oracle Airlines Data Model table has partitions:</p>
<ul>
<li>
<p>For tables that do not have partitions (that is, lookup tables and reference tables), you can change the existing tablespace for a table.</p>
<p>By default, Oracle Airlines Data Model defines the partitioned tables as interval partitioning, which means the partitions are created only when new data arrives.</p>
<p>Consequently, for Oracle Airlines Data Model tables that have partitions (that is, Base, Derived, and Aggregate tables), for the new interval partitions to be generated in new tablespaces rather than current ones, issue the following statements.</p>
<pre>
ALTER TABLE <span class="italic">table_name</span> MODIFY DEFAULT ATTRIBUTES 
TABLESPACE <span class="italic">new_tablespace_name</span>;
 
</pre>
<p>When new data is inserted in the table specified by <span class="italic">table_name</span>, a new partition is automatically created in the tablespace specified by <span class="italic">tablespace new_tablespace_name</span>.</p>
</li>
<li>
<p>For tables that have partitions (that is, base, derived, and aggregate tables), you can specify that new interval partitions be generated into new tablespaces.</p>
<p>For Oracle Airlines Data Model tables that do not have partitions (that is, lookup tables and reference tables), to change the existing tablespace for a table then issue the following statement.</p>
<pre>
ALTER TABLE <span class="italic">table_name</span> MOVE TABLESPACE <span class="italic">new_tablespace_name</span>;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFJDEE"></a><a id="DMAOG161"></a>
<div class="sect2">
<h3 class="sect2">Data Compression in the Oracle Airlines Data Model</h3>
<p><a id="sthref57"></a><a id="sthref58"></a>A key decision that you must make is whether to compress your data. Using table compression reduces disk and memory usage, often resulting in better scale-up performance for read-only operations. Table compression can also speed up query execution by minimizing the number of round trips required to retrieve data from the disks. Compressing data however imposes a performance penalty on the load speed of the data. Most of the base tables in the Oracle Airlines Data Model are compressed tables.</p>
<p class="subhead2"><a id="DMAOG162"></a>Recommendations: Data Compression</p>
<p>In general, choose to compress the data. The overall performance gain typically outweighs the cost of compression.</p>
<p>If you decide to use compression, consider sorting your data before loading it to achieve the best possible compression rate. The easiest way to sort incoming data is to load it using an <code>ORDER BY</code> clause on either your <code>CTAS</code> or <code>IAS</code> statement. Specify an <code>ORDER BY</code> a <code>NOT NULL</code> column (ideally non numeric) that has a large number of distinct values (1,000 to 10,000).</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDIBBIA">"Types of Data Compression Available"</a> and <a href="adm.htm#CHDHIGBI">"Compressing Materialized Views"</a>.</div>
<a id="CHDIBBIA"></a><a id="DMAOG163"></a>
<div class="sect3">
<h4 class="sect3">Types of Data Compression Available</h4>
<p><a id="sthref59"></a><a id="sthref60"></a>Oracle Database offers the following types of compression:</p>
<ul>
<li>
<p><a href="#CHDFJADH">Basic or Standard Compression</a></p>
</li>
<li>
<p><a href="#CHDFIAJD">OLTP Compression</a></p>
</li>
<li>
<p><a href="#CACIIFAE">Hybrid Columnar Compression (HCC)</a></p>
</li>
</ul>
<a id="CHDFJADH"></a><a id="DMAOG329"></a>
<div class="sect4">
<h5 class="sect4">Basic or Standard Compression</h5>
<p>With standard compression Oracle Database compresses data by eliminating duplicate values in a database block. Standard compression only works for direct path operations (CTAS or IAS). If the data is modified using any kind of conventional DML operation (for example updates), the data within that database block is uncompressed to make the modifications and is written back to disk uncompressed.</p>
<p><a id="sthref61"></a><a id="sthref62"></a>By using a compression algorithm specifically designed for relational data, Oracle Database can compress data effectively and in such a way that Oracle Database incurs virtually no performance penalty for SQL queries accessing compressed tables.</p>
<p>Oracle Airlines Data Model leverages the compress feature for all base, derived, and aggregate tables which reduces the amount of data being stored, reduces memory usage (more data per memory block), and increases query performance.</p>
<p>You can specify table compression by using the <code>COMPRESS</code> clause of the <code>CREATE TABLE</code> statement or you can enable compression for an existing table by using <code>ALTER TABLE</code> statement as shown below.</p>
<pre>
alter table &lt;tablename&gt; move compress;
</pre></div>
<!-- class="sect4" -->
<a id="CHDFIAJD"></a><a id="DMAOG331"></a>
<div class="sect4">
<h5 class="sect4">OLTP Compression</h5>
<p>OLTP compression is a component of the Advanced Compression option. With OLTP compression, just like standard compression, Oracle Database compresses data by eliminating duplicate values in a database block. But unlike standard compression OLTP compression allows data to remain compressed during all types of data manipulation operations, including conventional DML such as <code>INSERT</code> and <code>UPDATE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink ADMIN" href="../../server.112/e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on OLTP table compression features.</div>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
For more information on Oracle Advanced Compression, see the "Using Table Compression to Save Storage Costs" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
</div>
<!-- class="sect4" -->
<a id="CACIIFAE"></a><a id="DMAOG350"></a>
<div class="sect4">
<h5 class="sect4">Hybrid Columnar Compression (HCC) <a id="sthref63"></a><a id="sthref64"></a></h5>
<p>HCC is available with some storage formats and achieves its compression using a logical construct called the compression unit which is used to store a set of hybrid columnar-compressed rows. When data is loaded, a set of rows is pivoted into a columnar representation and compressed. After the column data for a set of rows has been compressed, it is fit into the compression unit. If conventional DML is issued against a table with HCC, the necessary data is uncompressed to do the modification and then written back to disk using a block-level compression algorithm.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
If your data set is frequently modified using conventional DML, then the use of HCC is not recommended; instead, the use of OLTP compression is recommended.</div>
<p>HCC provides different levels of compression, focusing on query performance or compression ratio respectively. With HCC optimized for query, fewer compression algorithms are applied to the data to achieve good compression with little to no performance impact. However, compression for archive tries to optimize the compression on disk, irrespective of its potential impact on the query performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
The discussion on HCC in <a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBAIJE"></a><a id="DMAOG165"></a>
<div class="sect2">
<h3 class="sect2">Tables for Supertype and Subtype Entities in Oracle Airlines Data Model</h3>
<p><a id="sthref65"></a><a id="sthref66"></a>A supertype is a generic entity type that has a relationship with one or more subtypes.</p>
<p><a id="sthref67"></a><a id="sthref68"></a>A subtype is a sub-grouping of the entities in an entity type that is meaningful to the organization and that shares common attributes or relationships distinct from other subgroups.</p>
<ul>
<li>
<p>Subtypes inherit all supertype attributes</p>
</li>
<li>
<p>Subtypes have attributes that are different from other subtypes</p>
</li>
</ul>
<p>For example, in the default Oracle Airlines Data Model, the table <code>DWB_PRTY_INTRATN</code> (Party Interaction) is a supertype that has a number of subtypes including <code>DWB_PRTY_INTRATN_CALL</code> (Party Interaction Call) and <code>DWB_PRTY_INTRATN_EML</code> (Party Interaction Email).</p>
<p class="subhead2"><a id="DMAOG166"></a>Recommendations: Tables for Supertype and Subtype Entities</p>
<p>Create separate tables for the super type and all sub type entities for the following reasons:</p>
<ul>
<li>
<p>Data integrity enforced at database level. (using <code>NOT NULL</code> column constraints)</p>
</li>
<li>
<p>Relationships can be accurately modeled and enforced including those which apply to only one subtype</p>
</li>
<li>
<p>Physical model closely resembles the logical data model.</p>
</li>
<li>
<p>It is easier to correlate the logical data model with the physical data model and support the logical data model enhancements and changes.</p>
</li>
<li>
<p>Physical data model reflects true business rules (for example, if there are some attributes or relationships mandatory for only one subtype.)</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDIHHFJ"></a><a id="DMAOG167"></a>
<div class="sect2">
<h3 class="sect2">Surrogate Keys in the Physical Model</h3>
<p><a id="sthref69"></a><a id="sthref70"></a>The surrogate key method for primary key construction involves taking the natural key components from the source systems and mapping them through a process of assigning a unique key value to each unique combination of natural key components (including source system identifier). The resulting primary key value is completely non-intelligent and is typically a numeric data type for maximum performance and storage efficiency.</p>
<p class="subhead2"><a id="DMAOG168"></a>Advantages of Surrogate keys include:</p>
<ul>
<li>
<p>Ensure uniqueness: data distribution</p>
</li>
<li>
<p>Independent of source systems</p>
</li>
<li>
<p>Re-numbering</p>
</li>
<li>
<p>Overlapping ranges</p>
</li>
<li>
<p>Uses the numeric data type which is the most performant data type for primary keys and joins</p>
</li>
</ul>
<p class="subhead2"><a id="DMAOG169"></a>Disadvantages of Surrogate keys:</p>
<ul>
<li>
<p>Have to allocate during ETL</p>
</li>
<li>
<p>Complex and expensive re-processing and data quality correction</p>
</li>
<li>
<p>Not used in queries &ndash; performance impact</p>
</li>
<li>
<p>The operational business intelligence requires natural keys to join to operational systems</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDBADHG"></a><a id="DMAOG170"></a>
<div class="sect2">
<h3 class="sect2">Integrity Constraints in Oracle Airlines Data Model</h3>
<p><a id="sthref71"></a>Integrity constraints are used to enforce business rules associated with your database and to prevent having invalid information in the tables. The most common types of constraints include:</p>
<ul>
<li>
<p><code>PRIMARY KEY</code> constraints, this is usually defined on the surrogate key column to ensure uniqueness of the record identifiers. In general, it is recommended that you specify the <code>ENFORCED ENABLED RELY</code> mode.</p>
</li>
<li>
<p><code>UNIQUE</code> constraints, to ensure that a given column (or set of columns) is unique. For slowly changing dimensions, it is recommended that you add a unique constraint on the Business Key and the Effective From Date columns to allow tracking multiple versions (based on surrogate key) of the same Business Key record.</p>
</li>
<li>
<p><code>NOT NULL</code> constraints, to ensure that no null values are allowed. For query rewrite scenarios, it is recommended that you have an inline explicit <code>NOT NULL</code> constraint on the primary key column in addition to the primary key constraint.</p>
</li>
<li>
<p><code>FOREIGN KEY</code> constraints, to ensure that relation between tables are being honored by the data. Usually in data warehousing environments, the foreign key constraint is present in <code>RELY DISABLE NOVALIDATE</code> mode.</p>
</li>
</ul>
<p>The Oracle Database uses constraints when optimizing SQL queries. Although constraints can be useful in many aspects of query optimization, constraints are particularly important for query rewrite of materialized views. Under some specific circumstances, constraints need space in the database. These constraints are in the form of the underlying unique index.</p>
<p>Unlike data in many relational database environments, data in a data warehouse is typically added or modified under controlled circumstances during the extraction, transformation, and loading (ETL) process.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJBEFG"></a><a id="DMAOG171"></a>
<div class="sect2">
<h3 class="sect2">Indexes and Partitioned Indexes in Oracle Airlines Data Model</h3>
<p><a id="sthref72"></a><a id="sthref73"></a>Indexes are optional structures associated with tables or clusters. In addition to the classical B-tree indexes, bitmap indexes are very common in data warehousing environments</p>
<ul>
<li>
<p>Bitmap indexes are optimized index structures for set-oriented operations. Additionally, they are necessary for some optimized data access methods such as star transformations. Bitmap indexes are typically only a fraction of the size of the indexed data in the table.</p>
</li>
<li>
<p>B-tree indexes are most effective for high-cardinality data: that is, for data with many possible values, such as customer name or phone number. However, fully indexing a large table with a traditional B-tree index can be prohibitively expensive in terms of disk space because the indexes can be several times larger than the data in the table. B-tree indexes can be stored specifically in a compressed manner to enable huge space savings, storing more keys in each index block, which also leads to less I/O and better performance.</p>
</li>
</ul>
<p class="subhead2"><a id="DMAOG172"></a>Recommendations: Indexes and Partitioned Indexes</p>
<p>Make the majority of the indexes in your customized Oracle Airlines Data Model bitmap indexes.</p>
<p>Use B-tree indexes only for unique columns or other columns with very high cardinalities (that is, columns that are almost unique). Store the B-tree indexes in a compressed manner.</p>
<p><a id="sthref74"></a><a id="sthref75"></a>Partition the indexes. Indexes are just like tables in that you can partition them, although the partitioning strategy is not dependent upon the table structure. Partitioning indexes makes it easier to manage the data warehouse during refresh and improves query performance.</p>
<p>Typically, specify the index on a partitioned table as local. Bitmap indexes on partitioned tables must always be local. B-tree indexes on partitioned tables can be global or local. However, in a data warehouse environment, local indexes are more common than global indexes. Use global indexes only when there is a specific requirement which cannot be met by local indexes (for example, a unique index on a non-partitioning key, or a performance requirement).</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDEDHHJ">"Partitioned Tables in the Oracle Airlines Data Model"</a>, <a href="adm.htm#CHDHFGEH">"Choosing Indexes for Materialized Views"</a>, <a href="adm.htm#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Airlines Data Model"</a>, and <a href="adm.htm#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEDHHJ"></a><a id="DMAOG173"></a>
<div class="sect2">
<h3 class="sect2">Partitioned Tables in the Oracle Airlines Data Model</h3>
<p><a id="sthref76"></a><a id="sthref77"></a>Partitioning allows a table, index or index-organized table to be subdivided into smaller pieces. Each piece of the database object is called a partition. Each partition has its own name, and may optionally have its own storage characteristics. From the perspective of a database administrator, a partitioned object has multiple pieces that can be managed either collectively or individually. This gives the administrator considerable flexibility in managing partitioned objects. However, from the perspective of the application, a partitioned table is identical to a non-partitioned table. No modifications are necessary when accessing a partitioned table using SQL DML commands.</p>
<p>As discussed in the following topics, partitioning can provide tremendous benefits to a wide variety of applications by improving manageability, availability, and performance:</p>
<ul>
<li>
<p><a href="#CHDFFJCG">Partitioning the Oracle Airlines Data Model for Manageability</a></p>
</li>
<li>
<p><a href="#CHDEDIDJ">Partitioning the Oracle Airlines Data Model for Easier Data Access</a></p>
</li>
<li>
<p><a href="#CHDDEEAA">Partitioning the Oracle Airlines Data Model for Join Performance</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
To understand the various partitioning techniques in Oracle Database, see the "Manipulating Partitions in Oracle Database 11<span class="italic">g</span>" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDJBEFG">"Indexes and Partitioned Indexes in Oracle Airlines Data Model"</a>, <a href="adm.htm#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Airlines Data Model"</a>, and <a href="adm.htm#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
<a id="CHDFFJCG"></a><a id="DMAOG174"></a>
<div class="sect3">
<h4 class="sect3">Partitioning the Oracle Airlines Data Model for Manageability</h4>
<p><a id="sthref78"></a>Range partitioning helps improve the manageability and availability of large volumes of data.</p>
<p>Consider the case where two year's worth of sales data or 100 terabytes (TB) is stored in a table. At the end of each day a new batch of data must be to loaded into the table and the oldest days worth of data must be removed. If the <code>Sales</code> table is range partitioned by day then the new data can be loaded using a partition exchange load. This is a sub-second operation that has little or no impact on end user queries.</p>
</div>
<!-- class="sect3" -->
<a id="CHDEDIDJ"></a><a id="DMAOG175"></a>
<div class="sect3">
<h4 class="sect3">Partitioning the Oracle Airlines Data Model for Easier Data Access</h4>
<p><a id="sthref79"></a>Range partitioning also helps ensure that only the necessary data to answer a query is scanned. Consider the case where business users predominately accesses the sales data on a weekly basis (for example, total sales per week) then range partitioning this table by day ensures that the data is accessed in the most efficient manner, as only seven partitions must be scanned to answer the business users query instead of the entire table. The ability to avoid scanning irrelevant partitions is known as partition pruning.</p>
</div>
<!-- class="sect3" -->
<a id="CHDDEEAA"></a><a id="DMAOG176"></a>
<div class="sect3">
<h4 class="sect3">Partitioning the Oracle Airlines Data Model for Join Performance</h4>
<p><a id="sthref80"></a><a id="sthref81"></a>Sub-partitioning by hash is used predominately for performance reasons. Oracle Database uses a linear hashing algorithm to create sub-partitions.</p>
<p>A major performance benefit of hash partitioning is partition-wise joins. Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves both CPU and memory resource usage. In a clustered data warehouse, this significantly reduces response times by limiting the data traffic over the interconnect (IPC), which is the key to achieving good scalability for massive join operations. Partition-wise joins can be full or partial, depending on the partitioning scheme of the tables to be joined.</p>
<p>As illustrated by <a href="#CHDBECGI">Figure 2-2, "Partitioning for Join Performance"</a>, a full partition-wise join divides a join between two large tables into multiple smaller joins. Each smaller join, performs a joins on a pair of partitions, one for each of the tables being joined. For the optimizer to choose the full partition-wise join method, both tables must be equi-partitioned on their join keys. That is, they have to be partitioned on the same column with the same partitioning method. Parallel execution of a full partition-wise join is similar to its serial execution, except that instead of joining one partition pair at a time, multiple partition pairs are joined in parallel by multiple parallel query servers. The number of partitions joined in parallel is determined by the Degree of Parallelism (DOP).</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDBECGI"></a><a id="DMAOG177"></a>Figure 2-2 Partitioning for Join Performance</p>
<img width="404" height="280" src="img/join1.gif" alt="Description of Figure 2-2 follows" /><br />
<a id="sthref82" href="img_text/join1.htm">Description of "Figure 2-2 Partitioning for Join Performance"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="subhead2"><a id="DMAOG333"></a>Recommendations: Number of Hash Partitions</p>
<p>In order to ensure that the data gets evenly distributed among the hash partitions it is highly recommended that the number of hash partitions is a power of 2 (for example, 2, 4, 8, and so on). A good rule of thumb to follow when deciding the number of hash partitions a table should have is <code>2 X # of CPUs</code> rounded to up to the nearest power of 2.</p>
<p>If your system has 12 CPUs, then 32 would be a good number of hash partitions. On a clustered system the same rules apply. If you have 3 nodes each with 4 CPUs, then 32 would still be a good number of hash partitions. However, ensure that each hash partition is at least 16MB in size. Many small partitions do not have efficient scan rates with parallel query. Consequently, if using the number of CPUs makes the size of the hash partitions too small, use the number of Oracle RAC nodes in the environment (rounded to the nearest power of 2) instead.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEFFJH"></a><a id="DMAOG178"></a>
<div class="sect2">
<h3 class="sect2">Parallel Execution in the Oracle Airlines Data Model</h3>
<p><a id="sthref83"></a>Parallel Execution enables a database task to be parallelized or divided into smaller units of work, thus allowing multiple processes to work concurrently. By using parallelism, a terabyte of data can be scanned and processed in minutes or less, not hours or days.</p>
<p><a href="#CHDJFAIC">Figure 2-3, "Parallel Execution of a Full Partition-Wise Join Between Two Tables"</a> illustrates the parallel execution of a full partition-wise join between two tables, Sales and Customers. Both tables have the same degree of parallelism and the same number of partitions. They are range partitioned on a date field and sub partitioned by hash on the <code>cust_id</code> field. As illustrated in the picture, each partition pair is read from the database and joined directly.</p>
<p>There is no data redistribution necessary, thus minimizing IPC communication, especially across nodes. Below figure shows the execution plan you would see for this join.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDJFAIC"></a><a id="DMAOG179"></a>Figure 2-3 Parallel Execution of a Full Partition-Wise Join Between Two Tables</p>
<img width="476" height="286" src="img/parthash.gif" alt="Surrounding text describes Figure 2-3 ." /><br /></div>
<!-- class="figure" -->
<p>To ensure that you get optimal performance when executing a partition-wise join in parallel, specify a number for the partitions in each of the tables that is larger than the degree of parallelism used for the join. If there are more partitions than parallel servers, each parallel server is given one pair of partitions to join, when the parallel server completes that join, it requests another pair of partitions to join. This process repeats until all pairs have been processed. This method enables the load to be balanced dynamically (for example, 128 partitions with a degree of parallelism of 32).</p>
<p>What happens if only one table that you are joining is partitioned? In this case the optimizer could pick a partial partition-wise join. Unlike full partition-wise joins, partial partition-wise joins can be applied if only one table is partitioned on the join key. Hence, partial partition-wise joins are more common than full partition-wise joins. To execute a partial partition-wise join, Oracle Database dynamically repartitions the other table based on the partitioning strategy of the partitioned table.</p>
<p>After the other table is repartitioned, the execution is similar to a full partition-wise join. The redistribution operation involves exchanging rows between parallel execution servers. This operation leads to interconnect traffic in Oracle RAC environments, since data must be repartitioned across node boundaries.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDJBDDH"></a><a id="DMAOG180"></a>Figure 2-4 Partial Partition-Wise Join</p>
<img width="404" height="275" src="img/partjoin2.gif" alt="Description of Figure 2-4 follows" /><br />
<a id="sthref84" href="img_text/partjoin2.htm">Description of "Figure 2-4 Partial Partition-Wise Join"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#CHDJBDDH">Figure 2-4, "Partial Partition-Wise Join"</a> illustrates a partial partition-wise join. It uses the same example as in <a href="#CHDJFAIC">Figure 2-3</a>, except that the customer table is not partitioned. Before the join operation is executed, the rows from the customers table are dynamically redistributed on the join key.</p>
<ul>
<li>
<p><a href="#CHDEDGDD">Enabling Parallel Execution for a Session</a></p>
</li>
<li>
<p><a href="#CHDCAFBJ">Enabling Parallel Execution of DML Operations</a></p>
</li>
<li>
<p><a href="#CHDEBFJD">Enabling Parallel Execution at the Table Level</a></p>
</li>
</ul>
<a id="CHDEDGDD"></a><a id="DMAOG181"></a>
<div class="sect3">
<h4 class="sect3">Enabling Parallel Execution for a Session</h4>
<p><a id="sthref85"></a>Parallel query is the most commonly used parallel execution feature in Oracle Database. Parallel execution can significantly reduce the elapsed time for large queries. To enable parallelization for an entire session, execute the following statement.</p>
<pre>
alter session enable parallel query; 
</pre></div>
<!-- class="sect3" -->
<a id="CHDCAFBJ"></a><a id="DMAOG182"></a>
<div class="sect3">
<h4 class="sect3">Enabling Parallel Execution of DML Operations</h4>
<p><a id="sthref86"></a>Data Manipulation Language (DML) operations such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> can be parallelized by Oracle Database. Parallel execution can speed up large DML operations and is particularly advantageous in data warehousing environments. To enable parallelization of DML statements, execute the following statement.</p>
<pre>
alter session enable parallel dml;
</pre>
<p>When you issue a DML statement such as an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, Oracle Database applies a set of rules to determine whether that statement can be parallelized. The rules vary depending on whether the statement is a DML <code>INSERT</code> statement, or a DML <code>UPDATE</code> or <code>DELETE</code> statement.</p>
<ul>
<li>
<p>The following rules apply when determining how to parallelize DML <code>UPDATE</code> and <code>DELETE</code> statements:</p>
<ul>
<li>
<p>Oracle Database can parallelize <code>UPDATE</code> and <code>DELETE</code> statements on partitioned tables, but only when multiple partitions are involved.</p>
</li>
<li>
<p>You cannot parallelize <code>UPDATE</code> or <code>DELETE</code> operations on a non-partitioned table or when such operations affect only a single partition.</p>
</li>
</ul>
</li>
<li>
<p>The following rules apply when determining how to parallelize DML <code>INSERT</code> statements:</p>
<ul>
<li>
<p>Standard <code>INSERT</code> statements using a <code>VALUES</code> clause cannot be parallelized.</p>
</li>
<li>
<p>Oracle Database can parallelize only <code>INSERT . . . SELECT . . . FROM</code> statements.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDEBFJD"></a><a id="DMAOG183"></a>
<div class="sect3">
<h4 class="sect3">Enabling Parallel Execution at the Table Level</h4>
<p>The setting of parallelism for a table influences the optimizer. Consequently, when using parallel query, also enable parallelism at the table level by issuing the following statement.</p>
<pre>
alter table &lt;table_name&gt; parallel 32;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2035">
<tr>
<td class="cellalignment2044">
<table class="cellalignment2040">
<tr>
<td class="cellalignment2039"><a href="impintro.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2039"><a href="adm.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2046">
<table class="cellalignment2038">
<tr>
<td class="cellalignment2039"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2039"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2039"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2039"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2039"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2039"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
