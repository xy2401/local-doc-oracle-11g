<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Physical Model Customization</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 740" />
<meta name="dcterms.created" content="2013-10-17T14:37:19Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Communications Data Model Implementation and Operations Guide" />
<meta name="dcterms.identifier" content="E28442-05" />
<meta name="dcterms.isVersionOf" content="CDMOG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="impintro.htm" title="Previous" type="text/html" />
<link rel="Next" href="adm.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e28442.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">7/15</span> <!-- End Header -->
<div id="CDMOG147" class="chapter"><a id="CHDFIAJJ"></a>
<h1 class="chapter"><span class="secnum">2</span> Physical Model Customization</h1>
<p><a id="sthref20"></a>This chapter provides general information about customizing the physical model of Oracle Communications Data Model and more detailed information about customizing the foundation layer of the physical model. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDCJJCJ">Characteristics of the Default Physical Model</a></p>
</li>
<li>
<p><a href="#CHDFEDEF">Customizing the Oracle Communications Data Model Physical Model</a></p>
</li>
<li>
<p><a href="#CHDDJFDJ">Foundation Layer Customization</a></p>
</li>
<li>
<p><a href="#CHDDFHCA">General Recommendations When Designing Physical Structures</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="adm.htm#CHDDHGHC">Chapter 3, "Access Layer Customization"</a></div>
<a id="CHDCJJCJ"></a>
<div id="CDMOG148" class="sect1">
<h2 class="sect1">Characteristics of the Default Physical Model</h2>
<p><a id="sthref21"></a><a id="sthref22"></a>The default physical model of Oracle Communications Data Model defines:</p>
<dl>
<dd>1800+ tables and 40,000+ columns</dd>
<dd>5000+ industry-specific measures and KPIs</dd>
<dd>7 pre-built data mining models</dd>
<dd>22 pre-built OLAP cubes</dd>
</dl>
<p>The default physical model of the Oracle Communications Data Model shares characteristics of a multischema "traditional" data warehouse, as described in <a href="#CHDDDDDD">"Layers in a "Traditional" Data Warehouse"</a>, but defines all data structures in a single schema as described in <a href="#CHDIJHEF">"Layers in the Default Oracle Communications Data Model Warehouse"</a>.</p>
<p class="subhead2"><a id="CHDDDDDD"></a><a id="CDMOG149"></a>Layers in a "Traditional" Data Warehouse</p>
<p><a id="sthref23"></a>Historically, three layers are defined for a data warehouse environment:</p>
<ul>
<li>
<p><span class="bold">Staging layer.</span> This layer is used when moving data from the operational system and other data sources into the data warehouse itself. It consists of temporary loading structures and rejected data. Having a staging layer enables the speedy extraction, transformation and loading (ETL) of data from your operational systems into data warehouse without disturbing any of the business users. It is in this layer the much of the complex data transformation and data quality processing occurs. The most basic approach for the design of the staging layer is as a schema identical to the one that exists in the source operational system.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In some implementations this layer is not necessary, because all data transformation processing is done as needed as data is extracted from the source system before it is inserted directly into the foundation layer.</div>
</li>
<li>
<p><a id="sthref24"></a><span class="bold">Foundation or integration layer.</span> This layer is traditionally implemented as a Third Normal Form (3NF) schema. A 3NF schema is a neutral schema design independent of any application, and typically has many tables. It preserves a detailed record of each transaction without any data redundancy and allows for rich encoding of attributes and all relationships between data elements. Users typically require a solid understanding of the data to navigate the more elaborate structure reliably. In this layer data begins to take shape and it is not uncommon to have some end-user application access data from this layer especially if they are time sensitive, as data becomes available here before it is transformed into the Access and Performance layer.</p>
</li>
<li>
<p><a id="sthref25"></a><span class="bold">Access layer.</span> This layer is traditionally defined as a snowflake or star schema that describes a "flattened" or dimensional view of the data.</p>
</li>
</ul>
<p class="subhead2"><a id="CHDIJHEF"></a><a id="CDMOG150"></a>Layers in the Default Oracle Communications Data Model Warehouse</p>
<p><a id="sthref26"></a>Oracle Communications Data Model warehouse environment also consists of three layers However, as indicated by the dotted line in <a href="#CHDFJJGA">Figure 2-1, "Layers of an Oracle Communications Data Model Warehouse"</a>, in the Oracle Communications Data Model the definitions of the foundation and access layers are combined in a single schema.</p>
<div id="CDMOG151" class="figure">
<p class="titleinfigure"><a id="CHDFJJGA"></a>Figure 2-1 Layers of an Oracle Communications Data Model Warehouse</p>
<img width="818" height="766" src="img/physlayers.gif" alt="Description of Figure 2-1 follows" /><br />
<a id="sthref27" href="img_text/physlayers.htm">Description of "Figure 2-1 Layers of an Oracle Communications Data Model Warehouse"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The layers in the Oracle Communications Data Model warehouse are:</p>
<ul>
<li>
<p><span class="bold"><a id="sthref28"></a><a id="sthref29"></a>Staging layer</span>. As in a "traditional" data warehouse environment, an Oracle Communications Data Model warehouse environment can have a staging layer. Because the definition of this layer varies by customer, a definition of this area is not provided as part of Oracle Communications Data Model.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are using an application adapter for Oracle Communications Data Model to populate the foundation layer of Oracle Communications Data Model, then that adapter defines and populates an Oracle Communications Data Model staging layer.</div>
</li>
<li>
<p><span class="bold">Foundation and Access layers.</span> The physical objects for these layers are defined in a single schema, the <code>ocdm_sys</code> schema:</p>
<ul>
<li>
<p><a id="sthref30"></a><a id="sthref31"></a><span class="bold">Foundation layer.</span> The foundation layer of the Oracle Communications Data Model is defined by base tables that present the data in 3NF (that is, tables that have the <code>DWB_</code> prefix). This layer also includes reference, lookup, and control tables defined in the <code>ocdm_sys</code> schema (that is, the tables that have the <code>DWR_</code> , <code>DWL_</code>, <code>DWC_</code> prefixes).</p>
</li>
<li>
<p><a id="sthref32"></a><a id="sthref33"></a><span class="bold">Access layer.</span> The access layer of Oracle Communications Data Model is defined by derived and aggregate tables (defined with <code>DWD_</code> and <code>DWA_</code> prefixes), cubes (defined with a <code>CB$</code> prefix), and views (that is, views defined with the <code>DWV_</code> prefix), and cube views (defined with <code>_VIEW</code> suffix). These structures provide a summarized or "flattened" perspectives of the data in the foundation layer.</p>
<p>This layer also contains the results of the data mining models which are stored in derived (<code>DWD_</code>) tables. The access layer also includes the tables with prefixes as shown in <a href="#CHDDHIHF">Table 2-1</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink CDMRF" href="../e28440/toc.htm"><span class="italic">Oracle Communications Data Model Reference</span></a> for detailed information on the <code>ocdm_sys</code> schema.</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="CHDFEDEF"></a>
<div id="CDMOG152" class="sect1">
<h2 class="sect1">Customizing the Oracle Communications Data Model Physical Model</h2>
<p><a id="sthref34"></a><a id="sthref35"></a>The starting point for the Oracle Communications Data Model physical data model is the 3NF logical data model. The physical data model mirrors the logical model as much as possible, (although some changes in the structure of the tables or columns may be necessary) and defines database objects (such as tables, cubes, and views).</p>
<p>To customize the default physical model of the Oracle Communications Data Model take the following steps:</p>
<ol>
<li>
<p>Answer the questions outlined in <a href="#CHDFDDGD">"Questions to Answer Before You Customize the Physical Model"</a>.</p>
</li>
<li>
<p>Familiarize yourself with the characteristics of the logical and physical model of Oracle Communications Data Model as outlined in<a href="#CHDCJJCJ">"Characteristics of the Default Physical Model"</a> and presented in detail in <span class="italic">Oracle Communications Data Model Reference</span>.</p>
</li>
<li>
<p>Modify the foundation level of your physical model of Oracle Communications Data Model, as needed. See <a href="#CHDHEHDA">"Common Change Scenarios"</a> for a discussion of when customization might be necessary.</p>
<p>When defining physical structures:</p>
<ul>
<li>
<p>Keep the foundation layer in 3NF form.</p>
</li>
<li>
<p>Use the information presented in <a href="#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a> to guide you when designing the physical objects.</p>
</li>
<li>
<p>Follow the conventions used when creating the default physical model of Oracle Communications Data Model as outlined in <a href="#CHDFGAAG">"Conventions When Customizing the Physical Model"</a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Package the changes you make to the physical data model as a patch to the <code>ocdm_sys</code> schema.</div>
</li>
<li>
<p>Modify the access layer of your physical model of Oracle Communications Data Model as discussed in <a href="adm.htm#CHDDHGHC">Chapter 3, "Access Layer Customization"</a>.</p>
</li>
<li>
<p>Modify existing or create a new Intra-ETL packages to feed the changes you make in the access layer, as discussed in <a href="etlmap.htm#BEHJFAFF">Chapter 4, "ETL Implementation and Customization"</a>.</p>
</li>
</ol>
<a id="CHDFDDGD"></a>
<div id="CDMOG153" class="sect2">
<h3 class="sect2">Questions to Answer Before You Customize the Physical Model</h3>
<p><a id="sthref36"></a><a id="sthref37"></a>When designing the physical model remember that the logical data model is not one-to-one with the physical data model. Consider the load, query, and maintenance requirements when you convert the logical data model into the physical layer. For example, answer the following questions before you design the physical data model:</p>
<ul>
<li>
<p>Do you need the physical data model to cover the full scope of the logical data model, or only part of the scope?</p>
<p><a href="#CHDHEHDA">"Common Change Scenarios"</a> provides an overview discussion of making physical data model changes when your business needs do not result in a logical model that is the same as the Oracle Communications Data Model logical model.</p>
</li>
<li>
<p>What is the result of the source data profile?</p>
</li>
<li>
<p>What is the data load frequency for each table?</p>
</li>
<li>
<p>How many large tables are there and which tables are these?</p>
</li>
<li>
<p>How will the tables and columns be accessed? What are the common joins?</p>
</li>
<li>
<p>What is your data backup strategy?</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFGAAG"></a>
<div id="CDMOG154" class="sect2">
<h3 class="sect2">Conventions When Customizing the Physical Model</h3>
<p><a id="sthref38"></a><a id="sthref39"></a><a id="sthref40"></a>When developing the physical model for Oracle Communications Data Model, the conventions outlined below were followed. Continue to follow these conventions as you customize the physical model.</p>
<p class="subhead2"><a id="CHDDEGEF"></a><a id="CDMOG155"></a>General Naming Conventions for Physical Objects</p>
<p><a id="sthref41"></a>Follow these guidelines for naming physical objects that you define:</p>
<ul>
<li>
<p>When naming the physical objects follow the naming guidelines for naming objects within an Oracle Database schema. For example:</p>
<ul>
<li>
<p>Table and column names must start with a letter, can use only 30 alphanumeric characters or less, cannot contain spaces or some special characters such as "!" and cannot use reserved words.</p>
</li>
<li>
<p>Table names must be unique within a schema that is shared with views and synonyms.</p>
</li>
<li>
<p>Column names must be unique within a table.</p>
</li>
</ul>
</li>
<li>
<p>Although it is common to use abbreviations in the physical modeling stage, as much as possible, use names for the physical objects that correspond to the names of the entities in the logical model. Use consistent abbreviations to avoid programmer and user confusion.</p>
</li>
<li>
<p>When naming columns, use short names if possible. Short column names reduce the time required for SQL command parsing.</p>
</li>
<li>
<p>The <code>ocdm_sys</code> schema delivered with Oracle Communications Data Model uses the prefixes and suffixes shown <a href="#CHDDHIHF">Table 2-1</a> to identify object types.</p>
<div id="CDMOG407" class="tblformalwide">
<p class="titleintable"><a id="sthref42"></a><a id="CHDDHIHF"></a>Table 2-1 Default Physical Object Prefixes and Suffixes in Oracle Communications Data Model</p>
<table class="cellalignment2082" title="Default Physical Object Prefixes and Suffixes in Oracle Communications Data Model" summary="Default Prefixes and Suffixes" dir="ltr">
<thead>
<tr class="cellalignment2076">
<th class="cellalignment2083" id="r1c1-t7">Prefix or Suffix</th>
<th class="cellalignment2083" id="r1c2-t7">Used for Name of These Objects</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r2c1-t7" headers="r1c1-t7">
<p><code>_VIEW</code></p>
</td>
<td class="cellalignment2084" headers="r2c1-t7 r1c2-t7">
<p>A relational view of an OLAP cube, dimension, or hierarchy.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r3c1-t7" headers="r1c1-t7">
<p><code>CCB_</code></p>
</td>
<td class="cellalignment2084" headers="r3c1-t7 r1c2-t7">
<p>Customized OLAP cubes.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r4c1-t7" headers="r1c1-t7">
<p><code>CUBE</code></p>
</td>
<td class="cellalignment2084" headers="r4c1-t7 r1c2-t7">
<p>Created when OLAP cubes are built. Used to store logs and results.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r5c1-t7" headers="r1c1-t7">
<p><code>DM$</code></p>
</td>
<td class="cellalignment2084" headers="r5c1-t7 r1c2-t7">
<p>Created when the mining models are trained. Used to store trained model and logs.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r6c1-t7" headers="r1c1-t7">
<p><code>DMV_</code></p>
</td>
<td class="cellalignment2084" headers="r6c1-t7 r1c2-t7">
<p>Materialized view created for performance reasons (that is, <span class="italic">not</span> an aggregate table or an OLAP cube).</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r7c1-t7" headers="r1c1-t7">
<p><code>DR$</code></p>
</td>
<td class="cellalignment2084" headers="r7c1-t7 r1c2-t7">
<p>Created when the mining models are trained. Used to store trained model and logs.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r8c1-t7" headers="r1c1-t7">
<p><code>DWA_</code></p>
</td>
<td class="cellalignment2084" headers="r8c1-t7 r1c2-t7">
<p>Aggregate tables which are materialized views.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r9c1-t7" headers="r1c1-t7">
<p><code>DWB_</code></p>
</td>
<td class="cellalignment2084" headers="r9c1-t7 r1c2-t7">
<p>Base transaction data (3NF) tables.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r10c1-t7" headers="r1c1-t7">
<p><code>DWC_</code></p>
</td>
<td class="cellalignment2084" headers="r10c1-t7 r1c2-t7">
<p>Control tables.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r11c1-t7" headers="r1c1-t7">
<p><code>DWD_</code></p>
</td>
<td class="cellalignment2084" headers="r11c1-t7 r1c2-t7">
<p>Derived tables -- including data mining result tables.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r12c1-t7" headers="r1c1-t7">
<p><code>DWL_</code></p>
</td>
<td class="cellalignment2084" headers="r12c1-t7 r1c2-t7">
<p>Lookup tables.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r13c1-t7" headers="r1c1-t7">
<p><code>DWR_</code></p>
</td>
<td class="cellalignment2084" headers="r13c1-t7 r1c2-t7">
<p>Reference data tables.</p>
</td>
</tr>
<tr class="cellalignment2076">
<td class="cellalignment2084" id="r14c1-t7" headers="r1c1-t7">
<p><code>DWV_</code></p>
</td>
<td class="cellalignment2084" headers="r14c1-t7 r1c2-t7">
<p>Relational view of time dimension</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink CDMRF" href="../e28440/toc.htm"><span class="italic">Oracle Communications Data Model Reference</span></a> for detailed information about the objects in the default Oracle Communications Data Model.</div>
</li>
</ul>
<p class="subhead2"><a id="CDMOG326"></a>Domain Definition Standards</p>
<p>A domain is a set of values allowed for a column. The domain can be enforced by a foreign key, check constraints, or the application on top of the database. Define the standards for each domain across the model such as:</p>
<ul>
<li>
<p>Date and time type, such as <code>'YYYY-MM-DD'</code>. For example, be aware that most date columns (abbreviation DT) in Oracle Communications Data Model may contain the time, such as <code>EVT_STRT_DT</code>. There is no separate <code>TIME</code> column.</p>
</li>
<li>
<p>Numeric value in different situations. For example, all columns of type <code>COUNT</code> are <code>NUMBER(16,0)</code> while all monetary-like columns (<code>AMOUNT</code>) are <code>NUMBER(22,7)</code>.</p>
</li>
<li>
<p>Character string length in different situations. For example, all Code columns are <code>VARCHAR2(120)</code>, Name (<code>NAME</code>) and Description columns (<code>DSCR</code>) are respectively 500 and 1000 characters long (with some exceptions). Indicator columns (<code>IND</code>) are <code>CHAR(1)</code>.</p>
</li>
<li>
<p>Coded value definition such as key or description. For example, all "Key" columns are <code>NUMBER(30)</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDJFDJ"></a>
<div id="CDMOG327" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Foundation Layer Customization</h2>
<p>The first step in customizing the physical model of Oracle Communications Data Model is customizing the foundation layer of the physical data model. Since, as mentioned in <a href="#CHDIJHEF">"Layers in the Default Oracle Communications Data Model Warehouse"</a>, the foundation layer of the physical model mirrors the 3NF logical model of Oracle Communications Data Model, you might choose to customize the foundation layer to reflect differences between your logical model needs and the default logical model of Oracle Communications Data Model. Additionally, you might need to customize the physical objects in the foundation layer to improve performance (for example, you might choose to compress some foundation layer tables).</p>
<p>When making changes to the foundation layer, keep the following points in mind:</p>
<ul>
<li>
<p>When changing the foundation layer objects to reflect your logical model design, make as few changes as possible. <a href="#CHDHEHDA">"Common Change Scenarios"</a> outlines the most common customization changes you will make in this regard.</p>
</li>
<li>
<p>When defining new foundation layer objects or when redesigning existing foundation layer objects for improved performance, follow the <a href="#CHDDFHCA">"General Recommendations When Designing Physical Structures"</a> and <a href="#CHDFGAAG">"Conventions When Customizing the Physical Model"</a>.</p>
</li>
<li>
<p>Remember that changes to the foundation layer objects can also impact the access layer objects.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Approach any attempt to change the Oracle Communications Data Model with caution. The foundation layer of the physical model of the Oracle Communications Data Model has (at its core) a set of generic structures that allow it to be flexible and extensible. You may disable temporarily Foreign Keys and constraints if required but do not forget to set them back when the entities are back in use. Before making extensive additions, deletions, or changes, ensure that you understand the full range of capabilities of Oracle Communications Data Model and that you cannot handle your requirements using the default objects in the foundation layer.
<p>Before making changes, review Appendix C, "Product Assumptions" in <span class="italic">Oracle Communications Data Model Reference</span>. For more information, see <a class="olink CDMRF2080" href="../../doc.112/e28440/app_assumption.htm#CDMRF2080"><span class="italic">Oracle Communications Data Model Reference</span></a>.</p>
</div>
<a id="CHDHEHDA"></a>
<div id="CDMOG328" class="sect2">
<h3 class="sect2">Common Change Scenarios</h3>
<p><a id="sthref43"></a>There are several common change scenarios when customizing the foundation layer of the physical data model:</p>
<ul>
<li>
<p><span class="bold">Additions to Existing Structures</span></p>
<p>If you identify business areas or processes that are not supported in the default foundation layer of the physical data model of Oracle Communications Data Model, add new tables and columns.</p>
<p>Carefully study the default foundation layer of the physical data model of Oracle Communications Data Model (and the underlying logical data model) to avoid building redundant structures when making additions. If these additions add high value to your business value, communicate the additions back to the Oracle Communications Data Model Development Team for possible inclusion in future releases of Oracle Communications Data Model.</p>
</li>
<li>
<p><span class="bold">Deletions of Existing Structures</span></p>
<p>If there are areas of the model that cannot be matched to any of the business requirements of your legacy systems, it is safer to keep these structures and not populate that part of the warehouse.</p>
<p>Deleting a table in the foundation layer of the physical data model can destroy relationships needed in other parts of the model or by applications based on the it. Some tables may not be needed during the initial implementation, but you may want to use these structures at a later time. If this is a possibility, keeping the structures now saves re-work later. If tables are deleted, perform a thorough analysis to identify all relationships originating from that entity.</p>
</li>
<li>
<p><span class="bold">Changes to Existing Structures</span></p>
<p>In some situations some structures in the foundation layer of the physical data model of the Oracle Communications Data Model may not exactly match the corresponding structures that you use.</p>
<p>Before implementing changes, identify the impact that the changes would have on the database design of Oracle Communications Data Model. Also identify the impact on any applications based on the new design.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDFHCA"></a>
<div id="CDMOG157" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">General Recommendations When Designing Physical Structures</h2>
<p><a id="sthref44"></a><a id="sthref45"></a>The <code>ocdm_sys</code> schema delivered with Oracle Communications Data Model was designed and defined following best practices for data access and performance. Continue to use these practices when you add new physical objects. This section provides information about how decisions about the following physical design aspects were made to the default Oracle Communications Data Model:</p>
<ul>
<li>
<p><a href="#CHDGHEEC">Tablespaces in the Oracle Communications Data Model</a></p>
</li>
<li>
<p><a href="#CHDFJDEE">Data Compression in the Oracle Communications Data Model</a></p>
</li>
<li>
<p><a href="#CHDBAIJE">Tables for Supertype and Subtype Entities in Oracle Communications Data Model</a></p>
</li>
<li>
<p><a href="#CHDIHHFJ">Surrogate Keys in the Physical Model</a></p>
</li>
<li>
<p><a href="#CHDBADHG">Integrity Constraints in Oracle Communications Data Model</a></p>
</li>
<li>
<p><a href="#CHDJBEFG">Indexes and Partitioned Indexes in the Oracle Communications Data Model</a></p>
</li>
<li>
<p><a href="#CHDEDHHJ">Partitioned Tables in the Oracle Communications Data Model</a></p>
</li>
<li>
<p><a href="#CHDEFFJH">Parallel Execution in the Oracle Communications Data Model</a></p>
</li>
</ul>
<a id="CHDGHEEC"></a>
<div id="CDMOG158" class="sect2">
<h3 class="sect2">Tablespaces in the Oracle Communications Data Model</h3>
<p><a id="sthref46"></a><a id="sthref47"></a>A tablespace consists of one or more data files, which are physical structures within the operating system you are using.</p>
<p class="subhead2"><a id="CDMOG159"></a>Recommendations: Defining Tablespaces</p>
<p>If possible, define tablespaces so that they represent logical business units.</p>
<p>Use ultra large data files for a significant improvement in very large Oracle Communications Data Model warehouse.</p>
<p class="subhead2"><a id="CDMOG160"></a>Changing the Tablespace and Partitions Used by Tables</p>
<p><a id="sthref48"></a>You can change the tablespace and partitions used by Oracle Communications Data Model tables. What you do depends on whether the Oracle Communications Data Model table has partitions:</p>
<ul>
<li>
<p>For tables that do not have partitions (that is, lookup tables and reference tables), you can change the existing tablespace for a table.</p>
<p>By default, Oracle Communications Data Model defines the partitioned tables as interval partitioning, which means the partitions are created only when new data arrives.</p>
<p>Consequently, for Oracle Communications Data Model tables that have partitions (that is, Base, Derived, and Aggregate tables), for the new interval partitions to be generated in new tablespaces rather than current ones, issue the following statements.</p>
<pre>
ALTER TABLE <span class="italic">table_name</span> MODIFY DEFAULT ATTRIBUTES 
TABLESPACE <span class="italic">new_tablespace_name</span>;
 
</pre>
<p>When new data is inserted in the table specified by <span class="italic">table_name</span>, a new partition is automatically created in the tablespace specified by <span class="italic">tablespace new_tablespace_name</span>.</p>
</li>
<li>
<p>For tables that have partitions (that is, base, derived, and aggregate tables), you can specify that new interval partitions be generated into new tablespaces.</p>
<p>For Oracle Communications Data Model tables that do not have partitions (that is, lookup tables and reference tables), to change the existing tablespace for a table then issue the following statement.</p>
<pre>
ALTER TABLE <span class="italic">table_name</span> MOVE TABLESPACE <span class="italic">new_tablespace_name</span>;
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDFJDEE"></a>
<div id="CDMOG161" class="sect2">
<h3 class="sect2">Data Compression in the Oracle Communications Data Model</h3>
<p><a id="sthref49"></a><a id="sthref50"></a>A key decision that you must make is whether to compress your data. Using table compression reduces disk and memory usage, often resulting in better scale-up performance for read-only operations. Table compression can also speed up query execution by minimizing the number of round trips required to retrieve data from the disks. Compressing data however imposes a performance penalty on the load speed of the data.</p>
<p class="subhead2"><a id="CDMOG162"></a>Recommendations: Data Compression</p>
<p>In general, choose to compress the data. The overall performance gain typically outweighs the cost of compression.</p>
<p>If you decide to use compression, consider sorting your data before loading it to achieve the best possible compression rate. The easiest way to sort incoming data is to load it using an <code>ORDER BY</code> clause on either the CTAS or IAS statement ("Create Table As Select" or "Insert As Select" types of statements). Specify an <code>ORDER BY</code> a <code>NOT NULL</code> column (ideally non numeric) that has many distinct values (1,000 to 10,000).</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDIBBIA">"Types of Data Compression Available"</a> and <a href="adm.htm#CHDHIGBI">"Compressing Materialized Views"</a>.</div>
<a id="CHDIBBIA"></a>
<div id="CDMOG163" class="sect3">
<h4 class="sect3">Types of Data Compression Available</h4>
<p><a id="sthref51"></a><a id="sthref52"></a>Oracle Database offers the following types of compression:</p>
<ul>
<li>
<p><a href="#CHDFJADH">Basic or Standard Compression</a></p>
</li>
<li>
<p><a href="#CHDFIAJD">OLTP Compression</a></p>
</li>
<li>
<p><a href="#CHDIHFFB">Hybrid Columnar Compression</a></p>
</li>
</ul>
<a id="CHDFJADH"></a>
<div id="CDMOG329" class="sect4">
<h5 class="sect4">Basic or Standard Compression</h5>
<p>With standard compression Oracle Database compresses data by eliminating duplicate values in a database block. Standard compression only works for direct path operations (CTAS or IAS). If the data is modified using any kind of conventional DML operation (for example updates), the data within that database block is uncompressed to make the modifications and is written back to disk uncompressed.</p>
<p><a id="sthref53"></a><a id="sthref54"></a>By using a compression algorithm specifically designed for relational data, Oracle Database can compress data effectively and in such a way that Oracle Database incurs virtually no performance penalty for SQL queries accessing compressed tables.</p>
<p>Oracle Communications Data Model leverages the compress feature for all base, derived, and aggregate tables which reduces the amount of data being stored, reduces memory usage (more data per memory block), and increases query performance.</p>
<p>You can specify table compression by using the <code>COMPRESS</code> clause of the <code>CREATE TABLE</code> statement or you can enable compression for an existing table by using <code>ALTER TABLE</code> statement as shown below.</p>
<pre>
alter table &lt;tablename&gt; move compress;
</pre>
<div id="CDMOG330" class="example">
<p class="titleinexample"><a id="sthref55"></a>Example 2-1 Creating a Compressed Table for Oracle Communications Data Model</p>
<p>To create a compressed table named <code>CWB_ACCS_MTHD_PORT_HIST</code>.</p>
<pre>
COMPRESS
Create table CWB_ACCS_MTHD_PORT_HIST 
(NP_RQST_HDR_CD                 VARCHAR2(30) 
,ACCS_MTHD_KEY                   NUMBER(30)  NOT NULL ENABLE  
,EXTRNL_OPRTR_KEY                NUMBER(30)  
&hellip;..
)  
tablespace TBS_BASE 
COMPRESS ;
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="CHDFIAJD"></a>
<div id="CDMOG331" class="sect4">
<h5 class="sect4">OLTP Compression</h5>
<p>OLTP compression is a component of the Advanced Compression option. With OLTP compression, just like standard compression, Oracle Database compresses data by eliminating duplicate values in a database block. But unlike standard compression OLTP compression allows data to remain compressed during all types of data manipulation operations, including conventional DML such as <code>INSERT</code> and <code>UPDATE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See:</p>
<a class="olink ADMIN" href="../../server.112/e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information on OLTP table compression features.</div>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
For more information on Oracle Advanced Compression, see the "Using Table Compression to Save Storage Costs" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
</div>
<!-- class="sect4" -->
<a id="CHDIHFFB"></a>
<div id="CDMOG332" class="sect4">
<h5 class="sect4">Hybrid Columnar Compression <a id="sthref56"></a></h5>
<p>is available with some storage formats and achieves its compression using a logical construct called the compression unit which is used to store a set of hybrid columnar-compressed rows. When data is loaded, a set of rows is pivoted into a columnar representation and compressed. After the column data for a set of rows has been compressed, it is fit into the compression unit. If conventional DML is issued against a table with Hybrid Columnar Compression, the necessary data is uncompressed to do the modification and then written back to disk using a block-level compression algorithm.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
If your data set is frequently modified using conventional DML, then the use of Hybrid Columnar Compression is not recommended; instead, the use of OLTP compression is recommended.</div>
<p>Hybrid Columnar Compression provides different levels of compression, focusing on query performance or compression ratio respectively. With Hybrid Columnar Compression optimized for query, fewer compression algorithms are applied to the data to achieve good compression with little to no performance impact. However, compression for archive tries to optimize the compression on disk, irrespective of its potential impact on the query performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
The discussion on Hybrid Columnar Compression in <a class="olink CNCPT89198" href="../../server.112/e40540/tablecls.htm#CNCPT89198"><span class="italic">Oracle Database Concepts</span></a>.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDBAIJE"></a>
<div id="CDMOG165" class="sect2">
<h3 class="sect2">Tables for Supertype and Subtype Entities in Oracle Communications Data Model</h3>
<p><a id="sthref57"></a><a id="sthref58"></a>A supertype is a generic entity type that has a relationship with one or more subtypes.</p>
<p><a id="sthref59"></a><a id="sthref60"></a>A subtype is a sub-grouping of the entities in an entity type that is meaningful to the organization and that shares common attributes or relationships distinct from other subgroups.</p>
<ul>
<li>
<p>Subtypes inherit all supertype attributes</p>
</li>
<li>
<p>Subtypes have attributes that are different from other subtypes</p>
</li>
</ul>
<p class="subhead2"><a id="CDMOG166"></a>Recommendations: Tables for Supertype and Subtype Entities</p>
<p>Create separate tables for the super type and all sub type entities for the following reasons:</p>
<ul>
<li>
<p>Data integrity enforced at database level. (using <code>NOT NULL</code> column constraints)</p>
</li>
<li>
<p>Relationships can be accurately modeled and enforced including those which apply to only one subtype</p>
</li>
<li>
<p>Physical model closely resembles the logical data model.</p>
</li>
<li>
<p>It is easier to correlate the logical data model with the physical data model and support the logical data model enhancements and changes.</p>
</li>
<li>
<p>Physical data model reflects true business rules (for example, if there are some attributes or relationships mandatory for only one subtype.)</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDIHHFJ"></a>
<div id="CDMOG167" class="sect2">
<h3 class="sect2">Surrogate Keys in the Physical Model</h3>
<p><a id="sthref61"></a><a id="sthref62"></a>The surrogate key method for primary key construction involves taking the natural key components from the source systems and mapping them through a process of assigning a unique key value to each unique combination of natural key components (including source system identifier). The resulting primary key value is completely non-intelligent and is typically a numeric data type for maximum performance and storage efficiency.</p>
<p class="subhead2"><a id="CDMOG168"></a>Advantages of Surrogate keys include:</p>
<ul>
<li>
<p>Ensure uniqueness: data distribution</p>
</li>
<li>
<p>Independent of source systems</p>
</li>
<li>
<p>Re-numbering</p>
</li>
<li>
<p>Overlapping ranges</p>
</li>
<li>
<p>Uses the numeric data type which is the most performant data type for primary keys and joins</p>
</li>
</ul>
<p class="subhead2"><a id="CDMOG169"></a>Disadvantages of Surrogate keys:</p>
<ul>
<li>
<p>Have to allocate during ETL</p>
</li>
<li>
<p>Complex and expensive re-processing and data quality correction</p>
</li>
<li>
<p>Not used in queries &ndash; performance impact</p>
</li>
<li>
<p>The operational business intelligence requires natural keys to join to operational systems</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDBADHG"></a>
<div id="CDMOG170" class="sect2">
<h3 class="sect2">Integrity Constraints in Oracle Communications Data Model</h3>
<p><a id="sthref63"></a>Integrity constraints are used to enforce business rules associated with your database and to prevent having invalid information in the tables. The most common types of constraints include:</p>
<ul>
<li>
<p><code>PRIMARY KEY</code> constraints, this is usually defined on the surrogate key column to ensure uniqueness of the record identifiers. In general, it is recommended that you specify the <code>ENFORCED ENABLED RELY</code> mode.</p>
</li>
<li>
<p><code>UNIQUE</code> constraints, to ensure that a given column (or set of columns) is unique. For slowly changing dimensions, it is recommended that you add a unique constraint on the Business Key and the Effective From Date columns to allow tracking multiple versions (based on surrogate key) of the same Business Key record.</p>
</li>
<li>
<p><code>NOT NULL</code> constraints, to ensure that no null values are allowed. For query rewrite scenarios, it is recommended that you have an inline explicit <code>NOT NULL</code> constraint on the primary key column in addition to the primary key constraint.</p>
</li>
<li>
<p><code>FOREIGN KEY</code> constraints, to ensure that relation between tables are being honored by the data. Usually in data warehousing environments, the foreign key constraint is present in <code>RELY DISABLE NOVALIDATE</code> mode.</p>
</li>
</ul>
<p>The Oracle Database uses constraints when optimizing SQL queries. Although constraints can be useful in many aspects of query optimization, constraints are particularly important for query rewrite of materialized views. Under some specific circumstances, constraints need space in the database. These constraints are in the form of the underlying unique index.</p>
<p>Unlike data in many relational database environments, data in a data warehouse is typically added or modified under controlled circumstances during the extraction, transformation, and loading (ETL) process, therefore, most foreign key columns in Oracle Communications Data Model are nullable.</p>
</div>
<!-- class="sect2" -->
<a id="CHDJBEFG"></a>
<div id="CDMOG171" class="sect2">
<h3 class="sect2">Indexes and Partitioned Indexes in the Oracle Communications Data Model</h3>
<p><a id="sthref64"></a><a id="sthref65"></a>Indexes are optional structures associated with tables or clusters. In addition to the classical B-tree indexes, bitmap indexes are very common in data warehousing environments</p>
<ul>
<li>
<p>Bitmap indexes are optimized index structures for set-oriented operations. Additionally, they are necessary for some optimized data access methods such as star transformations. Bitmap indexes are typically only a fraction of the size of the indexed data in the table.</p>
</li>
<li>
<p>B-tree indexes are most effective for high-cardinality data: that is, for data with many possible values, such as <code>customer_name</code> or <code>phone_number</code>. However, fully indexing a large table with a traditional B-tree index can be prohibitively expensive in terms of disk space because the indexes can be several times larger than the data in the table. B-tree indexes can be stored specifically in a compressed manner to enable huge space savings, storing more keys in each index block, which also leads to less I/O and better performance.</p>
</li>
</ul>
<p class="subhead2"><a id="CDMOG172"></a>Recommendations: Indexes and Partitioned Indexes</p>
<p>Make the majority of the indexes in your customized Oracle Communications Data Model bitmap indexes.</p>
<p>Use B-tree indexes only for unique columns or other columns with very high cardinalities (that is, columns that are almost unique). Store the B-tree indexes in a compressed manner.</p>
<p><a id="sthref66"></a><a id="sthref67"></a>Partition the indexes. Indexes are just like tables in that you can partition them, although the partitioning strategy is not dependent upon the table structure. Partitioning indexes makes it easier to manage the data warehouse during refresh and improves query performance.</p>
<p>Typically, specify the index on a partitioned table as local. Bitmap indexes on partitioned tables must always be local. B-tree indexes on partitioned tables can be global or local. However, in a data warehouse environment, local indexes are more common than global indexes. Use global indexes only when there is a specific requirement which cannot be met by local indexes (for example, a unique index on a non-partitioning key, or a performance requirement).</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDEDHHJ">"Partitioned Tables in the Oracle Communications Data Model"</a>, <a href="adm.htm#CHDHFGEH">"Choosing Indexes for Materialized Views"</a>, <a href="adm.htm#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Communications Data Model"</a>, and <a href="adm.htm#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
</div>
<!-- class="sect2" -->
<a id="CHDEDHHJ"></a>
<div id="CDMOG173" class="sect2">
<h3 class="sect2">Partitioned Tables in the Oracle Communications Data Model</h3>
<p><a id="sthref68"></a><a id="sthref69"></a>Partitioning allows a table, index or index-organized table to be subdivided into smaller pieces. Each piece of the database object is called a partition. Each partition has its own name, and may optionally have its own storage characteristics. From the perspective of a database administrator, a partitioned object has multiple pieces that can be managed either collectively or individually. This gives the administrator considerable flexibility in managing partitioned objects. However, from the perspective of the application, a partitioned table is identical to a nonpartitioned table. No modifications are necessary when accessing a partitioned table using SQL DML commands.</p>
<p>As discussed in the following topics, partitioning can provide tremendous benefits to a wide variety of applications by improving manageability, availability, and performance:</p>
<ul>
<li>
<p><a href="#CHDFFJCG">Partitioning the Oracle Communications Data Model for Manageability</a></p>
</li>
<li>
<p><a href="#CHDEDIDJ">Partitioning the Oracle Communications Data Model for Easier Data Access</a></p>
</li>
<li>
<p><a href="#CHDDEEAA">Partitioning the Oracle Communications Data Model for Join Performance</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Oracle by Example:</p>
To understand the various partitioning techniques in Oracle Database, see the "Manipulating Partitions in Oracle Database 11<span class="italic">g</span>" OBE tutorial.
<p>To access the tutorial, open the Oracle Learning Library in your browser by following the instructions in <a href="preface.htm#BABIJDCI">"Oracle Technology Network"</a>; and, then, search for the tutorial by name.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="#CHDJBEFG">"Indexes and Partitioned Indexes in the Oracle Communications Data Model"</a>, <a href="adm.htm#CHDHEGCC">"Choosing a Cube Partitioning Strategy for Oracle Communications Data Model"</a>, and <a href="adm.htm#CHDCGHCG">"Partitioning and Materialized Views"</a>.</div>
<a id="CHDFFJCG"></a>
<div id="CDMOG174" class="sect3">
<h4 class="sect3">Partitioning the Oracle Communications Data Model for Manageability</h4>
<p><a id="sthref70"></a>Range partitioning helps improve the manageability and availability of large volumes of data.</p>
<p>Consider the case where two year's worth of sales data or 100 terabytes (TB) is stored in a table. At the end of each day a new batch of data must be to loaded into the table and the oldest days worth of data must be removed. If the <code>Sales</code> table is range partitioned by day then the new data can be loaded using a partition exchange load. This is a sub-second operation that has little or no impact on end user queries.</p>
<p>Oracle Communications Data Model uses Interval Partitioning as an extension of Range Partitioning, so that you provide just the first partition higher limit and interval to create the first partition and the following partitions are created automatically as and when data comes. The (hidden) assumption is that the data flow is more or less similar over the various intervals.</p>
</div>
<!-- class="sect3" -->
<a id="CHDEDIDJ"></a>
<div id="CDMOG175" class="sect3">
<h4 class="sect3">Partitioning the Oracle Communications Data Model for Easier Data Access</h4>
<p><a id="sthref71"></a>Range partitioning also helps ensure that only the necessary data to answer a query is scanned. Assuming that the business users predominately accesses the sales data on a weekly basis (for example, total sales per week) then range partitioning this table by day ensures that the data is accessed in the most efficient manner, as only seven partitions must be scanned to answer the business users query instead of the entire table. The ability to avoid scanning irrelevant partitions is known as partition pruning.</p>
</div>
<!-- class="sect3" -->
<a id="CHDDEEAA"></a>
<div id="CDMOG176" class="sect3">
<h4 class="sect3">Partitioning the Oracle Communications Data Model for Join Performance</h4>
<p><a id="sthref72"></a><a id="sthref73"></a>Sub-partitioning by hash is used predominately for performance reasons. Oracle Database uses a linear hashing algorithm to create sub-partitions.</p>
<p>A major performance benefit of hash partitioning is partition-wise joins. Partition-wise joins reduce query response time by minimizing the amount of data exchanged among parallel execution servers when joins execute in parallel. This significantly reduces response time and improves both CPU and memory resource usage. In a clustered data warehouse, this significantly reduces response times by limiting the data traffic over the interconnect (IPC), which is the key to achieving good scalability for massive join operations. Partition-wise joins can be full or partial, depending on the partitioning scheme of the tables to be joined.</p>
<p><a href="#CHDBECGI">Figure 2-2</a> shows how a full partition-wise join divides a join between two large tables into multiple smaller joins. Each smaller join, performs a joins on a pair of partitions, one for each of the tables being joined. For the optimizer to choose the full partition-wise join method, both tables must be equi-partitioned on their join keys. That is, they have to be partitioned on the same column with the same partitioning method. Parallel execution of a full partition-wise join is similar to its serial execution, except that instead of joining one partition pair at a time, multiple partition pairs are joined in parallel by multiple parallel query servers. The number of partitions joined in parallel is determined by the Degree of Parallelism (DOP).</p>
<div id="CDMOG177" class="figure">
<p class="titleinfigure"><a id="CHDBECGI"></a>Figure 2-2 Partitioning for Join Performance</p>
<img width="404" height="280" src="img/join1.gif" alt="Description of Figure 2-2 follows" /><br />
<a id="sthref74" href="img_text/join1.htm">Description of "Figure 2-2 Partitioning for Join Performance"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="subhead2"><a id="CDMOG333"></a>Recommendations: Number of Hash Partitions</p>
<p>In order to ensure that the data gets evenly distributed among the hash partitions it is highly recommended that the number of hash partitions is a power of 2 (for example, 2, 4, 8, and so on). A good rule of thumb to follow when deciding the number of hash partitions a table should have is <code>2 X # of CPUs</code> rounded to up to the nearest power of 2.</p>
<p>If your system has 12 CPUs, then 32 would be a good number of hash partitions. On a clustered system the same rules apply. If you have 3 nodes each with 4 CPUs, then 32 would still be a good number of hash partitions. However, ensure that each hash partition is at least 16 MB. Many small partitions do not have efficient scan rates with parallel query. Consequently, if using the number of CPUs makes the size of the hash partitions too small, use the number of Oracle RAC nodes in the environment (rounded to the nearest power of 2) instead.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEFFJH"></a>
<div id="CDMOG178" class="sect2">
<h3 class="sect2">Parallel Execution in the Oracle Communications Data Model</h3>
<p><a id="sthref75"></a>Parallel Execution enables a database task to be parallelized or divided into smaller units of work, thus allowing multiple processes to work concurrently. By using parallelism, a terabyte of data can be scanned and processed in minutes or less, not hours or days.</p>
<p><a href="#CHDJFAIC">Figure 2-3</a> illustrates the parallel execution of a full partition-wise join between two tables, Sales and Customers. Both tables have the same degree of parallelism and the same number of partitions. They are range partitioned on a date field and sub partitioned by hash on the cust_id field. As illustrated in the picture, each partition pair is read from the database and joined directly.</p>
<p>There is no data redistribution necessary, thus minimizing IPC communication, especially across nodes. Below figure shows the execution plan you would see for this join.</p>
<div id="CDMOG179" class="figure">
<p class="titleinfigure"><a id="CHDJFAIC"></a>Figure 2-3 Parallel Execution of a Full Partition-Wise Join Between Two Tables</p>
<img width="476" height="286" src="img/parthash.gif" alt="Description of Figure 2-3 follows" /><br />
<a id="sthref76" href="img_text/parthash.htm">Description of "Figure 2-3 Parallel Execution of a Full Partition-Wise Join Between Two Tables"</a><br />
<br /></div>
<!-- class="figure" -->
<p>To ensure that you get optimal performance when executing a partition-wise join in parallel, specify a number for the partitions in each of the tables that is larger than the degree of parallelism used for the join. If there are more partitions than parallel servers, each parallel server is given one pair of partitions to join, when the parallel server completes that join, it requests another pair of partitions to join. This process repeats until all pairs have been processed. This method enables the load to be balanced dynamically (for example, 128 partitions with a degree of parallelism of 32).</p>
<p>What happens if only one table that you are joining is partitioned? In this case the optimizer could pick a partial partition-wise join. Unlike full partition-wise joins, partial partition-wise joins can be applied if only one table is partitioned on the join key. Hence, partial partition-wise joins are more common than full partition-wise joins. To execute a partial partition-wise join, Oracle Database dynamically repartitions the other table based on the partitioning strategy of the partitioned table.</p>
<p>After the other table is repartitioned, the execution is similar to a full partition-wise join. The redistribution operation involves exchanging rows between parallel execution servers. This operation leads to interconnect traffic in Oracle RAC environments, since data must be repartitioned across node boundaries.</p>
<p><a href="#CHDJBDDH">Figure 2-4</a> illustrates a partial partition-wise join. It uses the same example as in <a href="#CHDJFAIC">Figure 2-3</a>, except that the customer table is not partitioned. Before the join operation is executed, the rows from the customers table are dynamically redistributed on the join key.</p>
<div id="CDMOG180" class="figure">
<p class="titleinfigure"><a id="CHDJBDDH"></a>Figure 2-4 Partial Partition-Wise Join</p>
<img width="404" height="275" src="img/partjoin2.gif" alt="Description of Figure 2-4 follows" /><br />
<a id="sthref77" href="img_text/partjoin2.htm">Description of "Figure 2-4 Partial Partition-Wise Join"</a><br />
<br /></div>
<!-- class="figure" -->
<a id="CHDEDGDD"></a>
<div id="CDMOG181" class="sect3">
<h4 class="sect3">Enabling Parallel Execution for a Session</h4>
<p><a id="sthref78"></a>Parallel query is the most commonly used parallel execution feature in Oracle Database. Parallel execution can significantly reduce the elapsed time for large queries. To enable parallelization for an entire session, execute the following statement.</p>
<pre>
alter session enable parallel query; 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is usually suggested to set at session level rather than at the system level.</div>
</div>
<!-- class="sect3" -->
<a id="CHDCAFBJ"></a>
<div id="CDMOG182" class="sect3">
<h4 class="sect3">Enabling Parallel Execution of DML Operations</h4>
<p><a id="sthref79"></a>Data Manipulation Language (DML) operations such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> can be parallelized by Oracle Database. Parallel execution can speed up large DML operations and is particularly advantageous in data warehousing environments. To enable parallelization of DML statements, execute the following statement.</p>
<pre>
alter session enable parallel dml;
</pre>
<p>When you issue a DML statement such as an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, Oracle Database applies a set of rules to determine whether that statement can be parallelized. The rules vary depending on whether the statement is a DML <code>INSERT</code> statement, or a DML <code>UPDATE</code> or <code>DELETE</code> statement.</p>
<ul>
<li>
<p>The following rules apply when determining how to parallelize DML <code>UPDATE</code> and <code>DELETE</code> statements:</p>
<ul>
<li>
<p>Oracle Database can parallelize <code>UPDATE</code> and <code>DELETE</code> statements on partitioned tables, but only when multiple partitions are involved.</p>
</li>
<li>
<p>You cannot parallelize <code>UPDATE</code> or <code>DELETE</code> operations on a nonpartitioned table or when such operations affect only a single partition.</p>
</li>
</ul>
</li>
<li>
<p>The following rules apply when determining how to parallelize DML <code>INSERT</code> statements:</p>
<ul>
<li>
<p>Standard <code>INSERT</code> statements using a <code>VALUES</code> clause cannot be parallelized.</p>
</li>
<li>
<p>Oracle Database can parallelize only <code>INSERT . . . SELECT . . . FROM</code> statements.</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CHDEBFJD"></a>
<div id="CDMOG183" class="sect3">
<h4 class="sect3">Enabling Parallel Execution at the Table Level</h4>
<p>The setting of parallelism for a table influences the optimizer. Consequently, when using parallel query, also enable parallelism at the table level by issuing the following statement.</p>
<pre>
alter table &lt;table_name&gt; parallel 32;
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2075">
<tr>
<td class="cellalignment2084">
<table class="cellalignment2080">
<tr>
<td class="cellalignment2079"><a href="impintro.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2079"><a href="adm.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2011, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2086">
<table class="cellalignment2078">
<tr>
<td class="cellalignment2079"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2079"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2079"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2079"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2079"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2079"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
