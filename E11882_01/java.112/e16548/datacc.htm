<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Accessing and Manipulating Oracle Data</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.1" />
<meta name="dcterms.created" content="2011-09-15T1:42:58Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database JDBC Developer's Guide" />
<meta name="dcterms.identifier" content="E16548-03" />
<meta name="dcterms.isVersionOf" content="JJDBC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part4.htm" title="Previous" type="text/html" />
<link rel="Next" href="jstreams.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e16548.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">22/54</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='datacc'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=120,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><h1>Footnote ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/body><\/html>');
    msg.document.close();
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript><a id="g1069804"></a><a id="JJDBC28363"></a>
<h1 class="chapter"><span class="secnum">11</span> Accessing and Manipulating Oracle Data</h1>
<p>T<a id="sthref382"></a>his chapter describes data access in <code>oracle.sql.*</code> formats, as opposed to standard Java formats. Using <code>oracle.sql.*</code> formats involves casting your result sets and statements to <code>OracleResultSet</code>, <code>OracleStatement</code>, <code>OraclePreparedStatement</code>, and <code>OracleCallableStatement</code>, as appropriate, and using the <code>getOracleObject</code>, <code>setOracleObject</code>, <code>get</code><code><span class="codeinlineitalic">XXX</span></code>, and <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods of these classes, where <code><span class="codeinlineitalic">XXX</span></code> corresponds to the types in the <code>oracle.sql</code> package.</p>
<p><a id="sthref383"></a><a id="sthref384"></a>This chapter covers the following topics:</p>
<a id="i1023953"></a>
<ul>
<li>
<p><a href="#i1008338">Data Type Mappings</a></p>
</li>
<li>
<p><a href="#i1044552">Data Conversion Considerations</a></p>
</li>
<li>
<p><a href="#i1024803">Result Set and Statement Extensions</a></p>
</li>
<li>
<p><a href="#i1024269">Comparison of Oracle get and set Methods to Standard JDBC</a></p>
</li>
<li>
<p><a href="#i1059088">Using Result Set Metadata Extensions</a></p>
</li>
<li>
<p><a href="#CHDGEJDJ">Using SQL CALL and CALL INTO Statements</a></p>
</li>
</ul>
<a id="i1008338"></a><a id="JJDBC28364"></a>
<div class="sect1">
<h2 class="sect1">Data Type Mappings<a id="sthref385"></a><a id="sthref386"></a><a id="sthref387"></a><a id="sthref388"></a><a id="sthref389"></a><a id="sthref390"></a><a id="sthref391"></a><a id="sthref392"></a><a id="sthref393"></a></h2>
<p>The Oracle JDBC drivers support standard JDBC types as well as Oracle-specific data types. This section documents standard and Oracle-specific SQL-Java default type mappings. This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BHCJBJCC">Table of Mappings</a></p>
</li>
<li>
<p><a href="#BHCGCBJC">Notes Regarding Mappings</a></p>
</li>
</ul>
<a id="BHCJBJCC"></a><a id="JJDBC28365"></a>
<div class="sect2">
<h3 class="sect2">Table of Mappings</h3>
<p><a href="#g1028145">Table 11-1</a> shows the default mappings between SQL data types, JDBC type codes, standard Java types, and Oracle extended types.</p>
<p>The SQL Data Types column lists the SQL types that exist in Oracle Database 11<span class="italic">g</span>. The JDBC Type Codes column lists data type codes supported by the JDBC standard and defined in the <code>java.sql.Types</code> class or by Oracle in the <code>oracle.jdbc.OracleTypes</code> class. For standard type codes, the codes are identical in these two classes.</p>
<p>The Standard Java Types column lists standard types defined in the Java language. The Oracle Extension Java Types column lists the <code>oracle.sql.*</code> Java types that correspond to each SQL data type in the database. These are Oracle extensions that let you retrieve all SQL data in the form of a <code>oracle.sql.*</code> Java type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>In general, the Oracle JDBC drivers are optimized to manipulate SQL data using the standard JDBC types. In a few specialized cases, it may be advantageous to use the Oracle extension classes that are available in the <code>oracle.sql</code> package. But, Oracle strongly recommends to use the standard JDBC types instead of Oracle extensions, whenever possible. For more information about when to use Oracle extension, refer to <a href="#BABIBHAC">"Standard Types Versus Oracle Types"</a>.</p>
</li>
<li>
<p>Oracle JDBC drivers do not support sharing any JDBC types across connections.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oraint.htm#i1023991">"Package oracle.sql"</a> for more information on Oracle extensions</div>
<div class="tblhruleformalwide">
<p class="titleintable"><a id="JJDBC28366"></a><a id="sthref394"></a><a id="g1028145"></a>Table 11-1 Default Mappings Between SQL Types and Java Types</p>
<table class="cellalignment11" title="Default Mappings Between SQL Types and Java Types " summary="table" >
<thead>
<tr class="cellalignment2">
<th class="cellalignment9" id="r1c1-t4">SQL Data Types</th>
<th class="cellalignment9" id="r1c2-t4">JDBC Type Codes</th>
<th class="cellalignment9" id="r1c3-t4">Standard Java Types</th>
<th class="cellalignment9" id="r1c4-t4">Oracle Extension Java Types</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment10" id="r2c1-t4" headers="r1c1-t4">&nbsp;</td>
<td class="cellalignment10" headers="r2c1-t4 r1c2-t4">
<p><span class="bold">STANDARD JDBC TYPES</span>:</p>
</td>
<td class="cellalignment10" headers="r2c1-t4 r1c3-t4">&nbsp;</td>
<td class="cellalignment10" headers="r2c1-t4 r1c4-t4">&nbsp;</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r3c1-t4" headers="r1c1-t4">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment10" headers="r3c1-t4 r1c2-t4">
<p><code>java.sql.Types.CHAR</code></p>
</td>
<td class="cellalignment10" headers="r3c1-t4 r1c3-t4">
<p><code>java.lang.String</code></p>
</td>
<td class="cellalignment10" headers="r3c1-t4 r1c4-t4">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r4c1-t4" headers="r1c1-t4">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment10" headers="r4c1-t4 r1c2-t4">
<p><code>java.sql.Types.VARCHAR</code></p>
</td>
<td class="cellalignment10" headers="r4c1-t4 r1c3-t4">
<p><code>java.lang.String</code></p>
</td>
<td class="cellalignment10" headers="r4c1-t4 r1c4-t4">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r5c1-t4" headers="r1c1-t4">
<p><code>LONG</code></p>
</td>
<td class="cellalignment10" headers="r5c1-t4 r1c2-t4">
<p><code>java.sql.Types.LONGVARCHAR</code></p>
</td>
<td class="cellalignment10" headers="r5c1-t4 r1c3-t4">
<p><code>java.lang.String</code></p>
</td>
<td class="cellalignment10" headers="r5c1-t4 r1c4-t4">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r6c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r6c1-t4 r1c2-t4">
<p><code>java.sql.Types.NUMERIC</code></p>
</td>
<td class="cellalignment10" headers="r6c1-t4 r1c3-t4">
<p><code>java.math.BigDecimal</code></p>
</td>
<td class="cellalignment10" headers="r6c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r7c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r7c1-t4 r1c2-t4">
<p><code>java.sql.Types.DECIMAL</code></p>
</td>
<td class="cellalignment10" headers="r7c1-t4 r1c3-t4">
<p><code>java.math.BigDecimal</code></p>
</td>
<td class="cellalignment10" headers="r7c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r8c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r8c1-t4 r1c2-t4">
<p><code>java.sql.Types.BIT</code></p>
</td>
<td class="cellalignment10" headers="r8c1-t4 r1c3-t4">
<p><code>boolean</code></p>
</td>
<td class="cellalignment10" headers="r8c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r9c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r9c1-t4 r1c2-t4">
<p><code>java.sql.Types.TINYINT</code></p>
</td>
<td class="cellalignment10" headers="r9c1-t4 r1c3-t4">
<p><code>byte</code></p>
</td>
<td class="cellalignment10" headers="r9c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r10c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r10c1-t4 r1c2-t4">
<p><code>java.sql.Types.SMALLINT</code></p>
</td>
<td class="cellalignment10" headers="r10c1-t4 r1c3-t4">
<p><code>short</code></p>
</td>
<td class="cellalignment10" headers="r10c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r11c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r11c1-t4 r1c2-t4">
<p><code>java.sql.Types.INTEGER</code></p>
</td>
<td class="cellalignment10" headers="r11c1-t4 r1c3-t4">
<p><code>int</code></p>
</td>
<td class="cellalignment10" headers="r11c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r12c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r12c1-t4 r1c2-t4">
<p><code>java.sql.Types.BIGINT</code></p>
</td>
<td class="cellalignment10" headers="r12c1-t4 r1c3-t4">
<p><code>long</code></p>
</td>
<td class="cellalignment10" headers="r12c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r13c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r13c1-t4 r1c2-t4">
<p><code>java.sql.Types.REAL</code></p>
</td>
<td class="cellalignment10" headers="r13c1-t4 r1c3-t4">
<p><code>float</code></p>
</td>
<td class="cellalignment10" headers="r13c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r14c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r14c1-t4 r1c2-t4">
<p><code>java.sql.Types.FLOAT</code></p>
</td>
<td class="cellalignment10" headers="r14c1-t4 r1c3-t4">
<p><code>double</code></p>
</td>
<td class="cellalignment10" headers="r14c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r15c1-t4" headers="r1c1-t4">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r15c1-t4 r1c2-t4">
<p><code>java.sql.Types.DOUBLE</code></p>
</td>
<td class="cellalignment10" headers="r15c1-t4 r1c3-t4">
<p><code>double</code></p>
</td>
<td class="cellalignment10" headers="r15c1-t4 r1c4-t4">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r16c1-t4" headers="r1c1-t4">
<p><code>RAW</code></p>
</td>
<td class="cellalignment10" headers="r16c1-t4 r1c2-t4">
<p><code>java.sql.Types.BINARY</code></p>
</td>
<td class="cellalignment10" headers="r16c1-t4 r1c3-t4">
<p><code>byte[]</code></p>
</td>
<td class="cellalignment10" headers="r16c1-t4 r1c4-t4">
<p><code>oracle.sql.RAW</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r17c1-t4" headers="r1c1-t4">
<p><code>RAW</code></p>
</td>
<td class="cellalignment10" headers="r17c1-t4 r1c2-t4">
<p><code>java.sql.Types.VARBINARY</code></p>
</td>
<td class="cellalignment10" headers="r17c1-t4 r1c3-t4">
<p><code>byte[]</code></p>
</td>
<td class="cellalignment10" headers="r17c1-t4 r1c4-t4">
<p><code>oracle.sql.RAW</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r18c1-t4" headers="r1c1-t4">
<p><code>LONGRAW</code></p>
</td>
<td class="cellalignment10" headers="r18c1-t4 r1c2-t4">
<p><code>java.sql.Types.LONGVARBINARY</code></p>
</td>
<td class="cellalignment10" headers="r18c1-t4 r1c3-t4">
<p><code>byte[]</code></p>
</td>
<td class="cellalignment10" headers="r18c1-t4 r1c4-t4">
<p><code>oracle.sql.RAW</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r19c1-t4" headers="r1c1-t4">
<p><code>DATE</code></p>
</td>
<td class="cellalignment10" headers="r19c1-t4 r1c2-t4">
<p><code>java.sql.Types.DATE</code></p>
</td>
<td class="cellalignment10" headers="r19c1-t4 r1c3-t4">
<p><code>java.sql.Date</code></p>
</td>
<td class="cellalignment10" headers="r19c1-t4 r1c4-t4">
<p><code>oracle.sql.DATE</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r20c1-t4" headers="r1c1-t4">
<p><code>DATE</code></p>
</td>
<td class="cellalignment10" headers="r20c1-t4 r1c2-t4">
<p><code>java.sql.Types.TIME</code></p>
</td>
<td class="cellalignment10" headers="r20c1-t4 r1c3-t4">
<p><code>java.sql.Time</code></p>
</td>
<td class="cellalignment10" headers="r20c1-t4 r1c4-t4">
<p><code>oracle.sql.DATE</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r21c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP</code></p>
</td>
<td class="cellalignment10" headers="r21c1-t4 r1c2-t4">
<p><code>java.sql.Types.TIMESTAMP</code></p>
</td>
<td class="cellalignment10" headers="r21c1-t4 r1c3-t4">
<p><code>javal.sql.Timestamp</code></p>
</td>
<td class="cellalignment10" headers="r21c1-t4 r1c4-t4">
<p><code>oracle.sql.TIMESTAMP</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r22c1-t4" headers="r1c1-t4">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment10" headers="r22c1-t4 r1c2-t4">
<p><code>java.sql.Types.BLOB</code></p>
</td>
<td class="cellalignment10" headers="r22c1-t4 r1c3-t4">
<p><code>java.sql.Blob</code></p>
</td>
<td class="cellalignment10" headers="r22c1-t4 r1c4-t4">
<p><code>oracle.sql.BLOB</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r23c1-t4" headers="r1c1-t4">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment10" headers="r23c1-t4 r1c2-t4">
<p><code>java.sql.Types.CLOB</code></p>
</td>
<td class="cellalignment10" headers="r23c1-t4 r1c3-t4">
<p><code>java.sql.Clob</code></p>
</td>
<td class="cellalignment10" headers="r23c1-t4 r1c4-t4">
<p><code>oracle.sql.CLOB</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r24c1-t4" headers="r1c1-t4">
<p>user-defined object</p>
</td>
<td class="cellalignment10" headers="r24c1-t4 r1c2-t4">
<p><code>java.sql.Types.STRUCT</code></p>
</td>
<td class="cellalignment10" headers="r24c1-t4 r1c3-t4">
<p><code>java.sql.Struct</code></p>
</td>
<td class="cellalignment10" headers="r24c1-t4 r1c4-t4">
<p><code>oracle.sql.STRUCT</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r25c1-t4" headers="r1c1-t4">
<p>user-defined reference</p>
</td>
<td class="cellalignment10" headers="r25c1-t4 r1c2-t4">
<p><code>java.sql.Types.REF</code></p>
</td>
<td class="cellalignment10" headers="r25c1-t4 r1c3-t4">
<p><code>java.sql.Ref</code></p>
</td>
<td class="cellalignment10" headers="r25c1-t4 r1c4-t4">
<p><code>oracle.sql.REF</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r26c1-t4" headers="r1c1-t4">
<p>user-defined collection</p>
</td>
<td class="cellalignment10" headers="r26c1-t4 r1c2-t4">
<p><code>java.sql.Types.ARRAY</code></p>
</td>
<td class="cellalignment10" headers="r26c1-t4 r1c3-t4">
<p><code>java.sql.Array</code></p>
</td>
<td class="cellalignment10" headers="r26c1-t4 r1c4-t4">
<p><code>oracle.sql.ARRAY</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r27c1-t4" headers="r1c1-t4">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment10" headers="r27c1-t4 r1c2-t4">
<p><code>java.sql.Types.ROWID</code></p>
</td>
<td class="cellalignment10" headers="r27c1-t4 r1c3-t4">
<p>java.sql.RowId</p>
</td>
<td class="cellalignment10" headers="r27c1-t4 r1c4-t4">
<p><code>oracle.sql.ROWID</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r28c1-t4" headers="r1c1-t4">
<p><code>NCLOB</code></p>
</td>
<td class="cellalignment10" headers="r28c1-t4 r1c2-t4">
<p>java.sql.Types.NCLOB</p>
</td>
<td class="cellalignment10" headers="r28c1-t4 r1c3-t4">
<p><code>java.sql.NClob</code></p>
</td>
<td class="cellalignment10" headers="r28c1-t4 r1c4-t4">
<p><code>oracle.sql.NCLOB</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r29c1-t4" headers="r1c1-t4">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment10" headers="r29c1-t4 r1c2-t4">
<p>java.sql.Types.NCHAR</p>
</td>
<td class="cellalignment10" headers="r29c1-t4 r1c3-t4">
<p>java.lang.String</p>
</td>
<td class="cellalignment10" headers="r29c1-t4 r1c4-t4">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r30c1-t4" headers="r1c1-t4">&nbsp;</td>
<td class="cellalignment10" headers="r30c1-t4 r1c2-t4">
<p><span class="bold">ORACLE EXTENSIONS</span>:</p>
</td>
<td class="cellalignment10" headers="r30c1-t4 r1c3-t4">&nbsp;</td>
<td class="cellalignment10" headers="r30c1-t4 r1c4-t4">&nbsp;</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r31c1-t4" headers="r1c1-t4">
<p><code>BFILE</code></p>
</td>
<td class="cellalignment10" headers="r31c1-t4 r1c2-t4">
<p><code>oracle.jdbc.OracleTypes.BFILE</code></p>
</td>
<td class="cellalignment10" headers="r31c1-t4 r1c3-t4">
<p>NA</p>
</td>
<td class="cellalignment10" headers="r31c1-t4 r1c4-t4">
<p><code>oracle.sql.BFILE</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r32c1-t4" headers="r1c1-t4">
<p><code>REF CURSOR</code></p>
</td>
<td class="cellalignment10" headers="r32c1-t4 r1c2-t4">
<p><code>oracle.jdbc.OracleTypes.CURSOR</code></p>
</td>
<td class="cellalignment10" headers="r32c1-t4 r1c3-t4">
<p><code>java.sql.ResultSet</code></p>
</td>
<td class="cellalignment10" headers="r32c1-t4 r1c4-t4">
<p><code>oracle.jdbc.OracleResultSet</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r33c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP</code></p>
</td>
<td class="cellalignment10" headers="r33c1-t4 r1c2-t4">
<p><code>oracle.jdbc.OracleTypes.TIMESTAMP</code></p>
</td>
<td class="cellalignment10" headers="r33c1-t4 r1c3-t4">
<p><code>java.sql.Timestamp</code></p>
</td>
<td class="cellalignment10" headers="r33c1-t4 r1c4-t4">
<p><code>oracle.sql.TIMESTAMP</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r34c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP WITH TIME ZONE</code></p>
</td>
<td class="cellalignment10" headers="r34c1-t4 r1c2-t4">
<p><code>oracle.jdbc.OracleTypes.TIMESTAMPTZ</code></p>
</td>
<td class="cellalignment10" headers="r34c1-t4 r1c3-t4">
<p><code>java.sql.Timestamp</code></p>
</td>
<td class="cellalignment10" headers="r34c1-t4 r1c4-t4">
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r35c1-t4" headers="r1c1-t4">
<p><code>TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</td>
<td class="cellalignment10" headers="r35c1-t4 r1c2-t4">
<p><code>oracle.jdbc.OracleTypes.TIMESTAMPLTZ</code></p>
</td>
<td class="cellalignment10" headers="r35c1-t4 r1c3-t4">
<p><code>java.sql.Timestamp</code></p>
</td>
<td class="cellalignment10" headers="r35c1-t4 r1c4-t4">
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For database versions, such as 8.1.7, which do not support the <code>TIMESTAMP</code> data type, <code>TIMESTAMP</code> is mapped to <code>DATE</code>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also :</p>
<ul>
<li>
<p><a href="apxref.htm#i1001571">"Valid SQL-JDBC Data Type Mappings"</a></p>
</li>
<li>
<p><a href="oraint.htm#g1090378">Chapter 4, "Oracle Extensions"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BHCGCBJC"></a><a id="JJDBC28367"></a>
<div class="sect2">
<h3 class="sect2">Notes Regarding Mappings</h3>
<p>This section provides further detail regarding mappings for <code>NUMBER</code> and user-defined types.</p>
<p class="subhead2"><a id="JJDBC28368"></a>NUMBER Types</p>
<p>For the different type codes that an Oracle <code>NUMBER</code> value can correspond to, call the getter routine that is appropriate for the size of the data for mapping to work properly. For example, call <code>getByte</code> to get a Java <code>tinyint</code> value for an item <span class="italic">x</span>, where -128 &lt; <span class="italic">x</span> &lt; 128.</p>
<p class="subhead2"><a id="JJDBC28369"></a>User-Defined Types</p>
<p>User-defined types, such as objects, object references, and collections, map by default to weak Java types, such as <code>java.sql.Struct</code>, but alternatively can map to strongly typed custom Java classes. Custom Java classes can implement one of two interfaces:</p>
<ul>
<li>
<p>The standard <code>java.sql.SQLData</code></p>
</li>
<li>
<p>The Oracle-specific <code>oracle.sql.ORAData</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oraoot.htm#i1056044">"Mapping Oracle Objects"</a> and <a href="oraoot.htm#i1039528">"Creating and Using Custom Object Classes for Oracle Objects"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1044552"></a><a id="JJDBC28370"></a>
<div class="sect1">
<h2 class="sect1">Data Conversion Considerations</h2>
<p>When JDBC programs retrieve <a id="sthref395"></a><a id="sthref396"></a>SQL data into Java, you can use standard Java types, or you can use types of the <code><a id="sthref397"></a>oracle.sql</code> package. This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABIBHAC">Standard Types Versus Oracle Types</a></p>
</li>
<li>
<p><a href="#BABBCIBD">Converting SQL NULL Data</a></p>
</li>
<li>
<p><a href="#BABBFGBJ">Testing for NULLs</a></p>
</li>
</ul>
<a id="BABIBHAC"></a><a id="JJDBC28371"></a>
<div class="sect2">
<h3 class="sect2">Standard Types Versus Oracle Types</h3>
<p>The Oracle data types in <code>oracle.sql</code> store data in the same bit format as used by the database. In versions of the Oracle JDBC drivers prior to Oracle Database 10g, the Oracle data types were generally more efficient. The Oracle Database 10<span class="italic">g</span> JDBC drivers were substantially updated. As a result, in most cases the standard Java types are preferred to the data types in <code>oracle.sql.*</code>. In particular, <code>java.lang.String</code> is much more efficient than <code>oracle.sql.CHAR</code>.</p>
<p>In general, Oracle recommends that you use the Java standard types. The exceptions to this are:</p>
<ul>
<li>
<p>Use the <code>oracle.sql.OraData</code> rather than the <code>java.sql.SqlData</code> if the OraData functionality better suits your needs.</p>
</li>
<li>
<p>Use <code>oracle.sql.NUMBER</code> rather than <code>java.lang.Double</code> if you need to retain the exact values of floating point numbers. Oracle <code>NUMBER</code> is a decimal representation and Java <code>Double</code> and <code>Float</code> are binary representations. Conversion from one format to the other can result in slight variations in the actual value represented. Additionally, the range of values that can be represented using the two formats is different.</p>
<p>Use <code>oracle.sql.NUMBER</code> rather than <code>java.math.BigDecimal</code> when performance is critical and you are not manipulating the values, just reading and writing them.</p>
</li>
<li>
<p>Use <code>oracle.sql.DATE</code> or <code>oracle.sql.TIMESTAMP</code> rather than <code>java.sql.Date</code> or <code>java.sql.Timestamp</code> if you are using a JDK version earlier than JDK 1.6 or require maximum performance. You can also use the <code>oracle.sql</code> data type if you want to read many date values, and compute or display only a small percentage.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Due to a bug in all versions of Java prior to JDK 1.6, construction of <code>java.lang.Date</code> and <code>java.lang.Timestamp</code> objects is slow, especially in multithreaded environments. This bug is fixed in JDK 1.6.</div>
</li>
<li>
<p>Use <code>oracle.sql.CHAR</code> only when you have data from some external source, which has been represented in an Oracle character set encoding. In all other cases, you should use <code>java.lang.String</code>.</p>
</li>
<li>
<p><code>STRUCT</code>, <code>ARRAY</code>, <code>BLOB</code>, <code>CLOB</code>, <code>REF</code>, and <code>ROWID</code> are all the implementation classes of the corresponding JDBC standard interface types. So, there is no benefit of using the Oracle extension types as they are identical to the JDBC standard types.</p>
</li>
<li>
<p><code>BFILE</code>, <code>TIMESTAMPTZ</code>, and <code>TIMESTAMPLTZ</code> have no representation in the JDBC standard. You must use these Oracle extensions.</p>
</li>
<li>
<p>In all other cases, you should use the standard JDBC type rather than the Oracle extensions.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you convert an <code>oracle.sql</code> data type to a Java standard data type, then the benefits of using the <code>oracle.sql</code> data type are lost.</div>
</div>
<!-- class="sect2" -->
<a id="BABBCIBD"></a><a id="JJDBC28372"></a>
<div class="sect2">
<h3 class="sect2">Converting SQL NULL Data</h3>
<p>Java represents a SQL <code><a id="sthref398"></a>NULL</code> datum by the Java value <code>null</code>. Java data types fall into two categories: primitive types, such as <code>byte</code>, <code>int</code>, and <code>float</code>, and object types, such as class instances. The primitive types cannot represent <code>null</code>. Instead, they store <code>null</code> as the value zero, as defined by the JDBC specification. This can lead to ambiguity when you try to interpret your results.</p>
<p>In contrast, Java object types can represent <code>null</code>. The Java language defines an object container type corresponding to every primitive type that can represent <code>null</code>. The object container types must be used as the targets for SQL data to detect SQL <code>NULL</code> without ambiguity.</p>
</div>
<!-- class="sect2" -->
<a id="BABBFGBJ"></a><a id="JJDBC28373"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Testing for NULLs</h3>
<p>You cannot use a relational operator to compare <code>NULL</code> values with each other or with <a id="sthref399"></a><a id="sthref400"></a>other values. For example, the following <code>SELECT</code> statement does not return any row even if the <code>COMM</code> column contains one or more <code>NULL</code> values.</p>
<pre>
PreparedStatement pstmt = conn.prepareStatement(
  "SELECT * FROM EMP WHERE COMM = ?"); 
pstmt.setNull(1, java.sql.Types.VARCHAR); 
</pre>
<p>The <a id="sthref401"></a>next example shows how to compare values for equality when some return values might be <code>NULL</code>. The following code returns all the <code>ENAMES</code> from the <code>EMP</code> table that are <code>NULL</code>, if there is no value of 100 for <code>COMM</code>.</p>
<pre>
PreparedStatement pstmt = conn.prepareStatement("SELECT ENAME FROM EMP 
  WHERE COMM =? OR  ((COMM IS NULL) AND (? IS NULL))"); 
pstmt.setBigDecimal(1, new BigDecimal(100)); 
pstmt.setNull(2, java.sql.Types.VARCHAR); 
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1024803"></a><a id="JJDBC28374"></a>
<div class="sect1">
<h2 class="sect1">Result Set and Statement Extensions</h2>
<p>The JDBC <code>Statement</code> object <a id="sthref402"></a><a id="sthref403"></a><a id="sthref404"></a><a id="sthref405"></a>returns an <code>OracleResultSet</code> object, typed as a <code>java.sql.ResultSet</code>. If you want to apply only standard JDBC methods to the object, then keep it as a <code>ResultSet</code> type. However, if you want to use the Oracle extensions on the object, then you must cast it to <code>OracleResultSet</code>. All of the Oracle Result Set extensions are in the <code><a id="sthref406"></a>oracle.jdbc.OracleResultSet</code> interface and all the <code>Statement</code> extensions are in the <code><a id="sthref407"></a>oracle.jdbc.OracleStatement</code> interface.</p>
<p>For example, assuming you have a standard <code>Statement</code> object <code>stmt</code>, do the following if you want to use only standard JDBC <code>ResultSet</code> methods:</p>
<pre>
ResultSet rs = stmt.executeQuery("SELECT * FROM emp");
</pre>
<p>If you need the extended functionality provided by the Oracle extensions to JDBC, you can select the results into a standard <code>ResultSet</code> variable and then cast that variable to <code>OracleResultSet</code> later.</p>
<p>Key extensions to the result set and statement classes include the <code>getOracleObject</code> and <code>setOracleObject</code> methods, used to access and manipulate data in <code>oracle.sql.*</code> formats.</p>
</div>
<!-- class="sect1" -->
<a id="i1024269"></a><a id="JJDBC28375"></a>
<div class="sect1">
<h2 class="sect1">Comparison of Oracle get and set Methods to Standard JDBC</h2>
<p>This section describes <code>get</code> and <code>set</code> methods, particularly the JDBC standard <code>getObject</code> and <code>setObject</code> methods and the Oracle-specific <code>getOracleObject</code> and <code>setOracleObject</code> methods, and how to access data in <code>oracle.sql.*</code> format compared with Java format.</p>
<p>Although there are specific <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods for all the Oracle SQL types, you can use the general <code>get</code> methods for convenience or simplicity, or if you are not certain in advance what type of data you will receive.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1024324">Standard getObject Method</a></p>
</li>
<li>
<p><a href="#i1024333">Oracle getOracleObject Method</a></p>
</li>
<li>
<p><a href="#i1023778">Summary of getObject and getOracleObject Return Types</a></p>
</li>
<li>
<p><a href="#i1024283">Other getXXX Methods</a></p>
</li>
<li>
<p><a href="#i1058745">Data Types For Returned Objects from getObject and getXXX</a></p>
</li>
<li>
<p><a href="#i1059382">The setObject and setOracleObject Methods</a></p>
</li>
<li>
<p><a href="#i1058921">Other setXXX Methods</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot qualify a column name with a table name and pass it as a parameter to the <code>get</code><code><span class="codeinlineitalic">XXX</span></code> method. For example:
<pre>
ResultSet rset = stmt.executeQuery("SELECT emp.deptno, dept.deptno FROM emp, dept");
rset.getInt("emp.deptno");
</pre>
<p>The <code>getInt</code> method in the preceding code will throw an exception. To uniquely identify the columns in the <code>get</code><code><span class="codeinlineitalic">XXX</span></code> method, you can either use column index or specify column aliases in the query and use these aliases in the <code>get</code><code><span class="codeinlineitalic">XXX</span></code> method.</p>
</div>
<a id="i1024324"></a><a id="JJDBC28376"></a>
<div class="sect2">
<h3 class="sect2">Standard getObject Method</h3>
<p>The standard <code><a id="sthref408"></a>getObject</code> method of a result set or callable statement has a return type of <code>java.lang.Object</code>. The class of the object returned is based on its SQL type, as follows:</p>
<ul>
<li>
<p>For SQL data types that are not Oracle-specific, <code>getObject</code> returns the default Java type corresponding to the SQL type of the column, following the mapping in the JDBC specification.</p>
</li>
<li>
<p>For Oracle-specific data types, <code>getObject</code> returns an object of the appropriate <code>oracle.sql.*</code> class, such as <code>oracle.sql.ROWID</code>.</p>
</li>
<li>
<p>For Oracle database objects, <code>getObject</code> returns a Java object of the class specified in your <a id="sthref409"></a>type map. Type maps specify a mapping from database named types to Java classes. The <code>getObject(</code><code><span class="codeinlineitalic">parameter_index</span></code><code>)</code> method uses the default type map of the connection. The <code>getObject(</code><code><span class="codeinlineitalic">parameter_index</span></code><code>,</code> <code><span class="codeinlineitalic">map</span></code><code>)</code> enables you to pass in a type map. If the type map does not provide a mapping for a particular Oracle object, then <code>getObject</code> returns an <code>oracle.sql.STRUCT</code> object.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1024333"></a><a id="JJDBC28377"></a>
<div class="sect2">
<h3 class="sect2">Oracle getOracleObject Method</h3>
<p><a id="sthref410"></a>If you want to retrieve data from a result set or callable statement as an <code>oracle.sql.*</code> object, then you must follow a special process. For a Result Set, you must cast the Result Set itself to <code>oracle.jdbc.OracleResultSet</code> and then call <code>getOracleObject</code> instead of <code>getObject</code>. The same applies to <code>CallableStatement</code> and <code>oracle.jdbc.OracleCallableStatement</code>.</p>
<p>The return type of <code>getOracleObject</code> is <code>oracle.sql.Datum</code>. The actual returned object is an instance of the appropriate <code>oracle.sql.*</code> class. The method signature is:</p>
<pre>
public oracle.sql.Datum getOracleObject(int <span class="codeinlineitalic">p</span><span class="italic">arameter_index</span>)
</pre>
<p>When you retrieve data into a <code>Datum</code> variable, you can use the standard Java <code>instanceof</code> operator to determine which <code>oracle.sql.*</code> type it really is.</p>
<p class="subhead2"><a id="JJDBC28378"></a>Example: Using getOracleObject with a Result Set</p>
<p>The <a id="sthref411"></a><a id="sthref412"></a>following example creates a table that contains a column of <code>CHAR</code> data and a column containing a <code>BFILE</code> locator. A <code>SELECT</code> statement retrieves the contents of the table as a result set. The <code>getOracleObject</code> then retrieves the <code>CHAR</code> data into the <code>char_datum</code> variable and the <code>BFILE</code> locator into the <code>bfile_datum</code> variable. Note that because <code>getOracleObject</code> returns a <code>Datum</code> object, the return values must be cast to <code>CHAR</code> and <code>BFILE</code>, respectively.</p>
<pre>
stmt.execute ("CREATE TABLE bfile_table (x VARCHAR2 (30), b BFILE)");
stmt.execute 
    ("INSERT INTO bfile_table VALUES ('one', BFILENAME ('TEST_DIR', 'file1'))");

ResultSet rset = stmt.executeQuery ("SELECT * FROM bfile_table");
while (rset.next ())
{
   CHAR char_datum = (CHAR) ((OracleResultSet)rset).getOracleObject (1);
   BFILE bfile_datum = (BFILE) ((OracleResultSet)rset).getOracleObject (2);
   ...
}
</pre>
<p class="subhead2"><a id="JJDBC28379"></a>Example: Using getOracleObject in a Callable Statement</p>
<p>The <a id="sthref413"></a><a id="sthref414"></a>following example prepares a call to the procedure <code>myGetDate</code>, which associates a character string with a date. The program passes "<code>SCOTT"</code> to the prepared call and registers the <code>DATE</code> type as an output parameter. After the call is run, <code>getOracleObject</code> retrieves the date associated with <code>"SCOTT"</code>. Note that because <code>getOracleObject</code> returns a <code>Datum</code> object, the results are cast to <code>DATE</code>.</p>
<pre>
OracleCallableStatement cstmt = (OracleCallableStatement)conn.prepareCall
                                   ("begin myGetDate (?, ?); end;");

cstmt.setString (1, "SCOTT");
cstmt.registerOutParameter (2, Types.DATE);
cstmt.execute ();

DATE date = (DATE) ((OracleCallableStatement)cstmt).getOracleObject (2);
...
</pre></div>
<!-- class="sect2" -->
<a id="i1023778"></a><a id="JJDBC28380"></a>
<div class="sect2">
<h3 class="sect2">Summary of getObject and getOracleObject Return Types</h3>
<p><a href="#g1061775">Table 11-2</a> lists the underlying return types for the <code>getObject</code> and <code>getOracleObject</code> methods for each Oracle SQL type.</p>
<p>Keep in mind the following when you use these methods:</p>
<ul>
<li>
<p><code>getObject</code>always returns data into a <code>java.lang.Object</code> instance</p>
</li>
<li>
<p><code>getOracleObject</code> always returns data into an <code>oracle.sql.Datum</code> instance</p>
</li>
</ul>
<p><a id="sthref415"></a><a id="sthref416"></a><a id="sthref417"></a><a id="sthref418"></a>You must cast the returned object to use any special functionality.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="JJDBC28381"></a><a id="sthref419"></a><a id="g1061775"></a>Table 11-2 getObject and getOracleObject Return Types</p>
<table class="cellalignment11" title="getObject and getOracleObject Return Types " summary="table" dir="ltr">
<thead>
<tr class="cellalignment2">
<th class="cellalignment9" id="r1c1-t11">Oracle SQL Type</th>
<th class="cellalignment9" id="r1c2-t11">getObject Underlying Return Type</th>
<th class="cellalignment9" id="r1c3-t11">getOracleObject Underlying Return Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment10" id="r2c1-t11" headers="r1c1-t11">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment10" headers="r2c1-t11 r1c2-t11">
<p><code>String</code></p>
</td>
<td class="cellalignment10" headers="r2c1-t11 r1c3-t11">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r3c1-t11" headers="r1c1-t11">
<p><code>VARCHAR2</code></p>
</td>
<td class="cellalignment10" headers="r3c1-t11 r1c2-t11">
<p><code>String</code></p>
</td>
<td class="cellalignment10" headers="r3c1-t11 r1c3-t11">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r4c1-t11" headers="r1c1-t11">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment10" headers="r4c1-t11 r1c2-t11">
<p><code>String</code></p>
</td>
<td class="cellalignment10" headers="r4c1-t11 r1c3-t11">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r5c1-t11" headers="r1c1-t11">
<p><code>LONG</code></p>
</td>
<td class="cellalignment10" headers="r5c1-t11 r1c2-t11">
<p><code>String</code></p>
</td>
<td class="cellalignment10" headers="r5c1-t11 r1c3-t11">
<p><code>oracle.sql.CHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r6c1-t11" headers="r1c1-t11">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment10" headers="r6c1-t11 r1c2-t11">
<p><code>java.math.BigDecimal</code></p>
</td>
<td class="cellalignment10" headers="r6c1-t11 r1c3-t11">
<p><code>oracle.sql.NUMBER</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r7c1-t11" headers="r1c1-t11">
<p><code>RAW</code></p>
</td>
<td class="cellalignment10" headers="r7c1-t11 r1c2-t11">
<p><code>byte[]</code></p>
</td>
<td class="cellalignment10" headers="r7c1-t11 r1c3-t11">
<p><code>oracle.sql.RAW</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r8c1-t11" headers="r1c1-t11">
<p><code>LONGRAW</code></p>
</td>
<td class="cellalignment10" headers="r8c1-t11 r1c2-t11">
<p><code>byte[]</code></p>
</td>
<td class="cellalignment10" headers="r8c1-t11 r1c3-t11">
<p><code>oracle.sql.RAW</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r9c1-t11" headers="r1c1-t11">
<p><code>DATE</code></p>
</td>
<td class="cellalignment10" headers="r9c1-t11 r1c2-t11">
<p><code>java.sql.Date</code></p>
</td>
<td class="cellalignment10" headers="r9c1-t11 r1c3-t11">
<p><code>oracle.sql.DATE</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r10c1-t11" headers="r1c1-t11">
<p><code>TIMESTAMP</code></p>
</td>
<td class="cellalignment10" headers="r10c1-t11 r1c2-t11">
<p><code>java.sql.Timestamp</code><a id="sthref420" href="#sthref420" onclick='footdisplay(1,"\u003ccode\u003eResultSet.getObject\u003c/code\u003e returns \u003ccode\u003ejava.sql.Timestamp\u003c/code\u003e only if the \u003ccode\u003eoracle.jdbc.J2EE13Compliant\u003c/code\u003e connection property is set to \u003ccode\u003eTRUE\u003c/code\u003e, else the method returns \u003ccode\u003eoracle.sql.TIMESTAMP\u003c/code\u003e.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></p>
</td>
<td class="cellalignment10" headers="r10c1-t11 r1c3-t11">
<p><code>oracle.sql.TIMESTAMP</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r11c1-t11" headers="r1c1-t11">
<p><code>TIMESTAMP WITH TIME ZONE</code></p>
</td>
<td class="cellalignment10" headers="r11c1-t11 r1c2-t11">
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
</td>
<td class="cellalignment10" headers="r11c1-t11 r1c3-t11">
<p><code>oracle.sql.TIMESTAMPTZ</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r12c1-t11" headers="r1c1-t11">
<p><code>TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</td>
<td class="cellalignment10" headers="r12c1-t11 r1c2-t11">
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</td>
<td class="cellalignment10" headers="r12c1-t11 r1c3-t11">
<p><code>oracle.sql.TIMESTAMPLTZ</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r13c1-t11" headers="r1c1-t11">
<p><code>BINARY_FLOAT</code></p>
</td>
<td class="cellalignment10" headers="r13c1-t11 r1c2-t11">
<p><code>java.lang.Float</code></p>
</td>
<td class="cellalignment10" headers="r13c1-t11 r1c3-t11">
<p><code>oracle.sql.BINARY_FLOAT</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r14c1-t11" headers="r1c1-t11">
<p><code>BINARY_DOUBLE</code></p>
</td>
<td class="cellalignment10" headers="r14c1-t11 r1c2-t11">
<p><code>java.lang.Double</code></p>
</td>
<td class="cellalignment10" headers="r14c1-t11 r1c3-t11">
<p><code>oracle.sql.BINARY_DOUBLE</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r15c1-t11" headers="r1c1-t11">
<p><code>INTERVAL DAY TO SECOND</code></p>
</td>
<td class="cellalignment10" headers="r15c1-t11 r1c2-t11">
<p><code>oracle.sql.INTERVALDS</code></p>
</td>
<td class="cellalignment10" headers="r15c1-t11 r1c3-t11">
<p><code>oracle.sql.INTERVALDS</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r16c1-t11" headers="r1c1-t11">
<p><code>INTERVAL YEAR TO MONTH</code></p>
</td>
<td class="cellalignment10" headers="r16c1-t11 r1c2-t11">
<p><code>oracle.sql.INTERVALYM</code></p>
</td>
<td class="cellalignment10" headers="r16c1-t11 r1c3-t11">
<p><code>oracle.sql.INTERVALYM</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r17c1-t11" headers="r1c1-t11">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment10" headers="r17c1-t11 r1c2-t11">
<p><code>oracle.sql.ROWID</code></p>
</td>
<td class="cellalignment10" headers="r17c1-t11 r1c3-t11">
<p><code>oracle.sql.ROWID</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r18c1-t11" headers="r1c1-t11">
<p><code>REF CURSOR</code></p>
</td>
<td class="cellalignment10" headers="r18c1-t11 r1c2-t11">
<p><code>java.sql.ResultSet</code></p>
</td>
<td class="cellalignment10" headers="r18c1-t11 r1c3-t11">
<p>(not supported)</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r19c1-t11" headers="r1c1-t11">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment10" headers="r19c1-t11 r1c2-t11">
<p><code>oracle.sql.BLOB</code></p>
</td>
<td class="cellalignment10" headers="r19c1-t11 r1c3-t11">
<p><code>oracle.sql.BLOB</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r20c1-t11" headers="r1c1-t11">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment10" headers="r20c1-t11 r1c2-t11">
<p><code>oracle.sql.CLOB</code></p>
</td>
<td class="cellalignment10" headers="r20c1-t11 r1c3-t11">
<p><code>oracle.sql.CLOB</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r21c1-t11" headers="r1c1-t11">
<p><code>NCLOB</code></p>
</td>
<td class="cellalignment10" headers="r21c1-t11 r1c2-t11">
<p><code>java.sql.NClob</code></p>
</td>
<td class="cellalignment10" headers="r21c1-t11 r1c3-t11">
<p><code>oracle.sql.NCLOB</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r22c1-t11" headers="r1c1-t11">
<p><code>BFILE</code></p>
</td>
<td class="cellalignment10" headers="r22c1-t11 r1c2-t11">
<p><code>oracle.sql.BFILE</code></p>
</td>
<td class="cellalignment10" headers="r22c1-t11 r1c3-t11">
<p><code>oracle.sql.BFILE</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r23c1-t11" headers="r1c1-t11">
<p>Oracle object</p>
</td>
<td class="cellalignment10" headers="r23c1-t11 r1c2-t11">
<p>class specified in type map</p>
<p>or <code>oracle.sql.STRUCT</code> (if no type map entry)</p>
</td>
<td class="cellalignment10" headers="r23c1-t11 r1c3-t11">
<p><code>oracle.sql.STRUCT</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r24c1-t11" headers="r1c1-t11">
<p>Oracle object reference</p>
</td>
<td class="cellalignment10" headers="r24c1-t11 r1c2-t11">
<p><code>oracle.sql.REF</code></p>
</td>
<td class="cellalignment10" headers="r24c1-t11 r1c3-t11">
<p><code>oracle.sql.REF</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r25c1-t11" headers="r1c1-t11">
<p>collection (varray or nested table)</p>
</td>
<td class="cellalignment10" headers="r25c1-t11 r1c2-t11">
<p><code>oracle.sql.ARRAY</code></p>
</td>
<td class="cellalignment10" headers="r25c1-t11 r1c3-t11">
<p><code>oracle.sql.ARRAY</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup><code>ResultSet.getObject</code> returns <code>java.sql.Timestamp</code> only if the <code>oracle.jdbc.J2EE13Compliant</code> connection property is set to <code>TRUE</code>, else the method returns <code>oracle.sql.TIMESTAMP</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>ResultSet.getObject</code> method returns <code>java.sql.Timestamp</code> for the <code>TIMESTAMP</code> SQL type, only when the connection property <code>oracle.jdbc.J2EE13Compliant</code> is set to <code>TRUE</code>. This property has to be set when the connection is obtained. If this connection property is not set or if it is set after the connection is obtained, then the <code>ResultSet.getObject</code> method returns <code>oracle.sql.TIMESTAMP</code> for the <code>TIMESTAMP</code> SQL type.
<p>The <code>oracle.jdbc.J2EE13Compliant</code> connection property can also be set without changing the code in the following ways:</p>
<ul>
<li>
<p>Including the <code>ojdbc5dms.jar</code> or <code>ojdbc6dms.jar</code> files in the <code>CLASSPATH</code>. These files set <code>oracle.jdbc.J2EE13Compliant</code> to <code>TRUE</code> by default. These are specific to the Oracle Application Server release and are not available as part of the general JDBC release. They are located in <code>$ORACLE_HOME/jdbc/lib</code>.</p>
</li>
<li>
<p>Setting the system property by calling the <code>java</code> command with the flag <code>-Doracle.jdbc.J2EE13Compliant=true</code>. For example,</p>
<pre>
java -Doracle.jdbc.J2EE13Compliant=true ...
</pre></li>
</ul>
<p>When the <code>J2EE13Compliant</code> is set to <code>TRUE</code> the action is as in Table B-3 of the JDBC specification.</p>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="apxref.htm#CACBBAIE">Table A-1, "Valid SQL Data Type-Java Class Mappings"</a>, for information about type compatibility between all SQL and Java types.</div>
</div>
<!-- class="sect2" -->
<a id="i1024283"></a><a id="JJDBC28382"></a>
<div class="sect2">
<h3 class="sect2">Other getXXX Methods</h3>
<p><a id="sthref421"></a>Standard JDBC provides a <code>get</code><code><span class="codeinlineitalic">XXX</span></code> for each standard Java type, such as <code>getByte</code>, <code>getInt</code>, <code>getFloat</code>, and so on. Each of these returns exactly what the method name implies.</p>
<p>In addition, the <code>OracleResultSet</code> and <code><a id="sthref422"></a><a id="sthref423"></a>OracleCallableStatement</code> classes provide a full complement of <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods corresponding to all the <code>oracle.sql.*</code> types. Each <code>get</code><code><span class="codeinlineitalic">XXX</span></code> method returns an <code>oracle.sql.</code><code><span class="codeinlineitalic">XXX</span></code> object. For example, <code>getROWID</code> returns an <code>oracle.sql.ROWID</code> object.</p>
<p>There is no performance advantage in using the specific <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods. However, they do save you the trouble of casting, because the return type is specific to the object being returned.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABFIJEC">Return Types of getXXX Methods</a></p>
</li>
<li>
<p><a href="#BABCIIHF">Special Notes about getXXX Methods</a></p>
</li>
</ul>
<a id="BABFIJEC"></a><a id="JJDBC28383"></a>
<div class="sect3">
<h4 class="sect3">Return Types of getXXX Methods</h4>
<p>Refer to the Java doc to know <a id="sthref424"></a>the return types for each <code>get</code><code><span class="codeinlineitalic">XXX</span></code> method and also which are Oracle extensions under Java Development Kit (JDK) 1.6. You must cast the returned object to <code>OracleResultSet</code> or <code>OracleCallableStatement</code> to use methods that are Oracle extensions.</p>
</div>
<!-- class="sect3" -->
<a id="BABCIIHF"></a><a id="JJDBC28385"></a>
<div class="sect3">
<h4 class="sect3">Special Notes about getXXX Methods</h4>
<p>This section provides additional details about some <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods.</p>
<p class="subhead2"><a id="JJDBC28386"></a>getBigDecimal</p>
<p>JDBC 2.0 simplified method signatures for the <code>getBigDecimal</code> method. The previous input signatures were:</p>
<pre>
(int columnIndex, int scale) or (String columnName, int scale)
</pre>
<p>The simplified input signature is:</p>
<pre>
(int columnIndex) or (String columnName)
</pre>
<p>The <code>scale</code> parameter, used to specify the number of digits to the right of the decimal, is no longer necessary. The Oracle JDBC drivers retrieve numeric values with full precision.</p>
<p class="subhead2"><a id="JJDBC28387"></a>getBoolean</p>
<p>Because there is no <code>BOOLEAN</code> database type, when you use <code>getBoolean</code> a data type conversion always occurs. The <code>getBoolean</code> method is supported only for numeric columns. When applied to these columns, <code>getBoolean</code> interprets any zero value as <code>false</code> and any other value as <code>true</code>. When applied to any other sort of column, <code>getBoolean</code> raises the exception <code>java.lang.NumberFormatException</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1058745"></a><a id="JJDBC28388"></a>
<div class="sect2">
<h3 class="sect2">Data Types For Returned Objects from getObject and getXXX</h3>
<p>The return type of <code>getObject</code> is <code>java.lang.Object</code>. The returned value is an instance of a subclass of <code>java.lang.Object</code>. Similarly, the return type of <code><a id="sthref425"></a><a id="sthref426"></a>getOracleObject</code> is <code>oracle.sql.Datum</code>, and the class of the returned value is a subclass of <code>oracle.sql.Datum</code>. You typically cast the returned object to the appropriate class to use particular methods and functionality of that class.</p>
<p>In addition, you have the option of using a specific <a id="sthref427"></a><a id="sthref428"></a><a id="sthref429"></a><code>get</code><code><span class="codeinlineitalic">XXX</span></code> method instead of the generic <code>getObject</code> or <code>getOracleObject</code> methods. The <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods enable you to avoid casting, because the return type of <code>get</code><code><span class="codeinlineitalic">XXX</span></code> corresponds to the type of object returned. For example, the return type of <code>getCLOB</code> is <code>oracle.sql.CLOB</code>, as opposed to <code>java.lang.Object</code>.</p>
<p class="subhead2"><a id="JJDBC28389"></a>Example of Casting Return Values</p>
<p>This example assumes that you have fetched data of the <code>NUMBER</code> type as the first column of a result set. Because you want to manipulate the <code>NUMBER</code> data without losing precision, cast your result set to <code>OracleResultSet</code> and use <code>getOracleObject</code> to return the <code>NUMBER</code> data in <code>oracle.sql.*</code> format. If you do not cast your result set, then you have to use <code>getObject</code>, which returns your numeric data into a Java <code>Float</code> and loses some of the precision of your SQL data.</p>
<p>The <code>getOracleObject</code> method returns an <code>oracle.sql.NUMBER</code> object into an <code>oracle.sql.Datum</code> return variable unless you cast the output. Cast the <code>getOracleObject</code> output to <code>oracle.sql.NUMBER</code> if you want to use a <code>NUMBER</code> return variable and any of the special functionality of that class.</p>
<pre>
NUMBER x = (NUMBER)ors.getOracleObject(1);
</pre></div>
<!-- class="sect2" -->
<a id="i1059382"></a><a id="JJDBC28390"></a>
<div class="sect2">
<h3 class="sect2">The setObject and setOracleObject Methods</h3>
<p><a id="sthref430"></a><a id="sthref431"></a>Just as there is a standard <code>getObject</code> and Oracle-specific <code>getOracleObject</code> in result sets and callable statements, there are also standard <code>setObject</code> and Oracle-specific <code>setOracleObject</code> methods in <code>OraclePreparedStatement</code> and <code>OracleCallableStatement</code>. The <code>setOracleObject</code> methods take <code>oracle.sql.*</code> input parameters.</p>
<p>To bind standard Java types to a prepared statement or callable statement, use the <code>setObject</code> method, which takes a <code>java.lang.Object</code> as input. The <code>setObject</code> method does support a few of the <code>oracle.sql.*</code> types. However, the method has been implemented so that you can enter instances of the <code>oracle.sql.*</code> classes that correspond to the following JDBC standard types: <code>Blob</code>, <code>Clob</code>, <code>Struct</code>, <code>Ref</code>, and <code>Array</code>.</p>
<p>To bind <code>oracle.sql.*</code> types to a prepared statement or callable statement, use the <code>setOracleObject</code> method, which takes a subclass of <code>oracle.sql.Datum</code> as input. To use <code>setOracleObject</code>, you must cast your prepared statement or callable statement to <code>OraclePreparedStatement</code> or <code>OracleCallableStatement</code>.</p>
<p class="subhead2"><a id="JJDBC28391"></a>Example of Using setObject and setOracleObject</p>
<p>For a prepared statement, the <code>setOracleObject</code> method binds the <code>oracle.sql.CHAR</code> data represented by the <code>charVal</code> variable to the prepared statement. To bind the <code>oracle.sql.*</code> data, the prepared statement must be cast to <code>OraclePreparedStatement</code>. Similarly, the <code>setObject</code> method binds the Java <code>String</code> data represented by the variable <code>strVal</code>.</p>
<pre>
PreparedStatement ps= conn.prepareStatement("<span class="codeinlineitalic">t</span><span class="italic">ext_of_prepared_statement</span>");
((OraclePreparedStatement)ps).setOracleObject(1,charVal);
ps.setObject(2,strVal);
</pre></div>
<!-- class="sect2" -->
<a id="i1058921"></a><a id="JJDBC28392"></a>
<div class="sect2">
<h3 class="sect2">Other setXXX Methods</h3>
<p>As with the <code>get</code><code><span class="codeinlineitalic">XXX</span></code> methods, there are several specific <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods. Standard <a id="sthref432"></a><code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods are provided for binding standard Java types, and Oracle-specific <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods are provided for binding Oracle-specific types.</p>
<p>Similarly, there are two forms of the <code>setNull</code> method:</p>
<ul>
<li>
<p><code>void <a id="sthref433"></a>setNull(int</code> <code><span class="codeinlineitalic">parameterIndex,</span></code> <code>int</code> <code><span class="codeinlineitalic">sqlType</span></code><code>)</code></p>
<p>This is specified in the standard <code>java.sql.PreparedStatement</code> interface. This signature takes a parameter index and a SQL type code defined by the <code>java.sql.Types</code> or <code>oracle.jdbc.OracleTypes</code> class. Use this signature to set an object other than a <code>REF</code>, <code>ARRAY</code>, or <code>STRUCT</code> to <code>NULL</code>.</p>
</li>
<li>
<p><code>void setNull(int</code> <code><span class="codeinlineitalic">parameterIndex</span></code>, <code>int</code> <code><span class="codeinlineitalic">sqlType</span></code><code>, String</code> <code><span class="codeinlineitalic">sql_type_name</span></code>)</p>
<p>With JDBC 2.0, this signature is also specified in the standard <code>java.sql.PreparedStatement</code> interface. This method takes a SQL type name in addition to a parameter index and a SQL type code. Use this method when the SQL type code is <code>java.sql.Types.REF</code>, <code>ARRAY</code>, or <code>STRUCT</code>. If the type code is other than <code>REF</code>, <code>ARRAY</code>, or <code>STRUCT</code>, then the given SQL type name is ignored.</p>
</li>
</ul>
<p>Similarly, the <code><a id="sthref434"></a><a id="sthref435"></a>registerOutParameter</code> method has a signature for use with <code>REF</code>, <code>ARRAY</code>, or <code>STRUCT</code> data:</p>
<pre>
void registerOutParameter
            (int <span class="italic">parameterIndex</span>, int <span class="italic">sqlType</span>, String <span class="italic">sql_type_name</span>)
</pre>
<p>Binding Oracle-specific types using the appropriate <code>setXXX</code> methods, instead of the methods used for binding standard Java types, may offer some performance advantage.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BJFHJDIH">Input Data Binding</a></p>
</li>
<li>
<p><a href="#BABCHGCH">Method setFixedCHAR for Binding CHAR Data into WHERE Clauses</a></p>
</li>
</ul>
<a id="BJFHJDIH"></a><a id="JJDBC28395"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Input Data Binding</h4>
<p>There are three way to bind data for input:</p>
<ul>
<li>
<p>Direct binding where the data itself is placed in a bind buffer</p>
</li>
<li>
<p>Stream binding where the data is streamed</p>
</li>
<li>
<p>LOB binding where a temporary lob is created, the data placed in the LOB using the LOB APIs, and the bytes of the LOB locator are placed in the bind buffer</p>
</li>
</ul>
<p>The three kinds of binding have some differences in performance and have an impact on batching. Direct binding is fast and batching is fine. Stream binding is slower, may require multiple round trips, and turns batching off. LOB binding is very slow and requires many round trips. Batching works, but might be a bad idea. They also have different size limits, depending on the type of the SQL statement.</p>
<p>For SQL parameters, the length of standard parameter types, such as <code>RAW</code> and <code>VARCHAR2</code>, is fixed by the size of the target column. For PL/SQL parameters, the size is limited to a fixed number of bytes, which is 32766.</p>
<p>In Oracle Database 10<span class="italic">g</span> release 2 (10.2), certain changes were made to the <code>setString</code>, <code>setCharacterStream</code>, <code>setAsciiStream</code>, <code>setBytes</code>, and <code>setBinaryStream</code> methods of <code>PreparedStatement</code>. The original behavior of these APIs were:</p>
<ul>
<li>
<p><code>setString</code>: Direct bind of characters</p>
</li>
<li>
<p><code>setCharacterStream</code>: Stream bind of characters</p>
</li>
<li>
<p><code>setAsciiStream</code>: Stream bind of bytes</p>
</li>
<li>
<p><code>setBytes</code>: Direct bind of bytes</p>
</li>
<li>
<p><code>setBinaryStream</code>: Stream bind of bytes</p>
</li>
</ul>
<p>Starting from Oracle Database 10<span class="italic">g</span> release 2 (10.2), automatic switching between binding modes, based on the data size and on the type of the SQL statement is provided.</p>
<p class="subhead2"><a id="JJDBC28396"></a>setBytes and setBinaryStream</p>
<p>For SQL, direct bind is used for size up to 2000 and stream bind for larger.</p>
<p>For PL/SQL direct bind is used for size up to 32766 and LOB bind is used for larger.</p>
<p class="subhead2"><a id="JJDBC28397"></a>setString, setCharacterStream, and setAsciiStream</p>
<p>For SQL, direct bind is used up to 32766 Java characters and stream bind is used for larger. This is independent of character set.</p>
<p>For PL/SQL, you must be careful about the byte size of the character data in the database character set or the national character set depending on the setting of the form of use parameter. Direct bind is used for data where the byte length is less than 32766 and LOB bind is used for larger.</p>
<p>For fixed length character sets, multiply the length of the Java character data by the fixed character size in bytes and compare that to the restrictive values. For variable length character sets, there are three cases based on the Java character length, as follows:</p>
<ul>
<li>
<p>If character length is less than 32766 divided by the maximum character size, then direct bind is used.</p>
</li>
<li>
<p>If character length is greater than 32766 divided by the minimum character size, then LOB bind is used.</p>
</li>
<li>
<p>If character length is in between and if the actual length of the converted bytes is less than 32766, then direct bind is used, else LOB bind is used.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
When a PL/SQL procedure is embedded in a SQL statement, the binding action is different. Refer to <a href="oralob.htm#CHDGJJDD">"Data Interface for LOBs"</a> for more information.</div>
<p>The server-side internal driver has the following additional limitations:</p>
<ul>
<li>
<p><code>setString</code>, <code>setCharacterStream</code>, and <code>setASCIIStream</code> APIs are not supported for SQL CLOB columns when the data size in characters is over 4000 bytes</p>
</li>
<li>
<p><code>setBytes</code> and <code>setBinaryStream</code> APIs are not supported for SQL BLOB columns when the data size is over 2000 bytes</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Important:</p>
Do not use these APIs with the server-side internal driver, without careful checking of the data size in client code.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
JDBC Release Notes for further discussion and possible workarounds</div>
</div>
<!-- class="sect3" -->
<a id="BABCHGCH"></a><a id="JJDBC28401"></a>
<div class="sect3">
<h4 class="sect3">Method setFi<a id="sthref436"></a><a id="sthref437"></a>xedCHAR for Binding CHAR Data into WHERE Clauses</h4>
<p><code>CHAR</code> data in the database is padded to the column width. This leads to a limitation in using the <code>setCHAR</code> method to bind character data into the <code>WHERE</code> clause of a <code>SELECT</code> statement. The character data in the <code>WHERE</code> clause must also be padded to the column width to produce a match in the <code>SELECT</code> statement. This is especially troublesome if you do not know the column width.</p>
<p>To remedy this, Oracle has added the <code>setFixedCHAR</code> method to the <code>OraclePreparedStatement</code> class. This method runs a non-padded comparison.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Remember to cast your prepared statement object to <code>OraclePreparedStatement</code> to use the <code>setFixedCHAR</code> method.</p>
</li>
<li>
<p>There is no need to use <code>setFixedCHAR</code> for an <code>INSERT</code> statement. The database always automatically pads the data to the column width as it inserts it.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JJDBC28402"></a>Example</p>
<p>The following example demonstrates the difference between the <code>setCHAR</code> and <code>setFixedCHAR</code> methods.</p>
<pre>
/* Schema is :
 create table my_table (col1 char(10));
 insert into my_table values ('JDBC');
*/
 PreparedStatement pstmt = conn.prepareStatement 
                    ("select count(*) from my_table where col1 = ?");

 pstmt.setString (1, "JDBC");  // Set the Bind Value
 runQuery (pstmt);             // This will print " No of rows are 0"

 CHAR ch = new CHAR("JDBC      ", null);
 ((OraclePreparedStatement)pstmt).setCHAR(1, ch); // Pad it to 10 bytes
 runQuery (pstmt);             // This will print "No of rows are 1"

 ((OraclePreparedStatement)pstmt).setFixedCHAR(1, "JDBC");
  runQuery (pstmt);            // This will print "No of rows are 1"
 
 void runQuery (PreparedStatement ps)
 {    
   // Run the Query
   ResultSet rs = pstmt.executeQuery ();

   while (rs.next())
     System.out.println("No of rows are " + rs.getInt(1));
   
   rs.close();
   rs = null;
 }
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1059088"></a><a id="JJDBC28403"></a>
<div class="sect1">
<h2 class="sect1">Using Result Set Metadata Extensions</h2>
<p>The <code><a id="sthref438"></a><a id="sthref439"></a>oracle.jdbc.OracleResultSetMetaData</code> interface is JDBC 2.0-compliant but does not implement the <code>getSchemaName</code> and <code>getTableName</code> methods because Oracle Database does not make this feasible.</p>
<p>The following code snippet uses several of the methods in the <code>OracleResultSetMetadata</code> interface to retrieve the number of columns from the <code>EMP</code> table and the numerical type and SQL type name of each column:</p>
<pre>
DatabaseMetaData dbmd = conn.getMetaData();
ResultSet rset = dbmd.getTables("", "SCOTT", "EMP", null);

 while (rset.next())
 {
   OracleResultSetMetaData orsmd = ((OracleResultSet)rset).getMetaData();
   int numColumns = orsmd.getColumnCount();
   System.out.println("Num of columns = " + numColumns);

   for (int i=0; i&lt;numColumns; i++)
   {
     System.out.print ("Column Name=" + orsmd.getColumnName (i+1));
     System.out.print (" Type=" + orsmd.getColumnType (i + 1) );
     System.out.println (" Type Name=" + orsmd.getColumnTypeName (i + 1));
  }
}
</pre>
<p>The program returns the following output:</p>
<pre>
Num of columns = 5
Column Name=TABLE_CAT Type=12 Type Name=VARCHAR2
Column Name=TABLE_SCHEM Type=12 Type Name=VARCHAR2
Column Name=TABLE_NAME Type=12 Type Name=VARCHAR2
Column Name=TABLE_TYPE Type=12 Type Name=VARCHAR2
Column Name=TABLE_REMARKS Type=12 Type Name=VARCHAR2
</pre></div>
<!-- class="sect1" -->
<a id="CHDGEJDJ"></a><a id="JJDBC28404"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using SQL CALL and CALL INTO Statements</h2>
<p>You can use the CALL statement to execute a routine from within SQL.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A routine is a procedure or a function that is standalone or is defined within a type or package. You must have <code>EXECUTE</code> privilege on the standalone routine or on the type or package in which the routine is defined. Refer to the "<a class="olink SQLRF" href="../../server.112/e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>" for more information about using the <code>CALL</code> statement.</div>
<p>You can execute a routine in two ways:</p>
<ul>
<li>
<p>By issuing a call to the routine itself by name or by using the <code>routine_clause</code></p>
</li>
<li>
<p>By using an <code>object_access_expression</code> inside the type of an expression</p>
</li>
</ul>
<p>You can specify one or more arguments to the routine, if the routine takes arguments. You can use positional, named, or mixed notation for argument.</p>
<p class="subhead2"><a id="JJDBC28405"></a>CALL INTO Statement</p>
<p>The <code>INTO</code> clause applies only to calls to functions. You can use the following types of variables with this clause:</p>
<ul>
<li>
<p>Host variable</p>
</li>
<li>
<p>Indicator variable</p>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28406"></a>PL/SQL Blocks</p>
<p>The basic unit in PL/SQL is a block. All PL/SQL programs are made up of blocks, which can be nested within each other. A PL/SQL block has three parts: a declarative part, an executable part, and an exception-handling part. You get the following advantages by using PL/SQL blocks in your application:</p>
<ul>
<li>
<p>Better performance</p>
</li>
<li>
<p>Higher productivity</p>
</li>
<li>
<p>Full portability</p>
</li>
<li>
<p>Tight integration with Oracle</p>
</li>
<li>
<p>Tight security</p>
</li>
</ul>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1">
<tr>
<td class="cellalignment10">
<table class="cellalignment6">
<tr>
<td class="cellalignment5"><a href="part4.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5"><a href="jstreams.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment13">
<table class="cellalignment4">
<tr>
<td class="cellalignment5"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
