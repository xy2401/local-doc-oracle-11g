<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Working with Oracle Object Types</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.1" />
<meta name="dcterms.created" content="2011-09-15T1:42:58Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database JDBC Developer's Guide" />
<meta name="dcterms.identifier" content="E16548-03" />
<meta name="dcterms.isVersionOf" content="JJDBC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="jstreams.htm" title="Previous" type="text/html" />
<link rel="Next" href="oralob.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e16548.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">24/54</span> <!-- End Header --><a id="g1104293"></a><a id="JJDBC28431"></a>
<h1 class="chapter"><span class="secnum">13</span> Working with Oracle Object Types</h1>
<p><a id="sthref476"></a><a id="sthref477"></a>This chapter describes the Java Database Connectivity (JDBC) support for user-defined object types. It discusses functionality of the generic, weakly typed <code>oracle.sql.STRUCT</code> class, as well as how to map to custom Java classes that implement either the JDBC standard <code><a id="sthref478"></a>SQLData</code> interface or the Oracle <code><a id="sthref479"></a>ORAData</code> interface.</p>
<p><a id="i1040527"></a>The following topics are covered:</p>
<ul>
<li>
<p><a href="#i1056044">Mapping Oracle Objects</a></p>
</li>
<li>
<p><a href="#i1039476">Using the Default STRUCT Class for Oracle Objects</a></p>
</li>
<li>
<p><a href="#i1039528">Creating and Using Custom Object Classes for Oracle Objects</a></p>
</li>
<li>
<p><a href="#i1078205">Object-Type Inheritance</a></p>
</li>
<li>
<p><a href="#i1078761">Using JPublisher to Create Custom Object Classes</a></p>
</li>
<li>
<p><a href="#i1059278">Describing an Object Type</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ" href="../../appdev.112/e11822/toc.htm"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a></div>
<a id="i1056044"></a><a id="JJDBC28432"></a>
<div class="sect1">
<h2 class="sect1">Mapping Oracle Objects</h2>
<p><a id="sthref480"></a>Oracle object types provide support for composite data structures in the database. For example, you can define a <code>Person</code> type that has the attributes <code>name</code> of <code>CHAR</code> type, <code>phoneNumber</code> of <code>CHAR</code> type, and <code>employeeNumber</code> of <code>NUMBER</code> type.</p>
<p>Oracle provides tight integration between its <a id="sthref481"></a>Oracle object features and its JDBC functionality. You can use a standard, generic JDBC type to map to Oracle objects, or you can customize the mapping by creating custom Java type definition classes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this book, Java classes that you create to map to Oracle objects will be referred to as <span class="bold">cust<a id="sthref482"></a>om Java classes</span> or, more specifically, <span class="bold">cust<a id="sthref483"></a>om object classes</span>. This is as opposed to <span class="bold">custom references classes</span>, which are Java classes that map to object references, and <span class="bold">custom collection classes</span>, which are Java classes that map to Oracle collections.</div>
<p>Custom object classes can implement either a standard JDBC interface or an Oracle extension interface to read and write data. JDBC materializes Oracle objects as instances of particular Java classes. Two main steps in using JDBC to access Oracle objects are:</p>
<ol>
<li>
<p>Creating the Java classes for the Oracle objects</p>
</li>
<li>
<p>Populating these classes. You have the following options:</p>
<ul>
<li>
<p>Let JDBC materialize the object as a <code>STRUCT</code> object.</p>
</li>
<li>
<p>Explicitly specify the mappings between Oracle objects and Java classes.</p>
<p>This includes customizing your Java classes for object data. The driver then must be able to populate instances of the custom object classes that you specify. This imposes a set of constraints on the Java classes. To satisfy these constraints, you can define your classes to implement either the JDBC standard <code>java.sql.SQLData</code> interface or the Oracle extension <code>oracle.sql.ORAData</code> interface.</p>
</li>
</ul>
</li>
</ol>
<p>You can use the Oracle JPublisher utility to generate custom Java classes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use the <code>SQLData</code> interface, you must use a Java type map to specify your SQL-Java mapping, unless weakly typed <code>java.sql.Struct</code> objects will suffice.</div>
</div>
<!-- class="sect1" -->
<a id="i1039476"></a><a id="JJDBC28433"></a>
<div class="sect1">
<h2 class="sect1">Using the Default STRUCT Class for Oracle Objects</h2>
<p>If you choose not to supply a custom Java class for your SQL-Java mapping for an <a id="sthref484"></a>Oracle object, then Oracle JDBC materializes the object as an object that implements the <code>java.sql.Struct</code> interface.</p>
<p>You would typically want to use <code>STRUCT</code> objects, instead of custom Java objects, in situations where you do not know the actual SQL type. For example, your Java application might be a tool to manipulate arbitrary object data within the database, as opposed to being an end-user application. You can select data from the database into <code>STRUCT</code> objects and create <code>STRUCT</code> objects for inserting data into the database. <code>STRUCT</code> objects completely preserve data, because they maintain the data in SQL format. Using <code>STRUCT</code> objects is more efficient and more precise in situations where you do not need the information in an application specific form.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1057236">Retrieving STRUCT Objects and Attributes</a></p>
</li>
<li>
<p><a href="#i1057069">Creating STRUCT Objects</a></p>
</li>
<li>
<p><a href="#BABCEIBE">Binding STRUCT Objects into Statements</a></p>
</li>
<li>
<p><a href="#i1061736">STRUCT Automatic Attribute Buffering</a></p>
</li>
</ul>
<a id="BABBDBFH"></a><a id="JJDBC28434"></a>
<div class="sect2">
<h3 class="sect2">STRUCT Class Functionality</h3>
<p>This section discusses standard versus Oracle-specific features of the <code>oracle.sql.STRUCT</code> class, introduces <code>STRUCT</code> descriptors, and lists methods of the <code>STRUCT</code> class to give an overview of its functionality.</p>
<p class="subhead2"><a id="JJDBC28435"></a>Standard java.sql.Struct Methods</p>
<p>If your code must comply with standard JDBC 2.0, then use a <code>java.sql.Struct</code> instance and use the following standard methods:</p>
<ul>
<li>
<p><code>getAttributes(map)</code></p>
<p>This method retrieves the values of the attributes, using entries in the specified type map to determine the Java classes to use in materializing any attribute that is a structured object type. The Java types for other attribute values would be the same as for a <code>getObject</code> call on data of the underlying SQL type.</p>
</li>
<li>
<p><code>getAttributes</code></p>
<p>This method is the same as the preceding <code>getAttributes(map)</code> method, except it uses the default type map for the connection.</p>
</li>
<li>
<p><code><a id="sthref485"></a><a id="sthref486"></a>getSQLTypeName</code></p>
<p>This method returns a Java <code>String</code> that represents the fully qualified name of the Oracle object type that this <code>Struct</code> represents.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1057236"></a><a id="JJDBC28438"></a>
<div class="sect2">
<h3 class="sect2">Retrieving STR<a id="sthref487"></a>UCT Objects and Attributes</h3>
<p>This section discusses how to retrieve and manipulate Oracle objects and their attributes, using either Oracle-specific features or JDBC 2.0 standard features.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The JDBC driver seamlessly handles embedded objects, that is, <code><a id="sthref488"></a>STRUCT</code> objects that are attributes of <code>STRUCT</code> objects, in the same way that it typically handles objects. When the JDBC driver retrieves an attribute that is an object, it follows the same rules of conversion by using the type map, if it is available, or by using default mapping.</div>
<p class="subhead2"><a id="JJDBC28440"></a>Retrieving an Oracle Object as a java.sql.Struct Object</p>
<p>Alternatively, in the preceding example, you can use standard JDBC functionality, such as <code><a id="sthref489"></a><a id="sthref490"></a>getObject</code>, to retrieve an Oracle object from the database as an instance of <code>java.sql.Struct</code>. Because <code>getObject</code> returns a <code>java.lang.Object</code>, you must cast the output of the method to <code>Struct</code>. For example:</p>
<pre>
ResultSet rs= stmt.executeQuery("SELECT * FROM struct_table");
java.sql.Struct jdbcStruct = (java.sql.Struct)rs.getObject(1);
</pre>
<p class="subhead2"><a id="JJDBC28441"></a>Retrieving Attri<a id="sthref491"></a>butes as oracle.sql Types</p>
<p>If you want to retrieve Oracle object attributes from a <code>STRUCT</code> or <code>Struct</code> instance as <code>oracle.sql</code> types, then use the <code>get<a id="sthref492"></a>OracleAttributes</code> method of the <code>oracle.sql.STRUCT</code> class, as follows:</p>
<pre>
oracle.sql.Datum[] attrs = oracleSTRUCT.getOracleAttributes();
</pre>
<p>or:</p>
<pre>
oracle.sql.Datum[] attrs = ((oracle.sql.STRUCT)jdbcStruct).getOracleAttributes();
</pre>
<p class="subhead2"><a id="JJDBC28442"></a>Retrieving Attributes as Standard Java Types</p>
<p>If you want to retrieve Oracle object attributes as standard Java types from a <code>STRUCT</code> or <code>Struct</code> instance, use the standard <code>getAttributes</code> method:</p>
<pre>
Object[] attrs = jdbcStruct.getAttributes();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle JDBC drivers cache array and structure descriptors. This provides enormous performance benefits. However, it means that if you change the underlying type definition of a structure type in the database, the cached descriptor for that structure type will become stale and your application will receive a <code>SQLException</code> exception.</div>
</div>
<!-- class="sect2" -->
<a id="i1057069"></a><a id="JJDBC28443"></a>
<div class="sect2">
<h3 class="sect2">Creating STRUCT Objects</h3>
<p>For information about creating STRUCT objects, refer to <a href="oraint.htm#i1075337">"Overview of Class oracle.sql.STRUCT"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABCEIBE"></a><a id="JJDBC28447"></a>
<div class="sect2">
<h3 class="sect2">Binding STRUCT Objects into Statements</h3>
<p>To bind an <code>oracle.sql.STRUCT</code> object to a prepared statement or callable statement, you can either use the standard <a id="sthref493"></a><code>setObject</code> method (specifying the type code), or cast the statement object to an Oracle statement type and use the Oracle extension <code>setOracleObject</code> method. For example:</p>
<pre>
PreparedStatement ps= conn.prepareStatement("<span class="italic">text_of_prepared_statement</span>");
STRUCT mySTRUCT = new STRUCT (...);
ps.setObject(1, mySTRUCT, Types.STRUCT);
</pre>
<p>or:</p>
<pre>
PreparedStatement ps= conn.prepareStatement("<span class="italic">text_of_prepared_statement</span>");
STRUCT mySTRUCT = new STRUCT (...);
((OraclePreparedStatement)ps).setOracleObject(1, mySTRUCT);
</pre></div>
<!-- class="sect2" -->
<a id="i1061736"></a><a id="JJDBC28448"></a>
<div class="sect2">
<h3 class="sect2">STRUCT Automatic Attribute Buffering</h3>
<p>Oracle JDBC driver furnishes public methods to enable and disable buffering of <code>STRUCT</code> attributes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="oraarr.htm#i1059905">"ARRAY Automatic Element Buffering"</a></div>
<p>The following methods are included with the <code><a id="sthref494"></a>oracle.sql.STRUCT</code> class:<code><a id="sthref495"></a></code></p>
<ul>
<li>
<p><code>public void <a id="sthref496"></a>setAutoBuffering(boolean enable)</code></p>
</li>
<li>
<p><code>public boolean <a id="sthref497"></a>getAutoBuffering()</code></p>
</li>
</ul>
<p>The <code>setAutoBuffering(boolean)</code> method enables or disables auto-buffering. The <code>getAutoBuffering</code> method returns the current auto-buffering mode. By default, auto-buffering is disabled.</p>
<p>It is advisable to enable auto-buffering in a JDBC application when the <code>STRUCT</code> attributes will be accessed more than once by the <code>getAttributes</code> and <code>getArray</code> methods, presuming the <code>ARRAY</code> data is able to fit into the Java Virtual Machine (JVM) memory without overflow.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Buffering the converted attributes may cause the JDBC application to consume a significant amount of memory.</div>
<p>When you enable auto-buffering, the <code>oracle.sql.STRUCT</code> object keeps a local copy of all the converted attributes. This data is retained so that subsequent access of this information does not require going through the data format conversion process.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1039528"></a><a id="JJDBC28449"></a>
<div class="sect1">
<h2 class="sect1">Creating and Using Custom Object Classes for Oracle Objects</h2>
<p>If you want to create <a id="sthref498"></a>custom object classes for your <a id="sthref499"></a>Oracle objects, then you must define entries in the <a id="sthref500"></a>type map that specify the custom object classes that the drivers will instantiate for the corresponding Oracle objects.</p>
<p>You must also provide a way to create and populate instances of the custom object class from the Oracle object and its attribute data. The driver must be able to read from a custom object class and write to it. In addition, the custom object class can provide <code>get</code><code><span class="codeinlineitalic">XXX</span></code> and <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods corresponding to the attributes of the Oracle object, although this is not necessary. To create and populate the custom classes and provide these read/write capabilities, you can choose between the following interfaces:</p>
<ul>
<li>
<p>The JDBC standard <code>SQLData</code> interface</p>
</li>
<li>
<p>The <code>ORAData</code> and <code>ORADataFactory</code> interfaces provided by Oracle</p>
</li>
</ul>
<p>The custom object class you create must implement one of these interfaces. The <code>ORAData</code> interface can also be used to implement the custom reference class corresponding to the custom object class. However, if you are using the <code>SQLData</code> interface, then you can use only weak reference types in Java, such as <code>java.sql.Ref</code> or <code>oracle.sql.REF</code>. The <code>SQLData</code> interface is for mapping SQL objects only.</p>
<p>As an example, assume you have an Oracle object type, <code>EMPLOYEE</code>, in the database that consists of two attributes: <code>Name</code>, which is of the <code>CHAR</code> type and <code>EmpNum</code>, which is of the <code>NUMBER</code> type. You use the type map to specify that the <code>EMPLOYEE</code> object should map to a custom object class that you call <code>JEmployee</code>. You can implement either the <code>SQLData</code> or <code>ORAData</code> interface in the <code>JEmployee</code> class.</p>
<p>You can create custom object classes yourself, but the most convenient way to create them is to use the Oracle <a id="sthref501"></a>JPublisher utility to create them for you. JPublisher supports the standard <code>SQLData</code> interface as well as the Oracle-specific <code>ORAData</code> interface, and is able to generate classes that implement either one.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1078761">"Using JPublisher to Create Custom Object Classes"</a> and <a href="#i1078205">"Object-Type Inheritance"</a></div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1074234">Relative Advantages of ORAData versus SQLData</a></p>
</li>
<li>
<p><a href="#i1039547">Understanding Type Maps for SQLData Implementations</a></p>
</li>
<li>
<p><a href="#i1058580">Creating Type Map and Defining Mappings for a SQLData Implementation</a></p>
</li>
<li>
<p><a href="#i1060229">Reading and Writing Data with a SQLData Implementation</a></p>
</li>
<li>
<p><a href="#i1040531">Understanding the ORAData Interface</a></p>
</li>
<li>
<p><a href="#i1060230">Reading and Writing Data with a ORAData Implementation</a></p>
</li>
<li>
<p><a href="#BABDDEAE">Additional Uses for ORAData</a></p>
</li>
</ul>
<a id="i1074234"></a><a id="JJDBC28450"></a>
<div class="sect2">
<h3 class="sect2">Relative Advantages of ORAData versus SQLData</h3>
<p>In deciding which of the two interface implementations to use, you need to consider the advantages of <code>ORAData</code> and <code>SQLData</code>.</p>
<p>The <code>SQLData</code> interface is for mapping SQL objects only. The <code>ORAData</code> interface is more flexible, enabling you to map SQL objects as well as any other SQL type for which you want to customize processing. You can create a <code>ORAData</code> object from any data type found in Oracle Database. This could be useful, for example, for serializing <code>RAW</code> data in Java.</p>
<p class="subhead2"><a id="JJDBC28451"></a>Advantages of <a id="sthref502"></a>ORAData</p>
<p>The advantages of <code>ORAData</code> are:</p>
<ul>
<li>
<p>It does not require an entry in the type map for the Oracle object.</p>
</li>
<li>
<p>It has awareness of Oracle extensions.</p>
</li>
<li>
<p>You can construct an <code>ORAData</code> from an <code>oracle.sql.STRUCT</code>. This is more efficient because it avoids unnecessary conversions to native Java types.</p>
</li>
<li>
<p>You can obtain the corresponding <code>Datum</code> object from the <code>ORAData</code> object, using the <code><a id="sthref503"></a>toDatum</code> method.</p>
</li>
<li>
<p>It provides better performance. <code>ORAData</code> works directly with <code>Datum</code> types, which is the internal format used by the driver to hold Oracle objects.</p>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28452"></a>Advantages of <a id="sthref504"></a>SQLData</p>
<p><code>SQLData</code> is a JDBC standard that makes your code portable.</p>
</div>
<!-- class="sect2" -->
<a id="i1039547"></a><a id="JJDBC28453"></a>
<div class="sect2">
<h3 class="sect2">Understanding Type Maps for SQLData Implementations</h3>
<p>If you use the <code>SQLData</code> interface in a custom object class, then you must create type map entries that specify the custom object class to use in mapping the Oracle object type to Java. You can either use the default type map of the connection object or a type map that you specify when you retrieve the data from the result set. The <code>getObject</code> method of the <code>ResultSet</code> interface has a signature that lets you specify a type map. You can use either of the following:</p>
<pre>
rs.getObject(int columnIndex);

rs.getObject(int columnIndex, Map map);
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1039528">"Creating and Using Custom Object Classes for Oracle Objects"</a></div>
<p>When using a SQLData implementation, if you do not include a type map entry, then the object will map to the <code>oracle.sql.STRUCT</code> class by default. <code>ORAData</code> implementations, by contrast, have their own mapping functionality so that a type map entry is not required. When using an <code>ORAData</code> implementation, use the Oracle <code>getORAData</code> method instead of the standard <code>getObject</code> method.</p>
<p>The type map relates a Java class to the SQL type name of an Oracle object. This one-to-one mapping is stored in a hash table as a keyword-value pair. When you read data from an Oracle object, the JDBC driver considers the type map to determine which Java class to use to materialize the data from the Oracle object type. When you write data to an Oracle object, the JDBC driver gets the SQL type name from the Java class by calling the <code>getSQLTypeName</code> method of the <code>SQLData</code> interface. The actual conversion between SQL and Java is performed by the driver.</p>
<p>The attributes of the Java class that corresponds to an Oracle object can use either Java native types or Oracle native types to store attributes.</p>
</div>
<!-- class="sect2" -->
<a id="i1058580"></a><a id="JJDBC28454"></a>
<div class="sect2">
<h3 class="sect2">Creating Type Map and Defining Mappings for a SQLData Implementation</h3>
<p>When using a <code>SQLData</code> implementation, the JDBC applications programmer is responsible for providing a type map, which must be an instance of a class that implements the standard <code>java.util.Map</code> interface.</p>
<p>You have the option of creating your own class to accomplish this, but the standard <code>java.util.Hashtable</code> class meets the requirement.</p>
<p><code>Hashtable</code> and other classes used for type maps implement a <code>pu<a id="sthref505"></a>t</code> method that takes keyword-value pairs as input, where each key is a fully qualified SQL type name and the corresponding value is an instance of a specified Java class.</p>
<p>A type map is associated with a connection instance. The standard <code>java.sql.Connection</code> interface and the Oracle-specific <code>oracle.jdbc.OracleConnection</code> interface include a <code>getTypeMap</code> method. Both return a <code>Map</code> object.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1039586">Adding Entries to an Existing Type Map</a></p>
</li>
<li>
<p><a href="#i1039612">Creating a New Type Map</a></p>
</li>
<li>
<p><a href="#BABIEDEC">Materializing Object Types not Specified in the Type Map</a></p>
</li>
</ul>
<a id="i1039586"></a><a id="JJDBC28455"></a>
<div class="sect3">
<h4 class="sect3">Adding Entries to an Existing Type Map</h4>
<p>When a connection instance is first established, the default type map is empty. You must populate it.</p>
<p>Perform the following <a id="sthref506"></a>general steps to add entries to an existing type map:</p>
<ol>
<li>
<p>Use the <code><a id="sthref507"></a>getTypeMap</code> method of your <code>OracleConnection</code> object to return the type map object of the connection. The <code>getTypeMap</code> method returns a <code>java.util.Map</code> object. For example, presuming an <code>OracleConnection</code> instance <code>oraconn</code>:</p>
<pre>
java.util.Map myMap = oraconn.getTypeMap();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the type map in the <code>OracleConnection</code> instance has not been initialized, then the first call to <code>getTypeMap</code> returns an empty map.</div>
</li>
<li>
<p>Use the <code><a id="sthref508"></a>put</code> method of the type map to add map entries. The <code>put</code> method takes two arguments: a SQL type name string and an instance of a specified Java class that you want to map to.</p>
<pre>
myMap.put(<span class="italic">sqlTypeName</span>, <span class="italic">classObject</span>);
</pre>
<p>The <code><span class="codeinlineitalic">sqlTypeName</span></code> is a string that represents the fully qualified name of the SQL type in the database. The <code><span class="codeinlineitalic">classObject</span></code> is the Java class object to which you want to map the SQL type. Get the class object with the <code>Class.forName</code> method, as follows:</p>
<pre>
myMap.put(<span class="italic">sqlTypeName</span>, Class.forName(<span class="italic">className</span>));
</pre>
<p>For example, if you have a <code>PERSON</code> SQL data type defined in the <code>CORPORATE</code> database schema, then map it to a <code>Person</code> Java class defined as <code>Person</code> with this statement:</p>
<pre>
myMap.put("CORPORATE.PERSON", Class.forName("Person"));
oraconn.setTypeMap(newMap);
 
</pre>
<p>The map has an entry that maps the <code>PERSON</code> SQL data type in the <code>CORPORATE</code> database to the <code>Person</code> Java class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL type names in the type map must be all uppercase, because that is how Oracle Database stores SQL names.</div>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="i1039612"></a><a id="JJDBC28456"></a>
<div class="sect3">
<h4 class="sect3">Creating a New Type Map</h4>
<p>Perform <a id="sthref509"></a>the following general steps to create a new type map. This example uses an instance of <code>java.util.Hashtable</code>, which extends <code>java.util.Dictionary</code> and implements <code>java.util.Map</code>.</p>
<ol>
<li>
<p>Create a new type map object.</p>
<pre>
Hashtable newMap = new Hashtable();
</pre></li>
<li>
<p>Use the <code>put</code> method of the type map object to add entries to the map. For example, if you have an <code>EMPLOYEE</code> SQL type defined in the <code>CORPORATE</code> database, then you can map it to an <code>Employee</code> class object defined by <code>Employee.java</code>, as follows:</p>
<pre>
newMap.put("CORPORATE.EMPLOYEE", class.forName("Employee"));
</pre></li>
<li>
<p>When you finish adding entries to the map, you must use the <code>setTypeMap</code> method of the <code>OracleConnection</code> object to overwrite the existing type map of the connection. For example:</p>
<pre>
oraconn.setTypeMap(newMap);
</pre>
<p>In this example, the <code>setTypeMap</code> method overwrites the original map of the <code>oraconn</code> connection object with <code>newMap</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The default type map of a connection instance is used when mapping is required but no map name is specified, such as for a result set <code>getObject</code> call that does not specify the map as input.</div>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="BABIEDEC"></a><a id="JJDBC28457"></a>
<div class="sect3">
<h4 class="sect3">Materializing Object Types not Specified in the Type Map</h4>
<p>If you do not provide a <a id="sthref510"></a>type map with an appropriate entry when using a <code>getObject</code> call, then the JDBC driver will materialize an Oracle object as an instance of the <code>oracle.sql.STRUCT</code> class. If the Oracle object type contains embedded objects and they are not present in the type map, then the driver will materialize the embedded objects as instances of <code>oracle.sql.STRUCT</code> as well. If the embedded objects are present in the type map, then a call to the <code><a id="sthref511"></a>getAttributes</code> method will return embedded objects as instances of the specified Java classes from the type map.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1060229"></a><a id="JJDBC28461"></a>
<div class="sect2">
<h3 class="sect2">Reading and Writing Data with a SQLData Implementation</h3>
<p>This section describes how to read data from an Oracle object or write data to an Oracle object if your corresponding Java class implements <code>SQLData</code>.</p>
<p class="subhead2"><a id="i1039737"></a><a id="JJDBC28462"></a>Reading SQLData Objects from a Result Set</p>
<p>The following text <a id="sthref512"></a><a id="sthref513"></a>summarizes the steps to read data from an Oracle object into your Java application when you choose the <code>SQLData</code> implementation for your custom object class.</p>
<p>These steps assume you have already defined the Oracle object type, created the corresponding custom object class, updated the type map to define the mapping between the Oracle object and the Java class, and defined a statement object <code>stmt</code>.</p>
<ol>
<li>
<p>Query the database to read the Oracle object into a JDBC result set.</p>
<pre>
ResultSet rs = stmt.executeQuery("SELECT emp_col FROM personnel");
</pre>
<p>The <code>PERSONNEL</code> table contains one column, <code>EMP_COL</code>, of SQL type <code>EMP_OBJECT</code>. This SQL type is defined in the type map to map to the Java class <code>Employee</code>.</p>
</li>
<li>
<p>Use the <code>getObject</code> method of your result set to populate an instance of your custom object class with data from one row of the result set. The <code>getObject</code> method returns the user-defined <code>SQLData</code> object because the type map contains an entry for <code>Employee</code>.</p>
<pre>
if (rs.next())
   Employee emp = (Employee)rs.getObject(1);
</pre>
<p>Note that if the type map did not have an entry for the object, then <code>getObject</code> would return an <code>oracle.sql.STRUCT</code> object. Cast the output to type <code>STRUCT</code>, because the <code>getObject</code> method signature returns the generic <code>java.lang.Object</code> type.</p>
<pre>
if (rs.next())
   STRUCT empstruct = (STRUCT)rs.getObject(1);
</pre>
<p>The <code>getObject</code> method calls <code>readSQL</code>, which, in turn, calls <code>read</code><code><span class="codeinlineitalic">XXX</span></code> from the <code>SQLData</code> interface.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you want to avoid using the defined type map, then use the <code>getSTRUCT</code> method. This method always returns a <code>STRUCT</code> object, even if there is a mapping entry in the type map.</div>
</li>
<li>
<p>If you have <code>get</code> methods in your custom object class, then use them to read data from your object attributes. For example, if <code>EMPLOYEE</code> has the attributes <code>EmpName</code> of type <code>CHAR</code> and <code>EmpNum</code> of type <code>NUMBER</code>, then provide a <code>getEmpName</code> method that returns a Java <code>String</code> and a <code>getEmpNum</code> method that returns an <code>int</code> value. Then call them in your Java application, as follows:</p>
<pre>
String empname = emp.getEmpName();
int empnumber = emp.getEmpNum();
 
</pre></li>
</ol>
<p class="subhead2"><a id="JJDBC28463"></a>Retrieving SQLData Objects from a Callable Statement OUT Parameter</p>
<p>Consider you have a <code>CallableStatement</code> instance, <code>cs</code>, that calls a PL/SQL function <code>GETEMPLOYEE</code>. The program passes an employee number to the function. The function returns the corresponding <code>Employee</code> object. To retrieve this object you do the following:</p>
<ol>
<li>
<p>Prepare a <code>CallableStatement</code> to call the <code>GETEMPLOYEE</code> function, as follows:</p>
<pre>
CallableStatement ocs = conn.prepareCall("{ ? = call GETEMPLOYEE(?) }");
</pre></li>
<li>
<p>Declare the <code>empnumber</code> as the input parameter to <code>GETEMPLOYEE</code>. Register the <code>SQLData</code> object as the <code>OUT</code> parameter, with the type code <code>OracleTypes.STRUCT</code>. Then, run the statement. This can be done as follows:</p>
<pre>
cs.setInt(2, empnumber); 
cs.registerOutParameter(1, OracleTypes.STRUCT, "EMP_OBJECT"); 
cs.execute(); 
</pre></li>
<li>
<p>Use the <code>getObject</code> method to retrieve the employee object.</p>
<pre>
Employee emp = (Employee)cs.getObject(1);
</pre>
<p>If there is no type map entry, then <code>getObject</code> would return a <code>java.sql.Struct</code> object.</p>
<pre>
Struct emp = cs.getObject(1);
</pre></li>
</ol>
<p class="subhead2"><a id="JJDBC28464"></a>Passing SQLData Objects to a Callable Statement as an IN Parameter</p>
<p>Suppose you have a PL/SQL function <code>addEmployee(?)</code> that takes an <code>Employee</code> object as an <code>IN</code> parameter and adds it to the <code>PERSONNEL</code> table. In this example, <code>emp</code> is a valid <code>Employee</code> object.</p>
<ol>
<li>
<p>Prepare an <code>CallableStatement</code> to call the <code>addEmployee(?)</code> function.</p>
<pre>
CallableStatement cs = 
  conn.prepareCall("{ call addEmployee(?) }");
</pre></li>
<li>
<p>Use <code>setObject</code> to pass the <code>emp</code> object as an <code>IN</code> parameter to the callable statement. Then, call the statement.</p>
<pre>
cs.setObject(1, emp); 
cs.execute();
</pre></li>
</ol>
<p class="subhead2"><a id="JJDBC28465"></a>Writing Data to an Oracle Object Using a SQLData Implementation</p>
<p>The <a id="sthref514"></a><a id="sthref515"></a>following text describes the steps in writing data to an Oracle object from your Java application when you choose the <code>SQLData</code> implementation for your custom object class.</p>
<p>This description assumes you have already defined the Oracle object type, created the corresponding Java class, and updated the type map to define the mapping between the Oracle object and the Java class.</p>
<ol>
<li>
<p>If you have <code>set</code> methods in your custom object class, then use them to write data from Java variables in your application to attributes of your Java data type object.</p>
<pre>
emp.setEmpName(empname);
emp.setEmpNum(empnumber);
</pre></li>
<li>
<p>Prepare a statement that updates an Oracle object in a row of a database table, as appropriate, using the data provided in your Java data type object.</p>
<pre>
PreparedStatement pstmt = conn.prepareStatement
                          ("INSERT INTO PERSONNEL VALUES (?)");
</pre></li>
<li>
<p>Use the <code>setObject</code> method of the prepared statement to bind your Java data type object to the prepared statement.</p>
<pre>
pstmt.setObject(1, emp);
</pre></li>
<li>
<p>Run the statement, which updates the database.</p>
<pre>
pstmt.executeUpdate();
</pre></li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1040531"></a><a id="JJDBC28466"></a>
<div class="sect2">
<h3 class="sect2">Understanding the ORAData Interface</h3>
<p>One of the choices in making an Oracle object and its attribute data available to Java applications is to create a custom object class that implements the <code><a id="sthref516"></a><a id="sthref517"></a><a id="sthref518"></a>oracle.sql.ORAData</code> and <code>oracle.sql.ORADataFactory</code> interfaces. The <code>ORAData</code> and <code>ORADataFactory</code> interfaces are supplied by Oracle and are not a part of the JDBC standard.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The JPublisher utility supports the generation of classes that implement the <code>ORAData</code> and <code>ORADataFactory</code> interfaces.</div>
<p class="subhead2"><a id="JJDBC28467"></a>Understanding ORAData Features</p>
<p>The <code>ORAData</code> interface has the following advantages:</p>
<ul>
<li>
<p>It supports Oracle extensions to the standard JDBC types.</p>
</li>
<li>
<p>It does not require a type map to specify the names of the Java custom classes you want to create.</p>
</li>
<li>
<p>It provides better performance. <code>ORAData</code> works directly with <code>Datum</code> types, the internal format the driver uses to hold Oracle objects.</p>
</li>
</ul>
<p>The <code>ORAData</code> and <code>ORADataFactory</code> interfaces do the following:</p>
<ul>
<li>
<p>The <code><a id="sthref519"></a>toDatum</code> method of the <code>ORAData</code> class transforms the data into an <code>oracle.sql.*</code> representation.</p>
</li>
<li>
<p><code>ORADataFactory</code> specifies a <code><a id="sthref520"></a>create</code> method equivalent to a constructor for your custom object class. It creates and returns an <code>ORAData</code> instance. The JDBC driver uses the <code>create</code> method to return an instance of the custom object class to your Java application or applet. It takes as input an <code>oracle.sql.Datum</code> object and an integer indicating the corresponding SQL type code as specified in the <code>OracleTypes</code> class.</p>
</li>
</ul>
<p><code>ORAData</code> and <code>ORADataFactory</code> have the following definitions:</p>
<pre>
public interface ORAData 
{ 
    Datum toDatum (OracleConnection <span class="italic">conn</span>) throws SQLException;
} 
 
public interface ORADataFactory 
{ 
    ORAData create (Datum <span class="italic">d</span>, int <span class="italic">sql_Type_Code</span>) throws SQLException; 
} 
</pre>
<p>Where <code><span class="codeinlineitalic">conn</span></code> represents the Connection object, <code><span class="codeinlineitalic">d</span></code> represents an object of type <code>oracle.sql.Datum</code> and <code><span class="codeinlineitalic">sql_Type_Code</span></code> represents the SQL type code of the <code>Datum</code> object.</p>
<p class="subhead2"><a id="JJDBC28468"></a>Retrieving and Inserting Object Data</p>
<p>The JDBC drivers provide the following methods to retrieve and insert object data as instances of <code>ORAData</code>.</p>
<p>You can retrieve the object data in one of the following ways:</p>
<ul>
<li>
<p>Use the following <code><a id="sthref521"></a>getORAData</code> method of the Oracle-specific <code>OracleResultSet</code> class:</p>
<pre>
ors.getORAData (int <span class="italic">col_index</span>, ORADataFactory <span class="italic">factory</span>);
</pre>
<p>This method takes as input the column index of the data in your result set and a <code>ORADataFactory</code> instance. For example, you can implement a <code>getORAFactory</code> method in your custom object class to produce the <code>ORADataFactory</code> instance to input to <code>getORAData</code>. The type map is not required when using Java classes that implement <code>ORAData</code>.</p>
</li>
<li>
<p>Use the standard <a id="sthref522"></a><code>getObject(</code><code><span class="codeinlineitalic">index</span></code><code>,</code> <code><span class="codeinlineitalic">map</span></code><code>)</code> method specified by the <code>ResultSet</code> interface to retrieve data as instances of <code>ORAData</code>. In this case, you must have an entry in the type map that identifies the factory class to be used for the given object type and its corresponding SQL type name.</p>
</li>
</ul>
<p>You can insert object data in one of the following ways:</p>
<ul>
<li>
<p>Use the following <code><a id="sthref523"></a>setORAData</code> method of the Oracle-specific <code>OraclePreparedStatement</code> class:</p>
<pre>
ops.setORAData (int <span class="italic">bind_index</span>, ORAData <span class="italic">custom_obj</span>);
</pre>
<p>This method takes as input the parameter index of the bind variable and the name of the object containing the variable.</p>
</li>
<li>
<p>Use the standard <code><a id="sthref524"></a>setObject</code> method specified by the <code>PreparedStatement</code> interface. You can also use this method, in its different forms, to insert <code>ORAData</code> instances without requiring a type map.</p>
</li>
</ul>
<p>The following sections describe the <code>getORAData</code> and <code>setORAData</code> methods.</p>
<p>To continue the example of an Oracle object <code>EMPLOYEE</code>, you might have something like the following in your Java application:</p>
<pre>
ORAData datum = ors.getORAData(1, Employee.getORAFactory());
</pre>
<p>In this example, <code>ors</code> is an Oracle result set, <code>getORAData</code> is a method in the <code>OracleResultSet</code> class used to retrieve a <code>ORAData</code> object, and the <code>EMPLOYEE</code> is in column 1 of the result set. The <code>static</code> <code>Employee.getORAFactory</code> method will return a <code>ORADataFactory</code> to the JDBC driver. The JDBC driver will call <code>create(</code>) from this object, returning to your Java application an instance of the <code>Employee</code> class populated with data from the result set.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p><code>ORAData</code> and <code>ORADataFactory</code> are defined as separate interfaces so that different Java classes can implement them if you wish.</p>
</li>
<li>
<p>To use the <code>ORAData</code> interface, your custom object classes must import <code>oracle.sql.*</code>.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1060230"></a><a id="JJDBC28469"></a>
<div class="sect2">
<h3 class="sect2">Reading and Writing Data with a ORAData Implementation</h3>
<p>This section describes how to read data from an Oracle object or write data to an Oracle object if your corresponding Java class implements <code>ORAData</code>.</p>
<p class="subhead2"><a id="i1039910"></a><a id="JJDBC28470"></a>Reading Data from an Oracle Object Using a ORAData Implementation</p>
<p>The following text <a id="sthref525"></a>summarizes the steps in reading data from an Oracle object into your Java application. These steps apply whether you implement <code>ORAData</code> manually or use JPublisher to produce your custom object classes.</p>
<p>These steps assume you have already defined the Oracle object type, created the corresponding custom object class or had JPublisher create it for you, and defined a statement object <code>stmt</code>.</p>
<ol>
<li>
<p>Query the database to read the Oracle object into a result set, casting it to an Oracle result set.</p>
<pre>
OracleResultSet ors = (OracleResultSet)stmt.executeQuery
                      ("SELECT Emp_col FROM PERSONNEL");
</pre>
<p>Where <code>PERSONNEL</code> is a one-column table. The column name is <code>Emp_col</code> of type <code>Employee_object</code>.</p>
</li>
<li>
<p>Use the <code><a id="sthref526"></a>getORAData</code> method of your Oracle result set to populate an instance of your custom object class with data from one row of the result set. The <code>getORAData</code> method returns an <code>oracle.sql.ORAData</code> object, which you can cast to your specific custom object class.</p>
<pre>
if (ors.next())
   Employee emp = (Employee)ors.getORAData(1, Employee.getORAFactory());
</pre>
<p>or:</p>
<pre>
if (ors.next())
   ORAData datum = ors.getORAData(1, Employee.getORAFactory());
</pre>
<p>This example assumes that <code>Employee</code> is the name of your custom object class and <code>ors</code> is the name of your <code>OracleResultSet</code> object.</p>
<p>In case you do not want to use <code>getORAData</code>, the JDBC drivers let you use the <code><a id="sthref527"></a>getObject</code> method of a standard JDBC <code>ResultSet</code> to retrieve <code>ORAData</code> data. However, you must have an entry in the type map that identifies the factory class to be used for the given object type and its corresponding SQL type name.</p>
<p>For example, if the SQL type name for your object is <code>EMPLOYEE</code>, then the corresponding Java class is <code>Employee</code>, which will implement <code>ORAData</code>. The corresponding Factory class is <code>EmployeeFactory</code>, which will implement <code>ORADataFactory</code>.</p>
<p>Use this statement to declare the <code>EmployeeFactory</code> entry for your type map:</p>
<pre>
map.put ("EMPLOYEE", Class.forName ("EmployeeFactory")); 
</pre>
<p>Then use the form of <code>getObject</code> where you specify the map object:</p>
<pre>
Employee emp = (Employee) rs.getObject (1, map);
</pre>
<p>If the default type map of the connection already has an entry that identifies the factory class to be used for the given object type and its corresponding SQL type name, then you can use this form of <code>getObject</code>:</p>
<pre>
Employee emp = (Employee) rs.getObject (1); 
</pre></li>
<li>
<p>If you have <code>get</code> methods in your custom object class, then use them to read data from your object attributes into Java variables in your application. For example, if <code>EMPLOYEE</code> has <code>EmpName</code> of type <code>CHAR</code> and <code>EmpNum</code> of type <code>NUMBER</code>, provide a <code>getEmpName</code> method that returns a Java <code>String</code> and a <code>getEmpNum</code> method that returns an integer. Then call them in your Java application as follows:</p>
<pre>
String empname = emp.getEmpName();
int empnumber = emp.getEmpNum();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Alternatively, you can fetch data using a callable statement object. The <code>OracleCallableStatement</code> class also has a <code>getORAData</code> method.</div>
</li>
</ol>
<p class="subhead2"><a id="JJDBC28471"></a>Writing Data to an Oracle Object Using a ORAData Implementation</p>
<p>The following text <a id="sthref528"></a>summarizes the steps in writing data to an Oracle object from your Java application. These steps apply whether you implement <code>ORAData</code> manually or use <a id="sthref529"></a>JPublisher to produce your custom object classes.</p>
<p>These steps assume you have already defined the Oracle object type and created the corresponding custom object class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The type map is not used when you are performing database <code>INSERT</code> and <code>UPDATE</code> operations.</div>
<ol>
<li>
<p>If you have <code>set</code> methods in your custom object class, then use them to write data from Java variables in your application to attributes of your Java data type object.</p>
<pre>
emp.setEmpName(empname);
emp.setEmpNum(empnumber);
</pre></li>
<li>
<p>Write an Oracle prepared statement that updates an Oracle object in a row of a database table, as appropriate, using the data provided in your Java data type object.</p>
<pre>
OraclePreparedStatement opstmt = conn.prepareStatement
   ("UPDATE PERSONNEL SET Employee = ? WHERE Employee.EmpNum = 28959);
</pre>
<p>This assumes <code>conn</code> is your <code>Connection</code> object.</p>
</li>
<li>
<p>Use the <code><a id="sthref530"></a>setORAData</code> method of the Oracle prepared statement to bind your Java data type object to the prepared statement.</p>
<pre>
opstmt.setORAData(1, emp);
</pre>
<p>The <code>setORAData</code> method calls the <code><a id="sthref531"></a>toDatum</code> method of the custom object class instance to retrieve an <code>oracle.sql.STRUCT</code> object that can be written to the database.</p>
<p>In this step you could also use the <code><a id="sthref532"></a>setObject</code> method to bind the Java data type. For example:</p>
<pre>
opstmt.setObject(1,emp);
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can use your Java data type objects as either <code>IN</code> or <code>OUT</code> bind variables.</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="BABDDEAE"></a><a id="JJDBC28472"></a>
<div class="sect2">
<h3 class="sect2">Addition<a id="sthref533"></a>al Uses for ORAData</h3>
<p>The <code>ORAData</code> interface offers far more flexibility than the <code>SQLData</code> interface. The <code>SQLData</code> interface is designed to let you customize the mapping of only Oracle object types to Java types of your choice. Implementing the <code>SQLData</code> interface lets the JDBC driver populate fields of a custom Java class instance from the original SQL object data, and the reverse, after performing the appropriate conversions between Java and SQL types.</p>
<p>The <code>ORAData</code> interface goes beyond supporting the customization of Oracle object types to Java types. It lets you provide a mapping between Java object types and <span class="italic">any</span> SQL type supported by the <code>oracle.sql</code> package.</p>
<p>It may be useful to provide custom Java classes to wrap <code>oracle.sql.*</code> types and perhaps implement customized conversions or functionality as well. The following are some possible scenarios:</p>
<ul>
<li>
<p>Performing encryption and decryption or validation of data</p>
</li>
<li>
<p>Performing logging of values that have been read or are being written</p>
</li>
<li>
<p>Parsing character columns, such as character fields containing URL information, into smaller components</p>
</li>
<li>
<p>Mapping character strings into numeric constants</p>
</li>
<li>
<p>Making data into more desirable Java formats, such as mapping a <code>DATE</code> field to <code>java.util.Date</code> format</p>
</li>
<li>
<p>Customizing data representation, for example, data in a table column is in feet but you want it represented in meters after it is selected</p>
</li>
<li>
<p>Serializing and deserializing Java objects</p>
</li>
</ul>
<p>For example, use <code>ORAData</code> to store instances of Java objects that do not correspond to a particular SQL object type in the database in columns of SQL type <code>RAW</code>. The <code>create</code> method in <code>ORADataFactory</code> would have to implement a conversion from an object of type <code>oracle.sql.RAW</code> to the desired Java object. The <code>toDatum</code> method in <code>ORAData</code> would have to implement a conversion from the Java object to an <code>oracle.sql.RAW</code> object. This can be done, for example, by using Java serialization.</p>
<p>Upon retrieval, the JDBC driver transparently retrieves the raw bytes of data in the form of an <code>oracle.sql.RAW</code> and calls the <code>create</code> method of <code>ORADataFactory</code> to convert the <code>oracle.sql.RAW</code> object to the desired Java class.</p>
<p>When you insert the Java object into the database, you can simply bind it to a column of type <code>RAW</code> to store it. The driver transparently calls the <code>ORAData</code>.<code>toDatum</code> method to convert the Java object to an <code>oracle.sql.RAW</code> object. This object is then stored in a column of type <code>RAW</code> in the database.</p>
<p>Support for the <code>ORAData</code> interfaces is also highly efficient because the conversions are designed to work using <code>oracle.sql.*</code> formats, which happen to be the internal formats used by the JDBC drivers. Moreover, the type map, which is necessary for the <code>SQLData</code> interface, is not required when using Java classes that implement <code>ORAData</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1040531">"Understanding the ORAData Interface"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1078205"></a><a id="JJDBC28474"></a>
<div class="sect1">
<h2 class="sect1">Object-Type Inheritance</h2>
<p>Object-type inheritance allows a new object type to be created by extending another object type. The new object type is then a subtype of the object type from which it extends. The subtype automatically inherits all the attributes and methods defined in the supertype. The subtype can add attributes and methods and overload or override methods inherited from the supertype.</p>
<p>Object-type inheritance introduces <span class="bold">substitutability</span>. Substitutability is the ability of a slot declared to hold a value of type <code>T</code> in addition to any subtype of type <code>T</code>. Oracle JDBC drivers handle substitutability transparently.</p>
<p>A database object is returned with its most specific type without losing information. For example, if the <code>STUDENT_T</code> object is stored in a <code>PERSON_T</code> slot, Oracle JDBC driver returns a Java object that represents the <code>STUDENT_T</code> object.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABCCDAB">Creating Subtypes</a></p>
</li>
<li>
<p><a href="#BABIIFFB">Implementing Customized Classes for Subtypes</a></p>
</li>
<li>
<p><a href="#BABCHFGG">Retrieving Subtype Objects</a></p>
</li>
<li>
<p><a href="#BABCEDCF">Creating Subtype Objects</a></p>
</li>
<li>
<p><a href="#BABEHFIH">Sending Subtype Objects</a></p>
</li>
<li>
<p><a href="#BABEJJEB">Accessing Subtype Data Fields</a></p>
</li>
<li>
<p><a href="#BABEJJJC">Inheritance Metadata Methods</a></p>
</li>
</ul>
<a id="BABCCDAB"></a><a id="JJDBC28475"></a>
<div class="sect2">
<h3 class="sect2">Creating Subtypes</h3>
<p>Create custom object classes if you want to have Java classes that explicitly correspond to the Oracle object types. If you have a hierarchy of object types, you may want a corresponding hierarchy of Java classes.</p>
<p>The most common way to create a database subtype in JDBC is to run a SQL <code><a id="sthref534"></a>CREATE TYPE</code> command using the <code>execute</code> method of the <code>java.sql.Statement</code> interface. For example, you want to create a type inheritance hierarchy as depicted in the following diagram:</p>
<img width="163" height="187" src="img/hierarchy.gif" alt="Type inheritance hierarchy diagram" title="Type inheritance hierarchy diagram" /><br />
<a id="sthref535" href="img_text/hierarchy.htm">Description of the illustration hierarchy.gif</a><br />
<br />
<p>The JDBC code for this can be as follows:</p>
<pre>
Statement s = conn.createStatement();
s.execute ("CREATE TYPE Person_T (SSN NUMBER, name VARCHAR2(30),
  address VARCHAR2(255))");
s.execute ("CREATE TYPE Student_T UNDER Person_t (deptid NUMBER,
  major VARCHAR2(100))");
s.execute ("CREATE TYPE PartTimeStudent_t UNDER Student_t (numHours NUMBER)");
</pre>
<p>In the following code, the <code>foo</code> member procedure in type <code>ST</code> is overloaded and the member procedure <code>print</code> overwrites the copy it inherits from type <code>T</code>.</p>
<pre>
CREATE TYPE T AS OBJECT (..., 
  MEMBER PROCEDURE foo(x NUMBER), 
  MEMBER PROCEDURE Print(), 
  ... 
  NOT FINAL; 

CREATE TYPE ST UNDER T (..., 
  MEMBER PROCEDURE foo(x DATE),         &lt;-- overload "foo" 
  OVERRIDING MEMBER PROCEDURE Print(),   &lt;-- override "print" 
  STATIC FUNCTION bar(...) ... 
  ... 
  );
</pre>
<p>Once the subtypes have been created, they can be used as both columns of a base table as well as attributes of a object type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ" href="../../appdev.112/e11822/toc.htm"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a></div>
</div>
<!-- class="sect2" -->
<a id="BABIIFFB"></a><a id="JJDBC28476"></a>
<div class="sect2">
<h3 class="sect2">Implementing Customized Classes for Subtypes</h3>
<p>In most cases, a customized Java class represents a database object type. When you create a customized Java class for a subtype, the Java class can either mirror the database object type hierarchy or not.</p>
<p>You can use either the <code>ORAData</code> or <code>SQLData</code> solution in creating classes to map to the hierarchy of object types.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1076588">Use of ORAData for Type Inheritance Hierarchy</a></p>
</li>
<li>
<p><a href="#BABEFIHJ">Use of SQLData for Type Inheritance Hierarchy</a></p>
</li>
<li>
<p><a href="#BABEHFAI">JPublisher Utility</a></p>
</li>
</ul>
<a id="i1076588"></a><a id="JJDBC28477"></a>
<div class="sect3">
<h4 class="sect3">Use of ORAData for Type Inheritance Hierarchy</h4>
<p>Oracle recommends customized mappings, where Java classes implement the <code>oracle.sql.ORAData</code> interface. <code>ORAData</code> mapping requires the JDBC application to implement the <code>ORAData</code> and <code>ORADataFactory</code> interfaces. The class implementing the <code>ORADataFactory</code> interface contains a factory method that produces objects. Each object represents a database object.</p>
<p>The hierarchy of the class implementing the <code>ORAData</code> interface can mirror the database object type hierarchy. For example, the Java classes mapping to <code>PERSON_T</code> and <code>STUDENT_T</code> are as follows:</p>
<p class="subhead2"><a id="JJDBC28478"></a>Person.java using ORAData</p>
<p>Code for the <code>Person.java</code> class which implements the <code>ORAData</code> and <code>ORADataFactory</code> interfaces:</p>
<pre>
class Person implements ORAData, ORADataFactory 
{ 
  static final Person _personFactory = new Person(); 

  public NUMBER ssn; 
  public CHAR name; 
  public CHAR address; 

  public static ORADataFactory getORADataFactory() 
  { 
    return _personFactory; 
  } 

  public Person () {} 

  public Person(NUMBER ssn, CHAR name, CHAR address) 
  { 
    this.ssn = ssn; 
    this.name = name; 
    this.address = address; 
  } 

  public Datum toDatum(OracleConnection c) throws SQLException 
  { 
    StructDescriptor sd =
      StructDescriptor.createDescriptor("SCOTT.PERSON_T", c); 
    Object [] attributes = { ssn, name, address }; 
    return new STRUCT(sd, c, attributes); 
  } 

  public ORAData create(Datum d, int sqlType) throws SQLException 
  { 
    if (d == null) return null; 
    Object [] attributes = ((STRUCT) d).getOracleAttributes(); 
    return new Person((NUMBER) attributes[0], 
                      (CHAR) attributes[1], 
                      (CHAR) attributes[2]); 
  } 
}
</pre>
<p class="subhead2"><a id="JJDBC28479"></a>Student.java extending Person.java</p>
<p>Code for the <code>Student.java</code> class, which extends the <code>Person.java</code> class:</p>
<pre>
class Student extends Person 
{ 
  static final Student _studentFactory = new Student (); 

  public NUMBER deptid; 
  public CHAR major; 

  public static ORADataFactory getORADataFactory() 
  { 
    return _studentFactory; 
  } 

  public Student () {} 

  public Student (NUMBER ssn, CHAR name, CHAR address, 
                  NUMBER deptid, CHAR major) 
  { 
    super (ssn, name, address); 
    this.deptid = deptid; 
    this.major = major; 
  } 

  public Datum toDatum(OracleConnection c) throws SQLException 
  { 
    StructDescriptor sd = 
      StructDescriptor.createDescriptor("SCOTT.STUDENT_T", c); 
    Object [] attributes = { ssn, name, address, deptid, major }; 
    return new STRUCT(sd, c, attributes); 
  } 

  public CustomDatum create(Datum d, int sqlType) throws SQLException 
  { 
    if (d == null) return null; 
    Object [] attributes = ((STRUCT) d).getOracleAttributes(); 
    return new Student((NUMBER) attributes[0], 
                       (CHAR) attributes[1], 
                       (CHAR) attributes[2], 
                       (NUMBER) attributes[3], 
                       (CHAR) attributes[4]); 
  } 
}
</pre>
<p>Customized classes that implement the <code>ORAData</code> interface do not have to mirror the database object type hierarchy. For example, you could have declared the <code>Student</code> class without a superclass. In this case, <code>Student</code> would contain fields to hold the inherited attributes from <code>PERSON_T</code> as well as the attributes declared by <code>STUDENT_T</code>.</p>
<p class="subhead2"><a id="JJDBC28480"></a>ORADataFactory Implementation</p>
<p>The JDBC application uses the factory class in querying the database to return instances of <code>Person</code> or its subclasses, as in the following example:</p>
<pre>
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  Object s = rset.getORAData (1, PersonFactory.getORADataFactory()); 
  ... 
} 
</pre>
<p>A class implementing the <code>ORADataFactory</code> interface should be able to produce instances of the associated custom object type, as well as instances of any subtype, or at least all the types you expect to support.</p>
<p>In the following example, the <code>PersonFactory.getORADataFactory</code> method returns a factory that can handle <code>PERSON_T</code>, <code>STUDENT_T</code>, and <code>PARTTIMESTUDENT_T</code> objects, by returning <code>person</code>, <code>student</code>, or <code>parttimestudent</code> Java instances.</p>
<pre>
class PersonFactory implements ORADataFactory 
{ 
  static final PersonFactory _factory = new PersonFactory (); 

  public static ORADataFactory getORADataFactory() 
  { 
    return _factory; 
  } 

  public ORAData create(Datum d, int sqlType) throws SQLException 
  { 
    STRUCT s = (STRUCT) d; 
    if (s.getSQLTypeName ().equals ("SCOTT.PERSON_T")) 
      return Person.getORADataFactory ().create (d, sqlType); 
    else if (s.getSQLTypeName ().equals ("SCOTT.STUDENT_T")) 
      return Student.getORADataFactory ().create(d, sqlType); 
    else if (s.getSQLTypeName ().equals ("SCOTT.PARTTIMESTUDENT_T")) 
      return ParttimeStudent.getORADataFactory ().create(d, sqlType); 
    else 
      return null; 
  } 
}
</pre>
<p>The following example assumes a table <code>tabl1</code>, such as the following:</p>
<pre>
CREATE TABLE tabl1 (idx NUMBER, person PERSON_T); 
INSERT INTO tabl1 VALUES (1, PERSON_T (1000, 'Scott', '100 Oracle Parkway')); 
INSERT INTO tabl1 VALUES (2, STUDENT_T (1001, 'Peter', '200 Oracle Parkway', 101, 'CS')); 
INSERT INTO tabl1 VALUES (3, PARTTIMESTUDENT_T (1002, 'David', '300 Oracle Parkway', 102, 'EE')); 
</pre></div>
<!-- class="sect3" -->
<a id="BABEFIHJ"></a><a id="JJDBC28481"></a>
<div class="sect3">
<h4 class="sect3">Use of SQLData for Type Inheritance Hierarchy</h4>
<p>The customized classes that implement the <code>java.sql.SQLData</code> interface can mirror the database object type hierarchy. The <code>readSQL</code> and <code>writeSQL</code> methods of a subclass typically call the corresponding superclass methods to read or write the superclass attributes before reading or writing the subclass attributes. For example, the Java classes mapping to <code>PERSON_T</code> and <code>STUDENT_T</code> are as follows:</p>
<p class="subhead2"><a id="JJDBC28482"></a>Person.java using SQLData</p>
<p>Code for the <code>Person.java</code> class, which implements the <code>SQLData</code> interface:</p>
<pre>
import java.sql.*; 

public class Person implements SQLData 
{ 
  private String sql_type; 
  public int ssn; 
  public String name; 
  public String address; 

  public Person () {} 

  public String getSQLTypeName() throws SQLException { return sql_type; } 

  public void readSQL(SQLInput stream, String typeName) throws SQLException 
  { 
    sql_type = typeName; 
    ssn = stream.readInt(); 
    name = stream.readString(); 
    address = stream.readString(); 
  } 

  public void writeSQL(SQLOutput stream) throws SQLException 
  { 
    stream.writeInt (ssn); 
    stream.writeString (name); 
    stream.writeString (address); 
  } 
}
</pre>
<p class="subhead2"><a id="JJDBC28483"></a>Student.java extending Student.java</p>
<p>Code for the <code>Student.java</code> class, which extends the <code>Person.java</code> class:</p>
<pre>
import java.sql.*; 

public class Student extends Person 
{ 
  private String sql_type; 
  public int deptid; 
  public String major; 

  public Student () { super(); } 

  public String getSQLTypeName() throws SQLException { return sql_type; } 

  public void readSQL(SQLInput stream, String typeName) throws SQLException 
  { 
    super.readSQL (stream, typeName);    // read supertype attributes 
    sql_type = typeName;
    deptid = stream.readInt(); 
    major = stream.readString(); 
  } 

  public void writeSQL(SQLOutput stream) throws SQLException 
  { 
    super.writeSQL (stream);        // write supertype
                                         // attributes 
    stream.writeInt (deptid); 
    stream.writeString (major); 
  } 
}
</pre>
<p>Although not required, it is recommended that the customized classes, which implement the <code>SQLData</code> interface, mirror the database object type hierarchy. For example, you could have declared the <code>Student</code> class without a superclass. In this case, <code>Student</code> would contain fields to hold the inherited attributes from <code>PERSON_T</code> as well as the attributes declared by <code>STUDENT_T</code>.</p>
<p class="subhead2"><a id="JJDBC28484"></a>Student.java using SQLData</p>
<p>Code for the <code>Student.java</code> class, which does not extend the <code>Person.java</code> class, but implements the SQLData interface directly:</p>
<pre>
import java.sql.*; 

public class Student implements SQLData 
{ 
  private String sql_type; 

  public int ssn; 
  public String name; 
  public String address; 
  public int deptid; 
  public String major; 

  public Student () {} 

  public String getSQLTypeName() throws SQLException { return sql_type; } 

  public void readSQL(SQLInput stream, String typeName) throws SQLException 
  { 
    sql_type = typeName; 
    ssn = stream.readInt(); 
    name = stream.readString(); 
    address = stream.readString(); 
    deptid = stream.readInt(); 
    major = stream.readString(); 
  } 

  public void writeSQL(SQLOutput stream) throws SQLException 
  { 
    stream.writeInt (ssn); 
    stream.writeString (name); 
    stream.writeString (address); 
    stream.writeInt (deptid); 
    stream.writeString (major); 
  } 
}
</pre></div>
<!-- class="sect3" -->
<a id="BABEHFAI"></a><a id="JJDBC28485"></a>
<div class="sect3">
<h4 class="sect3">JPublisher Utility</h4>
<p>Even though you can manually create customized classes that implement the <code>SQLData</code>, <code>ORAData</code>, and <code>ORADataFactory</code> interfaces, it is recommended that you use Oracle JPublisher to automatically generate these classes. The customized classes generated <a id="sthref536"></a>by Oracle JPublisher that implement the <code>SQLData</code>, <code>ORAData</code>, and <code>ORADataFactory</code> interfaces, can mirror the inheritance hierarchy.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1078761">"Using JPublisher to Create Custom Object Classes"</a></p>
</li>
<li>
<p><a class="olink JJPUB" href="../e10587/toc.htm"><span class="italic">Oracle Database JPublisher User's Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABCHFGG"></a><a id="JJDBC28486"></a>
<div class="sect2">
<h3 class="sect2">Retrieving Subtype Objects</h3>
<p>In a typical JDBC application, a subtype object is returned as one of the following:</p>
<ul>
<li>
<p>A query result</p>
</li>
<li>
<p>A PL/SQL <code>OUT</code> parameter</p>
</li>
<li>
<p>A type attribute</p>
</li>
</ul>
<p>You can use either the default mapping or the <code>SQLData</code> mapping or the <code>ORAData</code> mapping to retrieve a subtype.</p>
<p class="subhead2"><a id="JJDBC28487"></a>Using Default Mapping</p>
<p>By default, a database object is returned as an instance of the <code>oracle.sql.STRUCT</code> class. This instance may represent an object of either the declared type or subtype of the declared type. If the <code>STRUCT</code> class represents a subtype object in the database, then it contains the attributes of its supertype as well as those defined in the subtype.</p>
<p>Oracle JDBC driver returns database objects in their most specific type. The JDBC application can use the <code>getSQLTypeName</code> method of the <code>STRUCT</code> class to determine the SQL type of the <code>STRUCT</code> object. The following code shows this:</p>
<pre>
// tab1.person column can store PERSON_T, STUDENT_T and PARTIMESTUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  oracle.sql.STRUCT s = (oracle.sql.STRUCT) rset.getObject(1); 
  if (s != null) 
    System.out.println (s.getSQLTypeName());    // print out the type name which 
    // may be SCOTT.PERSON_T, SCOTT.STUDENT_T or SCOTT.PARTTIMESTUDENT_T
}
</pre>
<p class="subhead2"><a id="JJDBC28488"></a>Using SQLData Mapping</p>
<p>With <code>SQLData</code> mapping, the JDBC driver returns the database object as an instance of the class implementing the <code>SQLData</code> interface.</p>
<p>To use <code>SQLData</code> mapping in retrieving database objects, do the following:</p>
<ol>
<li>
<p>Implement the container classes that implement the <code>SQLData</code> interface for the desired object types.</p>
</li>
<li>
<p>Populate the connection type map with entries that specify what custom Java type corresponds to each Oracle object type.</p>
</li>
<li>
<p>Use the <code>getObject</code> method to access the SQL object values.</p>
<p>The JDBC driver checks the type map for an entry match. If one exists, then the driver returns the database object as an instance of the class implementing the <code>SQLData</code> interface.</p>
</li>
</ol>
<p>The following code shows the whole SQLData customized mapping process:</p>
<pre>
// The JDBC application developer implements Person.java for PERSON_T, 
// Student.java for STUDENT_T 
// and ParttimeStudent.java for PARTTIMESTUDEN_T. 

Connection conn = ...;  // make a JDBC connection 

// obtains the connection typemap 
java.util.Map map = conn.getTypeMap (); 

// populate the type map 
map.put ("SCOTT.PERSON_T", Class.forName ("Person")); 
map.put ("SCOTT.STUDENT_T", Class.forName ("Student")); 
map.put ("SCOTT.PARTTIMESTUDENT_T", Class.forName ("ParttimeStudent")); 

// tab1.person column can store PERSON_T, STUDENT_T and PARTTIMESTUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  // "s" is instance of Person, Student or ParttimeStudent 
  Object s = rset.getObject(1); 

  if (s != null) 
  { 
    if (s instanceof Person) 
      System.out.println ("This is a Person"); 
    else if (s instanceof Student) 
      System.out.println ("This is a Student"); 
    else if (s instanceof ParttimeStudent) 
      System.out.pritnln ("This is a PartimeStudent"); 
    else 
      System.out.println ("Unknown type"); 
  } 
}
</pre>
<p>The JDBC drivers check the connection type map for each call to the following:</p>
<ul>
<li>
<p><code>getObject</code> method of the <code>java.sql.ResultSet</code> and <code>java.sql.CallableStatement</code> interfaces</p>
</li>
<li>
<p><code>getAttribute</code> method of the <code>java.sql.Struct</code> interface</p>
</li>
<li>
<p><code>getArray</code> method of the <code>java.sql.Array</code> interface</p>
</li>
<li>
<p><code>getValue</code> method of the <code>oracle.sql.REF</code> interface</p>
</li>
</ul>
<p class="subhead2"><a id="i1076595"></a><a id="JJDBC28489"></a>Using ORAData Mapping</p>
<p>With <code>ORAData</code> mapping, the JDBC driver returns the database object as an instance of the class implementing the <code>ORAData</code> interface.</p>
<p>Oracle JDBC driver needs to be informed of what Java class is mapped to the Oracle object type. The following are the two ways to inform Oracle JDBC drivers:</p>
<ul>
<li>
<p>The JDBC application uses the <code>getORAData(int idx, ORADataFactory f)</code> method to access database objects. The second parameter of the <code>getORAData</code> method specifies an instance of the factory class that produces the customized class. The <code>getORAData</code> method is available in the <code>OracleResultSet</code> and <code>OracleCallableStatement</code> classes.</p>
</li>
<li>
<p>The JDBC application populates the connection type map with entries that specify what custom Java type corresponds to each Oracle object type. The <code>getObject</code> method is used to access the Oracle object values.</p>
</li>
</ul>
<p>The second approach involves the use of the standard <code>getObject</code> method. The following code example demonstrates the first approach:</p>
<pre>
// tab1.person column can store both PERSON_T and STUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  Object s = rset.getORAData (1, PersonFactory.getORADataFactory()); 
  if (s != null) 
  { 
    if (s instanceof Person) 
      System.out.println ("This is a Person"); 
    else if (s instanceof Student) 
      System.out.println ("This is a Student"); 
    else if (s instanceof ParttimeStudent) 
      System.out.pritnln ("This is a PartimeStudent"); 
    else 
      System.out.println ("Unknown type"); 
  } 
}
</pre></div>
<!-- class="sect2" -->
<a id="BABCEDCF"></a><a id="JJDBC28490"></a>
<div class="sect2">
<h3 class="sect2">Creating Subtype Objects</h3>
<p>There are cases where JDBC applications create database subtype objects with JDBC drivers. These objects are sent either to the database as bind variables or are used to exchange information within the JDBC application.</p>
<p>With customized mapping, the JDBC application creates either <code>SQLData</code>- or <code>ORAData</code>-based objects, depending on the approach you choose, to represent database subtype objects. With default mapping, the JDBC application creates <code>STRUCT</code> objects to represent database subtype objects. All the data fields inherited from the supertype as well as all the fields defined in the subtype must have values. The following code demonstrates this:</p>
<pre>
Connection conn = ...   // make a JDBC connection 
StructDescriptor desc = StructDescriptor.createDescriptor ("SCOTT.PARTTIMESTUDENT", conn); 
Object[] attrs = { 
  new Integer(1234), "Scott", "500 Oracle Parkway", // data fields defined in
                                                    // PERSON_T 
  new Integer(102), "CS",                           // data fields defined in
                                                    // STUDENT_T 
  new Integer(4)                                    // data fields defined in
                                                    // PARTTIMESTUDENT_T 
}; 
STRUCT s = new STRUCT (desc, conn, attrs);
</pre>
<p><code>s</code> is initialized with data fields inherited from <code>PERSON_T</code> and <code>STUDENT_T</code>, and data fields defined in <code>PARTTIMESTUDENT_T</code>.</p>
</div>
<!-- class="sect2" -->
<a id="BABEHFIH"></a><a id="JJDBC28491"></a>
<div class="sect2">
<h3 class="sect2">Sending Subtype Objects</h3>
<p>In a typical JDBC application, a Java object that represents a database object is sent to the databases as one of the following:</p>
<ul>
<li>
<p>A data manipulation language (DML) bind variable</p>
</li>
<li>
<p>A PL/SQL <code>IN</code> parameter</p>
</li>
<li>
<p>An object type attribute value</p>
</li>
</ul>
<p>The Java object can be an instance of the <code>STRUCT</code> class or an instance of the class implementing either the <code>SQLData</code> or <code>ORAData</code> interface. Oracle JDBC driver will convert the Java object into the linearized format acceptable to the database SQL engine. Binding a subtype object is the same as binding a standard object.</p>
</div>
<!-- class="sect2" -->
<a id="BABEJJEB"></a><a id="JJDBC28492"></a>
<div class="sect2">
<h3 class="sect2">Accessing Subtype Data Fields</h3>
<p>While the logic to access subtype data fields is part of the customized class, this logic for default mapping is defined in the JDBC application itself. The database objects are returned as instances of the <code>oracle.sql.STRUCT</code> class. The JDBC application needs to call one of the following access methods in the <code>STRUCT</code> class to access the data fields:</p>
<ul>
<li>
<p><code>Object[] getAttribute()</code></p>
</li>
<li>
<p><code>oracle.sql.Datum[] getOracleAttribute()</code></p>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28493"></a>Subtype Data Fields from the getAttribute Method</p>
<p>The <code>getAttribute</code> method of the <code>java.sql.Struct</code> interface is used in JDBC 2.0 to access object data fields. This method returns a <code>java.lang.Object</code> array, where each array element represents an object attribute. You can determine the individual element type by referencing the corresponding attribute type in the JDBC conversion matrix. For example, a SQL <code>NUMBER</code> attribute is converted to a <code>java.math.BigDecimal</code> object. The <code>getAttribute</code> method returns all the data fields defined in the supertype of the object type as well as data fields defined in the subtype. The supertype data fields are listed first followed by the subtype data fields.</p>
<p class="subhead2"><a id="JJDBC28494"></a>Subtype Data Fields from the getOracleAttribute Method</p>
<p>The <code>getOracleAttribute</code> method is an Oracle extension method and is more efficient than the <code>getAttribute</code> method. The <code>getOracleAttribute</code> method returns an <code>oracle.sql.Datum</code> array to hold the data fields. Each element in the <code>oracle.sql.Datum</code> array represents an attribute. You can determine the individual element type by referencing the corresponding attribute type in the Oracle conversion matrix. For example, a SQL <code>NUMBER</code> attribute is converted to an <code>oracle.sql.NUMBER</code> object. The <code>getOracleAttribute</code> method returns all the attributes defined in the supertype of the object type, as well as attributes defined in the subtype. The supertype data fields are listed first followed by the subtype data fields.</p>
<p>The following code shows the use of the <code>getAttribute</code> method:</p>
<pre>
// tab1.person column can store PERSON_T, STUDENT_T and PARTIMESTUDENT_T objects 
ResultSet rset = stmt.executeQuery ("select person from tab1"); 
while (rset.next()) 
{ 
  oracle.sql.STRUCT s = (oracle.sql.STRUCT) rset.getObject(1); 
  if (s != null) 
  { 
    String sqlname = s.getSQLTypeName(); 

<span class="bold">    Object[] attrs = s.getAttribute(); </span>

    if (sqlname.equals ("SCOTT.PERSON") 
    { 
      System.out.println ("ssn="+((BigDecimal)attrs[0]).intValue()); 
      System.out.println ("name="+((String)attrs[1])); 
      System.out.println ("address="+((String)attrs[2])); 
    } 
    else if (sqlname.equals ("SCOTT.STUDENT")) 
    { 
      System.out.println ("ssn="+((BigDecimal)attrs[0]).intValue()); 
      System.out.println ("name="+((String)attrs[1])); 
      System.out.println ("address="+((String)attrs[2])); 
      System.out.println ("deptid="+((BigDecimal)attrs[3]).intValue()); 
      System.out.println ("major="+((String)attrs[4])); 
    } 
    else if (sqlname.equals ("SCOTT.PARTTIMESTUDENT")) 
    { 
      System.out.println ("ssn="+((BigDecimal)attrs[0]).intValue()); 
      System.out.println ("name="+((String)attrs[1])); 
      System.out.println ("address="+((String)attrs[2])); 
      System.out.println ("deptid="+((BigDecimal)attrs[3]).intValue()); 
      System.out.println ("major="+((String)attrs[4])); 
      System.out.println ("numHours="+((BigDecimal)attrs[5]).intValue()); 
    } 
    else 
      throw new Exception ("Invalid type name: "+sqlname); 
  } 
} 
rset.close (); 
stmt.close (); 
conn.close ();
</pre></div>
<!-- class="sect2" -->
<a id="BABEJJJC"></a><a id="JJDBC28495"></a>
<div class="sect2">
<h3 class="sect2">Inheritance Metadata Methods</h3>
<p>Oracle JDBC drivers provide a set of metadata methods to access inheritance properties. The inheritance metadata methods are defined in the <code>oracle.sql.StructDescriptor</code> and <code>oracle.jdbc.StructMetaData</code> classes.</p>
<p>The <code>StructMetaData</code> class provides inheritance metadata methods for subtype attributes. The <code>getMetaData</code> method of the <code>StructDescriptor</code> class returns an instance of <code>StructMetaData</code> of the type. The <code>StructMetaData</code> class contains the following inheritance metadata methods:</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1078761"></a><a id="JJDBC28496"></a>
<div class="sect1">
<h2 class="sect1">Using JPublisher to Create Custom Object Classes</h2>
<p>A convenient way to create custom object classes, as well as other kinds of custom Java classes, is to use the Oracle <a id="sthref537"></a>JPublisher utility. It generates a full definition for a custom Java class, which you can instantiate to hold the data from an Oracle object. JPublisher-generated classes include methods to convert data from SQL to Java and from Java to SQL, as well as getter and setter methods for the object attributes.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#BABFCAFD">JPublisher Functionality</a></p>
</li>
<li>
<p><a href="#BABBGAAJ">JPublisher Type Mappings</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink JJPUB" href="../e10587/toc.htm"><span class="italic">Oracle Database JPublisher User's Guide.</span></a></div>
<a id="BABFCAFD"></a><a id="JJDBC28497"></a>
<div class="sect2">
<h3 class="sect2">JPublisher Functionality</h3>
<p>You can direct JPublisher to create custom object classes that implement either the <code>SQLData</code> interface or the <code>ORAData</code> interface, according to how you set the JPublisher type mappings.</p>
<p>If you use the <code>ORAData</code> interface, then <a id="sthref538"></a>JPublisher will also create a custom reference class to map to object references for the Oracle object type. If you use the <code>SQLData</code> interface, then JPublisher will not produce a custom reference class. You would use standard <code>java.sql.Ref</code> instances instead.</p>
<p>If you want additional functionality, you can subclass the custom object class and add features as desired. When you run JPublisher, there is a command-line option for specifying both a generated class name and the name of the subclass you will implement. For the SQL-Java mapping to work properly, JPublisher must know the subclass name, which is incorporated into some of the functionality of the generated class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Hand-editing the JPublisher-generated class, instead of subclassing it, is not recommended. If you hand-edit this class and later have to re-run JPublisher for some reason, you would have to re-implement your changes.</div>
</div>
<!-- class="sect2" -->
<a id="BABBGAAJ"></a><a id="JJDBC28498"></a>
<div class="sect2">
<h3 class="sect2">JPubli<a id="sthref539"></a><a id="sthref540"></a>sher Type Mappings</h3>
<p>JPublisher offers various choices for how to map user-defined types and their attribute types between SQL and Java. This section lists categories of SQL types and the mapping options available for each category.</p>
<p class="subhead2"><a id="JJDBC28499"></a>Categ<a id="sthref541"></a>ories of SQL Types</p>
<p>JPublisher categorizes SQL types into the following groups, with corresponding JPublisher options as specifies:</p>
<ul>
<li>
<p>User-defined types (UDT)</p>
<p>This includes Oracle objects, references, and collections. You use the JPublisher <code>-usertypes</code> option to specify the type-mapping implementation for UDTs, either a standard <code>SQLData</code> implementation or an Oracle-specific <code>ORAData</code> implementation.</p>
</li>
<li>
<p>Numeric types</p>
<p>This includes anything stored in the database as the <code>NUMBER</code> SQL type. You use the JPublisher <code>-numbertypes</code> option to specify type-mapping for numeric types.</p>
</li>
<li>
<p>Large object (LOB) types</p>
<p>This includes the SQL types, <code>BLOB</code> and <code>CLOB</code>. You use the JPublisher <code>-lobtypes</code> option to specify type-mapping for LOB types.</p>
</li>
<li>
<p>Built-in types</p>
<p>This includes anything stored in the database as a SQL type not covered by the preceding categories. For example, <code>CHAR</code>, <code>VARCHAR2</code>, <code>LONG</code>, and <code>RAW</code>. You use the JPublisher <code>-builtintypes</code> option to specify type-mapping for built-in types.</p>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28500"></a>Type-M<a id="sthref542"></a>apping Modes</p>
<p>JPublisher defines the following type-mapping modes, two of which apply to numeric types only:</p>
<ul>
<li>
<p><a id="sthref543"></a><a id="sthref544"></a>JDBC mapping (setting <code>jdbc</code>)</p>
<p>Uses standard default mappings between SQL types and Java native types. For a custom object class, uses a <code>SQLData</code> implementation.</p>
</li>
<li>
<p><a id="sthref545"></a><a id="sthref546"></a>Oracle mapping (setting <code>oracle</code>)</p>
<p>Uses corresponding <code>oracle.sql</code> types to map to SQL types. For a custom object, reference, or collection class, uses a <code>ORAData</code> implementation.</p>
</li>
<li>
<p><a id="sthref547"></a><a id="sthref548"></a>Object-JDBC mapping (setting <code>objectjdbc</code>)</p>
<p>Is an extension of the JDBC mapping. Where relevant, object-JDBC mapping uses numeric object types from the standard <code>java.lang</code> package, such as <code>java.lang.Integer</code>, <code>Float</code>, and <code>Double</code>, instead of primitive Java types, such as <code>int</code>, <code>float</code>, and <code>double</code>. The <code>java.lang</code> types are nullable, while the primitive types are not.</p>
</li>
<li>
<p><code><a id="sthref549"></a><a id="sthref550"></a>BigDecimal</code> mapping (setting <code>bigdecimal</code>)</p>
<p>Uses <code>java.math.BigDecimal</code> to map to all numeric attributes. This is appropriate if you are dealing with large numbers but do not want to map to the <code>oracle.sql.NUMBER</code> class.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Using <code>BigDecimal</code> mapping can significantly degrade performance.</div>
</li>
</ul>
<p class="subhead2"><a id="JJDBC28501"></a>Mapping the Oracle object type to Java</p>
<p>Use the JPublisher <code>-usertypes</code> option to determine how JPublisher will implement the custom Java class that corresponds to a Oracle object type:</p>
<ul>
<li>
<p>A setting of <code>-usertypes=oracle</code>, which is the default setting, instructs JPublisher to create a <code>ORAData</code> implementation for the custom object class. This will also result in JPublisher producing a <code>ORAData</code> implementation for the corresponding custom reference class.</p>
</li>
<li>
<p>A setting of <code>-usertypes=jdbc</code> instructs JPublisher to create a <code>SQLData</code> implementation for the custom object class. No custom reference class can be created. You must use <code>java.sql.Ref</code> or <code>oracle.sql.REF</code> for the reference type.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can also use JPublisher with a <code>-usertypes=oracle</code> setting in creating <code>ORAData</code> implementations to map SQL collection types.
<p>The <code>-usertypes=jdbc</code> setting is not valid for mapping SQL collection types. The <code>SQLData</code> interface is intended only for mapping Oracle object types.</p>
</div>
<p class="subhead2"><a id="JJDBC28502"></a>Mapping Attribute Types to Java</p>
<p>If you do not specify mappings for the attribute types of the Oracle object type, then JPublisher uses the following defaults:</p>
<ul>
<li>
<p>For numeric attribute types, the default mapping is object-JDBC.</p>
</li>
<li>
<p>For LOB attribute types, the default mapping is Oracle.</p>
</li>
<li>
<p>For built-in type attribute types, the default mapping is JDBC.</p>
</li>
</ul>
<p>If you want alternate mappings, then use the <code>-numbertypes</code>, <code>-lobtypes</code>, and <code>-builtintypes</code> options, as necessary, depending on the attribute types you have and the mappings you desire.</p>
<p>If an attribute type is itself an Oracle object type, then it will be mapped according to the <code>-usertypes</code> setting.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
Be aware that if you specify an <code>SQLData</code> implementation for the custom object class and want the code to be portable, then you must be sure to use portable mappings for the attribute types. The defaults for numeric types and built-in types are portable, but for LOB types you must specify <code>-lobtypes=jdbc</code>.</div>
<p class="subhead2"><a id="JJDBC28503"></a>Summary of SQL Type Categories and Mapping Settings</p>
<p><a href="#g1082748">Table 13-1</a> summarizes JPublisher categories for SQL types, the mapping settings relevant for each category, and the default settings.</p>
<div class="tblformal">
<p class="titleintable"><a id="JJDBC28504"></a><a id="sthref551"></a><a id="g1082748"></a>Table 13-1 JPublisher SQL Type Categories, Supported Settings, and Defaults</p>
<table class="cellalignment8" title="JPublisher SQL Type Categories, Supported Settings, and Defaults" summary="JPublisher SQL Type Categories, Supported Settings, and Defaults" dir="ltr">
<thead>
<tr class="cellalignment2">
<th class="cellalignment9" id="r1c1-t28">SQL Type Category</th>
<th class="cellalignment9" id="r1c2-t28">JPublisher Mapping Option</th>
<th class="cellalignment9" id="r1c3-t28">Mapping Settings</th>
<th class="cellalignment9" id="r1c4-t28">Default</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment10" id="r2c1-t28" headers="r1c1-t28">
<p>UDT types</p>
</td>
<td class="cellalignment10" headers="r2c1-t28 r1c2-t28">
<p>-usertypes</p>
</td>
<td class="cellalignment10" headers="r2c1-t28 r1c3-t28">
<p>oracle, jdbc</p>
</td>
<td class="cellalignment10" headers="r2c1-t28 r1c4-t28">
<p>oracle</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r3c1-t28" headers="r1c1-t28">
<p>numeric types</p>
</td>
<td class="cellalignment10" headers="r3c1-t28 r1c2-t28">
<p>-numbertypes</p>
</td>
<td class="cellalignment10" headers="r3c1-t28 r1c3-t28">
<p>oracle, jdbc, objectjdbc, bigdecimal</p>
</td>
<td class="cellalignment10" headers="r3c1-t28 r1c4-t28">
<p>objectjdbc</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r4c1-t28" headers="r1c1-t28">
<p>LOB types</p>
</td>
<td class="cellalignment10" headers="r4c1-t28 r1c2-t28">
<p>-lobtypes</p>
</td>
<td class="cellalignment10" headers="r4c1-t28 r1c3-t28">
<p>oracle, jdbc</p>
</td>
<td class="cellalignment10" headers="r4c1-t28 r1c4-t28">
<p>oracle</p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r5c1-t28" headers="r1c1-t28">
<p>built-in types</p>
</td>
<td class="cellalignment10" headers="r5c1-t28 r1c2-t28">
<p>-builtintypes</p>
</td>
<td class="cellalignment10" headers="r5c1-t28 r1c3-t28">
<p>oracle, jdbc</p>
</td>
<td class="cellalignment10" headers="r5c1-t28 r1c4-t28">
<p>jdbc</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1059278"></a><a id="JJDBC28505"></a>
<div class="sect1">
<h2 class="sect1">Describing an Object Type</h2>
<p>Oracle JDBC includes functionality to retrieve information about a structured object type regarding its attribute names and types. This is similar conceptually to retrieving information from a result set about its column names and types, and in fact uses an almost identical method.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1063251">Functionality for Getting Object Metadata</a></p>
</li>
<li>
<p><a href="#BABDCAGJ">Steps for Retrieving Object Metadata</a></p>
</li>
</ul>
<a id="i1063251"></a><a id="JJDBC28506"></a>
<div class="sect2">
<h3 class="sect2">Functionality for Getting Object Metadata</h3>
<p>The <code>oracle.sql.StructDescriptor</code> class includes functionality to retrieve metadata about a structured object type. The <code>StructDescriptor</code> class has a <code>getMetaData</code> method with the same functionality as the standard <code>getMetaData</code> method available in result set objects. It returns a set of attribute information, such as attribute names and types. Call this method on a <code>StructDescriptor</code> object to get metadata about the Oracle object type that the <code>StructDescriptor</code> object describes.</p>
<p>The signature of the <code>StructDescriptor</code> class <code>getMetaData</code> method is the same as the signature specified for <code>getMetaData</code> in the standard <code>ResultSet</code> interface. The signature is as follows:</p>
<pre>
ResultSetMetaData getMetaData() throws SQLException
</pre>
<p>However, this method actually returns an instance of <code>oracle.jdbc.StructMetaData</code>, a class that supports structured object metadata in the same way that the standard <code>java.sql.ResultSetMetaData</code> interface specifies support for result set metadata.</p>
<p>The following method is also supported by <code>StructMetaData</code>:</p>
<pre>
String getOracleColumnClassName(int column) throws SQLException
</pre>
<p>This method returns the fully qualified name of the <code>oracle.sql.Datum</code> subclass whose instances are manufactured if the <code>OracleResultSet</code> class <code>getOracleObject</code> method is called to retrieve the value of the specified attribute. For example, <code>oracle.sql.NUMBER</code>.</p>
<p>To use the <code>getOracleColumnClassName</code> method, you must cast the <code>ResultSetMetaData</code> object, which that was returned by the <code>getMetaData</code> method, to <code>StructMetaData</code>.</p>
<ul>
<li>
<div class="infobox-note">
<p class="notep1">Note:</p>
In all the preceding method signatures, <code>column</code> is something of a misnomer. Where you specify a value of 4 for <code>column</code>, you really refer to the fourth attribute of the object.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="BABDCAGJ"></a><a id="JJDBC28507"></a>
<div class="sect2">
<h3 class="sect2">Steps for Retrieving Object Metadata</h3>
<p>Use the following steps to obtain metadata about a structured object type:</p>
<ol>
<li>
<p><a id="BABBJBEG"></a>Create or acquire a <code>StructDescriptor</code> instance that describes the relevant structured object type.</p>
</li>
<li>
<p>Call the <code>getMetaData</code> method on the <code>StructDescriptor</code> instance.</p>
</li>
<li>
<p><a id="BABFDCJH"></a>Call the metadata getter methods, <code>getColumnName</code>, <code>getColumnType</code>, and <code>getColumnTypeName</code>, as desired.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If one of the structured object attributes is itself a structured object, repeat steps <a href="#BABBJBEG">1</a> through <a href="#BABFDCJH">3</a>.</div>
</li>
</ol>
<p class="subhead2"><a id="JJDBC28508"></a>Example</p>
<p>The following method shows how to retrieve information about the attributes of a structured object type. This includes the initial step of creating a <code>StructDescriptor</code> instance.</p>
<pre>
// 
// Print out the ADT's attribute names and types 
// 
void getAttributeInfo (Connection conn, String type_name) throws SQLException 
{ 
  // get the type descriptor 
  StructDescriptor desc = StructDescriptor.createDescriptor (type_name, conn); 

  // get type metadata 
  ResultSetMetaData md = desc.getMetaData (); 

  // get # of attrs of this type 
  int numAttrs = desc.length (); 

  // temporary buffers 
  String attr_name; 
  int attr_type; 
  String attr_typeName; 

  System.out.println ("Attributes of "+type_name+" :"); 
  for (int i=0; i&lt;numAttrs; i++) 
  { 
    attr_name = md.getColumnName (i+1); 
    attr_type = md.getColumnType (i+1); 
    System.out.println (" index"+(i+1)+" name="+attr_name+" type="+attr_type); 

    // drill down nested object 
    if (attrType == OracleTypes.STRUCT) 
    { 
      attr_typeName = md.getColumnTypeName (i+1); 

      // recursive calls to print out nested object metadata 
      getAttributeInfo (conn, attr_typeName); 
    } 
  } 
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1">
<tr>
<td class="cellalignment10">
<table class="cellalignment6">
<tr>
<td class="cellalignment5"><a href="jstreams.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5"><a href="oralob.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment13">
<table class="cellalignment4">
<tr>
<td class="cellalignment5"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
