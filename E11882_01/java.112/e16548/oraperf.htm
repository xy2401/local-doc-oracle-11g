<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Performance Extensions</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.1" />
<meta name="dcterms.created" content="2011-09-15T1:42:58Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database JDBC Developer's Guide" />
<meta name="dcterms.identifier" content="E16548-03" />
<meta name="dcterms.isVersionOf" content="JJDBC" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1999, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="rlb.htm" title="Previous" type="text/html" />
<link rel="Next" href="ociconpl.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e16548.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">35/54</span> <!-- End Header --><a id="g1068570"></a><a id="JJDBC28752"></a>
<h1 class="chapter"><span class="secnum">23</span> Performance Extensions</h1>
<p><a id="sthref740"></a><a id="sthref741"></a>This chapter describes the Oracle performance extensions to the Java Database Connectivity (JDBC) standard.</p>
<p><a id="i1059063"></a>This chapter covers the following topics:</p>
<ul>
<li>
<p><a href="#i1056232">Update Batching</a></p>
</li>
<li>
<p><a href="#i1053736">Additional Oracle Performance Extensions</a></p>
</li>
</ul>
<a id="i1056232"></a><a id="JJDBC28753"></a>
<div class="sect1">
<h2 class="sect1">Update Batching</h2>
<p>You can reduce the number of round-trips to the database, thereby improving application performance, by grouping multiple <code>UPDATE</code>, <code>DELETE</code>, or <code>INSERT</code> statements into a single batch and having the whole batch sent to the database and processed in one trip. This is referred to as update batching.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The JDBC 2.0 specification refers to update batching as batch updates.</div>
<p>This is especially useful with prepared statements, when you are repeating the same statement with different bind variables.</p>
<p>Oracle JDBC supports two distinct models for update batching:</p>
<ul>
<li>
<p>The standard model, implementing the JDBC 2.0 specification, which is referred to as standard update batching</p>
</li>
<li>
<p>The Oracle-specific model, independent of the JDBC 2.0 specification, which is referred to as Oracle update batching</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
It is important to be aware that you cannot mix these models. In any single application, you can use one model or the other, but not both. Oracle JDBC driver will throw exceptions when you mix these.</div>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#i1059054">Overview of Update Batching Models</a></p>
</li>
<li>
<p><a href="#i1058859">Oracle Update Batching</a></p>
</li>
<li>
<p><a href="#i1059053">Standard Update Batching</a></p>
</li>
<li>
<p><a href="#CHDIJADJ">Premature Batch Flush</a></p>
</li>
</ul>
<a id="i1059054"></a><a id="JJDBC28754"></a>
<div class="sect2">
<h3 class="sect2">Overview of Update Batching Models</h3>
<p>This section compares and contrasts the general models and types of statements supported for standard update batching and Oracle update batching.</p>
<p class="subhead2"><a id="JJDBC28755"></a>Ora<a id="sthref742"></a>cle Model Versus Standard Model</p>
<p>Oracle update batching uses a batch value that typically results in implicit processing of a batch. The batch value is the number of operations you want to add to a batch for each trip to the database. As soon as that many operations have been added to the batch, the batch is processed. Note the following:</p>
<ul>
<li>
<p>You can set a default batch for the connection object, which applies to any prepared statement run in that connection.</p>
</li>
<li>
<p>For any individual prepared statement object, you can set a statement batch value that overrides the connection batch value.</p>
</li>
<li>
<p>You can choose to explicitly process a batch at any time, overriding both the connection batch value and the statement batch value.</p>
</li>
</ul>
<p>Standard update batching is a manual, explicit model. There is no batch value. You manually add operations to the batch, and then, explicitly choose when to process the batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Oracle recommends that you use JDBC standard features when possible. This recommendation applies to update batching as well. Oracle update batching is retained primarily for backwards compatibility.</p>
</li>
<li>
<p>For both standard update batching and Oracle update batching, Oracle recommends you to keep the batch sizes in the general range of 50 to 100. This is because though the drivers support larger batches, they in turn result in a large memory footprint with no corresponding increase in performance. Very large batches usually result in a decline in performance compared to smaller batches.</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="JJDBC28756"></a>Types of Sta<a id="sthref743"></a>tements Supported</p>
<p>As implemented by Oracle, update batching is intended for use with prepared statements, when you are repeating the same statement with different bind variables. Be aware of the following:</p>
<ul>
<li>
<p>Oracle update batching supports <span class="italic">only</span> prepared statement objects. For a callable statement, both the connection default batch value and the statement batch value are overridden with a value of 1. In an Oracle generic statement, there is no statement batch value, and the connection default batch value is overridden with a value of 1.</p>
</li>
<li>
<p>To adhere to the JDBC 2.0 standard, Oracle implementation of standard update batching supports callable statements, without <code>OUT</code> parameters, and generic statements, as well as prepared statements. You can migrate standard update batching into an Oracle JDBC application without difficulty.</p>
</li>
<li>
<p>You can batch only <code>UPDATE</code>, <code>INSERT</code>, or <code>DELETE</code> operations. Processing a batch that includes an operation that attempts to return a result set will cause an exception.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Oracle implementation of standard update batching does not implement true batching for generic statements and callable statements. Although Oracle JDBC supports the use of standard batching syntax for <code>Statement</code> and <code>CallableStatement</code> objects, you will see performance improvement for only <code>PreparedStatement</code> objects.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1058859"></a><a id="JJDBC28757"></a>
<div class="sect2">
<h3 class="sect2">Oracle Update Bat<a id="sthref744"></a>ching</h3>
<p>The Oracle update batching feature associates a batch value with each prepared statement object. With Oracle update batching, instead of the JDBC driver running a prepared statement each time the <code>executeUpdate</code> method is called, the driver adds the statement to a batch of accumulated processing requests. The driver will pass all the operations to the database for processing once the batch value is reached. For example, if the batch value is 10, then each batch of 10 operations will be sent to the database and processed in one trip.</p>
<p>A method in the <code>OracleConnection</code> class enables you to set a default batch value for the Oracle conn<a id="sthref745"></a><a id="sthref746"></a>ection as a whole, and this batch value applies to any Oracle prepared statement in the connection. For any particular Oracle prepared statement, a method in the <code>OraclePreparedStatement</code> class enables you to set a statement batch value that overrides the connection batch value. You can also override both batch values by choosing to manually process the pending batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not mix standard update batching with Oracle update batching in the same application. The JDBC driver will throw an exception when you mix these.</p>
</li>
<li>
<p>Disable auto-com<a id="sthref747"></a>mit mode if you use either update batching model. In case an error occurs while you are processing a batch, this provides you the option of committing or rolling back the operations that ran successfully prior to the error.</p>
</li>
</ul>
</div>
<a id="JJDBC28758"></a>
<div class="sect3"><a id="sthref748"></a>
<h4 class="sect3">Oracle Update Batching Characteristics and Limitations<a id="sthref749"></a></h4>
<p>Note the following limitations and implementation details regarding Oracle update batching:</p>
<ul>
<li>
<p>By defa<a id="sthref750"></a><a id="sthref751"></a>ult, there is no statement batch value and the connection batch value is 1.</p>
</li>
<li>
<p>Batch values between 5 and 30 tend to be the most effective. Setting a very high value might even have a negative effect. It is worth trying different values to verify the effectiveness for your particular application.</p>
</li>
<li>
<p>Regardless of the batch value in effect, if any of the bind variables of an Oracle prepared statement is a <a id="sthref752"></a>stream type, then Oracle JDBC driver sets the batch value to 1 and sends any queued requests to the database for processing.</p>
</li>
<li>
<p>Oracle JDBC driver automatically runs the <code>sendBatch</code> method of an Oracle prepared statement in any of the following circumstances:</p>
<ul>
<li>
<p>The connection receives a <code>COMMIT</code> request, either as a result of calling the <code>commit</code> method or as a result of auto-commit mode.</p>
</li>
<li>
<p>The statement receives a <code>close</code> request.</p>
</li>
<li>
<p>The connection receives a <code>close</code> request.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
A connection <code>COMMIT</code> request, statement close, or connection close has an effect on a pending batch only if you use Oracle update batching. However, if you use standard update batching, then it has no effect on a pending batch.</div>
</li>
<li>
<p>If the connection receives a <code>ROLLBACK</code> request before <code>sendBatch</code> has been called, then the pending batched operations are not removed. You must explicitly call <code>clearBatch</code> to do this.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="JJDBC28759"></a>
<div class="sect3"><a id="sthref753"></a>
<h4 class="sect3">Setting the Connection Batch Value<a id="sthref754"></a><a id="sthref755"></a></h4>
<p>You can specify a default batch value for any Oracle prepared statement in your Oracle connection. To do this, use the <code>setDefaultExecuteBatch</code> method of the <code>OracleConnection</code> object. For example, the following code sets the default batch value to 20 for all prepared statement objects associated with the <code>conn</code> connection object:</p>
<pre>
((OracleConnection)conn).set<a id="sthref756"></a>DefaultExecuteBatch(20);
</pre>
<p>Even though this sets the default batch value for all the prepared statements of the connection, you can override it by calling the <code>setExecuteBatch</code> method of the <code>oracle.jdbc.OraclePreparedStatement</code> interface on individual Oracle prepared statements.</p>
<p>The connection batch value will apply to statement objects created after this batch value was set.</p>
<p>Note that instead of calling the <code>setDefaultExecuteBatch</code> method, you can set the <code>defaultBatchValue</code> Java property if you use a Java <code>Properties</code> object in establishing the connection.</p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28760"></a>
<div class="sect3"><a id="sthref757"></a>
<h4 class="sect3">Setting the Statement Batch Value<a id="sthref758"></a><a id="sthref759"></a></h4>
<p>Use the following steps to set the statement batch value for a particular Oracle prepared statement. This will override any connection batch value set using the <code>setDefaultExecuteBatch</code> method of the <code>OracleConnection</code> instance for the connection in which the statement is processed.</p>
<ol>
<li>
<p>Write your prepared statement, and specify input values for the first row, as follows:</p>
<pre>
PreparedStatement ps = conn.prepareStatement 
                              ("INSERT INTO dept VALUES (?,?,?)");
ps.setInt (1,12);
ps.setString (2,"Oracle");
ps.setString (3,"USA");
</pre></li>
<li>
<p>Cast your prepared statement to <code>OraclePreparedStatement</code>, and apply the <code>setExecuteBatch</code> method. In this example, the batch size of the statement is set to 2.</p>
<pre>
((OraclePreparedStatement)ps).setExec<a id="sthref760"></a>uteBatch(2);
</pre>
<p>If you wish, insert the <code><a id="sthref761"></a>getExecuteBatch</code> method at any point in the program to check the default batch value for the statement, as follows:</p>
<pre>
System.out.println (" Statement Execute Batch Value " +
                   ((OraclePreparedStatement)ps).getExecuteBatch());
</pre></li>
<li>
<p>If you send an execute-update call to the database at this point, then no data will be sent to the database, and the call will return 0.</p>
<pre>
// No data is sent to the database by this call to executeUpdate
System.out.println ("Number of rows updated so far: "
                                  + ps.executeUpdate ());
</pre></li>
<li>
<p>If you enter a set of input values for a second row and an execute-update, then the number of batch calls to <code>executeUpdate</code> will be equal to the batch value of 2. The data will be sent to the database, and both rows will be inserted in a single round-trip.</p>
<pre>
ps.setInt (1, 11);
ps.setString (2, "Applications");
ps.setString (3, "Indonesia");

int rows = ps.executeUpdate ();
System.out.println ("Number of rows updated now: " + rows);

ps.close ();
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<a id="JJDBC28761"></a>
<div class="sect3"><a id="sthref762"></a>
<h4 class="sect3">Checking the Batch Value<a id="sthref763"></a><a id="sthref764"></a></h4>
<p>To check the overall connection batch value of an Oracle connection instance, use the <code>OracleConnection</code> class <code>getDefaultExecuteBatch</code> method:</p>
<pre>
Integer batch_val = ((OracleConnection)conn).get<a id="sthref765"></a>DefaultExecuteBatch();
</pre>
<p>To check the particular statement batch value of an Oracle prepared statement, use the <code>OraclePreparedStatement</code> class <code>getExecuteBatch</code> method:</p>
<pre>
Integer batch_val = ((OraclePreparedStatement)ps).get<a id="sthref766"></a>ExecuteBatch();
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
If no statement batch value has been set, then <code>getExecuteBatch</code> will return the connection batch value.</div>
</div>
<!-- class="sect3" -->
<a id="JJDBC28762"></a>
<div class="sect3"><a id="sthref767"></a>
<h4 class="sect3">Overriding the Batch Value <a id="sthref768"></a><a id="sthref769"></a></h4>
<p>If you want to process accumulated operations before the batch value in effect is reached, then use the <code><a id="sthref770"></a>sendBatch</code> method of the <code>OraclePreparedStatement</code> object.</p>
<p>For this example, presume you set the connection batch value to 20. This sets the default batch value for all prepared statement objects associated with the connection to 20. You can accomplish this by casting your connection to <code>OracleConnection</code> and applying the <code>setDefaultExecuteBatch</code> method for the connection, as follows:</p>
<pre>
((OracleConnection)conn).setDefaultExecuteBatch (20);
</pre>
<p>Override the batch value as follows:</p>
<ol>
<li>
<p>Write your prepared statement, specify input values for the first row, and then process the statement, as follows:</p>
<pre>
PreparedStatement ps =
   conn.prepareStatement ("insert into dept values (?, ?, ?)");
    
ps.setInt (1, 32);
ps.setString (2, "Oracle");
ps.setString (3, "USA");

System.out.println (ps.executeUpdate ()); 
</pre>
<p>The batch is not processed at this point. The <code>ps.executeUpdate</code> method returns <code>0</code>.</p>
</li>
<li>
<p>If you enter a set of input values for a second operation and call <code>executeUpdate</code> again, then the data will still not be sent to the database, because the batch value in effect for the statement is the connection batch value, which is <code>20</code>.</p>
<pre>
ps.setInt (1, 33);
ps.setString (2, "Applications");
ps.setString (3, "Indonesia");

// this batch is still not executed at this point
int rows = ps.executeUpdate ();  
    
System.out.println ("Number of rows updated before calling sendBatch: "
                        + rows);
</pre>
<p>Note that the value of <code>rows</code> in the <code>println</code> statement is <code>0</code>.</p>
</li>
<li>
<p>If you apply the <code>sendBatch</code> method at this point, then the two previously batched operations will be sent to the database in a single round-trip. The <code>sendBatch</code> method also returns the total number of updated rows. This property of <code>sendBatch</code> is used by <code>println</code> to print the number of updated rows.</p>
<pre>
// Execution of both previously batched executes will happen
// at this point. The number of rows updated will be
// returned by sendBatch.
rows = ((OraclePreparedStatement)ps).sendBatch ();

System.out.println ("Number of rows updated by calling sendBatch: "
                        + rows);
ps.close ();
</pre></li>
</ol>
</div>
<!-- class="sect3" -->
<a id="JJDBC28763"></a>
<div class="sect3"><a id="sthref771"></a>
<h4 class="sect3">Committing the Changes in Oracle Batching<a id="sthref772"></a></h4>
<p>After you process the batch, you must still commit the changes, presuming auto-commit is disabled as recommended.</p>
<p>Calling <code>commit</code> on the connection object in Oracle batching not only commits operations in batches that have been processed, but also issues an implicit <code>sendBatch</code> call to process all pending batches. So <code>commit</code> effectively commits changes for all operations that have been added to a batch.</p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28764"></a>
<div class="sect3"><a id="sthref773"></a>
<h4 class="sect3">Update Counts in Oracle Batching<a id="sthref774"></a><a id="sthref775"></a></h4>
<p>In a nonbatching situation, the <code>executeUpdate</code> method of an <code>OraclePreparedStatement</code> object will return the number of database rows affected by the operation.</p>
<p>In an Oracle batching situation, this method returns the number of rows affected at the time the method is invoked, as follows:</p>
<ul>
<li>
<p>If an <code><a id="sthref776"></a>executeUpdate</code> call results in the operation being added to the batch, then the method returns a value of 0, because nothing was written to the database yet.</p>
</li>
<li>
<p>If an <code>executeUpdate</code> call results in the batch value being reached and the batch being processed, then the method will return the total number of rows affected by all operations in the batch.</p>
</li>
</ul>
<p>Similarly, the <code>send<a id="sthref777"></a>Batch</code> method of an <code>OraclePreparedStatement</code> object returns the total number of rows affected by all operations in the batch.</p>
<p><a href="#CHDCCEHD">Example 23-1</a> illustrates the use of Oracle update batching.</p>
<div class="example">
<p class="titleinexample"><a id="CHDCCEHD"></a><a id="JJDBC28765"></a>Example 23-1 Oracle Update Batching<a id="sthref778"></a></p>
<p>The following example illustrates how you use the Oracle update batching feature. It assumes you have imported the <code>oracle.driver.*</code> interfaces.</p>
<pre>
...
OracleDataSource ods = new OracleDataSource();
ods.setURL("jdbc:oracle:oci);
ods.setUser("scott");
ods.setPassword("tiger");

Connection conn = ods.getConnection();
conn.setAutoCommit(false);

PreparedStatement ps = 
  conn.prepareStatement("insert into dept values (?, ?, ?)"); 
     
//Change batch size for this statement to 3 
((OraclePreparedStatement)ps).setExecuteBatch (3);
 
ps.setInt(1, 23); 
ps.setString(2, "Sales"); 
ps.setString(3, "USA"); 
ps.executeUpdate(); //JDBC queues this for later execution 
 
ps.setInt(1, 24); 
ps.setString(2, "Blue Sky"); 
ps.setString(3, "Montana"); 
ps.executeUpdate(); //JDBC queues this for later execution 
 
ps.setInt(1, 25); 
ps.setString(2, "Applications"); 
ps.setString(3, "India"); 
ps.executeUpdate(); //The queue size equals the batch value of 3 
                    //JDBC sends the requests to the database

ps.setInt(1, 26); 
ps.setString(2, "HR"); 
ps.setString(3, "Mongolia"); 
ps.executeUpdate(); //JDBC queues this for later execution
 
((OraclePreparedStatement)ps).sendBatch(); // JDBC sends the queued request
conn.commit();

ps.close();
...
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Updates deferred through batching can affect the results of other queries. In the following example, if the first query is deferred due to batching, then the second will return unexpected results:
<pre>
UPDATE emp SET name = "Sue" WHERE name = "Bob";
SELECT name FROM emp WHERE name = "Sue";
</pre></div>
</div>
<!-- class="sect3" -->
<a id="JJDBC28766"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref779"></a>
<h4 class="sect3">Error Reporting in Oracle Update Batching</h4>
<p>If any one of the batched operations fails to complete successfully or attempts to return a result set during an <code>executeBatch</code> call, then the processing stops and a <code>java.sql.BatchUpdateException</code> is generated.</p>
<p>If the exception is raised, you can call the <code>getUpdateCounts</code> method on the <code>BatchUpdateException</code> object to retrieve the update count. This method returns an <code>int</code> array of update counts, just as the <code>executeBatch</code> method does.</p>
<p>In Oracle Database 11<span class="italic">g</span> Release 2 (11.2), the integer array returned contains <span class="italic">n</span> <code>Statement.EXECUTE_FAILED</code> entries, where <span class="italic">n</span> is the size of the batch. However, this does not indicate where in the batch the error occurred. The only option you have is to roll back the transaction.</p>
<p>In Oracle Database 11<span class="italic">g</span> Release 2 (11.2), the integer array returned contains <span class="italic">n</span> <code>Statement.SUCCESS_NO_INFO</code> entries, where <span class="italic">n</span> is the number of elements in the batch that have been successfully executed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The execution of the batch always stops with the first element of the batch that generates an error.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1059053"></a><a id="JJDBC28767"></a>
<div class="sect2">
<h3 class="sect2">Stand<a id="sthref780"></a>ard Update Batching</h3>
<p>JDBC standard update batching, unlike the Oracle update batching model, depends on explicitly adding statements to the batch using an <code>addBatch</code> method and explicitly processing the batch using an <code>executeBatch</code> method. In the Oracle model, you call <code>executeUpdate</code> as in a nonbatching situation, but whether an operation is added to the batch or the whole batch is processed is typically determined implicitly, depending on whether or not a predetermined batch value is reached.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not mix standard update batching with Oracle update batching in the same application. Oracle JDBC driver will throw exceptions when these are mixed.</p>
</li>
<li>
<p>Disable auto-commit mode if you use either update batching model. In case an error occurs while you are processing a batch, this provides you the option of committing or rolling back the operations that ran successfully prior to the error.</p>
</li>
</ul>
</div>
<a id="JJDBC28768"></a>
<div class="sect3"><a id="sthref781"></a>
<h4 class="sect3">Limitations in the Oracle Implementation of Standard Batching</h4>
<p>This section discusses the limitations and implementation details regarding the Oracle implementation of standard update batching.</p>
<p>In Oracle JDBC applications, update batching is intended for use with prepared statements that are being processed repeatedly with different sets of bind values.</p>
<p>The Oracle implementation of standard update batching does not implement true batching for generic statements and callable statements. Even though Oracle JDBC supports the use of standard batching for <code>Statement</code> and <code>CallableStatement</code> objects, you are unlikely to see performance improvement.</p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28769"></a>
<div class="sect3"><a id="sthref782"></a>
<h4 class="sect3">Adding Operations to the Batch<a id="sthref783"></a></h4>
<p>When any statement object is first created, its statement batch is empty. Use the standard <code>ad<a id="sthref784"></a>dBatch</code> method to add an operation to the statement batch. This method is specified in the standard <code>java.sql.Statement</code>, <code>PreparedStatement</code>, and <code>CallableStatement</code> interfaces, which are implemented by the <code>oracle.jdbc.OracleStatement</code>, <code>OraclePreparedStatement</code>, and <code>OracleCallableStatement</code> interfaces, respectively.</p>
<p>For a <code>Statement</code> object, the <code>addBatch</code> method takes a Java <code>String</code> with a SQL operation as input. For example:</p>
<pre>
...
Statement stmt = conn.createStatement();

stmt.addBatch("INSERT INTO emp VALUES(1000, 'Joe Jones')");
stmt.addBatch("INSERT INTO dept VALUES(260, 'Sales')");
stmt.addBatch("INSERT INTO emp_dept VALUES(1000, 260)");
...
</pre>
<p>At this point, three operations are in the batch.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Remember, however, that in the Oracle implementation of standard update batching, you will probably see no performance improvement in batching generic statements.</div>
<p>For prepared statements, update batching is used to batch multiple runs of the same statement with different sets of bind parameters. For a <code>PreparedStatement</code> or <code>OraclePreparedStatement</code> object, the <code>addBatch</code> method takes no input. It simply adds the operation to the batch using the bind parameters last set by the appropriate <code>set</code><code><span class="codeinlineitalic">XXX</span></code> methods. This is also true for <code>CallableStatement</code> or <code>OracleCallableStatement</code> objects, but remember that in the Oracle implementation of standard update batching, you will probably see no performance improvement in batching callable statements.</p>
<p>For example:</p>
<pre>
...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();
...
</pre>
<p>At this point, two operations are in the batch.</p>
<p>Because a batch is associated with a single prepared statement object, you can batch only repeated runs of a single prepared statement, as in this example.</p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28770"></a>
<div class="sect3"><a id="sthref785"></a>
<h4 class="sect3">Processing the Batch<a id="sthref786"></a></h4>
<p>To process the current batch of operations, use the <code>exec<a id="sthref787"></a>uteBatch</code> method of the statement object. This method is specified in the standard <code>Statement</code> interface, which is extended by the standard <code>PreparedStatement</code> and <code>CallableStatement</code> interfaces.</p>
<p>Following is an example that repeats the prepared statement <code>addBatch</code> calls shown previously and then processes the batch:</p>
<pre>
...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();

int[] updateCounts = pstmt.executeBatch();
...
</pre>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 1 (11.1), the <code>executeBatch</code> method has been improved so that when an error occurs in the middle of the batch execution, the <code>BatchUpdateExecution</code> exception that is thrown contains the position of the error in the batch. The <code>BatchUpdateExecution.getUpdateCounts</code> method returns an array of <code>int</code> containing the update counts for the updates that were executed successfully before this error occurred. So if an error occurs in the 5th element of the batch, then the size of the array returned is 4 and each value is <code>Statement.SUCCESS_NO_INFO.</code></p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28771"></a>
<div class="sect3"><a id="sthref788"></a>
<h4 class="sect3">Com<a id="sthref789"></a>mitting the Changes in the Oracle Implementation of Standard Batching</h4>
<p>After you process the batch, you must still commit the changes, presuming auto-commit is disabled as recommended.</p>
<p>Calling <code>commit</code>, commits nonbatched operations and batched operations for statement batches that have been processed, but for the Oracle implementation of standard batching, has no effect on pending statement batches that have <span class="italic">not</span> been processed.</p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28772"></a>
<div class="sect3"><a id="sthref790"></a>
<h4 class="sect3">Clearing the Batch<a id="sthref791"></a></h4>
<p>To clear the current batch of operations instead of processing it, use the <code>cle<a id="sthref792"></a>arBatch</code> method of the statement object. This method is specified in the standard <code>Statement</code> interface, which is extended by the standard <code>PreparedStatement</code> and <code>CallableStatement</code> interfaces.</p>
<p>Keep the following things in mind:</p>
<ul>
<li>
<p>When a batch is processed, operations are performed in the order in which they were batched.</p>
</li>
<li>
<p>After calling <code>addBatch</code>, you must call either <code>executeBatch</code> or <code>clearBatch</code> before a call to <code>executeUpdate</code>, otherwise there will be a SQL exception.</p>
</li>
<li>
<p>A <code>clearBatch</code> or <code>executeBatch</code> call resets the statement batch to empty.</p>
</li>
<li>
<p>The statement batch is not reset to empty if the connection receives a <code>ROLLBACK</code> request. You must explicitly call <code>clearBatch</code> to reset it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>If you are using Oracle update batching in Oracle Database 11<span class="italic">g</span>, then you do not have to clear your batches explicitly in the code after a rollback. However, it is OK to invoke <code>clearBatch</code> method after a rollback.</p>
</li>
<li>
<p>If you are using Oracle update batching in an earlier release, then you have to invoke <code>clearBatch</code> method to clear your batches explicitly after a rollback.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Invoking <code>clearBatch</code> method after a rollback works for all releases.</p>
</li>
<li>
<p>An <code>executeBatch</code> call closes the current result set of the statement object, if one exists.</p>
</li>
<li>
<p>Nothing is returned by the <code>clearBatch</code> method.</p>
</li>
</ul>
<p>Following is an example that repeats the prepared statement <code>addBatch</code> calls shown previously but then clears the batch under certain circumstances:</p>
<pre>
...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();

if (...<span class="italic">condition</span>...)
{
   int[] updateCounts = pstmt.executeBatch();
   ...
}
else
{
   pstmt.clearBatch();
   ...
}
</pre></div>
<!-- class="sect3" -->
<a id="i1057545"></a><a id="JJDBC28773"></a>
<div class="sect3">
<h4 class="sect3">Update Counts in the Oracle Implementation of Standard Batching<a id="sthref793"></a><a id="sthref794"></a></h4>
<p>If a statement batch is processed successfully, then the integer array, or update counts array, returned by the statement <code>executeBatch</code> call will always have one element for each operation in the batch. In the Oracle implementation of standard update batching, the values of the array elements are as follows:</p>
<ul>
<li>
<p>For a prepared statement batch, it is not possible to know the number of rows affected in the database by each individual statement in the batch. Therefore, all array elements have a value of <code>-2</code>. According to the JDBC 2.0 specification, a value of <code>-2</code> indicates that the operation was successful but the number of rows affected is unknown.</p>
</li>
<li>
<p>For a generic statement batch, the array contains the actual update counts indicating the number of rows affected by each operation. The actual update counts can be provided only in the case of generic statements in the Oracle implementation of standard batching.</p>
</li>
<li>
<p>For a callable statement batch, the server always returns the value <code>1</code> as the update count, irrespective of the number rows affected by each operation.</p>
</li>
</ul>
<p>In your code, upon successful processing of a batch, you should be prepared to handle either <code>-2</code>, <code>1</code>, or true update counts in the array elements. For a successful batch processing, the array contains either all <code>-2</code>, 1, or all positive integers.</p>
<p><a href="#CHDCBHEC">Example 23-2</a> illustrates the use of standard update batching.</p>
<div class="example">
<p class="titleinexample"><a id="CHDCBHEC"></a><a id="JJDBC28774"></a>Example 23-2 Stan<a id="sthref795"></a>dard Update Batching</p>
<p>This example combines the sample fragments in the previous sections, accomplishing the following steps:</p>
<ol>
<li>
<p>Disabling auto-commit mode, which you should always do when using either update batching model</p>
</li>
<li>
<p>Creating a prepared statement object</p>
</li>
<li>
<p>Adding operations to the batch associated with the prepared statement object</p>
</li>
<li>
<p>Processing the batch</p>
</li>
<li>
<p>Committing the operations from the batch</p>
</li>
</ol>
<pre>
conn.setAutoCommit(false);

PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");
pstmt.addBatch();

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();

int[] updateCounts = pstmt.executeBatch();

conn.commit();

pstmt.close();
...
</pre>
<p>You can process the update counts array to determine if the batch processed successfully.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<a id="i1059009"></a><a id="JJDBC28775"></a>
<div class="sect3">
<h4 class="sect3">Error Handling in the Oracle Implementation of Standard Batching<a id="sthref796"></a></h4>
<p>If any one of the batched operations fails to complete successfully or attempts to return a result set during an <code>executeBatch</code> call, then the processing stops and a <code>java.sql.Batch<a id="sthref797"></a>UpdateException</code> is generated.</p>
<p>After a batch exception, the update counts array can be retrieved using the <code>get<a id="sthref798"></a>UpdateCounts</code> method of the <code>BatchUpdateException</code> object. This returns an <code>int</code> array of update counts, just as the <code>executeBatch</code> method does. In the Oracle implementation of standard update batching, contents of the update counts array are as follows, after a batch is processed:</p>
<ul>
<li>
<p>For a pr<a id="sthref799"></a><a id="sthref800"></a>epared statement batch, it is not possible to know which operation failed. The array has one element for each operation in the batch, and each element has a value of <code>-3</code>. According to the JDBC 2.0 specification, a value of <code>-3</code> indicates that an operation did not complete successfully. In this case, it was presumably just one operation that actually failed, but because the JDBC driver does not know which operation that was, it labels all the batched operations as failures.</p>
<p>You should always perform a <code>ROLLBACK</code> operation in this situation.</p>
</li>
<li>
<p>For a generic statement batch or callable statement batch, the update counts array is only a partial array containing the actual update counts up to the point of the error. The actual update counts can be provided because Oracle JDBC cannot use true batching for generic and callable statements in the Oracle implementation of standard update batching.</p>
<p>For example, if there were 20 operations in the batch, the first 13 succeeded, and the 14th generated an exception, then the update counts array will have 13 elements, containing actual update counts of the successful operations.</p>
<p>You can either commit or roll back the successful operations in this situation, as you prefer.</p>
</li>
</ul>
<p>In your code, upon failed processing of a batch, you should be prepared to handle either <code>-3</code> or true update counts in the array elements when an exception occurs. For a failed batch processing, you will have either a full array of <code>-3</code> or a partial array of positive integers.</p>
</div>
<!-- class="sect3" -->
<a id="JJDBC28776"></a>
<div class="sect3"><a id="sthref801"></a>
<h4 class="sect3">Intermixing Batched Statements and Nonbatched Statements<a id="sthref802"></a></h4>
<p>You cannot call <code>executeUpdate</code> for regular, nonbatched processing of an operation if the statement object has a pending batch of operations.</p>
<p>However, you can intermix batched operations and nonbatched operations in a single statement object if you process nonbatched operations either prior to adding any operations to the statement batch or after processing the batch. Essentially, you can call <code>executeUpdate</code> for a statement object only when its update batch is empty. If the batch is non-empty, then an exception will be generated.</p>
<p>For example, it is valid to have a sequence, such as the following:</p>
<pre>
...
PreparedStatement pstmt = 
          conn.prepareStatement("INSERT INTO employees VALUES(?, ?)");

pstmt.setInt(1, 2000);
pstmt.setString(2, "Milo Mumford");

int scount = pstmt.executeUpdate();   // OK; no operations in pstmt batch

pstmt.setInt(1, 3000);
pstmt.setString(2, "Sulu Simpson");
pstmt.addBatch();                    // Now start a batch

pstmt.setInt(1, 4000);
pstmt.setString(2, "Stan Leland");
pstmt.addBatch();

int[] bcounts = pstmt.executeBatch();

pstmt.setInt(1, 5000);
pstmt.setString(2, "Amy Feiner");

int scount = pstmt.executeUpdate();   // OK; pstmt batch was executed
...
</pre>
<p>Intermixing nonbatched operations on one statement object and batched operations on another statement object within your code is permissible. Different statement objects are independent of each other with regard to update batching operations. A <code>COMMIT</code> request will affect all nonbatched operations and all successful operations in processed batches, but will not affect any pending batches.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDIJADJ"></a><a id="JJDBC28777"></a>
<div class="sect2">
<h3 class="sect2">Premature Batch Flush</h3>
<p>Premature batch flush happens due to a change in cached metadata. Cached metadata can be changed due to various reasons, such as the following:</p>
<ul>
<li>
<p>The initial bind was null and the following bind is not null.</p>
</li>
<li>
<p>A scalar type is initially bound as string and then bound as scalar type or the reverse.</p>
</li>
</ul>
<p>The premature batch flush count is summed to the return value of the next <code>executeUpdate</code> or <code>sendBatch</code> method.</p>
<p>The old functionality lost all these batch flush values which can be obtained now. To switch back to the old functionality, you can set the <code>AccumulateBatchResult</code> property to <code>false</code>, as follows:</p>
<pre>
java.util.Properties info = new java.util.Properties(); 
info.setProperty("user", "SCOTT"); 
info.setProperty("passwd", "TIGER"); 
// other properties 
... 

// property: batch flush type 
info.setProperty("AccumulateBatchResult", "false");

OracleDataSource ods = new OracleDataSource();
ods.setConnectionProperties(info);
ods.setURL("jdbc:oracle:oci:@"");
Connection conn = ods.getConnection(); 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code>AccumulateBatchResult</code> property is set to <code>true</code> by default.</div>
<p><a href="#CHDIJICJ">Example 23-3</a> illustrates premature batch flushing.</p>
<div class="example">
<p class="titleinexample"><a id="CHDIJICJ"></a><a id="JJDBC28778"></a>Example 23-3 Premature Batch Flushing</p>
<pre>
((OraclePreparedStatement)pstmt).setExecuteBatch (2); 

pstmt.setNull (1, OracleTypes.NUMBER); 
pstmt.setString (2, "test11"); 
int count = pstmt.executeUpdate (); // returns 0 

/* 
* Premature batch flush happens here. 
*/ 
pstmt.setInt (1, 22); 
pstmt.setString (2, "test22"); 
int count = pstmt.executeUpdate (); // returns 0 

pstmt.setInt (1, 33); 
pstmt.setString (2, "test33"); 
/* 
*  returns 3 with the new batching scheme where as, 
*  returns 2 with the old batching scheme. 
*/ 
int count = pstmt.executeUpdate ();
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1053736"></a><a id="JJDBC28779"></a>
<div class="sect1">
<h2 class="sect1">Additional Oracle Performance Extensions</h2>
<p>In addition to update batching, Oracle JDBC drivers support the following extensions that improve performance by reducing round-trips to the database:</p>
<ul>
<li>
<p><a id="sthref803"></a>Prefetching rows</p>
<p>This reduces round-trips to the database by fetching multiple rows of data each time data is fetched. The extra data is stored in client-side buffers for later access by the client. The number of rows to prefetch can be set as desired.</p>
</li>
<li>
<p>Specifying <a id="sthref804"></a>column types</p>
<p>This avoids an inefficiency in the standard JDBC protocol for performing and returning the results of queries.</p>
</li>
<li>
<p>Suppressing database metadata <code><a id="sthref805"></a>TABLE_REMARKS</code> columns</p>
<p>This avoids an expensive outer join operation.</p>
</li>
</ul>
<p>Oracle provides several extensions to connection properties objects to support these performance extensions. These extensions enable you to set the <code><a id="sthref806"></a>remarksReporting</code> flag and default values for row prefetching and update batching.</p>
<p>This section covers the following topics:</p>
<ul>
<li>
<p><a href="#CACGEEIB">Prefetching LOB Data</a></p>
</li>
<li>
<p><a href="#CHDHDADD">Oracle Row-Prefetching Limitations</a></p>
</li>
<li>
<p><a href="#i1059055">Defining Column Types</a></p>
</li>
<li>
<p><a href="#i1023518">Reporting DatabaseMetaData TABLE_REMARKS</a></p>
</li>
</ul>
<a id="CACGEEIB"></a><a id="JJDBC23210"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Prefetching LOB Data</h3>
<p>For the JDBC drivers prior to Oracle Database 11<span class="italic">g</span> Release 2 (11.2) JDBC drivers, if you want to retrieve <code>LOB</code> data in one round trip, then you have to fetch the data as <code>VARCHAR2</code> type, that is, you have to use <code>OracleTypes.VARCHAR</code> or <code>OracleTypes.LONGVARCHAR</code> with the JDBC <code>defineColumnType</code> method. The limitation of this approach is that when <code>LOB</code> data is fetched as <code>CHAR</code> type, the locator cannot be fetched along with the data. So, if the application wants to get the <code>LOB</code> data at a later point of time, or if the application wants to perform other <code>LOB</code> operations, then one more round trip is required to get the <code>LOB</code> locator, as <code>LOB</code> locator is not available to the application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Array operations on <code>LOB</code> locators are not supported in the JDBC APIs.</div>
<p>For Oracle Database 11<span class="italic">g</span> Release 2 (11.2) JDBC drivers, the number of round trips is reduced by prefetching frequently used metadata, such as the <code>LOB</code> length and the chunk size as well as the beginning of the <code>LOB</code> data along with the locator during regular fetch operations. For small <code>LOB</code>s, the data may be totally prefetched in one single round trip, that is, the <code>select</code> parse, execution, and fetch occurs in one round trip, and performance is improved greatly. For large <code>LOB</code>s that are larger than 5 times the prefetch size, the performance improvement is not very significant as only the round trip for retrieving the chunk size is not needed.</p>
<p class="subhead2"><a id="JJDBC28780"></a>defaultLobPrefetchSize Connection Property</p>
<p>Starting from Oracle Database 11<span class="italic">g</span> Release 2 (11.2), there is a new connection property <code>oracle.jdbc.defaultLobPrefetchSize</code> that can be used to set the default <code>LOB</code> prefetch size for the connection. This connection property is defined as the following constant: <code>OracleConnection.CONNECTION_PROPERTY_DEFAULT_LOB_PREFETCH_SIZE</code>. The value of this property is used as the default <code>LOB</code> prefetch size for the current connection. The default value of this connection property is -1. If you want to change the default value at the statement level, then use the <code>setLobPrefetchSize</code> method defined in <code>oracle.jdbc.OracleStatement</code> interface. You can change the default value to:</p>
<ul>
<li>
<p>-1 to disable <code>LOB</code> prefetch for the current connection</p>
</li>
<li>
<p>0 to enable <code>LOB</code> prefetch for metadata only</p>
</li>
<li>
<p>Any value greater than 0 to specify the number of bytes for <code>BLOB</code>s and the number of characters for <code>CLOB</code>s to be prefetched along with the locator during fetch operations</p>
</li>
</ul>
<p>Use <code>getLobPrefetchSize</code> method defined in <code>oracle.jdbc.OracleStatement</code> interface to retrieve the <code>LOB</code> prefetch size.</p>
<p>You can also set the value of <code>LOB</code> prefetch size at the column level by using the <code>defineColumnType</code> method. The column-level value overrides any value that is set at the connection or statement level.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The JavaDoc for more information</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
If <code>LOB</code> prefetch is not disabled at the connection level or statement level, it cannot be disabled at the column level.</div>
</div>
<!-- class="sect2" -->
<a id="CHDHDADD"></a><a id="JJDBC28781"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Oracle Row-Prefetching Limitations</h3>
<p>There is no maximum prefetch setting. <a id="sthref807"></a>The default value is 10. Larger or smaller values may be appropriate depending on the number of rows and columns expected from the query. You can set the default connection row-prefetch value using a <code>Properties</code> object.</p>
<p>When a statement object is created, it receives the default row-prefetch setting from the associated connection. Subsequent changes to the default connection row-prefetch setting will have no effect on the statement row-prefetch setting.</p>
<p>If a column of a result set is of data type <code>LONG</code>, <code>LONG</code> <code>RAW</code> or <code>LOB</code>s returned through the data interface, that is, the streaming types, then JDBC changes the statement row-prefetch setting to 1, even if you never actually read a value of either of these types.</p>
<p>Setting the prefetch size can affect the performance of an application. Increasing the prefetch size will reduce the number of round-trips required to get all the data, but will increase memory usage. This will depend on the number and size of the columns in the query and the number of rows expected to be returned. It will also depend on the memory and CPU loading of the JDBC client machine. The optimum for a standalone client application will be different from a heavily loaded application server. The speed and latency of the network connection should also be considered.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Starting from Oracle Database 11<span class="italic">g</span> Release 1 (11.1), the Thin driver can fetch the first <code>prefetch_size</code> number of rows from the server in the very first roundtrip. This saves one roundtrip in SELECT statements.</div>
<p>If you are migrating an application from earlier releases of Oracle JDBC drivers to 10<span class="italic">g</span> Release 1 (10.1) or later releases of Oracle JDBC drivers, then you should revisit the optimizations that you had done earlier, because the memory usage and performance characteristics may have changed substantially.</p>
<p>A common situation that you may encounter is, say, you have a query that selects a unique key. The query will return only zero or one row. Setting the prefetch size to 1 will decrease memory and CPU usage and cannot increase round-trips. However, you must be careful to avoid the error of requesting an extra fetch by writing <code>while(rs.next())</code> instead of <code>if(rs.next())</code>.</p>
<p>If you are using the JDBC Thin driver, then use the <code>useFetchSizeWithLongColumn</code> connection property, because it will perform <code>PARSE</code>, <code>EXECUTE</code>, and <code>FETCH</code> in a single round-trip.</p>
<p>Tuning of the prefetch size should be done along with tuning of memory management in your JVM under realistic loads of the actual application.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>Do not mix the JDBC 2.0 fetch size application programming interface (API) and the Oracle row-prefetching API in your application. You can use one or the other, but not both.</p>
</li>
<li>
<p>Be aware that setting the Oracle fetch size value can affect not only queries, but also explicitly refetching rows in a result set through the result set <code>refreshRow</code> method, which is relevant for scroll-sensitive/read-only, scroll-sensitive/updatable, and scroll-insensitive/updatable result sets, and the window size of a scroll-sensitive result set, affecting how often automatic refetches are performed. However, the Oracle fetch size value will be overridden by any setting of the fetch size.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="urls.htm#i1006362">"Supported Connection Properties"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1059055"></a><a id="JJDBC28782"></a>
<div class="sect2">
<h3 class="sect2">Defining Column Types</h3>
<p>The implementation of <code>defineColumnType</code> changed significantly since Oracle Database 10<span class="italic">g</span>. Previously, <code>defineColumnType</code> was used both as a performance optimization and to force data type conversion. In previous releases, all of the drivers benefited from calls to <code>defineColumnType</code>. Starting from Oracle Database 10<span class="italic">g</span>, the JDBC Thin driver no longer needs the information provided. The JDBC Thin driver achieves maximum performance without calls to <code>defineColumnType</code>. The JDBC Oracle Call Interface (OCI) and server-side internal drivers still get better performance when the application uses <code>defineColumnType</code>.</p>
<p>If your code is used with both the JDBC Thin and OCI drivers, you can disable the <code>defineColumnType</code> method when using the Thin driver by setting the connection property <code>disableDefineColumnType</code> to <code>true</code>. Doing this makes <code>defineColumnType</code> have no effect. Do not set this connection property to <code>true</code> when using the JDBC OCI or server-side internal drivers.</p>
<p>You can also use <code>defineColumnType</code> to control how much memory the client-side allocates or to limit the size of variable-length data.</p>
<p><a id="sthref808"></a><a id="sthref809"></a>Follow these general steps to define column types for a query:</p>
<ol>
<li>
<p>If necessary, cast your statement object to <code>OracleStatement</code>, <code>OraclePreparedStatement</code>, or <code>OracleCallableStatement</code>, as applicable.</p>
</li>
<li>
<p>If necessary, use the <code><a id="sthref810"></a>clearDefines</code> method of your <code>Statement</code> object to clear any previous column definitions for this <code>Statement</code> object.</p>
</li>
<li>
<p>On each column, call the <code><a id="sthref811"></a>defineColumnType</code> method of your <code>Statement</code> object, passing it these parameters:</p>
<ul>
<li>
<p>Column index (integer)</p>
</li>
<li>
<p>Type code (integer)</p>
<p>Use the <code>static</code> constants of the <code><a id="sthref812"></a>java.sql.Types</code> class or <code><a id="sthref813"></a>oracle.jdbc.OracleTypes</code> class, such as <code>Types.INTEGER</code>, <code>Types.FLOAT</code>, <code>Types.VARCHAR</code>, <code>OracleTypes.VARCHAR</code>, and <code>OracleTypes.ROWID</code>. Type codes for standard types are identical in these two classes.</p>
</li>
<li>
<p>Type name (string)</p>
<p>For structured objects, object references, and arrays, you must also specify the type name. For example, <code>Employee</code>, <code>EmployeeRef</code>, or <code>EmployeeArray</code>.</p>
</li>
<li>
<p>Maximum field size (integer)</p>
<p>Optionally specify a maximum data length for this column.</p>
<p>You cannot specify a maximum field size parameter if you are defining the column type for a structured object, object reference, or array. If you try to include this parameter, it will be ignored.</p>
</li>
<li>
<p>Form of use (short)</p>
<p>Optionally specify a form of use for the column. This can be <code>OraclePreparedStatement.FORM_CHAR</code> to use the database character set or <code>OraclePreparedStatement.FORM_NCHAR</code> to use the national character set. If this parameter is omitted, the default is <code>FORM_CHAR</code>.</p>
</li>
</ul>
<p>For example, assuming <code>stmt</code> is an Oracle statement, use:</p>
<pre>
stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>);
</pre>
<p>If the column is <code>VARCHAR</code> or equivalent and you know the length limit:</p>
<pre>
stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, <span class="italic">max_size</span>);
</pre>
<p>For an <code>NVARCHAR</code> column where the original maximum length is desired and conversion to the database character set is requested:</p>
<pre>
stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, 0,
   OraclePreparedStatement.FORM_CHAR );
</pre>
<p>For structured object, object reference, and array columns:</p>
<pre>
stmt.defineColumnType(<span class="italic">column_index</span>, <span class="italic">typeCode</span>, <span class="italic">typeName</span>);
</pre>
<p>Set a maximum field size if you do not want to receive the full default length of the data. Calling the <code><a id="sthref814"></a>setMaxFieldSize</code> method of the standard JDBC <code>Statement</code> class sets a restriction on the amount of data returned. Specifically, the size of the data returned will be the minimum of the following:</p>
<ul>
<li>
<p>The maximum field size set in <code>defineColumnType</code></p>
</li>
<li>
<p>The maximum field size set in <code>setMaxFieldSize</code></p>
</li>
<li>
<p>The natural maximum size of the data type</p>
</li>
</ul>
</li>
</ol>
<p>After you complete these steps, use the <code>executeQuery</code> method of the statement to perform the query.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
It is no longer necessary to specify a data type for each column of the expected result set.</div>
<p><a href="#CHDJDDEA">Example 23-4</a> illustrates the use of this feature. It assumes you have imported the <code>oracle.jdbc.*</code> interfaces.</p>
<div class="example">
<p class="titleinexample"><a id="CHDJDDEA"></a><a id="JJDBC28783"></a>Example 23-4 Defining Column Types</p>
<pre>
OracleDataSource ods = new OracleDataSource();
ods.setURL("jdbc:oracle:thin:@localhost:1502:orcl");
ods.setUser("scott");
ods.setPassword("tiger");
Connection conn = ods.getConnection();

Statement stmt = conn.createStatement();
// Allocate only 2 chars for this column (truncation will happen)
((OracleStatement)stmt).defineColumnType(1, Types.VARCHAR, 2);
ResultSet rset = stmt.executeQuery("select ename from emp");
while (rset.next() )
  System.out.println(rset.getString(1));
stmt.close();
</pre></div>
<!-- class="example" -->
<p>As this example shows, you must cast the <code>Statement</code> object, <code>stmt</code>, to <code>OracleStatement</code> in the invocation of the <code>defineColumnType</code> method. The <code>createStatement</code> method of the connection returns an object of type <code>java.sql.Statement</code>, which does not have the <code>defineColumnType</code> and <code>clearDefines</code> methods. These methods are provided only in the <code>OracleStatement</code> implementation.</p>
<p>The define-extensions use JDBC types to specify the desired types. The allowed define types for columns depend on the internal Oracle type of the column.</p>
<p>All columns can be defined to their natural JDBC types. In most cases, they can be defined to the <code>Types.CHAR</code> or <code>Types.VARCHAR</code> type code.</p>
<p><a href="#g1060844">Table 23-1</a> lists the valid column definition arguments you can use in the <code>defineColumnType</code> method.</p>
<div class="tblformal">
<p class="titleintable"><a id="JJDBC28784"></a><a id="sthref815"></a><a id="g1060844"></a>Table 23-1 Valid Column Type Specifications</p>
<table class="cellalignment8" title="Valid Column Type Specifications " summary="table" dir="ltr">
<thead>
<tr class="cellalignment2">
<th class="cellalignment9" id="r1c1-t22">If the column has Oracle SQL type:</th>
<th class="cellalignment9" id="r1c2-t22">You can use defineColumnType to define it as:</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2">
<td class="cellalignment10" id="r2c1-t22" headers="r1c1-t22">
<p><code>NUMBER</code>, <code>VARNUM</code></p>
</td>
<td class="cellalignment10" headers="r2c1-t22 r1c2-t22">
<p><code>BIGINT</code>, <code>TINYINT</code>, <code>SMALLINT</code>, <code>INTEGER</code>, <code>FLOAT</code>, <code>REAL</code>, <code>DOUBLE</code>, <code>NUMERIC</code>, <code>DECIMAL</code>, <code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r3c1-t22" headers="r1c1-t22">
<p><code>CHAR</code>, <code>VARCHAR2</code></p>
</td>
<td class="cellalignment10" headers="r3c1-t22 r1c2-t22">
<p><code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r4c1-t22" headers="r1c1-t22">
<p><code>LONG</code></p>
</td>
<td class="cellalignment10" headers="r4c1-t22 r1c2-t22">
<p><code>CHAR</code>, <code>VARCHAR</code>, <code>LONGVARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r5c1-t22" headers="r1c1-t22">
<p><code>LONGRAW</code></p>
</td>
<td class="cellalignment10" headers="r5c1-t22 r1c2-t22">
<p><code>LONGVARBINARY</code>, <code>VARBINARY</code>, <code>BINARY</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r6c1-t22" headers="r1c1-t22">
<p><code>RAW</code></p>
</td>
<td class="cellalignment10" headers="r6c1-t22 r1c2-t22">
<p><code>VARBINARY</code>, <code>BINARY</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r7c1-t22" headers="r1c1-t22">
<p><code>DATE</code></p>
</td>
<td class="cellalignment10" headers="r7c1-t22 r1c2-t22">
<p><code>DATE</code>, <code>TIME</code>, <code>TIMESTAMP</code>, <code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r8c1-t22" headers="r1c1-t22">
<p><code>ROWID</code></p>
</td>
<td class="cellalignment10" headers="r8c1-t22 r1c2-t22">
<p><code>ROWID</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r9c1-t22" headers="r1c1-t22">
<p><code>BLOB</code></p>
</td>
<td class="cellalignment10" headers="r9c1-t22 r1c2-t22">
<p><code>VARBINARY</code>, <code>BINARY</code></p>
</td>
</tr>
<tr class="cellalignment2">
<td class="cellalignment10" id="r10c1-t22" headers="r1c1-t22">
<p><code>CLOB</code></p>
</td>
<td class="cellalignment10" headers="r10c1-t22 r1c2-t22">
<p><code>LONG</code>, <code>CHAR</code>, <code>VARCHAR</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>It is always valid to use <code>defineColumnType</code> with the original data type of the column.</p>
</div>
<!-- class="sect2" -->
<a id="i1023518"></a><a id="JJDBC28785"></a>
<div class="sect2">
<h3 class="sect2">Reporting DatabaseMetaData TABLE_REMARKS</h3>
<p>The <code><a id="sthref816"></a><a id="sthref817"></a><a id="sthref818"></a>getColumns</code>, <code>getProcedureColumns</code>, <code>getProcedures</code>, and <code>getTables</code> methods of the database metadata classes are slow if they must report <code><a id="sthref819"></a><a id="sthref820"></a>TABLE_REMARKS</code> columns, because this necessitates an expensive outer join. For this reason, the JDBC driver does <span class="italic">not</span> report <code>TABLE_REMARKS</code> columns by default.</p>
<p>You can enable <code>TABLE_REMARKS</code> reporting by passing a <code>true</code> argument to the <code><a id="sthref821"></a>setRemarksReporting</code> method of an <code>OracleConnection</code> object.</p>
<p>Equivalently, instead of calling <code>setRemarksReporting</code>, you can set the <code>remarksReporting</code> Java property if you use a Java <code>Properties</code> object in establishing the connection.</p>
<p>If you are using a standard <code>java.sql.Connection</code> object, you must cast it to <code>OracleConnection</code> to use <code>setRemarksReporting</code>.</p>
<p><a href="#CHDECFCC">Example 23-5</a> illustrates how to enable <code>TABLE_REMARKS</code> reporting.</p>
<div class="example">
<p class="titleinexample"><a id="CHDECFCC"></a><a id="JJDBC28786"></a>Example 23-5 TABLE_REMARKS Reporting</p>
<p>Assuming <code>conn</code> is the name of your standard <code>Connection</code> object, the following statement enables <code>TABLE_REMARKS</code> reporting:</p>
<pre>
( (oracle.jdbc.OracleConnection)conn ).setRemarksReporting(true);
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="JJDBC28787"></a>Considerations for getColumns</p>
<p>By default, the <code>getColumns</code> method does not retrieve information about the columns if a synonym is specified. To enable the retrieval of information if a synonym is specified, you must call the <code>setIncludeSynonyms</code> method on the connection as follows:</p>
<pre>
( (oracle.jdbc.driver.OracleConnection)conn ).setIncludeSynonyms(true)
</pre>
<p>This will cause all subsequent <code>getColumns</code> method calls on the connection to include synonyms. This is similar to <code>setRemarksReporting</code>. Alternatively, you can set the <code>includeSynonyms</code> connection property. This is similar to the <code>remarksReporting</code> connection property.</p>
<p>However, bear in mind that if <code>includeSynonyms</code> is <code>true</code>, then the name of the object returned in the <code>table_name</code> column will be the synonym name, if a synonym exists. This is true even if you pass the table name to <code>getColumns</code>.</p>
<p class="subhead2"><a id="CHDCHECH"></a><a id="JJDBC28788"></a>Considerations for getProcedures and getProcedureColumns Methods</p>
<p>According to JDBC versions 1.1 and 1.2, the methods <code>getProcedures</code> and <code>getProcedureColumns</code> treat the <code>catalog</code>, <code>schemaPattern</code>, <code>columnNamePattern</code>, and <code>procedureNamePattern</code> parameters in the same way. In the Oracle definition of these methods, the parameters are treated differently:</p>
<ul>
<li>
<p><code>catalog</code></p>
<p>Oracle does not have multiple catalogs, but it does have packages. Consequently, the <code>catalog</code> parameter is treated as the package name. This applies both on input, which is the <code>catalog</code> parameter, and the output, which is the <code>catalog</code> column in the returned <code>ResultSet</code>. On input, the construct <code>"</code> <code>"</code>, which is an empty string, retrieves procedures and arguments without a package, that is, standalone objects. A <code>null</code> value means to drop from the selection criteria, that is, return information about both standalone and packaged objects. That is, it has the same effect as passing in the percent sign (<code>%</code>). Otherwise, the <code>catalog</code> parameter should be a package name pattern, with SQL wild cards, if desired.</p>
</li>
<li>
<p><code>schemaPattern</code></p>
<p>All objects within Oracle database must have a schema, so it does not make sense to return information for those objects without one. Thus, the construct <code>"</code> <code>"</code>, which is an empty string, is interpreted on input to mean the objects in the current schema, that is, the one to which you are currently connected. To be consistent with the behavior of the <code>catalog</code> parameter, <code>null</code> is interpreted to drop the schema from the selection criteria. That is, it has the same effect as passing in <code>%</code>. It can also be used as a pattern with SQL wild cards.</p>
</li>
<li>
<p><code>procedureNamePattern</code> and <code>columnNamePattern</code></p>
<p>The empty string (" ") does not make sense for either parameter, because all procedures and arguments must have names. Thus, the construct <code>"</code> <code>"</code> will raise an exception. To be consistent with the behavior of other parameters, <code>null</code> has the same effect as passing in percent sign (<code>%</code>).</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1">
<tr>
<td class="cellalignment10">
<table class="cellalignment6">
<tr>
<td class="cellalignment5"><a href="rlb.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment5"><a href="ociconpl.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1999, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment13">
<table class="cellalignment4">
<tr>
<td class="cellalignment5"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment5"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment5"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment5"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment5"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment5"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
