<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>AGGMAP</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 742" />
<meta name="dcterms.created" content="2013-11-14T21:21:35Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="OLAP DML Reference" />
<meta name="dcterms.identifier" content="E17122-08" />
<meta name="dcterms.isVersionOf" content="OLADM" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="dml_commands_1005.htm" title="Previous" type="text/html" />
<link rel="Next" href="dml_commands_1007.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e17122.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">422/593</span> <!-- End Header --><a id="i1032719"></a>
<hr />
<div id="OLADM727" class="refsect1">
<h1 class="refsect1">AGGMAP</h1>
<p><a id="sthref3554"></a><a id="ABC1045471"></a>The AGGMAP command identifies an aggmap object as a specification for aggregation and adds an aggregation specification to the definition of the current aggmap object. To use AGGMAP to assign an aggregation specification to n aggmap object, the definition must be the one most recently defined or considered during the current session. When it is not, you must first use a CONSIDER statement to make it the current definition.</p>
<p>An alternative to the AGGMAP command is the EDIT AGGMAP statement, which is available only in OLAP Worksheet. The EDIT AGGMAP statement opens an Edit window in which you can add, delete, or change the aggregation specification for an aggmap object.</p>
<div class="infoboxnotealso">
<p class="notep1">See also:</p>
<a href="dml_objects.htm#BABEJFHJ">"OLAP DML Aggregation Objects"</a></div>
<p>(Note that there are two other OLAP DML statements that are also sometimes referred to as "AGGMAP statements": AGGMAP ADD or REMOVE model statement that you can use to add or remove a model from an aggmap object of type AGGMAP, and AGGMAP SET that you can use to specify the default aggmap for a variable.)</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3555"></a>Syntax</p>
<p class="synopsis">AGGMAP [<span class="italic">specification</span>]</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3556"></a>Parameters</p>
<dl>
<dt><span class="italic">specification</span></dt>
<dd>
<p>A multiline text expression that is the aggregation specification for the current aggmap object. Each statement is a line of the multiline text expression. When coding an AGGMAP command at the command line level, separate statements with newline delimiters (<code>\n</code>), or use JOINLINES.</p>
<p>An aggregation specification begins with AGGMAP and ends with an <code>END</code>. Between these statements, you code one or more the following statements depending on the calculation that you want to specify. Minimally, you must code one RELATION (for aggregation) statement.</p>
<dl>
<dd><a href="#i78730">AGGINDEX</a></dd>
<dd><a href="#i1018970">BREAKOUT DIMENSION</a></dd>
<dd><a href="#i1020124">CACHE</a></dd>
<dd><a href="#i80583">DIMENSION (for aggregation)</a></dd>
<dd><a href="#BCFECFFC">DROP DIMENSION</a></dd>
<dd><a href="#i1005123">MEASUREDIM (for aggregation)</a></dd>
<dd><a href="#i1010068">MODEL (in an aggregation)</a></dd>
<dd><a href="#BCFJGIGI">PRECOMPUTE</a></dd>
<dd><a href="#i1017474">RELATION (for aggregation)</a></dd>
</dl>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot specify a conjoint dimension in the specification for the aggmap; use composites instead.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3557"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2101"></a>Creating Temporary or Custom Aggregates</p>
<p>Most aggmap objects are defined to calculate variable values that are dimensioned by permanent dimension members (that is, dimension members that persist from one session to another). However, users might want to create their own aggregates at run time for forecasting or what-if analysis, or just because they want to view the data in an unforeseen way. Adding temporary members to dimensions and aggregating data for those members is sometimes called creating temporary or custom aggregates. For example, you can use a <a href="dml_commands_2016.htm#i1023561">MAINTAIN ADD SESSION</a> statement like the one below to temporarily add a model to an aggmap object.</p>
<p><span class="syntaxinline">MAINTAIN</span> <span class="syntaxinlineitalic">dimension</span> <span class="syntaxinline">ADD SESSION</span> <span class="syntaxinlineitalic">member</span> <span class="syntaxinline">=</span> <span class="syntaxinlineitalic">model</span> <span class="syntaxinline">APPLY TO AGGMAP</span> <span class="syntaxinlineitalic">aggmap</span></p>
<p class="subhead2"><a id="CHDFGADE"></a><a id="OLADM2102"></a>Aggregating Variables Dimensioned by Compressed Composites</p>
<p>Keep the following points in mind when designing an aggregation specification for a variable dimensioned by a compressed composite:</p>
<ul>
<li>
<p>RELATION statements in the aggregation specification must be coded following the guidelines given in <a href="#BCFFHAEF">"RELATION Statements for Compressed Composites"</a>.</p>
</li>
<li>
<p>There is no support for parallel aggregation. Instead, use multiple sessions to compute variables or partitions that have their own compressed composites.</p>
</li>
<li>
<p>If possible, Oracle OLAP automatically performs incremental aggregation when you reaggregate a variable dimensioned by the compressed composite. In other words, Oracle OLAP determines what changes have occurred since the last aggregation, determines the smallest region of the variable that needs to be recomputed, and recomputes only that region.</p>
<p>Consequently, there is no support for explicit incremental aggregation. You cannot aggregate a variable dimensioned by a compressed composite if the dimension status of the variable is limited. The status of the variable's dimensions must be ALLSTAT for the aggregation to succeed. You can, however, partition using a dense dimension with local compressed composites. In this way you can aggregate only those partitions that contain new data.</p>
</li>
</ul>
<p class="subhead2"><a id="OLADM2103"></a>Aggregation Options and System Properties</p>
<p>Several options can impact aggregation as outlined in <a href="dml_options.htm#CHDEGEDE">"Aggregation Options"</a>.</p>
<p>See <a href="dml_properties.htm#BABEIFHE">"System Properties by Category"</a> for a list of system properties that relate to aggregation or allocation.</p>
<p class="subhead2"><a id="OLADM2104"></a>Checking for Circularity</p>
<p>AGGREGATE automatically checks relations for circularity in and among multiple hierarchies. When you first define hierarchies, check for circularity by setting PRECOMPUTE statements to <code>NA</code> and AGGINDEX to <code>NO</code>. A XSHIERCK01 error during aggregation indicates that a circular hierarchy may have been detected. However, when the message includes a reference to UNDIRECTED, then multiple paths to an ancestor from a detail data cell have been detected. Some calculations require that a detail data cell use multiple paths to the same ancestor cell. When this is the case, then you must set the MULTIPATHHIER option to <code>YES</code> before you execute the AGGREGATE command. Otherwise, you must correct the error in the hierarchy structure. For more details about this error message and how to interpret it, see the <a href="dml_options057.htm#i79230">MULTIPATHHIER</a> option.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3558"></a>Examples</p>
<div id="OLADM2105" class="example">
<p class="titleinexample"><a id="i1026297"></a>Example 9-6 Combining Pre-calculation and Calculation on the Fly</p>
<p>This example describes the steps you can take to pre-calculate some data in your analytic workspace and specify that the rest should be calculated when users request it.</p>
<p>Suppose you define an analytic workspace named <code>mydtb</code> that has a <code>units</code> variable with the following definition.</p>
<pre>
DEFINE units INTEGER &lt;time, SPARSE &lt;product, geography&gt;&gt;
</pre>
<p>You now must create and add a specification to the aggmap, which specifies the data that should be aggregated. This example shows you how to use an input file, which contains OLAP DML statements that define the aggmap and add a specification to it:</p>
<ol>
<li>
<p>Identify the name of each dimension's hierarchy. When you have defined the hierarchies as self-relations, you use the names of the self-relations.</p>
</li>
<li>
<p>Decide which data to aggregate.</p>
<p>Suppose you want to calculate data for all levels of the <code>time</code> and <code>product</code> dimensions, but not for <code>geography</code>. The <code>geography</code> dimension's lowest level of data is at the city level. The second level of the hierarchy has three dimension values that represent regions: <code>East</code>, <code>Central</code>, and <code>West</code>. The third level of the hierarchy has one dimension value: <code>Total</code>.</p>
<p>Suppose that you want to pre-calculate the data for <code>East</code> and store it in the analytic workspace. You want the data for <code>Central</code>, <code>West</code>, and <code>Total</code> to be calculated only when users request that data &mdash; that data is not stored in the analytic workspace. Therefore, you must specify this information in the specification that you add to your aggmap object.</p>
</li>
<li>
<p>Create an ASCII text file named <code>units.txt</code>. Add the following OLAP DML statements to your text file.</p>
<pre>
DEFINE units.agg AGGMAP &lt;time, SPARSE &lt;product, geography&gt;&gt;
AGGMAP
RELATION myti.parent
RELATION mypr.parent
RELATION myge.parent PRECOMPUTE ('East')
END
</pre>
<p>The preceding statements define an aggmap named <code>units.agg</code>, then add the three RELATION statements to the aggregation specification when you read the units.txt file into your analytic workspace.</p>
</li>
<li>
<p>To read the <code>units.txt</code> file into your analytic workspace, execute the following statement.</p>
<pre>
INFILE 'inf/units.txt'
</pre></li>
<li>
<p>The <code>units.agg</code> aggmap should now exist in your analytic workspace. You can aggregate the <code>units</code> variable with the following statement.</p>
<pre>
AGGREGATE units USING units.agg
</pre>
<p>Now the data for <code>East</code> for all times and products has been calculated and stored in the analytic workspace.</p>
</li>
<li>
<p>Set up the analytic workspace so that when a user requests data for <code>Central</code>, <code>West</code>, or <code>Total</code>, that data is calculated and displayed. It is generally a good idea to compile the aggmap object before using it with the AGGREGATE function, as shown by the following statement.</p>
<pre>
COMPILE units.agg
</pre>
<p>This is not an issue when you are just using the AGGREGATE command, because this statement compiles the aggmap object before it uses it. However, when you do not use the FUNCDATA keyword with the AGGREGATE command, the metadata that is needed to perform calculation on the fly has not been compiled yet. If you have performed all other necessary calculations (such as calculating models), then it is a good practice to compile the aggmap when you load data. When you fail to do so, that means that every time a user opens the analytic workspace, that user has to wait for the aggregation to be compiled automatically. In other words, when any data is calculated on the fly, you can improve query performance for all of your users by compiling the aggmap before making the analytic workspace available to your users.</p>
</li>
<li>
<p>Add a property to the <code>units</code> variable.</p>
<pre>
CONSIDER units
PROPERTY '$NATRIGGER' 'AGGREGATE(units USING units.agg)'
</pre>
<p>This property indicates that when a data cell contains an <code>NA</code> value, Oracle OLAP calls the AGGREGATE function to aggregate the data for that cell. Therefore, any <code>units</code> data that is requested by a user displayed. However, only the data for the <code>East</code> dimension value of the <code>geography</code> dimension has actually been aggregated and stored in the analytic workspace. All other data (for <code>Central</code>, <code>West</code>, and <code>Total</code>) is calculated only when users request it.</p>
</li>
</ol>
</div>
<!-- class="example" -->
<div id="OLADM2106" class="example">
<p class="titleinexample"><a id="sthref3559"></a>Example 9-7 Performing Non-additive Aggregation</p>
<p>This example shows how to use operators and arguments to combine additive and non-additive aggregation.</p>
<p>Suppose that you have defined four variables: <code>sales</code>, <code>debt</code>, <code>interest_rate</code>, and <code>inventory</code>. The variables have been defined with the same dimensionality where <code>cp</code> is a composite that has been defined with the <code>product</code> and <code>geography</code> dimensions.</p>
<pre>
&lt;time cp&lt;product geography&gt;&gt;
</pre>
<pre>
</pre>
<p>Suppose you want to use one AGGREGATE command to aggregate all four variables. The <code>debt</code> variable requires additive aggregation. The <code>sales</code> variable requires a weighted sum aggregation, and <code>interest_rate</code> requires a hierarchical weighted average. Therefore, both <code>sales</code> and <code>interest_rate</code> require a weight object, which you must define and populate with weight values. <code>inventory</code> requires a result that represents the total inventory, which is the last value in the hierarchy.</p>
<p>You specify the aggregation operation for <code>debt</code> and <code>inventory</code> with the OPERATOR keyword. However, because <code>sales</code> and <code>interest_rate</code> have aggregation operations that require weight objects, you must use the ARGS keyword to specify their operations. You define an operator variable to use the OPERATOR keyword. Typically, the operator variable is dimensioned by a measure dimension or a line item dimension.</p>
<p>Here are the steps to define the aggregation you want to occur:</p>
<ol>
<li>
<p>Because you are also using a measure dimension to define an argument variable to use with the ARGS keyword, define that <code>measure</code> dimension, as illustrated by the following statements.</p>
<pre>
DEFINE measure DIMENSION TEXT
MAINTAIN measure 'sales', 'debt', 'interest_rate', 'inventory'
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Whenever you use a <code>measure</code> dimension in a RELATION statement, you must include a MEASUREDIM statement in the same aggregation specification</div>
</li>
<li>
<p>Define an operator variable named <code>opvar</code> and populate it.The statements specify that the aggregation for <code>debt</code> should use the <code>SUM</code> operator, and the aggregation for <code>inventory</code> should use the <code>HLAST</code> operator.</p>
<pre>
DEFINE opvar TEXT &lt;measure&gt;
opvar (measure 'sales') = 'WSUM'
opvar (measure 'debt') = 'SUM'
opvar (measure 'interest_rate') = 'HWAVERAGE'
opvar (measure 'inventory') = 'HLAST'
</pre></li>
<li>
<p>Because <code>sales</code> and <code>interest_rate</code> require weight objects, define and populate those weight objects. The following statement defines a weight object named <code>currency</code> (to be used by <code>sales</code>).</p>
<pre>
DEFINE currency DECIMAL &lt;time geography&gt;
</pre>
<p>Notice that the <code>currency</code> variable is dimensioned only by <code>time</code> and <code>geography</code>. The purpose of this variable is to provide weights that act as currency conversion information for foreign countries; therefore, it is unnecessary to include the <code>product</code> dimension.</p>
</li>
<li>
<p>Populate <code>currency</code> with the weight values that you want to use.</p>
</li>
<li>
<p>The <code>interest_rate</code> variable's nonaddictive aggregation (hierarchical weighted average) requires the sum of the variable <code>debt</code>. In other words, <code>interest_rate</code> cannot be aggregated without the results of the aggregation of <code>debt</code>.</p>
<p>You can now define an argument variable, which you must specify the aggregation results of <code>debt</code> as a weight object for <code>interest_rate</code>. You use the same argument variable to specify <code>currency</code> as the weight object for the <code>sales</code> variable. The following statement defines an argument variable named <code>argvar</code>.</p>
<pre>
DEFINE argvar TEXT &lt;measure&gt;
</pre></li>
<li>
<p>The next few statements populate the argument variable.</p>
<pre>
argvar (measure 'sales') = 'weightby currency'
argvar (measure 'debt') = NA
argvar (measure 'interest_rate') = 'weightby debt'
argvar (measure 'inventory') = NA
</pre></li>
<li>
<p>For the aggregation of <code>product</code> and <code>geography</code>, the data for the <code>sales</code>, <code>debt</code>, and <code>interest_rate</code> variables can simply be added. But the <code>inventory</code> variable requires a hierarchical weighted average. Consequently, it is necessary to define a second operator variable and a second argument variable, both of which are used in the RELATION statement for <code>product</code> and <code>geography</code>.</p>
<p>The following statements define the second operator variable and populate it.</p>
<pre>
DEFINE opvar2 TEXT &lt;measure&gt;
opvar (measure 'sales') = 'Sum'
opvar (measure 'debt') = 'Sum'
opvar (measure 'interest_rate') = 'Sum'
opvar (measure 'inventory') = 'HWAverage'
</pre>
<p>The following statements define the second argument variable and populate it.</p>
<pre>
DEFINE argvar2 TEXT &lt;measure&gt;
argvar (measure 'sales') = NA
argvar (measure 'debt') = NA
argvar (measure 'interest_rate') = NA
argvar (measure 'inventory') = 'weightby debt'
</pre></li>
<li>
<p>Now create the aggmap, by issuing the following statements.</p>
<pre>
DEFINE sales.agg AGGMAP &lt;time, CP&lt;product geography&gt;&gt;
AGGMAP
RELATION time.r OPERATOR opvar ARGS argvar
RELATION product.r OPERATOR opvar2 ARGS argvar2
RELATION geography.r OPERATOR opvar2 ARGS argvar2
MEASUREDIM measure
END
</pre></li>
<li>
<p>Finally, use the following statement to aggregate all four variables.</p>
<pre>
AGGREGATE sales debt interest_rate inventory USING sales.agg
</pre></li>
</ol>
</div>
<!-- class="example" -->
<div id="OLADM2107" class="example">
<p class="titleinexample"><a id="sthref3560"></a>Example 9-8 Programmatically Defining an Aggmap</p>
<p>The following program uses the EXISTS function to test whether an AGGMAP exists, and defines the AGGMAP when it does not. It then uses an AGGMAP statement to define the specification for the aggmap.</p>
<pre>
DEFINE MAKEAGGMAP PROGRAM
LD Create dynamic aggmap
PROGRAM
IF NOT EXISTS ('test.agg')
   THEN DEFINE test.agg AGGMAP &lt;geography product channel time&gt;
   ELSE CONSIDER test.agg
AGGMAP JOINLINES(-
   'RELATION geography.parentrel PRECOMPUTE (geography.lvldim 2 4)' -
   'RELATION product.parentrel' -
   'RELATION channel.parentrel' -
   'RELATION time.parentrel' -
   'END')
END
</pre></div>
<!-- class="example" -->
<div id="OLADM2108" class="example">
<p class="titleinexample"><a id="sthref3561"></a>Example 9-9 Creating an Aggmap Using an Input File</p>
<p>Suppose that you have created a disk file called <code>salesagg.txt</code>, which contains the following aggmap definition and specification.</p>
<pre>
DEFINE sales.agg AGGMAP &lt;time, product, geography&gt;
AGGMAP
RELATION time.r PRECOMPUTE (time NE 'Year99')
RELATION product.r PRECOMPUTE (product NE 'ALL')
RELATION geography.r
CACHE STORE
END
</pre>
<p>To include the <code>sales.agg</code> aggmap in your analytic workspace, execute the following statement, where <code>inf</code> is the alias for the directory where the file is stored.</p>
<pre>
INFILE 'inf/salesagg.txt'
</pre>
<p>The <code>sales.agg</code> aggmap has now been defined and contains the three RELATION statements and the CACHE statement. In this example, you are specifying that all of the data for the hierarchy for the <code>time</code> dimension, <code>time.r</code>, should be aggregated, except for any data that has a <code>time</code> dimension value of <code>Year99</code>. All of the data for the hierarchy for the <code>product</code> dimension, <code>product.r</code>, should be aggregated, except for any data that has a <code>product</code> dimension value of <code>All</code>. All <code>geography</code> dimension values are aggregated. The CACHE STORE statement specifies that any data that are rolled up on the fly should be calculated just once and stored in the cache for other access requests during the same session.</p>
<p>You can now use the <code>sales.agg</code> aggmap with an AGGREGATE command, such as.</p>
<pre>
AGGREGATE sales USING sales.agg
</pre>
<p>In this example, any data value that dimensioned by a <code>Year99</code> value of the <code>time</code> dimension or an <code>All</code> value of the <code>product</code> dimension is calculated on the fly. All other data is aggregated and stored in the analytic workspace.<a id="sthref3562"></a></p>
</div>
<!-- class="example" -->
<div id="OLADM2109" class="example">
<p class="titleinexample"><a id="i1037127"></a>Example 9-10 Using Multiple Aggmaps</p>
<p>When you use a forecast, you must ensure that all of the input data that is required by that forecast has been pre-calculated. Otherwise, the forecast uses incorrect or nonexistent data. For example, suppose your forecast requires that all line items are aggregated. Using a <code>budget</code> variable that is dimensioned by <code>time</code>, <code>line</code>, and <code>division</code>, one approach would be to perform a complete aggregation of the <code>line</code> dimension, forecast the <code>dimension of type DAY, WEEK, MONTH, QUARTER, or YEAR</code>, and then aggregate the remaining dimension, <code>division</code>.</p>
<p>You can support this processing by defining three aggmap objects:</p>
<ol>
<li>
<p>Define the first aggmap, named <code>forecast.agg1</code>, which aggregates the data needed by the forecast. It contains the following statement.</p>
<pre>
RELATION line.parentrel
</pre></li>
<li>
<p>Define the second aggmap, named <code>forecast.agg2</code>, which aggregates the data generated using the first aggmap and the forecast. It contains the following statement.</p>
<pre>
RELATION division.parentrel PRECOMPUTE ('L3')
</pre></li>
<li>
<p>Define the third aggmap, named <code>forecast.agg3</code>, which contains the RELATION statements in the specifications of the first two aggmaps.</p>
<pre>
RELATION line.parentrel
RELATION division.parentrel PRECOMPUTE ('L3')
</pre></li>
</ol>
<p>When your forecast is in a program named <code>fore.prg</code>, then you would use the following statements to aggregate the data.</p>
<pre>
AGGREGATE budget USING forecast.agg1   "Aggregate over LINE 
CALL fore.prg                          "Forecast over TIME
AGGREGATE budget USING forecast.agg2   "Aggregate over DIVISION
"Compile the limit map for LINE and DIVISION
COMPILE forecast.agg3
"Use the combined aggmap for the AGGREGATE function
CONSIDER budget
PROPERTY 'NATRIGGER' 'AGGREGATE(budget USING forecast.agg3)'
</pre></div>
<!-- class="example" -->
<div id="OLADM2110" class="example">
<p class="titleinexample"><a id="CHDIHJDJ"></a>Example 9-11 Using an AGGINDEX Statement in an Aggregation Specification</p>
<p>Suppose you have two variables, <code>sales1</code> and <code>sales2</code>, with the following definitions.</p>
<pre>
DEFINE sales1 DECIMAL &lt;time, SPARSE&lt;product, channel, customer&gt;&gt;
DEFINE sales2 DECIMAL &lt;time, SPARSE&lt;product, channel, customer&gt;&gt;
</pre>
<p>You do not want to precompute and commit all of the <code>sales</code> data to the database, because disk space is limited and you must improve performance. Therefore, you must create an aggmap, in which you specify which data should be pre-computed and which data should be calculated on the fly.</p>
<p>You define the aggmap, named <code>sales.agg</code>, with the following statement.</p>
<pre>
DEFINE sales.agg AGGMAP &lt;time, SPARSE&lt;product, channel, customer&gt;&gt;
</pre>
<p>Next, you use an AGGMAP statement to enter the following specification for <code>sales.agg</code>.</p>
<pre>
RELATION time.r PRECOMPUTE (time NE 'Year99')
RELATION product.r PRECOMPUTE (product NE 'All')
RELATION channel.r
RELATION customer.r
AGGINDEX NO
</pre>
<p>This aggregation specification tells Oracle OLAP that all <code>sales</code> data should be rolled up and committed to the database except for any data that has a <code>time</code> dimension value of <code>Year99</code> or a <code>product</code> dimension value of <code>All</code>&mdash;the data for those cells is calculated the first time a user accesses them. The AGGINDEX value of <code>NO</code> tells Oracle OLAP not to create the indexes for data that should be calculated on the fly.</p>
<p>Now you execute the following statement.</p>
<pre>
sales2 = AGGREGATE(sales1 USING sales.agg) ACROSS SPARSE -
   &lt;product, channel, customer&gt;
</pre>
<p><code>sales2</code> now contains all of the data in <code>sales1</code>, plus any data that is aggregated for <code>Year99</code>&mdash;this is because <code>time</code> is not included in a composite.</p>
<p>On the other hand, the data that is aggregated for the <code>product</code> value of <code>All</code> is not computed and stored in <code>sales2</code>. This data is not computed or stored because the <code>product</code> dimension is included in a composite&mdash;the indexes that are required for dimensions that are included in composites were not created because the aggregation specification contains an <code>AGGINDEX</code> <code>NO</code> statement. Because the indexes did not exist, Oracle OLAP never called the AGGREGATE function to compute the data to be calculated on the fly.</p>
</div>
<!-- class="example" -->
<div id="OLADM2111" class="example">
<p class="titleinexample"><a id="CHDIIIAC"></a><a id="i1027309"></a>Example 9-12 Aggregating By Dimension Attributes</p>
<p>Assume that when your business makes a sales it keeps records of the customer's name, sex, age, and the amount of the sale. To hold this data, your analytic workspace contains a dimension named <code>customer</code> and three variables (named <code>customer_sex</code>, <code>customer_age</code>, and <code>sales</code>) that are dimensioned by <code>customer</code>.</p>
<pre>
 REPORT W 14 &lt;customer_sex customer_age sales&gt;

CUSTOMER        CUSTOMER_SEX   CUSTOMER_AGE      SALES
-------------- -------------- -------------- --------------
Clarke         M                          26      26,000.00
Smith          M                          47      15,000.00
Ilsa           F                          24      33,000.00
Rick           M                          33      22,000.00
</pre>
<p>You want to aggregate the detail sales data over sex and age to calculate the amount of sales you have made to males and females, and the amount of sales for different age ranges. To hold this data you need an <code>INTEGER</code> variable that is dimensioned by hierarchical dimensions for sex and age. You also need an aggmap object that specifies the calculations that Oracle OLAP performs to populate this variable from the data in the <code>sales</code> variable.</p>
<p>To create and populate the necessary objects, you take the following steps:</p>
<ol>
<li>
<p>Create and populate dimensions and self-relations for hierarchical dimensions named <code>sex</code> and <code>age</code>.</p>
<pre>
DEFINE sex DIMENSION TEXT
DEFINE sex.parentrel RELATION sex &lt;sex&gt;
DEFINE age DIMENSION TEXT
DEFINE age.parentrel RELATION age &lt;age&gt;

AGE               AGE.PARENTREL
-------------- --------------------
0-20           All
21-30          All
31-50          All
51-100         All
No Response    All
All            NA

SEX               SEX.PARENTREL
-------------- --------------------
M              All
F              All
No Reponse     All
All            NA
</pre></li>
<li>
<p>Create and populate relations that map the <code>age</code> and <code>sex</code> dimensions to the <code>customer</code> dimension.</p>
<pre>
DEFINE customer.age.rel RELATION age &lt;customer&gt;
DEFINE customer.sex.rel RELATION sex &lt;customer&gt;

CUSTOMER         CUSTOMER.AGE.REL     CUSTOMER.SEX.REL
-------------- -------------------- --------------------
Clarke         21-30                M
Smith          31-50                M
Ilsa           21-30                F
Rick           31-50                M
</pre></li>
<li>
<p>Create a variable named <code>sales_by_sex_age</code> to hold the aggregated data. Like the <code>sales</code> variable this variable is of type DECIMAL, but it is dimensioned by <code>sex</code> and <code>age</code> rather than by <code>customer</code>.</p>
<pre>
DEFINE sales_by_sex_age VARIABLE DECIMAL &lt;sex age&gt;
</pre></li>
<li>
<p>Define an AGGMAP type aggmap object named <code>ssa_aggmap</code> to calculate the values of the <code>sales_by_sex_age</code> variable.</p>
<pre>
DEFINE SSA_AGGMAP AGGMAP
AGGMAP
RELATION sex.parentrel OPERATOR SUM
RELATION age.parentrel OPERATOR SUM
BREAKOUT DIMENSION customer -
BY customer.sex.rel, customer.age.rel OPERATOR SUM
END
</pre>
<p>Notice that the specification for the <code>ssa_aggmap</code> includes the following statements:</p>
<ul>
<li>
<p>A BREAKOUT DIMENSION statement that specifies how to map the <code>customer</code> dimension of the <code>sales</code> variable to the lowest-level values of the <code>sales_by_sex_age</code> variable. This statement specifies the name of the dimension of the variable that contains the detail values (that is, <code>customer</code>) and the names of the relations (<code>customer.sex.rel</code> and <code>customer.age.rel</code>) that define the relations between <code>customer</code> dimension and the <code>sex</code> and <code>age</code> dimensions.</p>
</li>
<li>
<p>Two RELATION statements that specify how to aggregate up the <code>sex</code> and <code>age</code> dimensions of the <code>sales_by_sex_age</code> variable. Each of these statements includes the name of the child-parent relation (<code>sex.parentrel</code> or <code>age.parentrel</code>) that define the self-relation for the hierarchal dimension (<code>sex</code> or <code>age</code>).</p>
</li>
</ul>
</li>
<li>
<p>Populate the <code>sales_by_sex_age</code> variable by issuing an AGGREGATE command that specifies that the detail data for the aggregation comes from the <code>sales</code> variable.</p>
<pre>
AGGREGATE sales_by_sex_age USING ssa_aggmap FROM sales 
</pre>
<p>After performing the aggregation, a report of <code>sales_by_sex_age</code> shows the calculated values.</p>
<pre>
               ---------------------SALES_BY_SEX_AGE----------------------
               ----------------------------SEX----------------------------
AGE                  M              F          No Reponse        All
-------------- -------------- -------------- -------------- --------------
0-20                       NA             NA             NA             NA
21-30               26,000.00      33,000.00             NA      59,000.00
31-50               37,000.00             NA             NA      37,000.00
51-100                     NA             NA             NA             NA
No Response                NA             NA             NA             NA
All                 63,000.00      33,000.00             NA      96,000.00
</pre></li>
</ol>
</div>
<!-- class="example" -->
<div id="OLADM2112" class="example">
<p class="titleinexample"><a id="CHDJJFED"></a>Example 9-13 Using a CACHE Statement in an Aggregation Specification</p>
<p>Suppose you have a <code>sales</code> variable with the following definition.</p>
<pre>
DEFINE sales DECIMAL &lt;time, SPARSE&lt;product, channel, customer&gt;&gt;
</pre>
<p>You do not want to pre-compute and commit all of the <code>sales</code> data, because space is limited and you must improve performance. Therefore, you must create an aggmap, in which you specify which data should be pre-computed and which data should be calculated on the fly.</p>
<p>You define the aggmap, named <code>sales.agg</code>, with the following statement.</p>
<pre>
DEFINE sales.agg AGGMAP &lt;time, SPARSE&lt;product, channel, - customer&gt;&gt;
</pre>
<p>Next, you use the AGGMAP statement to enter the following aggregation specification for<code>sales.agg</code>.</p>
<pre>
AGGMAP
RELATION time.r PRECOMPUTE (time NE 'YEAR99')
RELATION product.r PRECOMPUTE (product NE 'ALL')
RELATION channel.r
RELATION customer.r
CACHE SESSION
END
</pre>
<p>This aggregation specification tells Oracle OLAP that all <code>sales</code> data should be rolled up and committed, except for any cells that have a time dimension value of <code>Year99</code> or a product dimension value of <code>ALL</code>; the data for those cells is calculated the first time a user accesses them. Because the CACHE statement uses the SESSION keyword, that means that when those cells are calculated on the fly, the data is stored in the cache for the remainder of the Oracle OLAP session. That way, the next time a user accesses the same cell, the data does not have to be calculated again. Instead, the data is retrieved from the session cache.</p>
</div>
<!-- class="example" -->
<div id="OLADM2113" class="example">
<p class="titleinexample"><a id="CHDBDBFJ"></a>Example 9-14 Populating All Levels of a Hierarchy Except the Detail Level</p>
<p>Assume that your analytic workspace contains the relations and dimensions with the following definitions.</p>
<pre>
DEFINE geog.d TEXT DIMENSION
DEFINE geog.r RELATION geog.d &lt;geog.d&gt;
DEFINE sales_by_units   INTEGER VARIABLE &lt;geog.d&gt;
DEFINE sales_by_revenue DECIMAL VARIABLE &lt;geog.d&gt;
DEFINE price_per_unit   DECIMAL VARIABLE &lt;geog.d&gt;
</pre>
<p>Assume that you create two aggmap objects. One aggmap object, named <code>units_aggmap</code>, is the specification to aggregate data in the <code>sales_by_units</code> variable. The other aggmap object, <code>revenue_aggmap</code>, is the specification to calculate all of the data <span class="italic">except</span> the detail data in the <code>sales_by_revenue</code> variable.</p>
<pre>
DEFINE units_aggmap AGGMAP
AGGMAP
  RELATION geog.r OPERATOR SUM
END

DEFINE revenue_aggmap AGGMAP
AGGMAP
  RELATION geog.r OPERATOR WSUM ARGS WEIGHTBY price_per_unit
  CACHE NOLEAF
END
</pre>
<p>The following steps outline the aggregation process:</p>
<ol>
<li>
<p>Before either the <code>sales_by_unit</code> or <code>sales_by_revenue</code> variables are aggregated, they have the following values.</p>
<pre>
GEOG.D    SALES_BY_UNIT SALES_BY_REVENUE
--------- ------------- ----------------
Boston                1               NA
Medford               2               NA
San Diego             3               NA
Sunnydale             4               NA
MA                    NA              NA             
CA                    NA              NA
USA                   NA              NA
</pre></li>
<li>
<p>After the data for the <code>sales_by_unit</code> variable is aggregated, the <code>sales_by_unit</code> and <code>sales_by_revenue</code> variables have the following values.</p>
<pre>
AGGREGATE sales_by_unit    USING units_aggmap

GEOG.D    SALES_BY_UNIT SALES_BY_REVENUE
--------- ------------- ----------------
Boston                1               NA
Medford               2               NA
San Diego             3               NA
Sunnydale             4               NA
MA                    3               NA             
CA                    7               NA
USA                  10               NA
</pre></li>
<li>
<p>After the data for the <code>sales_by_revue</code> variable is aggregated, the <code>sales_by_unit</code> and <code>sales_by_revenue</code> variables have the following values.</p>
<pre>
AGGREGATE sales_by_revenue USING revenue_aggmap FROM units_aggmap

GEOG.D    SALES_BY_UNIT SALES_BY_REVENUE
--------- ------------- ----------------
Boston                1               NA
Medford               2               NA
San Diego             3               NA
Sunnydale             4               NA
MA                    3             13.5             
CA                    7             31.5
USA                  10             45.0
</pre></li>
</ol>
</div>
<!-- class="example" -->
<div id="OLADM2114" class="example">
<p class="titleinexample"><a id="CHDBHJHD"></a>Example 9-15 Aggregating into a Different Variable</p>
<p>Assume that there is a variable named <code>sales</code> that is dimensioned by <code>time</code>, a hierarchical dimension, and <code>district</code>, a non-hierarchical dimension.</p>
<pre>
DEFINE time DIMENSION TEXT
DEFINE time.parentrel RELATION time &lt;time&gt;
DEFINE district DIMENSION TEXT
DEFINE sales VARIABLE DECIMAL &lt;time district&gt;

             -----------------------SALES-----------------------
             ---------------------DISTRICT----------------------
TIME            North        South         West         East
------------ ------------ ------------ ------------ ------------
1976Q1         168,776.81   362,367.87   219,667.47   149,815.65
1976Q2         330,062.49   293,392.29   237,128.26   167,808.03
1976Q3         304,953.04   354,240.51   170,892.80   298,737.70
1976Q4         252,757.33   206,189.01   139,954.56   175,063.51
1976                   NA           NA           NA           NA
</pre>
<p>Assume also that you want to calculate the total sales for each quarter and year for all districts <span class="italic">except</span> the <code>North</code> district. To perform this calculation using an aggmap object, you take the following steps:</p>
<ol>
<li>
<p>Create a valueset named <code>not_north</code> that represents the values of <code>district</code> for which you want to aggregate data.</p>
<pre>
DEFINE not_north VALUESET district
LIMIT not_north TO ALL
LIMIT not_north REMOVE 'North'
</pre></li>
<li>
<p>Define a variable named <code>total_sales_exclud_north</code> to hold the results of the calculation.</p>
<pre>
DEFINE total_sales_exclud_north VARIABLE DECIMAL &lt;time&gt;
</pre>
<p>Notice that, like <code>sales</code>, the <code>total_sales_exclud_north</code> variable is dimensioned by time. However, unlike <code>sales</code>, the <code>total_sales_exclud_north</code> variable is not dimensioned by <code>district</code> because it holds detail data for each district, but only the total (aggregated) values for the <code>South</code>, <code>West</code>, and <code>East</code> districts (that is, all districts <span class="italic">except</span> <code>North</code>).</p>
<pre>
</pre></li>
<li>
<p>Define an aggmap object that specifies the calculation that you want performed.</p>
<pre>
DEFINE agg_sales_exclud_north AGGMAP
AGGMAP
RELATION time.parentrel OPERATOR SUM
DROP DIMENSION district OPERATOR SUM VALUES not_north
END
</pre>
<p>Notice that the aggregation specification consists of two statements that specify how to perform the aggregation:</p>
<ul>
<li>
<p>A RELATION statement that specifies how to aggregate up the hierarchical <code>time</code> dimension</p>
</li>
<li>
<p>A DROP DIMENSION statement that specifies how to aggregate across the non-hierarchical <code>district</code> dimension. In this case, the DROP DIMENSION also uses the <code>not_north</code> valueset to specify that values for the <code>North</code> district are excluded when performing the aggregation</p>
</li>
</ul>
</li>
<li>
<p>Aggregate the data.</p>
<pre>
AGGREGATE total_sales_exclud_north USING agg_sales_exclud_north FROM sales
</pre>
<p>The report of the <code>total_sales_exclud_north</code> variable shows the aggregated values.</p>
<pre>
TIME             ALL_SALES_EXCEPT_NORTH
------------ ------------------------------
1976Q1                           731,850.99
1976Q2                           698,328.58
1976Q3                           823,871.02
1976Q4                           521,207.09
1976                           2,775,257.69
</pre></li>
</ol>
</div>
<!-- class="example" -->
<div id="OLADM2115" class="example">
<p class="titleinexample"><a id="CHDHEIGA"></a>Example 9-16 Using a MEASUREDIM Statement in an Aggregation Specification</p>
<p>Suppose you have defined a measure dimension named <code>measure</code>. You then define an operation variable named <code>myopvar</code>, which is dimensioned by <code>measure</code>. When you use <code>myopvar</code> in an aggregation specification, you must also include a MEASUREDIM statement that identifies <code>measure</code> as the dimension is included in the definition of <code>myopvar</code>.</p>
<p>The MEASUREDIM statement should follow the last RELATION statement in the aggregation specification, as shown in the following example.</p>
<pre>
DEFINE sales.agg AGGMAP &lt;time, product, geography&gt;
AGGMAP
RELATION time.r OPERATOR myopvar
RELATION product.r
RELATION geography.r
MEASUREDIM measure
END 
</pre></div>
<!-- class="example" -->
<div id="OLADM2116" class="example">
<p class="titleinexample"><a id="CHDEEHBB"></a><a id="BABJFHCA"></a>Example 9-17 Solving a Model in an Aggregation</p>
<p>This example uses the <code>budget</code> variable.</p>
<pre>
DEFINE budget VARIABLE DECIMAL &lt;line time&gt;
LD Budgeted $ Financial
</pre>
<p>The <code>time</code> dimension has two hierarchies (<code>Standard</code> and <code>YTD</code>) and a parent relation named <code>time.parentrel</code> as follows.</p>
<pre>
               -----TIME.PARENTREL------
               ----TIME.HIERARCHIES-----
TIME             Standard       YTD
-------------- ------------ ------------
Last.YTD       NA           NA
Current.YTD    NA           NA
Jan01          Q1.01        Last.YTD
...
Dec01          Q4.01        Last.YTD
Jan02          Q1.02        Current.YTD
Feb02          Q1.02        Current.YTD
Mar02          Q1.02        Current.YTD
Apr02          Q2.02        Current.YTD
May02          Q2.02        Current.YTD
Q1.01          2001         NA
...
Q4.01          2001         NA
Q1.02          2002         NA
Q2.02          2002         NA
2001           NA           NA
2002           NA           NA
</pre>
<p>The relationships among line items are defined in the following model.</p>
<pre>
DEFINE income.budget MODEL
MODEL
DIMENSION line time
opr.income = gross.margin - marketing
gross.margin = revenue - cogs
revenue = LAG(revenue, 12, time) * 1.02
cogs = LAG(cogs, 1, time) * 1.01
marketing = LAG(opr.income, 1, time) * 0.20
END
</pre>
<p>The following aggregation specification pre-aggregates all of the data. Notice that all of the data must be pre-aggregated because the model includes both LAG functions and a simultaneous equation.</p>
<pre>
DEFINE budget.aggmap1 AGGMAP
AGGMAP
MODEL income.budget
RELATION time.parentrel
END
</pre></div>
<!-- class="example" -->
<div id="OLADM2117" class="example">
<p class="titleinexample"><a id="CHDEHECG"></a><a id="i1016915"></a>Example 9-18 Aggregating Up a Hierarchy</p>
<p>Suppose you define a <code>sales</code> variable with the following statement.</p>
<pre>
DEFINE sales VARIABLE &lt;time, SPARSE &lt;product, geography&gt;&gt;
</pre>
<p>The aggregation specification for <code>sales</code> might include RELATION statements like the following.</p>
<pre>
AGGMAP
RELATION time.r PRECOMPUTE ('Yr98', 'Yr99')
RELATION product.r
RELATION geography.r PRECOMPUTE (geography NE 'Atlanta')
END
</pre>
<p>The AGGREGATE command aggregates values for <code>Yr98</code> and <code>Yr99</code>, over all of products, and over all geographic areas except for <code>Atlanta</code>. All other aggregates are calculated on the fly.</p>
</div>
<!-- class="example" -->
<div id="OLADM2118" class="example">
<p class="titleinexample"><a id="sthref3563"></a>Example 9-19 Using Valuesets</p>
<p>Suppose you have a hierarchy dimension named time.type, whose dimension values are <code>Fiscal</code> and <code>Calendar</code>, in that order. These hierarchies are in conflict, and you want to precompute some <code>time</code> data but calculate the rest on the fly. Because the <code>Calendar</code> hierarchy is the last dimension value in the hierarchy dimension, consequently, you must define a valueset to get the correct results for the <code>Fiscal</code> hierarchy.</p>
<p>First, use the following statements to define and populate a valueset.</p>
<pre>
DEFINE time.vs VALUESET time
LIMIT time.vs TO 'Calendar' 'Fiscal'
</pre>
<p>You can then use the valueset in the following RELATION statement. Because the Fiscal hierarchy is the last hierarchy in the valueset, the data that is aggregated is accurate for the Fiscal hierarchy.</p>
<pre>
RELATION time.r(time.vs) PRECOMPUTE ('Yr99', 'Yr00')
</pre></div>
<!-- class="example" -->
<div id="OLADM2119" class="example">
<p class="titleinexample"><a id="sthref3564"></a>Example 9-20 Aggregating with a RELATION Statement That Uses an ARGS Keyword</p>
<p>You can list the arguments in a RELATION statement directly in the statement or as the value of a text variable. For example, the following statement specifies <code>WEIGHTBY wobj</code> as an argument.</p>
<pre>
RELATION time.r OPERATOR wsum ARGS WEIGHTBY wobj
</pre>
<p>Alternatively, you can define an variable for the argument whose value is the text of the WEIGHTBY clause.</p>
<pre>
DEFINE argvar TEXT
argvar = 'WEIGHTBY wobj'
</pre>
<p>Then the RELATION statement can specify the text variable that contains the WEIGHTBY clause.</p>
<pre>
RELATION time.r OPERATOR WSUM ARGS argvar
</pre></div>
<!-- class="example" -->
<div id="OLADM2120" class="example">
<p class="titleinexample"><a id="i87187"></a>Example 9-21 Aggregating Using a Measure Dimension</p>
<p>Suppose you want to use a single AGGREGATE command to aggregate the <code>sales</code>, <code>units</code>, <code>price</code>, and <code>inventory</code> variables. When you want to use the same operator for each variable, then you do not have to use a measure dimension. However, when you want to specify different aggregation operations, then you must use a measure dimension.</p>
<p>The following statement defines a dimension named <code>measure</code>.</p>
<pre>
DEFINE measure DIMENSION TEXT
</pre>
<p>You can then use a MAINTAIN statement to add dimension values to the <code>measure</code> dimension.</p>
<pre>
MAINTAIN measure ADD 'sales', 'units', 'quota', 'inventory'
</pre>
<p>Use the <code>measure</code> dimension to dimension a text variable named <code>meas.opvar</code> that you use as the operator variable.</p>
<pre>
DEFINE meas.opvar TEXT WIDTH 2 &lt;measure&gt;
</pre>
<p>The following statements add values to OPVAR</p>
<pre>
meas.opvar (measure 'sales') = 'SU'
meas.opvar (measure 'units') = 'SU'
meas.opvar (measure 'price') = 'HA'
meas.opvar (measure 'inventory') = 'HL'
</pre>
<p>The aggregation specification might look like the following. Note that when you specify an operator variable in a RELATION statement, you must include a MEASUREDIM statement that specifies the name of the measure dimension (<code>measure</code> in the following example) in the aggregation specification.</p>
<pre>
DEFINE opvar.aggmap AGGMAP
AGGMAP
RELATION geography.parentrel PRECOMPUTE (geography.lvldim 2 4)
RELATION product.parentrel OPERATOR opvar
RELATION channel.parentrel OPERATOR opvar
RELATION time.parentrel OPERATOR opvar
MEASUREDIM measure
END
</pre></div>
<!-- class="example" -->
<div id="OLADM2121" class="example">
<p class="titleinexample"><a id="i87198"></a>Example 9-22 Aggregating Using a Line Item Dimension</p>
<p>Suppose you have two variables, <code>actual</code> and <code>budget</code>, that have these dimensions.</p>
<pre>
&lt;time line division&gt;
</pre>
<p>You want to use different methods to calculate different line items. You create a text variable that you use as the operator variable.</p>
<pre>
DEFINE line.opvar TEXT WIDTH 2 &lt;line&gt;
</pre>
<p>You then populate <code>line.opvar</code> with the appropriate operator for each line item, for example.</p>
<pre>
line.opvar (line 'Net.Income') = 'SU'
line.opvar (line 'Tax.Rate') = 'AV'
</pre>
<p>&nbsp;The aggregation specification might look like this.</p>
<pre>
DEFINE LINE.AGGMAP AGGMAP
AGGMAP
RELATION time.parentrel OPERATOR line.opvar
RELATION division.parentrel
END
</pre></div>
<!-- class="example" -->
<div id="OLADM2122" class="example">
<p class="titleinexample"><a id="CHDCAEBD"></a>Example 9-23 Skip-Level Aggregation</p>
<p>Suppose you want to aggregate <code>sales</code> data. The <code>sales</code> variable is dimensioned by <code>geography</code>, <code>product</code>, <code>channel</code>, and <code>time</code>.</p>
<p>First, consider the hierarchy for each dimension. How many levels does each hierarchy have? What levels of data do users typically query? When you are designing a new workspace, what levels of data do your users plan to query?</p>
<p>Suppose you learn the information described in the following table about how users tend to query <code>sales</code> data for the <code>time</code> hierarchy.</p>
<div class="inftblinformal">
<table class="cellalignment3100" title="How Users Query sales Data for the time Hierarchy" summary="This table summarizes how users in this example query data in the sales variable over the time hierarchy." dir="ltr">
<thead>
<tr class="cellalignment3089">
<th class="cellalignment3099" id="r1c1-t18">Time Level Names</th>
<th class="cellalignment3099" id="r1c2-t18">Descriptive Level Name</th>
<th class="cellalignment3099" id="r1c3-t18">Examples of Dimension Values</th>
<th class="cellalignment3099" id="r1c4-t18">Do users query this level often?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r2c1-t18" headers="r1c1-t18">L1</td>
<td class="cellalignment3095" headers="r2c1-t18 r1c2-t18">Year</td>
<td class="cellalignment3095" headers="r2c1-t18 r1c3-t18"><code>Year99</code>, <code>Year00</code></td>
<td class="cellalignment3095" headers="r2c1-t18 r1c4-t18">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r3c1-t18" headers="r1c1-t18">L2</td>
<td class="cellalignment3095" headers="r3c1-t18 r1c2-t18">Quarter</td>
<td class="cellalignment3095" headers="r3c1-t18 r1c3-t18"><code>Q3.99</code>, <code>Q3.99</code>, <code>Q1.00</code></td>
<td class="cellalignment3095" headers="r3c1-t18 r1c4-t18">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r4c1-t18" headers="r1c1-t18">L3</td>
<td class="cellalignment3095" headers="r4c1-t18 r1c2-t18">Month</td>
<td class="cellalignment3095" headers="r4c1-t18 r1c3-t18"><code>Jan99</code>, <code>Dec00</code></td>
<td class="cellalignment3095" headers="r4c1-t18 r1c4-t18">yes</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>While the next table shows how your users tend to query <code>sales</code> data for the <code>geography</code> hierarchy.</p>
<div class="inftblinformal">
<table class="cellalignment3100" title="How Users Query sales Data for the geography Hierarchy" summary="This table summarizes how users in this example query data in the sales variable over the geography hierarchy." dir="ltr">
<thead>
<tr class="cellalignment3089">
<th class="cellalignment3099" id="r1c1-t19">Geography Level Names</th>
<th class="cellalignment3099" id="r1c2-t19">Descriptive Level Name</th>
<th class="cellalignment3099" id="r1c3-t19">Examples of Dimension Values</th>
<th class="cellalignment3099" id="r1c4-t19">Do users query this level often?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r2c1-t19" headers="r1c1-t19">L1</td>
<td class="cellalignment3095" headers="r2c1-t19 r1c2-t19">World</td>
<td class="cellalignment3095" headers="r2c1-t19 r1c3-t19"><code>World</code></td>
<td class="cellalignment3095" headers="r2c1-t19 r1c4-t19">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r3c1-t19" headers="r1c1-t19">L2</td>
<td class="cellalignment3095" headers="r3c1-t19 r1c2-t19">Continent</td>
<td class="cellalignment3095" headers="r3c1-t19 r1c3-t19"><code>Europe, Americas</code></td>
<td class="cellalignment3095" headers="r3c1-t19 r1c4-t19">no</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r4c1-t19" headers="r1c1-t19">L3</td>
<td class="cellalignment3095" headers="r4c1-t19 r1c2-t19">Country</td>
<td class="cellalignment3095" headers="r4c1-t19 r1c3-t19"><code>Hungary, Spain</code></td>
<td class="cellalignment3095" headers="r4c1-t19 r1c4-t19">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r5c1-t19" headers="r1c1-t19">L4</td>
<td class="cellalignment3095" headers="r5c1-t19 r1c2-t19">City</td>
<td class="cellalignment3095" headers="r5c1-t19 r1c3-t19"><code>Budapest, Madrid</code></td>
<td class="cellalignment3095" headers="r5c1-t19 r1c4-t19">yes</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>Finally, the next table shows how your users tend to query <code>sales</code> data for the <code>product</code> dimension hierarchy.</p>
<div class="inftblinformal">
<table class="cellalignment3100" title="How Users Use the Product Dimension" summary="This table shows how users use the product dimension." dir="ltr">
<thead>
<tr class="cellalignment3089">
<th class="cellalignment3099" id="r1c1-t20">Product Level Names</th>
<th class="cellalignment3099" id="r1c2-t20">Descriptive Level Name</th>
<th class="cellalignment3099" id="r1c3-t20">Examples of Dimension Values</th>
<th class="cellalignment3099" id="r1c4-t20">Do users query this level often?</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r2c1-t20" headers="r1c1-t20">L1</td>
<td class="cellalignment3095" headers="r2c1-t20 r1c2-t20">All Products</td>
<td class="cellalignment3095" headers="r2c1-t20 r1c3-t20"><code>Totalprod</code></td>
<td class="cellalignment3095" headers="r2c1-t20 r1c4-t20">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r3c1-t20" headers="r1c1-t20">L2</td>
<td class="cellalignment3095" headers="r3c1-t20 r1c2-t20">Division</td>
<td class="cellalignment3095" headers="r3c1-t20 r1c3-t20"><code>Audiodiv, Videodiv</code></td>
<td class="cellalignment3095" headers="r3c1-t20 r1c4-t20">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r4c1-t20" headers="r1c1-t20">L3</td>
<td class="cellalignment3095" headers="r4c1-t20 r1c2-t20">Category</td>
<td class="cellalignment3095" headers="r4c1-t20 r1c3-t20"><code>TV, VCR</code></td>
<td class="cellalignment3095" headers="r4c1-t20 r1c4-t20">yes</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r5c1-t20" headers="r1c1-t20">L4</td>
<td class="cellalignment3095" headers="r5c1-t20 r1c2-t20">Product</td>
<td class="cellalignment3095" headers="r5c1-t20 r1c3-t20"><code>Tuner, CDplayer</code></td>
<td class="cellalignment3095" headers="r5c1-t20 r1c4-t20">yes</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>Using this information about how users query data, use the following strategy for aggregation:</p>
<ul>
<li>
<p>Fully aggregate <code>time</code> and <code>product</code> because all levels are queried frequently.</p>
</li>
<li>
<p>For the <code>geography</code> dimension, aggregate data for <code>L1</code> (<code>World</code>) and <code>L3</code> (<code>Country</code>) because they are queried frequently. However, <code>L2</code> is queried less often and so can be calculated on the fly.</p>
</li>
</ul>
<p>The lowest level of data was loaded into the analytic workspace. The aggregate data is calculated from this source data.</p>
<p>Therefore, the aggregation specification might look like the following.</p>
<pre>
RELATION time.parentrel
RELATION geography.parentrel PRECOMPUTE (geog.leveldim 'L3' 'L1')
RELATION product.parentrel
</pre></div>
<!-- class="example" -->
<div id="OLADM2123" class="example">
<p class="titleinexample"><a id="sthref3565"></a>Example 9-24 Aggregation Specification with RELATION Statements That Include PRECOMPUTE Clauses</p>
<p>This aggregation specification uses PRECOMPUTE clauses in the RELATION statements to limit the data that is aggregated by the AGGREGATE command.</p>
<pre>
DEFINE gpct.aggmap AGGMAP
LD Aggmap for sales, units, quota, costs
AGGMAP
RELATION geography.parentrel PRECOMPUTE (geography.levelrel 'L3')
RELATION product.parentrel PRECOMPUTE (LIMIT(product complement 'TotalProd'))
RELATION channel.parentrel
RELATION time.parentrel PRECOMPUTE (time NE '2001')
END
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" -->
<div id="OLADM728" class="refsect2"><a id="i78730"></a>
<hr />
<h2 class="refsect2">AGGINDEX</h2>
<p>Within an aggregation specification, an<a id="ABC1044925"></a> AGGINDEX statement tells Oracle OLAP whether the compilation of that aggmap should create indexes (meaning, composite tuples) for data cells that are calculated on the fly by the AGGREGATE function. Therefore, the AGGINDEX statement has an effect on a dimension that is included in a composite but it has no effect on a dimension that is not included in a composite.</p>
<p>These indexes are used by the MODEL statement in an AGGMAP and by statements that use the ACROSS phrase to help Oracle OLAP loop over variables that are dimensioned by composites. These statements expect all data to be calculated. When you specify calculating some data on the fly, that data appears to be missing. When you set AGGINDEX to <code>YES</code>, then the statements try to access the missing data whether or not you are using the AGGREGATE function to perform calculation on the fly (meaning, you have added to the variable whose data is being aggregated an <code>NA</code> trigger property that calls the AGGREGATE function).</p>
<p>When the indexes have been created and you use AGGREGATION with the AGGREGATE function, then when MODEL (or a statement that uses the ACROSS phrase) requests the missing data, that data is calculated on the fly. That means that the results of the MODEL (or other statement) are correct, because the statement has all of the data that it needs.</p>
<p>When these indexes have not been created, the missing data cannot be calculated. Consequently, the statements that need the indexes interpret the missing data as <code>NA</code> data, even when you use the AGGREGATE function.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3566"></a>Syntax</p>
<p class="synopsis">AGGINDEX&nbsp;{<span class="underline">YES</span>|NO}</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3567"></a>Parameters</p>
<dl>
<dt>YES</dt>
<dd>
<p>(Default) Tells the AGGMAP compiler to ensure that all possible indexes are created whenever an aggmap is recompiled. In other words, indexes are created both for the data that is being pre-calculated and the data that is calculated on the fly. Data is recalculates on the fly happens when a COMPILE statement compiles the aggmap and when the AGGREGATE command executes an aggmap whose specification has changed since the last time it was compiled. The creation of all possible indexes results in a longer compilation time but faster execution of the AGGREGATE function. For a discussion of when AGGINDEX should be set to YES, see <a href="#BCFCAAFB">"When To Use an AGGINDEX Value of YES"</a>.</p>
</dd>
<dt>NO</dt>
<dd>
<p>Does not create the indexes for data that is calculated on the fly. Omitting the creation of these index values accelerates the compilation time, but causes Oracle OLAP to treat the uncomputed data as <code>NA</code> data whenever the MODEL statement in an AGGMAP or an ACROSS phrase is executed. For a discussion of when AGGINDEX should be set to NO, see <a href="#BCFDJFEG">"When To Use an AGGINDEX Value of NO"</a>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3568"></a>Usage Notes</p>
<p class="subhead2"><a id="BCFCAAFB"></a><a id="OLADM2124"></a>When To Use an AGGINDEX Value of YES</p>
<p>The primary advantage to using an AGGINDEX value of <code>YES</code> is that then Oracle OLAP always try to access data that you have specified to be calculated on the fly. When you have created an $NATRIGGER property for a variable that calls the AGGREGATE function, the variable appears to have been fully precomputed. That means that when any <code>NA</code> value is encountered, the <code>NA</code> trigger is called during the execution of an ACROSS phrase or the MODEL statement in an AGGMAP. When the <code>NA</code> trigger is called, the AGGREGATE function is executed, and the data is calculated on the fly.</p>
<p>When AGGINDEX has a value of <code>NO</code>, then the <code>NA</code> trigger is called only to aggregate data for dimensions that are not included in a composite. Data for dimensions that are included in composites is interpreted as <code>NA</code> values.</p>
<p>For example, suppose you have two variables called <code>sales1</code> and <code>sales2</code>, which are defined with the following definitions.</p>
<pre>
DEFINE sales1 DECIMAL &lt;time, SPARSE &lt;product, geography&gt;&gt;
DEFINE sales2 DECIMAL &lt;time, SPARSE &lt;product, geography&gt;&gt;
</pre>
<p>Now suppose you have an aggmap object named <code>sales.agg</code>, which has the following definition.</p>
<pre>
DEFINE sales.agg AGGMAP &lt;time, SPARSE &lt;product, geography&gt;&gt;
</pre>
<p>When you add a specification to the <code>sales.agg</code> aggmap, you enter RELATION statements for <code>time</code>, <code>product</code> and <code>geography</code> with <code>PRECOMPUTE</code> clauses that specify <code>NA</code> which specifies that no data is aggregated&mdash;instead, all of the data for any variable that uses this aggmap is calculated on the fly.</p>
<pre>
RELATION time.r PRECOMPUTE (NA)
RELATION product.r PRECOMPUTE (NA)
RELATION geography.r PRECOMPUTE (NA)
</pre>
<p>Now attach the following $NATRIGGER property to the <code>sales1</code> variable.</p>
<pre>
CONSIDER sales1
PROPERTY '$NATRIGGER' 'AGGREGATE(sales1 USING sales.agg)'
</pre>
<p>Consider the effect of AGGINDEX in the following statement. Because you did not enter an AGGINDEX statement in the <code>sales.agg</code> aggregation specification, the default of AGGINDEX <code>YES</code> is assumed.</p>
<pre>
sales2 = sales1 ACROSS SPARSE &lt;product, geography&gt;
</pre>
<p>This statement loops over the data in <code>sales1</code> and copies the values into <code>sales2</code>. This statement causes the <code>NA</code> trigger to call the AGGREGATE function for all of the data that you have specified to be calculated on the fly in <code>sales1</code>. Consequently, after the aggregation that <code>sales2</code> contains a copy of <code>sales1</code> plus all the aggregate data cells (the cells that would have been calculated if the <code>sales1</code> data had been completely precomputed, meaning, fully rolled up).</p>
<p>However, when you put an AGGINDEX <code>NO</code> statement in the <code>sales.agg</code> aggregation specification, then <code>sales2</code> contains a copy of the data in <code>sales1</code> and the aggregate data cells for the <code>time</code> dimension.</p>
<p>Note that in both cases, $NATRIGGER is called to aggregate <code>time</code> data, because the <code>time</code> dimension is not included in the composite, so the value of AGGINDEX has no effect on it.</p>
<p class="subhead2"><a id="BCFDJFEG"></a><a id="OLADM2125"></a>When To Use an AGGINDEX Value of NO</p>
<p>You can use an AGGINDEX value of <code>NO</code> when you know that either of the following is true:</p>
<ul>
<li>
<p>Your application does not contain an ACROSS phrase or a MODEL statement in an AGGMAP command.</p>
</li>
<li>
<p>The results of your MODEL statements or ACROSS phrases are additive, and data that needs to be aggregated can be calculated safely on the fly.</p>
</li>
</ul>
<p>Each of the preceding cases ensures that the data that you have specified to be calculated on the fly is available at the appropriate time.</p>
<p>By setting AGGINDEX to <code>NO</code>, the size of the indexes is reduced, and overall application performance improves.</p>
<p class="subhead2"><a id="OLADM2126"></a>When Using an AGGINDEX Value Of NO Causes Problems</p>
<p>When you run a MODEL that assumes all data that should be aggregated has been aggregated, then you may get <code>NA</code> data where real data should occur. For instance, suppose you have a variable that has a composite that includes the <code>time</code> dimension. You perform a calculation that subtracts the fourth quarter from the total for the year. When the value of <code>Year</code> is to be calculated dynamically, and the AGGINDEX statement is set to <code>NO</code>, then the result of the calculation is <code>NA</code>. When the value of <code>Year</code> was precomputed or when AGGINDEX is set to <code>YES</code>, then the MODEL correctly calculates a result equal to the sum of the first three quarters.</p>
<p class="subhead2"><a id="OLADM2127"></a>Index Creation Is Based on Existing Data</p>
<p>Only the indexes that are needed to aggregate existing data are created when AGGINDEX has a value of <code>YES</code>. For example, suppose one dimension in your composite is a dimension named <code>time</code>. The lowest-level data for the <code>time</code> dimension is at the monthly level. Therefore, the dimension values that are associated with the lowest-level data are <code>Jan99</code>, <code>Feb99</code>, and so on. The monthly data aggregates to quarters and to years. Suppose you have data for the first six months of the year. When AGGINDEX has a value of <code>YES</code>, indexes are created for the <code>Q1</code>, <code>Q2</code>, and <code>Yr99</code> dimension values, but not for <code>Q3</code> and <code>Q4</code>.</p>
<p class="subhead2"><a id="OLADM2128"></a>Reducing Compilation Time When AGGINDEX is YES</p>
<p>One disadvantage of using the default of AGGINDEX <code>YES</code> is that the compilation of the aggmap takes a longer time to complete. You can eliminate the cost of this extra time by using the <code>FUNCDATA</code> keyword with the AGGREGATE command. When you use the <code>FUNCDATA</code> keyword, all possible indexes (regardless of how you have limited your data) are created. However, do not use the <code>FUNCDATA</code> keyword when you use a different aggmap to execute the AGGREGATE command and the AGGREGATE function.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3569"></a>Examples</p>
<p>For an example of using an AGGINDEX statement, see <a href="#CHDIHJDJ">Example 9-11, "Using an AGGINDEX Statement in an Aggregation Specification"</a>.<a id="sthref3570"></a></p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM729" class="refsect2"><a id="i1018970"></a>
<hr />
<h2 class="refsect2">BREAKOUT DIMENSION</h2>
<p>Within an aggregation specification, a BREAKOUT DIMENSION statement specifies how a dimension of the target variable maps to one or more dimensions of the source variable. You use this statement in an aggregation specification when you are aggregating the detail data from one variable (the source variable) into another variable (the target variable) that has a different dimension (that is, a "breakout" dimension) than the variable that contains the detail data.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3571"></a>Syntax</p>
<p class="synopsis">BREAKOUT DIMENSION <span class="italic">dimname</span> BY <span class="italic">relation</span> [, <span class="italic">relation</span>...] -</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OPERATOR <span class="italic">operation</span> [ARGS&nbsp;<span class="italic">argument</span>]</p>
<p>where:</p>
<p><span class="syntaxinlineitalic">relation</span> has the following syntax:</p>
<p class="synopsis"><span class="italic">relationname</span> [IGNORE <span class="italic">ignore_dim_value</span> [DEFAULT <span class="italic">default_dim_value</span>]]</p>
<p><span class="syntaxinlineitalic">argument</span> specifies the settings of various options and is one or more of the following phrases:</p>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="syntaxinline">DIVIDEBYZERO {YES|NO}</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="syntaxinline">DECIMALOVERFLOW {YES|NO}</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="syntaxinline">NASKIP {YES|NO}</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="syntaxinline">WEIGHTBY&nbsp;[WNAFILL {</span><span class="syntaxinlineitalic">number</span> <span class="syntaxinline">| NA}]</span> <span class="syntaxinlineitalic">wobj</span></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3572"></a>Parameters</p>
<dl>
<dt><span class="italic">dimname</span></dt>
<dd>
<p>The name of a dimension in the variable that contains the detail data (that is, the source variable).</p>
</dd>
<dt><span class="italic">relationname</span></dt>
<dd>
<p>The name of a relation whose values relate a dimension of the target variable to <span class="italic">dimname</span>.</p>
</dd>
<dt>IGNORE <span class="italic">ignore_dim_value</span></dt>
<dd>
<p>Specifies that if the target dimension is QDRd to the value specified by <span class="italic">ignore_dim-value</span> then AGGREGATE does not use the relation specified by <span class="italic">relationname</span> to limit the source dimension.</p>
</dd>
<dt>DEFAULT <span class="italic">default_dim_value</span></dt>
<dd>
<p>Specifies that if all relations have an IGNORE phrase, then AGGREGATE uses the value specified by <span class="italic">default_dim-value</span> value to create a QDR rather than using a relation. If all relations have an IGNORE phrase and you do not include a DEFAULT phrase, the AGGREGATE arbitrarily chooses a relationship to limit by.</p>
<p>when <span class="italic">dimname</span> is QDRd to the dimension value specified by <span class="italic">ignore_dim-value</span> then AGGREGATE does not use the relation specified by <span class="italic">relationname</span> to limit the source dimension</p>
</dd>
<dt>OPERATOR</dt>
<dd>
<p>Identifies the calculation method used to aggregate the data.</p>
</dd>
<dt><span class="italic">operation</span></dt>
<dd>
<p>A keyword that describes the type of aggregation to perform. The keywords are listed in <a href="#g1028397">Table 9-1, "Aggregation Methods"</a>.</p>
</dd>
<dt>ARGS</dt>
<dd>
<p>Indicates optional handling of the aggregation.</p>
</dd>
<dt>DIVIDEBYZERO</dt>
<dd>
<p>Specifies whether to allow division by zero.</p>
<p><span class="syntaxinlinebold">YES</span> allows division by zero; a statement involving division by zero executes without error but produces <code>NA</code> results.</p>
<p><span class="syntaxinlinebold">NO</span> disallows division by zero; a statement involving division by zero stops executing and produces an error message.</p>
<p>The default value is the current value of the DIVIDEBYZERO option.</p>
</dd>
<dt>DECIMALOVERFLOW</dt>
<dd>
<p>Specifies whether to allow decimal overflow, which occurs when the result of a calculation is very large and can no longer be represented by the exponent portion of the numeric representation. Specify <span class="syntaxinlinebold">YES</span> to allow overflow, which means that a calculation that generates overflow executes without error and produces <code>NA</code> results. Specify <span class="syntaxinlinebold">NO</span> to disallow overflow, which means that; a calculation involving overflow stops executing and generates an error message. The default value is the current value of the DECIMALOVERFLOW option.</p>
</dd>
<dt>NASKIP</dt>
<dd>
<p>Specifies whether <code>NA</code> values are input. Specify <span class="syntaxinlinebold">YES</span> when you want Oracle OLAP to ignore <code>NA</code> values when aggregating which means that only actual values are used in calculations. Specify <span class="syntaxinlinebold">NO</span> when you want Oracle OLAP to consider <code>NA</code> values are considered which means that when any of the values being considered are <code>NA</code>, the calculation returns <code>NA</code>.The default value is the current value of the NASKIP option.</p>
<p>The value that you specify for the NASKIP phrase does <span class="italic">not</span> effect calculation performed when you specify HAVERAGE, HFIRST, HLAST, HWAVERAGE, HWFIRST, HWLAST for <span class="italic">operation</span>.</p>
</dd>
<dt>WEIGHTBY</dt>
<dd>
<p>Indicates that weighted aggregation is to be performed. You must include a WEIGHTBY clause when you specify HWAVERAGE, HWFIRST, HWLAST, SSUM, WAVERAGE, WFIRST, WLAST, or WSUM for <span class="italic">operation</span>. The WEIGHTBY phrase always includes a <span class="italic">wobj</span> argument and can optionally include the WNAFILL keyword. For more information about the use of the WEIGHTBY phrase, see <a href="#i1017474">RELATION (for aggregation)</a> statement of the AGGMAP command.</p>
</dd>
<dt>WNAFILL</dt>
<dd>
<p>Indicates handling for <code>NA</code> values. The default values for WNAFILL vary depending on the value of operation.</p>
</dd>
<dt><span class="syntaxinlineboldital">number</span></dt>
<dd>
<p>Substitutes a number for every <code>NA</code> value. That number replaces every <code>NA</code> value in the weight object, weight formula, or weight relation. The default for HWAVERAGE and SSUM is The default for HWFIRST, HWLAST, WAVERAGE, WFIRST, WLAST, and WSUM is <code>1.0</code> .</p>
</dd>
<dt><span class="syntaxinlinebold">NA</span></dt>
<dd>
<p>Specifies that <code>NA</code> values are to be specified as <code>NA</code>. <code>NA</code> is the default for OR.</p>
<p>For more information about using the WNAFILL phrase, see <a href="#i1017474">RELATION (for aggregation)</a> statement of the AGGMAP command.</p>
</dd>
<dt><span class="italic">wobj</span></dt>
<dd>
<p>A variable, formula, or relation that provides the weighted values. It can be numeric or BOOLEAN. When <span class="italic">wobj</span> is BOOLEAN, then <code>TRUE</code> has a weight of <code>1.0</code> and <code>FALSE</code> has a weight of&nbsp;<code>0.0</code>. A formula is queried only when needed, depending on the dimensionality of the formula and the variable being aggregated. When <span class="italic">wobj</span> is a relation, it should be a one-dimensional self-relation. For more information about specifying values for <span class="italic">wobj</span>, see <a href="#i1017474">RELATION (for aggregation)</a> statement of the AGGMAP command.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3573"></a>Examples</p>
<p>For an example of using the BREAKOUT DIMENSION statement, see <a href="#CHDIIIAC">Example 9-12, "Aggregating By Dimension Attributes"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM730" class="refsect2"><a id="i1020124"></a>
<hr />
<h2 class="refsect2">CACHE</h2>
<p>Within an aggregation specification, a <a id="sthref3574"></a>CACHE statement tells Oracle OLAP whether to cache or store the calculated data, whether to populate leaf or detail data when the variable data is aggregated using detail data from another variable, and whether to cache <code>NA</code> values when a summary values calculates to <code>NA</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The CACHE statement is only one factor that determines whether variable data that has been aggregated on-the-fly using the AGGREGATE function is stored or cached. See <a href="dml_properties018.htm#i1029245">"How Oracle OLAP Determines Whether to Store or Cache Aggregated Data"</a>.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3575"></a>Syntax</p>
<p class="synopsis">CACHE&nbsp;{NOSTORE|NONE|STORE|SESSION|<span class="underline">DEFAULT</span>} [LEAF|<span class="underline">NOLEAF</span>] [NA|NONA]</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3576"></a>Parameters</p>
<dl>
<dt>NONE</dt>
<dt>NOSTORE</dt>
<dd>
<p>For data that is calculated using the AGGREGATE function, specifies that Oracle OLAP calculates the data each time the AGGREGATE function executes. When you specify either of these keywords, Oracle OLAP does not store or cache the data calculated by the AGGREGATE function.</p>
</dd>
<dt>STORE</dt>
<dd>
<p>For data that is calculated using the AGGREGATE function, specifies that Oracle OLAP stores data calculated by the AGGREGATE function in the variable in the database. When you specify this option, the results of the aggregation are permanently stored in the variable when the analytic workspace is updated and committed.</p>
</dd>
<dt>SESSION</dt>
<dd>
<p><a id="sthref3577"></a><a id="sthref3578"></a>For data that is calculated using the AGGREGATE function, specifies that Oracle OLAP caches data calculated by the AGGREGATE function in the session cache (see <a href="dml_options089.htm#i1011029">"What is an Oracle OLAP Session Cache?"</a>). When you specify this option, the results of the aggregation are ignored during updates and commits and are discarded after the session.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When SESSCACHE is set to <code>NO</code>, Oracle OLAP does not cache the data even when you specify <code>SESSION</code>. In this case, specifying <code>SESSION</code> is the same as specifying <code>NONE</code>.</div>
</dd>
<dt>DEFAULT</dt>
<dd>
<p><a id="sthref3579"></a>(Default) For data that is calculated using the AGGREGATE function, specifies that Oracle OLAP uses the value of the VARCACHE option to determine what to do with data that is calculated by the AGGREGATE function. See <a href="dml_properties018.htm#i1029245">"How Oracle OLAP Determines Whether to Store or Cache Aggregated Data"</a>.</p>
</dd>
<dt>LEAF</dt>
<dd>
<p>When the variable data is aggregated using detail data from another variable, specifies that Oracle OLAP calculates the leaf data for the variable.</p>
</dd>
<dt>NOLEAF</dt>
<dd>
<p>(Default) When the variable data is aggregated using detail data from another variable, specifies that Oracle OLAP does not calculate the leaf data for the variable.</p>
</dd>
<dt>NA</dt>
<dd>
<p><a id="sthref3580"></a>For data that is calculated using the AGGREGATE function, specifies that Oracle OLAP places any <code>NA</code> values that are the results of the execution of the AGGREGATE function in the Oracle OLAP session cache. In this case, when there is a variable has an $NATRIGGER property with an AGGREGATE function as its expression, Oracle OLAP does <span class="italic">not</span> recalculate the values for the variable. (For more information on the caching <code>NA</code> values, see <a href="dml_properties018.htm#i1028822">"How Oracle OLAP Determines Whether to Store or Cache Results of $NATRIGGER"</a>.)</p>
</dd>
<dt>NONA</dt>
<dd>
<p><a id="sthref3581"></a>For data that is calculated using the AGGREGATE function, specifies that Oracle OLAP does <span class="italic">not</span> cache any <code>NA</code> values that are the results of the execution of the AGGREGATE function. In this case, when a variable has an $NATRIGGER property with an AGGREGATE function as its expression, Oracle OLAP recalculates the values for the variable.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3582"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2129"></a>When to Use NOSTORE</p>
<p>Use NOSTORE when you know that your users are likely to modify pre-computed data, and you want any data that calculated by the AGGREGATE function to consistent with any of those users' changes.</p>
<p>In other words, suppose a user makes a change to detail-level data, such as <code>sales</code> figures for three stores, which are in a <code>geography</code> dimension. The <code>geography</code> dimension rolls up data from stores to cities to states to regions to countries. In other words, there are five levels in the <code>geography</code> dimension's hierarchy. Now suppose that users tend to access data only at the store level (your detail data), the regions level, and the countries level. Those are the levels for which you roll up sales data and commit it to the database. Because users do not access data at the city and state level, you specify that the data cells in those two levels are calculated on the fly. When users modify the store-level data and then access city data, the city data are calculated every time that a user requests it. Therefore, any changes that a user makes to the store-level details accurately rollup to the city and state level every time that user accesses a data cell in the city or state level. (However, this is not true of the data in the region and country levels, because those cells store pre-computed data.)</p>
<p class="subhead2"><a id="OLADM2130"></a>When to Use STORE or SESSION</p>
<p>The advantage to using STORE or SESSION is that it improves query performance. For example, suppose your users use a Table tool to look at a variable's data and an individual user requests the same data cells several times in the same session. When you use the default of NOSTORE, then any data that is not aggregated using the AGGREGATE command has to be calculated every time the user requests that data even if you do not use the FORECALC keyword in the AGGREGATE function. On the other hand, when you use STORE or SESSION, then any given cell of data is calculated only once because it is available in either the variable or the cache for the entire session. Therefore, the next time a user requests that data cell, the data is returned from the variable or the cache instead of being calculated on the fly, which results in faster query time for the user.</p>
<p>Frequently you do not want the data that is calculated using the AGGREGATE function to be stored permanently in the database because that would defeat the purpose of calculating data on the fly.</p>
<ul>
<li>
<p>To ensure that the aggregated values cannot be permanently committed to the database, use SESSION.</p>
</li>
<li>
<p>Use STORE when you know either of the following is true which also ensures that the data that is calculated on the fly using the AGGREGATE function is not committed to the database:</p>
<ul>
<li>
<p>The users of the analytic workspace can only open it as read-only</p>
</li>
<li>
<p>You know that the users of the analytic workspace will not or cannot issue UPDATE and COMMIT statements.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Use STORE with caution when it is likely that your users modify pre-computed data, and they access data that you have specified to be calculated on the fly using the AGGREGATE function. The problem is that any data that is calculated using the AGGREGATE function before the user's modification does not reflect the user's change unless the user made the change using an AGGREGATE function with the FORCECALC keyword or unless there is an $AGGREGATE_FORCECALC property on the variable being aggregated</div>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="i79977"></a>Examples</p>
<p>For examples of using a CACHE statement in an aggregation specification, see <a href="#CHDJJFED">Example 9-13, "Using a CACHE Statement in an Aggregation Specification"</a> and <a href="#CHDBDBFJ">Example 9-14, "Populating All Levels of a Hierarchy Except the Detail Level"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM731" class="refsect2"><a id="i80583"></a>
<hr />
<h2 class="refsect2">DIMENSION (for aggregation)</h2>
<p>Within an aggregation specification, a<a id="sthref3583"></a> DIMENSION statement sets the status to a single value of a dimension. When an aggregation specification does not specify such single values with DIMENSION statements, Oracle OLAP uses the current status values of the dimensions when performing the aggregation.</p>
<p>You use a DIMENSION statement to ensure that the status of a dimension is set to the value that you want it to have for the aggregation. You must use a separate DIMENSION statement for each dimension that is not shared by the source, basis, and target objects.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3584"></a>Syntax</p>
<p class="synopsis">DIMENSION&nbsp;<span class="italic">dimension&nbsp;</span>'<span class="italic">dimval</span> '</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3585"></a>Parameters</p>
<dl>
<dt><span class="italic">dimension</span></dt>
<dd>
<p>the name of the dimension to limit.</p>
</dd>
<dt><span class="italic">dimval</span></dt>
<dd>
<p>A <code>TEXT</code> expression that is the single value of the dimension to which you want the status of the dimension set for the duration of an aggregation.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM732" class="refsect2"><a id="BCFECFFC"></a>
<hr />
<h2 class="refsect2">DROP DIMENSION</h2>
<p>Within an aggregation specification, a DROP DIMENSION statement specifies how non-hierarchical aggregation across variables is performed. You use this statement in aggregation specification when you are aggregating the detail data from one variable (the source variable) into another variable (the target variable) and you want to aggregate across a non-hierarchical dimension of the source variable. In this case, the target variable has one less dimension (the "dropped" dimension) than the source variable because the values of the source variable associated with this dimension are aggregated to populate the target variable.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3586"></a>Syntax</p>
<p class="synopsis">DROP DIMENSION <span class="italic">dimname</span> [VALUES {<span class="italic">valsetname</span>|ALL} &nbsp;OPERATOR <span class="italic">operation</span> [ARGS&nbsp;<span class="italic">argument</span>]</p>
<p>where <span class="syntaxinlineitalic">argument</span> is one or more of the following phrases:</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIVIDEBYZERO {YES|NO}</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DECIMALOVERFLOW {YES|NO}</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NASKIP {YES|NO}</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WEIGHTBY&nbsp;[WNAFILL {<span class="italic">number|</span>NA}] <span class="italic">wobj</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3587"></a>Parameters</p>
<dl>
<dt><span class="italic">dimname</span></dt>
<dd>
<p>The name of a dimension in the source variable that contains the detail data.</p>
</dd>
<dt>VALUES</dt>
<dd>
<p>Sets the status of <span class="italic">dimname</span> during the aggregation.</p>
</dd>
<dt><span class="italic">valueset</span></dt>
<dd>
<p>The name of a valueset object that determines the status of the dimension specified by <span class="italic">dimname</span>.</p>
</dd>
<dt>ALL</dt>
<dd>
<p>Specifies that all of the values of <span class="italic">dimname</span> are in status.</p>
</dd>
<dt>OPERATOR</dt>
<dd>
<p>Identifies the calculation method used to aggregate the data.</p>
</dd>
<dt><span class="italic">operation</span></dt>
<dd>
<p>A keyword that describes the type of aggregation to perform. The keywords are listed in <a href="#g1028397">Table 9-1, "Aggregation Methods"</a>.</p>
</dd>
<dt>ARGS</dt>
<dd>
<p>Indicates optional handling of the aggregation.</p>
</dd>
<dt>DIVIDEBYZERO</dt>
<dd>
<p>Specifies whether to allow division by zero. Specify <span class="syntaxinlinebold">YES</span> to allow division by zero which means that a statement involving division by zero executes without error but produces <code>NA</code> results. Specify <span class="syntaxinlinebold">NO</span> to disallow division by zero which means that a statement involving division by zero stops executing and produces an error message. The default value is the current value of the DIVIDEBYZERO option.</p>
</dd>
<dt>DECIMALOVERFLOW</dt>
<dd>
<p>Specifies whether to allow decimal overflow, which occurs when the result of a calculation is very large and can no longer be represented by the exponent portion of the numeric representation. Specify <span class="syntaxinlinebold">YES</span> to allow overflow, which means that a calculation that generates overflow executes without error and produces <code>NA</code> results. Specify <span class="syntaxinlinebold">NO</span> to disallow overflow which means that a calculation involving overflow stops executing and generates an error message. The default value is the current value of the DECIMALOVERFLOW option.</p>
</dd>
<dt>NASKIP</dt>
<dd>
<p>Specifies whether <code>NA</code> values are input. Specify <span class="syntaxinlinebold">YES</span> when you want Oracle OLAP to ignore <code>NA</code> values when aggregating which means that only actual values are used in calculations. Specify <span class="syntaxinlinebold">NO</span> when you want Oracle OLAP to consider <code>NA</code> values when aggregating which means that when any of the values being considered are <code>NA</code>, the calculation returns <code>NA</code>. The default value is the current value of the NASKIP option.</p>
<p>The value that you specify for the NASKIP phrase does <span class="italic">not</span> effect calculation performed when you specify HAVERAGE, HFIRST, HLAST, HWAVERAGE, HWFIRST, HWLAST for <span class="italic">operation</span>.</p>
</dd>
<dt>WEIGHTBY</dt>
<dd>
<p>Indicates that weighted aggregation is to be performed. You must include a WEIGHTBY clause when you specify HWAVERAGE, HWFIRST, HWLAST, SSUM, WAVERAGE, WFIRST, WLAST, or WSUM for <span class="italic">operation</span>. The WEIGHTBY phrase always includes a <span class="italic">wobj</span> argument and can optionally include the WNAFILL keyword. For more information about the use of the WEIGHTBY phrase, see the <a href="#i1017474">RELATION (for aggregation)</a> statement of the AGGMAP command.</p>
</dd>
<dt>WNAFILL</dt>
<dd>
<p>Indicates handling for <code>NA</code> values. The default values for WNAFILL vary depending on the value of operation. For more information about using the WNAFILL phrase, see the <a href="#i1017474">RELATION (for aggregation)</a> statement of the AGGMAP command.</p>
</dd>
<dt>number</dt>
<dd>
<p>Substitutes a number for every <code>NA</code> value. That number replaces every <code>NA</code> value in the weight object, weight formula, or weight relation.</p>
<ul>
<li>
<p><code>0.0</code> is the default for HWAVERAGE and SSUM.</p>
</li>
<li>
<p><code>1.0</code> is the default for HWFIRST, HWLAST, WAVERAGE, WFIRST, WLAST, and WSUM.</p>
</li>
</ul>
</dd>
<dt><span class="syntaxinlinebold">NA</span></dt>
<dd>
<p>Specifies that <code>NA</code> values are to be specified as <code>NA</code>. <code>NA</code> is the default for OR.</p>
</dd>
<dt><span class="italic">wobj</span></dt>
<dd>
<p>A variable, formula, or relation that provides the weighted values. It can be numeric or BOOLEAN. When <span class="italic">wobj</span> is BOOLEAN, then <code>TRUE</code> has a weight of <code>1.0</code> and <code>FALSE</code> has a weight of&nbsp;<code>0.0</code>. A formula is queried only when needed, depending on the dimensionality of the formula and the variable being aggregated. When <span class="italic">wobj</span> is a relation, it should be a one-dimensional self-relation. For more information about specifying values for <span class="italic">wobj</span>, see the <a href="#i1017474">RELATION (for aggregation)</a> statement of the AGGMAP command.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3588"></a>Examples</p>
<p>For an example of using a DROP DIMENSION statement in an aggregation specification, see <a href="#CHDBHJHD">Example 9-15, "Aggregating into a Different Variable"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM733" class="refsect2"><a id="i1005123"></a>
<hr />
<h2 class="refsect2">MEASUREDIM (for aggregation)</h2>
<p><a id="sthref3589"></a>Within an aggregation specification, a MEASUREDIM statement identifies the name of a measure dimension that is specified in the definition of an operator variable or an argument variable.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3590"></a>Syntax</p>
<p class="synopsis">MEASUREDIM&nbsp;<span class="italic">name</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3591"></a>Parameters</p>
<dl>
<dt><span class="italic">name</span></dt>
<dd>
<p>The name of the measure dimension. A measure dimension is a dimension that you define. The dimension values are names of existing variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot specify a measure dimension when it is included in the definition of the aggmap object.</div>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3592"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2131"></a>Defining a Measure Dimension</p>
<p>The following statement defines a dimension named MEASURE.</p>
<pre>
DEFINE measure DIMENSION TEXT
</pre>
<p class="subhead2"><a id="OLADM2132"></a>Populating a Measure Dimension</p>
<p>Once you have defined a measure dimension, you can then use a MAINTAIN statement to add dimension values to the MEASURE dimension.</p>
<p>The following statement adds the names of the <code>sales</code>, <code>units</code>, <code>price</code>, and <code>inventory</code> variables to <code>measure</code> as its dimension values.</p>
<pre>
MAINTAIN measure ADD 'sales', 'units', 'price', 'inventory'
</pre>
<p class="subhead2"><a id="OLADM2133"></a>Using a Measure Dimension with an Operator Variable</p>
<p>The purpose of using measure dimensions is to take advantage of the flexibility of using non-additive aggregation operators. You can use measure dimensions in the definition of operation variables or argument variables.</p>
<p>The following statements show how to define an operator variable named <code>opvar</code> and populate it.</p>
<pre>
DEFINE opvar TEXT &lt;measure&gt;
opvar (measure 'sales') = 'SUM'
opvar (measure 'inventory') = 'HLAST'
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3593"></a>Examples</p>
<p>For an example of an aggregation specification that includes a MEASUREDIM statement, see <a href="#CHDHEIGA">Example 9-16, "Using a MEASUREDIM Statement in an Aggregation Specification"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM734" class="refsect2"><a id="i1010068"></a>
<hr />
<h2 class="refsect2">MODEL (in an aggregation)</h2>
<p>Within an aggregation specification, a MODEL statement executes a predefined model.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3594"></a>Syntax</p>
<p class="synopsis">MODEL&nbsp;<span class="italic">modelname</span> [<span class="underline">PRECOMPUTE</span>&nbsp;<span class="underline">ALL</span> | PRECOMPUTE NA]</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3595"></a>Parameters</p>
<dl>
<dt><span class="italic">modelname</span></dt>
<dd>
<p>A text expression that contains the name of a predefined MODEL object.</p>
</dd>
<dt>PRECOMPUTE ALL</dt>
<dt>PRECOMPUTE NA</dt>
<dd>
<p>&nbsp;Specifies whether the model is a static (precomputed) model or a dynamic model.</p>
<ul>
<li>
<p><span class="syntaxinlinebold">PRECOMPUTE ALL</span> is the default and specifies a static model. The following conditions must be met:</p>
<ul>
<li>
<p>Any RELATION or MODEL statements that precede it in the aggregation specification must also be specified as PRECOMPUTE ALL.</p>
</li>
<li>
<p>Any RELATION or MODEL statements that follow it in the aggregation specification can either be specified as PRECOMPUTE ALL or PRECOMPUTE NA.</p>
</li>
</ul>
</li>
<li>
<p><span class="syntaxinlinebold">PRECOMPUTE NA</span> specifies a dynamic model. The following conditions must be met for run-time execution of the model:</p>
<ul>
<li>
<p>All RELATION statements in the aggregation specification must appear before the MODEL statements specified as PRECOMPUTE NA.</p>
</li>
<li>
<p>Any additional MODEL statements that follow it in the aggregation specification must also be specified as PRECOMPUTE NA.</p>
</li>
</ul>
</li>
</ul>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3596"></a>Usage Notes</p>
<p class="subhead2"><a id="BGEJFGEF"></a><a id="OLADM2134"></a>Dynamic Models and Non-Additive Operators</p>
<p>Model statements are executed in the order that they are coded within the aggregation specification. Typically, when the order of execution matters to the result, MODEL statements follow the corresponding RELATION statement.</p>
<p>Because the order of RELATION statements that use non-additive operators (for example, MAX) effects the result of the calculation and because dynamic models (that is, MODEL statements that include a PRECOMPUTE NA phrase) must follow all RELATION statements, the use of dynamic models with non-additive operators is somewhat constrained.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3597"></a>Examples</p>
<p>For an example of using a model in an aggregation specification, see <a href="#CHDEEHBB">Example 9-17, "Solving a Model in an Aggregation"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM735" class="refsect2"><a id="BCFJGIGI"></a>
<hr />
<h2 class="refsect2">PRECOMPUTE</h2>
<p>Within an aggregation specification, a <a id="sthref3598"></a>PRECOMPUTE statement specifies which of the variable's aggregate values are calculated <span class="italic">only</span> with the AGGREGATE command.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An aggregation specification that has a PRECOMPUTE statement cannot have any PRECOMPUTE clauses in its RELATION statements.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3599"></a>Syntax</p>
<p class="synopsis">PRECOMPUTE <span class="italic">precompute-phrase</span></p>
<p>where <span class="syntaxinlineitalic">precompute-phrase</span> is one of the following:</p>
<dl>
<dd><span class="syntaxinlineitalic">n</span><span class="syntaxinline">% | AUTO</span></dd>
<dd><span class="syntaxinline">ALL</span></dd>
<dd><span class="syntaxinline">NA | NONE</span></dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3600"></a>Parameters</p>
<dl>
<dt><span class="italic">n</span>%</dt>
<dd>
<p>Specifies an explicit percentage of the aggregate variable values that are aggregated as a database maintenance procedure using an AGGREGATE command. Oracle OLAP uses special functionality called the <a id="sthref3601"></a>Aggregate Advisor to determine exactly which values are in the percentage.</p>
</dd>
<dt>AUTO</dt>
<dd>
<p>Specifies that Oracle OLAP uses the <a id="sthref3602"></a>Aggregate Advisor to determine how many and which aggregate variable values to aggregate as a database maintenance procedure using an AGGREGATE command.</p>
</dd>
<dt>ALL</dt>
<dd>
<p>Specifies that all aggregated data is precomputed using an AGGREGATE command.</p>
</dd>
<dt>NA</dt>
<dt>NONE</dt>
<dd>
<p>Specifies that all values should be calculated on the fly using the AGGREGATE function (that is, that no data should be precalculated with the AGGREGATE command).</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM736" class="refsect2"><a id="i1017474"></a>
<hr />
<h2 class="refsect2">RELATION (for aggregation)</h2>
<p><a id="sthref3603"></a><a id="sthref3604"></a>Within an aggregation specification, a RELATION statement specifies how data is aggregated across a hierarchical dimension. Frequently, an aggregation specification contains one RELATION statement for each of the hierarchical dimensions of a variable.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not confuse this RELATION statement which can only be used as part of an AGGMAP command with either the RELATION command that defines a default relation for a dimension or the RELATION statement that is used as part of an ALLOCMAP command.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3605"></a>Syntax</p>
<p class="synopsis">RELATION&nbsp;<span class="italic">rel-name&nbsp;</span>[(<span class="italic">valueset...</span>)] -</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[PRECOMPUTE&nbsp;(<span class="italic">precompute-phrase</span>)]&nbsp;-</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[OPERATOR&nbsp;{<span class="italic">operation|opvar</span>}] -</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[PARENTALIAS <span class="italic">dimension-alias-name</span>] -</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ARGS&nbsp;{<span class="italic">argument|argsvar</span>}] -</p>
<p class="synopsis">[LOAD_STATUS(<span class="italic">status-valueset-name</span>)]</p>
<p>where:</p>
<ul>
<li>
<p><span class="syntaxinlineitalic">precompute-phrase</span> is one or more of the following:</p>
<dl>
<dd><span class="syntaxinlineitalic">n</span><span class="syntaxinline">% | AUTO</span></dd>
<dd><span class="syntaxinlineitalic">dimension-values</span></dd>
<dd><span class="syntaxinlineitalic">positions-of-dim-values</span></dd>
<dd><span class="syntaxinlineitalic">level-relation-name</span> <span class="syntaxinlineitalic">level-name</span><span class="syntaxinline">...</span></dd>
<dd><span class="syntaxinlineitalic">valueset2</span></dd>
<dd><span class="syntaxinline">ALL</span></dd>
<dd><span class="syntaxinline">NA | NONE</span></dd>
</dl>
</li>
<li>
<p><span class="syntaxinlineitalic">argument</span> is one or more of the following:</p>
<dl>
<dd><span class="syntaxinline">DIVIDEBYZERO {YES|NO}</span></dd>
<dd><span class="syntaxinline">DECIMALOVERFLOW {YES|NO}</span></dd>
<dd><span class="syntaxinline">NASKIP {YES|NO}</span></dd>
<dd><span class="syntaxinline">WEIGHTBY&nbsp;[WNAFILL {</span><span class="syntaxinlineitalic">number</span> <span class="syntaxinline">| NA}]</span> <span class="syntaxinlineitalic">wobj</span></dd>
<dd><span class="syntaxinline">COUNT {YES|NO}</span></dd>
</dl>
</li>
<li>
<p><span class="syntaxinlineitalic">argsvar</span> is a text variable that contains <span class="syntaxinlineitalic">argument</span> phrases for some or all dimension values.</p>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3606"></a>Parameters</p>
<dl>
<dt><span class="italic">rel-name</span></dt>
<dd>
<p>A relation that defines a hierarchy by identifying the parent of every dimension value in a hierarchy.</p>
</dd>
<dt><span class="italic">valueset</span></dt>
<dd>
<p>Sets the status of one or more dimensions for the duration of the aggregation. It overrides the current status.</p>
</dd>
<dt>PRECOMPUTE</dt>
<dd>
<p>Indicates that some dimension values are populated <span class="italic">only</span> with the AGGREGATE command. The PRECOMPUTE clause of the RELATION statement limits the data that is aggregated by the AGGREGATE command. In its simplest form, you can think of the PRECOMPUTE clause as working like a LIMIT&nbsp;<span class="italic">dimension</span> TO statement. Notice that the default limit is on the dimension, which is not explicitly named in the RELATION statement.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An aggregation specification has PRECOMPUTE clauses in any of its RELATION statements cannot also have a PRECOMPUTE statement. Additionally, you cannot specify a PRECOMPUTE phrase for a RELATION statement for a compressed composite.</div>
</dd>
<dt><span class="italic">n</span>%</dt>
<dd>
<p>Specifies an explicit percentage of the aggregate variable values that are aggregated as a database maintenance procedure using an AGGREGATE command. Oracle OLAP uses special functionality called the <a id="sthref3607"></a>Aggregate Advisor to determine exactly which values are in the percentage.</p>
</dd>
<dt>AUTO</dt>
<dd>
<p>Specifies that Oracle OLAP uses the <a id="sthref3608"></a>Aggregate Advisor to determine how many and which aggregate variable values to aggregate as a database maintenance procedure using an AGGREGATE command.</p>
</dd>
<dt><span class="italic">dimension-values</span></dt>
<dd>
<p>A list of one or more values of dimension.</p>
</dd>
<dt><span class="italic">positions-of-dim-values</span></dt>
<dd>
<p>For all dimensions except those with <code>INTEGER</code> or <code>NUMBER</code> values, the positions of the dimension values that you want precomputed. Specify the positions using <code>INTEGER</code> values, separated by commas.</p>
</dd>
<dt><span class="italic">valueset2</span></dt>
<dd>
<p>The name of a valueset. When you include this argument, only data that is dimensioned by the dimension values in the valueset should be precalculated with the AGGREGATE command. The rest of the values can be calculated on the fly.</p>
<p>Note that the current status of a dimension can also limit the data that is precalculated. See the <a href="dml_commands_1009.htm#i78745">AGGREGATE command</a> for details.</p>
</dd>
<dt>ALL</dt>
<dd>
<p>Specifies that data should be precalculated for all dimension values.</p>
</dd>
<dt>NA</dt>
<dt>NONE</dt>
<dd>
<p>Specifies that all values should be calculated on the fly using the AGGREGATE function (that is, that no data should be precalculated with the AGGREGATE command).</p>
</dd>
<dt><span class="italic">level-relation-name</span> <span class="italic">level-name</span> ...</dt>
<dd>
<p>Specifies the levels of the dimension to be precomputed. For l<span class="italic">evel-relation-name</span>, specify, as a <code>TEXT</code> value, <a id="sthref3609"></a>the name of the relation object that relates the values of the dimension to the names of the levels of the dimension. For <span class="italic">level-name</span>, specify, as <code>TEXT</code> values, the name of one or more levels using the same level names used in <span class="italic">level-relation-name</span>.</p>
</dd>
<dt>OPERATOR <span class="italic">&nbsp;</span></dt>
<dd>
<p>Identifies the calculation method used to aggregate the data.</p>
</dd>
<dt><span class="italic">operation &nbsp;</span></dt>
<dd>
<p>A keyword that describes the type of calculation to perform. The keywords are listed in <a href="#g1028397">Table 9-1, "Aggregation Methods"</a> and can be retrieved by issuing an AGGROPS statement. You can specify a fixed-length three-character abbreviation for the keywords by specifying only the first three characters.</p>
<div id="OLADM2135" class="tblformal">
<p class="titleintable"><a id="sthref3610"></a><a id="g1028397"></a>Table 9-1 Aggregation Methods</p>
<table class="cellalignment3098" title="Aggregation Methods" summary="This table describes the valid values for the operator argument that specifies the aggregation operation to be performed." dir="ltr">
<thead>
<tr class="cellalignment3089">
<th class="cellalignment3099" id="r1c1-t28">Keyword</th>
<th class="cellalignment3099" id="r1c2-t28">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r2c1-t28" headers="r1c1-t28">
<p>AND</p>
</td>
<td class="cellalignment3095" headers="r2c1-t28 r1c2-t28">
<p>When any child data value is <code>FALSE</code>, then the data value of its parent is <code>FALSE</code>. A parent is <code>TRUE</code> only when all of its children are <code>TRUE</code>. (BOOLEAN variables only)</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r3c1-t28" headers="r1c1-t28">
<p>AVERAGE</p>
</td>
<td class="cellalignment3095" headers="r3c1-t28 r1c2-t28">
<p>Adds data values, then divides the sum by the number of data values that were added. When you use AVERAGE, there are special considerations described in <a href="#i1018865">"Average Operators"</a>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r4c1-t28" headers="r1c1-t28">
<p>FIRST</p>
</td>
<td class="cellalignment3095" headers="r4c1-t28 r1c2-t28">
<p>The first non-<code>NA</code> data value.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r5c1-t28" headers="r1c1-t28">
<p>HAVERAGE</p>
</td>
<td class="cellalignment3095" headers="r5c1-t28 r1c2-t28">
<p>(Hierarchical Average) Adds data values, then divides the sum by the number of the children in the dimension hierarchy. Unlike AVERAGE, which counts only non-<code>NA</code> children, HAVERAGE counts all of the logical children of a parent, regardless of whether each child does or does not have a value.</p>
<p>This keyword is not affected by the setting of the NASKIP option for <span class="italic">argument</span>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r6c1-t28" headers="r1c1-t28">
<p>HFIRST</p>
</td>
<td class="cellalignment3095" headers="r6c1-t28 r1c2-t28">
<p>(Hierarchical First) The first data value that is specified by the hierarchy, even when that value is <code>NA</code>.</p>
<p>This keyword is not affected by the setting of the NASKIP option for <span class="italic">argument</span>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r7c1-t28" headers="r1c1-t28">
<p>HLAST</p>
</td>
<td class="cellalignment3095" headers="r7c1-t28 r1c2-t28">
<p>(Hierarchical Last) The last data value that is specified by the hierarchy, even when that value is <code>NA</code>.</p>
<p>This keyword is not affected by the setting of the NASKIP option for <span class="italic">argument</span>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r8c1-t28" headers="r1c1-t28">
<p>HWAVERAGE</p>
</td>
<td class="cellalignment3095" headers="r8c1-t28 r1c2-t28">
<p>(Hierarchical Weighted Average) Multiplies non-<code>NA</code> child data values by their corresponding weight values then divides the result by the sum of the weight values. Unlike WAVERAGE, HWAVERAGE includes weight values in the denominator sum even when the corresponding child values are <code>NA</code>.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
<p>This keyword is not affected by the setting of the NASKIP option for <span class="italic">argument</span>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r9c1-t28" headers="r1c1-t28">
<p>HWFIRST</p>
</td>
<td class="cellalignment3095" headers="r9c1-t28 r1c2-t28">
<p>(Hierarchical Weighted First) The first data value that is specified by the hierarchy multiplied by its corresponding weight value, even when that value is <code>NA</code>.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
<p>This keyword is not affected by the setting of the NASKIP option for <span class="italic">argument</span>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r10c1-t28" headers="r1c1-t28">
<p>HWLAST</p>
</td>
<td class="cellalignment3095" headers="r10c1-t28 r1c2-t28">
<p>(Hierarchical Weighted Last) The last data value that is specified by the hierarchy multiplied by its corresponding weight value, even when that value is <code>NA</code>.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
<p>This keyword is not affected by the setting of the NASKIP option for <span class="italic">argument</span>.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r11c1-t28" headers="r1c1-t28">
<p>LAST</p>
</td>
<td class="cellalignment3095" headers="r11c1-t28 r1c2-t28">
<p>The last non-<code>NA</code> data value.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r12c1-t28" headers="r1c1-t28">
<p>MAX</p>
</td>
<td class="cellalignment3095" headers="r12c1-t28 r1c2-t28">
<p>The largest data value among the children of any parent data value.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r13c1-t28" headers="r1c1-t28">
<p>MIN</p>
</td>
<td class="cellalignment3095" headers="r13c1-t28 r1c2-t28">
<p>The smallest data value among the children of any parent data value.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r14c1-t28" headers="r1c1-t28">
<p>NOAGG</p>
</td>
<td class="cellalignment3095" headers="r14c1-t28 r1c2-t28">
<p>Do <span class="italic">not</span> aggregate any data for this dimension.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r15c1-t28" headers="r1c1-t28">
<p>OR</p>
</td>
<td class="cellalignment3095" headers="r15c1-t28 r1c2-t28">
<p>When any child data value is <code>TRUE</code>, then the data value of its parent is <code>TRUE</code>. A parent is <code>FALSE</code> only when all of its children are <code>FALSE</code>. (BOOLEAN variables only)</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r16c1-t28" headers="r1c1-t28">
<p>SSUM</p>
</td>
<td class="cellalignment3095" headers="r16c1-t28 r1c2-t28">
<p>(Scaled Sum) Adds the value of a weight object to each data value, then adds the data values.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r17c1-t28" headers="r1c1-t28">
<p>SUM</p>
</td>
<td class="cellalignment3095" headers="r17c1-t28 r1c2-t28">
<p>(Default) Adds data values.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r18c1-t28" headers="r1c1-t28">
<p>WAVERAGE</p>
</td>
<td class="cellalignment3095" headers="r18c1-t28 r1c2-t28">
<p>(Weighted Average) Multiplies each data value by a weight factor, adds the data values, and then divides that result by the sum of the weight factors.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r19c1-t28" headers="r1c1-t28">
<p>WFIRST</p>
</td>
<td class="cellalignment3095" headers="r19c1-t28 r1c2-t28">
<p>(Weighted First) The first non-<code>NA</code> data value multiplied by its corresponding weight value.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r20c1-t28" headers="r1c1-t28">
<p>WLAST</p>
</td>
<td class="cellalignment3095" headers="r20c1-t28 r1c2-t28">
<p>(Weighted Last) The last non-<code>NA</code> data value multiplied by its corresponding weight value.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r21c1-t28" headers="r1c1-t28">
<p>WMAX</p>
</td>
<td class="cellalignment3095" headers="r21c1-t28 r1c2-t28">
<p>(Weighted Maximum) The largest data value among the children of any parent data value multiplied by its corresponding weight value.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r22c1-t28" headers="r1c1-t28">
<p>WMIN</p>
</td>
<td class="cellalignment3095" headers="r22c1-t28 r1c2-t28">
<p>(Weighted Minimum) The smallest data value among the children of any parent data value multiplied by its corresponding weight value.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r23c1-t28" headers="r1c1-t28">
<p>WSUM</p>
</td>
<td class="cellalignment3095" headers="r23c1-t28 r1c2-t28">
<p>(Weighted Sum) Multiplies each data value by a weight factor, then adds the data values.</p>
<p>When you use this keyword, you must include the WEIGHTBY argument keyword with a variable, formula, or relation as the weight object.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></dd>
<dt><span class="italic">opvar</span></dt>
<dd>
<p>A <code>TEXT</code> variable that you define that specifies a different the operation for each of its dimension values.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Not valid for variables dimensioned by compressed composites.</div>
<p>The <span class="italic">opvar</span> argument is used in two ways:</p>
<ul>
<li>
<p>Measure dimension -- Changes the aggregation method depending upon the variable being aggregated. Changing the aggregation method based on the variable being aggregated is useful when a single aggmap is used to aggregate several variables that must be aggregated with different methods. Whether you pre-aggregate all of the measures in a single AGGREGATE command or in separate statements, AGGREGATE uses the operation variable to identify the calculation method. The values of the measure dimension are the names of the variables to be aggregated. It dimensions a text variable whose values identify the operation to be used to aggregate each measure. The aggregation specification must include a MEASUREDIM statement that identifies the measure dimension. See <a href="#i87187">Example 9-21, "Aggregating Using a Measure Dimension"</a>.</p>
</li>
<li>
<p>Line item dimension -- Changes the aggregation method depending upon the line item being aggregated. The line item dimension is typically non-hierarchical and identifies financial allocations. The line item dimension is used both to dimension the data variable and to dimension a text variable that identifies the operation to be used to aggregate each item. The operation variable is typically used to aggregate line items over time. You do not use the MEASUREDIM statement in the aggmap. See <a href="#i87198">Example 9-22, "Aggregating Using a Line Item Dimension"</a>.</p>
</li>
</ul>
<p>The <span class="italic">opvar</span> argument cannot be dimensioned by the dimension it is used to aggregate. For example, when you want to specify different operations for the <code>geography</code> dimension, then <span class="italic">opvar</span> cannot be dimensioned by <code>geography</code>.</p>
<p>To minimize the amount of paging for the operator variable, define the operation variable as type of <code>TEXT</code> with a fixed width of <code>8</code>.</p>
</dd>
<dt>PARENTALIAS</dt>
<dd>
<p>Specifies that an alias dimension for the dimension being aggregated is QDRd to the parent value currently being aggregated.</p>
</dd>
<dt><span class="italic">dimension-alias-name</span></dt>
<dd>
<p>The name of the alias dimension for the dimension of <span class="italic">rel-name</span>.</p>
</dd>
<dt>ARGS</dt>
<dd>
<p>Indicates optional handling of the aggregation.</p>
</dd>
<dt>DIVIDEBYZERO</dt>
<dd>
<p>Specifies whether to allow division by zero.</p>
<ul>
<li>
<p><span class="syntaxinlinebold">YES</span> allows division by zero; a statement involving division by zero executes without error but produces <code>NA</code> results.</p>
</li>
<li>
<p><span class="syntaxinlinebold">NO</span> disallows division by zero; a statement involving division by zero stops executing and produces an error message.</p>
</li>
</ul>
<p>The default value is the current value of the DIVIDEBYZERO option.</p>
</dd>
<dt>DECIMALOVERFLOW</dt>
<dd>
<p>Specifies whether to allow decimal overflow, which occurs when the result of a calculation is very large and can no longer be represented by the exponent portion of the numeric representation.</p>
<ul>
<li>
<p><span class="syntaxinlinebold">YES</span> allows overflow; a calculation that generates overflow executes without error and produces <code>NA</code> results.</p>
</li>
<li>
<p><span class="syntaxinlinebold">NO</span> disallows overflow; a calculation involving overflow stops executing and generates an error message.</p>
</li>
</ul>
<p>The default value is the current value of the DECIMALOVERFLOW option.</p>
</dd>
<dt>NASKIP</dt>
<dd>
<p>Specifies whether <code>NA</code> values are input.</p>
<ul>
<li>
<p><span class="syntaxinlinebold">YES</span> specifies that <code>NA</code> values are ignored when aggregating. Only actual values are used in calculations.</p>
</li>
<li>
<p><span class="syntaxinlinebold">NO</span> specifies that <code>NA</code> values are considered when aggregating. When any of the values being considered are <code>NA</code>, the calculation returns <code>NA</code>.</p>
</li>
</ul>
<p>The default value is the current value of the NASKIP option.</p>
<p>The value that you specify for the NASKIP phrase does <span class="italic">not</span> effect calculation performed when you specify HAVERAGE, HFIRST, HLAST, HWAVERAGE, HWFIRST, HWLAST for <span class="italic">operation</span>.</p>
</dd>
<dt>WEIGHTBY</dt>
<dd>
<p>Indicates that weighted aggregation is to be performed. You must include a WEIGHTBY clause when you specify HWAVERAGE, HWFIRST, HWLAST, SSUM, WAVERAGE, WFIRST, WLAST, or WSUM for <span class="italic">operation</span>. The WEIGHTBY phrase always includes a <span class="italic">wobj</span> argument and, optionally, can include the WNAFILL keyword.</p>
</dd>
<dt>WNAFILL {<span class="italic">number</span> | NA}</dt>
<dd>
<p>Indicates handling for <code>NA</code> values. The default values for WNAFILL vary depending on the value of operation. The default value for HWAVERAGE and SSUM is <code>0.0</code>. The default value for OR is <code>NA</code>. The default value for the other operators is <code>1.0</code>. WNAFILL defaults for each operator in an aggregation specification. In other words, when one RELATION statement includes a WSUM OPERATOR, then WNAFILL defaults to <code>1.0</code>. When the next RELATION statement includes an SSUM OPERATOR, then WNAFILL defaults to <code>0.0</code>, and so on. See <a href="#i87209">"Using WNAFILL"</a>.</p>
</dd>
<dt><span class="italic">wobj</span></dt>
<dd>
<p>A variable, formula, or relation that provides the weighted values. It can be numeric or BOOLEAN. When <span class="italic">wobj</span> is BOOLEAN, then <code>TRUE</code> has a weight of <code>1.0</code> and <code>FALSE</code> has a weight of&nbsp;<code>0.0</code>. A formula is queried only when needed, depending on the dimensionality of the formula and the variable being aggregated. When <span class="italic">wobj</span> is a relation, it should be a one-dimensional self-relation. See <a href="#BCFEIEBI">Using Weighted Aggregation Methods</a> for more information about specifying values for <span class="italic">wobj</span>.</p>
</dd>
<dt>COUNT {YES|NO}</dt>
<dd>
<p>YES specifies that when Oracle OLAP aggregates a variable using this relation that it also populates the Aggcount variable associated with that variable. For more information on Aggcount variables, see <a href="dml_commands_1032.htm#CIHFEAGE">"Aggcount Variables"</a>.</p>
<p>NO specifies that when Oracle OLAP aggregates a variable using this relation that it does <span class="italic">not</span> populate the Aggcount variable associated with that variable. For more information on Aggcount variables, see <a href="dml_commands_1032.htm#CIHFEAGE">"Aggcount Variables"</a>.</p>
</dd>
<dt><span class="italic">argsvar</span></dt>
<dd>
<p>A <code>TEXT</code> variable that contains the <span class="italic">argument</span> options for some or all dimension values.</p>
</dd>
<dt>LOAD_STATUS</dt>
<dd>
<p>Specifies that, for the aggregation, Oracle OLAP consider the values specified by <span class="italic">status-valueset-name</span> as the detail or lowest level of the hierarchy.</p>
</dd>
<dt><span class="italic">status-valueset-name</span></dt>
<dd>
<p>A previously-defined valueset that specifies the lowest-level values to have in status when performing the aggregation. When performing any aggregation using an aggmap with a RELATION statement with this clause, Oracle OLAP temporarily sets the status of the dimension to the values specified by <span class="italic">status-valueset-name</span> and their ancestors. The valueset specified by <span class="italic">status-valueset-name</span> must be a single dimensional valueset for the relation dimension (not the hierarchy dimension). Additionally, the valueset specified by <span class="italic">status-valueset-name</span> cannot contain both a value and an ancestor of that value.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3611"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2136"></a>Ordering RELATION Statements with Non-Additive Operators</p>
<p>The order of RELATION statements that use non-additive operators effects the result of the calculation. For example the max of sum is not generally equal to the sum of max. Consequently, the order of RELATION statements within an aggregation specification must follow the logical requirements of the calculation. This logical necessity limits the use of dynamic models within an aggregation as discussed in <a href="#BGEJFGEF">"Dynamic Models and Non-Additive Operators"</a>.</p>
<p class="subhead2"><a id="BCFFHAEF"></a><a id="OLADM2137"></a>RELATION Statements for Compressed Composites</p>
<p>When designing the aggregation specification, follow these guidelines when coding RELATION statements for compressed composites:</p>
<ul>
<li>
<p>The HAVERAGE, HWAVERAGE, HWFIRST, HWLAST, SSUM, WAVERAGE, WFIRST, WLAST, WMAX, WMIN, and WSUM operators cause data values to change with each level of aggregation, regardless of sparsity. When possible, to insure the largest amount of overall compression, place RELATION statements with these operators at the beginning of your aggregation specification before RELATION statements that use an AND, AVERAGE, FIRST, HFIRST, HLAST, LAST, MAX, MIN, NOAGG, OR, or SUM operator.</p>
</li>
<li>
<p>To optimize the compression of a compressed composite, list similar operators contiguously if the calculation logic allows. For example, specifying MAX for the first dimension and then SUM for all the other dimensions results in better compression, and thus provides better calculation performance, than specifying SUM, MAX, and then SUM over the remaining dimensions.</p>
</li>
<li>
<p>SUM is the fastest and most compressible operator. Changing the aggregation operator for one or more dimensions from SUM to some other operator results in less compression, and therefore a larger variable, and the AGGREGATE command for that variable takes longer to complete.</p>
</li>
<li>
<p>When an AGGMAP contains a RELATION statement that specifies the AVERAGE operator, any variable using that aggregation specification must be defined using a DEFINE VARIABLE statement with a WITH AGGCOUNT phrase.</p>
</li>
<li>
<p>You can only specify a single aggregation operation. You cannot specify aggregation operations using an <span class="italic">opvar</span> variable.</p>
</li>
</ul>
<p class="subhead2"><a id="OLADM2138"></a>Two Ways to use Valuesets</p>
<p>You can use valuesets to:</p>
<ul>
<li>
<p>Limit hierarchy dimensions. You can limit which hierarchies are used by the AGGREGATE command and AGGREGATE function and the order in which these hierarchies should be used. The valueset that you use specifies the names of a dimension's hierarchies. To use a valueset in this way, use the following syntax.</p>
<pre>
RELATION <span class="italic">rel-name </span>(<span class="italic">valueset</span>)
</pre>
<p>In this case, using valuesets provides a way to manage hierarchies that are in conflict with each other, meaning, when the same dimension value stores data for different children in different hierarchies (such as, <code>Q1</code> stores data for <code>Jan</code>, <code>Feb</code>, and <code>Mar</code> in the <code>Calendar</code> hierarchy, but <code>Q1</code> stores data for <code>May</code>, <code>Jun</code>, and <code>Jul</code> in the <code>Fiscal</code> hierarchy).</p>
</li>
<li>
<p>Specify which values should be calculated on the fly by the AGGREGATE function and which values should be pre-calculated by the AGGREGATE command. The valueset that you use specifies the names of dimension values. To use a valueset in this way, use the following syntax.</p>
<pre>
RELATION <span class="italic">rel-name</span> PRECOMPUTE (<span class="italic">valueset</span>)
</pre>
<p>In this case, you use the valueset that follows the PRECOMPUTE keyword.</p>
<p>When you use valuesets to limit hierarchy dimensions and when using multiple aggmaps and the hierarchies are inconsistent, you must also use the FORCECALC keyword in the AGGREGATE function or have set an $AGGREGATE_FORCECALC property on the variable to be aggregated.</p>
</li>
</ul>
<p class="subhead2"><a id="OLADM2139"></a>When You Change a PRECOMPUTE or an OPERATOR Clause</p>
<p>Any time you make changes to a PRECOMPUTE or an OPERATOR clause, aggregate the variable data again and recompile the aggmap to produce accurate data.</p>
<p class="subhead2"><a id="OLADM2140"></a>Aggregating Data Loaded into Different Hierarchy Levels</p>
<p>When data is loaded into dimension values that are at different levels of a hierarchy, then you must be careful in how you set status in the PRECOMPUTE clause in a RELATION statement in your aggregation specification.</p>
<p>Suppose that a <code>time</code> dimension has a hierarchy with three levels: months aggregate into quarters, and quarters aggregate into years. Some data is loaded into month dimension values, while other data is loaded into quarter dimension values. For example, <code>Q1</code> is the parent of <code>January</code>, <code>February</code>, and <code>March</code>. Data for <code>March</code> is loaded into the <code>March</code> dimension value. But the sum of data for <code>January</code> and <code>February</code> is loaded directly into the <code>Q1</code> dimension value. In fact, the <code>January</code> and <code>February</code> dimension values contain <code>NA</code> values instead of data. Your goal is to add the data in <code>March</code> to the data in <code>Q1</code>.</p>
<p>When you attempt to aggregate <code>January</code>, <code>February</code>, and <code>March</code> into <code>Q1</code>, the data in <code>March</code> simply replaces the data in <code>Q1</code>. When this happens, <code>Q1</code> contains only the <code>March</code> data instead of the sum of <code>January</code>, <code>February</code>, and <code>March</code>.</p>
<p>To aggregate data that is loaded into different levels of a hierarchy, create a valueset for only those dimension values that contain data.</p>
<pre>
DEFINE all_but_q4 VALUESET time
LIMIT all_but_q4 TO ALL
LIMIT all_but_q4 REMOVE 'Q4'
</pre>
<p>Within the aggregation specification, use that valueset to specify that the detail-level data should be added to the data that exists in its parent, <code>Q1</code>, as shown in the following statement.</p>
<pre>
RELATION time.r PRECOMPUTE (all_but_q4)
</pre>
<p class="subhead2"><a id="i1018865"></a><a id="OLADM2141"></a>Average Operators</p>
<p>There are several issues involved in using the AVERAGE, HAVERAGE, WAVERAGE, and HWAVERAGE operators:</p>
<ul>
<li>
<p>Oracle OLAP needs a separate <code>INTEGER</code> variable in which it stores the non-<code>NA</code> counts of the number of leaf nodes that contributed to aggregate values to calculate average values. When you want to aggregate a variable using one the average operators, include the WITH AGGCOUNT phrase in the DEFINE VARIABLE statement for the variable.</p>
</li>
<li>
<p>Accuracy when averaging&mdash;All decimal data is converted to floating point format, both for storing and for calculations, consequently, in some cases, an average aggregation computed on a <code>DECIMAL</code> or <code>SHORTDECIMAL</code> variable can differ in the least significant digits from a result you compute by hand. For this reason, you might want to use the <code>NUMBER</code> data type when accuracy is more important than computational speed, such as variables that contain currency amounts. See <a href="dml_expression.htm#i1012610">"Numeric Expressions"</a> for more information.</p>
</li>
<li>
<p>Using Average operators when aggregating using an AGGREGATE command&mdash;When you use an average operator with the PRECOMPUTE keyword, the best practice is to use variables that have a decimal or <code>NUMBER</code> data type to ensure the accuracy of the results.</p>
</li>
<li>
<p>Using Average operators for partial aggregations&mdash;When you use an average operator in a partial aggregation, then you must always aggregate using the same <code>INTEGER</code> variable (that is, Aggcount or Countvar variable). Do not change the values that are stored in this <code>INTEGER</code> variable between aggregations. Finally, the number of <code>INTEGER</code> variables must match the number of variables that are being aggregated.</p>
</li>
</ul>
<p class="subhead2"><a id="OLADM2142"></a>HAVERAGE, HFIRST, HLAST, AND HWAVERAGE Operators</p>
<p>The "hierarchical" operators (HAVERAGE, HFIRST, HLAST, AND HWAVERAGE) are intended to provide an alternative form of <code>NA</code> handling.</p>
<p class="subhead2"><a id="OLADM2143"></a>FIRST, HFIRST, LAST, AND HLAST Operators</p>
<p>These operators rely on the existing order of the dimension values, which are assumed to be the default logical order of that dimension. For example, in a month dimension, it is assumed that February follows January, March follows February, and so on.</p>
<p>When you must change the default order, use the MAINTAIN statement to do so. For example, suppose <code>Q1</code> includes <code>January</code>, <code>February</code>, and <code>March</code>, but you must make <code>Februar</code>y the last month in the <code>Q1</code> instead of <code>March</code>. Use the following statement to do so.</p>
<pre>
MAINTAIN time MOVE 'Feb01' AFTER 'Mar01'
</pre>
<p>Now, the LAST operator assumes that <code>FEB01</code> is the last month in <code>Q1</code>.</p>
<p class="subhead2"><a id="OLADM2144"></a>Read Permissions and Aggmaps</p>
<p>When you change the read permission to <span class="italic">rel-name</span> in a RELATION statement, then you must recompile the aggmap before using it with the AGGREGATE function. Compilation is not an issue when you use the AGGREGATE command, because the aggmap is recompiled automatically. However, when you do not have read access to every <span class="italic">rel-name</span> in the aggmap, then attempting to use that aggmap results in an error message.</p>
<p class="subhead2"><a id="BCFEIEBI"></a><a id="OLADM2145"></a>Using Weighted Aggregation Methods</p>
<p>When you use a weighted method of aggregation, you must define and populate an object that contains the weights. You identify the aggregation method in the OPERATOR clause and the weight object in the ARGS clause.</p>
<p>The weight object can be a variable, a formula, or a relation. Special considerations apply depending on the type of object. the data type of the weight object, and whether or not you are performing a partial aggregation.</p>
<p><a id="OLADM2146"></a><span class="subhead3">Weight Object Considerations Based on Type of Object&nbsp;</span>The following considerations apply depending on the type of object that you use for the weight object:</p>
<ul>
<li>
<p>When the weight object is a variable, you can define it with a numeric or BOOLEAN data type. Use a variable as your weight object when you want to pre-calculate weight values and commit them to the database. You can use a variable weight object with any weight option.</p>
</li>
<li>
<p>When the weight object is a relation, define it as a one-dimensional self-relation. <span class="italic">Y</span>ou can use the weight object to specify that the weight for a specific cell is contained in the current variable at a different location. Use a relation as your weight object when you use a line item or a measure dimension. In this case, one line item is used as the weight to calculate the aggregate value of another line item. Using a relation enables you to specify another set of cells in the variable being aggregated as the weight values for a weighted operation.</p>
</li>
<li>
<p>When the weight object is a formula, that formula is queried only as often as needed, depending on the dimensionality of the formula and the dimensionality of the variable whose data is being aggregated. You can define the formula with a numeric or BOOLEAN data type. Use a formula as your weight object when you want to calculate weight values on the fly. A formula weight object is similar to a variable weight object, except that it cannot be aggregated. The value of a formula weight object is executed dynamically. Therefore, you cannot use a formula weight object with many of the weight options.</p>
</li>
</ul>
<p><a id="OLADM2147"></a><span class="subhead3">Considerations Based on Data Type of the Weight Object&nbsp;</span>The following considerations apply when the weight object is numeric or <code>BOOLEAN</code>:</p>
<ul>
<li>
<p>When the weight object has a numeric data type, It is good practice for the weight object variable to have the same dimensionality (or a subset thereof) as the variable to which it corresponds, but it is not required. When you use Oracle numbers or decimals to define your data variable, then always use the same data type to define the corresponding weight object. Otherwise, use the same data type for the weight object and the data variable unless you use WAVERAGE or HWAVERAGE; in this case, use a decimal or <code>NUMBER</code> data type to define the weight object.</p>
</li>
<li>
<p>When the weight object variable, formula, or relation that you define has a <code>BOOLEAN</code> data type, then <code>TRUE</code> represents a weight of <code>1.0</code> and <code>FALSE</code> represents a weight of <code>0.0</code>. Furthermore, when an <code>NA</code> value is multiplied by any value, the result is <code>NA</code>.</p>
</li>
</ul>
<p><a id="i1020804"></a><a id="OLADM2148"></a><span class="subhead3">Weight Object Considerations When Performing Partial Aggregations&nbsp;</span>When you use any operators that require the WEIGHTBY phrase, and you are performing a partial aggregation, then do not change the values that are stored in the weight object between AGGREGATE commands.</p>
<p class="subhead2"><a id="i87209"></a><a id="OLADM2149"></a>Using WNAFILL</p>
<p>For example, suppose you use the WSUM operator to perform currency conversion. The currency conversation rates are applied at the detail data level. Only the detail data needs to be converted, because the variable data is aggregated after the conversion. To get the correct results, all of the non-detail level weight values in the weight object would have to be <code>1</code>. Although this strategy produces correct results, it is inefficient. The best practice is to use the default WNAFILL value of <code>1</code> which specifies that all <code>NA</code> values in the weight object should be treated as if they have a weight of <code>1</code>. In this case, because the operator is WSUM, you do not have to include WNAFILL in the AGGREGATE command, because the default values are correct.</p>
<p>For example, the following statement causes the value <code>0.7</code> to be substituted for every <code>NA</code> value in the <code>salesw</code> weight object.</p>
<pre>
AGGREGATE sales USING sales.agg WEIGHTBY WNAFILL 0.7 salesw
</pre>
<p>When you do not want to specify a number to replace <code>NA</code> values, then you can use <code>NA</code> instead of a number, as shown in the following statement.</p>
<pre>
AGGREGATE sales USING sales.agg WEIGHTBY WNAFILL NA salesw
</pre>
<p>Specifying <code>NA</code> after WNAFILL has the following effect:</p>
<ul>
<li>
<p>When the aggregation specification contains a WAVERAGE or a WSUM OPERATOR, then any child cell in the weight object that has an <code>NA</code> value is treated as an <code>NA</code> cell.</p>
</li>
<li>
<p>When the aggregation specification contains an SSUM OPERATOR, then the results depend on how the Oracle OLAP option NASKIP is set. When NASKIP is set to <code>YES</code>, then any <code>NA</code> value is treated as 0.0. However, when NASKIP is set to <code>NO</code>, then any <code>NA</code> value is treated as an <code>NA</code> cell.</p>
</li>
</ul>
<p class="subhead2"><a id="i1016653"></a><a id="OLADM2150"></a>Effects of Dimension Status on Aggregation</p>
<p>A RELATION statement only aggregates those source data values that are in status&mdash;whether you set the status using LIMI T statements or a LOAD STATUS clause on the RELATION statement. The parent values are calculated regardless of whether they are in status or not. For example, when only <code>Jan01</code>, <code>Feb01</code>, and <code>Mar01</code> are in status for the <code>time</code> dimension, then <code>Q1.01</code> is calculated (but no other quarters), and <code>2001</code> is calculated (but no other years) using only <code>Q1.01</code> as input because the other quarters are NA. This functionality is useful when you want to aggregate just the new data in your analytic workspace.</p>
<p>Assume that there is a variable named <code>sales</code> that is dimensioned by <code>time</code>, a hierarchical dimension, and <code>district</code>, a non-hierarchical dimension.</p>
<pre>
DEFINE time DIMENSION TEXT
DEFINE time.parentrel RELATION time &lt;time&gt;
DEFINE district DIMENSION TEXT
DEFINE sales VARIABLE DECIMAL &lt;time district&gt;

REPORT DOWN time sales

             -----------------------SALES-----------------------
             ---------------------DISTRICT----------------------
TIME            North        South         West         East
------------ ------------ ------------ ------------ ------------
1976Q1         168,776.81   362,367.87   219,667.47   149,815.65
1976Q2         330,062.49   293,392.29   237,128.26   167,808.03
1976Q3         304,953.04   354,240.51   170,892.80   298,737.70
1976Q4         252,757.33   206,189.01   139,954.56   175,063.51
1976                   NA           NA           NA           NA
</pre></div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref3612"></a>Examples</p>
<p>For examples of aggregation specifications that include RELATION statements, see the examples in the <a href="#i1032719">AGGMAP</a> command.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3088">
<tr>
<td class="cellalignment3095">
<table class="cellalignment3093">
<tr>
<td class="cellalignment3092"><a href="dml_commands_1005.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3092"><a href="dml_commands_1007.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3097">
<table class="cellalignment3091">
<tr>
<td class="cellalignment3092"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3092"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3092"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3092"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3092"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3092"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
