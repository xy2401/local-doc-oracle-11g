<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 742" />
<meta name="dcterms.created" content="2013-11-14T21:21:58Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="OLAP DML Reference" />
<meta name="dcterms.identifier" content="E17122-08" />
<meta name="dcterms.isVersionOf" content="OLADM" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="dml_commands_2057.htm" title="Previous" type="text/html" />
<link rel="Next" href="dml_commands_2059.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e17122.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">532/593</span> <!-- End Header --><a id="g1037371"></a>
<hr />
<div id="OLADM905" class="refsect1">
<h1 class="refsect1">SQL</h1>
<p><a id="ABC1072431"></a><a id="ABC1072431SRI1"></a>The SQL command passes instructions written in Structured Query Language (SQL) to the relational manager from Oracle OLAP. Using the SQL command, you can insert and update data in relational tables, retrieve data from relational tables into analytic workspace objects, and execute stored procedures.</p>
<p>To use the SQL command, you must be familiar with SQL syntax and with the data structures in your relational database, and have the appropriate access rights to the relational tables that you want to use.</p>
<p>This entry describes the OLAP DML SQL command in general, and subsequent entries discuss the use of the OLAP DML SQL command for specific SQL statements:</p>
<ul>
<li>
<p><a href="#i78701">SQL CLEANUP</a></p>
</li>
<li>
<p><a href="#i78697">SQL CLOSE</a></p>
</li>
<li>
<p><a href="#i78681">SQL DECLARE CURSOR</a></p>
</li>
<li>
<p><a href="#i1001016">SQL EXECUTE</a></p>
</li>
<li>
<p><a href="#i78689">SQL FETCH</a></p>
</li>
<li>
<p><a href="#i78693">SQL IMPORT</a></p>
</li>
<li>
<p><a href="#i78685">SQL OPEN</a></p>
</li>
<li>
<p><a href="#i78976">SQL PREPARE</a></p>
</li>
<li>
<p><a href="#BJEIJDAD">SQL PROCEDURE</a></p>
</li>
<li>
<p><a href="#i78599">SQL SELECT</a></p>
</li>
</ul>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5041"></a>Syntax</p>
<p class="synopsis">SQL <span class="italic">sql-statement</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5042"></a>Parameters</p>
<dl>
<dt><span class="italic">sql-statement</span></dt>
<dd>
<p>For <span class="italic">sql-statement</span> you can specify most SQL statements that can be executed dynamically and also several associated non-dynamic statements. You can also specify PROCEDURE for a stored procedure as described in SQL PROCEDURE. A SQL statement cannot exceed 128K bytes including the values of all non-textual OLAP DML input expressions.</p>
<p>You can<span class="italic">not</span> specify the following SQL statements for <span class="italic">sql-statement</span>:</p>
<ul>
<li>
<p><code>COMMIT</code> -- To commit your changes, issue the OLAP DML COMMIT statement.</p>
</li>
<li>
<p><code>ROLLBACK</code> -- You cannot rollback using the OLAP DML. When you specify SQL <code>ROLLBACK</code>, you receive an error message stating that <code>ROLLBACK</code> is not supported as an argument to an OLAP DML SQL statement.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
When you use an OLAP DML SQL statement to request a rollback in some other fashion (for example, using SQL EXECUTE), Oracle OLAP issues a system error message, abnormally terminates the OLAP DML program that issued the statement. Oracle OLAP also detaches, in an indeterminate state, the analytic workspace that contains the OLAP DML program that made the rollback request and any other attached analytic workspaces with uncommitted updates.</div>
</li>
</ul>
<p>Oracle OLAP evaluates some SQL statements before sending them to the relational manager. For example, Oracle OLAP evaluates SQL PREPARE and SQL EXECUTE, and SQL statements that copy data from relational tables into analytic workspace objects (See <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a> for a list of these statements).</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5043"></a>Usage Notes</p>
<p class="subhead2"><a id="i79314"></a><a id="OLADM2787"></a>Copying Relational Data into Analytic Workspace Objects</p>
<p><a id="sthref5044"></a>You can copy relational data into analytic workspace objects using either an implicit cursor or an explicit cursor:</p>
<ul>
<li>
<p>To copy data from relational tables into analytic workspace objects using an implicit cursor, use a SQL SELECT statement. You can use this OLAP DML statement interactively in the OLAP Worksheet or within an OLAP DML program.</p>
</li>
<li>
<p>To copy data from relational tables into analytic workspace objects using an explicit cursor, use the following commands within an OLAP DML program in the order indicated:</p>
<ol>
<li>
<p><a href="#i78681">SQL DECLARE CURSOR</a> to define a SQL cursor by associating it with a SELECT statement or procedure.</p>
</li>
<li>
<p><a href="#i78685">SQL OPEN</a> to activate a SQL cursor.</p>
</li>
<li>
<p><a href="#i78689">SQL FETCH</a> or <a href="#i78693">SQL IMPORT</a> to retrieve and process data specified by a cursor.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
SQL FETCH offers the most functionality; while SQL IMPORT offers improved performance when copying large amounts of data from relational tables into analytic workspace object.</div>
</li>
<li>
<p><a href="#i78697">SQL CLOSE</a> to close a SQL cursor.</p>
</li>
<li>
<p><a href="#i78701">SQL CLEANUP</a> to cancel all SQL cursor declarations and free the memory resources of an SQL cursor.</p>
</li>
</ol>
</li>
</ul>
<p>Oracle OLAP evaluates all of these statements before sending them to the relational manager.</p>
<p>For the syntax of these statements, see the individual topics. For the syntax of other SQL statements, refer to <span class="italic">Oracle Database SQL Language Reference</span>.</p>
<p class="subhead2"><a id="OLADM2788"></a>Inserting Data into a Relational Table</p>
<p><a id="sthref5045"></a>You can insert analytic workspace data into a relational table using SQL PREPARE statement for a SQL INSERT statement (typically with DIRECT= YES), and then executing the statement using SQL EXECUTE.</p>
<p class="subhead2"><a id="OLADM2789"></a>Options Related to the OLAP DML SQL Statements</p>
<p>Several options are available to you when embedding SQL into the OLAP DML. These options are listed in <a href="dml_options.htm#CHDCDDAB">"SQL Embed Options"</a>.</p>
<p class="subhead2"><a id="BJEHBHBI"></a><a id="OLADM2790"></a>Using OLAP DML Expressions in OLAP DML SQL Statements</p>
<p>You can use OLAP DML expressions (for example, OLAP DML variables) as arguments in many OLAP DML SQL statements. OLAP DML input expressions are values supplied by Oracle OLAP as parameters to a SQL statement. They specify the data to be selected or provide values for data that is being modified. You can use OLAP DML input expressions in SQL <code>WHERE</code> clauses, parameter list for procedures, <code>UPDATE</code> statements, and the value clause of <code>INSERT</code>.</p>
<p>Keep the following points in mind when using an OLAP DML expression in an OLAP DML SQL statement:</p>
<ul>
<li>
<p>OLAP DML expressions must be preceded by a colon (for example, <code>:myvar</code>).</p>
</li>
<li>
<p>When you specify a dimension or a dimensioned variable as an OLAP DML input expression, the first value in status is used; no implicit looping occurs, although you can use a FOR or an ACROSS statement to loop through all of the values. An OLAP DML input expression can be any expression with an appropriate data type. The value of an OLAP DML input expression is taken when a cursor is opened, not when it is declared. See <a href="#i79325">Example 10-131, "Inserting Data in a Table"</a>.</p>
</li>
<li>
<p>To update or insert data in a relational table that has either the CLOB and NCLOB data type, you use <code>WIDE</code> in the OLAP DML input expression as described in <a href="#BJEIFAHJ">"Inserting Large Text Values into a CLOB or NCLOB Column"</a> .</p>
</li>
</ul>
<p class="subhead2"><a id="OLADM2791"></a>Error Checking</p>
<p>Oracle OLAP can detect some syntax errors in the arguments to the SQL statement, but most errors are detected by the Oracle RDBMS. Error codes and messages are returned to Oracle OLAP. Check the value of SQLCODE after each SQL statement to determine when it resulted in an error. When it does cause an error (that is when <code>SQLCODE EQ -1</code>), check the value of SQLERRM for information about the cause of the error.</p>
<p class="subhead2"><a id="OLADM2792"></a>Converting Oracle RDBMS Data Types into Oracle OLAP DML Data Types</p>
<p><a href="#g1017647">Table 10-10, "RDBMS Data Type Conversion to OLAP DML Data Types"</a> shows which Oracle RDBMS data types can be automatically converted into Oracle OLAP DML data types. You must explicitly convert or cast other data types in the SELECT statement within a SQL DECLARE CURSOR statement.</p>
<div id="OLADM2793" class="tblformal">
<p class="titleintable"><a id="sthref5046"></a><a id="g1017647"></a>Table 10-10 RDBMS Data Type Conversion to OLAP DML Data Types</p>
<table class="cellalignment3098" title="RDBMS Data Type Conversion to OLAP DML Data Types" summary="This table outlines how Oracle OLAP converts RDBMS table data types into OLAP DML data types." dir="ltr">
<thead>
<tr class="cellalignment3089">
<th class="cellalignment3099" id="r1c1-t111">Oracle RDBMS Data Type</th>
<th class="cellalignment3099" id="r1c2-t111">OLAP DML Dimension Type</th>
<th class="cellalignment3099" id="r1c3-t111">OLAP DML Variable Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r2c1-t111" headers="r1c1-t111">
<p><code>CHAR,</code> <code>NCHAR</code>, <code>NVARCHAR2</code>, <code>VARCHAR2</code></p>
</td>
<td class="cellalignment3095" headers="r2c1-t111 r1c2-t111">
<p><code>TEXT [WIDTH</code> <code><span class="codeinlineitalic">n</span></code><code>]</code>, <code>ID,</code> <code>NTEXT</code></p>
</td>
<td class="cellalignment3095" headers="r2c1-t111 r1c3-t111">
<p><code>TEXT</code>, <code>NTEXT</code></p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r3c1-t111" headers="r1c1-t111">
<p><code>NUMBER</code></p>
</td>
<td class="cellalignment3095" headers="r3c1-t111 r1c2-t111">
<p><code>NUMBER</code>, <code>INTEGER</code>, <code>SHORTINTEGER</code>, <code>LONGINTEGER</code></p>
</td>
<td class="cellalignment3095" headers="r3c1-t111 r1c3-t111">
<p><code>NUMBER</code>, <code>INTEGER</code>, <code>BOOLEAN</code>, <code>SHORTINTEGER</code>, <code>LONGINTEGER</code>, <code>DECIMAL</code>, <code>SHORTDECIMAL</code></p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r4c1-t111" headers="r1c1-t111">
<p><code>CLOB</code> (only within SQL FETCH and SQL SELECT statements)</p>
</td>
<td class="cellalignment3095" headers="r4c1-t111 r1c2-t111">
<p><code>TEXT</code></p>
</td>
<td class="cellalignment3095" headers="r4c1-t111 r1c3-t111">
<p><code>TEXT</code></p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r5c1-t111" headers="r1c1-t111">
<p><code>NCLOB</code> (only within SQL FETCH and SQL SELECT statements)</p>
</td>
<td class="cellalignment3095" headers="r5c1-t111 r1c2-t111">
<p><code>NTEXT</code></p>
</td>
<td class="cellalignment3095" headers="r5c1-t111 r1c3-t111">
<p><code>NTEXT</code></p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r6c1-t111" headers="r1c1-t111">
<p><code>DATE</code></p>
</td>
<td class="cellalignment3095" headers="r6c1-t111 r1c2-t111">
<p>-</p>
</td>
<td class="cellalignment3095" headers="r6c1-t111 r1c3-t111">
<p><code>DATE</code>, <code>DATETIME</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p class="subhead2"><a id="OLADM2794"></a>SQL UPDATE Statements</p>
<p><code>SQL</code> <code>UPDATE</code> statements can contain a <code>WHERE</code> clause, which specifies a particular search condition. In addition to the search conditions typically used in SQL, the phrase <code>WHERE</code> <code>CURRENT</code> <code>OF</code> <code><span class="codeinlineitalic">cursor</span></code> is supported for single tables and views that include columns from only one table. The cursor must have been defined with the <code>FOR</code> <code>UPDATE</code> clause as described in SQL DECLARE CURSOR.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5047"></a>Examples</p>
<div id="OLADM2795" class="example">
<p class="titleinexample"><a id="i79325"></a>Example 10-131 Inserting Data in a Table</p>
<p>You can use SQL statements such as the following to create a table and add rows to that table. The SQL INSERT statement adds a row to the <code>sales</code> table using values from the dimension <code>salesperson</code> and the variable <code>dollars</code>. It adds one row using the first value of <code>salesperson</code> that is in status.</p>
<pre>
SQL CREATE TABLE sales (name CHAR(12), dollars INTEGER)
SQL INSERT INTO sales VALUES (:salesperson, :dollars)
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" -->
<div id="OLADM906" class="refsect2"><a id="i78701"></a>
<hr />
<h2 class="refsect2">SQL CLEANUP</h2>
<p><a id="i1010705"></a><a id="sthref5048"></a>The SQL CLEANUP command cancels all SQL cursor declarations and frees the memory resources for all SQL cursors. You use the SQL CLEANUP command in combination with other SQL commands to copy data from relational tables into analytic workspace objects as outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a></p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5049"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;CLEANUP</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5050"></a>Examples</p>
<p>For an example of the use of SQL CLEANUP, see <a href="#CHDIJEAB">Example 10-141, "Fetching Data into a Concat Dimension"</a>.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM907" class="refsect2"><a id="i78697"></a>
<hr />
<h2 class="refsect2">SQL CLOSE</h2>
<p><a id="sthref5051"></a><a id="sthref5052"></a><a id="sthref5053"></a>The SQL CLOSE command closes a SQL cursor. You use the SQL OPEN command in combination with other SQL commands to copy data from relational tables into analytic workspace objects as outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5054"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;CLOSE&nbsp;<span class="italic">cursor</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5055"></a>Parameters</p>
<dl>
<dt><span class="italic">cursor</span></dt>
<dd>
<p>The name of a cursor previously opened with a SQL OPEN statement.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5056"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2796"></a>Redefining the Result Set</p>
<p>You can change the result set associated with a cursor by closing the cursor, setting the value of an OLAP DML input expression, and issuing a new SQL OPEN statement. You do not have to free the cursor and redeclare it.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM908" class="refsect2"><a id="i78681"></a>
<hr />
<h2 class="refsect2">SQL DECLARE CURSOR</h2>
<p><a id="sthref5057"></a><a id="sthref5058"></a><a id="sthref5059"></a>The SQL DECLARE CURSOR <a id="sthref5060"></a><a id="sthref5061"></a><a id="sthref5062"></a>command defines an explicit SQL cursor by associating it with a <code>SELECT</code> statement or procedure. The <code>SELECT</code> statement specifies the scope of the data (the rows and columns) selected by the cursor. You use the SQL DECLARE CURSOR command in combination with other SQL commands to use an explicit cursor to copy data from relational tables into analytic workspace objects as outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a>.</p>
<p>Two pseudo procedures, <code>SQLTABLES</code> and <code>SQLCOLUMNS</code>, allow you to obtain information about tables and columns.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5063"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;DECLARE&nbsp;<span class="italic">cursor&nbsp;</span>CURSOR&nbsp;FOR&nbsp;{<span class="italic">select-statement</span> [FOR UPDATE]|<span class="italic">table-info</span>}</p>
<p>where <span class="syntaxinlineitalic">table-info</span> is one of the following:</p>
<dl>
<dd><span class="syntaxinline">PROCEDURE&nbsp;SQLTABLES&nbsp;[</span><span class="syntaxinlineitalic">owner</span><span class="syntaxinline">,&nbsp;</span><span class="syntaxinlineitalic">table</span><span class="syntaxinline">]</span></dd>
<dd><span class="syntaxinline">PROCEDURE&nbsp;SQLCOLUMNS&nbsp;[</span><span class="syntaxinlineitalic">owner</span><span class="syntaxinline">,&nbsp;</span><span class="syntaxinlineitalic">table</span><span class="syntaxinline">,&nbsp;</span><span class="syntaxinlineitalic">column</span><span class="syntaxinline">]</span></dd>
</dl>
<div class="infobox-note">
<p class="notep1">Note:</p>
You specify <span class="syntaxinlineitalic">table-info</span> only to declare a cursor when <span class="italic">select-statement</span> is a SQL FETCH statement.</div>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5064"></a>Parameters</p>
<dl>
<dt><span class="italic">cursor</span></dt>
<dd>
<p>The name of the cursor you are defining. Cursor names can consist of 1 to 18 alphanumeric characters or the symbols <code>@</code>, <code>_</code>, <code>$</code>, or <code>#</code>. A name that contains symbols <code>@</code>, <code>$</code>, or <code>#</code> must be enclosed in single quotes. The first character cannot be a number or an underscore. Cursor names are internal to Oracle OLAP. Unless you have issued a SQL CLEANUP statement, when you try to declare a cursor with the same name as a previously declared cursor, but with a different SQL <code>SELECT</code> statement, an error is signaled.</p>
</dd>
<dt><span class="italic">select-statement</span></dt>
<dd>
<p>A SQL SELECT statement that identifies the data you want to associate with the cursor. For the syntax of an SQL SELECT statement, refer to <span class="italic">Oracle Database SQL Language Reference.</span></p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Because both OLAP DML syntax and SQL syntax allow you to use AND and OR, construct the clause clearly so that Oracle OLAP can identify the end of an OLAP DML input expression. Use parenthesis to clarify the syntax in these situations and when using a SQL operator that is unknown in Oracle OLAP.</div>
</dd>
<dt>FOR UPDATE</dt>
<dd>
<p>Indicates that SQL FETCH is used to write data to the table. This clause is required when the cursor is used in an <code>UPDATE</code> statement with a <code>WHERE</code> <code>CURRENT</code> <code>OF</code> <code><span class="codeinlineitalic">cursor</span></code> clause. The names of the columns to be updated can be listed in an <code>OF</code> clause (for example, <code>FOR</code>&nbsp;<code>UPDATE</code>&nbsp;<code>OF</code>&nbsp;<code>COL1,</code>&nbsp;<code>COL2,</code>&nbsp;<code>COL3</code>).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The FOR UPDATE clause is ignored by SQL IMPORT and SQL SELECT.</div>
</dd>
<dt>PROCEDURE SQLTABLES</dt>
<dd>
<p>When declaring a cursor for use by SQL FETCH, calls the pseudo procedure <code>SQLTABLES</code>, which returns the following values for each table that matches the search criterion as illustrated in <a href="#i79412">Example 10-133, "Discovering Information About Relational Tables"</a>:</p>
<ul>
<li>
<p><span class="italic">tableowner</span> -- A text value identifying the owner of the table.</p>
</li>
<li>
<p><span class="italic">tablename</span> -- A text value identifying the name of the table.</p>
</li>
<li>
<p><span class="italic">tabletype</span> -- A text value identifying the type of table using one of the following: TABLE, VIEW, SYSTEM TABLE, ALIAS, SYNONYM, LOCAL TEMPORARY, GLOBAL TEMPORARY, or NA (indicating an unrecognized type).</p>
</li>
</ul>
<p>When declaring a cursor for use by SQL IMPORT, you cannot use this clause.</p>
</dd>
<dt>PROCEDURE SQLCOLUMNS</dt>
<dd>
<p>When declaring a cursor for use by SQL FETCH, calls the pseudo procedure <code>SQLCOLUMNS</code>, which returns the following values for each column that matches the search criterion as illustrated in <a href="#i79422">Example 10-134, "Discovering Information About the Columns of a Relational Table"</a>:</p>
<ul>
<li>
<p><span class="italic">tableowner</span> -- A text value identifying the owner of the table.</p>
</li>
<li>
<p><span class="italic">tablename</span> -- A text value identifying the name of the table.</p>
</li>
<li>
<p><span class="italic">colname</span> -- A text value identifying the name of the column.</p>
</li>
<li>
<p><span class="italic">coltype</span> -- A text value identifying the data type of the column.</p>
</li>
<li>
<p><span class="italic">olaptype</span> -- A text value identifying the data type that most closely matches <span class="italic">coltype.</span></p>
</li>
<li>
<p><span class="italic">length</span> -- An <code>INTEGER</code> value identifying the length of column values.</p>
</li>
<li>
<p><span class="italic">precision</span> -- An <code>INTEGER</code> value identifying the precision of numeric column values.</p>
</li>
<li>
<p><span class="italic">scale</span> -- An <code>INTEGER</code> value identifying the scale of column values.</p>
</li>
<li>
<p><span class="italic">nullable</span> -- A text value of <code>Y</code> or <code>N</code> indicating whether the column can contain null values.</p>
</li>
</ul>
<p>When declaring a cursor for use by SQL IMPORT, you cannot use the PROCEDURE SQLCOLUMNS clause.</p>
</dd>
<dt><span class="italic">owner</span></dt>
<dd>
<p>Literal text or the name of an OLAP DML variable whose value specifies one or more owners. This expression acts as a filter to limit the results to only tables belonging to the specified owners. The keyword NULL or an OLAP DML variable with an <code>NA</code> value causes all table owners to be included in the results.</p>
<p>The expression can be specific, such as <code>'SCOTT'</code>, or it can contain wildcard characters such as <code>'S%T'</code> (all owners whose name begins with <code>S</code> and ends with <code>T</code>). The value retains its case when it is passed to the database, so be sure to enter the value with the appropriate use of upper- and lowercase letters. For example, Oracle relational databases by default store all values in uppercase and do not match <code>'scott'</code> or <code>'Scott'</code> with <code>'SCOTT'</code>.</p>
</dd>
<dt><span class="italic">table</span></dt>
<dd>
<p>Literal text or the name of an OLAP DML variable whose value specifies one or more tables. This expression acts as a filter to limit the results to only tables with the specified names. The keyword NULL or an OLAP DML variable with an <code>NA</code> value causes all tables to be included in the results.</p>
<p>The expression can be specific, such as <code>'PAYROLL',</code> or it can contain wildcard characters such as <code>'%ROLL'</code> (all tables whose name ends with <code>ROLL</code>). The value retains its case when it is passed to the database, so be sure to enter the value with the appropriate use of upper- and lowercase letters. For example, Oracle relational databases by default store all values in uppercase and do not match <code>'payroll'</code> or <code>'Payroll'</code> with <code>'PAYROLL'</code>.</p>
</dd>
<dt><span class="italic">column</span></dt>
<dd>
<p>Literal text or the name of an OLAP DML variable whose value specifies one or more columns. This expression acts as a filter to limit the results to only columns with the specified names. The keyword <code>NULL</code> or an OLAP DML variable with an NA value causes all tables to be included in the results.</p>
<p>The expression can be specific, such as <code>'SALARY'</code>, or it can contain wildcard characters such as <code>'SAL%'</code> (all columns whose name begins with <code>SAL</code>). The value retains its case when it is passed to the database, so be sure to enter the value with the appropriate use of upper- and lowercase letters. For example, Oracle relational databases by default store all values in uppercase and do not match <code>'salary'</code> or <code>'Salary'</code> with <code>'SALARY'</code>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5065"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2797"></a>General Restrictions that Apply to SQL DECLARE CURSOR</p>
<p>The following restrictions apply to the SQL DECLARE CURSOR command:</p>
<ul>
<li>
<p>You can use it only in a program.</p>
</li>
<li>
<p>It cannot contain ampersand substitution.</p>
</li>
</ul>
<p class="subhead2"><a id="OLADM2798"></a>Restrictions when Declaring a Cursor for Use by SQL IMPORT</p>
<p>When declaring a cursor to be used by a SQL IMPORT statement, you can only use the following simplified syntax.</p>
<p class="synopsis">SQL&nbsp;DECLARE&nbsp;<span class="italic">cursor&nbsp;</span>CURSOR&nbsp;FOR&nbsp;<span class="italic">select-statement</span></p>
<p>where <span class="italic">select-statement</span> is a SQL <code>SELECT</code> statement that identifies the data you want to associate with the cursor. You cannot use the <code>FOR</code> <code>UPDATE</code> clause or the <code><span class="codeinlineitalic">table-info</span></code> clause.</p>
<p class="subhead2"><a id="OLADM2799"></a>Cursor's Result Set</p>
<p>A cursor's result set is determined at the time it is opened, and it is not updated later. Therefore, when you change the value of an OLAP DML input expression after you open its cursor, the change does not affect the cursor's result set. A cursor remains open until a SQL CLOSE statement is executed for that cursor or until a SQL CLEANUP statement closes all cursors. A cursor is not automatically closed at the termination of the program in which it was opened.</p>
<p class="subhead2"><a id="OLADM2800"></a>Optimizing Fetches</p>
<p>When fetching values into a multidimensional input variable, list the columns that correspond to the dimensions in an ORDER BY clause in the <span class="italic">select-statement</span> argument of a SQL DECLARE CURSOR statement, with the slowest-varying dimension first which optimizes performance.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5066"></a>Examples</p>
<div id="OLADM2801" class="example">
<p class="titleinexample"><a id="sthref5067"></a>Example 10-132 Testing for the Value of SQLCODE</p>
<p>Cursor <code>c1</code> is declared for three columns in the table <code>mkt</code>, which is owned by user <code>sqldba</code>. Values from the three columns are fetched into three analytic workspace objects. The first OLAP DML object is the <code>market</code> dimension, which is temporarily limited to the retrieved value. Because of the temporary status of <code>market</code>, the other column values are assigned to the appropriate cells of the other OLAP DML objects.</p>
<p>This example tests the value of SQLCODE in two places. A more complete program would do more error checking.</p>
<pre>
DEFINE market DIMENSION TEXT
DEFINE mkt.desc TEXT &lt;market&gt;
DEFINE mkt.abbrev ID &lt;market&gt;
DEFINE sql.market PROGRAM
PROGRAM
TRAP ON ERROR
SQL DECLARE c1 cursor FOR -
   SELECT mktcode, mktabbrev, mktdesc FROM sqldba.mkt
SQL OPEN c1
IF SQLCODE NE 0
   THEN SIGNAL SQLERR 'open cursor failed.'
WHILE SQLCODE EQ 0
   SQL FETCH c1 INTO :APPEND market, :mkt.abbrev, :mkt.desc
SQL CLOSE c1
   ...
RETURN
error:
   ...
END
</pre></div>
<!-- class="example" -->
<div id="OLADM2802" class="example">
<p class="titleinexample"><a id="i79412"></a>Example 10-133 Discovering Information About Relational Tables</p>
<p>The following program fetches information about all tables owned by <code>Scott</code>. Notice that the value of the <span class="italic">ownername</span> variable is set after the SQL DECLARE cursor statement; it can be set any time before the SQL OPEN statement. The <span class="italic">tablename</span> variable is not set, but is initialized automatically to <code>NA</code>, which is passed as a null value.</p>
<pre>
DEFINE ownername TEXT     "Search criteria
DEFINE tablename TEXT     "Search criteria
DEFINE tblowner TEXT      "Search results
DEFINE tblname TEXT       "Search results
DEFINE tbltype TEXT       "Search results
 
SQL DECLARE c1 CURSOR FOR PROCEDURE sqltables(:ownername, :tablename)
ownername = 'Scott'
SQL OPEN c1
WHILE SQLCODE EQ 0
   DO
   SQL FETCH c1 INTO :tblowner, :tblname, :tbltype
      ...     "Process fetched values
   DOEND
</pre></div>
<!-- class="example" -->
<div id="OLADM2803" class="example">
<p class="titleinexample"><a id="i79422"></a>Example 10-134 Discovering Information About the Columns of a Relational Table</p>
<p>The following program fetches information about all columns in the <code>employee</code> table owned by <code>Scott</code>. Notice that <code>NULL</code> (and not <code>NA</code>) is used for the value of the third argument to <code>SQLCOLUMNS</code> because it is processed by the relational manager, not Oracle OLAP.</p>
<pre>
DEFINE tblname TEXT             "Search results
DEFINE tblowner TEXT            "Search results
DEFINE colname TEXT             "Search results
DEFINE coltype TEXT             "Search results
DEFINE olaptype TEXT            "Search results
DEFINE length INTEGER           "Search results
DEFINE precision INTEGER        "Search results
DEFINE scale INTEGER            "Search results
DEFINE nullable TEXT            "Search results
 
SQL DECLARE c1 CURSOR FOR PROCEDURE sqlcolumns('Scott', -
   'Employee', NULL)
SQL OPEN c1
WHILE SQLCODE EQ 0
   DO
   SQL FETCH c1 INTO :tblowner, :tblname, :colname, :coltype, -
   :olaptype, :length, :precision, :scale, :nullable
      ...  "Process fetched values
    DOEND 
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM909" class="refsect2"><a id="i1001016"></a>
<hr />
<h2 class="refsect2">SQL EXECUTE</h2>
<p><a id="i1010706"></a>The <a id="sthref5068"></a>SQL EXECUTE command executes SQL statements that have been compiled using SQL PREPARE. Typically, the SQL statements that you precompile are statements that are executed repeatedly, particularly those involving OLAP DML input expressions, such as <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The SQL PREPARE and SQL EXECUTE commands can only be used within the same DML program.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5069"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;EXECUTE&nbsp;<span class="italic">statement-name</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5070"></a>Parameters</p>
<dl>
<dt><span class="italic">statement-name</span></dt>
<dd>
<p>The name that you assigned to the executable code when you prepared it using SQL PREPARE.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5071"></a>Examples</p>
<div id="OLADM2804" class="example">
<p class="titleinexample"><a id="sthref5072"></a>Example 10-135 Updating a Relational Table Using Analytic Workspace Data</p>
<p>The next example shows a simple update of a table using data stored in Oracle OLAP. The market dimension is limited to one value at a time in the FOR loop. The SQL phrase <code>WHERE s.market=:market</code> specifies that the sales value in the row for that market is the value that is changed.</p>
<pre>
FOR market
   SQL UPDATE mkt SET sales=:mkt.sales WHERE s.market=:market
</pre>
<p>An UPDATE statement should be used in a SQL PREPARE statement and executed in a FOR loop.</p>
<pre>
SQL PREPARE s2 FROM UPDATE mkt -
   SET sales=:mkt.sales WHERE s.market=:market
FOR market
   DO
      SQL EXECUTE s2
      IF SQLCODE NE 0
      THEN BREAK
   DOEND
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM910" class="refsect2"><a id="i78689"></a>
<hr />
<h2 class="refsect2">SQL FETCH</h2>
<p><a id="sthref5073"></a><a id="sthref5074"></a>The SQL FETCH command <a id="sthref5075"></a>retrieves and processes data specified by a named SQL cursor. SQL FETCH assigns the retrieved data to OLAP objects. You use the SQL FETCH command in combination with other SQL commands to copy data from relational tables into analytic workspace objects as outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5076"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;FETCH&nbsp;<span class="italic">cursor&nbsp;</span>[LOOP&nbsp;[<span class="italic">loopcount</span>]]&nbsp;-</p>
<p class="synopsis">&nbsp;&nbsp;&nbsp;INTO&nbsp;:<span class="italic">targets.</span>..&nbsp;[THEN&nbsp;<span class="italic">action-statements</span>...]</p>
<p>where:</p>
<ul>
<li>
<p><span class="syntaxinlineitalic">targets</span> is one or more of the following:</p>
<dl>
<dd><span class="syntaxinline">[MATCH]</span>&nbsp;<span class="syntaxinlineitalic">dimension|surrogate</span></dd>
<dd><span class="syntaxinline">APPEND&nbsp;[</span><span class="syntaxinlineitalic">position</span><span class="syntaxinline">]&nbsp;</span><span class="syntaxinlineitalic">dimension</span></dd>
<dd><span class="syntaxinline">ASSIGN&nbsp;</span><span class="syntaxinlineitalic">surrogate</span></dd>
<dd><span class="syntaxinlineitalic">variable</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">qualified&nbsp;data&nbsp;reference</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">relation</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">composite</span></dd>
</dl>
</li>
<li>
<p><span class="syntaxinlineitalic">position</span> is one of the following:</p>
<dl>
<dd><span class="syntaxinline">AFTER&nbsp;</span><span class="syntaxinlineitalic">dimension-value</span></dd>
<dd><span class="syntaxinline">BEFORE&nbsp;</span><span class="syntaxinlineitalic">dimension-value</span></dd>
<dd><span class="syntaxinline">FIRST</span></dd>
<dd><span class="syntaxinline">LAST</span></dd>
</dl>
</li>
</ul>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5077"></a>Parameters</p>
<dl>
<dt><span class="italic">cursor</span></dt>
<dd>
<p>The name of a declared and opened cursor.</p>
</dd>
<dt>LOOP</dt>
<dd>
<p><a id="sthref5078"></a>Specifies that Oracle OLAP should implicitly loop over the rows obtained from a relational table. For each row, Oracle OLAP copies the data in individual fields to objects specified as target analytic workspace objects. When you include a LOOP clause, SQL FETCH continues processing rows until it reaches the end of the active set specified by the cursor, or an error occurs, or <span class="italic">loopcount</span> is satisfied. In most cases, use the LOOP clause to improve the performance of SQL&nbsp;FETCH.</p>
<p>When you do not specify a LOOP clause and the cursor contains multiple rows in its active set, you must code the SQL FETCH statement within a WHILE loop. This loop must be based on the value of the SQLCODE option, which returns a nonzero value to indicate the end of the data or an error.</p>
</dd>
<dt><span class="italic">loopcount</span></dt>
<dd>
<p>Optional <code>INTEGER</code> argument to the LOOP keyword. <span class="italic">Loopcount</span> controls how SQL&nbsp;FETCH loops over the rows from a relational table. <span class="italic">Loopcount</span> can be a literal value, an OLAP DML variable, or <code>NA</code>. When <span class="italic">loopcount</span> is less than or equal to zero, no looping occurs and no data is fetched.</p>
<p>When you specify a LOOP clause without a value for <span class="italic">loopcount</span>, SQL&nbsp;FETCH continues reading rows and copying their contents to target analytic workspace objects until there are no more rows or an error occurs. Internally, each row is processed until SQLCODE is nonzero.</p>
<p>When you specify a literal value for <span class="italic">loopcount</span>, SQL FETCH processes the number of rows specified by <span class="italic">loopcount</span> or until SQLCODE is nonzero.</p>
<p>When you specify a variable for <span class="italic">loopcount</span>, it must be in the form of an OLAP DML variable (preceded by a colon). This variable acts as both an input and an output variable. The initial value of <span class="italic">loopcount</span> specifies the number of rows that SQL&nbsp;FETCH attempts to process. Upon completion of the SQL FETCH, <span class="italic">loopcount</span> contains the number of rows actually processed.</p>
<p>When you specify <code>NA</code> for <span class="italic">loopcount</span>, SQL FETCH processes rows until SQLCODE is nonzero. However, upon completion of the SQL FETCH, <span class="italic">loopcount</span> contains the number of rows actually processed.</p>
</dd>
<dt><span class="italic">targets</span></dt>
<dd>
<p>Identifies the analytic workspace objects in which you want to store data that is retrieved from a relational table. This list of target analytic workspace objects must correspond in number and data type with the list of table columns specified in the <span class="italic">select-statement</span> argument of the SQL DECLARE CURSOR command that declared <span class="italic">cursor</span>. A target can be a variable, a qualified data reference, a relation, a dimension, a composite, or a conjoint.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
The order in which you specify the target analytic workspace objects affects dimension status. For each dimension value, Oracle OLAP temporarily limits the status of the dimension to the fetched value. Values are assigned to subsequent analytic workspace objects according to this temporary status. See <a href="#i79465">"Conjoints as Target Analytic Workspace Objects"</a> and <a href="#i79472">"Composites as Target Analytic Workspace Objects"</a>.</div>
<p>A target must be preceded by a colon. When the target is a dimension, it can include the MATCH and APPEND keywords to specify dimension handling; in this case, the colon precedes the keywords.</p>
</dd>
<dt>[MATCH] {<span class="italic">dimension</span>|<span class="italic">surrogate</span>}</dt>
<dd>
<p>(Default) Oracle OLAP does not perform dimension maintenance on the <span class="italic">target</span> dimension or surrogate. It uses the incoming values to align data that is being fetched into dimensioned objects. When a value from the relational database does not match any value in the dimension or surrogate, an error is signaled.</p>
</dd>
<dt>APPEND [<span class="italic">position</span>] <span class="italic">dimension</span></dt>
<dd>
<p>Oracle OLAP performs dimension maintenance on the <span class="italic">target</span> dimension, adding new values to the dimension. It uses both old and new dimension values to align data being fetched into dimensioned objects. By default, new values are added to the end of a dimension or surrogate.</p>
<p><span class="italic">position</span> is one of the following:</p>
<ul>
<li>
<p><span class="syntaxinline">AFTER&nbsp;</span><span class="syntaxinlineitalic">dimension-value</span></p>
<p>Any new values are added after <span class="italic">dimension-value</span> in the status list.</p>
</li>
<li>
<p><span class="syntaxinline">BEFORE&nbsp;</span><span class="syntaxinlineitalic">dimension-value</span></p>
<p>Any new values are added immediately before <span class="italic">dimension-value</span> in the status list.</p>
</li>
<li>
<p><span class="syntaxinline">FIRST</span></p>
<p>Any new values are added to the beginning of the status list.</p>
</li>
<li>
<p><span class="syntaxinline">LAST</span></p>
<p>Any new values are added to the end of the status list.</p>
</li>
</ul>
<p>The <span class="italic">position</span> can also be used to control how dimension values are processed in action statements.</p>
</dd>
<dt>ASSIGN <span class="italic">surrogate</span></dt>
<dd>
<p>Assigns the values to the specified surrogate.</p>
</dd>
<dt>THEN <span class="italic">action-statements</span>...</dt>
<dd>
<p>Specifies any number of <span class="italic">action-statements</span> to be performed each time a row of data is fetched and assigned to target analytic workspace objects. An <span class="italic">action-statement</span> can be one of the following:</p>
<p class="synopsis"><span class="syntaxinlineitalic">assignment-statement</span></p>
<p class="synopsis">IF <span class="italic">statement</span></p>
<p class="synopsis">SELECT-<span class="italic">statement</span></p>
<p class="synopsis">ACROSS <span class="italic">statement</span>: <span class="italic">action-statement</span></p>
<p class="synopsis">&lt;<span class="italic">action-statement-group</span>&gt;</p>
<p><a id="sthref5079"></a>Refer to the SQL IMPORT command for a complete description of the syntax of <span class="italic">action-statements</span>.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5080"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2805"></a>Effect of Order SQL FETCH Targets on Dimension Status</p>
<p>For each dimension value, Oracle OLAP temporarily limits the status of the dimension to the fetched value. Values are assigned to subsequent analytic workspace objects according to this temporary status.</p>
<p class="subhead2"><a id="i79465"></a><a id="OLADM2806"></a>Conjoints as Target Analytic Workspace Objects</p>
<p>You can use a conjoint dimension as a target analytic workspace object, but you must ensure that you select the same number of columns from the relational table as there are simple base dimensions. When Oracle OLAP executes a SQL FETCH statement for a target that is a conjoint dimension, it uses the dimension order that was specified when the conjoint was defined.</p>
<p class="subhead2"><a id="i79472"></a><a id="OLADM2807"></a>Composites as Target Analytic Workspace Objects</p>
<p>You can specify analytic workspace objects for composites just as you would for dimensioned variables. For example, to fetch data into a variable <code>var1</code> dimensioned by <code>dim1</code> and <code>dim2</code>, you would specify the following list of target analytic workspace objects.</p>
<pre>
:dim1 :dim2 :var1
</pre>
<p>To fetch data into a variable <code>var2</code> dimensioned by a composite whose dimensions are <code>dim1</code> and <code>dim2</code>, you would specify the following list of target analytic workspace objects.</p>
<pre>
:dim1 :dim2 :var2
</pre>
<p class="subhead2"><a id="OLADM2808"></a>Null Values</p>
<p>A null value in SQL is equivalent to an <code>NA</code> value in Oracle OLAP, so null values fetched into target analytic workspace objects are given <code>NA</code> values. Because Oracle OLAP handles null values in this way, the SQL command does not support <code>INDICATOR</code> variables in the INTO clause of a SQL FETCH statement. When fetching null values into a dimension, however, Oracle OLAP discards the values for the entire row.</p>
<p class="subhead2"><a id="OLADM2809"></a>Working with Boolean Variables as Input and Target Objects</p>
<p>You can use Boolean variables as input and target analytic workspace objects for OLAP SQL commands. In OLAP DML input expressions, Oracle OLAP treats Boolean values as <code>INTEGER</code> values with a value of <code>1</code> (<code>TRUE</code>) or <code>0</code> (<code>FALSE</code>).</p>
<p>As target analytic workspace objects, Boolean variables can receive values from any numeric (or bit) column in a relational table.</p>
<p class="subhead2"><a id="OLADM2810"></a>Fetching Text Data into DATE Variables</p>
<p>When fetching text data into a DATE variable, the current setting of the DATEORDER option is used to interpret the value. For example, a text value of <code>12-08-96</code> could be interpreted as December 8, 1996, or August 12, 1996, depending on the setting of DATEORDER.</p>
<p class="subhead2"><a id="OLADM2811"></a>Untransferable Data Types</p>
<p>You cannot transfer data with the following data types: LONG RAW, ROWID, UROWID, BLOB, and BFILE.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5081"></a>Examples</p>
<div id="OLADM2812" class="example">
<p class="titleinexample"><a id="i1009361"></a>Example 10-136 Fetching Data From Relational Tables -- A Simple SQL FETCH</p>
<p>he following program fragment shows the basic steps of declaring and opening a cursor, and fetching the data. Relational data from the <code>Prod_ID</code> and <code>Prod_Name</code> columns of the <code>Products</code> table are fetched into the <code>prod</code> dimension and <code>prod_label</code> variable. The variable <code>prod_label</code> is dimensioned by <code>prod</code>. Notice that the SQL FETCH statement in this example does not include a LOOP clause; it therefore retrieves a single row of data each time it is called.</p>
<pre>
VARIABLE set_price SHORT
set_price = 20
     ...
SQL DECLARE highprice CURSOR FOR SELECT Prod_ID, Prod_Name -
   FROM Products WHERE suggested_price &gt; :set_price
SQL OPEN highprice
WHILE SQLCODE EQ 0
     SQL FETCH highprice INTO :prod, :prod_label
</pre></div>
<!-- class="example" -->
<div id="OLADM2813" class="example">
<p class="titleinexample"><a id="sthref5082"></a>Example 10-137 Fetching Data From Relational Tables with a THEN Clause</p>
<p>The following program fragment shows the SQL FETCH statement from the previous example with the addition of the LOOP keyword and a THEN clause. Because of the LOOP keyword, this SQL FETCH statement does not have to run within a WHILE loop. The action statement following the THEN keyword copies any product names stored in <code>prod_label</code> that start with the letter <code>A</code> into a multiline text variable called <code>a_product</code>.</p>
<pre>
SQL FETCH highprice LOOP INTO :prod, :prod_label -
   THEN IF UPCASE(EXTCHARS(prod_label, 1, 1)) EQ 'a' -
      THEN a_product = JOINLINES(a_product prod_label)
</pre></div>
<!-- class="example" -->
<div id="OLADM2814" class="example">
<p class="titleinexample"><a id="sthref5083"></a>Example 10-138 Populating with Relational Data While Maintaining a Conjoint Dimension</p>
<p>In this example, a conjoint dimension (named <code>mpt</code>) is used as a target analytic workspace object. To populate a conjoint dimension, you must select values from the relational database for each of its base dimensions. Here, the three base dimensions are <code>market</code>, <code>product</code>, and <code>time</code>. Therefore, the <code>SELECT</code> statement specifies the three corresponding columns (<code>Mktcode</code>, <code>Prdcode</code>, and <code>Percode</code>). The program assumes that the <code>market</code>, <code>product</code>, and <code>time</code> dimensions are already populated with up-to-date values; Oracle OLAP does not update the base dimensions unless you explicitly specify them as target analytic workspace objects.</p>
<pre>
DEFINE mpt DIMENSION &lt;market product time&gt;
DEFINE sql.mpt PROGRAM
PROGRAM
   ...
SQL DECLARE c1 CURSOR FOR -
   SELECT Mktcode, Prdcode, Percode FROM Sqldba.Data
IF SQLCODE NE 0
   THEN SIGNAL sqlerrm
SQL OPEN c1
SQL FETCH c1 LOOP INTO :append mpt
SQL CLOSE c1
   ...
END
</pre></div>
<!-- class="example" -->
<div id="OLADM2815" class="example">
<p class="titleinexample"><a id="sthref5084"></a>Example 10-139 Populating Data While Maintaining Base and Conjoint Dimensions</p>
<p>To retrieve current values for the base and conjoint dimensions, or to retrieve the values for the first time, you can fetch the values for the base dimensions immediately before you fetch the values for the conjoint dimension. In the following example, the SQL DECLARE CURSOR and SQL FETCH commands have been edited to fetch both base and conjoint dimension values. Notice that the number of columns selected from the relational table must match the number of <span class="italic">base</span> dimensions fetched. There are six column specifications in the SELECT statement. The first three match the three base dimensions, and the last three match the conjoint dimension itself.</p>
<pre>
SQL DECLARE c1 CURSOR FOR -
   SELECT Mktcode, Prdcode, Percode, Mktcode,  -
      Prdcode, Percode FROM Sqldba.Data
   ...
  SQL FETCH c1 LOOP INTO :APPEND market, :APPEND product, -
   :APPEND time, :APPEND mpt
</pre></div>
<!-- class="example" -->
<div id="OLADM2816" class="example">
<p class="titleinexample"><a id="sthref5085"></a>Example 10-140 Populating Variables with Relational Table Data while Maintaining Dimensions</p>
<p>In the next example, variable <code>dollars.mpt</code> is dimensioned by the conjoint <code>mpt</code>, and its values are populated in the same SQL FETCH statement with the dimension values. The SQL DECLARE CURSOR and SQL FETCH commands have been edited again with the new column and target analytic workspace object added.</p>
<pre>
DEFINE dollars.mpt DECIMAL &lt;mpt&gt;
SQL DECLARE c1 CURSOR FOR -
   SELECT Mktcode, Prdcode, Percode, Mktcode, Prdcode, -
      Percode, Dollars FROM Sqldba.Data
   ...
SQL FETCH c1 LOOP INTO :APPEND market, :APPEND product, -
   :APPEND time, :APPEND mpt, :DOLLARS.mpt 
</pre></div>
<!-- class="example" -->
<div id="OLADM2817" class="example">
<p class="titleinexample"><a id="CHDIJEAB"></a><a id="i1009978"></a>Example 10-141 Fetching Data into a Concat Dimension</p>
<p>Assume that a relational table has four columns of product data and that you decide to create a Product hierarchy with four levels in your analytic workspace to hold this data. The levels in the hierarchy (<code>prod_id</code>, <code>prod_subcategory</code>, <code>prod_category</code>, and <code>products_all</code>) map to columns in the <code>products</code> tables. The lowest level of the hierarchy is <code>prod_id</code> and the highest level is <code>products_all</code>. There is also a column with supplier information in the table.</p>
<p>To hold the data in the analytic workspace you define a dimension was defined for each level of the Product hierarchy, a concat dimension for the hierarchy itself, and a child-parent relation between the values in the hierarchy. You also define a dimension for the supplier data and a relation that holds the relationship between suppliers and products with the following definitions.</p>
<pre>
DEFINE aw_prod_id DIMENSION NUMBER (6)
DEFINE aw_prod_subcategory DIMENSION TEXT
DEFINE aw_prod_category DIMENSION TEXT
DEFINE aw_products_all DIMENSION TEXT
DEFINE aw_products DIMENSION CONCAT (aw_products_all -
                                  aw_prod_category -
                                  aw_prod_subcategory -
                                  aw_prod_id)
DEFINE aw_products.parents RELATION aw_products &lt;aw_products&gt;
DEFINE aw_supplier_id DIMENSION NUMBER (6)
DEFINE aw_prod_id.aw_supplier_id RELATION aw_supplier_id &lt;aw_prod_id&gt;
</pre>
<p>Assume that you write a program named <code>get_products_hier</code> that consists of the following code.</p>
<pre>
' get_products_hier Program
ALLSTAT
" Fetch values into the products hierarchy
SQL DECLARE grabprods CURSOR FOR SELECT prod_total, -
                                        prod_category, -
                                        prod_subcategory, -
                                        prod_id -
                                   FROM sh.products
SQL OPEN grabprods
SQL IMPORT grabprods INTO :APPEND aw_products_all -
                              :APPEND aw_prod_category -
                              :APPEND aw_prod_subcategory -
                              :APPEND aw_prod_id 
                         
SQL CLOSE grabprods 
SQL CLEANUP
" Update the analytic workspace and make the updates permanent
UPDATE
COMMIT
" Fetch values into supplier_id
SQL DECLARE grabsupid CURSOR FOR SELECT supplier_id -
                                 FROM sh.products
SQL OPEN grabsupid
SQL IMPORT grabsupid INTO :APPEND aw_supplier_id 
SQL CLOSE grabsupid 
SQL CLEANUP
" Update the analytic workspace and make the updates permanent
UPDATE
COMMIT

" Populate self-relation for concat dimension
" and relation between aw_prod_id and aw_supplier_id
SQL DECLARE makerels CURSOR FOR SELECT prod_total, -
                                       prod_category, -
                                       prod_subcategory, -
                                       prod_id, -
                                       supplier_id -
                                 FROM sh.products
SQL OPEN makerels
SQL FETCH makerels LOOP INTO :MATCH aw_products_all -
                             :MATCH aw_prod_category -
                             :MATCH aw_prod_subcategory -
                             :MATCH aw_prod_id -
                             :MATCH aw_supplier_id -
            THEN aw_products.parents(aw_products aw_prod_id) -
                = aw_products(aw_prod_subcategory aw_prod_subcategory) -
            aw_products.parents(aw_products aw_prod_subcategory) -
               = aw_products(aw_prod_category aw_prod_category) -
            aw_products.parents(aw_products aw_prod_category) -
               = aw_products(aw_products_all aw_products_all) -
            aw_prod_id.aw_supplier_id = aw_supplier_id         
SQL CLOSE makerels 
SQL CLEANUP
" Update the analytic workspace and make the updates permanent
UPDATE
COMMIT
</pre></div>
<!-- class="example" -->
<p>The <code>get_products_hier</code> program copies the data from the dimension tables into the base dimensions of the <code>aw_products</code> concat dimension using <code>SQL FETCH</code> commands with the <code>APPEND</code> keyword. As the base dimensions of <code>aw_products</code> are populated, Oracle OLAP automatically populates <code>aw_products</code>, itself. As the <code>THEN</code> clause of the <code>SQL FETCH</code> statement executes, Oracle OLAP fetches data into the child-parent self-relation for <code>aw_products</code>. This program also populates the <code>aw_supplier_id</code> dimension and its relation.</p>
</div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM911" class="refsect2"><a id="i78693"></a>
<hr />
<h2 class="refsect2">SQL IMPORT</h2>
<p><a id="sthref5086"></a><a id="sthref5087"></a>The SQL IMPORT command retrieves and processes data specified by an explicit SQL cursor. SQL IMPORT assigns the retrieved data to OLAP objects. You use the SQL IMPORT command in combination with other SQL commands to copy data from relational tables into analytic workspace objects as outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a>. SQL IMPORT is particularly effective in copying fact data from relational tables into analytic workspace variables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot transfer data with the following data types: LONG, BLOB, and BFILE.</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5088"></a>Syntax</p>
<p class="synopsis">SQL IMPORT <span class="italic">cursor</span> [:<span class="italic">var-num-of-rows</span> |<span class="italic">num-of-rows</span>[:<span class="italic">var-num-of-processed-rows</span>]]-</p>
<p class="synopsis">INTO :<span class="italic">targets</span>... [THEN <span class="italic">action-statements</span>...]</p>
<p>where:</p>
<ul>
<li>
<p><span class="syntaxinlineitalic">targets</span> is one or more of the following:</p>
<dl>
<dd><span class="syntaxinline">MATCH | MATCHSKIPERR [</span><span class="syntaxinlineitalic">position</span><span class="syntaxinline">]&nbsp;{</span><span class="syntaxinlineitalic">dimension</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">surrogate</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">valueset</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">relation</span><span class="syntaxinline">}</span></dd>
<dd><span class="syntaxinline">APPEND</span>&nbsp;<span class="syntaxinlineitalic">dimension</span></dd>
<dd><span class="syntaxinline">ASSIGN</span>&nbsp;<span class="syntaxinlineitalic">surrogate</span></dd>
<dd><span class="syntaxinlineitalic">variable</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">relation</span> <span class="syntaxinline">|</span> <span class="syntaxinlineitalic">qualified&nbsp;data&nbsp;reference</span></dd>
</dl>
</li>
<li>
<p><span class="syntaxinlineitalic">action-statements</span> is one of the following:</p>
<dl>
<dd><span class="syntaxinlineitalic">assignment-statement</span></dd>
<dd><span class="syntaxinlineitalic">IF-statement</span></dd>
<dd><span class="syntaxinlineitalic">SELECT-statement</span></dd>
<dd><span class="syntaxinlineitalic">ACROSS-statement</span><span class="syntaxinline">:</span> <span class="syntaxinlineitalic">action-statement</span></dd>
<dd><span class="syntaxinline">&lt;</span><span class="syntaxinlineitalic">action-statement-group</span><span class="syntaxinline">&gt;</span></dd>
</dl>
</li>
</ul>
<p class="synopsis">&nbsp;</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5089"></a>Parameters</p>
<dl>
<dt><span class="italic">cursor</span></dt>
<dd>
<p>The name of a declared cursor.</p>
</dd>
<dt><span class="italic">var-num-of-rows</span></dt>
<dd>
<p>The name of a variable that specifies the number of rows that you want SQL IMPORT to attempt to import.</p>
</dd>
<dt><span class="italic">num-of-rows</span></dt>
<dd>
<p>A numeric constant that specifies the number of rows that you want SQL IMPORT to attempt to import.</p>
</dd>
<dt><span class="italic">var-num-of-processed-rows</span></dt>
<dd>
<p>When you include the MATCHSKIPERR keyword in the <span class="italic">targets</span> parameter, the name of a variable that specifies the actual number of rows that you want SQL IMPORT to import into analytic workspace objects.</p>
</dd>
<dt><span class="italic">targets</span></dt>
<dd>
<p>Identifies the analytic workspace objects in which you want to store data that is retrieved from a relational table. This list of target analytic workspace objects must correspond in number and data type with the list of table columns specified in the <span class="italic">select-statement</span> argument of the SQL DECLARE CURSOR command that declared <span class="italic">cursor</span>. A target can be a variable, a qualified data reference, a relation, a dimension, or a composite.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
The order in which you specify the analytic workspace objects affects dimension status. For each dimension value, Oracle OLAP temporarily limits the status of the dimension to the fetched value. Values are assigned to subsequent analytic workspace objects according to this temporary status.</div>
</dd>
<dt>MATCH</dt>
<dd>
<p>(Default) Oracle OLAP does not copy values from the corresponding relational table column into the <span class="italic">target</span> dimension or surrogate. It only uses the values to align data that is being fetched into dimensioned objects. When a value from the relational database does not match any value in the dimension, an error is signaled.</p>
</dd>
<dt>MATCHSKIPERR</dt>
<dd>
<p>Oracle OLAP does not copy values from the corresponding relational table column into the <span class="italic">target</span> dimension or surrogate. It only uses the values to align data that is being fetched into dimensioned objects. When a value from the relational database does not match any value in the dimension, the value is ignored and processing continues without signaling an error.</p>
</dd>
<dt><span class="italic">position</span></dt>
<dd>
<p>The one-based logical position of the value.</p>
</dd>
<dt>APPEND</dt>
<dd>
<p>Oracle OLAP performs dimension maintenance on the <span class="italic">target</span> dimension, adding new values from the corresponding relational table column to the dimension. It uses both old and new dimension values to align data being fetched into dimensioned objects. New values are added to the end of a dimension.</p>
</dd>
<dt>ASSIGN</dt>
<dd>
<p>Oracle OLAP assigns the corresponding relational value to the specified surrogate.</p>
</dd>
<dt><span class="italic">dimension</span></dt>
<dd>
<p>The name of the analytic workspace dimension.</p>
</dd>
<dt><span class="italic">surrogate</span></dt>
<dd>
<p>The name of an analytic workspace surrogate.</p>
</dd>
<dt><span class="italic">valueset</span></dt>
<dd>
<p>The name of the analytic valueset.</p>
</dd>
<dt><span class="italic">relation</span></dt>
<dd>
<p>The name of the analytic workspace relation.</p>
</dd>
<dt><span class="italic">variable</span></dt>
<dd>
<p>The name of a variable.</p>
</dd>
<dt><span class="italic">qualified_data_reference</span></dt>
<dd>
<p>A QDR is a qualifier that limits one or more of the dimensions of a variable or a relation to a single value. Oracle OLAP evaluates QDRs in a SQL IMPORT statement, as follows:</p>
<ul>
<li>
<p>When the QDR includes an expression, the expression is evaluated only once before the data is retrieved. In other words, the expression is, in essence, a constant.</p>
</li>
<li>
<p>When the QDR is specified as a relation name, the values of the QDR vary depending on the status of the dimensions of that relation.</p>
</li>
</ul>
</dd>
<dt>THEN <span class="italic">action-statements</span>...</dt>
<dd>
<p>Specifies any number of <span class="italic">action-statements</span> to be performed each time a row of data is imported and assigned to analytic workspace objects. Action statements may contain simple assignment statements, conditional assignment statements, and assignments across dimensions.</p>
<p>Action statements allow you to examine and manipulate the fetched data on a row-by-row basis. For example, you may want to specify temporary objects as analytic workspace objects and only update your permanent objects once you have performed certain actions on the row of fetched data. However, action statements do not have to reference the imported data. For example, one of your action statements might be an assignment statement that executes a user-defined function (that is, a program) that performs complex processing and then simply increments a counter.</p>
<p>A THEN clause can improve SQL loading performance by eliminating the need for postprocessing upon completion of a SQL IMPORT.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The syntax of an action statement within SQL IMPORT is essentially the same as the syntax of an action statement within FILEREAD. Exceptions are in the syntax of an assignment statement and the use of the VALUE keyword. In SQL IMPORT action statements, assignments must be explicit; they must include a source, target, and equal sign. In FILEREAD action statements, assignments may be implicit and specify only the target. The VALUE keyword is supported in FILEREAD action statements, but not in SQL IMPORT action statements. When you have already specified action statements for use with FILEREAD, you can reuse the code with SQL IMPORT by simply adjusting the assignment statements and eliminating the VALUE keyword (if necessary). Most of the attributes listed in FILEREAD (except for the attributes that control dimension processing) are not meaningful for SQL loading and are ignored when executing within SQL IMPORT.
<p>For best performance, within a THEN clause reference only the data within the imported row.</p>
</div>
<p>In your list of action statements, <span class="italic">be sure to process dimensions before variables</span>. Oracle OLAP processes each action statement from left to right for each row in the relational table. When an action statement performs dimension processing, the resulting status remains in effect for subsequent action statements. When you do not first specify action statements that limit a variable's dimensions, Oracle OLAP uses the first value in status to target a cell in the variable. Unless you specify an ACROSS phrase, Oracle OLAP assigns a single value from a row to a single cell in an Oracle OLAP variable. By default, Oracle OLAP does <span class="italic">not</span> loop over a variable's dimensions when assigning data to the variable.</p>
</dd>
<dt><span class="italic">assignment-statement</span></dt>
<dd>
<p>An assignment statement (SET) that assigns a value that is the result of an expression to an Oracle OLAP object.</p>
</dd>
<dt><span class="italic">IF-statement</span></dt>
<dd>
<p>An IF...THEN...ELSE command that performs some action depending on whether a Boolean expression is <code>TRUE</code> or <code>FALSE</code>.</p>
</dd>
<dt><span class="italic">SELECT-statement</span></dt>
<dd>
<p>A SQL SELECT statement lets you perform some action based on the value of an expression. A SELECT statement has the following form.</p>
<dl>
<dd><span class="syntaxinline">SELECT</span> <span class="syntaxinlineitalic">select-expression</span></dd>
<dd><span class="syntaxinline">[WHEN</span> <span class="syntaxinlineitalic">expression1 action</span><span class="syntaxinline">]</span></dd>
<dd><span class="syntaxinline">[WHEN</span> <span class="syntaxinlineitalic">expression2 action</span> <span class="syntaxinline">. . .]</span></dd>
<dd><span class="syntaxinline">[ELSE</span> <span class="syntaxinlineitalic">action</span><span class="syntaxinline">]</span></dd>
</dl>
<p>SELECT evaluates the SELECT expression and then sequentially compares the result with the WHEN expressions. When the first match is found, the associated <span class="italic">action</span> occurs. When no match is found, the ELSE <span class="italic">action</span> (if specified) occurs.</p>
</dd>
<dt><span class="syntaxinlineitalic">ACROSS-statement</span>: <span class="italic">action-statement</span></dt>
<dd>
<p><a id="sthref5090"></a>An ACROSS statement causes the following action statement to execute once for every value in status of the ACROSS dimension. When you want the looping to apply to multiple action statements, enclose the action statements in angle brackets. An ACROSS statement has the following form.</p>
<p class="synopsis">ACROSS <span class="italic">dimension</span> [<span class="italic">limit</span>]:</p>
<p class="synopsis"><span class="italic">action-statement</span></p>
<p>In an ACROSS statement, <span class="italic">limit</span> temporarily change the status of <span class="italic">dimension</span>, if it is not in a FOR loop over <span class="italic">dimension</span>. The new status is in effect only for the duration of the SQL FETCH statement. The format of <span class="italic">limit</span> is as follows.</p>
<p class="synopsis">[ADD|COMPLEMENT|KEEP|REMOVE|<span class="underline">TO</span>] <span class="italic">limit-clause</span></p>
<p>To specify the temporary status, insert any of the LIMIT command keywords (the default is TO) along with an appropriate list of dimension values or related dimensions. You can use any valid limit clause (see the <a href="dml_commands_2009.htm#i78802">LIMIT command</a> for further information). The following example limits <code>month</code> to the last six values, no matter what the current status of <code>month</code> is.</p>
<pre>
   ACROSS month last 6: units
</pre></dd>
<dt>&lt;<span class="italic">action-statement-group</span>&gt;</dt>
<dd>
<p>You can group several action statements by enclosing them in angle brackets. An <span class="italic">action-statement-group</span> has the following form.</p>
<p class="synopsis">&lt;<span class="italic">action-statement1</span> -</p>
<p class="synopsis">[<span class="italic">action-statement2</span> . . .]&gt;</p>
<p>A typical use for action statement groups is after an ACROSS statement. With the angle bracket syntax, you can cause multiple action statements to execute for every value in status of the ACROSS dimension.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5091"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2818"></a>Effect of Order of SQL SELECT Targets on Dimension Status</p>
<p>For each dimension value, Oracle OLAP temporarily limits the status of the dimension to the fetched value. Values are assigned to subsequent analytic workspace objects according to this temporary status.</p>
<p class="subhead2"><a id="OLADM2819"></a>Working with Boolean Data Variables</p>
<p>You can use Boolean variables as input and target analytic workspace objects for OLAP SQL commands. In OLAP DML input expressions, Oracle OLAP treats Boolean values as <code>INTEGER</code> values with a value of <code>1</code> (TRUE) or <code>0</code> (FALSE).</p>
<p>As target analytic workspace objects, Boolean variables can receive values from any numeric (or bit) column in a relational table.</p>
<p class="subhead2"><a id="OLADM2820"></a>Importing Text Data into a DATE Variable</p>
<p>When importing text data into a DATE variable, the current setting of the DATEORDER option is used to interpret the value. For example, a text value of 12-08-96 could be interpreted as December 8, 1996, or August 12, 1996, depending on the setting of DATEORDER.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5092"></a>Examples</p>
<div id="OLADM2821" class="example">
<p class="titleinexample"><a id="sthref5093"></a>Example 10-142 Simple Import</p>
<p>The following program fragment shows the basic steps of declaring a cursor and importing the data. Values from the <code>Prod_ID</code> and <code>Prod_Name</code> columns of the <code>Products</code> relational table in the Sales -History (<code>sh</code>) database are fetched into the <code>prod_id</code> dimension and <code>prod_label</code> analytic workspace variable. The <code>prod_label</code> variable is dimensioned by <code>prod_id</code>.</p>
<pre>
SQL DECLARE productcur CURSOR FOR SELECT Prod_ID, Prod_Name FROM sh.Products
SQL OPEN productdur
SQL IMPORT productcur INTO :prod_id, :prod_label
SQL CLOSE productcur
SQL CLEANUP 
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM912" class="refsect2"><a id="i78685"></a>
<hr />
<h2 class="refsect2">SQL OPEN</h2>
<p><a id="sthref5094"></a>The SQL OPEN command activates an explicitly-declared SQL cursor. When the cursor is opened, SQL examines any OLAP DML input expressions used in the definition of the specified cursor, determines the cursor's result set, and leaves the cursor in the open state for use by SQL FETCH or SQL IMPORT. The cursor is positioned before the first row of the result set.</p>
<p>You use the SQL OPEN command in combination with other SQL commands to copy data from relational tables into analytic workspace objects as outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5095"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;OPEN&nbsp;<span class="italic">cursor</span></p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5096"></a>Parameters</p>
<dl>
<dt><span class="italic">cursor</span></dt>
<dd>
<p>The name of a cursor previously declared in the same program. You cannot use ampersand substitution.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5097"></a>Examples</p>
<div id="OLADM2822" class="example">
<p class="titleinexample"><a id="sthref5098"></a>Example 10-143 Opening a Cursor Using SQL OPEN</p>
<p>The following program fragment declares and opens a cursor named <code>geolabels</code>.</p>
<pre>
SQL DECLARE geolabels CURSOR FOR -
   SELECT Store_ID, Store_Name, City FROM Stores
IF SQLCODE NE 0
   THEN SIGNAL dclerror 'SQLERRM'
SQL OPEN geolabels
IF SQLCODE NE 0
   THEN SIGNAL operror 'SQLERRM' 
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM913" class="refsect2"><a id="i78976"></a>
<hr />
<h2 class="refsect2">SQL PREPARE</h2>
<p><a id="sthref5099"></a><a id="sthref5100"></a><a id="sthref5101"></a>Within a program, the SQL PREPARE command precompiles a SQL statement for later execution, in the same program using SQL EXECUTE. Typically, you use SQL PREPARE in programs to optimize the processing of SQL statements that are executed repeatedly, particularly those involving OLAP DML input expressions, such as INSERT, UPDATE, and DELETE.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5102"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;PREPARE&nbsp;<span class="italic">statement-name&nbsp;</span>FROM&nbsp;<span class="italic">sql-statement</span> [<span class="italic">insert-options</span>]</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5103"></a>Parameters</p>
<dl>
<dt><span class="italic">statement-name</span></dt>
<dd>
<p>A name that you assign to the executable code produced from <span class="italic">sql-statement.</span> You can redefine <span class="italic">statement-name</span> just by issuing another SQL PREPARE statement.</p>
</dd>
<dt><span class="italic">sql-statement</span></dt>
<dd>
<p>The SQL statement that you want to precompile for more efficient execution. It cannot contain ampersand substitution or variables that are undefined when the program is compiled.</p>
</dd>
<dt><span class="italic">insert-options</span></dt>
<dd>
<p>The following options are optional when <span class="italic">sql-statement</span> is an <code>INSERT</code> statement:</p>
<p><span class="syntaxinlinebold">DIRECT=YES|NO</span> specifies if the insert is a direct-path <code>INSERT</code>. This option must be the first option specified right aver the <span class="italic">values</span> phrase of the <code>INSERT</code> statement.</p>
<p>Setting this option to <code>YES</code> specifies that the insert is a direct-path <code>INSERT</code>. Direct-path <code>INSERT</code> enhances performance during <code>INSERT</code> operations and is similar to the functionality of Oracle's direct-path loader utility, SQL*Loader.&nbsp;</p>
<p>The default value is <code>NO</code> which specifies a normal <code>INSERT</code>.</p>
<p><span class="syntaxinlinebold">NOLOG=YES|NO</span> specifies if logging occurs. Setting this option to <code>YES</code> specifies that the redo information is not recorded in the redo log files which makes load-time faster. The default value is <code>NO</code> which specifies logging mode.</p>
<p><span class="syntaxinlinebold">PARTITION=</span><span class="syntaxinlineboldital">(sub)partition-name</span> specifies that only the segments related to the named partition or subpartition are locked.<a id="sthref5104"></a><a id="sthref5105"></a> When you specify this option, another session can insert data to unrelated segments in the same table. When you do not specify this option (the default), other sessions cannot insert data into the same table.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5106"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2823"></a>Using Direct-Path INSERT</p>
<p>When performing a direct-path <code>INSERT</code>, data is written directly into data files, bypassing the buffer cache, free space in the existing data is not reused, and the inserted data is appended after existing data in the table.</p>
<p><a id="OLADM2824"></a><span class="subhead3">Restrictions When Using Direct-Path INSERT&nbsp;</span>Direct-path <code>INSERT</code> is subject to several restrictions. When executing a direct-path <code>INSERT</code> using the OLAP DML, transactions in the session issuing the direct-path <code>INSERT</code> must be committed for the <code>INSERT</code> to execute successfully. (You can use the SQL or OLAP DML COMMIT to commit transactions.)</p>
<p>Additionally, the general restrictions that apply to using direct-path <code>INSERT</code> in SQL apply to preparing a direct-path<code>INSERT</code> using OLAP DML PREPARE statements:</p>
<ul>
<li>
<p>The target table cannot be index organized or clustered.</p>
</li>
<li>
<p>The target table cannot contain object type or LOB columns.</p>
</li>
<li>
<p>The target table cannot have any triggers or referential integrity constraints defined on it.</p>
</li>
</ul>
<p>For more information on restrictions when using a direct-path INSERT, see the discussion of the <code>INSERT</code> statement in <span class="italic">Oracle Database SQL Language Reference</span>.</p>
<p><a id="OLADM2825"></a><span class="subhead3">Data Type Conversions During Direct-Path Insertion&nbsp;</span><a href="#CHDGDEFD">Table 10-11, "Automatic Data Type Conversion During Direct-Path Insertion"</a> shows the automatic data type conversion performed during direct-path insertion.</p>
<div id="OLADM2826" class="tblformal">
<p class="titleintable"><a id="sthref5107"></a><a id="CHDGDEFD"></a>Table 10-11 Automatic Data Type Conversion During Direct-Path Insertion</p>
<table class="cellalignment3098" title="Automatic Data Type Conversion During Direct-Path Insertion" summary="This table outlines how Oracle OLAP automatically converts data types in the RDBMS to OLAP DML data types." dir="ltr">
<thead>
<tr class="cellalignment3089">
<th class="cellalignment3099" id="r1c1-t120">Oracle RDBMS</th>
<th class="cellalignment3099" id="r1c2-t120">Oracle OLAP DML</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r2c1-t120" headers="r1c1-t120">
<p>CHAR(<span class="italic">n</span>), VARCHAR(<span class="italic">n</span>)</p>
</td>
<td class="cellalignment3095" headers="r2c1-t120 r1c2-t120">
<p>TEXT</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r3c1-t120" headers="r1c1-t120">
<p>LONG</p>
</td>
<td class="cellalignment3095" headers="r3c1-t120 r1c2-t120">
<p>TEXT with WIDE option</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r4c1-t120" headers="r1c1-t120">
<p>CHAR(8), VARCHAR(8)</p>
</td>
<td class="cellalignment3095" headers="r4c1-t120 r1c2-t120">
<p>ID</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r5c1-t120" headers="r1c1-t120">
<p>DATE</p>
</td>
<td class="cellalignment3095" headers="r5c1-t120 r1c2-t120">
<p>DATE</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r6c1-t120" headers="r1c1-t120">
<p>NUMBER(<span class="italic">x</span>,<span class="italic">x</span>)</p>
</td>
<td class="cellalignment3095" headers="r6c1-t120 r1c2-t120">
<p>DECIMAL (SHORTDECIMAL)</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r7c1-t120" headers="r1c1-t120">
<p>INTEGER (or NUMBER(38)</p>
</td>
<td class="cellalignment3095" headers="r7c1-t120 r1c2-t120">
<p>INTEGER (SHORTINTEGER)</p>
</td>
</tr>
<tr class="cellalignment3089">
<td class="cellalignment3095" id="r8c1-t120" headers="r1c1-t120">
<p>NUMBER(1)</p>
</td>
<td class="cellalignment3095" headers="r8c1-t120 r1c2-t120">
<p>BOOLEAN</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a id="OLADM2827"></a><span class="subhead3">Inserting OLAP Text Data into a Column with a DATE Data Type&nbsp;</span>When inserting text data from Oracle OLAP into a column with a DATE data type, you must use the default date format of <code>DD</code> <code>MMM</code> <code>YY</code>. You can use slashes (<code>/</code>), hyphens (<code>-</code>), or spaces as separators. When the data is in a different format, you can use the Oracle <code>TO_DATE</code> function in a SQL <code>INSERT</code> statement.</p>
<p><a id="BJEIFAHJ"></a><a id="OLADM2828"></a><span class="subhead3">Inserting Large Text Values into a CLOB or NCLOB Column&nbsp;</span>To insert more than 2K bytes of text data from an analytic workspace into a CLOB or NCLOB column, use the WIDE keyword before the name of the OLAP DML input expression. When the data type of the OLAP DML input expression is <code>TEXT</code>, then the target data type is CLOB. When the data type of the input expression is NTEXT, then the target data type is NCLOB.</p>
<p>The following is the syntax of an OLAP DML input expression with the WIDE keyword. See <a href="#BJEEDEEH">Example 10-146, "Using the WIDE Keyword"</a> for an example.</p>
<pre>
:WIDE input-expression
</pre>
<p>See <a href="#BJEEDEEH">Example 10-146, "Using the WIDE Keyword"</a> for an example.</p>
<p>Note that the target table must conform to these guidelines:</p>
<ul>
<li>
<p>Any number and combination of CLOB and NCLOB columns</p>
</li>
<li>
<p>No LONG columns</p>
</li>
</ul>
<p>The RDBMS imposes some restrictions on large data types. Oracle OLAP does not signal an error when you violate these restrictions. However, you might get unexpected results. Refer to the <span class="italic">Oracle Application Developer's Guide</span> for restrictions on large data types.</p>
<p class="subhead2"><a id="OLADM2829"></a>Calculating the Number of Characters</p>
<p>You can calculate the number of characters that are sent to a database table from an Oracle OLAP variable by using the following formula.</p>
<pre>
NUMCHARS(variable) + 2 * (NUMLINES(variable) - 1)
</pre>
<p>This formula counts the extra carriage return and line feed characters that Oracle OLAP inserts between lines when passing the text to the database.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5108"></a>Examples</p>
<div id="OLADM2830" class="example">
<p class="titleinexample"><a id="sthref5109"></a>Example 10-144 Preparing a FOR Loop</p>
<p>To automatically add all the sales people from the <code>salesperson</code> dimension to the relational table, you could write a program and put the SQL <code>INSERT</code> statement in a FOR loop.</p>
<pre>
FOR salesperson
   SQL INSERT INTO Sales VALUES (:Salesperson, :Dollars) DIRECT=YES
</pre>
<p>When a statement includes OLAP DML input expressions and are executed repeatedly, such as in a FOR loop, you can make the statements more efficient by "preparing" the SQL statement first. The INSERT statement becomes part of a PREPARE statement.</p>
<pre>
SQL PREPARE s1 FROM INSERT INTO Sales VALUES -
   (:Salesperson, :Dollars) DIRECT=YES
FOR Salesperson
   DO
      SQL EXECUTE s1
      IF SQLCODE NE 0
      THEN BREAK
   DOEND
</pre></div>
<!-- class="example" -->
<div id="OLADM2831" class="example">
<p class="titleinexample"><a id="sthref5110"></a>Example 10-145 Updating a Table</p>
<p>The next example shows a simple update of a table using data stored in an analytic workspace. The <code>market</code> dimension is limited to one value at a time in the FOR loop. The SQL phrase <code>WHERE S.Market=:market</code> specifies that the sales value in the row for that market is the value that is changed.</p>
<pre>
FOR market
   SQL UPDATE Mkt SET Sales=:Mkt.Sales WHERE S.Market=:market
</pre>
<p>Like the INSERT statement in the previous example, an <code>UPDATE</code> statement should be used in a PREPARE statement and executed in an ACROSS statement or FOR loop.</p>
<pre>
SQL PREPARE s2 FROM UPDATE mkt -
   SET Sales=:mkt.sales WHERE s.market=:market
ACROSS market DO 'SQL EXECUTE s1'
</pre></div>
<!-- class="example" -->
<div id="OLADM2832" class="example">
<p class="titleinexample"><a id="BJEEDEEH"></a>Example 10-146 Using the WIDE Keyword</p>
<p>In both of the following statements, <code>WIDE</code> indicates that the target value is <code>CLOB</code> when <code>var1</code> is <code>TEXT</code>, or <code>NCLOB</code> when <code>var1</code> is <code>NTEXT</code>.</p>
<pre>
SQL INSERT INTO CLOB_TEST values (:dim1 :WIDE var1)
SQL UPDATE CLOB_TEXT SET clob_col = :WIDE var1 WHERE key = 1
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM914" class="refsect2"><a id="BJEIJDAD"></a>
<hr />
<h2 class="refsect2">SQL PROCEDURE</h2>
<p><a id="sthref5111"></a><a id="ABC1072349"></a>The SQL PROCEDURE command executes procedures stored in the RDBMS.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can also create SQL stored procedures using the OLAP DML. See:
<ul>
<li>
<p><a href="#BJEHEAAH">"Creating SQL Procedures using the OLAP DML"</a></p>
</li>
<li>
<p><a href="#BJEFBHEA">Example 10-147, "Creating a Stored Procedure"</a></p>
</li>
</ul>
</div>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5112"></a>Syntax</p>
<p class="synopsis">SQL PROCEDURE <span class="italic">procedure-name</span> (<span class="italic">parameters</span>)</p>
<p>where <span class="syntaxinlineitalic">parameters</span> is one or more of the following, separated by commas:</p>
<dl>
<dd><span class="syntaxinlineitalic">sql-parameter</span></dd>
<dd><span class="syntaxinline">:</span><span class="syntaxinlineitalic">dml-parameter</span></dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5113"></a>Parameters</p>
<dl>
<dt><span class="italic">procedure-name</span></dt>
<dd>
<p>The name of the SQL stored procedure.</p>
</dd>
<dt><span class="italic">sql-parameter</span></dt>
<dd>
<p>The name of a variable in the RDBMS.</p>
</dd>
<dt>:<span class="italic">dml-parameter</span></dt>
<dd>
<p>An OLAP DML expressions such as an OLAP DML variable. See <a href="#BJEHBHBI">"Using OLAP DML Expressions in OLAP DML SQL Statements"</a> for more information on using OLAP DML expressions in OLAP DML SQL statements.</p>
</dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5114"></a>Usage Notes</p>
<p class="subhead2"><a id="BJEHEAAH"></a><a id="OLADM2833"></a>Creating SQL Procedures using the OLAP DML</p>
<p>To create a stored procedure using the OLAP DML, issue an OLAP DML SQL statement with a SQL <code>CREATE PROCEDURE</code> statement as its argument. The syntax for coding <code>CREATE PROCEDURE</code> as an argument within an OLAP DML SQL statement is slightly different than the syntax for coding <code>CREATE PROCEDURE</code> in SQL proper. When coded as an arguments to an OLAP DML statements, use a tilde (<code>~</code>) instead of a semicolon as a terminator, and two colons instead of one in an assignment statement. See <a href="#BJEFBHEA">Example 10-147, "Creating a Stored Procedure"</a>.</p>
<p class="subhead2"><a id="OLADM2834"></a>Restrictions When Calling SQL Procedures using the OLAP DML</p>
<p>A stored procedure called using an OLAP DML SQL PROCEDURE statement cannot contain output variables or transactions.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5115"></a>Examples</p>
<div id="OLADM2835" class="example">
<p class="titleinexample"><a id="BJEFBHEA"></a><a id="i79336"></a>Example 10-147 Creating a Stored Procedure</p>
<p><a id="sthref5116"></a><a id="sthref5117"></a>The following example shows the syntax for creating a procedure named <code>new_products</code>.</p>
<pre>
SQL CREATE OR REPLACE PROCEDURE new_products -
   (id CHAR, name CHAR, cost NUMBER) AS -
      price NUMBER~ -
   BEGIN -
      price ::= cost * 2.5~ -
      INSERT INTO products -
         VALUES(id, name, price)~ -
   END~
</pre></div>
<!-- class="example" -->
<div id="OLADM2836" class="example">
<p class="titleinexample"><a id="i79346"></a>Example 10-148 Executing a Stored Procedure</p>
<p><a id="sthref5118"></a>The following FOR loop executes a SQL stored procedure named <code>new_products</code> and inserts data stored in dimensions and variables into a relational table. In this example, <code>prod</code> is an Oracle OLAP dimension, and <code>labels.p</code> and <code>cost.p</code> are variables dimensioned by <code>prod<a id="sthref5119"></a></code>.</p>
<pre>
FOR prod
   DO
      SQL PROCEDURE new_products(:prod, :labels.p, :cost.p)
      IF SQLCODE NE 0
         THEN BREAK
   DOEND 
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" -->
<div id="OLADM915" class="refsect2"><a id="i78599"></a>
<hr />
<h2 class="refsect2">SQL SELECT</h2>
<p><a id="sthref5120"></a>The SQL SELECT command<a id="sthref5121"></a><a id="sthref5122"></a><a id="sthref5123"></a> uses an implicit cursor to copy data from relational tables into analytic workspace objects. You use the SQL SELECT command to copy data from relational tables into analytic workspace objects using an implicit cursor. You can also use copy the data using an explicit cursor using the OLAP DML commands outlined in <a href="#i79314">"Copying Relational Data into Analytic Workspace Objects"</a>.</p>
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5124"></a>Syntax</p>
<p class="synopsis">SQL&nbsp;SELECT <span class="italic">expressions</span> FROM <span class="italic">tables</span>&nbsp;-</p>
<p class="synopsis">[WHERE <span class="italic">predicates</span>] [GROUP BY <span class="italic">expressions</span>] -</p>
<p class="synopsis">[ORDER BY <span class="italic">expressions</span>] [HAVING <span class="italic">predicates</span>] -</p>
<p class="synopsis">INTO&nbsp;:<span class="italic">targets.</span>..&nbsp;[THEN&nbsp;<span class="italic">action-statements</span>...]</p>
<p>where <span class="syntaxinlineitalic">targets</span> is one or more of the following:</p>
<dl>
<dd><span class="syntaxinline">[MATCH]&nbsp;</span><span class="syntaxinlineitalic">dimension</span><span class="syntaxinline">|</span><span class="syntaxinlineitalic">surrogate</span></dd>
<dd><span class="syntaxinline">APPEND&nbsp;[</span><span class="syntaxinlineitalic">position</span><span class="syntaxinline">]&nbsp;</span><span class="syntaxinlineitalic">dimension</span></dd>
<dd><span class="syntaxinline">ASSIGN&nbsp;</span><span class="syntaxinlineitalic">surrogate</span></dd>
<dd><span class="syntaxinlineitalic">variable</span><span class="syntaxinline">|</span><span class="syntaxinlineitalic">qualified&nbsp;data&nbsp;reference</span><span class="syntaxinline">|</span><span class="syntaxinlineitalic">relation</span><span class="syntaxinline">|</span><span class="syntaxinlineitalic">composite</span></dd>
</dl>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5125"></a>Parameters</p>
<dl>
<dt>SELECT <span class="italic">expressions</span> FROM <span class="italic">tables-</span></dt>
<dt>&nbsp;[WHERE <span class="italic">predicates</span>] [GROUP BY <span class="italic">expressions</span>] -</dt>
<dt>[ORDER BY <span class="italic">expressions</span>] [HAVING <span class="italic">predicates</span>]</dt>
<dd>
<p>A SQL SELECT statement that identifies the data you want to associate with the cursor. For the syntax of an SQL SELECT statement, refer to <span class="italic">Oracle Database SQL Language Reference.</span></p>
</dd>
<dt><span class="italic">targets</span></dt>
<dd>
<p>Identifies the analytic workspace objects in which you want to store data that is retrieved from a relational table. This list of target analytic workspace objects must correspond in number and data type with the list of table columns specified in the SELECT statement. A target can be a variable, a qualified data reference, a relation, a dimension, or a composite.</p>
<div class="infobox-note">
<p class="notep1">Important:</p>
The order in which you specify the analytic workspace objects affects dimension status. For each dimension value, Oracle OLAP temporarily limits the status of the dimension to the fetched value. Values are assigned to subsequent analytic workspace objects according to this temporary status. See <a href="#i79465">"Conjoints as Target Analytic Workspace Objects"</a> and <a href="#i79472">"Composites as Target Analytic Workspace Objects"</a>.</div>
<p>A target must be preceded by a colon. When the target is a dimension, it can include the MATCH and APPEND keywords to specify dimension handling; in this case, the colon precedes the keywords.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
Because both OLAP DML syntax and SQL WHERE clauses allow you to use AND and OR, construct the targets clause clearly so that Oracle OLAP can identify the end of an OLAP DML input expression.</div>
</dd>
<dt>[MATCH] {<span class="italic">dimension</span>|<span class="italic">surrogate</span>}</dt>
<dd>
<p>(Default) Oracle OLAP does not perform dimension maintenance on the <span class="italic">target</span> dimension or surrogate. It uses the incoming values to align data that is being fetched into dimensioned objects. When a value from the relational database does not match any value in the dimension or surrogate, an error is signaled.</p>
</dd>
<dt>APPEND [<span class="italic">position</span>] <span class="italic">dimension</span></dt>
<dd>
<p>Oracle OLAP performs dimension maintenance on the <span class="italic">target</span> dimension, adding new values to the dimension. It uses both old and new dimension values to align data being fetched into dimensioned objects. By default, new values are added to the end of a dimension or surrogate. The <span class="italic">position</span> can also be used to control how dimension values are processed in action statements.</p>
</dd>
<dt>ASSIGN <span class="italic">surrogate</span></dt>
<dd>
<p>Assigns the values to the specified surrogate.</p>
</dd>
<dt>THEN <span class="italic">action-statements</span></dt>
<dd>
<p>You may optionally include a THEN clause to specify any number of <span class="italic">action-statements</span> to be performed each time a row of data is fetched and assigned to analytic workspace objects. An <span class="italic">action-statement</span> can be one of the following:</p>
</dd>
</dl>
<dl>
<dd><span class="syntaxinlineitalic">assignment-statement</span></dd>
<dd><span class="syntaxinlineitalic">IF-statement</span></dd>
<dd><span class="syntaxinlineitalic">SELECT-statement</span></dd>
<dd><span class="syntaxinlineitalic">ACROSS-statement</span><span class="syntaxinlineitalic">action-statement</span></dd>
<dd><span class="syntaxinline">&lt;</span><span class="syntaxinlineitalic">action-statement-group</span><span class="syntaxinline">&gt;</span></dd>
</dl>
<p><a id="sthref5126"></a>Refer to the SQL IMPORT command for a complete description of the syntax of <span class="italic">action-statement</span>.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5127"></a>Usage Notes</p>
<p class="subhead2"><a id="OLADM2837"></a>General Restrictions that APPLY to SQL SELECT</p>
<p>An SQL SELECT statement cannot contain ampersand substitution.</p>
<p class="subhead2"><a id="OLADM2838"></a>Optimizing Copies</p>
<p>When copying values from relational tables into a multidimensional input variable, list the columns that correspond to the dimensions in an ORDER BY clause in the <span class="italic">select-statement</span> argument of the SQL SELECT statement, with the slowest-varying dimension first which optimizes performance.</p>
</div>
<!-- class="refsubsect" -->
<div class="refsubsect">
<p class="titleinrefsubsect"><a id="sthref5128"></a>Examples</p>
<div id="OLADM2839" class="example">
<p class="titleinexample"><a id="sthref5129"></a>Example 10-149 Simple select</p>
<p>For example, assume that there is a relational table named <code>sales</code> with the following description.</p>
<pre>
PROD_ID                     NOT NULL NUMBER(6)
CUST_ID                     NOT NULL NUMBER
TIME_ID                     NOT NULL DATE
CHANNEL_ID                  NOT NULL CHAR(1)
PROMO_ID                    NOT NULL NUMBER(6)
QUANTITY_SOLD               NOT NULL NUMBER(3)
AMOUNT_SOLD                 NOT NULL NUMBER(10,2)
</pre>
<p>Assume also that your analytic workspace contains the following definitions for corresponding analytic workspace objects.</p>
<pre>
DEFINE aw_prod_id DIMENSION NUMBER (6)
DEFINE aw_cust_id DIMENSION NUMBER (6) 
DEFINE aw_date DIMENSION TEXT
DEFINE aw_channel_id DIMENSION TEXT
DEFINE aw_promo_id DIMENSION NUMBER (6)
DEFINE aw_sales_dims COMPOSITE &lt;aw_prod_id aw_cust_id -
     aw_channel_id aw_promo_id&gt;
DEFINE aw_sales_quantity_sold VARIABLE NUMBER (3) &lt;aw_date aw_sales_dims -
     &lt;aw_prod_id aw_cust_id aw_date aw_channel_id aw_promo_id&gt;&gt;
DEFINE aw_sales_amount_sold VARIABLE NUMBER (10,2) &lt;aw_date aw_sales_dims -
     &lt;aw_prod_id aw_cust_id aw_date aw_channel_id aw_promo_id&gt;&gt;
</pre>
<p>To copy the data for product 415 from the <code>sales</code> table into the analytic workspace objects, you execute the following statement in the OLAP worksheet.<a id="sthref5130"></a><a id="sthref5131"></a></p>
<pre>
SQL SELECT prod_id cust_id time_id channel_id promo_id quantity_sold -
</pre>
<pre>
amount_sold WHERE prod_id = 415 -
INTO :aw_prod_id, :aw_cust_id, :aw_date,  -
:aw_channel_id, :aw_promo_id, :aw_sales_quantity_sold, :aw_sales_amount_sold 
</pre></div>
<!-- class="example" --></div>
<!-- class="refsubsect" --></div>
<!-- class="refsect2" --></div>
<!-- class="refsect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment3088">
<tr>
<td class="cellalignment3095">
<table class="cellalignment3093">
<tr>
<td class="cellalignment3092"><a href="dml_commands_2057.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment3092"><a href="dml_commands_2059.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1994, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment3097">
<table class="cellalignment3091">
<tr>
<td class="cellalignment3092"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment3092"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment3092"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment3092"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment3092"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment3092"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
