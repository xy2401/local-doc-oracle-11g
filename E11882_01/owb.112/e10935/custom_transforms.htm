<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Defining Custom Transformations</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-21T18:21:32Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Warehouse Builder Data Modeling, ETL, and Data Quality Guide" />
<meta name="dcterms.identifier" content="E10935-05" />
<meta name="dcterms.isVersionOf" content="WBETL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="design_processflows.htm" title="Previous" type="text/html" />
<link rel="Next" href="etl_performance.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10935.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">14/37</span> <!-- End Header --><a id="CHDGJFDI"></a><a id="WBETL09000"></a>
<h1 class="chapter"><span class="secnum">9</span> Defining Custom Transformations</h1>
<p><a id="ABC1419186"></a>One of the main functions of an extract, transformation, and loading (ETL) tool is to transform data. Oracle Warehouse Builder provides several methods of transforming data. This chapter discusses transformations and describes how to create custom transformations using Oracle Warehouse Builder. It also describes how to import transformation definitions.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BHCECJCJ">"About Transforming Data Using Oracle Warehouse Builder"</a></p>
</li>
<li>
<p><a href="#i1149862">"Defining Custom Transformations"</a></p>
</li>
<li>
<p><a href="#i1150091">"Editing Custom Transformations"</a></p>
</li>
<li>
<p><a href="#i1150024">"Importing Transformations"</a></p>
</li>
<li>
<p><a href="#BHCFIGJH">"Example: Reusing Existing PL/SQL Code"</a></p>
</li>
<li>
<p><a href="#CHDHDAII">"Using Functions In Non-Oracle Platforms"</a></p>
</li>
<li>
<p><a href="#CHDBBADD">"Configuring Functions"</a></p>
</li>
</ul>
<a id="BHCECJCJ"></a><a id="WBETL09001"></a>
<div class="sect1">
<h2 class="sect1">About Transforming Data Using Oracle Warehouse Builder</h2>
<p>Oracle Warehouse Builder provides an intuitive user interface that enables you to define transformations required for your source data. Use one of the following methods to transform source data.</p>
<ul>
<li>
<p><span class="bold">Transformations:</span> The Design Center includes a set of transformations used to transform data. You can use the predefined transformations provided by Oracle Warehouse Builder or define custom transformations that suit your requirements.</p>
<p>Custom transformations can be deployed to Oracle Database just like any other data object that you define in an Oracle module. For more information about transformations, see <a href="transformdata_intro.htm#BHCFCAEC">"About Transformations"</a>.</p>
</li>
<li>
<p><span class="bold">Operators:</span> The Mapping Editor includes a set of prebuilt transformation operators that enable you to define common transformations when you define how data moves from source to target. Transformation operators are prebuilt PL/SQL functions, procedures, package functions, and package procedures. They take input data, perform operations on it, and produce output.</p>
<p>In addition to the prebuilt operators, you can use custom transformations that you define in the Mapping Editor through the Transformation operator. For more information about these operators, see <a href="data_flow_opers.htm#CIHBEEAC">Chapter 26, "Data Flow Operators."</a></p>
</li>
</ul>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1239"></a>
<h3 class="sect2">Benefits of Using Oracle Warehouse Builder for Transforming Data</h3>
<p>Oracle Warehouse Builder enables you to reuse PL/SQL and to write your own custom PL/SQL transformations. These custom transformations can be used in Oracle Warehouse Builder mappings.</p>
<p>All major relational database management systems support SQL and all programs written in SQL can be moved from one database to another with very little modification. It means that all the SQL knowledge in your organization is fully portable to Oracle Warehouse Builder. Oracle Warehouse Builder enables you to import and maintain any existing complex custom code.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1149862"></a><a id="WBETL09002"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref1240"></a><a id="sthref1241"></a><a id="sthref1242"></a><a id="sthref1243"></a>Defining Custom Transformations</h2>
<p>Custom transformations include procedures, functions, and packages. Oracle Warehouse Builder provides wizards to create each type of custom transformation. Custom transformations can belong to the public Oracle Custom library or to a module in a project.</p>
<p class="subhead2"><a id="sthref1244"></a>Custom Transformations in the Public Oracle Custom Library</p>
<p>Custom transformations that are part of the public Oracle custom library can be used across all projects of the workspace in which they are defined. For example, you create a function called <code>ADD_EMPL</code> in the public Oracle Custom library of the workspace <code>REP_OWNER</code>. This procedure can be used across all the projects in <code>REP_OWNER</code>.</p>
<p>Use the Custom node of the Public Transformations node in the Globals Navigator to define custom transformations that can be used across all projects in the workspace.</p>
<p><span class="bold">To create a custom transformation in the Public Oracle Custom Library:</span></p>
<ol>
<li>
<p>From the Globals Navigator, expand the Public Transformations node, and then the Oracle node.</p>
</li>
<li>
<p>Right-click the Custom node and select <span class="bold">New</span>.</p>
<p>The New Gallery dialog box is displayed containing the type of transformations that you can create. This includes functions, procedures, and packages. PL/SQL types can be created only as part of a package.</p>
</li>
<li>
<p>Select the type of transformation you want to create a click <span class="bold">OK</span>.</p>
</li>
<li>
<p>For table functions, Oracle Warehouse Builder displays the Create Table Function wizard. Use the wizard to define the table function as described in <a href="#CJAIJJAH">"Defining Table Functions"</a>.</p>
<p>For functions, procedures, and packages, the Create Function dialog box, Create Procedure dialog box, or Create Package dialog box respectively, is displayed. Provide a name and an optional description and click <span class="bold">OK</span>. For packages, the package is added to the Projects Navigator. For functions and procedures, the editor is displayed. Use the editor to define the function or procedure.</p>
<p>See <a href="#CEGCEJFC">"Defining Functions and Procedures"</a> and <a href="#CEGDAIIH">"Defining PL/SQL Types"</a>.</p>
</li>
</ol>
<p class="subhead2"><a id="sthref1245"></a>Custom Transformations in a Project</p>
<p>Sometimes, you must define custom transformations that are required only in the current module or project. In such cases, you can define custom transformations in an Oracle module of a project. When you define a custom transformation in an Oracle module, the transformation is accessible from all the modules of the project in which it is defined. For example, consider the workspace owner called <code>REP_OWNER</code>, that contains two projects, <code>PROJECT1</code> and <code>PROJECT2</code>. In the Oracle module called <code>SALES</code> of <code>PROJECT1</code>, you define a procedure called <code>CALC_SAL</code>. This procedure can be used in all modules belonging to <code>PROJECT1</code>, but is not accessible in <code>PROJECT2</code>.</p>
<p><span class="bold">To define a custom transformation in an Oracle module:</span></p>
<ol>
<li>
<p>From the Projects Navigator, expand the Oracle Warehouse Builder module node under which you want to define a custom transformation.</p>
</li>
<li>
<p>Right-click the Transformations node and select <span class="bold">New</span>.</p>
<p>The New Gallery dialog box is displayed.</p>
</li>
<li>
<p>Select the type of transformation you want to create and click <span class="bold">OK</span>.</p>
<p>For functions and procedures, Oracle Warehouse Builder displays the Create Function or Create Procedure dialog box. Provide a name and an optional description and click <span class="bold">OK</span>. The editor for that transformation is displayed. Use the tabs on the editor to define the transformation. For packages, after you define a name and description and click <span class="bold">OK</span>, the package is added to the Projects Navigator. You can then define the transformations that are part of the package.</p>
<p>For table functions, Oracle Warehouse Builder displays the Welcome page of the Create Table Function Wizard. You can create PL/SQL types only under a package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
For more information about defining each type of transformation, see the following sections:
<ul>
<li>
<p><a href="#CEGCEJFC">"Defining Functions and Procedures"</a></p>
</li>
<li>
<p><a href="#CEGDAIIH">"Defining PL/SQL Types"</a></p>
</li>
<li>
<p><a href="#CJAIJJAH">"Defining Table Functions"</a></p>
</li>
</ul>
</div>
</li>
</ol>
<a id="CEGCEJFC"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Defining Functions and Procedures</h3>
<p>Complete the following steps using the Function Editor or Procedure Editor to define a function or procedure.</p>
<ul>
<li>
<p><a href="#CEGGJECG">"Naming the Custom Transformation"</a></p>
</li>
<li>
<p><a href="#CEGIIEAF">"Defining the Parameters"</a></p>
</li>
<li>
<p><a href="#CEGDJHJB">"Specifying the Implementation"</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot copy and paste functions across platforms. For example, you cannot copy a function from an Oracle module and paste it into a SQL Server module.</div>
<a id="CEGGJECG"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Naming the Custom Transformation</h4>
<p>Use the Name and Description page or the Name tab to describe the custom transformation. Specify the following details on this page:</p>
<ul>
<li>
<p><span class="bold">Name:</span> Represents the name of the custom transformation. For more information about naming conventions, see <a href="orcl_data_objx.htm#CHDEAEAD">"Naming Conventions for Data Objects"</a>.</p>
</li>
<li>
<p><span class="bold">Description:</span> Represents the description of the custom transformation. This is an optional field.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CEGIIEAF"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Defining the Parameters</h4>
<p>Use the Parameters tab to define, modify, or delete the parameters, both input and output, of the transformation. For functions, an additional field called Return Type is displayed. The Return Type field represents the data type of the value returned by the function. Select a return type from the available options in the list.</p>
<p>For transformations defined in an Oracle module, specify the following details for each parameter:</p>
<ul>
<li>
<p><span class="bold">Name:</span> Enter the name of the parameter.</p>
</li>
<li>
<p><span class="bold">Data Type:</span> Select the data type of the parameter from the list.</p>
</li>
<li>
<p><span class="bold">I/O:</span> Select the type of parameter. The options available are Input, Output, and I/O.</p>
</li>
<li>
<p><span class="bold">Required:</span> Select <span class="bold">Yes</span> to indicate that a parameter is mandatory or <span class="bold">No</span> to indicate that it is not mandatory.</p>
</li>
<li>
<p><span class="bold">Default Value:</span> Enter the default value for the parameter. The default value is used when you do not specify a value for the parameter when you run the function or procedure.</p>
</li>
</ul>
<p>Transformations defined in a DB2 module contain the following details for each parameter: Name, Data Type, Length, Precision, Scale.</p>
<p>Length is applicable to character data types only and represents the length of the parameter. Precision represents the total number of digits enabled for the parameter and is applicable to numeric data types only. Scale represents the total number of digits to the right of the decimal point and is applicable to numeric data types only.</p>
<p>Transformations defined in a SQL Server module contain the following details for each parameter: Name, Data Type, Length, Precision, Scale, Required, Default Value.</p>
</div>
<!-- class="sect3" -->
<a id="CEGDJHJB"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying the Implementation</h4>
<p>Use the Implementation tab to specify or modify the implementation details, such as the code, of the transformation. Click <span class="bold">Generate</span> to validate and generate the implementation code.</p>
<p>Ensure that you save changes made to the function or procedure definition before you close the editor. You can save changes by clicking <span class="bold">Save All</span> on the toolbar or selecting <span class="bold">Save</span> from the File menu.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJAIJJAH"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Defining Table Functions</h3>
<p>Table functions are functions that take a set of rows as input and produce a set of rows as output. The input to the table function can be scalar data types, collection data types (PL/SQL records, Varrays, and nested tables), or Ref Cursors. The output of table functions is either a nested table or a Varray. Table functions can be queried like a regular database table.</p>
<p>Parallelization eliminates the need for intermediate staging of table function output by enabling you to stream rows returned by the table function directly to the next process.</p>
<p>Table functions enable you to define and use more flexible and powerful transformations. You can create your own specialized transformations, without using the transformation operators provided, to perform tasks such as user-defined aggregations and data mining. Table functions provide support for parallel and pipelined execution of transformations, resulting in better performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLQR" href="../../server.112/e41085/toc.htm"><span class="italic">Oracle Database SQL Language Quick Reference</span></a> for more information about table functions</div>
<p>Use the following steps to define a table function:</p>
<ol>
<li>
<p><a href="#CJAHACJA">"Naming the Table Function"</a></p>
</li>
<li>
<p><a href="#CJAGFHEE">"Specifying the Return Type"</a></p>
</li>
<li>
<p><a href="#CJADJAFH">"Specifying Table Function Input and Output Parameters"</a></p>
</li>
<li>
<p><a href="#CJADHBCC">"Specifying Parallelism Options"</a> (optional)</p>
</li>
<li>
<p><a href="#CJAJAAJA">"Specifying Data Streaming Options"</a> (optional)</p>
</li>
<li>
<p><a href="#CJAFEIEJ">"Specifying the Table Function Implementation"</a></p>
</li>
</ol>
<a id="CJAHACJA"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Naming the Table Function</h4>
<p>Use the following fields on the Name page to describe the table function.</p>
<p><span class="bold">Name:</span> Represents the name of the table function. The name must follow the naming conventions for Oracle Warehouse Builder objects.</p>
<p>To rename a table function, select the name and enter the new name. When you rename a table function, you must deploy it again. Also synchronize any mappings that use the table function.</p>
<p><span class="bold">Description:</span> Represents an optional description, up to 4,000 characters long, for the table function.</p>
</div>
<!-- class="sect3" -->
<a id="CJAGFHEE"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying the Return Type</h4>
<p>The return type for table functions can be the following collection types: nested tables and Varrays. The Return Type page displays the collection types that you can select as the return type. Select the collection type to use as the return type of the table function.</p>
<p>For table functions defined under an Oracle module, you can use following as return type:</p>
<ul>
<li>
<p>Nested tables and Varrays defined in an Oracle module that is contained by the project in which the table function is defined</p>
</li>
<li>
<p>Public nested tables that are defined as part of a package in the Globals Navigator</p>
</li>
</ul>
<p>For public table functions, defined using the Globals Navigator, you can only use public nested tables or public Varrays as a return type.</p>
</div>
<!-- class="sect3" -->
<a id="CJADJAFH"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying Table Function Input and Output Parameters</h4>
<p>Use the Parameters page or Parameters tab to define the input parameters of the table function. For each parameter, enter the following details:</p>
<ul>
<li>
<p><span class="bold">Name:</span> Enter the name of the parameter.</p>
</li>
<li>
<p><span class="bold">Type:</span> Select the data type of the parameter from the list.</p>
<p>Parameters can be Oracle scalar data types or user-defined collection types, except nested tables. Typically the input parameters of table functions are the collection types such as Record Type, Table Type, or Ref Cursor Type. Since collection types are user-defined, you must define these types before you use them as data types for a table function parameter. You can define collection types only as part of a public package or a package within an Oracle module.</p>
</li>
<li>
<p><span class="bold">I/O:</span> Select the type of parameter. The only option available for table functions is Input.</p>
</li>
<li>
<p><span class="bold">Required:</span> Select Yes to indicate that a parameter is mandatory and No to indicate that it is not mandatory.</p>
</li>
<li>
<p><span class="bold">Default Value:</span> Enter the default value for the parameter. The default value is used when you do not specify a value for the parameter when you run the table function.</p>
</li>
</ul>
<p>To modify a parameter, select the parameter value and enter the new value. Redeploy the table function after you make this change.</p>
</div>
<!-- class="sect3" -->
<a id="CJADHBCC"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying Parallelism Options</h4>
<p>You can parallelize the execution of table functions to eliminate the need for staging tables. When the execution of a table function is parallelized, the rows returned by the table function can be streamed directly into the next process without intermediate staging. It enables multithreaded, concurrent execution of table functions.</p>
<p>Parallel execution of table functions is performed using multiple slave processes. For a table function to be run in parallel, you must specify one input parameter, of type Ref cursor, that is used for data partitioning.</p>
<p>Provide the following details to parallelize the execution of your table function:</p>
<ul>
<li>
<p><span class="bold">Parallel:</span> Select this option to indicate that the execution of the table function should be parallelized.</p>
<p>This option is enabled only when one or more input parameters are of type Ref Cursor.</p>
</li>
<li>
<p><span class="bold">Partition Method:</span> Select the partition method. You can choose Any, Range, or Hash as the partition method.</p>
</li>
<li>
<p><span class="bold">Parameters:</span> Select the input parameter on which partitioning should be performed. Only parameters of type Ref cursor can be selected as partitioning parameters. Thus this field lists only input parameters of type Ref Cursor.</p>
</li>
<li>
<p><span class="bold">Attributes for Partitioning:</span> Select the attributes in the Ref cursor on which partitioning should be performed. The Available Attributes section lists the attributes of the Ref cursor on which the table function input parameter is based. Select the attributes and use the arrows to move them to the Selected Attributes section.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CJAJAAJA"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying Data Streaming Options</h4>
<p>Use the Order page to perform streaming on table functions. When you perform data streaming, the table function orders or clusters rows that it fetches from cursor arguments. Ordering or clustering is performed using a particular key or key columns. Clustering causes rows that have the same input key values to appear, but does not perform any ordering of rows.</p>
<p>To perform data streaming, enter the following information on this page.</p>
<ul>
<li>
<p><span class="bold">Ordering Method:</span> Specify the method used for data streaming. You can select Order By to order rows or Cluster By to cluster rows.</p>
</li>
<li>
<p><span class="bold">Attributes for Ordering:</span> Select the attributes on which the ordering or clustering is performed. The Available Attributes section lists the attributes of the Ref cursor input parameter. Select one or more attributes and use the arrows to move the attributes to the Selected Attributes section.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CJAFEIEJ"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying the Table Function Implementation</h4>
<p>On the Implementation page, specify the following details:</p>
<ul>
<li>
<p><span class="bold">Pipelined:</span> Select the <span class="bold">Pipelined</span> option to create a pipelined table function. Pipelining iteratively returns rows as they are produced, instead of returning them in a single batch after all the table function processing is complete. Pipelining enables table functions to return rows faster and reduces the memory required to cache table function results. Thus query response times are reduced. Pipelining enables tables functions to be used as a virtual table.</p>
</li>
<li>
<p><span class="bold">Implementation:</span> In the Implementation section, a sample code is provided with comments for each part of the table function definition. Click <span class="bold">Code Editor</span> to display the Code Editor that enables you to edit the default sample code and enter the code for your table function.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CEGDAIIH"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Defining PL/SQL Types<a id="sthref1246"></a><a id="sthref1247"></a></h3>
<p>Use the Create PL/SQL Type Wizard to create PL/SQL types. PL/SQL types must be defined within a package and they cannot exist independently.</p>
<a id="CHDIGAFD"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3"><a id="sthref1248"></a>About PL/SQL Types</h4>
<p>PL/SQL types enable you to create collection types, record types, and REF cursor types in Oracle Warehouse Builder. You use PL/SQL types as parameters in subprograms or as return types for functions. Using PL/SQL types as parameters to subprograms enables you to process arbitrary number of elements. Use collection types to move data into and out of database tables using bulk SQL. For more information about PL/SQL types, see <a class="olink LNPLS" href="../../appdev.112/e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a>.</p>
<p>Oracle Warehouse Builder enables you to create the following PL/SQL types:</p>
<ul>
<li>
<p>PL/SQL Record types</p>
<p>Record types enable you to define records in a package. A record is a composite data structure that contains multiple fields. Use records to hold related items and pass them to subprograms using a single parameter.</p>
<p>For example, an <code>EMPLOYEE</code> record can contain details related to an employee such as ID, first name, last name, address, date of birth, date of joining, and salary. You can create a record type based on the <code>EMPLOYEE</code> record and use this record type to pass employee data between subprograms.</p>
</li>
<li>
<p>REF Cursor types</p>
<p>REF cursor types enable you to define REF cursors within a package. REF cursors are not bound to a single query and can point to different result sets. Use REF cursors when you want to perform a query in one subprogram and process the results in another subprogram. REF cursors also enable you to pass query result sets between PL/SQL stored subprograms and various clients such as an OCI client or an Oracle Forms application.</p>
<p>REF cursors are available to all PL/SQL clients. For example, you can declare a REF cursor in a PL/SQL host environment such as an OCI or Pro*C program, then pass it as an input host variable (bind variable) to PL/SQL. Application development tools such as Oracle Forms, which have a PL/SQL engine, can use cursor variables entirely on the client side. Or, you can pass cursor variables back and forth between a client and the database server through remote procedure calls.</p>
</li>
<li>
<p>Nested Table types</p>
<p>Use nested table types to define nested tables within a package. A nested table is an unordered set of elements, all of the same data type. They are similar to one-dimensional arrays with no declared number of elements. Nested tables enable you to model multidimensional arrays by creating a nested table whose elements are also tables.</p>
<p>For example, you can create a nested table type that can hold an arbitrary number of employee IDs. This nested table type can then be passed as a parameter to a subprogram that processes only the employee records contained in the nested table type.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1249"></a>
<h4 class="sect3">Usage Scenario for PL/SQL Types</h4>
<p>The <code>SALES</code> table stores the daily sales of an organization that has offices across the world. This table contains the sale ID, sale date, customer ID, product ID, amount sold, quantity sold, and currency in which the sale was made. Management wants to analyze global sales for a specified time period using a single currency, for example the U.S. Dollar. Thus all sales values must be converted to U.S. Dollar. Because the currency exchange rates can change every day, the sales amounts must be computed using the exchange rate of the sale currency on the sale date.</p>
<p><a id="sthref1250"></a><span class="subhead3">Solution Using PL/SQL Record Types&nbsp;</span></p>
<p><a href="#CHDCHFFJ">Figure 9-1</a> displays the mapping that you use to obtain the sales amount in a specified currency using PL/SQL record types.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDCHFFJ"></a>Figure 9-1 PL/SQL Record Type in a Mapping</p>
<img width="834" height="356" src="img/plsql_record_type_ex.gif" alt="Description of Figure 9-1 follows" /><br />
<a id="sthref1251" href="img_text/plsql_record_type_ex.htm">Description of "Figure 9-1 PL/SQL Record Type in a Mapping"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The mapping takes the individual sales data stored in different currencies, obtains the sales value in the specified currency, and loads this data into a target table. Use the following steps to create this mapping.</p>
<ol>
<li>
<p>In the Globals Navigator, create a package. In this package, create a procedure called <code>CURR_CONV_PROC</code>.</p>
<p>This procedure obtains the currency conversion values on each date in a specified time interval from a Web site. The input parameters of this procedure are the sales currency, the currency to which the sale value must be converted, and the time interval for which the currency conversion is required. This data is stored in a PL/SQL record type of type <code>CURR_CONV_REC</code>. This record type contains two attributes: date and conversion value.</p>
<p>You create the PL/SQL record type as part of the package.</p>
</li>
<li>
<p>Create a mapping that contains a Transformation operator. This operator is bound to the <code>CURR_CONV_PROC</code> procedure.</p>
</li>
<li>
<p>Use a Mapping Input Parameter operator to provide values for the input parameters of the Transformation operator.</p>
<p>The output group of the Transformation operator is a PL/SQL record type of type <code>CURR_CONV_REC</code>.</p>
</li>
<li>
<p>Use an Expand Object operator to obtain the individual values stored in this record type and store these values in the table <code>CURRENCY_TAB</code>.</p>
</li>
<li>
<p>Use an Aggregator operator to aggregate sales details for each order.</p>
<p>The <code>SALES</code> table is a transactional table and stores data in normalized form. To obtain the aggregate sales for each order, use an Aggregator operator to aggregate sales data.</p>
</li>
<li>
<p>Use a Joiner operator to join the aggregated sales details, which is the output of the Aggregator operator, with the data in the <code>CURRENCY_TAB</code> table. The sale date is used as the join condition.</p>
</li>
<li>
<p>Use the Expression operator to multiply the sales amount with the currency exchange rate to get the total sales in the required currency. Load the converted sales data into the <code>CONV_SALES_TAB</code> table.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1252"></a>
<h4 class="sect3">Creating PL/SQL Types<a id="sthref1253"></a><a id="sthref1254"></a></h4>
<p>You can create PL/SQL types in the Projects Navigator or Globals Navigator of the Design Center.</p>
<p>Use the Create PL/SQL Types Wizard to create PL/SQL types. To display the Create PL/SQL Types Wizard, right-click the PL/SQL Types node under a package, and select <span class="bold">New PL/SQL Type</span>. The Welcome page of the Create PL/SQL Types Wizard is displayed. Click <span class="bold">Next</span> and then the wizard guides you through the following pages:</p>
<ul>
<li>
<p><a href="#CEGGAJID">"Name and Description Page"</a></p>
</li>
<li>
<p><a href="#CEGGBGHA">"Attributes Page"</a></p>
</li>
<li>
<p><a href="#CEGIJDDI">"Return Type Page"</a></p>
</li>
<li>
<p><a href="#CEGEBBHH">"Summary Page"</a></p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CEGGAJID"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Name and Description Page</h4>
<p>Use the Name and Description page to provide the name and an optional description for the PL/SQL type. Also use this page to select the type of PL/SQL type to create.</p>
<p>You can create any of the following PL/SQL types:</p>
<ul>
<li>
<p>PL/SQL record type</p>
</li>
<li>
<p>REF cursor type</p>
</li>
<li>
<p>Nested table type</p>
</li>
</ul>
<p>For more information about each PL/SQL type, see <a href="#CHDIGAFD">"About PL/SQL Types"</a>.</p>
<p>After specifying the name and selecting the type of PL/SQL type to create, click <span class="bold">Next</span>.</p>
</div>
<!-- class="sect3" -->
<a id="CEGGBGHA"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Attributes Page</h4>
<p>Use the Attributes page to define the attributes of the PL/SQL record type. You specify attributes only for PL/SQL record types. A PL/SQL record must have at least one attribute.</p>
<p>For each attribute, define the following:</p>
<ul>
<li>
<p><span class="bold">Name:</span> The name of the attribute. The name should be unique within the record type.</p>
</li>
<li>
<p><span class="bold">Data Type:</span> The data type of the attribute. Select the data type from the list.</p>
</li>
<li>
<p><span class="bold">Length:</span> The length of the data type, for character data types.</p>
</li>
<li>
<p><span class="bold">Precision:</span> The total number of digits enabled for the attribute, for numeric data types.</p>
</li>
<li>
<p><span class="bold">Scale:</span> The total number of digits to the right of the decimal point, for numeric data types.</p>
</li>
<li>
<p><span class="bold">Seconds Precision:</span> The number of digits in the fractional part of the datetime field. It can be a number between 0 and 9. Seconds Precision is used only for <code>TIMESTAMP</code>, <code>TIMESTAMP WITH TIME ZONE</code>, and <code>TIMESTAMP WITH LOCAL TIME ZONE</code> data types.</p>
</li>
</ul>
<p>Click <span class="bold">Next</span> to proceed to the next step.</p>
</div>
<!-- class="sect3" -->
<a id="CEGIJDDI"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Return Type Page</h4>
<p>Use the Return Type page to select the return type of the PL/SQL type. You must specify a return type only while creating REF cursors and nested tables.</p>
<p><span class="bold">To define REF cursors:</span></p>
<p>The return type for a REF cursor can only be a PL/SQL record type. If you know the name of the PL/SQL record type, then you can search for it by entering the name in the <span class="bold">Search For</span> field and clicking <span class="bold">Go</span>.</p>
<p>The area below the Search For field displays the available PL/SQL types. These PL/SQL types are grouped under the two nodes: Public and Private. Expand the Public node to view the PL/SQL types that are part of the Oracle Shared Library. The types are grouped by package name. The Private node contains PL/SQL types that are created as part of a package in an Oracle module. Only PL/SQL types that belong to the current project are displayed. Each Oracle module is represented by a node. Within the module, the PL/SQL types are grouped by the package to which they belong.</p>
<p><span class="bold">To define nested tables:</span></p>
<p>For nested tables, the return type can be a scalar data type or a PL/SQL record type. Select one of the following options based on what the PL/SQL type returns:</p>
<ul>
<li>
<p>Select a scalar type as return type</p>
<p>This option enables you to create a PL/SQL type that returns a scalar type. Use the list to select the data type.</p>
</li>
<li>
<p>Select a PL/SQL record as return type</p>
<p>This option enables you to create a PL/SQL type that returns a PL/SQL record type. If you know the name of the PL/SQL record type that is returned, then type the name in the <span class="bold">Search For</span> field and click <span class="bold">Go</span>. The results of the search are displayed in the area below the option.</p>
<p>You can also select the return type from the list of available types displayed. The area below this option contains two nodes: Public and Private. The Public node contains PL/SQL record types that are part of the Oracle Shared Library. The PL/SQL record types are grouped by the package to which they belong. The Private node contains the PL/SQL record types created as transformations in each Oracle module in the current project. These are grouped by module. Select the PL/SQL record type that the PL/SQL type returns.</p>
</li>
</ul>
<p>Click <span class="bold">Next</span> to proceed with the creation of the PL/SQL type.</p>
</div>
<!-- class="sect3" -->
<a id="CEGEBBHH"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Summary Page</h4>
<p>The Summary page displays the options that you have chosen on the wizard pages. Review the options. Click <span class="bold">Back</span> to modify any options. Click <span class="bold">Finish</span> to create the PL/SQL type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1150091"></a><a id="WBETL09003"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref1255"></a><a id="sthref1256"></a><a id="sthref1257"></a>Editing Custom Transformations</h2>
<p>You can edit the definition of a custom transformation using the editors. Make sure you edit properties consistently. For example, if you change the name of a parameter, then you must also change its name in the implementation code.</p>
<p>After editing a custom transformation, ensure that you do the following:</p>
<ul>
<li>
<p>Synchronize any mapping operators that reference the edited transformation with the edited transformation</p>
<p>Synchronization updates the definition of the transformation in the mapping with the changes made while editing.</p>
</li>
<li>
<p>Redeploy the mapping containing the edited transformation</p>
</li>
</ul>
<a id="CEGBFHDB"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2"><a id="sthref1258"></a><a id="sthref1259"></a><a id="sthref1260"></a>Editing Function or Procedure Definitions</h3>
<p>The Edit Function dialog box enables you to edit function definitions. To edit a procedure definition, use the Edit Procedure dialog box.</p>
<p><span class="bold">Use the following steps to edit functions, procedures, or packages:</span></p>
<ol>
<li>
<p>From the Projects Navigator, expand the Oracle module in which the transformation is created. Then expand the Transformations node.</p>
<p>To edit a transformation that is part of the public Oracle Custom library, from the Globals Navigator, expand the Public Transformations node, and then the Custom node.</p>
</li>
<li>
<p>Right-click the name of the function, procedure, or package to edit and select <span class="bold">Open.</span> Or, double-click the name of the function, procedure, or package.</p>
<p>For functions, the Function Editor is displayed. For procedures, the Procedure Editor is displayed. Use the following tabs to edit the function or procedure definition:</p>
<ul>
<li>
<p>Name tab, see <a href="#CEGGJECG">"Naming the Custom Transformation"</a></p>
</li>
<li>
<p>Parameters tab, see <a href="#CEGIIEAF">"Defining the Parameters"</a></p>
</li>
<li>
<p>Implementation tab, see <a href="#CEGDJHJB">"Specifying the Implementation"</a></p>
</li>
</ul>
<p>For packages, Oracle Warehouse Builder displays the Edit Transformation Library dialog box. You can only edit the name and description of the package. You can edit the functions and procedures contained within the package using the steps used to edit functions or packages.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CEGIGJGA"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Editing PL/SQL Types<a id="sthref1261"></a><a id="sthref1262"></a></h3>
<p>The Edit PL/SQL Type dialog box enables you to edit the definition of a PL/SQL type. Use the following steps to edit a PL/SQL type:</p>
<ol>
<li>
<p>From the Projects Navigator, expand the Oracle module that contains the PL/SQL type. Then expand the Transformations node.</p>
<p>To edit a PL/SQL type stored in the public Oracle Custom library, expand the Public Transformations node in the Globals Navigator, and then the Custom node.</p>
</li>
<li>
<p>Expand the package that contains the PL/SQL type and then the PL/SQL Types node.</p>
</li>
<li>
<p>Right-click the name of the PL/SQL type to edit and select <span class="bold">Open</span>. Or, double-click the name of the PL/SQL type.</p>
<p>The Edit PL/SQL Type dialog box is displayed. Use the following tabs to edit the PL/SQL type:</p>
<ul>
<li>
<p><a href="#CEGBIHCB">"Name Tab"</a></p>
</li>
<li>
<p><a href="#CEGJEEAE">"Attributes Tab"</a></p>
</li>
<li>
<p><a href="#CEGDEBBE">"Return Type Tab"</a></p>
</li>
</ul>
</li>
</ol>
<a id="CEGBIHCB"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Name Tab</h4>
<p>The Name tab displays the name and the description of the PL/SQL type. Use this tab to edit the name or the description of the PL/SQL type.</p>
<p>To rename a PL/SQL type, select the name and enter the new name.</p>
</div>
<!-- class="sect3" -->
<a id="CEGJEEAE"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Attributes Tab</h4>
<p>The Attributes tab displays details about the existing attributes of the PL/SQL record type. This tab is displayed for PL/SQL record types only. You can modify existing attributes, add new attributes, or delete attributes.</p>
<p>To add a new attribute, click the <span class="bold">Name</span> column of a blank row specify the details for the attribute. To delete an attribute, right-click the gray cell to the left the row that represents the attribute and select <span class="bold">Delete</span>.</p>
</div>
<!-- class="sect3" -->
<a id="CEGDEBBE"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Return Type Tab</h4>
<p>Use the Return Type tab to modify the details of the return type of the PL/SQL type. For a REF cursor type, the return type must be a PL/SQL record. For a nested table, the return type can be a PL/SQL record type or a scalar data type.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1263"></a>
<h3 class="sect2">Editing Table Functions</h3>
<p>You can edit the definition of a table function and modify its specification.</p>
<p><span class="bold">To edit table functions:</span></p>
<ol>
<li>
<p>Expand the Oracle Module that contains the table function, the Transformations node, and then the Table Functions node.</p>
<p>For a global table function, expand the Public Transformations node and then the Custom node.</p>
</li>
<li>
<p>If the table function belongs to a package, first expand the package node. Right-click the name of the table function to edit and select <span class="bold">Open</span>. Or, double-click the name of the table function.</p>
<p>The Table Function Editor is displayed.</p>
</li>
<li>
<p>Use the following tabs to edit the table function:</p>
<ul>
<li>
<p>Name tab, see <a href="#CJAHACJA">"Naming the Table Function"</a></p>
</li>
<li>
<p>Return Type tab, see <a href="#CJAGFHEE">"Specifying the Return Type"</a></p>
</li>
<li>
<p>Parameters tab, see <a href="#CJADJAFH">"Specifying Table Function Input and Output Parameters"</a></p>
</li>
<li>
<p>Partitions tab, see <a href="#CJADHBCC">"Specifying Parallelism Options"</a></p>
</li>
<li>
<p>Order tab, see <a href="#CJAJAAJA">"Specifying Data Streaming Options"</a></p>
</li>
<li>
<p>Implementation tab, see <a href="#CJAFEIEJ">"Specifying the Table Function Implementation"</a></p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1150024"></a><a id="WBETL09004"></a>
<div class="sect1">
<h2 class="sect1"><a id="sthref1264"></a><a id="sthref1265"></a><a id="sthref1266"></a><a id="sthref1267"></a><a id="sthref1268"></a>Importing Transformations</h2>
<p>Use the Import Metadata Wizard to import PL/SQL functions, procedures, and packages into an Oracle Warehouse Builder project. You can also import scalar functions from IBM DB2 and SQL Server databases.</p>
<p>You can edit, save, and deploy the imported PL/SQL functions and procedures. You can also view and modify imported packages.</p>
<p><span class="bold">To import transformations in to a project:</span></p>
<ol>
<li>
<p>From the Projects Navigator, expand the project node and then the Databases node.</p>
</li>
<li>
<p>Expand the node corresponding to the database from which you want to import transformations.</p>
<p>For example, to import PL/SQL functions from an Oracle database, right-click the Oracle node. To import scalar functions from an IBM DB2UDB database, right-click the DB2 node.</p>
</li>
<li>
<p>Right-click the module into which you want to import transformations, select <span class="bold">Import,</span> and then <span class="bold">Database Objects</span>.</p>
<p>Oracle Warehouse Builder displays the Welcome page of the Import Metadata Wizard.</p>
</li>
<li>
<p>Click <span class="bold">Next.</span></p>
</li>
<li>
<p>In the Object Type field of the Filter Information page, select <span class="bold">PL/SQL Transformation</span> to import PL/SQL transformations into an Oracle module or select <span class="bold">Transformation</span> to import scalar functions into an IBM DB2 UDB or a SQL Server module.</p>
</li>
<li>
<p>Click <span class="bold">Next.</span></p>
<p>The Import Metadata Wizard displays the Object Selection page.</p>
</li>
<li>
<p>Select a function, procedure, or package from the Available Objects list. Move the objects to the Selected Objects list by clicking the right arrow to move a single object or the Move All button to move multiple objects.</p>
</li>
<li>
<p>Click <span class="bold">Next.</span></p>
<p>The Import Metadata Wizard displays the Summary and Import page.</p>
</li>
<li>
<p>Verify the import information. Click <span class="bold">Back</span> to revise your selections.</p>
</li>
<li>
<p>Click <span class="bold">Finish</span> to import the selected PL/SQL transformations.</p>
<p>Oracle Warehouse Builder displays the Import Results page.</p>
</li>
<li>
<p>Click <span class="bold">OK</span> proceed with the import. Click <span class="bold">Undo</span> to cancel the import process.</p>
<p>The imported PL/SQL information appears under the Transformations node of the module into which you imported the data.</p>
</li>
</ol>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1269"></a>
<h3 class="sect2">Restrictions on Using Imported PL/SQL</h3>
<p>The following restrictions apply to the use of imported PL/SQL:</p>
<ul>
<li>
<p>You cannot edit imported PL/SQL packages.</p>
</li>
<li>
<p>Wrapped PL/SQL objects are not readable.</p>
</li>
<li>
<p>You can edit the imported package body but not the imported package specification.<a id="sthref1270"></a></p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BHCFIGJH"></a><a id="WBETL09005"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Example: Reusing Existing PL/SQL Code</h2>
<p class="subhead2"><a id="sthref1271"></a>Scenario</p>
<p>A movie rental company periodically updates the customer rental activity in its <code>CUST_RENTAL_ACTIVITY</code> table, where it stores the rental sales and overdue charges data for each customer. This table is used for different mailing campaigns. For example, in their latest mailing campaign, customers with high overdue charges are offered the company's new pay-per-view service.Currently, the movie rental company uses a PL/SQL package to consolidate their data. The existing PL/SQL package must be maintained manually by accessing the database. This code runs on an Oracle 8<span class="italic">i</span> database.</p>
<pre>
CREATE OR REPLACE PACKAGE RENTAL_ACTIVITY AS
  PROCEDURE REFRESH_ACTIVITY(SNAPSHOT_START_DATE IN DATE);
END RENTAL_ACTIVITY;
/
CREATE OR REPLACE PACKAGE BODY RENTAL_ACTIVITY AS
 PROCEDURE REFRESH_ACTIVITY(SNAPSHOT_START_DATE IN DATE) IS
   CURSOR C_ACTIVITY IS
    SELECT
      CUST.CUSTOMER_NUMBER CUSTOMER_NUMBER,
      CUST.CUSTOMER_FIRST_NAME CUSTOMER_FIRST_NAME,
      CUST.CUSTOMER_LAST_NAME CUSTOMER_LAST_NAME,
      CUST.CUSTOMER_ADDRESS CUSTOMER_ADDRESS,
      CUST.CUSTOMER_CITY CUSTOMER_CITY,
      CUST.CUSTOMER_STATE CUSTOMER_STATE,
      CUST.CUSTOMER_ZIP_CODE CUSTOMER_ZIP_CODE,
      SUM(SALE.RENTAL_SALES) RENTAL_SALES,
      SUM(SALE.OVERDUE_FEES) OVERDUE_FEES
    FROM  CUSTOMER CUST, MOVIE_RENTAL_RECORD SALE
    WHERE SALE.CUSTOMER_NUMBER = CUST.CUSTOMER_NUMBER AND
          SALE.RENTAL_RECORD_DATE &gt;= SNAPSHOT_START_DATE 
    GROUP BY
    CUST.CUSTOMER_NUMBER,
    CUST.CUSTOMER_FIRST_NAME,
    CUST.CUSTOMER_LAST_NAME,
    CUST.CUSTOMER_ADDRESS,
    CUST.CUSTOMER_CITY,
    CUST.CUSTOMER_STATE,
    CUST.CUSTOMER_ZIP_CODE;
   
   V_CUSTOMER_NUMBER NUMBER;
   V_CUSTOMER_FIRST_NAME VARCHAR2(20);
   V_CUSTOMER_LAST_NAME VARCHAR2(20);
   V_CUSTOMER_ADDRESS VARCHAR(50);
   V_CUSTOMER_CITY VARCHAR2(20);
   V_CUSTOMER_STATE VARCHAR2(20);
   V_CUSTOMER_ZIP_CODE VARCHAR(10);
   V_RENTAL_SALES NUMBER;
   V_OVERDUE_FEES NUMBER;

BEGIN
   OPEN C_ACTIVITY;
   LOOP
    EXIT WHEN C_ACTIVITY%NOTFOUND;
    FETCH
     C_ACTIVITY
    INTO 
     V_CUSTOMER_NUMBER,
     V_CUSTOMER_FIRST_NAME,
     V_CUSTOMER_LAST_NAME,
     V_CUSTOMER_ADDRESS,
     V_CUSTOMER_CITY,
     V_CUSTOMER_STATE,
     V_CUSTOMER_ZIP_CODE,
     V_RENTAL_SALES,
     V_OVERDUE_FEES;

    UPDATE CUST_ACTIVITY_SNAPSHOT
    SET
     CUSTOMER_FIRST_NAME = V_CUSTOMER_FIRST_NAME,
     CUSTOMER_LAST_NAME = V_CUSTOMER_LAST_NAME,
     CUSTOMER_ADDRESS = V_CUSTOMER_ADDRESS,
     CUSTOMER_CITY = V_CUSTOMER_CITY,
     CUSTOMER_STATE = V_CUSTOMER_STATE,
     CUSTOMER_ZIP_CODE = V_CUSTOMER_ZIP_CODE,
     RENTAL_SALES = V_RENTAL_SALES,
     OVERDUE_FEES = V_OVERDUE_FEES,
     STATUS_UPDATE_DATE = SYSDATE
    WHERE
     CUSTOMER_NUMBER = V_CUSTOMER_NUMBER;

    IF SQL%NOTFOUND THEN
       INSERT INTO CUST_ACTIVITY_SNAPSHOT
       ( CUSTOMER_NUMBER,
         CUSTOMER_FIRST_NAME,
         CUSTOMER_LAST_NAME,
         CUSTOMER_ADDRESS,
         CUSTOMER_CITY,
         CUSTOMER_STATE,
         CUSTOMER_ZIP_CODE,
         RENTAL_SALES,
         OVERDUE_FEES,
         STATUS_UPDATE_DATE )
       VALUES
       ( V_CUSTOMER_NUMBER, 
         V_CUSTOMER_FIRST_NAME,
         V_CUSTOMER_LAST_NAME,
         V_CUSTOMER_ADDRESS,
         V_CUSTOMER_CITY,
         V_CUSTOMER_STATE,
         V_CUSTOMER_ZIP_CODE,
         V_RENTAL_SALES,
         V_OVERDUE_FEES,
         SYSDATE );
     END IF;
   END LOOP;
END REFRESH_ACTIVITY;
END RENTAL_ACTIVITY;
/
</pre>
<p class="subhead2"><a id="sthref1272"></a>Solution</p>
<p>This case study highlights the benefits of importing an existing custom PL/SQL package into Oracle Warehouse Builder and using its functionality to automatically maintain, update, and regenerate the PL/SQL code. Oracle Warehouse Builder enables you to automatically take advantage of new database features and upgrades by generating code that is optimized for new database versions. For example, if you have a PL/SQL package for Oracle8<span class="italic">i</span>, then by importing it into Oracle Warehouse Builder you can generate code for Oracle8<span class="italic">i,</span> Oracle9<span class="italic">i</span>, Oracle 10<span class="italic">g</span>, or Oracle 11<span class="italic">g</span>.</p>
<p>Also, by importing a custom package and re-creating its operations through an Oracle Warehouse Builder mapping, you can transparently run and monitor the operations. Otherwise, you must manually access the database to verify and update the code. Oracle Warehouse Builder also enables you to perform lineage and impact analysis on all ETL operations while the Runtime Audit Browser monitors the running of the code and logs errors.</p>
<p class="subhead2"><a id="sthref1273"></a>Case Study</p>
<p>You can migrate the PL/SQL code into Oracle Warehouse Builder using the following steps:</p>
<ul>
<li>
<p><a href="#CIADDGBB">"Step 1: Import the Custom PL/SQL Package"</a></p>
</li>
<li>
<p><a href="#CIAGDFAJ">"Step 2: Create a "Black Box" Mapping"</a> by using a custom transformation in an Oracle Warehouse Builder mapping</p>
</li>
<li>
<p><a href="#CIABAGJI">"Step 3: Reimplement Custom Code into a Mapping"</a> by reimplementing the legacy PL/SQL code into a new Oracle Warehouse Builder mapping and phasing out the custom package</p>
</li>
<li>
<p><a href="#CIAHAJEF">"Step 4: Generate Code for Oracle Database 11<span class="italic">g</span>"</a></p>
</li>
</ul>
<p>Follow these steps to handle a custom PL/SQL package in Oracle Warehouse Builder.</p>
<p class="subhead2"><a id="CIADDGBB"></a>Step 1: Import the Custom PL/SQL Package</p>
<p>In the Projects Navigator, expand the Transformations node under the Oracle module into which you want to import the PL/SQL package <code>refresh_activity(</code><code><span class="codeinlineitalic">DATE</span></code><code>)</code>. Use the Import Metadata Wizard to import the package by right-clicking Transformations, selecting <span class="bold">Import</span>, and then <span class="bold">Database Objects</span>. On the Filter Information page of this wizard, indicate that you are importing a PL/SQL Transformation.</p>
<p>After you finish the import, the package <code>refresh_activity(</code><code><span class="codeinlineitalic">DATE</span></code><code>)</code> appears under the Packages node of the Transformations folder.</p>
<p class="subhead2"><a id="CIAGDFAJ"></a>Step 2: Create a "Black Box" Mapping</p>
<p>You can use the <code>refresh_activity(</code><code><span class="codeinlineitalic">DATE</span></code><code>)</code> procedure directly in a mapping without making any changes to it. In the mapping, you add a Post-Mapping Process operator to the mapping, with the package <code>refresh_activity(</code><code><span class="codeinlineitalic">DATE</span></code><code>)</code> selected.</p>
<p>In this example, you can immediately take advantage of the existing custom code. The learning curve and investment on resources is minimal. You may decide to maintain all the existing and developed PL/SQL code in this manner, using Oracle Warehouse Builder only to develop new processing units. Oracle Warehouse Builder enables you to use mappings that use the legacy code along with the new mappings you create. In such a case, although you can generate code for these mappings in Oracle Warehouse Builder, you cannot use Oracle Warehouse Builder features to maintain, update, or audit the code.</p>
<p>Because the legacy code is used as a "black box" that is not transparent to Oracle Warehouse Builder, you must maintain the legacy code manually. Thus, you cannot take advantage of Oracle Warehouse Builder features, such as run time audit browser, lineage and impact analysis, and optimized code generation, that rely on infrastructure code and metadata available for Oracle Warehouse Builder generated mappings.</p>
<p>Follow the next steps to take advantage of these features in Oracle Warehouse Builder and to automatically maintain, monitor, and generate your PL/SQL code.</p>
<p class="subhead2"><a id="CIABAGJI"></a>Step 3: Reimplement Custom Code into a Mapping</p>
<p>To take advantage of the code generation, maintenance, and auditing features, you can reimplement the legacy PL/SQL code functionality using a mapping and phase out the custom "black box" package. The mapping created to provide the PL/SQL code functionality is called <code>Rental_Activity</code>.</p>
<p>The recommended method is to test out this new mapping by running it side by side with the "black box" mapping. If the testing is successful and the new mapping can perform all the operations included in the custom code, then the "black box" mappings can be phased out. Oracle Warehouse Builder enables you to maintain, update, and generate code from a mapping without performing manual updates in the database.</p>
<p><a href="#CHDCEHHG">Figure 9-2</a> shows a sample of code generated from the <code>Rental_Activity</code> mapping that replicates the operations of the custom PL/SQL package for the movie rental company.</p>
<div class="figure">
<p class="titleinfigure"><a id="CHDCEHHG"></a>Figure 9-2 Sample Code</p>
<img width="454" height="476" src="img/plsqlmap4.gif" alt="Description of Figure 9-2 follows" /><br />
<a id="sthref1274" href="img_text/plsqlmap4.htm">Description of "Figure 9-2 Sample Code"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="subhead2"><a id="CIAHAJEF"></a>Step 4: Generate Code for Oracle Database 11<span class="italic">g</span></p>
<p>If you upgrade to Oracle9<span class="italic">i</span> version of the database, you must redeploy the <code>Rental_Activity</code> mapping created in Step 3. Oracle Warehouse Builder generates code optimized for the new database version.</p>
<p><a href="#CIAFGHGG">Figure 9-3</a> shows the <code>MERGE</code> statement from a sample of code generated for the same mapping for Oracle9<span class="italic">i</span>.</p>
<div class="figure">
<p class="titleinfigure"><a id="CIAFGHGG"></a>Figure 9-3 Sample Code for Oracle9i</p>
<img width="382" height="309" src="img/plsqlmap5.gif" alt="Description of Figure 9-3 follows" /><br />
<a id="sthref1275" href="img_text/plsqlmap5.htm">Description of "Figure 9-3 Sample Code for Oracle9i"</a><br />
<br /></div>
<!-- class="figure" -->
<p>No manual steps are required to maintain and generate the new code. Also, you can transparently monitor and maintain their ETL operations. Oracle Warehouse Builder enables them to perform lineage and impact analysis on their mappings and the Runtime Audit Browser enables them to track and log errors when running the mappings.</p>
</div>
<!-- class="sect1" -->
<a id="CHDHDAII"></a><a id="WBETL09006"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using Functions In Non-Oracle Platforms</h2>
<p>Starting with Oracle Warehouse Builder 11<span class="italic">g</span> Release 2 (11.2), you can create, import, and use predefined functions within non-Oracle platforms as well. This release extends the usage of functions to the following platforms:</p>
<ul>
<li>
<p>DB2</p>
</li>
<li>
<p>SQL Server</p>
</li>
</ul>
<p>Like with Oracle modules, you can create a new function in DB2 and SQL Server modules. Similarly, you can also import existing functions from a DB2 or SQL Server database. Oracle Warehouse Builder also provides predefined functions in the Globals Navigator.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot copy and paste functions across platforms. For example, you cannot copy a function from an Oracle module and paste it into a SQL Server module.</div>
<a id="CJAEEAGJ"></a>
<div class="sect2">
<h3 class="sect2">Creating IBM DB2 and SQL Server Functions</h3>
<p>When you define functions using the Custom node under the Public Transformations node of the Globals Navigator, they can be used only when you deploy objects to an Oracle Database location. However, you can use Oracle Warehouse Builder to load data into SQL Server and DB2 data objects also. In these cases, you must create user-defined functions to transform data for these platforms. Use the Databases node in the Projects Navigator to define functions for these databases.</p>
<p>Once you define functions for a DB2 or SQL Server database, you can use these functions in mappings and process flows with the help of the Transformation operator and Transformation activity, respectively. You can also publish these functions as Web Services.</p>
<div class="sect3"><a id="sthref1276"></a>
<h4 class="sect3">Defining IBM DB2 and SQL Server Functions</h4>
<p><span class="bold">To define an IBM DB2 or a SQL Server function:</span></p>
<ol>
<li>
<p>In the Projects Navigator, expand the Databases node.</p>
</li>
<li>
<p>Depending on whether you are creating a function in DB2 or SQL Server, expand the DB2 or SQL Server node.</p>
</li>
<li>
<p>Expand the Transformations node and right-click the Functions node and select <span class="bold">New Function</span>.</p>
<p>The Create Function dialog box is displayed.</p>
</li>
<li>
<p>Enter a name and optional description for the function and click <span class="bold">OK</span>.</p>
<p>The Function Editor is displayed.</p>
</li>
<li>
<p>On the Parameters tab, provide the following information:</p>
<ul>
<li>
<p><span class="bold">Return Type:</span> Select the data type for the return type of the global function.</p>
</li>
<li>
<p><span class="bold">Parameters:</span> Each function parameter is represented by a row in the table below the Return Type field. To create a parameter, enter a name on a blank cell and provide details, such as the data type and default value, for the parameter. The list in the Data Type column is populated depending on the platform you choose in the Platform field.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
For SQL Server functions, <span class="italic">@</span> is automatically prefixed to each parameter name.</div>
</li>
<li>
<p>On the Implementation tab, enter the code that is used to implement the function on the platform that you selected in the Parameters tab.</p>
</li>
<li>
<p>From the View menu, select <span class="bold">Code Templates</span>.</p>
<p>The Code Templates tab is displayed in the Log window.</p>
</li>
<li>
<p>In the Code Templates tab, select the Function CT that is used to generate code for the function.</p>
<p>Oracle Warehouse Builder provides prebuilt Function CTs to generate code for DB2 and SQL Server databases. These Function CTs are located in the Globals Navigator under the BUILT_IN_CT node of the Public Code Templates folder. For DB2, you can use DB2_FCT and for SQL Server, you can use SQLSERVER_FCT.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1277"></a>
<h4 class="sect3">Importing a Function</h4>
<p>You can import existing functions from DB2 and SQL Server databases. This is similar to importing Oracle functions.</p>
<p><span class="bold">To import DB2 or SQL Server functions</span>:</p>
<ol>
<li>
<p>Right-click an existing DB2 or SQL Server module, and select <span class="bold">Import</span>, <span class="bold">Database Object</span>.</p>
<p>The Import Metadata Wizard is displayed.</p>
</li>
<li>
<p>In the Filter Information page, select <span class="bold">Transformations</span> from Object Type.</p>
</li>
<li>
<p>In the Object Selection page, select the required functions and move them from the Available field to the Selected field.</p>
</li>
<li>
<p>Verify the information in the Summary page and click <span class="bold">Finish</span> to begin the import.</p>
</li>
</ol>
<p>The imported functions are now visible under the module in the Projects Navigator.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Warehouse Builder enables you to import overloaded DB2 functions. However you cannot import overloaded SQL Server functions.</div>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1278"></a>
<h4 class="sect3">Predefined Generic Heterogeneous Functions</h4>
<p>The Heterogeneous node under the Public Transformations node of the Globals Navigator contains predefined functions that you can use for Oracle, SQL Server, and DB2 platforms.</p>
<p>Generic heterogeneous functions are categorized as follows:</p>
<ul>
<li>
<p>Character</p>
</li>
<li>
<p>Conversion</p>
</li>
<li>
<p>Date</p>
</li>
<li>
<p>Numeric</p>
</li>
<li>
<p>Other</p>
</li>
</ul>
<p>To view the function definition and the platform for which it is defined, double-click a function in any of the above categories. The Function Editor containing the Name, Parameter, and Expression tabs is displayed. Click the Parameter tab to view the platform for which the function is defined, the function parameters, and the function return type. Click the Expression tab to view the expression used for the SQL function and the platform for which the function is defined.</p>
<p>For details about the semantics of the expression provided, the parameters, and parameter data types, refer to the documentation for the particular platform.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1279"></a>
<h4 class="sect3">Using the Functions in Mappings</h4>
<p>At the time of creating DB2 or SQL Server functions, you associate a code template with the function. Therefore, you can only use these functions in mappings that are created under the Template Mappings node in Projects Navigator. These mappings are different from the normal mappings as they are used with code templates.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDBBADD"></a><a id="WBETL09007"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Configuring Functions</h2>
<p>After you define a function, you can configure it by setting configuration parameters using the Configuration panel.</p>
<p>The following sections list the configuration parameters supported by Oracle Warehouse Builder for the Oracle platform.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1280"></a>
<h3 class="sect2">Configuring Oracle Functions</h3>
<p>You can set the following configuration parameters for functions defined on the Oracle platform.</p>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1281"></a>
<h4 class="sect3">AUTHID</h4>
<p>Use this parameter to specify the privileges with which the function is run. Select one of the following options:</p>
<ul>
<li>
<p>CURRENT_USER: Indicates that the function is run with the privileges of the current user, in the current user's schema. This limits the scope for name resolution. Oracle Database looks for the function by name in the current user's schema.</p>
</li>
<li>
<p>DEFINER: Indicates that the function is run with the privileges assigned to the owner of the schema that the function resides in. All external names are to be resolved within the same schema.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1282"></a>
<h4 class="sect3">Deterministic</h4>
<p>Select this option to indicate that the function is deterministic. Deterministic functions return the same results for a given set of arguments every time that the function is run.</p>
<p>Setting this option helps to avoid redundant function calls. If a stored function was called previously with the same arguments, then the previous result can be used. The function result should not depend on the state of session variables or schema objects. Otherwise, results might vary across calls. Only DETERMINISTIC functions can be called from a function-based index or a materialized view that has query-rewrite enabled.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1283"></a>
<h4 class="sect3">Parallel Enable</h4>
<p>This parameter is an optimization hint. Select this parameter to indicate to the Oracle Database that the function should be run in parallel whenever called from within a SQL query. The processing is split between parallel processes (UNIX), or threads (Windows). Setting this option results in a speed improvement on multiprocessor systems.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref1284"></a>
<h4 class="sect3">Pragma Autonomous Transaction</h4>
<p>Selecting this option causes the PL/SQL compiler to mark the function as independent. It enables the function to suspend the main transaction (the one from which the function was invoked), and roll back or commit its own SQL operations.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2968">
<tr>
<td class="cellalignment2977">
<table class="cellalignment2973">
<tr>
<td class="cellalignment2972"><a href="design_processflows.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2972"><a href="etl_performance.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2980">
<table class="cellalignment2971">
<tr>
<td class="cellalignment2972"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2972"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2972"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2972"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2972"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2972"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
