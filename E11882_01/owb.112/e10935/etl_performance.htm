<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Understanding Performance and Advanced ETL Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-21T18:21:32Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Warehouse Builder Data Modeling, ETL, and Data Quality Guide" />
<meta name="dcterms.identifier" content="E10935-05" />
<meta name="dcterms.isVersionOf" content="WBETL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2000, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="custom_transforms.htm" title="Previous" type="text/html" />
<link rel="Next" href="scheduling_etl.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10935.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">15/37</span> <!-- End Header --><a id="BBAHFHBC"></a><a id="WBETL10000"></a>
<h1 class="chapter"><span class="secnum">10</span> Understanding Performance and Advanced ETL Concepts</h1>
<p><a id="sthref1285"></a><a id="sthref1286"></a><a id="sthref1287"></a>Use this chapter as a guide for creating ETL logic that meets your performance expectations.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#BBAGAHCH">"Best Practices for Designing PL/SQL Mappings"</a></p>
</li>
<li>
<p><a href="#BBABEBIG">"Best Practices for Designing SQL*Loader Mappings"</a></p>
</li>
<li>
<p><a href="#i1131648">"Improved Performance through Partition Exchange Loading"</a></p>
</li>
<li>
<p><a href="#CHDHECFF">"High Performance Data Extraction from Remote Sources"</a></p>
</li>
</ul>
<a id="BBAGAHCH"></a><a id="WBETL10001"></a>
<div class="sect1">
<h2 class="sect1">Best Practices for Designing PL/SQL Mappings<a id="sthref1288"></a><a id="sthref1289"></a><a id="sthref1290"></a><a id="sthref1291"></a></h2>
<p>This section addresses PL/SQL mapping design and includes:</p>
<ul>
<li>
<p><a href="#i1146158">"Set-Based Versus Row-Based Operating Modes"</a></p>
</li>
<li>
<p><a href="#CHDGJCGE">"About Committing Data in Oracle Warehouse Builder"</a></p>
</li>
<li>
<p><a href="#BBACEAGC">"Committing Data Based on Mapping Design"</a></p>
</li>
<li>
<p><a href="#CHDGBIJD">"Committing Data Independently of Mapping Design"</a></p>
</li>
<li>
<p><a href="#CHDHFBEH">"Running Multiple Mappings Before Committing Data"</a></p>
</li>
<li>
<p><a href="#BBABFIGF">"Ensuring Referential Integrity in PL/SQL Mappings"</a></p>
</li>
</ul>
<p>Oracle Warehouse Builder generates code for PL/SQL mappings that meet the following criteria:</p>
<ul>
<li>
<p>The output code of each operator satisfies the input code requirement of its next downstream operator.</p>
</li>
<li>
<p>If the mapping contains an operator that generates only PL/SQL output, all downstream data flow operators must also be implemented by PL/SQL. You can use SQL operators in such a mapping only after loading the PL/SQL output to a target.</p>
</li>
</ul>
<p>As you design a mapping, you can evaluate its validity by examining the input and output code types for each operator in the mapping.</p>
<p>For example, you can see that the mapping in <a href="#BBABCCAG">Figure 10-1</a> is invalid because the Match Merge operator <code>MM</code> generates PL/SQL output, but the subsequent Joiner operator accepts SQL input only.</p>
<div class="figure">
<p class="titleinfigure"><a id="BBABCCAG"></a>Figure 10-1 Mapping Violates Input Requirement for Joiner Operator</p>
<img width="494" height="233" src="img/invalid_map.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1292" href="img_text/invalid_map.htm">Description of "Figure 10-1 Mapping Violates Input Requirement for Joiner Operator"</a><br />
<br /></div>
<!-- class="figure" -->
<p>To achieve the desired results for the mapping, consider joining the source tables before performing the Match Merge or loading the results from the Match Merge to a staging table before performing the join.</p>
<p><a href="#i1144383">Figure 10-2</a> displays a mapping in which source tables are joined before the match-merge operation. <a href="#i1144389">Figure 10-3</a> displays a mapping in which the results from the Match Merge operator are loaded into a staging table before performing the join.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1144383"></a>Figure 10-2 Valid Mapping Design with Sources Joined Before Match Merge</p>
<img width="509" height="182" src="img/valid_map2.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1293" href="img_text/valid_map2.htm">Description of "Figure 10-2 Valid Mapping Design with Sources Joined Before Match Merge"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="figure">
<p class="titleinfigure"><a id="i1144389"></a>Figure 10-3 Valid Mapping Design with Staging Table</p>
<img width="574" height="173" src="img/valid_map1.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1294" href="img_text/valid_map1.htm">Description of "Figure 10-3 Valid Mapping Design with Staging Table"</a><br />
<br /></div>
<!-- class="figure" -->
<p><a href="#CBHIFIBE">Table 10-1</a> and <a href="#g1186289">Table 10-2</a> list the implementation types for each Oracle Warehouse Builder operator. These tables also indicate whether PL/SQL code includes the operation associated with the operator in the cursor. This information is relevant in determining which operating modes are valid for a given mapping design. It also determines what auditing details are available during error handling.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="sthref1295"></a><a id="CBHIFIBE"></a>Table 10-1 Source-Target Operators Implementation in PL/SQL Mappings</p>
<table class="cellalignment2978" title="Source-Target Operators Implementation in PL/SQL Mappings" summary="Lists the implementation types for each Warehouse Builder source and target operator." dir="ltr">
<thead>
<tr class="cellalignment2969">
<th class="cellalignment2976" id="r1c1-t2">Operator</th>
<th class="cellalignment2976" id="r1c2-t2">Implementation Types</th>
<th class="cellalignment2976" id="r1c3-t2">Valid in Set-Based Mode</th>
<th class="cellalignment2976" id="r1c4-t2">Valid in Row-Based Mode</th>
<th class="cellalignment2976" id="r1c5-t2">Valid in Row-Based (Target Only)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r2c1-t2" headers="r1c1-t2">
<p>Source Operators: Tables, Dimensions, Cubes, Views, External Tables</p>
</td>
<td class="cellalignment2977" headers="r2c1-t2 r1c2-t2">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r2c1-t2 r1c3-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r2c1-t2 r1c4-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r2c1-t2 r1c5-t2">
<p>Yes. Part of cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r3c1-t2" headers="r1c1-t2">
<p>Target Operators: Tables, Dimensions, Cubes, Views</p>
</td>
<td class="cellalignment2977" headers="r3c1-t2 r1c2-t2">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r3c1-t2 r1c3-t2">
<p>Yes, unless loading= UPDATE and database is not 10<span class="italic">g</span> or higher.</p>
</td>
<td class="cellalignment2977" headers="r3c1-t2 r1c4-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r3c1-t2 r1c5-t2">
<p>Yes. Not part of cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r4c1-t2" headers="r1c1-t2">
<p>Flat File as source</p>
</td>
<td class="cellalignment2977" headers="r4c1-t2 r1c2-t2">
<p>For PL/SQL, create an external table.</p>
</td>
<td class="cellalignment2977" headers="r4c1-t2 r1c3-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r4c1-t2 r1c4-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r4c1-t2 r1c5-t2">
<p>Yes. Part of the cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r5c1-t2" headers="r1c1-t2">
<p>Flat File as target</p>
</td>
<td class="cellalignment2977" headers="r5c1-t2 r1c2-t2">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r5c1-t2 r1c3-t2">
<p>Yes, unless loading = DELETE or loading= UPDATE and database is not 10<span class="italic">g</span> or higher.</p>
</td>
<td class="cellalignment2977" headers="r5c1-t2 r1c4-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r5c1-t2 r1c5-t2">
<p>Yes. Not part of cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r6c1-t2" headers="r1c1-t2">
<p>Sequence as source</p>
</td>
<td class="cellalignment2977" headers="r6c1-t2 r1c2-t2">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r6c1-t2 r1c3-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r6c1-t2 r1c4-t2">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r6c1-t2 r1c5-t2">
<p>Yes, part of cursor.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<div class="tblformalwide">
<p class="titleintable"><a id="sthref1296"></a><a id="g1186289"></a>Table 10-2 Data Flow Operator Implementation in PL/SQL Mappings</p>
<table class="cellalignment2978" title="Data Flow Operator Implementation in PL/SQL Mappings" summary="Lists the implementation types for each Warehouse Builder data flow operator." dir="ltr">
<thead>
<tr class="cellalignment2969">
<th class="cellalignment2976" id="r1c1-t3">Operator Name</th>
<th class="cellalignment2976" id="r1c2-t3">Implementation Types</th>
<th class="cellalignment2976" id="r1c3-t3">Valid in Set-Based Mode</th>
<th class="cellalignment2976" id="r1c4-t3">Valid in Row-Based Mode</th>
<th class="cellalignment2976" id="r1c5-t3">Valid in Row-Based (Target Only) Mode</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r2c1-t3" headers="r1c1-t3">
<p>Aggregator</p>
</td>
<td class="cellalignment2977" headers="r2c1-t3 r1c2-t3">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r2c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r2c1-t3 r1c4-t3">
<p>Yes, only if part of the cursor.</p>
</td>
<td class="cellalignment2977" headers="r2c1-t3 r1c5-t3">
<p>Yes, only if part of the cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r3c1-t3" headers="r1c1-t3">
<p>Constant Operator</p>
</td>
<td class="cellalignment2977" headers="r3c1-t3 r1c2-t3">
<p>PL/SQL</p>
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r3c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r3c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r3c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r4c1-t3" headers="r1c1-t3">
<p>Data Generator</p>
</td>
<td class="cellalignment2977" headers="r4c1-t3 r1c2-t3">
<p>SQL*Loader Only</p>
</td>
<td class="cellalignment2977" headers="r4c1-t3 r1c3-t3">
<p>N/A</p>
</td>
<td class="cellalignment2977" headers="r4c1-t3 r1c4-t3">
<p>N/A</p>
</td>
<td class="cellalignment2977" headers="r4c1-t3 r1c5-t3">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r5c1-t3" headers="r1c1-t3">
<p>Deduplicator</p>
</td>
<td class="cellalignment2977" headers="r5c1-t3 r1c2-t3">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r5c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r5c1-t3 r1c4-t3">
<p>Yes, only if part of the cursor</p>
</td>
<td class="cellalignment2977" headers="r5c1-t3 r1c5-t3">
<p>Yes, only if part of the cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r6c1-t3" headers="r1c1-t3">
<p>Expression</p>
</td>
<td class="cellalignment2977" headers="r6c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r6c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r6c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r6c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r7c1-t3" headers="r1c1-t3">
<p>Filter</p>
</td>
<td class="cellalignment2977" headers="r7c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r7c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r7c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r7c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r8c1-t3" headers="r1c1-t3">
<p>Joiner</p>
</td>
<td class="cellalignment2977" headers="r8c1-t3 r1c2-t3">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r8c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r8c1-t3 r1c4-t3">
<p>Yes, only if part of the cursor.</p>
</td>
<td class="cellalignment2977" headers="r8c1-t3 r1c5-t3">
<p>Yes, only if part of the cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r9c1-t3" headers="r1c1-t3">
<p>Lookup</p>
</td>
<td class="cellalignment2977" headers="r9c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r9c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r9c1-t3 r1c4-t3">
<p>Yes, unless the All Rows option is selected on the <a href="data_flow_opers.htm#CHDJCCAI">Multiple Match Rows</a> page of the Lookup operator.</p>
</td>
<td class="cellalignment2977" headers="r9c1-t3 r1c5-t3">
<p>Yes, unless the All Rows option is selected on the <a href="data_flow_opers.htm#CHDJCCAI">Multiple Match Rows</a> page of the Lookup operator.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r10c1-t3" headers="r1c1-t3">
<p>Mapping Input Parameter</p>
</td>
<td class="cellalignment2977" headers="r10c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r10c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r10c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r10c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r11c1-t3" headers="r1c1-t3">
<p>Mapping Output Parameter</p>
</td>
<td class="cellalignment2977" headers="r11c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r11c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r11c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r11c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r12c1-t3" headers="r1c1-t3">
<p>Match Merge</p>
</td>
<td class="cellalignment2977" headers="r12c1-t3 r1c2-t3">
<p>SQL input</p>
<p>PL/SQL output</p>
<p>(PL/SQL input from XREF group only)</p>
</td>
<td class="cellalignment2977" headers="r12c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment2977" headers="r12c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r12c1-t3 r1c5-t3">
<p>Yes. Not part of cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r13c1-t3" headers="r1c1-t3">
<p>Name and Address</p>
</td>
<td class="cellalignment2977" headers="r13c1-t3 r1c2-t3">
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r13c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment2977" headers="r13c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r13c1-t3 r1c5-t3">
<p>Yes. Not part of cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r14c1-t3" headers="r1c1-t3">
<p>Pivot</p>
</td>
<td class="cellalignment2977" headers="r14c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r14c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r14c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r14c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r15c1-t3" headers="r1c1-t3">
<p>Post-Mapping Process</p>
</td>
<td class="cellalignment2977" headers="r15c1-t3 r1c2-t3">
<p>Irrelevant</p>
</td>
<td class="cellalignment2977" headers="r15c1-t3 r1c3-t3">
<p>Yes, independent of data flow</p>
</td>
<td class="cellalignment2977" headers="r15c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r15c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r16c1-t3" headers="r1c1-t3">
<p>Pre-Mapping Process</p>
</td>
<td class="cellalignment2977" headers="r16c1-t3 r1c2-t3">
<p>Irrelevant</p>
</td>
<td class="cellalignment2977" headers="r16c1-t3 r1c3-t3">
<p>Yes, independent of data flow</p>
</td>
<td class="cellalignment2977" headers="r16c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r16c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r17c1-t3" headers="r1c1-t3">
<p>Set</p>
</td>
<td class="cellalignment2977" headers="r17c1-t3 r1c2-t3">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r17c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r17c1-t3 r1c4-t3">
<p>Yes, only if part of the cursor.</p>
</td>
<td class="cellalignment2977" headers="r17c1-t3 r1c5-t3">
<p>Yes, only if part of the cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r18c1-t3" headers="r1c1-t3">
<p>Sorter</p>
</td>
<td class="cellalignment2977" headers="r18c1-t3 r1c2-t3">
<p>SQL</p>
</td>
<td class="cellalignment2977" headers="r18c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r18c1-t3 r1c4-t3">
<p>Yes, only if part of the cursor.</p>
</td>
<td class="cellalignment2977" headers="r18c1-t3 r1c5-t3">
<p>Yes, as part of the cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r19c1-t3" headers="r1c1-t3">
<p>Splitter</p>
</td>
<td class="cellalignment2977" headers="r19c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r19c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r19c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r19c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r20c1-t3" headers="r1c1-t3">
<p>Table Function</p>
</td>
<td class="cellalignment2977" headers="r20c1-t3 r1c2-t3">
<p>SQL or PL/SQL input</p>
<p>SQL output only</p>
</td>
<td class="cellalignment2977" headers="r20c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r20c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r20c1-t3 r1c5-t3">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r21c1-t3" headers="r1c1-t3">
<p>Transformation as a procedure</p>
</td>
<td class="cellalignment2977" headers="r21c1-t3 r1c2-t3">
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r21c1-t3 r1c3-t3">
<p>No</p>
</td>
<td class="cellalignment2977" headers="r21c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r21c1-t3 r1c5-t3">
<p>Yes. Not part of cursor.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r22c1-t3" headers="r1c1-t3">
<p>Transformation as a function that does not perform DML</p>
</td>
<td class="cellalignment2977" headers="r22c1-t3 r1c2-t3">
<p>SQL</p>
<p>PL/SQL</p>
</td>
<td class="cellalignment2977" headers="r22c1-t3 r1c3-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r22c1-t3 r1c4-t3">
<p>Yes</p>
</td>
<td class="cellalignment2977" headers="r22c1-t3 r1c5-t3">
<p>Yes, included in the cursor.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<a id="i1146158"></a>
<div class="sect2">
<h3 class="sect2">Set-Based Versus Row-Based Operating Modes<a id="sthref1297"></a><a id="sthref1298"></a></h3>
<p>For mappings with a PL/SQL implementation, select one of the following operating modes:</p>
<ul>
<li>
<p><a href="#i1146027">"Set-Based Mode"</a></p>
</li>
<li>
<p><a href="#i1146067">"Row-Based Mode"</a></p>
</li>
<li>
<p><a href="#i1146105">"Row-Based (Target Only) Mode"</a></p>
</li>
<li>
<p>Set-based fail over to row-based</p>
</li>
<li>
<p>Set-based fail over to row-based (target only)</p>
</li>
</ul>
<p>The default operating mode that you select depends upon the performance that you expect, the amount of auditing data that you require, and how you design the mapping. Mappings have at least one and as many as three valid operating modes, excluding the options for failing over to row-based modes. During code generation, Oracle Warehouse Builder generates code for the specified default operating mode and for the deselected modes. Therefore, at run time, you can select to run in the default operating mode or any one of the other valid operating modes.</p>
<p>The types of operators in the mapping may limit the operating modes that you can select. As a general rule, mappings run in set-based mode can include any of the operators except for Match Merge, Name and Address, and Transformations used as procedures. Although you can include any of the operators in row-based and row-based (target only) modes, there are important restrictions on how you use SQL based operators such as Aggregators and Joins. To use SQL-based operators in either of the row-based modes, ensure that the operation associated with the operator can be included in the cursor.</p>
<p>These general rules are explained in the following sections.</p>
<a id="i1146027"></a>
<div class="sect3">
<h4 class="sect3">Set-Based<a id="sthref1299"></a><a id="sthref1300"></a> Mode</h4>
<p>In set-based mode, Oracle Warehouse Builder generates a single SQL statement that processes all data and performs all operations. Although processing data as a set improves performance, the auditing information available is limited. Runtime auditing is limited to reporting of the execution error only. With set-based mode, you cannot identify the rows that contain errors.</p>
<p><a href="#i1146041">Figure 10-4</a> shows a simple mapping and the associated logic that Oracle Warehouse Builder uses to generate code for the mapping when run in set-based operating mode. TAB1, FLTR, and TAB2 are processed as a set using SQL.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1146041"></a>Figure 10-4 Simple Mapping Run in Set-Based Mode</p>
<img width="346" height="121" src="img/set_ex.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1301" href="img_text/set_ex.htm">Description of "Figure 10-4 Simple Mapping Run in Set-Based Mode"</a><br />
<br /></div>
<!-- class="figure" -->
<p>To correctly design a mapping for the set-based mode, avoid operators that require row- by-row processing such as Match Merge and Name and Address operators. If you include an operator in the data flow that cannot be performed in SQL, then Oracle Warehouse Builder does not generate set-based code and displays an error when you run the package in set-based mode.</p>
<p><a id="sthref1302"></a>For target operators in a mapping, the loading types INSERT/UPDATE and UPDATE/INSERT are always valid for set-based mode. Oracle Warehouse Builder supports UPDATE loading in set-based mode only with Oracle Database is 10<span class="italic">g</span> or later. Oracle Warehouse Builder also supports the loading type DELETE in set-based mode. For a complete listing of how Oracle Warehouse Builder handles operators in set-based mappings, see <a href="#g1186289">Table 10-2</a>.</p>
</div>
<!-- class="sect3" -->
<a id="i1146067"></a>
<div class="sect3">
<h4 class="sect3">Row-Based<a id="sthref1303"></a><a id="sthref1304"></a> Mode</h4>
<p>In row-based mode, Oracle Warehouse Builder generates statements that process data row by row. The select statement is in a SQL cursor. All subsequent statements are PL/SQL. You can access full run time auditing information for all operators performed in PL/SQL and only limited information for operations performed in the cursor.</p>
<p><a href="#i1146081">Figure 10-5</a> shows a simple mapping and the associated logic that Oracle Warehouse Builder uses to generate code for the mapping when run in row-based operating mode. TAB1 is included in the cursor and processed as a set using SQL. FLTR and TAB2 are processed row by row using PL/SQL.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1146081"></a>Figure 10-5 Simple Mapping Run in Row-Based Mode</p>
<img width="346" height="121" src="img/row_ex.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1305" href="img_text/row_ex.htm">Description of "Figure 10-5 Simple Mapping Run in Row-Based Mode"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If the mapping includes any SQL-based operators that cannot be performed in PL/SQL, Oracle Warehouse Builder attempts to generate code with those operations in the cursor. To generate valid row-based code, design your mapping such that if you include any of the following SQL-based operators, Oracle Warehouse Builder can include the operations in the cursor:</p>
<ul>
<li>
<p>Aggregation</p>
</li>
<li>
<p>Deduplicator</p>
</li>
<li>
<p>Joiner</p>
</li>
<li>
<p>Lookup</p>
</li>
<li>
<p>Sequence</p>
</li>
<li>
<p>Set</p>
</li>
<li>
<p>Sorter</p>
</li>
</ul>
<p>For the preceding operators to be included in the cursor, do not directly precede it by an operator that generates PL/SQL code. In other words, you cannot run the mapping in row-based mode if it contains a Transformation implemented as a procedure, a Flat File used as a source, a Match Merge, or Name and Address operator directly followed by any of the seven SQL-based operators. For the design to be valid, include a staging table between the PL/SQL generating operator and the SQL-based operator.</p>
</div>
<!-- class="sect3" -->
<a id="i1146105"></a>
<div class="sect3">
<h4 class="sect3">Row-Based (Target Only)<a id="sthref1306"></a><a id="sthref1307"></a> Mode</h4>
<p>In row-based (target only) mode, Oracle Warehouse Builder generates a cursor select statement and attempts to include as many operations as possible in the cursor. For each target, Oracle Warehouse Builder inserts each row into the target separately. You can access full run time auditing information for all operators performed in PL/SQL and only limited information for operations performed in the cursor. Use this mode when you expect fast set-based operations to extract and transform the data but need extended auditing for loading the data, which is where errors are likely to occur.</p>
<p><a href="#i1146122">Figure 10-6</a> shows a simple mapping and the associated logic that Oracle Warehouse Builder uses to generate code for the mapping when run in row-based (target only) operating mode. TAB1 and FLTR are included in the cursor and processed as a set using SQL. TAB2 is processed row by row.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1146122"></a>Figure 10-6 Simple Mapping Run in Row-Based (Target Only) Mode</p>
<img width="346" height="121" src="img/row_target_ex.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1308" href="img_text/row_target_ex.htm">Description of "Figure 10-6 Simple Mapping Run in Row-Based (Target Only) Mode"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Row-based (target only) mode places the same restrictions on SQL-based operators as the row-based operating mode. Additionally, for mappings with multiple targets, Oracle Warehouse Builder generates code with a cursor for each target.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Release 11.2.0.3 and onwards, the feature Set Based Failover Row Based has been deprecated.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGJCGE"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">About Committing Data in Oracle Warehouse Builder</h3>
<p>There are two major approaches to committing data in Oracle Warehouse Builder. You can commit or rollback data based on the mapping design. Use one of the commit control methods described in <a href="#BBACEAGC">"Committing Data Based on Mapping Design"</a>.</p>
<p>Alternatively, for PL/SQL mappings, you can commit or rollback data independently of the mapping design. Use a process flow to commit the data or establish your own method as described in <a href="#CHDGBIJD">"Committing Data Independently of Mapping Design"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BBACEAGC"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Committing Data Based on Mapping Design</h3>
<p>By default, Oracle Warehouse Builder loads and then automatically commits data based on the mapping design. For PL/SQL mappings you can override the default setting and control when and how Oracle Warehouse Builder commits data. You have the following options for committing data in mappings:</p>
<p><span class="bold">Automatic:</span> This is the default setting and is valid for all mapping types. Oracle Warehouse Builder loads and then automatically commits data based on the mapping design. If the mapping has multiple targets, then Oracle Warehouse Builder commits and rolls back each target separately and independently of other targets. Use the automatic commit when the consequences of multiple targets being loaded unequally are not great or are irrelevant.</p>
<p><span class="bold">Automatic correlated:</span> Automatic correlated commit is a specialized type of automatic commit that applies to PL/SQL mappings with multiple targets only. Oracle Warehouse Builder considers all targets collectively and commits or rolls back data uniformly across all targets. Use the correlated commit when it is important to ensure that every row in the source affects all affected targets uniformly. For more information about automatic correlated commit, see <a href="#i1145851">"Committing Data from a Single Source to Multiple Targets"</a>.</p>
<p><span class="bold">Manual:</span> Select manual commit control for PL/SQL mappings when you want to interject complex business logic, perform validations, or run other mappings before committing data. For examples, see <a href="#BBAFJJCJ">"Embedding Commit Logic into the Mapping"</a> and <a href="#CHDGBIJD">"Committing Data Independently of Mapping Design"</a>.</p>
<a id="i1145851"></a>
<div class="sect3">
<h4 class="sect3">Committing Data from a Single Source to Multiple Targets<a id="sthref1309"></a><a id="sthref1310"></a></h4>
<p>To populate multiple targets based on a common source, you may also want to ensure that every row from the source affects all targets uniformly.</p>
<p><a href="#i1145859">Figure 10-7</a> shows a PL/SQL mapping that illustrates this case. The target tables all depend upon the source table. If a row from SOURCE causes changes in multiple targets (for instance TARGET_1 and TARGET_2), then Oracle Warehouse Builder should commit the appropriate data to both affected targets at the same time. If this relationship is not maintained when you run the mapping again, then the data can become inaccurate and possibly unusable.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1145859"></a>Figure 10-7 Mapping with Multiple Targets Dependent on One Source</p>
<img width="476" height="244" src="img/cor_commit_ex_generic.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1311" href="img_text/cor_commit_ex_generic.htm">Description of "Figure 10-7 Mapping with Multiple Targets Dependent on One Source"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If the number of rows from the source table is relatively small, maintaining the three targets may not be difficult. Manually maintaining targets dependent on a common source, however, becomes more tedious as you increase the number of rows from the source, or as you design more complex mappings with more targets and transformations.</p>
<p>To ensure that every row in the source properly affects every target, configure the mapping to use the correlated commit strategy.</p>
<p class="subhead2"><a id="sthref1312"></a>Using the Automatic Correlated Commit Strategy<a id="sthref1313"></a></p>
<p>In set-based mode, correlated commit may impact the size of your rollback segments. Space for rollback segments may be a concern when you merge data (insert/update or update/insert).</p>
<p>Correlated commit operates transparently with PL/SQL bulk processing code.</p>
<p>The correlated commit strategy is not available for mappings run in any mode that are configured for Partition Exchange Loading or that include a Queue, Match Merge, or Table Function operator.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1314"></a>
<h4 class="sect3">Automatic Commit versus Automatic Correlated Commit</h4>
<p>The combination of the commit strategy and operating mode determines mapping behavior. <a href="#CIHBDGFG">Table 10-3</a> shows the valid combinations that you can select.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref1315"></a><a id="CIHBDGFG"></a>Table 10-3 Valid Commit Strategies for Operating Modes</p>
<table class="cellalignment2975" title="Valid Commit Strategies for Operating Modes" summary="Lists the valid combinations of operation modes and commit strategies." dir="ltr">
<thead>
<tr class="cellalignment2969">
<th class="cellalignment2976" id="r1c1-t5">Operating Mode</th>
<th class="cellalignment2976" id="r1c2-t5">Automatic Correlated Commit</th>
<th class="cellalignment2976" id="r1c3-t5">Automatic Commit</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r2c1-t5" headers="r1c1-t5">
<p>Set-based</p>
</td>
<td class="cellalignment2977" headers="r2c1-t5 r1c2-t5">
<p>Valid</p>
</td>
<td class="cellalignment2977" headers="r2c1-t5 r1c3-t5">
<p>Valid</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r3c1-t5" headers="r1c1-t5">
<p>Row-based</p>
</td>
<td class="cellalignment2977" headers="r3c1-t5 r1c2-t5">
<p>Valid</p>
</td>
<td class="cellalignment2977" headers="r3c1-t5 r1c3-t5">
<p>Valid</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r4c1-t5" headers="r1c1-t5">
<p>Row-based (target only)</p>
</td>
<td class="cellalignment2977" headers="r4c1-t5 r1c2-t5">
<p>Not Applicable</p>
</td>
<td class="cellalignment2977" headers="r4c1-t5 r1c3-t5">
<p>Valid</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Correlated commit is not applicable for row-based (target only). By definition, this operating mode places the cursor as close to the target as possible. In most cases, this results in only one target for each select statement and negates the purpose of committing data to multiple targets. If you design a mapping with the row-based (target only) and correlated commit combination, then Oracle Warehouse Builder runs the mapping but does not perform the correlated commit.</p>
<p>To understand the effects each operating mode and commit strategy combination has on a mapping, consider the mapping from <a href="#i1145859">Figure 10-7</a>. Assume the data from source table equates to 1,000 new rows. When the mapping runs successfully, Oracle Warehouse Builder loads 1,000 rows to each of the targets. If the mapping fails to load the 100th new row to Target_2, then you can expect the following results, ignoring the influence from other configuration settings such as Commit Frequency and Number of Maximum Errors:</p>
<ul>
<li>
<p><span class="bold">Set-based/ Correlated Commit:</span> A single error anywhere in the mapping triggers the rollback of all data. When Oracle Warehouse Builder encounters the error inserting into Target_2, it reports an error for the table and does not load the row. Oracle Warehouse Builder rolls back all the rows inserted into Target_1 and does not attempt to load rows to Target_3. No rows are added to any of the target tables. For error details, Oracle Warehouse Builder reports only that it encountered an error loading to Target_2.</p>
</li>
<li>
<p><span class="bold">Row-based/ Correlated Commit:</span> Beginning with the first row, Oracle Warehouse Builder evaluates each row separately and loads it to all three targets. Loading continues in this way until Oracle Warehouse Builder encounters an error loading row 100 to Target_2. Oracle Warehouse Builder reports the error and does not load the row. It rolls back the row 100 previously inserted into Target_1 and does not attempt to load row 100 to Target_3. Next, Oracle Warehouse Builder continues loading the remaining rows, resuming with loading row 101 to Target_1. Assuming Oracle Warehouse Builder encounters no other errors, the mapping completes with 999 new rows inserted into each target. The source rows are accurately represented in the targets.</p>
</li>
<li>
<p><span class="bold">Set-based/ Automatic Commit:</span> When Oracle Warehouse Builder encounters the error inserting into Target_2, it does not load any rows and reports an error for the table. It does, however, continue to insert rows into Target_3 and does not roll back the rows from Target_1. Assuming Oracle Warehouse Builder encounters no other errors, the mapping completes with one error message for Target_2, no rows inserted into Target_2, and 1,000 rows inserted into Target_1 and Target_3. The source rows are not accurately represented in the targets.</p>
</li>
<li>
<p><span class="bold">Row-based/Automatic Commit:</span> Beginning with the first row, Oracle Warehouse Builder evaluates each row separately for loading into the targets. Loading continues in this way until Oracle Warehouse Builder encounters an error loading row 100 to Target_2 and reports the error. Oracle Warehouse Builder does not roll back row 100 from Target_1, does insert it into Target_3, and continues to load the remaining rows. Assuming Oracle Warehouse Builder encounters no other errors, the mapping completes with 999 rows inserted into Target_2 and 1,000 rows inserted into each of the other targets. The source rows are not accurately represented in the targets.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="BBAFJJCJ"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Embedding Commit Logic into the Mapping</h4>
<p>For PL/SQL mappings only, you can embed commit logic into the mapping design by adding a Pre-Mapping Process or Post-Mapping Process operator with SQL statements to commit and rollback data. When you run the mapping, Oracle Warehouse Builder commits or rollback data based solely on the SQL statements you provide in the Pre-Mapping Process or Post-Mapping Process operator.</p>
<p>Use these instructions to implement a business rule that is tedious or impossible to design given existing Oracle Warehouse Builder mapping operators. For example, you may want to verify the existence of a single row in a target. Write the required logic in SQL and introduce that logic to the mapping through a pre or post mapping operator.</p>
<p><span class="bold">To include commit logic in the mapping design:</span></p>
<ol>
<li>
<p>Design the mapping to include a Pre-Mapping Process or Post-Mapping Process operator. Use one of these operators to introduce commit and rollback SQL statements.</p>
</li>
<li>
<p>Configure the mapping with <span class="bold">Commit Control</span> set to Manual.</p>
<p>In the Projects Navigator, right-click the mapping and select <span class="bold">Configure.</span> Under <span class="bold">Code Generation Options,</span> select <span class="bold">Commit Control</span> to Manual.</p>
<p>To understand the implications of selecting to commit data manually, see <a href="#CHDFBCDI">"About Manual Commit Control"</a>.</p>
</li>
<li>
<p>Deploy the mapping.</p>
</li>
<li>
<p>Run the mapping.</p>
<p>Oracle Warehouse Builder runs the mapping but does not commit data until processing the commit logic you wrote in the Pre-Mapping Process or Post-Mapping Process operator.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDGBIJD"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Committing Data Independently of Mapping Design</h3>
<p>You may want to commit data independently of the mapping design for any of the following reasons:</p>
<ul>
<li>
<p><a href="#CHDHFBEH"><span class="xreftitlebold">Running Multiple Mappings Before Committing Data</span></a>: You may want to run multiple mappings without committing data until successfully running and validating all mappings. This can be the case when you have separate mappings for loading dimensions and cubes.</p>
</li>
<li>
<p><span class="bold">Maintaining targets more efficiently:</span> If incorrect data is loaded and committed to a very large target, it can be difficult and time consuming to repair the damage. To avoid, first check the data and then decide whether to issue a commit or rollback command.</p>
</li>
</ul>
<p>The first step to achieve these goals is to configure the mapping with commit control set to Manual.</p>
<p class="subhead2"><a id="CHDFBCDI"></a>About Manual Commit Control</p>
<p>Manual commit control enables you to specify when Oracle Warehouse Builder commits data regardless of the mapping design. Manual commit control does not affect auditing statistics. It means that you can view the number of rows inserted and other auditing information before issuing the commit or rollback command.</p>
<p>When using manual commit, be aware that this option may have performance implications. Mappings that you intend to run in parallel maybe be run serially if the design requires a target to be read after being loaded. This occurs when moving data from a remote source or loading to two targets bound to the same table.</p>
<p>When you enable manual commit control, Oracle Warehouse Builder runs the mapping with PEL switched off.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHFBEH"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Running Multiple Mappings Before Comm<a id="sthref1316"></a>itting Data</h3>
<p>This section provides two sets of instructions for committing data independent of the mapping design. The first set describes how to run mappings and then commit data in a SQL*Plus session. Use these instructions to test and debug your strategy of running multiple mappings and then committing the data. Then, use the second set of instructions to automate the strategy.</p>
<p>Both sets of instructions rely upon the use of the main procedure generated for each PL/SQL mapping.</p>
<p class="subhead2"><a id="CHDIICDH"></a>Main Procedure<a id="sthref1317"></a><a id="sthref1318"></a><a id="sthref1319"></a></p>
<p>The main procedure is a procedure that exposes the logic for starting mappings in Oracle Warehouse Builder. You can employ this procedure in PL/SQL scripts or use it in interactive SQL*Plus sessions.</p>
<p>When you use the main procedure, you must specify one required parameter, <span class="italic">p_status</span>. And you can optionally specify other parameters relevant to the execution of the mapping as described in <a href="#CHDBDGEH">Table 10-4</a>. Oracle Warehouse Builder uses the default setting for any optional parameters that you do not specify.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref1320"></a><a id="CHDBDGEH"></a>Table 10-4 Parameter for the Main Procedure</p>
<table class="cellalignment2975" title="Parameter for the Main Procedure" summary="List of optional parameters when using the main procedure." dir="ltr">
<thead>
<tr class="cellalignment2969">
<th class="cellalignment2976" id="r1c1-t6">Parameter Name</th>
<th class="cellalignment2976" id="r1c2-t6">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r2c1-t6" headers="r1c1-t6">
<p>p_status</p>
</td>
<td class="cellalignment2977" headers="r2c1-t6 r1c2-t6">
<p>Use this required parameter to write the status of the mapping upon completion. It operates with the predefined variable called <span class="italic">status</span>.</p>
<p>The status variable is defined such that OK indicates the mapping completed without errors. OK_WITH_WARNINGS indicates the mapping completed with user errors. FAILURE indicates the mapping encountered a irrecoverable error.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r3c1-t6" headers="r1c1-t6">
<p>p_operating_mode</p>
</td>
<td class="cellalignment2977" headers="r3c1-t6 r1c2-t6">
<p>Use this optional parameter to pass in the default operating mode such as SET_BASED.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r4c1-t6" headers="r1c1-t6">
<p>p_bulk_size</p>
</td>
<td class="cellalignment2977" headers="r4c1-t6 r1c2-t6">
<p>Use this optional parameter to pass in the bulk size.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r5c1-t6" headers="r1c1-t6">
<p>p_audit_level</p>
</td>
<td class="cellalignment2977" headers="r5c1-t6 r1c2-t6">
<p>Use this optional parameter to pass in the default audit level such as COMPLETE.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r6c1-t6" headers="r1c1-t6">
<p>p_max_no_of_errors</p>
</td>
<td class="cellalignment2977" headers="r6c1-t6 r1c2-t6">
<p>Use this optional parameter to pass in the permitted maximum number of errors.</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r7c1-t6" headers="r1c1-t6">
<p>p_commit_frequency</p>
</td>
<td class="cellalignment2977" headers="r7c1-t6 r1c2-t6">
<p>Use this optional parameter to pass in the commit frequency.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="BBAJIGIJ"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Committing Data at Runtime</h4>
<p>For PL/SQL mappings alone, you can run mappings and issue commit and rollback commands from the SQL*Plus session. Based on your knowledge of SQL*Plus and the <a href="#CHDIICDH">"Main Procedure"</a>, you can manually run and validate multiple mappings before committing data.</p>
<p><span class="bold">To commit data manually at runtime:</span></p>
<ol>
<li>
<p>Design the PL/SQL mappings. For instance, create one mapping to load dimensions and a separate mapping to load cubes.</p>
<p>These instructions are not valid for SQL*Loader and ABAP mappings.</p>
</li>
<li>
<p>Configure both mappings with the Commit Control parameter set to Manual.</p>
<p>In the Projects Navigator, right-click the mapping and select <span class="bold">Configure.</span> Under the Code Generation Options<span class="bold">,</span> set the Commit Control parameter to Manual.</p>
</li>
<li>
<p>Generate each mapping.</p>
</li>
<li>
<p>From a SQL*Plus session, issue the following command to run the first mapping called <span class="italic">map1</span> in this example:</p>
<pre>
var status VARCHAR2(30);
execute map1.main(:status);
</pre>
<p>The first line declares the predefined status variable described in <a href="#CHDBDGEH">Table 10-4</a>. In the second line, <span class="italic">p_status</span> is set to the status variable. When <span class="italic">map1</span> completes, SQL*Plus displays the mapping status such as <span class="italic">OK.</span></p>
</li>
<li>
<p>Run the second mapping, in this example, the cubes mapping called <span class="italic">map2.</span></p>
<p>You can run the second in the same way you ran the previous map. Or, you can supply additional parameters listed in <a href="#CHDBDGEH">Table 10-4</a> to dictate how to run the <span class="italic">map2</span> in this example:</p>
<pre>
map2.main (p_status =&gt; :status,               \
           p_operating_mode =&gt; 'SET_BASED',   \
           p_audit_level =&gt; 'COMPLETE');
</pre></li>
<li>
<p>Verify the results from the execution of the two mappings and send either the commit or rollback command.</p>
</li>
<li>
<p>Automate your commit strategy as described in <a href="#BCEGGFCF">"Committing Mappings through the Process Flow Editor"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="BCEGGFCF"></a>
<div class="sect3">
<h4 class="sect3">Committing Mappings through the Process Flow Editor</h4>
<p>For PL/SQL mappings alone, you can commit or rollback mappings. Based on your knowledge of the SQL*PLUS activity, the Main Procedure, and writing PL/SQL scripts, you can use process flows to automate logic that commits data after all mappings complete successfully or rollback the data if any mapping fails.</p>
<p><span class="bold">To commit multiple mappings through a process flow:</span></p>
<ol>
<li>
<p>Design the PL/SQL mappings.</p>
<p>These instructions are not valid for SQL*Loader and ABAP mappings.</p>
</li>
<li>
<p>Ensure each mapping is deployed to the same schema.</p>
<p>All mappings must have their locations pointing to the same schema. You can achieve this by designing the mappings under the same target module. Or, for multiple target modules, ensure that the locations point to the same schema.</p>
</li>
<li>
<p>Configure each mapping with the Commit Control parameter set to Manual.</p>
<p>In the Projects Navigator, right-click the mapping and select <span class="bold">Configure.</span> Under Code Generation Options<span class="bold">,</span> set the Commit Control parameter to Manual.</p>
</li>
<li>
<p>Design a process flow using a SQL*PLUS activity instead of multiple mapping activities.</p>
<p>In typical process flows, you add a Mapping activity for each mapping and the process flow runs an implicit commit after each Mapping activity. However, in this design, do not add mapping activities. Instead, add a single SQL*PLUS activity.</p>
</li>
<li>
<p>Write a PL/SQL script that uses the main procedure to run each mapping. The following script demonstrates how to run the next mapping only if the initial mapping succeeds.</p>
<pre>
declare
    status VARCHAR2(30);
begin
    map1.main(status);
    if status != 'OK' then
       rollback;
    else
       map2.main(status);
       if status != 'OK' then
           rollback;
       else
           commit;
       end if;
    end if;
end;
</pre></li>
<li>
<p>Paste your PL/SQL script into the SQL*PLUS activity.</p>
<p>In the editor explorer, select <span class="bold">SCRIPT</span> under the SQL*PLUS activity and then double-click <span class="bold">Value</span> in the object inspector.</p>
</li>
<li>
<p>Optionally apply a schedule to the process flow as described in <a href="scheduling_etl.htm#BIHDCJCD">"Defining Schedules"</a>.</p>
</li>
<li>
<p>Deploy the mappings, process flow, and schedule if you defined one.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BBABFIGF"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Ensuring Referential Integrity in PL/SQL Mappings<a id="sthref1321"></a><a id="sthref1322"></a><a id="sthref1323"></a><a id="sthref1324"></a><a id="sthref1325"></a><a id="sthref1326"></a></h3>
<p>When you design mappings with multiple targets, you may want to ensure that Oracle Warehouse Builder loads the targets in a specific order. This is the case when a column in one target derives its data from another target.</p>
<p>To ensure referential integrity in PL/SQL mappings:</p>
<ol>
<li>
<p>Design a PL/SQL mapping with multiple targets.</p>
</li>
<li>
<p>(Optional) Define a parent/child relationship between two of the targets by specifying a foreign key.</p>
<p>A foreign key in the child table must refer to a primary key in the parent table. If the parent does not have a column defined as a primary key, then you must add a column and set it as the primary key. For an example, see <a href="#i1143526">"Using Conventional Loading to Ensure Referential Integrity in SQL*Loader Mappings"</a>.</p>
</li>
<li>
<p>In the mapping properties, view the Target Load Order property by clicking the Ellipsis button to the right of this property.</p>
<p>If you defined a foreign key relationship in the previous step, Oracle Warehouse Builder calculates a default loading order that loads parent targets before children. If you did not define a foreign key, then use the Target Load Order dialog box to define the loading order.</p>
<p>For more information, see <a href="mappings.htm#BEIHJBIG">"Specifying the Order in Which Target Objects in a Mapping Are Loaded"</a>.</p>
</li>
<li>
<p>Ensure that the Use Target Load Ordering configuration parameter is set to its default value of true.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BBABEBIG"></a><a id="WBETL10002"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Best Practices for Designing SQL*Loader Mappings</h2>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#i1143526">"Using Conventional Loading to Ensure Referential Integrity in SQL*Loader Mappings"</a></p>
</li>
<li>
<p><a href="#i1147024">"Using Direct Path Loading to Ensure Referential Integrity in SQL*Loader Mappings"</a></p>
</li>
</ul>
<a id="i1143526"></a>
<div class="sect2">
<h3 class="sect2">Using Conventional Loading to<a id="sthref1327"></a> Ensure Referential Integrity<a id="sthref1328"></a><a id="sthref1329"></a><a id="sthref1330"></a><a id="sthref1331"></a><a id="sthref1332"></a> in SQL*Loader Mappings</h3>
<p>If you are extracting data from a multiple-record-type file with a master-detail structure and mapping to tables, add a Sequence operator to the mapping to retain the relationship between the master and detail records through a surrogate primary key or foreign key relationship. A master-detail file structure is one where a master record is followed by its detail records. <a id="sthref1333"></a><a id="sthref1334"></a><a id="sthref1335"></a><a id="sthref1336"></a>In <a href="#i1143829">Example 10-1</a>, records beginning with "E" are master records with Employee information and records beginning with "P" are detail records with Payroll information for the corresponding employee.</p>
<div class="example">
<p class="titleinexample"><a id="i1143829"></a>Example 10-1 A Multiple-Record-Type Flat File with a Master-Detail Structure</p>
<pre>
E 003715 4 153 09061987 014000000 "IRENE HIRSH" 1 08500
P 01152000 01162000 00101 000500000 000700000
P 02152000 02162000 00102 000300000 000800000
E 003941 2 165 03111959 016700000 "ANNE FAHEY" 1 09900 
P 03152000 03162000 00107 000300000 001000000
E 001939 2 265 09281988 021300000 "EMILY WELLMET" 1 07700
P 01152000 01162000 00108 000300000 001000000
P 02152000 02162000 00109 000300000 001000000
</pre></div>
<!-- class="example" -->
<p><a id="sthref1337"></a><a id="sthref1338"></a>In <a href="#i1143829">Example 10-1</a>, the relationship between the master and detail records is inherent only in the physical record order: payroll records correspond to the employee record they follow. However, if this is the only means of relating detail records to their masters, this relationship is lost when Oracle Warehouse Builder loads each record into its target table.</p>
<a id="BBADGCDJ"></a>
<div class="sect3">
<h4 class="sect3">Maintaining Relationships Between Master and Detail Records</h4>
<p>You can maintain the relationship between master and detail records if both types of records share a common field. If <a href="#i1143829">Example 10-1</a> contains a field Employee ID in both Employee and Payroll records, then you can use it as the primary key for the Employee table and as the foreign key in the Payroll table, thus associating Payroll records to the correct Employee record.</p>
<p>However, if your file does not have a common field that is required to join master and detail records, you must add a sequence column to both the master and detail targets (see <a href="#g1251688">Table 10-5</a> and <a href="#g1251955">Table 10-6</a>) to maintain the relationship between the master and detail records. Use the Sequence operator to generate this additional value.</p>
<p><a href="#g1251688">Table 10-5</a> represents the target table containing the master records from the file in <a href="#i1143829">Example 10-1</a>. The target table for the master records in this case contains employee information. Columns E1-E10 contain data extracted from the flat file. Column E11 is the additional column added to store the master sequence number. Notice that the number increments by one for each employee.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref1339"></a><a id="g1251688"></a>Table 10-5 Target Table Containing Master Records</p>
<table class="cellalignment2975" title="Target Table Containing Master Records " summary="Target table containing master records." dir="ltr">
<thead>
<tr class="cellalignment2969">
<th class="cellalignment2976" id="r1c1-t7">E1</th>
<th class="cellalignment2976" id="r1c2-t7">E2</th>
<th class="cellalignment2976" id="r1c3-t7">E3</th>
<th class="cellalignment2976" id="r1c4-t7">E4</th>
<th class="cellalignment2976" id="r1c5-t7">E5</th>
<th class="cellalignment2976" id="r1c6-t7">E6</th>
<th class="cellalignment2976" id="r1c7-t7">E7</th>
<th class="cellalignment2976" id="r1c8-t7">E8</th>
<th class="cellalignment2976" id="r1c9-t7">E9</th>
<th class="cellalignment2976" id="r1c10-t7">E10</th>
<th class="cellalignment2976" id="r1c11-t7">E11</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r2c1-t7" headers="r1c1-t7">
<p><code>E</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c2-t7">
<p><code>003715</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c3-t7">
<p><code>4</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c4-t7">
<p><code>153</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c5-t7">
<p><code>09061987</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c6-t7">
<p><code>014000000</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c7-t7">
<p><code>"IRENE</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c8-t7">
<p><code>HIRSH"</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c9-t7">
<p><code>1</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c10-t7">
<p><code>08500</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t7 r1c11-t7">
<p><code>1</code></p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r3c1-t7" headers="r1c1-t7">
<p><code>E</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c2-t7">
<p><code>003941</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c3-t7">
<p><code>2</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c4-t7">
<p><code>165</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c5-t7">
<p><code>03111959</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c6-t7">
<p><code>016700000</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c7-t7">
<p><code>"ANNE</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c8-t7">
<p><code>FAHEY"</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c9-t7">
<p><code>1</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c10-t7">
<p><code>09900</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t7 r1c11-t7">
<p><code>2</code></p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r4c1-t7" headers="r1c1-t7">
<p><code>E</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c2-t7">
<p><code>001939</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c3-t7">
<p><code>2</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c4-t7">
<p><code>265</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c5-t7">
<p><code>09281988</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c6-t7">
<p><code>021300000</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c7-t7">
<p><code>"EMILY</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c8-t7">
<p><code>WELSH"</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c9-t7">
<p><code>1</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c10-t7">
<p><code>07700</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t7 r1c11-t7">
<p><code>3</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#g1251955">Table 10-6</a> represents the target table containing the detail records from the file in <a href="#i1143829">Example 10-1</a>. The target table for the detail records in this case contains payroll information, with one or more payroll records for each employee. Columns P1-P6 contain data extracted from the flat file. Column P7 is the additional column added to store the detail sequence number. Notice that the number for each payroll record matches the corresponding employee record in <a href="#g1251688">Table 10-5</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="sthref1340"></a><a id="g1251955"></a>Table 10-6 Target Table Containing Detail Records</p>
<table class="cellalignment2975" title="Target Table Containing Detail Records " summary="Target table containing detail records." dir="ltr">
<thead>
<tr class="cellalignment2969">
<th class="cellalignment2976" id="r1c1-t8">P1</th>
<th class="cellalignment2976" id="r1c2-t8">P2</th>
<th class="cellalignment2976" id="r1c3-t8">P3</th>
<th class="cellalignment2976" id="r1c4-t8">P4</th>
<th class="cellalignment2976" id="r1c5-t8">P5</th>
<th class="cellalignment2976" id="r1c6-t8">P6</th>
<th class="cellalignment2976" id="r1c7-t8">P7</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r2c1-t8" headers="r1c1-t8">
<p><code>P</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t8 r1c2-t8">
<p><code>01152000</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t8 r1c3-t8">
<p><code>01162000</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t8 r1c4-t8">
<p><code>00101</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t8 r1c5-t8">
<p><code>000500000</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t8 r1c6-t8">
<p><code>000700000</code></p>
</td>
<td class="cellalignment2977" headers="r2c1-t8 r1c7-t8">
<p><code>1</code></p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r3c1-t8" headers="r1c1-t8">
<p><code>P</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t8 r1c2-t8">
<p><code>02152000</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t8 r1c3-t8">
<p><code>02162000</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t8 r1c4-t8">
<p><code>00102</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t8 r1c5-t8">
<p><code>000300000</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t8 r1c6-t8">
<p><code>000800000</code></p>
</td>
<td class="cellalignment2977" headers="r3c1-t8 r1c7-t8">
<p><code>1</code></p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r4c1-t8" headers="r1c1-t8">
<p><code>P</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t8 r1c2-t8">
<p><code>03152000</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t8 r1c3-t8">
<p><code>03162000</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t8 r1c4-t8">
<p><code>00107</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t8 r1c5-t8">
<p><code>000300000</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t8 r1c6-t8">
<p><code>001000000</code></p>
</td>
<td class="cellalignment2977" headers="r4c1-t8 r1c7-t8">
<p><code>2</code></p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r5c1-t8" headers="r1c1-t8">
<p>P</p>
</td>
<td class="cellalignment2977" headers="r5c1-t8 r1c2-t8">
<p><code>01152000</code></p>
</td>
<td class="cellalignment2977" headers="r5c1-t8 r1c3-t8">
<p><code>01162000</code></p>
</td>
<td class="cellalignment2977" headers="r5c1-t8 r1c4-t8">
<p><code>00108</code></p>
</td>
<td class="cellalignment2977" headers="r5c1-t8 r1c5-t8">
<p><code>000300000</code></p>
</td>
<td class="cellalignment2977" headers="r5c1-t8 r1c6-t8">
<p><code>001000000</code></p>
</td>
<td class="cellalignment2977" headers="r5c1-t8 r1c7-t8">
<p>3</p>
</td>
</tr>
<tr class="cellalignment2969">
<td class="cellalignment2977" id="r6c1-t8" headers="r1c1-t8">
<p>P</p>
</td>
<td class="cellalignment2977" headers="r6c1-t8 r1c2-t8">
<p><code>02152000</code></p>
</td>
<td class="cellalignment2977" headers="r6c1-t8 r1c3-t8">
<p><code>02162000</code></p>
</td>
<td class="cellalignment2977" headers="r6c1-t8 r1c4-t8">
<p><code>00109</code></p>
</td>
<td class="cellalignment2977" headers="r6c1-t8 r1c5-t8">
<p><code>000300000</code></p>
</td>
<td class="cellalignment2977" headers="r6c1-t8 r1c6-t8">
<p><code>001000000</code></p>
</td>
<td class="cellalignment2977" headers="r6c1-t8 r1c7-t8">
<p>3</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect3" -->
<a id="i1143847"></a>
<div class="sect3">
<h4 class="sect3">Extracting and Loading Master-Detail Records<a id="sthref1341"></a><a id="sthref1342"></a><a id="sthref1343"></a><a id="sthref1344"></a><a id="sthref1345"></a></h4>
<p>This section contains instructions on creating a mapping that extracts records from a master-detail flat file and loads those records into two different tables. One target table stores master records and the other target table stores detail records from the flat file. The Mapping Sequence is used to maintain the master-detail relationship between the two tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
These instructions are for conventional path loading. For instructions on using direct path loading for master-detail records, see <a href="#i1147024">"Using Direct Path Loading to Ensure Referential Integrity in SQL*Loader Mappings"</a>.</div>
<p>This procedure outlines general steps for building such a mapping. Additional detailed instructions are available at:</p>
<ul>
<li>
<p><a href="src_tgt_opers.htm#CIHCGEDE">"Flat File Operator"</a></p>
</li>
<li>
<p><a href="mappings.htm#CHDEJAAD">"Using the Add Operator Dialog Box to Add Operators"</a></p>
</li>
<li>
<p><a href="src_tgt_opers.htm#i1175826">"Sequence Operator"</a></p>
</li>
<li>
<p><a href="ref_maps_processflows.htm#i1113472">"Configuring Mappings Reference"</a></p>
</li>
<li>
<p><a class="olink WBDOD04370" href="../../owb.112/e10582/importing_metadata.htm#WBDOD04370"><span class="italic">Oracle Warehouse Builder Sources and Targets Guide</span></a></p>
</li>
</ul>
<p><span class="bold">To extract from a master-detail flat file and maintain master-detail relationships, use the following steps<a id="sthref1346"></a><a id="sthref1347"></a><a id="sthref1348"></a><a id="sthref1349"></a>:</span></p>
<ol>
<li>
<p>Import and <a id="sthref1350"></a><a id="sthref1351"></a><a id="sthref1352"></a><a id="sthref1353"></a>sample the flat file source that consists of master and detail records.</p>
<p>When naming the record types as you sample the file, assign descriptive names to the master and detail records. This makes it easier to identify those records in the future.</p>
<p>In this example, for multi-record-type flat files, the Flat File Sample Wizard contains department and employee information. The master record type (for employee records) is called EmployeeMaster, while the detail record type (for payroll information) is called PayrollDetail.</p>
</li>
<li>
<p>Drop a Flat File operator onto the Mapping Editor canvas and specify the master-detail file from which you want to extract data.</p>
</li>
<li>
<p>Drop a Sequence operator onto the mapping canvas.</p>
</li>
<li>
<p>Drop a Table operator for the master records onto the mapping canvas.</p>
<p>You can either select an existing workspace table that you created earlier or create a new unbound Table operator with no attributes. You can then map or copy all required fields from the master record of the Flat File operator to the master Table operator (creating columns) and perform an outbound reconciliation to define the table later.</p>
<p>The table must contain all the columns required for the master fields you want to load plus an additional numeric column for loading sequence values.</p>
</li>
<li>
<p>Drop a Table operator for the detail records onto the mapping canvas.</p>
<p>You can either select an existing workspace table that you created earlier or create a new unbound Table operator with no attributes. You can then map or copy all required fields from the master record of the Flat File operator to the master Table operator (creating columns) and perform an outbound synchronize to define the table later.</p>
<p>The table must contain all the columns required for the detail fields you want to load plus an additional numeric column for loading sequence values.</p>
</li>
<li>
<p>Map all of the necessary flat file master fields to the master table and detail fields to the detail table.</p>
<p><a href="#i1143770">Figure 10-8</a> displays the mapping of the fields.</p>
</li>
<li>
<p>Map the Sequence <code>NEXTVAL</code> attribute to the additional sequence column in the master table.</p>
<p><a href="#i1143770">Figure 10-8</a> displays the mapping from the <code>NEXTVAL</code> attribute of the Sequence operator to the master table.</p>
</li>
<li>
<p>Map the Sequence <code>CURRVAL</code> attribute to the additional sequence column in the detail table.</p>
<p><a href="#i1143770">Figure 10-8</a> shows a completed mapping with the flat file master fields mapped to the master target table, the detail fields mapped to the detail target table, and the <code>NEXTVAL</code> and <code>CURRVAL</code> attributes from the Mapping Sequence mapped to the master and detail target tables, respectively.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1143770"></a>Figure 10-8 Completed Mapping from Master-Detail Flat File to Two Target Tables<a id="sthref1354"></a><a id="sthref1355"></a><a id="sthref1356"></a></p>
<img width="587" height="480" src="img/etl_perf_mapping_editor.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1357" href="img_text/etl_perf_mapping_editor.htm">Description of "Figure 10-8 Completed Mapping from Master-Detail Flat File to Two Target Tables"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>Configure the mapping that loads the source data into the target tables with the following parameters:<a id="sthref1358"></a><a id="sthref1359"></a><a id="sthref1360"></a></p>
<p><span class="bold">Direct Mode:</span> Not selected</p>
<p><span class="bold">Errors Allowed:</span> 0</p>
<p><span class="bold">Row:</span> 1</p>
<p><span class="bold">Trailing Nullcols:</span> True (for all tables)</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1361"></a>
<h4 class="sect3">Error Handling Suggestions</h4>
<p>This section contains error handling recommendations for files with varying numbers of errors.</p>
<p><span class="bold">If your data file almost never contains errors:</span></p>
<ol>
<li>
<p>Create a mapping with a <a href="src_tgt_opers.htm#i1175826">"Sequence Operator"</a>.</p>
</li>
<li>
<p>Configure a mapping with the following parameters:</p>
<p>Direct Mode= Not selected</p>
<p>ROW=1</p>
<p>ERROR ALLOWED = 0</p>
</li>
<li>
<p>Generate the code and run an SQL*Loader script.</p>
<p>If the data file has errors, then the loading stops when the first error occurs.</p>
</li>
<li>
<p>Fix the data file and run the control file again with the following configuration values:</p>
<p>CONTINUE_LOAD=TRUE</p>
<p>SKIP=<code><span class="codeinlineitalic">number of records loaded</span></code></p>
</li>
</ol>
<p><span class="bold">If your data file is likely to contain a moderate number of errors:</span></p>
<ol>
<li>
<p>Create a primary key (PK) for the master record based on the <code>seq_nextval</code> column.</p>
</li>
<li>
<p>Create a foreign key (FK) for the detail record based on the <code>seq_currval</code> column which references the master table PK.</p>
<p>In this case, master records with errors is rejected with all their detail records. You can recover these records by following these steps.</p>
</li>
<li>
<p>Delete all failed detail records that have no master records.</p>
</li>
<li>
<p>Fix the errors in the bad file and reload only those records.</p>
</li>
<li>
<p>If there are very few errors, you may choose to load the remaining records and manually update the table with correct sequence numbers.</p>
</li>
<li>
<p>In the log file, you can identify records that failed with errors because those errors violate the integrity constraint. The following is an example of a log file record with errors:</p>
<pre>
<span class="bold">Record 9:</span> Rejected - Error on table "MASTER_T", column "C3". 
ORA-01722: invalid number 
<span class="bold">Record 10:</span> Rejected - Error on table "DETAIL1_T". 
ORA-02291: integrity constraint (SCOTT.FK_SEQ) violated - parent key not found
<span class="bold">Record 11:</span> Rejected - Error on table "DETAIL1_T". 
ORA-02291: integrity constraint (SCOTT.FK_SEQ) violated - parent key not found 
<span class="bold">Record 21:</span> Rejected - Error on table "DETAIL2_T". 
ORA-02291: invalid number  
</pre></li>
</ol>
<p><span class="bold">If your data file always contains many errors:</span></p>
<ol>
<li>
<p>Load all records without using the Sequence operator.</p>
<p>Load the records into independent tables. You can load the data in Direct Mode, with the following parameters that increase loading speed:</p>
<p>ROW&gt;1</p>
<p>ERRORS ALLOWED=MAX</p>
</li>
<li>
<p>Correct all rejected records.</p>
</li>
<li>
<p>Reload the file again with a <a href="src_tgt_opers.htm#i1175826">"Sequence Operator"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1362"></a>
<h4 class="sect3">Subsequent Operations<a id="sthref1363"></a><a id="sthref1364"></a></h4>
<p>After the initial loading of the master and detail tables, you can use the loaded sequence values to further transform, update, or merge master table data with detail table data. For example, if your master records have a column that acts as a unique identifier, such as an Employee ID, and you want to use it as the key to join master and detail rows (instead of the sequence field you added for that purpose), you can update the detail tables to use this unique column. You can then drop the sequence column you created for the initial load. Operators such as the Aggregator, Filter, or Match Merge operator can help you with these subsequent transformations.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1147024"></a>
<div class="sect2">
<h3 class="sect2">Using Direct Path Loading to Ensure Referential Integrity in SQL*Loader Mappings<a id="sthref1365"></a></h3>
<p>If you are using a master-detail flat file where the master record has a unique field (or if the concatenation of several fields can result in a unique identifier), you can use Direct Path Load as an option for faster loading.</p>
<p>For direct path loading, the record number (<code>RECNUM</code>) of each record is stored in the master and detail tables. A post-load procedure uses the <code>RECNUM</code> to update each detail row with the unique identifier of the corresponding master row.</p>
<p>This procedure outlines general steps for building such a mapping. Additional detailed instructions are available:</p>
<ul>
<li>
<p>For additional information about importing flat file sources, see <a class="olink WBDOD04370" href="../../owb.112/e10582/importing_metadata.htm#WBDOD04370"><span class="italic">Oracle Warehouse Builder Sources and Targets Guide</span></a>.</p>
</li>
<li>
<p>For additional information about using flat files as a source, <a href="src_tgt_opers.htm#CIHCGEDE">"Flat File Operator"</a>.</p>
</li>
<li>
<p>For additional information about using Table operators, see <a href="mappings.htm#CHDEJAAD">"Using the Add Operator Dialog Box to Add Operators"</a>.</p>
</li>
<li>
<p>For additional information about using the Data Generator operator, see <a href="src_tgt_opers.htm#i1175749">"Data Generator Operator"</a>.</p>
</li>
<li>
<p>For additional information about using the Constant operator, see <a href="src_tgt_opers.htm#i1175748">"Constant Operator"</a>.</p>
</li>
<li>
<p>For additional information about configuring mappings, see <a href="ref_maps_processflows.htm#i1113472">"Configuring Mappings Reference"</a>.</p>
</li>
</ul>
<p><span class="bold">To extract from a master-detail flat file using direct path load to maintain master-detail relationships:<a id="sthref1366"></a><a id="sthref1367"></a><a id="sthref1368"></a><a id="sthref1369"></a></span></p>
<ol>
<li>
<p>Import and sample a flat file source that consists of master and detail records.</p>
<p>When naming the record types as you sample the file, assign descriptive names to the master and detail records. This helps in identifying those records in the future.</p>
</li>
<li>
<p>Create a mapping that you use to load data from the flat file source.</p>
</li>
<li>
<p>Drop a Flat File operator onto the mapping canvas and specify the master-detail file from which you want to extract data.</p>
</li>
<li>
<p>Drop a Data Generator and a Constant operator onto the mapping canvas.</p>
</li>
<li>
<p>Drop a Table operator for the master records onto the mapping canvas.</p>
<p>You can either select an existing workspace table that you created earlier, or create a new unbound Table operator with no attributes and perform an outbound synchronize to define the table later.</p>
<p>The table must contain all the columns required for the master fields you plan to load plus an additional numeric column for loading the <code>RECNUM</code> value.</p>
</li>
<li>
<p>Drop a Table operator for the detail records onto the mapping canvas.</p>
<p>You can either select an existing workspace table that you created earlier, or create a new unbound Table operator with no attributes and perform an outbound synchronize to define the table later.</p>
<p>The table must contain all the columns required for the detail fields you plan to load plus an additional numeric column for loading a <code>RECNUM</code> value, and a column that is updated with the unique identifier of the corresponding master table row.</p>
</li>
<li>
<p>Map all of the necessary flat file master fields to the master table and detail fields to the detail table.</p>
<p><a href="#i1144067">Figure 10-9</a> displays this mapping of master and detail fields.</p>
</li>
<li>
<p><a id="sthref1370"></a><a id="sthref1371"></a><a id="sthref1372"></a>Map the Data Generator operator's <code>RECNUM</code> attribute to the <code>RECNUM</code> columns in the master and detail tables.</p>
<p><a href="#i1144067">Figure 10-9</a> displays the mapping in which the <code>RECNUM</code> attribute of the Data Generator operator is mapped to the <code>RECORDNUMBER</code> table attribute.</p>
</li>
<li>
<p>Add a constant attribute in the Constant operator.</p>
<p>If the master row unique identifier column is of <code>CHAR</code> data type, in the Property Inspector of the constant attribute, set the Data type property to <code>CHAR</code> and the Expression property to asterisk (<code>*)</code>.</p>
<p>If the master row unique identifier column is a number, in the Property Inspector of the constant attribute, set the Data type property to <code>NUMBER</code> and the Expression property to zero. This marks all data rows as "just loaded".</p>
</li>
<li>
<p>Map the constant attribute from the Constant operator to the detail table column that later stores the unique identifier for the corresponding master table record.</p>
<p><a href="#i1144067">Figure 10-9</a> shows a completed mapping with the flat file's master fields mapped to the master target table, the detail fields mapped to the detail target table, the <code>RECNUM</code> attributes from the Data Generator operator mapped to the master and detail target tables, respectively, and the constant attribute mapped to the detail target table.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1144067"></a>Figure 10-9 Completed Mapping from Master-Detail Flat File with a Direct Path Load<a id="sthref1373"></a><a id="sthref1374"></a><a id="sthref1375"></a></p>
<img width="555" height="546" src="img/etl_perf_directpathload.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1376" href="img_text/etl_perf_directpathload.htm">Description of "Figure 10-9 Completed Mapping from Master-Detail Flat File with a Direct Path Load"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>Configure the mapping with the following parameters<a id="sthref1377"></a><a id="sthref1378"></a><a id="sthref1379"></a>:</p>
<p><span class="bold">Direct Mode:</span> True</p>
<p><span class="bold">Errors Allowed:</span> 0</p>
<p><span class="bold">Trailing Nullcols:</span> True (for each table)</p>
</li>
<li>
<p>After you validate the mapping and generate the SQL*Loader script, create a post-update PL/SQL procedure and add it to Oracle Warehouse Builder library.</p>
</li>
<li>
<p>Run the SQL*Loader script.</p>
</li>
<li>
<p>Run an UPDATE SQL statement by running a PL/SQL post-update procedure or manually executing a script.</p>
</li>
</ol>
<p><a id="sthref1380"></a><a id="sthref1381"></a>The following is an example of the generated SQL*Loader control file script:</p>
<pre>
OPTIONS ( DIRECT=TRUE,PARALLEL=FALSE, ERRORS=0, BINDSIZE=50000, ROWS=200, READSIZE=65536)
LOAD DATA
CHARACTERSET WE8MSWIN1252
  INFILE 'g:\FFAS\DMR2.dat'
  READBUFFERS 4
  INTO TABLE "MATER_TABLE"
  APPEND
  REENABLE DISABLED_CONSTRAINTS
       WHEN 
        "REC_TYPE"='P'
  FIELDS
    TERMINATED BY ','
                OPTIONALLY ENCLOSED BY '"'
                TRAILING NULLCOLS
    
                (
                "REC_TYPE" POSITION (1) CHAR ,
                "EMP_ID" CHAR ,
                "ENAME" CHAR ,
                "REC_NUM" RECNUM
                )
  
INTO TABLE "DETAIL_TABLE"
                APPEND
                REENABLE DISABLED_CONSTRAINTS
                WHEN 
                "REC_TYPE"='E'
                FIELDS
                TERMINATED BY ','
                OPTIONALLY ENCLOSED BY '"'
                TRAILING NULLCOLS
        (
                "REC_TYPE" POSITION (1) CHAR ,
                "C1" CHAR ,
                "C2" CHAR ,
                "C3" CHAR ,
                "EMP_ID" CONSTANT '*',
         "REC_NUM" RECNUM
</pre>
<p>The following is an example of the post-update PL/SQL procedure:</p>
<pre>
  create or replace procedure wb_md_post_update( 
     master_table varchar2 
    ,master_recnum_column varchar2 
    ,master_unique_column varchar2 
    ,detail_table varchar2 
    ,detail_recnum_column varchar2 
    ,detail_masterunique_column varchar2 
    ,detail_just_load_condition varchar2) 
  IS 
     v_SqlStmt VARCHAR2(1000); 
  BEGIN 
     v_SqlStmt := 'UPDATE '||detail_table||' l '|| 
                  ' SET l.'||detail_masterunique_column||' = (select i.'||master_unique_column|| 
                  ' from '||master_table||' i '|| 
                  ' WHERE i.'||master_recnum_column||' IN '|| 
                  ' (select max(ii.'||master_recnum_column||') '|| 
                  ' from '||master_table||' ii '|| 
                  ' WHERE ii.'||master_recnum_column||' &lt; l.'||detail_recnum_column||') '|| 
                  ' ) '|| 
                  ' WHERE l.'||detail_masterunique_column||' = '||''''||detail_just_load_condition||''''; 
     dbms_output.put_line(v_sqlStmt); 
     EXECUTE IMMEDIATE  v_SqlStmt; 
  END; 
  /
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1131648"></a><a id="WBETL10003"></a>
<div class="sect1">
<h2 class="sect1">Improved Performance through Partition Exchange Loading<a id="sthref1382"></a></h2>
<p>Data partitioning can improve performance when loading or purging data in a target system. This practice is known as Partition Exchange Loading (PEL).</p>
<p>PEL is recommended when loading a relatively small amount of data into a target containing a much larger volume of historical data. The target can be a table, a dimension, or a cube in a data warehouse.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#i1133946">"About Partition Exchange Loading"</a></p>
</li>
<li>
<p><a href="#i1148133">"Configuring a Mapping for PEL"</a></p>
</li>
<li>
<p><a href="#i1148262">"Direct and Indirect PEL"</a></p>
</li>
<li>
<p><a href="#CHDEFCGH">"Using PEL Effectively"</a></p>
</li>
<li>
<p><a href="#i1133992">"Configuring Targets in a Mapping"</a></p>
</li>
<li>
<p><a href="#i1134004">"Restrictions for Using PEL in Oracle Warehouse Builder"</a></p>
</li>
</ul>
<a id="i1133946"></a>
<div class="sect2">
<h3 class="sect2">About Partition Exchange Loading<a id="sthref1383"></a></h3>
<p>By manipulating partitions in your target system, you can use Partition Exchange Loading (PEL) to instantly add or delete data. When a table is exchanged with an empty partition, new data is added.</p>
<p>You can use PEL to load new data by exchanging it into a target table as a partition. For example, a table that holds the new data assumes the identity of a partition from the target table and this partition assumes the identity of the source table. This exchange process is a DDL operation with no actual data movement.</p>
<p><a href="#i1130686">Figure 10-10</a> illustrates an example of PEL. Data from a source table <code><span class="codeinlineitalic">Source</span></code> is inserted into a target table consisting of four partitions (<code>Target_P1</code>, <code>Target_P2</code>, <code>Target_P3</code>, and <code>Target_P4</code>). If the new data is loaded into <code>Target_P3</code>, then the partition exchange operation only exchanges the names on the data objects without moving the actual data. After the exchange, the formerly labeled <code>Source</code> is renamed to <code>Target_P3</code>, and the former <code>Target_P3</code> is now labeled as <code>Source</code>. The target table still contains four partitions: <code>Target_P1</code>, <code>Target_P2</code>, <code>Target_P3</code>, and <code>Target_P4</code>. The partition exchange operation available in Oracle 9<span class="italic">i</span> completes the loading process without data movement.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1130686"></a>Figure 10-10 Overview of Partition Exchange Loading</p>
<img width="573" height="175" src="img/partition_exchange.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1384" href="img_text/partition_exchange.htm">Description of "Figure 10-10 Overview of Partition Exchange Loading"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect2" -->
<a id="i1148133"></a>
<div class="sect2">
<h3 class="sect2">Configuring a Mapping for PEL<a id="sthref1385"></a><a id="sthref1386"></a></h3>
<p><span class="bold">To configure a mapping for partition exchange loading, complete the following steps:</span></p>
<ol>
<li>
<p>In the Projects Navigator, right-click a mapping and select <span class="bold">Configure.</span></p>
<p>Oracle Warehouse Builder displays the Configuration tab for the mapping.</p>
</li>
<li>
<p>By default, PEL is disabled for all mappings. Select <span class="bold">PEL Enabled</span> to use Partition Exchange Loading.</p>
</li>
<li>
<p>Use <span class="bold">Data Collection Frequency</span> to specify the amount of new data to be collected for each run of the mapping. Set this parameter to specify if you want the data collected by Year, Quarter, Month, Day, Hour, or Minute. This determines the number of partitions.</p>
</li>
<li>
<p>Select <span class="bold">Direct</span> to create a temporary table to stage the collected data before performing the partition exchange. If you do not select this parameter, then Oracle Warehouse Builder directly swaps the source table into the target table as a partition without creating a temporary table. For more information, see <a href="#i1148262">"Direct and Indirect PEL"</a>.</p>
</li>
<li>
<p>If you select <span class="bold">Replace Data</span>, Oracle Warehouse Builder replaces the existing data in the target partition with the newly collected data. If you do not select it, then Oracle Warehouse Builder preserves the existing data in the target partition. The new data is inserted into a non-empty partition. This parameter affects the local partition and is required to remove or swap a partition out of a target table. At the table level, you can set Truncate/Insert properties.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1148262"></a>
<div class="sect2">
<h3 class="sect2">Direct and Indirect PEL</h3>
<p>When you use Oracle Warehouse Builder to load a target by exchanging partitions, you can load the target indirectly or directly.</p>
<ul>
<li>
<p><span class="bold">Indirect PEL:</span> By default, Oracle Warehouse Builder creates and maintains a temporary table that stages the source data before initiating the partition exchange process. For example, use Indirect PEL when the mapping includes a remote source or a join of multiple sources.</p>
</li>
<li>
<p><span class="bold">Direct PEL:</span> You design the source for the mapping to match the target structure. For example, use Direct PEL in a mapping to instantaneously publish fact tables that you loaded in a mapping that is run before.</p>
</li>
</ul>
<div class="sect3"><a id="sthref1387"></a>
<h4 class="sect3">Using Indirect PEL</h4>
<p>If you design a mapping using PEL and it includes remote sources or a join of multiple sources, Oracle Warehouse Builder must perform source processing and stage the data before partition exchange can proceed. Therefore, configure such mappings with Direct PEL set to False. Oracle Warehouse Builder transparently creates and maintains a temporary table that stores the results from source processing. After performing the PEL, Oracle Warehouse Builder drops the table.</p>
<p><a href="#i1148633">Figure 10-11</a> shows a mapping that joins two sources and performs an aggregation. If all new data loaded into the <code>ORDER_SUMMARY</code> table is always loaded into same partition, then you can use Indirect PEL on this mapping to improve load performance. In this case, Oracle Warehouse Builder transparently creates a temporary table after the Aggregator and before <code>ORDER_SUMMARY</code>.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1148633"></a>Figure 10-11 Mapping with Multiple Sources</p>
<img width="322" height="167" src="img/etl_perf_get_sales_summary.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1388" href="img_text/etl_perf_get_sales_summary.htm">Description of "Figure 10-11 Mapping with Multiple Sources"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Oracle Warehouse Builder creates the temporary table using the same structure as the target table with the same columns, indexes, and constraints. For the fastest performance, Oracle Warehouse Builder loads the temporary table using parallel direct-path loading INSERT. After the INSERT, Oracle Warehouse Builder indexes and constrains the temporary table in parallel.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref1389"></a>
<h4 class="sect3">Example: Using Direct PEL to Publish Fact Tables</h4>
<p>Use Direct PEL when the source table is local and the data is of good quality. You must design the mapping such that the source and target are in the same database and have the same structure. The source and target must have the same indexes and constraints, the same number of columns, and the same column types and lengths.</p>
<p>For example, assume that you have the same mapping from <a href="#i1148633">Figure 10-11</a> but would like greater control on when data is loaded into the target. Depending on the amount of data, it could take hours to load and you would not know precisely when the target table would be updated.</p>
<p><span class="bold">To instantly load data to a target using Direct PEL:</span></p>
<ol>
<li>
<p>Design one mapping to join source data, if necessary, transform data, ensure data validity, and load it to a staging table. Do not configure this mapping to use PEL.</p>
<p>Design the staging table to exactly match the structure of the final target that you load in a separate mapping.</p>
<p>For example, the staging table in <a href="#i1148633">Figure 10-11</a> is <code>ORDER_SUMMARY</code> and should be of the same structure as the final target, <code>ORDER_CUBE</code> in <a href="#i1148770">Figure 10-12</a>.</p>
</li>
<li>
<p>Create a second mapping that loads data from the staging table to the final target. Configure this mapping to use Direct PEL.</p>
<p><a href="#i1148770">Figure 10-12</a> displays the mapping that loads data from the staging table to the final target.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1148770"></a>Figure 10-12 Publish_Sales_Summary Mapping</p>
<img width="325" height="131" src="img/etl_perf_direct_pel.gif" alt="This illustration is described in the surrounding text." /><br />
<a id="sthref1390" href="img_text/etl_perf_direct_pel.htm">Description of "Figure 10-12 Publish_Sales_Summary Mapping"</a><br />
<br /></div>
<!-- class="figure" --></li>
<li>
<p>Use either Oracle Warehouse Builder Process Flow Editor or Oracle Workflow to start the second mapping after the completion of the first.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEFCGH"></a>
<div class="sect2">
<h3 class="sect2">Using PEL Effectively<a id="sthref1391"></a></h3>
<p>You can use PEL effectively for scalable loading performance if the following conditions are true:</p>
<ul>
<li>
<p><span class="bold">Table partitioning and tablespace:</span> The target table must be Range partitioned by one <code>DATE</code> column. All partitions must be created in the same tablespace. All tables are created in the same tablespace.</p>
</li>
<li>
<p><span class="bold">Existing historical data:</span> The target table must contain a huge amount of historical data. An example use for PEL is for a click stream application where the target collects data every day from an OLTP database or Web log files. New data is transformed and loaded into the target that contains historical data.</p>
</li>
<li>
<p><span class="bold">New data:</span> All new data must to be loaded into the same partition in a target table. For example, if the target table is partitioned by day, then the daily data should be loaded into one partition.</p>
</li>
<li>
<p><span class="bold">Loading Frequency:</span> The loading frequency should be equal to or less than the data collection frequency.</p>
</li>
<li>
<p><span class="bold">No global indexes:</span> There must be no global indexes on the target table.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1133992"></a>
<div class="sect2">
<h3 class="sect2">Configuring Targets in a Mapping<a id="sthref1392"></a><a id="sthref1393"></a></h3>
<p>To configure targets in a mapping for PEL:</p>
<ul>
<li>
<p><a href="#i1133799">"Step 1: Create All Partitions"</a></p>
</li>
<li>
<p><a href="#i1131552">"Step 2: Create All Indexes Using the LOCAL Option"</a></p>
</li>
<li>
<p><a href="#i1133821">"Step 3: Primary/Unique Keys Use "USING INDEX" Option"</a></p>
</li>
</ul>
<a id="i1133799"></a>
<div class="sect3">
<h4 class="sect3">Step 1: Create All Partitions</h4>
<p>Oracle Warehouse Builder does not automatically create partitions during run time. Before you can use PEL, you must create all partitions as described in <a href="orcl_data_objx.htm#BEHGEGGI">"Defining Partitions"</a>.</p>
<p>For example, if you select Month as the frequency of new data collection, you must create all the required partitions for each month of new data. Use the object editors to create partitions for a table, dimension, or cube.</p>
<p>To use PEL, all partition names must follow a naming convention. For example, for a partition that holds data for May 2002, the partition name must be in the format Y2002_Q2_M05.</p>
<p>For PEL to recognize a partition, its name must fit one of the following formats:</p>
<p><code><span class="codeinlinebold">Y</span></code><code>dddd</code></p>
<p><code><span class="codeinlinebold">Y</span></code><code>dddd_</code><code><span class="codeinlinebold">Q</span></code><code>d</code></p>
<p><code><span class="codeinlinebold">Y</span></code><code>dddd_</code><code><span class="codeinlinebold">Q</span></code><code>d_</code><code><span class="codeinlinebold">M</span></code><code>dd</code></p>
<p><code><span class="codeinlinebold">Y</span></code><code>dddd_</code><code><span class="codeinlinebold">Q</span></code><code>d_</code><code><span class="codeinlinebold">M</span></code><code>dd_</code><code><span class="codeinlinebold">D</span></code><code>dd</code></p>
<p><code><span class="codeinlinebold">Y</span></code><code>dddd_</code><code><span class="codeinlinebold">Q</span></code><code>d_</code><code><span class="codeinlinebold">M</span></code><code>dd_</code><code><span class="codeinlinebold">D</span></code><code>dd_</code><code><span class="codeinlinebold">H</span></code><code>dd</code></p>
<p><code><span class="codeinlinebold">Y</span></code><code>dddd_</code><code><span class="codeinlinebold">Q</span></code><code>d_</code><code><span class="codeinlinebold">M</span></code><code>dd_</code><code><span class="codeinlinebold">D</span></code><code>dd_</code><code><span class="codeinlinebold">H</span></code><code>dd_</code><code><span class="codeinlinebold">M</span></code><code>dd</code></p>
<p>Where <code>d</code> represents a decimal digit. All the letters must be in upper case. Lower case is not recognized.</p>
<p>If you correctly name each partition, Oracle Warehouse Builder automatically computes the Value Less Than property for each partition. Otherwise, you must manually configure Value Less Than for each partition for Oracle Warehouse Builder to generate a DDL statement. The following is an example of a DDL statement generated by Oracle Warehouse Builder:</p>
<pre>
. . .
PARTITION A_PARTITION_NAME 
      VALUES LESS THAN (TO_DATE('01-06-2002','DD-MM-YYYY')),
. . .
</pre></div>
<!-- class="sect3" -->
<a id="i1131552"></a>
<div class="sect3">
<h4 class="sect3">Step 2: Create All Indexes Using the LOCAL Option</h4>
<p>Add an index (<code>ORDER_SUMMARY_PK_IDX</code>) to the <code>ORDER_SUMMARY</code> table. This index has two columns, <code>ORDER_DATE</code> and <code>ITEM_ID</code>. Set the following on the Indexes tab of the Table Editor:</p>
<ul>
<li>
<p>Select UNIQUE in the Type column.</p>
</li>
<li>
<p>Select LOCAL in the Scope column.</p>
</li>
</ul>
<p>Now Oracle Warehouse Builder can generate a DDL statement for a unique local index on table <code>ORDER_SUMMARY</code>.</p>
<p>Using local indexes provides the most important PEL performance benefit. Local indexes require all indexes to be partitioned in the same way as the table. When the temporary table is swapped into the target table using PEL, so are the identities of the index segments.</p>
<p>If an index is created as a local index, the Oracle server requires that the partition key column must be the leading column of the index. In the preceding example, the partition key is <code>ORDER_DATE</code> and it is the leading column in the index <code>ORDER_SUMMARY_PK_IDX</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i1133821"></a>
<div class="sect3">
<h4 class="sect3">Step 3: Primary/Unique Keys Use "USING INDEX" Option</h4>
<p>In this step you must specify that all primary key and unique key constraints are created with the <code>USING INDEX</code> option. In the Projects Navigator, right-click the table and select <span class="bold">Configure</span>. The Configuration tab for the table is displayed. Select the primary or unique key in the left panel and select <span class="bold">Using Index</span> in the right panel.</p>
<p>With the <code>USING INDEX</code> option, a constraint does not triggers automatic index creation when it is added to the table. The server searches existing indexes for an index with same column list as that of the constraint. Thus, each primary or unique key constraint must be backed by a user-defined unique local index. The index required by the constraint <code>ORDER_SUMMARY_PK</code> is <code>ORDER_SUMMARY_PK_IDX</code> which was created in <a href="#i1131552">"Step 2: Create All Indexes Using the LOCAL Option"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1134004"></a>
<div class="sect2">
<h3 class="sect2">Restrictions for Using PEL in Oracle Warehouse Builder<a id="sthref1394"></a></h3>
<p>These are the restrictions for using PEL in Oracle Warehouse Builder:</p>
<ul>
<li>
<p><span class="bold">Only One Date Partition Key:</span> Only one partition key column of <code>DATE</code> data type is enabled. Numeric partition keys are not supported in Oracle Warehouse Builder.</p>
</li>
<li>
<p><span class="bold">Only Natural Calendar System:</span> The current PEL method supports only the natural calendar system adopted worldwide. Specific business calendar systems with user-defined fiscal and quarter endings are currently not supported.</p>
</li>
<li>
<p><span class="bold">All Data Partitions Must Be In the Same Tablespace:</span> All partitions of a target (table, dimension, or cube) must be created in the same tablespace.</p>
</li>
<li>
<p><span class="bold">All Index Partitions Must Be In the Same Tablespace:</span> All indexes of a target (table, dimension, or cube) must be created in the same tablespace. However, the index tablespace can be different from the data tablespace.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDHECFF"></a><a id="WBETL10004"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">High Performance Data Extraction from Remote Sources</h2>
<p>Although you can design mappings to access remote sources through database links, performance is likely to be slow when you move large volumes of data. For mappings that move large volumes of data between sources and targets of the same Oracle Database version, you have an option for dramatically improving performance with transportable modules.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="trans_mod.htm#CEGBJCGC">"Moving Large Volumes of Data Using Transportable Modules"</a> for instructions on using transportable modules.</div>
<p>You can also efficiently extract data from remote Oracle or other heterogeneous database sources using Code Template (CT) mappings. Oracle Warehouse Builder provides a set of predefined Code Templates that you can use in CT mappings for different data movement options.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="sap_km_mappings.htm#BABIFJIA">"Creating Code Template (CT) Mappings"</a> for information about defining and using CT mappings.</p>
</li>
<li>
<p><a href="sap_km_mappings.htm#BEIBHJBB">"About Prebuilt Code Templates Shipped with Oracle Warehouse Builder"</a> for a description of the Code Templates shipped with Oracle Warehouse Builder.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment2968">
<tr>
<td class="cellalignment2977">
<table class="cellalignment2973">
<tr>
<td class="cellalignment2972"><a href="custom_transforms.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment2972"><a href="scheduling_etl.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2000, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment2980">
<table class="cellalignment2971">
<tr>
<td class="cellalignment2972"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment2972"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment2972"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment2972"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment2972"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment2972"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
