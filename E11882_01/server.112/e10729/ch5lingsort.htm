<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Linguistic Sorting and String Searching</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-05T0:14:27Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Globalization Support Guide" />
<meta name="dcterms.identifier" content="E10729-08" />
<meta name="dcterms.isVersionOf" content="NLSPG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="ch4datetime.htm" title="Previous" type="text/html" />
<link rel="Next" href="ch6unicode.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10729.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/21</span> <!-- End Header --><a id="g1018324"></a><a id="NLSPG005"></a><a id="i1005902"></a>
<h1 class="chapter"><span class="secnum">5</span> Linguistic Sorting and String Searching</h1>
<p><a id="NLSPG041"></a>This chapter explains linguistic sorting and searching for strings in an Oracle Database environment.</p>
<p>This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1008198">Overview of Oracle Database Sorting Capabilities</a></p>
</li>
<li>
<p><a href="#i1008187">Using Binary Sorts</a></p>
</li>
<li>
<p><a href="#i1005958">Using Linguistic Sorts</a></p>
</li>
<li>
<p><a href="#i1006211">Linguistic Sort Features</a></p>
</li>
<li>
<p><a href="#i1009059">Case-Insensitive and Accent-Insensitive Linguistic Sorts</a></p>
</li>
<li>
<p><a href="#CIHJBFAD">Performing Linguistic Comparisons</a></p>
</li>
<li>
<p><a href="#i1006421">Using Linguistic Indexes</a></p>
</li>
<li>
<p><a href="#i1008708">Searching Linguistic Strings</a></p>
</li>
<li>
<p><a href="#i1008619">SQL Regular Expressions in a Multilingual Environment</a></p>
</li>
</ul>
<a id="i1008198"></a><a id="NLSPG267"></a>
<div class="sect1">
<h2 class="sect1">Overview of Oracle Database Sorting Capabilities</h2>
<p>Different languages have different sort orders. In addition, different cultures or countries that use the same alphabets may sort words differently. For example, in Danish, &AElig; is after <code>Z</code>, while <code>Y</code> and <code>&Uuml;</code> are considered to be variants of the same letter.</p>
<p>Sort order can be <a id="sthref414"></a>case-sensitive or case-insensitive. <span class="bold">Case</span> refers to the condition of being uppercase or lowercase. For example, in a Latin alphabet, <code>A</code> is the uppercase glyph for <code>a</code>, the lowercase glyph.</p>
<p>Sort order can ignore or consider diacritics. A <span class="bold"><a id="sthref415"></a>diacritic</span> is a mark near or through a character or combination of characters that indicates a different sound than the sound of the character without the diacritic. For example, the cedilla (<code>,</code>) in <code>fa&ccedil;ade</code> is a diacritic. It changes the sound of <code>c</code>.</p>
<p>Sort order can be phonetic or it can be based on the appearance of the character. For example, sort order can be based on the number of strokes in East Asian ideographs. Another common sorting issue is combining letters into a single character. For example, in traditional Spanish, <code>ch</code> is a distinct character that comes after <code>c</code>, which means that the correct order is: cerveza, colorado, cheremoya. This means that the letter <code>c</code> cannot be sorted until Oracle Database has checked whether the next letter is an <code>h</code>.</p>
<p>Oracle Database provides the following types of sorts:</p>
<ul>
<li>
<p>Binary sort</p>
</li>
<li>
<p>Monolingual linguistic sort</p>
</li>
<li>
<p>Multilingual linguistic sort</p>
</li>
</ul>
<p>These sorts achieve a linguistically correct order for a single language as well as a sort based on the multilingual ISO standard (ISO 14651), which is designed to handle many languages at the same time.</p>
</div>
<!-- class="sect1" -->
<a id="i1008187"></a><a id="NLSPG268"></a>
<div class="sect1">
<h2 class="sect1">Using Binary Sorts</h2>
<p>One way to sort character data <a id="sthref416"></a>is based on the numeric values of the characters defined by the character encoding scheme. This is called a <span class="bold">binary</span> <span class="bold">sort</span>. Binary sorts are the fastest type of sort. They produce reasonable results for the English alphabet because the ASCII and EBCDIC standards define the letters A to Z in ascending numeric value.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
In the ASCII standard, all uppercase letters appear before any lowercase letters. In the EBCDIC standard, the opposite is true: all lowercase letters appear before any uppercase letters.</div>
<p>When characters used in other languages are present, a binary sort usually does not produce reasonable results. For example, an ascending <code>ORDER</code> <code>BY</code> query returns the character strings <code>ABC</code>, <code>ABZ</code>, <code>BCD</code>, <code>&Auml;BC</code>, when <code>&Auml;</code> has a higher numeric value than <code>B</code> in the character encoding scheme. A binary sort is not usually linguistically meaningful for Asian languages that use ideographic characters.</p>
</div>
<!-- class="sect1" -->
<a id="i1005958"></a><a id="NLSPG269"></a>
<div class="sect1">
<h2 class="sect1">Using Linguistic Sorts</h2>
<p><a id="i1005960"></a>To produce a sort sequence that matches the alphabetic sequence of characters, another sort technique must be used that sorts characters independently of their numeric values in the character encoding scheme. This technique is called a <span class="bold">linguistic</span> <span class="bold">sort</span>. A linguistic sort operates by replacing characters with numeric values that reflect each character's proper linguistic order.</p>
<p>Oracle Database offers two kinds of linguistic sorts: monolingual and multilingual.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#i1005980">Monolingual Linguistic Sorts</a></p>
</li>
<li>
<p><a href="#i1006047">Multilingual Linguistic Sorts</a></p>
</li>
<li>
<p><a href="#CIHDEEBG">Multilingual Sorting Levels</a></p>
</li>
<li>
<p><a href="#i1008970">Linguistic Sort Examples</a></p>
</li>
</ul>
<a id="i1005980"></a><a id="NLSPG270"></a>
<div class="sect2">
<h3 class="sect2">Monolingual Linguistic Sorts</h3>
<p>Oracle Database compares character strings in two steps for monolingual sorts. The first step compares the major value of the entire string from a table of major values. Usually, letters with the same appearance have the same major value. The second step compares the minor value from a table of minor values. The major and minor values are defined by Oracle Database. Oracle Database defines letters with diacritic and case differences as having the same major value but different minor values.</p>
<p>Each major table entry contains the <span class="bold">Unicode code point</span> and major value for a character. The Unicode code point is a 16-bit binary value that represents a character.</p>
<p><a href="#g1010269">Table 5-1</a> illustrates sample values for sorting <code>a</code>, <code>A</code>, <code>&auml;</code>, <code>&Auml;</code>, and <code>b</code>.</p>
<div class="tblformal">
<p class="titleintable"><a id="NLSPG768"></a><a id="sthref417"></a><a id="g1010269"></a>Table 5-1 Sample Glyphs and Their Major and Minor Sort Values</p>
<table class="cellalignment1916" title="Sample Glyphs and Their Major and Minor Sort Values " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t3">Glyph</th>
<th class="cellalignment1915" id="r1c2-t3">Major Value</th>
<th class="cellalignment1915" id="r1c3-t3">Minor Value</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t3" headers="r1c1-t3">
<p>a</p>
</td>
<td class="cellalignment1911" headers="r2c1-t3 r1c2-t3">
<p>15</p>
</td>
<td class="cellalignment1911" headers="r2c1-t3 r1c3-t3">
<p>5</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t3" headers="r1c1-t3">
<p>A</p>
</td>
<td class="cellalignment1911" headers="r3c1-t3 r1c2-t3">
<p>15</p>
</td>
<td class="cellalignment1911" headers="r3c1-t3 r1c3-t3">
<p>10</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t3" headers="r1c1-t3">
<p>&auml;</p>
</td>
<td class="cellalignment1911" headers="r4c1-t3 r1c2-t3">
<p>15</p>
</td>
<td class="cellalignment1911" headers="r4c1-t3 r1c3-t3">
<p>15</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t3" headers="r1c1-t3">
<p>&Auml;</p>
</td>
<td class="cellalignment1911" headers="r5c1-t3 r1c2-t3">
<p>15</p>
</td>
<td class="cellalignment1911" headers="r5c1-t3 r1c3-t3">
<p>20</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r6c1-t3" headers="r1c1-t3">
<p>b</p>
</td>
<td class="cellalignment1911" headers="r6c1-t3 r1c2-t3">
<p>20</p>
</td>
<td class="cellalignment1911" headers="r6c1-t3 r1c3-t3">
<p>5</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
Monolingual linguistic sorting is not available for non-Unicode multibyte database character sets. If a monolingual linguistic sort is specified when the database character set is non-Unicode multibyte, then the default sort order is the binary sort order of the database character set. One exception is <code>UNICODE_BINARY</code>. This sort is available for all character sets.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch6unicode.htm#CACHJHDJ">"Overview of Unicode"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006047"></a><a id="NLSPG271"></a>
<div class="sect2">
<h3 class="sect2">Multilingual Linguistic Sorts</h3>
<p><a id="i1006049"></a>Oracle Database provides multilingual linguistic sorts so that you can sort data in more than one language in one sort. This is useful for regions or languages that have complex sorting rules and for multilingual databases. As of Oracle Database 11<span class="italic">g</span>, Oracle Database supports all of the sort orders defined by previous releases.</p>
<p>For Asian language data or multilingual data, Oracle Database provides a sorting mechanism based on the ISO 14651 standard and the Unicode 5.0 standard. Chinese characters are ordered by the number of strokes, PinYin, or radicals.</p>
<p>In addition, multilingual sorts can handle canonical equivalence and supplementary characters. <span class="bold"><a id="sthref418"></a>Canonical equivalence</span> is a basic equivalence between characters or sequences of characters. For example, <code>&ccedil;</code> is equivalent to the combination of <code>c</code> and <code>,</code>. <span class="bold"><a id="sthref419"></a>Supplementary characters</span> are user-defined characters or predefined characters in Unicode that require two code points within a specific code range. You can define up to 1.1 million code points in one multilingual sort.</p>
<p>For example, Oracle Database supports a monolingual French sort (<code>FRENCH</code>), but you can specify a multilingual French sort (<code>FRENCH_M</code>). <code>_M</code> represents the ISO 14651 standard for multilingual sorting. The sorting order is based on the <code>GENERIC_M</code> sorting order and can sort diacritical marks from right to left. Oracle recommends using a multilingual linguistic sort if the tables contain multilingual data. If the tables contain only French, then a monolingual French sort may have better performance because it uses less memory. It uses less memory because fewer characters are defined in a monolingual French sort than in a multilingual French sort. There is a tradeoff between the scope and the performance of a sort.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1006316">"Canonical Equivalence"</a></p>
</li>
<li>
<p><a href="ch6unicode.htm#i1006752">"Supplementary Characters"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHDEEBG"></a><a id="NLSPG272"></a>
<div class="sect2">
<h3 class="sect2">Multilingual Sorting Levels</h3>
<p>Oracle Database evaluates multilingual sorts at three levels of precision:</p>
<ul>
<li>
<p><a href="#i1006091">Primary Level Sorts</a></p>
</li>
<li>
<p><a href="#CIHFJHGG">Secondary Level Sorts</a></p>
</li>
<li>
<p><a href="#i1006126">Tertiary Level Sorts</a></p>
</li>
</ul>
<a id="i1006091"></a><a id="NLSPG273"></a>
<div class="sect3">
<h4 class="sect3">Primary Level Sorts</h4>
<p>A <a id="sthref420"></a><a id="sthref421"></a>primary level sort distinguishes between <span class="bold"><a id="sthref422"></a>base</span> <span class="bold">letters</span>, such as the difference between characters <code>a</code> and <code>b</code>. It is up to individual locales to define whether <code>a</code> is before <code>b</code>, <code>b</code> is before <code>a</code>, or if they are equal. The binary representation of the characters is completely irrelevant. If a character is an ignorable character, then it is assigned a primary level <span class="bold">order</span> (or weight) of zero, which means it is ignored at the primary level. Characters that are ignorable on other levels are given an order of zero at those levels.</p>
<p>For example, at the primary level, all variations of <code>bat</code> come before all variations of <code>bet</code>. The variations of <code>bat</code> can appear in any order, and the variations of <code>bet</code> can appear in any order:</p>
<pre>
Bat
bat
BAT
BET
Bet
bet
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006286">"Ignorable Characters"</a></div>
</div>
<!-- class="sect3" -->
<a id="CIHFJHGG"></a><a id="NLSPG274"></a>
<div class="sect3">
<h4 class="sect3">Secondary Level Sorts</h4>
<p>A <a id="sthref423"></a>secondary level sort distinguishes between base letters (the primary level sort) before distinguishing between diacritics on a given base letter. For example, the character <code>&Auml;</code> differs from the character <code>A</code> only because it has a diacritic. Thus, <code>&Auml;</code> and <code>A</code> are the same on the primary level because they have the same base letter (<code>A</code>) but differ on the secondary level.</p>
<p>The following list has been sorted on the primary level (<code>resume</code> comes before <code>resumes</code>) and on the secondary level (strings without diacritics come before strings with diacritics):</p>
<pre>
resume
r&eacute;sum&eacute;
R&eacute;sum&eacute;
Resumes
resumes
r&eacute;sum&eacute;s
</pre></div>
<!-- class="sect3" -->
<a id="i1006126"></a><a id="NLSPG275"></a>
<div class="sect3">
<h4 class="sect3">Tertiary Level Sorts</h4>
<p>A <a id="sthref424"></a>tertiary level sort distinguishes between base letters (primary level sort), diacritics (secondary level sort), and case (upper case and lower case). It can also include special characters such as <code>+</code>, <code>-</code>, and <code>*</code><span class="bolditalic">.</span></p>
<p>The following are examples of tertiary level sorts:</p>
<ul>
<li>
<p>Characters <code>a</code> and <code>A</code> are equal on the primary and secondary levels but different on the tertiary level because they have different cases.</p>
</li>
<li>
<p>Characters <code>&auml;</code> and <code>A</code> are equal on the primary level and different on the secondary and tertiary levels.</p>
</li>
<li>
<p>The primary and secondary level orders for the dash character <code>-</code> is 0. That is, it is ignored on the primary and secondary levels. If a dash is compared with another character whose primary level order is nonzero, for example, <code>u</code>, then no result for the primary level is available because <code>u</code> is not compared with anything. In this case, Oracle Database finds a difference between <code>-</code> and <code>u</code> only at the tertiary level.</p>
</li>
</ul>
<p>The following list has been sorted on the primary level (<code>resume</code> comes before <code>resumes</code>) and on the secondary level (strings without diacritics come before strings with diacritics) and on the tertiary level (lower case comes before upper case):</p>
<pre>
resume
Resume
r&eacute;sum&eacute;
R&eacute;sum&eacute;
resumes
Resumes
r&eacute;sum&eacute;s
R&eacute;sum&eacute;s
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006211"></a><a id="NLSPG276"></a>
<div class="sect1">
<h2 class="sect1">Linguistic Sort Features</h2>
<p>This section contains information about different features that a linguistic sort can have:</p>
<ul>
<li>
<p><a href="#CIHFCJDF">Base Letters</a></p>
</li>
<li>
<p><a href="#i1006286">Ignorable Characters</a></p>
</li>
<li>
<p><a href="#i1006294">Contracting Characters</a></p>
</li>
<li>
<p><a href="#i1006301">Expanding Characters</a></p>
</li>
<li>
<p><a href="#i1006306">Context-Sensitive Characters</a></p>
</li>
<li>
<p><a href="#i1006316">Canonical Equivalence</a></p>
</li>
<li>
<p><a href="#i1006332">Reverse Secondary Sorting</a></p>
</li>
<li>
<p><a href="#i1006347">Character Rearrangement for Thai and Laotian Characters</a></p>
</li>
<li>
<p><a href="#i1006363">Special Letters</a></p>
</li>
<li>
<p><a href="#i1006379">Special Combination Letters</a></p>
</li>
<li>
<p><a href="#i1006394">Special Uppercase Letters</a></p>
</li>
<li>
<p><a href="#i1006416">Special Lowercase Letters</a></p>
</li>
</ul>
<p>You can customize linguistic sorts to include the desired characteristics.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch13custlocale.htm#g1014110">Chapter 13, "Customizing Locale Data"</a></div>
<a id="CIHFCJDF"></a><a id="NLSPG277"></a>
<div class="sect2">
<h3 class="sect2">Base Letters</h3>
<p>Base letters are defined in a base letter table, which maps each letter to its base letter. For example, <code>a</code>, <code>A</code>, <code>&auml;</code>, and <code>&Auml;</code> all map to <code>a</code>, which is the <span class="bold"><a id="sthref425"></a>base</span> <span class="bold">letter</span>. This concept is particularly relevant for working with Oracle Text.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CCREF" href="../../text.112/e24436/toc.htm"><span class="italic">Oracle Text Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1006286"></a><a id="NLSPG278"></a>
<div class="sect2">
<h3 class="sect2">Ignorable Characters</h3>
<p>In multilingual sorts, certain characters may be treated as ignorab<a id="sthref426"></a>le. <span class="bold">Ignorable</span> <span class="bold">characters</span> are skipped, that is, treated as non-existent, when two character values (strings) containing such characters are compared in a sorting or matching operation. There are two kinds of ignorable characters that may be defined in a multilingual sort: primary ignorable and secondary ignorable. The primary ignorable characters are ignored when the multilingual sort definition applied to the given comparison has the accent-insensitivity modifier <code>_AI</code>, for example <code>GENERIC_M_AI</code>. The secondary ignorable characters are ignored when the applied definition has either the accent-insensitivity modifier <code>_AI</code> or the case-insensitivity modifier <code>_CI</code>.</p>
<p>The primary ignorable characters are called Non-Spacing Characters when viewed in a multilingual sort definition in the Oracle Locale Builder utility. The primary ignorable characters are comprised of diacritics (accents) from various alphabets (Latin, Cyrillic, Greek, Devanagari, Katakana, etc.) but also of decorating modifiers, such as enclosing circle and enclosing square. These characters are non-spacing combining characters, which means they combine with the preceding character to form a complete accented or decorated character. ("Non-spacing" means that the character occupies the same character position on screen or paper as the preceding character.) For example, the character "Latin Small Letter e" followed by the character "Combining Grave Accent" forms a single letter "&egrave;", while the character "Latin Capital Letter A" followed by the "Combining Enclosing Circle" forms a single character "(A)". Thanks to non-spacing characters being defined as ignorable for accent-insensitive sorts these sorts can treat, for example, <code>r&ocirc;le</code> as equal to <code>role</code>, <code>na&iuml;ve</code> as equal to <code>naive</code>, and (A)(B)(C) as equal to ABC.</p>
<p>The secondary ignorable characters are called Punctuation Characters when viewed in a multilingual sort definition in the Oracle Locale Builder utility. The secondary ignorable characters are comprised of punctuation characters, such as space, new line control codes, dashes, various quote forms, mathematical operators, dot, comma, exclamation mark, various bracket forms, etc. In accent-insensitive (<code>_AI</code>) and case-insensitive (<code>_CI</code>) sorts, these punctuation characters are ignored so that <code>multi-lingual</code> can be treated equal to <code>multilingual</code> and <code>e-mail</code> can be treated equal to <code>email</code>.</p>
<p>Ignorable characters are not ignored when a standard, case- and accent-sensitive sort is used. However, they have lower priority when determining the order of strings. For example, <code>multi-lingual</code> sorts after <code>multilingual</code> in the <code>GENERIC_M</code> sort but it still sorts between <code>multidimensional</code> and <code>multinational</code>. The comparison <code>d</code> &lt; <code>l</code> &lt; <code>n</code> of the base letters has higher priority in determining the order than the presence of the secondary ignorable character hyphen.</p>
<p>You can see the full list of Non-Spacing Characters and Punctuation Characters in a multilingual sort definition when viewing the definition in the Oracle Locale Builder.</p>
<p>Generally, neither punctuation characters nor non-spacing characters are included in the monolingual sort definitions. In some monolingual sort definitions, the space character and the tabulator character may be included. The comparison algorithm automatically assigns a minor value to each undefined character. This makes punctuation characters non-ignorable but, like in case of multilingual sorts, considered with lower priority when determining the order of compared strings. The ordering among punctuation characters in monolingual sorts is based on their Unicode code points and may not correspond to user expectations.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1009059">"Case-Insensitive and Accent-Insensitive Linguistic Sorts"</a> and</div>
</div>
<!-- class="sect2" -->
<a id="i1006294"></a><a id="NLSPG279"></a>
<div class="sect2">
<h3 class="sect2">Contracting Characters</h3>
<p>Sorting elements usually consist of a single character, but in some locales, two or more characters in a character <a id="sthref427"></a><a id="sthref428"></a>string must be considered as a single sorting element during sorting. For example, in traditional Spanish, the string <code>ch</code> is composed of two characters. These characters are called <span class="bold">contracting</span> <span class="bold">characters</span> in multilingual linguistic sorting and <span class="bold"><a id="sthref429"></a>special</span> <span class="bold">combination</span> <span class="bold">letters</span> in monolingual linguistic sorting.</p>
<p>Do not confuse a <span class="bold"><a id="sthref430"></a>composed character</span> with a contracting character. A composed character like <code>&aacute;</code> can be decomposed into <code>a</code> and <code>'</code>, each with their own encoding. The difference between a composed character and a contracting character is that a composed character can be displayed as a single character on a terminal, while a contracting character is used only for sorting, and its component characters must be rendered separately.</p>
</div>
<!-- class="sect2" -->
<a id="i1006301"></a><a id="NLSPG280"></a>
<div class="sect2">
<h3 class="sect2">Expanding Characters</h3>
<p>In some locales, certain charact<a id="sthref431"></a>ers must be sorted as if they were character strings. An example is the German character <code>&szlig;</code> (sharp s). It is sorted exactly the same as the string <code>SS</code>. Another example is that <code>&ouml;</code> sorts as if it were <code>oe</code>, after <code>od</code> and before <code>of</code>. These characters are known as <span class="bold">expanding</span> <span class="bold">characters</span> in multilingual linguistic sorting and <span class="bold"><a id="sthref432"></a>special</span> <span class="bold">letters</span> in monolingual linguistic sorting. Just as with contracting characters, the replacement string for an expanding character is meaningful only for sorting.</p>
</div>
<!-- class="sect2" -->
<a id="i1006306"></a><a id="NLSPG281"></a>
<div class="sect2">
<h3 class="sect2">Context-Sensitive Characters</h3>
<p>In Japanese, a prolonged sound mark that resembles an em dash <code>&mdash;</code> represents a length mark that lengthens the<a id="sthref433"></a><a id="sthref434"></a> vowel of the preceding character. The sort order depends on the vowel that precedes the length mark. This is called context-sensitive sorting. For example, after the character <code>ka</code>, the <code>&mdash;</code> length mark indicates a long <code>a</code> and is treated the same as <code>a</code>, while after the character <code>ki</code>, the <code>&mdash;</code> length mark indicates a long <code>i</code> and is treated the same as <code>i</code>. Transliterating this to Latin characters, a sort might look like this:</p>
<pre>
kaa   
ka&mdash;   -- kaa and ka&mdash; are the same
kai   -- kai follows ka- because i is after a
kia   -- kia follows kai because i is after a
kii   -- kii follows kia because i is after a
ki&mdash;   -- kii and ki&mdash; are the same
</pre></div>
<!-- class="sect2" -->
<a id="i1006316"></a><a id="NLSPG282"></a>
<div class="sect2">
<h3 class="sect2">Canonical Equivalence</h3>
<p><span class="bold">Canonical</span> <span class="bold">equivalence</span> is an attribute of a multilingual sort and describes how equivalent code point sequences are sorted. If canonical equivalence is applied in a particular linguistic sort, then canonically equivalent strings are treated as equal.</p>
<p>One Unicode code point can be <a id="sthref435"></a>equivalent to a sequence of base letter code points plus diacritic code points. This is called the Unicode canonical equivalence. For example, <code>&auml;</code> equals its base letter <code>a</code> and an umlaut. A linguistic flag, <code>CANONICAL_EQUIVALENCE = TRUE</code>, indicates that all canonical equivalence rules defined in Unicode need to be applied in a specific linguistic sort. Oracle Database-defined linguistic sorts include the appropriate setting for the canonical equivalence flag. You can set the flag to <code>FALSE</code> to speed up the comparison and ordering functions if all the data is in its composed form.</p>
<p>For example, consider the following strings:</p>
<ul>
<li>
<p><code>&auml;a</code> (<code>a</code> umlaut followed by <code>a</code>)</p>
</li>
<li>
<p><code>a&uml;b</code> (<code>a</code> followed by umlaut followed by <code>b</code>)</p>
</li>
<li>
<p><code>&auml;c</code> (<code>a</code> umlaut followed by <code>c</code>)</p>
</li>
</ul>
<p>If <code>CANONICAL_EQUIVALENCE=FALSE</code>, then the sort order of the strings is:</p>
<pre>
a&uml;b
&auml;a
&auml;c
</pre>
<p>This occurs because <code>a</code> comes before <code>&auml;</code> if canonical equivalence is not applied.</p>
<p>If <code>CANONICAL_EQUIVALENCE=TRUE</code>, then the sort order of the strings is:</p>
<pre>
&auml;a
a&uml;b
&auml;c
</pre>
<p>This occurs because <code>&auml;</code> and <code>a&uml;</code> are treated as canonically equivalent.</p>
<p>You can use Oracle Locale Builder to view the setting of the canonical equivalence flag in existing multilingual sorts. When you create a customized multilingual sort with Oracle Locale Builder, you can set the canonical equivalence flag as desired.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch13custlocale.htm#i1006766">"Creating a New Linguistic Sort with the Oracle Locale Builder"</a> for more information about setting the canonical equivalence flag</div>
</div>
<!-- class="sect2" -->
<a id="i1006332"></a><a id="NLSPG283"></a>
<div class="sect2">
<h3 class="sect2">Reverse Secondary Sorting</h3>
<p>In French, sorting <a id="sthref436"></a><a id="sthref437"></a>strings of characters with diacritics first compares base letters from left to right, but compares characters with diacritics from right to left. For example, by default, a character with a diacritic is placed after its unmarked variant. Thus <code>&Egrave;dit</code> comes before <code>Ed&iacute;t</code> in a French sort. They are equal on the primary level, and the secondary order is determined by examining characters with diacritics from right to left. Individual locales can request that the characters with diacritics be sorted with the right-to-left rule. Set the <code>REVERSE_SECONDARY</code> linguistic flag to <code>TRUE</code> to enable reverse secondary sorting.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch13custlocale.htm#i1006766">"Creating a New Linguistic Sort with the Oracle Locale Builder"</a> for more information about setting the reverse secondary flag</div>
</div>
<!-- class="sect2" -->
<a id="i1006347"></a><a id="NLSPG284"></a>
<div class="sect2">
<h3 class="sect2">Character Rearrangement for Thai and Laotian Characters</h3>
<p>In Thai and Lao, some <a id="sthref438"></a><a id="sthref439"></a>characters must first change places with the following character before sorting. Normally, these types of characters are symbols representing vowel sounds, and the next character is a consonant. Consonants and vowels must change places before sorting. Set the <code>SWAP_WITH_NEXT</code> linguistic flag for all characters that must change places before sorting.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch13custlocale.htm#i1006766">"Creating a New Linguistic Sort with the Oracle Locale Builder"</a> for more information about setting the <code>SWAP_WITH_NEXT</code> flag</div>
</div>
<!-- class="sect2" -->
<a id="i1006363"></a><a id="NLSPG285"></a>
<div class="sect2">
<h3 class="sect2">Special Letters</h3>
<p><span class="bold"><a id="sthref440"></a>Special letters</span> is a term used in monolingual sorts. They are called <span class="bold"><a id="sthref441"></a>expanding</span> <span class="bold">characters</span> in multilingual sorts.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006301">"Expanding Characters"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006379"></a><a id="NLSPG286"></a>
<div class="sect2">
<h3 class="sect2">Special Combination Letters</h3>
<p><span class="bold">Special</span> <span class="bold">combination</span> <span class="bold">letters</span> is the term <a id="sthref442"></a><a id="sthref443"></a>used in monolingual sorts. They are called <span class="bold">contracting</span> <span class="bold">letters</span> in multilingual sorts.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006294">"Contracting Characters"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006394"></a><a id="NLSPG287"></a>
<div class="sect2">
<h3 class="sect2">Special Uppercase Letters</h3>
<p>One lowercase letter may map to<a id="sthref444"></a> multiple uppercase letters. For example, in traditional German, the uppercase letters for <code>&szlig;</code> are <code>SS</code>.</p>
<p>These case conversions are handled by the <code><a id="sthref445"></a><a id="sthref446"></a><a id="sthref447"></a><a id="sthref448"></a><a id="sthref449"></a><a id="sthref450"></a>NLS_UPPER</code>, <code>NLS_LOWER</code>, and <code>NLS_INITCAP</code> SQL functions, according to the conventions established by the linguistic sort sequence. The <code>UPPER</code>, <code>LOWER</code>, and <code>INITCAP</code> SQL functions cannot handle these special characters, because their casing operation is based on binary mapping defined for the underlying character set, which is not linguistic sensitive.</p>
<p>The <code>NLS_UPPER</code> SQL function returns all uppercase characters from the same character set as the lowercase string. The following example shows the result of the <code>NLS_UPPER</code> function when <code>NLS_SORT</code> is set to <code>XGERMAN</code>:</p>
<pre>
SELECT NLS_UPPER ('gro&szlig;e') "Uppercase" FROM DUAL;

Upper
-----
GROSSE
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1006416"></a><a id="NLSPG288"></a>
<div class="sect2">
<h3 class="sect2">Special Lowercase Letters</h3>
<p>Oracle Database supports special lowercas<a id="sthref451"></a>e letters. One uppercase letter may map to multiple lowercase letters. An example is the Turkish uppercase <code>I</code> becoming a small, dotless i.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009059"></a><a id="NLSPG0051"></a>
<div class="sect1">
<h2 class="sect1">Case-Insensitive and Accent-Insensitive <a id="sthref452"></a><a id="sthref453"></a><a id="sthref454"></a><a id="sthref455"></a>Linguistic Sorts</h2>
<p>Operation inside an Oracle database is always sensitive to the case and the accents (diacritics) of the characters. Sometimes you may need to perform case-insensitive or accent-insensitive comparisons and sorts.</p>
<p>In previous versions of the database, case-insensitive queries could be achieved by using the <code>NLS_UPPER</code> and <code><a id="sthref456"></a><a id="sthref457"></a>NLS_LOWER</code> SQL functions. The functions change the case of strings based on a specific linguistic sort definition. This enables you to perform case-insensitive searches regardless of the language being used. For example, create a table called <code>test1</code> as follows:</p>
<pre>
SQL&gt; CREATE TABLE test1(word VARCHAR2(12));
SQL&gt; INSERT INTO test1 VALUES('GROSSE');
SQL&gt; INSERT INTO test1 VALUES('Gro&szlig;e');
SQL&gt; INSERT INTO test1 VALUES('gro&szlig;e');
SQL&gt; SELECT * FROM test1;

WORD
------------
GROSSE
Gro&szlig;e
gro&szlig;e
</pre>
<p>Perform a case-sensitive search for <code>GROSSE</code> as follows:</p>
<pre>
SQL&gt; SELECT word FROM test1 WHERE word='GROSSE';

WORD
------------
GROSSE
</pre>
<p>Perform a case-insensitive search for <code>GROSSE</code> using the <code><a id="sthref458"></a><a id="sthref459"></a>NLS_UPPER</code> function:</p>
<pre>
SELECT word FROM test1
WHERE NLS_UPPER(word, 'NLS_SORT = XGERMAN') = 'GROSSE';

WORD
------------
GROSSE
Gro&szlig;e
gro&szlig;e
</pre>
<p>As of Oracle Database 10<span class="italic">g,</span> Oracle Database provides case-insensitive and accent-insensitive options for linguistic sorts. It provides the following types of monolingual and multilingual linguistic sorts:</p>
<ul>
<li>
<p>Linguistic sorts that use information about base letters, diacritics, punctuation, and case. These are the standard monolingual and multilingual linguistic sorts that are described in <a href="#i1005958">"Using Linguistic Sorts"</a>.</p>
</li>
<li>
<p>Monolingual sorts that use information about base letters, diacritics, and punctuation, but not case, and multilingual sorts that use information about base letters and diacritics, but not case nor punctuation. This type of sort is called <span class="bold">case-insensitive</span>.</p>
</li>
<li>
<p>Monolingual sorts that use information about base letters and punctuation only and multilingual sorts that use information about base letters only. This type of sort is called <span class="bold">accent-insensitive</span>. (<span class="bold">Accent<a id="sthref460"></a></span> is another word for <span class="bold">diacritic</span>.) Like case-insensitive sorts, an accent-insensitive sort does not use information about case.</p>
</li>
</ul>
<p>Accent- and case-insensitive multilingual sorts ignore punctuation characters as described in <a href="#i1006286">"Ignorable Characters"</a>.</p>
<p>The rest of this section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1008800">Examples of Case-Insensitive and Accent-Insensitive Sorts</a></p>
</li>
<li>
<p><a href="#i1008835">Specifying a Case-Insensitive or Accent-Insensitive Sort</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ch3globenv.htm#i1008393">"NLS_SORT"</a></p>
</li>
<li>
<p><a href="ch3globenv.htm#i1008458">"NLS_COMP"</a></p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i1008800"></a><a id="NLSPG289"></a>
<div class="sect2">
<h3 class="sect2">Examples of Case-Insensitive and Accent-Insensitive Sorts</h3>
<p>The following examples show:</p>
<ul>
<li>
<p>A sort that uses information about base letters, diacritics, punctuation, and case</p>
</li>
<li>
<p>A case-insensitive sort</p>
</li>
<li>
<p>An accent-insensitive sort</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="NLSPG769"></a><a id="sthref461"></a>Example 5-1 Linguistic Sort Using Base Letters, Diacritics, Punctuation, and Case Information</p>
<p>The following list has been sorted using information about base letters, diacritics, punctuation, and case:</p>
<pre>
blackbird
black bird
black-bird
Blackbird
Black-bird
blackb&icirc;rd
bl&auml;ckbird
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG770"></a><a id="sthref462"></a>Example 5-2 Case-Insensitive Linguistic Sort</p>
<p>The following list has been sorted using information about base letters, diacritics, and punctuation, ignoring case:</p>
<pre>
black bird
black-bird
Black-bird
blackbird
Blackbird
blackb&icirc;rd
bl&auml;ckbird
</pre>
<p><code>black-bird</code> and <code>Black-bird</code> have the same value in the sort, because the only different between them is case. They could appear interchanged in the list. <code>Blackbird</code> and <code>blackbird</code> also have the same value in the sort and could appear interchanged in the list.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG771"></a><a id="sthref463"></a>Example 5-3 Accent-Insensitive Linguistic Sort</p>
<p>The following list has been sorted using information about base letters only. No information about diacritics, punctuation, or case has been used.</p>
<pre>
blackbird
bl&auml;ckbird
blackb&icirc;rd
Blackbird
BlackBird
Black-bird
Black bird
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1008835"></a><a id="NLSPG290"></a>
<div class="sect2">
<h3 class="sect2">Specifying a Case-Insensitive or Accent-Insensitive Sort</h3>
<p>Use the <code>NLS_SORT</code> session parameter to specify a case-insensitive or accent-insensitive sort:</p>
<ul>
<li>
<p>Append <code>_CI</code> to an Oracle Database sort name for a case-insensitive sort.</p>
</li>
<li>
<p>Append <code>_AI</code> to an Oracle Database sort name for an accent-insensitive and case-insensitive sort.</p>
</li>
</ul>
<p>For example, you can set <code>NLS_SORT</code> to the following types of values:</p>
<pre>
FRENCH_M_AI
XGERMAN_CI
</pre>
<p>Binary sorts <a id="sthref464"></a>can also be case-insensitive or accent-insensitive. When you specify <code>BINARY_CI</code> as a value for <code>NLS_SORT</code>, it designates a sort that is accent-sensitive and case-insensitive. <code>BINARY_AI</code> designates an accent-insensitive and case-insensitive binary sort. You may want to use a binary sort if the binary sort order of the character set is appropriate for the character set you are using.</p>
<p>For example, with the <code>NLS_LANG</code> environment variable set to <code>AMERICAN_AMERICA.WE8ISO8859P1</code>, create a table called <code>test2</code> and populate it as follows:</p>
<pre>
SQL&gt; CREATE TABLE test2 (letter VARCHAR2(10));
SQL&gt; INSERT INTO test2 VALUES('&auml;');
SQL&gt; INSERT INTO test2 VALUES('a');
SQL&gt; INSERT INTO test2 VALUES('A');
SQL&gt; INSERT INTO test2 VALUES('Z');
SQL&gt; SELECT * FROM test2;

LETTER
-----------
&auml; 
a
A
Z
</pre>
<p>The default value of <code>NLS_SORT</code> is <code>BINARY</code>. Use the following statement to do a binary sort of the characters in table <code>test2</code>:</p>
<pre>
SELECT * FROM test2 ORDER BY letter;
</pre>
<p>To change the value of <code>NLS_SORT</code>, enter a statement similar to the following:</p>
<pre>
ALTER SESSION SET NLS_SORT=BINARY_CI;
</pre>
<p>The following table shows the sort orders that result from setting <code>NLS_SORT</code> to <code>BINARY</code>, <a id="sthref465"></a><a id="sthref466"></a><code>BINARY_CI</code>, and <code>BINARY_AI</code>.</p>
<div class="inftblinformal">
<table class="cellalignment1914" title="Sort orders for different binary sorts" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t18">BINARY</th>
<th class="cellalignment1915" id="r1c2-t18">BINARY_CI</th>
<th class="cellalignment1915" id="r1c3-t18">BINARY_AI</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t18" headers="r1c1-t18"><code>A</code></td>
<td class="cellalignment1911" headers="r2c1-t18 r1c2-t18"><code>a</code></td>
<td class="cellalignment1911" headers="r2c1-t18 r1c3-t18"><code>&auml;</code></td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t18" headers="r1c1-t18"><code>Z</code></td>
<td class="cellalignment1911" headers="r3c1-t18 r1c2-t18"><code>A</code></td>
<td class="cellalignment1911" headers="r3c1-t18 r1c3-t18"><code>a</code></td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t18" headers="r1c1-t18"><code>a</code></td>
<td class="cellalignment1911" headers="r4c1-t18 r1c2-t18"><code>Z</code></td>
<td class="cellalignment1911" headers="r4c1-t18 r1c3-t18"><code>A</code></td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t18" headers="r1c1-t18"><code>&auml;</code></td>
<td class="cellalignment1911" headers="r5c1-t18 r1c2-t18"><code>&auml;</code></td>
<td class="cellalignment1911" headers="r5c1-t18 r1c3-t18"><code>Z</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>When <code>NLS_SORT=BINARY</code>, uppercase letters come before lowercase letters. Letters with diacritics appear last.</p>
<p>When the sort considers diacritics but ignores case (<code>BINARY_CI</code>), the letters with diacritics appear last.</p>
<p>When both case and diacritics are ignored (<code>BINARY_AI</code>), <code>&auml;</code> is sorted with the other characters whose base letter is <code>a</code>. All the characters whose base letter is <code>a</code> occur before <code>z</code>.</p>
<p>You can use binary sorts for better performance when the character set is US7ASCII or another character set that has the same sort order as the binary sorts.</p>
<p>The following table shows the sort orders that result from German sorts for the table.</p>
<div class="inftblinformal">
<table class="cellalignment1914" title="Sort orders for different German sorts" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t19">GERMAN</th>
<th class="cellalignment1915" id="r1c2-t19">GERMAN_CI</th>
<th class="cellalignment1915" id="r1c3-t19">GERMAN_AI</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t19" headers="r1c1-t19"><code>a</code></td>
<td class="cellalignment1911" headers="r2c1-t19 r1c2-t19"><code>a</code></td>
<td class="cellalignment1911" headers="r2c1-t19 r1c3-t19"><code>&auml;</code></td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t19" headers="r1c1-t19"><code>A</code></td>
<td class="cellalignment1911" headers="r3c1-t19 r1c2-t19"><code>A</code></td>
<td class="cellalignment1911" headers="r3c1-t19 r1c3-t19"><code>a</code></td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t19" headers="r1c1-t19"><code>&auml;</code></td>
<td class="cellalignment1911" headers="r4c1-t19 r1c2-t19"><code>&auml;</code></td>
<td class="cellalignment1911" headers="r4c1-t19 r1c3-t19"><code>A</code></td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t19" headers="r1c1-t19"><code>Z</code></td>
<td class="cellalignment1911" headers="r5c1-t19 r1c2-t19"><code>Z</code></td>
<td class="cellalignment1911" headers="r5c1-t19 r1c3-t19"><code>Z</code></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>A German sort places lowercase letters before uppercase letters, and <code>&auml;</code> occurs before <code>Z</code>. When the sort ignores both case and diacritics (<code>GERMAN_AI</code>), <code>&auml;</code> appears with the other characters whose base letter is <code>a</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i1008970"></a><a id="NLSPG291"></a>
<div class="sect2">
<h3 class="sect2">Linguistic Sort Examples</h3>
<p>The examples in this section demonstrate a binary sort, a monolingual sort, and a multilingual sort. To prepare for the examples, create and populate a table called <code>test3</code>. Enter the following statements:</p>
<pre>
SQL&gt; CREATE TABLE test3 (name VARCHAR2(20));
SQL&gt; INSERT INTO test3 VALUES('Diet');
SQL&gt; INSERT INTO test3 VALUES('&Agrave; voir');
SQL&gt; INSERT INTO test3 VALUES('Freizeit');
</pre>
<div class="example">
<p class="titleinexample"><a id="NLSPG772"></a><a id="sthref467"></a>Example 5-4 Binary Sort</p>
<p>The <code>ORDER BY</code> <a id="sthref468"></a>clause uses a binary sort.</p>
<pre>
SQL&gt; SELECT * FROM test3 ORDER BY name;
</pre>
<p>You should see the following output:</p>
<pre>
Diet
Freizeit
&Agrave; voir
</pre>
<p>Note that a binary sort results in <code>&Agrave; voir</code> being at the end of the list.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG773"></a><a id="sthref469"></a>Example 5-5 Monolingual German Sort</p>
<p>Use the <code>NLSSORT</code> <a id="sthref470"></a>function with the <code>NLS_SORT</code> parameter set to <code>german</code> to obtain a German sort.</p>
<pre>
SQL&gt; SELECT * FROM test3 ORDER BY NLSSORT(name, 'NLS_SORT=german');
</pre>
<p>You should see the following output:</p>
<pre>
&Agrave; voir
Diet
Freizeit
</pre>
<p>Note that <code>&Agrave; voir</code> is at the beginning of the list in a German sort.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG774"></a><a id="sthref471"></a>Example 5-6 Comparing a Monolingual German Sort to a Multilingual Sort</p>
<p>Insert the <a id="sthref472"></a>character string shown in <a href="#i1009005">Figure 5-1</a> into <code>test</code>. It is a <code>D</code> with a crossbar followed by <code>&ntilde;</code>.</p>
</div>
<!-- class="example" -->
<div class="figure">
<p class="titleinfigure"><a id="i1009005"></a><a id="NLSPG775"></a>Figure 5-1 Character String</p>
<img width="600" height="16" src="img/dn14.gif" alt="Description of Figure 5-1 follows" /><br />
<a id="sthref473" href="./img_text/dn14.htm">Description of "Figure 5-1 Character String"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Perform a monolingual German sort by using the <code>NLSSORT</code> function with the <code>NLS_SORT</code> parameter set to <code>german</code>.</p>
<pre>
SQL&gt; SELECT * FROM test2 ORDER BY NLSSORT(name, 'NLS_SORT=german');
</pre>
<p>The output from the German sort shows the new character string last in the list of entries because the characters are not recognized in a German sort.</p>
<p>Perform a multilingual sort by entering the following statement:</p>
<pre>
SQL&gt; SELECT * FROM test2 ORDER BY NLSSORT(name, 'NLS_SORT=generic_m');
</pre>
<p>The output shows the new character string after <code>Diet</code>, following ISO sorting rules.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ch9sql.htm#i1006311">"The NLSSORT Function"</a></p>
</li>
<li>
<p><a href="ch3globenv.htm#i1008393">"NLS_SORT"</a> for more information about setting and changing the <code>NLS_SORT</code> parameter</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CIHJBFAD"></a><a id="NLSPG292"></a>
<div class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Performing Linguistic Comparisons</h2>
<p>When performing SQL comparison operations, characters are compared according to their binary values. A character is greater than another if it has a higher binary value. Because the binary sequences rarely match the linguistic sequences for most languages, such comparisons may not be meaningful for a typical user. To achieve a meaningful comparison, you can specify behavior by using the session parameters <code>NLS_COMP</code> and <code>NLS_SORT</code>. The way you set these two parameters determines the rules by which characters are sorted and compared.</p>
<p>The <code>NLS_COMP</code> setting determines how <code>NLS_SORT</code> is handled by the SQL operations. There are three valid values for <code>NLS_COMP</code>:</p>
<ul>
<li>
<p><code>BINARY</code></p>
<p>All SQL sorts and comparisons are based on the binary values of the string characters, regardless of the value set to <code>NLS_SORT</code>. This is the default setting.</p>
</li>
</ul>
<ul>
<li>
<p><code>LINGUISTIC</code></p>
<p>All SQL sorting and comparison are based on the linguistic rule specified by <code>NLS_SORT</code>. For example, <code>NLS_COMP=LINGUISTIC</code> and <code>NLS_SORT=BINARY_CI</code> means the collation sensitive SQL operations will use binary value for sorting and comparison but ignore character case.</p>
</li>
</ul>
<ul>
<li>
<p><code>ANSI</code></p>
<p>A limited set of SQL functions honor the <code>NLS_SORT</code> setting. <code>ANSI</code> is available for backward compatibility only. In general, you should set <code>NLS_COMP</code> to <code>LINGUISTIC</code> when performing linguistic comparison.</p>
</li>
</ul>
<p><a href="#CIHBFIID">Table 5-2</a> shows how different SQL operations behave with these different settings.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG776"></a><a id="sthref474"></a><a id="CIHBFIID"></a>Table 5-2 Linguistic Comparison Behavior with NLS_COMP Settings</p>
<table class="cellalignment1914" title="Linguistic Comparison Behavior with NLS_COMP Settings" summary="Linguistic Comparison Behavior" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t21"><br /></th>
<th class="cellalignment1915" id="r1c2-t21">BINARY</th>
<th class="cellalignment1915" id="r1c3-t21">LINGUISTIC</th>
<th class="cellalignment1915" id="r1c4-t21">ANSI</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t21" headers="r1c1-t21">
<p><span class="bold">SQL</span> <span class="bold">Operators</span></p>
</td>
<td class="cellalignment1911" headers="r2c1-t21 r1c2-t21">&nbsp;</td>
<td class="cellalignment1911" headers="r2c1-t21 r1c3-t21">&nbsp;</td>
<td class="cellalignment1911" headers="r2c1-t21 r1c4-t21">&nbsp;</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t21" headers="r1c1-t21">
<p><code>UNION</code>, <code>INTERSECT</code>, <code>MINUS</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r3c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t21" headers="r1c1-t21">
<p><span class="bold">SQL</span> <span class="bold">Functions</span></p>
</td>
<td class="cellalignment1911" headers="r4c1-t21 r1c2-t21">&nbsp;</td>
<td class="cellalignment1911" headers="r4c1-t21 r1c3-t21">&nbsp;</td>
<td class="cellalignment1911" headers="r4c1-t21 r1c4-t21">&nbsp;</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t21" headers="r1c1-t21">
<p><code>DECODE</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r5c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r6c1-t21" headers="r1c1-t21">
<p><code>INSTRx</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r6c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r7c1-t21" headers="r1c1-t21">
<p><code>LEAST</code>, <code>GREATEST</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r7c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r8c1-t21" headers="r1c1-t21">
<p><code>MAX</code>, <code>MIN</code></p>
</td>
<td class="cellalignment1911" headers="r8c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r8c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r8c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r9c1-t21" headers="r1c1-t21">
<p><code>NLS_INITCAP</code></p>
</td>
<td class="cellalignment1911" headers="r9c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r9c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r9c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r10c1-t21" headers="r1c1-t21">
<p><code>NLS_LOWER</code></p>
</td>
<td class="cellalignment1911" headers="r10c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r10c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r10c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r11c1-t21" headers="r1c1-t21">
<p><code>NLS_UPPER</code></p>
</td>
<td class="cellalignment1911" headers="r11c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r11c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r11c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r12c1-t21" headers="r1c1-t21">
<p><code>NLSSORT</code></p>
</td>
<td class="cellalignment1911" headers="r12c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r12c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r12c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r13c1-t21" headers="r1c1-t21">
<p><code>NULLIF</code></p>
</td>
<td class="cellalignment1911" headers="r13c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r13c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r13c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r14c1-t21" headers="r1c1-t21">
<p><code>REGEXP_COUNT</code></p>
</td>
<td class="cellalignment1911" headers="r14c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r14c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r14c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r15c1-t21" headers="r1c1-t21">
<p><code>REGEXP_INSTR</code></p>
</td>
<td class="cellalignment1911" headers="r15c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r15c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r15c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r16c1-t21" headers="r1c1-t21">
<p><code>REGEXP_LIKE</code></p>
</td>
<td class="cellalignment1911" headers="r16c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r16c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r16c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r17c1-t21" headers="r1c1-t21">
<p><code>REGEXP_REPLACE</code></p>
</td>
<td class="cellalignment1911" headers="r17c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r17c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r17c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r18c1-t21" headers="r1c1-t21">
<p><code>REGEXP_SUBSTR</code></p>
</td>
<td class="cellalignment1911" headers="r18c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r18c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r18c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r19c1-t21" headers="r1c1-t21">
<p><code>REPLACE</code></p>
</td>
<td class="cellalignment1911" headers="r19c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r19c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r19c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r20c1-t21" headers="r1c1-t21">
<p><code>RTRIM</code>, <code>TRIM</code>, <code>LTRIM</code></p>
</td>
<td class="cellalignment1911" headers="r20c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r20c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r20c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r21c1-t21" headers="r1c1-t21">
<p><code>TRANSLATE</code>, <code>TRANSLATE</code> <code>USING</code></p>
</td>
<td class="cellalignment1911" headers="r21c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r21c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r21c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r22c1-t21" headers="r1c1-t21">
<p><span class="bold">SQL</span> <span class="bold">Expressions</span></p>
</td>
<td class="cellalignment1911" headers="r22c1-t21 r1c2-t21">&nbsp;</td>
<td class="cellalignment1911" headers="r22c1-t21 r1c3-t21">&nbsp;</td>
<td class="cellalignment1911" headers="r22c1-t21 r1c4-t21">&nbsp;</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r23c1-t21" headers="r1c1-t21">
<p><code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></p>
</td>
<td class="cellalignment1911" headers="r23c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r23c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r23c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r24c1-t21" headers="r1c1-t21">
<p><code>BETWEEN</code>, <code>NOT</code> <code>BETWEEN</code></p>
</td>
<td class="cellalignment1911" headers="r24c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r24c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r24c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r25c1-t21" headers="r1c1-t21">
<p><code>CASE</code></p>
</td>
<td class="cellalignment1911" headers="r25c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r25c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r25c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r26c1-t21" headers="r1c1-t21">
<p><code>DISTINCT</code></p>
</td>
<td class="cellalignment1911" headers="r26c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r26c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r26c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r27c1-t21" headers="r1c1-t21">
<p><code>GROUP</code></p>
</td>
<td class="cellalignment1911" headers="r27c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r27c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r27c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r28c1-t21" headers="r1c1-t21">
<p><code>GROUP</code> <code>BY</code></p>
</td>
<td class="cellalignment1911" headers="r28c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r28c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r28c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r29c1-t21" headers="r1c1-t21">
<p><code>HAVING</code></p>
</td>
<td class="cellalignment1911" headers="r29c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r29c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r29c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r30c1-t21" headers="r1c1-t21">
<p><code>IN</code>, <code>NOT</code> <code>IN</code></p>
</td>
<td class="cellalignment1911" headers="r30c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r30c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r30c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r31c1-t21" headers="r1c1-t21">
<p><code>LIKE</code></p>
</td>
<td class="cellalignment1911" headers="r31c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r31c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r31c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r32c1-t21" headers="r1c1-t21">
<p><code>ORDER</code> <code>BY</code></p>
</td>
<td class="cellalignment1911" headers="r32c1-t21 r1c2-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r32c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r32c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r33c1-t21" headers="r1c1-t21">
<p><code>START</code> <code>WITH</code></p>
</td>
<td class="cellalignment1911" headers="r33c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r33c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r33c1-t21 r1c4-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r34c1-t21" headers="r1c1-t21">
<p><code>UNIQUE</code></p>
</td>
<td class="cellalignment1911" headers="r34c1-t21 r1c2-t21">
<p>Binary</p>
</td>
<td class="cellalignment1911" headers="r34c1-t21 r1c3-t21">
<p>Honors <code>NLS_SORT</code></p>
</td>
<td class="cellalignment1911" headers="r34c1-t21 r1c4-t21">
<p>Binary</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>See <a href="ch3globenv.htm#i1008458">"NLS_COMP"</a> and <a href="ch3globenv.htm#i1008393">"NLS_SORT"</a> for information regarding these parameters.</p>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref475"></a>
<h3 class="sect2">Collation Keys</h3>
<p>When the comparison conditions =, !=, &gt;, &lt;, &gt;=, &lt;=, <code>BETWEEN</code>, <code>NOT</code> <code>BETWEEN</code>, <code>IN</code>, <code>NOT</code> <code>IN</code>, the query clauses <code>ORDER</code> <code>BY</code> or <code>GROUP</code> <code>BY</code>, or the aggregate function <code>COUNT(DISTINCT)</code> are evaluated according to linguistic rules specified by <code>NLS_SORT</code>, the compared argument values are first transformed to binary values called collation keys and then compared byte by byte, like <code>RAW</code> values. If a monolingual sort is applied, collation keys contain major values for characters of the source value concatenated with minor values for those characters. If a multilingual sort is applied, collation keys contain concatenated primary, secondary, and tertiary values.</p>
<p>The collation keys are the same values that are returned by the <code>NLSSORT</code> function. That is, activating the linguistic behavior of these SQL operations is equivalent to including their arguments into calls to the <code>NLSSORT</code> function.</p>
</div>
<!-- class="sect2" -->
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref476"></a>
<h3 class="sect2">Restricted Precision of Linguistic Comparison</h3>
<p>As collation keys are values of the data type <code>RAW</code> and the maximum length of a <code>RAW</code> value is 2000 bytes, the maximum length of a collation key is restricted to 2000 bytes. If a full source character value yields a collation key longer than 2000 bytes, the collation key generated for this value is calculated for a maximum prefix (initial substring) of the value for which the calculated result does not exceed 2000 bytes. For monolingual sorts, the prefix length is typically 1000 characters. For multilingual sorts, the prefix is typically 500 characters. The exact length may be higher or lower and depends on the particular collation and the particular characters contained in the source value.</p>
<p>The implication of this method of collation key generation is that SQL operations using the collation keys to implement the linguistic behavior will return results that may ignore trailing parts of long arguments. For example, two character values starting with the same 1000 characters but differing somewhere after the 1000th character will be grouped together by the <code>GROUP</code> <code>BY</code> clause.</p>
</div>
<!-- class="sect2" -->
<a id="NLSPG293"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref477"></a>
<h3 class="sect2">Linguistic Comparison Examples</h3>
<p>The following examples illustrate behavior with different <code>NLS_COMP</code> settings.</p>
<div class="example">
<p class="titleinexample"><a id="NLSPG777"></a><a id="sthref478"></a>Example 5-7 Binary Comparison Binary Sort</p>
<p>The following illustrates behavior with a binary setting:</p>
</div>
<!-- class="example" -->
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=BINARY;
SQL&gt; ALTER SESSION SET NLS_SORT=BINARY;
SQL&gt; SELECT ename FROM emp1;

ENAME
----------------------
Mc Calla
MCAfee
McCoye
Mccathye
McCafe&eacute;

5 rows selected

SQL&gt; SELECT ename FROM emp1 WHERE ename LIKE 'McC%e';

ENAME
----------------------
McCoye

1 row selected
</pre>
<div class="example">
<p class="titleinexample"><a id="NLSPG778"></a><a id="sthref479"></a>Example 5-8 Linguistic Comparison Binary Case-Insensitive Sort</p>
<p>The following illustrates behavior with a case-insensitive setting:</p>
</div>
<!-- class="example" -->
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=LINGUISTIC;
SQL&gt; ALTER SESSION SET NLS_SORT=BINARY_CI;
SQL&gt; SELECT ename FROM emp1 WHERE ename LIKE 'McC%e';

ENAME
----------------------
McCoye
Mccathye

2 rows selected
</pre>
<div class="example">
<p class="titleinexample"><a id="NLSPG779"></a><a id="sthref480"></a>Example 5-9 Linguistic Comparison Binary Accent-Insensitive Sort</p>
<p>The following illustrates behavior with an accent-insensitive setting:</p>
</div>
<!-- class="example" -->
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=LINGUISTIC;
SQL&gt; ALTER SESSION SET NLS_SORT=BINARY_AI;
SQL&gt; SELECT ename FROM emp1 WHERE ename LIKE 'McC%e';

ENAME
----------------------
McCoye
Mccathye
McCafe&eacute;

3 rows selected
</pre>
<div class="example">
<p class="titleinexample"><a id="NLSPG780"></a><a id="sthref481"></a>Example 5-10 Linguistic Comparisons Returning Fewer Rows</p>
<p>Some operations may return fewer rows after applying linguistic rules. For example, with a binary setting, <code>McAfee</code> and <code>Mcafee</code> are different:</p>
</div>
<!-- class="example" -->
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=BINARY;
SQL&gt; ALTER SESSION SET NLS_SORT=BINARY;
SQL&gt; SELECT DISTINCT ename FROM emp2;

ENAME
----------------------
McAfee
Mcafee
McCoy

3 rows selected
</pre>
<p>However, with a case-insensitive setting, <code>McAfee</code> and <code>Mcafee</code> are the same:</p>
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=LINGUISTIC;
SQL&gt; ALTER SESSION SET NLS_SORT=BINARY_CI;
SQL&gt; SELECT DISTINCT ename FROM emp2;

ENAME
----------------------
McAfee
McCoy

2 rows selected
</pre>
<p>In this example, either <code>McAfee</code> or <code>Mcafee</code> could be returned from the <code>DISTINCT</code> operation. There is no guarantee exactly which one will be picked.</p>
<div class="example">
<p class="titleinexample"><a id="NLSPG781"></a><a id="sthref482"></a>Example 5-11 Linguistic Comparisons Using XSPANISH</p>
<p>There are cases where characters the are same using binary comparison but different using linguistic comparison. For example, with a binary setting, the character <code>C</code> in <code>Cindy</code>, <code>Chad</code>, and <code>Clara</code> represents the same letter <code>C</code>:</p>
</div>
<!-- class="example" -->
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=BINARY;
SQL&gt; ALTER SESSION SET NLS_SORT=BINARY;
SQL&gt; SELECT ename FROM emp3 WHERE ename LIKE 'C%';

ENAME
----------------------
Cindy
Chad
Clara

3 rows selected
</pre>
<p>In a database session with the linguistic rule set to traditional Spanish, <code>XSPANISH</code>, <code>ch</code> is treated as one character. So the letter <code>c</code> in <code>Chad</code> is different than the letter <code>C</code> in <code>Cindy</code> and <code>Clara</code>:</p>
<pre>
SQL&gt; ALTER SESSION SET NLS_COMP=LINGUISTIC;
SQL&gt; ALTER SESSION SET NLS_SORT=XSPANISH;
SQL&gt; SELECT ename FROM emp3 WHERE ename LIKE 'C%';

ENAME
----------------------
Cindy
Clara

2 rows selected
</pre>
<p>And the letter <code>c</code> in combination <code>ch</code> is different than the <code>c</code> standing by itself:</p>
<pre>
SQL&gt; SELECT REPLACE ('character', 'c', 't') "Changes" FROM DUAL;

Changes
---------------------
charatter
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006421"></a><a id="NLSPG294"></a>
<div class="sect1">
<h2 class="sect1">Using Linguistic Indexes</h2>
<p><a id="i1006426"></a>Linguistic sorting is language-specific and requires more data processing than binary sorting. Using a binary sort for ASCII is accurate and fast because the binary codes for ASCII characters reflect their linguistic order. When data in multiple languages is stored in the database, you may want applications to sort the data returned from a <code>SELECT...ORDER BY</code> statement according to different sort sequences depending on the language. You can accomplish this without sacrificing performance by using linguistic indexes. Although a linguistic index for a column slows down inserts and updates, it greatly improves the performance of linguistic sorting with the <code>ORDER</code> <code>BY</code> clause and the <code>WHERE</code> clause.</p>
<p>You can create a function-based index that uses languages other than English. The index does not change the linguistic sort order determined by <code>NLS_SORT</code>. The linquistic index simply improves the performance.</p>
<p>The following statement creates an index based on a German sort:</p>
<pre>
CREATE TABLE my_table(name VARCHAR(20) NOT NULL);
CREATE INDEX nls_index ON my_table (NLSSORT(name, 'NLS_SORT = German'));

/*The NOT NULL in the CREATE TABLE statement ensures that the index is used*/
</pre>
<p>After the index has been created, enter a <code>SELECT</code> statement similar to the following example:</p>
<pre>
SELECT * FROM my_table ORDER BY name
WHERE name LIKE 'Hein%';
</pre>
<p>It returns the result much faster than the same <code>SELECT</code> statement without a linguistic index.</p>
<p>The rest of this section contains the following topics:</p>
<ul>
<li>
<p><a href="#CHDHGGEC">Supported SQL Operations and Functions for Linguistic Indexes</a></p>
</li>
<li>
<p><a href="#i1006463">Linguistic Indexes for Multiple Languages</a></p>
</li>
<li>
<p><a href="#i1006494">Requirements for Using Linguistic Indexes</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a></p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about function-based indexes</p>
</li>
</ul>
</div>
</li>
</ul>
<a id="CHDHGGEC"></a><a id="NLSPG295"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Supported SQL Operations and Functions for Linguistic Indexes</h3>
<p>Linguistic index support is available for the following collation-sensitive SQL operations and SQL functions:</p>
<ul>
<li>
<p>Comparison conditions <code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></p>
</li>
<li>
<p>Range conditions <code>BETWEEN</code> | <code>NOT</code> <code>BETWEEN</code></p>
</li>
<li>
<p><code>IN</code> | <code>NOT</code> <code>IN</code></p>
</li>
<li>
<p><code>ORDER</code> <code>BY</code></p>
</li>
<li>
<p><code>GROUP</code> <code>BY</code></p>
</li>
<li>
<p><code>LIKE</code> (<code>LIKE</code>, <code>LIKE2</code>, <code>LIKE4</code>, <code>LIKEC</code>)</p>
</li>
<li>
<p><code>DISTINCT</code></p>
</li>
<li>
<p><code>UNIQUE</code></p>
</li>
<li>
<p><code>UNION</code></p>
</li>
<li>
<p><code>INTERSECT</code></p>
</li>
<li>
<p><code>MINUS</code></p>
</li>
</ul>
<p>The SQL functions in the following list cannot utilize linguistic index:</p>
<ul>
<li>
<p><code>INSTR</code> (<code>INSTR</code>, <code>INSTRB</code>, <code>INSTR2</code>, <code>INSTR4</code>, <code>INSTRC</code>)</p>
</li>
<li>
<p><code>MAX</code></p>
</li>
<li>
<p><code>MIN</code></p>
</li>
<li>
<p><code>REPLACE</code></p>
</li>
<li>
<p><code>TRIM</code></p>
</li>
<li>
<p><code>LTRIM</code></p>
</li>
<li>
<p><code>RTRIM</code></p>
</li>
<li>
<p><code>TRANSLATE</code></p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006463"></a><a id="NLSPG296"></a>
<div class="sect2">
<h3 class="sect2">Linguistic Indexes for Multiple Languages</h3>
<p>There are three ways to build linguistic indexes for data in multiple languages:</p>
<ul>
<li>
<p>Build a linguistic index for each language that the application supports. This approach offers simplicity but requires more disk space. For each index, the rows in the language other than the one on which the index is built are collated together at the end of the sequence. The following example builds linguistic indexes for French and German.</p>
<pre>
CREATE INDEX french_index ON employees (NLSSORT(employee_id, 'NLS_SORT=FRENCH'));
CREATE INDEX german_index ON employees (NLSSORT(employee_id, 'NLS_SORT=GERMAN'));
</pre>
<p>Oracle Database chooses the index based on the <code>NLS_SORT</code> session parameter or the arguments of the <code>NLSSORT</code> function specified in the <code>ORDER</code> <code>BY</code> clause. For example, if the <code>NLS_SORT</code> session parameter is set to <code>FRENCH</code>, then Oracle Database uses <code>french_index</code>. When it is set to <code>GERMAN</code>, Oracle Database uses <code>german_index</code>.</p>
</li>
<li>
<p>Build a single linguistic index for all languages. This requires a language column (<code>LANG_COL</code> in <a href="#i1006563">"Example: Setting Up a French Linguistic Index"</a>) to be used as a parameter of the <code>NLSSORT</code> function. The language column contains <code>NLS_LANGUAGE</code> values for the data in the column on which the index is built. The following example builds a single linguistic index for multiple languages. With this index, the rows with the same values for <code>NLS_LANGUAGE</code> are sorted together.</p>
<pre>
CREATE INDEX i ON t (NLSSORT(col, 'NLS_SORT=' || LANG_COL));
</pre>
<p>Queries choose an index based on the argument of the <code>NLSSORT</code> function specified in the <code>ORDER BY</code> clause.</p>
</li>
<li>
<p>Build a single linguistic index for all languages using one of the multilingual linguistic sorts such as <code>GENERIC_M</code> or <code>FRENCH_M</code>. These indexes sort characters according to the rules defined in ISO 14651. For example:</p>
<pre>
CREATE INDEX i on t (NLSSORT(col, 'NLS_SORT=GENERIC_M');
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006047">"Multilingual Linguistic Sorts"</a> for more information about Unicode sorts</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006494"></a><a id="NLSPG297"></a>
<div class="sect2">
<h3 class="sect2">Requirements for Using Linguistic Indexes</h3>
<p><a id="i1006496"></a>The following are requirements for using linguistic indexes:</p>
<ul>
<li>
<p><a href="#i1006531">Set NLS_SORT Appropriately</a></p>
</li>
<li>
<p><a href="#i1009158">Specify NOT NULL in a WHERE Clause If the Column Was Not Declared NOT NULL</a></p>
</li>
</ul>
<p>This section also includes:</p>
<ul>
<li>
<p><a href="#i1006563">Example: Setting Up a French Linguistic Index</a></p>
</li>
</ul>
<a id="i1006531"></a><a id="NLSPG298"></a>
<div class="sect3">
<h4 class="sect3">Set NLS_SORT Appropriately</h4>
<p>The <code><a id="sthref483"></a>NLS_SORT</code> parameter should indicate the linguistic definition you want to use for the linguistic sort. If you want a French linguistic sort order, then <code>NLS_SORT</code> should be set to <code>FRENCH</code>. If you want a German linguistic sort order, then <code>NLS_SORT</code> should be set to <code>GERMAN</code>.</p>
<p>There are several ways to set <code>NLS_SORT</code>. You should set <code>NLS_SORT</code> as a client environment variable so that you can use the same SQL statements for all languages. Different linguistic indexes can be used when <code>NLS_SORT</code> is set in the client environment.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch3globenv.htm#i1008393">"NLS_SORT"</a></div>
</div>
<!-- class="sect3" -->
<a id="i1009158"></a><a id="NLSPG299"></a>
<div class="sect3">
<h4 class="sect3">Specify NOT NULL in a WHERE Clause If the Column Was Not Declared NOT NULL</h4>
<p>When you want to use the <code>ORDER BY</code> <code><span class="codeinlineitalic">column_name</span></code> clause with a column that has a linguistic index, include a <code>WHERE</code> clause like the following example:</p>
<pre>
WHERE NLSSORT(<span class="codeinlineitalic">column_name</span>) IS NOT NULL
</pre>
<p>This <code>WHERE</code> clause is not necessary if the column has already been defined as a <code>NOT NULL</code> column in the schema.</p>
</div>
<!-- class="sect3" -->
<a id="i1006563"></a><a id="NLSPG300"></a>
<div class="sect3">
<h4 class="sect3">Example: Setting Up a French Linguistic Index</h4>
<p>The following example shows how to set up a French linguistic index. You may want to set <code>NLS_SORT</code> as a client environment variable instead of using the <code>ALTER</code> <code>SESSION</code> statement.</p>
<pre>
ALTER SESSION SET NLS_SORT='FRENCH';
CREATE INDEX test_idx ON test4(NLSSORT(name, 'NLS_SORT=FRENCH'));
SELECT * FROM test4 ORDER BY col;
ALTER SESSION SET NLS_COMP=LINGUISTIC;
SELECT * FROM test4 WHERE name &gt; 'Henri';
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
The SQL functions <code>MAX( )</code> and <code>MIN( )</code> cannot use linguistic indexes when <code>NLS_COMP</code> is set to <code>LINGUISTIC</code>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008708"></a><a id="NLSPG301"></a>
<div class="sect1">
<h2 class="sect1">Searching Linguistic Strings</h2>
<p>Searching <a id="sthref484"></a><a id="sthref485"></a>and sorting are related tasks. Organizing data and processing it in a linguistically meaningful order is necessary for proper business processing. Searching and matching data in a linguistically meaningful way depends on what sort order is applied. For example, searching for all strings greater than <code>c</code> and less than <code>f</code> produces different results depending on the value of <code>NLS_SORT</code>. In an ASCII binary sort the search finds any strings that start with <code>d</code> or <code>e</code> but excludes entries that begin with upper case <code>D</code> or <code>E</code> or accented <code>e</code> with a diacritic, such as <code>&ecirc;</code>. Applying an accent-insensitive binary sort returns all strings that start with <code>d</code>, <code>D,</code> and accented <code>e,</code> such as <code>&Ecirc;</code> or <code>&ecirc;</code>. Applying the same search with <code>NLS_SORT</code> set to <code>XSPANISH</code> also returns strings that start with <code>ch</code>, because <code>ch</code> is treated as a composite character that sorts between <code>c</code> and <code>d</code> in traditional Spanish. This chapter discusses the kinds of sorts that Oracle Database offers and how they affect string searches by SQL and SQL regular expressions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1006211">"Linguistic Sort Features"</a></p>
</li>
<li>
<p><a href="#i1008619">"SQL Regular Expressions in a Multilingual Environment"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1008619"></a><a id="NLSPG0052"></a>
<div class="sect1">
<h2 class="sect1">SQL Regular Expressions in a Multilingual Environment</h2>
<p>Regular<a id="sthref486"></a> expressions provide a powerful method of identifying patterns of strings within a body of text. Usage ranges from a simple search for a string such as <code>San Francisco</code> to the more complex task of extracting all URLs to finding all words whose every second character is a vowel. SQL and PL/SQL support regular expressions in Oracle Database.</p>
<p>Traditional regular expression engines were designed to address only English text. However, regular expression implementations can encompass a wide variety of languages with characteristics that are very different from western European text. The implementation of regular expressions in Oracle Database is based on the Unicode Regular Expression Guidelines. The <code><a id="sthref487"></a>REGEXP</code> SQL functions work with all character sets that are supported as database character sets and national character sets. Moreover, Oracle Database enhances the matching capabilities of the POSIX regular expression constructs to handle the unique linguistic requirements of matching multilingual data.</p>
<p>Oracle Database enhancements of the linguistic-sensitive operators are described in the following sections:</p>
<ul>
<li>
<p><a href="#i1008657">Character Range '[x-y]' in Regular Expressions</a></p>
</li>
<li>
<p><a href="#i1008666">Collation Element Delimiter '[. .]' in Regular Expressions</a></p>
</li>
<li>
<p><a href="#i1008670">Character Class '[: :]' in Regular Expressions</a></p>
</li>
<li>
<p><a href="#i1008674">Equivalence Class '[= =]' in Regular Expressions</a></p>
</li>
<li>
<p><a href="#i1008751">Examples: Regular Expressions</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information about regular expression syntax</p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code>REGEX</code> SQL functions</p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i1008657"></a><a id="NLSPG302"></a>
<div class="sect2">
<h3 class="sect2">Character Range '[x-y]' in <a id="sthref488"></a>Regular Expressions</h3>
<p>According to the POSIX standard, a range in a regular expression includes all collation elements between the start point and the end point of the range in the linguistic definition of the current locale. Therefore, ranges in regular expressions are meant to be linguistic ranges, not byte value ranges, because byte value ranges depend on the platform, and the end user should not be expected to know the ordering of the byte values of the characters. The semantics of the range expression must be independent of the character set. This implies that a range such as <code>[a-d]</code> includes all the letters between <code>a</code> and <code>d</code> plus all of those letters with diacritics, plus any special case collation element such as <code>ch</code> in Traditional Spanish that is sorted as one character.</p>
<p>Oracle Database interprets range expressions as specified by the <code>NLS_SORT</code> parameter to determine the collation elements covered by a given range. For example:</p>
<pre>
Expression:     [a-d]e
NLS_SORT:       BINARY
Does not match: cheremoya
NLS_SORT:       XSPANISH
Matches:        &gt;&gt;che&lt;&lt;remoya
</pre></div>
<!-- class="sect2" -->
<a id="i1008666"></a><a id="NLSPG303"></a>
<div class="sect2">
<h3 class="sect2">Collation Element Delimiter '[. .]' in Regular Expressions</h3>
<p>This <a id="sthref489"></a>construct is introduced by the POSIX standard to separate collating elements. A <span class="bold">collating element</span> is a unit of collation and is equal to one character in most cases. However, the collation sequence in some languages may define two or more characters as a collating element. The historical regular expression syntax does not allow the user to define ranges involving multicharacter collation elements. For example, there was no way to define a range from <code>a</code> to <code>ch</code> because <code>ch</code> was interpreted as two separate characters.</p>
<p>By using the collating element delimiter <code>[. .]</code>, you can separate a multicharacter collation element from other elements. For example, the range from <code>a</code> to <code>ch</code> can be written as <code>[a-[.ch.]]</code>. It can also be used to separate single-character collating elements. If you use <code>[. .]</code> to enclose a multicharacter sequence that is not a defined collating element, then it is considered as a semantic error in the regular expression. For example, <code>[.ab.]</code> is considered invalid if <code>ab</code> is not a defined multicharacter collating element.</p>
</div>
<!-- class="sect2" -->
<a id="i1008670"></a><a id="NLSPG304"></a>
<div class="sect2">
<h3 class="sect2">Character Class '[: :]' in Regular <a id="sthref490"></a>Expressions</h3>
<p>In English regular expressions, the range expression can be used to indicate a character class. For example, <code>[a-z]</code> can be used to indicate any lowercase letter. However, in non-English regular expressions, this approach is not accurate unless <code>a</code> is the first lowercase letter and <code>z</code> is the last lowercase letter in the collation sequence of the language.</p>
<p>The POSIX standard introduces a new syntactical element to enable specifying explicit character classes in a portable way. The <code>[: :]</code> syntax denotes the set of characters belonging to a certain character class. The character class definition is based on the character set classification data.</p>
</div>
<!-- class="sect2" -->
<a id="i1008674"></a><a id="NLSPG305"></a>
<div class="sect2">
<h3 class="sect2">Equivalence Class '[= =]' in R<a id="sthref491"></a>egular Expressions</h3>
<p>Oracle Database also supports equivalence classes through the <code>[= =]</code> syntax as recommended by the POSIX standard. A base letter and all of the accented versions of the base constitute an <span class="bold">equivalence class</span>. For example, the equivalence class <code>[=a=]</code> matches <code>&auml;</code> as well as <code>&acirc;</code>. The current implementation does not support matching of Unicode composed and decomposed forms for performance reasons. For example, &auml; (<code>a</code> umlaut) does not match '<code>a</code> followed by umlaut'.</p>
</div>
<!-- class="sect2" -->
<a id="i1008751"></a><a id="NLSPG306"></a>
<div class="sect2">
<h3 class="sect2">Examples: Regular Expressions<a id="sthref492"></a></h3>
<p>The following examples show regular expression matches.</p>
<div class="example">
<p class="titleinexample"><a id="NLSPG782"></a><a id="sthref493"></a>Example 5-12 Case-Insensitive Match Using the NLS_SORT Value</p>
<p>Case sensitivity in an Oracle Database regular expression match is determined at two levels: the <code>NLS_SORT</code> initialization parameter and the runtime match option. The <code>REGEXP</code> functions inherit the case-sensitivity behavior from the value of <code>NLS_SORT</code> by default. The value can also be explicitly overridden by the runtime match option <code>'c'</code> (case sensitive) or <code>'i'</code> (case insensitive).</p>
<pre>
Expression: catalog(ue)?
NLS_SORT: GENERIC_M_CI
Matches: 
</pre>
<pre>
&gt;&gt;Catalog&lt;&lt;
&gt;&gt;catalogue&lt;&lt;
&gt;&gt;CATALOG&lt;&lt;
</pre>
<p>Oracle Database SQL syntax:</p>
<pre>
SQL&gt; ALTER SESSION SET NLS_SORT='GENERIC_M_CI';
SQL&gt; SELECT col FROM test WHERE REGEXP_LIKE(col,'catalog(ue)?');
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG783"></a><a id="sthref494"></a>Example 5-13 Case Insensitivity Overridden by the Runtime Match Option</p>
<pre>
Expression: catalog(ue)?
NLS_SORT: GENERIC_M_CI
Match option: 'c'
Matches:
</pre>
<pre>
&gt;&gt;catalogue&lt;&lt;
</pre>
<pre>
Does not match: 
</pre>
<pre>
Catalog
CATALOG
</pre>
<p>Oracle Database SQL syntax:</p>
<pre>
SQL&gt; ALTER SESSION SET NLS_SORT='GENERIC_M_CI';
SQL&gt; SELECT col FROM test WHERE REGEXP_LIKE(col,'catalog(ue)?','c');
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG784"></a><a id="sthref495"></a>Example 5-14 Matching with the Collation Element Operator [..]</p>
<pre>
Expression: [^-a-[.ch.]]+  /*with NLS_SORT set to xspanish*/
Matches: 
</pre>
<pre>
&gt;&gt;driver&lt;&lt;
</pre>
<pre>
Does not match:
</pre>
<pre>
cab
</pre>
<p>Oracle Database SQL syntax:</p>
<pre>
SQL&gt; SELECT col FROM test WHERE REGEXP_LIKE(col,'[^-a-[.ch.]]+');
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG785"></a><a id="sthref496"></a>Example 5-15 Matching with the Character Class Operator [::]</p>
<p>This expression looks for 6-character strings with lowercase characters. Note that accented characters are matched as lowercase characters.</p>
<pre>
Expression: [[:lower:]]{6}
Database character set: WE8ISO8859P1
Matches:
</pre>
<pre>
&gt;&gt;ma&icirc;tre&lt;&lt;
&gt;&gt;m&ograve;bile&lt;&lt;
&gt;&gt;p&aacute;jaro&lt;&lt;
&gt;&gt;zur&uuml;ck&lt;&lt;
</pre>
<p>Oracle Database SQL syntax:</p>
<pre>
SQL&gt; SELECT col FROM test WHERE REGEXP_LIKE(col,'[[:lower:]]{6}');
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG786"></a><a id="sthref497"></a>Example 5-16 Matching with the Base Letter Operator [==]</p>
<pre>
Expression: r[[=e=]]sum[[=e=]]
Matches:
</pre>
<pre>
&gt;&gt;resume&lt;&lt;
&gt;&gt;r&eacute;sum&eacute;&lt;&lt;
&gt;&gt;r&eacute;sume&lt;&lt;
&gt;&gt;resum&eacute;&lt;&lt;
</pre>
<p>Oracle Database SQL syntax:</p>
<pre>
SQL&gt; SELECT col FROM test WHERE REGEXP_LIKE(col,'r[[=e=]]sum[[=e=]]');
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for more information about regular expression syntax</p>
</li>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about <code>REGEX</code> SQL functions</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1904">
<tr>
<td class="cellalignment1911">
<table class="cellalignment1909">
<tr>
<td class="cellalignment1908"><a href="ch4datetime.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1908"><a href="ch6unicode.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1913">
<table class="cellalignment1907">
<tr>
<td class="cellalignment1908"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1908"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1908"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1908"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1908"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1908"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
