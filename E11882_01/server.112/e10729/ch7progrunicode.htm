<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Programming with Unicode</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 070" />
<meta name="dcterms.created" content="2013-07-05T0:14:28Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Globalization Support Guide" />
<meta name="dcterms.identifier" content="E10729-08" />
<meta name="dcterms.isVersionOf" content="NLSPG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="ch6unicode.htm" title="Previous" type="text/html" />
<link rel="Next" href="ch8gdk.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e10729.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/21</span> <!-- End Header --><a id="g1022957"></a><a id="NLSPG007"></a><a id="i1005901"></a>
<h1 class="chapter"><span class="secnum">7</span> Programming with Unicode</h1>
<p>This chapter describes how to use programming and access products for Oracle Database with Unicode. This chapter contains the following topics:</p>
<ul>
<li>
<p><a href="#i1005929">Overview of Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006019">SQL and PL/SQL Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006356">OCI Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006721">Pro*C/C++ Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006858">JDBC Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1008646">ODBC and OLE DB Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1007741">XML Programming with Unicode</a></p>
</li>
</ul>
<a id="i1005929"></a><a id="NLSPG0072"></a>
<div class="sect1">
<h2 class="sect1">Overview of Programming with Unicode</h2>
<p><a id="sthref562"></a>Oracle offers several database access products for inserting and retrieving Unicode data. Oracle offers database access products for commonly used programming environments such as Java and C/C++. Data is transparently converted between the database and client programs, which ensures that client programs are independent of the database character set and national character set. In addition, client programs are sometimes even independent of the character data type, such as <code>NCHAR</code> or <code>CHAR</code>, used in the database.</p>
<p>To avoid overloading the database server with data conversion operations, Oracle always tries to move them to the client side database access products. In a few cases, data must be converted in the database, which affects performance. This chapter discusses details of the data conversion paths.</p>
<a id="i1005934"></a><a id="NLSPG334"></a>
<div class="sect2">
<h3 class="sect2">Database Access Product Stack and Unicode</h3>
<p>Oracle offers a comprehensive set of database access products that enable programs from different development environments to access Unicode data stored in the database. These products are listed in <a href="#CACBBCAG">Table 7-1</a>.</p>
<div class="tblformal">
<p class="titleintable"><a id="NLSPG800"></a><a id="sthref563"></a><a id="CACBBCAG"></a>Table 7-1 Oracle Database Access Products</p>
<table class="cellalignment1916" title="Oracle Database Access Products " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t2">Programming Environment</th>
<th class="cellalignment1915" id="r1c2-t2">Oracle Database Access Products</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t2" headers="r1c1-t2">
<p>C/C++</p>
</td>
<td class="cellalignment1911" headers="r2c1-t2 r1c2-t2">
<p>Oracle Call Interface (OCI) Oracle Pro*C/C++ Oracle ODBC driver Oracle Provider for OLE DB Oracle Data Provider for .NET</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t2" headers="r1c1-t2">
<p>Java</p>
</td>
<td class="cellalignment1911" headers="r3c1-t2 r1c2-t2">
<p>Oracle JDBC OCI or thin driver Oracle server-side thin driver Oracle server-side internal driver</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t2" headers="r1c1-t2">
<p>PL/SQL</p>
</td>
<td class="cellalignment1911" headers="r4c1-t2 r1c2-t2">
<p>Oracle PL/SQL and SQL</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t2" headers="r1c1-t2">
<p>Visual Basic/C#</p>
</td>
<td class="cellalignment1911" headers="r5c1-t2 r1c2-t2">
<p>Oracle ODBC driver Oracle Provider for OLE DB</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p><a href="#i1005974">Figure 7-1</a> shows how the database access products can access the database.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1005974"></a><a id="NLSPG801"></a>Figure 7-1 Oracle Database Access Products</p>
<img width="600" height="262" src="img/nlspg024.gif" alt="Description of Figure 7-1 follows" /><br />
<a id="sthref564" href="./img_text/nlspg024.htm">Description of "Figure 7-1 Oracle Database Access Products "</a><br />
<br /></div>
<!-- class="figure" -->
<p>The <a id="sthref565"></a><a id="sthref566"></a><a id="sthref567"></a>Oracle Call Interface (OCI) is the lowest level API that the rest of the client-side database access products use. It provides a flexible way for C/C++ programs to access Unicode data stored in SQL <code>CHAR</code> and <code>NCHAR</code> data types. Using OCI, you can programmatically specify the character set (UTF-8, UTF-16, and others) for the data to be inserted or retrieved. It accesses the database through Oracle Net.</p>
<p><a id="sthref568"></a><a id="sthref569"></a>Oracle Pro*C/C++ enables you to embed SQL and PL/SQL in your programs. It uses OCI's Unicode capabilities to provide UTF-16 and UTF-8 data access for SQL <code>CHAR</code> and <code>NCHAR</code> data types.</p>
<p>The <a id="sthref570"></a><a id="sthref571"></a>Oracle ODBC driver enables C/C++, Visual Basic, and VBScript programs running on Windows platforms to access Unicode data stored in SQL <code>CHAR</code> and <code>NCHAR</code> data types of the database. It provides UTF-16 data access by implementing the <code>SQLWCHAR</code> interface specified in the ODBC standard specification.</p>
<p>The <a id="sthref572"></a><a id="sthref573"></a>Oracle Provider for OLE DB enables C/C++, Visual Basic, and VBScript programs running on Windows platforms to access Unicode data stored in SQL <code>CHAR</code> and <code>NCHAR</code> data types. It provides UTF-16 data access through wide string OLE DB data types.</p>
<p>The <a id="sthref574"></a><a id="sthref575"></a>Oracle Data Provider for .NET enables programs running in any .NET programming environment on Windows platforms to access Unicode data stored in SQL <code>CHAR</code> and <code>NCHAR</code> data types. It provides UTF-16 data access through Unicode data types.</p>
<p>Oracle JDBC drivers are the primary Java programmatic interface for accessing an Oracle database. Oracle provides the following JDBC drivers:</p>
<ul>
<li>
<p>The <a id="sthref576"></a><a id="sthref577"></a>JDBC OCI driver that is used by Java applications and requires the OCI library</p>
</li>
<li>
<p>The <a id="sthref578"></a><a id="sthref579"></a>JDBC thin driver, which is a pure Java driver that is primarily used by Java applets and supports the Oracle Net protocol over TCP/IP</p>
</li>
<li>
<p>The<a id="sthref580"></a><a id="sthref581"></a> JDBC server-side thin driver, a pure Java driver used inside Java stored procedures to connect to another Oracle server</p>
</li>
<li>
<p>The <a id="sthref582"></a><a id="sthref583"></a>JDBC server-side internal driver that is used inside the Oracle server to access the data in the database</p>
</li>
</ul>
<p>All drivers support Unicode data access to SQL <code>CHAR</code> and <code>NCHAR</code> data types in the database.</p>
<p>The <a id="sthref584"></a><a id="sthref585"></a>PL/SQL and SQL engines process PL/SQL programs and SQL statements on behalf of client-side programs such as OCI and server-side PL/SQL stored procedures. They allow PL/SQL programs to declare <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, and <code>NVARCHAR2</code> variables and to access SQL <code>CHAR</code> and <code>NCHAR</code> data types in the database.</p>
<p>The following sections describe how each of the database access products supports Unicode data access to an Oracle database and offer examples for using those products:</p>
<ul>
<li>
<p><a href="#i1006019">SQL and PL/SQL Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006356">OCI Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006721">Pro*C/C++ Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1006858">JDBC Programming with Unicode</a></p>
</li>
<li>
<p><a href="#i1008646">ODBC and OLE DB Programming with Unicode</a></p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006019"></a><a id="NLSPG0073"></a>
<div class="sect1">
<h2 class="sect1">SQL and PL/SQL Programming with Unicode</h2>
<p>SQL is the fundamental language with which all programs and users access data in an Oracle database either directly or indirectly. PL/SQL is a procedural language that combines the data manipulating power of SQL with the data processing power of procedural languages. Both SQL and PL/SQL can be embedded in other programming languages. This section describes Unicode-related features in SQL and PL/SQL that you can deploy for multilingual applications.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006072">SQL NCHAR Data Types</a></p>
</li>
<li>
<p><a href="#i1006129">Implicit Data Type Conversion Between NCHAR and Other Data Types</a></p>
</li>
<li>
<p><a href="#i1006145">Exception Handling for Data Loss During Data Type Conversion</a></p>
</li>
<li>
<p><a href="#i1006150">Rules for Implicit Data Type Conversion</a></p>
</li>
<li>
<p><a href="#i1006233">SQL Functions for Unicode Data Types</a></p>
</li>
<li>
<p><a href="#i1006279">Other SQL Functions</a></p>
</li>
<li>
<p><a href="#i1006315">Unicode String Literals</a></p>
</li>
<li>
<p><a href="#CACIDIFA">Using the UTL_FILE Package with NCHAR Data</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></p>
</li>
<li>
<p><a class="olink LNPLS" href="../../appdev.112/e25519/toc.htm"><span class="italic">Oracle Database PL/SQL Language Reference</span></a></p>
</li>
</ul>
</div>
</li>
</ul>
<a id="i1006072"></a><a id="NLSPG0071"></a>
<div class="sect2">
<h3 class="sect2">SQL NCHAR Data Types</h3>
<p>There are three SQL <code>NCHAR</code> data types:</p>
<ul>
<li>
<p><a href="#i1006087">The NCHAR Data Type</a></p>
</li>
<li>
<p><a href="#i1006105">The NVARCHAR2 Data Type</a></p>
</li>
<li>
<p><a href="#i1006114">The NCLOB Data Type</a></p>
</li>
</ul>
<a id="i1006087"></a><a id="NLSPG335"></a>
<div class="sect3">
<h4 class="sect3">The NCHAR Data Type</h4>
<p>When you define a table column or a PL/SQL variable as the <code><a id="sthref586"></a>NCHAR</code> data type, the length is always specified as the number of characters. For example, the following statement creates a column with a maximum length of 30 characters:</p>
<pre>
CREATE TABLE table1 (column1 NCHAR(30)); 
</pre>
<p>The maximum number of bytes for the column is determined as follows:</p>
<pre>
maximum number of bytes = (maximum number of characters) x (maximum number of bytes for each character)
</pre>
<p>For example, if the national character set is UTF8, then the maximum byte length is 30 characters times 3 bytes for each character, or 90 bytes.</p>
<p>The national character set, which is used for all <code>NCHAR</code> data types, is defined when the database is created. The national character set can be either UTF8 or AL16UTF16. The default is AL16UTF16.<a id="sthref587"></a><a id="sthref588"></a></p>
<p>The maximum column size allowed is 2000 characters when the national character set is UTF8 and 1000 when it is AL16UTF16. The actual data is subject to the maximum byte limit of 2000. The two size constraints must be satisfied at the same time. In PL/SQL, the maximum length of <code>NCHAR</code> data is 32767 bytes. You can define an <code>NCHAR</code> variable of up to 32767 characters, but the actual data cannot exceed 32767 bytes. If you insert a value that is shorter than the column length, then Oracle pads the value with blanks to whichever length is smaller: maximum character length or maximum byte length.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
UTF8 may affect performance because it is a variable-width character set. Excessive blank padding of <code>NCHAR</code> fields decreases performance. Consider using the <code>NVARCHAR</code> data type or changing to the AL16UTF16 character set for the <code>NCHAR</code> data type.</div>
</div>
<!-- class="sect3" -->
<a id="i1006105"></a><a id="NLSPG336"></a>
<div class="sect3">
<h4 class="sect3">The NVARCHAR2 Data Type</h4>
<p>The <code><a id="sthref589"></a>NVARCHAR2</code> data type specifies a variable length character string that uses the national character set<a id="sthref590"></a><a id="sthref591"></a>. When you create a table with an <code>NVARCHAR2</code> column, you specify the maximum number of characters for the column. Lengths for <code>NVARCHAR2</code> are always in units of characters, just as for <code>NCHAR</code>. Oracle subsequently stores each value in the column exactly as you specify it, if the value does not exceed the column's maximum length. Oracle does not pad the string value to the maximum length.</p>
<p>The maximum column size allowed is 4000 characters when the national character set is UTF8 and 2000 when it is AL16UTF16. The maximum length of an <code>NVARCHAR2</code> column in bytes is 4000. Both the byte limit and the character limit must be met, so the maximum number of characters that is actually allowed in an <code>NVARCHAR2</code> column is the number of characters that can be written in 4000 bytes.</p>
<p>In PL/SQL, the maximum length for an <code>NVARCHAR2</code> variable is 32767 bytes. You can define <code>NVARCHAR2</code> variables up to 32767 characters, but the actual data cannot exceed 32767 bytes.</p>
<p>The following statement creates a table with one <code>NVARCHAR2</code> column whose maximum length in characters is 2000 and maximum length in bytes is 4000.</p>
<pre>
CREATE TABLE table2 (column2 NVARCHAR2(2000)); 
</pre></div>
<!-- class="sect3" -->
<a id="i1006114"></a><a id="NLSPG337"></a>
<div class="sect3">
<h4 class="sect3">The <a id="sthref592"></a>NCLOB Data Type</h4>
<p><code>NCLOB</code> is a character large object containing Unicode characters, with a maximum size of 4 gigabytes. Unlike the <code>BLOB</code> data type, the <code>NCLOB</code> data type has full transactional support so that changes made through SQL, the <code>DBMS_LOB</code> package, or OCI participate fully in transactions. Manipulations of <code>NCLOB</code> value can be committed and rolled back. Note, however, that you cannot save an <code>NCLOB</code> locator in a PL/SQL or OCI variable in one transaction and then use it in another transaction or session.</p>
<p><code>NCLOB</code> values are stored in the database in a format that is compatible with UCS-2, regardless of the national character set. Oracle translates the stored Unicode value to the character set requested on the client or on the server, which can be fixed-width or variable-width. When you insert data into an <code>NCLOB</code> column using a variable-width character set, Oracle converts the data into a format that is compatible with UCS-2 before storing it in the database.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for more information about the <code>NCLOB</code> data type</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006129"></a><a id="NLSPG338"></a>
<div class="sect2">
<h3 class="sect2">Implicit Data Type Conversion Between NCHAR and Other Data Types</h3>
<p>Oracle supports implicit conversions between SQL <code>NCHAR</code> data types and other Oracle data types, such as <code>CHAR</code>, <code>VARCHAR2</code>, <code>NUMBER</code>, <code>DATE</code>, <code>ROWID</code>, and <code>CLOB</code>. Any implicit conversions for <code>CHAR</code> and <code>VARCHAR2</code> data types are also supported for SQL <code>NCHAR</code> data types. You can use SQL <code>NCHAR</code> data types the same way as SQL <code>CHAR</code> data types.</p>
<p>Type conversions between SQL <code>CHAR</code> data types and SQL <code>NCHAR</code> data types may involve character set conversion when the database and national character sets are different. Padding with blanks may occur if the target data is either <code>CHAR</code> or <code>NCHAR</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1006145"></a><a id="NLSPG339"></a>
<div class="sect2">
<h3 class="sect2">Exception Handling for Data Loss During Data Type Conversion</h3>
<p>Data loss can occur during<a id="sthref593"></a><a id="sthref594"></a> data type conversion when character set conversion is necessary. If a character in the source character set is not defined in the target character set, then a replacement character is used in its place. For example, if you try to insert <code>NCHAR</code> data into a regular <code>CHAR</code> column and the character data in <code>NCHAR</code> (Unicode) form cannot be converted to the database character set, then the character is replaced by a replacement character defined by the database character set. The <code>NLS_NCHAR_CONV_EXCP</code> initialization parameter controls the behavior of data loss during character type conversion. When this parameter is set to <code>TRUE</code>, any SQL statements that result in data loss return an <code>ORA-12713</code> error and the corresponding operation is stopped. When this parameter is set to <code>FALSE</code>, data loss is not reported and the unconvertible characters are replaced with replacement characters. The default value is <code>FALSE</code>. This parameter works for both implicit and explicit conversion.</p>
<p>In PL/SQL, when data loss occurs during conversion of SQL <code>CHAR</code> and <code>NCHAR</code> data types, the <code>LOSSY_CHARSET_CONVERSION</code> exception is raised for both implicit and explicit conversion.</p>
</div>
<!-- class="sect2" -->
<a id="i1006150"></a><a id="NLSPG340"></a>
<div class="sect2">
<h3 class="sect2">Rules for Implicit Data Type Conversion</h3>
<p>In some <a id="sthref595"></a><a id="sthref596"></a>cases, conversion between data types is possible in only one direction. In other cases, conversion in both directions is possible. Oracle defines a set of rules for conversion between data types. <a href="#g1010142">Table 7-2</a> contains the rules for conversion between data types.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG802"></a><a id="sthref597"></a><a id="g1010142"></a>Table 7-2 Rules for Conversion Between Data Types</p>
<table class="cellalignment1914" title="Rules for Conversion Between Data Types" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t7">Statement</th>
<th class="cellalignment1915" id="r1c2-t7">Rule</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t7" headers="r1c1-t7">
<p><code>INSERT</code>/<code>UPDATE</code> statement</p>
</td>
<td class="cellalignment1911" headers="r2c1-t7 r1c2-t7">
<p>Values are converted to the data type of the target database column.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t7" headers="r1c1-t7">
<p><code>SELECT</code> <code>INTO</code> statement</p>
</td>
<td class="cellalignment1911" headers="r3c1-t7 r1c2-t7">
<p>Data from the database is converted to the data type of the target variable.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t7" headers="r1c1-t7">
<p>Variable assignments</p>
</td>
<td class="cellalignment1911" headers="r4c1-t7 r1c2-t7">
<p>Values on the right of the equal sign are converted to the data type of the target variable on the left of the equal sign.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t7" headers="r1c1-t7">
<p>Parameters in SQL and PL/SQL functions</p>
</td>
<td class="cellalignment1911" headers="r5c1-t7 r1c2-t7">
<p><code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code>, and <code>NVARCHAR2</code> are loaded the same way. An argument with a <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code> or <code>NVARCHAR2</code> data type is compared to a formal parameter of any of the <code>CHAR</code>, <code>VARCHAR2</code>, <code>NCHAR</code> or <code>NVARCHAR2</code> data types. If the argument and formal parameter data types do not match exactly, then implicit conversions are introduced when data is copied into the parameter on function entry and copied out to the argument on function exit.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r6c1-t7" headers="r1c1-t7">
<p>Concatenation || operation or <code>CONCAT</code> function</p>
</td>
<td class="cellalignment1911" headers="r6c1-t7 r1c2-t7">
<p>If one operand is a SQL <code>CHAR</code> or <code>NCHAR</code> data type and the other operand is a <code>NUMBER</code> or other non-character data type, then the other data type is converted to <code>VARCHAR2</code> or <code>NVARCHAR2</code>. For concatenation between character data types, see <a href="#i1006225">"SQL <code>NCHAR</code> data types and SQL <code>CHAR</code> data types"</a>.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r7c1-t7" headers="r1c1-t7">
<p>SQL <code>CHAR</code> or <code>NCHAR</code> data types and <code>NUMBER</code> data type</p>
</td>
<td class="cellalignment1911" headers="r7c1-t7 r1c2-t7">
<p>Character values are converted to <code>NUMBER</code> data type.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r8c1-t7" headers="r1c1-t7">
<p>SQL <code>CHAR</code> or <code>NCHAR</code> data types and <code>DATE</code> data type</p>
</td>
<td class="cellalignment1911" headers="r8c1-t7 r1c2-t7">
<p>Character values are converted to <code>DATE</code> data type.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r9c1-t7" headers="r1c1-t7">
<p>SQL <code>CHAR</code> or <code>NCHAR</code> data types and <code>ROWID</code> data type</p>
</td>
<td class="cellalignment1911" headers="r9c1-t7 r1c2-t7">
<p>Character values are converted to <code>ROWID</code> data type.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r10c1-t7" headers="r1c1-t7">
<p><a id="i1006225"></a>SQL <code>NCHAR</code> data types and SQL <code>CHAR</code> data types</p>
</td>
<td class="cellalignment1911" headers="r10c1-t7 r1c2-t7">
<p>Comparisons between SQL <code>NCHAR</code> data types and SQL <code>CHAR</code> data types are more complex because they can be encoded in different character sets.</p>
<p>When <code>CHAR</code> and <code>VARCHAR2</code> values are compared, the <code>CHAR</code> values are converted to <code>VARCHAR2</code> values.</p>
<p>When <code>NCHAR</code> and <code>NVARCHAR2</code> values are compared, the <code>NCHAR</code> values are converted to <code>NVARCHAR2</code> values.</p>
<p>When there is comparison between SQL <code>NCHAR</code> data types and SQL <code>CHAR</code> data types, character set conversion occurs if they are encoded in different character sets. The character set for SQL <code>NCHAR</code> data types is always Unicode and can be either UTF8 or AL16UTF16 encoding, which have the same character repertoires but are different encodings of the Unicode standard. SQL <code>CHAR</code> data types use the database character set, which can be any character set that Oracle supports. Unicode is a superset of any character set supported by Oracle, so SQL <code>CHAR</code> data types can always be converted to SQL <code>NCHAR</code> data types without data loss.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect2" -->
<a id="i1006233"></a><a id="NLSPG341"></a>
<div class="sect2">
<h3 class="sect2">SQL Functions <a id="sthref598"></a><a id="sthref599"></a>for Unicode Data Types</h3>
<p>SQL <code>NCHAR</code> data types can be converted to and from SQL <code>CHAR</code> data types and other data types using explicit conversion functions. The examples in this section use the table created by the following statement:</p>
<pre>
CREATE TABLE customers 
  (id NUMBER, name NVARCHAR2(50), address NVARCHAR2(200), birthdate DATE);
</pre>
<div class="example">
<p class="titleinexample"><a id="i1006239"></a><a id="NLSPG803"></a>Example 7-1 Populating the Customers Table Using the TO_NCHAR Function</p>
<p>The <code><a id="sthref600"></a><a id="sthref601"></a>TO_NCHAR</code> function converts the data at run time, while the <code>N</code> function converts the data at compilation time.</p>
<pre>
INSERT INTO customers VALUES (1000, 
  TO_NCHAR('John Smith'),N'500 Oracle Parkway',sysdate);
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG804"></a><a id="sthref602"></a>Example 7-2 Selecting from the Customer Table Using the TO_CHAR Function</p>
<p>The following statement converts the values of <code>name</code> from characters in the national character set to characters in the database character set before selecting them according to the <code>LIKE</code> clause:</p>
<pre>
SELECT name FROM customers WHERE TO_CHAR(name) LIKE '%Sm%';
</pre>
<p>You should see the following output:</p>
<pre>
NAME
--------------------------------------
John Smith
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="CACIACHB"></a><a id="NLSPG805"></a>Example 7-3 Selecting from the Customer Table Using the TO_DATE Function</p>
<p>Using the <code><a id="sthref603"></a><a id="sthref604"></a>N</code> function shows that either <code>NCHAR</code> or <code>CHAR</code> data can be passed as parameters for the <code><a id="sthref605"></a><a id="sthref606"></a>TO_DATE</code> function. The data types can mixed because they are converted at run time.</p>
<pre>
DECLARE
ndatestring NVARCHAR2(20) := N'12-SEP-1975';
ndstr NVARCHAR2(50);
BEGIN
SELECT name INTO ndstr FROM customers
WHERE (birthdate)&gt; TO_DATE(ndatestring, 'DD-MON-YYYY', N'NLS_DATE_LANGUAGE =
AMERICAN');
END;
</pre>
<p>As demonstrated in <a href="#CACIACHB">Example 7-3</a>, SQL <code>NCHAR</code> data can be passed to explicit conversion functions. SQL <code>CHAR</code> and <code>NCHAR</code> data can be mixed together when using multiple string parameters.</p>
</div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about explicit conversion functions for SQL <code>NCHAR</code> data types</div>
</div>
<!-- class="sect2" -->
<a id="i1006279"></a><a id="NLSPG342"></a>
<div class="sect2">
<h3 class="sect2">Other SQL Functions</h3>
<p>Most SQL functions can take arguments of SQL <code>NCHAR</code> data types as well as mixed character data types. The return data type is based on the type of the first argument. If a non-string data type like <code>NUMBER</code> or <code>DATE</code> is passed to these functions, then it is converted to <code>VARCHAR2</code>. The following examples use the <code>customer</code> table created in <a href="#i1006233">"SQL Functions for Unicode Data Types"</a>.</p>
<div class="example">
<p class="titleinexample"><a id="NLSPG806"></a><a id="sthref607"></a>Example 7-4 INSTR Function</p>
<p>In this example, the string literal <code>'Sm'</code> is converted to <code>NVARCHAR2</code> and then scanned by <code>INSTR</code>, to detect the position of the first occurrence of this string in <code>name</code>.</p>
<pre>
<a id="sthref608"></a><a id="sthref609"></a>SELECT INSTR(name, N'Sm', 1, 1) FROM customers;
</pre></div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG807"></a><a id="sthref610"></a>Example 7-5 CONCAT Function</p>
<pre>
SELECT CONCAT(name,id) FROM customers;
</pre>
<p><code>id</code> is converted to <code>NVARCHAR2</code> and then concatenated with <code>name</code>.</p>
</div>
<!-- class="example" -->
<div class="example">
<p class="titleinexample"><a id="NLSPG808"></a><a id="sthref611"></a>Example 7-6 RPAD Function</p>
<pre>
<a id="sthref612"></a><a id="sthref613"></a>SELECT RPAD(name,100,' ') FROM customers;
</pre>
<p>The following output results:</p>
<pre>
RPAD(NAME,100,'')
------------------------------------------
John Smith
</pre>
<p>The space character ' ' is converted to the corresponding character in the <code>NCHAR</code> character set and then padded to the right of <code>name</code> until the total display length reaches 100.</p>
</div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1006315"></a><a id="NLSPG343"></a>
<div class="sect2">
<h3 class="sect2">Unicode String Literals</h3>
<p>You can input <a id="sthref614"></a><a id="sthref615"></a>Unicode string literals in SQL and PL/SQL as follows:</p>
<ul>
<li>
<p>Put a prefix <code>N</code> before a string literal that is enclosed with single quote marks. This explicitly indicates that the following string literal is an <code>NCHAR</code> string literal. For example, <code>N'r&eacute;sum&eacute;'</code> is an <code>NCHAR</code> string literal. For information about limitations of this method, see <a href="#CACHHIFE">"NCHAR String Literal Replacement"</a>.</p>
</li>
<li>
<p>Use the <code><a id="sthref616"></a><a id="sthref617"></a>NCHR(</code><code><span class="codeinlineitalic">n</span></code><code>)</code> SQL function, which returns a unit of character code in the national character set, which is AL16UTF16 or UTF8. The result of concatenating several <code>NCHR(</code><code><span class="codeinlineitalic">n</span></code><code>)</code> functions is <code>NVARCHAR2</code> data. In this way, you can bypass the client and server character set conversions and create an <code>NVARCHAR2</code> string directly. For example, <code>NCHR(32)</code> represents a blank character.</p>
<p>Because <code>NCHR(</code><code><span class="codeinlineitalic">n</span></code><code>)</code> is associated with the national character set, portability of the resulting value is limited to applications that run with the same national character set. If this is a concern, then use the <code>UNISTR</code> function to remove portability limitations.</p>
</li>
<li>
<p>Use the <code><a id="sthref618"></a><a id="sthref619"></a>UNISTR</code>('<code><span class="codeinlineitalic">string'</span></code>) SQL function. <code>UNISTR</code>('<code><span class="codeinlineitalic">string'</span></code>) converts a string to the national character set. To ensure portability and to preserve data, include only ASCII characters and Unicode encoding in the following form: <code>\xxxx</code>, where <code>xxxx</code> is the hexadecimal value of a character code value in UTF-16 encoding format. For example, <code>UNISTR('G\0061ry')</code> represents <code>'Gary'</code>. The ASCII characters are converted to the database character set and then to the national character set. The Unicode encoding is converted directly to the national character set.</p>
</li>
</ul>
<p>The last two methods can be used to encode any Unicode string literals.</p>
</div>
<!-- class="sect2" -->
<a id="CACHHIFE"></a><a id="NLSPG344"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">NCHAR String Literal Replacement</h3>
<p>This section provides information on how to avoid data loss when performing <code>NCHAR</code> string literal replacement.</p>
<p>Being part of a SQL or PL/SQL statement, the text of any literal, with or without the prefix <code>N</code>, is encoded in the same character set as the rest of the statement. On the client side, the statement is in the client character set, which is determined by the client character set defined in <code>NLS_LANG</code>, or specified in the <code>OCIEnvNlsCreate()</code> call, or predefined as UTF-16 in JDBC. On the server side, the statement is in the database character set.</p>
<ul>
<li>
<p>When the SQL or PL/SQL statement is transferred from client to the database server, its character set is converted accordingly. It is important to note that if the database character set does not contain all characters used in the text literals, then the data is lost in this conversion. This problem affects <code>NCHAR</code> string literals more than the <code>CHAR</code> text literals. This is because the <code>N'</code> literals are designed to be independent of the database charactser set, and should be able to provide any data that the client character set supports.</p>
<p>To avoid data loss in conversion to an incompatible database character set, you can activate the <code>NCHAR</code> literal replacement functionality. The functionality transparently replaces the <code>N'</code> literals on the client side with an internal format. The database server then decodes this to Unicode when the statement is executed.</p>
</li>
<li>
<p>The sections <a href="#CACCJIEH">"Handling SQL NCHAR String Literals in OCI"</a> and <a href="#CHDCBACA">"Using SQL NCHAR String Literals in JDBC"</a> show how to switch on the replacement functionality in OCI and JDBC, respectively. Because many applications, for example, SQL*Plus, use OCI to connect to a database, and they do not control <code>NCHAR</code> literal replacement explicitly, you can set the client environment variable <code>ORA_NCHAR_LITERAL_REPLACE</code> to <code>TRUE</code> to control the functionality for them. By default, the functionality is switched off to maintain backward compatibility.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACIDIFA"></a><a id="NLSPG345"></a>
<div class="sect2">
<h3 class="sect2">Using the UTL_FILE Package with NCHAR Data</h3>
<p>The <code><a id="sthref620"></a>UTL_FILE</code> package handles Unicode national character set data of the <code>NVARCHAR2</code> data type. <code>NCHAR</code> and <code>NCLOB</code> are supported through implicit conversion. The functions and procedures include the following:</p>
<ul>
<li>
<p><code>FOPEN_NCHAR</code></p>
<p>This function opens a file in national character set mode for input or output, with the maximum line size specified. Even though the contents of an <code>NVARCHAR2</code> buffer may be AL16UTF16 or UTF8 (depending on the national character set of the database), the contents of the file are always read and written in UTF8. See <a href="ch6unicode.htm#i1006865">"Support for Unicode in Oracle Database"</a> for more information. <code>UTL_FILE</code> converts between UTF8 and AL16UTF16 as necessary.</p>
</li>
<li>
<p><code>GET_LINE_NCHAR</code></p>
<p>This procedure reads text from the open file identified by the file handle and places the text in the output buffer parameter. The file must be opened in national character set mode, and must be encoded in the UTF8 character set. The expected buffer data type is <code>NVARCHAR2</code>. If a variable of another data type, such as <code>NCHAR</code>, <code>NCLOB</code>, or <code>VARCHAR2</code> is specified, PL/SQL performs standard implicit conversion from <code>NVARCHAR2</code> after the text is read.</p>
</li>
<li>
<p><code>PUT_NCHAR</code></p>
<p>This procedure writes the text string stored in the buffer parameter to the open file identified by the file handle. The file must be opened in the national character set mode. The text string will be written in the UTF8 character set. The expected buffer data type is <code>NVARCHAR2</code>. If a variable of another data type is specified, PL/SQL performs implicit conversion to <code>NVARCHAR2</code> before writing the text.</p>
</li>
<li>
<p><code>PUT_LINE_NCHAR</code></p>
<p>This procedure is equivalent to <code>PUT_NCHAR</code>, except that the line separator is appended to the written text.</p>
</li>
<li>
<p><code>PUTF_NCHAR</code></p>
<p>This procedure is a formatted version of a <code>PUT_NCHAR</code> procedure. It accepts a format string with formatting elements \n and %s, and up to five arguments to be substituted for consecutive instances of %s in the format string. The expected data type of the format string and the arguments is <code>NVARCHAR2</code>. If variables of another data type are specified, PL/SQL performs implicit conversion to <code>NVARCHAR2</code> before formatting the text. Formatted text is written in the UTF8 character set to the file identified by the file handle. The file must be opened in the national character set mode.</p>
</li>
</ul>
<p>The above functions and procedures process text files encoded in the UTF8 character set, that is, in the Unicode CESU-8 encoding. See <a href="applocaledata.htm#i636713">"Universal Character Sets"</a> for more information about CESU-8. The functions and procedures convert between UTF8 and the national character set of the database, which can be UTF8 or AL16UTF16, as needed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>UTL_FILE</code> package</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006356"></a><a id="NLSPG0074"></a>
<div class="sect1">
<h2 class="sect1">OCI Programming with Unicode</h2>
<p><a id="i1006358"></a>OCI is the lowest-level API for accessing a database, so it offers the best possible performance. When using Unicode with OCI, consider these topics:</p>
<ul>
<li>
<p><a href="#i1006392">OCIEnvNlsCreate() Function for Unicode Programming</a></p>
</li>
<li>
<p><a href="#i1006452">OCI Unicode Code Conversion</a></p>
</li>
<li>
<p><a href="#CACCBHDG">Setting UTF-8 to the NLS_LANG Character Set in OCI</a></p>
</li>
<li>
<p><a href="#i1006619">Binding and Defining SQL CHAR Data Types in OCI</a></p>
</li>
<li>
<p><a href="#CACGCEAI">Binding and Defining SQL NCHAR Data Types in OCI</a></p>
</li>
<li>
<p><a href="#i1006698">Binding and Defining CLOB and NCLOB Unicode Data in OCI</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch10oci.htm#g1012464">Chapter 10, "OCI Programming in a Global Environment"</a></div>
</li>
</ul>
<a id="i1006392"></a><a id="NLSPG346"></a>
<div class="sect2">
<h3 class="sect2">OCIEnvNlsCreate() Function for Unicode Programming</h3>
<p>The <code><a id="sthref621"></a>OCIEnvNlsCreate()</code> function is used to specify a SQL <code>CHAR</code> character set and a SQL <code>NCHAR</code> character set when the OCI environment is created. It is an enhanced version of the <code>OCIEnvCreate()</code> function and has extended arguments for two character set IDs. The <a id="sthref622"></a>OCI_UTF16ID UTF-16 character set ID replaces the <a id="sthref623"></a>Unicode mode introduced in Oracle9<span class="italic">i</span> release 1 (9.0.1). For example:</p>
<pre>
OCIEnv *envhp;
status = OCIEnvNlsCreate((OCIEnv **)&amp;envhp,
(ub4)0,
(void *)0,
(void *(*) ()) 0,
(void *(*) ()) 0,
(void(*) ()) 0,
(size_t) 0,
(void **)0,
(ub2)OCI_UTF16ID, /* Metadata and SQL CHAR character set */
(ub2)OCI_UTF16ID /* SQL NCHAR character set */);
</pre>
<p>The Unicode mode, in which the OCI_UTF16 flag is used with the <code>OCIEnvCreate()</code> function, is deprecated.</p>
<p>When OCI_UTF16ID is specified for both SQL <code>CHAR</code> and SQL <code>NCHAR</code> character sets, all metadata and bound and defined data are encoded in UTF-16. Metadata includes SQL statements, user names, error messages, and column names. Thus, all inherited operations are independent of the <code>NLS_LANG</code> setting, and all metatext data parameters (<code>text*</code>) are assumed to be Unicode text data types (<code>utext*</code>) in UTF-16 encoding.</p>
<p>To prepare the SQL statement when the <code>OCIEnv()</code> function is initialized with the OCI_UTF16ID character set ID, call the <code>OCIStmtPrepare()</code> function with a <code>(utext*)</code> string. The following example runs on the Windows platform only. You may need to change <code>wchar_t</code> data types for other platforms.</p>
<pre>
const wchar_t sqlstr[] = L"SELECT * FROM ENAME=:ename";
...
OCIStmt* stmthp;
sts = OCIHandleAlloc(envh, (void **)&amp;stmthp, OCI_HTYPE_STMT, 0,
NULL);
status = OCIStmtPrepare(stmthp, errhp,(const text*)sqlstr,
wcslen(sqlstr), OCI_NTV_SYNTAX, OCI_DEFAULT);
</pre>
<p>To bind and define data, you do not have to set the <code>OCI_ATTR_CHARSET_ID</code> attribute because the <code>OCIEnv()</code> function has already been initialized with UTF-16 character set IDs. The bind variable names also must be UTF-16 strings.</p>
<pre>
/* Inserting Unicode data */
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (const text*)L":ename",
(sb4)wcslen(L":ename"),
              (void *) ename, sizeof(ename), SQLT_STR, (void
*)&amp;insname_ind,
              (ub2 *) 0, (ub2 *) 0, (ub4) 0, (ub4 *)0,
OCI_DEFAULT);
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *)
&amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp);
...
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
               (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0,
(ub2*)0, (ub4)OCI_DEFAULT);
</pre>
<p>The <code>OCIExecute()</code> function performs the operation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ch10oci.htm#i1005942">"Specifying Character Sets in OCI"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006452"></a><a id="NLSPG347"></a>
<div class="sect2">
<h3 class="sect2">OCI Unicode Code Conversion</h3>
<p>Unicode <a id="sthref624"></a><a id="sthref625"></a>character set conversions take place between an OCI client and the database server if the client and server character sets are different. The conversion occurs on either the client or the server depending on the circumstances, but usually on the client side.</p>
<a id="NLSPG348"></a>
<div class="sect3"><a id="sthref626"></a>
<h4 class="sect3">Data Integrity</h4>
<p>You can <a id="sthref627"></a><a id="sthref628"></a>lose data during conversion if you call an OCI API inappropriately. If the server and client character sets are different, then you can lose data when the destination character set is a smaller set than the source character set. You can avoid this potential problem if both character sets are Unicode character sets (for example, UTF8 and AL16UTF16).</p>
<p>When you bind or define SQL <code>NCHAR</code> data types, you should set the <code><a id="sthref629"></a>OCI_ATTR_CHARSET_FORM</code> attribute to <code>SQLCS_NCHAR</code>. Otherwise, you can lose data because the data is converted to the database character set before converting to or from the national character set. This occurs only if the database character set is not Unicode.</p>
</div>
<!-- class="sect3" -->
<a id="i1006461"></a><a id="NLSPG349"></a>
<div class="sect3">
<h4 class="sect3">OCI Performance Implications When Using Unicode</h4>
<p>Redundant data<a id="sthref630"></a><a id="sthref631"></a> conversions can cause performance degradation in your OCI applications. These conversions occur in two cases:</p>
<ul>
<li>
<p>When you bind or define SQL <code>CHAR</code> data types and set the <code>OCI_ATTR_CHARSET_FORM</code> attribute to <code>SQLCS_NCHAR</code>, data conversions take place from client character set to the national database character set, and from the national character set to the database character set. No data loss is expected, but two conversions happen, even though it requires only one.</p>
</li>
<li>
<p>When you bind or define SQL <code>NCHAR</code> data types and do not set <code>OCI_ATTR_CHARSET_FORM</code>, data conversions take place from client character set to the database character set, and from the database character set to the national database character set. In the worst case, data loss can occur if the database character set is smaller than the client's.</p>
</li>
</ul>
<p>To avoid performance problems, you should always set <code>OCI_ATTR_CHARSET_FORM</code> correctly, based on the data type of the target columns. If you do not know the target data type, then you should set the <code>OCI_ATTR_CHARSET_FORM</code> attribute to <code>SQLCS_NCHAR</code> when binding and defining.</p>
<p><a href="#g1010212">Table 7-3</a> contains information about <a id="sthref632"></a>OCI character set conversions.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG809"></a><a id="sthref633"></a><a id="g1010212"></a>Table 7-3 OCI Character Set Conversions</p>
<table class="cellalignment1914" title="OCI Character Set Conversions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t13">Data Types for OCI Client Buffer</th>
<th class="cellalignment1915" id="r1c2-t13">OCI_ATTR_CHARSET_FORM</th>
<th class="cellalignment1915" id="r1c3-t13">Data Types of the Target Column in the Database</th>
<th class="cellalignment1915" id="r1c4-t13">Conversion Between</th>
<th class="cellalignment1915" id="r1c5-t13">Comments</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t13" headers="r1c1-t13">
<p><code>utext</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t13 r1c2-t13">
<p><code>SQLCS_IMPLICIT</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t13 r1c3-t13">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t13 r1c4-t13">
<p>UTF-16 and database character set in OCI</p>
</td>
<td class="cellalignment1911" headers="r2c1-t13 r1c5-t13">
<p>No unexpected data loss</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t13" headers="r1c1-t13">
<p><code>utext</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t13 r1c2-t13">
<p><code>SQLCS_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t13 r1c3-t13">
<p><code>NCHAR, NVARCHAR2, NCLOB</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t13 r1c4-t13">
<p>UTF-16 and national character set in OCI</p>
</td>
<td class="cellalignment1911" headers="r3c1-t13 r1c5-t13">
<p>No unexpected data loss</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t13" headers="r1c1-t13">
<p><code>utext</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t13 r1c2-t13">
<p><code>SQLCS_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t13 r1c3-t13">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t13 r1c4-t13">
<p>UTF-16 and national character set in OCI</p>
<p>National character set and database character set in database server</p>
</td>
<td class="cellalignment1911" headers="r4c1-t13 r1c5-t13">
<p>No unexpected data loss, but may degrade performance because the conversion goes through the national character set</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t13" headers="r1c1-t13">
<p><code>utext</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t13 r1c2-t13">
<p><code>SQLCS_IMPLICIT</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t13 r1c3-t13">
<p><code>NCHAR, NVARCHAR2, NCLOB</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t13 r1c4-t13">
<p>UTF-16 and database character set in OCI</p>
<p>Database character set and national character set in database server</p>
</td>
<td class="cellalignment1911" headers="r5c1-t13 r1c5-t13">
<p>Data loss may occur if the database character set is not Unicode</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r6c1-t13" headers="r1c1-t13">
<p><code>text</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t13 r1c2-t13">
<p><code>SQLCS_IMPLICIT</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t13 r1c3-t13">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t13 r1c4-t13">
<p><code>NLS_LANG</code> character set and database character set in OCI</p>
</td>
<td class="cellalignment1911" headers="r6c1-t13 r1c5-t13">
<p>No unexpected data loss</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r7c1-t13" headers="r1c1-t13">
<p><code>text</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t13 r1c2-t13">
<p><code>SQLCS_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t13 r1c3-t13">
<p><code>NCHAR, NVARCHAR2, NCLOB</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t13 r1c4-t13">
<p><code>NLS_LANG</code> character set and national character set in OCI</p>
</td>
<td class="cellalignment1911" headers="r7c1-t13 r1c5-t13">
<p>No unexpected data loss</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r8c1-t13" headers="r1c1-t13">
<p><code>text</code></p>
</td>
<td class="cellalignment1911" headers="r8c1-t13 r1c2-t13">
<p><code>SQLCS_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r8c1-t13 r1c3-t13">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r8c1-t13 r1c4-t13">
<p><code>NLS_LANG</code> character set and national character set in OCI</p>
<p>National character set and database character set in database server</p>
</td>
<td class="cellalignment1911" headers="r8c1-t13 r1c5-t13">
<p>No unexpected data loss, but may degrade performance because the conversion goes through the national character set</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r9c1-t13" headers="r1c1-t13">
<p><code>text</code></p>
</td>
<td class="cellalignment1911" headers="r9c1-t13 r1c2-t13">
<p><code>SQLCS_IMPLICIT</code></p>
</td>
<td class="cellalignment1911" headers="r9c1-t13 r1c3-t13">
<p><code>NCHAR, NVARCHAR2, NCLOB</code></p>
</td>
<td class="cellalignment1911" headers="r9c1-t13 r1c4-t13">
<p><code>NLS_LANG</code> character set and database character set in OCI</p>
<p>Database character set and national character set in database server</p>
</td>
<td class="cellalignment1911" headers="r9c1-t13 r1c5-t13">
<p>Data loss may occur because the conversion goes through the database character set</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" -->
<a id="i1006583"></a><a id="NLSPG350"></a>
<div class="sect3">
<h4 class="sect3">OCI Unicode Data Expansion</h4>
<p>Data conversion can result in <a id="sthref634"></a><a id="sthref635"></a>data expansion, which can cause a buffer to overflow. For binding operations, you must set the <code><a id="sthref636"></a>OCI_ATTR_MAXDATA_SIZE</code> attribute to a large enough size to hold the expanded data on the server. If this is difficult to do, then you must consider changing the table schema. For defining operations, client applications must allocate enough buffer space for the expanded data. The size of the buffer should be the maximum length of the expanded data. You can estimate the maximum buffer length with the following calculation:</p>
<ol>
<li>
<p>Get the column data byte size.</p>
</li>
<li>
<p>Multiply it by the maximum number of bytes for each character in the client character set.</p>
</li>
</ol>
<p>This method is the simplest and quickest way, but it may not be accurate and can waste memory. It is applicable to any character set combination. For example, for UTF-16 data binding and defining, the following example calculates the client buffer:</p>
<pre>
ub2 csid = OCI_UTF16ID;
oratext *selstmt = "SELECT ename FROM emp";
counter = 1;
... 
OCIStmtPrepare(stmthp, errhp, selstmt, (ub4)strlen((char*)selstmt),
               OCI_NTV_SYNTAX, OCI_DEFAULT);
OCIStmtExecute ( svchp, stmthp, errhp, (ub4)0, (ub4)0,
                 (CONST OCISnapshot*)0, (OCISnapshot*)0,
                 OCI_DESCRIBE_ONLY);
OCIParamGet(stmthp, OCI_HTYPE_STMT, errhp, &amp;myparam, (ub4)counter);
OCIAttrGet((void*)myparam, (ub4)OCI_DTYPE_PARAM, (void*)&amp;col_width,
           (ub4*)0, (ub4)OCI_ATTR_DATA_SIZE, errhp);
... 
maxenamelen = (col_width + 1) * sizeof(utext);
cbuf = (utext*)malloc(maxenamelen);
...
OCIDefineByPos(stmthp, &amp;dfnp, errhp, (ub4)1, (void *)cbuf,
                (sb4)maxenamelen, SQLT_STR, (void *)0, (ub2 *)0,
                (ub2*)0, (ub4)OCI_DEFAULT);
OCIAttrSet((void *) dfnp, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp);
OCIStmtFetch(stmthp, errhp, 1, OCI_FETCH_NEXT, OCI_DEFAULT);
...
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACCBHDG"></a><a id="NLSPG351"></a>
<div class="sect2">
<h3 class="sect2">Setting UTF-8 to the NLS_LANG Character Set in OCI</h3>
<p>For OCI client applications that support Unicode UTF-8 encoding, use AL32UTF8 to specify the<a id="sthref637"></a><a id="sthref638"></a> <code>NLS_LANG</code> character set, unless the database character set is UTF8. Use UTF8 if the database character set is UTF8.</p>
<p>Do not set <code>NLS_LANG</code> to AL16UTF16, because AL16UTF16 is the national character set for the server. If you need to use UTF-16, then you should specify the client character set to <code>OCI_UTF16ID</code>, using the <code>OCIAttrSet()</code> function when binding or defining data.</p>
</div>
<!-- class="sect2" -->
<a id="i1006619"></a><a id="NLSPG352"></a>
<div class="sect2">
<h3 class="sect2">Binding and Defining SQL CHAR Data Types in OCI</h3>
<p>To specify a <a id="sthref639"></a><a id="sthref640"></a><a id="sthref641"></a>Unicode character set for binding and defining data with SQL <code>CHAR</code> data types, you may need to call the <code>OCIAttrSet()</code> function to set the appropriate character set ID after <code><a id="sthref642"></a>OCIBind()</code> or <code><a id="sthref643"></a>OCIDefine()</code> APIs. There are two typical cases:</p>
<ul>
<li>
<p>Call <code>OCIBind()</code> or <code>OCIDefine()</code> followed by <code>OCIAttrSet</code>() to specify UTF-16 Unicode character set encoding. For example:</p>
<pre>
...
ub2 csid = OCI_UTF16ID;
utext ename[100]; /* enough buffer for ENAME */
... 
/* Inserting Unicode data */ 
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (oratext*)":ENAME",
             (sb4)strlen((char *)":ENAME"), (void *) ename, sizeof(ename),
             SQLT_STR, (void *)&amp;insname_ind, (ub2 *) 0, (ub2 *) 0, (ub4) 0,
             (ub4 *)0, OCI_DEFAULT); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp); 
... 
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename, 
                (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0,
                (ub2*)0, (ub4)OCI_DEFAULT); 
OCIAttrSet((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid,
           (ub4) 0, (ub4)OCI_ATTR_CHARSET_ID, errhp); 
...
</pre>
<p>If bound buffers are of the <code>utext</code> data type, then you should add a cast (<code>text</code>*) when <code>OCIBind()</code> or <code>OCIDefine()</code> is called. The value of the <code>OCI_ATTR_MAXDATA_SIZE</code> attribute is usually determined by the column size of the server character set because this size is only used to allocate temporary buffer space for conversion on the server when you perform binding operations.</p>
</li>
<li>
<p>Call <code>OCIBind()</code> or <code>OCIDefine()</code> with the <code>NLS_LANG</code> character set specified as UTF8 or AL32UTF8.</p>
<p>UTF8 or AL32UTF8 can be set in the <code>NLS_LANG</code> environment variable. You call <code>OCIBind()</code> and <code>OCIDefine()</code> in exactly the same manner as when you are not using Unicode. Set the <code>NLS_LANG</code> environment variable to UTF8 or AL32UTF8 and run the following OCI program:</p>
<pre>
...
oratext ename[100]; /* enough buffer size for ENAME */
... 
/* Inserting Unicode data */ 
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (oratext*)":ENAME",
              (sb4)strlen((char *)":ENAME"), (void *) ename, sizeof(ename),
              SQLT_STR, (void *)&amp;insname_ind, (ub2 *) 0, (ub2 *) 0,
              (ub4) 0, (ub4 *)0, OCI_DEFAULT); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp); 
... 
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
                (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0, (ub2*)0,
                (ub4)OCI_DEFAULT); 
...
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CACGCEAI"></a><a id="NLSPG353"></a>
<div class="sect2">
<h3 class="sect2">Binding and Defining SQL NCHAR Data Types in OCI</h3>
<p><a id="sthref644"></a><a id="sthref645"></a><a id="sthref646"></a>Oracle recommends that you access SQL <code>NCHAR</code> data types using UTF-16 binding or defining when using OCI. Beginning with Oracle9<span class="italic">i</span>, SQL <code>NCHAR</code> data types are Unicode data types with an encoding of either UTF8 or AL16UTF16. To access data in SQL <code>NCHAR</code> data types, set the <code>OCI_ATTR_CHARSET_FORM</code> attribute to <code>SQLCS_NCHAR</code> between binding or defining and execution so that it performs an appropriate data conversion without data loss. The length of data in SQL <code>NCHAR</code> data types is always in the number of Unicode code units.</p>
<p>The following program is a typical example of inserting and fetching data against an <code>NCHAR</code> data column:</p>
<pre>
...
ub2 csid = OCI_UTF16ID;
ub1 cform = SQLCS_NCHAR;
utext ename[100]; /* enough buffer for ENAME */
... 
/* Inserting Unicode data */ 
OCIBindByName(stmthp1, &amp;bnd1p, errhp, (oratext*)":ENAME",
              (sb4)strlen((char *)":ENAME"), (void *) ename,
              sizeof(ename), SQLT_STR, (void *)&amp;insname_ind, (ub2 *) 0,
              (ub2 *) 0, (ub4) 0, (ub4 *)0, OCI_DEFAULT); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;cform, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_FORM, errhp); 
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;csid, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_ID, errhp);
OCIAttrSet((void *) bnd1p, (ub4) OCI_HTYPE_BIND, (void *) &amp;ename_col_len,
           (ub4) 0, (ub4)OCI_ATTR_MAXDATA_SIZE, errhp); 
... 
/* Retrieving Unicode data */
OCIDefineByPos (stmthp2, &amp;dfn1p, errhp, (ub4)1, (void *)ename,
                (sb4)sizeof(ename), SQLT_STR, (void *)0, (ub2 *)0, (ub2*)0,
                (ub4)OCI_DEFAULT); 
OCIAttrSet((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;csid, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_ID, errhp); 
OCIAttrSet((void *) dfn1p, (ub4) OCI_HTYPE_DEFINE, (void *) &amp;cform, (ub4) 0,
           (ub4)OCI_ATTR_CHARSET_FORM, errhp); 
...
</pre></div>
<!-- class="sect2" -->
<a id="CACCJIEH"></a><a id="NLSPG354"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Handling SQL NCHAR String Literals in OCI</h3>
<p>By default, the <code>NCHAR</code> literal replacement is not performed in OCI. (Refer to <a href="#CACHHIFE">"NCHAR String Literal Replacement"</a>.)</p>
<p>You can switch it on by setting the environment variable <code>ORA_NCHAR_LITERAL_REPLACE</code> to <code>TRUE</code>. You can also achieve this behavior programmatically by using the <code>OCI_NCHAR_LITERAL_REPLACE_ON</code> and <code>OCI_NCHAR_LITERAL_REPLACE_OFF</code> modes in <code>OCIEnvCreate()</code> and <code>OCIEnvNlsCreate()</code>. So, for example, <code>OCIEnvCreate(OCI_NCHAR_LITERAL_REPLACE_ON)</code> turns on <code>NCHAR</code> literal replacement, while <code>OCIEnvCreate(OCI_NCHAR_LITERAL_REPLACE_OFF)</code> turns it off.</p>
<p>As an example, consider the following statement:</p>
<pre>
int main(argc, argv)
{
   OCIEnv *envhp;
if (OCIEnvCreate((OCIEnv **) &amp;envhp,
   (ub4)OCI_THREADED|OCI_NCHAR_LITERAL_REPLACE_ON,
   (dvoid *)0, (dvoid * (*)(dvoid *, size_t)) 0,
   (dvoid * (*)(dvoid *, dvoid *, size_t))0,
   (void (*)(dvoid *, dvoid *)) 0,
   (size_t) 0, (dvoid **) 0))
{
  printf("FAILED: OCIEnvCreate()\n";
  return 1;
}
...
}
</pre>
<p>Note that, when the <code>NCHAR</code> literal replacement is turned on, <code>OCIStmtPrepare</code> and <code>OCIStmtPrepare2</code> transforms <code>N'</code> literals with <code>U'</code> literals in the SQL text and store the resulting SQL text in the statement handle. Thus, if the application uses <code>OCI_ATTR_STATEMENT</code> to retrieve the SQL text from the OCI statement handle, the SQL text returns <code>U'</code> instead of <code>N'</code> as specified in the original text.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for information regarding environment variables</div>
</div>
<!-- class="sect2" -->
<a id="i1006698"></a><a id="NLSPG355"></a>
<div class="sect2">
<h3 class="sect2">Binding and Defining CLOB and <a id="sthref647"></a><a id="sthref648"></a><a id="sthref649"></a>NCLOB Unicode Data in OCI</h3>
<p>In order to write (bind) and read (define) UTF-16 data for <code>CLOB</code> or <code>NCLOB</code> columns, the UTF-16 character set ID must be specified as <code><a id="sthref650"></a><a id="sthref651"></a>OCILobWrite()</code> and <code>OCILobRead()</code>. When you write UTF-16 data into a <code>CLOB</code> column, call <code>OCILobWrite()</code> as follows:</p>
<pre>
...
ub2 csid = OCI_UTF16ID;
err = OCILobWrite (ctx-&gt;svchp, ctx-&gt;errhp, lobp, &amp;amtp, offset, (void *) buf,
                   (ub4) BUFSIZE, OCI_ONE_PIECE, (void *)0,
                   (sb4 (*)()) 0, (ub2) csid, (ub1) SQLCS_IMPLICIT); 
</pre>
<p>The <code>amtp</code> parameter is the data length in number of Unicode code units. The <code>offset</code> parameter indicates the offset of data from the beginning of the data column. The <code>csid</code> parameter must be set for UTF-16 data.</p>
<p>To read UTF-16 data from <code>CLOB</code> columns, call <code>OCILobRead()</code> as follows:</p>
<pre>
...
ub2 csid = OCI_UTF16ID;
err = OCILobRead(ctx-&gt;svchp, ctx-&gt;errhp, lobp, &amp;amtp, offset, (void *) buf,
                 (ub4)BUFSIZE , (void *) 0, (sb4 (*)()) 0, (ub2)csid,
                 (ub1) SQLCS_IMPLICIT);
</pre>
<p>The data length is always represented in the number of Unicode code units. Note one Unicode supplementary character is counted as two code units, because the encoding is UTF-16. After binding or defining a <code>LOB</code> column, you can measure the data length stored in the <code>LOB</code> column using <code>OCILobGetLength()</code>. The returning value is the data length in the number of code units if you bind or define as UTF-16.</p>
<pre>
err = OCILobGetLength(ctx-&gt;svchp, ctx-&gt;errhp, lobp, &amp;lenp);
</pre>
<p>If you are using an <code>NCLOB</code>, then you must set <code>OCI_ATTR_CHARSET_FORM</code> to <code>SQLCS_NCHAR</code>.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006721"></a><a id="NLSPG0075"></a>
<div class="sect1">
<h2 class="sect1">Pro*C/C++ Programming with Unicode</h2>
<p><a id="i1006723"></a>Pro*C/C++ provides the following ways to insert or retrieve Unicode data into or from the database:</p>
<ul>
<li>
<p>Using the <code>VARCHAR</code> Pro*C/C++ data type or the native C/C++ <code>text</code> data type, a program can access Unicode data stored in SQL <code>CHAR</code> data types of a UTF8 or AL32UTF8 database. Alternatively, a program could use the C/C++ native <code>text</code> type.</p>
</li>
<li>
<p>Using the <code>UVARCHAR</code> Pro*C/C++ data type or the native C/C++ <code>utext</code> data type, a program can access Unicode data stored in <code>NCHAR</code> data types of a database.</p>
</li>
<li>
<p>Using the <code>NVARCHAR</code> Pro*C/C++ data type, a program can access Unicode data stored in <code>NCHAR</code> data types. The difference between <code>UVARCHAR</code> and <code>NVARCHAR</code> in a Pro*C/C++ program is that the data for the <code>UVARCHAR</code> data type is stored in a <code>utext</code> buffer while the data for the <code>NVARCHAR</code> data type is stored in a <code>text</code> data type.</p>
</li>
</ul>
<p>Pro*C/C++ does not use the Unicode OCI API for SQL text. As a result, embedded SQL text must be encoded in the character set specified in the <code>NLS_LANG</code> environment variable.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006746">Pro*C/C++ Data Conversion in Unicode</a></p>
</li>
<li>
<p><a href="#i1006810">Using the VARCHAR Data Type in Pro*C/C++</a></p>
</li>
<li>
<p><a href="#i1006830">Using the NVARCHAR Data Type in Pro*C/C++</a></p>
</li>
<li>
<p><a href="#i1006835">Using the UVARCHAR Data Type in Pro*C/C++</a></p>
</li>
</ul>
<a id="i1006746"></a><a id="NLSPG356"></a>
<div class="sect2">
<h3 class="sect2">Pro*C/C++ Data Conversion in Unicode</h3>
<p>Data <a id="sthref652"></a><a id="sthref653"></a>conversion occurs in the OCI layer, but it is the Pro*C/C++ preprocessor that instructs OCI which conversion path should be taken based on the data types used in a Pro*C/C++ program. <a href="#g1010270">Table 7-4</a> illustrates the conversion paths:</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG810"></a><a id="sthref654"></a><a id="g1010270"></a>Table 7-4 Pro*C/C++ Bind and Define Data Conversion</p>
<table class="cellalignment1914" title="Pro*C/C++ Bind and Define Data Conversion " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t15">Pro*C/C++ Data Type</th>
<th class="cellalignment1915" id="r1c2-t15">SQL Data Type</th>
<th class="cellalignment1915" id="r1c3-t15">Conversion Path</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t15" headers="r1c1-t15">
<p><code>VARCHAR</code> or <code>text</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t15 r1c2-t15">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t15 r1c3-t15">
<p><code>NLS_LANG</code> character set to and from the database character set happens in OCI</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t15" headers="r1c1-t15">
<p><code>VARCHAR</code> or <code>text</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t15 r1c2-t15">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t15 r1c3-t15">
<p><code>NLS_LANG</code> character set to and from database character set happens in OCI</p>
<p>Database character set to and from national character set happens in database server</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t15" headers="r1c1-t15">
<p><code>NVARCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t15 r1c2-t15">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t15 r1c3-t15">
<p><code>NLS_LANG</code> character set to and from national character set happens in OCI</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t15" headers="r1c1-t15">
<p><code>NVARCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t15 r1c2-t15">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t15 r1c3-t15">
<p><code>NLS_LANG</code> character set to and from national character set happens in OCI</p>
<p>National character set to and from database character set in database server</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r6c1-t15" headers="r1c1-t15">
<p><code>UVARCHAR</code> or <code>utext</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t15 r1c2-t15">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t15 r1c3-t15">
<p>UTF-16 to and from the national character set happens in OCI</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r7c1-t15" headers="r1c1-t15">
<p><code>UVARCHAR</code> or <code>utext</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t15 r1c2-t15">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t15 r1c3-t15">
<p>UTF-16 to and from national character set happens in OCI</p>
<p>National character set to database character set happens in database server</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect2" -->
<a id="i1006810"></a><a id="NLSPG357"></a>
<div class="sect2">
<h3 class="sect2">Using the VARCHAR Data Type in Pro*C/C++</h3>
<p>The Pro*C/C++ <code>VARCHAR</code> data type is <a id="sthref655"></a><a id="sthref656"></a>preprocessed to a struct with a <code>length</code> field and <code>text</code> buffer field. The following example uses the C/C++ <code>text</code> native data type and the <code>VARCHAR</code> Pro*C/C++ data types to bind and define table columns.</p>
<pre>
#include &lt;sqlca.h&gt; 
main() 
{ 
   ... 
   /* Change to STRING datatype:    */ 
   EXEC ORACLE OPTION (CHAR_MAP=STRING) ; 
   text ename[20] ;                  /* unsigned short type */ 
   varchar address[50] ;             /* Pro*C/C++ varchar type */ 

   EXEC SQL SELECT ename, address INTO :ename, :address FROM emp; 
   /* ename is NULL-terminated */ 
   printf(L"ENAME = %s, ADDRESS = %.*s\n", ename, address.len, address.arr); 
   ... 
} 
</pre>
<p>When you use the <code>VARCHAR</code> data type or native <code>text</code> data type in a Pro*C/C++ program, the preprocessor assumes that the program intends to access columns of SQL <code>CHAR</code> data types instead of SQL <code>NCHAR</code> data types in the database. The preprocessor generates C/C++ code to reflect this fact by doing a bind or define using the <code>SQLCS_IMPLICIT</code> value for the <code>OCI_ATTR_CHARSET_FORM</code> attribute. As a result, if a bind or define variable is bound to a column of SQL <code>NCHAR</code> data types in the database, then implicit conversion occurs in the database server to convert the data from the database character set to the national database character set and vice versa. During the conversion, data loss occurs when the database character set is a smaller set than the national character set.</p>
</div>
<!-- class="sect2" -->
<a id="i1006830"></a><a id="NLSPG358"></a>
<div class="sect2">
<h3 class="sect2">Using the NVARCHAR Data Type in Pro*C/C++</h3>
<p>The <a id="sthref657"></a><a id="sthref658"></a>Pro*C/C++ <code>NVARCHAR</code> data type is similar to the Pro*C/C++ <code>VARCHAR</code> data type. It should be used to access SQL <code>NCHAR</code> data types in the database. It tells Pro*C/C++ preprocessor to bind or define a text buffer to the column of SQL <code>NCHAR</code> data types. The preprocessor specifies the <code>SQLCS_NCHAR</code> value for the <code>OCI_ATTR_CHARSET_FORM</code> attribute of the bind or define variable. As a result, no implicit conversion occurs in the database.</p>
<p>If the <code>NVARCHAR</code> buffer is bound against columns of SQL <code>CHAR</code> data types, then the data in the <code>NVARCHAR</code> buffer (encoded in the <code>NLS_LANG</code> character set) is converted to or from the national character set in OCI, and the data is then converted to the database character set in the database server. Data can be lost when the <code>NLS_LANG</code> character set is a larger set than the database character set.</p>
</div>
<!-- class="sect2" -->
<a id="i1006835"></a><a id="NLSPG359"></a>
<div class="sect2">
<h3 class="sect2">Using the UVARCHAR Data Type in Pro*C/C++</h3>
<p>The <code><a id="sthref659"></a><a id="sthref660"></a>UVARCHAR</code> data type is preprocessed to a struct with a <code>length</code> field and <code>utext</code> buffer field. The following example code contains two host variables, <code>ename</code> and <code>address</code>. The <code>ename</code> host variable is declared as a <code>utext</code> buffer containing 20 Unicode characters. The <code>address</code> host variable is declared as a <code>uvarchar</code> buffer containing 50 Unicode characters. The <code>len</code> and <code>arr</code> fields are accessible as fields of a struct.</p>
<pre>
#include &lt;sqlca.h&gt; 
#include &lt;sqlucs2.h&gt; 

main() 
{ 
   ... 
   /* Change to STRING datatype:    */ 
   EXEC ORACLE OPTION (CHAR_MAP=STRING) ; 
   utext ename[20] ;                  /* unsigned short type */ 
 uvarchar address[50] ;               /* Pro*C/C++ uvarchar type */ 

   EXEC SQL SELECT ename, address INTO :ename, :address FROM emp; 
   /* ename is NULL-terminated */ 
wprintf(L"ENAME = %s, ADDRESS = %.*s\n", ename, address.len, 
address.arr); 
... 
} 
</pre>
<p>When you use the <code>UVARCHAR</code> data type or native <code>utext</code> data type in Pro*C/C++ programs, the preprocessor assumes that the program intends to access SQL <code>NCHAR</code> data types. The preprocessor generates C/C++ code by binding or defining using the <code>SQLCS_NCHAR</code> value for <code>OCI_ATTR_CHARSET_FORM</code> attribute. As a result, if a bind or define variable is bound to a column of a SQL <code>NCHAR</code> data type, then an implicit conversion of the data from the national character set occurs in the database server. However, there is no data lost in this scenario because the national character set is always a larger set than the database character set.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006858"></a><a id="NLSPG0076"></a>
<div class="sect1">
<h2 class="sect1">JDBC Programming with Unicode</h2>
<p>Oracle provides the following <a id="sthref661"></a><a id="sthref662"></a>JDBC drivers for Java programs to access character data in an Oracle database:</p>
<ul>
<li>
<p>The JDBC OCI driver</p>
</li>
<li>
<p>The JDBC thin driver</p>
</li>
<li>
<p>The JDBC server-side internal driver</p>
</li>
<li>
<p>The JDBC server-side thin driver</p>
</li>
</ul>
<p>Java programs can insert or retrieve character data to and from columns of SQL <code>CHAR</code> and <code>NCHAR</code> data types. Specifically, JDBC enables Java programs to bind or define Java strings to SQL <code>CHAR</code> and <code>NCHAR</code> data types. Because Java's <code>string</code> data type is UTF-16 encoded, data retrieved from or inserted into the database must be converted from UTF-16 to the database character set or the national character set and vice versa. JDBC also enables you to specify the PL/SQL and SQL statements in Java strings so that any non-ASCII schema object names and string literals can be used.</p>
<p>At database connection time, JDBC sets the server <code>NLS_LANGUAGE</code> and <code>NLS_TERRITORY</code> parameters to correspond to the locale of the Java VM that runs the JDBC driver. This operation ensures that the server and the Java client communicate in the same language. As a result, Oracle error messages returned from the server are in the same language as the client locale.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006887">Binding and Defining Java Strings to SQL CHAR Data Types</a></p>
</li>
<li>
<p><a href="#i1008882">Binding and Defining Java Strings to SQL NCHAR Data Types</a></p>
</li>
<li>
<p><a href="#i1008044">Using the SQL NCHAR Data Types Without Changing the Code</a></p>
</li>
<li>
<p><a href="#CHDCBACA">Using SQL NCHAR String Literals in JDBC</a></p>
</li>
<li>
<p><a href="#i1006925">Data Conversion in JDBC</a></p>
</li>
<li>
<p><a href="#i1008887">Using oracle.sql.CHAR in Oracle Object Types</a></p>
</li>
<li>
<p><a href="#i1008897">Restrictions on Accessing SQL CHAR Data with JDBC</a></p>
</li>
</ul>
<a id="i1006887"></a><a id="NLSPG360"></a>
<div class="sect2">
<h3 class="sect2">Binding and Defining Java Strings to SQL CHAR Data Types</h3>
<p>Oracle JDBC <a id="sthref663"></a><a id="sthref664"></a> drivers allow you to access SQL <code>CHAR</code> data types in the database using Java string bind or define variables. The following code illustrates how to bind a Java string to a <code>CHAR</code> column.</p>
<pre>
int employee_id = 12345;
String last_name = "Joe";
PreparedStatement pstmt = conn.prepareStatement("INSERT INTO" +
    "employees (last_name, employee_id) VALUES (?, ?)");
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                 /* execute to insert into first row */
employee_id += 1;                      /* next employee number */
last_name = "\uFF2A\uFF4F\uFF45";    /* Unicode characters in name */
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                 /* execute to insert into second row */
</pre>
<p>You can define the target SQL columns by specifying their data types and lengths. When you define a SQL <code>CHAR</code> column with the data type and the length, JDBC uses this information to optimize the performance of fetching SQL <code>CHAR</code> data from the column. The following is an example of defining a SQL <code>CHAR</code> column.</p>
<pre>
OraclePreparedStatement pstmt = (OraclePreparedStatement)
     conn.prepareStatement("SELECT ename, empno from emp");
pstmt.defineColumnType(1,Types.VARCHAR, 3);
pstmt.defineColumnType(2,Types.INTEGER);
ResultSet rest = pstmt.executeQuery();
String name = rset.getString(1);
int id = reset.getInt(2);
</pre>
<p>You must cast <code>PreparedStatement</code> to <code>OraclePreparedStatement</code> to call <code>defineColumnType()</code>. The second parameter of <code>defineColumnType()</code> is the data type of the target SQL column. The third parameter is the length in number of characters.</p>
</div>
<!-- class="sect2" -->
<a id="i1008882"></a><a id="NLSPG361"></a>
<div class="sect2">
<h3 class="sect2">Binding and Defining Java Strings to SQL NCHAR Data Types</h3>
<p>For binding or defining Java string variables to SQL <code>NCHAR</code> data types, Oracle provides an extended <code>PreparedStatement</code> which has the <code>setFormOfUse()</code> method through which you can explicitly specify the target column of a bind variable to be a SQL <code>NCHAR</code> data type. The following code illustrates how to bind a Java string to an <code>NCHAR</code> column.</p>
<pre>
int employee_id = 12345;
String last_name = "Joe"
oracle.jdbc.OraclePreparedStatement pstmt =
    (oracle.jdbc.OraclePreparedStatement)
    conn.prepareStatement("INSERT INTO employees (last_name, employee_id) 
    VALUES    (?, ?)");
pstmt.setFormOfUse(1, oracle.jdbc.OraclePreparedStatement.FORM_NCHAR);
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                 /* execute to insert into first row */
employee_id += 1;                      /* next employee number */
last_name = "\uFF2A\uFF4F\uFF45";    /* Unicode characters in name */
pstmt.setString(1, last_name);
pstmt.setInt(2, employee_id);
pstmt.execute();                 /* execute to insert into second row */
</pre>
<p>You can define the target SQL <code>NCHAR</code> columns by specifying their data types, forms of use, and lengths. JDBC uses this information to optimize the performance of fetching SQL <code>NCHAR</code> data from these columns. The following is an example of defining a SQL <code>NCHAR</code> column.</p>
<pre>
OraclePreparedStatement pstmt = (OraclePreparedStatement)
     conn.prepareStatement("SELECT ename, empno from emp");
   pstmt.defineColumnType(1,Types.VARCHAR, 3, 
OraclePreparedStatement.FORM_NCHAR);
   pstmt.defineColumnType(2,Types.INTEGER);
   ResultSet rest = pstmt.executeQuery();
   String name = rset.getString(1);
   int id = reset.getInt(2);
</pre>
<p>To define a SQL <code>NCHAR</code> column, you must specify the data type that is equivalent to a SQL <code>CHAR</code> column in the first argument, the length in number of characters in the second argument, and the form of use in the fourth argument of <code>defineColumnType()</code>.</p>
<p>You can bind or define a Java string against an <code>NCHAR</code> column without explicitly specifying the form of use argument. This implies the following:</p>
<ul>
<li>
<p>If you do not specify the argument in the <code>setString()</code> method, then JDBC assumes that the bind or define variable is for the SQL <code>CHAR</code> column. As a result, it tries to convert them to the database character set. When the data gets to the database, the database implicitly converts the data in the database character set to the national character set. During this conversion, data can be lost when the database character set is a subset of the national character set. Because the national character set is either UTF8 or AL16UTF16, data loss would happen if the database character set is not UTF8 or AL32UTF8.</p>
</li>
<li>
<p>Because implicit conversion from SQL <code>CHAR</code> to SQL <code>NCHAR</code> data types happens in the database, database performance is degraded.</p>
</li>
</ul>
<p>In addition, if you bind or define a Java string for a column of SQL <code>CHAR</code> data types but specify the form of use argument, then performance of the database is degraded. However, data should not be lost because the national character set is always a larger set than the database character set.</p>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref665"></a>
<h4 class="sect3">New JDBC4.0 Methods for NCHAR Data Types</h4>
<p>JDBC 11.1 adds support for the new JDBC 4.0 (JDK6) SQL data types <code>NCHAR</code>, <code>NVARCHAR</code>, <code>LONGNVARCHAR</code>, and <code>NCLOB</code>. To retrieve a national character value, an application can call one of the following methods:</p>
<ul>
<li>
<p><code>getNString</code></p>
</li>
<li>
<p><code>getNClob</code></p>
</li>
<li>
<p><code>getNCharacterStream</code></p>
</li>
</ul>
<p>The <code>getNClob</code> method verifies that the retrieved value is indeed an <code>NCLOB</code>. Otherwise, these methods are equivalent to corresponding methods without the letter <code>N</code>.</p>
<p>To specify a value for a parameter marker of national character type, an application can call one of the following methods:</p>
<ul>
<li>
<p><code>setNString</code></p>
</li>
<li>
<p><code>setNCharacterStream</code></p>
</li>
<li>
<p><code>setNClob</code></p>
</li>
</ul>
<p>These methods are equivalent to corresponding methods without the letter <code>N</code> preceded by a call to <code>setFormOfUse(..., OraclePreparedStatement.FORM_NCHAR)</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic">Oracle Database JDBC Developer's Guide and Reference</span> for the section "New Methods for National Character Set Type Data in JDK 1.6"</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008044"></a><a id="NLSPG362"></a>
<div class="sect2">
<h3 class="sect2">Using the SQL NCHAR Data Types Without Changing the Code</h3>
<p>A Java system property has been introduced in the Oracle JDBC drivers for customers to tell whether the form of use argument should be specified by default in a Java application. This property has the following purposes:</p>
<ul>
<li>
<p>Existing applications accessing the SQL <code>CHAR</code> data types can be migrated to support the SQL <code>NCHAR</code> data types for worldwide deployment without changing a line of code.</p>
</li>
<li>
<p>Applications do not need to call the <code><a id="sthref666"></a><a id="sthref667"></a>setFormOfUse()</code> method when binding and defining a SQL <code>NCHAR</code> column. The application code can be made neutral and independent of the data types being used in the backend database. With this property set, applications can be easily switched from using SQL <code>CHAR</code> or SQL <code>NCHAR</code>.</p>
</li>
</ul>
<p>The Java system property is specified in the command line that invokes the Java application. The syntax of specifying this flag is as follows:</p>
<pre>
java -Doracle.jdbc.defaultNChar=true &lt;application class&gt;
</pre>
<p>With this property specified, the Oracle JDBC drivers assume the presence of the form of use argument for all bind and define operations in the application.</p>
<p>If you have a database schema that consists of both the SQL <code>CHAR</code> and SQL <code>NCHAR</code> columns, then using this flag may have some performance impact when accessing the SQL <code>CHAR</code> columns because of implicit conversion done in the database server.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006925">"Data Conversion in JDBC"</a> for more information about the performance impact of implicit conversion</div>
</div>
<!-- class="sect2" -->
<a id="CHDCBACA"></a><a id="NLSPG363"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using SQL NCHAR String Literals in JDBC</h3>
<p>When using <code>NCHAR</code> string literals in JDBC, there is a potential for data loss because characters are converted to the database character set before processing. See <a href="#CACHHIFE">"NCHAR String Literal Replacement"</a> for more details.</p>
<p>The desired behavior for preserving the <code>NCHAR</code> string literals can be achieved by enabling the property set <code>oracle.jdbc.convertNcharLiterals</code>. If the value is true, then this option is enabled; otherwise, it is disabled. The default setting is false. It can be enabled in two ways: a) as a Java system property or b) as a connection property. Once enabled, conversion is performed on all SQL in the VM (system property) or in the connection (connection property). For example, the property can be set as a Java system property as follows:</p>
<pre>
java -Doracle.jdbc.convertNcharLiterals="true" ...
</pre>
<p>Alternatively, you can set this as a connection property as follows:</p>
<pre>
Properties props = new Properties();
...
props.setProperty("oracle.jdbc.convertNcharLiterals", "true");
Connection conn = DriverManager.getConnection(url, props);
</pre>
<p>If you set this as a connection property, it overrides a system property setting.</p>
</div>
<!-- class="sect2" -->
<a id="i1006925"></a><a id="NLSPG364"></a>
<div class="sect2">
<h3 class="sect2">Data Conversion in JDBC</h3>
<p>Because <a id="sthref668"></a><a id="sthref669"></a><a id="sthref670"></a>Java strings are always encoded in UTF-16, JDBC drivers transparently convert data from the database character set to UTF-16 or the national character set. The conversion paths taken are different for the JDBC drivers:</p>
<ul>
<li>
<p><a href="#i1006941">Data Conversion for the OCI Driver</a></p>
</li>
<li>
<p><a href="#i1006992">Data Conversion for Thin Drivers</a></p>
</li>
<li>
<p><a href="#i1009338">Data Conversion for the Server-Side Internal Driver</a></p>
</li>
</ul>
<a id="i1006941"></a><a id="NLSPG365"></a>
<div class="sect3">
<h4 class="sect3">Data Conversion for the <a id="sthref671"></a>OCI Driver</h4>
<p>For the OCI driver, the SQL statements are always converted to the database character set by the driver before it is sent to the database for processing. When the database character set is neither US7ASCII nor WE8ISO8859P1, the driver converts the SQL statements to UTF-8 first in Java and then to the database character set in C. Otherwise, it converts the SQL statements directly to the database character set. For Java string bind variables, <a href="#g1010302">Table 7-5</a> summarizes the conversion paths taken for different scenarios. For Java string define variables, the same conversion paths, but in the opposite direction, are taken.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG811"></a><a id="sthref672"></a><a id="g1010302"></a>Table 7-5 OCI Driver Conversion Path</p>
<table class="cellalignment1914" title="OCI Driver Conversion Path " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t18">Form of Use</th>
<th class="cellalignment1915" id="r1c2-t18">SQL Data Type</th>
<th class="cellalignment1915" id="r1c3-t18">Conversion Path</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t18" headers="r1c1-t18">
<p><code>FORM_CHAR (Default)</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t18 r1c2-t18">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t18 r1c3-t18">
<p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the JDBC driver.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t18" headers="r1c1-t18">
<p><code>FORM_CHAR (Default)</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t18 r1c2-t18">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t18 r1c3-t18">
<p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the JDBC driver. Then, conversion between the database character set and the national character set happens in the database server.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t18" headers="r1c1-t18">
<p><code>FORM_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t18 r1c2-t18">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t18 r1c3-t18">
<p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the JDBC driver.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t18" headers="r1c1-t18">
<p><code>FORM_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t18 r1c2-t18">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t18 r1c3-t18">
<p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the JDBC driver. Then, conversion between the national character set and the database character set happens in the database server.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" -->
<a id="i1006992"></a><a id="NLSPG366"></a>
<div class="sect3">
<h4 class="sect3">Data Conversion for <a id="sthref673"></a>Thin Drivers</h4>
<p>SQL statements are always converted to either the database character set or to UTF-8 by the driver before they are sent to the database for processing. The driver converts the SQL statement to the database character set when the database character set is one of the following character sets:</p>
<ul>
<li>
<p>US7ASCII</p>
</li>
<li>
<p>WE8ISO8859P1</p>
</li>
<li>
<p>WE8DEC</p>
</li>
<li>
<p>WE8MSWIN1252</p>
</li>
</ul>
<p>Otherwise, the driver converts the SQL statement to UTF-8 and notifies the database that the statement requires further conversion before being processed. The database, in turn, converts the SQL statement to the database character set. For Java string bind variables, the conversion paths shown in <a href="#g1010326">Table 7-6</a> are taken for the thin driver. For Java string define variables, the same conversion paths but in the opposite direction are taken. The four character sets listed earlier are called <span class="bold">selected</span> <span class="bold">characters</span> <span class="bold">sets</span> in the table.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG812"></a><a id="sthref674"></a><a id="g1010326"></a>Table 7-6 Thin Driver Conversion Path</p>
<table class="cellalignment1914" title="Thin Driver Conversion Path " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t19">Form of Use</th>
<th class="cellalignment1915" id="r1c2-t19">SQL Data Type</th>
<th class="cellalignment1915" id="r1c3-t19">Database Character Set</th>
<th class="cellalignment1915" id="r1c4-t19">Conversion Path</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t19" headers="r1c1-t19">
<p><code>FORM_CHAR (Default)</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t19 r1c2-t19">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t19 r1c3-t19">
<p>One of the selected character sets</p>
</td>
<td class="cellalignment1911" headers="r2c1-t19 r1c4-t19">
<p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the thin driver.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t19" headers="r1c1-t19">
<p><code>FORM_CHAR (Default)</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t19 r1c2-t19">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t19 r1c3-t19">
<p>One of the selected character sets</p>
</td>
<td class="cellalignment1911" headers="r3c1-t19 r1c4-t19">
<p>Conversion between the UTF-16 encoding of a Java string and the database character set happens in the thin driver. Then, conversion between the database character set and the national character set happens in the database server.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t19" headers="r1c1-t19">
<p><code>FORM_CHAR (Default)</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t19 r1c2-t19">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t19 r1c3-t19">
<p>Other than the selected character sets</p>
</td>
<td class="cellalignment1911" headers="r4c1-t19 r1c4-t19">
<p>Conversion between the UTF-16 encoding of a Java string and UTF-8 happens in the thin driver. Then, conversion between UTF-8 and the database character set happens in the database server.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r5c1-t19" headers="r1c1-t19">
<p><code>FORM_CHAR (Default)</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t19 r1c2-t19">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r5c1-t19 r1c3-t19">
<p>Other than the selected character sets</p>
</td>
<td class="cellalignment1911" headers="r5c1-t19 r1c4-t19">
<p>Conversion between the UTF-16 encoding of a Java string and UTF-8 happens in the thin driver. Then, conversion from UTF-8 to the database character set and then to the national character set happens in the database server.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r6c1-t19" headers="r1c1-t19">
<p><code>FORM_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t19 r1c2-t19">
<p><code>CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r6c1-t19 r1c3-t19">
<p>Any</p>
</td>
<td class="cellalignment1911" headers="r6c1-t19 r1c4-t19">
<p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the thin driver. Then, conversion between the national character set and the database character set happens in the database server.</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r7c1-t19" headers="r1c1-t19">
<p><code>FORM_NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t19 r1c2-t19">
<p><code>NCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r7c1-t19 r1c3-t19">
<p>Any</p>
</td>
<td class="cellalignment1911" headers="r7c1-t19 r1c4-t19">
<p>Conversion between the UTF-16 encoding of a Java string and the national character set happens in the thin driver.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" -->
<a id="i1009338"></a><a id="NLSPG367"></a>
<div class="sect3">
<h4 class="sect3">Data Conversion for the Server-Side Internal Driver</h4>
<p>All data conversion occurs in the database server because the server-side internal driver works inside the database.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008887"></a><a id="NLSPG368"></a>
<div class="sect2">
<h3 class="sect2">Using oracle.sql.CHAR in Oracle Object Types</h3>
<p>JDBC drivers support Oracle object types. Oracle objects are always sent from database to client as an object represented in the database character set or national character set. That means the data conversion path in <a href="#i1006925">"Data Conversion in JDBC"</a> does not apply to Oracle object access. Instead, the <code>oracle.sql.CHAR</code> class is used for passing SQL <code>CHAR</code> and SQL <code>NCHAR</code> data of an object type from the database to the client.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#i1009098">oracle.sql.CHAR</a></p>
</li>
<li>
<p><a href="#i1008892">Accessing SQL CHAR and NCHAR Attributes with oracle.sql.CHAR</a></p>
</li>
</ul>
<a id="i1009098"></a><a id="NLSPG369"></a>
<div class="sect3">
<h4 class="sect3">oracle.sql.CHAR</h4>
<p>The <code><a id="sthref675"></a>oracle.sql.CHAR</code> class has a special functionality for conversion of character data. The Oracle character set is a key attribute of the <code>oracle.sql.CHAR</code> class. The Oracle character set is always passed in when an <code>oracle.sql.CHAR</code> object is constructed. Without a known character set, the bytes of data in the <code>oracle.sql.CHAR</code> object are meaningless.</p>
<p>The <code>oracle.sql.CHAR</code> class provides the following methods for converting character data to strings:</p>
<ul>
<li>
<p><code><a id="sthref676"></a><a id="sthref677"></a>getString()</code></p>
<p>Converts the sequence of characters represented by the <code>oracle.sql.CHAR</code> object to a string, returning a Java string object. If the character set is not recognized, then <code>getString()</code> returns a <code>SQLException</code>.</p>
</li>
<li>
<p><code><a id="sthref678"></a><a id="sthref679"></a>toString()</code></p>
<p>Identical to <code>getString()</code>, except that if the character set is not recognized, then <code>toString()</code> returns a hexadecimal representation of the <code>oracle.sql.CHAR</code> data and does not returns a <code>SQLException</code>.</p>
</li>
<li>
<p><code><a id="sthref680"></a><a id="sthref681"></a>getStringWithReplacement()</code></p>
<p>Identical to <code>getString()</code>, except that a default replacement character replaces characters that have no Unicode representation in the character set of this <code>oracle.sql.CHAR</code> object. This default character varies among character sets, but it is often a question mark.</p>
</li>
</ul>
<p>You may want to construct an <code>oracle.sql.CHAR</code> object yourself (to pass into a prepared statement, for example). When you construct an <code>oracle.sql.CHAR</code> object, you must provide character set information to the <code>oracle.sql.CHAR</code> object by using an instance of the <code>oracle.sql.CharacterSet</code> class. Each instance of the <code>oracle.sql.CharacterSet</code> class represents one of the character sets that Oracle supports.</p>
<p>Complete the following tasks to construct an <code>oracle.sql.CHAR</code> object:</p>
<ol>
<li>
<p>Create a <code>CharacterSet</code> instance by calling the static <code>CharacterSet.make()</code> method. This method creates the character set class. It requires as input a valid Oracle character set (<code>OracleId)</code>. For example:</p>
<pre>
int OracleId = CharacterSet.JA16SJIS_CHARSET; // this is character set 832
...
CharacterSet mycharset = CharacterSet.make(OracleId);
</pre>
<p>Each character set that Oracle supports has a unique predefined <code>OracleId</code>. The <code>OracleId</code> can always be referenced as a character set specified as <code><span class="codeinlineitalic">Oracle_character_set_name</span></code><code>_CHARSET</code> where <code><span class="codeinlineitalic">Oracle_character_set_name</span></code> is the Oracle character set.</p>
</li>
<li>
<p>Construct an <code>oracle.sql.CHAR</code> object. Pass to the constructor a string (or the bytes that represent the string) and the <code>CharacterSet</code> object that indicates how to interpret the bytes based on the character set. For example:</p>
<pre>
String mystring = "teststring";
...
oracle.sql.CHAR mychar = new oracle.sql.CHAR(teststring, mycharset);
</pre>
<p>The <code>oracle.sql.CHAR</code> class has multiple constructors: they can take a string, a byte array, or an object as input along with the <code>CharacterSet</code> object. In the case of a string, the string is converted to the character set indicated by the <code>CharacterSet</code> object before being placed into the <code>oracle.sql.CHAR</code> object.</p>
</li>
</ol>
<p>The server (database) and the client (or application running on the client) can use different character sets. When you use the methods of this class to transfer data between the server and the client, the JDBC drivers must convert the data between the server character set and the client character set.</p>
</div>
<!-- class="sect3" -->
<a id="i1008892"></a><a id="NLSPG370"></a>
<div class="sect3">
<h4 class="sect3">Accessing SQL CHAR and NCHAR Attributes with oracle.sql.CHAR</h4>
<p>The following is an example of an object type created using SQL:</p>
<pre>
CREATE TYPE person_type AS OBJECT (
   name VARCHAR2(30), address NVARCHAR2(256), age NUMBER);
CREATE TABLE employees (id NUMBER, person PERSON_TYPE);
</pre>
<p>The Java class corresponding to this object type can be constructed as follows:</p>
<pre>
public class person implement SqlData  
{
   oracle.sql.CHAR name;
   oracle.sql.CHAR address;
   oracle.sql.NUMBER age;
   // SqlData interfaces
   getSqlType() {...}
   writeSql(SqlOutput stream) {...}
   readSql(SqlInput stream, String sqltype) {...}
}
</pre>
<p>The <code>oracle.sql.CHAR</code> class is used here to map to the <code>NAME</code> attributes of the Oracle object type, which is of <code>VARCHAR2</code> data type. JDBC populates this class with the byte representation of the <code>VARCHAR2</code> data in the database and the <code>CharacterSet</code> object corresponding to the database character set. The following code retrieves a <code>person</code> object from the <code>employees</code> table:</p>
<pre>
TypeMap map = ((OracleConnection)conn).getTypeMap();
map.put("PERSON_TYPE", Class.forName("person"));
conn.setTypeMap(map);
    .       .        .
    .       .        .
ResultSet rs = stmt.executeQuery("SELECT PERSON FROM EMPLOYEES");
rs.next();
person p = (person) rs.getObject(1);
oracle.sql.CHAR sql_name = p.name;
oracle.sql.CHAR sql_address=p.address;
String java_name = sql_name.getString();
String java_address = sql_address.getString();
</pre>
<p>The <code>getString()</code> method of the <code>oracle.sql.CHAR</code> class converts the byte array from the database character set or national character set to UTF-16 by calling Oracle's Java data conversion classes and returning a Java string. For the <code>rs.getObject(1)</code> call to work, the <code>SqlData</code> interface has to be implemented in the class <code>person</code>, and the <code>Typemap</code> <code>map</code> has to be set up to indicate the mapping of the object type <code>PERSON_TYPE</code> to the Java class.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008897"></a><a id="NLSPG371"></a>
<div class="sect2">
<h3 class="sect2">Restrictions on Accessing SQL CHAR Data with JDBC</h3>
<p>This section contains the following topic:</p>
<ul>
<li>
<p><a href="#i1008855">Character Integrity Issues in a Multibyte Database Environment</a></p>
</li>
</ul>
<a id="i1008855"></a><a id="NLSPG372"></a>
<div class="sect3">
<h4 class="sect3">Character Integrity Issues in a Multibyte Database Environment</h4>
<p>Oracle JDBC drivers perform character set conversions as appropriate when character data is inserted into or retrieved from the database. The drivers convert Unicode characters used by Java clients to Oracle database character set characters, and vice versa. Character data that makes a round trip from the Java Unicode character set to the database character set and back to Java can suffer some loss of information. This happens when multiple Unicode characters are mapped to a single character in the database character set. An example is the Unicode full-width tilde character (0xFF5E) and its mapping to Oracle's JA16SJIS character set. The round-trip conversion for this Unicode character results in the Unicode character 0x301C, which is a <a id="sthref682"></a><a id="sthref683"></a>wave dash (a character commonly used in Japan to indicate range), not a tilde.</p>
<p><a href="#i1008863">Figure 7-2</a> shows the round-trip conversion of the tilde character.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1008863"></a><a id="NLSPG813"></a>Figure 7-2 Character Integrity</p>
<img width="596" height="208" src="img/nlspg015.gif" alt="Description of Figure 7-2 follows" /><br />
<a id="sthref684" href="./img_text/nlspg015.htm">Description of "Figure 7-2 Character Integrity"</a><br />
<br /></div>
<!-- class="figure" -->
<p>This issue is not a bug in Oracle's JDBC. It is an unfortunate side effect of the ambiguity in character mapping specifications on different operating systems. Fortunately, this problem affects only a small number of characters in a small number of Oracle character sets such as JA16SJIS, JA16EUC, ZHT16BIG5, and KO16KS5601. The workaround is to avoid making a full round-trip with these characters.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008646"></a><a id="NLSPG0077"></a>
<div class="sect1">
<h2 class="sect1">ODBC and OLE DB Programming with Unicode</h2>
<p>You should <a id="sthref685"></a>use the Oracle ODBC driver or Oracle Provider for OLE DB to access the Oracle server when using a Windows platform. This section describes how these drivers support Unicode. It includes the following topics:</p>
<ul>
<li>
<p><a href="#i1007105">Unicode-Enabled Drivers in ODBC and OLE DB</a></p>
</li>
<li>
<p><a href="#i1007109">OCI Dependency in Unicode</a></p>
</li>
<li>
<p><a href="#i1007123">ODBC and OLE DB Code Conversion in Unicode</a></p>
</li>
<li>
<p><a href="#CACCFFFG">ODBC Unicode Data Types</a></p>
</li>
<li>
<p><a href="#i1007268">OLE DB Unicode Data Types</a></p>
</li>
<li>
<p><a href="#i1007296">ADO Access</a></p>
</li>
</ul>
<a id="i1007105"></a><a id="NLSPG373"></a>
<div class="sect2">
<h3 class="sect2">Unicode-Enabled Drivers in ODBC and OLE DB</h3>
<p>Oracle's ODBC driver and Oracle Provider for OLE DB can handle Unicode data properly without data loss. For example, you can run a Unicode ODBC application containing Japanese data on English Windows if you install Japanese fonts and an input method editor for entering Japanese characters.</p>
<p>Oracle provides ODBC and OLE DB products for Windows platforms only. For Unix platforms, contact your vendor.</p>
</div>
<!-- class="sect2" -->
<a id="i1007109"></a><a id="NLSPG374"></a>
<div class="sect2">
<h3 class="sect2">OCI Dependency in Unicode</h3>
<p>OCI Unicode binding and defining features are used by the ODBC and OLE DB drivers to handle Unicode data. OCI Unicode data binding and defining features are independent from <code>NLS_LANG</code>. This means Unicode data is handled properly, irrespective of the <code>NLS_LANG</code> setting on the platform.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006356">"OCI Programming with Unicode"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1007123"></a><a id="NLSPG375"></a>
<div class="sect2">
<h3 class="sect2">ODBC and OLE DB Code Conversion in Unicode</h3>
<p>In general, no redundant <a id="sthref686"></a>data conversion occurs unless you specify a different client data type from that of the server. If you bind Unicode buffer <code>SQL_C_WCHAR</code> with a Unicode data column like <code>NCHAR</code>, for example, then ODBC and OLE DB drivers bypass it between the application and OCI layer.</p>
<p>If you do not specify data types before fetching, but call <code>SQLGetData</code> with the client data types instead, then the conversions in <a href="#g1010369">Table 7-7</a> occur.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG814"></a><a id="sthref687"></a><a id="g1010369"></a>Table 7-7 ODBC Implicit Binding Code Conversions</p>
<table class="cellalignment1914" title="ODBC Implicit Binding Code Conversions " summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t21">Data Types of ODBC Client Buffer</th>
<th class="cellalignment1915" id="r1c2-t21">Data Types of the Target Column in the Database</th>
<th class="cellalignment1915" id="r1c3-t21">Fetch Conversions</th>
<th class="cellalignment1915" id="r1c4-t21">Comments</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t21" headers="r1c1-t21">
<p><code>SQL_C_WCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t21 r1c2-t21">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t21 r1c3-t21">
<p>If the database character set is a subset of the <code>NLS_LANG</code> character set, then the conversions occur in the following order:</p>
<ul>
<li>
<p>Database character set</p>
</li>
<li>
<p><code>NLS_LANG</code></p>
</li>
<li>
<p>UTF-16 in OCI</p>
</li>
<li>
<p>UTF-16 in ODBC</p>
</li>
</ul>
</td>
<td class="cellalignment1911" headers="r2c1-t21 r1c4-t21">
<p>No unexpected data loss</p>
<p>May degrade performance if database character set is a subset of the <code>NLS_LANG</code> character set</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t21" headers="r1c1-t21">
<p><code>SQL_C_CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t21 r1c2-t21">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t21 r1c3-t21">
<p>If database character set is a subset of <code>NLS_LANG</code> character set:</p>
<p>Database character set to <code>NLS_LANG</code> in OCI</p>
<p>If database character set is NOT a subset of <code>NLS_LANG</code> character set:</p>
<p>Database character set, UTF-16, to <code>NLS_LANG</code> character set in OCI and ODBC</p>
</td>
<td class="cellalignment1911" headers="r3c1-t21 r1c4-t21">
<p>No unexpected data loss</p>
<p>May degrade performance if database character set is not a subset of <code>NLS_LANG</code> character set</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>You must specify the data type for inserting and updating operations.</p>
<p>The data type of the ODBC client buffer is given when you call <code>SQLGetData</code> but not immediately. Hence, <code>SQLFetch</code> does not have the information.</p>
<p>Because the ODBC driver guarantees data integrity, if you perform implicit bindings, then redundant conversion may result in performance degradation. Your choice is the trade-off between performance with explicit binding or usability with implicit binding.</p>
<a id="NLSPG376"></a>
<div class="sect3"><a id="sthref688"></a>
<h4 class="sect3">OLE DB Code Conversions</h4>
<p>Unlike ODBC, OLE DB only enables you to perform implicit bindings for inserting, updating, and fetching data. The conversion algorithm for determining the intermediate character set is the same as the implicit binding cases of ODBC.</p>
<div class="tblformalwide">
<p class="titleintable"><a id="NLSPG815"></a><a id="sthref689"></a><a id="sthref690"></a>Table 7-8 OLE DB Implicit Bindings</p>
<table class="cellalignment1914" title="OLE DB Implicit Bindings" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t22">Data Types of OLE_DB Client Buffer</th>
<th class="cellalignment1915" id="r1c2-t22">Data Types of the Target Column in the Database</th>
<th class="cellalignment1915" id="r1c3-t22">In-Binding and Out-Binding Conversions</th>
<th class="cellalignment1915" id="r1c4-t22">Comments</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t22" headers="r1c1-t22">
<p><code>DBTYPE_WCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t22 r1c2-t22">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t22 r1c3-t22">
<p>If database character set is a subset of the <code>NLS_LANG</code> character set:</p>
<p>Database character set to and from <code>NLS_LANG</code> character set in OCI. <code>NLS_LANG</code> character set to UTF-16 in OLE DB</p>
<p>If database character set is NOT a subset of <code>NLS_LANG</code> character set:</p>
<p>Database character set to and from UTF-16 in OCI</p>
</td>
<td class="cellalignment1911" headers="r2c1-t22 r1c4-t22">
<p>No unexpected data loss</p>
<p>May degrade performance if database character set is a subset of <code>NLS_LANG</code> character set</p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t22" headers="r1c1-t22">
<p><code>DBTYPE_CHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t22 r1c2-t22">
<p><code>CHAR, VARCHAR2, CLOB</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t22 r1c3-t22">
<p>If database character set is a subset of the <code>NLS_LANG</code> character set:</p>
<p>Database character set to and from <code>NLS_LANG</code> in OCI</p>
<p>If database character set is not a subset of <code>NLS_LANG</code> character set:</p>
<p>Database character set to and from UTF-16 in OCI. UTF-16 to <code>NLS_LANG</code> character set in OLE DB</p>
</td>
<td class="cellalignment1911" headers="r3c1-t22 r1c4-t22">
<p>No unexpected data loss</p>
<p>May degrade performance if database character set is not a subset of <code>NLS_LANG</code> character set</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACCFFFG"></a><a id="NLSPG377"></a>
<div class="sect2">
<h3 class="sect2">ODBC Unicode Data Types</h3>
<p>In <a id="sthref691"></a>ODBC Unicode applications, use <code>SQLWCHAR</code> to store Unicode data. All standard Windows Unicode functions can be used for <code>SQLWCHAR</code> data manipulations. For example, <code>wcslen</code> counts the number of characters of <code>SQLWCHAR</code> data:</p>
<pre>
SQLWCHAR sqlStmt[] = L"select ename from emp";
len = wcslen(sqlStmt);
</pre>
<p>Microsoft's ODBC 3.5 specification defines three Unicode data type identifiers for the <code>SQL_C_WCHAR</code>, <code>SQL_C_WVARCHAR</code>, and <code>SQL_WLONGVARCHAR</code> clients; and three Unicode data type identifiers for servers <code>SQL_WCHAR</code>, <code>SQL_WVARCHAR</code>, and <code>SQL_WLONGVARCHAR</code>.</p>
<p>For binding operations, specify data types for both client and server using <code>SQLBindParameter</code>. The following is an example of Unicode binding, where the client buffer <code>Name</code> indicates that Unicode data (<code>SQL_C_WCHAR</code>) is bound to the first bind variable associated with the Unicode column (<code>SQL_WCHAR</code>):</p>
<pre>
SQLBindParameter(StatementHandle, 1, SQL_PARAM_INPUT, SQL_C_WCHAR,
SQL_WCHAR, NameLen, 0, (SQLPOINTER)Name, 0, &amp;Name);
</pre>
<p><a href="#g1010407">Table 7-9</a> represents the data type mappings of the ODBC Unicode data types for the server against SQL <code>NCHAR</code> data types.</p>
<div class="tblformal">
<p class="titleintable"><a id="NLSPG816"></a><a id="sthref692"></a><a id="g1010407"></a>Table 7-9 Server ODBC Unicode Data Type Mapping</p>
<table class="cellalignment1916" title="Server ODBC Unicode Data Type Mapping" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t23">ODBC Data Type</th>
<th class="cellalignment1915" id="r1c2-t23">Oracle Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t23" headers="r1c1-t23">
<p><code>SQL_WCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t23 r1c2-t23">
<p><code>NCHAR</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r3c1-t23" headers="r1c1-t23">
<p><code>SQL_WVARCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r3c1-t23 r1c2-t23">
<p><code>NVARCHAR2</code></p>
</td>
</tr>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r4c1-t23" headers="r1c1-t23">
<p><code>SQL_WLONGVARCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r4c1-t23 r1c2-t23">
<p><code>NCLOB</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>According to ODBC specifications, <code>SQL_WCHAR</code>, <code>SQL_WVARCHAR</code>, and <code>SQL_WLONGVARCHAR</code> are treated as Unicode data, and are therefore measured in the number of characters instead of the number of bytes.</p>
</div>
<!-- class="sect2" -->
<a id="i1007268"></a><a id="NLSPG378"></a>
<div class="sect2">
<h3 class="sect2">OLE DB Unicode Data Types</h3>
<p><a id="sthref693"></a>OLE DB offers the <code>wchar_t</code>, <code>BSTR</code>, and <code>OLESTR</code> data types for a Unicode C client. In practice, <code>wchar_t</code> is the most common data type and the others are for specific purposes. The following example assigns a static SQL statement:</p>
<pre>
wchar_t *sqlStmt = OLESTR("SELECT ename FROM emp");
</pre>
<p>The <code>OLESTR</code> macro works exactly like an "L" modifier to indicate the Unicode string. If you need to allocate Unicode data buffer dynamically using <code>OLESTR</code>, then use the <code>IMalloc</code> allocator (for example, <code>CoTaskMemAlloc</code>). However, using <code>OLESTR</code> is not the normal method for variable length data; use <code>wchar_t</code>* instead for generic string types. <code>BSTR</code> is similar. It is a string with a length prefix in the memory location preceding the string. Some functions and methods can accept only <code>BSTR</code> Unicode data types. Therefore, <code>BSTR</code> Unicode string must be manipulated with special functions like <code>SysAllocString</code> for allocation and <code>SysFreeString</code> for freeing memory.</p>
<p>Unlike ODBC, OLE DB does not allow you to specify the server data type explicitly. When you set the client data type, the OLE DB driver automatically performs data conversion if necessary.</p>
<p><a href="#g1010423">Table 7-10</a> illustrates OLE DB data type mapping.</p>
<div class="tblformal">
<p class="titleintable"><a id="NLSPG817"></a><a id="sthref694"></a><a id="g1010423"></a>Table 7-10 OLE DB Data Type Mapping</p>
<table class="cellalignment1916" title="OLE DB Data Type Mapping" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1905">
<th class="cellalignment1915" id="r1c1-t24">OLE DB Data Type</th>
<th class="cellalignment1915" id="r1c2-t24">Oracle Data Type</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1905">
<td class="cellalignment1911" id="r2c1-t24" headers="r1c1-t24">
<p><code>DBTYPE_WCHAR</code></p>
</td>
<td class="cellalignment1911" headers="r2c1-t24 r1c2-t24">
<p><code>NCHAR or NVARCHAR2</code></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>If <code>DBTYPE_BSTR</code> is specified, then it is assumed to be <code>DBTYPE_WCHAR</code> because both are Unicode strings.</p>
</div>
<!-- class="sect2" -->
<a id="i1007296"></a><a id="NLSPG379"></a>
<div class="sect2">
<h3 class="sect2">ADO Access</h3>
<p>ADO <a id="sthref695"></a>is a high-level API to access database with the OLE DB and ODBC drivers. Most database application developers use the ADO interface on Windows because it is easily accessible from Visual Basic, the primary scripting language for Active Server Pages (ASP) for the Internet Information Server (IIS). To OLE DB and ODBC drivers, ADO is simply an OLE DB consumer or ODBC application. ADO assumes that OLE DB and ODBC drivers are Unicode-aware components; hence, it always attempts to manipulate Unicode data.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007741"></a><a id="NLSPG0078"></a>
<div class="sect1">
<h2 class="sect1">XML Programming with Unicode<a id="sthref696"></a><a id="sthref697"></a></h2>
<p>XML support of Unicode is essential for software development for global markets so that text information can be exchanged in any language. Unicode uniformly supports almost every character and language, which makes it much easier to support multiple languages within XML. To enable Unicode for XML within an Oracle database, the character set of the database must be UTF-8. By enabling Unicode text handling in your application, you acquire a basis for supporting any language. Every XML document is Unicode text and potentially multilingual, unless it is guaranteed that only a known subset of Unicode characters will appear on your documents. Thus Oracle recommends that you enable Unicode for XML. Unicode support comes with Java and many other modern programming environments.</p>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#i1008118">Writing an XML File in Unicode with Java</a></p>
</li>
<li>
<p><a href="#i1007760">Reading an XML File in Unicode with Java</a></p>
</li>
<li>
<p><a href="#i1007765">Parsing an XML Stream in Unicode with Java</a></p>
</li>
</ul>
<a id="i1008118"></a><a id="NLSPG380"></a>
<div class="sect2">
<h3 class="sect2">Writing an XML File in Unicode with Java<a id="sthref698"></a><a id="sthref699"></a></h3>
<p>A common mistake in reading and writing XML files is using the <code>Reader</code> and <code>Writer</code> classes for character input and output. Using <code>Reader</code> and <code>Writer</code> for XML files should be avoided because it requires character set conversion based on the default character encoding of the runtime environment.</p>
<p>For example, using <code>FileWriter</code> class is not safe because it converts the document to the default character encoding. The output file can suffer from a parsing error or data loss if the document contains characters that are not available in the default character encoding.</p>
<p>UTF-8 is popular for XML documents, but UTF-8 is not usually the default file encoding for Java. Thus using a Java class that assumes the default file encoding can cause problems.</p>
<p>The following example shows how to avoid these problems:</p>
<pre>
import java.io.*;
import oracle.xml.parser.v2.*;

public class I18nSafeXMLFileWritingSample 
{
  public static void main(String[] args) throws Exception
  {
    // create a test document
    XMLDocument         doc  = new XMLDocument();
    doc.setVersion( "1.0" );
    doc.appendChild(doc.createComment( "This is a test empty document." ));
    doc.appendChild(doc.createElement( "root" ));
    
    // create a file
    File                file = new File( "myfile.xml" );

    // create a binary output stream to write to the file just created
    FileOutputStream    fos  = new FileOutputStream( file );

    // create a Writer that converts Java character stream to UTF-8 stream
    OutputStreamWriter  osw  = new OutputStreamWriter( fos, "UTF8" );

    // buffering for efficiency
    Writer              w    = new BufferedWriter( osw );

    // create a PrintWriter to adapt to the printing method
    PrintWriter         out  = new PrintWriter( w );

    // print the document to the file through the connected objects
    doc.print( out ); 
  }
}
</pre></div>
<!-- class="sect2" -->
<a id="i1007760"></a><a id="NLSPG381"></a>
<div class="sect2">
<h3 class="sect2">Reading an<a id="sthref700"></a><a id="sthref701"></a> XML File in Unicode with Java</h3>
<p>Do not read XML files as text input. When reading an XML document stored in a file system, use the parser to automatically detect the character encoding of the document. Avoid using a <code>Reader</code> class or specifying a character encoding on the input stream. Given a binary input stream with no external encoding information, the parser automatically figures out the character encoding based on the byte order mark and encoding declaration of the XML document. Any well-formed document in any supported encoding can be successfully parsed using the following sample code:</p>
<pre>
import java.io.*;
import oracle.xml.parser.v2.*;

public class I18nSafeXMLFileReadingSample 
{
  public static void main(String[] args) throws Exception
  {
    // create an instance of the xml file
    File                 file = new File( "myfile.xml" );

    // create a binary input stream
    FileInputStream      fis  = new FileInputStream( file );

    // buffering for efficiency
    BufferedInputStream  in = new BufferedInputStream( fis );

    // get an instance of the parser
    DOMParser  parser = new DOMParser();

    // parse the xml file
    parser.parse( in );
  }
}
</pre></div>
<!-- class="sect2" -->
<a id="i1007765"></a><a id="NLSPG382"></a>
<div class="sect2">
<h3 class="sect2">Parsing an XML Stream in Unicode with Java<a id="sthref702"></a><a id="sthref703"></a></h3>
<p>When the source of an XML document is not a file system, the encoding information is usually available before reading the document. For example, if the input document is provided in the form of a Java character stream or Reader, its encoding is evident and no detection should take place. The parser can begin parsing a Reader in Unicode without regard to the character encoding.</p>
<p>The following is an example of parsing a document with external encoding information:</p>
<pre>
import java.io.*;
import java.net.*;
import org.xml.sax.*;
import oracle.xml.parser.v2.*;

public class I18nSafeXMLStreamReadingSample 
{
  public static void main(String[] args) throws Exception
  {
    // create an instance of the xml file
    URL  url = new URL( "http://myhost/mydocument.xml" );

    // create a connection to the xml document    
    URLConnection  conn = url.openConnection();

    // get an input stream
    InputStream  is = conn.getInputStream();

    // buffering for efficiency
    BufferedInputStream  bis = new BufferedInputStream( is );

    /* figure out the character encoding here                              */
    /* a typical source of encoding information is the content-type header */
    /* we assume it is found to be utf-8 in this example                   */
    String  charset = "utf-8";

    // create an InputSource for UTF-8 stream
    InputSource  in = new InputSource( bis );
    in.setEncoding( charset );
    
    // get an instance of the parser
    DOMParser  parser = new DOMParser();

    // parse the xml stream
    parser.parse( in );  
  }
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1904">
<tr>
<td class="cellalignment1911">
<table class="cellalignment1909">
<tr>
<td class="cellalignment1908"><a href="ch6unicode.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1908"><a href="ch8gdk.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1913">
<table class="cellalignment1907">
<tr>
<td class="cellalignment1908"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1908"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1908"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1908"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1908"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1908"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
