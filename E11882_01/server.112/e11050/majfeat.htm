<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Features of Oracle Database Gateways</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.1 Build 005" />
<meta name="dcterms.created" content="2009-07-31T22:45:59Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Heterogeneous Connectivity User's Guide" />
<meta name="dcterms.identifier" content="E11050-01" />
<meta name="dcterms.isVersionOf" content="HETER" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="tgvsgc.htm" title="Previous" type="text/html" />
<link rel="Next" href="admin.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e11050.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/12</span> <!-- End Header --><a id="g1015441"></a><a id="i1005901"></a>
<h1 class="chapter"><span class="secnum">3</span> <a id="HETER003"></a>Features of Oracle Database Gateways</h1>
<p>This chapter describes the major features provided by Oracle Database gateways. Descriptions of these features are in the following topics:</p>
<ul>
<li>
<p>SQL and PL/SQL Support</p>
</li>
<li>
<p>Heterogeneous Replication</p>
</li>
<li>
<p>Passthrough SQL</p>
</li>
<li>
<p>Result Set Support</p>
</li>
<li>
<p>Data Dictionary Translations</p>
</li>
<li>
<p>Date-Time Data Types</p>
</li>
<li>
<p>Two-Phase Commit Protocol</p>
</li>
<li>
<p>Piecewise LONG Data Type</p>
</li>
<li>
<p>SQL*Plus DESCRIBE Command</p>
</li>
<li>
<p>Constraints on SQL in a Distributed Environment</p>
</li>
<li>
<p>Oracle's Optimizer and Heterogeneous Services</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
These features may not be available in all Heterogeneous Services gateways. Not only must there be generic support for these features, which Heterogeneous Services provides, but there must also be support added to the driver for them. Consult the appropriate gateway documentation to determine if a particular feature is supported for your gateway.</div>
</li>
</ul>
<a id="i1005954"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.1</span> SQL and PL/SQL Support</h2>
<p>SQL statements are translated and data types are mapped according to capabilities. PL/SQL calls are mapped to non-Oracle system stored procedures. With SQL statements, if functionality is missing at the remote system, then either a simpler query is issued or the statement is broken up into multiple queries. Then, the desired results are obtained by postprocessing in the Oracle database.</p>
<p>Even though Heterogeneous Services can, for the most part, incorporate non-Oracle systems into Oracle distributed sessions, there are several limitations to this. Some of the generic limitations are:</p>
<ul>
<li>
<p>There is no support for <code>CONNECT BY</code> clauses in SQL statements.</p>
</li>
<li>
<p><code>ROWID</code> support is limited; consult individual gateway documentation for more details. The Oracle Universal <code>ROWID</code> data type is not supported in any gateway that uses Heterogeneous Services.</p>
</li>
<li>
<p>Large objects (LOBs), abstract data types (ADTs), and reference data types (REFs) are not supported.</p>
</li>
<li>
<p>Remote packages are not supported.</p>
</li>
<li>
<p>Remote stored procedures can have <code>out</code> arguments of type <code>REF CURSOR</code> but not <code>in</code> or <code>in-out</code> objects.</p>
</li>
<li>
<p>Oracle Heterogeneous Services agents do not support shared database links.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In addition to these generic limitations, each gateway can have additional limitations. See the gateway documentation for individual gateways for a complete list of limitations of the product.</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1005975"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.2</span> Heterogeneous Replication</h2>
<p>Data can be replicated between a non-Oracle system and Oracle Database using materialized views.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There is another means of replicating information between Oracle and non-Oracle databases called <a id="sthref37"></a>Oracle Streams.
<p>For information about using Oracle Streams, see <span class="italic"><a class="olink STRMS" href="../e17069/toc.htm">Oracle Streams Concepts and Administration</a>.</span></p>
</div>
<p>Materialized views instantiate data captured from tables at the non-Oracle master site at a particular time. This instant is defined by a refresh operation, which copies this data to Oracle Database and synchronizes the copy on the Oracle system with the master copy on the non-Oracle system. The materialized data is then available as a view on Oracle Database.</p>
<p>Replication facilities provide mechanisms to schedule refreshes and to collect materialized views into replication groups to facilitate their administration. Refresh groups permit refreshing multiple materialized views as if they were a single object.</p>
<p>Heterogeneous replication support is necessarily limited to a subset of the full Oracle-to-Oracle replication functionality:</p>
<ul>
<li>
<p>Only the non-Oracle system can be the primary site. This is because materialized views can be created only on Oracle Database.</p>
</li>
<li>
<p>Materialized views must use a complete refresh. This is because fast refresh would require Oracle-specific functionality in the non-Oracle system.</p>
</li>
<li>
<p>Not all types of materialized views can be created to reference tables on a non-Oracle system. Primary key and subquery materialized views are supported, but <code>ROWID</code> and <code>OBJECT ID</code> materialized views are not supported. This is because there is no SQL standard for the format and contents of <code>ROWID</code>, and non-Oracle systems do not implement Oracle objects.</p>
</li>
</ul>
<p>Other restrictions apply to any access to non-Oracle data through Oracle's Heterogeneous Services facilities. The most important of these are:</p>
<ul>
<li>
<p>Non-Oracle data types in table columns mapped to a fixed view must be compatible with (that is, have a mapping to or from) Oracle data types. This is usually true for data types defined by ANSI SQL standards.</p>
</li>
<li>
<p>A subquery materialized view may not be able to use language features restricted by individual non-Oracle systems. In many cases, Heterogeneous Services supports such language features by processing queries within Oracle Database. Occasionally the non-Oracle systems impose limitations that cannot be detected until Heterogeneous Services attempts to execute the query.</p>
</li>
</ul>
<p>The following examples illustrate basic setup and use of three materialized views to replicate data from a non-Oracle system to an Oracle data store.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For the following examples, <code>remote_db</code> refers to the non-Oracle system that you are accessing from Oracle Database.
<p>Modify these examples for your environment. Do not try to execute them as they are written.</p>
</div>
<p class="subhead1"><a id="sthref38"></a>Example 1: Create Materialized Views for Heterogeneous Replication</p>
<p>This example creates three materialized views that are then used in subsequent examples.</p>
<ol>
<li>
<p>Create a primary key materialized view of table <code>customer@remote_db</code>.</p>
</li>
</ol>
<pre>
    CREATE MATERIALIZED VIEW pk_mv REFRESH COMPLETE AS
      SELECT * FROM customer@remote_db WHERE "zip" = 94555;
</pre>
<ol start="2">
<li>
<p>Create a subquery materialized view of tables <code>orders@remote_db</code> and <code>customer@remote_db</code>.</p>
</li>
</ol>
<pre>
    CREATE MATERIALIZED VIEW sq_mv REFRESH COMPLETE AS
      SELECT * FROM orders@remote_db o WHERE EXISTS
        (SELECT c."c_id" FROM customer@remote_db c
           WHERE c."zip" = 94555 and c."c_id"  = o."c_id" );
</pre>
<ol start="3">
<li>
<p>Create a complex materialized view of data from multiple tables on <code>remote_db</code><code><span class="codeinlineitalic">.</span></code></p>
</li>
</ol>
<pre>
    CREATE MATERIALIZED VIEW cx_mv
      REFRESH COMPLETE AS
      SELECT  c."c_id", o."o_id"
        FROM customer@remote_db c,
             orders@remote_db o,
             order_line@remote_db ol
        WHERE c."c_id" = o."c_id"
        AND o."o_id" = ol."o_id";
</pre>
<p class="subhead1"><a id="sthref39"></a>Example 2: Set Up a Refresh Group for Heterogeneous Replication</p>
<pre>
BEGIN
  dbms_refresh.make('refgroup1',
   'pk_mv, sq_mv, cx_mv',
   NULL, NULL);
 END;
 /
</pre>
<p class="subhead1"><a id="sthref40"></a>Example 3: Force Refresh of All Three Materialized Views</p>
<pre>
BEGIN
   dbms_refresh.refresh('refgroup1');
END;
 /
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic"><a class="olink REPLN" href="../e10706/toc.htm">Oracle Database Advanced Replication</a></span> for a complete description of materialized views and replication facilities</div>
</div>
<!-- class="sect1" -->
<a id="i1006049"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.3</span> Passthrough SQL<a id="sthref41"></a><a id="sthref42"></a></h2>
<p><a id="sthref43"></a><a id="sthref44"></a>The<a id="sthref45"></a> <a id="sthref46"></a>passthrough SQL feature enables you to send a statement directly to a non-Oracle system without first being interpreted by Oracle Database. This feature can be useful if the non-Oracle system allows for operations in statements for which there is no equivalent in Oracle.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p>Using the DBMS_HS_PASSTHROUGH Package</p>
</li>
<li>
<p>Considering the Implications of Using Passthrough SQL</p>
</li>
<li>
<p>Executing Passthrough SQL Statements</p>
</li>
</ul>
<a id="i1007905"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.3.1</span> Using the DBMS_HS_PASSTHROUGH Package</h3>
<p>You can execute passthrough SQL statements directly on the non-Oracle system using the PL/SQL package <a id="sthref47"></a><code>DBMS_HS_PASSTHROUGH</code>. Any statement executed with this package is executed in the same transaction as standard SQL statements.</p>
<p>The <code>DBMS_HS_PASSTHROUGH</code> package is a virtual package. It conceptually resides on the non-Oracle system. In reality, however, calls to this package are intercepted by Heterogeneous Services and are mapped to one or more Heterogeneous Services calls. The driver then maps these Heterogeneous Services calls to the API of the non-Oracle system. The client application invokes the procedures in the package through a database link in the same way as it would invoke a non-Oracle system stored procedure. The special processing done by Heterogeneous Services is transparent to the user.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic"><a class="olink ARPLS017" href="../../appdev.112/e40758/d_hspass.htm#ARPLS017">Oracle Database PL/SQL Packages and Types Reference</a></span> for more information about this package</div>
</div>
<!-- class="sect2" -->
<a id="i1006083"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.3.2</span> Considering the Implications of Using Passthrough SQL</h3>
<p><a id="sthref48"></a>When you execute a <a id="sthref49"></a>passthrough SQL statement that implicitly commits or rolls back a transaction in a non-Oracle system, the transaction is affected. For example, some systems implicitly commit the transaction containing a data definition language (DDL) statement. Because Oracle Database is bypassed, Oracle Database is unaware that a transaction was committed in the non-Oracle system. Consequently, the data at the non-Oracle system can be committed, while the transaction in Oracle Database is not.</p>
<p>If the transaction in Oracle Database is rolled back, data inconsistencies between Oracle Database and the non-Oracle system can occur. This situation results in <span class="bold">global data inconsistency.</span></p>
<p>Note that if the application executes a typical <code>COMMIT</code> statement, Oracle Database can coordinate the distributed transaction with the non-Oracle system. The statement executed with the passthrough facility is part of the distributed transaction.</p>
</div>
<!-- class="sect2" -->
<a id="i1006090"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.3.3</span> Executing <a id="sthref50"></a>Passthrough SQL Statements</h3>
<p>The following table shows the functions and procedures provided by the <code><a id="sthref51"></a>DBMS_HS_PASSTHROUGH</code> package that enable you to execute passthrough SQL statements.</p>
<div class="inftblruleinformal">
<table class="cellalignment1573" title="Functions and procedures provided by DBMS_HS_PASSTHROUGH" summary="This table is described in the preceding text" dir="ltr">
<thead>
<tr class="cellalignment1567">
<th class="cellalignment1574" id="r1c1-t8">Procedure/Function</th>
<th class="cellalignment1574" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r2c1-t8" headers="r1c1-t8"><code><a id="sthref52"></a>OPEN_CURSOR</code></td>
<td class="cellalignment1575" headers="r2c1-t8 r1c2-t8">Opens a cursor.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r3c1-t8" headers="r1c1-t8"><code><a id="sthref53"></a>CLOSE_CURSOR</code></td>
<td class="cellalignment1575" headers="r3c1-t8 r1c2-t8">Closes a cursor.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r4c1-t8" headers="r1c1-t8"><code><a id="sthref54"></a>PARSE</code></td>
<td class="cellalignment1575" headers="r4c1-t8 r1c2-t8">Parses the statement.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r5c1-t8" headers="r1c1-t8"><code><a id="sthref55"></a>BIND_VARIABLE</code></td>
<td class="cellalignment1575" headers="r5c1-t8 r1c2-t8">Binds <code>IN</code> variables.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r6c1-t8" headers="r1c1-t8"><code><a id="sthref56"></a>BIND_OUT_VARIABLE</code></td>
<td class="cellalignment1575" headers="r6c1-t8 r1c2-t8">Binds <code>OUT</code> variables.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r7c1-t8" headers="r1c1-t8"><code><a id="sthref57"></a>BIND_INOUT_VARIABLE</code></td>
<td class="cellalignment1575" headers="r7c1-t8 r1c2-t8">Binds <code>IN OUT</code> variables.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r8c1-t8" headers="r1c1-t8"><code><a id="sthref58"></a>EXECUTE_NON_QUERY</code></td>
<td class="cellalignment1575" headers="r8c1-t8 r1c2-t8">Executes a nonquery statement.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r9c1-t8" headers="r1c1-t8"><code><a id="sthref59"></a>EXECUTE_IMMEDIATE</code></td>
<td class="cellalignment1575" headers="r9c1-t8 r1c2-t8">Executes a nonquery statement without bind variables.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r10c1-t8" headers="r1c1-t8"><code><a id="sthref60"></a>FETCH_ROW</code></td>
<td class="cellalignment1575" headers="r10c1-t8 r1c2-t8">Fetches rows from query.</td>
</tr>
<tr class="cellalignment1567">
<td class="cellalignment1575" id="r11c1-t8" headers="r1c1-t8"><code><a id="sthref61"></a>GET_VALUE</code></td>
<td class="cellalignment1575" headers="r11c1-t8 r1c2-t8">Retrieves column value from <code>SELECT</code> statement or retrieves <code>OUT</code> bind parameters.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<a id="i1006151"></a>
<div class="sect3">
<h4 class="sect3"><span class="secnum">3.3.3.1</span> Executing Nonqueries</h4>
<p><a id="sthref62"></a>Nonqueries include the following statements and types of statements:</p>
<ul>
<li>
<p>INSERT</p>
</li>
<li>
<p>UPDATE</p>
</li>
<li>
<p>DELETE</p>
</li>
<li>
<p>DDL</p>
</li>
</ul>
<p>To execute nonquery statements, use the <code>EXECUTE_IMMEDIATE</code> function. For example, to execute a DDL statement on a non-Oracle system that you can access using the database link <code>salesdb</code>, enter the following:</p>
<pre>
DECLARE
  num_rows INTEGER;

BEGIN
  num_rows := DBMS_HS_PASSTHROUGH.EXECUTE_IMMEDIATE@salesdb
            ('CREATE TABLE dept1 (n SMALLINT, loc CHARACTER(10))');
END;

</pre>
<p>The variable <code><span class="codeinlineitalic">num_rows</span></code> is assigned the number of rows affected by the statements that were executed. For DDL statements, zero is returned. Note that you cannot execute a query with <a id="sthref63"></a><code>EXECUTE_IMMEDIATE</code> function and you cannot use bind variables.</p>
<div class="sect4"><a id="sthref64"></a>
<h5 class="sect4"><span class="secnum">3.3.3.1.1</span> Using Bind Variables: Overview</h5>
<p>Bind <a id="sthref65"></a>variables let you use the same SQL statement multiple times with different values, reducing the number of times a SQL statement needs to be parsed. For example, when you insert four rows in a table, you can parse the SQL statement once, and bind and execute the SQL statement for each row. One SQL statement can have zero or more bind variables.</p>
<p>To execute <a id="sthref66"></a>passthrough SQL statements with bind variables, you must:</p>
<ol>
<li>
<p>Open a cursor.</p>
</li>
<li>
<p>Parse the SQL statement on the non-Oracle system.</p>
</li>
<li>
<p>Bind the variables.</p>
</li>
<li>
<p>Execute the SQL statement on the non-Oracle system.</p>
</li>
<li>
<p>Close the cursor.</p>
</li>
</ol>
<p><a href="#i1006184">Figure 3-1</a> shows the flow diagram for executing nonqueries with bind variables.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006184"></a>Figure 3-1 Flow Diagram for Nonquery Passthrough SQL</p>
<img width="600" height="483" src="img/heter007.gif" alt="Description of Figure 3-1 follows" title="Description of Figure 3-1 follows" /><br />
<a id="sthref67" href="img_text/heter007.htm">Description of "Figure 3-1 Flow Diagram for Nonquery Passthrough SQL"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect4" -->
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref68"></a>
<h5 class="sect4"><span class="secnum">3.3.3.1.2</span> Using IN Bind Variables</h5>
<p>The syntax of the non-Oracle system <a id="sthref69"></a>determines how a statement specifies a bind variable. For example, on an Oracle system you define bind variables with a preceding colon. For example:</p>
<pre>
...
UPDATE emp
SET sal=sal*1.1
WHERE ename=:ename;
...
</pre>
<p>In this statement<code>,</code> <code>ename</code> is the bind variable. On non-Oracle systems, you may need to specify bind variables with a question mark. For example:</p>
<pre>
...
UPDATE emp
SET sal=sal*1.1
WHERE ename= ?;
...
</pre>
<p>In the bind variable step, you must positionally associate host program variables (in this case, PL/SQL) with each of these bind variables. For example, to execute the preceding statement, use the following PL/SQL program:</p>
<pre>
<a id="i1006205"></a>
DECLARE
  c INTEGER;
  nr INTEGER;
BEGIN
  c := DBMS_HS_PASSTHROUGH.OPEN_CURSOR@salesdb;
  DBMS_HS_PASSTHROUGH.PARSE@salesdb(c,
        'UPDATE emp SET SAL=SAL*1.1 WHERE ename=?');
  DBMS_HS_PASSTHROUGH.BIND_VARIABLE@salesdb(c,1,'JONES');
  nr:=DBMS_HS_PASSTHROUGH.EXECUTE_NON_QUERY@salesdb(c);
  DBMS_OUTPUT.PUT_LINE(nr||' rows updated');
  DBMS_HS_PASSTHROUGH.CLOSE_CURSOR@salesdb(c);
END;
</pre></div>
<!-- class="sect4" -->
<div class="sect4"><a id="sthref70"></a>
<h5 class="sect4"><span class="secnum">3.3.3.1.3</span> Using OUT Bind Variables</h5>
<p><a id="sthref71"></a><a id="sthref72"></a>The non-Oracle system can support <code>OUT</code> bind variables. With <code>OUT</code> bind variables, the value of the bind variable is not known until after the execution of the SQL statement.</p>
<p>Although <code>OUT</code> bind variables are populated after executing the SQL statement, the non-Oracle system must know that the particular bind variable is an <code>OUT</code> bind variable before the SQL statement is executed. You must use the <a id="sthref73"></a><code>BIND_OUT_VARIABLE</code> procedure to specify that the bind variable is an <code>OUT</code> bind variable.</p>
<p>After executing the SQL statement, you can retrieve the value of the <code>OUT</code> bind variable using the <a id="sthref74"></a><code>GET_VALUE</code> procedure.</p>
</div>
<!-- class="sect4" -->
<div class="sect4"><a id="sthref75"></a>
<h5 class="sect4"><span class="secnum">3.3.3.1.4</span> Using IN OUT Bind Variables</h5>
<p><a id="sthref76"></a>A bind variable can be both an <code>IN</code> and an <code>OUT</code> variable. This means that the value of the bind variable must be known before executing the SQL statement, but you can change the value after the SQL statement is executed.</p>
<p>For <code>IN OUT</code> bind variables, you must use the<a id="sthref77"></a> <code>BIND_INOUT_VARIABLE</code> procedure to provide a value before executing the SQL statement. After executing the SQL statement, you must use the <code><a id="sthref78"></a>GET_VALUE</code> procedure to retrieve the new value of the bind variable.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006232"></a>
<div class="sect3">
<h4 class="sect3"><span class="secnum">3.3.3.2</span> Executing Queries<a id="sthref79"></a></h4>
<p><a id="sthref80"></a><a id="sthref81"></a>The difference between queries and nonqueries is that queries retrieve a result set from a <code>SELECT</code> statement. The result set is retrieved by using a cursor.</p>
<p><a href="#i1006242">Figure 3-2</a> illustrates the steps in a passthrough SQL query. After the system parses the <code>SELECT</code> statement, each row of the result set can be retrieved with the <code><a id="sthref82"></a>FETCH_ROW</code> procedure. After the row is retrieved, use the <code>GET_VALUE</code> procedure to retrieve the selected list of items into program variables. After all rows are retrieved, you can close the cursor.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1006242"></a>Figure 3-2 Passthrough SQL for Queries</p>
<img width="600" height="470" src="img/heter008.gif" alt="Description of Figure 3-2 follows" title="Description of Figure 3-2 follows" /><br />
<a id="sthref83" href="img_text/heter008.htm">Description of "Figure 3-2 Passthrough SQL for Queries"</a><br />
<br /></div>
<!-- class="figure" -->
<p>You do not have to retrieve all the rows. You can close the cursor at any time after opening the cursor.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Although you are retrieving one row at a time, Heterogeneous Services <a id="sthref84"></a>optimizes the round-trips between Oracle Database and the non-Oracle system by <a id="sthref85"></a>buffering<a id="sthref86"></a> multipl<a id="sthref87"></a>e rows and fetching from the non-Oracle data system in one round-trip.</div>
<p>The following example executes a query:</p>
<pre>
DECLARE
   val  VARCHAR2(100);
   c    INTEGER;
   nr   INTEGER;
BEGIN
  c := DBMS_HS_PASSTHROUGH.OPEN_CURSOR@salesdb; 
  DBMS_HS_PASSTHROUGH.PARSE@salesdb(c, 
    'select ENAME
     from   EMP
     where  DEPTNO=10');
  LOOP
    nr := DBMS_HS_PASSTHROUGH.FETCH_ROW@salesdb(c);
    EXIT WHEN nr = 0;
    DBMS_HS_PASSTHROUGH.GET_VALUE@salesdb(c, 1, val);
    DBMS_OUTPUT.PUT_LINE(val);
  END LOOP;  
  DBMS_HS_PASSTHROUGH.CLOSE_CURSOR@salesdb(c); 
END;
</pre>
<p>After the <code>SELECT</code> statement has been parsed, the rows are fetched and printed in a loop until the <code>FETCH_ROW</code> function returns the value <code>0</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006287"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.4</span> Result Set Support</h2>
<p>Various relational databases enable stored procedures to return result sets (one or more sets of rows).</p>
<p>Traditionally, database stored procedures worked exactly like procedures in any high-level programming language. They had a fixed number of arguments which could be of types <code>IN</code>, <code>OUT</code>, or <code>IN OUT</code>. If a procedure had <code>n</code> arguments, it could return at most <code>n</code> values as results. However, suppose that you wanted a stored procedure to execute a query such as <code>SELECT * FROM emp</code> and return the results. The <code>emp</code> table might have a fixed number of columns, but there is no way of telling, at procedure creation time, the number of rows it has. Because of this, no traditional stored procedure could be created that returned the results of this type of query. As a result, several relational database vendors added the ability to return results sets from stored procedures, but each relational database returns result sets from stored procedures differently.</p>
<p>Oracle has a data type called a <code>REF CURSOR</code>. Like every other Oracle data type, a stored procedure can take this data type as an <code>IN</code> or <code>OUT</code> argument. With Oracle Database, a stored procedure must have an output argument of type <code>REF CURSOR</code>. It then opens a cursor for a SQL statement and places a handle to that cursor in that output parameter. The caller can then retrieve from the <code>REF CURSOR</code> the same way as from any other cursor.</p>
<p>Oracle Database can do a lot more than return result sets. The <code>REF CURSOR</code> data type can be passed as an input argument to PL/SQL routines to be passed back and forth between client programs and PL/SQL routines or as an input argument between several PL/SQL routines.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p>Result Set Support for Non-Oracle Systems</p>
</li>
<li>
<p>Heterogeneous Services Support for Result Sets</p>
</li>
</ul>
<div class="sect2"><a id="sthref88"></a>
<h3 class="sect2"><span class="secnum">3.4.1</span> Result Set Support for Non-Oracle Systems</h3>
<p>Several non-Oracle systems allow stored procedures to return result sets, but they do so in different ways. Result set support for non-Oracle databases is typically based on one of the following two models.</p>
<ul>
<li>
<p>Model 1: Result Set Support</p>
<p>When creating a stored procedure, you can explicitly specify the maximum number of result sets that can be returned by that stored procedure. While executing, the stored procedure can open anywhere from zero up to its specified maximum number of result sets. After the execution of the stored procedure, a client program gets handles to these result sets by using either an embedded SQL directive or by calling a client library function. After that, the client program can retrieve from the result set in the same way as from a typical cursor.</p>
</li>
<li>
<p>Model 2: Result Set Support</p>
<p>In this model, there is no specified limit to the number of result sets that can be returned by a stored procedure. Both Model 1 and Oracle Database have a limit. For Oracle Database, the number of result sets returned by a stored procedure can be at most the number of <code>REF CURSOR OUT</code> arguments. For Model 1, the upper limit is specified using a directive in the stored procedure language. Another way that Model 2 differs from Oracle Database and Model 1 is that they do not return a handle to the result sets. Instead, they place the entire result set on the wire when returning from a stored procedure. For Oracle Database, the handle is the <code>REF CURSOR OUT</code> argument. For Model 1, it is obtained separately after the execution of the stored procedure. For both Oracle Database and Model 1, after the handle is obtained, data from the result set is obtained by doing a fetch on the handle; there are several cursors open and the fetch can be in any order. In the case of Model 2, however, all the data is already on the wire, with the result sets coming in the order determined by the stored procedure and the output arguments of the procedures coming at the end. The entire first result set must be retrieved, then the entire second result set, until all of the results are retrieved. Finally, the stored procedure <code>OUT</code> arguments are retrieved.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div class="sect2"><a id="sthref89"></a>
<h3 class="sect2"><span class="secnum">3.4.2</span> Heterogeneous Services Support for Result Sets</h3>
<p>Result set support exists among non-Oracle databases in different forms. All of these must be mapped to the Oracle <code>REF CURSOR</code> model. Due to the differences in behavior among the non-Oracle systems, Heterogeneous Services result set support acts in one of two different ways depending on the non-Oracle system to which it is connected.</p>
<p>Note the following about Heterogeneous Services result set support:</p>
<ul>
<li>
<p>Result set support is part of the Heterogeneous Services generic code, but for the feature to work in a gateway, the driver has to implement it. Not all drivers have implemented result set support and you must verify that your gateway is supported.</p>
</li>
<li>
<p>Heterogeneous Services supports <code>REF CURSOR OUT</code> arguments from stored procedures. <code>IN</code> and <code>IN OUT</code> arguments are not supported.</p>
</li>
<li>
<p>The <code>REF CURSOR OUT</code> arguments are all anonymous reference cursors. <code>REF CURSOR</code>s that are returned by Heterogeneous Services do not have types.</p>
</li>
</ul>
<div class="sect3"><a id="sthref90"></a>
<h4 class="sect3"><span class="secnum">3.4.2.1</span> Results Sets: Cursor Mode</h4>
<p>Each result set returned by a non-Oracle system stored procedure is mapped by an Oracle driver to an <code>OUT</code> argument of type <code>REF CURSOR</code>. The client program detects a stored procedure with several <code>OUT</code> arguments of type <code>REF CURSOR</code>. After executing the stored procedure, the client program can fetch from the <code>REF CURSOR</code> the same way as it would from a <code>REF CURSOR</code> returned by an Oracle stored procedure. When connecting to the gateway as described in Section&nbsp;3.4.1.1, Heterogeneous Services will be in cursor mode.</p>
</div>
<!-- class="sect3" -->
<div class="sect3"><a id="sthref91"></a>
<h4 class="sect3"><span class="secnum">3.4.2.2</span> Result Sets: Sequential Mode</h4>
<p>There is a maximum number of result sets that a particular stored procedure can return. The number of result sets returned is at most the number of <code>REF CURSOR OUT</code> arguments for the stored procedure. It can return fewer result sets, but it can never return more.</p>
<p>For the system described in Section&nbsp;3.4.1.2, there is no maximum number of result sets that can be returned. In the case of Model 1 (in Section&nbsp;3.4.1.1), the maximum number of result sets that a procedure can return is known, and that the driver can return to Heterogeneous Services, is specified in the stored procedure by the number of <code>REF CURSOR OUT</code> arguments. If, when the stored procedure is executed, fewer result sets than the maximum are returned, then the other <code>REF CURSOR OUT</code> arguments are set to <code>NULL</code>.</p>
<p>Another problem for Model 2 database servers is that result sets must be retrieved in the order in which they were placed on the wire by the database. This prevents Heterogeneous Services from running in cursor mode when connecting to these databases. To access result sets returned by these stored procedures, Heterogeneous Services must be in sequential mode.</p>
<p>In sequential mode, the procedure description returned by the driver contains the following:</p>
<ul>
<li>
<p>All the input arguments of the remote stored procedure</p>
</li>
<li>
<p>None of the output arguments</p>
</li>
<li>
<p>One <code>OUT</code> argument of type <code>REF CURSOR</code> (corresponding to the first result set returned by the stored procedure)</p>
</li>
</ul>
<p>The client fetches from this <code>REF CURSOR</code> and then calls the virtual package function <code>DBMS_HS_RESULT_SET.GET_NEXT_RESULT_SET</code> to fetch the <code>REF CURSOR</code> corresponding to the next result set. This function call repeats until all result sets are retrieved. The last result set returned will be the <code>OUT</code> arguments of the remote stored procedure.</p>
<p>The primary limitations of sequential mode are:</p>
<ul>
<li>
<p>Result sets returned by a remote stored procedure must be retrieved in the order in which they were placed on the wire.</p>
</li>
<li>
<p>When a stored procedure is executed, all result sets returned by a previously executed stored procedure are closed (regardless of whether or not the data was retrieved).</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Your gateway-specific manual for more information about how result sets are supported through the gateway</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006597"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.5</span> Data Dictionary Translations</h2>
<p>Most database systems have some form of data dictionary. A data dictionary is a collection of information about the database objects that were created by various users of the system. For a relational database, a data dictionary is a set of tables and views that contain information about the data in the database. This information includes information about the users who are using the system and about the objects that they created (such as tables, views, and triggers). Almost all data dictionaries (regardless of the database system) contain the same information, but each database system organizes the information differently.</p>
<p>For example, the <code>ALL_CATALOG</code> Oracle data dictionary view gives a list of tables, views, and sequences in the database. It has three columns: the first is called <code>OWNER</code>, and it is the name of the owner of the object; the second is called <code>TABLE_NAME</code>, and it is the name of the object; and the third is called <code>TABLE_TYPE</code>, and it is the data type. This field has value <code>TABLE</code>, <code>VIEW</code>, <code>SEQUENCE</code> and so forth depending on the object type. However, in Sybase, the same information is stored in two tables called <code>sysusers</code> and <code>sysobjects</code> whose column names are different from those of the Oracle <code>ALL_CATALOG</code> table. Additionally, in Oracle Database, the table type is a string with a value such as <code>TABLE</code> or <code>VIEW</code>. With Sybase, it is a letter, for example, <code>U</code> means user table; <code>S</code> means system table; <code>V</code> means view, and so forth.</p>
<p>If the client program requires information from the table <code>ALL_CATALOG</code> on a Sybase system, it sends a query referencing <code>ALL_CATALOG@</code><code><span class="codeinlineitalic">database_link</span></code> to a gateway. Heterogeneous Services translates this query to an appropriate query on <code>systables</code> and then sends the translated query to the Sybase system, for example:</p>
<pre>
SELECT SU."name" OWNER, SO."name" TABLE_NAME,
   DECODE(SO."type", 'U ','TABLE', 'S ', 'TABLE', 'V ', 'VIEW')
TABLE_TYPE
FROM "dbo"."sysusers"@remote_db  SU, "dbo"."sysobjects"@remote_db SO
WHERE SU."uid" = SO."uid" AND
   (SO."type" = 'V' OR SO."type" = 'S' OR SO."type" = 'U');
</pre>
<p>To relay the translation of a query on an Oracle data dictionary table to the equivalent one on the non-Oracle system data dictionary table, Heterogeneous Services needs data dictionary translations for that non-Oracle system. A data dictionary translation is a view definition (essentially a <code>SELECT</code> statement) of one or more non-Oracle system data dictionary tables that look like the Oracle data dictionary table, with the same column names and the same formatting. Most data dictionary translations are not as simple as the preceding example. Often, the information is scattered over many tables, and the data dictionary translation is a complex join of those tables.</p>
<p>In some cases, an Oracle data dictionary table does not have a translation because the information does not exist on the non-Oracle system. In such cases, the gateway must not upload a translation, or the gateway might implement an alternative approach called <span class="bold">mimicking.</span> If the gateway mimics a data dictionary table, it informs Heterogeneous Services, and Heterogeneous Services will get the description of the data dictionary table by querying the local database. When asked to retrieve data, it will report that no rows were selected.</p>
</div>
<!-- class="sect1" -->
<a id="i1006669"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.6</span> Date-Time Data Types</h2>
<p>Oracle Database has five date-time data types:</p>
<ul>
<li>
<p><code>TIMESTAMP</code></p>
</li>
<li>
<p><code>TIMESTAMP WITH TIME ZONE</code></p>
</li>
<li>
<p><code>TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</li>
<li>
<p><code>INTERVAL YEAR TO MONTH</code></p>
</li>
<li>
<p><code>INTERVAL DAY TO SECOND</code></p>
</li>
</ul>
<p>Heterogeneous Services generic code supports Oracle date-time data types in SQL and stored procedures. Heterogeneous Services does not support these data types in data dictionary translations or queries involving data dictionary translations.</p>
<p>Even though Heterogeneous Services generic code supports date-time data types, support for a particular gateway depends on whether or not the driver for that non-Oracle system implemented date-time support. Support, even when the driver implements it, may be partial because of the limitations of the non-Oracle system. For more information, see your gateway-specific documentation.</p>
<p>You must set the timestamp formats of the non-Oracle system in the gateway initialization file. The parameters to set are <code>HS_NLS_TIMESTAMP_FORMAT</code> and <code>HS_NLS_TIMESTAMP_TZ_FORMAT</code>. You should also set the local time zone for the non-Oracle system in the initialization file by setting <code>HS_TIME_ZONE</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic"><a class="olink SQLRF" href="../e41084/toc.htm">Oracle Database SQL Language Reference</a></span> for information about datetime data types</div>
</div>
<!-- class="sect1" -->
<a id="i1006690"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.7</span> Two-Phase Commit Protocol</h2>
<p>Heterogeneous Services provides the infrastructure to implement the two-phase commit protocol. The extent to which this is supported depends on the gateway and the remote system. For more information, see your gateway-specific documentation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<span class="italic"><a class="olink ADMIN" href="../e25494/toc.htm">Oracle Database Administrator's Guide</a></span> for more information about the two-phase commit protocol</div>
</div>
<!-- class="sect1" -->
<a id="i1006700"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.8</span> Piecewise LONG Data Type</h2>
<p>Earlier versions of gateways had limited support for the <code>LONG</code> data type. <code>LONG</code> is an Oracle data type that can store up to 2 GB of character data or raw data (<code>LONG RAW</code>). These earlier versions restricted the amount of <code>LONG</code> data to 4 MB because they treated <code>LONG</code> data as a single piece. This caused memory and network bandwidth restrictions on the size of the data that could be handled. Current gateways extended the functionality to support the full 2 GB of heterogeneous <code>LONG</code> data. The gateways now manage the data piecewise between the agent and Oracle Database, eliminating the large memory and network bandwidth requirements.</p>
<p>The <code>HS_LONG_PIECE_TRANSFER_SIZE</code> Heterogeneous Services initialization parameter can be used to set the size of the transferred pieces. For example, consider retrieving 2 GB of <code>LONG</code> data from a heterogeneous source. A smaller piece requires less memory, but it requires more round-trips to retrieve all the data. A larger piece requires fewer round-trips, but it requires a larger amount of memory to store the intermediate pieces internally. The initialization parameter can be used to tune a system for the best performance, that is, for the best trade-off between round-trips and memory requirements. If the initialization parameter is not set, the system uses 64 KB as the default piece size.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not confuse this feature with piecemeal operations on <code>LONG</code> data on the client side. Piecemeal fetch and insert operations on the client side worked with the earlier versions of the gateways, and they continue to do so. The only difference on the client side is that, where earlier versions of the gateways were able to fetch a maximum of 4 MB of <code>LONG</code> data, now they can retrieve the 2 GB of <code>LONG</code> data. This is a significant improvement because 4 MB is only 0.2 percent of the data type's capacity.</div>
</div>
<!-- class="sect1" -->
<a id="i1006709"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.9</span> SQL*Plus DESCRIBE Command</h2>
<p>You can describe non-Oracle system objects using the SQL*Plus <code>DESCRIBE</code> command. However, there are some limitations. For example, using heterogeneous links, you cannot describe packages, sequences, synonyms, or types.</p>
</div>
<!-- class="sect1" -->
<a id="i1006714"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.10</span> Constraints on SQL in a Distributed Environment</h2>
<p>This section explains some of the constraints on SQL in a distributed environment. These constraints apply to distributed environments that access non-Oracle systems or remote Oracle databases.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p>Remote and Heterogeneous References</p>
</li>
<li>
<p>Important Restrictions</p>
</li>
</ul>
<a id="i1006731"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.10.1</span> Remote and Heterogeneous References</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
Many of the rules for heterogeneous access also apply to remote references. For more information, see the distributed database section of the <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a>.</div>
<p>A statement can, with restrictions, be executed on any database node referenced in the statement or the local node. If all objects referenced are resolved to a single, referenced node, Oracle attempts to execute a query at that node. You can force execution at a referenced node by using the <code>/*+ REMOTE_MAPPED */</code> or <code>/*+ DRIVING_SITE */</code> hints. If a statement is forwarded to a node other than the node from where the statement was issued, the statement is said to be <span class="bold">remote-mapped</span>.</p>
<p>There is complete data type checking support for remote-mapped statements. The result provides consistent data type checking and complete data type coercion.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Section&nbsp;4.5, "Oracle Database Server SQL Construct Processing"</div>
<p>The ways in which statements can be remote-mapped are subject to specific rules or restrictions. If these rules are not followed, an error occurs. As long as the statements issued are consistent with all these rules, the order in which the rules are applied does not matter. See Section&nbsp;3.10.2 for these rules or restrictions.</p>
<p><a id="i1006745"></a>Different constraints exist when you are using SQL for remote mapping in a distributed environment. This distributed environment can include remote Oracle databases as well as non-Oracle databases that are accessed through Oracle Database gateways.</p>
</div>
<!-- class="sect2" -->
<a id="i1006747"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.10.2</span> Important Restrictions</h3>
<p>The following section lists some of the different rules or restrictions that exist when you are using SQL for remote mapping in a distributed environment.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In the examples that follow, <code>remote_db</code> refers to a remote non-Oracle system while <code>remote_oracle_db</code> refers to a remote Oracle Database.</div>
<p class="subhead1"><a id="sthref92"></a>Rule A: A data definition language statement cannot be remote-mapped.</p>
<p>In Oracle data definition language, the target object syntactically has no place for a remote reference. Data definition language statements that contain remote references are always executed locally. For Heterogeneous Services, this means it cannot directly create database objects in a non-Oracle database using SQL.</p>
<p>However, there is an indirect way using passthrough SQL as shown in the following example:</p>
<pre>
DECLARE
  num_rows INTEGER;
BEGIN 
  num_rows := DBMS_HS_PASSTHROUGH.EXECUTE_IMMEDIATE@remote_db 
  (
     'create table x1 (c1 char, c2 int)'
  ); 
END; 
</pre>
<p class="subhead1"><a id="CIHECAIE"></a>Rule B: INSERT, UPDATE and DELETE statements with a remote target table must be remote-mapped.</p>
<p>This rule is more restrictive for non-Oracle remote databases than for a remote Oracle database. This is because the remote system cannot fetch data from the originating Oracle database while executing data manipulation language (DML) statements targeting tables in a non-Oracle system.</p>
<p>For example, to insert all local employees from the local <code>emp</code> table to a remote non-Oracle <code>emp</code> table, use the following statement:</p>
<pre>
INSERT INTO emp@remote_db SELECT * FROM emp;
</pre>
<p>This statement is remote-mapped to the remote database. The remote-mapped statement sent to the remote database contains a remote reference back to the originating database for <code>emp</code>. Such a remote link received by the remote database is called a <a id="sthref93"></a><span class="bold">callback link</span>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Even though callback links are supported in generic Heterogeneous Services, they may not be implemented in all Heterogeneous Services agents. Refer to your database gateway documentation to determine if callback links work with the database gateway that you are using.</div>
<p>If callback links are not supported by a particular gateway, the previous <code>INSERT</code> statements returns the following error:</p>
<pre>
ORA-02025: all tables in the SQL statement must be at the remote database
</pre>
<p>The workaround is to write a PL/SQL block. For example:</p>
<pre>
DECLARE 
CURSOR remote_insert IS SELECT * FROM emp;
BEGIN 
   FOR rec IN remote_insert LOOP
    INSERT INTO emp@remote_db (empno, ename, deptno) VALUES (
      rec.empno,
      rec.ename, 
      rec.deptno 
    );  
   END loop;
END;
</pre>
<p>Another special case involves session-specific SQL functions such as <code>USER</code>, <code>USERENV</code>, and <code>SYSDATE</code>. These functions need to be executed at the originating site. A remote-mapped statement containing these functions contains a callback link. For a non-Oracle database for which callbacks are not supported, this can (by default) result in a restriction error.</p>
<p>For example, consider the following statement:</p>
<pre>
DELETE FROM emp@remote_db WHERE hiredate &gt; sysdate;
</pre>
<p>The previous statement returns the following error message:</p>
<pre>
ORA-02070: database <span class="italic">REMOTE_DB</span> does not support special functions in this context 
</pre>
<p>This can be resolved by replacing special functions with a bind variable. For example:</p>
<pre>
DELETE FROM emp@remote_db WHERE hiredate &gt; :1;
</pre>
<p class="subhead1"><a id="sthref94"></a>Rule C: Object features like tables with nested table columns, ADT columns, Opaque columns, or Ref Columns cannot be remote-mapped.</p>
<p>Currently, these column types are not supported for heterogeneous access. Hence, this limitation is not directly encountered.</p>
<p class="subhead1"><a id="sthref95"></a>Rule D: SQL statements containing operators and constructs that are not supported at the remote site cannot be remote-mapped.</p>
<p>In the case of an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, this means that the SQL statement cannot be executed (see Rule B). However, you might still be able to execute the SQL statement if the unsupported operator or construct can be executed through a callback link.</p>
<p>In the case of a <code>SELECT</code>, you can always execute a statement affected by this rule as long as none of the remaining rules require the statement to be remote mapped. The <code>SELECT</code> statements affected by this rule are executed by fetching all the necessary data through a remote <code>SELECT</code> operation, and processing the unsupported operator or construct locally using the local SQL engine.</p>
<p>A remote <code>SELECT</code> operation is the operation that retrieves rows from the remote table as opposed to an operation that retrieves data from the local table. In the worse possible case of a remote <code>SELECT</code>, Oracle does a full table scan. A full table scan is a fetch of all the data in the remote table across the network without any filtering (for example, <code>SELECT * FROM EMP</code>).</p>
<p>Full table scans are expensive and, therefore, Oracle attempts to avoid them. If there are indexes on the remote table that can be used, these indexes are used in a <code>WHERE</code> clause predicate to reduce the number of rows fetched across the network.</p>
<p>You can check the SQL statement generated by Oracle Database by explaining the statement and querying the <code>OTHER</code> column of the explain plan table for each <code>REMOTE</code> operation.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Section&nbsp;3.11.1 for more information on how to interpret explain plans with remote references</div>
<p>For example, consider the following statement:</p>
<pre>
SELECT COUNT(*) FROM emp@remote_db WHERE hiredate &lt; sysdate;
</pre>
<p>The statement returns the following output:</p>
<pre>
COUNT(*)  
----------
        14
1 row selected.
</pre>
<p>The remote table scan is:</p>
<pre>
SELECT hiredate FROM emp;
</pre>
<p>The predicate converted to a filter cannot be generated back and passed down to the remote operation because <code>sysdate</code> is not supported by the <code><span class="codeinlineitalic">remote_db</span></code> or evaluation rules. Thus <code>sysdate</code> must be executed locally.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the remote table scan operation is only partially related to the original query, the number of rows retrieved can be significantly larger than expected and can have a significant impact on performance.</div>
<p class="subhead1"><a id="sthref96"></a>Rule E: SQL statement containing a table expression cannot be remote-mapped.</p>
<p>This limitation is not directly encountered because table expressions are not supported in the heterogeneous access module.</p>
<p class="subhead1"><a id="sthref97"></a>Rule F: If a SQL statement selects LONG data, the statement must be mapped to the node where the table containing the LONG data resides.</p>
<p>Consider the following type of statement:</p>
<pre>
SELECT long1 FROM <span class="italic">table_with_long</span>@<span class="italic">remote_db</span>, dual; 
</pre>
<p>The previous statement returns the following error message (if callback links are not supported):</p>
<pre>
ORA-02025: all tables in the SQL statement must be at the remote database
</pre>
<p class="subhead1"><a id="sthref98"></a>Rule G: The statement must be mapped to the node on which the table or tables with columns referenced in the FOR UPDATE OF clause resides when the SQL statement is of form "SELECT...FOR UPDATE OF..."</p>
<p>When the SQL statement is of the form <code>SELECT...FOR UPDATE OF...,</code> the statement must be mapped to the node on which the table or tables with columns referenced in the <code>FOR UPDATE OF</code> clause resides.</p>
<p>For example, consider the following statement:</p>
<pre>
SELECT ename FROM emp@remote_db WHERE hiredate &lt; sysdate FOR UPDATE OF empno;
</pre>
<p>The previous statement returns the following error message if it cannot be remote-mapped:</p>
<pre>
ORA-02070: database <span class="italic">REMOTE_DB</span> does not support special functions in this context 
</pre>
<p class="subhead1"><a id="sthref99"></a>Rule H: If the SQL statement contains a SEQUENCE or sequences, then the statement must be mapped to the site where each sequence resides.</p>
<p>This rule is not encountered for the heterogeneous access module because remote non-Oracle sequences are not supported.</p>
<p class="subhead1"><a id="sthref100"></a>Rule I: If the statement contains a user-defined operator or operators, then the statement must be mapped to the node where each operator is defined.</p>
<p>If the statement contains a user-defined operator, the entire statement needs to be remote-mapped to the database node where the operator is defined.</p>
<p class="subhead1"><a id="sthref101"></a>Rule J: A statement containing duplicate bind variables cannot be remote-mapped.</p>
<p>The workaround for this restriction is to use unique bind variables and bind by number.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006885"></a>
<div class="sect1">
<h2 class="sect1"><span class="secnum">3.11</span> Oracle's Optimizer and Heterogeneous Services</h2>
<p>Oracle's optimizer can be used with Heterogeneous Services. Heterogeneous Services collects certain table and index statistics information on the respective non-Oracle system tables and passes this information back to Oracle Database. The Oracle cost-based optimizer uses this information when building the query plan.</p>
<p>There are several other optimizations that the cost-based optimizer performs. The most important ones are remote sort elimination and remote joins.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p>Example: Using Index and Table Statistics</p>
</li>
<li>
<p>Example: Remote Join Optimization</p>
</li>
<li>
<p>Optimizer Restrictions for Non-Oracle Access</p>
</li>
</ul>
<a id="i1006889"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.11.1</span> Example: Using Index and Table Statistics</h3>
<p>Consider the following statement where you create a table in the Oracle database with 10 rows:</p>
<pre>
CREATE TABLE T1 (C1 number);
</pre>
<p>Analyze the table using the <code>DBMS_STATS</code> package. For example:</p>
<pre>
DBMS_STATS.GATHER_TABLE_STATS ('SCOTT','T1');
DBMS_STATS.GENERATE_STATS ('SCOTT','T1');
</pre>
<p>The preceding example assumes the schema name is <code>SCOTT</code> and the table name is <code>T1</code>. See the <a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>DBMS_STATS</code> package.</p>
<p>Create a table in the non-Oracle system with 1000 rows.</p>
<p>Issue the following SQL statement:</p>
<pre>
SELECT a.* FROM remote_t1@remote_db a, T1 b 
    WHERE a.C1 = b.C1;
</pre>
<p>The Oracle optimizer issues the following SQL statement to the agent:</p>
<pre>
SELECT C1 FROM remote_t1@remote_db;
</pre>
<p>This fetches all 1000 rows from the non-Oracle system and performs the join in the Oracle database.</p>
<p>If we add a unique index on the column <code>C1</code> in the table <code>remote_t1</code>, and issue the same SQL statement again, the agent receives the following SQL statement for each value of <code>C1</code> in the local <code>t1</code>:</p>
<pre>
...
SELECT C1 FROM remote_t1@remote_db WHERE C1 = ?;
...
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code>?</code> is the bind parameter marker. Also, join predicates containing bind variables generated by Oracle are generated only for nested loop join methods.</div>
<p>To verify the SQL execution plan, generate an explain plan for the SQL statement. First, load <code>utlxplan</code> in the <code>admin</code> directory.</p>
<p>Enter the following:</p>
<pre>
EXPLAIN PLAN FOR SELECT a.* FROM remote_t1@remote_db a, T1 b 
    WHERE a.C1 = b.C1;
</pre>
<p>Execute the <code>utlxpls</code> utility script by entering the following statement.</p>
<pre>
@utlxpls
</pre>
<p><code>OPERATION REMOTE</code> indicates that remote SQL is being referenced.</p>
<p>To find out what statement is sent, enter the following statement:</p>
<pre>
SELECT ID, OTHER FROM PLAN_TABLE WHERE OPERATION = 'REMOTE';
</pre></div>
<!-- class="sect2" -->
<a id="i1006928"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.11.2</span> Example: Remote Join Optimization</h3>
<p>The following is an example of the remote join optimization capability of the Oracle database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The explain plan that uses tables from a non-Oracle system can differ from similar statements with local or remote Oracle table scans. This is because of the limitation on the statistics available to Oracle for non-Oracle tables. Most importantly, column selectivity is not available for non-unique indexes of non-Oracle tables. Because of the limitation of the statistics available, the following example is not necessarily what you encounter when doing remote joins and is intended for illustration only.</div>
<p>Consider the following example:</p>
<pre>
EXPLAIN PLAN FOR
SELECT e.ename, d.dname, f.ename, f.deptno FROM
   dept d,
   emp@<span class="italic">remote_db</span> e,
   emp@<span class="italic">remote_db</span> f
 WHERE e.mgr = f.empno
  AND e.deptno = d.deptno 
  AND e.empno = f.empno;
  
@utlxpls
</pre>
<p>You should see output similar to the following:</p>
<pre>
PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

---------------------------------------------------------------------------
| Id    | Operation                           | Name  | Rows  | Bytes  | Cost
| Inst  |IN-OUT|
---------------------------------------------------------------------------
|   0   | SELECT STATEMENT   |                |  2000   |   197K|   205 |
|*  1   | HASH JOIN          |                |  2000   |   197K|
205 |
|   2   | TABLE ACCESS FULL  | DEPT           |  21     |   462 |     2 |
|*  3   | HASH JOIN          |                |  2000   |   154K|
201 |
|   4   | REMOTE             |                |  2000   | 66000 
|    52 |
|   5   | REMOTE             |                |  2000   | 92000
|    52 |
---------------------------------------------------------------------------

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

Query Block Name / Hint Alias (identified by operation id):
-----------------------------------------------------------

   1 - sel$1 / D
   2 - sel$1 / D
   3 - sel$1 / F
   4 - sel$1 / F
   5 - sel$1 / E

Predicate Information (identified by operation id):

PLAN_TABLE_OUTPUT
--------------------------------------------------------------------------------

---------------------------------------------------

   1 - access("E"."DEPTNO"="D"."DEPTNO")
   3 - access("E"."MGR"="F"."EMPNO" AND "E"."EMPNO"="F"."EMPNO")

</pre>
<p>Issue the following statement:</p>
<pre>
SET long 300
SELECT other FROM plan_table WHERE operation = 'REMOTE'; 
</pre>
<p>You should see output similar to the following:</p>
<pre>
OTHER
--------------------------------------------------------------------------------

SELECT "EMPNO","ENAME","DEPTNO" FROM "EMP"
SELECT "EMPNO","ENAME","MGR","DEPTNO" FROM "EMP"
SELECT "EMPNO","ENAME","DEPTNO" FROM "EMP"
SELECT "EMPNO","ENAME","MGR","DEPTNO" FROM "EMP"
</pre></div>
<!-- class="sect2" -->
<a id="i1007027"></a>
<div class="sect2">
<h3 class="sect2"><span class="secnum">3.11.3</span> Optimizer Restrictions for Non-Oracle Access</h3>
<p>The following are optimizer restrictions for non-Oracle system access:</p>
<ul>
<li>
<p>There are no column statistics for remote objects. This can result in poor execution plans. Verify the execution plan and use hints to improve the plan.</p>
</li>
<li>
<p>There is no optimizer hint to force a remote join. However, there is a remote query block optimization that can be used to rewrite the query slightly in order to get a remote join.</p>
<p>The example from the previous section can be rewritten to the following form:</p>
<pre>
    SELECT v.ename, d.dname, d.deptno FROM dept d,
        (SELECT /*+ NO_MERGE */ 
         e.deptno deptno, e.ename ename emp@remote_db e, emp@remote_db f
             WHERE e.mgr = f.empno
             AND e.empno = f.empno;
        )
      WHERE v.deptno = d.deptno;


</pre></li>
</ul>
<p>This example guarantees a remote join because it has been isolated in a nested query with the <code>NO_MERGE</code> hint.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1566">
<tr>
<td class="cellalignment1575">
<table class="cellalignment1571">
<tr>
<td class="cellalignment1570"><a href="tgvsgc.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1570"><a href="admin.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2009,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1577">
<table class="cellalignment1569">
<tr>
<td class="cellalignment1570"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1570"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1570"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1570"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1570"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1570"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
