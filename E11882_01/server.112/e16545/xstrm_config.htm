<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Configuring XStream</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 735" />
<meta name="dcterms.created" content="2013-07-02T6:44:42Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database XStream Guide" />
<meta name="dcterms.identifier" content="E16545-09" />
<meta name="dcterms.isVersionOf" content="XSTRM" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2009, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="xstrm_pt_admin.htm" title="Previous" type="text/html" />
<link rel="Next" href="xstrm_man.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e16545.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">9/22</span> <!-- End Header -->
<div id="XSTRM1496" class="chapter"><a id="CBDIJEFE"></a>
<h1 class="chapter"><span class="secnum">4</span> Configuring XStream</h1>
<p><a id="sthref128"></a>This chapter describes configuring the Oracle Database components that are used by XStream. This chapter also includes sample client applications that communicate with an XStream outbound server and inbound server.</p>
<p>This chapter contains these topics:</p>
<ul>
<li>
<p><a href="#CEGHFDIA">Preparing for XStream</a></p>
</li>
<li>
<p><a href="#CBDHJEJD">Configuring XStream Out</a></p>
</li>
<li>
<p><a href="#CBDJFJJE">Configuring XStream In</a></p>
</li>
<li>
<p><a href="#CBDFEAJF">Sample XStream Client Application</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xstrm_cncpt.htm#BCEBDGFJ">Chapter 2, "XStream Concepts"</a></p>
</li>
<li>
<p><a href="xstrm_use.htm#CHDCFEHI">Chapter 3, "XStream Use Cases"</a></p>
</li>
<li>
<p><a href="xstrm_mon.htm#CHDDBGIA">Chapter 6, "Monitoring XStream"</a></p>
</li>
<li>
<p><a href="xstrm_trouble.htm#BABJJCEG">Chapter 7, "Troubleshooting XStream"</a></p>
</li>
<li>
<p><a href="xstrm_pt_oci.htm#CIAFHDJF">Part IV, "XStream OCI API Reference"</a></p>
</li>
<li>
<p><a class="olink STXJV" href="../../appdev.112/e16674/toc.htm"><span class="italic">Oracle Database XStream Java API Reference</span></a></p>
</li>
</ul>
</div>
<a id="CEGHFDIA"></a>
<div id="XSTRM72584" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Preparing for XStream</h2>
<p>This section describes preparing for an XStream configuration.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#CEGDFBCE">Granting Privileges for the XStream Administrator</a></p>
</li>
<li>
<p><a href="#CBDGBCHF">Preparing for XStream Out</a></p>
</li>
<li>
<p><a href="#CBDIACGD">Preparing for XStream In</a></p>
</li>
</ul>
<a id="CEGDFBCE"></a>
<div id="XSTRM72553" class="sect2">
<h3 class="sect2">Granting Privileges for the XStream Administrator<a id="sthref129"></a><a id="sthref130"></a></h3>
<p>An XStream administrator configures and manages XStream components in an XStream Out or XStream In environment. This section describes configuring an XStream administrator by granting a user the appropriate privileges. You must configure an XStream administrator in each Oracle database included in the XStream configuration.</p>
<p>With XStream, you can implement the security model that best fits with your organization's requirements.</p>
<p>XStream supports two modes of security:</p>
<ul>
<li>
<p>XStream Trusted User Model<a id="sthref131"></a></p>
<p>An XStream administrator configured with the trusted user model can manage any XStream configuration, has more database privileges than an untrusted counterpart, and can monitor XStream with <code>DBA_</code> views.</p>
<p>The trusted user model is easier to implement than the untrusted user model, especially in an environment with multiple XStream configurations.</p>
</li>
<li>
<p>XStream Untrusted User Model<a id="sthref132"></a></p>
<p>An XStream administrator configured with the untrusted user model (also referred to as the minimum privilege model) can only manage XStream configurations owned by the untrusted user administrator. This model offers fine-grained administrative security because you can designate different untrusted user administrators to access different resources in the XStream environment. You can configure one or more XStream untrusted users and each of these users only has the minimum privileges required for the tasks that they are assigned. This strategy gives you the ability to isolate access and privileges to certain XStream resources. The untrusted administrator can monitor XStream with <code>ALL_</code> views</p>
<p>For example, you might want to use the untrusted user model for situations where the capture process requires more privileges than the client process. You can then assign a different user for the client process that only has the privileges it requires.</p>
<p>Government and commercial organizations implement a variety of software and hardware security architectures to protect and control access to data and applications. Compliance with industry-specific service level agreements (SLAs), audits, security laws and regulations may require a separation of duties and responsibilities, and controlled access to data. These types of security criteria and restrictions suit the untrusted user model where you can designate different users and privileges to secure resources.</p>
</li>
</ul>
<p class="subhead2"><a id="XSTRM72585"></a>Prerequisites</p>
<p>Before configuring an XStream administrator, ensure that the following prerequisites are met:</p>
<ul>
<li>
<p>Ensure that you can log in to each database in the XStream configuration as an administrative user who can create users, grant privileges, and create tablespaces.</p>
</li>
<li>
<p>Identify a user who will be the XStream administrator. Either create a new user with the appropriate privileges or grant these privileges to an existing user.</p>
<p>Do not use the <code>SYS</code> or <code>SYSTEM</code> user as an XStream administrator, and ensure that the XStream administrator does not use the <code>SYSTEM</code> tablespace as its default tablespace.</p>
</li>
<li>
<p>If a new tablespace is required for the XStream administrator, then ensure that there is enough disk space on each computer system in the XStream configuration for the tablespace. The recommended size of the tablespace is 25 MB.</p>
</li>
</ul>
<p class="subhead2"><a id="XSTRM72586"></a>Assumptions</p>
<p>This section makes the following assumptions:</p>
<ul>
<li>
<p>The username of the XStream administrator is <code>xstrmadmin</code>.</p>
</li>
<li>
<p>The tablespace used by the XStream administrator is <code>xstream_tbs</code>.</p>
</li>
</ul>
<p class="orderedlisttitle">To configure an XStream administrator:&nbsp;</p>
<ol>
<li>
<p>In SQL*Plus, connect as an administrative user who can create users, grant privileges, and create tablespaces. Remain connected as this administrative user for all subsequent steps.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN00102" href="../../server.112/e25494/dba.htm#ADMIN00102"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about connecting to a database in SQL*Plus</div>
</li>
<li>
<p>Either create a tablespace for the XStream administrator or use an existing tablespace.</p>
<p>This tablespace stores any objects created in the XStream administrator's schema, including any spillover of messages from the buffered queues owned by the schema.</p>
<p>For example, the following statement creates a new tablespace for the XStream administrator:</p>
<pre>
CREATE TABLESPACE xstream_tbs DATAFILE '/usr/oracle/dbs/xstream_tbs.dbf' 
  SIZE 25M REUSE AUTOEXTEND ON MAXSIZE UNLIMITED;
</pre></li>
<li>
<p>Create a new user to act as the XStream administrator or identify an existing user.</p>
<p>For example, to create a user named <code>xstrmadmin</code> and specify that this user uses the <code>xstream_tbs</code> tablespace, run the following statement:</p>
<pre>
CREATE USER xstrmadmin IDENTIFIED BY <span class="italic">password</span> 
  DEFAULT TABLESPACE xstream_tbs
  QUOTA UNLIMITED ON xstream_tbs;
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
Enter an appropriate password for the administrative user.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink DBSEG33223" href="../../network.112/e36292/authentication.htm#DBSEG33223"><span class="italic">Oracle Database Security Guide</span></a> for guidelines about choosing passwords</div>
</li>
<li>
<p>Grant <code>CREATE</code> <code>SESSION</code> privilege to the XStream administrator.</p>
<p>If you created a new user to act as the XStream administrator, then grant this user <code>CREATE</code> <code>SESSION</code> privilege.</p>
<p>For example, to grant <code>CREATE</code> <code>SESSION</code> privilege to user <code>xstrmadmin</code>, run the following statement:</p>
<pre>
GRANT CREATE SESSION TO xstrmadmin;
</pre></li>
<li>
<p>Run the <code>GRANT_ADMIN_PRIVILEGE</code> procedure in the <code>DBMS_XSTREAM_AUTH</code> package.</p>
<p>A user must have explicit <code>EXECUTE</code> privilege on a package to execute a subprogram in the package inside of a user-created subprogram, and a user must have explicit <code>SELECT</code> privilege on a data dictionary view to query the view inside of a user-created subprogram. These privileges cannot be granted through a role. You can run the <code>GRANT_ADMIN_PRIVILEGE</code> procedure to grant such privileges to the XStream administrator, or you can grant them directly.</p>
<p>Depending on the parameter settings for the <code>GRANT_ADMIN_PRIVILEGE</code> procedure, it can grant the appropriate privileges for a trusted or untrusted XStream administrator. Set the <code>grant_select_privileges</code> parameter to <code>TRUE</code> to configure a trusted XStream administrator, or set it to <code>FALSE</code> to configure an untrusted XStream administrator.</p>
<div id="XSTRM72664" class="example">
<p class="titleinexample"><a id="sthref134"></a>Example 4-1 Granting Privileges to a Trusted XStream Administrator for XStream Out Without Generating a Script</p>
<pre>
BEGIN
   DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
      grantee                 =&gt; 'xstrmadmin',
      privilege_type          =&gt; 'CAPTURE',
      grant_select_privileges =&gt; TRUE);
END;
/
</pre></div>
<!-- class="example" -->
<div id="XSTRM72665" class="example">
<p class="titleinexample"><a id="sthref135"></a>Example 4-2 Granting Privileges to a Trusted XStream Administrator for XStream Out and Generating a Script</p>
<p>The directory specified in the <code>directory_name</code> parameter must exist and must be accessible to the current user.</p>
<pre>
BEGIN
   DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
      grantee                 =&gt; 'xstrmadmin',
      privilege_type          =&gt; 'CAPTURE',
      grant_select_privileges =&gt; TRUE);
      do_grants               =&gt; TRUE,
      file_name               =&gt; 'grant_xstrm_privs.sql',
      directory_name          =&gt; 'xstrm_dir');
END;
/
</pre></div>
<!-- class="example" -->
<div id="XSTRM72666" class="example">
<p class="titleinexample"><a id="sthref136"></a>Example 4-3 Granting Privileges to an Untrusted XStream Administrator for XStream Out Without Generating a Script</p>
<pre>
BEGIN
   DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
      grantee                 =&gt; 'xstrmadmin',
      privilege_type          =&gt; 'CAPTURE',
      grant_select_privileges =&gt; FALSE);
END;
/
</pre></div>
<!-- class="example" -->
<div id="XSTRM72667" class="example">
<p class="titleinexample"><a id="sthref137"></a>Example 4-4 Granting Privileges to a Trusted XStream Administrator for XStream In Without Generating a Script</p>
<pre>
BEGIN
   DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
      grantee                 =&gt; 'xstrmadmin',
      privilege_type          =&gt; 'APPLY',
      grant_select_privileges =&gt; TRUE);
END;
/
</pre></div>
<!-- class="example" -->
<div id="XSTRM72668" class="example">
<p class="titleinexample"><a id="sthref138"></a>Example 4-5 Granting Privileges to a Trusted XStream Administrator for XStream In and Generating a Script</p>
<p>The directory specified in the <code>directory_name</code> parameter must exist and must be accessible to the current user.</p>
<pre>
BEGIN
   DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
      grantee                 =&gt; 'xstrmadmin',
      privilege_type          =&gt; 'APPLY',
      grant_select_privileges =&gt; TRUE);
      do_grants               =&gt; TRUE,
      file_name               =&gt; 'grant_xstrm_privs.sql',
      directory_name          =&gt; 'xstrm_dir');
END;
/
</pre></div>
<!-- class="example" -->
<div id="XSTRM72669" class="example">
<p class="titleinexample"><a id="sthref139"></a>Example 4-6 Granting Privileges to an Untrusted XStream Administrator for XStream In Without Generating a Script</p>
<pre>
BEGIN
   DBMS_XSTREAM_AUTH.GRANT_ADMIN_PRIVILEGE(
      grantee                 =&gt; 'xstrmadmin',
      privilege_type          =&gt; 'APPLY',
      grant_select_privileges =&gt; FALSE);
END;
/
</pre></div>
<!-- class="example" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
For any scenario, when the XStream administrator must manage both an XStream Out and an XStream In configuration on the database, specify <code>*</code> for the <code>privilege_type</code> parameter.</div>
</li>
<li>
<p>If necessary, grant the following additional privileges:</p>
<ul>
<li>
<p>If you plan to use Oracle Enterprise Manager to manage databases with XStream components, then configure the XStream administrator to be a Database Control administrator. Doing so grants additional privileges required by Oracle Enterprise Manager, such as the privileges required to run Oracle Enterprise Manager jobs. See <a class="olink ADMQS034" href="../../server.112/e10897/em_manage.htm#ADMQS034"><span class="italic">Oracle Database 2 Day DBA</span></a> for instructions.</p>
</li>
<li>
<p>Grant the privileges for a remote XStream administrator to perform actions in the local database. Grant these privileges using the <code>GRANT_REMOTE_ADMIN_ACCESS</code> procedure in the <code>DBMS_XSTREAM_AUTH</code> package. Grant this privilege if a remote XStream administrator will use a database link that connects to the local XStream administrator to perform administrative actions. Specifically, grant these privileges if either of the following conditions are true:</p>
<ul>
<li>
<p>You plan to configure a downstream capture process at a remote downstream database that captures changes originating at the local source database, and the downstream capture process will use a database link to perform administrative actions at the source database.</p>
</li>
<li>
<p>You plan to use a remote XStream administrator to set the instantiation system change number (SCN) values for replicated database objects at the local database.</p>
</li>
</ul>
</li>
<li>
<p>If no apply user is specified for an inbound server, then grant the XStream administrator the necessary privileges to perform DML and DDL changes on the apply objects owned by other users. If an apply user is specified, then the apply user must have these privileges. These privileges can be granted directly or through a role.</p>
</li>
<li>
<p>If no apply user is specified for an inbound server, then grant the XStream administrator <code>EXECUTE</code> privilege on any PL/SQL subprogram owned by another user that is executed by an inbound server. These subprograms can be used in apply handlers or error handlers. If an apply user is specified, then the apply user must have these privileges. These privileges must be granted directly. They cannot be granted through a role.</p>
</li>
<li>
<p>Grant the XStream administrator <code>EXECUTE</code> privilege on any PL/SQL function owned by another user that is specified in a custom rule-based transformation for a rule used by a capture process, synchronous capture, propagation, outbound server, or inbound server. For a capture process or synchronous capture, if a capture user is specified, then the capture user must have these privileges. For an inbound server, if an apply user is specified, then the apply user must have these privileges. These privileges must be granted directly. They cannot be granted through a role.</p>
</li>
<li>
<p>Grant the XStream administrator privileges to alter database objects where appropriate. For example, if the XStream administrator must create a supplemental log group for a table in another schema, then the XStream administrator must have the necessary privileges to alter the table. These privileges can be granted directly or through a role.</p>
</li>
<li>
<p>If the XStream administrator does not own the queue used by a capture process, synchronous capture, propagation, outbound server, or inbound server, and is not specified as the queue user for the queue when the queue is created, then the XStream administrator must be configured as a secure queue user of the queue if you want the XStream administrator to be able to enqueue messages into or dequeue messages from the queue. The XStream administrator might also need <code>ENQUEUE</code> or <code>DEQUEUE</code> privileges on the queue, or both. See <a class="olink STRMS101" href="../../server.112/e17069/strms_mprop.htm#STRMS101"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about managing queues.</p>
</li>
<li>
<p>Grant the XStream administrator <code>EXECUTE</code> privilege on any object types that the XStream administrator might need to access. These privileges can be granted directly or through a role.</p>
</li>
<li>
<p>If the XStream administrator will use Data Pump to perform export and import operations on database objects in other schemas during an instantiation, then grant the <code>EXP_FULL_DATABASE</code> and <code>IMP_FULL_DATABASE</code> roles to the XStream administrator.</p>
</li>
<li>
<p>If you are using Oracle Database Vault, then the following additional privileges are required:</p>
<ul>
<li>
<p>The XStream administrator must be granted the <code>DV_STREAMS_ADMIN</code> role to perform the following tasks: create a capture process, create an outbound server, and modify the capture user for a capture process. When the XStream administrator is not performing these tasks, you can revoke <code>DV_STREAMS_ADMIN</code> role from the XStream administrator.</p>
</li>
<li>
<p>The apply user for an inbound server must be authorized to apply changes to realms that include replicated database objects. The replicated database objects are the objects to which the inbound server applies changes.</p>
<p>To authorize an apply user for a realm, run the <code>DBMS_MACADM.ADD_AUTH_TO_REALM</code> procedure and specify the realm and the apply user. For example, to authorize apply user <code>xstrmadmin</code> for the <code>sales</code> realm, run the following procedure:</p>
<pre>
BEGIN
 DBMS_MACADM.ADD_AUTH_TO_REALM(
  realm_name  =&gt; 'sales', 
  grantee     =&gt; 'xstrmadmin'); 
END;
/
</pre></li>
</ul>
<p>In addition, the user who performs the following actions must be granted the <code>BECOME</code> <code>USER</code> system privilege:</p>
<ul>
<li>
<p>Creates or alters a capture process</p>
</li>
<li>
<p>Creates or alters an outbound server</p>
</li>
<li>
<p>Creates or alters an inbound server</p>
</li>
</ul>
<p>Granting the <code>BECOME</code> <code>USER</code> system privilege to the user who performs these actions is not required if Oracle Database Vault is not installed. You can revoke the <code>BECOME</code> <code>USER</code> system privilege from the user after the completing one of these actions, if necessary.</p>
<p>See <a class="olink DVADM70351" href="../../server.112/e23090/db_objects.htm#DVADM70351"><span class="italic">Oracle Database Vault Administrator's Guide</span></a>.</p>
</li>
</ul>
</li>
<li>
<p>Repeat all of the previous steps at each Oracle database in the environment that will use XStream.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="CBDGBCHF"></a>
<div id="XSTRM1554" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Preparing for XStream Out<a id="sthref140"></a><a id="sthref141"></a></h3>
<p>This section describes the decisions to make and the tasks to complete to prepare for an XStream Out configuration.</p>
<ul>
<li>
<p><a href="#CBDDJIJD">Decide How to Configure XStream</a></p>
</li>
<li>
<p><a href="#CBDIHHEF">Prerequisites for Configuring XStream Out</a></p>
</li>
</ul>
<a id="CBDDJIJD"></a>
<div id="XSTRM1555" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Decide How to Configure XStream<a id="sthref142"></a><a id="sthref143"></a></h4>
<p>When you configure XStream Out, you must configure XStream components to capture database changes and send these changes to the outbound server in the form of logical change records (LCRs). These components include a capture process and at least one queue. The capture process can be a local capture process or a downstream capture process. For some configurations, you must also configure a propagation.</p>
<p>Local capture means that a capture process runs on the source database. Downstream capture means that a capture process runs on a database other than the source database. The source database is the database where the changes were generated. The primary reason to use downstream capture is to reduce the load on the source database, thereby improving its performance. The primary reason to use a local capture is because it is easier to configure and maintain.</p>
<p>The database that captures changes made to the source database is called the <span class="bold">capture database</span>. One of the following databases can be the capture database:</p>
<ul>
<li>
<p>Source database (local capture)</p>
</li>
<li>
<p>Destination database (downstream capture)</p>
</li>
<li>
<p>A third database (downstream capture)</p>
</li>
</ul>
<p>If the database running the outbound server is not the capture database, then a propagation sends changes from the capture database to the database running the outbound server. If the database running the outbound server is the capture database, then this propagation between databases is not needed because the capture process and outbound server use the same queue.</p>
<p>You can configure the components in the following ways:</p>
<ul>
<li>
<p><span class="bold">Local capture and outbound server in the same database:</span> The database objects, capture process, and outbound server are all in the same database. This configuration is the easiest to configure and maintain because all of the components are contained in one database. See <a href="#CEGEEBDA">Figure 4-1</a> for an overview of this configuration.</p>
</li>
<li>
<p><span class="bold">Local capture and outbound server in different databases:</span> The database objects and capture process are in one database, and the outbound server is in another database. A propagation sends LCRs from the source database to the outbound server database. This configuration is best when you want easy configuration and maintenance and when you want to optimize the performance of the outbound server database. See <a href="#CEGEAAIE">Figure 4-2</a> for an overview of this configuration.</p>
</li>
<li>
<p><span class="bold">Downstream capture and outbound server in the same database:</span> The database objects are in one database, and the capture process and outbound server are in another database. This configuration is best when you want to optimize the performance of the database with the database objects and want to offload change capture to another database. With this configuration, most of the components run on the database with the outbound server. See <a href="#CEGDHECF">Figure 4-3</a> for an overview of this configuration.</p>
</li>
<li>
<p><span class="bold">Downstream capture and outbound server in different databases:</span> The database objects are in one database, the outbound server is in another database, and the capture process is in a third database. This configuration is best when you want to optimize the performance of both the database with the database objects and the database with the outbound server. With this configuration, the capture process runs on a third database, and a propagation sends LCRs from the capture database to the outbound server database. See <a href="#CEGGJCFE">Figure 4-4</a> for an overview of this configuration.</p>
</li>
</ul>
<p>The following figures illustrate these different configurations.</p>
<div id="XSTRM72655" class="figure">
<p class="titleinfigure"><a id="CEGEEBDA"></a>Figure 4-1 Local Capture and Outbound Server in the Same Database</p>
<img width="633" height="278" src="img/xstrm075.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref144" href="img_text/xstrm075.htm">Description of "Figure 4-1 Local Capture and Outbound Server in the Same Database"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="XSTRM72656" class="figure">
<p class="titleinfigure"><a id="CEGEAAIE"></a>Figure 4-2 Local Capture and Outbound Server in Different Databases</p>
<img width="633" height="503" src="img/xstrm076.gif" alt="Description of Figure 4-2 follows" /><br />
<a id="sthref145" href="img_text/xstrm076.htm">Description of "Figure 4-2 Local Capture and Outbound Server in Different Databases"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="XSTRM72657" class="figure">
<p class="titleinfigure"><a id="CEGDHECF"></a>Figure 4-3 Downstream Capture and Outbound Server in the Same Database</p>
<img width="434" height="566" src="img/xstrm077.gif" alt="Description of Figure 4-3 follows" /><br />
<a id="sthref146" href="img_text/xstrm077.htm">Description of "Figure 4-3 Downstream Capture and Outbound Server in the Same Database"</a><br />
<br /></div>
<!-- class="figure" -->
<div id="XSTRM72658" class="figure">
<p class="titleinfigure"><a id="CEGGJCFE"></a>Figure 4-4 Downstream Capture and Outbound Server in Different Databases</p>
<img width="570" height="633" src="img/xstrm078.gif" alt="Description of Figure 4-4 follows" /><br />
<a id="sthref147" href="img_text/xstrm078.htm">Description of "Figure 4-4 Downstream Capture and Outbound Server in Different Databases"</a><br />
<br /></div>
<!-- class="figure" -->
<p>If you decide to configure a downstream capture process, then you must decide which type of downstream capture process you want to configure. The following types are available:</p>
<ul>
<li>
<p>A <span class="bold">real-time downstream capture process</span> configuration means that redo transport services use the log writer process (LGWR) at the source database to send redo data to the downstream database, and a remote file server process (RFS) at the downstream database receives the redo data over the network and stores the redo data in the standby redo log.</p>
</li>
<li>
<p>An <span class="bold">archived-log downstream capture process</span> configuration means that archived redo log files from the source database are copied to the downstream database, and the capture process captures changes in these archived redo log files. These log files can be transferred automatically using redo transport services, or they can be transferred manually using a method such as FTP.</p>
</li>
</ul>
<p>The advantage of real-time downstream capture over archived-log downstream capture is that real-time downstream capture reduces the amount of time required to capture changes made to the source database. The time is reduced because the real-time downstream capture process does not need to wait for the redo log file to be archived before it can capture changes from it. You can configure multiple real-time downstream capture processes that capture changes from the same source database, but you cannot configure real-time downstream capture for multiple source databases at one downstream database.</p>
<p>The advantage of archived-log downstream capture over real-time downstream capture is that archived-log downstream capture allows downstream capture processes for multiple source databases at a downstream database. You can copy redo log files from multiple source databases to a single downstream database and configure multiple archived-log downstream capture processes to capture changes in these redo log files.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS" href="../e17069/toc.htm"><span class="italic">Oracle Streams Concepts and Administration</span></a></div>
</div>
<!-- class="sect3" -->
<a id="CBDIHHEF"></a>
<div id="XSTRM1498" class="sect3">
<h4 class="sect3">Prerequisites for Configuring XStream Out</h4>
<p>Preparing for an XStream Out outbound server is similar to preparing for an Oracle Streams replication environment. The components used in an Oracle Streams replication environment to capture changes and send them to an apply process are the same components used to capture changes and send them to an outbound server. These components include a capture process and one or more queues. If the capture process runs on a different database than the outbound server, then a propagation is also required.</p>
<p>Several of the tasks described in this section are described in more detail in <a class="olink STREP232" href="../../server.112/e10705/prep_rep.htm#STREP232"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a>. This section provides an overview of each task and specific information about completing the task for an XStream Out configuration.</p>
<p>Ensure that the following prerequisites are met before configuring XStream Out:</p>
<ul>
<li>
<p><a href="#CBDFFDJI">Configure an XStream Administrator on All Databases</a></p>
</li>
<li>
<p><a href="#CBDHCDAB">If Required, Configure Network Connectivity and Database Links</a></p>
</li>
<li>
<p><a href="#CBDCICFG">Ensure That Each Source Database Is in ARCHIVELOG Mode</a></p>
</li>
<li>
<p><a href="#CBDBCHEG">Set the Relevant Initialization Parameters</a></p>
</li>
<li>
<p><a href="#CBDDDDGB">Configure the Oracle Streams Pool</a></p>
</li>
<li>
<p><a href="#CBDGJHCE">If Required, Configure Log File Transfer to a Downstream Database</a></p>
</li>
<li>
<p><a href="#CBDCBGHF">If Required, Add Standby Redo Logs for Real-Time Downstream Capture</a></p>
</li>
</ul>
<a id="CBDFFDJI"></a>
<div id="XSTRM1556" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Configure an XStream Administrator on All Databases</h5>
<p>To configure and manage an XStream Out configuration, create an XStream administrator on each Oracle database that is involved in the XStream Out configuration.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CEGDFBCE">"Granting Privileges for the XStream Administrator"</a></div>
<a id="CBDHCDAB"></a>
<div id="XSTRM1557" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">If Required, Configure Network Connectivity and Database Links<a id="sthref148"></a><a id="sthref149"></a></h5>
<p>Network connectivity and database links are not required when all of the components run on the same database. These components include the capture process, queue, and outbound server.</p>
<p>You must configure network connectivity and database links if you decided to configure XStream in either of the following ways:</p>
<ul>
<li>
<p>The capture process and the outbound server will run on different databases.</p>
</li>
<li>
<p>Downstream capture will be used.</p>
</li>
</ul>
<p>See <a href="#CBDDJIJD">"Decide How to Configure XStream"</a> for more information about these decisions.</p>
<p>If network connectivity is required, then configure your network and Oracle Net so that the databases can communicate with each other.</p>
<p>The following database links are required:</p>
<ul>
<li>
<p>When the capture process runs on a different database from the outbound server, create a database link from the capture database to the outbound server database. A propagation uses this database link to send changes from the capture database to the outbound server database.</p>
</li>
<li>
<p>When you use downstream capture, create a database link from the capture database to the source database. The source database is the database that generates the redo data that the capture process uses to capture changes. The capture process uses this database link to perform administrative tasks at the source database.</p>
</li>
</ul>
<p>The name of each database link must match the global name of the destination database, and each database link should be created in the XStream administrator's schema.</p>
<p>For example, assume that you want to create a database link in a configuration with the following characteristics:</p>
<ul>
<li>
<p>The global name of the source database is <code>dbs1.example.com</code>.</p>
</li>
<li>
<p>The global name of the destination database is <code>dbs2.example.com</code>.</p>
</li>
<li>
<p>The XStream administrator is <code>xstrmadmin</code> at each database.</p>
</li>
</ul>
<p>Given these assumptions, the following statement creates a database link from <code>dbs1.example.com</code> to <code>dbs2.example.com</code>:</p>
<pre>
CONNECT xstrmadmin@dbs1.example.com
Enter password: <span class="italic">password</span>

CREATE DATABASE LINK dbs2.example.com CONNECT TO xstrmadmin 
   IDENTIFIED BY <span class="italic">password</span> USING 'dbs2.example.com';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMQS004" href="../../server.112/e10897/network.htm#ADMQS004"><span class="italic">Oracle Database 2 Day DBA</span></a></p>
</li>
<li>
<p><a class="olink TDPII009" href="../../server.112/e17516/tdpii_common_ii.htm#TDPII009"><span class="italic">Oracle Database 2 Day + Data Replication and Integration Guide</span></a> for instructions about creating database links using Oracle Enterprise Manager</p>
</li>
<li>
<p><a class="olink ADMIN029" href="../../server.112/e25494/ds_admin.htm#ADMIN029"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about database links</p>
</li>
</ul>
</div>
<a id="CBDCICFG"></a>
<div id="XSTRM1558" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Ensure That Each Source Database Is in ARCHIVELOG Mode<a id="sthref150"></a><a id="sthref151"></a></h5>
<p>Each source database that generates changes that will be captured by a capture process must be in <code>ARCHIVELOG</code> mode. For downstream capture processes, the downstream database also must be in <code>ARCHIVELOG</code> mode if you plan to configure a real-time downstream capture process. The downstream database does not need to be in <code>ARCHIVELOG</code> mode if you plan to run only archived-log downstream capture processes on it.</p>
<p>If you are configuring XStream in an Oracle Real Application Clusters (Oracle RAC) environment, then the archived redo log files of all threads from all instances must be available to any instance running a capture process. This requirement pertains to both local and downstream capture processes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN008" href="../../server.112/e25494/archredo.htm#ADMIN008"><span class="italic">Oracle Database Administrator's Guide</span></a> for instructions about running a database in <code>ARCHIVELOG</code> mode</div>
<a id="CBDBCHEG"></a>
<div id="XSTRM1559" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Set the Relevant Initialization Parameters<a id="sthref152"></a><a id="sthref153"></a><a id="sthref154"></a><a id="sthref155"></a></h5>
<p>Some initialization parameters are important for the configuration, operation, reliability, and performance of the components in an XStream configuration. Set these parameters appropriately.</p>
<p><a class="olink STREP201" href="../../server.112/e10705/prep_rep.htm#STREP201"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> contains detailed information about all of the initialization parameters that are important for an Oracle Streams environment. The guidelines for setting these parameters also apply to an XStream configuration. In addition to the requirements described in <a class="olink STREP201" href="../../server.112/e10705/prep_rep.htm#STREP201"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for all Oracle Streams components, the following requirements apply to XStream outbound servers:</p>
<ul>
<li>
<p>Ensure that the <code>PROCESSES</code> initialization parameter is set to a value large enough to accommodate the outbound server background processes and all of the other Oracle Database background processes.</p>
</li>
<li>
<p>Ensure that the <code>SESSIONS</code> initialization parameter is set to a value large enough to accommodate the sessions used by the outbound server background processes and all of the other Oracle Database sessions.</p>
</li>
</ul>
<a id="CBDDDDGB"></a>
<div id="XSTRM1560" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Configure the Oracle Streams Pool<a id="sthref156"></a><a id="sthref157"></a></h5>
<p>The Oracle Streams pool is a portion of memory in the System Global Area (SGA) that is used by Oracle Streams. The Oracle Streams pool stores buffered queue messages in memory, and it provides memory for capture processes and outbound servers. The Oracle Streams pool always stores LCRs captured by a capture process, and it stores LCRs and messages that are enqueued into a buffered queue by applications. Ensure that there is enough space in the Oracle Streams pool at each database to store LCRs and run the components properly.</p>
<p>Each outbound server requires 1 MB of memory. The Oracle Streams pool is initialized the first time an outbound server is started.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP202" href="../../server.112/e10705/prep_rep.htm#STREP202"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for information about Oracle Streams pool requirements</div>
<a id="CBDGJHCE"></a>
<div id="XSTRM1561" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">If Required, Configure Log File Transfer to a Downstream Database</h5>
<p>If you decided to use a local capture process, then log file transfer is not required. However, if you decided to use downstream capture that uses redo transport services to transfer archived redo log files to the downstream database automatically, then configure log file transfer from the source database to the capture database. See <a href="#CBDDJIJD">"Decide How to Configure XStream"</a> for information about this decision.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP211" href="../../server.112/e10705/prep_rep.htm#STREP211"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions</div>
<a id="CBDCBGHF"></a>
<div id="XSTRM1562" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">If Required, Add Standby Redo Logs for Real-Time Downstream Capture</h5>
<p>If you decided to configure real-time downstream capture, then add standby redo logs to the capture database. See <a href="#CBDDJIJD">"Decide How to Configure XStream"</a> for information about this decision.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP251" href="../../server.112/e10705/prep_rep.htm#STREP251"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CBDIACGD"></a>
<div id="XSTRM1502" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Preparing for XStream In<a id="sthref158"></a><a id="sthref159"></a></h3>
<p>Ensure that the following prerequisites are met before configuring XStream In:</p>
<ul>
<li>
<p><a href="#CBDEDHCB">Configure an XStream Administrator</a></p>
</li>
<li>
<p><a href="#CBDBJGGI">Set the Relevant Initialization Parameters Relevant</a></p>
</li>
<li>
<p><a href="#CBDJIHGD">Configure the Oracle Streams Pool</a></p>
</li>
</ul>
<a id="CBDEDHCB"></a>
<div id="XSTRM1564" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Configure an XStream Administrator</h4>
<p>To configure and manage an XStream In configuration, create an XStream administrator on the Oracle database that will run the XStream inbound server.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CEGDFBCE">"Granting Privileges for the XStream Administrator"</a></div>
</div>
<!-- class="sect3" -->
<a id="CBDBJGGI"></a>
<div id="XSTRM1565" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Set the Relevant Initialization Parameters Relevant<a id="sthref160"></a><a id="sthref161"></a></h4>
<p>Some initialization parameters are important for the configuration, operation, reliability, and performance of XStream inbound servers. Set these parameters appropriately.</p>
<p><a class="olink STREP201" href="../../server.112/e10705/prep_rep.htm#STREP201"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> contains detailed information about all of the initialization parameters that are important for an Oracle Streams environment. The guidelines for setting these parameters also apply to an XStream configuration. In addition to the requirements described in <a class="olink STREP201" href="../../server.112/e10705/prep_rep.htm#STREP201"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for all Oracle Streams components, the following requirements apply to XStream inbound servers:</p>
<ul>
<li>
<p>Ensure that the <code>PROCESSES</code> initialization parameter is set to a value large enough to accommodate the inbound server background processes and all of the other Oracle Database background processes.</p>
</li>
<li>
<p>Ensure that the <code>SESSIONS</code> initialization parameter is set to a value large enough to accommodate the sessions used by the inbound server background processes and all of the other Oracle Database sessions.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CBDJIHGD"></a>
<div id="XSTRM1566" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Configure the Oracle Streams Pool<a id="sthref162"></a><a id="sthref163"></a></h4>
<p>The Oracle Streams pool is a portion of memory in the System Global Area (SGA) that provides memory for inbound servers. Ensure that there is enough space in the Oracle Streams pool for the inbound server to run properly. An inbound server requires 1 MB for each inbound server parallelism. For example, if parallelism is set to 10 for an inbound server, then at least 10 MB of memory is required for the inbound server. The Oracle Streams pool also must have enough space to store LCRs before they are applied. The Oracle Streams pool is initialized the first time an inbound server is started.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP202" href="../../server.112/e10705/prep_rep.htm#STREP202"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CBDHJEJD"></a>
<div id="XSTRM1497" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Configuring XStream Out<a id="sthref164"></a></h2>
<p>An outbound server in an XStream Out configuration streams Oracle database changes to a client application. The client application attaches to the outbound server using the Oracle Call Interface (OCI) or Java interface to receive these changes.</p>
<p>Configuring an outbound server involves creating the components that send captured database changes to the outbound server. It also involves configuring the outbound server itself, which includes specifying the connect user that the client application will use to attach to the outbound server.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CBDHHHAI">Configuring an XStream Outbound Server</a></p>
</li>
<li>
<p><a href="#CBDFGFAF">Adding an Additional Outbound Server to a Capture Process Stream</a></p>
</li>
</ul>
<a id="CBDHHHAI"></a>
<div id="XSTRM1563" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Configuring an XStream Outbound Server<a id="sthref165"></a></h3>
<p>You can create an outbound server using the following procedures in the <code>DBMS_XSTREAM_ADM</code> package:</p>
<ul>
<li>
<p>The <code>CREATE_OUTBOUND</code> procedure creates an outbound server, a queue, and a capture process in a single database with one procedure call.</p>
</li>
<li>
<p>The <code>ADD_OUTBOUND</code> procedure only creates an outbound server. You must create the capture process and queue separately, and they must exist before you run the <code>ADD_OUTBOUND</code> procedure. You can configure the capture process on the same database as the outbound server or on a different database.</p>
</li>
</ul>
<p>In both cases, you must create the client application that communicates with the outbound server and receives LCRs from the outbound server.</p>
<p>If you require multiple outbound servers, then you can use the <code>CREATE_OUTBOUND</code> procedure to create the capture process that captures database changes for the first outbound server. Next, you can run the <code>ADD_OUTBOUND</code> procedure to add additional outbound servers that receive the same captured changes. The capture process can reside on the same database as the outbound servers or on a different database.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#CBDGEGEA">Configuring Multiple XStream Out Components Using CREATE_OUTBOUND</a></p>
</li>
<li>
<p><a href="#CBDHAICE">Configuring an Outbound Server Using ADD_OUTBOUND</a></p>
</li>
</ul>
<a id="CBDGEGEA"></a>
<div id="XSTRM1499" class="sect3">
<h4 class="sect3">Configuring Multiple XStream Out Components Using CREATE_OUTBOUND<a id="sthref166"></a></h4>
<p>The <code>CREATE_OUTBOUND</code> procedure in the <code>DBMS_XSTREAM_ADM</code> package creates a capture process, queue, and outbound server in a single database. Both the capture process and the outbound server use the queue created by the procedure. When you run the procedure, you provide the name of the new outbound server, while the procedure generates a name for the capture process and queue. If you want all of the components to run on the same database, then the <code>CREATE_OUTBOUND</code> procedure is the fastest and easiest way to create an outbound server.</p>
<p class="subhead2"><a id="XSTRM72587"></a>Prerequisites</p>
<p>Before configuring XStream Out, ensure that the following prerequisites are met:</p>
<ul>
<li>
<p>Complete the tasks described in <a href="#CBDIHHEF">"Prerequisites for Configuring XStream Out"</a>.</p>
</li>
</ul>
<p class="subhead2"><a id="XSTRM72588"></a>Assumptions</p>
<p>This section makes the following assumptions:</p>
<ul>
<li>
<p>The capture process will be a local capture process, and it will run on the same database as the outbound server.</p>
<p>The instructions in this section can only set up the local capture and outbound server on the same database configuration described in <a href="#CBDDJIJD">"Decide How to Configure XStream"</a>.</p>
</li>
<li>
<p>The name of the outbound server is <code>xout</code>.</p>
</li>
<li>
<p>Data manipulation language (DML) and data definition language (DDL) changes made to the <code>oe.orders</code> and <code>oe.order_items</code> tables are sent to the outbound server.</p>
</li>
<li>
<p>DML and DDL changes made to the <code>hr</code> schema are sent to the outbound server.</p>
</li>
</ul>
<p><a href="#CEGCHCDE">Figure 4-5</a> provides an overview of this XStream Out configuration.</p>
<div id="XSTRM72659" class="figure">
<p class="titleinfigure"><a id="CEGCHCDE"></a>Figure 4-5 Sample XStream Out Configuration Created Using CREATE_OUTBOUND</p>
<img width="507" height="488" src="img/xstrm074.gif" alt="Description of Figure 4-5 follows" /><br />
<a id="sthref167" href="img_text/xstrm074.htm">Description of "Figure 4-5 Sample XStream Out Configuration Created Using CREATE_OUTBOUND"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="orderedlisttitle">To create an outbound server using the <code><span class="codeinlinebold">CREATE_OUTBOUND</span></code> procedure:&nbsp;</p>
<ol>
<li>
<p>In SQL*Plus, connect to the database as the XStream administrator.</p>
<p>See <a class="olink ADMIN00102" href="../../server.112/e25494/dba.htm#ADMIN00102"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about connecting to a database in SQL*Plus.</p>
</li>
<li id="CBDJFCJH">
<p>Run the <code>CREATE_OUTBOUND</code> procedure.</p>
<p>Given the assumptions for this section, run the following <code>CREATE_OUTBOUND</code> procedure:</p>
<pre>
DECLARE
  tables  DBMS_UTILITY.UNCL_ARRAY;
  schemas DBMS_UTILITY.UNCL_ARRAY;
  BEGIN
    tables(1)  := 'oe.orders';
    tables(2)  := 'oe.order_items';
    schemas(1) := 'hr';
  DBMS_XSTREAM_ADM.CREATE_OUTBOUND(
    server_name     =&gt;  'xout',
    table_names     =&gt;  tables,
    schema_names    =&gt;  schemas);
END;
/
</pre>
<p>Running this procedure performs the following actions:</p>
<ul>
<li>
<p>Configures supplemental logging for the <code>oe.orders</code> and <code>oe.order_items</code> tables and for all of the tables in the <code>hr</code> schema.</p>
</li>
<li>
<p>Creates a queue with a system-generated name that is used by the capture process and the outbound server.</p>
</li>
<li>
<p>Creates and starts a capture process with a system-generated name with rule sets that instruct it to capture DML and DDL changes to the <code>oe.orders</code> table, the <code>oe.order_items</code> table, and the <code>hr</code> schema.</p>
</li>
<li>
<p>Creates and starts an outbound server named <code>xout</code> with rule sets that instruct it to send DML and DDL changes to the <code>oe.orders</code> table, the <code>oe.order_items</code> table, and the <code>hr</code> schema to the client application.</p>
</li>
<li>
<p>Sets the current user as the connect user for the outbound server. In this example, the current user is the XStream administrator. The client application must connect to the database as the connect user to interact with the outbound server.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
To capture and send all database changes to the outbound server, specify <code>NULL</code> (the default) for the <code>table_names</code> and <code>schema_names</code> parameters.</div>
</li>
<li>
<p>Create and run the client application that will connect to the outbound server and receive the LCRs. See <a href="#CBDFEAJF">"Sample XStream Client Application"</a> for a sample application.</p>
</li>
<li>
<p>To add one or more additional outbound servers that receive LCRs from the capture process created in Step <a href="#CBDJFCJH">2</a>, follow the instructions in <a href="#CBDFGFAF">"Adding an Additional Outbound Server to a Capture Process Stream"</a>.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xstrm_xstream_adm.htm#CACBHJDD">"CREATE_OUTBOUND Procedure"</a></div>
</div>
<!-- class="sect3" -->
<a id="CBDHAICE"></a>
<div id="XSTRM1500" class="sect3">
<h4 class="sect3">Configuring an Outbound Server Using ADD_OUTBOUND<a id="sthref169"></a></h4>
<p>The <code>ADD_OUTBOUND</code> procedure in the <code>DBMS_XSTREAM_ADM</code> package creates an outbound server. This procedure does not create the capture process or the queue. You must configure these components manually.</p>
<p>The instructions in this section can set up any of the configurations described in <a href="#CBDDJIJD">"Decide How to Configure XStream"</a>. However, if you chose the local capture and outbound server on the same database configuration, then it is usually easier to use the <code>CREATE_OUTBOUND</code> procedure to configure all of the components simultaneously. See <a href="#CBDGEGEA">"Configuring Multiple XStream Out Components Using CREATE_OUTBOUND"</a>.</p>
<p class="subhead2"><a id="XSTRM72589"></a>Prerequisites</p>
<p>Before configuring XStream Out, ensure that the following prerequisites are met:</p>
<ul>
<li>
<p>Complete the tasks described in <a href="#CBDIHHEF">"Prerequisites for Configuring XStream Out"</a>.</p>
</li>
</ul>
<p class="subhead2"><a id="XSTRM72590"></a>Assumptions</p>
<p>This section makes the following assumptions:</p>
<ul>
<li>
<p>The name of the outbound server is <code>xout</code>.</p>
</li>
<li>
<p>The queue used by the outbound server is <code>xstrmadmin.xstream_queue</code>.</p>
</li>
<li>
<p>The source database is <code>db1.example.com</code>.</p>
</li>
<li>
<p>DML and DDL changes made to the <code>oe.orders</code> and <code>oe.order_items</code> tables are sent to the outbound server.</p>
</li>
<li>
<p>DML and DDL changes made to the <code>hr</code> schema are sent to the outbound server.</p>
</li>
<li>
<p>The capture process for the outbound server does not exist. (If the capture process exists, then skip Steps <a href="#CEGEEGEH">1</a> to <a href="#CBDHHGBG">3</a>, and go to Step <a href="#CEGCFJEI">4</a>.)</p>
</li>
</ul>
<p><a href="#CEGDCGCA">Figure 4-6</a> provides an overview of this XStream Out configuration.</p>
<div id="XSTRM72660" class="figure">
<p class="titleinfigure"><a id="CEGDCGCA"></a>Figure 4-6 Sample XStream Out Configuration Created Using ADD_OUTBOUND</p>
<img width="581" height="812" src="img/xstrm071.gif" alt="Description of Figure 4-6 follows" /><br />
<a id="sthref170" href="img_text/xstrm071.htm">Description of "Figure 4-6 Sample XStream Out Configuration Created Using ADD_OUTBOUND"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
If the capture database and the outbound server database are different databases, then a propagation propagates the LCRs to a queue at the outbound server database. If the capture database and outbound server database are the same, then the propagation is not needed.</div>
<p class="orderedlisttitle">To create an outbound server using the <code><span class="codeinlinebold">ADD_OUTBOUND</span></code> procedure:&nbsp;</p>
<ol>
<li id="CEGEEGEH">
<p>In SQL*Plus, connect to the database that will run the capture process (the capture database) as the XStream administrator.</p>
<p>See <a class="olink ADMIN00102" href="../../server.112/e25494/dba.htm#ADMIN00102"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about connecting to a database in SQL*Plus.</p>
</li>
<li>
<p>Create the queue that will be used by the capture process.</p>
<p>See <a class="olink STREP308" href="../../server.112/e10705/cprop.htm#STREP308"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions.</p>
</li>
<li id="CBDHHGBG">
<p>Create the capture process.</p>
<p>Add rules to the capture process's rule sets to capture changes to the <code>hr</code> schema, the <code>oe.orders</code> table, and the <code>oe.order_items</code> table. Do not start the capture process.</p>
<p>See <a class="olink STREP209" href="../../server.112/e10705/ccap.htm#STREP209"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions.</p>
</li>
<li id="CEGCFJEI">
<p>If the capture process will run on a different database than the outbound server, then set the <code>xout_client_exists</code> capture process parameter to <code>Y</code>.</p>
<p>Setting this parameter to <code>Y</code> enables the capture process to send LCRs to an outbound server.</p>
<p>Skip this step if the capture process will run on the same database as the outbound server. In this case, the <code>xout_client_exists</code> capture process parameter will be set to <code>Y</code> automatically.</p>
<p>See <a class="olink STRMS630" href="../../server.112/e17069/strms_mcap.htm#STRMS630"><span class="italic">Oracle Streams Concepts and Administration</span></a> for information about setting a capture process parameter. See <a class="olink ARPLS306" href="../../appdev.112/e40758/d_cap_a.htm#ARPLS306"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code>xout_client_exists</code> capture process parameter.</p>
</li>
<li id="CEGGHAHE">
<p>Connect to the source database.</p>
<p>The source database is the database that contains the database objects for which the capture process will capture changes. The source database and the capture database might be the same database.</p>
</li>
<li>
<p>Ensure that required supplemental logging is specified for the database objects at the source database.</p>
<p>Supplemental logging is required for the database objects for which the capture process will capture changes. If the capture database and the source database are the same database, then supplemental logging might have been specified during capture process creation.</p>
<p>Ensure that the following supplemental logging is specified at the source database:</p>
<ul>
<li>
<p>Any columns at the source database that are used in a primary key in tables for which changes are processed by the outbound server must be unconditionally logged in a log group or by database supplemental logging of primary key columns.</p>
</li>
<li>
<p>Any columns at the source database that are used by a rule or a rule-based transformation must be unconditionally logged.</p>
</li>
</ul>
<p>For the example in this section, ensure that supplemental logging is configured for the <code>hr</code> schema, the <code>oe.orders</code> table, and the <code>oe.order_items</code> table.</p>
<p>See <a class="olink STREP107" href="../../server.112/e10705/prep_rep.htm#STREP107"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions about specifying supplemental logging.</p>
</li>
<li>
<p>Connect to the database that will run the outbound server as the XStream administrator.</p>
</li>
<li>
<p>Create the queue that will be used by the outbound server.</p>
<p>This step is not required if the capture process and the outbound server run on the same database and use the same queue.</p>
<p>See <a class="olink STREP308" href="../../server.112/e10705/cprop.htm#STREP308"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions.</p>
</li>
<li>
<p>Run the <code>ADD_OUTBOUND</code> procedure.</p>
<p>Given the assumption for this section, run the following <code>ADD_OUTBOUND</code> procedure:</p>
<pre>
DECLARE
  tables  DBMS_UTILITY.UNCL_ARRAY;
  schemas DBMS_UTILITY.UNCL_ARRAY;
  BEGIN
    tables(1)  := 'oe.orders';
    tables(2)  := 'oe.order_items';
    schemas(1) := 'hr';
  DBMS_XSTREAM_ADM.ADD_OUTBOUND(
    server_name     =&gt;  'xout',
    queue_name      =&gt;  'xstrmadmin.xstream_queue',
    source_database =&gt;  'db1.example.com',
    table_names     =&gt;  tables,
    schema_names    =&gt;  schemas);
END;
/
</pre>
<p>If the capture process runs on the same database as the outbound server, then specify the capture process's queue for the <code>queue_name</code> parameter.</p>
<p>Running this procedure performs the following actions:</p>
<ul>
<li>
<p>Creates an outbound server named <code>xout</code>. The outbound server has rule sets that instruct it to send DML and DDL changes to the <code>oe.orders</code> table, the <code>oe.order_items</code> table, and the <code>hr</code> schema to the client application. The rules specify that these changes must have originated at the <code>db1.example.com</code> database. The outbound server dequeues LCRs from the queue <code>xstrmadmin.xstream_queue</code>.</p>
</li>
<li>
<p>Sets the current user as the connect user for the outbound server. In this example, the current user is the XStream administrator. The client application must connect to the database as the connect user to interact with the outbound server.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
For the outbound server to receive all of the LCRs sent by the capture process, specify <code>NULL</code> (the default) for the <code>table_names</code> and <code>schema_names</code> parameters.</div>
</li>
<li>
<p>Connect to the capture database as the XStream administrator.</p>
</li>
<li>
<p>Create the propagation that sends LCRs from the capture process's queue on the local database to the queue used by the outbound server on the outbound server database.</p>
<p>Add rules to the propagation's rule sets to send changes to the <code>hr</code> schema, the <code>oe.orders</code> table, and the <code>oe.order_items</code> table from the source queue to the destination queue.</p>
<p>This step is not required if the capture process and the outbound server run on the same database and use the same queue.</p>
<p>See <a class="olink STREP309" href="../../server.112/e10705/cprop.htm#STREP309"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for instructions.</p>
</li>
<li>
<p>Create and run the client application that will connect to the outbound server and receive the LCRs. See <a href="#CBDFEAJF">"Sample XStream Client Application"</a> for a sample application.</p>
</li>
<li>
<p>Connect to the database that is running outbound server as the XStream administrator.</p>
</li>
<li>
<p>Start the outbound server if it is disabled. For example:</p>
<pre>
exec DBMS_APPLY_ADM.START_APPLY('xout');
</pre></li>
<li>
<p>Connect to the capture database as the XStream administrator.</p>
</li>
<li>
<p>Start the capture process created in Step <a href="#CBDHHGBG">3</a>.</p>
<p>See <a class="olink STRMS217" href="../../server.112/e17069/strms_mcap.htm#STRMS217"><span class="italic">Oracle Streams Concepts and Administration</span></a> for instructions.</p>
</li>
<li>
<p>To add one or more additional outbound servers that receive LCRs from the capture process created in Step <a href="#CBDHHGBG">3</a>, follow the instructions in <a href="#CBDFGFAF">"Adding an Additional Outbound Server to a Capture Process Stream"</a>.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xstrm_xstream_adm.htm#CACCCAJJ">"ADD_OUTBOUND Procedure"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CBDFGFAF"></a>
<div id="XSTRM1639" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Adding an Additional Outbound Server to a Capture Process Stream</h3>
<p>XStream Out configurations often require multiple outbound servers that process a stream of LCRs from a single capture process. This section describes adding an additional outbound server to a database that already includes at least one outbound server. The additional outbound server uses the same queue as another outbound server to receive the LCRs from the capture process. When an XStream Out environment exists, use the <code>ADD_OUTBOUND</code> procedure in the <code>DBMS_XSTREAM_ADM</code> package to add another outbound server to a capture process stream.</p>
<p class="subhead2"><a id="XSTRM72591"></a>Prerequisites</p>
<p>Before completing the steps in this section, configure an XStream Out environment that includes at least one outbound server. The following sections describe configuring and XStream Out environment:</p>
<ul>
<li>
<p><a href="#CBDGEGEA">"Configuring Multiple XStream Out Components Using CREATE_OUTBOUND"</a></p>
</li>
<li>
<p><a href="#CBDHAICE">"Configuring an Outbound Server Using ADD_OUTBOUND"</a></p>
</li>
</ul>
<p class="subhead2"><a id="XSTRM72592"></a>Assumptions</p>
<p>This section makes the following assumptions:</p>
<ul>
<li>
<p>The name of the outbound server is <code>xout2</code>.</p>
</li>
<li>
<p>The queue used by the outbound server is <code>xstrmadmin.xstream_queue</code>.</p>
</li>
<li>
<p>DML and DDL changes made to the <code>oe.orders</code> and <code>oe.order_items</code> tables are sent to the outbound server.</p>
</li>
<li>
<p>DML and DDL changes made to the <code>hr</code> schema are sent to the outbound server.</p>
</li>
<li>
<p>The source database for the database changes is <code>db1.example.com</code>.</p>
</li>
</ul>
<p><a href="#CEGCCEHB">Figure 4-7</a> provides an overview of this XStream Out configuration.</p>
<div id="XSTRM72661" class="figure">
<p class="titleinfigure"><a id="CEGCCEHB"></a>Figure 4-7 Sample XStream Out Configuration With an Additional Outbound Server</p>
<img width="639" height="510" src="img/xstrm073.gif" alt="Description of Figure 4-7 follows" /><br />
<a id="sthref172" href="img_text/xstrm073.htm">Description of "Figure 4-7 Sample XStream Out Configuration With an Additional Outbound Server"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="orderedlisttitle">To add another outbound server to a capture process stream using the <code><span class="codeinlinebold">ADD_OUTBOUND</span></code> procedure:&nbsp;</p>
<ol>
<li>
<p>In SQL*Plus, connect to the database that will run the additional outbound server as the XStream administrator.</p>
<p>See <a class="olink ADMIN00102" href="../../server.112/e25494/dba.htm#ADMIN00102"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about connecting to a database in SQL*Plus.</p>
</li>
<li>
<p>Determine the name of the queue used by an existing outbound server that receives LCRs from the capture process.</p>
<p>Run the query in <a href="xstrm_mon.htm#CHDJCIEH">"Displaying General Information About an Outbound Server"</a> to determine the owner and name of the queue. This query also shows the name of the capture process and the source database name.</p>
</li>
<li>
<p>Run the <code>ADD_OUTBOUND</code> procedure.</p>
<p>Given the assumptions for this section, run the following <code>ADD_OUTBOUND</code> procedure:</p>
<pre>
DECLARE
  tables  DBMS_UTILITY.UNCL_ARRAY;
  schemas DBMS_UTILITY.UNCL_ARRAY;
  BEGIN
    tables(1)  := 'oe.orders';
    tables(2)  := 'oe.order_items';
    schemas(1) := 'hr';
  DBMS_XSTREAM_ADM.ADD_OUTBOUND(
    server_name     =&gt;  'xout2',
    queue_name      =&gt;  'xstrmadmin.xstream_queue',
    source_database =&gt;  'db1.example.com',
    table_names     =&gt;  tables,
    schema_names    =&gt;  schemas);
END;
/
</pre>
<p>Running this procedure performs the following actions:</p>
<ul>
<li>
<p>Creates an outbound server named <code>xout2</code>. The outbound server has rule sets that instruct it to send DML and DDL changes to the <code>oe.orders</code> table, the <code>oe.order_items</code> table, and the <code>hr</code> schema to the client application. The rules specify that these changes must have originated at the <code>db1.example.com</code> database. The outbound server dequeues LCRs from the queue <code>xstrmadmin.xstream_queue</code>.</p>
</li>
<li>
<p>Sets the current user as the connect user for the outbound server. In this example, the current user is the XStream administrator. The client application must connect to the database as the connect user to interact with the outbound server.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
For the outbound server to receive all of the LCRs sent by the capture process, specify <code>NULL</code> (the default) for the <code>table_names</code> and <code>schema_names</code> parameters.</div>
</li>
<li>
<p>If a client application does not exist, then create and run the client application that will connect to the outbound server and receive the LCRs. See <a href="#CBDFEAJF">"Sample XStream Client Application"</a> for a sample application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xstrm_xstream_adm.htm#CACCCAJJ">"ADD_OUTBOUND Procedure"</a></div>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CBDJFJJE"></a>
<div id="XSTRM1501" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Configuring XStream In<a id="sthref174"></a><a id="sthref175"></a><a id="sthref176"></a></h2>
<p>An inbound server in an XStream In configuration receives a stream of changes from a client application. The inbound server can apply these changes to database objects in an Oracle database, or it can process the changes in a customized way. A client application can attach to an inbound server and send row changes and DDL changes encapsulated in LCRs using the OCI or Java interface.</p>
<p>The <code>CREATE_INBOUND</code> procedure in the <code>DBMS_XSTREAM_ADM</code> package creates an inbound server. You must create the client application that communicates with the inbound server and sends LCRs to the inbound server.</p>
<p class="subhead2"><a id="XSTRM72593"></a>Prerequisites</p>
<p>Before configuring XStream In, ensure that the following prerequisites are met:</p>
<ul>
<li>
<p>Complete the tasks described in <a href="#CBDIACGD">"Preparing for XStream In"</a>.</p>
</li>
</ul>
<p class="subhead2"><a id="XSTRM72594"></a>Assumptions</p>
<p>This section makes the following assumptions:</p>
<ul>
<li>
<p>The name of the inbound server is <code>xin</code>.</p>
</li>
<li>
<p>The inbound server applies all of the changes it receives from the XStream client application.</p>
</li>
<li>
<p>The queue used by the inbound server is <code>xstrmadmin.xin_queue</code>.</p>
</li>
</ul>
<p><a href="#CEGIABCG">Figure 4-8</a> provides an overview of this XStream In configuration.</p>
<div id="XSTRM72662" class="figure">
<p class="titleinfigure"><a id="CEGIABCG"></a>Figure 4-8 Sample XStream In Configuration</p>
<img width="401" height="356" src="img/xstrm072.gif" alt="Description of Figure 4-8 follows" /><br />
<a id="sthref177" href="img_text/xstrm072.htm">Description of "Figure 4-8 Sample XStream In Configuration"</a><br />
<br /></div>
<!-- class="figure" -->
<p class="orderedlisttitle">To create an inbound server:&nbsp;</p>
<ol>
<li>
<p>In SQL*Plus, connect to the database that will run the inbound server as the XStream administrator.</p>
<p>See <a class="olink ADMIN00102" href="../../server.112/e25494/dba.htm#ADMIN00102"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about connecting to a database in SQL*Plus.</p>
</li>
<li>
<p>Run the <code>CREATE_INBOUND</code> procedure.</p>
<p>For example, the following <code>CREATE_INBOUND</code> procedure configures an inbound server named <code>xin</code>:</p>
<pre>
BEGIN
  DBMS_XSTREAM_ADM.CREATE_INBOUND(
    server_name =&gt; 'xin',
    queue_name  =&gt; 'xin_queue');
END;
/
</pre>
<p>Running this procedure performs the following actions:</p>
<ul>
<li>
<p>Creates an inbound server named <code>xin</code>.</p>
</li>
<li>
<p>Sets the queue with the name <code>xin_queue</code> as the inbound server's queue, and creates this queue if it does not exist. This queue does not store LCRs sent by the client application. Instead, it stores error transactions if an LCR raises an error. The current user is the queue owner. In this example, the current user is the XStream administrator.</p>
</li>
<li>
<p>Sets the current user as the apply user for the inbound server. In this example, the current user is the XStream administrator. The client application must connect to the database as the apply user to interact with the inbound server.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
By default, an inbound server does not use rules or rule sets. Therefore, it processes all LCRs sent to it by the client application. To add rules and rule sets, use the <code>DBMS_STREAMS_ADM</code> package or the <code>DBMS_RULE_ADM</code> package. See <a class="olink STRMS006" href="../../server.112/e17069/strms_rules.htm#STRMS006"><span class="italic">Oracle Streams Concepts and Administration</span></a>.</div>
</li>
<li>
<p>If necessary, create apply handlers for the inbound server.</p>
<p>Apply handlers are optional. Apply handlers process LCRs sent to an inbound server in a customized way.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STRMS175" href="../../server.112/e17069/strms_apply.htm#STRMS175"><span class="italic">Oracle Streams Concepts and Administration</span></a></div>
</li>
<li>
<p>Create and run the client application that will connect to the inbound server and send LCRs to it.</p>
<p>See <a href="#CBDFEAJF">"Sample XStream Client Application"</a> for a sample application.</p>
</li>
<li>
<p>If the inbound server is disabled, then start the inbound server.</p>
<p>For example, enter the following:</p>
<pre>
exec DBMS_APPLY_ADM.START_APPLY('xin');
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="xstrm_xstream_adm.htm#CACEGCGG">"CREATE_INBOUND Procedure"</a></div>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="CBDFEAJF"></a>
<div id="XSTRM1568" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Sample XStream Client Application<a id="sthref179"></a><a id="sthref180"></a></h2>
<p>This section contains a sample XStream client application. This application illustrates the basic tasks that are required of an XStream Out and XStream In application.</p>
<p>The application performs the following tasks:</p>
<ul>
<li>
<p>It attaches to an XStream outbound server and inbound server and waits for LCRs from the outbound server. The outbound server and inbound server are in two different databases.</p>
</li>
<li>
<p>When it receives an LCR from the outbound server, it immediately sends the LCR to the inbound server.</p>
</li>
<li>
<p>It periodically gets the processed low position from the inbound server and sends this value to the outbound server.</p>
</li>
<li>
<p>It periodically sends a "ping" LCR from the outbound server to the inbound server to move the inbound server's processed low position forward in times of low activity.</p>
</li>
</ul>
<p>In an XStream Out configuration that does not send LCRs to an inbound server, the client application must obtain the processed low position in another way.</p>
<p>This application waits indefinitely for transactions from the outbound server. To interrupt the application, enter the interrupt command for your operating system. For example, the interrupt command on some operating systems is <code>control-C</code>. If the program is restarted, then the outbound server starts sending LCRs from the processed low position that was set during the previous run.</p>
<p><a href="#CBDIHADI">Figure 4-9</a> provides an overview of the XStream environment configured in this section.</p>
<div id="XSTRM1640" class="figure">
<p class="titleinfigure"><a id="CBDIHADI"></a>Figure 4-9 Sample XStream Configuration</p>
<img width="672" height="290" src="img/xstrm508.gif" alt="Description of Figure 4-9 follows" /><br />
<a id="sthref181" href="img_text/xstrm508.htm">Description of "Figure 4-9 Sample XStream Configuration"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Before running the sample application, ensure that the following components exist:</p>
<ul>
<li>
<p>Two Oracle databases with network connectivity between them</p>
</li>
<li>
<p>An XStream administrator on both databases</p>
</li>
<li>
<p>An outbound server configuration on one database, including a capture process, queue, and outbound server</p>
</li>
<li>
<p>An inbound server configuration on another database</p>
</li>
</ul>
<p>The sample applications in the following sections perform the same tasks. One sample application uses the OCI API, and the other uses the Java API.</p>
<ul>
<li>
<p><a href="#CBDFIDGC">Sample XStream Client Application for the Oracle Call Interface API</a></p>
</li>
<li>
<p><a href="#CBDGIIID">Sample XStream Client Application for the Java API</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
<a id="sthref182"></a><a id="sthref183"></a>An Oracle Database installation includes several XStream demos. These demos are in the following location:
<pre>
$ORACLE_HOME/rdbms/demo/xstream
</pre></div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="xstrm_cncpt.htm#BCEBFIIA">"Position of LCRs and XStream In"</a></p>
</li>
<li>
<p><a href="#CBDHJEJD">"Configuring XStream Out"</a></p>
</li>
<li>
<p><a href="#CBDJFJJE">"Configuring XStream In"</a></p>
</li>
<li>
<p><a href="xstrm_pt_oci.htm#CIAFHDJF">Part IV, "XStream OCI API Reference"</a></p>
</li>
<li>
<p><a class="olink STXJV" href="../../appdev.112/e16674/toc.htm"><span class="italic">Oracle Database XStream Java API Reference</span></a></p>
</li>
<li>
<p><a href="#CEGDFBCE">"Granting Privileges for the XStream Administrator"</a></p>
</li>
</ul>
</div>
<a id="CBDFIDGC"></a>
<div id="XSTRM1569" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Sample XStream Client Application for the Oracle Call Interface API</h3>
<p>To run the sample XStream client application for the OCI API, compile and link the application file, and enter the following on a command line:</p>
<pre>
xio -ob_svr <span class="italic">xout_name</span> -ob_db <span class="italic">sn_xout_db</span> -ob_usr <span class="italic">xout_cu</span> -ob_pwd <span class="italic">xout_cu_pass</span> 
-ib_svr <span class="italic">xin_name</span> -ib_db <span class="italic">sn_xin_db</span> -ib_usr <span class="italic">xin_au</span> -ib_pwd <span class="italic">xin_au_pass</span>
</pre>
<p>Substitute the appropriate values for the following placeholders:</p>
<ul>
<li>
<p><span class="italic">xout_name</span> is the name of the outbound server.</p>
</li>
<li>
<p><span class="italic">sn_xout_db</span> is the service name for the outbound server's database.</p>
</li>
<li>
<p><span class="italic">xout_cu</span> is the outbound server's connect user.</p>
</li>
<li>
<p><span class="italic">xout_cu_pass</span> is the password for the outbound server's connect user.</p>
</li>
<li>
<p><span class="italic">xin_name</span> is the name of the inbound server.</p>
</li>
<li>
<p><span class="italic">sn_xin_db</span> is the service name for the inbound server's database.</p>
</li>
<li>
<p><span class="italic">xin_au</span> is the inbound server's apply user.</p>
</li>
<li>
<p><span class="italic">xin_au_pass</span> is the password for the inbound server's apply user.</p>
</li>
</ul>
<p>When the sample client application is running, it prints information about the row LCRs it is processing. The output looks similar to the following:</p>
<pre>
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=17.0.74
  owner=HR oname=COUNTRIES 
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=COMMIT txid=17.0.74
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=12.25.77
  owner=OE oname=ORDERS 
 
 ----------- ROW LCR Header  -----------------
  src_db_name=DB.EXAMPLE.COM
  cmd_type=UPDATE txid=12.25.77
  owner=OE oname=ORDERS 
</pre>
<p>This output contains the following information for each row LCR:</p>
<ul>
<li>
<p><code>src_db_name</code> shows the source database for the change encapsulated in the row LCR.</p>
</li>
<li>
<p><code>cmd_type</code> shows the type of SQL statement that made the change.</p>
</li>
<li>
<p><code>txid</code> shows the transaction ID of the transaction that includes the row LCR.</p>
</li>
<li>
<p><code>owner</code> shows the owner of the database object that was changed.</p>
</li>
<li>
<p><code>oname</code> shows the name of the database object that was changed.</p>
</li>
</ul>
<p>This demo is available in the following location:</p>
<pre>
$ORACLE_HOME/rdbms/demo/xstream/oci
</pre>
<p>The file name for the demo is <code>xio.c</code>. See the <code>README.txt</code> file in the demo directory for more information about compiling and running the application.</p>
<p>The code for the sample application that uses the OCI API follows:</p>
<pre>
#ifndef OCI_ORACLE
#include &lt;oci.h&gt;
#endif
 
#ifndef _STDIO_H
#include &lt;stdio.h&gt;
#endif
 
#ifndef _STDLIB_H
#include &lt;stdlib.h&gt;
#endif
 
#ifndef _STRING_H
#include &lt;string.h&gt;
#endif
 
#ifndef _MALLOC_H
#include &lt;malloc.h&gt;
#endif
 
/*---------------------------------------------------------------------- 
 *           Internal structures
 *----------------------------------------------------------------------*/ 
 
#define M_DBNAME_LEN    (128)
 
typedef struct conn_info                                     /* connect info */
{
  oratext * user;
  ub4       userlen;
  oratext * passw;
  ub4       passwlen;
  oratext * dbname;
  ub4       dbnamelen;
  oratext * svrnm;
  ub4       svrnmlen;
} conn_info_t;
 
typedef struct params
{
  conn_info_t  xout;                                        /* outbound info */
  conn_info_t  xin;                                          /* inbound info */
} params_t;
 
typedef struct oci                                            /* OCI handles */
{
  OCIEnv      *envp;                                   /* Environment handle */
  OCIError    *errp;                                         /* Error handle */
  OCIServer   *srvp;                                        /* Server handle */
  OCISvcCtx   *svcp;                                       /* Service handle */
  OCISession  *authp;
  OCIStmt    *stmtp;        
  boolean     attached;
  boolean     outbound;
} oci_t;
 
static void connect_db(conn_info_t *opt_params_p, oci_t ** ocip, ub2 char_csid,
                       ub2 nchar_csid);
static void disconnect_db(oci_t * ocip);
static void ocierror(oci_t * ocip, char * msg);
static void attach(oci_t * ocip, conn_info_t *conn, boolean outbound);
static void detach(oci_t *ocip);
static void get_lcrs(oci_t *xin_ocip, oci_t *xout_ocip);
static void get_chunks(oci_t *xin_ocip, oci_t *xout_ocip);
static void print_lcr(oci_t *ocip, void *lcrp, ub1 lcrtype, 
                      oratext **src_db_name, ub2  *src_db_namel);
static void print_chunk (ub1 *chunk_ptr, ub4 chunk_len, ub2 dty);
static void get_inputs(conn_info_t *xout_params, conn_info_t *xin_params, 
                       int argc, char ** argv);
static void get_db_charsets(conn_info_t *params_p, ub2 *char_csid, 
                            ub2 *nchar_csid);
static void set_client_charset(oci_t *outbound_ocip);
 
#define OCICALL(ocip, function) do {\
sword status=function;\
if (OCI_SUCCESS==status) break;\
else if (OCI_ERROR==status) \
{ocierror(ocip, (char *)"OCI_ERROR");\
exit(1);}\
else {printf("Error encountered %d\n", status);\
exit(1);}\
} while(0)
 
/*---------------------------------------------------------------------
 *                M A I N   P R O G R A M
 *---------------------------------------------------------------------*/
main(int argc, char **argv)
{
  /* Outbound and inbound connection info */
  conn_info_t   xout_params;
  conn_info_t   xin_params;
  oci_t        *xout_ocip = (oci_t *)NULL;
  oci_t        *xin_ocip = (oci_t *)NULL;
  ub2           obdb_char_csid = 0;                 /* outbound db char csid */
  ub2           obdb_nchar_csid = 0;               /* outbound db nchar csid */
 
  /* parse command line arguments */
  get_inputs(&amp;xout_params, &amp;xin_params, argc, argv); 
 
  /* Get the outbound database CHAR and NCHAR character set info */
  get_db_charsets(&amp;xout_params, &amp;obdb_char_csid, &amp;obdb_nchar_csid);
 
  /* Connect to the outbound db and set the client env to the outbound charsets
   * to minimize character conversion when transferring LCRs from outbound 
   * directly to inbound server. 
   */
  connect_db(&amp;xout_params, &amp;xout_ocip, obdb_char_csid, obdb_nchar_csid);
 
  /* Attach to outbound server */
  attach(xout_ocip, &amp;xout_params, TRUE);
 
  /* connect to inbound db and set the client charsets the same as the 
   * outbound db charsets.
   */
  connect_db(&amp;xin_params, &amp;xin_ocip, obdb_char_csid, obdb_nchar_csid);
 
  /* Attach to inbound server */
  attach(xin_ocip, &amp;xin_params, FALSE);
 
  /* Get lcrs from outbound server and send to inbound server */
  get_lcrs(xin_ocip, xout_ocip);
 
  /* Detach from XStream servers */
  detach(xout_ocip);
  detach(xin_ocip);
 
  /* Disconnect from both databases */
  disconnect_db(xout_ocip);
  disconnect_db(xin_ocip);
 
  free(xout_ocip);
  free(xin_ocip);
  exit (0);
}
 
/*---------------------------------------------------------------------
 * connect_db - Connect to the database and set the env to the given
 * char and nchar character set ids. 
 *---------------------------------------------------------------------*/
static void connect_db(conn_info_t *params_p, oci_t **ociptr, ub2 char_csid,
                ub2 nchar_csid)
{
  oci_t        *ocip;
 
  printf ("Connect to Oracle as %.*s@%.*s ",
          params_p-&gt;userlen, params_p-&gt;user, 
          params_p-&gt;dbnamelen, params_p-&gt;dbname);
       
  if (char_csid &amp;&amp; nchar_csid)
    printf ("using char csid=%d and nchar csid=%d", char_csid, nchar_csid);
 
  printf("\n");
 
  ocip = (oci_t *)malloc(sizeof(oci_t));
 
  if (OCIEnvNlsCreate(&amp;ocip-&gt;envp, OCI_OBJECT, (dvoid *)0,
                     (dvoid * (*)(dvoid *, size_t)) 0,
                     (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                     (void (*)(dvoid *, dvoid *)) 0,
                     (size_t) 0, (dvoid **) 0, char_csid, nchar_csid))
  {
    ocierror(ocip, (char *)"OCIEnvCreate() failed");
  }
 
  if (OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;errp,
                     (ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)"OCIHandleAlloc(OCI_HTYPE_ERROR) failed");
  }
 
  /* Logon to database */
  OCICALL(ocip,
          OCILogon(ocip-&gt;envp, ocip-&gt;errp, &amp;ocip-&gt;svcp,
                   params_p-&gt;user, params_p-&gt;userlen,
                   params_p-&gt;passw, params_p-&gt;passwlen,
                   params_p-&gt;dbname, params_p-&gt;dbnamelen));
 
  /* allocate the server handle */
  OCICALL(ocip,
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;srvp,
                         OCI_HTYPE_SERVER, (size_t) 0, (dvoid **) 0));
 
  OCICALL(ocip, 
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;stmtp,
                     (ub4) OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));
 
  if (*ociptr == (oci_t *)NULL)
  {
    *ociptr = ocip;
  }
}
 
/*---------------------------------------------------------------------
 * get_db_charsets - Get the database CHAR and NCHAR character set ids.
 *---------------------------------------------------------------------*/
static const oratext GET_DB_CHARSETS[] =  \
 "select parameter, value from nls_database_parameters where parameter = \
 'NLS_CHARACTERSET' or parameter = 'NLS_NCHAR_CHARACTERSET'";
 
#define PARM_BUFLEN      (30)
 
static void get_db_charsets(conn_info_t *params_p, ub2 *char_csid, 
                            ub2 *nchar_csid)
{
  OCIDefine  *defnp1 = (OCIDefine *) NULL;
  OCIDefine  *defnp2 = (OCIDefine *) NULL;
  oratext     parm[PARM_BUFLEN];
  oratext     value[OCI_NLS_MAXBUFSZ];
  ub2         parm_len = 0;
  ub2         value_len = 0;
  oci_t       ocistruct; 
  oci_t      *ocip = &amp;ocistruct;
   
  *char_csid = 0;
  *nchar_csid = 0;
  memset (ocip, 0, sizeof(ocistruct));
 
  if (OCIEnvCreate(&amp;ocip-&gt;envp, OCI_OBJECT, (dvoid *)0,
                     (dvoid * (*)(dvoid *, size_t)) 0,
                     (dvoid * (*)(dvoid *, dvoid *, size_t))0,
                     (void (*)(dvoid *, dvoid *)) 0,
                     (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)"OCIEnvCreate() failed");
  }
 
  if (OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;errp,
                     (ub4) OCI_HTYPE_ERROR, (size_t) 0, (dvoid **) 0))
  {
    ocierror(ocip, (char *)"OCIHandleAlloc(OCI_HTYPE_ERROR) failed");
  }
 
  OCICALL(ocip, 
          OCILogon(ocip-&gt;envp, ocip-&gt;errp, &amp;ocip-&gt;svcp,
                   params_p-&gt;user, params_p-&gt;userlen,
                   params_p-&gt;passw, params_p-&gt;passwlen,
                   params_p-&gt;dbname, params_p-&gt;dbnamelen));
 
  OCICALL(ocip, 
          OCIHandleAlloc((dvoid *) ocip-&gt;envp, (dvoid **) &amp;ocip-&gt;stmtp,
                     (ub4) OCI_HTYPE_STMT, (size_t) 0, (dvoid **) 0));
 
  /* Execute stmt to select the db nls char and nchar character set */ 
  OCICALL(ocip, 
          OCIStmtPrepare(ocip-&gt;stmtp, ocip-&gt;errp,
                         (CONST text *)GET_DB_CHARSETS,
                         (ub4)strlen((char *)GET_DB_CHARSETS),
                         (ub4)OCI_NTV_SYNTAX, (ub4)OCI_DEFAULT));
 
  OCICALL(ocip,
          OCIDefineByPos(ocip-&gt;stmtp, &amp;defnp1,
                         ocip-&gt;errp, (ub4) 1, parm,
                         PARM_BUFLEN, SQLT_CHR, (void*) 0,
                         &amp;parm_len, (ub2 *)0, OCI_DEFAULT));
 
  OCICALL(ocip,
          OCIDefineByPos(ocip-&gt;stmtp, &amp;defnp2,
                         ocip-&gt;errp, (ub4) 2, value,
                         OCI_NLS_MAXBUFSZ, SQLT_CHR, (void*) 0,
                         &amp;value_len, (ub2 *)0, OCI_DEFAULT));
 
  OCICALL(ocip, 
          OCIStmtExecute(ocip-&gt;svcp, ocip-&gt;stmtp, 
                         ocip-&gt;errp, (ub4)0, (ub4)0, 
                         (const OCISnapshot *)0,
                         (OCISnapshot *)0, (ub4)OCI_DEFAULT));
 
  while (OCIStmtFetch(ocip-&gt;stmtp, ocip-&gt;errp, 1,
                      OCI_FETCH_NEXT, OCI_DEFAULT) == OCI_SUCCESS)
  {
    value[value_len] = '\0';
    if (parm_len == strlen("NLS_CHARACTERSET") &amp;&amp;
        !memcmp(parm, "NLS_CHARACTERSET", parm_len))
    {
      *char_csid = OCINlsCharSetNameToId(ocip-&gt;envp, value);
      printf("Outbound database NLS_CHARACTERSET = %.*s (csid = %d) \n",
             value_len, value, *char_csid);
    }
    else if (parm_len == strlen("NLS_NCHAR_CHARACTERSET") &amp;&amp;
             !memcmp(parm, "NLS_NCHAR_CHARACTERSET", parm_len))
    {
      *nchar_csid = OCINlsCharSetNameToId(ocip-&gt;envp, value);
      printf("Outbound database NLS_NCHAR_CHARACTERSET = %.*s (csid = %d) \n",
             value_len, value, *nchar_csid);
    }
  }
 
  disconnect_db(ocip);
}
 
/*---------------------------------------------------------------------
 * attach - Attach to XStream server specified in connection info
 *---------------------------------------------------------------------*/
static void attach(oci_t * ocip, conn_info_t *conn, boolean outbound)
{
  sword       err;
 
  printf ("Attach to XStream %s server '%.*s'\n", 
          outbound ? "outbound" : "inbound",
          conn-&gt;svrnmlen, conn-&gt;svrnm);
 
  if (outbound)
  {
    OCICALL(ocip, 
            OCIXStreamOutAttach(ocip-&gt;svcp, ocip-&gt;errp, conn-&gt;svrnm,
                              (ub2)conn-&gt;svrnmlen, (ub1 *)0, 0, OCI_DEFAULT));
  }
  else
  {
    OCICALL(ocip, 
            OCIXStreamInAttach(ocip-&gt;svcp, ocip-&gt;errp, conn-&gt;svrnm,
                               (ub2)conn-&gt;svrnmlen, 
                               (oratext *)"From_XOUT", 9,
                               (ub1 *)0, 0, OCI_DEFAULT));
  }
 
  ocip-&gt;attached = TRUE;
  ocip-&gt;outbound = outbound;
}
 
/*---------------------------------------------------------------------
 * ping_svr - Ping inbound server by sending a commit LCR.
 *---------------------------------------------------------------------*/
static void ping_svr(oci_t *xin_ocip, void *commit_lcr,
                     ub1 *cmtpos, ub2 cmtpos_len, 
                     oratext *source_db, ub2 source_db_len)
{
  OCIDate     src_time;
  oratext     txid[128];
 
  OCICALL(xin_ocip, OCIDateSysDate(xin_ocip-&gt;errp, &amp;src_time));
  sprintf(txid, "Ping %2d:%2d:%2d",
          src_time.OCIDateTime.OCITimeHH,
          src_time.OCIDateTime.OCITimeMI,
          src_time.OCIDateTime.OCITimeSS);
 
  /* Initialize LCR with new txid and commit position */
  OCICALL(xin_ocip,
          OCILCRHeaderSet(xin_ocip-&gt;svcp, xin_ocip-&gt;errp,
                          source_db, source_db_len,
                          (oratext *)OCI_LCR_ROW_CMD_COMMIT,
                          (ub2)strlen(OCI_LCR_ROW_CMD_COMMIT),
                          (oratext *)0, 0,                     /* null owner */
                          (oratext *)0, 0,                    /* null object */
                          (ub1 *)0, 0,                           /* null tag */
                          txid, (ub2)strlen((char *)txid),
                          &amp;src_time, cmtpos, cmtpos_len,
                          0, commit_lcr, OCI_DEFAULT));
 
  /* Send commit lcr to inbound server. */
  if (OCIXStreamInLCRSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, commit_lcr,
                          OCI_LCR_XROW, 0, OCI_DEFAULT) == OCI_ERROR)
  {
    ocierror(xin_ocip, (char *)"OCIXStreamInLCRSend failed in ping_svr()");
  }
}
 
/*---------------------------------------------------------------------
 * get_lcrs - Get LCRs from outbound server and send to inbound server.
 *---------------------------------------------------------------------*/
static void get_lcrs(oci_t *xin_ocip, oci_t *xout_ocip)
{
  sword       status = OCI_SUCCESS;
  void       *lcr;
  ub1         lcrtype;
  oraub8      flag;
  ub1         proclwm[OCI_LCR_MAX_POSITION_LEN];
  ub2         proclwm_len = 0;
  ub1         sv_pingpos[OCI_LCR_MAX_POSITION_LEN];
  ub2         sv_pingpos_len = 0;
  ub1         fetchlwm[OCI_LCR_MAX_POSITION_LEN];
  ub2         fetchlwm_len = 0;
  void       *commit_lcr = (void *)0;
  oratext    *lcr_srcdb = (oratext *)0;
  ub2         lcr_srcdb_len = 0;
  oratext     source_db[M_DBNAME_LEN];
  ub2         source_db_len = 0;
  ub4         lcrcnt = 0;
 
  /* create an lcr to ping the inbound server periodically by sending a
   * commit lcr.
   */
  commit_lcr = (void*)0;
  OCICALL(xin_ocip,
          OCILCRNew(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, OCI_DURATION_SESSION,
                    OCI_LCR_XROW, &amp;commit_lcr, OCI_DEFAULT));
 
  while (status == OCI_SUCCESS)
  {
    lcrcnt = 0;                         /* reset lcr count before each batch */
 
    while ((status = 
                OCIXStreamOutLCRReceive(xout_ocip-&gt;svcp, xout_ocip-&gt;errp,
                                        &amp;lcr, &amp;lcrtype, &amp;flag, 
                                        fetchlwm, &amp;fetchlwm_len, OCI_DEFAULT))
                                               == OCI_STILL_EXECUTING)
    {
      lcrcnt++;
 
      /* print header of LCR just received */
      print_lcr(xout_ocip, lcr, lcrtype, &amp;lcr_srcdb, &amp;lcr_srcdb_len);
 
      /* save the source db to construct ping lcr later */
      if (!source_db_len &amp;&amp; lcr_srcdb_len)
      {
        memcpy(source_db, lcr_srcdb, lcr_srcdb_len);
        source_db_len = lcr_srcdb_len;
      }
      
      /* send the LCR just received */
      if (OCIXStreamInLCRSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, 
                              lcr, lcrtype, flag, OCI_DEFAULT) == OCI_ERROR)
      {
        ocierror(xin_ocip, (char *)"OCIXStreamInLCRSend failed");
      }
 
      /* If LCR has chunked columns (i.e, has LOB/Long/XMLType columns) */
      if (flag &amp; OCI_XSTREAM_MORE_ROW_DATA)
      {
        /* receive and send chunked columns */
        get_chunks(xin_ocip, xout_ocip); 
      }
    }
 
    if (status == OCI_ERROR)
      ocierror(xout_ocip, (char *)"OCIXStreamOutLCRReceive failed");
 
    /* clear the saved ping position if we just received some new lcrs */
    if (lcrcnt)
    {
      sv_pingpos_len = 0;
    }
 
    /* If no lcrs received during previous WHILE loop and got a new fetch 
     * LWM then send a commit lcr to ping the inbound server with the new
     * fetch LWM position.
     */
    else if (fetchlwm_len &gt; 0 &amp;&amp; source_db_len &gt; 0 &amp;&amp;
        (fetchlwm_len != sv_pingpos_len ||
         memcmp(sv_pingpos, fetchlwm, fetchlwm_len))) 
    {
      /* To ensure we don't send multiple lcrs with duplicate position, send
       * a new ping only if we have saved the last ping position.
       */
      if (sv_pingpos_len &gt; 0)
      {     
        ping_svr(xin_ocip, commit_lcr, fetchlwm, fetchlwm_len,
                 source_db, source_db_len); 
      }
 
      /* save the position just sent to inbound server */
      memcpy(sv_pingpos, fetchlwm, fetchlwm_len);
      sv_pingpos_len = fetchlwm_len;
    }
 
    /* flush inbound network to flush all lcrs to inbound server */
    OCICALL(xin_ocip,
            OCIXStreamInFlush(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, OCI_DEFAULT));
 
    
    /* get processed LWM of inbound server */   
    OCICALL(xin_ocip, 
            OCIXStreamInProcessedLWMGet(xin_ocip-&gt;svcp, xin_ocip-&gt;errp,
                                        proclwm, &amp;proclwm_len, OCI_DEFAULT));
 
    if (proclwm_len &gt; 0)
    {
      /* Set processed LWM for outbound server */
      OCICALL(xout_ocip, 
              OCIXStreamOutProcessedLWMSet(xout_ocip-&gt;svcp, xout_ocip-&gt;errp, 
                                           proclwm, proclwm_len, OCI_DEFAULT));
    }
  }
  
  if (status != OCI_SUCCESS)
    ocierror(xout_ocip, (char *)"get_lcrs() encounters error");
}
 
/*---------------------------------------------------------------------
 * get_chunks - Get each chunk for the current LCR and send it to 
 *              the inbound server.
 *---------------------------------------------------------------------*/
static void get_chunks(oci_t *xin_ocip, oci_t *xout_ocip)
{
  oratext *colname;
  ub2      colname_len;
  ub2      coldty;
  oraub8   col_flags;
  ub2      col_csid;
  ub4      chunk_len;
  ub1     *chunk_ptr;
  oraub8   row_flag;
  sword    err;
  sb4      rtncode;
 
  do
  {
    /* Get a chunk from outbound server */
    OCICALL(xout_ocip,
            OCIXStreamOutChunkReceive(xout_ocip-&gt;svcp, xout_ocip-&gt;errp, 
                                      &amp;colname, &amp;colname_len, &amp;coldty, 
                                      &amp;col_flags, &amp;col_csid, &amp;chunk_len, 
                                      &amp;chunk_ptr, &amp;row_flag, OCI_DEFAULT));
   
    /* print chunked column info */
    printf(
      "  Chunked column name=%.*s DTY=%d  chunk len=%d csid=%d col_flag=0x%x\n",
      colname_len, colname, coldty, chunk_len, col_csid, col_flags);
 
    /* print chunk data */
    print_chunk(chunk_ptr, chunk_len, coldty);
 
    /* Send the chunk just received to inbound server */
    OCICALL(xin_ocip,
            OCIXStreamInChunkSend(xin_ocip-&gt;svcp, xin_ocip-&gt;errp, colname,
                                  colname_len, coldty, col_flags,
                                  col_csid, chunk_len, chunk_ptr,
                                  row_flag, OCI_DEFAULT));
 
  } while (row_flag &amp; OCI_XSTREAM_MORE_ROW_DATA);
}
 
/*---------------------------------------------------------------------
 * print_chunk - Print chunked column information. Only print the first
 *               50 bytes for each chunk.
 *---------------------------------------------------------------------*/
static void print_chunk (ub1 *chunk_ptr, ub4 chunk_len, ub2 dty)
{
#define MAX_PRINT_BYTES     (50)          /* print max of 50 bytes per chunk */
 
  ub4  print_bytes;
 
  if (chunk_len == 0)
    return;
 
  print_bytes = chunk_len &gt; MAX_PRINT_BYTES ? MAX_PRINT_BYTES : chunk_len;
 
  printf("  Data = ", chunk_len);
  if (dty == SQLT_CHR)
    printf("%.*s", print_bytes, chunk_ptr);
  else
  {
    ub2  idx;
 
    for (idx = 0; idx &lt; print_bytes; idx++)
      printf("%02x", chunk_ptr[idx]);
  }
  printf("\n");
}
 
/*---------------------------------------------------------------------
 * print_lcr - Print header information of given lcr.
 *---------------------------------------------------------------------*/
static void print_lcr(oci_t *ocip, void *lcrp, ub1 lcrtype, 
                      oratext **src_db_name, ub2  *src_db_namel)
{
  oratext     *cmd_type;
  ub2          cmd_type_len;
  oratext     *owner;
  ub2          ownerl;
  oratext     *oname;
  ub2          onamel;
  oratext     *txid;
  ub2          txidl;
  sword        ret;
 
  printf("\n ----------- %s LCR Header  -----------------\n",
         lcrtype == OCI_LCR_XDDL ? "DDL" : "ROW");
 
  /* Get LCR Header information */
  ret = OCILCRHeaderGet(ocip-&gt;svcp, ocip-&gt;errp, 
                        src_db_name, src_db_namel,              /* source db */
                        &amp;cmd_type, &amp;cmd_type_len,            /* command type */
                        &amp;owner, &amp;ownerl,                       /* owner name */
                        &amp;oname, &amp;onamel,                      /* object name */
                        (ub1 **)0, (ub2 *)0,                      /* lcr tag */
                        &amp;txid, &amp;txidl, (OCIDate *)0,   /* txn id  &amp; src time */
                        (ub2 *)0, (ub2 *)0,              /* OLD/NEW col cnts */
                        (ub1 **)0, (ub2 *)0,                 /* LCR position */
                        (oraub8*)0, lcrp, OCI_DEFAULT);
 
  if (ret != OCI_SUCCESS)
    ocierror(ocip, (char *)"OCILCRHeaderGet failed");
  else
  {
    printf("  src_db_name=%.*s\n  cmd_type=%.*s txid=%.*s\n",
           *src_db_namel, *src_db_name, cmd_type_len, cmd_type, txidl, txid );
 
    if (ownerl &gt; 0)
      printf("  owner=%.*s oname=%.*s \n", ownerl, owner, onamel, oname);
  } 
}
 
/*---------------------------------------------------------------------
 * detach - Detach from XStream server
 *---------------------------------------------------------------------*/
static void detach(oci_t * ocip)
{
  sword  err = OCI_SUCCESS;
 
  printf ("Detach from XStream %s server\n",
          ocip-&gt;outbound ? "outbound" : "inbound" );
 
  if (ocip-&gt;outbound)
  {
    OCICALL(ocip, OCIXStreamOutDetach(ocip-&gt;svcp, ocip-&gt;errp, OCI_DEFAULT));
  }
  else
  {
    OCICALL(ocip, OCIXStreamInDetach(ocip-&gt;svcp, ocip-&gt;errp, 
                                     (ub1 *)0, (ub2 *)0,    /* processed LWM */
                                     OCI_DEFAULT));
  }
}
 
/*---------------------------------------------------------------------
 * disconnect_db  - Logoff from the database
 *---------------------------------------------------------------------*/
static void disconnect_db(oci_t * ocip)
{
  if (OCILogoff(ocip-&gt;svcp, ocip-&gt;errp))
  {
    ocierror(ocip, (char *)"OCILogoff() failed");
  }
 
  if (ocip-&gt;errp)
    OCIHandleFree((dvoid *) ocip-&gt;errp, (ub4) OCI_HTYPE_ERROR);
 
  if (ocip-&gt;envp)
    OCIHandleFree((dvoid *) ocip-&gt;envp, (ub4) OCI_HTYPE_ENV);
}
 
/*---------------------------------------------------------------------
 * ocierror - Print error status and exit program
 *---------------------------------------------------------------------*/
static void ocierror(oci_t * ocip, char * msg)
{
  sb4 errcode=0;
  text bufp[4096];
 
  if (ocip-&gt;errp)
  {
    OCIErrorGet((dvoid *) ocip-&gt;errp, (ub4) 1, (text *) NULL, &amp;errcode,
                bufp, (ub4) 4096, (ub4) OCI_HTYPE_ERROR);
    printf("%s\n%s", msg, bufp);
  }
  else
    puts(msg);
 
  printf ("\n");
  exit(1);
}
 
/*--------------------------------------------------------------------
 * print_usage - Print command usage
 *---------------------------------------------------------------------*/
static void print_usage(int exitcode)
{
  puts("\nUsage: xio -ob_svr &lt;outbound_svr&gt; -ob_db &lt;outbound_db&gt;\n" 
         "           -ob_usr &lt;conn_user&gt; -ob_pwd &lt;conn_user_pwd&gt;\n" 
         "           -ib_svr &lt;inbound_svr&gt; -ib_db &lt;inbound_db&gt;\n"
         "           -ib_usr &lt;apply_user&gt; -ib_pwd &lt;apply_user_pwd&gt;\n");
  puts("  ob_svr  : outbound server name\n"
       "  ob_db   : database name of outbound server\n"
       "  ob_usr  : connect user to outbound server\n"
       "  ob_pwd  : password of outbound's connect user\n"
       "  ib_svr  : inbound server name\n"
       "  ib_db   : database name of inbound server\n"
       "  ib_usr  : apply user for inbound server\n"
       "  ib_pwd  : password of inbound's apply user\n");
 
  exit(exitcode);
}
 
/*--------------------------------------------------------------------
 * get_inputs - Get user inputs from command line
 *---------------------------------------------------------------------*/
static void get_inputs(conn_info_t *xout_params, conn_info_t *xin_params, 
                       int argc, char ** argv)
{
  char * option;
  char * value;
 
  memset (xout_params, 0, sizeof(*xout_params));
  memset (xin_params, 0, sizeof(*xin_params));
  while(--argc)
  {
    /* get the option name */
    argv++;
    option = *argv;
 
    /* check that the option begins with a "-" */
    if (!strncmp(option, (char *)"-", 1))
    {
      option ++;
    }
    else
    {
      printf("Error: bad argument '%s'\n", option);
      print_usage(1);
    }
 
    /* get the value of the option */
    --argc;
    argv++;
 
    value = *argv;    
 
    if (!strncmp(option, (char *)"ob_db", 5))
    {
      xout_params-&gt;dbname = (oratext *)value;
      xout_params-&gt;dbnamelen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ob_usr", 6))
    {
      xout_params-&gt;user = (oratext *)value;
      xout_params-&gt;userlen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ob_pwd", 6))
    {
      xout_params-&gt;passw = (oratext *)value;
      xout_params-&gt;passwlen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ob_svr", 6))
    {
      xout_params-&gt;svrnm = (oratext *)value;
      xout_params-&gt;svrnmlen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_db", 5))
    {
      xin_params-&gt;dbname = (oratext *)value;
      xin_params-&gt;dbnamelen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_usr", 6))
    {
      xin_params-&gt;user = (oratext *)value;
      xin_params-&gt;userlen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_pwd", 6))
    {
      xin_params-&gt;passw = (oratext *)value;
      xin_params-&gt;passwlen = strlen(value);
    }
    else if (!strncmp(option, (char *)"ib_svr", 6))
    {
      xin_params-&gt;svrnm = (oratext *)value;
      xin_params-&gt;svrnmlen = strlen(value);
    }
    else
    {
      printf("Error: unknown option '%s'.\n", option);
      print_usage(1);
    }
  }
 
  /* print usage and exit if any argument is not specified */
  if (!xout_params-&gt;svrnmlen || !xout_params-&gt;passwlen || 
      !xout_params-&gt;userlen || !xout_params-&gt;dbnamelen ||
      !xin_params-&gt;svrnmlen || !xin_params-&gt;passwlen || 
      !xin_params-&gt;userlen || !xin_params-&gt;dbnamelen)
  {
    printf("Error: missing command arguments. \n");
    print_usage(1);
  }
}
</pre></div>
<!-- class="sect2" -->
<a id="CBDGIIID"></a>
<div id="XSTRM1570" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Sample XStream Client Application for the Java API</h3>
<p>To run the sample XStream client application for the Java API, compile and link the application file, and enter the following on a command line:</p>
<pre>
java xio <span class="italic">xsin_oraclesid</span> <span class="italic">xsin_host</span> <span class="italic">xsin_port</span> <span class="italic">xsin_username</span> 
<span class="italic">xsin_passwd</span> <span class="italic">xin_servername</span> <span class="italic">xsout_oraclesid</span> <span class="italic">xsout_host</span> <span class="italic">xsout_port</span> 
<span class="italic">xsout_username</span> <span class="italic">xsout_passwd</span> <span class="italic">xsout_servername</span>
</pre>
<p>Substitute the appropriate values for the following placeholders:</p>
<ul>
<li>
<p><span class="italic">xsin_oraclesid</span> is the Oracle SID of the inbound server's database.</p>
</li>
<li>
<p><span class="italic">xsin_host</span> is the host name of the computer system running the inbound server.</p>
</li>
<li>
<p><span class="italic">xsin_port</span> is the port number of the listener for the inbound server's database.</p>
</li>
<li>
<p><span class="italic">xsin_username</span> is the inbound server's apply user.</p>
</li>
<li>
<p><span class="italic">xsin_passwd</span> is the password for the inbound server's apply user.</p>
</li>
<li>
<p><span class="italic">xin_servername</span> is the name of the inbound server.</p>
</li>
<li>
<p><span class="italic">xsout_oraclesid</span> is the Oracle SID of the outbound server's database.</p>
</li>
<li>
<p><span class="italic">xsout_host</span> is the host name of the computer system running the outbound server.</p>
</li>
<li>
<p><span class="italic">xsout_port</span> is the port number of the listener for the outbound server's database.</p>
</li>
<li>
<p><span class="italic">xsout_username</span> is the outbound server's connect user.</p>
</li>
<li>
<p><span class="italic">xsout_passwd</span> is the password for the outbound server's connect user.</p>
</li>
<li>
<p><span class="italic">xsout_servername</span> is the name of the outbound server.</p>
</li>
</ul>
<p>When the sample client application is running, it prints information about attaching to the inbound server and outbound server, along with the last position for each server. The output looks similar to the following:</p>
<pre>
xsin_host = server2.example.com
xsin_port = 1482
xsin_ora_sid = db2
xsin connection url: jdbc:oracle:oci:@server2.example.com:1482:db2
xsout_host = server1.example.com
xsout_port = 1481
xsout_ora_sid = db1
xsout connection url: jdbc:oracle:oci:@server1.example.com:1481:db1
Attached to inbound server:xin
Inbound Server Last Position is: 0000000920250000000100000001000000092025000000010000000101
Attached to outbound server:xout
Last Position is: 0000000920250000000100000001000000092025000000010000000101
</pre>
<p>This demo is available in the following location:</p>
<pre>
$ORACLE_HOME/rdbms/demo/xstream/java
</pre>
<p>The file name for the demo is <code>xio.java</code>. See the <code>README.txt</code> file in the demo directory for more information about compiling and running the application.</p>
<p>The code for the sample application that uses the Java API follows:</p>
<pre>
import oracle.streams.*;
import oracle.jdbc.internal.OracleConnection;
import oracle.jdbc.*;
import oracle.sql.*;
import java.sql.*;
import java.util.*;
 
public class xio
{
  public static String xsinusername = null;
  public static String xsinpasswd = null;
  public static String xsinName = null;
  public static String xsoutusername = null;
  public static String xsoutpasswd = null;
  public static String xsoutName = null;
  public static String in_url = null;
  public static String out_url = null;
  public static Connection in_conn = null;
  public static Connection out_conn = null;
  public static XStreamIn xsIn = null;
  public static XStreamOut xsOut = null;
  public static byte[] lastPosition = null;
  public static byte[] processedLowPosition = null;
    
  public static void main(String args[])
  {
    // get connection url to inbound and outbound server
    in_url = parseXSInArguments(args);    
    out_url = parseXSOutArguments(args);    
 
    // create connection to inbound and outbound server
    in_conn = createConnection(in_url, xsinusername, xsinpasswd);
    out_conn = createConnection(out_url, xsoutusername, xsoutpasswd);
 
    // attach to inbound and outbound server
    xsIn = attachInbound(in_conn);
    xsOut = attachOutbound(out_conn);
    
    // main loop to get lcrs 
    get_lcrs(xsIn, xsOut);
    
    // detach from inbound and outbound server
    detachInbound(xsIn);
    detachOutbound(xsOut);
  }
    
  // parse the arguments to get the conncetion url to inbound db
  public static String parseXSInArguments(String args[])
  {
    String trace, pref;
    String orasid, host, port;
    
    if (args.length != 12)
    {
      printUsage();
      System.exit(0);
    }
 
    orasid = args[0];
    host = args[1];
    port = args[2];
    xsinusername = args[3];
    xsinpasswd = args[4];
    xsinName = args[5];
    
    System.out.println("xsin_host = "+host);
    System.out.println("xsin_port = "+port);
    System.out.println("xsin_ora_sid = "+orasid);
 
    String in_url = "jdbc:oracle:oci:@"+host+":"+port+":"+orasid;
    System.out.println("xsin connection url: "+ in_url);
 
    return in_url;
  }
 
  // parse the arguments to get the conncetion url to outbound db
  public static String parseXSOutArguments(String args[])
  {
    String trace, pref;
    String orasid, host, port;
    
    if (args.length != 12)
    {
      printUsage();
      System.exit(0);
    }
 
    orasid = args[6];
    host = args[7];
    port = args[8];
    xsoutusername = args[9];
    xsoutpasswd = args[10];
    xsoutName = args[11];
    
    
    System.out.println("xsout_host = "+host);
    System.out.println("xsout_port = "+port);
    System.out.println("xsout_ora_sid = "+orasid);
 
    String out_url = "jdbc:oracle:oci:@"+host+":"+port+":"+orasid;
    System.out.println("xsout connection url: "+ out_url);
 
    return out_url;
  }
 
  // print out sample program usage message
  public static void printUsage()
  {
    System.out.println("");      
    System.out.println("Usage: java xio "+"&lt;xsin_oraclesid&gt; " + "&lt;xsin_host&gt; "
                                         + "&lt;xsin_port&gt; ");
    System.out.println("                "+"&lt;xsin_username&gt; " + "&lt;xsin_passwd&gt; "
                                         + "&lt;xsin_servername&gt; ");
    System.out.println("                "+"&lt;xsout_oraclesid&gt; " + "&lt;xsout_host&gt; "
                                         + "&lt;xsout_port&gt; ");
    System.out.println("                "+"&lt;xsout_username&gt; " + "&lt;xsout_passwd&gt; "
                                         + "&lt;xsout_servername&gt; ");
  }
 
  // create a connection to an Oracle Database
  public static Connection createConnection(String url, 
                                            String username, 
                                            String passwd)
  {
    try
    {
      DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
      return DriverManager.getConnection(url, username, passwd);
    }
    catch(Exception e)
    {
      System.out.println("fail to establish DB connection to: " +url);
      e.printStackTrace();
      return null;
    }
  }
 
  // attach to the XStream Inbound Server
  public static XStreamIn attachInbound(Connection in_conn)
  {
    XStreamIn xsIn = null;
    try
    {
      xsIn = XStreamIn.attach((OracleConnection)in_conn, xsinName,
                              "XSDEMOINCLIENT" , XStreamIn.DEFAULT_MODE);
 
      // use last position to decide where should we start sending LCRs  
      lastPosition = xsIn.getLastPosition();
      System.out.println("Attached to inbound server:"+xsinName);
      System.out.print("Inbound Server Last Position is: ");
      if (null == lastPosition)
      {
        System.out.println("null");
      }
      else
      {
        printHex(lastPosition);
      }
      return xsIn;
    }
    catch(Exception e)
    {
      System.out.println("cannot attach to inbound server: "+xsinName);
      System.out.println(e.getMessage());
      e.printStackTrace();
      return null;
    }        
  }
 
  // attach to the XStream Outbound Server    
  public static XStreamOut attachOutbound(Connection out_conn)
  {
    XStreamOut xsOut = null;
 
    try
    {
      // when attach to an outbound server, client needs to tell outbound
      // server the last position.
      xsOut = XStreamOut.attach((OracleConnection)out_conn, xsoutName,
                                lastPosition, XStreamOut.DEFAULT_MODE);
      System.out.println("Attached to outbound server:"+xsoutName);
      System.out.print("Last Position is: ");  
      if (lastPosition != null)
      {
        printHex(lastPosition);
      }
      else
      {
        System.out.println("NULL");
      }
      return xsOut;
    }
    catch(Exception e)
    {
      System.out.println("cannot attach to outbound server: "+xsoutName);
      System.out.println(e.getMessage());
      e.printStackTrace();
      return null;
    } 
  }
 
  // detach from the XStream Inbound Server
  public static void detachInbound(XStreamIn xsIn)
  {
    byte[] processedLowPosition = null;
    try
    {
      processedLowPosition = xsIn.detach(XStreamIn.DEFAULT_MODE);
      System.out.print("Inbound server processed low Position is: ");
      if (processedLowPosition != null)
      {
        printHex(processedLowPosition);
      }
      else
      {
        System.out.println("NULL");
      }
    }
    catch(Exception e)
    {
      System.out.println("cannot detach from the inbound server: "+xsinName);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
 
  // detach from the XStream Outbound Server    
  public static void detachOutbound(XStreamOut xsOut)
  {
    try
    {
      xsOut.detach(XStreamOut.DEFAULT_MODE);
    }
    catch(Exception e)
    {
      System.out.println("cannot detach from the outbound server: "+xsoutName);
      System.out.println(e.getMessage());
      e.printStackTrace();
    }       
  }
 
  public static void get_lcrs(XStreamIn xsIn, XStreamOut xsOut)
  {
    byte[] ping_pos = null;
    byte[] fetchlwm = null;
    String src_db = null;
    
    if (null == xsIn) 
    {
      System.out.println("xstreamIn is null");
      System.exit(0);
    }
 
    if (null == xsOut)
    {
      System.out.println("xstreamOut is null");
      System.exit(0);
    }
 
    try
    {
      while(true) 
      {
        // receive an LCR from outbound server
        LCR alcr = xsOut.receiveLCR(XStreamOut.DEFAULT_MODE);
        fetchlwm = xsOut.getFetchLowWatermark();
    
        // save source db for ping lcr
        if (null != alcr)
          src_db = alcr.getSourceDatabaseName();
        
        if (xsOut.getBatchStatus() == XStreamOut.EXECUTING) // batch is active
        {
          assert alcr != null;
          // send the LCR to the inbound server
          xsIn.sendLCR(alcr, XStreamIn.DEFAULT_MODE);
 
          // also get chunk data for this LCR if any
          if (alcr instanceof RowLCR)
          {
            // receive chunk from outbound then send to inbound
            if (((RowLCR)alcr).hasChunkData())
            {
              ChunkColumnValue chunk = null; 
              do
              {
                chunk = xsOut.receiveChunk(XStreamOut.DEFAULT_MODE);
                xsIn.sendChunk(chunk, XStreamIn.DEFAULT_MODE);
              } while (!chunk.isEndOfRow());
            }
          }
          processedLowPosition = alcr.getPosition();
          ping_pos = processedLowPosition;          
        }
        else  // batch is end 
        {
          assert alcr == null;
 
          // send ping lcr if we haven't received any lcr in the batch
          // but we got a new fetch lwm, then send a commit lcr to
          // ping the inbound server with the new fetch LWM position
          if (null != src_db &amp;&amp; null != fetchlwm &amp;&amp; 
              !samePos(fetchlwm,ping_pos))
          {
            xsIn.sendLCR(createPing(src_db, fetchlwm), 
                         XStreamIn.DEFAULT_MODE);
            ping_pos = fetchlwm;
          }
 
          // flush the network
          xsIn.flush(XStreamIn.DEFAULT_MODE);
          // get the processed_low_position from inbound server
          processedLowPosition = 
              xsIn.getProcessedLowWatermark();
          // update the processed_low_position at oubound server
          if (null != processedLowPosition)
            xsOut.setProcessedLowWatermark(processedLowPosition, 
                                           XStreamOut.DEFAULT_MODE);
        }
      }
    }
    catch(Exception e)
    {
      System.out.println("exception when processing LCRs");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
 
  public static void printHex(byte[] b) 
  {
    for (int i = 0; i &lt; b.length; ++i) 
    {
      System.out.print(
        Integer.toHexString((b[i]&amp;0xFF) | 0x100).substring(1,3));
    }
    System.out.println("");
  }    
 
  // ping lcr is used to bump up the inbound server watermark
  private static RowLCR createPing(String src_db, byte[] pos)
  {
    java.util.Date today = new java.util.Date();
    java.sql.Timestamp now = new java.sql.Timestamp(today.getTime());
    oracle.sql.DATE src_time = new oracle.sql.DATE(now);
 
 
    RowLCR alcr = new DefaultRowLCR();
    ((RowLCR)alcr).setSourceDatabaseName(src_db);
    ((RowLCR)alcr).setSourceTime(src_time);
    ((RowLCR)alcr).setPosition(pos);
    ((RowLCR)alcr).setCommandType(RowLCR.COMMIT);
    ((RowLCR)alcr).setTransactionId("Ping: " + src_time.toString());
 
    return alcr;
  }
 
  private static boolean samePos(byte[] pos1, byte[] pos2)
  {
    int   cmp_len;
    boolean    result;
 
    if (pos1.length != pos2.length)
      return false;
    
    for (int i = 0; i&lt;pos1.length; i++)
    {
      if (pos1[i] != pos2[i])
        return false;            
    }
 
    return true;
  }
}
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1341">
<tr>
<td class="cellalignment1348">
<table class="cellalignment1346">
<tr>
<td class="cellalignment1345"><a href="xstrm_pt_admin.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1345"><a href="xstrm_man.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2009, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1350">
<table class="cellalignment1344">
<tr>
<td class="cellalignment1345"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1345"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1345"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1345"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1345"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1345"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
