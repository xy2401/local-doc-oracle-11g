<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Oracle Streams Information Consumption</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 732" />
<meta name="dcterms.created" content="2013-06-04T12:39:33Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Streams Concepts and Administration" />
<meta name="dcterms.identifier" content="E17069-08" />
<meta name="dcterms.isVersionOf" content="STRMS" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2002, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Glossary" href="strms_glossary.htm" title="Glossary" type="text/html" />
<link rel="Prev" href="strms_prop.htm" title="Previous" type="text/html" />
<link rel="Next" href="strms_rules.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e17069.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">11/57</span> <!-- End Header -->
<div id="STRMS004" class="chapter"><a id="g1018604"></a><a id="BGBDFEBD"></a>
<h1 class="chapter"><span class="secnum">4</span> Oracle Streams Information Consumption</h1>
<p><a id="sthref176"></a><a id="sthref177"></a>The following topics contain information about consuming information with Oracle Streams.</p>
<ul>
<li>
<p><a href="#BABEBJFD">Overview of Information Consumption with Oracle Streams</a></p>
</li>
<li>
<p><a href="#BABFBJDG">Implicit Consumption with an Apply Process</a></p>
</li>
<li>
<p><a href="#i1008622">Explicit Consumption with a Messaging Client</a></p>
</li>
<li>
<p><a href="#BABCICBA">Explicit Consumption with Manual Dequeue</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#g1026098">Chapter 17, "Managing Oracle Streams Information Consumption"</a></p>
</li>
<li>
<p><a href="strms_apmon.htm#CFFGFJBB">Chapter 26, "Monitoring Oracle Streams Apply Processes"</a></p>
</li>
<li>
<p><a href="strms_trapply.htm#BABHBJHA">Chapter 33, "Troubleshooting Apply"</a></p>
</li>
</ul>
</div>
<a id="BABEBJFD"></a>
<div id="STRMS363" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Overview of Information Consumption with Oracle Streams</h2>
<p>Consuming information with Oracle Streams means dequeuing a <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a> that contains the information from a <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a> and either processing or discarding the message. The consumed information can describe a database change, or it can be any other type of information. A dequeued message might have originated at the same database where it is dequeued, or it might have originated at a different database.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1006172">Ways to Consume Information with Oracle Streams</a></p>
</li>
<li>
<p><a href="#BABDIFIJ">Types of Information Consumed with Oracle Streams</a></p>
</li>
<li>
<p><a href="#BABHJGHF">Summary of Information Consumption Options</a></p>
</li>
</ul>
<a id="i1006172"></a>
<div id="STRMS100" class="sect2">
<h3 class="sect2">Ways to Consume Information with Oracle Streams<a id="sthref178"></a><a id="sthref179"></a><a id="sthref180"></a><a id="sthref181"></a><a id="sthref182"></a><a id="sthref183"></a></h3>
<p>The following are ways to consume information with Oracle Streams:</p>
<ul>
<li>
<p><a href="#BABBJDBE">Implicit Consumption</a></p>
</li>
<li>
<p><a href="#BABFJECH">Explicit Consumption</a></p>
</li>
</ul>
<a id="BABBJDBE"></a>
<div id="STRMS364" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Implicit Consumption</h4>
<p>With <a href="strms_glossary.htm#CBAHFJJB"><span class="xrefglossterm">implicit consumption</span></a>, an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> automatically dequeues either <a href="strms_glossary.htm#CHDCHEJI"><span class="xrefglossterm">captured LCR</span></a>s, <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a>s, or <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s. The queue must be an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a>. If a message contains a <a href="strms_glossary.htm#CHDEJJAF"><span class="xrefglossterm">logical change record (LCR)</span></a>, then the apply process can either apply it directly or call a user-specified procedure for processing. If the message does not contain an LCR, then the apply process can invoke a user-specified procedure called a <a href="strms_glossary.htm#CHDDHDEH"><span class="xrefglossterm">message handler</span></a> to process it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Captured LCRs must be dequeued by an apply process. However, if an apply process or a user procedure called by an apply process re-enqueues a captured LCR, then the LCR becomes a persistent LCR and can be explicitly dequeued.</div>
</div>
<!-- class="sect3" -->
<a id="BABFJECH"></a>
<div id="STRMS365" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Explicit Consumption</h4>
<p>With <a href="strms_glossary.htm#CBAGHCIE"><span class="xrefglossterm">explicit consumption</span></a>, messages are dequeued in one of the following ways:</p>
<ul>
<li>
<p>A <a href="strms_glossary.htm#CHDDGHHB"><span class="xrefglossterm">messaging client</span></a> explicitly dequeues <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a>s or <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s. The queue must be an <code>ANYDATA</code> queue. A messaging client dequeues messages when it is invoked by an application, and the application processes the messages after the messaging client dequeues them.</p>
</li>
<li>
<p>An application explicitly dequeues <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>s manually and processes them. An application can dequeue the following types of messages: <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a>s, <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s, <a href="strms_glossary.htm#CBABHDGA"><span class="xrefglossterm">buffered LCR</span></a>s, and <a href="strms_glossary.htm#CBAGGFJH"><span class="xrefglossterm">buffered user message</span></a>s. The queue from which the messages are dequeued can be an <code>ANYDATA</code> queue or a <a href="strms_glossary.htm#CHDBGAAH"><span class="xrefglossterm">typed queue</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDIFIJ"></a>
<div id="STRMS103" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Types of Information Consumed with Oracle Streams</h3>
<p>The following types of information can be consumed with Oracle Streams:</p>
<ul>
<li>
<p><a href="#BABGHECH">Captured LCRs</a></p>
</li>
<li>
<p><a href="#BABBBFEJ">Persistent LCRs</a></p>
</li>
<li>
<p><a href="#BABFEFHF">Buffered LCRs</a></p>
</li>
<li>
<p><a href="#BABBAEIE">Persistent User Messages</a></p>
</li>
<li>
<p><a href="#BABIBEIB">Buffered User Messages</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#CACHGDHC">"Types of Information Captured with Oracle Streams"</a></p>
</li>
<li>
<p><a href="strms_capture.htm#CACJJIAH">"Summary of Information Capture Options with Oracle Streams"</a></p>
</li>
</ul>
</div>
<a id="BABGHECH"></a>
<div id="STRMS366" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Captured LCRs<a id="sthref184"></a><a id="sthref185"></a></h4>
<p>A <span class="bold">captured LCR</span> is a <a href="strms_glossary.htm#CHDEJJAF"><span class="xrefglossterm">logical change record (LCR)</span></a> that was captured implicitly by a <a href="strms_glossary.htm#CHDBHECD"><span class="xrefglossterm">capture process</span></a> and enqueued into the <a href="strms_glossary.htm#CHDFJFED"><span class="xrefglossterm">buffered queue</span></a> portion of an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a>.</p>
<p>Only an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> can dequeue captured LCRs. After dequeue, an apply process can apply the captured LCR directly to make a database change, discard the captured LCR, send the captured LCR to an apply handler for processing, or re-enqueue the captured LCR into a <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#CACGECDI">"Implicit Capture with an Oracle Streams Capture Process"</a></p>
</li>
<li>
<p><a href="#BABFBJDG">"Implicit Consumption with an Apply Process"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABBBFEJ"></a>
<div id="STRMS367" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Persistent LCRs<a id="sthref186"></a><a id="sthref187"></a></h4>
<p>A <span class="bold">persistent LCR</span> is a <a href="strms_glossary.htm#CHDEJJAF"><span class="xrefglossterm">logical change record (LCR)</span></a> that was enqueued into the <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> portion of an <code>ANYDATA</code> queue. A persistent LCR can be enqueued in one of the following ways:</p>
<ul>
<li>
<p>Captured implicitly by a <a href="strms_glossary.htm#CBACHEDJ"><span class="xrefglossterm">synchronous capture</span></a> and enqueued</p>
</li>
<li>
<p>Constructed explicitly by an application and enqueued</p>
</li>
<li>
<p>Dequeued by an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> and enqueued by the same apply process using the <code>SET_ENQUEUE_DESTINATION</code> procedure in the <code>DBMS_APPLY_ADM</code> package</p>
</li>
</ul>
<p>Persistent LCRs can be dequeued by an apply process, a messaging client, or an application.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#CACIDGBI">"Implicit Capture with Synchronous Capture"</a></p>
</li>
<li>
<p><a href="strms_capture.htm#CACGBFJB">"Explicit Capture by Applications"</a></p>
</li>
<li>
<p><a href="#BABFBJDG">"Implicit Consumption with an Apply Process"</a></p>
</li>
<li>
<p><a href="#i1008622">"Explicit Consumption with a Messaging Client"</a></p>
</li>
<li>
<p><a href="#BABCICBA">"Explicit Consumption with Manual Dequeue"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABFEFHF"></a>
<div id="STRMS368" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Buffered LCRs</h4>
<p>A <span class="bold">buffered LCR</span> is a <a href="strms_glossary.htm#CHDEJJAF"><span class="xrefglossterm">logical change record (LCR)</span></a> that was constructed explicitly by an application and enqueued into the buffered queue portion of an <code>ANYDATA</code> queue. Only an application can dequeue buffered LCRs.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#CACGBFJB">"Explicit Capture by Applications"</a></p>
</li>
<li>
<p><a href="#BABCICBA">"Explicit Consumption with Manual Dequeue"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABBAEIE"></a>
<div id="STRMS369" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Persistent User Messages<a id="sthref188"></a><a id="sthref189"></a><a id="sthref190"></a><a id="sthref191"></a></h4>
<p>A <span class="bold">persistent user message</span> is a non-<a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a> <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a> of a user-defined type that was enqueued into a <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a>. A persistent user message can be enqueued in one of the following ways:</p>
<ul>
<li>
<p>Created explicitly by an application and enqueued</p>
</li>
<li>
<p>Dequeued by an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> and enqueued by the same apply process using the <code>SET_ENQUEUE_DESTINATION</code> procedure in the <code>DBMS_APPLY_ADM</code> package</p>
</li>
</ul>
<p>Apply processes and messaging clients can only dequeue persistent user messages that are in an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a>. Applications can dequeue persistent user messages that are in an <code>ANYDATA</code> queue or a <a href="strms_glossary.htm#CHDBGAAH"><span class="xrefglossterm">typed queue</span></a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#CACGBFJB">"Explicit Capture by Applications"</a></p>
</li>
<li>
<p><a href="#BABFBJDG">"Implicit Consumption with an Apply Process"</a></p>
</li>
<li>
<p><a href="#i1008622">"Explicit Consumption with a Messaging Client"</a></p>
</li>
<li>
<p><a href="#BABCICBA">"Explicit Consumption with Manual Dequeue"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABIBEIB"></a>
<div id="STRMS370" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Buffered User Messages</h4>
<p>A <span class="bold">buffered user message</span> is a non-<a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a> <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a> of a user-defined type that was created explicitly by an application and enqueued into a <a href="strms_glossary.htm#CHDFJFED"><span class="xrefglossterm">buffered queue</span></a>. A buffered user message can be enqueued into the buffered queue portion of an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a> or a <a href="strms_glossary.htm#CHDBGAAH"><span class="xrefglossterm">typed queue</span></a>. Only an application can dequeue buffered user messages.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#CACGBFJB">"Explicit Capture by Applications"</a></p>
</li>
<li>
<p><a href="#BABCICBA">"Explicit Consumption with Manual Dequeue"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABHJGHF"></a>
<div id="STRMS371" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Summary of Information Consumption Options</h3>
<p><a href="#BABJHCJI">Table 4-1</a> summarizes the information consumption options available with Oracle Streams.</p>
<div id="STRMS372" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref192"></a><a id="BABJHCJI"></a>Table 4-1 Information Consumption Options with Oracle Streams</p>
<table class="cellalignment1634" title="Information Consumption Options with Oracle Streams" summary="This table describes how each consumption option dequeues messages, the message types dequeued by each option, and when to use each option." dir="ltr">
<thead>
<tr class="cellalignment1625">
<th class="cellalignment1635" id="r1c1-t10">Consumption Type</th>
<th class="cellalignment1635" id="r1c2-t10">Dequeues Messages</th>
<th class="cellalignment1635" id="r1c3-t10">Message Types</th>
<th class="cellalignment1635" id="r1c4-t10">Use When</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r2c1-t10" headers="r1c1-t10">
<p><a href="#BABFBJDG">Implicit Consumption with an Apply Process</a></p>
</td>
<td class="cellalignment1631" headers="r2c1-t10 r1c2-t10">
<p>Continually and automatically when enabled</p>
</td>
<td class="cellalignment1631" headers="r2c1-t10 r1c3-t10">
<p>Captured LCRs</p>
<p>Persistent LCRs</p>
<p>Persistent user messages</p>
</td>
<td class="cellalignment1631" headers="r2c1-t10 r1c4-t10">
<p>You want to dequeue and process <a href="strms_glossary.htm#CHDCHEJI"><span class="xrefglossterm">captured LCR</span></a>s.</p>
<p>You want to dequeue persistent LCRs or persistent user messages continually and automatically from the <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> portion of an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a>.</p>
<p>You want to dequeue <a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a>s that must be applied directly to database objects to make database changes.</p>
<p>You want to dequeue messages and process them with an <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a>.</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r3c1-t10" headers="r1c1-t10">
<p><a href="#i1008622">Explicit Consumption with a Messaging Client</a></p>
</td>
<td class="cellalignment1631" headers="r3c1-t10 r1c2-t10">
<p>When invoked by an application</p>
</td>
<td class="cellalignment1631" headers="r3c1-t10 r1c3-t10">
<p>Persistent LCRs</p>
<p>Persistent user messages</p>
</td>
<td class="cellalignment1631" headers="r3c1-t10 r1c4-t10">
<p>You want to use a simple method for dequeuing on demand persistent LCRs or persistent user messages from the persistent queue portion of an <code>ANYDATA</code> queue.</p>
<p>You want to send messages to an application for processing after dequeue.</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r4c1-t10" headers="r1c1-t10">
<p><a href="#BABCICBA">Explicit Consumption with Manual Dequeue</a></p>
</td>
<td class="cellalignment1631" headers="r4c1-t10 r1c2-t10">
<p>Manually according to application logic</p>
</td>
<td class="cellalignment1631" headers="r4c1-t10 r1c3-t10">
<p>Persistent LCRs</p>
<p>Buffered LCRs</p>
<p>Persistent user messages</p>
<p>Buffered user messages</p>
</td>
<td class="cellalignment1631" headers="r4c1-t10 r1c4-t10">
<p>You want an application to dequeue manually persistent LCRs or buffered LCRs from an <code>ANYDATA</code> queue and process them.</p>
<p>You want an application to dequeue manually persistent user messages or buffered user messages from an <code>ANYDATA</code> queue or a <a href="strms_glossary.htm#CHDBGAAH"><span class="xrefglossterm">typed queue</span></a> and process them.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<div class="infobox-note">
<p class="notep1">Note:</p>
A single database can use any combination of the information consumption options summarized in the table.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#i1006083">Chapter 2, "Oracle Streams Information Capture"</a></p>
</li>
<li>
<p><a class="olink ADQUE" href="../e11013/toc.htm"><span class="italic">Oracle Streams Advanced Queuing User's Guide</span></a> for information about enqueuing messages</p>
</li>
<li>
<p><a class="olink STREP118" href="../../server.112/e10705/man_lcrs.htm#STREP118"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for more information about managing LCRs</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABFBJDG"></a>
<div id="STRMS104" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Implicit Consumption with an Apply Process</h2>
<p>This section explains the concepts related to Oracle Streams <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a>es.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#i1006156">Introduction to the Apply Process</a></p>
</li>
<li>
<p><a href="#BGBBHBFF">Apply Process Rules</a></p>
</li>
<li>
<p><a href="#BGBCDIDA">Types of Messages That Can Be Processed with an Apply Process</a></p>
</li>
<li>
<p><a href="#i1006214">Message Processing Options for an Apply Process</a></p>
</li>
<li>
<p><a href="#BABGCACJ">The Source of Messages Applied by an Apply Process</a></p>
</li>
<li>
<p><a href="#i1006373">Data Types Applied</a></p>
</li>
<li>
<p><a href="#BABICJGE">Automatic Data Type Conversion During Apply</a></p>
</li>
<li>
<p><a href="#BCEEHIHH">SQL Generation</a></p>
</li>
<li>
<p><a href="#i1006983">Oracle Streams Apply Processes and RESTRICTED SESSION</a></p>
</li>
<li>
<p><a href="#i1007083">Apply Process Subcomponents</a></p>
</li>
<li>
<p><a href="#BABEAJFC">Apply User</a></p>
</li>
<li>
<p><a href="#i1007170">Apply Process Parameters</a></p>
</li>
<li>
<p><a href="#i1007252">Persistent Apply Process Status Upon Database Restart</a></p>
</li>
<li>
<p><a href="#i1008918">The Error Queue</a></p>
</li>
</ul>
<a id="i1006156"></a>
<div id="STRMS373" class="sect2">
<h3 class="sect2">Introduction to the Apply Process<a id="sthref193"></a></h3>
<p>An <span class="bold">apply process</span> is an optional Oracle background process that dequeues <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>s from a specific <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a> and either applies each message directly, discards it, passes it as a parameter to an <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a>, or re-enqueues it. These messages can be logical change records (<a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a>s) or <a href="strms_glossary.htm#CHDDIHEC"><span class="xrefglossterm">user message</span></a>s.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
An apply process can only dequeue messages from an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a>, not a <a href="strms_glossary.htm#CHDBGAAH"><span class="xrefglossterm">typed queue</span></a>.</div>
</div>
<!-- class="sect2" -->
<a id="BGBBHBFF"></a>
<div id="STRMS374" class="sect2"><a id="BGBBBDCJ"></a>
<h3 class="sect2">Apply Process Rules<a id="sthref194"></a><a id="sthref195"></a></h3>
<p>An <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> applies messages based on <a href="strms_glossary.htm#CHDIFFCF"><span class="xrefglossterm">rule</span></a>s that you define. For <a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a>s, each rule specifies the database objects and types of changes for which the rule evaluates to <code>TRUE</code>. For <a href="strms_glossary.htm#CHDDIHEC"><span class="xrefglossterm">user message</span></a>s, you can create rules to control apply process behavior for specific types of messages. You can place these rules in the <a href="strms_glossary.htm#CHDEEDIJ"><span class="xrefglossterm">positive rule set</span></a> or <a href="strms_glossary.htm#CHDBHJHI"><span class="xrefglossterm">negative rule set</span></a> for the apply process.</p>
<p>If a rule evaluates to <code>TRUE</code> for a message, and the rule is in the positive rule set for an apply process, then the apply process dequeues and processes the message. If a rule evaluates to <code>TRUE</code> for a message, and the rule is in the negative rule set for an apply process, then the apply process discards the message. If an apply process has both a positive and a negative rule set, then the negative rule set is always evaluated first.</p>
<p>You can specify apply process rules for LCRs at the following levels:</p>
<ul>
<li>
<p>A table rule applies or discards either row changes resulting from DML changes or DDL changes to a particular table. A subset rule is a table rule that include a subset of the row changes to a particular table.</p>
</li>
<li>
<p>A schema rule applies or discards either row changes resulting from DML changes or DDL changes to the database objects in a particular schema.</p>
</li>
<li>
<p>A global rule applies or discards either all row changes resulting from DML changes or all DDL changes in the <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a> associated with an apply process.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_adrules.htm#BABEBHGC">Chapter 11, "Advanced Rule Concepts"</a></p>
</li>
<li>
<p><a href="strms_rules.htm#g1049257">Chapter 5, "How Rules Are Used in Oracle Streams"</a></p>
</li>
<li>
<p><a href="strms_mrules.htm#BABBHHIA">"Managing Rules"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BGBCDIDA"></a>
<div id="STRMS375" class="sect2">
<h3 class="sect2">Types of Messages That Can Be Processed with an Apply Process<a id="sthref196"></a><a id="sthref197"></a><a id="sthref198"></a></h3>
<p>Apply processes can dequeue the following types of messages:</p>
<ul>
<li>
<p><span class="bold">Captured LCRs:</span> A <a href="strms_glossary.htm#CHDEJJAF"><span class="xrefglossterm">logical change record (LCR)</span></a> that was captured implicitly by a <a href="strms_glossary.htm#CHDBHECD"><span class="xrefglossterm">capture process</span></a> and enqueued into the <a href="strms_glossary.htm#CHDFJFED"><span class="xrefglossterm">buffered queue</span></a> portion of an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a>. In some situations, an optimization enables capture processes to send LCRs to apply processes more efficiently. This optimization is called combined capture and apply.</p>
</li>
<li>
<p><span class="bold">Persistent LCRs:</span> An LCR that was captured implicitly by a <a href="strms_glossary.htm#CBACHEDJ"><span class="xrefglossterm">synchronous capture</span></a>, constructed and enqueued persistently by an application, or enqueued by an apply process. A persistent LCR is enqueued into the <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> portion of an <code>ANYDATA</code> queue.</p>
</li>
<li>
<p><span class="bold">Persistent user messages:</span> A non-LCR <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a> of a user-defined type that was enqueued explicitly by an application or an apply process. A persistent user message is enqueued into the persistent queue portion of an <code>ANYDATA</code> queue. In addition, a user message can be enqueued into an <code>ANYDATA</code> queue or a typed queue, but an apply process can dequeue only user messages in an <code>ANYDATA</code> queue.</p>
</li>
</ul>
<p>A single apply process cannot dequeue both from the buffered queue and persistent queue portions of a queue. If messages in both the buffered queue and persistent queue must be processed by an apply process, then the <a href="strms_glossary.htm#CHDGCAJA"><span class="xrefglossterm">destination database</span></a> must have at least two apply processes to process the messages.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_prop.htm#i1006125">"Introduction to Message Staging and Propagation"</a></p>
</li>
<li>
<p><a class="olink STREP206" href="../../server.112/e10705/capply.htm#STREP206"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for information about creating an apply process</p>
</li>
<li>
<p><a href="strms_adcca.htm#BGBJBDHJ">Chapter 12, "Combined Capture and Apply Optimization"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006214"></a>
<div id="STRMS175" class="sect2">
<h3 class="sect2">Message Processing Options for an Apply Process<a id="sthref199"></a><a id="sthref200"></a><a id="sthref201"></a><a id="sthref202"></a><a id="sthref203"></a><a id="sthref204"></a><a id="sthref205"></a><a id="sthref206"></a></h3>
<p>An apply process can either apply <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>s directly or send messages to an <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a> for processing. Your options for message processing depend on whether the message received by an apply process is a <a href="strms_glossary.htm#CHDIGGFF"><span class="xrefglossterm">row logical change record (row LCR)</span></a>, a <a href="strms_glossary.htm#CHDDJGGJ"><span class="xrefglossterm">DDL logical change record (DDL LCR)</span></a>, or a <a href="strms_glossary.htm#CHDDIHEC"><span class="xrefglossterm">user message</span></a>.</p>
<p><a href="#i1006221">Figure 4-1</a> shows the message processing options for an apply process and which options can be used for different types of messages.</p>
<div id="STRMS376" class="figure">
<p class="titleinfigure"><a id="i1006221"></a>Figure 4-1 Apply Process Message Processing Options</p>
<img width="501" height="221" src="img/strms013.gif" alt="Description of Figure 4-1 follows" /><br />
<a id="sthref207" href="img_text/strms013.htm">Description of "Figure 4-1 Apply Process Message Processing Options"</a><br />
<br /></div>
<!-- class="figure" -->
<p>By default, an apply process applies LCRs directly. The apply process executes the change in the LCR on the database object identified in the LCR. The apply process either successfully applies the change in the LCR or, if a <a href="strms_glossary.htm#CHDDGDDG"><span class="xrefglossterm">conflict</span></a> or an apply error is encountered, tries to resolve the error with a conflict handler or a user-specified procedure called an <span class="bold">error handler</span>.</p>
<p>If a conflict handler can resolve the conflict, then it either applies the LCR or it discards the change in the LCR. If an error handler can resolve the error, then it should apply the LCR, if appropriate. An error handler can resolve an error by modifying the LCR before applying it. If the conflict handler or error handler cannot resolve the error, then the apply process places the transaction, and all LCRs associated with the transaction, into the error queue.</p>
<p>Instead of applying LCRs directly, you can process LCRs in a customized way with apply handlers. When you use an apply handler, an apply process passes a message to a collection of SQL statements or to a user-defined PL/SQL procedure for processing. An apply handler can process the message in a customized way.</p>
<p>An apply process cannot apply user messages directly. An apply process that dequeues user messages must have a message handler to process the user messages.</p>
<p>There are several types of apply handlers. This section uses the following categories to describe apply handlers:</p>
<div id="STRMS1464" class="tblhruleformal">
<p class="titleintable"><a id="sthref208"></a><a id="sthref209"></a>Table 4-2 Characteristics of Apply Handlers</p>
<table class="cellalignment1634" title="Characteristics of Apply Handlers" summary="This table describes each category used to define apply handlers." dir="ltr">
<thead>
<tr class="cellalignment1625">
<th class="cellalignment1635" id="r1c1-t16">Category</th>
<th class="cellalignment1635" id="r1c2-t16">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r2c1-t16" headers="r1c1-t16">
<p>Mechanism</p>
</td>
<td class="cellalignment1631" headers="r2c1-t16 r1c2-t16">
<p>The means by which the apply handler processes messages. The mechanism for an apply handler is either SQL statements or a user-defined PL/SQL procedure.</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r3c1-t16" headers="r1c1-t16">
<p>Type of message</p>
</td>
<td class="cellalignment1631" headers="r3c1-t16 r1c2-t16">
<p>The type of message processed by the apply handler. The message type is either <a href="strms_glossary.htm#CHDIGGFF"><span class="xrefglossterm">row logical change record (row LCR)</span></a>, <a href="strms_glossary.htm#CHDDJGGJ"><span class="xrefglossterm">DDL logical change record (DDL LCR)</span></a>, <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>, or <a href="strms_glossary.htm#CHDHCEJD"><span class="xrefglossterm">transaction control directive</span></a>.</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r4c1-t16" headers="r1c1-t16">
<p>Message creator</p>
</td>
<td class="cellalignment1631" headers="r4c1-t16 r1c2-t16">
<p>The component that creates the messages processed by the apply handler. The message creator is either a capture process, a synchronous capture, or an application.</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r5c1-t16" headers="r1c1-t16">
<p>Scope</p>
</td>
<td class="cellalignment1631" headers="r5c1-t16 r1c2-t16">
<p>The level at which the apply handler is set. The scope is either one operation on one table or all operations on all database objects.</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r6c1-t16" headers="r1c1-t16">
<p>Number allowed for each apply process</p>
</td>
<td class="cellalignment1631" headers="r6c1-t16 r1c2-t16">
<p>The number of apply handlers of a specific type allowed for each apply process. The number allowed is either one or many.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>The following sections describe different types of apply handlers:</p>
<ul>
<li>
<p><a href="#BABGBDGD">DML Handlers</a></p>
</li>
<li>
<p><a href="#BABDBCFF">DDL Handlers</a></p>
</li>
<li>
<p><a href="#i1007980">Message Handlers</a></p>
</li>
<li>
<p><a href="#i1008356">Precommit Handlers</a></p>
</li>
<li>
<p><a href="#BABFHCDF">Considerations for Apply Handlers</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
An apply process cannot apply non-LCR messages directly. Each <a href="strms_glossary.htm#CHDDIHEC"><span class="xrefglossterm">user message</span></a> dequeued by an apply process must be processed with a message handler.</div>
<a id="BABGBDGD"></a>
<div id="STRMS379" class="sect3">
<h4 class="sect3">DML Handlers<a id="sthref210"></a><a id="sthref211"></a></h4>
<p>DML handlers process row logical change records (row LCRs) dequeued by an apply process. There are two types of DML handlers: statement DML handlers and procedure DML handlers. A statement DML handler uses a collection of SQL statements to process row LCRs, while a procedure DML handler uses a PL/SQL procedure to process row LCRs.</p>
<p>The following sections describe DML handlers and error handlers:</p>
<ul>
<li>
<p><a href="#BGBFBIAE">Statement DML Handlers</a></p>
</li>
<li>
<p><a href="#BGBFFGHI">Procedure DML Handlers</a></p>
</li>
</ul>
<a id="BGBFBIAE"></a>
<div id="STRMS1465" class="sect4">
<h5 class="sect4">Statement DML Handlers<a id="sthref212"></a><a id="sthref213"></a></h5>
<p>A <span class="bold">statement DML handler</span> has the following characteristics:</p>
<ul>
<li>
<p>Mechanism: A collection of SQL statements</p>
</li>
<li>
<p>Type of message: Row LCR</p>
</li>
<li>
<p>Message creator: Capture process, synchronous capture, or application</p>
</li>
<li>
<p>Scope: One operation on one table</p>
</li>
<li>
<p>Number allowed for each apply process: Many, and many can be specified for the same operation on the same table</p>
</li>
</ul>
<p>Each SQL statement included in a statement DML handler has a unique execution sequence number. When a statement DML handler is invoked, it executes its statements in order from the statement with the lowest execution sequence number to the statement with the highest execution sequence number. An execution sequence number can be a positive number, a negative number, or a decimal number.</p>
<p>For each table associated with an apply process, you can set a separate statement DML handler to process each of the following types of operations in row LCRs:</p>
<ul>
<li>
<p><code>INSERT</code></p>
</li>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
</ul>
<p>A statement DML handler is invoked when the apply process dequeues a row LCR that performs the specified operation on the specified table. For example, the <code>hr.employees</code> table can have one statement DML handler to process <code>INSERT</code> operations and a different statement DML handler to process <code>UPDATE</code> operations. Alternatively, the <code>hr.employees</code> table can use the same statement DML handler for each type of operation.</p>
<p>You can specify multiple statement DML handlers for the same operation on the same table. In this case, these statement DML handlers can execute in any order, and each statement DML handler receives a copy of the original row LCR that was dequeued by the apply process.</p>
<p>A SQL statement in a statement DML handler can include the following types of operations in row LCRs:</p>
<ul>
<li>
<p><code>INSERT</code></p>
</li>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>MERGE</code></p>
</li>
</ul>
<p>For example, a SQL statement in a statement DML handler can process a row LCR that updates the <code>hr.employees</code> table, and this statement can include an <code>INSERT</code> operation that inserts a row into a different table.</p>
<p>Statement DML handlers can run valid DML statements on row LCRs, but statement DML handlers cannot modify the column values in row LCRs. However, statement DML handlers can use SQL to insert a row or update a row with column values that are different than the ones in the row LCR. Also, statement DML handlers should never commit and never roll back.</p>
<p>To execute a row LCR in a statement DML handler, invoke the <code>EXECUTE</code> member procedure for the row LCR. A statement that runs the <code>EXECUTE</code> member procedure can be placed anywhere in the execution sequence order of the statement DML handler. It is not necessary to execute a row LCR unless the goal is to apply the changes in the row LCR to a table in addition to performing any other SQL statements in the statement DML handler.</p>
<p><a id="sthref214"></a>To add a statement to a statement DML handler, use the <code>ADD_STMT_TO_HANDLER</code> procedure in the <code>DBMS_STREAMS_HANDLER_ADM</code> package. To add a statement DML handler to an apply process, use the <code>ADD_STMT_HANDLER</code> procedure in the <code>DBMS_APPLY_ADM</code> package. You can either add a statement DML handler to a specific apply process, or you can add a statement DML handler as a general statement DML handler that is used by all apply processes in the database. If a statement DML handler for an operation on a table is used by a specific apply process, and another statement DML handler is a general handler for the same operation on the same table, then both handlers are invoked when an apply process dequeues a row LCR with the operation on the table. Each statement DML handler receives the original row LCR, and the statement DML handlers can execute in any order.</p>
<p>Statement DML handlers are often used to record the changes made to tables. Statement DML handlers can also perform changes that do not modify column values. For example, statement DML handlers can change the data type of a column.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>When you run the <code>ADD_STMT_HANDLER</code> procedure, you specify the object for which the handler is used. This object does not need to exist at the destination database when you run the procedure.</p>
</li>
<li>
<p><a id="sthref215"></a><a id="sthref216"></a>A change handler is a special type of statement DML handler that tracks table changes and was created by either the <code>DBMS_STREAMS_ADM.MAINTAIN_CHANGE_TABLE</code> procedure or the <code>DBMS_APPLY_ADM.SET_CHANGE_HANDLER</code> procedure.</p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#BGBFBBBA">"Managing a Statement DML Handler"</a></p>
</li>
<li>
<p><a href="strms_apmon.htm#CACIJBDA">"Displaying Information About Statement DML Handlers"</a></p>
</li>
<li>
<p><a href="strms_capture.htm#i1006190">"Row LCRs"</a></p>
</li>
<li>
<p><a href="ap_restrictions.htm#BABBIDBA">"Unsupported Data Types for Apply Handlers"</a></p>
</li>
<li>
<p><a href="strms_change_table.htm#CHDGHDHF">Chapter 20, "Using Oracle Streams to Record Table Changes"</a> for information about change handlers</p>
</li>
<li>
<p><a class="olink ARPLS307" href="../../appdev.112/e40758/t_lcr.htm#ARPLS307"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>EXECUTE</code> member procedure for LCR types</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" -->
<a id="BGBFFGHI"></a>
<div id="STRMS1466" class="sect4"><!-- infolevel="all" infotype="General" -->
<h5 class="sect4">Procedure DML Handlers<a id="sthref217"></a><a id="sthref218"></a></h5>
<p>A <span class="bold">procedure DML handler</span> has the following characteristics:</p>
<ul>
<li>
<p>Mechanism: A user-defined PL/SQL procedure</p>
</li>
<li>
<p>Type of message: Row LCR</p>
</li>
<li>
<p>Message creator: Capture process, synchronous capture, or application</p>
</li>
<li>
<p>Scope: One operation on one table</p>
</li>
<li>
<p>Number allowed for each apply process: Many, but only one can be specified for the same operation on the same table</p>
</li>
</ul>
<p>For each table associated with an apply process, you can set a separate procedure DML handler to process each of the following types of operations in row LCRs:</p>
<ul>
<li>
<p><code>INSERT</code></p>
</li>
<li>
<p><code>UPDATE</code></p>
</li>
<li>
<p><code>DELETE</code></p>
</li>
<li>
<p><code>LOB_UPDATE</code></p>
</li>
</ul>
<p>A procedure DML handler is invoked when the apply process dequeues a row LCR that performs the specified operation on the specified table. For example, the <code>hr.employees</code> table can have one procedure DML handler to process <code>INSERT</code> operations and a different procedure DML handler to process <code>UPDATE</code> operations. Alternatively, the <code>hr.employees</code> table can use the same procedure DML handler for each type of operation.</p>
<p>The PL/SQL procedure can perform any customized processing of row LCRs. For example, if you want each insert into a particular table at the <a href="strms_glossary.htm#CHDHFBJG"><span class="xrefglossterm">source database</span></a> to result in inserts into multiple tables at the <a href="strms_glossary.htm#CHDGCAJA"><span class="xrefglossterm">destination database</span></a>, then you can create a user-defined PL/SQL procedure that processes <code>INSERT</code> operations on the table to accomplish this. Unlike statement DML handlers, procedure DML handlers can modify the column values in row LCRs.</p>
<p>A procedure DML handler should never commit and never roll back, except to a named savepoint that the user-defined PL/SQL procedure has established. To execute a row LCR inside a procedure DML handler, invoke the <code>EXECUTE</code> member procedure for the row LCR. Also, a procedure DML handler should handle any errors that might occur during processing.</p>
<p><a id="sthref219"></a>To set a procedure DML handler, use the <code>SET_DML_HANDLER</code> procedure in the <code>DBMS_APPLY_ADM</code> package. You can either set a procedure DML handler for a specific apply process, or you can set a procedure DML handler to be a general procedure DML handler that is used by all apply processes in the database. If a procedure DML handler for an operation on a table is set for a specific apply process, and another procedure DML handler is a general handler for the same operation on the same table, then the specific procedure DML handler takes precedence over the general procedure DML handler.</p>
<p>Typically, procedure DML handlers are used in Oracle Streams <a href="strms_glossary.htm#CHDCDAHE"><span class="xrefglossterm">replication</span></a> environments to perform custom processing of row LCRs, but procedure DML handlers can be used in nonreplication environments as well. For example, you can use such handlers to record changes made to database objects without replicating these changes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you run the <code>SET_DML_HANDLER</code> procedure, you specify the object for which the handler is used. This object does not need to exist at the destination database when you run the procedure.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#i1006190">"Row LCRs"</a></p>
</li>
<li>
<p><a href="ap_restrictions.htm#BABBIDBA">"Unsupported Data Types for Apply Handlers"</a></p>
</li>
<li>
<p><a class="olink ARPLS307" href="../../appdev.112/e40758/t_lcr.htm#ARPLS307"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>EXECUTE</code> member procedure for LCR types</p>
</li>
<li>
<p><a href="strms_mapply.htm#BGBJHGHG">"Managing a DML Handler"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BGBICIAB"></a>
<div id="STRMS1467" class="sect3">
<h4 class="sect3">Error Handlers</h4>
<p>An <span class="bold">error handler</span> has the following characteristics:</p>
<ul>
<li>
<p>Mechanism: A user-defined PL/SQL procedure</p>
</li>
<li>
<p>Type of message: Row LCR</p>
</li>
<li>
<p>Message creator: Capture process, synchronous capture, or application</p>
</li>
<li>
<p>Scope: One operation on one table</p>
</li>
<li>
<p>Number allowed for each apply process: Many, but only one can be specified for the same operation on the same table</p>
</li>
</ul>
<p>An error handler is similar to a procedure DML handler. The difference between the two is that an error handler is invoked only if an apply error results when an apply process tries to apply a row LCR for the specified operation on the specified table.</p>
<p>You create an error handler in the same way that you create a procedure DML handler, except that you set the <code>error_handler</code> parameter to <code>TRUE</code> when you run the <code>SET_DML_HANDLER</code> procedure.</p>
<p>An error handler cannot coexist with a procedure DML handler for the same operation on the same table. However, an error handler can coexist with a statement DML handler for the same operation on the same table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Statement DML handlers cannot be used as error handlers.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#i1006190">"Row LCRs"</a></p>
</li>
<li>
<p><a href="ap_restrictions.htm#BABBIDBA">"Unsupported Data Types for Apply Handlers"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABDBCFF"></a>
<div id="STRMS380" class="sect3">
<h4 class="sect3">DDL Handlers<a id="sthref220"></a><a id="sthref221"></a></h4>
<p>A <span class="bold">DDL handler</span> has the following characteristics:</p>
<ul>
<li>
<p>Mechanism: A user-defined PL/SQL procedure</p>
</li>
<li>
<p>Type of message: DDL LCR</p>
</li>
<li>
<p>Message creator: Capture process or application</p>
</li>
<li>
<p>Scope: All DDL LCRs dequeued by the apply process</p>
</li>
<li>
<p>Number allowed for each apply process: One</p>
</li>
</ul>
<p>The user-defined PL/SQL procedure can perform any customized processing of DDL LCRs. For example, to log DDL changes before applying them, you can create a procedure that processes DDL operations to accomplish this.</p>
<p>To execute a DDL LCR inside a DDL handler, invoke the <code>EXECUTE</code> member procedure for the DDL LCR. To associate a DDL handler with a particular apply process, use the <code>ddl_handler</code> parameter in the <code>CREATE_APPLY</code> or the <code>ALTER_APPLY</code> procedure in the <code>DBMS_APPLY_ADM</code> package.</p>
<p>Typically, DDL handlers are used in Oracle Streams <a href="strms_glossary.htm#CHDCDAHE"><span class="xrefglossterm">replication</span></a> environments to perform custom processing of DDL LCRs, but these handlers can be used in nonreplication environments as well. For example, you can use such handlers to record changes made to database objects without replicating these changes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_capture.htm#BABBDHJC">"DDL LCRs"</a></p>
</li>
<li>
<p><a class="olink ARPLS307" href="../../appdev.112/e40758/t_lcr.htm#ARPLS307"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>EXECUTE</code> member procedure for LCR types</p>
</li>
<li>
<p><a href="strms_mapply.htm#BGBJHHEI">"Managing a DDL Handler"</a> for more information about DDL handlers</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1007980"></a>
<div id="STRMS381" class="sect3">
<h4 class="sect3">Message Handlers<a id="sthref222"></a><a id="sthref223"></a><a id="sthref224"></a></h4>
<p>A <span class="bold">message handler</span> has the following characteristics:</p>
<ul>
<li>
<p>Mechanism: A user-defined PL/SQL procedure</p>
</li>
<li>
<p>Type of message: Persistent user message (non-LCR)</p>
</li>
<li>
<p>Message creator: Application</p>
</li>
<li>
<p>Scope: All user messages dequeued by the apply process</p>
</li>
<li>
<p>Number allowed for each apply process: One</p>
</li>
</ul>
<p>A message handler offers advantages in any environment that has applications that must update one or more remote databases or perform some other remote action. These applications can enqueue persistent user messages into a <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a> at the local database, and Oracle Streams can propagate each persistent user message to the appropriate queues at destination databases. If there are multiple destinations, then Oracle Streams provides the infrastructure for automatic propagation and processing of these messages at these destinations. If there is only one destination, then Oracle Streams still provides a layer between the application at the source database and the application at the destination database, so that, if the application at the remote database becomes unavailable, then the application at the source database can continue to function normally.</p>
<p>For example, a message handler can convert a persistent user message into an electronic mail message. In this case, the persistent user message can contain the attributes you would expect in an electronic mail message, such as <code>from</code>, <code>to</code>, <code>subject</code>, <code>text_of_message</code>, and so on. After converting a message into an electronic mail messages, the message handler can send it out through an electronic mail gateway.</p>
<p>You can specify a message handler for an apply process using the <code>message_handler</code> parameter in the <code>CREATE_APPLY</code> or the <code>ALTER_APPLY</code> procedure in the <code>DBMS_APPLY_ADM</code> package. An Oracle Streams apply process always assumes that a non-LCR message has no dependencies on any other messages in the queue. If parallelism is greater than <code>1</code> for an apply process that applies <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s, then these messages can be dequeued by a message handler in any order. Therefore, if dependencies exist between these messages in your environment, then Oracle recommends that you set apply process parallelism to <code>1</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#i1006583">"Managing the Message Handler for an Apply Process"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1008356"></a>
<div id="STRMS382" class="sect3">
<h4 class="sect3">Precommit Handlers<a id="sthref225"></a><a id="sthref226"></a></h4>
<p>A <span class="bold">precommit handler</span> has the following characteristics:</p>
<ul>
<li>
<p>Mechanism: A user-defined PL/SQL procedure</p>
</li>
<li>
<p>Type of message: Commit directive for transactions that include row LCRs or persistent user messages</p>
</li>
<li>
<p>Message creator: Capture process, synchronous capture, or application</p>
</li>
<li>
<p>Scope: All row LCRs with commit directives dequeued by the apply process</p>
</li>
<li>
<p>Number allowed for each apply process: One</p>
</li>
</ul>
<p>You can use a precommit handler to audit commit directives for <a href="strms_glossary.htm#CHDCHEJI"><span class="xrefglossterm">captured LCR</span></a>s and transaction boundaries for <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a>s and <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s. A commit directive is a <a href="strms_glossary.htm#CHDHCEJD"><span class="xrefglossterm">transaction control directive</span></a> that contains a <code>COMMIT</code>. A precommit handler is a user-defined PL/SQL procedure that can receive the commit information for a transaction and process the commit information in any customized way. A precommit handler can work with a statement DML handler, procedure DML handler, or message handler.</p>
<p>For example, a precommit handler can improve performance by caching data for the length of a transaction. This data can include cursors, temporary LOBs, data from a <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>, and so on. The precommit handler can release or execute the objects cached by the handler when a transaction completes.</p>
<p>A precommit handler executes when the apply process commits a transaction. You can use the <code>commit_serialization</code> apply process parameter to control the commit order for an apply process.</p>
<p>The following list describes commit directives and transaction boundaries:</p>
<ul>
<li>
<p><span class="bold">Commit Directives for Captured LCRs:</span> When you are using a capture process, and a user commits a transaction, the capture process captures an internal commit directive for the transaction if the transaction contains row LCRs that were captured by the capture process. The capture process also records the transaction identifier in each captured LCR in a transaction.</p>
<p>Once enqueued, these commit directives can be propagated to <a href="strms_glossary.htm#CHDHJHJD"><span class="xrefglossterm">destination queue</span></a>s, along with the LCRs in a transaction. A precommit handler receives each commit SCN for these internal commit directives in the queue of an apply process before they are processed by the apply process.</p>
</li>
<li>
<p><span class="bold">Transaction Boundaries for Persistent LCRs Enqueued by Synchronous Captures:</span> When you are using a synchronous capture, and a user commits a transaction, the persistent LCRs that were enqueued by the synchronous capture are organized into a message group. The synchronous capture records the transaction identifier in each persistent LCR in a transaction.</p>
<p>After persistent LCRs are enqueued by a synchronous capture, the persistent LCRs in the message group can be propagated to other queues. When an apply process is configured to process these persistent LCRs, it generates a commit SCN for all of the persistent LCRs in a message group. The commit SCN values generated by an individual apply process have no relation to the source transaction, or to the values generated by any other apply process. A precommit handler configured for such an apply process receives the commit SCN supplied by the apply process.</p>
</li>
<li>
<p><span class="bold">Transaction Boundaries for Messages Enqueued by Applications:</span> An application can enqueue persistent LCRs and persistent user messages, as well as other types of messages. When the user performing these enqueue operations issues a <code>COMMIT</code> statement to end the transaction, the enqueued persistent LCRs and persistent user messages are organized into a message group.</p>
<p>When messages that were enqueued by an application are organized into a message group, the messages in the message group can be propagated to other queues. When an apply process is configured to process these messages, it generates a single transaction identifier and commit SCN for all the messages in a message group. Transaction identifiers and commit SCN values generated by an individual apply process have no relation to the source transaction, or to the values generated by any other apply process. A precommit handler configured for such an apply process receives the commit SCN supplied by the apply process.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#i1009583">"Managing the Precommit Handler for an Apply Process"</a></p>
</li>
<li>
<p><a class="olink ARPLS314" href="../../appdev.112/e40758/d_apply.htm#ARPLS314"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about apply process parameters</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABFHCDF"></a>
<div id="STRMS383" class="sect3">
<h4 class="sect3">Considerations for Apply Handlers</h4>
<p>The following are considerations for using apply handlers:</p>
<ul>
<li>
<p>Both statement DML handlers and procedure DML handlers process row LCRs. Procedure DML handlers require PL/SQL processing while statement DML handlers do not. Therefore, statement DML handlers typically perform better than procedure DML handlers. Statement DML handlers also are usually easier to configure that procedure DML handlers. However, procedure DML handlers can perform operations that are not possible with a statement DML handler, such as controlling program flow and trapping errors. In addition, procedure DML handlers can modify column values in row LCRs while statement DML handlers cannot.</p>
</li>
<li>
<p>Statement DML handlers, procedure DML handlers, error handlers, DDL handlers, and message handlers can execute an LCR by calling the LCR's <code>EXECUTE</code> member procedure.</p>
</li>
<li>
<p>All applied DDL LCRs commit automatically. Therefore, if a DDL handler calls the <code>EXECUTE</code> member procedure of a DDL LCR, then a commit is performed automatically.</p>
</li>
<li>
<p>An apply handler that uses a PL/SQL procedure can set an Oracle Streams session <a href="strms_glossary.htm#CHDBJJHH"><span class="xrefglossterm">tag</span></a>. Statement DML handlers cannot set an Oracle Streams session tag.</p>
</li>
<li>
<p><a id="sthref227"></a>An apply handler that uses a user-defined PL/SQL procedure can call a Java stored procedure that is published (or wrapped) in a PL/SQL procedure. Statement DML handlers cannot call a Java stored procedure.</p>
</li>
<li>
<p>If an apply process tries to invoke an apply handler that does not exist or is invalid, then the apply process aborts.</p>
</li>
<li>
<p>If an apply handler that uses a PL/SQL procedure invokes a procedure or function in an Oracle-supplied package, then the user who runs the apply handler must have direct <code>EXECUTE</code> privilege on the package. It is not sufficient to grant this privilege through a role. The <code>DBMS_STREAMS_AUTH.GRANT_ADMIN_PRIVILEGE</code> procedure grants <code>EXECUTE</code> privilege on all Oracle Streams packages, and other privileges relevant to Oracle Streams. A statement DML handler cannot invoke a procedure or function.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS307" href="../../appdev.112/e40758/t_lcr.htm#ARPLS307"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>EXECUTE</code> member procedure for LCR types</p>
</li>
<li>
<p><a class="olink STREP008" href="../../server.112/e10705/rep_tags.htm#STREP008"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for more information about Oracle Streams tags</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BABJDGEG"></a>
<div id="STRMS384" class="sect3">
<h4 class="sect3">Summary of Message Processing Options</h4>
<p>The table in this section summarizes the message processing options available when you are using one or more of the <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a>s described in the previous sections. Apply handlers are optional for row LCRs and DDL LCRs because an apply process can apply these messages directly. However, a message handler is required for processing persistent user messages. In addition, an apply process dequeues a message only if the message satisfies the <a href="strms_glossary.htm#CHDCHGGB"><span class="xrefglossterm">rule set</span></a>s for the apply process. In general, a message satisfies the rule sets for an apply process if <span class="italic">no rules</span> in the <a href="strms_glossary.htm#CHDBHJHI"><span class="xrefglossterm">negative rule set</span></a> evaluate to <code>TRUE</code> for the message, and <span class="italic">at least one rule</span> in the <a href="strms_glossary.htm#CHDEEDIJ"><span class="xrefglossterm">positive rule set</span></a> evaluates to <code>TRUE</code> for the message.</p>
<p><a href="#g1013185">Table 4-3</a> summarizes the message processing options for an apply process.</p>
<div id="STRMS385" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref228"></a><a id="g1013185"></a>Table 4-3 Summary of Message Processing Options</p>
<table class="cellalignment1634" title="Summary of Message Processing Options" summary="This table lists apply handlers. For each apply handler, this table lists the type of messages processed by the handler, the mechanism for processing the messages, the default apply process behavior for the message, and the scope of the handler." dir="ltr">
<thead>
<tr class="cellalignment1625">
<th class="cellalignment1635" id="r1c1-t28">Message Processing Option</th>
<th class="cellalignment1635" id="r1c2-t28">Mechanism</th>
<th class="cellalignment1635" id="r1c3-t28">Type of Message</th>
<th class="cellalignment1635" id="r1c4-t28">Message Creator</th>
<th class="cellalignment1635" id="r1c5-t28">Default Apply Process Behavior</th>
<th class="cellalignment1635" id="r1c6-t28">Scope of Handler</th>
<th class="cellalignment1635" id="r1c7-t28">Number Allowed for Each Apply Process</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r2c1-t28" headers="r1c1-t28">
<p>Apply Message Directly</p>
</td>
<td class="cellalignment1631" headers="r2c1-t28 r1c2-t28">
<p>Not applicable</p>
</td>
<td class="cellalignment1631" headers="r2c1-t28 r1c3-t28">
<p>Row LCR or DDL LCR</p>
</td>
<td class="cellalignment1631" headers="r2c1-t28 r1c4-t28">
<p>Capture process, synchronous capture, or application</p>
</td>
<td class="cellalignment1631" headers="r2c1-t28 r1c5-t28">
<p>Execute DML or DDL</p>
</td>
<td class="cellalignment1631" headers="r2c1-t28 r1c6-t28">
<p>Not applicable</p>
</td>
<td class="cellalignment1631" headers="r2c1-t28 r1c7-t28">
<p>Not applicable</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r3c1-t28" headers="r1c1-t28">
<p>Statement DML Handler</p>
</td>
<td class="cellalignment1631" headers="r3c1-t28 r1c2-t28">
<p>SQL statements</p>
</td>
<td class="cellalignment1631" headers="r3c1-t28 r1c3-t28">
<p>Row LCR</p>
</td>
<td class="cellalignment1631" headers="r3c1-t28 r1c4-t28">
<p>Capture process, synchronous capture, or application</p>
</td>
<td class="cellalignment1631" headers="r3c1-t28 r1c5-t28">
<p>Execute DML</p>
</td>
<td class="cellalignment1631" headers="r3c1-t28 r1c6-t28">
<p>One operation on one table</p>
</td>
<td class="cellalignment1631" headers="r3c1-t28 r1c7-t28">
<p>Many, and many can be specified for the same operation on the same table</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r4c1-t28" headers="r1c1-t28">
<p>Procedure DML Handler or Error Handler</p>
</td>
<td class="cellalignment1631" headers="r4c1-t28 r1c2-t28">
<p>User-defined PL/SQL procedure</p>
</td>
<td class="cellalignment1631" headers="r4c1-t28 r1c3-t28">
<p>Row LCR</p>
</td>
<td class="cellalignment1631" headers="r4c1-t28 r1c4-t28">
<p>Capture process, synchronous capture, or application</p>
</td>
<td class="cellalignment1631" headers="r4c1-t28 r1c5-t28">
<p>Execute DML</p>
</td>
<td class="cellalignment1631" headers="r4c1-t28 r1c6-t28">
<p>One operation on one table</p>
</td>
<td class="cellalignment1631" headers="r4c1-t28 r1c7-t28">
<p>Many, but only one can be specified for the same operation on the same table</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r5c1-t28" headers="r1c1-t28">
<p>DDL Handler</p>
</td>
<td class="cellalignment1631" headers="r5c1-t28 r1c2-t28">
<p>User-defined PL/SQL procedure</p>
</td>
<td class="cellalignment1631" headers="r5c1-t28 r1c3-t28">
<p>DDL LCR</p>
</td>
<td class="cellalignment1631" headers="r5c1-t28 r1c4-t28">
<p>Capture process or application</p>
</td>
<td class="cellalignment1631" headers="r5c1-t28 r1c5-t28">
<p>Execute DDL</p>
</td>
<td class="cellalignment1631" headers="r5c1-t28 r1c6-t28">
<p>Entire apply process</p>
</td>
<td class="cellalignment1631" headers="r5c1-t28 r1c7-t28">
<p>One</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r6c1-t28" headers="r1c1-t28">
<p>Message Handler</p>
</td>
<td class="cellalignment1631" headers="r6c1-t28 r1c2-t28">
<p>User-defined PL/SQL procedure</p>
</td>
<td class="cellalignment1631" headers="r6c1-t28 r1c3-t28">
<p>Persistent user message</p>
</td>
<td class="cellalignment1631" headers="r6c1-t28 r1c4-t28">
<p>Application</p>
</td>
<td class="cellalignment1631" headers="r6c1-t28 r1c5-t28">
<p>Create error transaction (if no message handler exists)</p>
</td>
<td class="cellalignment1631" headers="r6c1-t28 r1c6-t28">
<p>Entire apply process</p>
</td>
<td class="cellalignment1631" headers="r6c1-t28 r1c7-t28">
<p>One</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r7c1-t28" headers="r1c1-t28">
<p>Precommit Handler</p>
</td>
<td class="cellalignment1631" headers="r7c1-t28 r1c2-t28">
<p>User-defined PL/SQL procedure</p>
</td>
<td class="cellalignment1631" headers="r7c1-t28 r1c3-t28">
<p>Commit directive for transactions that include row LCRs or user messages</p>
</td>
<td class="cellalignment1631" headers="r7c1-t28 r1c4-t28">
<p>Capture process, synchronous capture, or application</p>
</td>
<td class="cellalignment1631" headers="r7c1-t28 r1c5-t28">
<p>Commit transaction</p>
</td>
<td class="cellalignment1631" headers="r7c1-t28 r1c6-t28">
<p>Entire apply process</p>
</td>
<td class="cellalignment1631" headers="r7c1-t28 r1c7-t28">
<p>One</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>In addition to the message processing options described in this section, you can use the <code>SET_ENQUEUE_DESTINATION</code> procedure in the <code>DBMS_APPLY_ADM</code> package to instruct an apply process to enqueue messages into the <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> portion of a specified destination queue. Also, you can control message execution using the <code>SET_EXECUTE</code> procedure in the <code>DBMS_APPLY_ADM</code> package.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_rules.htm#g1049257">Chapter 5, "How Rules Are Used in Oracle Streams"</a></p>
</li>
<li>
<p><a href="strms_mapply.htm#i1008466">"Specifying That Apply Processes Enqueue Messages"</a></p>
</li>
<li>
<p><a href="strms_mapply.htm#i1008467">"Specifying Execute Directives for Apply Processes"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABGCACJ"></a>
<div id="STRMS386" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">The Source of Messages Applied by an Apply Process</h3>
<p>The following list describes the <a href="strms_glossary.htm#CHDHFBJG"><span class="xrefglossterm">source database</span></a> for different types of messages that are processed by an apply process:</p>
<ul>
<li>
<p>For a <a href="strms_glossary.htm#CHDCHEJI"><span class="xrefglossterm">captured LCR</span></a>, the source database is the database where the change encapsulated in the <a href="strms_glossary.htm#CHDJDFAD"><span class="xrefglossterm">LCR</span></a> was generated in the redo log.</p>
</li>
<li>
<p>For a <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a> captured by a synchronous capture, the source database is the database where the synchronous capture that captured the row LCR is configured.</p>
</li>
<li>
<p>For a persistent LCR constructed and enqueued by an application, the source database is the database where the message was first enqueued.</p>
</li>
<li>
<p>For a <a href="strms_glossary.htm#CHDDIHEC"><span class="xrefglossterm">user message</span></a>, the source database is the database where the message was first enqueued.</p>
</li>
</ul>
<p>A single apply process can apply user messages that originated at multiple databases. However, a single apply process can apply captured LCRs from only one source database. Similarly, a single apply process can apply persistent LCRs captured by a synchronous capture from only one source database. Applying these LCRs requires knowledge of the dependencies, meaningful transaction ordering, and transactional boundaries at the source database.</p>
<p>Captured LCRs from multiple databases can be sent to a single <a href="strms_glossary.htm#CHDHJHJD"><span class="xrefglossterm">destination queue</span></a>. The same is true for persistent LCRs captured by a synchronous capture. However, if a single queue contains these LCRs from multiple source databases, then there must be multiple apply processes retrieving these LCRs. Each of these apply processes should be configured to receive messages from exactly one source database using <a href="strms_glossary.htm#CHDIFFCF"><span class="xrefglossterm">rule</span></a>s. Oracle recommends that you use a separate <code>ANYDATA</code> queue for messages from each source database.</p>
<p>Also, each apply process can apply captured LCRs from only one capture process. If multiple capture processes are running on a source database, and LCRs from more than one of these capture processes are applied at a destination database, then there must be one apply process to apply changes from each capture process. In such an environment, Oracle recommends that each <code>ANYDATA</code> queue used by a capture process, propagation, or apply process have captured LCRs from at most one capture process from a particular source database. A queue can contain LCRs from more than one capture process if each capture process is capturing changes that originated at a different source database.</p>
<p>The same restriction applies to persistent LCRs captured by multiple synchronous captures at the same source database. Store these LCRs in separate <code>ANYDATA</code> queues, and use a separate apply process to apply the LCRs from each synchronous capture.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Captured LCRs are in the <a href="strms_glossary.htm#CHDFJFED"><span class="xrefglossterm">buffered queue</span></a> portion of a queue while persistent LCRs are in the <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> portion of a <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a>. Therefore, a single apply process cannot apply both captured LCRs and persistent LCRs.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BGBCDIDA">"Types of Messages That Can Be Processed with an Apply Process"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006373"></a>
<div id="STRMS117" class="sect2">
<h3 class="sect2">Data Types Applied<a id="sthref229"></a><a id="sthref230"></a></h3>
<p>When applying row LCRs resulting from DML changes to tables, an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> applies changes made to columns of the following data types:</p>
<ul>
<li>
<p><code>VARCHAR2</code></p>
</li>
<li>
<p><code>NVARCHAR2</code></p>
</li>
<li>
<p><code>NUMBER</code></p>
</li>
<li>
<p><code>FLOAT</code></p>
</li>
<li>
<p><code>LONG</code></p>
</li>
<li>
<p><code>DATE</code></p>
</li>
<li>
<p><code>BINARY_FLOAT</code></p>
</li>
<li>
<p><code>BINARY_DOUBLE</code></p>
</li>
<li>
<p><code>TIMESTAMP</code></p>
</li>
<li>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code></p>
</li>
<li>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code></p>
</li>
<li>
<p><code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code></p>
</li>
<li>
<p><code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code></p>
</li>
<li>
<p><code>RAW</code></p>
</li>
<li>
<p><code>LONG</code> <code>RAW</code></p>
</li>
<li>
<p><code>CHAR</code></p>
</li>
<li>
<p><code>NCHAR</code></p>
</li>
<li>
<p><code>CLOB</code> with <code>BASICFILE</code> or <code>SECUREFILE</code> storage</p>
</li>
<li>
<p><code>NCLOB</code> with <code>BASICFILE</code> or <code>SECUREFILE</code> storage</p>
</li>
<li>
<p><code>BLOB</code> with <code>BASICFILE</code> or <code>SECUREFILE</code> storage</p>
</li>
<li>
<p><code>UROWID</code></p>
</li>
<li>
<p><code>XMLType</code> stored as <code>CLOB</code>, object relationally, or as binary XML</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Streams capture processes can only capture changes to <code>XMLType</code> columns that are stored as <code>CLOB</code>s. However, apply processes can apply these captured LCRs to <code>XMLType</code> columns that are stored as <code>CLOB</code>s, object relationally, or as binary XML.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_otmon.htm#CFFGFIJD">"Listing Database Objects and Columns Not Compatible with Apply Processes"</a></p>
</li>
<li>
<p><a href="ap_restrictions.htm#BABCDHED">"Unsupported Data Types for Apply Processes"</a></p>
</li>
<li>
<p><a href="strms_rules.htm#g1049257">Chapter 5, "How Rules Are Used in Oracle Streams"</a></p>
</li>
<li>
<p><a href="strms_capture.htm#i1006263">"Data Types Captured by Capture Processes"</a></p>
</li>
<li>
<p><a class="olink SQLRF002" href="../../server.112/e41084/sql_elements.htm#SQLRF002"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about these data types</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="BABICJGE"></a>
<div id="STRMS181" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Automatic Data Type Conversion During Apply<a id="sthref231"></a><a id="sthref232"></a><a id="sthref233"></a></h3>
<p>During apply, an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> automatically converts certain data types when there is a mismatch between the data type of a column in the row logical change record (row LCR) and the data type of the corresponding column in a table.</p>
<p><a href="#BABFHJBG">Table 4-4</a> shows which data type combinations are converted automatically during apply.</p>
<div id="STRMS387" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref234"></a><a id="BABFHJBG"></a>Table 4-4 Data Type Combinations Converted Automatically During Apply</p>
<table class="cellalignment1634" title="Data Type Combinations Converted Automatically During Apply" summary="This table shows each data type combination and specifies whether the data type is converted automatically during apply." dir="ltr">
<thead>
<tr class="cellalignment1625">
<th class="cellalignment1635" id="r1c1-t34"><span class="bold">Data Types</span></th>
<th class="cellalignment1635" id="r1c2-t34"><span class="bold">To</span> <code><span class="codeinlinebold">CHAR</span></code></th>
<th class="cellalignment1635" id="r1c3-t34"><span class="bold">To</span> <code><span class="codeinlinebold">NCHAR</span></code></th>
<th class="cellalignment1635" id="r1c4-t34"><span class="bold">To</span> <code><span class="codeinlinebold">VARCHAR2</span></code></th>
<th class="cellalignment1635" id="r1c5-t34"><span class="bold">To</span> <code><span class="codeinlinebold">NVARCHAR2</span></code></th>
<th class="cellalignment1635" id="r1c6-t34"><span class="bold">To</span> <code><span class="codeinlinebold">CLOB</span></code></th>
<th class="cellalignment1635" id="r1c7-t34"><span class="bold">To</span> <code><span class="codeinlinebold">BLOB</span></code></th>
<th class="cellalignment1635" id="r1c8-t34"><span class="bold">To</span> <code><span class="codeinlinebold">DATE</span></code></th>
<th class="cellalignment1635" id="r1c9-t34"><span class="bold">To</span> <code><span class="codeinlinebold">TIMESTAMP</span></code></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r2c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">CHAR</span></code></p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c2-t34">
<p>Not Applicable</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c3-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c4-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c5-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c6-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c8-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r2c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r3c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">NCHAR</span></code></p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c2-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c3-t34">
<p>Not Applicable</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c4-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c5-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c6-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c8-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r3c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r4c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">VARCHAR2</span></code></p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c2-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c3-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c4-t34">
<p>Not Applicable</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c5-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c6-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c8-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r4c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r5c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">NVARCHAR2</span></code></p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c2-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c3-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c4-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c5-t34">
<p>Not Applicable</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c6-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c8-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r5c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r6c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">NUMBER</span></code></p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c2-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c3-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c4-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c5-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c6-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c8-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r6c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r7c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">LONG</span></code></p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c2-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c3-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c4-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c5-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c6-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c8-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r7c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r8c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">LONG</span></code> <code><span class="codeinlinebold">RAW</span></code></p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c2-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c3-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c4-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c5-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c6-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c7-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c8-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r8c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r9c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">RAW</span></code></p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c2-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c3-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c4-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c5-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c6-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c7-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c8-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r9c1-t34 r1c9-t34">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r10c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">DATE</span></code></p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c2-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c3-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c4-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c5-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c6-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c8-t34">
<p>Not Applicable</p>
</td>
<td class="cellalignment1631" headers="r10c1-t34 r1c9-t34">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1625">
<td class="cellalignment1631" id="r11c1-t34" headers="r1c1-t34">
<p><span class="bold">From</span> <code><span class="codeinlinebold">TIMESTAMP</span></code></p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c2-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c3-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c4-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c5-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c6-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c7-t34">
<p>No</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c8-t34">
<p>Yes</p>
</td>
<td class="cellalignment1631" headers="r11c1-t34 r1c9-t34">
<p>Not Applicable</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" -->
<p>An apply process automatically performs data type conversion for a data type combination when <a href="#BABFHJBG">Table 4-4</a> specifies "Yes" for the combination. An apply process does not perform data type conversion for a data type combination when <a href="#BABFHJBG">Table 4-4</a> specifies "No" for the combination. For example, an apply process automatically converts a <code>CHAR</code> to an <code>NCHAR</code>, but it does not convert a <code>CHAR</code> to a <code>BLOB</code>.</p>
<p>Also, if the corresponding table column is not large enough to hold the converted string from a row LCR column, then the apply process raises an error.</p>
<p>The following sections provide more information about automatic data type conversion during apply:</p>
<ul>
<li>
<p><a href="#BABIBDFB">Automatic Trimming of Character Data Types During Apply</a></p>
</li>
<li>
<p><a href="#BABGGFBH">Automatic Conversion and LOB Data Types</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
An apply process must be part of Oracle Database 11<span class="italic">g</span> Release 1 (11.1.0.7) or later to perform automatic data type conversion. However, an apply process can convert columns in row LCRs that were captured or constructed on an earlier Oracle Database release.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF0021" href="../../server.112/e41084/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about data types</div>
<a id="BABIBDFB"></a>
<div id="STRMS388" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Automatic Trimming of Character Data Types During Apply</h4>
<p>The <code>rtrim_on_implicit_conversion</code> apply process parameter determines whether the apply process trims data when it converts a <code>CHAR</code> or <code>NCHAR</code> to a <code>VARCHAR2</code>, <code>NVARCHAR2</code>, or <code>CLOB</code>. When this parameter is set to <code>Y</code>, the apply process automatically removes blank padding from the right end of a column during data type conversion. When this parameter is set to <code>N</code>, the apply process preserves blank padding during data type conversion.</p>
<p>Consider the following example:</p>
<ul>
<li>
<p>A row LCR contains <code>'abc'</code> for a <code>CHAR(10)</code> column.</p>
</li>
<li>
<p>The corresponding table column for the row LCR is <code>NVARCHAR2(10)</code>.</p>
</li>
</ul>
<p>If the <code>rtrim_on_implicit_conversion</code> apply process parameter is set to <code>Y</code>, the apply process inserts <code>'abc'</code> into the table column and trims the padding after these characters. If the <code>rtrim_on_implicit_conversion</code> apply process parameter is set to <code>N</code>, then the apply process inserts <code>'abc'</code> into the table column, and the remaining space in the column is filled with blanks.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS314" href="../../appdev.112/e40758/d_apply.htm#ARPLS314"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></div>
</div>
<!-- class="sect3" -->
<a id="BABGGFBH"></a>
<div id="STRMS389" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Automatic Conversion and LOB Data Types</h4>
<p>Procedure DML handlers and error handlers can use <a href="strms_glossary.htm#CBAEBDDB"><span class="xrefglossterm">LOB assembly</span></a> for data that has been converted from <code>LONG</code> to <code>CLOB</code> or from <code>LONG</code> <code>RAW</code> to <code>BLOB</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink STREP137" href="../../server.112/e10705/man_lcrs.htm#STREP137"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BCEEHIHH"></a>
<div id="STRMS1092" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">SQL Generation<a id="sthref235"></a><a id="sthref236"></a></h3>
<p>SQL generation is the ability to generate the SQL statement required to perform the change encapsulated in a <a href="strms_glossary.htm#CHDIGGFF"><span class="xrefglossterm">row logical change record (row LCR)</span></a>. Apply processes can generate the SQL statement necessary to perform the insert, update, or delete operation in a row LCR.</p>
<p>This section contains these topics:</p>
<ul>
<li>
<p><a href="#BGBDJJFF">Interfaces for Performing SQL Generation</a></p>
</li>
<li>
<p><a href="#BGBDBAIG">SQL Generation Formats</a></p>
</li>
<li>
<p><a href="#BCEJACHB">SQL Generation and Data Types</a></p>
</li>
<li>
<p><a href="#BCEEIAGI">SQL Generation and Character Sets</a></p>
</li>
<li>
<p><a href="#BGBBDDAD">Sample Generated SQL Statements</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
This section describes using SQL generation with the PL/SQL interface. You can also use SQL generation with XStream interfaces.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#BGBIBIED">"Creating a Procedure DML Handler"</a> for an example of a procedure DML handler that uses SQL generation</p>
</li>
<li>
<p><a class="olink XSTRM72457" href="../../server.112/e16545/xstrm_cncpt.htm#XSTRM72457"><span class="italic">Oracle Database XStream Guide</span></a> for information about using SQL generation with XStream</p>
</li>
</ul>
</div>
<a id="BGBDJJFF"></a>
<div id="STRMS1611" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Interfaces for Performing SQL Generation<a id="sthref237"></a></h4>
<p>You can use the <code>GET_ROW_TEXT</code> and <code>GET_WHERE_CLAUSE</code> member procedures for row LCRs to perform SQL generation. The PL/SQL interface generates SQL in a <code>CLOB</code> data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS368" href="../../appdev.112/e40758/t_lcr.htm#ARPLS368"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a></div>
</div>
<!-- class="sect3" -->
<a id="BGBDBAIG"></a>
<div id="STRMS1612" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL Generation Formats<a id="sthref238"></a></h4>
<p>SQL statement can be generated in one of two formats: inline values or bind variables. Use inline values when the returned SQL statement is relatively small. For larger SQL statements, use bind variables. In this case, the bind variables are passed in a separate list that includes pointers to both old and new column values.</p>
<p>For information about using bind variables with each interface, see the documentation about the <code>GET_ROW_TEXT</code> and <code>GET_WHERE_CLAUSE</code> row LCR member procedures in <a class="olink ARPLS368" href="../../appdev.112/e40758/t_lcr.htm#ARPLS368"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For generated SQL statements with the values inline, SQL injection is possible. SQL injection is a technique for maliciously exploiting applications that use client-supplied data in SQL statements, thereby gaining unauthorized access to a database in order to view or manipulate restricted data. Oracle strongly recommends using bind variables if you plan to execute the generated SQL statement. See <a class="olink LNPLS01109" href="../../appdev.112/e25519/dynamic.htm#LNPLS01109"><span class="italic">Oracle Database PL/SQL Language Reference</span></a> for more information about SQL injection.</div>
</div>
<!-- class="sect3" -->
<a id="BCEJACHB"></a>
<div id="STRMS1418" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL Generation and Data Types<a id="sthref239"></a></h4>
<p>SQL generation supports the following data types:</p>
<ul>
<li>
<p><code>VARCHAR2</code></p>
</li>
<li>
<p><code>NVARCHAR2</code></p>
</li>
<li>
<p><code>NUMBER</code></p>
</li>
<li>
<p><code>FLOAT</code></p>
</li>
<li>
<p><code>DATE</code></p>
</li>
<li>
<p><code>BINARY_FLOAT</code></p>
</li>
<li>
<p><code>BINARY_DOUBLE</code></p>
</li>
<li>
<p><code>LONG</code></p>
</li>
<li>
<p><code>TIMESTAMP</code></p>
</li>
<li>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>TIME</code> <code>ZONE</code></p>
</li>
<li>
<p><code>TIMESTAMP</code> <code>WITH</code> <code>LOCAL</code> <code>TIME</code> <code>ZONE</code></p>
</li>
<li>
<p><code>INTERVAL</code> <code>YEAR</code> <code>TO</code> <code>MONTH</code></p>
</li>
<li>
<p><code>INTERVAL</code> <code>DAY</code> <code>TO</code> <code>SECOND</code></p>
</li>
<li>
<p><code>RAW</code></p>
</li>
<li>
<p><code>LONG</code> <code>RAW</code></p>
</li>
<li>
<p><code>CHAR</code></p>
</li>
<li>
<p><code>NCHAR</code></p>
</li>
<li>
<p><code>CLOB</code> with <code>BASICFILE</code> storage</p>
</li>
<li>
<p><code>NCLOB</code> with <code>BASICFILE</code> storage</p>
</li>
<li>
<p><code>BLOB</code> with <code>BASICFILE</code> storage</p>
</li>
<li>
<p><code>XMLType</code> stored as <code>CLOB</code></p>
</li>
</ul>
<div id="STRMS1613" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref240"></a>
<h5 class="sect4">SQL Generation and Automatic Data Type Conversion</h5>
<p>An <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> performs implicit data type conversion where it is possible, and the generated SQL follows ANSI standards where it is possible. The following are considerations for automatic data type conversions:</p>
<ul>
<li>
<p><code>NULL</code> is specified as <code>"NULL"</code>.</p>
</li>
<li>
<p>Single quotation marks are converted into double quotation marks for the following data types when they are inline values: <code>CHAR</code>, <code>VARCHAR2</code>, <code>NVARCHAR2</code>, <code>NCHAR</code>, <code>CLOB</code>, and <code>NCLOB</code>.</p>
</li>
<li>
<p><code>LONG</code> data is converted into <code>CLOB</code> data.</p>
</li>
<li>
<p><code>LONG</code> <code>RAW</code> data is converted into <code>BLOB</code> data.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="STRMS1614" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref241"></a>
<h5 class="sect4">SQL Generation and LOB, LONG, LONG RAW, and XMLType Data Types</h5>
<p>For <code>INSERT</code> and <code>UPDATE</code> operations on LOB columns, an apply process automatically assembles the LOB chunks using <a href="strms_glossary.htm#CBAEBDDB"><span class="xrefglossterm">LOB assembly</span></a>. For these operations, the generated SQL includes a non-<code>NULL</code> empty value. The actual values of the chunked columns arrive in subsequent LCRs. For each chunk, you must perform the correct SQL operation on the correct column.</p>
<p>Similarly, for <code>LONG</code>, <code>LONG</code> <code>RAW</code>, and <code>XMLType</code> data types, an apply process generates a non-<code>NULL</code> empty value, and the actual values of the column arrive in chunks in subsequent LCRs. For each chunk, you must perform the correct SQL operation on the correct column.</p>
<p>In the inline version of the generated SQL, for LOB, <code>LONG</code>, <code>LONG</code> <code>RAW</code>, and <code>XMLType</code> data type columns, the following SQL is generated for inserts and updates:</p>
<ul>
<li>
<p>For <code>CLOB</code>, <code>NCLOB</code>, and <code>LONG</code> data type columns:</p>
<pre>
EMPTY_CLOB()
</pre></li>
<li>
<p>For <code>BLOB</code> and <code>LONG</code> <code>RAW</code> data type columns:</p>
<pre>
EMPTY_BLOB()
</pre></li>
<li>
<p>For <code>XMLType</code> columns:</p>
<pre>
XMLTYPE.CREATEXML('<span class="italic">xml /</span>')
</pre>
<p>where <code><span class="codeinlineitalic">xml</span></code> <code><span class="codeinlineitalic">/</span></code> is the XML chunk.</p>
</li>
</ul>
<p>After the LCR that contains the DML statement arrives, the data for these changes arrive in separate chunks. You can generate the <code>WHERE</code> clause for such a change and use the generated <code>WHERE</code> clause to identify the row for the modifications contained in the chunks. For example, in PL/SQL you can use the <code>GET_WHERE_CLAUSE</code> row LCR member procedure to generate the <code>WHERE</code> clause for a row change.</p>
<p>For <code>INSERT</code> and <code>UPDATE</code> operations, the generated <code>WHERE</code> clause identifies the row after the insert or update. For example, consider the following update to the <code>hr.departments</code> table:</p>
<pre>
UPDATE hr.departments SET department_name='Management' 
  WHERE department_name='Administration';
</pre>
<p>The generated <code>WHERE</code> clause for this change is the following:</p>
<pre>
WHERE "DEPARTMENT_NAME"='Management'
</pre>
<p>For piecewise LOB operation performed by subprograms in the <code>DBMS_LOB</code> package (including the <code>WRITE</code>, <code>TRIM</code>, and <code>ERASE</code> procedures), the generated SQL includes a <code>SELECT</code> <code>FOR</code> <code>UPDATE</code> statement.</p>
<p>For example, a <code>LOB_WRITE</code> operation on a <code>clob_col</code> results in generated SQL similar to the following:</p>
<pre>
SELECT "CLOB_COL" FROM "HR"."LOB_TAB" WHERE "N1"=2 FOR UPDATE
</pre>
<p>The selected <code>clob_col</code> must be defined. You can use the LOB locator to perform piecewise LOB operations with the LOB chunks that follow the row LCR.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BGBIABCA">"Sample Generated SQL Statements for a Table With LOB Columns"</a></p>
</li>
<li>
<p><a class="olink STREP490" href="../../server.112/e10705/man_lcrs.htm#STREP490"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for information about LOB assembly</p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BCEEIAGI"></a>
<div id="STRMS1422" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">SQL Generation and Character Sets<a id="sthref242"></a></h4>
<p>When you use the LCR methods, the generated SQL is in the database character set. SQL keywords, such as <code>INSERT</code>, <code>UPDATE</code>, and <code>INTO</code>, do not change with the character set.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink NLSPG364" href="../../server.112/e10729/ch7progrunicode.htm#NLSPG364"><span class="italic">Oracle Database Globalization Support Guide</span></a> for information about data conversion in JDBC</p>
</li>
<li>
<p><a class="olink SQLRF51129" href="../../server.112/e41084/sql_elements008.htm#SQLRF51129"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about SQL keywords</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="BGBBDDAD"></a>
<div id="STRMS1615" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Sample Generated SQL Statements<a id="sthref243"></a></h4>
<p>This section provides examples of generated SQL statements:</p>
<ul>
<li>
<p><a href="#BCEFGBII">Sample Generated SQL Statements for the hr.employees Table</a></p>
</li>
<li>
<p><a href="#BGBIABCA">Sample Generated SQL Statements for a Table With LOB Columns</a></p>
</li>
</ul>
<a id="BCEFGBII"></a>
<div id="STRMS1424" class="sect4">
<h5 class="sect4">Sample Generated SQL Statements for the hr.employees Table</h5>
<p>This section provides examples of SQL statements generated by an apply process for changes made to the <code>hr.employees</code> table.</p>
<p>This section includes these examples:</p>
<ul>
<li>
<p><a href="#BCEHEBAE">Example 4-1, "Generated Insert"</a></p>
</li>
<li>
<p><a href="#BCECCHJD">Example 4-2, "Generated Update"</a></p>
</li>
<li>
<p><a href="#BCEIHAFD">Example 4-3, "Generated Delete"</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generated SQL is in a single line and is not formatted.</div>
<div id="STRMS1093" class="example">
<p class="titleinexample"><a id="BCEHEBAE"></a>Example 4-1 Generated Insert</p>
<p>Assume the following insert is executed:</p>
<pre>
INSERT INTO hr.employees (employee_id, 
                           last_name, 
                           email, 
                           hire_date, 
                           job_id, 
                           salary, 
                           commission_pct) 
                   VALUES (207, 
                           'Gregory', 
                           'pgregory@example.com', 
                           SYSDATE, 
                           'PU_CLERK', 
                           9000, 
                           NULL);
</pre>
<p>The following is the generated SQL with inline values:</p>
<pre>
INSERT INTO "HR"."EMPLOYEES"("EMPLOYEE_ID","FIRST_NAME","LAST_NAME",
"EMAIL","PHONE_NUMBER","HIRE_DATE","JOB_ID","SALARY","COMMISSION_PCT",
"MANAGER_ID","DEPARTMENT_ID" ) VALUES ( 207, NULL,'Gregory',
'pgregory@example.com', NULL , TO_DATE(' 2009-04-15','syyyy-mm-dd'),
'PU_CLERK',9000, NULL , NULL , NULL )
</pre>
<p>The following is the generated SQL with bind variables:</p>
<pre>
INSERT INTO "HR"."EMPLOYEES"("EMPLOYEE_ID","FIRST_NAME","LAST_NAME",
"EMAIL","PHONE_NUMBER","HIRE_DATE","JOB_ID","SALARY",
"COMMISSION_PCT","MANAGER_ID","DEPARTMENT_ID" ) VALUES ( :1   ,:2   ,:3   
,:4   ,:5   ,:6   ,:7   ,:8   ,:9   ,:10  ,:11  )
</pre></div>
<!-- class="example" -->
<div id="STRMS1095" class="example">
<p class="titleinexample"><a id="BCECCHJD"></a>Example 4-2 Generated Update</p>
<p>Assume the following update is executed:</p>
<pre>
UPDATE hr.employees SET salary=10000 WHERE employee_id=207;
</pre>
<p>The following is the generated SQL with inline values:</p>
<pre>
UPDATE "HR"."EMPLOYEES" SET "SALARY"=10000 WHERE "EMPLOYEE_ID"=207 
AND "SALARY"=9000
</pre>
<p>The following is the generated SQL with bind variables:</p>
<pre>
UPDATE "HR"."EMPLOYEES" SET "SALARY"=:1    WHERE "EMPLOYEE_ID"=:2    
AND "SALARY"=:3
</pre></div>
<!-- class="example" -->
<div id="STRMS1097" class="example">
<p class="titleinexample"><a id="BCEIHAFD"></a>Example 4-3 Generated Delete</p>
<p>Assume the following delete is executed:</p>
<pre>
DELETE FROM hr.employees WHERE employee_id=207;
</pre>
<p>The following is the generated SQL with inline values:</p>
<pre>
DELETE  FROM "HR"."EMPLOYEES" WHERE "EMPLOYEE_ID"=207 AND "FIRST_NAME" IS NULL 
AND "LAST_NAME"='Gregory' AND "EMAIL"='pgregory@example.com' AND 
"PHONE_NUMBER" IS NULL  AND "HIRE_DATE"= TO_DATE(' 2009-04-15','syyyy-mm-dd') 
AND "JOB_ID"='PU_CLERK' AND "SALARY"=10000 AND "COMMISSION_PCT" IS NULL  
AND "MANAGER_ID" IS NULL  AND "DEPARTMENT_ID" IS NULL 
</pre>
<p>The following is the generated SQL with bind variables:</p>
<pre>
DELETE  FROM "HR"."EMPLOYEES" WHERE "EMPLOYEE_ID"=:1    AND "FIRST_NAME"=:2    
AND "LAST_NAME"=:3    AND "EMAIL"=:4    AND "PHONE_NUMBER"=:5    AND 
"HIRE_DATE"=:6    AND "JOB_ID"=:7    AND "SALARY"=:8    AND 
"COMMISSION_PCT"=:9   AND "MANAGER_ID"=:10   AND "DEPARTMENT_ID"=:11 
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" -->
<a id="BGBIABCA"></a>
<div id="STRMS1616" class="sect4">
<h5 class="sect4">Sample Generated SQL Statements for a Table With LOB Columns</h5>
<p>This section provides examples of SQL statements generated by an apply process for changes made to the following table:</p>
<pre>
CREATE TABLE hr.lob_tab(
   n1        number primary key,
   clob_col  CLOB,
   nclob_col NCLOB,
   blob_col  BLOB);
</pre>
<p>This section includes these examples:</p>
<ul>
<li>
<p><a href="#BGBDJDIF">Example 4-4, "Generated Insert for a Table with LOB Columns"</a></p>
</li>
<li>
<p><a href="#BGBEBFHD">Example 4-5, "Generated Update for a Table with LOB Columns"</a></p>
</li>
<li>
<p><a href="#BGBFIGCD">Example 4-6, "Generated Delete for a Table with LOB Columns"</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generated SQL is in a single line and is not formatted.</div>
<div id="STRMS1617" class="example">
<p class="titleinexample"><a id="BGBDJDIF"></a>Example 4-4 Generated Insert for a Table with LOB Columns</p>
<p>Assume the following insert is executed:</p>
<pre>
INSERT INTO hr.lob_tab VALUES (2, 'test insert', NULL, NULL);
</pre>
<p>The following is the generated SQL with inline values:</p>
<pre>
INSERT INTO "HR"."LOB_TAB"("N1","BLOB_COL","CLOB_COL","NCLOB_COL" ) 
VALUES ( 2,, EMPTY_CLOB() ,)
</pre>
<p>The following is the generated SQL with bind variables:</p>
<pre>
INSERT INTO "HR"."LOB_TAB"("N1","BLOB_COL","CLOB_COL","NCLOB_COL" ) 
VALUES ( :1   ,:2   ,:3   ,:4   )
</pre></div>
<!-- class="example" -->
<p>The <code>GET_WHERE_CLAUSE</code> member procedure generates the following <code>WHERE</code> clause for this insert:</p>
<ul>
<li>
<p>Inline:</p>
<pre>
WHERE "N1"=2
</pre></li>
<li>
<p>Bind variables:</p>
<pre>
WHERE "N1"=:1
</pre></li>
</ul>
<p>You can use the <code>WHERE</code> clause to identify the row that was inserted when the subsequent chunks arrive for the LOB column change.</p>
<div id="STRMS1618" class="example">
<p class="titleinexample"><a id="BGBEBFHD"></a>Example 4-5 Generated Update for a Table with LOB Columns</p>
<p>Assume the following update is executed:</p>
<pre>
UPDATE hr.lob_tab SET clob_col='test update' WHERE n1=2;
</pre>
<p>The following is the generated SQL with inline values:</p>
<pre>
UPDATE "HR"."LOB_TAB" SET "CLOB_COL"= EMPTY_CLOB()  WHERE "N1"=2
</pre>
<p>The following is the generated SQL with bind variables:</p>
<pre>
UPDATE "HR"."LOB_TAB" SET "CLOB_COL"=:1    WHERE "N1"=:2
</pre></div>
<!-- class="example" -->
<div id="STRMS1619" class="example">
<p class="titleinexample"><a id="BGBFIGCD"></a>Example 4-6 Generated Delete for a Table with LOB Columns</p>
<p>Assume the following delete is executed:</p>
<pre>
DELETE FROM hr.lob_tab WHERE n1=2;
</pre>
<p>The following is the generated SQL with inline values:</p>
<pre>
DELETE  FROM "HR"."LOB_TAB" WHERE "N1"=2
</pre>
<p>The following is the generated SQL with bind variables:</p>
<pre>
DELETE  FROM "HR"."LOB_TAB" WHERE "N1"=:1
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006983"></a>
<div id="STRMS390" class="sect2">
<h3 class="sect2">Oracle Streams Apply Processes and RESTRICTED SESSION<a id="sthref244"></a><a id="sthref245"></a></h3>
<p>When restricted session is enabled during system startup by issuing a <code>STARTUP</code> <code>RESTRICT</code> statement, <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a>es do not start, even if they were running when the database shut down. When the restricted session is disabled, each apply process that was not stopped is started.</p>
<p>When restricted session is enabled in a running database by the SQL statement <code>ALTER</code> <code>SYSTEM</code> <code>ENABLE</code> <code>RESTRICTED</code> <code>SESSION</code>, it does not affect any running apply processes. These apply processes continue to run and apply messages. If a stopped apply process is started in a restricted session, then the apply process does not actually start until the restricted session is disabled.</p>
</div>
<!-- class="sect2" -->
<a id="i1007083"></a>
<div id="STRMS146" class="sect2">
<h3 class="sect2">Apply Process Subcomponents<a id="sthref246"></a><a id="sthref247"></a><a id="sthref248"></a><a id="sthref249"></a></h3>
<p>An <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> consists of the following subcomponents:</p>
<ul>
<li>
<p>A <span class="bold">reader server</span> that dequeues <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>s. The reader server is a process that computes dependencies between logical change records (LCRs) and assembles messages into transactions. The reader server then returns the assembled transactions to the coordinator process.</p>
</li>
<li>
<p>A <span class="bold">coordinator process</span> that gets transactions from the reader server and passes them to apply servers. The coordinator process name is <code>AP</code><code><span class="codeinlineitalic">nn</span></code>, where <code><span class="codeinlineitalic">nn</span></code> can include letters and numbers. The coordinator process is an Oracle background process.</p>
</li>
<li>
<p>One or more <span class="bold">apply servers</span> that apply LCRs to database objects as DML or DDL statements or that pass the LCRs to their appropriate <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a>s. For non-LCR messages, the apply servers pass the messages to the <a href="strms_glossary.htm#CHDDHDEH"><span class="xrefglossterm">message handler</span></a>. Apply servers can also enqueue LCR and non-LCR messages into the <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> portion of a <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a> specified by the <code>DBMS_APPLY_ADM.SET_ENQUEUE_DESTINATION</code> procedure. Each apply server is a process. If an apply server encounters an error, then it then tries to resolve the error with a user-specified <a href="strms_glossary.htm#CHDDGDDG"><span class="xrefglossterm">conflict</span></a> handler or error handler. If an apply server cannot resolve an error, then it rolls back the transaction and places the entire transaction, including all of its messages, in the error queue.</p>
<p>When an apply server commits a completed transaction, this transaction has been applied. When an apply server places a transaction in the error queue and commits, this transaction also has been applied.</p>
</li>
</ul>
<p>The reader server and the apply server process names are <code>AS</code><code><span class="codeinlineitalic">nn</span></code>, where <code><span class="codeinlineitalic">nn</span></code> can include letters and numbers. If a transaction being handled by an apply server has a dependency on another transaction that is not known to have been applied, then the apply server contacts the coordinator process and waits for instructions. The coordinator process monitors all of the apply servers to ensure that transactions are applied and committed in the correct order.</p>
<p>The following sections describe the possible states for each apply process subcomponent:</p>
<ul>
<li>
<p><a href="#i1009432">Reader Server States</a></p>
</li>
<li>
<p><a href="#i1009431">Coordinator Process States</a></p>
</li>
<li>
<p><a href="#i1009430">Apply Server States</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_adapply.htm#BABDFDBI">"Apply Processes and Dependencies"</a></p>
</li>
</ul>
</div>
<a id="i1009432"></a>
<div id="STRMS391" class="sect3">
<h4 class="sect3">Reader Server States<a id="sthref250"></a><a id="sthref251"></a></h4>
<p>The state of a reader server describes what the reader server is doing currently. You can view the state of the reader server for an apply process by querying the <code>V$STREAMS_APPLY_READER</code> dynamic performance view. The following reader server states are possible:</p>
<ul>
<li>
<p><code>INITIALIZING</code> - Starting up</p>
</li>
<li>
<p><code>IDLE</code> - Performing no work</p>
</li>
<li>
<p><code>DEQUEUE</code> <code>MESSAGES</code> - Dequeuing messages from the apply process's queue</p>
</li>
<li>
<p><code>SCHEDULE</code> <code>MESSAGES</code> - Computing dependencies between messages and assembling messages into transactions</p>
</li>
<li>
<p><code>SPILLING</code> - Spilling unapplied messages from memory to hard disk</p>
</li>
<li>
<p><code>PAUSED</code> <code>-</code> <code>WAITING</code> <code>FOR</code> <code>DDL</code> <code>TO</code> <code>COMPLETE</code> - Paused while waiting for a DDL LCR to be applied</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_apmon.htm#i1007562">"Displaying Information About the Reader Server for Each Apply Process"</a> for a query that displays the state of an apply process reader server</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1009431"></a>
<div id="STRMS392" class="sect3">
<h4 class="sect3">Coordinator Process States<a id="sthref252"></a><a id="sthref253"></a></h4>
<p>The state of a coordinator process describes what the coordinator process is doing currently. You can view the state of a coordinator process by querying the <code>V$STREAMS_APPLY_COORDINATOR</code> dynamic performance view. The following coordinator process states are possible:</p>
<ul>
<li>
<p><code>INITIALIZING</code> - Starting up</p>
</li>
<li>
<p><code>IDLE</code> - Performing no work</p>
</li>
<li>
<p><code>APPLYING</code> - Passing transactions to apply servers</p>
</li>
<li>
<p><code>SHUTTING</code> <code>DOWN</code> <code>CLEANLY</code> - Stopping without an error</p>
</li>
<li>
<p><code>ABORTING</code> - Stopping because of an apply error</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_apmon.htm#i1007622">"Displaying General Information About Each Coordinator Process"</a> for a query that displays the state of a coordinator process</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1009430"></a>
<div id="STRMS393" class="sect3">
<h4 class="sect3">Apply Server States<a id="sthref254"></a><a id="sthref255"></a></h4>
<p>The state of an apply server describes what the apply server is doing currently. You can view the state of each apply server for an apply process by querying the <code>V$STREAMS_APPLY_SERVER</code> dynamic performance view. The following apply server states are possible:</p>
<ul>
<li>
<p><code>INITIALIZING</code> - Starting up.</p>
</li>
<li>
<p><code>IDLE</code> - Performing no work.</p>
</li>
<li>
<p><code>RECORD</code> <code>LOW-WATERMARK</code> - Performing an administrative action that maintains information about the apply progress, which is used in the <code>ALL_APPLY_PROGRESS</code> and <code>DBA_APPLY_PROGRESS</code> data dictionary views.</p>
</li>
<li>
<p><code>ADD</code> <code>PARTITION</code> - Performing an administrative action that adds a partition that is used for recording information about in-progress transactions.</p>
</li>
<li>
<p><code>DROP</code> <code>PARTITION</code> - Performing an administrative action that drops a partition that was used to record information about in-progress transactions.</p>
</li>
<li>
<p><code>EXECUTE</code> <code>TRANSACTION</code> - Applying a transaction.</p>
</li>
<li>
<p><code>WAIT</code> <code>COMMIT</code> - Waiting to commit a transaction until all other transactions with a lower commit SCN are applied. This state is possible only if the <code>commit_serialization</code> apply process parameter is set to a value other than <code>DEPENDENT_TRANSACTIONS</code> and the <code>parallelism</code> apply process parameter is set to a value greater than <code>1</code>.</p>
</li>
<li>
<p><code>WAIT</code> <code>DEPENDENCY</code> - Waiting to apply an LCR in a transaction until another transaction, on which it has a dependency, is applied. This state is possible only if the <code>PARALLELISM</code> apply process parameter is set to a value greater than <code>1</code>.</p>
</li>
<li>
<p><code>WAIT</code> <code>FOR</code> <code>CLIENT</code> - Waiting for an XStream In client application to request more logical change records (LCRs).</p>
</li>
<li>
<p><code>WAIT</code> <code>FOR</code> <code>NEXT</code> <code>CHUNK</code> - Waiting for the next set of LCRs for a large transaction.</p>
</li>
<li>
<p><code>ROLLBACK</code> <code>TRANSACTION</code> - Rolling back a transaction.</p>
</li>
<li>
<p><code>TRANSACTION</code> <code>CLEANUP</code> - Cleaning up an applied transaction, which includes removing LCRs from the apply process's queue.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_apmon.htm#i1007717">"Displaying Information About the Apply Servers for Each Apply Process"</a> for a query that displays the state of each apply process apply server</p>
</li>
<li>
<p><a class="olink ARPLS314" href="../../appdev.112/e40758/d_apply.htm#ARPLS314"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about apply process parameters</p>
</li>
<li>
<p><a class="olink XSTRM" href="../e16545/toc.htm"><span class="italic">Oracle Database XStream Guide</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABEAJFC"></a>
<div id="STRMS394" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Apply User</h3>
<p>An apply process applies messages in the security domain of its <a href="strms_glossary.htm#CHDGCCIF"><span class="xrefglossterm">apply user</span></a>. The apply user dequeues all messages that satisfy the apply process <a href="strms_glossary.htm#CHDCHGGB"><span class="xrefglossterm">rule set</span></a>s. The apply user can apply messages directly to database objects. In addition, the apply user runs all <a href="strms_glossary.htm#CHDDGIFE"><span class="xrefglossterm">custom rule-based transformation</span></a>s specified by the rules in these rule sets. The apply user also runs user-defined <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a>s.</p>
<p>The apply user must have the necessary privileges to apply changes, including the following privileges:</p>
<ul>
<li>
<p><code>EXECUTE</code> privilege on the rule sets used by the apply process</p>
</li>
<li>
<p><code>EXECUTE</code> privilege on all custom rule-based transformation functions specified for rules in the <a href="strms_glossary.htm#CHDEEDIJ"><span class="xrefglossterm">positive rule set</span></a></p>
</li>
<li>
<p><code>EXECUTE</code> privilege on any apply handlers</p>
</li>
<li>
<p>Privileges to dequeue messages from the apply process's queue</p>
</li>
</ul>
<p>An apply process can be associated with only one user, but one user can be associated with many apply processes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink STREP200" href="../../server.112/e10705/prep_rep.htm#STREP200"><span class="italic">Oracle Streams Replication Administrator's Guide</span></a> for information about the required privileges</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007170"></a>
<div id="STRMS131" class="sect2">
<h3 class="sect2">Apply Process Parameters<a id="sthref256"></a></h3>
<p>After creation, an <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> is disabled so that you can set the apply process parameters for your environment before starting the process for the first time. Apply process parameters control the way an apply process operates. For example, the parallelism apply process parameter specifies the number of <a href="strms_glossary.htm#CHDDCEJB"><span class="xrefglossterm">apply servers</span></a> that can concurrently apply transactions, and the <code>time_limit</code> apply process parameter specifies the amount of time an apply process runs before it is shut down automatically. After you set the apply process parameters, you can start the apply process.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#i1006527">"Setting an Apply Process Parameter"</a></p>
</li>
<li>
<p><a class="olink ARPLS314" href="../../appdev.112/e40758/d_apply.htm#ARPLS314"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for detailed information about all of the apply process parameters</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007252"></a>
<div id="STRMS395" class="sect2">
<h3 class="sect2">Persistent Apply Process Status Upon Database Restart<a id="sthref257"></a></h3>
<p>An <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a> maintains a persistent status when the database running the apply process is shut down and restarted. For example, if an apply process is enabled when the database is shut down, then the apply process automatically starts when the database is restarted. Similarly, if an apply process is disabled or aborted when a database is shut down, then the apply process is not started and retains the disabled or aborted status when the database is restarted.</p>
</div>
<!-- class="sect2" -->
<a id="i1008918"></a>
<div id="STRMS156" class="sect2">
<h3 class="sect2">The Error Queue<a id="sthref258"></a><a id="sthref259"></a><a id="sthref260"></a><a id="sthref261"></a></h3>
<p>The error queue contains all of the current apply errors for a database. If there are multiple <a href="strms_glossary.htm#CHDJBHJC"><span class="xrefglossterm">apply process</span></a>es in a database, then the error queue contains the apply errors for each apply process. To view information about apply errors, query the <code>DBA_APPLY_ERROR</code> data dictionary view or use Enterprise Manager.</p>
<p>The error queue stores information about transactions that could not be applied successfully by the apply processes running in a database. A transaction can include many <a href="strms_glossary.htm#CHDFHHGJ"><span class="xrefglossterm">message</span></a>s. When an unhandled error occurs during apply, an apply process automatically moves all of the messages in the transaction that satisfy the apply process <a href="strms_glossary.htm#CHDCHGGB"><span class="xrefglossterm">rule set</span></a>s to the error queue.</p>
<p>You can correct the condition that caused an error and then reexecute the transaction that caused the error. For example, you might modify a row in a table to correct the condition that caused an error.</p>
<p>When the condition that caused the error has been corrected, you can either reexecute the transaction in the error queue using the <code>EXECUTE_ERROR</code> or <code>EXECUTE_ALL_ERRORS</code> procedure, or you can delete the transaction from the error queue using the <code>DELETE_ERROR</code> or <code>DELETE_ALL_ERRORS</code> procedure. These procedures are in the <code>DBMS_APPLY_ADM</code> package.</p>
<p>When you reexecute a transaction in the error queue, you can specify that the transaction be executed either by the user who originally placed the error in the error queue or by the user who is reexecuting the transaction. Also, the current Oracle Streams <a href="strms_glossary.htm#CHDBJJHH"><span class="xrefglossterm">tag</span></a> for the apply process is used when you reexecute a transaction in the error queue.</p>
<p>A reexecuted transaction uses any relevant <a href="strms_glossary.htm#CHDCJAED"><span class="xrefglossterm">apply handler</span></a>s and <a href="strms_glossary.htm#CHDJBFBD"><span class="xrefglossterm">conflict resolution</span></a> handlers. If, to resolve the error, a row LCR in an error queue must be modified before it is executed, then you can configure a <a href="strms_glossary.htm#CHDEAFJH"><span class="xrefglossterm">procedure DML handler</span></a> to process the row LCR that caused the error in the error queue. In this case, the DML handler can modify the row LCR to avoid a repetition of the same error. The row LCR is passed to the DML handler when you reexecute the error containing the row LCR. For example, a statement DML handler might insert different values than the ones present in an insert row LCR, while a procedure DML handler might modify one or more columns in the row LCR to avoid a repetition of the same error.</p>
<p>The error queue contains information about errors encountered at the local <a href="strms_glossary.htm#CHDGCAJA"><span class="xrefglossterm">destination database</span></a> only. It does not contain information about errors for apply processes running in other databases in an Oracle Streams environment.</p>
<p>The error queue uses the <a href="strms_glossary.htm#CHDCIBDJ"><span class="xrefglossterm">exception queue</span></a>s in the database. When you create an <code>ANYDATA</code> queue using the <code>SET_UP_QUEUE</code> procedure in the <code>DBMS_STREAMS_ADM</code> package, the procedure creates a <a href="strms_glossary.htm#CHDFFJJB"><span class="xrefglossterm">queue table</span></a> for the queue if one does not already exist. When a queue table is created, an exception queue is created automatically for the queue table. Multiple queues can use a single queue table, and each queue table has one exception queue. Therefore, a single exception queue can store errors for multiple queues and multiple apply processes.</p>
<p>An exception queue only contains the apply errors for its queue table, but the Oracle Streams error queue contains information about all of the apply errors in each exception queue in a database. You should use the procedures in the <code>DBMS_APPLY_ADM</code> package to manage Oracle Streams apply errors. You should not dequeue apply errors from an exception queue directly.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a <a href="strms_glossary.htm#CHDDGHHB"><span class="xrefglossterm">messaging client</span></a> encounters an error when it is dequeuing messages, then the messaging client moves these messages to the exception queue associated with the its queue table. However, information about messaging client errors is not stored in the error queue. Only information about apply process errors is stored in the error queue.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_mapply.htm#i1010782">"Managing Apply Errors"</a></p>
</li>
<li>
<p><a href="strms_apmon.htm#i1007797">"Checking for Apply Errors"</a></p>
</li>
<li>
<p><a href="strms_apmon.htm#i1007852">"Displaying Detailed Information About Apply Errors"</a></p>
</li>
<li>
<p><a href="strms_mapply.htm#i1010565">"Managing an Error Handler"</a></p>
</li>
<li>
<p><a href="strms_rules.htm#g1049257">Chapter 5, "How Rules Are Used in Oracle Streams"</a></p>
</li>
<li>
<p><a class="olink ARPLS300" href="../../appdev.112/e40758/d_apply.htm#ARPLS300"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about the <code>DBMS_APPLY_ADM</code> package</p>
</li>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for more information about the <code>DBA_APPLY_ERROR</code> data dictionary view</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008622"></a>
<div id="STRMS396" class="sect1">
<h2 class="sect1">Explicit Consumption with a Messaging Client<a id="sthref262"></a><a id="sthref263"></a></h2>
<p>A <span class="bold">messaging client</span> dequeues messages from its <a href="strms_glossary.htm#CBAEIBGJ"><span class="xrefglossterm">persistent queue</span></a> when it is invoked by an application or a user. You use <a href="strms_glossary.htm#CHDIFFCF"><span class="xrefglossterm">rule</span></a>s to specify which messages in the <a href="strms_glossary.htm#CHDIDCDI"><span class="xrefglossterm">queue</span></a> are dequeued by a messaging client. These messages can be <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a>s or <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s.</p>
<p>You can create a messaging client by specifying <code>dequeue</code> for the <code>streams_type</code> parameter when you run one of the following procedures in the <code>DBMS_STREAMS_ADM</code> package:</p>
<ul>
<li>
<p><a class="olink ARPLS521" href="../../appdev.112/e40758/d_streams_adm.htm#ARPLS521"><code>ADD_MESSAGE_RULE</code></a></p>
</li>
<li>
<p><a class="olink ARPLS308" href="../../appdev.112/e40758/d_streams_adm.htm#ARPLS308"><code>ADD_TABLE_RULES</code></a></p>
</li>
<li>
<p><a class="olink ARPLS329" href="../../appdev.112/e40758/d_streams_adm.htm#ARPLS329"><code>ADD_SUBSET_RULES</code></a></p>
</li>
<li>
<p><a class="olink ARPLS309" href="../../appdev.112/e40758/d_streams_adm.htm#ARPLS309"><code>ADD_SCHEMA_RULES</code></a></p>
</li>
<li>
<p><a class="olink ARPLS310" href="../../appdev.112/e40758/d_streams_adm.htm#ARPLS310"><code>ADD_GLOBAL_RULES</code></a></p>
</li>
</ul>
<p>When you create a messaging client, you specify the name of the messaging client and the <code>ANYDATA</code> queue from which the messaging client dequeues messages. These procedures can also add rules to the <a href="strms_glossary.htm#CHDEEDIJ"><span class="xrefglossterm">positive rule set</span></a> or <a href="strms_glossary.htm#CHDBHJHI"><span class="xrefglossterm">negative rule set</span></a> of a messaging client. You specify the message type for each rule, and a single messaging client can dequeue messages of different types.</p>
<p>The user who creates a messaging client is granted the privileges to dequeue from the queue using the messaging client. This user is the <span class="bold">messaging client user</span>. The messaging client user can dequeue messages that satisfy the messaging client <a href="strms_glossary.htm#CHDCHGGB"><span class="xrefglossterm">rule set</span></a>s. A messaging client can be associated with only one user, but one user can be associated with many messaging clients.</p>
<p><a href="#i1008509">Figure 4-2</a> shows a messaging client dequeuing messages.</p>
<div id="STRMS397" class="figure">
<p class="titleinfigure"><a id="i1008509"></a>Figure 4-2 Messaging Client</p>
<img width="423" height="147" src="img/strms045.gif" alt="Description of Figure 4-2 follows" /><br />
<a id="sthref264" href="img_text/strms045.htm">Description of "Figure 4-2 Messaging Client"</a><br />
<br /></div>
<!-- class="figure" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="strms_rules.htm#g1049257">Chapter 5, "How Rules Are Used in Oracle Streams"</a></p>
</li>
<li>
<p><a href="ap_restrictions.htm#BABGDIFA">"Messaging Client Restrictions"</a></p>
</li>
<li>
<p><a class="olink TDPII026" href="../../server.112/e17516/tdpii_messaging.htm#TDPII026"><span class="italic">Oracle Database 2 Day + Data Replication and Integration Guide</span></a> contains basic information about messaging</p>
</li>
<li>
<p><a class="olink ADQUE" href="../e11013/toc.htm"><span class="italic">Oracle Streams Advanced Queuing User's Guide</span></a> for information about the <code>DBMS_AQ</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="BABCICBA"></a>
<div id="STRMS398" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Explicit Consumption with Manual Dequeue<a id="sthref265"></a><a id="sthref266"></a></h2>
<p>With <a href="strms_glossary.htm#CBAGHCIE"><span class="xrefglossterm">explicit consumption</span></a> with manual dequeue, an application explicitly dequeues <a href="strms_glossary.htm#CBABHDGA"><span class="xrefglossterm">buffered LCR</span></a>s, <a href="strms_glossary.htm#CBAGDEIH"><span class="xrefglossterm">persistent LCR</span></a>s, <a href="strms_glossary.htm#CBAGGFJH"><span class="xrefglossterm">buffered user message</span></a>s, or <a href="strms_glossary.htm#CBAGGIDA"><span class="xrefglossterm">persistent user message</span></a>s manually and processes them. The queue from which the messages are dequeued can be an <a href="strms_glossary.htm#CHDJDEHJ"><span class="xrefglossterm">ANYDATA queue</span></a> or a <a href="strms_glossary.htm#CHDBGAAH"><span class="xrefglossterm">typed queue</span></a>. You can use either the <code>DBMS_STREAMS_MESSAGING</code> package or the <code>DBMS_AQ</code> package to dequeue messages.</p>
<p>The dequeue features available with Oracle Streams Advanced Queuing include the following:</p>
<ul>
<li>
<p>Dequeue from a buffered queue or a persistent queue</p>
</li>
<li>
<p>Concurrent dequeues</p>
</li>
<li>
<p>Dequeue methods</p>
</li>
<li>
<p>Dequeue modes</p>
</li>
<li>
<p>Dequeue an array of messages</p>
</li>
<li>
<p>Message states</p>
</li>
<li>
<p>Navigation of messages in dequeuing</p>
</li>
<li>
<p>Waiting for messages</p>
</li>
<li>
<p>Retries with delays</p>
</li>
<li>
<p>Optional transaction protection</p>
</li>
<li>
<p>Exception queues</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink TDPII026" href="../../server.112/e17516/tdpii_messaging.htm#TDPII026"><span class="italic">Oracle Database 2 Day + Data Replication and Integration Guide</span></a></p>
</li>
<li>
<p><a class="olink ADQUE" href="../e11013/toc.htm"><span class="italic">Oracle Streams Advanced Queuing User's Guide</span></a> for detailed information about these features and for information about other features available with Oracle Streams Advanced Queuing</p>
</li>
<li>
<p><a href="ap_restrictions.htm#BABDAGAD">"Restrictions for Buffered Messaging"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1624">
<tr>
<td class="cellalignment1631">
<table class="cellalignment1629">
<tr>
<td class="cellalignment1628"><a href="strms_prop.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1628"><a href="strms_rules.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2002, 2013,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1633">
<table class="cellalignment1627">
<tr>
<td class="cellalignment1628"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1628"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1628"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1628"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1628"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1628"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
