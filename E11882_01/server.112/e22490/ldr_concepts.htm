<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL*Loader Concepts</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093" />
<meta name="dcterms.created" content="2018-03-26T15:54:45Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Utilities" />
<meta name="dcterms.identifier" content="E22490-08" />
<meta name="dcterms.isVersionOf" content="SUTIL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="part_ldr.htm" title="Previous" type="text/html" />
<link rel="Next" href="ldr_params.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e22490.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">16/36</span> <!-- End Header -->
<div id="SUTIL003" class="chapter"><a id="g1013706"></a> <a id="i1005437"></a>
<h1 class="chapter"><span class="secnum">7</span> SQL*Loader Concepts</h1>
<p>This chapter explains the basic concepts of loading data into an Oracle database with SQL*Loader. This chapter covers the following topics:</p>
<ul>
<li>
<p><a href="#i1004619">SQL*Loader Features</a></p>
</li>
<li>
<p><a href="#i1007844">SQL*Loader Parameters</a></p>
</li>
<li>
<p><a href="#i1004652">SQL*Loader Control File</a></p>
</li>
<li>
<p><a href="#i1004677">Input Data and Data Files</a></p>
</li>
<li>
<p><a href="#i1005928">LOBFILEs and Secondary Data Files (SDFs)</a></p>
</li>
<li>
<p><a href="#i1004811">Data Conversion and Datatype Specification</a></p>
</li>
<li>
<p><a href="#i1004846">Discarded and Rejected Records</a></p>
</li>
<li>
<p><a href="#i1004909">Log File and Logging Information</a></p>
</li>
<li>
<p><a href="#i1004917">Conventional Path Loads, Direct Path Loads, and External Table Loads</a></p>
</li>
<li>
<p><a href="#i1005027">Loading Objects, Collections, and LOBs</a></p>
</li>
<li>
<p><a href="#i1005088">Partitioned Object Support</a></p>
</li>
<li>
<p><a href="#i1005101">Application Development: Direct Path Load API</a></p>
</li>
<li>
<p><a href="#i1006494">SQL*Loader Case Studies</a></p>
</li>
</ul>
<a id="i1004619"></a>
<div id="SUTIL978" class="sect1">
<h2 class="sect1">SQL*Loader Features</h2>
<p>SQL*Loader loads data from external files into tables of an Oracle database. It has a powerful data parsing engine that puts little limitation on the format of the data in the data file. You can use SQL*Loader to do the following:</p>
<ul>
<li>
<p>Load data across a network if your data files are on a different system than the database. (See <a href="ldr_params.htm#BABFGEAJ">Loading Data Across a Network</a>)</p>
</li>
<li>
<p>Load data from multiple data files during the same load session.</p>
</li>
<li>
<p>Load data into multiple tables during the same load session.</p>
</li>
<li>
<p>Specify the character set of the data.</p>
</li>
<li>
<p>Selectively load data (you can load records based on the records' values).</p>
</li>
<li>
<p>Manipulate the data before loading it, using SQL functions.</p>
</li>
<li>
<p>Generate unique sequential key values in specified columns.</p>
</li>
<li>
<p>Use the operating system's file system to access the data files.</p>
</li>
<li>
<p>Load data from disk, tape, or named pipe.</p>
</li>
<li>
<p>Generate sophisticated error reports, which greatly aid troubleshooting.</p>
</li>
<li>
<p>Load arbitrarily complex object-relational data.</p>
</li>
<li>
<p>Use secondary data files for loading LOBs and collections.</p>
</li>
<li>
<p>Use either conventional or direct path loading. While conventional path loading is very flexible, direct path loading provides superior loading performance. See <a href="ldr_modes.htm#g1023818">Chapter 12</a>.</p>
</li>
</ul>
<p>A typical SQL*Loader session takes as input a control file, which controls the behavior of SQL*Loader, and one or more data files. The output of SQL*Loader is an Oracle database (where the data is loaded), a log file, a bad file, and potentially, a discard file. An example of the flow of a SQL*Loader session is shown in <a href="#i1007641">Figure 7-1</a>.</p>
<div id="SUTIL3312" class="figure">
<p class="titleinfigure"><a id="i1007641"></a>Figure 7-1 SQL*Loader Overview</p>
<img width="379" height="302" src="img/sut81088.gif" alt="Description of Figure 7-1 follows" /><br />
<a id="sthref382" href="img_text/sut81088.htm">Description of ''Figure 7-1 SQL*Loader Overview''</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect1" -->
<a id="i1007844"></a>
<div id="SUTIL979" class="sect1">
<h2 class="sect1">SQL*Loader Parameters</h2>
<p>SQL*Loader is invoked when you specify the <code dir="ltr">sqlldr</code> command and, optionally, parameters that establish session characteristics.</p>
<p>In situations where you always use the same parameters for which the values seldom change, it can be more efficient to specify parameters using the following methods, rather than on the command line:</p>
<ul>
<li>
<p>Parameters can be grouped together in a parameter file. You could then specify the name of the parameter file on the command line using the <code dir="ltr">PARFILE</code> parameter.</p>
</li>
<li>
<p>Certain parameters can also be specified within the SQL*Loader control file by using the <code dir="ltr">OPTIONS</code> clause.</p>
</li>
</ul>
<p>Parameters specified on the command line override any parameter values specified in a parameter file or <code dir="ltr">OPTIONS</code> clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_params.htm#g1014550">Chapter 8</a> for descriptions of the SQL*Loader parameters</p>
</li>
<li>
<p><a href="ldr_params.htm#i1005781">"PARFILE (parameter file)"</a></p>
</li>
<li>
<p><a href="ldr_control_file.htm#i1004788">"OPTIONS Clause"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1004652"></a>
<div id="SUTIL980" class="sect1">
<h2 class="sect1">SQL*Loader Control File</h2>
<p>The <a id="sthref383"></a>control file is a text file written in a language that SQL*Loader understands. The control file tells SQL*Loader where to find the data, how to parse and interpret the data, where to insert the data, and more.</p>
<p>Although not precisely defined, a control file can be said to have three sections.</p>
<p>The first section contains session-wide information, for example:</p>
<ul>
<li>
<p>Global options such as bindsize, rows, records to skip, and so on</p>
</li>
<li>
<p><code dir="ltr">INFILE</code> clauses to specify where the input data is located</p>
</li>
<li>
<p>Data to be loaded</p>
</li>
</ul>
<p>The second section consists of one or more <code dir="ltr">INTO TABLE</code> blocks. Each of these blocks contains information about the table into which the data is to be loaded, such as the table name and the columns of the table.</p>
<p>The third section is optional and, if present, contains input data.</p>
<p>Some control file syntax considerations to keep in mind are:</p>
<ul>
<li>
<p>The syntax is free-format (statements can extend over multiple lines).</p>
</li>
<li>
<p>It is case insensitive; however, strings enclosed in single or double quotation marks are taken literally, including case.</p>
</li>
<li>
<p>In control file syntax, comments extend from the two hyphens (--) that mark the beginning of the comment to the end of the line. The optional third section of the control file is interpreted as data rather than as control file syntax; consequently, comments in this section are not supported.</p>
</li>
<li>
<p>The keywords <code dir="ltr">CONSTANT</code> and <code dir="ltr">ZONE</code> have special meaning to SQL*Loader and are therefore <a id="sthref384"></a>reserved. To avoid potential conflicts, Oracle recommends that you do not use either <code dir="ltr">CONSTANT</code> or <code dir="ltr">ZONE</code> as a name for any tables or columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_control_file.htm#i1006645">Chapter 9</a> for details about control file syntax and semantics</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1004677"></a>
<div id="SUTIL981" class="sect1">
<h2 class="sect1">Input Data and Data Files</h2>
<p>SQL*Loader reads data from one or more files (or operating system equivalents of files) specified in the control file. From SQL*Loader's perspective, the data in the data file is organized as <span class="italic">records</span>. A particular data file can be in fixed record format, variable record format, or stream record format. The record format can be specified in the control file with the <code dir="ltr">INFILE</code> parameter. If no record format is specified, then the default is stream record format.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If data is specified inside the control file (that is, <code dir="ltr">INFILE *</code> was specified in the control file), then the data is interpreted in the stream record format with the default record terminator.</div>
<a id="i1004685"></a>
<div id="SUTIL982" class="sect2">
<h3 class="sect2">Fixed Record Format<a id="sthref385"></a></h3>
<p>A file is in fixed record format when all<a id="sthref386"></a> records in a data file are the same byte length. Although this format is the least flexible, it results in better performance than variable or stream format. Fixed format is also simple to specify. For example:</p>
<pre dir="ltr">
INFILE <span class="italic">datafile_name</span> "fix <span class="codeinlineitalic">n</span>"
</pre>
<p>This example specifies that SQL*Loader should interpret the particular data file as being in fixed record format where every record is <code dir="ltr"><span class="codeinlineitalic">n</span></code> bytes long.</p>
<p><a href="#i1004697">Example 7-1</a> shows a control file that specifies a data file (example.dat) to be interpreted in the fixed record format. The data file in the example contains five physical records; each record has fields that contain the number and name of an employee. Each of the five records is 11 bytes long, including spaces. For the purposes of explaining this example, periods are used to represent spaces in the records, but in the actual records there would be no periods. With that in mind, the first physical record is <code dir="ltr">396,...ty,.</code> which is exactly eleven bytes (assuming a single-byte character set). The second record is <code dir="ltr">4922,beth,</code> followed by the newline character (<code dir="ltr">\n</code>) which is the eleventh byte, and so on. (Newline characters are not required with the fixed record format; it is simply used here to illustrate that if used, it counts as a byte in the record length.)</p>
<p>Note that the length is always interpreted in bytes, even if character-length semantics are in effect for the file. This is necessary because the file could contain a mix of fields, some of which are processed with character-length semantics and others which are processed with byte-length semantics. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
<div id="SUTIL3313" class="example">
<p class="titleinexample"><a id="i1004697"></a>Example 7-1 Loading Data in Fixed Record Format</p>
<pre dir="ltr">
load data
infile 'example.dat'  "fix 11"
into table example
fields terminated by ',' optionally enclosed by '"'
(col1, col2)
</pre>
<p><span class="bold">example.dat:</span></p>
<pre dir="ltr">
396,...ty,.4922,beth,\n
68773,ben,.
1,.."dave",
5455,mike,.
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1004711"></a>
<div id="SUTIL983" class="sect2">
<h3 class="sect2">Variable Record Format<a id="sthref387"></a></h3>
<p>A file is in variable record format when the length of each record in a character field is included at the beginning of each record in the data file. This format provides some added flexibility over the fixed record format and a performance advantage over the stream record format. For example, you can specify a data file that is to be interpreted as being in variable record format as follows:</p>
<pre dir="ltr">
INFILE "<span class="italic">datafile_name</span>" "var <span class="codeinlineitalic">n</span>"
</pre>
<p>In this example, <code dir="ltr"><span class="codeinlineitalic">n</span></code> specifies the number of bytes in the record length field. If <code dir="ltr"><span class="codeinlineitalic">n</span></code> is not specified, then SQL*Loader assumes a length of 5 bytes. Specifying <code dir="ltr"><span class="codeinlineitalic">n</span></code> larger than 40 will result in an error.</p>
<p><a href="#i1004722">Example 7-2</a> shows a control file specification that tells SQL*Loader to look for data in the data file <code dir="ltr">example</code>.<code dir="ltr">dat</code> and to expect variable record format where the record length fields are 3 bytes long. The <code dir="ltr">example.dat</code> data file consists of three physical records. The first is specified to be 009 (that is, 9) bytes long, the second is 010 bytes long (that is, 10, including a 1-byte newline), and the third is 012 bytes long (also including a 1-byte newline). Note that newline characters are not required with the variable record format. This example also assumes a single-byte character set for the data file.</p>
<p>The lengths are always interpreted in bytes, even if character-length semantics are in effect for the file. This is necessary because the file could contain a mix of fields, some processed with character-length semantics and others processed with byte-length semantics. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
<div id="SUTIL3314" class="example">
<p class="titleinexample"><a id="i1004722"></a>Example 7-2 Loading Data in Variable Record Format</p>
<pre dir="ltr">
load data
infile 'example.dat'  "var 3"
into table example
fields terminated by ',' optionally enclosed by '"'
(col1 char(5),
 col2 char(7))

example.dat:
009hello,cd,010world,im,
012my,name is,
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="SUTIL984" class="sect2"><a id="sthref388"></a>
<h3 class="sect2">Stream Record Format <a id="sthref389"></a></h3>
<p>A file is in stream record format when the records are not specified by size; instead SQL*Loader forms records by scanning for the <span class="italic">record terminator</span>. <a id="sthref390"></a>Stream record format is the most flexible format, but there can be a negative effect on performance. The specification of a data file to be interpreted as being in stream record format looks similar to the following:</p>
<pre dir="ltr">
INFILE <span class="italic">datafile_name</span> [<span class="codeinlineitalic">"str </span><span class="italic">terminator_string</span><span class="codeinlineitalic">"</span>]
</pre>
<p>The <code dir="ltr"><span class="codeinlineitalic">terminator_string</span></code> is specified as either <code dir="ltr">'</code><code dir="ltr"><span class="codeinlineitalic">char_string</span></code><code dir="ltr">'</code> or <code dir="ltr"><span class="codeinlineitalic">X'hex_string</span></code><code dir="ltr">'</code> where:</p>
<ul>
<li>
<p><code dir="ltr">'</code><code dir="ltr"><span class="codeinlineitalic">char_string</span></code><code dir="ltr">'</code> is a string of characters enclosed in single or double quotation marks</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">X'hex_string</span></code><code dir="ltr">'</code> is a byte string in hexadecimal format</p>
</li>
</ul>
<p>When the <code dir="ltr"><span class="codeinlineitalic">terminator_string</span></code> contains special (nonprintable) characters, it should be specified as an <code dir="ltr"><span class="codeinlineitalic">X'hex_string</span></code><code dir="ltr">'</code>. However, some nonprintable characters can be specified as (<code dir="ltr">'</code><code dir="ltr"><span class="codeinlineitalic">char_string</span></code><code dir="ltr">'</code> ) by using a backslash. For example:</p>
<ul>
<li>
<p><code dir="ltr">\n</code> indicates a line feed</p>
</li>
<li>
<p><code dir="ltr">\t</code> indicates a horizontal tab</p>
</li>
<li>
<p><code dir="ltr">\f</code> indicates a form feed</p>
</li>
<li>
<p><code dir="ltr">\v</code> indicates a vertical tab</p>
</li>
<li>
<p><code dir="ltr">\r</code> indicates a carriage return</p>
</li>
</ul>
<p>If the character set specified with the <code dir="ltr">NLS_LANG</code> parameter for your session is different from the character set of the data file, then character strings are converted to the character set of the data file. This is done before SQL*Loader checks for the default record terminator.</p>
<p>Hexadecimal strings are assumed to be in the character set of the data file, so no conversion is performed.</p>
<p>On UNIX-based platforms, if no <code dir="ltr"><span class="codeinlineitalic">terminator_string</span></code> is specified, then SQL*Loader defaults to the line feed character, <code dir="ltr">\n</code>.</p>
<p>On Windows NT, if no <code dir="ltr"><span class="codeinlineitalic">terminator_string</span></code> is specified, then SQL*Loader uses either <code dir="ltr">\n</code> or <code dir="ltr">\r\n</code> as the record terminator, depending on which one it finds first in the data file. This means that if you know that one or more records in your data file has <code dir="ltr">\n</code> embedded in a field, but you want <code dir="ltr">\r\n</code> to be used as the record terminator, then you must specify it.</p>
<p><a href="#i1005800">Example 7-3</a> illustrates loading data in stream record format where the terminator string is specified using a character string, <code dir="ltr">'|\n'</code>. The use of the backslash character allows the character string to specify the nonprintable line feed character.</p>
<div id="SUTIL3315" class="example">
<p class="titleinexample"><a id="i1005800"></a>Example 7-3 Loading Data in Stream Record Format</p>
<pre dir="ltr">
load data
infile 'example.dat'  "str '|\n'"
into table example
fields terminated by ',' optionally enclosed by '"'
(col1 char(5),
 col2 char(7))

example.dat:
hello,world,|
james,bond,|
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="SUTIL985" class="sect2"><a id="sthref391"></a>
<h3 class="sect2">Logical Records</h3>
<p>SQL*Loader organizes the input data into physical records, according to the specified record format. By default a physical record is a logical record, but for added flexibility, SQL*Loader can be instructed to combine several physical records into a logical record.</p>
<p>SQL*Loader can be instructed to follow one of the following logical record-forming strategies:</p>
<ul>
<li>
<p>Combine a fixed number of physical records to form each logical record.</p>
</li>
<li>
<p>Combine physical records into logical records while a certain condition is true.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_control_file.htm#i1005509">"Assembling Logical Records from Physical Records"</a></p>
</li>
<li>
<p>Case study 4, Loading Combined Physical Records (see <a href="#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL986" class="sect2"><a id="sthref392"></a>
<h3 class="sect2">Data Fields</h3>
<p>Once a logical record is formed, field setting on the logical record is done. Field setting is a process in which SQL*Loader uses control-file field specifications to determine which parts of logical record data correspond to which control-file fields. It is possible for two or more field specifications to claim the same data. Also, it is possible for a logical record to contain data that is not claimed by any control-file field specification.</p>
<p>Most control-file field specifications claim a particular part of the logical record. This mapping takes the following forms:</p>
<ul>
<li>
<p>The byte position of the data field's beginning, end, or both, can be specified. This specification form is not the most flexible, but it provides high field-setting performance.</p>
</li>
<li>
<p>The strings delimiting (enclosing and/or terminating) a particular data field can be specified. A delimited data field is assumed to start where the last data field ended, unless the byte position of the start of the data field is specified.</p>
</li>
<li>
<p>The byte offset and/or the length of the data field can be specified. This way each field starts a specified number of bytes from where the last one ended and continues for a specified length.</p>
</li>
<li>
<p>Length-value datatypes can be used. In this case, the first <code dir="ltr"><span class="codeinlineitalic">n</span></code> number of bytes of the data field contain information about how long the rest of the data field is.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_field_list.htm#i1006565">"Specifying the Position of a Data Field"</a></p>
</li>
<li>
<p><a href="ldr_field_list.htm#i1007368">"Specifying Delimiters"</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005928"></a>
<div id="SUTIL987" class="sect1">
<h2 class="sect1">LOBFILEs and Secondary Data Files (SDFs)<a id="sthref393"></a><a id="sthref394"></a><a id="sthref395"></a></h2>
<p>LOB data can be lengthy enough that it makes sense to load it from a LOBFILE. In LOBFILEs, LOB data instances are still considered to be in fields (predetermined size, delimited, length-value), but these fields are not organized into records (the concept of a record does not exist within LOBFILEs). Therefore, the processing overhead of dealing with records is avoided. This type of organization of data is ideal for LOB loading.</p>
<p>For example, you might use LOBFILEs to load employee names, employee IDs, and employee resumes. You could read the employee names and IDs from the main data files and you could read the resumes, which can be quite lengthy, from LOBFILEs.</p>
<p>You might also use LOBFILEs to facilitate the loading of XML data. You can use <code dir="ltr">XML</code> columns to hold data that models structured and semistructured data. Such data can be quite lengthy.</p>
<p>Secondary data files (SDFs) are similar in concept to primary data files. Like primary data files, SDFs are a collection of records, and each record is made up of fields. The SDFs are specified on a per control-file-field basis. Only a <code dir="ltr">collection_fld_spec</code> can name an SDF as its data source.</p>
<p>SDFs are specified using the <code dir="ltr">SDF</code> parameter. The <code dir="ltr">SDF</code> parameter can be followed by either the file specification string, or a <code dir="ltr">FILLER</code> field that is mapped to a data field containing one or more file specification strings.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_loading.htm#i1006993">"Loading LOB Data from LOBFILEs"</a></p>
</li>
<li>
<p><a href="ldr_loading.htm#i1007276">"Secondary Data Files (SDFs)"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1004811"></a>
<div id="SUTIL988" class="sect1">
<h2 class="sect1">Data Conversion and Datatype Specification<a id="sthref396"></a><a id="sthref397"></a></h2>
<p>During a conventional path load, <span class="italic">data fields</span> in the data file are converted into <span class="italic">columns</span> in the database (direct path loads are conceptually similar, but the implementation is different). There are two conversion steps:</p>
<ol>
<li>
<p>SQL*Loader uses the field specifications in the control file to interpret the format of the data file, parse the input data, and populate the bind arrays that correspond to a SQL <code dir="ltr">INSERT</code> statement using that data.</p>
</li>
<li>
<p>The Oracle database accepts the data and executes the <code dir="ltr">INSERT</code> statement to store the data in the database.</p>
</li>
</ol>
<p>The Oracle database uses the datatype of the column to convert the data into its final, stored form. Keep in mind the distinction between a <span class="italic">field</span> in a data file and a <span class="italic">column</span> in the database. Remember also that the <span class="italic">field datatypes</span> defined in a SQL*Loader control file are <span class="italic">not</span> the same as the <span class="italic">column</span> <span class="italic">datatypes.</span></p>
</div>
<!-- class="sect1" -->
<a id="i1004846"></a>
<div id="SUTIL989" class="sect1">
<h2 class="sect1">Discarded and Rejected Records<a id="sthref398"></a><a id="sthref399"></a><a id="sthref400"></a><a id="sthref401"></a></h2>
<p>Records read from the input file might not be inserted into the database. Such records are placed in either a bad file or a discard file<span class="italic">.<a id="sthref402"></a><a id="sthref403"></a></span></p>
<div id="SUTIL990" class="sect2"><a id="sthref404"></a>
<h3 class="sect2">The Bad File</h3>
<p>The bad file contains records that were rejected, either by SQL*Loader or by the Oracle database. If you do not specify a bad file and there are rejected records, then SQL*Loader automatically creates one. It will have the same name as the data file, with a.bad extension. Some of the possible reasons for rejection are discussed in the next sections.</p>
<div id="SUTIL991" class="sect3"><a id="sthref405"></a>
<h4 class="sect3">SQL*Loader Rejects</h4>
<p>Data file records are rejected by SQL*Loader when the input format is invalid. For example, if the second enclosure delimiter is missing, or if a delimited field exceeds its maximum length, then SQL*Loader rejects the record. Rejected records are placed in the bad file.<a id="sthref406"></a></p>
</div>
<!-- class="sect3" -->
<div id="SUTIL992" class="sect3"><a id="sthref407"></a>
<h4 class="sect3">Oracle Database Rejects</h4>
<p>After a data file record is accepted for processing by SQL*Loader, it is sent to the Oracle database for insertion into a table as a row. If the Oracle database determines that the row is valid, then the row is inserted into the table. If the row is determined to be invalid, then the record is rejected and SQL*Loader puts it in the bad file. The row may be invalid, for example, because a key is not unique, because a required field is null, or because the field contains invalid data for the Oracle datatype.<a id="sthref408"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_control_file.htm#i1005085">"Specifying the Bad File"</a></p>
</li>
<li>
<p>Case study 4, Loading Combined Physical Records (see <a href="#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL993" class="sect2"><a id="sthref409"></a>
<h3 class="sect2">The Discard File</h3>
<p>As SQL*Loader executes, it may create a file called the discard file. This file is created only when it is needed, and only if you have specified that a discard file should be enabled. The discard file contains records that were filtered out of the load because they did not match any record-selection criteria specified in the control file.</p>
<p>The discard file therefore contains records that were not inserted into any table in the database. You can specify the maximum number of such records that the discard file can accept. Data written to any database table is not written to the discard file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>Case study 4, Loading Combined Physical Records (see <a href="#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</p>
</li>
<li>
<p><a href="ldr_control_file.htm#i1005162">"Specifying the Discard File"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1004909"></a>
<div id="SUTIL994" class="sect1">
<h2 class="sect1">Log File and Logging Information<a id="sthref410"></a><a id="sthref411"></a></h2>
<p>When SQL*Loader begins execution, it creates a <span class="italic">log file.</span> If it cannot create a log file, then execution terminates. The log file contains a detailed summary of the load, including a description of any errors that occurred during the load.</p>
</div>
<!-- class="sect1" -->
<a id="i1004917"></a>
<div id="SUTIL995" class="sect1">
<h2 class="sect1">Conventional Path Loads, Direct Path Loads, and External Table Loads<a id="sthref412"></a></h2>
<p>SQL*Loader provides the following methods to load data:</p>
<ul>
<li>
<p><a href="#i1004935">Conventional Path Loads</a></p>
</li>
<li>
<p><a href="#i1004951">Direct Path Loads</a></p>
</li>
<li>
<p><a href="#i1005624">External Table Loads</a></p>
</li>
</ul>
<a id="i1004935"></a>
<div id="SUTIL996" class="sect2">
<h3 class="sect2">Conventional Path Loads<a id="sthref413"></a></h3>
<p>During conventional path loads, the input records are parsed according to the field specifications, and each data field is copied to its corresponding bind array. When the bind array is full (or no more data is left to read), an array insert is executed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_modes.htm#i1007501">"Data Loading Methods"</a></p>
</li>
<li>
<p><a href="ldr_control_file.htm#i1005907">"Bind Arrays and Conventional Path Loads"</a></p>
</li>
</ul>
</div>
<p>SQL*Loader stores LOB fields after a bind array insert is done. Thus, if there are any errors in processing the LOB field (for example, the LOBFILE could not be found), then the LOB field is left empty. Note also that because LOB data is loaded after the array insert has been performed, <code dir="ltr">BEFORE</code> and <code dir="ltr">AFTER</code> row triggers may not work as expected for LOB columns. This is because the triggers fire before SQL*Loader has a chance to load the LOB contents into the column. For instance, suppose you are loading a LOB column, <code dir="ltr">C1</code>, with data and you want a <code dir="ltr">BEFORE</code> row trigger to examine the contents of this LOB column and derive a value to be loaded for some other column, <code dir="ltr">C2</code>, based on its examination. This is not possible because the LOB contents will not have been loaded at the time the trigger fires.</p>
</div>
<!-- class="sect2" -->
<a id="i1004951"></a>
<div id="SUTIL997" class="sect2">
<h3 class="sect2">Direct Path Loads</h3>
<p>A direct path load parses the input records according to the field specifications, converts the input field data to the column datatype, and builds a column array. The column array is passed to a block formatter, which creates data blocks in Oracle database block format. The newly formatted database blocks are written directly to the database, bypassing much of the data processing that normally takes place.<a id="sthref414"></a><a id="sthref415"></a> Direct path load is much faster than conventional path load, but entails several restrictions.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_modes.htm#i1008815">"Direct Path Load"</a></div>
<div id="SUTIL998" class="sect3"><a id="sthref416"></a>
<h4 class="sect3">Parallel Direct Path</h4>
<p>A parallel direct path load allows multiple direct path load sessions to concurrently load the same data segments (allows intrasegment parallelism). Parallel direct path is more restrictive than direct path.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_modes.htm#i1008225">"Parallel Data Loading Models"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005624"></a>
<div id="SUTIL999" class="sect2">
<h3 class="sect2">External Table Loads<a id="sthref417"></a></h3>
<p>External tables are defined as tables that do not reside in the database, and can be in any format for which an access driver is provided. Oracle Database provides two access drivers: <code dir="ltr">ORACLE_LOADER</code> and <code dir="ltr">ORACLE_DATAPUMP</code>. By providing the database with metadata describing an external table, the database is able to expose the data in the external table as if it were data residing in a regular database table.</p>
<p>An external table load creates an external table for data that is contained in a data file. The load executes <code dir="ltr">INSERT</code> statements to insert the data from the data file into the target table.</p>
<p>The advantages of using external table loads over conventional path and direct path loads are as follows:</p>
<ul>
<li>
<p>If a data file is big enough, then an external tables load attempts to load that file in parallel.</p>
</li>
<li>
<p>An external table load allows modification of the data being loaded by using SQL functions and PL/SQL functions as part of the <code dir="ltr">INSERT</code> statement that is used to create the external table.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
An external table load is not supported using a named pipe<a id="sthref418"></a> on Windows NT.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="et_params.htm#g1031955">Chapter 14, "The ORACLE_LOADER Access Driver"</a></p>
</li>
<li>
<p><a href="et_dp_driver.htm#g1017944">Chapter 15, "The ORACLE_DATAPUMP Access Driver"</a></p>
</li>
<li>
<p><a class="olink ADMIN01507" href="../../server.112/e25494/tables.htm#ADMIN01507"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about creating and managing external tables</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CIHFCBCC"></a>
<div id="SUTIL1000" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Choosing External Tables Versus SQL*Loader</h3>
<p>The record parsing of external tables and SQL*Loader is very similar, so normally there is not a major performance difference for the same record format. However, due to the different architecture of external tables and SQL*Loader, there are situations in which one method may be more appropriate than the other.</p>
<p>Use external tables for the best load performance in the following situations:</p>
<ul>
<li>
<p>You want to transform the data as it is being loaded into the database</p>
</li>
<li>
<p>You want to use transparent parallel processing without having to split the external data first</p>
</li>
</ul>
<p>Use SQL*Loader for the best load performance in the following situations:</p>
<ul>
<li>
<p>You want to load data remotely</p>
</li>
<li>
<p>Transformations are not required on the data, and the data does not need to be loaded in parallel</p>
</li>
<li>
<p>You want to load data, and additional indexing of the staging table is required</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CHDGDGFC"></a>
<div id="SUTIL3316" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Behavior Differences Between SQL*Loader and External Tables</h3>
<p>This section describes important differences between loading data with external tables, using the <code dir="ltr">ORACLE_LOADER</code> access driver, as opposed to loading data with SQL*Loader conventional and direct path loads. This information does not apply to the <code dir="ltr">ORACLE_DATAPUMP</code> access driver.</p>
<div id="SUTIL3317" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref419"></a>
<h4 class="sect3">Multiple Primary Input Data Files</h4>
<p>If there are multiple primary input data files with SQL*Loader loads, then a bad file and a discard file are created for each input data file. With external table loads, there is only one bad file and one discard file for all input data files. If parallel access drivers are used for the external table load, then each access driver has its own bad file and discard file.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL3318" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref420"></a>
<h4 class="sect3">Syntax and Datatypes</h4>
<p>The following are not supported with external table loads:</p>
<ul>
<li>
<p>Use of <code dir="ltr">CONTINUEIF</code> or <code dir="ltr">CONCATENATE</code> to combine multiple physical records into a single logical record.</p>
</li>
<li>
<p>Loading of the following SQL*Loader datatypes: <code dir="ltr">GRAPHIC</code>, <code dir="ltr">GRAPHIC EXTERNAL</code>, and <code dir="ltr">VARGRAPHIC</code></p>
</li>
<li>
<p>Use of the following database column types: <code dir="ltr">LONG</code>s, nested tables, <code dir="ltr">VARRAY</code>s, <code dir="ltr">REF</code>s, primary key <code dir="ltr">REF</code>s, and <code dir="ltr">SID</code>s</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="SUTIL3319" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref421"></a>
<h4 class="sect3">Byte-Order Marks</h4>
<p>With SQL*Loader, if a primary data file uses a Unicode character set (UTF8 or UTF16) and it also contains a byte-order mark (BOM), then the byte-order mark is written at the beginning of the corresponding bad and discard files. With external table loads, the byte-order mark is not written at the beginning of the bad and discard files.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL3320" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref422"></a>
<h4 class="sect3">Default Character Sets, Date Masks, and Decimal Separator</h4>
<p>For fields in a data file, the settings of NLS environment variables on the client determine the default character set, date mask, and decimal separator. For fields in external tables, the database settings of the NLS parameters determine the default character set, date masks, and decimal separator.</p>
</div>
<!-- class="sect3" -->
<a id="CHDCADAF"></a>
<div id="SUTIL3321" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Use of the Backslash Escape Character</h4>
<p>In SQL*Loader, you can use the backslash (\) escape character to mark a single quotation mark as a single quotation mark, as follows:</p>
<pre dir="ltr">
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\''
</pre>
<p>In external tables, the use of the backslash escape character within a string will raise an error. The workaround is to use double quotation marks to mark the separation string, as follows:</p>
<pre dir="ltr">
TERMINATED BY ',' ENCLOSED BY "'"
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005027"></a>
<div id="SUTIL1001" class="sect1">
<h2 class="sect1">Loading <a id="sthref423"></a>Objects, <a id="sthref424"></a>Collections, and LOBs</h2>
<p>You can use SQL*Loader to bulk load objects, collections, and LOBs. It is assumed that you are familiar with the concept of objects and with Oracle's implementation of object support as described in <a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts</span></a> and in the <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a>.</p>
<div id="SUTIL1002" class="sect2"><a id="sthref425"></a>
<h3 class="sect2">Supported Object Types<a id="sthref426"></a></h3>
<p>SQL*Loader supports loading of the following two object types:</p>
<div id="SUTIL1003" class="sect3"><a id="sthref427"></a>
<h4 class="sect3">column objects</h4>
<p>When a column of a table is of some object type, the objects in that column are referred to as column objects. Conceptually such objects are stored in their entirety in a single column position in a row. These objects do not have object identifiers and cannot be referenced.</p>
<p>If the object type of the column object is declared to be nonfinal, then SQL*Loader allows a derived type (or subtype) to be loaded into the column object.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1004" class="sect3"><a id="sthref428"></a>
<h4 class="sect3">row objects</h4>
<p>These objects are stored in tables, known as object tables, that have columns corresponding to the attributes of the object. The object tables have an additional system-generated column, called <code dir="ltr">SYS_NC_OID$,</code> that stores system-generated unique identifiers (OIDs) for each of the objects in the table. Columns in other tables can refer to these objects by using the OIDs.</p>
<p>If the object type of the object table is declared to be nonfinal, then SQL*Loader allows a derived type (or subtype) to be loaded into the row object.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_loading.htm#i1006457">"Loading Column Objects"</a></p>
</li>
<li>
<p><a href="ldr_loading.htm#i1009398">"Loading Object Tables"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1005" class="sect2"><a id="sthref429"></a>
<h3 class="sect2">Supported Collection Types<a id="sthref430"></a></h3>
<p>SQL*Loader supports loading of the following two collection types:</p>
<div id="SUTIL1006" class="sect3"><a id="sthref431"></a>
<h4 class="sect3">Nested Tables</h4>
<p>A nested table is a table that appears as a column in another table. All operations that can be performed on other tables can also be performed on nested tables.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1007" class="sect3"><a id="sthref432"></a>
<h4 class="sect3">VARRAYs</h4>
<p><code dir="ltr">VARRAY</code>s are variable sized arrays. An array is an ordered set of built-in types or objects, called elements. Each array element is of the same type and has an index, which is a number corresponding to the element's position in the <code dir="ltr">VARRAY.</code></p>
<p>When creating a <code dir="ltr">VARRAY</code> type, you must specify the maximum size. Once you have declared a <code dir="ltr">VARRAY</code> type, it can be used as the datatype of a column of a relational table, as an object type attribute, or as a PL/SQL variable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_loading.htm#i1007180">"Loading Collections (Nested Tables and VARRAYs)"</a> for details on using SQL*Loader control file data definition language to load these collection types</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1008" class="sect2"><a id="sthref433"></a>
<h3 class="sect2">Supported LOB Types<a id="sthref434"></a></h3>
<p>A LOB is a large object type. This release of SQL*Loader supports loading of four LOB types:</p>
<ul>
<li>
<p><code dir="ltr">BLOB</code>: a LOB containing unstructured binary data</p>
</li>
<li>
<p><code dir="ltr">CLOB</code>: a LOB containing character data</p>
</li>
<li>
<p><code dir="ltr">NCLOB</code>: a LOB containing characters in a database national character set</p>
</li>
<li>
<p><code dir="ltr">BFILE</code>: a <code dir="ltr">BLOB</code> stored outside of the database tablespaces in a server-side operating system file</p>
</li>
</ul>
<p>LOBs can be column datatypes, and except for <code dir="ltr">NCLOB</code>, they can be an object's attribute datatypes. LOBs can have an actual value, they can be <code dir="ltr">null</code>, or they can be "empty."</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_loading.htm#i1006803">"Loading LOBs"</a> for details on using SQL*Loader control file data definition language to load these LOB types</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005088"></a>
<div id="SUTIL1009" class="sect1">
<h2 class="sect1">Partitioned<a id="sthref435"></a> Object Support</h2>
<p>SQL*Loader supports loading partitioned objects in the database. A partitioned object in an Oracle database is a table or index consisting of partitions (pieces) that have been grouped, typically by common logical attributes. For example, sales data for the year 2000 might be partitioned by month. The data for each month is stored in a separate partition of the sales table. Each partition is stored in a separate segment of the database and can have different physical attributes.</p>
<p>SQL*Loader partitioned object support enables SQL*Loader to load the following:</p>
<ul>
<li>
<p>A single partition of a partitioned table</p>
</li>
<li>
<p>All partitions of a partitioned table</p>
</li>
<li>
<p>A nonpartitioned table</p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1005101"></a>
<div id="SUTIL1010" class="sect1">
<h2 class="sect1">Application Development: Direct Path Load API</h2>
<p>Oracle provides a direct path load API for application developers. See the <a class="olink LNOCI" href="../../appdev.112/e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information.</p>
</div>
<!-- class="sect1" -->
<a id="i1006494"></a>
<div id="SUTIL1011" class="sect1">
<h2 class="sect1">SQL*Loader Case Studies</h2>
<p>SQL*Loader features are illustrated in a variety of case studies. The case studies are based upon the Oracle demonstration database tables, <code dir="ltr">emp</code> and <code dir="ltr">dept</code>, owned by the user <code dir="ltr">scott</code>. (In some case studies, additional columns have been added.)The case studies are numbered 1 through 11, starting with the simplest scenario and progressing in complexity.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Files for use in the case studies are located in the <code dir="ltr">$ORACLE_HOME/rdbms/demo</code> directory. These files are installed when you install the Oracle Database 11<span class="italic">g</span> Examples (formerly Companion) media. See <a href="#g1022881">Table 7-1</a> for the names of the files.</div>
<p>The following is a summary of the case studies:</p>
<ul>
<li>
<p>Case Study 1: Loading Variable-Length Data - Loads stream format records in which the fields are terminated by commas and may be enclosed by quotation marks. The data is found at the end of the control file.</p>
</li>
<li>
<p>Case Study 2: Loading Fixed-Format Fields - Loads data from a separate data file.</p>
</li>
<li>
<p>Case Study 3: Loading a Delimited, Free-Format File - Loads data from stream format records with delimited fields and sequence numbers. The data is found at the end of the control file.</p>
</li>
<li>
<p>Case Study 4: Loading Combined Physical Records - Combines multiple physical records into one logical record corresponding to one database row.</p>
</li>
<li>
<p>Case Study 5: Loading Data into Multiple Tables - Loads data into multiple tables in one run.</p>
</li>
<li>
<p>Case Study 6: Loading Data Using the Direct Path Load Method - Loads data using the direct path load method.</p>
</li>
<li>
<p>Case Study 7: Extracting Data from a Formatted Report - Extracts data from a formatted report.</p>
</li>
<li>
<p>Case Study 8: Loading Partitioned Tables - Loads partitioned tables.</p>
</li>
<li>
<p>Case Study 9: Loading LOBFILEs (CLOBs) - Adds a <code dir="ltr">CLOB</code> column called <code dir="ltr">resume</code> to the table <code dir="ltr">emp</code>, uses a <code dir="ltr">FILLER</code> field (<code dir="ltr">res_file</code>), and loads multiple LOBFILEs into the <code dir="ltr">emp</code> table.</p>
</li>
<li>
<p>Case Study 10: REF Fields and VARRAYs - Loads a customer table that has a primary key as its OID and stores order items in a <code dir="ltr">VARRAY</code>. Loads an order table that has a reference to the customer table and the order items in a <code dir="ltr">VARRAY</code>.</p>
</li>
<li>
<p>Case Study 11: Loading Data in the Unicode Character Set - Loads data in the Unicode character set, UTF16, in little-endian byte order. This case study uses character-length semantics.</p>
</li>
</ul>
<div id="SUTIL1012" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref436"></a>
<h3 class="sect2">Case Study Files</h3>
<p>Generally, each case study is comprised of the following types of files:</p>
<ul>
<li>
<p>Control files (for example, <code dir="ltr">ulcase5.ctl</code>)</p>
</li>
<li>
<p>Data files (for example, <code dir="ltr">ulcase5.dat</code>)</p>
</li>
<li>
<p>Setup files (for example, <code dir="ltr">ulcase5.sql</code>)</p>
</li>
</ul>
<p>These files are installed when you install the Oracle Database 11<span class="italic">g</span> Examples (formerly Companion) media. They are installed in the <code dir="ltr">$ORACLE_HOME/rdbms/demo</code> directory.</p>
<p>If the sample data for the case study is contained within the control file, then there will be no .<code dir="ltr">dat</code> file for that case.</p>
<p>Case study 2 does not require any special set up, so there is no .<code dir="ltr">sql</code> script for that case. Case study 7 requires that you run both a starting (setup) script and an ending (cleanup) script.</p>
<p><a href="#g1022881">Table 7-1</a> lists the files associated with each case.</p>
<div id="SUTIL3322" class="tblformal">
<p class="titleintable"><a id="sthref437"></a><a id="g1022881"></a>Table 7-1 Case Studies and Their Related Files</p>
<table class="cellalignment1394" title="Case Studies and Their Related Files" summary="List of SQL*Loader case studies and their related files" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t19">Case</th>
<th class="cellalignment1395" id="r1c2-t19"><code dir="ltr"><span class="codeinlinebold">.ctl</span></code></th>
<th class="cellalignment1395" id="r1c3-t19"><code dir="ltr"><span class="codeinlinebold">.dat</span></code></th>
<th class="cellalignment1395" id="r1c4-t19"><code dir="ltr"><span class="codeinlinebold">.sql</span></code></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t19" headers="r1c1-t19">
<p>1</p>
</td>
<td class="cellalignment1396" headers="r2c1-t19 r1c2-t19">
<p>ulcase1.ctl</p>
</td>
<td class="cellalignment1396" headers="r2c1-t19 r1c3-t19">
<p>N/A</p>
</td>
<td class="cellalignment1396" headers="r2c1-t19 r1c4-t19">
<p>ulcase1.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t19" headers="r1c1-t19">
<p>2</p>
</td>
<td class="cellalignment1396" headers="r3c1-t19 r1c2-t19">
<p>ulcase2.ctl</p>
</td>
<td class="cellalignment1396" headers="r3c1-t19 r1c3-t19">
<p>ulcase2.dat</p>
</td>
<td class="cellalignment1396" headers="r3c1-t19 r1c4-t19">
<p>N/A</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t19" headers="r1c1-t19">
<p>3</p>
</td>
<td class="cellalignment1396" headers="r4c1-t19 r1c2-t19">
<p>ulcase3.ctl</p>
</td>
<td class="cellalignment1396" headers="r4c1-t19 r1c3-t19">
<p>N/A</p>
</td>
<td class="cellalignment1396" headers="r4c1-t19 r1c4-t19">
<p>ulcase3.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t19" headers="r1c1-t19">
<p>4</p>
</td>
<td class="cellalignment1396" headers="r5c1-t19 r1c2-t19">
<p>ulcase4.ctl</p>
</td>
<td class="cellalignment1396" headers="r5c1-t19 r1c3-t19">
<p>ulcase4.dat</p>
</td>
<td class="cellalignment1396" headers="r5c1-t19 r1c4-t19">
<p>ulcase4.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t19" headers="r1c1-t19">
<p>5</p>
</td>
<td class="cellalignment1396" headers="r6c1-t19 r1c2-t19">
<p>ulcase5.ctl</p>
</td>
<td class="cellalignment1396" headers="r6c1-t19 r1c3-t19">
<p>ulcase5.dat</p>
</td>
<td class="cellalignment1396" headers="r6c1-t19 r1c4-t19">
<p>ulcase5.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t19" headers="r1c1-t19">
<p>6</p>
</td>
<td class="cellalignment1396" headers="r7c1-t19 r1c2-t19">
<p>ulcase6.ctl</p>
</td>
<td class="cellalignment1396" headers="r7c1-t19 r1c3-t19">
<p>ulcase6.dat</p>
</td>
<td class="cellalignment1396" headers="r7c1-t19 r1c4-t19">
<p>ulcase6.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t19" headers="r1c1-t19">
<p>7</p>
</td>
<td class="cellalignment1396" headers="r8c1-t19 r1c2-t19">
<p>ulcase7.ctl</p>
</td>
<td class="cellalignment1396" headers="r8c1-t19 r1c3-t19">
<p>ulcase7.dat</p>
</td>
<td class="cellalignment1396" headers="r8c1-t19 r1c4-t19">
<p>ulcase7s.sql</p>
<p>ulcase7e.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r9c1-t19" headers="r1c1-t19">
<p>8</p>
</td>
<td class="cellalignment1396" headers="r9c1-t19 r1c2-t19">
<p>ulcase8.ctl</p>
</td>
<td class="cellalignment1396" headers="r9c1-t19 r1c3-t19">
<p>ulcase8.dat</p>
</td>
<td class="cellalignment1396" headers="r9c1-t19 r1c4-t19">
<p>ulcase8.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r10c1-t19" headers="r1c1-t19">
<p>9</p>
</td>
<td class="cellalignment1396" headers="r10c1-t19 r1c2-t19">
<p>ulcase9.ctl</p>
</td>
<td class="cellalignment1396" headers="r10c1-t19 r1c3-t19">
<p>ulcase9.dat</p>
</td>
<td class="cellalignment1396" headers="r10c1-t19 r1c4-t19">
<p>ulcase9.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r11c1-t19" headers="r1c1-t19">
<p>10</p>
</td>
<td class="cellalignment1396" headers="r11c1-t19 r1c2-t19">
<p>ulcase10.ctl</p>
</td>
<td class="cellalignment1396" headers="r11c1-t19 r1c3-t19">
<p>N/A</p>
</td>
<td class="cellalignment1396" headers="r11c1-t19 r1c4-t19">
<p>ulcase10.sql</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r12c1-t19" headers="r1c1-t19">
<p>11</p>
</td>
<td class="cellalignment1396" headers="r12c1-t19 r1c2-t19">
<p>ulcase11.ctl</p>
</td>
<td class="cellalignment1396" headers="r12c1-t19 r1c3-t19">
<p>ulcase11.dat</p>
</td>
<td class="cellalignment1396" headers="r12c1-t19 r1c4-t19">
<p>ulcase11.sql</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<div id="SUTIL1013" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref438"></a>
<h3 class="sect2">Running the Case Studies</h3>
<p>In general, you use the following steps to run the case studies (be sure you are in the <code dir="ltr">$ORACLE_HOME/rdbms/demo</code> directory, which is where the case study files are located):</p>
<ol>
<li>
<p>At the system prompt, type <code dir="ltr">sqlplus</code> and press Enter to start SQL*Plus. At the user-name prompt, enter <code dir="ltr">scott</code>. At the password prompt, enter <code dir="ltr">tiger</code>.</p>
<p>The SQL prompt is displayed.</p>
</li>
<li>
<p>At the SQL prompt, execute the SQL script for the case study. For example, to execute the SQL script for case study 1, enter the following:</p>
<pre dir="ltr">
SQL&gt; @ulcase1
</pre>
<p>This prepares and populates tables for the case study and then returns you to the system prompt.</p>
</li>
<li>
<p>At the system prompt, invoke SQL*Loader and run the case study, as follows:</p>
<pre dir="ltr">
sqlldr USERID=scott CONTROL=<span class="codeinlineitalic">ulcase1.ctl</span> LOG=<span class="codeinlineitalic">ulcase1.log</span>
</pre>
<p>Substitute the appropriate control file name and log file name for the <code dir="ltr">CONTROL</code> and <code dir="ltr">LOG</code> parameters and press Enter. When you are prompted for a password, type <code dir="ltr">tiger</code> and then press Enter.</p>
</li>
</ol>
<p>Be sure to read the control file for each case study before you run it. The beginning of the control file contains information about what is being demonstrated in the case study and any other special information you need to know. For example, case study 6 requires that you add <code dir="ltr">DIRECT=TRUE</code> to the SQL*Loader command line.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1014" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref439"></a>
<h3 class="sect2">Case Study Log Files</h3>
<p>Log files for the case studies are not provided in the <code dir="ltr">$ORACLE_HOME/rdbms/demo</code> directory. This is because the log file for each case study is produced when you execute the case study, provided that you use the <code dir="ltr">LOG</code> parameter. If you do not want to produce a log file, then omit the <code dir="ltr">LOG</code> parameter from the command line.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1015" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref440"></a>
<h3 class="sect2">Checking the Results of a Case Study</h3>
<p>To check the results of running a case study, start SQL*Plus and perform a select operation from the table that was loaded in the case study. This is done, as follows:</p>
<ol>
<li>
<p>At the system prompt, type <code dir="ltr">sqlplus</code> and press Enter to start SQL*Plus. At the user-name prompt, enter <code dir="ltr">scott</code>. At the password prompt, enter <code dir="ltr">tiger</code>.</p>
<p>The SQL prompt is displayed.</p>
</li>
<li>
<p>At the SQL prompt, use the <code dir="ltr">SELECT</code> statement to select all rows from the table that the case study loaded. For example, if the table <code dir="ltr">emp</code> was loaded, then enter:</p>
<pre dir="ltr">
SQL&gt; SELECT * FROM emp;
</pre>
<p>The contents of each row in the <code dir="ltr">emp</code> table will be displayed.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1387">
<tr>
<td class="cellalignment1396">
<table class="cellalignment1392">
<tr>
<td class="cellalignment1391"><a href="part_ldr.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1391"><a href="ldr_params.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1398">
<table class="cellalignment1390">
<tr>
<td class="cellalignment1391"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1391"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1391"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1391"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1391"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1391"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
