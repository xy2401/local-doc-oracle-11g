<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL*Loader Control File Reference</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093" />
<meta name="dcterms.created" content="2018-03-26T15:54:46Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Utilities" />
<meta name="dcterms.identifier" content="E22490-08" />
<meta name="dcterms.isVersionOf" content="SUTIL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ldr_params.htm" title="Previous" type="text/html" />
<link rel="Next" href="ldr_field_list.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e22490.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">18/36</span> <!-- End Header -->
<div id="SUTIL005" class="chapter"><a id="i1006645"></a>
<h1 class="chapter"><span class="secnum">9</span> SQL*Loader Control File Reference</h1>
<p>This chapter describes the SQL*Loader control file. The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1004642">Control File Contents</a></p>
</li>
<li>
<p><a href="#i1009196">Specifying Command-Line Parameters in the Control File</a></p>
</li>
<li>
<p><a href="#i1004816">Specifying File Names and Object Names</a></p>
</li>
<li>
<p><a href="#i1015627">Identifying XMLType Tables</a></p>
</li>
<li>
<p><a href="#i1008015">Specifying Data Files</a></p>
</li>
<li>
<p><a href="#i1005017">Identifying Data in the Control File with BEGINDATA</a></p>
</li>
<li>
<p><a href="#i1005062">Specifying Data File Format and Buffering</a></p>
</li>
<li>
<p><a href="#i1005085">Specifying the Bad File</a></p>
</li>
<li>
<p><a href="#i1005162">Specifying the Discard File</a></p>
</li>
<li>
<p><a href="#i1005287">Handling Different Character Encoding Schemes</a></p>
</li>
<li>
<p><a href="#i1008517">Interrupted Loads</a></p>
</li>
<li>
<p><a href="#i1005509">Assembling Logical Records from Physical Records</a></p>
</li>
<li>
<p><a href="#i1005614">Loading Logical Records into Tables</a></p>
</li>
<li>
<p><a href="#i1005761">Index Options</a></p>
</li>
<li>
<p><a href="#i1005798">Benefits of Using Multiple INTO TABLE Clauses</a></p>
</li>
<li>
<p><a href="#i1005907">Bind Arrays and Conventional Path Loads</a></p>
</li>
</ul>
<a id="i1004642"></a>
<div id="SUTIL1049" class="sect1">
<h2 class="sect1">Control File Contents</h2>
<p><a id="sthref536"></a>The SQL*Loader control file is a text file that contains data definition language (DDL) instructions. DDL is used to control the following aspects of a SQL*Loader session:</p>
<ul>
<li>
<p>Where SQL*Loader will find the data to load</p>
</li>
<li>
<p>How SQL*Loader expects that data to be formatted</p>
</li>
<li>
<p>How SQL*Loader will be configured (memory management, rejecting records, interrupted load handling, and so on) as it loads the data</p>
</li>
<li>
<p>How SQL*Loader will manipulate the data being loaded</p>
</li>
</ul>
<p>See <a href="app_ldr_syntax.htm#g632912">Appendix A</a> for syntax diagrams of the SQL*Loader DDL.</p>
<p>To create the SQL*Loader control file, use a text editor such as vi or xemacs.</p>
<p>In general, the control file has three main sections, in the following order:</p>
<ul>
<li>
<p>Session-wide information</p>
</li>
<li>
<p>Table and field-list information</p>
</li>
<li>
<p>Input data (optional section)</p>
</li>
</ul>
<p><a href="#i1004663">Example 9-1</a> shows a sample control file.</p>
<div id="SUTIL3325" class="example">
<p class="titleinexample"><a id="i1004663"></a>Example 9-1 Sample Control File</p>
<pre dir="ltr">
<span class="bold">1</span>    -- This is a sample control file
<span class="bold">2</span>    LOAD DATA
<span class="bold">3</span>    INFILE 'sample.dat'
<span class="bold">4</span>    BADFILE 'sample.bad'
<span class="bold">5</span>    DISCARDFILE 'sample.dsc'
<span class="bold">6</span>    APPEND
<span class="bold">7</span>    INTO TABLE emp
<span class="bold">8</span>    WHEN (57) = '.'
<span class="bold">9</span>    TRAILING NULLCOLS
<span class="bold">10</span>  (hiredate SYSDATE,
      deptno POSITION(1:2)  INTEGER EXTERNAL(2)
              NULLIF deptno=BLANKS,
       job    POSITION(7:14)  CHAR  TERMINATED BY WHITESPACE
              NULLIF job=BLANKS  "UPPER(:job)",
       mgr    POSITION(28:31) INTEGER EXTERNAL 
              TERMINATED BY WHITESPACE, NULLIF mgr=BLANKS,
       ename  POSITION(34:41) CHAR 
              TERMINATED BY WHITESPACE  "UPPER(:ename)",
       empno  POSITION(45) INTEGER EXTERNAL 
              TERMINATED BY WHITESPACE,
       sal    POSITION(51) CHAR  TERMINATED BY WHITESPACE
              "TO_NUMBER(:sal,'$99,999.99')",
       comm   INTEGER EXTERNAL  ENCLOSED BY '(' AND '%'
              ":comm * 100"
    )
</pre>
<p>In this sample control file, the numbers that appear to the left would not appear in a real control file. They are keyed in this sample to the explanatory notes in the following list:</p>
</div>
<!-- class="example" -->
<ol>
<li>
<p>This is how comments are entered in a control file. See <a href="#i1004772">"Comments in the Control File"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">LOAD DATA</code> statement tells SQL*Loader that this is the beginning of a new data load. See <a href="app_ldr_syntax.htm#g632912">Appendix A</a> for syntax information.</p>
</li>
<li>
<p>The <code dir="ltr">INFILE</code> clause specifies the name of a data file containing the data you want to load. See <a href="#i1008015">"Specifying Data Files"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">BADFILE</code> clause specifies the name of a file into which rejected records are placed. See <a href="#i1005085">"Specifying the Bad File"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">DISCARDFILE</code> clause specifies the name of a file into which discarded records are placed. See <a href="#i1005162">"Specifying the Discard File"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">APPEND</code> clause is one of the options you can use when loading data into a table that is not empty. See <a href="#i1006862">"Loading Data into Nonempty Tables"</a>.</p>
<p>To load data into a table that is empty, you would use the <code dir="ltr">INSERT</code> clause. See <a href="#i1006848">"Loading Data into Empty Tables"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">INTO TABLE</code> clause enables you to identify tables, fields, and datatypes. It defines the relationship between records in the data file and tables in the database. See <a href="#i1005623">"Specifying Table Names"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">WHEN</code> clause specifies one or more field conditions. SQL*Loader decides whether to load the data based on these field conditions. See <a href="#i1005657">"Loading Records Based on a Condition"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">TRAILING NULLCOLS</code> <a id="sthref537"></a>clause tells SQL*Loader to treat any relatively positioned columns that are not present in the record as null columns. See <a href="#i1005730">"Handling Short Records with Missing Data"</a>.</p>
</li>
<li>
<p>The remainder of the control file contains the field list, which provides information about column formats in the table being loaded. See <a href="ldr_field_list.htm#g1044967">Chapter 10</a> for information about that section of the control file.</p>
</li>
</ol>
<a id="i1004772"></a>
<div id="SUTIL1050" class="sect2">
<h3 class="sect2">Comments in the Control File</h3>
<p>Comments can appear anywhere in the command section of the file, but they should not appear within the data. Precede any comment with two hyphens, for example:</p>
<pre dir="ltr">
--This is a comment
</pre>
<p>All text to the right of the double hyphen is ignored, until the end of the line.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009196"></a>
<div id="SUTIL1051" class="sect1">
<h2 class="sect1">Specifying Command-Line Parameters in the Control File</h2>
<p>You can specify command-line parameters in the SQL*Loader control file using the <code dir="ltr">OPTIONS</code> clause. This can be useful when you typically invoke a control file with the same set of options. The <code dir="ltr">OPTIONS</code> clause precedes the <code dir="ltr">LOAD</code> <code dir="ltr">DATA</code> statement.</p>
<a id="i1004788"></a>
<div id="SUTIL1052" class="sect2">
<h3 class="sect2">OPTIONS Clause</h3>
<p><a id="sthref538"></a>The following command-line parameters can be specified using the <code dir="ltr">OPTIONS</code> clause. These parameters are described in greater detail in <a href="ldr_params.htm#g1014550">Chapter 8</a>.</p>
<pre dir="ltr">
BINDSIZE = <span class="italic">n</span>
COLUMNARRAYROWS = <span class="italic">n</span>
DATE_CACHE = <span class="codeinlineitalic">n</span>
DIRECT = {TRUE | FALSE} 
ERRORS = <span class="italic">n</span>
EXTERNAL_TABLE = {NOT_USED | GENERATE_ONLY | EXECUTE}
FILE
LOAD = <span class="italic">n</span> 
MULTITHREADING = {TRUE | FALSE}
PARALLEL = {TRUE | FALSE}
READSIZE = <span class="italic">n</span>
RESUMABLE = {TRUE | FALSE}
RESUMABLE_NAME = 'text string'
RESUMABLE_TIMEOUT = <span class="italic">n</span>
ROWS =<span class="italic"> n </span>
SILENT = {HEADER | FEEDBACK | ERRORS | DISCARDS | PARTITIONS | ALL} 
SKIP = <span class="italic">n   </span>
SKIP_INDEX_MAINTENANCE = {TRUE | FALSE}
SKIP_UNUSABLE_INDEXES = {TRUE | FALSE}
STREAMSIZE = <span class="italic">n</span>
</pre>
<p>The following is an example use of the <code dir="ltr">OPTIONS</code> clause that you could use in a SQL*Loader control file:</p>
<pre dir="ltr">
OPTIONS (BINDSIZE=100000, SILENT=(ERRORS, FEEDBACK) )
</pre>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
Parameter values specified on the command line override parameter values specified in the control file <code dir="ltr">OPTIONS</code> clause.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1004816"></a>
<div id="SUTIL1053" class="sect1">
<h2 class="sect1">Specifying File Names and Object Names</h2>
<p>In general, <a id="sthref539"></a><a id="sthref540"></a><a id="sthref541"></a><a id="sthref542"></a>SQL*Loader follows the SQL standard for specifying object names (for example, table and column names). The information in this section discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1004835">File Names That Conflict with SQL and SQL*Loader Reserved Words</a></p>
</li>
<li>
<p><a href="#i1006585">Specifying SQL Strings</a></p>
</li>
<li>
<p><a href="#i1004868">Operating System Considerations</a></p>
</li>
</ul>
<a id="i1004835"></a>
<div id="SUTIL1054" class="sect2">
<h3 class="sect2">File Names That Conflict with SQL and SQL*Loader Reserved Words</h3>
<p><a id="sthref543"></a>SQL and SQL*Loader reserved words must be specified within double quotation marks. The only SQL*Loader reserved word is <code dir="ltr">CONSTANT.</code></p>
<p>You must use double quotation marks if the object name contains special characters other than those recognized by SQL ($, #, _), or if the name is case sensitive.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1006585"></a>
<div id="SUTIL1055" class="sect2">
<h3 class="sect2">Specifying SQL Strings</h3>
<p><a id="sthref544"></a><a id="sthref545"></a>You must specify SQL strings within double quotation marks. The SQL string applies SQL operators to data fields.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_field_list.htm#i1008150">"Applying SQL Operators to Fields"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1004868"></a>
<div id="SUTIL1056" class="sect2">
<h3 class="sect2">Operating System Considerations</h3>
<p>The following sections discuss situations in which your course of action may depend on the operating system you are using.</p>
<div id="SUTIL1057" class="sect3"><a id="sthref546"></a>
<h4 class="sect3">Specifying a Complete Path</h4>
<p><a id="sthref547"></a><a id="sthref548"></a>If you encounter problems when trying to specify a complete path name, it may be due to an operating system-specific incompatibility caused by special characters in the specification. In many cases, specifying the path name within single quotation marks prevents errors.</p>
</div>
<!-- class="sect3" -->
<a id="i1004876"></a>
<div id="SUTIL1058" class="sect3">
<h4 class="sect3">Backslash Escape Character</h4>
<p><a id="sthref549"></a><a id="sthref550"></a><a id="sthref551"></a>In DDL syntax, you can place a double quotation mark inside a string delimited by double quotation marks by preceding it with the escape character, "\" (if the escape character is allowed on your operating system). The same rule applies when single quotation marks are required in a string delimited by single quotation marks.</p>
<p>For example, <code dir="ltr">homedir\data"norm\mydata</code> contains a double quotation mark. Preceding the double quotation mark with a backslash indicates that the double quotation mark is to be taken literally:</p>
<pre dir="ltr">
INFILE 'homedir\data\"norm\mydata'
</pre>
<p>You can also put the escape character itself into a string by entering it twice.</p>
<p>For example:</p>
<pre dir="ltr">
"so'\"far"     or  'so\'"far'     is parsed as   so'"far 
"'so\\far'"    or  '\'so\\far\''  is parsed as  'so\far' 
"so\\\\far"    or  'so\\\\far'    is parsed as   so\\far 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
A double quotation mark in the initial position cannot be preceded by an escape character. Therefore, you should avoid creating strings with an initial quotation mark.</div>
</div>
<!-- class="sect3" -->
<div id="SUTIL1059" class="sect3"><a id="sthref552"></a>
<h4 class="sect3">Nonportable Strings</h4>
<p>There are two kinds of character strings in a SQL*Loader control file that are not portable between operating systems: <span class="italic">filename</span> and <span class="italic">file processing option</span> strings. When you convert to a different operating system, you will probably need to modify these strings. All other strings in a SQL*Loader control file should be portable between operating systems.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1060" class="sect3"><a id="sthref553"></a>
<h4 class="sect3">Using the Backslash as an Escape Character</h4>
<p>If your operating system uses the backslash character to separate directories in a path name, <span class="italic">and</span> if the release of the Oracle database running on your operating system implements the backslash escape character for file names and other nonportable strings, then you must specify double backslashes in your path names and use single quotation marks.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1061" class="sect3"><a id="sthref554"></a>
<h4 class="sect3">Escape Character Is Sometimes Disallowed</h4>
<p>The release of the Oracle database running on your operating system may not implement the escape character for nonportable strings. When the escape character is disallowed, a backslash is treated as a normal character, rather than as an escape character (although it is still usable in all other strings). Then path names such as the following can be specified normally:</p>
<pre dir="ltr">
INFILE 'topdir\mydir\myfile'
</pre>
<p>Double backslashes are not needed.</p>
<p>Because the backslash is not recognized as an escape character, strings within single quotation marks cannot be embedded inside another string delimited by single quotation marks. This rule also holds for double quotation marks. A string within double quotation marks cannot be embedded inside another string delimited by double quotation marks.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1015627"></a>
<div id="SUTIL1062" class="sect1">
<h2 class="sect1">Identifying XMLType Tables</h2>
<p>As of Oracle Database 10<span class="italic">g</span>, the <code dir="ltr">XMLTYPE</code> clause<a id="sthref555"></a><a id="sthref556"></a> is available for use in a SQL*Loader control file. This clause is of the format <code dir="ltr">XMLTYPE(field name)</code>. It is used to identify XMLType tables so that the correct SQL statement can be constructed. <a href="#i1013712">Example 9-2</a> shows how the <code dir="ltr">XMLTYPE</code> clause can be used in a SQL*Loader control file to load data into a schema-based XMLType table.</p>
<div id="SUTIL3326" class="example">
<p class="titleinexample"><a id="i1013712"></a>Example 9-2 Identifying XMLType Tables in the SQL*Loader Control File</p>
<p>The XML schema definition is as follows. It registers the XML schema, <code dir="ltr">xdb_user.xsd</code>, in the Oracle XML DB, and then creates the table, <code dir="ltr">xdb_tab5</code>.</p>
<pre dir="ltr">
begin dbms_xmlschema.registerSchema('xdb_user.xsd',
'&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:xdb="http://xmlns.oracle.com/xdb"&gt;
 &lt;xs:element name = "Employee"
        xdb:defaultTable="EMP31B_TAB"&gt;
   &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name = "EmployeeId" type = "xs:positiveInteger"/&gt;
      &lt;xs:element name = "Name" type = "xs:string"/&gt;
      &lt;xs:element name = "Salary" type = "xs:positiveInteger"/&gt;
      &lt;xs:element name = "DeptId" type = "xs:positiveInteger"
             xdb:SQLName="DEPTID"/&gt;
    &lt;/xs:sequence&gt;
   &lt;/xs:complexType&gt;
 &lt;/xs:element&gt;
&lt;/xs:schema&gt;',
TRUE, TRUE, FALSE); end;
/
</pre>
<p>The table is defined as follows:</p>
<pre dir="ltr">
CREATE TABLE xdb_tab5 OF XMLTYPE XMLSCHEMA "xdb_user.xsd" ELEMENT "Employee";
</pre>
<p>The control file used to load data into the table, <code dir="ltr">xdb_tab5</code>, looks as follows. It loads XMLType data using the registered XML schema, <code dir="ltr">xdb_user.xsd</code>. The <code dir="ltr">XMLTYPE</code> clause is used to identify this table as an XMLType table. Either direct path or conventional mode can be used to load the data into the table.</p>
<pre dir="ltr">
LOAD DATA
INFILE *
INTO TABLE xdb_tab5 TRUNCATE
xmltype(xmldata)
(
  xmldata   char(4000)
)
BEGINDATA
&lt;Employee&gt;  &lt;EmployeeId&gt;111&lt;/EmployeeId&gt;  &lt;Name&gt;Ravi&lt;/Name&gt;  &lt;Salary&gt;100000&lt;/Sal
ary&gt;  &lt;DeptId&gt;12&lt;/DeptId&gt;&lt;/Employee&gt;
&lt;Employee&gt;  &lt;EmployeeId&gt;112&lt;/EmployeeId&gt;  &lt;Name&gt;John&lt;/Name&gt;  &lt;Salary&gt;150000&lt;/Sal
ary&gt;  &lt;DeptId&gt;12&lt;/DeptId&gt;&lt;/Employee&gt;
&lt;Employee&gt;  &lt;EmployeeId&gt;113&lt;/EmployeeId&gt;  &lt;Name&gt;Michael&lt;/Name&gt;  &lt;Salary&gt;75000&lt;/S
alary&gt;  &lt;DeptId&gt;12&lt;/DeptId&gt;&lt;/Employee&gt;
&lt;Employee&gt;  &lt;EmployeeId&gt;114&lt;/EmployeeId&gt;  &lt;Name&gt;Mark&lt;/Name&gt;  &lt;Salary&gt;125000&lt;/Sal
ary&gt;  &lt;DeptId&gt;16&lt;/DeptId&gt;&lt;/Employee&gt;
&lt;Employee&gt;  &lt;EmployeeId&gt;115&lt;/EmployeeId&gt;  &lt;Name&gt;Aaron&lt;/Name&gt;  &lt;Salary&gt;600000&lt;/Sa
lary&gt;  &lt;DeptId&gt;16&lt;/DeptId&gt;&lt;/Employee&gt;
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADXDB2900" href="../../appdev.112/e23094/xdb25loa.htm#ADXDB2900"><span class="italic">Oracle XML DB Developer's Guide</span></a> for more information about loading XML data using SQL*Loader</div>
</div>
<!-- class="sect1" -->
<a id="i1008015"></a>
<div id="SUTIL1063" class="sect1">
<h2 class="sect1">Specifying Data Files<a id="sthref557"></a><a id="sthref558"></a></h2>
<p>To specify a data file that contains the data to be loaded, use the <code dir="ltr">INFILE</code> keyword, followed by the file name and optional file processing options string. You can specify multiple files by using multiple <code dir="ltr">INFILE</code> keywords.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You can also specify the data file from the command line, using the <code dir="ltr">DATA</code> parameter described in <a href="ldr_params.htm#i1004682">"Command-Line Parameters"</a>. A file name specified on the command line overrides the first <code dir="ltr">INFILE</code> clause in the control file.</div>
<p>If no file name is specified, then the file name defaults to the control file name with an extension or file type of .<code dir="ltr">dat</code>. <a id="sthref559"></a></p>
<p>If the control file itself contains the data to be loaded, then specify an asterisk (*). This specification is described in <a href="#i1005017">"Identifying Data in the Control File with BEGINDATA"</a> .</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The information in this section applies only to primary data files. It does not apply to LOBFILEs or SDFs.
<p>For information about LOBFILES, see <a href="ldr_loading.htm#i1006993">"Loading LOB Data from LOBFILEs"</a>.</p>
<p>For information about SDFs, see <a href="ldr_loading.htm#i1007276">"Secondary Data Files (SDFs)"</a>.</p>
</div>
<p>The syntax for <code dir="ltr">INFILE</code> is as follows:</p>
<img width="385" height="64" src="img/infile.gif" alt="Description of infile.gif follows" /><br />
<a id="sthref560" href="img_text/infile.htm">Description of the illustration ''infile.gif''</a><br />
<br />
<p><a href="#g1022822">Table 9-1</a> describes the parameters for the <code dir="ltr">INFILE</code> keyword.</p>
<div id="SUTIL3327" class="tblformal">
<p class="titleintable"><a id="sthref561"></a><a id="g1022822"></a>Table 9-1 Parameters for the INFILE Keyword</p>
<table class="cellalignment1394" title="Parameters for the INFILE Keyword" summary="Parameters for the INFILE clause" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t9">Parameter</th>
<th class="cellalignment1395" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t9" headers="r1c1-t9">
<p><code dir="ltr">INFILE</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t9 r1c2-t9">
<p>Specifies that a data file specification follows.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t9" headers="r1c1-t9">
<p><code dir="ltr"><span class="codeinlineitalic">input_filename</span></code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t9 r1c2-t9">
<p>Name of the file containing the data.</p>
<p>Any spaces or punctuation marks in the file name must be enclosed in single quotation marks. See <a href="#i1004816">"Specifying File Names and Object Names"</a>.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t9" headers="r1c1-t9">
<p><code dir="ltr">*</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t9 r1c2-t9">
<p>If your data is in the control file itself, then use an asterisk instead of the file name. If you have data in the control file and in data files, then you must specify the asterisk first in order for the data to be read.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t9" headers="r1c1-t9">
<p><code dir="ltr"><span class="codeinlineitalic">os_file_proc_clause</span></code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t9 r1c2-t9">
<p>This is the file-processing options string. It specifies the data file format. It also optimizes data file reads. The syntax used for this string is specific to your operating system. See <a href="#i1005062">"Specifying Data File Format and Buffering"</a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<div id="SUTIL1064" class="sect2"><a id="sthref562"></a>
<h3 class="sect2">Examples of INFILE Syntax</h3>
<p>The following list shows different ways you can specify <code dir="ltr">INFILE</code> syntax:</p>
<ul>
<li>
<p>Data contained in the control file itself:</p>
<pre dir="ltr">
INFILE  *
</pre></li>
<li>
<p>Data contained in a file named <code dir="ltr">sample</code> with a default extension of .<code dir="ltr">dat:</code></p>
<pre dir="ltr">
INFILE  sample
</pre></li>
<li>
<p>Data contained in a file named <code dir="ltr">datafile</code>.<code dir="ltr">dat</code> with a full path specified:</p>
<pre dir="ltr">
INFILE 'c:/topdir/subdir/datafile.dat' 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
file names that include spaces or punctuation marks must be enclosed in single quotation marks.</div>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1065" class="sect2"><a id="sthref563"></a>
<h3 class="sect2">Specifying Multiple Data Files</h3>
<p><a id="sthref564"></a><a id="sthref565"></a>To load data from multiple data files in one SQL*Loader run, use an <code dir="ltr">INFILE</code> clause for each data file. Data files need not have the same file processing options, although the layout of the records must be identical. For example, two files could be specified with completely different file processing options strings, and a third could consist of data in the control file.</p>
<p>You can also specify a separate discard file and bad file for each data file. In such a case, the separate bad files and discard files must be declared immediately after each data file name. For example, the following excerpt from a control file specifies four data files with separate bad and discard files:</p>
<pre dir="ltr">
INFILE  mydat1.dat  BADFILE  mydat1.bad  DISCARDFILE mydat1.dis 
INFILE  mydat2.dat 
INFILE  mydat3.dat  DISCARDFILE  mydat3.dis 
INFILE  mydat4.dat  DISCARDMAX  10 0
</pre>
<ul>
<li>
<p>For <code dir="ltr">mydat1.dat,</code> both a bad file and discard file are explicitly specified. Therefore both files are created, as needed.</p>
</li>
<li>
<p>For <code dir="ltr">mydat2.dat,</code> neither a bad file nor a discard file is specified. Therefore, only the bad file is created, as needed. If created, the bad file has the default file name and extension <code dir="ltr">mydat2.bad</code>. The discard file is <span class="italic">not</span> created, even if rows are discarded.</p>
</li>
<li>
<p>For <code dir="ltr">mydat3.dat,</code> the default bad file is created, if needed. A discard file with the specified name (<code dir="ltr">mydat3.dis</code>) is created, as needed.</p>
</li>
<li>
<p>For <code dir="ltr">mydat4.dat,</code> the default bad file is created, if needed. Because the <code dir="ltr">DISCARDMAX</code> option is used, SQL*Loader assumes that a discard file is required and creates it with the default name <code dir="ltr">mydat4.dsc</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005017"></a>
<div id="SUTIL1066" class="sect1">
<h2 class="sect1"><a id="sthref566"></a><a id="sthref567"></a><a id="sthref568"></a>Identifying Data in the Control File with BEGINDATA</h2>
<p>If the data is included in the control file itself, then the <code dir="ltr">INFILE</code> clause is followed by an asterisk rather than a file name. The actual data is placed in the control file after the load configuration specifications.</p>
<p>Specify the <code dir="ltr">BEGINDATA</code> statement before the first data record. The syntax is:</p>
<pre dir="ltr">
BEGINDATA 
data
</pre>
<p>Keep the following points in mind when using the <code dir="ltr">BEGINDATA</code> statement:</p>
<ul>
<li>
<p>If you omit the <code dir="ltr">BEGINDATA</code> statement but include data in the control file, then SQL*Loader tries to interpret your data as control information and issues an error message. If your data is in a separate file, then do not use the <code dir="ltr">BEGINDATA</code> statement.</p>
</li>
<li>
<p>Do not use spaces or other characters on the same line as the <code dir="ltr">BEGINDATA</code> statement, or the line containing <code dir="ltr">BEGINDATA</code> will be interpreted as the first line of data.</p>
</li>
<li>
<p>Do not put comments after <code dir="ltr">BEGINDATA,</code> or they will also be interpreted as data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1008015">"Specifying Data Files"</a> for an explanation of using <code dir="ltr">INFILE</code></p>
</li>
<li>
<p>Case study 1, Loading Variable-Length Data (see <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1005062"></a>
<div id="SUTIL1067" class="sect1">
<h2 class="sect1"><a id="sthref569"></a><a id="sthref570"></a><a id="sthref571"></a><a id="sthref572"></a>Specifying Data File Format and Buffering</h2>
<p>When configuring SQL*Loader, you can specify an operating system-dependent file processing options string (<code dir="ltr"><span class="codeinlineitalic">os_file_proc_clause</span></code>) in the control file to specify file format and buffering.</p>
<p>For example, suppose that your operating system has the following option-string syntax:</p>
<img width="388" height="37" src="img/recsize_spec.gif" alt="Description of recsize_spec.gif follows" /><br />
<a id="sthref573" href="img_text/recsize_spec.htm">Description of the illustration ''recsize_spec.gif''</a><br />
<br />
<p>In this syntax, <code dir="ltr">RECSIZE</code> is the size of a fixed-length record, and <code dir="ltr">BUFFERS</code> is the number of buffers to use for asynchronous I/O.</p>
<p>To declare a file named <code dir="ltr">mydata.dat</code> as a file that contains 80-byte records and instruct SQL*Loader to use 8 I/O buffers, you would use the following control file entry:</p>
<pre dir="ltr">
INFILE 'mydata.dat' "RECSIZE 80 BUFFERS 8" 
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
This example uses the recommended convention of single quotation marks for file names and double quotation marks for everything else.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NTQRF040" href="../../win.112/e10845/tools.htm#NTQRF040"><span class="italic">Oracle Database Platform Guide for Microsoft Windows</span></a> for information about using the <code dir="ltr"><span class="codeinlineitalic">os_file_proc_clause</span></code> on Windows systems.</div>
</div>
<!-- class="sect1" -->
<a id="i1005085"></a>
<div id="SUTIL1068" class="sect1">
<h2 class="sect1"><a id="sthref574"></a><a id="sthref575"></a><a id="sthref576"></a>Specifying the Bad File</h2>
<p>When SQL*Loader executes, it can create a file called a bad file or reject file in which it places records that were rejected because of formatting errors or because they caused Oracle errors. If you have specified that a bad file is to be created, then the following applies: <a id="sthref577"></a><a id="sthref578"></a><a id="sthref579"></a><a id="sthref580"></a><a id="sthref581"></a></p>
<ul>
<li>
<p>If one or more records are rejected, then the bad file is created and the rejected records are logged.</p>
</li>
<li>
<p>If no records are rejected, then the bad file is not created.</p>
</li>
<li>
<p>If the bad file is created, then it overwrites any existing file with the same name; ensure that you do not overwrite a file you want to retain.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
On some systems, a new version of the file may be created if a file with the same name already exists.</div>
</li>
</ul>
<p>To specify the name of the bad file, use the <code dir="ltr">BADFILE</code> clause, followed by a file name. If you do not specify a name for the bad file, then the name defaults to the name of the data file with an extension or file type of <code dir="ltr">.bad.</code> You can also specify the bad file from the command line with the <code dir="ltr">BAD</code> parameter described in <a href="ldr_params.htm#i1004682">"Command-Line Parameters"</a>.</p>
<p>A file name specified on the command line is associated with the first <code dir="ltr">INFILE</code> clause in the control file, overriding any bad file that may have been specified as part of that clause.</p>
<p>The bad file is created in the same record and file format as the data file so that you can reload the data after you correct it. For data files in stream record format, the record terminator that is found in the data file is also used in the bad file.</p>
<p>The syntax for the bad file is as follows:</p>
<img width="208" height="37" src="img/badfile.gif" alt="Description of badfile.gif follows" /><br />
<a id="sthref582" href="img_text/badfile.htm">Description of the illustration ''badfile.gif''</a><br />
<br />
<p>The <code dir="ltr">BADFILE</code> clause specifies that a file name for the bad file follows.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">filename</span></code> parameter specifies a valid file name specification for your platform. Any spaces or punctuation marks in the file name must be enclosed in single quotation marks.</p>
<div id="SUTIL1069" class="sect2"><a id="sthref583"></a>
<h3 class="sect2">Examples of Specifying a Bad File Name</h3>
<p>To specify a bad file with file name <code dir="ltr">sample</code> and default file extension or file type of <code dir="ltr">.bad,</code> enter the following in the control file:</p>
<pre dir="ltr">
BADFILE sample 
</pre>
<p>To specify a bad file with file name <code dir="ltr">bad0001</code> and file extension or file type of .<code dir="ltr">rej</code>, enter either of the following lines:</p>
<pre dir="ltr">
BADFILE bad0001.rej
BADFILE '/REJECT_DIR/bad0001.rej' 
</pre></div>
<!-- class="sect2" -->
<div id="SUTIL1070" class="sect2"><a id="sthref584"></a>
<h3 class="sect2">How Bad Files Are Handled with LOBFILEs and SDFs</h3>
<p>Data from LOBFILEs and SDFs is not written to a bad file when there are rejected rows. If there is an error loading a LOB, then the row is <span class="italic">not</span> rejected. Rather, the LOB column is left empty (not null with a length of zero (0) bytes). However, when the LOBFILE is being used to load an <code dir="ltr">XML</code> column and there is an error loading this LOB data, then the <code dir="ltr">XML</code> column is left as null.</p>
</div>
<!-- class="sect2" -->
<a id="i1005143"></a>
<div id="SUTIL1071" class="sect2">
<h3 class="sect2">Criteria for Rejected Records</h3>
<p>A record can be rejected for the following reasons:</p>
<ol>
<li>
<p>Upon insertion, the record causes an Oracle error (such as invalid data for a given datatype).</p>
</li>
<li>
<p>The record is formatted incorrectly so that SQL*Loader cannot find field boundaries.</p>
</li>
<li>
<p>The record violates a constraint or tries to make a unique index non-unique.</p>
</li>
</ol>
<p>If the data can be evaluated according to the <code dir="ltr">WHEN</code> clause criteria (even with unbalanced delimiters), then it is either inserted or rejected.</p>
<p>Neither a conventional path nor a direct path load will write a row to any table if it is rejected because of reason number 2 in the previous list.</p>
<p>A conventional path load will not write a row to any tables if reason number 1 or 3 in the previous list is violated for any one table. The row is rejected for that table and written to the reject file.</p>
<p>In a conventional path load, if the data file has a record that is being loaded into multiple tables and that record is rejected from at least one of the tables, then that record is not loaded into any of the tables.</p>
<p>The log file indicates the Oracle error for each rejected record. Case study 4 demonstrates rejected records. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005162"></a>
<div id="SUTIL1072" class="sect1">
<h2 class="sect1"><a id="sthref585"></a><a id="sthref586"></a>Specifying the Discard File</h2>
<p>During execution, SQL*Loader can create a discard file for records that do not meet any of the loading criteria. The records contained in this file are called discarded records. Discarded records do not satisfy any of the <code dir="ltr">WHEN</code> clauses specified in the control file. These records differ from rejected records. <span class="italic">Discarded records do not necessarily have any bad data</span>. No insert is attempted on a discarded record. <a id="sthref587"></a><a id="sthref588"></a></p>
<p>A discard file is created according to the following rules:</p>
<ul>
<li>
<p>You have specified a discard file name and one or more records fail to satisfy all of the <code dir="ltr">WHEN</code> clauses specified in the control file. (Be aware that if the discard file is created, then it overwrites any existing file with the same name.)</p>
</li>
<li>
<p>If no records are discarded, then a discard file is not created.</p>
</li>
</ul>
<p>To create a discard file from within a control file, specify any of the following: <code dir="ltr">DISCARDFILE</code> <code dir="ltr"><span class="codeinlineitalic">filename</span></code>, <code dir="ltr">DISCARDS</code>, or <code dir="ltr">DISCARDMAX</code>.</p>
<p>To create a discard file from the command line, specify either <code dir="ltr">DISCARD</code> or <code dir="ltr">DISCARDMAX</code>.</p>
<p>You can specify the discard file directly by specifying its name, or indirectly by specifying the maximum number of discards.</p>
<p>The discard file is created in the same record and file format as the data file. For data files in stream record format, the same record terminator that is found in the data file is also used in the discard file.</p>
<a id="i1010412"></a>
<div id="SUTIL1073" class="sect2">
<h3 class="sect2">Specifying the Discard File in the Control File</h3>
<p><a id="sthref589"></a>To specify the name of the file, use the <code dir="ltr">DISCARDFILE</code> clause, followed by the file name.</p>
<img width="477" height="70" src="img/discard.gif" alt="Description of discard.gif follows" /><br />
<a id="sthref590" href="img_text/discard.htm">Description of the illustration ''discard.gif''</a><br />
<br />
<p>The <code dir="ltr">DISCARDFILE</code> clause specifies that a discard file name follows.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">filename</span></code> parameter specifies a valid file name specification for your platform. Any spaces or punctuation marks in the file name must be enclosed in single quotation marks.</p>
<p>The default file name is the name of the data file, and the default file extension or file type is .<code dir="ltr">dsc</code>. A discard file name specified on the command line overrides one specified in the control file. If a discard file with that name already exists, then it is either overwritten or a new version is created, depending on your operating system.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1074" class="sect2"><a id="sthref591"></a>
<h3 class="sect2">Specifying the Discard File from the Command Line</h3>
<p>See <a href="ldr_params.htm#i1008202">"DISCARD (file name)"</a> for information about how to specify a discard file from the command line. <a id="sthref592"></a></p>
<p>A file name specified on the command line overrides any discard file that you may have specified in the control file.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1075" class="sect2"><a id="sthref593"></a>
<h3 class="sect2">Examples of Specifying a Discard File Name</h3>
<p>The following list shows different ways you can specify a name for the discard file from within the control file:</p>
<ul>
<li>
<p>To specify a discard file with file name <code dir="ltr">circular</code> and default file extension or file type of .<code dir="ltr">dsc</code>:</p>
<pre dir="ltr">
DISCARDFILE  circular 
</pre></li>
<li>
<p>To specify a discard file named <code dir="ltr">notappl</code> with the file extension or file type of .<code dir="ltr">may</code>:</p>
<pre dir="ltr">
DISCARDFILE notappl.may 
</pre></li>
<li>
<p>To specify a full path to the discard file <code dir="ltr">forget</code>.<code dir="ltr">me</code>:</p>
<pre dir="ltr">
DISCARDFILE  '/discard_dir/forget.me'
</pre></li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1005254"></a>
<div id="SUTIL1076" class="sect2">
<h3 class="sect2">Criteria for Discarded Records<a id="sthref594"></a><a id="sthref595"></a><a id="sthref596"></a></h3>
<p>If there is no <code dir="ltr">INTO TABLE</code> clause specified for a record, then the record is discarded. This situation occurs when every <code dir="ltr">INTO TABLE</code> clause in the SQL*Loader control file has a <code dir="ltr">WHEN</code> clause and, either the record fails to match any of them, or all fields are null.</p>
<p>No records are discarded if an <code dir="ltr">INTO TABLE</code> clause is specified without a <code dir="ltr">WHEN</code> clause. An attempt is made to insert every record into such a table. Therefore, records may be rejected, but none are discarded.</p>
<p>Case study 7, Extracting Data from a Formatted Report, provides an example of using a discard file. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1077" class="sect2"><a id="sthref597"></a>
<h3 class="sect2">How Discard Files Are Handled with LOBFILEs and SDFs</h3>
<p>Data from LOBFILEs and SDFs is not written to a discard file when there are discarded rows.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1078" class="sect2"><a id="sthref598"></a>
<h3 class="sect2">Limiting the Number of Discarded Records</h3>
<p><a id="sthref599"></a><a id="sthref600"></a><a id="sthref601"></a>You can limit the number of records to be discarded for each data file by specifying an <code dir="ltr"><span class="codeinlineitalic">integer</span></code> for either the <code dir="ltr">DISCARDS</code> or <code dir="ltr">DISCARDMAX</code> keyword.</p>
<p>When the discard limit is reached, processing of the data file terminates and continues with the next data file, if one exists.</p>
<p>You can specify a different number of discards for each data file. Or, if you specify the number of discards only once, then the maximum number of discards specified applies to all files.</p>
<p>If you specify a maximum number of discards, but no discard file name, then SQL*Loader creates a discard file with the default file name and file extension or file type.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005287"></a>
<div id="SUTIL1079" class="sect1">
<h2 class="sect1"><a id="sthref602"></a><a id="sthref603"></a><a id="sthref604"></a>Handling Different Character Encoding Schemes</h2>
<p>SQL*Loader supports different character encoding schemes (called character sets, or code pages). SQL*Loader uses features of Oracle's globalization support technology to handle the various single-byte and multibyte character encoding schemes available today.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink NLSPG" href="../e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a></div>
<p>The following sections provide a brief introduction to some of the supported character encoding schemes.</p>
<a id="i1005295"></a>
<div id="SUTIL1080" class="sect2">
<h3 class="sect2">Multibyte (Asian) Character Sets</h3>
<p><a id="sthref605"></a><a id="sthref606"></a>Multibyte character sets support Asian languages. Data can be loaded in multibyte format, and database object names (fields, tables, and so on) can be specified with multibyte characters. In the control file, comments and object names can also use multibyte characters.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1081" class="sect2"><a id="sthref607"></a>
<h3 class="sect2">Unicode Character Sets</h3>
<p>SQL*Loader supports loading data that is in a Unicode<a id="sthref608"></a> character set.</p>
<p>Unicode is a universal encoded character set that supports storage of information from most languages in a single character set. Unicode provides a unique code value for every character, regardless of the platform, program, or language. There are two different encodings for Unicode, UTF-16 and UTF-8.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In this manual, you will see the terms UTF-16 and UTF16 both used. The term UTF-16 is a general reference to UTF-16 encoding for Unicode. The term UTF16 (no hyphen) is the specific name of the character set and is what you should specify for the <code dir="ltr">CHARACTERSET</code> parameter when you want to use UTF-16 encoding. This also applies to UTF-8 and UTF8.</div>
<p>The UTF-16 Unicode encoding is a fixed-width multibyte encoding in which the character codes 0x0000 through 0x007F have the same meaning as the single-byte ASCII codes 0x00 through 0x7F.</p>
<p>The UTF-8 Unicode encoding is a variable-width multibyte encoding in which the character codes 0x00 through 0x7F have the same meaning as ASCII. A character in UTF-8 can be 1 byte, 2 bytes, or 3 bytes long.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>Case study 11, Loading Data in the Unicode Character Set (see <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</p>
</li>
<li>
<p><a class="olink NLSPG" href="../e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information about Unicode encoding</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="SUTIL1082" class="sect2"><a id="sthref609"></a>
<h3 class="sect2">Database Character Sets</h3>
<p>The Oracle database uses the database character set for data stored in SQL <code dir="ltr">CHAR</code> datatypes (<code dir="ltr">CHAR,</code> <code dir="ltr">VARCHAR2,</code> <code dir="ltr">CLOB,</code> and <code dir="ltr">LONG</code>), for identifiers such as table names, and for SQL statements and PL/SQL source code. Only single-byte character sets and varying-width character sets that include either ASCII or EBCDIC characters are supported as database character sets. Multibyte fixed-width character sets (for example, AL16UTF16) are not supported as the database character set.</p>
<p>An alternative character set can be used in the database for data stored in SQL <code dir="ltr">NCHAR</code> datatypes (<code dir="ltr">NCHAR,</code> <code dir="ltr">NVARCHAR2,</code> and <code dir="ltr">NCLOB</code>). This alternative character set is called the database national character set. Only Unicode character sets are supported as the database national character set.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1083" class="sect2"><a id="sthref610"></a>
<h3 class="sect2">Data File Character Sets</h3>
<p>By default, the data file is in the character set defined by the <code dir="ltr">NLS_LANG</code> parameter. The data file character sets supported with <code dir="ltr">NLS_LANG</code> are the same as those supported as database character sets. SQL*Loader supports all Oracle-supported character sets in the data file (even those not supported as database character sets).</p>
<p>For example, SQL*Loader supports multibyte fixed-width character sets (such as AL16UTF16 and JA16EUCFIXED) in the data file. SQL*Loader also supports UTF-16 encoding with little-endian byte ordering. However, the Oracle database supports only UTF-16 encoding with big-endian byte ordering (AL16UTF16) and only as a database national character set, not as a database character set.</p>
<p>The character set of the data file can be set up by using the <code dir="ltr">NLS_LANG</code> parameter or by specifying a SQL*Loader <code dir="ltr">CHARACTERSET</code> parameter.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1084" class="sect2"><a id="sthref611"></a>
<h3 class="sect2">Input Character Conversion<a id="sthref612"></a></h3>
<p>The default character set for all data files, if the <code dir="ltr">CHARACTERSET</code> parameter is not specified, is the session character set defined by the <code dir="ltr">NLS_LANG</code> parameter. The character set used in input data files can be specified with the <code dir="ltr">CHARACTERSET</code> parameter.</p>
<p>SQL*Loader can automatically convert data from the data file character set to the database character set or the database national character set, when they differ.</p>
<p>When data character set conversion is required, the target character set should be a superset of the source data file character set. Otherwise, characters that have no equivalent in the target character set are converted to replacement characters, often a default character such as a question mark (?). This causes loss of data.</p>
<p>The sizes of the database character types <code dir="ltr">CHAR</code> and <code dir="ltr">VARCHAR2</code> can be specified in bytes (byte-length semantics) or in characters (character-length semantics). If they are specified in bytes, and data character set conversion is required, then the converted values may take more bytes than the source values if the target character set uses more bytes than the source character set for any character that is converted. This will result in the following error message being reported if the larger target value exceeds the size of the database column:</p>
<pre dir="ltr">
ORA-01401: inserted value too large for column
</pre>
<p>You can avoid this problem by specifying the database column size in characters and also by using character sizes in the control file to describe the data. Another way to avoid this problem is to ensure that the maximum column size is large enough, in bytes, to hold the converted value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts f</span></a>or more information about character-length semantics in the database</p>
</li>
<li>
<p><a href="#i1008619">"Character-Length Semantics"</a></p>
</li>
<li>
<p><a class="olink NLSPG" href="../e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a></p>
</li>
</ul>
</div>
<div id="SUTIL1085" class="sect3"><a id="sthref613"></a>
<h4 class="sect3">Considerations When Loading Data into VARRAYs or Primary-Key-Based REFs</h4>
<p>If you use SQL*Loader conventional path or the Oracle Call Interface (OCI) to load data into <code dir="ltr">VARRAY</code>s or into primary-key-based <code dir="ltr">REF</code>s, and the data being loaded is in a different character set than the database character set, then problems such as the following might occur:</p>
<ul>
<li>
<p>Rows might be rejected because a field is too large for the database column, but in reality the field is not too large.</p>
</li>
<li>
<p>A load might be abnormally terminated without any rows being loaded, when only the field that really was too large should have been rejected.</p>
</li>
<li>
<p>Rows might be reported as loaded correctly, but the primary-key-based <code dir="ltr">REF</code> columns are returned as blank when they are selected with SQL*Plus.</p>
</li>
</ul>
<p>To avoid these problems, set the client character set (using the <code dir="ltr">NLS_LANG</code> environment variable) to the database character set before you load the data.</p>
</div>
<!-- class="sect3" -->
<a id="i1008293"></a>
<div id="SUTIL1086" class="sect3">
<h4 class="sect3">CHARACTERSET Parameter</h4>
<p>Specifying the <code dir="ltr">CHARACTERSET</code> parameter tells SQL*Loader the character set of the input data file. The default character set for all data files, if the <code dir="ltr">CHARACTERSET</code> parameter is not specified, is the session character set defined by the <code dir="ltr">NLS_LANG</code> parameter. Only character data (fields in the SQL*Loader datatypes <code dir="ltr">CHAR,</code> <code dir="ltr">VARCHAR,</code> <code dir="ltr">VARCHARC,</code> numeric <code dir="ltr">EXTERNAL</code>, and the datetime and interval datatypes) is affected by the character set of the data file.</p>
<p>The <code dir="ltr">CHARACTERSET</code> syntax is as follows:</p>
<pre dir="ltr">
CHARACTERSET char_set_name 
</pre>
<p>The <code dir="ltr"><span class="codeinlineitalic">char_set_name</span></code> variable specifies the character set name. Normally, the specified name must be the name of an Oracle-supported character set.</p>
<p>For UTF-16 Unicode encoding, use the name UTF16 rather than AL16UTF16. AL16UTF16, which is the supported Oracle character set name for UTF-16 encoded data, is only for UTF-16 data that is in big-endian byte order. However, because you are allowed to set up data using the byte order of the system where you create the data file, the data in the data file can be either big-endian or little-endian. Therefore, a different character set name (UTF16) is used. The character set name AL16UTF16 is also supported. But if you specify AL16UTF16 for a data file that has little-endian byte order, then SQL*Loader issues a warning message and processes the data file as big-endian.</p>
<p><a id="sthref614"></a>The <code dir="ltr">CHARACTERSET</code> parameter can be specified for primary data files and also for LOBFILEs and SDFs. All primary data files are assumed to be in the same character set. A <code dir="ltr">CHARACTERSET</code> parameter specified before the <code dir="ltr">INFILE</code> parameter applies to the entire list of primary data files. If the <code dir="ltr">CHARACTERSET</code> parameter is specified for primary data files, then the specified value will also be used as the default for LOBFILEs and SDFs. This default setting can be overridden by specifying the <code dir="ltr">CHARACTERSET</code> parameter with the LOBFILE or SDF specification.</p>
<p>The character set specified with the <code dir="ltr">CHARACTERSET</code> parameter does not apply to data in the control file (specified with <code dir="ltr">INFILE</code>). To load data in a character set other than the one specified for your session by the <code dir="ltr">NLS_LANG</code> parameter, you must place the data in a separate data file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_field_list.htm#i1011032">"Byte Ordering"</a></p>
</li>
<li>
<p><a class="olink NLSPG" href="../e10729/toc.htm"><span class="italic">Oracle Database Globalization Support Guide</span></a> for more information about the names of the supported character sets</p>
</li>
<li>
<p><a href="#i1005332">"Control File Character Set"</a></p>
</li>
<li>
<p>Case study 11, Loading Data in the Unicode Character Set, for an example of loading a data file that contains little-endian UTF-16 encoded data. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="i1005332"></a>
<div id="SUTIL1087" class="sect3">
<h4 class="sect3">Control File Character Set</h4>
<p>The SQL*Loader control file<a id="sthref615"></a> itself is assumed to be in the character set<a id="sthref616"></a> specified for your session by the <code dir="ltr">NLS_LANG</code> parameter. If the control file character set is different from the data file character set, then keep the following issue in mind. Delimiters and comparison clause values specified in the SQL*Loader control file as character strings are converted from the control file character set to the data file character set before any comparisons are made. To ensure that the specifications are correct, you may prefer to specify hexadecimal strings, rather than character string values.</p>
<p>If hexadecimal strings are used with a data file in the UTF-16 Unicode encoding, then the byte order is different on a big-endian versus a little-endian system. For example, "," (comma) in UTF-16 on a big-endian system is X'002c'. On a little-endian system it is X'2c00'. SQL*Loader requires that you always specify hexadecimal strings in big-endian format. If necessary, SQL*Loader swaps the bytes before making comparisons. This allows the same syntax to be used in the control file on both a big-endian and a little-endian system.</p>
<p>Record terminators for data files that are in stream format in the UTF-16 Unicode encoding default to "\n" in UTF-16 (that is, 0x000A on a big-endian system and 0x0A00 on a little-endian system). You can override these default settings by using the <code dir="ltr">"STR '</code><code dir="ltr"><span class="codeinlineitalic">char_str</span></code><code dir="ltr">'"</code> or the <code dir="ltr">"STR</code> <code dir="ltr"><span class="codeinlineitalic">x'hex_str'</span></code><code dir="ltr">"</code> specification on the <code dir="ltr">INFILE</code> line. For example, you could use either of the following to specify that <code dir="ltr">'ab'</code> is to be used as the record terminator, instead of <code dir="ltr"><span class="codeinlineitalic">'\n'</span></code>.</p>
<pre dir="ltr">
INFILE myfile.dat "STR 'ab'"

INFILE myfile.dat "STR x'00410042'"
</pre>
<p>Any data included after the <code dir="ltr">BEGINDATA</code> statement is also assumed to be in the character set specified for your session by the <code dir="ltr">NLS_LANG</code> parameter.</p>
<p>For the SQL*Loader datatypes <code dir="ltr">(CHAR,</code> <code dir="ltr">VARCHAR,</code> <code dir="ltr">VARCHARC,</code> <code dir="ltr">DATE,</code> and <code dir="ltr">EXTERNAL</code> numerics), SQL*Loader supports lengths of character fields that are specified in either bytes (byte-length semantics) or characters (character-length semantics). For example, the specification <code dir="ltr">CHAR(10)</code> in the control file can mean 10 bytes or 10 characters. These are equivalent if the data file uses a single-byte character set. However, they are often different if the data file uses a multibyte character set.</p>
<p>To avoid insertion errors caused by expansion of character strings during character set conversion, use character-length semantics in both the data file and the target database columns.</p>
</div>
<!-- class="sect3" -->
<a id="i1008619"></a>
<div id="SUTIL1088" class="sect3">
<h4 class="sect3">Character-Length Semantics<a id="sthref617"></a></h4>
<p>Byte-length semantics are the default for all data files except those that use the UTF16 character set (which uses character-length semantics by default). To override the default you can specify <code dir="ltr">CHAR</code> or <code dir="ltr">CHARACTER</code>, as shown in the following syntax:</p>
<img width="406" height="102" src="img/char_length.gif" alt="Description of char_length.gif follows" /><br />
<a id="sthref618" href="img_text/char_length.htm">Description of the illustration ''char_length.gif''</a><br />
<br />
<p>The <code dir="ltr">LENGTH</code> parameter is placed after the <code dir="ltr">CHARACTERSET</code> parameter in the SQL*Loader control file. The <code dir="ltr">LENGTH</code> parameter applies to the syntax specification for primary data files and also to LOBFILEs and secondary data files (SDFs). A <code dir="ltr">LENGTH</code> specification before the <code dir="ltr">INFILE</code> parameters applies to the entire list of primary data files. The <code dir="ltr">LENGTH</code> specification specified for the primary data file is used as the default for LOBFILEs and SDFs. You can override that default by specifying <code dir="ltr">LENGTH</code> with the LOBFILE or SDF specification. Unlike the <code dir="ltr">CHARACTERSET</code> parameter, the <code dir="ltr">LENGTH</code> parameter can also apply to data contained within the control file itself (that is, <code dir="ltr">INFILE *</code> syntax).</p>
<p>You can specify <code dir="ltr">CHARACTER</code> instead of <code dir="ltr">CHAR</code> for the <code dir="ltr">LENGTH</code> parameter.</p>
<p>If character-length semantics are being used for a SQL*Loader data file, then the following SQL*Loader datatypes will use character-length semantics:</p>
<ul>
<li>
<p><code dir="ltr">CHAR</code></p>
</li>
<li>
<p><code dir="ltr">VARCHAR</code></p>
</li>
<li>
<p><code dir="ltr">VARCHARC</code></p>
</li>
<li>
<p><code dir="ltr">DATE</code></p>
</li>
<li>
<p><code dir="ltr">EXTERNAL</code> numerics (<code dir="ltr">INTEGER</code>, <code dir="ltr">FLOAT</code>, <code dir="ltr">DECIMAL</code>, and <code dir="ltr">ZONED</code>)</p>
</li>
</ul>
<p>For the <code dir="ltr">VARCHAR</code> datatype, the length subfield is still a binary <code dir="ltr">SMALLINT</code> length subfield, but its value indicates the length of the character string in characters.</p>
<p>The following datatypes use byte-length semantics even if character-length semantics are being used for the data file, because the data is binary, or is in a special binary-encoded form in the case of <code dir="ltr">ZONED</code> and <code dir="ltr">DECIMAL</code>:</p>
<ul>
<li>
<p><code dir="ltr">INTEGER</code></p>
</li>
<li>
<p><code dir="ltr">SMALLINT</code></p>
</li>
<li>
<p><code dir="ltr">FLOAT</code></p>
</li>
<li>
<p><code dir="ltr">DOUBLE</code></p>
</li>
<li>
<p><code dir="ltr">BYTEINT</code></p>
</li>
<li>
<p><code dir="ltr">ZONED</code></p>
</li>
<li>
<p><code dir="ltr">DECIMAL</code></p>
</li>
<li>
<p><code dir="ltr">RAW</code></p>
</li>
<li>
<p><code dir="ltr">VARRAW</code></p>
</li>
<li>
<p><code dir="ltr">VARRAWC</code></p>
</li>
<li>
<p><code dir="ltr">GRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">GRAPHIC EXTERNAL</code></p>
</li>
<li>
<p><code dir="ltr">VARGRAPHIC</code></p>
</li>
</ul>
<p>The start and end arguments to the <code dir="ltr">POSITION</code> parameter are interpreted in bytes, even if character-length semantics are in use in a data file. This is necessary to handle data files that have a mix of data of different datatypes, some of which use character-length semantics, and some of which use byte-length semantics. It is also needed to handle position with the <code dir="ltr">VARCHAR</code> datatype, which has a <code dir="ltr">SMALLINT</code> length field and then the character data. The <code dir="ltr">SMALLINT</code> length field takes up a certain number of bytes depending on the system (usually 2 bytes), but its value indicates the length of the character string in characters.</p>
<p>Character-length semantics in the data file can be used independent of whether character-length semantics are used for the database columns. Therefore, the data file and the database columns can use either the same or different length semantics.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1089" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref619"></a>
<h3 class="sect2">Shift-sensitive Character Data</h3>
<p>In general, loading shift-sensitive character data can be much slower than loading simple ASCII or EBCDIC data. The fastest way to load shift-sensitive character data is to use fixed-position fields without delimiters. To improve performance, remember the following points:</p>
<ul>
<li>
<p>The field data must have an equal number of shift-out/shift-in bytes.</p>
</li>
<li>
<p>The field must start and end in single-byte mode.</p>
</li>
<li>
<p>It is acceptable for the first byte to be shift-out and the last byte to be shift-in.</p>
</li>
<li>
<p>The first and last characters cannot be multibyte.</p>
</li>
<li>
<p>If blanks are not preserved and multibyte-blank-checking is required, then a slower path is used. This can happen when the shift-in byte is the last byte of a field after single-byte blank stripping is performed.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008517"></a>
<div id="SUTIL1090" class="sect1">
<h2 class="sect1">Interrupted Load<a id="sthref620"></a><a id="sthref621"></a>s</h2>
<p>Loads are interrupted and discontinued for several reasons. A primary reason is space errors, in which SQL*Loader runs out of space for data rows or index entries. A load might also be discontinued because the maximum number of errors was exceeded, an unexpected error was returned to SQL*Loader from the server, a record was too long in the data file, or a Ctrl+C was executed.</p>
<p>The behavior of SQL*Loader when a load is discontinued varies depending on whether it is a conventional path load or a direct path load, and on the reason the load was interrupted. Additionally, when an interrupted load is continued, the use and value of the <code dir="ltr">SKIP</code> parameter can vary depending on the particular case. The following sections explain the possible scenarios.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_params.htm#i1008524">"SKIP (records to skip)"</a></div>
<a id="i1011891"></a>
<div id="SUTIL1091" class="sect2">
<h3 class="sect2">Discontinued Conventional Path Loads<a id="sthref622"></a><a id="sthref623"></a></h3>
<p>In a conventional path load, data is committed after all data in the bind array is loaded into all tables. If the load is discontinued, then only the rows that were processed up to the time of the last commit operation are loaded. There is no partial commit of data.</p>
</div>
<!-- class="sect2" -->
<a id="i1011892"></a>
<div id="SUTIL1092" class="sect2">
<h3 class="sect2">Discontinued Direct Path Loads<a id="sthref624"></a><a id="sthref625"></a></h3>
<p>In a direct path load, the behavior of a discontinued load varies depending on the reason the load was discontinued:</p>
<ul>
<li>
<p><a href="#CIAJBIAJ">Load Discontinued Because of Space Errors</a></p>
</li>
<li>
<p><a href="#CIACGCJE">Load Discontinued Because Maximum Number of Errors Exceeded</a></p>
</li>
<li>
<p><a href="#CIAEJEFJ">Load Discontinued Because of Fatal Errors</a></p>
</li>
<li>
<p><a href="#CIADABEE">Load Discontinued Because a Ctrl+C Was Issued</a></p>
</li>
</ul>
<a id="CIAJBIAJ"></a>
<div id="SUTIL1093" class="sect3">
<h4 class="sect3">Load Discontinued Because of Space Errors</h4>
<p>If a load is discontinued because of space errors, then the behavior of SQL*Loader depends on whether you are loading data into multiple subpartitions.</p>
<ul>
<li>
<p><span class="bold">Space errors when loading data into multiple subpartitions (that is, loading into a partitioned table, a composite partitioned table, or one partition of a composite partitioned table):</span></p>
<p>If space errors occur when loading into multiple subpartitions, then the load is discontinued and no data is saved unless <code dir="ltr">ROWS</code> has been specified (in which case, all data that was previously committed will be saved). The reason for this behavior is that it is possible rows might be loaded out of order. This is because each row is assigned (not necessarily in order) to a partition and each partition is loaded separately. If the load discontinues before all rows assigned to partitions are loaded, then the row for record "n" may have been loaded, but not the row for record "n-1". Therefore, the load cannot be continued by simply using <code dir="ltr">SKIP=N</code> .</p>
</li>
</ul>
<ul>
<li>
<p><span class="bold">Space errors when loading data into an unpartitioned table, one partition of a partitioned table, or one subpartition of a composite partitioned table:</span></p>
<p>If there is one <code dir="ltr">INTO TABLE</code> statement in the control file, then SQL*Loader commits as many rows as were loaded before the error occurred.</p>
<p>If there are multiple <code dir="ltr">INTO TABLE</code> statements in the control file, then SQL*Loader loads data already read from the data file into other tables and then commits the data.</p>
<p>In either case, this behavior is independent of whether the <code dir="ltr">ROWS</code> parameter was specified. When you continue the load, you can use the <code dir="ltr">SKIP</code> parameter to skip rows that have already been loaded. In the case of multiple <code dir="ltr">INTO TABLE</code> statements, a different number of rows could have been loaded into each table, so to continue the load you would need to specify a different value for the <code dir="ltr">SKIP</code> parameter for every table. SQL*Loader only reports the value for the <code dir="ltr">SKIP</code> parameter if it is the same for all tables.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CIACGCJE"></a>
<div id="SUTIL1094" class="sect3">
<h4 class="sect3">Load Discontinued Because Maximum Number of Errors Exceeded</h4>
<p>If the maximum number of errors is exceeded, then SQL*Loader stops loading records into any table and the work done to that point is committed. This means that when you continue the load, the value you specify for the <code dir="ltr">SKIP</code> parameter may be different for different tables. SQL*Loader reports the value for the <code dir="ltr">SKIP</code> parameter only if it is the same for all tables.</p>
</div>
<!-- class="sect3" -->
<a id="CIAEJEFJ"></a>
<div id="SUTIL1095" class="sect3">
<h4 class="sect3">Load Discontinued Because of Fatal Errors</h4>
<p>If a fatal error is encountered, then the load is stopped and no data is saved unless <code dir="ltr">ROWS</code> was specified at the beginning of the load. In that case, all data that was previously committed is saved. SQL*Loader reports the value for the <code dir="ltr">SKIP</code> parameter only if it is the same for all tables.</p>
</div>
<!-- class="sect3" -->
<a id="CIADABEE"></a>
<div id="SUTIL1096" class="sect3">
<h4 class="sect3">Load Discontinued Because a Ctrl+C Was Issued</h4>
<p>If SQL*Loader is in the middle of saving data when a Ctrl+C is issued, then it continues to do the save and then stops the load after the save completes. Otherwise, SQL*Loader stops the load without committing any work that was not committed already. This means that the value of the <code dir="ltr">SKIP</code> parameter will be the same for all tables.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1097" class="sect2"><a id="sthref626"></a>
<h3 class="sect2">Status of Tables and Indexes After an Interrupted Load</h3>
<p>When a load is discontinued, any data already loaded remains in the tables, and the tables are left in a valid state. If the conventional path is used, then all indexes are left in a valid state. <a id="sthref627"></a></p>
<p>If the direct path load method is used, then any indexes on the table are left in an unusable<a id="sthref628"></a> state.<a id="sthref629"></a> You can either rebuild or re-create the indexes before continuing, or after the load is restarted and completes.</p>
<p>Other indexes are valid if no other errors occurred. See <a href="ldr_modes.htm#i1007756">"Indexes Left in an Unusable State"</a> for other reasons why an index might be left in an unusable state.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1098" class="sect2"><a id="sthref630"></a>
<h3 class="sect2">Using the Log File to Determine Load Status</h3>
<p>The <a id="sthref631"></a>SQL*Loader log file tells you the state of the tables and indexes and the number of logical records already read from the input data file. Use this information to resume the load where it left off.</p>
</div>
<!-- class="sect2" -->
<a id="i1005460"></a>
<div id="SUTIL1099" class="sect2">
<h3 class="sect2">Continuing Single-Table Loads<a id="sthref632"></a><a id="sthref633"></a><a id="sthref634"></a></h3>
<p>When SQL*Loader must discontinue a direct path or conventional path load before it is finished, some rows have probably already been committed or marked with savepoints. To continue the discontinued load, use the <code dir="ltr">SKIP</code> parameter to specify the number of logical records that have already been processed by the previous load. At the time the load is discontinued, the value for <code dir="ltr">SKIP</code> is written to the log file in a message similar to the following:</p>
<pre dir="ltr">
Specify SKIP=1001 when continuing the load.
</pre>
<p>This message specifying the value of the <code dir="ltr">SKIP</code> parameter is preceded by a message indicating why the load was discontinued.</p>
<p>Note that for multiple-table loads, the value of the <code dir="ltr">SKIP</code> parameter is displayed only if it is the same for all tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_params.htm#i1008524">"SKIP (records to skip)"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005509"></a>
<div id="SUTIL1100" class="sect1">
<h2 class="sect1">Assembling Logical Records from Physical Records<a id="sthref635"></a><a id="sthref636"></a><a id="sthref637"></a><a id="sthref638"></a></h2>
<p>As of Oracle9<span class="italic">i</span>, user-defined record sizes larger than 64 KB are supported (see <a href="ldr_params.htm#i1004852">"READSIZE (read buffer size)"</a>). This reduces the need to break up logical records into multiple physical records. However, there may still be situations in which you may want to do so. At some point, when you want to combine those multiple physical records back into one logical record, you can use one of the following clauses, depending on your data:</p>
<ul>
<li>
<p><code dir="ltr">CONCATENATE</code></p>
</li>
<li>
<p><code dir="ltr">CONTINUEIF</code></p>
</li>
</ul>
<a id="i1011559"></a>
<div id="SUTIL1101" class="sect2">
<h3 class="sect2">Using CONCATENATE to Assemble Logical Records</h3>
<p>Use <code dir="ltr">CONCATENATE</code> when you want SQL*Loader to always combine the same number of physical records to form one logical record. In the following example, <code dir="ltr"><span class="codeinlineitalic">integer</span></code> specifies the number of physical records to combine.</p>
<pre dir="ltr">
CONCATENATE  integer 
</pre>
<p>The <code dir="ltr"><span class="codeinlineitalic">integer</span></code> value specified for <code dir="ltr">CONCATENATE</code> determines the number of physical record structures that SQL*Loader allocates for each row in the column array. In direct path loads, the default value for <code dir="ltr">COLUMNARRAYROWS</code> is large, so if you also specify a large value for <code dir="ltr">CONCATENATE</code>, then excessive memory allocation can occur. If this happens, you can improve performance by reducing the value of the <code dir="ltr">COLUMNARRAYROWS</code> parameter to lower the number of rows in a column array.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_params.htm#i1008321">"COLUMNARRAYROWS"</a></p>
</li>
<li>
<p><a href="ldr_modes.htm#i1008016">"Specifying the Number of Column Array Rows and Size of Stream Buffers"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007834"></a>
<div id="SUTIL1102" class="sect2">
<h3 class="sect2">Using CONTINUEIF to Assemble Logical Records</h3>
<p>Use <code dir="ltr">CONTINUEIF</code> if the number of physical records to be combined varies. The <code dir="ltr">CONTINUEIF</code> clause is followed by a condition that is evaluated for each physical record, as it is read. For example, two records might be combined if a pound sign (#) were in byte position 80 of the first record. If any other character were there, then the second record would not be added to the first.</p>
<p>The full syntax for <code dir="ltr">CONTINUEIF</code> adds even more flexibility:</p>
<img width="819" height="131" src="img/continueif.gif" alt="Description of continueif.gif follows" /><br />
<a id="sthref639" href="img_text/continueif.htm">Description of the illustration ''continueif.gif''</a><br />
<br />
<p><a href="#g1022570">Table 9-2</a> describes the parameters for the <code dir="ltr">CONTINUEIF</code> clause.</p>
<div id="SUTIL3328" class="tblformal">
<p class="titleintable"><a id="sthref640"></a><a id="g1022570"></a>Table 9-2 Parameters for the CONTINUEIF Clause</p>
<table class="cellalignment1394" title="Parameters for the CONTINUEIF Clause" summary="Parameters for the CONTINUEIF clause" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t23">Parameter</th>
<th class="cellalignment1395" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t23" headers="r1c1-t23">
<p><code dir="ltr">THIS</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t23 r1c2-t23">
<p>If the condition is true in the current record, then the next physical record is read and concatenated to the current physical record, continuing until the condition is false. If the condition is false, then the current physical record becomes the last physical record of the current logical record. <code dir="ltr">THIS</code> is the default.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t23" headers="r1c1-t23">
<p><code dir="ltr">NEXT</code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t23 r1c2-t23">
<p>If the condition is true in the next record, then the current physical record is concatenated to the current logical record, continuing until the condition is false.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t23" headers="r1c1-t23">
<p><code dir="ltr"><span class="codeinlineitalic">operator</span></code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t23 r1c2-t23">
<p>The supported operators are equal (=) and not equal (!= or &lt;&gt;).</p>
<p>For the equal operator, the field and comparison string must match exactly for the condition to be true. For the not equal operator, they can differ in any character.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t23" headers="r1c1-t23">
<p><code dir="ltr">LAST</code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t23 r1c2-t23">
<p>This test is similar to <code dir="ltr">THIS,</code> but the test is always against the last nonblank character. If the last nonblank character in the current physical record meets the test, then the next physical record is read and concatenated to the current physical record, continuing until the condition is false. If the condition is false in the current record, then the current physical record is the last physical record of the current logical record.</p>
<p><code dir="ltr">LAST</code> allows only a single character-continuation field (as opposed to <code dir="ltr">THIS</code> and <code dir="ltr">NEXT,</code> which allow multiple character-continuation fields).</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t23" headers="r1c1-t23">
<p><code dir="ltr"><span class="codeinlineitalic">pos_spec</span></code></p>
</td>
<td class="cellalignment1396" headers="r6c1-t23 r1c2-t23">
<p>Specifies the starting and ending column numbers in the physical record.</p>
<p>Column numbers start with 1. Either a hyphen or a colon is acceptable (<code dir="ltr"><span class="codeinlineitalic">start-end</span></code> or <code dir="ltr"><span class="codeinlineitalic">start:end</span></code>).</p>
<p>If you omit <code dir="ltr">end</code>, then the length of the continuation field is the length of the byte string or character string. If you use <code dir="ltr">end</code>, and the length of the resulting continuation field is not the same as that of the byte string or the character string, then the shorter one is padded. Character strings are padded with blanks, hexadecimal strings with zeros.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t23" headers="r1c1-t23">
<p><code dir="ltr"><span class="codeinlineitalic">str</span></code></p>
</td>
<td class="cellalignment1396" headers="r7c1-t23 r1c2-t23">
<p>A string of characters to be compared to the continuation field defined by start and end, according to the operator. The string must be enclosed in double or single quotation marks. The comparison is made character by character, blank padding on the right if necessary.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t23" headers="r1c1-t23">
<p><code dir="ltr"><span class="codeinlineitalic">X'hex-str'</span></code></p>
</td>
<td class="cellalignment1396" headers="r8c1-t23 r1c2-t23">
<p>A string of bytes in hexadecimal format used in the same way as <code dir="ltr">str.X'1FB033'</code> would represent the three bytes with values 1F, B0, and 33 (hexadecimal).</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r9c1-t23" headers="r1c1-t23">
<p><code dir="ltr">PRESERVE</code></p>
</td>
<td class="cellalignment1396" headers="r9c1-t23 r1c2-t23">
<p>Includes '<code dir="ltr"><span class="codeinlineitalic">char_string</span></code>' or <code dir="ltr"><span class="codeinlineitalic">X</span></code>'<code dir="ltr"><span class="codeinlineitalic">hex_string</span></code>' in the logical record. The default is to exclude them.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>The positions in the <code dir="ltr">CONTINUEIF</code> clause refer to positions in each physical record. This is the only time you refer to positions in physical records. All other references are to logical records.</p>
<p>For <code dir="ltr">CONTINUEIF</code> <code dir="ltr">THIS</code> and <code dir="ltr">CONTINUEIF</code> <code dir="ltr">LAST</code>, if the <code dir="ltr">PRESERVE</code> parameter<a id="sthref641"></a> is not specified, then the continuation field is removed from all physical records when the logical record is assembled. That is, data values are allowed to span the records with no extra characters (continuation characters) in the middle. For example, if <code dir="ltr">CONTINUEIF</code> <code dir="ltr">THIS(3:5)='***'</code> is specified, then positions <code dir="ltr">3</code> through <code dir="ltr">5</code> are removed from all records. This means that the continuation characters are removed if they are in positions <code dir="ltr">3</code> through <code dir="ltr">5</code> of the record. It also means that the characters in positions <code dir="ltr">3</code> through <code dir="ltr">5</code> are removed from the record even if the continuation characters are not in positions <code dir="ltr">3</code> through <code dir="ltr">5</code>.</p>
<p>For <code dir="ltr">CONTINUEIF</code> <code dir="ltr">THIS</code> and <code dir="ltr">CONTINUEIF</code> <code dir="ltr">LAST</code>, if the <code dir="ltr">PRESERVE</code> parameter is used, then the continuation field is kept in all physical records when the logical record is assembled.</p>
<p><code dir="ltr">CONTINUEIF</code> <code dir="ltr">LAST</code> differs from <code dir="ltr">CONTINUEIF</code> <code dir="ltr">THIS</code> and <code dir="ltr">CONTINUEIF</code> <code dir="ltr">NEXT</code>. For <code dir="ltr">CONTINUEIF</code> <code dir="ltr">LAST</code>, where the positions of the continuation field vary from record to record, the continuation field is never removed, even if <code dir="ltr">PRESERVE</code> is not specified.</p>
<p><a href="#i1007185">Example 9-3</a> through <a href="#i1010345">Example 9-6</a> show the use of <code dir="ltr">CONTINUEIF THIS</code> and <code dir="ltr">CONTINUEIF NEXT,</code> with and without the <code dir="ltr">PRESERVE</code> parameter.</p>
<div id="SUTIL3329" class="example">
<p class="titleinexample"><a id="i1007185"></a>Example 9-3 CONTINUEIF THIS Without the PRESERVE Parameter</p>
<p>Assume that you have physical records 14 bytes long and that a period represents a space:</p>
<pre dir="ltr">
        %%aaaaaaaa....
        %%bbbbbbbb....
        ..cccccccc....
        %%dddddddddd..
        %%eeeeeeeeee..
        ..ffffffffff..
</pre>
<p>In this example, the <code dir="ltr">CONTINUEIF THIS</code> clause does not use the <code dir="ltr">PRESERVE</code> parameter:</p>
<pre dir="ltr">
CONTINUEIF THIS (1:2) = '%%'
</pre>
<p>Therefore, the logical records are assembled as follows:</p>
<pre dir="ltr">
        aaaaaaaa....bbbbbbbb....cccccccc....
        dddddddddd..eeeeeeeeee..ffffffffff..
</pre>
<p>Note that columns 1 and 2 (for example, %% in physical record 1) are removed from the physical records when the logical records are assembled.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3330" class="example">
<p class="titleinexample"><a id="sthref642"></a>Example 9-4 CONTINUEIF THIS with the PRESERVE Parameter</p>
<p>Assume that you have the same physical records as in <a href="#i1007185">Example 9-3</a>.</p>
<p>In this example, the <code dir="ltr">CONTINUEIF THIS</code> clause uses the <code dir="ltr">PRESERVE</code> parameter:</p>
<pre dir="ltr">
CONTINUEIF THIS PRESERVE (1:2) = '%%'
</pre>
<p>Therefore, the logical records are assembled as follows:</p>
<pre dir="ltr">
        %%aaaaaaaa....%%bbbbbbbb......cccccccc....
        %%dddddddddd..%%eeeeeeeeee....ffffffffff..
</pre>
<p>Note that columns 1 and 2 are not removed from the physical records when the logical records are assembled.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3331" class="example">
<p class="titleinexample"><a id="i1007216"></a>Example 9-5 CONTINUEIF NEXT Without the PRESERVE Parameter</p>
<p>Assume that you have physical records 14 bytes long and that a period represents a space:</p>
<pre dir="ltr">
        ..aaaaaaaa....
        %%bbbbbbbb....
        %%cccccccc....
        ..dddddddddd..
        %%eeeeeeeeee..
        %%ffffffffff..
</pre>
<p>In this example, the <code dir="ltr">CONTINUEIF NEXT</code> clause does not use the <code dir="ltr">PRESERVE</code> parameter:</p>
<pre dir="ltr">
CONTINUEIF NEXT (1:2) = '%%'
</pre>
<p>Therefore, the logical records are assembled as follows (the same results as for <a href="#i1007185">Example 9-3</a>).</p>
<pre dir="ltr">
        aaaaaaaa....bbbbbbbb....cccccccc....
        dddddddddd..eeeeeeeeee..ffffffffff..
</pre></div>
<!-- class="example" -->
<div id="SUTIL3332" class="example">
<p class="titleinexample"><a id="i1010345"></a>Example 9-6 CONTINUEIF NEXT with the PRESERVE Parameter</p>
<p>Assume that you have the same physical records as in <a href="#i1007216">Example 9-5</a>.</p>
<p>In this example, the <code dir="ltr">CONTINUEIF NEXT</code> clause uses the <code dir="ltr">PRESERVE</code> parameter:</p>
<pre dir="ltr">
CONTINUEIF NEXT PRESERVE (1:2) = '%%'
</pre>
<p>Therefore, the logical records are assembled as follows:</p>
<pre dir="ltr">
        ..aaaaaaaa....%%bbbbbbbb....%%cccccccc....
        ..dddddddddd..%%eeeeeeeeee..%%ffffffffff..
</pre></div>
<!-- class="example" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Case study 4, Loading Combined Physical Records, for an example of the <code dir="ltr">CONTINUEIF</code> clause. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005614"></a>
<div id="SUTIL1103" class="sect1">
<h2 class="sect1">Loading Logical Records into Tables<a id="sthref643"></a><a id="sthref644"></a></h2>
<p>This section describes the way in which you specify:</p>
<ul>
<li>
<p>Which tables you want to load</p>
</li>
<li>
<p>Which records you want to load into them</p>
</li>
<li>
<p>Default data delimiters for those records</p>
</li>
<li>
<p>How to handle short records with missing data</p>
</li>
</ul>
<a id="i1005623"></a>
<div id="SUTIL1104" class="sect2">
<h3 class="sect2">Specifying Table Names</h3>
<p>The <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause of the <code dir="ltr">LOAD</code> <code dir="ltr">DATA</code> statement enables you to identify tables, fields, and datatypes. It defines the relationship between records in the data file and tables in the database. The specification of fields and datatypes is described in later sections.</p>
<div id="SUTIL1105" class="sect3"><a id="sthref645"></a>
<h4 class="sect3">INTO TABLE Clause</h4>
<p>Among its many functions, the <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause enables you to specify the table into which you load data. To load multiple tables, you include one <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause for each table you want to load.</p>
<p>To begin an <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause, use the keywords <code dir="ltr">INTO</code> <code dir="ltr">TABLE,</code> followed by the name of the Oracle table that is to receive the data.</p>
<p>The syntax is as follows:</p>
<img width="610" height="128" src="img/into_table1.gif" alt="Description of into_table1.gif follows" /><br />
<a id="sthref646" href="img_text/into_table1.htm">Description of the illustration ''into_table1.gif''</a><br />
<br />
<p>The table must already exist. The table name should be enclosed in double quotation marks if it is the same as any SQL or SQL*Loader reserved keyword, if it contains any special characters, or if it is case sensitive.</p>
<pre dir="ltr">
INTO TABLE scott."CONSTANT"
INTO TABLE scott."Constant" 
INTO TABLE scott."-CONSTANT" 
</pre>
<p>The user must have <code dir="ltr">INSERT</code> privileges for the table being loaded. If the table is not in the user's schema, then the user must either use a synonym to reference the table or include the schema name as part of the table name (for example, <code dir="ltr">scott.emp</code> refers to the table <code dir="ltr">emp</code> in the <code dir="ltr">scott</code> schema).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL*Loader considers the default schema<a id="sthref647"></a> to be whatever schema is current after your connect to the database finishes executing. This means that the default schema<a id="sthref648"></a> will not necessarily be the one you specified in the connect string, if there are logon triggers present that get executed during connection to a database.
<p>If you have a logon trigger<a id="sthref649"></a> that changes your current schema to a different one when you connect to a certain database, then SQL*Loader uses that new schema as the default.</p>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1010411"></a>
<div id="SUTIL1106" class="sect2">
<h3 class="sect2">Table-Specific Loading Method</h3>
<p>When you are loading a table, you can use the <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause to specify<a id="sthref650"></a> a table-specific loading method (<code dir="ltr">INSERT</code>, <code dir="ltr">APPEND</code>, <code dir="ltr">REPLACE</code>, or <code dir="ltr">TRUNCATE</code>) that applies only to that table. That method overrides the global table-loading method. The global table-loading method is <code dir="ltr">INSERT</code>, by default, unless a different method was specified before any <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses. The following sections discuss using these options to load data into empty and nonempty tables.</p>
<a id="i1006848"></a>
<div id="SUTIL1107" class="sect3">
<h4 class="sect3">Loading Data into Empty Tables</h4>
<p>If the tables you are loading into are empty, then use the <code dir="ltr">INSERT</code> option.</p>
<div id="SUTIL1108" class="sect4"><a id="sthref651"></a>
<h5 class="sect4">INSERT</h5>
<p><a id="sthref652"></a><a id="sthref653"></a><a id="sthref654"></a>This is SQL*Loader's default method. It requires the table to be empty before loading. SQL*Loader terminates with an error if the table contains rows. Case study 1, Loading Variable-Length Data, provides an example. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1006862"></a>
<div id="SUTIL1109" class="sect3">
<h4 class="sect3">Loading Data into Nonempty Tables</h4>
<p>If the tables you are loading into already contain data, then you have three options:</p>
<ul>
<li>
<p><code dir="ltr">APPEND</code></p>
</li>
<li>
<p><code dir="ltr">REPLACE</code></p>
</li>
<li>
<p><code dir="ltr">TRUNCATE</code></p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
<a id="sthref655"></a>When <code dir="ltr">REPLACE</code> or <code dir="ltr">TRUNCATE</code> is specified, the entire <span class="italic">table</span> is replaced, not just individual rows. After the rows are successfully deleted, a <code dir="ltr">COMMIT</code> statement is issued. You cannot recover the data that was in the table before the load, unless it was saved with Export or a comparable utility.</div>
</li>
</ul>
<div id="SUTIL1110" class="sect4"><a id="sthref656"></a>
<h5 class="sect4">APPEND</h5>
<p><a id="sthref657"></a><a id="sthref658"></a><a id="sthref659"></a>If data already exists in the table, then SQL*Loader appends the new rows to it. If data does not already exist, then the new rows are simply loaded. You must have <code dir="ltr">SELECT</code> privilege to use the <code dir="ltr">APPEND</code> option. Case study 3, Loading a Delimited Free-Format File, provides an example. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</div>
<!-- class="sect4" -->
<a id="i1008929"></a>
<div id="SUTIL1111" class="sect4">
<h5 class="sect4">REPLACE</h5>
<p>The <code dir="ltr">REPLACE</code> option executes a SQL <code dir="ltr">DELETE FROM TABLE</code> statement. <a id="sthref660"></a><a id="sthref661"></a><a id="sthref662"></a><a id="sthref663"></a>All rows in the table are deleted and the new data is loaded. The table must be in your schema, or you must have <code dir="ltr">DELETE</code> privilege on the table. Case study 4, Loading Combined Physical Records, provides an example. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
<p>The row deletes cause any delete triggers defined on the table to fire. If <a id="sthref664"></a><code dir="ltr">DELETE CASCADE</code> has been specified for the table, then the cascaded deletes are carried out. For more information about cascaded deletes, see the information about data integrity in <a class="olink CNCPT" href="../e40540/toc.htm"><span class="italic">Oracle Database Concepts.</span></a></p>
</div>
<!-- class="sect4" -->
<div id="SUTIL1112" class="sect4"><a id="sthref665"></a>
<h5 class="sect4">Updating Existing Rows</h5>
<p><a id="sthref666"></a><a id="sthref667"></a>The <code dir="ltr">REPLACE</code> method is a <span class="italic">table</span> replacement, not a replacement of individual rows. SQL*Loader does not update existing records, even if they have null columns. To update existing rows, use the following procedure:</p>
<ol>
<li>
<p>Load your data into a work table.</p>
</li>
<li>
<p>Use the SQL <code dir="ltr">UPDATE</code> statement with correlated subqueries.</p>
</li>
<li>
<p>Drop the work table.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<div id="SUTIL1113" class="sect4"><a id="sthref668"></a>
<h5 class="sect4">TRUNCATE</h5>
<p><a id="sthref669"></a>The <code dir="ltr">TRUNCATE</code> option executes a SQL <code dir="ltr">TRUNCATE TABLE</code> <code dir="ltr"><span class="codeinlineitalic">table_name</span></code> <code dir="ltr">REUSE STORAGE</code> statement, which means that the table's extents will be reused. The <code dir="ltr">TRUNCATE</code> option quickly and efficiently deletes all rows from a table or cluster, to achieve the best possible performance. For the <code dir="ltr">TRUNCATE</code> statement to operate, the table's referential integrity constraints must first be disabled. If they have not been disabled, then SQL*Loader returns an error.</p>
<p>Once the integrity constraints have been disabled, <a id="sthref670"></a><code dir="ltr">DELETE CASCADE</code> is no longer defined for the table. If the <code dir="ltr">DELETE CASCADE</code> functionality is needed, then the contents of the table must be manually deleted before the load begins.</p>
<p>The table must be in your schema, or you must have the <a id="sthref671"></a><code dir="ltr">DROP ANY TABLE</code> privilege.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the SQL statements discussed in this section</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1114" class="sect2"><a id="sthref672"></a>
<h3 class="sect2">Table-Specific OPTIONS Parameter</h3>
<p><a id="sthref673"></a>The <code dir="ltr">OPTIONS</code> parameter can be specified for individual tables in a parallel load. (It is valid only for a parallel load.)</p>
<p>The syntax for the <code dir="ltr">OPTIONS</code> parameter is as follows:</p>
<img width="355" height="37" src="img/into_table3.gif" alt="Description of into_table3.gif follows" /><br />
<a id="sthref674" href="img_text/into_table3.htm">Description of the illustration ''into_table3.gif''</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_modes.htm#i1008282">"Parameters for Parallel Direct Path Loads"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1005657"></a>
<div id="SUTIL1115" class="sect2">
<h3 class="sect2">Loading Records Based on a Condition</h3>
<p>You can choose to load or discard a logical record by using the <code dir="ltr">WHEN</code> clause to test a condition in the record. <a id="sthref675"></a><a id="sthref676"></a><a id="sthref677"></a></p>
<p>The <code dir="ltr">WHEN</code> clause appears after the table name and is followed by one or more field conditions. The syntax for <code dir="ltr">field_condition</code> is as follows:</p>
<img width="522" height="123" src="img/fld_cond.gif" alt="Description of fld_cond.gif follows" /><br />
<a id="sthref678" href="img_text/fld_cond.htm">Description of the illustration ''fld_cond.gif''</a><br />
<br />
<p>For example, the following clause indicates that any record with the value "q" in the fifth column position should be loaded:</p>
<pre dir="ltr">
WHEN (5) = 'q' 
</pre>
<p>A <code dir="ltr">WHEN</code> clause can contain several comparisons, provided each is preceded by <code dir="ltr">AND</code>. Parentheses are optional, but should be used for clarity with multiple comparisons joined by <code dir="ltr">AND</code>. For example:</p>
<pre dir="ltr">
WHEN (deptno = '10') AND (job = 'SALES') 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_field_list.htm#i1009345">"Using the WHEN, NULLIF, and DEFAULTIF Clauses"</a> for information about how SQL*Loader evaluates <code dir="ltr">WHEN</code> clauses, as opposed to <code dir="ltr">NULLIF</code> and <code dir="ltr">DEFAULTIF</code> clauses</p>
</li>
<li>
<p>Case study 5, Loading Data into Multiple Tables, for an example of using the <code dir="ltr">WHEN</code> clause (see <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</p>
</li>
</ul>
</div>
<div id="SUTIL1116" class="sect3"><a id="sthref679"></a>
<h4 class="sect3">Using the WHEN Clause with LOBFILEs and SDFs</h4>
<p>If a record with a LOBFILE or SDF is discarded, then SQL*Loader skips the corresponding data in that LOBFILE or SDF.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1117" class="sect2"><a id="sthref680"></a>
<h3 class="sect2">Specifying Default Data Delimiters</h3>
<p><a id="sthref681"></a><a id="sthref682"></a><a id="sthref683"></a>If all data fields are terminated similarly in the data file, then you can use the <code dir="ltr">FIELDS</code> clause to indicate the default delimiters. The syntax for the <code dir="ltr">fields_spec,</code> <code dir="ltr">termination_spec,</code> and <code dir="ltr">enclosure_spec</code> clauses is as follows:</p>
<div id="SUTIL1118" class="sect3"><a id="sthref684"></a>
<h4 class="sect3">fields_spec</h4>
<p><img width="525" height="98" src="img/fields_spec.gif" alt="Description of fields_spec.gif follows" /><br />
<a id="sthref685" href="img_text/fields_spec.htm">Description of the illustration ''fields_spec.gif''</a><br />
<br /></p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1119" class="sect3"><a id="sthref686"></a>
<h4 class="sect3">termination_spec</h4>
<p><img width="340" height="123" src="img/terminat.gif" alt="Description of terminat.gif follows" /><br />
<a id="sthref687" href="img_text/terminat.htm">Description of the illustration ''terminat.gif''</a><br />
<br /></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Terminator strings can contain one or more characters. Also, <code dir="ltr">TERMINATED BY EOF</code> applies only to loading LOBs from a LOBFILE.</div>
</div>
<!-- class="sect3" -->
<div id="SUTIL1120" class="sect3"><a id="sthref688"></a>
<h4 class="sect3">enclosure_spec</h4>
<p><img width="541" height="79" src="img/enclose.gif" alt="Description of enclose.gif follows" /><br />
<a id="sthref689" href="img_text/enclose.htm">Description of the illustration ''enclose.gif''</a><br />
<br /></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Enclosure strings can contain one or more characters.</div>
<p>You can override the delimiter for any given column by specifying it after the column name. Case study 3, Loading a Delimited Free-Format File, provides an example. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_field_list.htm#i1007368">"Specifying Delimiters"</a> for a complete description of the syntax</p>
</li>
<li>
<p><a href="ldr_loading.htm#i1006993">"Loading LOB Data from LOBFILEs"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005730"></a>
<div id="SUTIL1121" class="sect2">
<h3 class="sect2">Handling Short Records with Missing Data</h3>
<p><a id="sthref690"></a><a id="sthref691"></a><a id="sthref692"></a><a id="sthref693"></a>When the control file definition specifies more fields for a record than are present in the record, SQL*Loader must determine whether the remaining (specified) columns should be considered null or whether an error should be generated.</p>
<p>If the control file definition explicitly states that a field's starting position is beyond the end of the logical record, then SQL*Loader always defines the field as null. If a field is defined with a relative position (such as <code dir="ltr">dname</code> and <code dir="ltr">loc</code> in the following example), and the record ends before the field is found, then SQL*Loader could either treat the field as null or generate an error. SQL*Loader uses the presence or absence of the <code dir="ltr">TRAILING NULLCOLS</code> clause (shown in the following syntax diagram) to determine the course of action.</p>
<p><img width="675" height="70" src="img/into_table6.gif" alt="Description of into_table6.gif follows" /><br />
<a id="sthref694" href="img_text/into_table6.htm">Description of the illustration ''into_table6.gif''</a><br />
<br /></p>
<p><img width="246" height="37" src="img/into_table7.gif" alt="Description of into_table7.gif follows" /><br />
<a id="sthref695" href="img_text/into_table7.htm">Description of the illustration ''into_table7.gif''</a><br />
<br /></p>
<a id="i1007153"></a>
<div id="SUTIL1122" class="sect3">
<h4 class="sect3">TRAILING NULLCOLS Clause</h4>
<p>The <a id="sthref696"></a><code dir="ltr">TRAILING</code> <code dir="ltr">NULLCOLS</code> clause tells SQL*Loader to treat any relatively positioned columns that are not present in the record as null columns.</p>
<p>For example, consider the following data:</p>
<pre dir="ltr">
10 Accounting 
</pre>
<p>Assume that the preceding data is read with the following control file and the record ends after <code dir="ltr">dname:</code></p>
<pre dir="ltr">
INTO TABLE dept 
    TRAILING NULLCOLS 
( deptno CHAR TERMINATED BY " ", 
  dname  CHAR TERMINATED BY WHITESPACE, 
  loc    CHAR TERMINATED BY WHITESPACE 
) 
</pre>
<p>In this case, the remaining <code dir="ltr">loc</code> field is set to null. Without the <code dir="ltr">TRAILING NULLCOLS</code> clause, an error would be generated due to missing data.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Case study 7, Extracting Data from a Formatted Report, for an example of using <code dir="ltr">TRAILING NULLCOLS</code> (see <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies)</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005761"></a>
<div id="SUTIL1123" class="sect1">
<h2 class="sect1">Index Options<a id="sthref697"></a><a id="sthref698"></a></h2>
<p>This section describes the following SQL*Loader options that control how index entries are created:</p>
<ul>
<li>
<p><code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code></p>
</li>
<li>
<p><code dir="ltr">SINGLEROW</code></p>
</li>
</ul>
<a id="i1005768"></a>
<div id="SUTIL1124" class="sect2">
<h3 class="sect2">SORTED INDEXES Clause</h3>
<p><a id="sthref699"></a><a id="sthref700"></a><a id="sthref701"></a>The <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause applies to direct path loads. It tells SQL*Loader that the incoming data has already been sorted on the specified indexes, allowing SQL*Loader to optimize performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_modes.htm#i1007937">"SORTED INDEXES Clause"</a></div>
</div>
<!-- class="sect2" -->
<a id="CIAEIFCF"></a>
<div id="SUTIL1125" class="sect2">
<h3 class="sect2">SINGLEROW Option</h3>
<p><a id="sthref702"></a><a id="sthref703"></a><a id="sthref704"></a>The <code dir="ltr">SINGLEROW</code> option is intended for use during a direct path load with <code dir="ltr">APPEND</code> on systems with limited memory, or when loading a small number of records into a large table. This option inserts each index entry directly into the index, one record at a time.<a id="sthref705"></a></p>
<p>By default, SQL*Loader does not use <code dir="ltr">SINGLEROW</code> to append records to a table. Instead, index entries are put into a separate, temporary storage area and merged with the original index at the end of the load. This method achieves better performance and produces an optimal index, but it requires extra storage space. During the merge operation, the original index, the new index, and the space for new entries all simultaneously occupy storage space.</p>
<p>With the <code dir="ltr">SINGLEROW</code> option, storage space is not required for new index entries or for a new index. The resulting index may not be as optimal as a freshly sorted one, but it takes less space to produce. It also takes more time because additional UNDO information is generated for each index insert. This option is suggested for use when either of the following situations exists:</p>
<ul>
<li>
<p>Available storage is limited.</p>
</li>
<li>
<p>The number of records to be loaded is small compared to the size of the table (a ratio of 1:20 or less is recommended).</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005798"></a>
<div id="SUTIL1126" class="sect1">
<h2 class="sect1">Benefits of Using Multiple INTO TABLE Clauses<a id="sthref706"></a><a id="sthref707"></a><a id="sthref708"></a></h2>
<p>Multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses enable you to:</p>
<ul>
<li>
<p>Load data into different tables <a id="sthref709"></a><a id="sthref710"></a></p>
</li>
<li>
<p>Extract multiple logical records from a single input record <a id="sthref711"></a></p>
</li>
<li>
<p>Distinguish different input record formats <a id="sthref712"></a></p>
</li>
<li>
<p>Distinguish different input row object subtypes<a id="sthref713"></a></p>
</li>
</ul>
<p>In the first case, it is common for the <code dir="ltr">INTO TABLE</code> clauses to refer to the same table. This section illustrates the different ways to use multiple <code dir="ltr">INTO TABLE</code> clauses and shows you how to use the <code dir="ltr">POSITION</code> parameter.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A key point when using multiple <code dir="ltr">INTO TABLE</code> clauses is that <span class="italic">field scanning continues from where it left off</span> when a new <code dir="ltr">INTO TABLE</code> clause is processed. The remainder of this section details important ways to make use of that behavior. It also describes alternative ways of using fixed field locations or the <code dir="ltr">POSITION</code> parameter.</div>
<a id="i1005817"></a>
<div id="SUTIL1127" class="sect2">
<h3 class="sect2">Extracting Multiple Logical Records</h3>
<p>Some data storage and transfer media have fixed-length physical records. When the data records are short, more than one can be stored in a single, physical record to use the storage space efficiently.</p>
<p>In this example, SQL*Loader treats a single physical record in the input file as two logical records and uses two <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses to load the data into the <code dir="ltr">emp</code> table. For example, assume the data is as follows:</p>
<pre dir="ltr">
1119 Smith      1120 Yvonne 
1121 Albert     1130 Thomas 
</pre>
<p>The following control file extracts the logical records:</p>
<pre dir="ltr">
INTO TABLE emp 
     (empno POSITION(1:4)  INTEGER EXTERNAL, 
      ename POSITION(6:15) CHAR) 
INTO TABLE emp 
     (empno POSITION(17:20) INTEGER EXTERNAL, 
      ename POSITION(21:30) CHAR) 
</pre>
<div id="SUTIL1128" class="sect3"><a id="sthref714"></a>
<h4 class="sect3">Relative Positioning Based on Delimiters</h4>
<p><a id="sthref715"></a>The same record could be loaded with a different specification. The following control file uses relative positioning instead of fixed positioning. It specifies that each field is delimited by a single blank (" ") or with an undetermined number of blanks and tabs (<code dir="ltr">WHITESPACE</code>):</p>
<pre dir="ltr">
INTO TABLE emp 
     (empno INTEGER EXTERNAL TERMINATED BY " ", 
      ename CHAR             TERMINATED BY WHITESPACE) 
INTO TABLE emp 
     (empno INTEGER EXTERNAL TERMINATED BY " ", 
      ename CHAR)            TERMINATED BY WHITESPACE) 
</pre>
<p>The important point in this example is that the second <code dir="ltr">empno</code> field is found immediately after the first <code dir="ltr">ename</code>, although it is in a separate <code dir="ltr">INTO TABLE</code> clause. Field scanning does not start over from the beginning of the record for a new <code dir="ltr">INTO TABLE</code> clause. Instead, scanning continues where it left off.</p>
<p>To force record scanning to start in a specific location, you use the <code dir="ltr">POSITION</code> parameter. That mechanism is described in <a href="#i1005855">"Distinguishing Different Input Record Formats"</a> and in <a href="#i1005894">"Loading Data into Multiple Tables"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1005855"></a>
<div id="SUTIL1129" class="sect2">
<h3 class="sect2">Distinguishing Different Input Record Formats</h3>
<p><a id="sthref716"></a><a id="sthref717"></a>A single data file might contain records in a variety of formats. Consider the following data, in which <code dir="ltr">emp</code> and <code dir="ltr">dept</code> records are intermixed:</p>
<pre dir="ltr">
1 50   Manufacturing       &mdash; DEPT record 
2 1119 Smith      50       &mdash; EMP record 
2 1120 Snyder     50 
1 60   Shipping 
2 1121 Stevens    60 
</pre>
<p>A record ID field distinguishes between the two formats. Department records have a <code dir="ltr">1</code> in the first column, while employee records have a <code dir="ltr">2</code>. The following control file uses exact positioning to load this data:</p>
<pre dir="ltr">
INTO TABLE dept 
   WHEN recid = 1 
   (recid  FILLER POSITION(1:1)  INTEGER EXTERNAL,
    deptno POSITION(3:4)  INTEGER EXTERNAL, 
    dname  POSITION(8:21) CHAR) 
INTO TABLE emp 
   WHEN recid &lt;&gt; 1 
   (recid  FILLER POSITION(1:1)   INTEGER EXTERNAL,
    empno  POSITION(3:6)   INTEGER EXTERNAL, 
    ename  POSITION(8:17)  CHAR, 
    deptno POSITION(19:20) INTEGER EXTERNAL) 
</pre>
<div id="SUTIL1130" class="sect3"><a id="sthref718"></a>
<h4 class="sect3">Relative Positioning Based on the POSITION Parameter</h4>
<p><a id="sthref719"></a>The records in the previous example could also be loaded as delimited data. In this case, however, it is necessary to use the <code dir="ltr">POSITION</code> parameter. The following control file could be used:</p>
<pre dir="ltr">
INTO TABLE dept 
   WHEN recid = 1 
   (recid  FILLER INTEGER EXTERNAL TERMINATED BY WHITESPACE, 
    deptno INTEGER EXTERNAL TERMINATED BY WHITESPACE, 
    dname  CHAR TERMINATED BY WHITESPACE) 
INTO TABLE emp 
   WHEN recid &lt;&gt; 1 
   (recid  FILLER<span class="bold"> </span>POSITION(1) INTEGER EXTERNAL TERMINATED BY ' ', 
    empno  INTEGER EXTERNAL TERMINATED BY ' ' 
    ename  CHAR TERMINATED BY WHITESPACE, 
    deptno INTEGER EXTERNAL TERMINATED BY ' ') 
</pre>
<p>The <code dir="ltr">POSITION</code> parameter in the second <code dir="ltr">INTO TABLE</code> clause is necessary to load this data correctly. It causes field scanning to start over at column 1 when checking for data that matches the second format. Without it, SQL*Loader would look for the <code dir="ltr">recid</code> field after <code dir="ltr">dname</code>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1131" class="sect2"><a id="sthref720"></a>
<h3 class="sect2">Distinguishing Different Input Row Object Subtypes<a id="sthref721"></a></h3>
<p>A single data file may contain records made up of row objects inherited from the same base row object type. For example, consider the following simple object type and object table definitions, in which a nonfinal base object type is defined along with two object subtypes that inherit their row objects from the base type:</p>
<pre dir="ltr">
CREATE TYPE person_t AS OBJECT 
 (name    VARCHAR2(30), 
  age     NUMBER(3)) not final; 

CREATE TYPE employee_t UNDER person_t 
 (empid   NUMBER(5), 
  deptno  NUMBER(4), 
  dept    VARCHAR2(30)) not final; 

CREATE TYPE student_t UNDER person_t 
 (stdid   NUMBER(5), 
  major   VARCHAR2(20)) not final; 

CREATE TABLE persons OF person_t;
</pre>
<p>The following input data file contains a mixture of these row objects subtypes. A type ID field distinguishes between the three subtypes. <code dir="ltr">person_t</code> objects have a <code dir="ltr">P</code> in the first column, <code dir="ltr">employee_t</code> objects have an <code dir="ltr">E</code>, and <code dir="ltr">student_t</code> objects have an <code dir="ltr">S</code>.</p>
<pre dir="ltr">
P,James,31, 
P,Thomas,22, 
E,Pat,38,93645,1122,Engineering, 
P,Bill,19, 
P,Scott,55, 
S,Judy,45,27316,English, 
S,Karen,34,80356,History, 
E,Karen,61,90056,1323,Manufacturing, 
S,Pat,29,98625,Spanish, 
S,Cody,22,99743,Math, 
P,Ted,43, 
E,Judy,44,87616,1544,Accounting, 
E,Bob,50,63421,1314,Shipping, 
S,Bob,32,67420,Psychology, 
E,Cody,33,25143,1002,Human Resources,
</pre>
<p>The following control file uses relative positioning based on the <code dir="ltr">POSITION</code> parameter to load this data. Note the use of the <code dir="ltr">TREAT</code> <code dir="ltr">AS</code> clause with a specific object type name. This informs SQL*Loader that all input row objects for the object table will conform to the definition of the named object type.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Multiple <a id="sthref722"></a>subtypes cannot be loaded with the same <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> statement. Instead, you must use multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> statements and have each one load a different subtype.</div>
<pre dir="ltr">
INTO TABLE persons 
REPLACE 
WHEN typid = 'P' TREAT AS person_t 
FIELDS TERMINATED BY "," 
 (typid   FILLER  POSITION(1) CHAR, 
  name            CHAR, 
  age             CHAR) 

INTO TABLE persons 
REPLACE 
WHEN typid = 'E' TREAT AS employee_t 
FIELDS TERMINATED BY "," 
 (typid   FILLER  POSITION(1) CHAR, 
  name            CHAR, 
  age             CHAR, 
  empid           CHAR, 
  deptno          CHAR, 
  dept            CHAR) 

INTO TABLE persons 
REPLACE 
WHEN typid = 'S' TREAT AS student_t 
FIELDS TERMINATED BY "," 
 (typid   FILLER  POSITION(1) CHAR, 
  name            CHAR, 
  age             CHAR, 
  stdid           CHAR, 
  major           CHAR)
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_loading.htm#i1006457">"Loading Column Objects"</a> for more information about loading object types</div>
</div>
<!-- class="sect2" -->
<a id="i1005894"></a>
<div id="SUTIL1132" class="sect2">
<h3 class="sect2">Loading Data into Multiple Tables</h3>
<p>By using the <code dir="ltr">POSITION</code> parameter with multiple <code dir="ltr">INTO TABLE</code> clauses, data from a single record can be loaded into multiple normalized tables. See case study 5, Loading Data into Multiple Tables, for an example. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information about how to access case studies.).</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1133" class="sect2"><a id="sthref723"></a>
<h3 class="sect2">Summary</h3>
<p>Multiple <code dir="ltr">INTO TABLE</code> clauses allow you to extract multiple logical records from a single input record and recognize different record formats in the same file.</p>
<p>For delimited data, proper use of the <code dir="ltr">POSITION</code> parameter is essential for achieving the expected results.</p>
<p>When the <code dir="ltr">POSITION</code> parameter is <span class="italic">not</span> used, multiple <code dir="ltr">INTO TABLE</code> clauses process different parts of the same (delimited data) input record, allowing multiple tables to be loaded from one record. When the <code dir="ltr">POSITION</code> parameter <span class="italic">is</span> used, multiple <code dir="ltr">INTO TABLE</code> clauses can process the same record in different ways, allowing multiple formats to be recognized in one input file.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1005907"></a>
<div id="SUTIL1134" class="sect1">
<h2 class="sect1">Bind Arrays and Conventional Path Loads</h2>
<p>SQL*Loader uses the SQL array-interface option to transfer data to the database. Multiple rows are read at one time and stored in the <span class="italic">bind array</span>. When SQL*Loader sends the Oracle database an <code dir="ltr">INSERT</code> command, the entire array is inserted at one time. After the rows in the bind array are inserted, a <code dir="ltr">COMMIT</code> statement is issued.</p>
<p>The determination of bind array size pertains to SQL*Loader's conventional path option. It does not apply to the direct path load method because a direct path load uses the direct path API, rather than Oracle's SQL interface.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI" href="../../appdev.112/e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information about the concepts of direct path loading</div>
<div id="SUTIL1135" class="sect2"><a id="sthref724"></a>
<h3 class="sect2">Size Requirements for Bind Arrays</h3>
<p><a id="sthref725"></a>The bind array must be large enough to contain a single row. If the maximum row length exceeds the size of the bind array, as specified by the <code dir="ltr">BINDSIZE</code> parameter, then SQL*Loader generates an error. Otherwise, the bind array contains as many rows as can fit within it, up to the limit set by the value of the <code dir="ltr">ROWS</code> parameter. (The maximum value for <code dir="ltr">ROWS</code> in a conventional path load is 65534.)</p>
<p>Although the entire bind array need not be in contiguous memory, the buffer for each field in the bind array must occupy contiguous memory. If the operating system cannot supply enough contiguous memory to store a field, then SQL*Loader generates an error.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_params.htm#i1004689">"BINDSIZE (maximum size)"</a></p>
</li>
<li>
<p><a href="ldr_params.htm#i1004872">"ROWS (rows per commit)"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="SUTIL1136" class="sect2"><a id="sthref726"></a>
<h3 class="sect2">Performance Implications of Bind Arrays</h3>
<p>Large bind arrays<a id="sthref727"></a><a id="sthref728"></a><a id="sthref729"></a> minimize the number of calls to the Oracle database and maximize performance. In general, you gain large improvements in performance with each increase in the bind array size up to 100 rows. Increasing the bind array size to be greater than 100 rows generally delivers more modest improvements in performance. The size (in bytes) of 100 rows is typically a good value to use.</p>
<p>In general, any reasonably large size permits SQL*Loader to operate effectively. It is not usually necessary to perform the detailed calculations described in this section. Read this section when you need maximum performance or an explanation of memory usage.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1137" class="sect2"><a id="sthref730"></a>
<h3 class="sect2">Specifying Number of Rows Versus Size of Bind Array</h3>
<p>When you specify a bind array size using the command-line parameter <code dir="ltr">BINDSIZE</code> or the <code dir="ltr">OPTIONS</code> clause in the control file, you impose an upper limit on the bind array. The bind array never exceeds that maximum. <a id="sthref731"></a><a id="sthref732"></a></p>
<p>As part of its initialization, SQL*Loader determines the size in bytes required to load a single row. If that size is too large to fit within the specified maximum, then the load terminates with an error.</p>
<p>SQL*Loader then multiplies that size by the number of rows for the load, whether that value was specified with the command-line parameter <code dir="ltr">ROWS</code> or the <code dir="ltr">OPTIONS</code> clause in the control file.</p>
<p>If that size fits within the bind array maximum, then the load continues&mdash;SQL*Loader does not try to expand the number of rows to reach the maximum bind array size. <span class="italic">If the number of rows and the maximum bind array size are both specified, then SQL*Loader always uses the smaller value for the bind array.</span></p>
<p>If the maximum bind array size is too small to accommodate the initial number of rows, then SQL*Loader uses a smaller number of rows that fits within the maximum.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1138" class="sect2"><a id="sthref733"></a>
<h3 class="sect2">Calculations to Determine Bind Array Size</h3>
<p><a id="sthref734"></a><a id="sthref735"></a>The bind array's size is equivalent to the number of rows it contains times the maximum length of each row. The maximum length of a row equals the sum of the maximum field lengths, plus overhead, as follows:</p>
<pre dir="ltr">
bind array size =
    (number of rows) * (  SUM(fixed field lengths)
                        + SUM(maximum varying field lengths)
                        + ( (number of varying length fields)
                             * (size of length indicator) )
                       )
</pre>
<p>Many fields do not vary in size. These fixed-length fields are the same for each loaded row. For these fields, the maximum length of the field is the field size, in bytes, as described in <a href="ldr_field_list.htm#i1006714">"SQL*Loader Datatypes"</a>. There is no overhead for these fields.</p>
<p>The fields that <span class="italic">can</span> vary in size from row to row are:</p>
<ul>
<li>
<p><code dir="ltr">CHAR</code></p>
</li>
<li>
<p><code dir="ltr">DATE</code></p>
</li>
<li>
<p><code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code></p>
</li>
<li>
<p><code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">YEAR</code></p>
</li>
<li>
<p><code dir="ltr">LONG</code> <code dir="ltr">VARRAW</code></p>
</li>
<li>
<p>numeric <code dir="ltr">EXTERNAL</code></p>
</li>
<li>
<p><code dir="ltr">TIME</code></p>
</li>
<li>
<p><code dir="ltr">TIMESTAMP</code></p>
</li>
<li>
<p><code dir="ltr">TIME</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
</li>
<li>
<p><code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
</li>
<li>
<p><code dir="ltr">VARCHAR</code></p>
</li>
<li>
<p><code dir="ltr">VARCHARC</code></p>
</li>
<li>
<p><code dir="ltr">VARGRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">VARRAW</code></p>
</li>
<li>
<p><code dir="ltr">VARRAWC</code></p>
</li>
</ul>
<p>The maximum length of these datatypes is described in <a href="ldr_field_list.htm#i1006714">"SQL*Loader Datatypes"</a>. The maximum lengths describe the number of bytes that the fields can occupy in the input data record. That length also describes the amount of storage that each field occupies in the bind array, but the bind array includes additional overhead for fields that can vary in size.</p>
<p>When the character datatypes (<code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and numeric <code dir="ltr">EXTERNAL</code>) are specified with delimiters, any lengths specified for these fields are maximum lengths. When specified without delimiters, the size in the record is fixed, but the size of the inserted field may still vary, due to whitespace trimming. So internally, these datatypes are always treated as varying-length fields&mdash;even when they are fixed-length fields.</p>
<p>A length indicator is included for each of these fields in the bind array. The space reserved for the field in the bind array is large enough to hold the longest possible value of the field. The length indicator gives the actual length of the field for each row.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In conventional path loads, LOBFILEs are not included when allocating the size of a bind array.</div>
<div id="SUTIL1139" class="sect3"><a id="sthref736"></a>
<h4 class="sect3">Determining the Size of the Length Indicator</h4>
<p>On most systems, the size of the length indicator is 2 bytes. On a few systems, it is 3 bytes. To determine its size, use the following<a id="sthref737"></a> control file:</p>
<pre dir="ltr">
OPTIONS (ROWS=1) 
LOAD DATA 
INFILE * 
APPEND 
INTO TABLE DEPT 
(deptno POSITION(1:1) CHAR(1)) 
BEGINDATA 
a 
</pre>
<p>This control file loads a 1-byte <code dir="ltr">CHAR</code> using a 1-row bind array. In this example, no data is actually loaded because a conversion error occurs when the character <code dir="ltr">a</code> is loaded into a numeric column (<code dir="ltr">deptno</code>). The bind array size shown in the log file, minus one (the length of the character field) is the value of the length indicator.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A similar technique can determine bind array size without doing any calculations. Run your control file without any data and with <code dir="ltr">ROWS=1</code> to determine the memory requirements for a single row of data. Multiply by the number of rows you want in the bind array to determine the bind array size.</div>
</div>
<!-- class="sect3" -->
<div id="SUTIL1140" class="sect3"><a id="sthref738"></a>
<h4 class="sect3">Calculating the Size of Field Buffers</h4>
<p><a href="#g1022601">Table 9-3</a> through <a href="#g1022698">Table 9-6</a> summarize the memory requirements for each datatype. "L" is the length specified in the control file. "P" is precision. "S" is the size of the length indicator. For more information about these values, see <a href="ldr_field_list.htm#i1006714">"SQL*Loader Datatypes"</a>.</p>
<div id="SUTIL3333" class="tblruleformal">
<p class="titleintable"><a id="sthref739"></a><a id="g1022601"></a>Table 9-3 Fixed-Length Fields</p>
<table class="cellalignment1399" title="Fixed-Length Fields" summary="Memory requirements for fixed-length fields" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t42">Datatype</th>
<th class="cellalignment1395" id="r1c2-t42">Size in Bytes (Operating System-Dependent)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t42" headers="r1c1-t42">
<p><code dir="ltr">INTEGER</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t42 r1c2-t42">
<p>The size of the <code dir="ltr">INT</code> datatype, in C</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t42" headers="r1c1-t42">
<p><code dir="ltr">INTEGER(</code><code dir="ltr"><span class="codeinlineitalic">N</span></code><code dir="ltr">)</code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t42 r1c2-t42">
<p><code dir="ltr"><span class="codeinlineitalic">N</span></code> bytes</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t42" headers="r1c1-t42">
<p><code dir="ltr">SMALLINT</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t42 r1c2-t42">
<p>The size of <code dir="ltr">SHORT INT</code> datatype, in C</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t42" headers="r1c1-t42">
<p><code dir="ltr">FLOAT</code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t42 r1c2-t42">
<p>The size of the <code dir="ltr">FLOAT</code> datatype, in C</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t42" headers="r1c1-t42">
<p><code dir="ltr">DOUBLE</code></p>
</td>
<td class="cellalignment1396" headers="r6c1-t42 r1c2-t42">
<p>The size of the <code dir="ltr">DOUBLE</code> datatype, in C</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t42" headers="r1c1-t42">
<p><code dir="ltr">BYTEINT</code></p>
</td>
<td class="cellalignment1396" headers="r7c1-t42 r1c2-t42">
<p>The size of <code dir="ltr">UNSIGNED CHAR</code>, in C</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t42" headers="r1c1-t42">
<p><code dir="ltr">VARRAW</code></p>
</td>
<td class="cellalignment1396" headers="r8c1-t42 r1c2-t42">
<p>The size of <code dir="ltr">UNSIGNED SHORT</code>, plus 4096 bytes or whatever is specified as <code dir="ltr"><span class="codeinlineitalic">max_length</span></code></p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r9c1-t42" headers="r1c1-t42">
<p><code dir="ltr">LONG VARRAW</code></p>
</td>
<td class="cellalignment1396" headers="r9c1-t42 r1c2-t42">
<p>The size of <code dir="ltr">UNSIGNED INT</code>, plus 4096 bytes or whatever is specified as <code dir="ltr"><span class="codeinlineitalic">max_length</span></code></p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r10c1-t42" headers="r1c1-t42">
<p><code dir="ltr">VARCHARC</code></p>
</td>
<td class="cellalignment1396" headers="r10c1-t42 r1c2-t42">
<p>Composed of 2 numbers. The first specifies length, and the second (which is optional) specifies <code dir="ltr"><span class="codeinlineitalic">max_length</span></code> (default is 4096 bytes).</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r11c1-t42" headers="r1c1-t42">
<p><code dir="ltr">VARRAWC</code></p>
</td>
<td class="cellalignment1396" headers="r11c1-t42 r1c2-t42">
<p>This datatype is for <code dir="ltr">RAW</code> data. It is composed of 2 numbers. The first specifies length, and the second (which is optional) specifies <code dir="ltr"><span class="codeinlineitalic">max_length</span></code> (default is 4096 bytes).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div id="SUTIL3334" class="tblruleformal">
<p class="titleintable"><a id="sthref740"></a><a id="sthref741"></a>Table 9-4 Nongraphic Fields</p>
<table class="cellalignment1399" title="Nongraphic Fields" summary="Memory requirements for nongraphic fields" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t43">Datatype</th>
<th class="cellalignment1395" id="r1c2-t43">Default Size</th>
<th class="cellalignment1395" id="r1c3-t43">Specified Size</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t43" headers="r1c1-t43">
<p>(packed) <code dir="ltr">DECIMAL</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t43 r1c2-t43">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r2c1-t43 r1c3-t43">
<p>(N+1)/2, rounded up</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t43" headers="r1c1-t43">
<p><code dir="ltr">ZONED</code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t43 r1c2-t43">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r3c1-t43 r1c3-t43">
<p>P</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t43" headers="r1c1-t43">
<p><code dir="ltr">RAW</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t43 r1c2-t43">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r4c1-t43 r1c3-t43">
<p>L</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t43" headers="r1c1-t43">
<p><code dir="ltr">CHAR</code> (no delimiters)</p>
</td>
<td class="cellalignment1396" headers="r5c1-t43 r1c2-t43">
<p>1</p>
</td>
<td class="cellalignment1396" headers="r5c1-t43 r1c3-t43">
<p>L + S</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t43" headers="r1c1-t43">
<p>datetime and interval (no delimiters)</p>
</td>
<td class="cellalignment1396" headers="r6c1-t43 r1c2-t43">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r6c1-t43 r1c3-t43">
<p>L + S</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t43" headers="r1c1-t43">
<p>numeric <code dir="ltr">EXTERNAL</code> (no delimiters)</p>
</td>
<td class="cellalignment1396" headers="r7c1-t43 r1c2-t43">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r7c1-t43 r1c3-t43">
<p>L + S</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div id="SUTIL3335" class="tblruleformal">
<p class="titleintable"><a id="sthref742"></a><a id="sthref743"></a>Table 9-5 Graphic Fields</p>
<table class="cellalignment1399" title="Graphic Fields" summary="Memory requirements for graphic fields" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t44">Datatype</th>
<th class="cellalignment1395" id="r1c2-t44">Default Size</th>
<th class="cellalignment1395" id="r1c3-t44">Length Specified<br />
with POSITION</th>
<th class="cellalignment1395" id="r1c4-t44">Length Specified<br />
with DATATYPE</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t44" headers="r1c1-t44">
<p><code dir="ltr">GRAPHIC</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t44 r1c2-t44">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r2c1-t44 r1c3-t44">
<p>L</p>
</td>
<td class="cellalignment1396" headers="r2c1-t44 r1c4-t44">
<p>2*L</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t44" headers="r1c1-t44">
<p><code dir="ltr">GRAPHIC<br />
EXTERNAL</code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t44 r1c2-t44">
<p>None</p>
</td>
<td class="cellalignment1396" headers="r3c1-t44 r1c3-t44">
<p>L - 2</p>
</td>
<td class="cellalignment1396" headers="r3c1-t44 r1c4-t44">
<p>2*(L-2)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t44" headers="r1c1-t44">
<p><code dir="ltr">VARGRAPHIC</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t44 r1c2-t44">
<p>4KB*2</p>
</td>
<td class="cellalignment1396" headers="r4c1-t44 r1c3-t44">
<p>L+S</p>
</td>
<td class="cellalignment1396" headers="r4c1-t44 r1c4-t44">
<p>(2*L)+S</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<div id="SUTIL3336" class="tblruleformal">
<p class="titleintable"><a id="sthref744"></a><a id="g1022698"></a>Table 9-6 Variable-Length Fields</p>
<table class="cellalignment1399" title="Variable-Length Fields" summary="Memory requirements for variable-length fields" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t45">Datatype</th>
<th class="cellalignment1395" id="r1c2-t45">Default Size</th>
<th class="cellalignment1395" id="r1c3-t45">Maximum Length<br />
Specified (L)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t45" headers="r1c1-t45">
<p><code dir="ltr">VARCHAR</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t45 r1c2-t45">
<p>4 KB</p>
</td>
<td class="cellalignment1396" headers="r2c1-t45 r1c3-t45">
<p>L+S</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t45" headers="r1c1-t45">
<p><code dir="ltr">CHAR</code> (delimited)</p>
</td>
<td class="cellalignment1396" headers="r3c1-t45 r1c2-t45">
<p>255</p>
</td>
<td class="cellalignment1396" headers="r3c1-t45 r1c3-t45">
<p>L+S</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t45" headers="r1c1-t45">
<p>datetime and interval (delimited)</p>
</td>
<td class="cellalignment1396" headers="r4c1-t45 r1c2-t45">
<p>255</p>
</td>
<td class="cellalignment1396" headers="r4c1-t45 r1c3-t45">
<p>L+S</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t45" headers="r1c1-t45">
<p>numeric <code dir="ltr">EXTERNAL</code> (delimited)</p>
</td>
<td class="cellalignment1396" headers="r5c1-t45 r1c2-t45">
<p>255</p>
</td>
<td class="cellalignment1396" headers="r5c1-t45 r1c3-t45">
<p>L+S</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1141" class="sect2"><a id="sthref745"></a>
<h3 class="sect2">Minimizing Memory Requirements for Bind Arrays</h3>
<p><a id="sthref746"></a>Pay particular attention to the default sizes allocated for <code dir="ltr">VARCHAR</code>, <code dir="ltr">VARGRAPHIC</code>, and the delimited forms of <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and numeric <code dir="ltr">EXTERNAL</code> fields. They can consume enormous amounts of memory&mdash;especially when multiplied by the number of rows in the bind array. It is best to specify the smallest possible maximum length for these fields. Consider the following example:</p>
<pre dir="ltr">
CHAR(10) TERMINATED BY "," 
</pre>
<p>With byte-length semantics, this example uses (10 + 2) * 64 = 768 bytes in the bind array, assuming that the length indicator is 2 bytes long and that 64 rows are loaded at a time.</p>
<p>With character-length semantics, the same example uses ((10 * s) + 2) * 64 bytes in the bind array, where "s" is the maximum size in bytes of a character in the data file character set.</p>
<p>Now consider the following example:</p>
<pre dir="ltr">
CHAR TERMINATED BY "," 
</pre>
<p>Regardless of whether byte-length semantics or character-length semantics are used, this example uses (255 + 2) * 64 = 16,448 bytes, because the default maximum size for a delimited field is 255 bytes. This can make a considerable difference in the number of rows that fit into the bind array.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1142" class="sect2"><a id="sthref747"></a>
<h3 class="sect2">Calculating Bind Array Size for Multiple INTO TABLE Clauses</h3>
<p><a id="sthref748"></a><a id="sthref749"></a>When calculating a bind array size for a control file that has multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses, calculate as if the <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses were not present. Imagine all of the fields listed in the control file as one, long data structure&mdash;that is, the format of a single row in the bind array.</p>
<p>If the same field in the data record is mentioned in multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses, then additional space in the bind array is required each time it is mentioned. It is especially important to minimize the buffer allocations for such fields.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Generated data is produced by the SQL*Loader functions <code dir="ltr">CONSTANT</code>, <code dir="ltr">EXPRESSION</code>, <code dir="ltr">RECNUM</code>, <code dir="ltr">SYSDATE</code>, and <code dir="ltr">SEQUENCE</code>. Such generated data does not require any space in the bind array.</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1387">
<tr>
<td class="cellalignment1396">
<table class="cellalignment1392">
<tr>
<td class="cellalignment1391"><a href="ldr_params.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1391"><a href="ldr_field_list.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1398">
<table class="cellalignment1390">
<tr>
<td class="cellalignment1391"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1391"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1391"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1391"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1391"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1391"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
