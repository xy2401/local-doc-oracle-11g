<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>SQL*Loader Field List Reference</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093" />
<meta name="dcterms.created" content="2018-03-26T15:54:52Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Utilities" />
<meta name="dcterms.identifier" content="E22490-08" />
<meta name="dcterms.isVersionOf" content="SUTIL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ldr_control_file.htm" title="Previous" type="text/html" />
<link rel="Next" href="ldr_loading.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e22490.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/36</span> <!-- End Header -->
<script  >
<!-- // <![CDATA[
window.name='ldr_field_list'
// ]]> -->
</script> <script  >
// <![CDATA[
function footdisplay(footnum,footnote) {
    var msg = window.open('', 'NewWindow' + footnum,
        'directories=no,height=100,location=no,menubar=no,resizable=yes,' +
        'scrollbars=yes,status=no,toolbar=no,width=598');
    msg.document.open('text/html');
    msg.document.write('<!DOCTYPE html ');
    msg.document.write('PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" ');

    msg.document.write('"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">');
    msg.document.write('<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>');
    msg.document.write('Footnote&nbsp; ' + footnum);
    msg.document.write('<\/title><meta http-equiv="Content-Type" ');
    msg.document.write('content="text/html; charset=utf-8" />');
    msg.document.write('');
    msg.document.write('<style> <![CDATA[ ');
    msg.document.write('h1 {text-align: center; font-size: 14pt;}');
    msg.document.write('fieldset {border: none;}');
    msg.document.write('form {text-align: center;}');
    msg.document.write(' ]]\u003e <\/style>');
    msg.document.write('<\/head><body><div id="footnote"><h1>Footnote&nbsp; ' + footnum + '<\/h1><p>');
    msg.document.write(footnote);
    msg.document.write('<\/p><form action="" method="post"><fieldset>');
    msg.document.write('<input type="button" value="OK" ');
    msg.document.write('onclick="window.close();" />');
    msg.document.write('<\/fieldset><\/form><\/div><\/body><\/html>');
    msg.document.close();
    setTimeout(function() { var height = msg.document.getElementById('footnote').offsetHeight; msg.resizeTo(598, height + 100); }, 100);
    msg.focus();
}
// ]]>
</script> <noscript>
<p>The script content on this page is for navigation purposes only and does not alter the content in any way.</p>
</noscript>
<div id="SUTIL006" class="chapter"><a id="g1044967"></a> <a id="i1008914"></a>
<h1 class="chapter"><span class="secnum">10</span> SQL*Loader Field List Reference</h1>
<p>This chapter describes the field-list portion of the SQL*Loader control file. The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1006477">Field List Contents</a></p>
</li>
<li>
<p><a href="#i1006565">Specifying the Position of a Data Field</a></p>
</li>
<li>
<p><a href="#i1008756">Specifying Columns and Fields</a></p>
</li>
<li>
<p><a href="#i1006714">SQL*Loader Datatypes</a></p>
</li>
<li>
<p><a href="#i1009544">Specifying Field Conditions</a></p>
</li>
<li>
<p><a href="#i1009345">Using the WHEN, NULLIF, and DEFAULTIF Clauses</a></p>
</li>
<li>
<p><a href="#i1007642">Loading Data Across Different Platforms</a></p>
</li>
<li>
<p><a href="#i1011032">Byte Ordering</a></p>
</li>
<li>
<p><a href="#i1007735">Loading All-Blank Fields</a></p>
</li>
<li>
<p><a href="#i1007768">Trimming Whitespace</a></p>
</li>
<li>
<p><a href="#i1008122">How the PRESERVE BLANKS Option Affects Whitespace Trimming</a></p>
</li>
<li>
<p><a href="#i1008150">Applying SQL Operators to Fields</a></p>
</li>
<li>
<p><a href="#i1008234">Using SQL*Loader to Generate Data for Input</a></p>
</li>
</ul>
<a id="i1006477"></a>
<div id="SUTIL1143" class="sect1">
<h2 class="sect1">Field List Contents</h2>
<p>The field-list portion of a SQL*Loader control file provides information about fields being loaded, such as position, datatype, conditions, and delimiters.</p>
<p><a href="#i1006487">Example 10-1</a> shows the field list section of the sample control file that was introduced in <a href="ldr_control_file.htm#i1006645">Chapter 9</a>.</p>
<div id="SUTIL3337" class="example">
<p class="titleinexample"><a id="i1006487"></a>Example 10-1 Field List Section of Sample Control File</p>
<pre >
<span class="bold">.</span>
.
.
<span class="bold">1 </span> (hiredate  SYSDATE,
<span class="bold">2</span>     deptno  POSITION(1:2)  INTEGER EXTERNAL(2)
              NULLIF deptno=BLANKS,
<span class="bold">3</span>       job   POSITION(7:14)  CHAR  TERMINATED BY WHITESPACE
              NULLIF job=BLANKS  "UPPER(:job)",
       mgr    POSITION(28:31) INTEGER EXTERNAL 
              TERMINATED BY WHITESPACE, NULLIF mgr=BLANKS,
       ename  POSITION(34:41) CHAR 
              TERMINATED BY WHITESPACE  "UPPER(:ename)",
       empno  POSITION(45) INTEGER EXTERNAL 
              TERMINATED BY WHITESPACE,
       sal    POSITION(51) CHAR  TERMINATED BY WHITESPACE
              "TO_NUMBER(:sal,'$99,999.99')",
<span class="bold">4 </span>     comm   INTEGER EXTERNAL  ENCLOSED BY '(' AND '%'
              ":comm * 100"
    )
</pre>
<p>In this sample control file, the numbers that appear to the left would not appear in a real control file. They are keyed in this sample to the explanatory notes in the following list:</p>
</div>
<!-- class="example" -->
<ol>
<li>
<p><code dir="ltr">SYSDATE</code> sets the column to the current system date. See <a href="#i1008291">"Setting a Column to the Current Date"</a>.</p>
</li>
<li>
<p><code dir="ltr">POSITION</code> specifies the position of a data field. See <a href="#i1006565">"Specifying the Position of a Data Field"</a>.</p>
<p><code dir="ltr">INTEGER</code> <code dir="ltr">EXTERNAL</code> is the datatype for the field. See <a href="#i1013072">"Specifying the Datatype of a Data Field"</a> and <a href="#i1007110">"Numeric EXTERNAL"</a>.</p>
<p>The <code dir="ltr">NULLIF</code> clause is one of the clauses that can be used to specify field conditions. See <a href="#i1009345">"Using the WHEN, NULLIF, and DEFAULTIF Clauses"</a>.</p>
<p>In this sample, the field is being compared to blanks, using the <code dir="ltr">BLANKS</code> parameter. See <a href="#i1009606">"Comparing Fields to BLANKS"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> <code dir="ltr">WHITESPACE</code> clause is one of the delimiters it is possible to specify for a field. See <a href="#i1007368">"Specifying Delimiters"</a>.</p>
</li>
<li>
<p>The <code dir="ltr">ENCLOSED</code> <code dir="ltr">BY</code> clause is another possible field delimiter. See <a href="#i1007368">"Specifying Delimiters"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1006565"></a>
<div id="SUTIL1144" class="sect1">
<h2 class="sect1">Specifying the Position of a Data Field</h2>
<p><a id="sthref750"></a><a id="sthref751"></a>To load data from the data file, SQL*Loader must know the length and location of the field. To specify the position of a field in the logical record, use the <code dir="ltr">POSITION</code> clause in the column specification. The position may either be stated explicitly or relative to the preceding field. Arguments to <code dir="ltr">POSITION</code> must be enclosed in parentheses. The start, end, and integer values are always in bytes, even if character-length semantics are used for a data file.</p>
<p>The syntax for the position specification (pos_spec) clause is as follows:</p>
<img width="407" height="105" src="img/pos_spec.gif" alt="Description of pos_spec.gif follows" /><br />
<a id="sthref752" href="img_text/pos_spec.htm">Description of the illustration ''pos_spec.gif''</a><br />
<br />
<p><a href="#i1017023">Table 10-1</a> describes the parameters for the position specification clause.</p>
<div id="SUTIL3338" class="tblformal">
<p class="titleintable"><a id="sthref753"></a><a id="i1017023"></a>Table 10-1 Parameters for the Position Specification Clause</p>
<table class="cellalignment1394" title="Parameters for the Position Specification Clause" summary="Parameters for the position specification clause" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t2">Parameter</th>
<th class="cellalignment1395" id="r1c2-t2">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t2" headers="r1c1-t2">
<p><code dir="ltr"><span class="codeinlineitalic">start</span></code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t2 r1c2-t2">
<p>The starting column of the data field in the logical record. The first byte position in a logical record is 1.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t2" headers="r1c1-t2">
<p><code dir="ltr"><span class="codeinlineitalic">end</span></code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t2 r1c2-t2">
<p>The ending position of the data field in the logical record. Either <code dir="ltr"><span class="codeinlineitalic">start</span></code>-<code dir="ltr"><span class="codeinlineitalic">end</span></code> or <code dir="ltr"><span class="codeinlineitalic">start:end</span></code> is acceptable. If you omit <code dir="ltr">end</code>, then the length of the field is derived from the datatype in the data file. Note that <code dir="ltr">CHAR</code> data specified without start or end, and without a length specification (<code dir="ltr">CHAR(n)</code>), is assumed to have a length of 1. If it is impossible to derive a length from the datatype, then an error message is issued.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t2" headers="r1c1-t2">
<p><code dir="ltr">*</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t2 r1c2-t2">
<p>Specifies that the data field follows immediately after the previous field. If you use <code dir="ltr"><span class="codeinlineitalic">*</span></code> for the first data field in the control file, then that field is assumed to be at the beginning of the logical record. When you use <code dir="ltr"><span class="codeinlineitalic">*</span></code> to specify position, the length of the field is derived from the datatype.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t2" headers="r1c1-t2">
<p>+i<code dir="ltr"><span class="codeinlineitalic">nteger</span></code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t2 r1c2-t2">
<p>You can use an offset, specified as +i<code dir="ltr"><span class="codeinlineitalic">nteger</span></code>, to offset the current field from the next position after the end of the previous field. A number of bytes, as specified by <code dir="ltr"><span class="codeinlineitalic">+integer</span></code>, are skipped before reading the value for the current field.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>You may omit <code dir="ltr">POSITION</code> entirely. If you do, then the position specification for the data field is the same as if <code dir="ltr">POSITION(*)</code> had been used.</p>
<a id="i1014623"></a>
<div id="SUTIL1145" class="sect2">
<h3 class="sect2">Using POSITION with Data Containing Tabs</h3>
<p><a id="sthref754"></a><a id="sthref755"></a><a id="sthref756"></a>When you are determining field positions, be alert for tabs in the data file. Suppose you use the SQL*Loader advanced SQL string capabilities to load data from a formatted report. You would probably first look at a printed copy of the report, carefully measure all character positions, and then create your control file. In such a situation, it is highly likely that when you attempt to load the data, the load will fail with <a id="sthref757"></a>multiple "invalid number" and "missing field" errors.</p>
<p><a id="sthref758"></a>These kinds of errors occur when the data contains tabs. When printed, each tab expands to consume several columns on the paper. In the data file, however, each tab is still only one character. As a result, when SQL*Loader reads the data file, the <code dir="ltr">POSITION</code> specifications are wrong.</p>
<p>To fix the problem, inspect the data file for tabs and adjust the <code dir="ltr">POSITION</code> specifications, or else use delimited fields.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007368">"Specifying Delimiters"</a></div>
</div>
<!-- class="sect2" -->
<div id="SUTIL1146" class="sect2"><a id="sthref759"></a>
<h3 class="sect2">Using POSITION with Multiple Table Loads</h3>
<p><a id="sthref760"></a>In a multiple table load, you specify multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses. When you specify <code dir="ltr">POSITION(*)</code> for the first column of the first table, the position is calculated relative to the beginning of the logical record. When you specify <code dir="ltr">POSITION(*)</code> for the first column of subsequent tables, the position is calculated relative to the last column of the last table loaded.</p>
<p>Thus, when a subsequent <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause begins, the position is <span class="italic">not</span> set to the beginning of the logical record automatically. This allows multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses to process different parts of the same physical record. For an example, see <a href="ldr_control_file.htm#i1005817">"Extracting Multiple Logical Records"</a>.</p>
<p>A logical record might contain data for one of two tables, but not both. In this case, you <span class="italic">would</span> reset <code dir="ltr">POSITION</code>. Instead of omitting the position specification or using <code dir="ltr">POSITION(*+</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code> for the first field in the <code dir="ltr">INTO TABLE</code> clause, use <code dir="ltr">POSITION(1)</code> or <code dir="ltr">POSITION(</code><code dir="ltr"><span class="codeinlineitalic">n</span></code><code dir="ltr">)</code>.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1147" class="sect2"><a id="sthref761"></a>
<h3 class="sect2">Examples of Using POSITION</h3>
<pre dir="ltr">
siteid  POSITION (*) SMALLINT 
siteloc POSITION (*) INTEGER 
</pre>
<p>If these were the first two column specifications, then <code dir="ltr">siteid</code> would begin in column 1, and <code dir="ltr">siteloc</code> would begin in the column immediately following.</p>
<pre dir="ltr">
ename  POSITION (1:20)  CHAR 
empno  POSITION (22-26) INTEGER EXTERNAL 
allow  POSITION (*+2)   INTEGER EXTERNAL TERMINATED BY "/" 
</pre>
<p>Column <code dir="ltr">ename</code> is character data in positions 1 through 20, followed by column <code dir="ltr">empno</code>, which is presumably numeric data in columns 22 through 26. Column <code dir="ltr">allow</code> is offset from the next position (27) after the end of <code dir="ltr">empno</code> by +2, so it starts in column 29 and continues until a slash is encountered.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008756"></a>
<div id="SUTIL1148" class="sect1">
<h2 class="sect1">Specifying Columns and Fields</h2>
<p><a id="sthref762"></a>You may load any number of a table's columns. Columns defined in the database, but not specified in the control file, are assigned null values.</p>
<p><a id="sthref763"></a><a id="sthref764"></a><a id="sthref765"></a><a id="sthref766"></a>A column specification is the name of the column, followed by a specification for the value to be put in that column. The list of columns is enclosed by parentheses and separated with commas as follows:</p>
<pre dir="ltr">
(<span class="italic">columnspec</span>,<span class="italic">columnspec</span>, ...)
</pre>
<p><a id="sthref767"></a>Each column name (unless it is marked <code dir="ltr">FILLER</code>) must correspond to a column of the table named in the <code dir="ltr">INTO TABLE</code> clause. A column name must be enclosed in quotation marks if it is a SQL or SQL*Loader reserved word, contains special characters, or is case sensitive.</p>
<p><a id="sthref768"></a>If the value is to be generated by SQL*Loader, then the specification includes the <code dir="ltr">RECNUM</code>, <code dir="ltr">SEQUENCE</code>, or <code dir="ltr">CONSTANT</code> parameter. See <a href="#i1008234">"Using SQL*Loader to Generate Data for Input"</a>.</p>
<p>If the column's value is read from the data file, then the data field that contains the column's value is specified. In this case, the column specification includes a <span class="italic">column name</span> that identifies a column in the database table, and a <span class="italic">field specification</span> that describes a field in a data record. The field specification includes position, datatype, null restrictions, and defaults.<a id="sthref769"></a></p>
<p>It is not necessary to specify all attributes when loading column objects. Any missing attributes will be set to <code dir="ltr">NULL</code>.</p>
<a id="i1006668"></a>
<div id="SUTIL1149" class="sect2">
<h3 class="sect2">Specifying Filler Fields<a id="sthref770"></a></h3>
<p>A filler field, specified by <code dir="ltr">BOUNDFILLER</code> or <code dir="ltr">FILLER</code> is a data file mapped field that does not correspond to a database column. Filler fields are assigned values from the data fields to which they are mapped.</p>
<p>Keep the following in mind regarding filler fields:</p>
<ul>
<li>
<p>The syntax for a filler field is same as that for a column-based field, except that a filler field's name is followed by <code dir="ltr">FILLER</code>.</p>
</li>
<li>
<p>Filler fields have names but they are not loaded into the table.</p>
</li>
<li>
<p>Filler fields can be used as arguments to <code dir="ltr">init_specs</code> (for example, <code dir="ltr">NULLIF</code> and <code dir="ltr">DEFAULTIF</code>).</p>
</li>
<li>
<p>Filler fields can be used as arguments to directives (for example, <code dir="ltr">SID</code>, <code dir="ltr">OID</code>, <code dir="ltr">REF</code>, and <code dir="ltr">BFILE</code>).</p>
<p>To avoid ambiguity, if a Filler field is referenced in a directive, such as <code dir="ltr">BFILE</code>, and that field is declared in the control file inside of a column object, then the field name must be qualified with the name of the column object. This is illustrated in the following example:</p>
<pre dir="ltr">
LOAD DATA 
INFILE * 
INTO TABLE BFILE1O_TBL REPLACE 
FIELDS TERMINATED BY ',' 
( 
   emp_number char, 
   emp_info_b column object 
   ( 
   bfile_name FILLER char(12), 
   emp_b BFILE(constant "SQLOP_DIR", emp_info_b.bfile_name) NULLIF 
  emp_info_b.bfile_name = 'NULL' 
   ) 
) 
BEGINDATA 
00001,bfile1.dat, 
00002,bfile2.dat, 
00003,bfile3.dat, 
</pre></li>
<li>
<p>Filler fields can be used in field condition specifications in <code dir="ltr">NULLIF</code>, <code dir="ltr">DEFAULTIF</code>, and <code dir="ltr">WHEN</code> clauses. However, they cannot be used in SQL strings.</p>
</li>
<li>
<p>Filler field specifications cannot contain a <code dir="ltr">NULLIF</code> or <code dir="ltr">DEFAULTIF</code> clause.</p>
</li>
<li>
<p>Filler fields are initialized to <code dir="ltr">NULL</code> if <code dir="ltr">TRAILING NULLCOLS</code> is specified and applicable. If another field references a nullified filler field, then an error is generated.</p>
</li>
<li>
<p>Filler fields can occur anyplace in the data file, including inside the field list for an object or inside the definition of a <code dir="ltr">VARRAY</code>.</p>
</li>
<li>
<p>SQL strings cannot be specified as part of a filler field specification, because no space is allocated for fillers in the bind array.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The information in this section also applies to specifying bound fillers by using <code dir="ltr">BOUNDFILLER<a id="sthref771"></a></code>. The only exception is that with bound fillers, SQL strings <span class="italic">can</span> be specified as part of the field, because space is allocated for them in the bind array.</div>
</li>
</ul>
<p>A sample filler field specification looks as follows:</p>
<pre dir="ltr">
 field_1_count FILLER char,
 field_1 varray count(field_1_count)
 (
    filler_field1  char(2),
    field_1  column object
    (
      attr1 char(2),
      filler_field2  char(2),
      attr2 char(2),
    )
    filler_field3  char(3),
 )
 filler_field4 char(6)
</pre></div>
<!-- class="sect2" -->
<a id="i1013072"></a>
<div id="SUTIL1150" class="sect2">
<h3 class="sect2">Specifying the Datatype of a Data Field</h3>
<p>The datatype specification of a field tells SQL*Loader how to interpret the data in the field. For example, a datatype of <code dir="ltr">INTEGER</code> specifies binary data, while <code dir="ltr">INTEGER</code> <code dir="ltr">EXTERNAL</code> specifies character data that represents a number. A <code dir="ltr">CHAR</code> field can contain any character data.</p>
<p>Only <span class="italic">one</span> datatype can be specified for each field; if a datatype is not specified, then <code dir="ltr">CHAR</code> is assumed.<a id="sthref772"></a><a id="sthref773"></a></p>
<p><a href="#i1006714">"SQL*Loader Datatypes"</a> describes how SQL*Loader datatypes are converted into Oracle datatypes and gives detailed information about each SQL*Loader datatype.</p>
<p>Before you specify the datatype, you must specify the position of the field.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006714"></a>
<div id="SUTIL1151" class="sect1">
<h2 class="sect1">SQL*Loader Datatypes<a id="sthref774"></a></h2>
<p>SQL*Loader datatypes can be grouped into portable and nonportable datatypes. Within each of these two groups, the datatypes are subgrouped into value datatypes and length-value datatypes.</p>
<p>Portable versus nonportable refers to whether the datatype is platform dependent. Platform dependency can exist for several reasons, including differences in the byte ordering schemes of different platforms (big-endian versus little-endian), differences in the number of bits in a platform (16-bit, 32-bit, 64-bit), differences in signed number representation schemes (2's complement versus 1's complement), and so on. In some cases, such as with byte ordering schemes and platform word length, SQL*Loader provides mechanisms to help overcome platform dependencies. These mechanisms are discussed in the descriptions of the appropriate datatypes.</p>
<p>Both portable and nonportable datatypes can be values or length-values. Value datatypes assume that a data field has a single part. Length-value datatypes require that the data field consist of two subfields where the length subfield specifies how long the value subfield can be.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1044967">Chapter 10, "SQL*Loader Field List Reference"</a> for information about loading a variety of datatypes including column objects, object tables, REF columns, and LOBs (BLOBs, CLOBs, NCLOBs and BFILEs)</div>
<div id="SUTIL1152" class="sect2"><a id="sthref775"></a>
<h3 class="sect2">Nonportable Datatypes<a id="sthref776"></a></h3>
<p>Nonportable datatypes are grouped into value datatypes and length-value datatypes. The nonportable value datatypes are as follows:</p>
<ul>
<li>
<p><code dir="ltr">INTEGER(n)</code></p>
</li>
<li>
<p><code dir="ltr">SMALLINT</code></p>
</li>
<li>
<p><code dir="ltr">FLOAT</code></p>
</li>
<li>
<p><code dir="ltr">DOUBLE</code></p>
</li>
<li>
<p><code dir="ltr">BYTEINT</code></p>
</li>
<li>
<p><code dir="ltr">ZONED</code></p>
</li>
<li>
<p>(packed) <code dir="ltr">DECIMAL</code></p>
</li>
</ul>
<p>The nonportable length-value datatypes are as follows:</p>
<ul>
<li>
<p><code dir="ltr">VARGRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">VARCHAR</code></p>
</li>
<li>
<p><code dir="ltr">VARRAW</code></p>
</li>
<li>
<p><code dir="ltr">LONG</code> <code dir="ltr">VARRAW</code></p>
</li>
</ul>
<p>The syntax for the nonportable datatypes is shown in the syntax diagram for <a href="app_ldr_syntax.htm#BABIABHB">"datatype_spec"</a>.</p>
<a id="BABFBEBE"></a>
<div id="SUTIL1153" class="sect3">
<h4 class="sect3">INTEGER(<span class="italic">n</span>)</h4>
<p>The data is a full-word binary integer, where <code dir="ltr"><span class="codeinlineitalic">n</span></code> is an optionally supplied length of 1, 2, 4, or 8. If no length specification is given, then the length, in bytes, is based on the size of a <code dir="ltr">LONG</code> <code dir="ltr">INT</code> in the C programming language on your particular platform.</p>
<p><code dir="ltr">INTEGER</code>s are not portable because their byte size, their byte order, and the representation of signed values may be different between systems. However, if the representation of signed values is the same between systems, then SQL*Loader may be able to access <code dir="ltr">INTEGER</code> data with correct results. If <code dir="ltr">INTEGER</code> is specified with a length specification (<code dir="ltr"><span class="codeinlineitalic">n</span></code>), and the appropriate technique is used (if necessary) to indicate the byte order of the data, then SQL*Loader can access the data with correct results between systems. If <code dir="ltr">INTEGER</code> is specified without a length specification, then SQL*Loader can access the data with correct results only if the size of a <code dir="ltr">LONG</code> <code dir="ltr">INT</code> in the C programming language is the same length in bytes on both systems. In that case, the appropriate technique must still be used (if necessary) to indicated the byte order of the data.</p>
<p>Specifying an explicit length for binary integers is useful in situations where the input data was created on a platform whose word length differs from that on which SQL*Loader is running. For instance, input data containing binary integers might be created on a 64-bit platform and loaded into a database using SQL*Loader on a 32-bit platform. In this case, use <code dir="ltr">INTEGER(8)</code> to instruct SQL*Loader to process the integers as 8-byte quantities, not as 4-byte quantities.</p>
<p>By default, <code dir="ltr">INTEGER</code> is treated as a <code dir="ltr">SIGNED</code> quantity. If you want SQL*Loader to treat it as an unsigned quantity, then specify <code dir="ltr">UNSIGNED</code>. To return to the default behavior, specify <code dir="ltr">SIGNED</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007642">"Loading Data Across Different Platforms"</a></div>
</div>
<!-- class="sect3" -->
<a id="i1006777"></a>
<div id="SUTIL1154" class="sect3">
<h4 class="sect3">SMALLINT</h4>
<p>The data is a half-word binary integer. The length of the field is the length of a half-word integer on your system. By default, it is treated as a <code dir="ltr">SIGNED</code> quantity. If you want SQL*Loader to treat it as an unsigned quantity, then specify <code dir="ltr">UNSIGNED</code>. To return to the default behavior, specify <code dir="ltr">SIGNED</code>.</p>
<p><code dir="ltr">SMALLINT</code> can be loaded with correct results only between systems where a <code dir="ltr">SHORT INT</code> has the same length in bytes. If the byte order is different between the systems, then use the appropriate technique to indicate the byte order of the data. See <a href="#i1011032">"Byte Ordering"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This is the <code dir="ltr">SHORT INT</code> datatype in the C programming language. One way to determine its length is to make a small control file with no data and look at the resulting log file. This length cannot be overridden in the control file.</div>
</div>
<!-- class="sect3" -->
<div id="SUTIL1155" class="sect3"><a id="sthref777"></a>
<h4 class="sect3">FLOAT</h4>
<p>The data is a single-precision, floating-point, binary number. If you specify <code dir="ltr"><span class="codeinlineitalic">end</span></code> in the <code dir="ltr">POSITION</code> clause, then <code dir="ltr"><span class="codeinlineitalic">end</span></code> is ignored. The length of the field is the length of a single-precision, floating-point binary number on your system. (The datatype is <code dir="ltr">FLOAT</code> in C.) This length cannot be overridden in the control file.</p>
<p><code dir="ltr">FLOAT</code> can be loaded with correct results only between systems where the representation of <code dir="ltr">FLOAT</code> is compatible and of the same length. If the byte order is different between the two systems, then use the appropriate technique to indicate the byte order of the data. See <a href="#i1011032">"Byte Ordering"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1156" class="sect3"><a id="sthref778"></a>
<h4 class="sect3">DOUBLE</h4>
<p>The data is a double-precision, floating-point binary number. If you specify <code dir="ltr"><span class="codeinlineitalic">end</span></code> in the <code dir="ltr">POSITION</code> clause, then <code dir="ltr"><span class="codeinlineitalic">end</span></code> is ignored. The length of the field is the length of a double-precision, floating-point binary number on your system. (The datatype is <code dir="ltr">DOUBLE</code> or <code dir="ltr">LONG FLOAT</code> in C.) This length cannot be overridden in the control file.</p>
<p><code dir="ltr">DOUBLE</code> can be loaded with correct results only between systems where the representation of <code dir="ltr">DOUBLE</code> is compatible and of the same length. If the byte order is different between the two systems, then use the appropriate technique to indicate the byte order of the data. See <a href="#i1011032">"Byte Ordering"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1157" class="sect3"><a id="sthref779"></a>
<h4 class="sect3">BYTEINT</h4>
<p>The decimal value of the binary representation of the byte is loaded. For example, the input character x"1C" is loaded as 28. The length of a <code dir="ltr">BYTEINT</code> field is always 1 byte. If <code dir="ltr">POSITION</code><code dir="ltr"><span class="codeinlineitalic">(start:end)</span></code> is specified, then <code dir="ltr"><span class="codeinlineitalic">end</span></code> is ignored. (The datatype is <code dir="ltr">UNSIGNED CHAR</code> in C.)</p>
<p>An example of the syntax for this datatype is:</p>
<pre dir="ltr">
(column1 position(1) BYTEINT, 
column2 BYTEINT, 
... 
) 
</pre></div>
<!-- class="sect3" -->
<a id="i1006807"></a>
<div id="SUTIL1158" class="sect3">
<h4 class="sect3">ZONED</h4>
<p><code dir="ltr">ZONED</code> data is in zoned decimal format: a string of decimal digits, one per byte, with the sign included in the last byte. (In COBOL, this is a <code dir="ltr">SIGN TRAILING</code> field.) The length of this field equals the precision (number of digits) that you specify.</p>
<p>The syntax for the <code dir="ltr">ZONED</code> datatype is:</p>
<img width="345" height="46" src="img/zoned.gif" alt="Description of zoned.gif follows" /><br />
<a id="sthref780" href="img_text/zoned.htm">Description of the illustration ''zoned.gif''</a><br />
<br />
<p>In this syntax, <code dir="ltr"><span class="codeinlineitalic">precision</span></code> is the number of digits in the number, and <code dir="ltr"><span class="codeinlineitalic">scale</span></code> (if given) is the number of digits to the right of the (implied) decimal point. The following example specifies an 8-digit integer starting at position 32:</p>
<pre dir="ltr">
sal  POSITION(32)  ZONED(8), 
 
</pre>
<p>The Oracle database uses the VAX/VMS zoned decimal format when the zoned data is generated on an ASCII-based platform. It is also possible to load zoned decimal data that is generated on an EBCDIC-based platform. In this case, Oracle uses the IBM format as specified in the ESA/390 Principles of Operations, version 8.1 manual. The format that is used depends on the character set encoding of the input data file. See <a href="ldr_control_file.htm#i1008293">"CHARACTERSET Parameter"</a> for more information.</p>
</div>
<!-- class="sect3" -->
<a id="i1009919"></a>
<div id="SUTIL1159" class="sect3">
<h4 class="sect3">DECIMAL</h4>
<p><code dir="ltr">DECIMAL</code> data is in packed decimal format: two digits per byte, except for the last byte, which contains a digit and sign. <code dir="ltr">DECIMAL</code> fields allow the specification of an implied decimal point, so fractional values can be represented.</p>
<p>The syntax for the <code dir="ltr">DECIMAL</code> datatype is:</p>
<img width="355" height="46" src="img/decimal.gif" alt="Description of decimal.gif follows" /><br />
<a id="sthref781" href="img_text/decimal.htm">Description of the illustration ''decimal.gif''</a><br />
<br />
<p>The <code dir="ltr"><span class="codeinlineitalic">precision</span></code> parameter is the number of digits in a value. The length of the field in bytes, as computed from digits, is (N+1)/2 rounded up.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">scale</span></code> parameter is the scaling factor, or number of digits to the right of the decimal point. The default is zero (indicating an integer). The scaling factor can be greater than the number of digits but cannot be negative.</p>
<p>An example is:</p>
<pre dir="ltr">
sal DECIMAL (7,2) 
</pre>
<p>This example would load a number equivalent to +12345.67. In the data record, this field would take up 4 bytes. (The byte length of a <code dir="ltr">DECIMAL</code> field is equivalent to (N+1)/2, rounded up, where <code dir="ltr">N</code> is the number of digits in the value, and 1 is added for the sign.)</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1160" class="sect3"><a id="sthref782"></a>
<h4 class="sect3">VARGRAPHIC</h4>
<p>The data is a varying-length, double-byte character set (DBCS). It consists of a length subfield followed by a string of double-byte characters. The Oracle database does not support double-byte character sets; however, SQL*Loader reads them as single bytes and loads them as <code dir="ltr">RAW</code> data. Like <code dir="ltr">RAW</code> data, <code dir="ltr">VARGRAPHIC</code> fields are stored without modification in whichever column you specify.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The size of the length subfield is the size of the SQL*Loader <code dir="ltr">SMALLINT</code> datatype on your system (C type <code dir="ltr">SHORT INT</code>). See <a href="#i1006777">"SMALLINT"</a> for more information.</div>
<p><code dir="ltr">VARGRAPHIC</code> data can be loaded with correct results only between systems where a <code dir="ltr">SHORT INT</code> has the same length in bytes. If the byte order is different between the systems, then use the appropriate technique to indicate the byte order of the length subfield. See <a href="#i1011032">"Byte Ordering"</a>.</p>
<p>The syntax for the <code dir="ltr">VARGRAPHIC</code> datatype is:</p>
<img width="310" height="46" src="img/vargraphic.gif" alt="Description of vargraphic.gif follows" /><br />
<a id="sthref783" href="img_text/vargraphic.htm">Description of the illustration ''vargraphic.gif''</a><br />
<br />
<p>The length of the current field is given in the first 2 bytes. A maximum length specified for the <code dir="ltr">VARGRAPHIC</code> datatype does <span class="italic">not</span> include the size of the length subfield. The maximum length specifies the number of graphic (double-byte) characters. It is multiplied by 2 to determine the maximum length of the field in bytes.</p>
<p>The default maximum field length is 2 KB graphic characters, or 4 KB<br />
(2 * 2KB). To minimize memory requirements, specify a maximum length for such fields whenever possible.</p>
<p>If a position specification is specified (using <code dir="ltr">pos_spec</code>) before the <code dir="ltr">VARGRAPHIC</code> statement, then it provides the location of the length subfield, not of the first graphic character. If you specify <code dir="ltr">pos_spec</code><code dir="ltr"><span class="codeinlineitalic">(start:end),</span></code> then the end location determines a maximum length for the field. Both <code dir="ltr"><span class="codeinlineitalic">start</span></code> and <code dir="ltr"><span class="codeinlineitalic">end</span></code> identify single-character (byte) positions in the file. <code dir="ltr"><span class="codeinlineitalic">Start</span></code> is subtracted from <code dir="ltr"><span class="codeinlineitalic">(end + 1)</span></code> to give the length of the field in bytes. If a maximum length is specified, then it overrides any maximum length calculated from the position specification.</p>
<p>If a <code dir="ltr">VARGRAPHIC</code> field is truncated by the end of the logical record before its full length is read, then a warning is issued. Because the length of a <code dir="ltr">VARGRAPHIC</code> field is embedded in every occurrence of the input data for that field, it is assumed to be accurate.</p>
<p><code dir="ltr">VARGRAPHIC</code> data cannot be delimited.</p>
</div>
<!-- class="sect3" -->
<a id="i1006877"></a>
<div id="SUTIL1161" class="sect3">
<h4 class="sect3">VARCHAR</h4>
<p>A <code dir="ltr">VARCHAR</code> field is a length-value datatype. It consists of a binary length subfield followed by a character string of the specified length. The length is in bytes unless character-length semantics are used for the data file. In that case, the length is in characters. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
<p><code dir="ltr">VARCHAR</code> fields can be loaded with correct results only between systems where a <code dir="ltr">SHORT</code> data field <code dir="ltr">INT</code> has the same length in bytes. If the byte order is different between the systems, or if the <code dir="ltr">VARCHAR</code> field contains data in the UTF16 character set, then use the appropriate technique to indicate the byte order of the length subfield and of the data. The byte order of the data is only an issue for the UTF16 character set. See <a href="#i1011032">"Byte Ordering"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The size of the length subfield is the size of the SQL*Loader <code dir="ltr">SMALLINT</code> datatype on your system (C type <code dir="ltr">SHORT</code> <code dir="ltr">INT</code>). See <a href="#i1006777">"SMALLINT"</a> for more information.</div>
<p>The syntax for the <code dir="ltr">VARCHAR</code> datatype is:</p>
<img width="291" height="46" src="img/varchar.gif" alt="Description of varchar.gif follows" /><br />
<a id="sthref784" href="img_text/varchar.htm">Description of the illustration ''varchar.gif''</a><br />
<br />
<p>A maximum length specified in the control file does <span class="italic">not</span> include the size of the length subfield. If you specify the optional maximum length for a <code dir="ltr">VARCHAR</code> datatype, then a buffer of that size, in bytes, is allocated for these fields. However, if character-length semantics are used for the data file, then the buffer size in bytes is the <code dir="ltr">max</code>_<code dir="ltr">length</code> times the size in bytes of the largest possible character in the character set. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
<p>The default maximum size is 4 KB. Specifying the smallest maximum length that is needed to load your data can minimize SQL*Loader's memory requirements, especially if you have many <code dir="ltr">VARCHAR</code> fields.</p>
<p>The <code dir="ltr">POSITION</code> clause, if used, gives the location, in bytes, of the length subfield, not of the first text character. If you specify <code dir="ltr">POSITION(start:end)</code>, then the end location determines a maximum length for the field. <code dir="ltr"><span class="codeinlineitalic">Start</span></code> is subtracted from <code dir="ltr"><span class="codeinlineitalic">(end + 1)</span></code> to give the length of the field in bytes. If a maximum length is specified, then it overrides any length calculated from <code dir="ltr">POSITION</code>.</p>
<p>If a <code dir="ltr">VARCHAR</code> field is truncated by the end of the logical record before its full length is read, then a warning is issued. Because the length of a <code dir="ltr">VARCHAR</code> field is embedded in every occurrence of the input data for that field, it is assumed to be accurate.</p>
<p><code dir="ltr">VARCHAR</code> data cannot be delimited.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1162" class="sect3"><a id="sthref785"></a>
<h4 class="sect3">VARRAW</h4>
<p><code dir="ltr">VARRAW</code> is made up of a 2-byte binary length subfield followed by a <code dir="ltr">RAW</code> string value subfield.</p>
<p><code dir="ltr">VARRAW</code> results in a <code dir="ltr">VARRAW</code> with a 2-byte length subfield and a maximum size of 4 KB (that is, the default). <code dir="ltr">VARRAW(65000)</code> results in a <code dir="ltr">VARRAW</code> with a length subfield of 2 bytes and a maximum size of 65000 bytes.</p>
<p><code dir="ltr">VARRAW</code> fields can be loaded between systems with different byte orders if the appropriate technique is used to indicate the byte order of the length subfield. See <a href="#i1011032">"Byte Ordering"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1163" class="sect3"><a id="sthref786"></a>
<h4 class="sect3">LONG VARRAW</h4>
<p><code dir="ltr">LONG VARRAW</code> is a <code dir="ltr">VARRAW</code> with a 4-byte length subfield instead of a 2-byte length subfield.</p>
<p><code dir="ltr">LONG VARRAW</code> results in a <code dir="ltr">VARRAW</code> with 4-byte length subfield and a maximum size of 4 KB (that is, the default). <code dir="ltr">LONG VARRAW(300000)</code> results in a <code dir="ltr">VARRAW</code> with a length subfield of 4 bytes and a maximum size of 300000 bytes.</p>
<p><code dir="ltr">LONG VARRAW</code> fields can be loaded between systems with different byte orders if the appropriate technique is used to indicate the byte order of the length subfield. See <a href="#i1011032">"Byte Ordering"</a>.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1164" class="sect2"><a id="sthref787"></a>
<h3 class="sect2">Portable Datatypes<a id="sthref788"></a></h3>
<p>The portable datatypes are grouped into value datatypes and length-value datatypes. The portable value datatypes are as follows:</p>
<ul>
<li>
<p><code dir="ltr">CHAR</code></p>
</li>
<li>
<p>Datetime and Interval</p>
</li>
<li>
<p><code dir="ltr">GRAPHIC</code></p>
</li>
<li>
<p><code dir="ltr">GRAPHIC</code> <code dir="ltr">EXTERNAL</code></p>
</li>
<li>
<p>Numeric <code dir="ltr">EXTERNAL</code> (<code dir="ltr">INTEGER</code>, <code dir="ltr">FLOAT</code>, <code dir="ltr">DECIMAL</code>, <code dir="ltr">ZONED</code>)</p>
</li>
<li>
<p><code dir="ltr">RAW</code></p>
</li>
</ul>
<p>The portable length-value datatypes are as follows:</p>
<ul>
<li>
<p><code dir="ltr">VARCHARC</code></p>
</li>
<li>
<p><code dir="ltr">VARRAWC</code></p>
</li>
</ul>
<p>The syntax for these datatypes is shown in the diagram for <a href="app_ldr_syntax.htm#BABIABHB">"datatype_spec"</a>.</p>
<p><a id="sthref789"></a><a id="sthref790"></a>The character datatypes are <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and the numeric <code dir="ltr">EXTERNAL</code> datatypes. These fields can be delimited and can have lengths (or maximum lengths) specified in the control file.</p>
<a id="i1015797"></a>
<div id="SUTIL1165" class="sect3">
<h4 class="sect3">CHAR</h4>
<p>The data field contains character data. The length, which is optional, is a maximum length. Note the following regarding length:</p>
<ul>
<li>
<p>If a length is not specified, then it is derived from the <code dir="ltr">POSITION</code> specification.</p>
</li>
<li>
<p>If a length <span class="italic">is</span> specified, then it overrides the length in the <code dir="ltr">POSITION</code> specification.</p>
</li>
<li>
<p>If no length is given and there is no <code dir="ltr">POSITION</code> specification, then <code dir="ltr">CHAR</code> data is assumed to have a length of 1, unless the field is delimited:</p>
<ul>
<li>
<p>For a delimited <code dir="ltr">CHAR</code> field, if a length is specified, then that length is used as a maximum.</p>
</li>
<li>
<p>For a delimited <code dir="ltr">CHAR</code> field for which no length is specified, the default is 255 bytes.</p>
</li>
<li>
<p>For a delimited <code dir="ltr">CHAR</code> field that is greater than 255 bytes, you must specify a maximum length. Otherwise you will receive an error stating that the field in the data file exceeds maximum length.</p>
</li>
</ul>
</li>
</ul>
<p>The syntax for the <code dir="ltr">CHAR</code> datatype is:</p>
<img width="319" height="46" src="img/char.gif" alt="Description of char.gif follows" /><br />
<a id="sthref791" href="img_text/char.htm">Description of the illustration ''char.gif''</a><br />
<br />
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007368">"Specifying Delimiters"</a></div>
</div>
<!-- class="sect3" -->
<a id="i1016161"></a>
<div id="SUTIL1166" class="sect3">
<h4 class="sect3">Datetime and Interval Datatypes</h4>
<p>Both datetimes and intervals are made up of fields. The values of these fields determine the value of the datatype.</p>
<p>The datetime datatypes are:</p>
<ul>
<li>
<p><code dir="ltr">DATE</code></p>
</li>
<li>
<p><code dir="ltr">TIME</code></p>
</li>
<li>
<p><code dir="ltr">TIME WITH TIME ZONE</code></p>
</li>
<li>
<p><code dir="ltr">TIMESTAMP</code></p>
</li>
<li>
<p><code dir="ltr">TIMESTAMP WITH TIME ZONE</code></p>
</li>
<li>
<p><code dir="ltr">TIMESTAMP WITH LOCAL TIME ZONE</code></p>
</li>
</ul>
<p>Values of datetime datatypes are sometimes called datetimes. In the following descriptions of the datetime datatypes you will see that, except for <code dir="ltr">DATE</code>, you are allowed to optionally specify a value for <code dir="ltr">fractional_second_precision</code>. The <code dir="ltr">fractional_second_precision</code> specifies the number of digits stored in the fractional part of the <code dir="ltr">SECOND</code> datetime field. When you create a column of this datatype, the value can be a number in the range 0 to 9. The default is 6.</p>
<p>The interval datatypes are:</p>
<ul>
<li>
<p><code dir="ltr">INTERVAL YEAR TO MONTH</code></p>
</li>
<li>
<p><code dir="ltr">INTERVAL DAY TO SECOND</code></p>
</li>
</ul>
<p>Values of interval datatypes are sometimes called intervals. The <code dir="ltr">INTERVAL YEAR TO MONTH</code> datatype lets you optionally specify a value for <code dir="ltr">year_precision</code>. The <code dir="ltr">year_precision</code> value is the number of digits in the <code dir="ltr">YEAR</code> datetime field. The default value is 2.</p>
<p>The <code dir="ltr">INTERVAL DAY TO SECOND</code> datatype lets you optionally specify values for <code dir="ltr">day_precision</code> and <code dir="ltr">fractional_second_precision</code>. The <code dir="ltr">day_precision</code> is the number of digits in the <code dir="ltr">DAY</code> datetime field. Accepted values are 0 to 9. The default is 2. The <code dir="ltr">fractional_second_precision</code> specifies the number of digits stored in the fractional part of the <code dir="ltr">SECOND</code> datetime field. When you create a column of this datatype, the value can be a number in the range 0 to 9. The default is 6.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more detailed information about specifying datetime and interval datatypes, including the use of <code dir="ltr">fractional_second_precision</code>, <code dir="ltr">year_precision</code>, and <code dir="ltr">day_precision</code></div>
<div id="SUTIL1167" class="sect4"><a id="sthref792"></a>
<h5 class="sect4">DATE</h5>
<p>The <code dir="ltr">DATE</code> field contains character data that should be converted to an Oracle date using the specified date mask. The syntax for the <code dir="ltr">DATE</code> field is:</p>
<img width="416" height="46" src="img/date.gif" alt="Description of date.gif follows" /><br />
<a id="sthref793" href="img_text/date.htm">Description of the illustration ''date.gif''</a><br />
<br />
<p>For example:</p>
<pre dir="ltr">
LOAD DATA 
INTO TABLE dates (col_a POSITION (1:15) DATE "DD-Mon-YYYY") 
BEGINDATA 
1-Jan-2008 
1-Apr-2008 28-Feb-2008 
</pre>
<p>Whitespace is ignored and dates are parsed from left to right unless delimiters are present. (A <code dir="ltr">DATE</code> field that consists entirely of whitespace is loaded as a <code dir="ltr">NULL</code> field.)</p>
<p>The length specification is optional, unless a varying-length date mask is specified. The length is in bytes unless character-length semantics are used for the data file. In that case, the length is in characters. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
<p>In the preceding example, the date mask, <code dir="ltr">"DD-Mon-YYYY"</code> contains 11 bytes, with byte-length semantics. Therefore, SQL*Loader expects a maximum of 11 bytes in the field, so the specification works properly. But, suppose a specification such as the following is given:</p>
<pre dir="ltr">
DATE "Month dd, YYYY" 
</pre>
<p>In this case, the date mask contains 14 bytes. If a value with a length longer than 14 bytes is specified, such as <code dir="ltr">"September 30, 2008"</code>, then a length must be specified.</p>
<p>Similarly, a length is required for any Julian dates (date mask "J"). A field length is required any time the length of the date string could exceed the length of the mask (that is, the count of bytes in the mask).</p>
<p>If an explicit length is not specified, then it can be derived from the <code dir="ltr">POSITION</code> clause. It is a good idea to specify the length whenever you use a mask, unless you are absolutely sure that the length of the data is less than, or equal to, the length of the mask.</p>
<p>An explicit length specification, if present, overrides the length in the <code dir="ltr">POSITION</code> clause. Either of these overrides the length derived from the mask. The mask may be any valid Oracle date mask. If you omit the mask, then the default Oracle date mask of "dd-mon-yy" is used.</p>
<p>The length must be enclosed in parentheses and the mask in quotation marks.</p>
<p>A field of datatype <code dir="ltr">DATE</code> may also be specified with delimiters. For more information, see <a href="#i1007368">"Specifying Delimiters"</a>.</p>
</div>
<!-- class="sect4" -->
<div id="SUTIL1168" class="sect4"><a id="sthref794"></a>
<h5 class="sect4">TIME</h5>
<p>The <code dir="ltr">TIME</code> datatype stores hour, minute, and second values. It is specified as follows:</p>
<pre dir="ltr">
TIME [(fractional_second_precision)]
</pre></div>
<!-- class="sect4" -->
<div id="SUTIL1169" class="sect4"><a id="sthref795"></a>
<h5 class="sect4">TIME WITH TIME ZONE</h5>
<p>The <code dir="ltr">TIME</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code> datatype is a variant of <code dir="ltr">TIME</code> that includes a time zone displacement in its value. The time zone displacement is the difference (in hours and minutes) between local time and UTC (coordinated universal time, formerly Greenwich mean time). It is specified as follows:</p>
<pre dir="ltr">
TIME [(fractional_second_precision)] WITH [LOCAL] TIME ZONE
</pre>
<p>If the <code dir="ltr">LOCAL</code> option is specified, then data stored in the database is normalized to the database time zone, and time zone displacement is not stored as part of the column data. When the data is retrieved, it is returned in the user's local session time zone.</p>
</div>
<!-- class="sect4" -->
<div id="SUTIL1170" class="sect4"><a id="sthref796"></a>
<h5 class="sect4">TIMESTAMP</h5>
<p>The <code dir="ltr">TIMESTAMP</code> datatype is an extension of the <code dir="ltr">DATE</code> datatype. It stores the year, month, and day of the <code dir="ltr">DATE</code> datatype, plus the hour, minute, and second values of the <code dir="ltr">TIME</code> datatype. It is specified as follows:</p>
<pre dir="ltr">
TIMESTAMP [(fractional_second_precision)]
</pre>
<p>If you specify a date value without a time component, then the default time is 12:00:00 a.m. (midnight).</p>
</div>
<!-- class="sect4" -->
<div id="SUTIL1171" class="sect4"><a id="sthref797"></a>
<h5 class="sect4">TIMESTAMP WITH TIME ZONE</h5>
<p>The <code dir="ltr">TIMESTAMP WITH TIME ZONE</code> datatype is a variant of <code dir="ltr">TIMESTAMP</code> that includes a time zone displacement in its value. The time zone displacement is the difference (in hours and minutes) between local time and UTC (coordinated universal time, formerly Greenwich mean time). It is specified as follows:</p>
<pre dir="ltr">
TIMESTAMP [(fractional_second_precision)] WITH TIME ZONE
</pre></div>
<!-- class="sect4" -->
<div id="SUTIL1172" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref798"></a>
<h5 class="sect4">TIMESTAMP WITH LOCAL TIME ZONE</h5>
<p>The <code dir="ltr">TIMESTAMP WITH LOCAL TIME ZONE</code> datatype is another variant of <code dir="ltr">TIMESTAMP</code> that includes a time zone offset in its value. Data stored in the database is normalized to the database time zone, and time zone displacement is not stored as part of the column data. When the data is retrieved, it is returned in the user's local session time zone. It is specified as follows:</p>
<pre dir="ltr">
TIMESTAMP [(fractional_second_precision)] WITH LOCAL TIME ZONE
</pre></div>
<!-- class="sect4" -->
<div id="SUTIL1173" class="sect4"><a id="sthref799"></a>
<h5 class="sect4">INTERVAL YEAR TO MONTH</h5>
<p>The <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code> datatype stores a period of time using the <code dir="ltr">YEAR</code> and <code dir="ltr">MONTH</code> datetime fields. It is specified as follows:</p>
<pre dir="ltr">
INTERVAL YEAR [(year_precision)] TO MONTH
</pre></div>
<!-- class="sect4" -->
<div id="SUTIL1174" class="sect4"><a id="sthref800"></a>
<h5 class="sect4">INTERVAL DAY TO SECOND</h5>
<p>The <code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code> datatype stores a period of time using the <code dir="ltr">DAY</code> and <code dir="ltr">SECOND</code> datetime fields. It is specified as follows:</p>
<pre dir="ltr">
INTERVAL DAY [(day_precision)] TO SECOND [(fractional_second_precision)]
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1013217"></a>
<div id="SUTIL1175" class="sect3">
<h4 class="sect3">GRAPHIC</h4>
<p>The data is in the form of a double-byte character set (DBCS). The Oracle database does not support double-byte character sets; however, SQL*Loader reads them as single bytes. Like <code dir="ltr">RAW</code> data, <code dir="ltr">GRAPHIC</code> fields are stored without modification in whichever column you specify.</p>
<p>The syntax for the <code dir="ltr">GRAPHIC</code> datatype is:</p>
<img width="281" height="46" src="img/graphic.gif" alt="Description of graphic.gif follows" /><br />
<a id="sthref801" href="img_text/graphic.htm">Description of the illustration ''graphic.gif''</a><br />
<br />
<p>For <code dir="ltr">GRAPHIC</code> and <code dir="ltr">GRAPHIC</code> <code dir="ltr">EXTERNAL</code>, specifying <code dir="ltr">POSITION</code><code dir="ltr"><span class="codeinlineitalic">(start:end)</span></code> gives the exact location of the field in the logical record.</p>
<p>If you specify a length for the <code dir="ltr">GRAPHIC</code> <code dir="ltr">(EXTERNAL)</code> datatype, however, then you give the number of double-byte graphic characters. That value is multiplied by 2 to find the length of the field in bytes. If the number of graphic characters is specified, then any length derived from <code dir="ltr">POSITION</code> is ignored. No delimited data field specification is allowed with <code dir="ltr">GRAPHIC</code> datatype specification.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1176" class="sect3"><a id="sthref802"></a>
<h4 class="sect3">GRAPHIC EXTERNAL</h4>
<p>If the DBCS field is surrounded by shift-in and shift-out characters, then use <code dir="ltr">GRAPHIC EXTERNAL</code>. This is identical to <code dir="ltr">GRAPHIC</code>, except that the first and last characters (the shift-in and shift-out) are not loaded.</p>
<p>The syntax for the <code dir="ltr">GRAPHIC</code> <code dir="ltr">EXTERNAL</code> datatype is:</p>
<img width="346" height="46" src="img/graphic_ext.gif" alt="Description of graphic_ext.gif follows" /><br />
<a id="sthref803" href="img_text/graphic_ext.htm">Description of the illustration ''graphic_ext.gif''</a><br />
<br />
<p><code dir="ltr">GRAPHIC</code> indicates that the data is double-byte characters. <code dir="ltr">EXTERNAL</code> indicates that the first and last characters are ignored. The <code dir="ltr"><span class="codeinlineitalic">graphic_char_length</span></code> value specifies the length in DBCS (see <a href="#i1013217">"GRAPHIC"</a>).</p>
<p>For example, let [ ] represent shift-in and shift-out characters, and let # represent any double-byte character.</p>
<p>To describe ####, use <code dir="ltr">POSITION(1:4) GRAPHIC</code> or <code dir="ltr">POSITION(1) GRAPHIC(2)</code>.</p>
<p>To describe [####], use <code dir="ltr">POSITION(1:6) GRAPHIC EXTERNAL</code> or <code dir="ltr">POSITION(1) GRAPHIC EXTERNAL(2)</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i1007110"></a>
<div id="SUTIL1177" class="sect3">
<h4 class="sect3">Numeric EXTERNAL</h4>
<p>The numeric <code dir="ltr">EXTERNAL</code> datatypes are the numeric datatypes (<code dir="ltr">INTEGER, FLOAT,</code> <code dir="ltr">DECIMAL,</code> and <code dir="ltr">ZONED</code>) specified as <code dir="ltr">EXTERNAL</code>, with optional length and delimiter specifications. The length is in bytes unless character-length semantics are used for the data file. In that case, the length is in characters. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
<p>These datatypes are the human-readable, character form of numeric data. The same rules that apply to <code dir="ltr">CHAR</code> data regarding length, position, and delimiters apply to numeric <code dir="ltr">EXTERNAL</code> data. See <a href="#i1015797">"CHAR"</a> for a complete description of these rules.</p>
<p>The syntax for the numeric <code dir="ltr">EXTERNAL</code> datatypes is shown as part of <a href="app_ldr_syntax.htm#BABIABHB">"datatype_spec"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The data is a number in character form, not binary representation. Therefore, these datatypes are identical to <code dir="ltr">CHAR</code> and are treated identically, <span class="italic">except for the use of DEFAULTIF</span>. If you want the default to be null, then use <code dir="ltr">CHAR</code>; if you want it to be zero, then use <code dir="ltr">EXTERNAL</code>. See <a href="#i1009345">"Using the WHEN, NULLIF, and DEFAULTIF Clauses"</a>.</div>
<p><code dir="ltr"><a id="sthref804"></a>FLOAT EXTERNAL</code> data can be given in either scientific<a id="sthref805"></a> or regular notation. Both "5.33" and "533E-2" are valid representations of the same value.<a id="sthref806"></a></p>
</div>
<!-- class="sect3" -->
<a id="i1007152"></a>
<div id="SUTIL1178" class="sect3">
<h4 class="sect3">RAW</h4>
<p>When raw, binary data is loaded "as is" into a <code dir="ltr">RAW</code> database column, it is not converted by the Oracle database. If it is loaded into a <code dir="ltr">CHAR</code> column, then the Oracle database converts it to hexadecimal. It cannot be loaded into a <code dir="ltr">DATE</code> or number column.</p>
<p>The syntax for the <code dir="ltr">RAW</code> datatype is as follows:</p>
<img width="182" height="46" src="img/raw.gif" alt="Description of raw.gif follows" /><br />
<a id="sthref807" href="img_text/raw.htm">Description of the illustration ''raw.gif''</a><br />
<br />
<p>The length of this field is the number of bytes specified in the control file. This length is limited only by the length of the target column in the database and by memory resources. The length is always in bytes, even if character-length semantics are used for the data file. <code dir="ltr">RAW</code> data fields cannot be delimited.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1179" class="sect3"><a id="sthref808"></a>
<h4 class="sect3">VARCHARC</h4>
<p>The datatype <code dir="ltr"><a id="sthref809"></a>VARCHARC</code> consists of a character length subfield followed by a character string value-subfield.</p>
<p>The declaration for <code dir="ltr">VARCHARC</code> specifies the length of the length subfield, optionally followed by the maximum size of any string. If byte-length semantics are in use for the data file, then the length and the maximum size are both in bytes. If character-length semantics are in use for the data file, then the length and maximum size are in characters. If a maximum size is not specified, then 4 KB is the default regardless of whether byte-length semantics or character-length semantics are in use.</p>
<p>For example:</p>
<ul>
<li>
<p><code dir="ltr">VARCHARC</code> results in an error because you must at least specify a value for the length subfield.</p>
</li>
<li>
<p><code dir="ltr">VARCHARC(7)</code> results in a <code dir="ltr">VARCHARC</code> whose length subfield is 7 bytes long and whose maximum size is 4 KB (the default) if byte-length semantics are used for the data file. If character-length semantics are used, then it results in a <code dir="ltr">VARCHARC</code> with a length subfield that is 7 characters long and a maximum size of 4 KB (the default). Remember that when a maximum size is not specified, the default of 4 KB is always used, regardless of whether byte-length or character-length semantics are in use.</p>
</li>
<li>
<p><code dir="ltr">VARCHARC(3,500)</code> results in a <code dir="ltr">VARCHARC</code> whose length subfield is 3 bytes long and whose maximum size is 500 bytes if byte-length semantics are used for the data file. If character-length semantics are used, then it results in a <code dir="ltr">VARCHARC</code> with a length subfield that is 3 characters long and a maximum size of 500 characters.</p>
</li>
</ul>
<p>See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1180" class="sect3"><a id="sthref810"></a>
<h4 class="sect3">VARRAWC</h4>
<p>The datatype <code dir="ltr"><a id="sthref811"></a>VARRAWC</code> consists of a <code dir="ltr">RAW</code> string value subfield.</p>
<p>For example:</p>
<ul>
<li>
<p><code dir="ltr">VARRAWC</code> results in an error.</p>
</li>
<li>
<p><code dir="ltr">VARRAWC(7)</code> results in a <code dir="ltr">VARRAWC</code> whose length subfield is 7 bytes long and whose maximum size is 4 KB (that is, the default).</p>
</li>
<li>
<p><code dir="ltr">VARRAWC(3,500)</code> results in a <code dir="ltr">VARRAWC</code> whose length subfield is 3 bytes long and whose maximum size is 500 bytes.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="i1007177"></a>
<div id="SUTIL1181" class="sect3">
<h4 class="sect3">Conflicting Native Datatype Field Lengths</h4>
<p><a id="sthref812"></a><a id="sthref813"></a>There are several ways to specify a length for a field. If multiple lengths are specified and they conflict, then one of the lengths takes precedence. A warning is issued when a conflict exists. The following rules determine which field length is used:</p>
<ol>
<li>
<p>The size of <code dir="ltr">SMALLINT</code>, <code dir="ltr">FLOAT</code>, and <code dir="ltr">DOUBLE</code> data is fixed, regardless of the number of bytes specified in the <code dir="ltr">POSITION</code> clause.</p>
</li>
<li>
<p>If the length (or precision) specified for a <code dir="ltr">DECIMAL</code>, <code dir="ltr">INTEGER</code>, <code dir="ltr">ZONED</code>, <code dir="ltr">GRAPHIC</code>, <code dir="ltr">GRAPHIC EXTERNAL</code>, or <code dir="ltr">RAW</code> field conflicts with the size calculated from a <code dir="ltr">POSITION</code><code dir="ltr"><span class="codeinlineitalic">(start:end)</span></code> specification, then the specified length (or precision) is used.</p>
</li>
<li>
<p>If the maximum size specified for a character or <code dir="ltr">VARGRAPHIC</code> field conflicts with the size calculated from a <code dir="ltr">POSITION</code><code dir="ltr"><span class="codeinlineitalic">(start:end)</span></code> specification, then the specified maximum is used.</p>
</li>
</ol>
<p>For example, assume that the native datatype <code dir="ltr">INTEGER</code> is 4 bytes long and the following field specification is given:</p>
<pre dir="ltr">
column1 POSITION(1:6) INTEGER 
</pre>
<p>In this case, a warning is issued, and the proper length (4) is used. The log file shows the actual length used under the heading "Len" in the column table:</p>
<pre dir="ltr">
Column Name             Position   Len  Term Encl Datatype 
----------------------- --------- ----- ---- ---- --------- 
COLUMN1                       1:6     4             INTEGER 
</pre></div>
<!-- class="sect3" -->
<div id="SUTIL1182" class="sect3"><a id="sthref814"></a>
<h4 class="sect3">Field Lengths for Length-Value Datatypes</h4>
<p>A control file can specify a maximum length for the following length-value datatypes: <code dir="ltr">VARCHAR</code>, <code dir="ltr">VARCHARC</code>, <code dir="ltr">VARGRAPHIC</code>, <code dir="ltr">VARRAW</code>, and <code dir="ltr">VARRAWC</code>. The specified maximum length is in bytes if byte-length semantics are used for the field, and in characters if character-length semantics are used for the field. If no length is specified, then the maximum length defaults to 4096 bytes. If the length of the field exceeds the maximum length, then the record is rejected with the following error:</p>
<pre dir="ltr">
Variable length field exceed maximum length
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABDBDFG"></a>
<div id="SUTIL1183" class="sect2">
<h3 class="sect2">Datatype Conversions</h3>
<p><a id="sthref815"></a>The datatype specifications in the control file tell SQL*Loader how to interpret the information in the data file. The server defines the datatypes for the columns in the database. The link between these two is the <span class="italic">column name</span> specified in the control file.</p>
<p>SQL*Loader extracts data from a field in the input file, guided by the datatype specification in the control file. SQL*Loader then sends the field to the server to be stored in the appropriate column (as part of an array of row inserts).</p>
<p>SQL*Loader or the server does any necessary data conversion to store the data in the proper internal format. This includes converting data from the data file character set to the database character set when they differ.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When you use SQL*Loader conventional path to load character data from the data file into a <code dir="ltr">LONG RAW</code> column, the character data is interpreted has a HEX string. SQL converts the HEX string into its binary representation. Be aware that any string longer than 4000 bytes exceeds the byte limit for the SQL <code dir="ltr">HEXTORAW</code> conversion operator. An error will be returned. SQL*Loader will reject that row and continue loading.</div>
<p>The datatype of the data in the file does not need to be the same as the datatype of the column in the Oracle table. The Oracle database automatically performs conversions, but you need to ensure that the conversion makes sense and does not generate errors. For instance, when a data file field with datatype <code dir="ltr">CHAR</code> is loaded into a database column with datatype <code dir="ltr">NUMBER</code>, you must ensure that the contents of the character field represent a valid number.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL*Loader does <span class="italic">not</span> contain datatype specifications for Oracle internal datatypes such as <code dir="ltr">NUMBER</code> or <code dir="ltr">VARCHAR2</code>.<a id="sthref816"></a> The SQL*Loader datatypes describe data that can be produced<a id="sthref817"></a> with text editors (<span class="italic">character</span> datatypes) and with standard programming languages (<span class="italic">native</span> datatypes). However, although SQL*Loader does not recognize datatypes like <code dir="ltr">NUMBER</code> and <code dir="ltr">VARCHAR2</code>, any data that the Oracle database can convert can be loaded into these or other database columns.</div>
</div>
<!-- class="sect2" -->
<div id="SUTIL1184" class="sect2"><a id="sthref818"></a>
<h3 class="sect2">Datatype Conversions for Datetime and Interval Datatypes</h3>
<p><a href="#g1026785">Table 10-2</a> shows which conversions between Oracle database datatypes and SQL*Loader control file datetime and interval datatypes are supported and which are not.</p>
<p>In the table, the abbreviations for the Oracle Database Datatypes are as follows:</p>
<p>N = <code dir="ltr">NUMBER</code></p>
<p>C = <code dir="ltr">CHAR</code> or <code dir="ltr">VARCHAR2</code></p>
<p>D = <code dir="ltr">DATE</code></p>
<p>T = <code dir="ltr">TIME</code> and <code dir="ltr">TIME</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
<p>TS = <code dir="ltr">TIMESTAMP</code> and <code dir="ltr">TIMESTAMP</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code></p>
<p>YM = <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code></p>
<p>DS = <code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code></p>
<p>For the SQL*Loader datatypes, the definitions for the abbreviations in the table are the same for D, T, TS, YM, and DS. However, as noted in the previous section, SQL*Loader does <span class="italic">not</span> contain datatype specifications for Oracle internal datatypes such as <code dir="ltr">NUMBER,CHAR</code>, and <code dir="ltr">VARCHAR2</code>.<a id="sthref819"></a> However, any data that the Oracle database can convert can be loaded into these or other database columns.</p>
<p>For an example of how to read this table, look at the row for the SQL*Loader datatype <code dir="ltr">DATE</code> (abbreviated as D). Reading across the row, you can see that datatype conversion is supported for the Oracle database datatypes of <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">DATE</code>, <code dir="ltr">TIMESTAMP</code>, and <code dir="ltr">TIMESTAMP WITH TIME ZONE</code> datatypes. However, conversion is not supported for the Oracle database datatypes <code dir="ltr">NUMBER</code>, <code dir="ltr">TIME</code>, <code dir="ltr">TIME</code> <code dir="ltr">WITH</code> <code dir="ltr">TIME</code> <code dir="ltr">ZONE</code>, <code dir="ltr">INTERVAL</code> <code dir="ltr">YEAR</code> <code dir="ltr">TO</code> <code dir="ltr">MONTH</code>, or <code dir="ltr">INTERVAL</code> <code dir="ltr">DAY</code> <code dir="ltr">TO</code> <code dir="ltr">SECOND</code> datatypes.</p>
<div id="SUTIL3339" class="tblformal">
<p class="titleintable"><a id="sthref820"></a><a id="g1026785"></a>Table 10-2 Datatype Conversions for Datetime and Interval Datatypes</p>
<table class="cellalignment1394" title="Datatype Conversions for Datetime and Interval Datatypes" summary="Datatype conversions for datetime and interval datatypes" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t15">SQL*Loader Datatype</th>
<th class="cellalignment1395" id="r1c2-t15">Oracle Database Datatype (Conversion Support)</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t15" headers="r1c1-t15">
<p><span class="bold">N</span></p>
</td>
<td class="cellalignment1396" headers="r2c1-t15 r1c2-t15">
<p><span class="bold">N</span> (Yes), <span class="bold">C</span> (Yes), <span class="bold">D</span> (No), <span class="bold">T</span> (No), <span class="bold">TS</span> (No), <span class="bold">YM</span> (No), <span class="bold">DS</span> (No)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t15" headers="r1c1-t15">
<p><span class="bold">C</span></p>
</td>
<td class="cellalignment1396" headers="r3c1-t15 r1c2-t15">
<p><span class="bold">N</span> (Yes), <span class="bold">C</span> (Yes), <span class="bold">D</span> (Yes), <span class="bold">T</span> (Yes), <span class="bold">TS</span> (Yes), <span class="bold">YM</span> (Yes), <span class="bold">DS</span> (Yes)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t15" headers="r1c1-t15">
<p><span class="bold">D</span></p>
</td>
<td class="cellalignment1396" headers="r4c1-t15 r1c2-t15">
<p><span class="bold">N</span> (No), <span class="bold">C</span> (Yes), <span class="bold">D</span> (Yes), <span class="bold">T</span> (No), <span class="bold">TS</span> (Yes), <span class="bold">YM</span> (No), <span class="bold">DS</span> (No)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t15" headers="r1c1-t15">
<p><span class="bold">T</span></p>
</td>
<td class="cellalignment1396" headers="r5c1-t15 r1c2-t15">
<p><span class="bold">N</span> (No), <span class="bold">C</span> (Yes), <span class="bold">D</span> (No), <span class="bold">T</span> (Yes), <span class="bold">TS</span> (Yes), <span class="bold">YM</span> (No), <span class="bold">DS</span> (No)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t15" headers="r1c1-t15">
<p><span class="bold">TS</span></p>
</td>
<td class="cellalignment1396" headers="r6c1-t15 r1c2-t15">
<p><span class="bold">N</span> (No), <span class="bold">C</span> (Yes), <span class="bold">D</span> (Yes), <span class="bold">T</span> (Yes), <span class="bold">TS</span> (Yes), <span class="bold">YM</span> (No), <span class="bold">DS</span> (No)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t15" headers="r1c1-t15">
<p><span class="bold">YM</span></p>
</td>
<td class="cellalignment1396" headers="r7c1-t15 r1c2-t15">
<p><span class="bold">N</span> (No), <span class="bold">C</span> (Yes), <span class="bold">D</span> (No), <span class="bold">T</span> (No), <span class="bold">TS</span> (No), <span class="bold">YM</span> (Yes), <span class="bold">DS</span> (No)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t15" headers="r1c1-t15">
<p><span class="bold">DS</span></p>
</td>
<td class="cellalignment1396" headers="r8c1-t15 r1c2-t15">
<p><span class="bold">N</span> (No), <span class="bold">C</span> (Yes), <span class="bold">D</span> (No), <span class="bold">T</span> (No), <span class="bold">TS</span> (No), <span class="bold">YM</span> (No), <span class="bold">DS</span> (Yes)</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" --></div>
<!-- class="sect2" -->
<a id="i1007368"></a>
<div id="SUTIL1185" class="sect2">
<h3 class="sect2">Specifying Delimiters</h3>
<p><a id="sthref821"></a><a id="sthref822"></a><a id="sthref823"></a><a id="sthref824"></a><a id="sthref825"></a><a id="sthref826"></a>The boundaries of <code dir="ltr">CHAR</code>, datetime, interval, or numeric <code dir="ltr">EXTERNAL</code> fields can also be marked by delimiter<a id="sthref827"></a> characters contained in the input data record. The delimiter characters are specified using various combinations of the <code dir="ltr">TERMINATED BY</code>, <code dir="ltr">ENCLOSED BY</code>, and <code dir="ltr">OPTIONALLY ENCLOSED BY</code> clauses (the <code dir="ltr">TERMINATED BY</code> clause, if used, must come first). The delimiter specification comes after the datatype specification.</p>
<p>For a description of how data is processed when various combinations of delimiter clauses are used, see <a href="#CIHJCIHG">"How Delimited Data Is Processed"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">RAW</code> datatype can also be marked by delimiters, but only if it is in an input LOBFILE, and only if the delimiter is <code dir="ltr">TERMINATED BY EOF</code> (end of file).</div>
<a id="i1015415"></a>
<div id="SUTIL1186" class="sect3">
<h4 class="sect3">Syntax for Termination and Enclosure Specification</h4>
<p>The following diagram shows the syntax for <code dir="ltr">termination_spec</code> and <code dir="ltr">enclosure_spec</code>.</p>
<img width="340" height="123" src="img/terminat.gif" alt="Description of terminat.gif follows" /><br />
<a id="sthref828" href="img_text/terminat.htm">Description of the illustration ''terminat.gif''</a><br />
<br />
<img width="541" height="79" src="img/enclose.gif" alt="Description of enclose.gif follows" /><br />
<a id="sthref829" href="img_text/enclose.htm">Description of the illustration ''enclose.gif''</a><br />
<br />
<p><a href="#g1026582">Table 10-3</a> describes the syntax for the termination and enclosure specifications used to specify delimiters.</p>
<div id="SUTIL3340" class="tblformal">
<p class="titleintable"><a id="sthref830"></a><a id="g1026582"></a>Table 10-3 Parameters Used for Specifying Delimiters</p>
<table class="cellalignment1394" title="Parameters Used for Specifying Delimiters" summary="Parameters used for specifying delimiters" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t17">Parameter</th>
<th class="cellalignment1395" id="r1c2-t17">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t17" headers="r1c1-t17">
<p><code dir="ltr">TERMINATED</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t17 r1c2-t17">
<p>Data is read until the first occurrence of a delimiter.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t17" headers="r1c1-t17">
<p><code dir="ltr">BY</code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t17 r1c2-t17">
<p>An optional word to increase readability.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t17" headers="r1c1-t17">
<p><code dir="ltr">WHITESPACE</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t17 r1c2-t17">
<p>Delimiter is any whitespace character including spaces, tabs, blanks, line feeds, form feeds, or carriage returns. (Only used with <code dir="ltr">TERMINATED</code>, not with <code dir="ltr">ENCLOSED</code>.)</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t17" headers="r1c1-t17">
<p><code dir="ltr">OPTIONALLY</code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t17 r1c2-t17">
<p>Data can be enclosed by the specified character. If SQL*Loader finds a first occurrence of the character, then it reads the data value until it finds the second occurrence. If the data is not enclosed, then the data is read as a terminated field. If you specify an optional enclosure, then you must specify a <code dir="ltr">TERMINATED BY</code> clause (either locally in the field definition or globally in the <code dir="ltr">FIELDS</code> clause).</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t17" headers="r1c1-t17">
<p><code dir="ltr">ENCLOSED</code></p>
</td>
<td class="cellalignment1396" headers="r6c1-t17 r1c2-t17">
<p>The data will be found between two delimiters.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t17" headers="r1c1-t17">
<p><code dir="ltr"><span class="codeinlineitalic">string</span></code></p>
</td>
<td class="cellalignment1396" headers="r7c1-t17 r1c2-t17">
<p>The delimiter is a string.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t17" headers="r1c1-t17">
<p><code dir="ltr"><span class="codeinlineitalic">X'hexstr</span></code>'</p>
</td>
<td class="cellalignment1396" headers="r8c1-t17 r1c2-t17">
<p>The delimiter is a string that has the value specified by <code dir="ltr"><span class="codeinlineitalic">X'hexstr'</span></code> in the character encoding scheme, such as X'1F' (equivalent to 31 decimal). "X" can be either lowercase or uppercase.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r9c1-t17" headers="r1c1-t17">
<p><code dir="ltr">AND</code></p>
</td>
<td class="cellalignment1396" headers="r9c1-t17 r1c2-t17">
<p>Specifies a trailing enclosure delimiter that may be different from the initial enclosure delimiter. If <code dir="ltr">AND</code> is not present, then the initial and trailing delimiters are assumed to be the same.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r10c1-t17" headers="r1c1-t17">
<p><code dir="ltr">EOF</code></p>
</td>
<td class="cellalignment1396" headers="r10c1-t17 r1c2-t17">
<p>Indicates that the entire file has been loaded into the LOB. This is valid only when data is loaded from a LOB file. Fields terminated by <code dir="ltr">EOF</code> cannot be enclosed.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>Here are some examples, with samples of the data they describe:</p>
<pre dir="ltr">
TERMINATED BY ','                      a data string, 
ENCLOSED BY '"'                        "a data string" 
TERMINATED BY ',' ENCLOSED BY '"'      "a data string", 
ENCLOSED BY '(' AND ')'                (a data string) 
</pre></div>
<!-- class="sect3" -->
<div id="SUTIL1187" class="sect3"><a id="sthref831"></a>
<h4 class="sect3">Delimiter Marks in the Data</h4>
<p>Sometimes the punctuation mark that is a delimiter must also be included in the data. To make that possible, two adjacent delimiter characters are interpreted as a single occurrence of the character, and this character is included in the data. For example, this data:<a id="sthref832"></a><a id="sthref833"></a></p>
<pre dir="ltr">
(The delimiters are left parentheses, (, and right parentheses, )).) 
</pre>
<p>with this field specification:</p>
<pre dir="ltr">
ENCLOSED BY "(" AND ")" 
</pre>
<p>puts the following string into the database:</p>
<pre dir="ltr">
The delimiters are left parentheses, (, and right parentheses, ). 
</pre>
<p>For this reason, problems can arise when adjacent fields use the same delimiters. For example, with the following specification:</p>
<pre dir="ltr">
field1 TERMINATED BY "/" 
field2 ENCLOSED by "/" 
</pre>
<p>the following data will be interpreted properly:</p>
<pre dir="ltr">
This is the first string/      /This is the second string/ 
</pre>
<p>But if <code dir="ltr">field1</code> and <code dir="ltr">field2</code> were adjacent, then the results would be incorrect, because</p>
<pre dir="ltr">
This is the first string//This is the second string/ 
</pre>
<p>would be interpreted as a single character string with a "/" in the middle, and that string would belong to <code dir="ltr">field1</code>.</p>
</div>
<!-- class="sect3" -->
<a id="i1007477"></a>
<div id="SUTIL1188" class="sect3">
<h4 class="sect3">Maximum Length of Delimited Data</h4>
<p>The default maximum length of delimited data is 255 bytes. Therefore, delimited fields can require significant amounts of storage for the bind array. A good policy is to specify the smallest possible maximum value if the fields are shorter than 255 bytes. If the fields are longer than 255 bytes, then you must specify a maximum length for the field, either with a length specifier or with the <code dir="ltr">POSITION</code> clause.<a id="sthref834"></a><a id="sthref835"></a></p>
<p>For example, if you have a string literal that is longer than 255 bytes, then in addition to using <code dir="ltr">SUBSTR()</code>, use <code dir="ltr">CHAR()</code> to specify the longest string in any record for the field. An example of how this would look is as follows, assuming that 600 bytes is the longest string in any record for <code dir="ltr">field1</code>:</p>
<pre dir="ltr">
field1 CHAR(600) SUBSTR(:field, 1, 240)
</pre></div>
<!-- class="sect3" -->
<div id="SUTIL1189" class="sect3"><a id="sthref836"></a>
<h4 class="sect3">Loading Trailing Blanks with Delimiters</h4>
<p><a id="sthref837"></a><a id="sthref838"></a><a id="sthref839"></a>Trailing blanks are not loaded with nondelimited datatypes unless you specify <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code>. If a data field is 9 characters long and contains the value <code dir="ltr">DANIEL</code><code dir="ltr"><span class="codeinlineitalic">bbb</span></code>, where <code dir="ltr"><span class="codeinlineitalic">bbb</span></code> is three blanks, then it is loaded into the Oracle database as "<code dir="ltr">DANIEL"</code> if declared as <code dir="ltr">CHAR(9)</code>.</p>
<p>If you want the trailing blanks, then you could declare it as <code dir="ltr">CHAR(9)</code> <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> <code dir="ltr">':'</code>, and add a colon to the data file so that the field is <code dir="ltr">DANIEL</code><code dir="ltr"><span class="codeinlineitalic">bbb</span></code><code dir="ltr">:</code>. This field is loaded as <code dir="ltr">"DANIEL "</code>, with the trailing blanks. You could also specify <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> without the <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> clause and obtain the same results.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1007768">"Trimming Whitespace"</a></p>
</li>
<li>
<p><a href="#i1008122">"How the PRESERVE BLANKS Option Affects Whitespace Trimming"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CIHJCIHG"></a>
<div id="SUTIL1190" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">How Delimited Data Is Processed</h3>
<p>To specify delimiters, field definitions can use various combinations of the <code dir="ltr">TERMINATED BY</code>, <code dir="ltr">ENCLOSED BY</code>, and <code dir="ltr">OPTIONALLY ENCLOSED BY</code> clauses. The following sections describe the processing that takes place in each case:</p>
<ul>
<li>
<p><a href="#CIHJGBJA">Fields Using Only TERMINATED BY</a></p>
</li>
<li>
<p><a href="#CIHBBJGC">Fields Using ENCLOSED BY Without TERMINATED BY</a></p>
</li>
<li>
<p><a href="#CIHIFBGE">Fields Using ENCLOSED BY With TERMINATED BY</a></p>
</li>
<li>
<p><a href="#CIHDJIGJ">Fields Using OPTIONALLY ENCLOSED BY With TERMINATED BY</a></p>
</li>
</ul>
<p>Each of these scenarios is described in the following sections.</p>
<a id="CIHJGBJA"></a>
<div id="SUTIL1191" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Fields Using Only TERMINATED BY</h4>
<p>If <code dir="ltr">TERMINATED BY</code> is specified for a field without <code dir="ltr">ENCLOSED BY</code>, then the data for the field is read from the starting position of the field up to, but not including, the first occurrence of the <code dir="ltr">TERMINATED BY</code> delimiter. If the terminator delimiter is found in the first column position of a field, then the field is null. If the end of the record is found before the <code dir="ltr">TERMINATED BY</code> delimiter, then all data up to the end of the record is considered part of the field.</p>
<p>If <code dir="ltr">TERMINATED BY WHITESPACE</code> is specified, then data is read until the first occurrence of a whitespace character (spaces, tabs, blanks, line feeds, form feeds, or carriage returns). Then the current position is advanced until no more adjacent whitespace characters are found. This allows field values to be delimited by varying amounts of whitespace. However, unlike non-whitespace terminators, if a whitespace terminator is found in the first column position of a field, then the field is <span class="italic">not</span> treated as null and can result in record rejection or fields loaded into incorrect columns.</p>
</div>
<!-- class="sect3" -->
<a id="CIHBBJGC"></a>
<div id="SUTIL1192" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Fields Using ENCLOSED BY Without TERMINATED BY</h4>
<p>The following steps take place when a field uses an <code dir="ltr">ENCLOSED BY</code> clause without also using a <code dir="ltr">TERMINATED BY</code> clause.</p>
<ol>
<li>
<p>Any whitespace at the beginning of the field is skipped.</p>
</li>
<li>
<p>The first non-whitespace character found must be the start of a string that matches the first <code dir="ltr">ENCLOSED BY</code> delimiter. If it is not, then the row is rejected.</p>
</li>
<li>
<p>If the first <code dir="ltr">ENCLOSED BY</code> delimiter is found, then the search for the second <code dir="ltr">ENCLOSED BY</code> delimiter begins.</p>
</li>
<li>
<p>If two of the second <code dir="ltr">ENCLOSED BY</code> delimiters are found adjacent to each other, then they are interpreted as a single occurrence of the delimiter and included as part of the data for the field. The search then continues for another instance of the second <code dir="ltr">ENCLOSED BY</code> delimiter.</p>
</li>
<li>
<p>If the end of the record is found before the second <code dir="ltr">ENCLOSED BY</code> delimiter is found, then the row is rejected.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="CIHIFBGE"></a>
<div id="SUTIL1193" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Fields Using ENCLOSED BY With TERMINATED BY</h4>
<p>The following steps take place when a field uses an <code dir="ltr">ENCLOSED BY</code> clause and also uses a <code dir="ltr">TERMINATED BY</code> clause.</p>
<ol>
<li>
<p>Any whitespace at the beginning of the field is skipped.</p>
</li>
<li>
<p>The first non-whitespace character found must be the start of a string that matches the first <code dir="ltr">ENCLOSED BY</code> delimiter. If it is not, then the row is rejected.</p>
</li>
<li>
<p>If the first <code dir="ltr">ENCLOSED BY</code> delimiter is found, then the search for the second <code dir="ltr">ENCLOSED BY</code> delimiter begins.</p>
</li>
<li>
<p>If two of the second <code dir="ltr">ENCLOSED BY</code> delimiters are found adjacent to each other, then they are interpreted as a single occurrence of the delimiter and included as part of the data for the field. The search then continues for the second instance of the <code dir="ltr">ENCLOSED BY</code> delimiter.</p>
</li>
<li>
<p>If the end of the record is found before the second <code dir="ltr">ENCLOSED BY</code> delimiter is found, then the row is rejected.</p>
</li>
<li>
<p>If the second <code dir="ltr">ENCLOSED BY</code> delimiter is found, then the parser looks for the <code dir="ltr">TERMINATED BY</code> delimiter. If the <code dir="ltr">TERMINATED BY</code> delimiter is anything other than <code dir="ltr">WHITESPACE</code>, then whitespace found between the end of the second <code dir="ltr">ENCLOSED BY</code> delimiter and the <code dir="ltr">TERMINATED BY</code> delimiter is skipped over.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Only <code dir="ltr">WHITESPACE</code> is allowed between the second <code dir="ltr">ENCLOSED BY</code> delimiter and the <code dir="ltr">TERMINATED BY</code> delimiter. Any other characters will cause an error.</div>
</li>
<li>
<p>The row is <span class="italic">not</span> rejected if the end of the record is found before the <code dir="ltr">TERMINATED BY</code> delimiter is found.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="CIHDJIGJ"></a>
<div id="SUTIL1194" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Fields Using OPTIONALLY ENCLOSED BY With TERMINATED BY</h4>
<p>The following steps take place when a field uses an <code dir="ltr">OPTIONALLY ENCLOSED BY</code> clause and a <code dir="ltr">TERMINATED BY</code> clause.</p>
<ol>
<li>
<p>Any whitespace at the beginning of the field is skipped.</p>
</li>
<li>
<p>The parser checks to see if the first non-whitespace character found is the start of a string that matches the first <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter. If it is not, and the <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiters are <span class="italic">not</span> present in the data, then the data for the field is read from the current position of the field up to, but not including, the first occurrence of the <code dir="ltr">TERMINATED BY</code> delimiter. If the <code dir="ltr">TERMINATED BY</code> delimiter is found in the first column position, then the field is null. If the end of the record is found before the <code dir="ltr">TERMINATED BY</code> delimiter, then all data up to the end of the record is considered part of the field.</p>
</li>
<li>
<p>If the first <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter is found, then the search for the second <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter begins.</p>
</li>
<li>
<p>If two of the second <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiters are found adjacent to each other, then they are interpreted as a single occurrence of the delimiter and included as part of the data for the field. The search then continues for the second <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter.</p>
</li>
<li>
<p>If the end of the record is found before the second <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter is found, then the row is rejected.</p>
</li>
<li>
<p>If the <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter <span class="italic">is</span> present in the data, then the parser looks for the <code dir="ltr">TERMINATED BY</code> delimiter. If the <code dir="ltr">TERMINATED BY</code> delimiter is anything other than <code dir="ltr">WHITESPACE</code>, then whitespace found between the end of the second <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter and the <code dir="ltr">TERMINATED BY</code> delimiter is skipped over.</p>
</li>
<li>
<p>The row is <span class="italic">not</span> rejected if the end of record is found before the <code dir="ltr">TERMINATED BY</code> delimiter is found.</p>
</li>
</ol>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Be careful when you specify whitespace characters as the <code dir="ltr">TERMINATED BY</code> delimiter and are also using <code dir="ltr">OPTIONALLY ENCLOSED BY</code>. SQL*Loader strips off leading whitespace when looking for an <code dir="ltr">OPTIONALLY ENCLOSED BY</code> delimiter. If the data contains two adjacent <code dir="ltr">TERMINATED BY</code> delimiters in the middle of a record (usually done to set a field in the record to NULL), then the whitespace for the first <code dir="ltr">TERMINATED BY</code> delimiter will be used to terminate a field, but the remaining whitespace will be considered as leading whitespace for the next field rather than the <code dir="ltr">TERMINATED BY</code> delimiter for the next field. If you want to load a NULL value, then you must include the <code dir="ltr">ENCLOSED BY</code> delimiters in the data.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007505"></a>
<div id="SUTIL1195" class="sect2">
<h3 class="sect2">Conflicting Field Lengths for Character Datatypes</h3>
<p><a id="sthref840"></a><a id="sthref841"></a><a id="sthref842"></a><a id="sthref843"></a><a id="sthref844"></a>A control file can specify multiple lengths for the character-data fields <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and numeric <code dir="ltr">EXTERNAL</code>. If conflicting lengths are specified, then one of the lengths takes precedence. A warning is also issued when a conflict exists. This section explains which length is used.</p>
<div id="SUTIL1196" class="sect3"><a id="sthref845"></a>
<h4 class="sect3">Predetermined Size Fields</h4>
<p><a id="sthref846"></a>If you specify a starting position and ending position for one of these fields, then the length of the field is determined by these specifications. If you specify a length as part of the datatype and do not give an ending position, the field has the given length. If starting position, ending position, and length are all specified, and the lengths differ, then the length given as part of the datatype specification is used for the length of the field, as follows:</p>
<pre dir="ltr">
POSITION(1:10) CHAR(15) 
</pre>
<p>In this example, the length of the field is 15.</p>
</div>
<!-- class="sect3" -->
<a id="i1007521"></a>
<div id="SUTIL1197" class="sect3">
<h4 class="sect3">Delimited Fields</h4>
<p><a id="sthref847"></a><a id="sthref848"></a>If a delimited field is specified with a length, or if a length can be calculated from the starting and ending positions, then that length is the <span class="italic">maximum</span> length of the field. The specified maximum length is in bytes if byte-length semantics are used for the field, and in characters if character-length semantics are used for the field. If no length is specified or can be calculated from the start and end positions, then the maximum length defaults to 255 bytes. The actual length can vary up to that maximum, based on the presence of the delimiter.</p>
<p>If delimiters and also starting and ending positions are specified for the field, then only the position specification has any effect. Any enclosure or termination delimiters are ignored.</p>
<p>If the expected delimiter is absent, then the end of record terminates the field. If <code dir="ltr">TRAILING NULLCOLS</code> is specified, then remaining fields are null. If either the delimiter or the end of record produces a field that is longer than the maximum, then SQL*Loader rejects the record and returns an error.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1198" class="sect3"><a id="sthref849"></a>
<h4 class="sect3">Date Field Masks</h4>
<p><a id="sthref850"></a><a id="sthref851"></a><a id="sthref852"></a>The length of a date field depends on the mask, if a mask is specified. The mask provides a format pattern, telling SQL*Loader how to interpret the data in the record. For example, assume the mask is specified as follows:</p>
<pre dir="ltr">
"Month dd, yyyy" 
</pre>
<p>Then "May 3, 2008" would occupy 11 bytes in the record (with byte-length semantics), while "January 31, 2009" would occupy 16.</p>
<p>If starting and ending positions <span class="italic">are</span> specified, however, then the length calculated from the position specification overrides a length derived from the mask. A specified length such as <code dir="ltr">DATE(12)</code> overrides either of those. If the date field is also specified with terminating or enclosing delimiters, then the length specified in the control file is interpreted as a maximum length for the field.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1016161">"Datetime and Interval Datatypes"</a> for more information about the <code dir="ltr">DATE</code> field</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009544"></a>
<div id="SUTIL1199" class="sect1">
<h2 class="sect1">Specifying Field Conditions</h2>
<p><a id="sthref853"></a><a id="sthref854"></a>A field condition is a statement about a field in a logical record that evaluates as true or false. It is used in the <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF,</code> and <code dir="ltr">DEFAULTIF</code> clauses. <a id="sthref855"></a><a id="sthref856"></a><a id="sthref857"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If a field used in a clause evaluation has a NULL value, then that clause will always evaluate to FALSE. This feature is illustrated in <a href="#i1013466">Example 10-5</a>.</div>
<p>A field condition is similar to the condition in the <code dir="ltr">CONTINUEIF</code> clause, with two important differences. First, positions in the field condition refer to the logical record, not to the physical record. Second, you can specify either a position in the logical record or the name of a field in the data file (including filler fields).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A field condition cannot be based on fields in a secondary data file (SDF).</div>
<p>The syntax for the <code dir="ltr">field_condition</code> clause is as follows:</p>
<img width="522" height="123" src="img/fld_cond.gif" alt="Description of fld_cond.gif follows" /><br />
<a id="sthref858" href="img_text/fld_cond.htm">Description of the illustration ''fld_cond.gif''</a><br />
<br />
<p>The syntax for the <code dir="ltr">pos_spec</code> clause is as follows:</p>
<img width="407" height="105" src="img/pos_spec.gif" alt="Description of pos_spec.gif follows" /><br />
<a id="sthref859" href="img_text/pos_spec.htm">Description of the illustration ''pos_spec.gif''</a><br />
<br />
<p><a href="#g1026547">Table 10-4</a> describes the parameters used for the field condition clause. For a full description of the position specification parameters, see <a href="#i1017023">Table 10-1</a>.</p>
<div id="SUTIL3341" class="tblformal">
<p class="titleintable"><a id="sthref860"></a><a id="g1026547"></a>Table 10-4 Parameters for the Field Condition Clause</p>
<table class="cellalignment1394" title="Parameters for the Field Condition Clause" summary="Parameters for the field condition clause" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t24">Parameter</th>
<th class="cellalignment1395" id="r1c2-t24">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t24" headers="r1c1-t24">
<p><code dir="ltr">pos_spec</code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t24 r1c2-t24">
<p>Specifies the starting and ending position of the comparison field in the logical record. It must be surrounded by parentheses. Either <code dir="ltr"><span class="codeinlineitalic">start</span></code>-<code dir="ltr"><span class="codeinlineitalic">end</span></code> or <code dir="ltr"><span class="codeinlineitalic">start</span></code>:<code dir="ltr"><span class="codeinlineitalic">end</span></code> is acceptable.</p>
<p>The starting location can be specified as a column number, or as <code dir="ltr"><span class="codeinlineitalic">*</span></code> (next column), or as <code dir="ltr"><span class="codeinlineitalic">*+n</span></code> (next column plus an offset).</p>
<p>If you omit an ending position, then the length of the field is determined by the length of the comparison string. If the lengths are different, then the shorter field is padded. Character strings are padded with blanks, hexadecimal strings with zeros.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t24" headers="r1c1-t24">
<p><code dir="ltr"><span class="codeinlineitalic">start</span></code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t24 r1c2-t24">
<p>Specifies the starting position of the comparison field in the logical record.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t24" headers="r1c1-t24">
<p><code dir="ltr"><span class="codeinlineitalic">end</span></code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t24 r1c2-t24">
<p>Specifies the ending position of the comparison field in the logical record.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t24" headers="r1c1-t24">
<p><code dir="ltr"><span class="codeinlineitalic">full_fieldname</span></code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t24 r1c2-t24">
<p><code dir="ltr"><span class="codeinlineitalic">full_fieldname</span></code> is the full name of a field specified using dot notation. If the field <code dir="ltr"><span class="codeinlineitalic">col2</span></code> is an attribute of a column object <code dir="ltr"><span class="codeinlineitalic">col1</span></code>, then when referring to <code dir="ltr"><span class="codeinlineitalic">col2</span></code> in one of the directives, you must use the notation <code dir="ltr"><span class="codeinlineitalic">col1</span></code>.<code dir="ltr"><span class="codeinlineitalic">col2</span></code>. The column name and the field name referencing or naming the same entity can be different, because the column name never includes the full name of the entity (no dot notation).</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t24" headers="r1c1-t24">
<p><code dir="ltr"><span class="codeinlineitalic">operator</span></code></p>
</td>
<td class="cellalignment1396" headers="r6c1-t24 r1c2-t24">
<p>A comparison operator for either equal or not equal.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t24" headers="r1c1-t24">
<p><code dir="ltr"><span class="codeinlineitalic">char_string</span></code></p>
</td>
<td class="cellalignment1396" headers="r7c1-t24 r1c2-t24">
<p>A string of characters enclosed in single or double quotation marks that is compared to the comparison field. If the comparison is true, then the current record is inserted into the table.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t24" headers="r1c1-t24">
<p><code dir="ltr"><span class="codeinlineitalic">X'hex_string</span></code>'</p>
</td>
<td class="cellalignment1396" headers="r8c1-t24 r1c2-t24">
<p>A string of hexadecimal digits, where each pair of digits corresponds to one byte in the field. It is enclosed in single or double quotation marks. If the comparison is true, then the current record is inserted into the table.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r9c1-t24" headers="r1c1-t24">
<p><code dir="ltr">BLANKS</code></p>
</td>
<td class="cellalignment1396" headers="r9c1-t24 r1c2-t24">
<p>Enables you to test a field to see if it consists entirely of blanks. <code dir="ltr">BLANKS</code> is required when you are loading delimited data and you cannot predict the length of the field, or when you use a multibyte character set that has multiple blanks.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<a id="i1009606"></a>
<div id="SUTIL1200" class="sect2">
<h3 class="sect2">Comparing Fields to BLANKS</h3>
<p><a id="sthref861"></a><a id="sthref862"></a><a id="sthref863"></a>The <code dir="ltr">BLANKS</code> parameter makes it possible to determine if a field of unknown length is blank.</p>
<p>For example, use the following clause to load a blank field as null:</p>
<pre dir="ltr">
<span class="italic">full_fieldname </span>... NULLIF <span class="italic">column_name</span>=BLANKS 
</pre>
<p>The <code dir="ltr">BLANKS</code> parameter recognizes only blanks, not tabs. It can be used in place of a literal string in any field comparison. The condition is true whenever the column is entirely blank.</p>
<p>The <code dir="ltr">BLANKS</code> parameter also works for fixed-length fields. Using it is the same as specifying an appropriately sized literal string of blanks. For example, the following specifications are equivalent:</p>
<pre dir="ltr">
<span class="italic">fixed_field</span> CHAR(2) NULLIF <span class="italic">fixed_field</span>=BLANKS 
<span class="italic">fixed_field</span><span class="codeinlineitalic"> </span>CHAR(2) NULLIF <span class="italic">fixed_field</span>="  " 
</pre>
<p>There can be more than one blank in a multibyte character set. It is a good idea to use the <code dir="ltr">BLANKS</code> parameter with these character sets instead of specifying a string of blank characters.</p>
<p>The character string will match only a specific sequence of blank characters, while the <code dir="ltr">BLANKS</code> parameter will match combinations of different blank characters. For more information about multibyte character sets, see <a href="ldr_control_file.htm#i1005295">"Multibyte (Asian) Character Sets"</a>.<a id="sthref864"></a></p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1201" class="sect2"><a id="sthref865"></a>
<h3 class="sect2">Comparing Fields to Literals</h3>
<p><a id="sthref866"></a><a id="sthref867"></a><a id="sthref868"></a><a id="sthref869"></a><a id="sthref870"></a>When a data field is compared to a literal string that is shorter than the data field, the string is padded. Character strings are padded with blanks, for example:</p>
<pre dir="ltr">
NULLIF (1:4)=" " 
</pre>
<p>This example compares the data in position 1:4 with 4 blanks. If position 1:4 contains 4 blanks, then the clause evaluates as true.</p>
<p>Hexadecimal strings are padded with hexadecimal zeros, as in the following clause:</p>
<pre dir="ltr">
NULLIF (1:4)=X'FF' 
</pre>
<p>This clause compares position 1:4 to hexadecimal 'FF000000'.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009345"></a>
<div id="SUTIL1202" class="sect1">
<h2 class="sect1">Using the WHEN, NULLIF, and DEFAULTIF Clauses</h2>
<p>The following information applies to scalar fields. For nonscalar fields (column objects, LOBs, and collections), the <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, and <code dir="ltr">DEFAULTIF</code> clauses are processed differently because nonscalar fields are more complex.</p>
<p>The results of a <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, or <code dir="ltr">DEFAULTIF</code> clause can be different depending on whether the clause specifies a field name or a position.</p>
<ul>
<li>
<p>If the <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, or <code dir="ltr">DEFAULTIF</code> clause specifies a field name, then SQL*Loader compares the clause to the evaluated value of the field. The evaluated value takes trimmed whitespace into consideration. See <a href="#i1007768">"Trimming Whitespace"</a> for information about trimming blanks and tabs.</p>
</li>
<li>
<p>If the <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, or <code dir="ltr">DEFAULTIF</code> clause specifies a position, then SQL*Loader compares the clause to the original logical record in the data file. No whitespace trimming is done on the logical record in that case.</p>
</li>
</ul>
<p>Different results are more likely if the field has whitespace that is trimmed, or if the <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, or <code dir="ltr">DEFAULTIF</code> clause contains blanks or tabs or uses the <code dir="ltr">BLANKS</code> parameter. If you require the same results for a field specified by name and for the same field specified by position, then use the <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> option. The <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> option instructs SQL*Loader not to trim whitespace when it evaluates the values of the fields.</p>
<p>The results of a <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, or <code dir="ltr">DEFAULTIF</code> clause are also affected by the order in which SQL*Loader operates, as described in the following steps. SQL*Loader performs these steps in order, but it does not always perform all of them. Once a field is set, any remaining steps in the process are ignored. For example, if the field is set in Step 5, then SQL*Loader does not move on to Step 6.</p>
<ol>
<li>
<p>SQL*Loader evaluates the value of each field for the input record and trims any whitespace that should be trimmed (according to existing guidelines for trimming blanks and tabs).</p>
</li>
<li>
<p>For each record, SQL*Loader evaluates any <code dir="ltr">WHEN</code> clauses for the table.</p>
</li>
<li>
<p>If the record satisfies the <code dir="ltr">WHEN</code> clauses for the table, or no <code dir="ltr">WHEN</code> clauses are specified, then SQL*Loader checks each field for a <code dir="ltr">NULLIF</code> clause.</p>
</li>
<li>
<p>If a <code dir="ltr">NULLIF</code> clause exists, then SQL*Loader evaluates it.</p>
</li>
<li>
<p>If the <code dir="ltr">NULLIF</code> clause is satisfied, then SQL*Loader sets the field to <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>If the <code dir="ltr">NULLIF</code> clause is not satisfied, or if there is no <code dir="ltr">NULLIF</code> clause, then SQL*Loader checks the length of the field from field evaluation. If the field has a length of 0 from field evaluation (for example, it was a null field, or whitespace trimming resulted in a null field), then SQL*Loader sets the field to <code dir="ltr">NULL</code>. In this case, any <code dir="ltr">DEFAULTIF</code> clause specified for the field is not evaluated.</p>
</li>
<li>
<p>If any specified <code dir="ltr">NULLIF</code> clause is false or there is no <code dir="ltr">NULLIF</code> clause, and if the field does not have a length of 0 from field evaluation, then SQL*Loader checks the field for a <code dir="ltr">DEFAULTIF</code> clause.</p>
</li>
<li>
<p>If a <code dir="ltr">DEFAULTIF</code> clause exists, then SQL*Loader evaluates it.</p>
</li>
<li>
<p>If the <code dir="ltr">DEFAULTIF</code> clause is satisfied, then the field is set to 0 if the field in the data file is a numeric field. It is set to <code dir="ltr">NULL</code> if the field is not a numeric field. The following fields are numeric fields and will be set to 0 if they satisfy the <code dir="ltr">DEFAULTIF</code> clause:</p>
<ul>
<li>
<p><code dir="ltr">BYTEINT</code></p>
</li>
<li>
<p><code dir="ltr">SMALLINT</code></p>
</li>
<li>
<p><code dir="ltr">INTEGER</code></p>
</li>
<li>
<p><code dir="ltr">FLOAT</code></p>
</li>
<li>
<p><code dir="ltr">DOUBLE</code></p>
</li>
<li>
<p><code dir="ltr">ZONED</code></p>
</li>
<li>
<p>(packed) <code dir="ltr">DECIMAL</code></p>
</li>
<li>
<p>Numeric <code dir="ltr">EXTERNAL</code> (<code dir="ltr">INTEGER</code>, <code dir="ltr">FLOAT</code>, <code dir="ltr">DECIMAL</code>, and <code dir="ltr">ZONED</code>)</p>
</li>
</ul>
</li>
<li>
<p>If the <code dir="ltr">DEFAULTIF</code> clause is not satisfied, or if there is no <code dir="ltr">DEFAULTIF</code> clause, then SQL*Loader sets the field with the evaluated value from Step 1.</p>
</li>
</ol>
<p>The order in which SQL*Loader operates could cause results that you do not expect. For example, the <code dir="ltr">DEFAULTIF</code> clause may look like it is setting a numeric field to <code dir="ltr">NULL</code> rather than to 0.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
As demonstrated in these steps, the presence of <code dir="ltr">NULLIF</code> and <code dir="ltr">DEFAULTIF</code> clauses results in extra processing that SQL*Loader must perform. This can affect performance. Note that during Step 1, SQL*Loader will set a field to NULL if its evaluated length is zero. To improve performance, consider whether it might be possible for you to change your data to take advantage of this. The detection of NULLs as part of Step 1 occurs much more quickly than the processing of a <code dir="ltr">NULLIF</code> or <code dir="ltr">DEFAULTIF</code> clause.
<p>For example, a <code dir="ltr">CHAR(5)</code> will have zero length if it falls off the end of the logical record or if it contains all blanks and blank trimming is in effect. A delimited field will have zero length if there are no characters between the start of the field and the terminator.</p>
<p>Also, for character fields, <code dir="ltr">NULLIF</code> is usually faster to process than <code dir="ltr">DEFAULTIF</code> (the default for character fields is NULL).</p>
</div>
<div id="SUTIL1203" class="sect2"><a id="sthref871"></a>
<h3 class="sect2">Examples of Using the WHEN, NULLIF, and DEFAULTIF Clauses</h3>
<p><a href="#i1009373">Example 10-2</a> through <a href="#i1013466">Example 10-5</a> clarify the results for different situations in which the <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF,</code> and <code dir="ltr">DEFAULTIF</code> clauses might be used. In the examples, a blank or space is indicated with a period (.). Assume that <code dir="ltr">col1</code> and <code dir="ltr">col2</code> are <code dir="ltr">VARCHAR2(5)</code> columns in the database.</p>
<div id="SUTIL3342" class="example">
<p class="titleinexample"><a id="i1009373"></a>Example 10-2 DEFAULTIF Clause Is Not Evaluated</p>
<p>The control file specifies:</p>
<pre dir="ltr">
(col1 POSITION (1:5),
 col2 POSITION (6:8) CHAR INTEGER EXTERNAL DEFAULTIF col1 = 'aname')
</pre>
<p>The data file contains:</p>
<pre dir="ltr">
aname...
</pre>
<p>In <a href="#i1009373">Example 10-2</a>, <code dir="ltr">col1</code> for the row evaluates to <code dir="ltr">aname</code>. <code dir="ltr">col2</code> evaluates to <code dir="ltr">NULL</code> with a length of 0 (it is <code dir="ltr">...</code> but the trailing blanks are trimmed for a positional field).</p>
<p>When SQL*Loader determines the final loaded value for <code dir="ltr">col2</code>, it finds no <code dir="ltr">WHEN</code> clause and no <code dir="ltr">NULLIF</code> clause. It then checks the length of the field, which is 0 from field evaluation. Therefore, SQL*Loader sets the final value for <code dir="ltr">col2</code> to <code dir="ltr">NULL</code>. The <code dir="ltr">DEFAULTIF</code> clause is not evaluated, and the row is loaded as <code dir="ltr">aname</code> for <code dir="ltr">col1</code> and <code dir="ltr">NULL</code> for <code dir="ltr">col2</code>.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3343" class="example">
<p class="titleinexample"><a id="i1009384"></a>Example 10-3 DEFAULTIF Clause Is Evaluated</p>
<p>The control file specifies:</p>
<pre dir="ltr">
.
.
.
PRESERVE BLANKS
.
.
.
(col1 POSITION (1:5),
 col2 POSITION (6:8) INTEGER EXTERNAL DEFAULTIF col1 = 'aname'
</pre>
<p>The data file contains:</p>
<pre dir="ltr">
aname...
</pre>
<p>In <a href="#i1009384">Example 10-3</a>, <code dir="ltr">col1</code> for the row again evaluates to <code dir="ltr">aname</code>. <code dir="ltr">col2</code> evaluates to '<code dir="ltr">...</code>' because trailing blanks are not trimmed when <code dir="ltr">PRESERVE BLANKS</code> is specified.</p>
<p>When SQL*Loader determines the final loaded value for <code dir="ltr">col2</code>, it finds no <code dir="ltr">WHEN</code> clause and no <code dir="ltr">NULLIF</code> clause. It then checks the length of the field from field evaluation, which is 3, not 0.</p>
<p>Then SQL*Loader evaluates the <code dir="ltr">DEFAULTIF</code> clause, which evaluates to true because <code dir="ltr">col1</code> is <code dir="ltr">aname</code>, which is the same as <code dir="ltr">aname</code>.</p>
<p>Because <code dir="ltr">col2</code> is a numeric field, SQL*Loader sets the final value for <code dir="ltr">col2</code> to <code dir="ltr">0</code>. The row is loaded as <code dir="ltr">aname</code> for <code dir="ltr">col1</code> and as <code dir="ltr">0</code> for <code dir="ltr">col2</code>.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3344" class="example">
<p class="titleinexample"><a id="i1013512"></a>Example 10-4 DEFAULTIF Clause Specifies a Position</p>
<p>The control file specifies:</p>
<pre dir="ltr">
(col1 POSITION (1:5), 
 col2 POSITION (6:8) INTEGER EXTERNAL DEFAULTIF (1:5) = BLANKS)
</pre>
<p>The data file contains:</p>
<pre dir="ltr">
.....123
</pre>
<p>In <a href="#i1013512">Example 10-4</a>, <code dir="ltr">col1</code> for the row evaluates to <code dir="ltr">NULL</code> with a length of 0 (it is <code dir="ltr">.....</code> but the trailing blanks are trimmed). <code dir="ltr">col2</code> evaluates to <code dir="ltr">123</code>.</p>
<p>When SQL*Loader sets the final loaded value for <code dir="ltr">col2</code>, it finds no <code dir="ltr">WHEN</code> clause and no <code dir="ltr">NULLIF</code> clause. It then checks the length of the field from field evaluation, which is 3, not 0.</p>
<p>Then SQL*Loader evaluates the <code dir="ltr">DEFAULTIF</code> clause. It compares <code dir="ltr">(1:5)</code> which is <code dir="ltr">.....</code> to <code dir="ltr">BLANKS</code>, which evaluates to true. Therefore, because <code dir="ltr">col2</code> is a numeric field (<code dir="ltr">integer EXTERNAL</code> is numeric), SQL*Loader sets the final value for <code dir="ltr">col2</code> to <code dir="ltr">0</code>. The row is loaded as <code dir="ltr">NULL</code> for <code dir="ltr">col1</code> and <code dir="ltr">0</code> for <code dir="ltr">col2</code>.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3345" class="example">
<p class="titleinexample"><a id="i1013466"></a>Example 10-5 DEFAULTIF Clause Specifies a Field Name</p>
<p>The control file specifies:</p>
<pre dir="ltr">
(col1 POSITION (1:5), 
 col2 POSITION(6:8) INTEGER EXTERNAL DEFAULTIF col1 = BLANKS)
</pre>
<p>The data file contains:</p>
<pre dir="ltr">
.....123
</pre>
<p>In <a href="#i1013466">Example 10-5</a>, <code dir="ltr">col1</code> for the row evaluates to <code dir="ltr">NULL</code> with a length of <code dir="ltr">0</code> (it is <code dir="ltr">.....</code> but the trailing blanks are trimmed). <code dir="ltr">col2</code> evaluates to <code dir="ltr">123</code>.</p>
<p>When SQL*Loader determines the final value for <code dir="ltr">col2</code>, it finds no <code dir="ltr">WHEN</code> clause and no <code dir="ltr">NULLIF</code> clause. It then checks the length of the field from field evaluation, which is 3, not 0.</p>
<p>Then SQL*Loader evaluates the <code dir="ltr">DEFAULTIF</code> clause. As part of the evaluation, it checks to see that <code dir="ltr">col1</code> is <code dir="ltr">NULL</code> from field evaluation. It is <code dir="ltr">NULL</code>, so the <code dir="ltr">DEFAULTIF</code> clause evaluates to false. Therefore, SQL*Loader sets the final value for <code dir="ltr">col2</code> to <code dir="ltr">123</code>, its original value from field evaluation. The row is loaded as <code dir="ltr">NULL</code> for <code dir="ltr">col1</code> and <code dir="ltr">123</code> for <code dir="ltr">col2</code>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007642"></a>
<div id="SUTIL1204" class="sect1">
<h2 class="sect1">Loading Data Across Different Platforms<a id="sthref872"></a><a id="sthref873"></a><a id="sthref874"></a></h2>
<p>When a data file created on one platform is to be loaded on a different platform, the data must be written in a form that the target system can read. For example, if the source system has a native, floating-point representation that uses 16 bytes, and the target system's floating-point numbers are 12 bytes, then the target system cannot directly read data generated on the source system.</p>
<p>The best solution is to load data across an Oracle Net database link, taking advantage of the automatic conversion of datatypes. This is the recommended approach, whenever feasible, and means that SQL*Loader must be run on the source system.</p>
<p>Problems with interplatform loads typically occur with <span class="italic">native</span> datatypes. In some situations, it is possible to avoid problems by lengthening a field by padding it with zeros, or to read only part of the field to shorten it (for example, when an 8-byte integer is to be read on a system that uses 4-byte integers, or the reverse). Note, however, that incompatible datatype implementation may prevent this.</p>
<p>If you cannot use an Oracle Net database link and the data file must be accessed by SQL*Loader running on the target system, then it is advisable to use only the portable SQL*Loader datatypes (for example, <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, <code dir="ltr">VARCHARC</code>, and numeric <code dir="ltr">EXTERNAL</code>). Data files written using these datatypes may be longer than those written with native datatypes. They may take more time to load, but they transport more readily across platforms.</p>
<p>If you know in advance that the byte ordering schemes or native integer lengths differ between the platform on which the input data will be created and the platform on which SQL*loader will be run, then investigate the possible use of the appropriate technique to indicate the byte order of the data or the length of the native integer. Possible techniques for indicating the byte order are to use the <code dir="ltr">BYTEORDER</code> parameter or to place a byte-order mark (BOM) in the file. Both methods are described in <a href="#i1011032">"Byte Ordering"</a>. It may then be possible to eliminate the incompatibilities and achieve a successful cross-platform data load. If the byte order is different from the SQL*Loader default, then you must indicate a byte order.</p>
</div>
<!-- class="sect1" -->
<a id="i1011032"></a>
<div id="SUTIL1205" class="sect1">
<h2 class="sect1">Byte Ordering</h2>
<div class="infobox-note">
<p class="notep1">Note:</p>
The information in this section is only applicable if you are planning to create input data on a system that has a different byte-ordering scheme than the system on which SQL*Loader will be run. Otherwise, you can skip this section.</div>
<p>SQL*Loader can load data from a data file that was created on a system whose byte ordering is different from the byte ordering on the system where SQL*Loader is running, even if the data file contains certain nonportable datatypes.</p>
<p>By default, SQL*Loader uses the byte order<a id="sthref875"></a> of the system where it is running as the byte order for all data files. For example, on a Sun Solaris system, SQL*Loader uses big-endian<a id="sthref876"></a> byte order. On an Intel or an Intel-compatible PC, SQL*Loader uses little-endian<a id="sthref877"></a> byte order.</p>
<p>Byte order affects the results when data is written and read an even number of bytes at a time (typically 2 bytes, 4 bytes, or 8 bytes). The following are some examples of this:</p>
<ul>
<li>
<p>The 2-byte integer value 1 is written as 0x0001 on a big-endian system and as 0x0100 on a little-endian system.</p>
</li>
<li>
<p>The 4-byte integer 66051 is written as 0x00010203 on a big-endian system and as 0x03020100 on a little-endian system.</p>
</li>
</ul>
<p>Byte order also affects character data in the UTF16 character set if it is written and read as 2-byte entities. For example, the character 'a' (0x61 in ASCII) is written as 0x0061 in UTF16 on a big-endian system, but as 0x6100 on a little-endian system.</p>
<p>All Oracle-supported character sets, except UTF16, are written one byte at a time. So, even for multibyte character sets such as UTF8, the characters are written and read the same way on all systems, regardless of the byte order of the system. Therefore, data in the UTF16 character set is nonportable because it is byte-order dependent. Data in all other Oracle-supported character sets is portable.</p>
<p>Byte order in a data file is only an issue if the data file that contains the byte-order-dependent data is created on a system that has a different byte order from the system on which SQL*Loader is running. If SQL*Loader knows the byte order of the data, then it swaps the bytes as necessary to ensure that the data is loaded correctly in the target database. Byte swapping means that data in big-endian format is converted to little-endian format, or the reverse.</p>
<p>To indicate byte order of the data to SQL*Loader, you can use the <code dir="ltr">BYTEORDER</code> parameter, or you can place a byte-order mark (BOM) in the file. If you do not use one of these techniques, then SQL*Loader will not correctly load the data into the data file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
Case study 11, Loading Data in the Unicode Character Set, for an example of how SQL*Loader handles byte swapping. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</div>
<div id="SUTIL1206" class="sect2"><a id="sthref878"></a>
<h3 class="sect2">Specifying Byte Order</h3>
<p>To specify the byte order<a id="sthref879"></a> of data in the input data files, use the following syntax in the SQL*Loader control file:</p>
<img width="373" height="74" src="img/byteorder.gif" alt="Description of byteorder.gif follows" /><br />
<a id="sthref880" href="img_text/byteorder.htm">Description of the illustration ''byteorder.gif''</a><br />
<br />
<p>The <code dir="ltr">BYTEORDER</code> parameter<a id="sthref881"></a> has the following characteristics:</p>
<ul>
<li>
<p><code dir="ltr">BYTEORDER</code> is placed after the <code dir="ltr">LENGTH</code> parameter in the SQL*Loader control file.</p>
</li>
<li>
<p>It is possible to specify a different byte order for different data files. However, the <code dir="ltr">BYTEORDER</code> specification before the <code dir="ltr">INFILE</code> parameters applies to the entire list of primary data files.</p>
</li>
<li>
<p>The <code dir="ltr">BYTEORDER</code> specification for the primary data files is also used as the default for LOBFILEs and SDFs. To override this default, specify <code dir="ltr">BYTEORDER</code> with the LOBFILE or SDF specification.</p>
</li>
<li>
<p>The <code dir="ltr">BYTEORDER</code> parameter is not applicable to data contained within the control file itself.</p>
</li>
<li>
<p>The <code dir="ltr">BYTEORDER</code> parameter applies to the following:</p>
<ul>
<li>
<p>Binary <code dir="ltr">INTEGER</code> and <code dir="ltr">SMALLINT</code> data</p>
</li>
<li>
<p>Binary lengths in varying-length fields (that is, for the <code dir="ltr">VARCHAR</code>, <code dir="ltr">VARGRAPHIC</code>, <code dir="ltr">VARRAW</code>, and <code dir="ltr">LONG</code> <code dir="ltr">VARRAW</code> datatypes)</p>
</li>
<li>
<p>Character data for data files in the UTF16 character set</p>
</li>
<li>
<p><code dir="ltr">FLOAT</code> and <code dir="ltr">DOUBLE</code> datatypes, if the system where the data was written has a compatible floating-point representation with that on the system where SQL*Loader is running</p>
</li>
</ul>
</li>
<li>
<p>The <code dir="ltr">BYTEORDER</code> parameter does not apply to any of the following:</p>
<ul>
<li>
<p>Raw datatypes (<code dir="ltr">RAW</code>, <code dir="ltr">VARRAW</code>, or <code dir="ltr">VARRAWC</code>)</p>
</li>
<li>
<p>Graphic datatypes (<code dir="ltr">GRAPHIC</code>, <code dir="ltr">VARGRAPHIC</code>, or <code dir="ltr">GRAPHIC</code> <code dir="ltr">EXTERNAL</code>)</p>
</li>
<li>
<p>Character data for data files in any character set other than UTF16</p>
</li>
<li>
<p><code dir="ltr">ZONED</code> or (packed) <code dir="ltr">DECIMAL</code> datatypes</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1207" class="sect2"><a id="sthref882"></a>
<h3 class="sect2">Using Byte Order Marks (BOMs)</h3>
<p>Data files that use a Unicode encoding (UTF-16 or UTF-8) may contain a byte-order mark (BOM) in the first few bytes of the file. For a data file that uses the character set UTF16, the values {0xFE,0xFF} in the first two bytes of the file are the BOM indicating that the file contains big-endian data. The values {0xFF,0xFE} are the BOM indicating that the file contains little-endian data.<a id="sthref883"></a><a id="sthref884"></a></p>
<p>If the first primary data file uses the UTF16 character set and it also begins with a BOM, then that mark is read and interpreted to determine the byte order for all primary data files. SQL*Loader reads and interprets the BOM, skips it, and begins processing data with the byte immediately after the BOM. The BOM setting overrides any <code dir="ltr">BYTEORDER</code> specification for the first primary data file. BOMs in data files other than the first primary data file are read and used for checking for byte-order conflicts only. They do not change the byte-order setting that SQL*Loader uses in processing the data file.</p>
<p>In summary, the precedence of the byte-order indicators for the first primary data file is as follows:</p>
<ul>
<li>
<p>BOM in the first primary data file, if the data file uses a Unicode character set that is byte-order dependent (UTF16) and a BOM is present</p>
</li>
<li>
<p><code dir="ltr">BYTEORDER</code> parameter value, if specified before the <code dir="ltr">INFILE</code> parameters</p>
</li>
<li>
<p>The byte order of the system where SQL*Loader is running</p>
</li>
</ul>
<p>For a data file that uses a UTF8 character set, a BOM of {0xEF,0xBB,0xBF} in the first 3 bytes indicates that the file contains UTF8 data. It does not indicate the byte order of the data, because data in UTF8 is not byte-order dependent. If SQL*Loader detects a UTF8 BOM, then it skips it but does not change any byte-order settings for processing the data files.</p>
<p>SQL*Loader first establishes a byte-order setting for the first primary data file using the precedence order just defined. This byte-order setting is used for all primary data files. If another primary data file uses the character set UTF16 and also contains a BOM, then the BOM value is compared to the byte-order setting established for the first primary data file. If the BOM value matches the byte-order setting of the first primary data file, then SQL*Loader skips the BOM, and uses that byte-order setting to begin processing data with the byte immediately after the BOM. If the BOM value does not match the byte-order setting established for the first primary data file, then SQL*Loader issues an error message and stops processing.</p>
<p>If any LOBFILEs or secondary data files are specified in the control file, then SQL*Loader establishes a byte-order setting for each LOBFILE and secondary data file (SDF) when it is ready to process the file. The default byte-order setting for LOBFILEs and SDFs is the byte-order setting established for the first primary data file. This is overridden if the <code dir="ltr">BYTEORDER</code> parameter is specified with a LOBFILE or SDF. In either case, if the LOBFILE or SDF uses the UTF16 character set and contains a BOM, the BOM value is compared to the byte-order setting for the file. If the BOM value matches the byte-order setting for the file, then SQL*Loader skips the BOM, and uses that byte-order setting to begin processing data with the byte immediately after the BOM. If the BOM value does not match, then SQL*Loader issues an error message and stops processing.</p>
<p>In summary, the precedence<a id="sthref885"></a> of the byte-order indicators for LOBFILEs and SDFs is as follows:</p>
<ul>
<li>
<p><code dir="ltr">BYTEORDER</code> parameter value specified with the LOBFILE or SDF</p>
</li>
<li>
<p>The byte-order setting established for the first primary data file</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the character set of your data file is a unicode character set and there is a byte-order mark in the first few bytes of the file, then do not use the <code dir="ltr">SKIP</code> parameter. If you do, then the byte-order mark will not be read and interpreted as a byte-order mark.</div>
</li>
</ul>
<div id="SUTIL1208" class="sect3"><a id="sthref886"></a>
<h4 class="sect3">Suppressing Checks for BOMs</h4>
<p>A data file in a Unicode character set may contain binary data that matches the BOM in the first bytes of the file. For example the integer(2) value 0xFEFF = 65279 decimal matches the big-endian BOM in UTF16. In that case, you can tell SQL*Loader to read the first bytes of the data file as data and not check for a BOM<a id="sthref887"></a> by specifying the <code dir="ltr">BYTEORDERMARK</code> parameter<a id="sthref888"></a> with the value <code dir="ltr">NOCHECK</code>. The syntax for the <code dir="ltr">BYTEORDERMARK</code> parameter is:</p>
<img width="308" height="70" src="img/byteordermark.gif" alt="Description of byteordermark.gif follows" /><br />
<a id="sthref889" href="img_text/byteordermark.htm">Description of the illustration ''byteordermark.gif''</a><br />
<br />
<p><code dir="ltr">BYTEORDERMARK</code> <code dir="ltr">NOCHECK</code> indicates that SQL*Loader should not check for a BOM and should read all the data in the data file as data.</p>
<p><code dir="ltr">BYTEORDERMARK</code> <code dir="ltr">CHECK</code> tells SQL*Loader to check for a BOM. This is the default behavior for a data file in a Unicode character set. But this specification may be used in the control file for clarification. It is an error to specify <code dir="ltr">BYTEORDERMARK</code> <code dir="ltr">CHECK</code> for a data file that uses a non-Unicode character set.</p>
<p>The <code dir="ltr">BYTEORDERMARK</code> parameter has the following characteristics:</p>
<ul>
<li>
<p>It is placed after the optional <code dir="ltr">BYTEORDER</code> parameter in the SQL*Loader control file.</p>
</li>
<li>
<p>It applies to the syntax specification for primary data files, and also to LOBFILEs and secondary data files (SDFs).</p>
</li>
<li>
<p>It is possible to specify a different <code dir="ltr">BYTEORDERMARK</code> value for different data files; however, the <code dir="ltr">BYTEORDERMARK</code> specification before the <code dir="ltr">INFILE</code> parameters applies to the entire list of primary data files.</p>
</li>
<li>
<p>The <code dir="ltr">BYTEORDERMARK</code> specification for the primary data files is also used as the default for LOBFILEs and SDFs, except that the value <code dir="ltr">CHECK</code> is ignored in this case if the LOBFILE or SDF uses a non-Unicode character set. This default setting for LOBFILEs and secondary data files can be overridden by specifying <code dir="ltr">BYTEORDERMARK</code> with the LOBFILE or SDF specification.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007735"></a>
<div id="SUTIL1209" class="sect1">
<h2 class="sect1">Loading All-Blank Fields<a id="sthref890"></a><a id="sthref891"></a><a id="sthref892"></a></h2>
<p>Fields that are totally blank cause the record to be rejected. To load one of these fields as <code dir="ltr">NULL</code>, use the <code dir="ltr">NULLIF</code> clause with the <code dir="ltr">BLANKS</code> parameter.</p>
<p>If an all-blank <code dir="ltr">CHAR</code> field is surrounded by enclosure delimiters, then the blanks within the enclosures are loaded. Otherwise, the field is loaded as <code dir="ltr">NULL</code>.</p>
<p>A <code dir="ltr">DATE</code> or numeric field that consists entirely of blanks is loaded as a <code dir="ltr">NULL</code> field.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p>Case study 6, Loading Data Using the Direct Path Load Method, for an example of how to load all-blank fields as <code dir="ltr">NULL</code> with the <code dir="ltr">NULLIF</code> clause. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</li>
<li>
<p><a href="#i1007768">"Trimming Whitespace"</a></p>
</li>
<li>
<p><a href="#i1008122">"How the PRESERVE BLANKS Option Affects Whitespace Trimming"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1007768"></a>
<div id="SUTIL1210" class="sect1">
<h2 class="sect1">Trimming Whitespace<a id="sthref893"></a><a id="sthref894"></a><a id="sthref895"></a><a id="sthref896"></a><a id="sthref897"></a></h2>
<p>Blanks, tabs, and other nonprinting characters (such as carriage returns and line feeds) constitute whitespace. Leading whitespace occurs at the beginning of a field. Trailing whitespace occurs at the end of a field. Depending on how the field is specified, whitespace may or may not be included when the field is inserted into the database. This is illustrated in <a href="#BABIHDHF">Figure 10-1</a>, where two <code dir="ltr">CHAR</code> fields are defined for a data record.</p>
<p>The field specifications are contained in the control file. The control file <code dir="ltr">CHAR</code> specification is not the same as the database <code dir="ltr">CHAR</code> specification. A data field defined as <code dir="ltr">CHAR</code> in the control file simply tells SQL*Loader how to create the row insert. The data could then be inserted into a <code dir="ltr">CHAR</code>, <code dir="ltr">VARCHAR2</code>, <code dir="ltr">NCHAR</code>, <code dir="ltr">NVARCHAR2</code>, or even a <code dir="ltr">NUMBER</code> or <code dir="ltr">DATE</code> column in the database, with the Oracle database handling any necessary conversions.</p>
<p>By default, SQL*Loader removes trailing spaces from <code dir="ltr">CHAR</code> data before passing it to the database. So, in <a href="#BABIHDHF">Figure 10-1</a>, both Field 1 and Field 2 are passed to the database as 3-byte fields. However, when the data is inserted into the table, there is a difference.</p>
<div id="SUTIL3346" class="figure">
<p class="titleinfigure"><a id="BABIHDHF"></a>Figure 10-1 Example of Field Conversion</p>
<img width="464" height="392" src="img/sut81003.gif" alt="Description of Figure 10-1 follows" /><br />
<a id="sthref898" href="img_text/sut81003.htm">Description of ''Figure 10-1 Example of Field Conversion ''</a><br />
<br /></div>
<!-- class="figure" -->
<p>Column 1 is defined in the database as a fixed-length <code dir="ltr">CHAR</code> column of length <code dir="ltr">5</code>. So the data (<code dir="ltr">aaa</code>) is left-justified in that column, which remains 5 bytes wide. The extra space on the right is padded with blanks. Column 2, however, is defined as a varying-length field with a <span class="italic">maximum</span> length of 5 bytes. The data for that column (<code dir="ltr">bbb</code>) is left-justified as well, but the length remains 3 bytes.</p>
<p><a id="sthref899"></a><a href="#g1026705">Table 10-5</a> summarizes when and how whitespace is removed from input data fields when <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> is not specified. See <a href="#i1008122">"How the PRESERVE BLANKS Option Affects Whitespace Trimming"</a> for details on how to prevent whitespace trimming.</p>
<div id="SUTIL3347" class="tblruleformal">
<p class="titleintable"><a id="sthref900"></a><a id="g1026705"></a>Table 10-5 Behavior Summary for Trimming Whitespace</p>
<table class="cellalignment1399" title="Behavior Summary for Trimming Whitespace" summary="Behavior summary for trimming whitespace" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t30">Specification</th>
<th class="cellalignment1395" id="r1c2-t30">Data</th>
<th class="cellalignment1395" id="r1c3-t30">Result</th>
<th class="cellalignment1395" id="r1c4-t30">Leading Whitespace Present<a id="BABGEJAI" href="#BABGEJAI" onclick='footdisplay(1,"When an all-blank field is trimmed, its value is \u003ccode dir=\"ltr\"\u003eNULL\u003c/code\u003e.")'><sup class="tablefootnote">Foot&nbsp;1&nbsp;</sup></a></th>
<th class="cellalignment1395" id="r1c5-t30">Trailing Whitespace Present<a id="sthref901" href="#sthref901" onclick='footdisplay(1,"When an all-blank field is trimmed, its value is \u003ccode dir=\"ltr\"\u003eNULL\u003c/code\u003e.")'><sup class="footnotenumber">Footref&nbsp;1</sup></a></th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t30" headers="r1c1-t30">
<p>Predetermined size</p>
</td>
<td class="cellalignment1396" headers="r2c1-t30 r1c2-t30">
<p>__aa__</p>
</td>
<td class="cellalignment1396" headers="r2c1-t30 r1c3-t30">
<p>__aa</p>
</td>
<td class="cellalignment1396" headers="r2c1-t30 r1c4-t30">
<p>Yes</p>
</td>
<td class="cellalignment1396" headers="r2c1-t30 r1c5-t30">
<p>No</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t30" headers="r1c1-t30">
<p>Terminated</p>
</td>
<td class="cellalignment1396" headers="r3c1-t30 r1c2-t30">
<p>__aa__,</p>
</td>
<td class="cellalignment1396" headers="r3c1-t30 r1c3-t30">
<p>__aa__</p>
</td>
<td class="cellalignment1396" headers="r3c1-t30 r1c4-t30">
<p>Yes</p>
</td>
<td class="cellalignment1396" headers="r3c1-t30 r1c5-t30">
<p>Yes<a id="sthref902" href="#sthref902" onclick='footdisplay(2,"Except for fields that are terminated by whitespace.")'><sup class="tablefootnote">Foot&nbsp;2&nbsp;</sup></a></p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t30" headers="r1c1-t30">
<p>Enclosed</p>
</td>
<td class="cellalignment1396" headers="r4c1-t30 r1c2-t30">
<p>"__aa__"</p>
</td>
<td class="cellalignment1396" headers="r4c1-t30 r1c3-t30">
<p>__aa__</p>
</td>
<td class="cellalignment1396" headers="r4c1-t30 r1c4-t30">
<p>Yes</p>
</td>
<td class="cellalignment1396" headers="r4c1-t30 r1c5-t30">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t30" headers="r1c1-t30">
<p>Terminated and enclosed</p>
</td>
<td class="cellalignment1396" headers="r5c1-t30 r1c2-t30">
<p>"__aa__",</p>
</td>
<td class="cellalignment1396" headers="r5c1-t30 r1c3-t30">
<p>__aa__</p>
</td>
<td class="cellalignment1396" headers="r5c1-t30 r1c4-t30">
<p>Yes</p>
</td>
<td class="cellalignment1396" headers="r5c1-t30 r1c5-t30">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t30" headers="r1c1-t30">
<p>Optional enclosure (present)</p>
</td>
<td class="cellalignment1396" headers="r6c1-t30 r1c2-t30">
<p>"__aa__",</p>
</td>
<td class="cellalignment1396" headers="r6c1-t30 r1c3-t30">
<p>__aa__</p>
</td>
<td class="cellalignment1396" headers="r6c1-t30 r1c4-t30">
<p>Yes</p>
</td>
<td class="cellalignment1396" headers="r6c1-t30 r1c5-t30">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t30" headers="r1c1-t30">
<p>Optional enclosure (absent)</p>
</td>
<td class="cellalignment1396" headers="r7c1-t30 r1c2-t30">
<p>__aa__,</p>
</td>
<td class="cellalignment1396" headers="r7c1-t30 r1c3-t30">
<p>aa__</p>
</td>
<td class="cellalignment1396" headers="r7c1-t30 r1c4-t30">
<p>No</p>
</td>
<td class="cellalignment1396" headers="r7c1-t30 r1c5-t30">
<p>Yes</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t30" headers="r1c1-t30">
<p>Previous field terminated by whitespace</p>
</td>
<td class="cellalignment1396" headers="r8c1-t30 r1c2-t30">
<p>__aa__</p>
</td>
<td class="cellalignment1396" headers="r8c1-t30 r1c3-t30">
<p>aa<a id="BABIACEG" href="#BABIACEG" onclick='footdisplay(3,"Presence of trailing whitespace depends on the current field\x27s specification, as shown by the other entries in the table.")'><sup class="tablefootnote">Foot&nbsp;3&nbsp;</sup></a></p>
</td>
<td class="cellalignment1396" headers="r8c1-t30 r1c4-t30">
<p>No</p>
</td>
<td class="cellalignment1396" headers="r8c1-t30 r1c5-t30">
<p><a id="sthref903" href="#sthref903" onclick='footdisplay(3,"Presence of trailing whitespace depends on the current field\x27s specification, as shown by the other entries in the table.")'><sup class="footnotenumber">Footref&nbsp;3</sup></a></p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformal" -->
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;1&nbsp;</sup>When an all-blank field is trimmed, its value is <code dir="ltr">NULL</code>.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;2&nbsp;</sup>Except for fields that are terminated by whitespace.</p>
<p class="tablefootnote"><sup class="tablefootnote">Footnote&nbsp;3&nbsp;</sup>Presence of trailing whitespace depends on the current field's specification, as shown by the other entries in the table.</p>
<p>The rest of this section discusses the following topics with regard to trimming whitespace:</p>
<ul>
<li>
<p><a href="#i1007819">Datatypes for Which Whitespace Can Be Trimmed</a></p>
</li>
<li>
<p><a href="#i1007836">Specifying Field Length for Datatypes for Which Whitespace Can Be Trimmed</a></p>
</li>
<li>
<p><a href="#i1007870">Relative Positioning of Fields</a></p>
</li>
<li>
<p><a href="#i1007924">Leading Whitespace</a></p>
</li>
<li>
<p><a href="#i1007970">Trimming Trailing Whitespace</a></p>
</li>
<li>
<p><a href="#i1007975">Trimming Enclosed Fields</a></p>
</li>
</ul>
<a id="i1007819"></a>
<div id="SUTIL1211" class="sect2">
<h3 class="sect2"><a id="sthref904"></a><a id="sthref905"></a>Datatypes for Which Whitespace Can Be Trimmed</h3>
<p>The information in this section applies only to fields specified with one of the character-data datatypes:</p>
<ul>
<li>
<p><code dir="ltr">CHAR</code> datatype</p>
</li>
<li>
<p>Datetime and interval datatypes</p>
</li>
<li>
<p>Numeric <code dir="ltr">EXTERNAL</code> datatypes:</p>
<ul>
<li>
<p><code dir="ltr">INTEGER</code> <code dir="ltr">EXTERNAL</code></p>
</li>
<li>
<p><code dir="ltr">FLOAT</code> <code dir="ltr">EXTERNAL</code></p>
</li>
<li>
<p>(packed) <code dir="ltr">DECIMAL</code> <code dir="ltr">EXTERNAL</code></p>
</li>
<li>
<p><code dir="ltr">ZONED</code> (decimal) <code dir="ltr">EXTERNAL</code></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although <code dir="ltr">VARCHAR</code> and <code dir="ltr">VARCHARC</code> fields also contain character data, these fields are never trimmed. These fields include all whitespace that is part of the field in the data file.</div>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1007836"></a>
<div id="SUTIL1212" class="sect2">
<h3 class="sect2">Specifying Field Length for Datatypes for Which Whitespace Can Be Trimmed</h3>
<p>There are two ways to specify field length. If a field has a constant length that is defined in the control file with a position specification or the datatype and length, then it has a predetermined size. If a field's length is not known in advance, but depends on indicators in the record, then the field is delimited, using either enclosure or termination delimiters. <a id="sthref906"></a></p>
<p>If a position specification with start and end values is defined for a field that also has enclosure or termination delimiters defined, then only the position specification has any effect. The enclosure and termination delimiters are ignored.</p>
<div id="SUTIL1213" class="sect3"><a id="sthref907"></a>
<h4 class="sect3">Predetermined Size Fields</h4>
<p><a id="sthref908"></a><a id="sthref909"></a>Fields that have a predetermined size are specified with a starting position and ending position, or with a length, as in the following examples:</p>
<pre dir="ltr">
loc POSITION(19:31) 
loc CHAR(14) 
</pre>
<p>In the second case, even though the exact position of the field is not specified, the length of the field is predetermined.</p>
</div>
<!-- class="sect3" -->
<a id="i1007848"></a>
<div id="SUTIL1214" class="sect3">
<h4 class="sect3">Delimited Fields</h4>
<p><a id="sthref910"></a><a id="sthref911"></a><a id="sthref912"></a><a id="sthref913"></a>Delimiters are characters that demarcate field boundaries.</p>
<p>Enclosure delimiters surround a field, like the quotation marks in the following example, where "__" represents blanks or tabs:</p>
<pre dir="ltr">
"__aa__"
</pre>
<p>Termination delimiters signal the end of a field, like the comma in the following example: <a id="sthref914"></a><a id="sthref915"></a></p>
<pre dir="ltr">
__aa__, 
</pre>
<p>Delimiters are specified with the control clauses <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> and <code dir="ltr">ENCLOSED</code> <code dir="ltr">BY</code>, as shown in the following example:</p>
<pre dir="ltr">
loc TERMINATED BY "." OPTIONALLY ENCLOSED BY '|'<a id="sthref916"></a><a id="sthref917"></a> 
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007870"></a>
<div id="SUTIL1215" class="sect2">
<h3 class="sect2">Relative Positioning of Fields</h3>
<p>This section describes how SQL*Loader determines the starting position<a id="sthref918"></a><a id="sthref919"></a> of a field in the following situations:</p>
<ul>
<li>
<p><a href="#i1007888">No Start Position Specified for a Field</a></p>
</li>
<li>
<p><a href="#i1007900">Previous Field Terminated by a Delimiter</a></p>
</li>
<li>
<p><a href="#i1007912">Previous Field Has Both Enclosure and Termination Delimiters</a></p>
</li>
</ul>
<a id="i1007888"></a>
<div id="SUTIL1216" class="sect3">
<h4 class="sect3">No Start Position Specified for a Field</h4>
<p>When a starting position is not specified for a field, it begins immediately after the end of the previous field. <a href="#i1007894">Figure 10-2</a> illustrates this situation when the previous field (Field 1) has a predetermined size.</p>
<div id="SUTIL3348" class="figure">
<p class="titleinfigure"><a id="i1007894"></a>Figure 10-2 Relative Positioning After a Fixed Field</p>
<img width="303" height="68" src="img/sut81005.gif" alt="Description of Figure 10-2 follows" /><br />
<a id="sthref920" href="img_text/sut81005.htm">Description of ''Figure 10-2 Relative Positioning After a Fixed Field ''</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="i1007900"></a>
<div id="SUTIL1217" class="sect3">
<h4 class="sect3">Previous Field Terminated by a Delimiter</h4>
<p>If the previous field (Field 1) is terminated by a delimiter, then the next field begins immediately after the delimiter, as shown in <a href="#i1007906">Figure 10-3</a>.</p>
<div id="SUTIL3349" class="figure">
<p class="titleinfigure"><a id="i1007906"></a>Figure 10-3 Relative Positioning After a Delimited Field</p>
<img width="304" height="68" src="img/sut81006.gif" alt="Description of Figure 10-3 follows" /><br />
<a id="sthref921" href="img_text/sut81006.htm">Description of ''Figure 10-3 Relative Positioning After a Delimited Field ''</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="i1007912"></a>
<div id="SUTIL1218" class="sect3">
<h4 class="sect3">Previous Field Has Both Enclosure and Termination Delimiters</h4>
<p>When a field is specified with both enclosure delimiters and a termination delimiter, then the next field starts after the termination delimiter, as shown in <a href="#i1007918">Figure 10-4</a>. If a nonwhitespace character is found after the enclosure delimiter, but before the terminator, then SQL*Loader generates an error.</p>
<div id="SUTIL3350" class="figure">
<p class="titleinfigure"><a id="i1007918"></a>Figure 10-4 Relative Positioning After Enclosure Delimiters</p>
<img width="318" height="82" src="img/sut81007.gif" alt="Description of Figure 10-4 follows" /><br />
<a id="sthref922" href="img_text/sut81007.htm">Description of ''Figure 10-4 Relative Positioning After Enclosure Delimiters ''</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007924"></a>
<div id="SUTIL1219" class="sect2">
<h3 class="sect2">Leading Whitespace</h3>
<p><a id="sthref923"></a><a id="sthref924"></a>In <a href="#i1007918">Figure 10-4</a>, both fields are stored with leading whitespace. Fields do <span class="italic">not</span> include leading whitespace in the following cases:</p>
<ul>
<li>
<p>When the previous field is terminated by whitespace, and no starting position is specified for the current field</p>
</li>
<li>
<p>When optional enclosure delimiters are specified for the field, and the enclosure delimiters are <span class="italic">not</span> present</p>
</li>
</ul>
<p>These cases are illustrated in the following sections.</p>
<div id="SUTIL1220" class="sect3"><a id="sthref925"></a>
<h4 class="sect3">Previous Field Terminated by Whitespace&nbsp;</h4>
<p><a id="sthref926"></a>If the previous field is <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> <code dir="ltr">WHITESPACE</code>, then all whitespace after the field acts as the delimiter. The next field starts at the next nonwhitespace character. <a href="#i1007941">Figure 10-5</a> illustrates this case.</p>
<div id="SUTIL3351" class="figure">
<p class="titleinfigure"><a id="i1007941"></a>Figure 10-5 Fields Terminated by Whitespace</p>
<img width="363" height="82" src="img/sut81008.gif" alt="Description of Figure 10-5 follows" /><br />
<a id="sthref927" href="img_text/sut81008.htm">Description of ''Figure 10-5 Fields Terminated by Whitespace''</a><br />
<br /></div>
<!-- class="figure" -->
<p>This situation occurs when the previous field is explicitly specified with the <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> <code dir="ltr">WHITESPACE</code> clause, as shown in the example. It also occurs when you use the global <code dir="ltr">FIELDS<a id="sthref928"></a></code> <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> <code dir="ltr">WHITESPACE</code> clause.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1221" class="sect3"><a id="sthref929"></a>
<h4 class="sect3">Optional Enclosure Delimiters</h4>
<p>Leading whitespace is also removed from a field when optional enclosure delimiters are specified but not present.</p>
<p>Whenever optional enclosure delimiters are specified, SQL*Loader scans forward, looking for the first enclosure delimiter. If an enclosure delimiter is not found, then SQL*Loader skips over whitespace, eliminating it from the field. The first nonwhitespace character signals the start of the field. This situation is shown in Field 2 in <a href="#i1007955">Figure 10-6</a>. (In Field 1 the whitespace is included because SQL*Loader found enclosure delimiters for the field.)</p>
<div id="SUTIL3352" class="figure">
<p class="titleinfigure"><a id="i1007955"></a>Figure 10-6 Fields Terminated by Optional Enclosure Delimiters</p>
<img width="363" height="82" src="img/sut81009.gif" alt="Description of Figure 10-6 follows" /><br />
<a id="sthref930" href="img_text/sut81009.htm">Description of ''Figure 10-6 Fields Terminated by Optional Enclosure Delimiters''</a><br />
<br /></div>
<!-- class="figure" -->
<p>Unlike the case when the previous field is <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> <code dir="ltr">WHITESPACE</code>, this specification removes leading whitespace even when a starting position is specified for the current field.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If enclosure delimiters are present, then leading whitespace after the initial enclosure delimiter is kept, but whitespace before this delimiter is discarded. See the first quotation mark in Field 1, <a href="#i1007955">Figure 10-6</a>.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007970"></a>
<div id="SUTIL1222" class="sect2">
<h3 class="sect2">Trimming Trailing Whitespace</h3>
<p><a id="sthref931"></a><a id="sthref932"></a>Trailing whitespace is always trimmed from character-data fields that have a predetermined size. These are the only fields for which trailing whitespace is always trimmed.</p>
</div>
<!-- class="sect2" -->
<a id="i1007975"></a>
<div id="SUTIL1223" class="sect2">
<h3 class="sect2">Trimming Enclosed Fields</h3>
<p><a id="sthref933"></a>If a field is enclosed, or terminated and enclosed, like the first field shown in <a href="#i1007955">Figure 10-6</a>, then any whitespace outside the enclosure delimiters is not part of the field. Any whitespace between the enclosure delimiters belongs to the field, whether it is leading or trailing whitespace.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008122"></a>
<div id="SUTIL1224" class="sect1">
<h2 class="sect1">How the PRESERVE BLANKS Option<a id="sthref934"></a><a id="sthref935"></a> Affects Whitespace Trimming</h2>
<p>To prevent whitespace trimming in <span class="italic">all</span> <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and numeric <code dir="ltr">EXTERNAL</code> fields, you specify <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> as part of the <code dir="ltr">LOAD</code> statement in the control file. However, there may be times when you do not want to preserve blanks for <span class="italic">all</span> <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and numeric <code dir="ltr">EXTERNAL</code> fields. Therefore, SQL*Loader also enables you to specify <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> as part of the datatype specification for individual fields, rather than specifying it globally as part of the <code dir="ltr">LOAD</code> statement.</p>
<p>In the following example, assume that <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> has not been specified as part of the <code dir="ltr">LOAD</code> statement, but you want the <code dir="ltr">c1</code> field to default to zero when blanks are present. You can achieve this by specifying <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> on the individual field. Only that field is affected; blanks will still be removed on other fields.</p>
<pre dir="ltr">
c1 INTEGER EXTERNAL(10) PRESERVE BLANKS DEFAULTIF c1=BLANKS
</pre>
<p>In this example, if <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> were not specified for the field, then it would result in the field being improperly loaded as NULL (instead of as 0).</p>
<p>There may be times when you want to specify <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> as an option to the <code dir="ltr">LOAD</code> statement and have it apply to most <code dir="ltr">CHAR</code>, <code dir="ltr">DATE</code>, and numeric <code dir="ltr">EXTERNAL</code> fields. You can override it for an individual field by specifying <code dir="ltr">NO</code> <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> as part of the datatype specification for that field, as follows:</p>
<pre dir="ltr">
c1 INTEGER EXTERNAL(10) NO PRESERVE BLANKS
</pre>
<div id="SUTIL1225" class="sect2"><a id="sthref936"></a>
<h3 class="sect2">How [NO] PRESERVE BLANKS Works with Delimiter Clauses</h3>
<p>The <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> option is affected by the presence of the delimiter clauses, as follows:</p>
<ul>
<li>
<p>Leading whitespace is left intact when optional enclosure delimiters are not present</p>
</li>
<li>
<p>Trailing whitespace is left intact when fields are specified with a predetermined size</p>
</li>
</ul>
<p>For example, consider the following field, where underscores represent blanks:</p>
<pre dir="ltr">
__aa__, 
</pre>
<p>Suppose this field is loaded with the following delimiter clause:</p>
<pre dir="ltr">
TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' 
</pre>
<p>In such a case, if <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> is specified, then both the leading whitespace and the trailing whitespace are retained. If <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> is not specified, then the leading whitespace is trimmed.</p>
<p>Now suppose the field is loaded with the following clause:</p>
<pre dir="ltr">
TERMINATED BY WHITESPACE
</pre>
<p>In such a case, if <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> is specified, then it does not retain the space at the beginning of the next field, unless that field is specified with a <code dir="ltr">POSITION</code> clause that includes some of the whitespace. Otherwise, SQL*Loader scans past all whitespace at the end of the previous field until it finds a nonblank, nontab character.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007768">"Trimming Whitespace"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008150"></a>
<div id="SUTIL1226" class="sect1">
<h2 class="sect1">Applying SQL Operators to Fields<a id="sthref937"></a><a id="sthref938"></a></h2>
<p>A wide variety of SQL operators can be applied to field data with the SQL string. This string can contain any combination of SQL expressions that are recognized by the Oracle database as valid for the <code dir="ltr">VALUES</code> clause of an <code dir="ltr">INSERT</code> statement. In general, any SQL function that returns a single value that is compatible with the target column's datatype can be used. SQL strings can be applied to simple scalar column types and also to user-defined complex types such as column object and collections. See the information about expressions in the <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference.</span></a></p>
<p>The column name and the name of the column in a SQL string bind variable must, with the interpretation of SQL identifier rules, correspond to the same column. But the two names do not necessarily have to be written exactly the same way, as in the following example of specifying the control file:</p>
<pre dir="ltr">
LOAD DATA 
INFILE * 
APPEND INTO TABLE XXX 
( "Last"   position(1:7)     char   "UPPER(:\"Last\")" 
   first   position(8:15)    char   "UPPER(:first || :FIRST || :\"FIRST\")" 
) 
BEGINDATA 
Phil Grant 
Jason Taylor 
</pre>
<p>Note the following about the preceding example:</p>
<ul>
<li>
<p>If, during table creation, a column identifier is declared using double quotation marks because it contains lowercase and/or special-case letters (as in the column named <code dir="ltr">"Last"</code> above), then the column name in the bind variable must exactly match the column name used in the <code dir="ltr">CREATE TABLE</code> statement.</p>
</li>
<li>
<p>If a column identifier is declared without double quotation marks during table creation (as in the column name <code dir="ltr">first</code> above), then because <code dir="ltr">first</code>, <code dir="ltr">FIRST</code>, and <code dir="ltr">"FIRST"</code> all point to the same column, any of these written formats in a SQL string bind variable would be acceptable.</p>
</li>
</ul>
<p>The following requirements and restrictions apply when you are using SQL strings:</p>
<ul>
<li>
<p>If your control file specifies character input that has an associated SQL string, then SQL*Loader makes no attempt to modify the data. This is because SQL*Loader assumes that character input data that is modified using a SQL operator will yield results that are correct for database insertion.</p>
</li>
<li>
<p>The SQL string appears after any other specifications for a given column.</p>
</li>
<li>
<p>The SQL string must be enclosed in double quotation marks.</p>
</li>
<li>
<p>To enclose a column name in quotation marks within a SQL string, you must use escape characters.</p>
<p>In the preceding example, <code dir="ltr">Last</code> is enclosed in double quotation marks to preserve the mixed case, and the double quotation marks necessitate the use of the backslash (escape) character.</p>
</li>
<li>
<p>If a SQL string contains a column name that references a column object attribute, then the full object attribute name must be used in the bind variable. Each attribute name in the full name is an individual identifier. Each identifier is subject to the SQL identifier quoting rules, independent of the other identifiers in the full name. For example, suppose you have a column object named <code dir="ltr">CHILD</code> with an attribute name of <code dir="ltr">"HEIGHT_%TILE"</code>. (Note that the attribute name is in double quotation marks.) To use the full object attribute name in a bind variable, any one of the following formats would work:</p>
<ul>
<li>
<p><code dir="ltr">:CHILD.\"HEIGHT_%TILE\"</code></p>
</li>
<li>
<p><code dir="ltr">:child.\"HEIGHT_%TILE\"</code></p>
</li>
</ul>
<p>Enclosing the full name (<code dir="ltr">:\"CHILD.HEIGHT_%TILE\"</code>) generates a warning message that the quoting rule on an object attribute name used in a bind variable has changed. The warning is only to suggest that the bind variable be written correctly; it will not cause the load to abort. The quoting rule was changed because enclosing the full name in quotation marks would have caused SQL to interpret the name as one identifier rather than a full column object attribute name consisting of multiple identifiers.</p>
</li>
<li>
<p>The SQL string is evaluated after any <code dir="ltr">NULLIF</code> or <code dir="ltr">DEFAULTIF</code> clauses, but before a date mask.</p>
</li>
<li>
<p>If the Oracle database does not recognize the string, then the load terminates in error. If the string is recognized, but causes a database error, then the row that caused the error is rejected.</p>
</li>
<li>
<p>SQL strings are required when using the <code dir="ltr">EXPRESSION</code> parameter in a field specification.</p>
</li>
<li>
<p>The SQL string cannot reference fields that are loaded using <code dir="ltr">OID</code>, <code dir="ltr">SID</code>, <code dir="ltr">REF</code>, or <code dir="ltr">BFILE</code>. Also, it cannot reference filler fields.</p>
</li>
<li>
<p>In direct path mode, a SQL string cannot reference a <code dir="ltr">VARRAY</code>, nested table, or LOB column. This also includes a <code dir="ltr">VARRAY</code>, nested table, or LOB column that is an attribute of a column object.</p>
</li>
<li>
<p>The SQL string cannot be used on <code dir="ltr">RECNUM</code>, <code dir="ltr">SEQUENCE</code>, <code dir="ltr">CONSTANT</code>, or <code dir="ltr">SYSDATE</code> fields.</p>
</li>
<li>
<p>The SQL string cannot be used on LOBs, <code dir="ltr">BFILE</code>s, <code dir="ltr">XML</code> columns, or a file that is an element of a collection.</p>
</li>
<li>
<p>In direct path mode, the final result that is returned after evaluation of the expression in the SQL string must be a scalar datatype. That is, the expression may not return an object or collection datatype when performing a direct path load.</p>
</li>
</ul>
<div id="SUTIL1227" class="sect2"><a id="sthref939"></a>
<h3 class="sect2">Referencing Fields</h3>
<p>To refer to fields in the record, precede the field name with a colon (:). Field values from the current record are substituted. A field name preceded by a colon (:) in a SQL string is also referred to as a bind variable. Note that bind variables enclosed in single quotation marks are treated as text literals, <span class="italic">not</span> as bind variables.</p>
<p>The following example illustrates how a reference is made to both the current field and to other fields in the control file. It also illustrates how enclosing bind variables in single quotation marks causes them to be treated as text literals. Be sure to read the notes following this example to help you fully understand the concepts it illustrates.</p>
<pre dir="ltr">
LOAD DATA
INFILE *
APPEND INTO TABLE YYY
(
 field1  POSITION(1:6) CHAR "LOWER(:field1)"
 field2  CHAR TERMINATED BY ','
         NULLIF ((1) = 'a') DEFAULTIF ((1)= 'b')
         "RTRIM(:field2)"
 field3  CHAR(7) "TRANSLATE(:field3, ':field1', ':1')",
 field4  COLUMN OBJECT
 (
  attr1  CHAR(3)  "UPPER(:field4.attr3)",
  attr2  CHAR(2),
  attr3  CHAR(3)  ":field4.attr1 + 1"
 ),
 field5  EXPRESSION "MYFUNC(:FIELD4, SYSDATE)"
)
BEGINDATA
ABCDEF1234511  ,:field1500YYabc
abcDEF67890    ,:field2600ZZghl
</pre>
<p><a id="SUTIL3353"></a><span class="subhead3">Notes About This Example:&nbsp;</span></p>
<ul>
<li>
<p>In the following line, <code dir="ltr">:field1</code> is <span class="italic">not</span> enclosed in single quotation marks and is therefore interpreted as a bind variable:</p>
<p>field1 POSITION(1:6) CHAR "LOWER(:field1)"</p>
</li>
<li>
<p>In the following line, <code dir="ltr">':field1'</code> and <code dir="ltr">':1'</code> <span class="italic">are</span> enclosed in single quotation marks and are therefore treated as text literals and passed unchanged to the <code dir="ltr">TRANSLATE</code> function:</p>
<p><code dir="ltr">field3 CHAR(7) "TRANSLATE(:field3, ':field1', ':1')"</code></p>
<p>For more information about the use of quotation marks inside quoted strings, see <a href="ldr_control_file.htm#i1004816">"Specifying File Names and Object Names"</a>.</p>
</li>
<li>
<p>For each input record read, the value of the field referenced by the bind variable will be substituted for the bind variable. For example, the value <code dir="ltr">ABCDEF</code> in the first record is mapped to the first field <code dir="ltr">:field1</code>. This value is then passed as an argument to the <code dir="ltr">LOWER</code> function.</p>
</li>
<li>
<p>A bind variable in a SQL string need not reference the current field. In the preceding example, the bind variable in the SQL string for field <code dir="ltr">FIELD4.ATTR1</code> references field <code dir="ltr">FIELD4.ATTR3</code>. The field <code dir="ltr">FIELD4.ATTR1</code> is still mapped to the values 500 and 600 in the input records, but the final values stored in its corresponding columns are ABC and GHL.</p>
</li>
<li>
<p><code dir="ltr">field5</code> is not mapped to any field in the input record. The value that is stored in the target column is the result of executing the <code dir="ltr">MYFUNC</code> PL/SQL function, which takes two arguments. The use of the <code dir="ltr">EXPRESSION</code> parameter requires that a SQL string be used to compute the final value of the column because no input data is mapped to the field.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1228" class="sect2"><a id="sthref940"></a>
<h3 class="sect2">Common Uses of SQL Operators in Field Specifications</h3>
<p>SQL operators are commonly used for the following tasks:</p>
<ul>
<li>
<p>Loading external data with an implied decimal point:</p>
</li>
</ul>
<pre dir="ltr">
     field1 POSITION(1:9) DECIMAL EXTERNAL(8) ":field1/1000"
</pre>
<ul>
<li>
<p>Truncating fields that could be too long:</p>
</li>
</ul>
<pre dir="ltr">
     field1 CHAR TERMINATED BY "," "SUBSTR(:field1, 1, 10)"
</pre></div>
<!-- class="sect2" -->
<div id="SUTIL1229" class="sect2"><a id="sthref941"></a>
<h3 class="sect2">Combinations of SQL Operators</h3>
<p>Multiple operators can also be combined, as in the following examples:</p>
<pre dir="ltr">
field1 POSITION(*+3) INTEGER EXTERNAL
       "TRUNC(RPAD(:field1,6,'0'), -2)"
field1 POSITION(1:8) INTEGER EXTERNAL
       "TRANSLATE(RTRIM(:field1),'N/A', '0')"
field1 CHAR(10)
       "NVL( LTRIM(RTRIM(:field1)), 'unknown' )"
</pre></div>
<!-- class="sect2" -->
<div id="SUTIL1230" class="sect2"><a id="sthref942"></a>
<h3 class="sect2">Using SQL Strings with a Date Mask</h3>
<p>When a SQL string is used with a date mask, the date mask is evaluated after the SQL string. Consider a field specified as follows:</p>
<pre dir="ltr">
field1 DATE "dd-mon-yy" "RTRIM(:field1)"
</pre>
<p>SQL*Loader internally generates and inserts the following:</p>
<pre dir="ltr">
TO_DATE(RTRIM(&lt;field1_value&gt;), 'dd-mon-yyyy')
</pre>
<p>Note that when using the <code dir="ltr">DATE</code> field datatype, it is not possible to have a SQL string without a date mask. This is because SQL*Loader assumes that the first quoted string it finds after the <code dir="ltr">DATE</code> parameter is a date mask. For instance, the following field specification would result in an error (ORA-01821: date format not recognized):</p>
<pre dir="ltr">
field1 DATE "RTRIM(TO_DATE(:field1, 'dd-mon-yyyy'))"
</pre>
<p>In this case, a simple workaround is to use the <code dir="ltr">CHAR</code> datatype.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1231" class="sect2"><a id="sthref943"></a>
<h3 class="sect2">Interpreting Formatted Fields</h3>
<p>It is possible to use the <code dir="ltr">TO_CHAR</code> operator to store formatted dates and numbers. For example:</p>
<pre dir="ltr">
field1 ... "TO_CHAR(:field1, '$09999.99')"
</pre>
<p>This example could store numeric input data in formatted form, where <code dir="ltr">field1</code> is a character column in the database. This field would be stored with the formatting characters (dollar sign, period, and so on) already in place.</p>
<p>You have even more flexibility, however, if you store such values as numeric quantities or dates. You can then apply arithmetic functions to the values in the database, and still select formatted values for your reports.</p>
<p>An example of using the SQL string to load data from a formatted report is shown in case study 7, Extracting Data from a Formatted Report. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1232" class="sect2"><a id="sthref944"></a>
<h3 class="sect2">Using SQL Strings to Load the ANYDATA Database Type</h3>
<p>The <code dir="ltr">ANYDATA</code> database type can contain data of different types. To load<a id="sthref945"></a> the <code dir="ltr">ANYDATA</code> type using SQL*loader, it must be explicitly constructed by using a function call. The function is invoked using support for SQL strings as has been described in this section.</p>
<p>For example, suppose you have a table with a column named <code dir="ltr">miscellaneous</code> which is of type <code dir="ltr">ANYDATA</code>. You could load the column by doing the following, which would create an <code dir="ltr">ANYDATA</code> type containing a number.</p>
<pre dir="ltr">
LOAD DATA
INFILE *
APPEND INTO TABLE  ORDERS
(
miscellaneous CHAR "SYS.ANYDATA.CONVERTNUMBER(:miscellaneous)"
)
BEGINDATA
4
</pre>
<p>There can also be more complex situations in which you create an <code dir="ltr">ANYDATA</code> type that contains a different type depending upon the values in the record. To do this, you could write your own PL/SQL function that would determine what type should be in the <code dir="ltr">ANYDATA</code> type, based on the value in the record, and then call the appropriate <code dir="ltr">ANYDATA</code>.<code dir="ltr">Convert*()</code> function to create it.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ANYDATA</code> database type</p>
</li>
<li>
<p><a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about using <code dir="ltr">ANYDATA</code> with PL/SQL</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008234"></a>
<div id="SUTIL1233" class="sect1">
<h2 class="sect1">Using SQL*Loader to Generate Data for Input</h2>
<p>The parameters described in this section provide the means for SQL*Loader to generate the data stored in the database record, rather than reading it from a data file. The following parameters are described:</p>
<ul>
<li>
<p><a href="#i1008664">CONSTANT Parameter</a></p>
</li>
<li>
<p><a href="#i1008675">EXPRESSION Parameter</a></p>
</li>
<li>
<p><a href="#i1008287">RECNUM Parameter</a></p>
</li>
<li>
<p><a href="#i1008302">SYSDATE Parameter</a></p>
</li>
<li>
<p><a href="#i1008320">SEQUENCE Parameter</a></p>
</li>
</ul>
<a id="i1008253"></a>
<div id="SUTIL1234" class="sect2">
<h3 class="sect2">Loading Data Without Files</h3>
<p><a id="sthref946"></a>It is possible to use SQL*Loader to generate data by specifying only sequences, record numbers, system dates, constants, and SQL string expressions as field specifications. <a id="sthref947"></a><a id="sthref948"></a></p>
<p>SQL*Loader inserts as many records as are specified by the <code dir="ltr">LOAD</code> statement. The <code dir="ltr">SKIP</code> parameter is not permitted in this situation.</p>
<p>SQL*Loader is optimized for this case. Whenever SQL*Loader detects that <span class="italic">only</span> generated specifications are used, it ignores any specified data file&mdash;no read I/O is performed.</p>
<p>In addition, no memory is required for a bind array. If there are any <code dir="ltr">WHEN</code> clauses in the control file, then SQL*Loader assumes that data evaluation is necessary, and input records are read.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1235" class="sect2"><a id="sthref949"></a>
<h3 class="sect2">Setting a Column to a Constant Value</h3>
<p>This is the simplest form of generated data. It does not vary during the load or between loads. <a id="sthref950"></a><a id="sthref951"></a></p>
<a id="i1008664"></a>
<div id="SUTIL1236" class="sect3">
<h4 class="sect3">CONSTANT Parameter</h4>
<p>To set a column to a constant value, use <code dir="ltr">CONSTANT</code> followed by a value:</p>
<pre dir="ltr">
CONSTANT  <span class="italic">value</span>
</pre>
<p><code dir="ltr">CONSTANT</code> data is interpreted by SQL*Loader as character input. It is converted, as necessary, to the database column type.</p>
<p>You may enclose the value within quotation marks, and you must do so if it contains whitespace or reserved words. Be sure to specify a legal value for the target column. If the value is bad, then every record is rejected.</p>
<p>Numeric values larger than 2^32 - 1 (4,294,967,295) must be enclosed in quotation marks.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Do not use the <code dir="ltr">CONSTANT</code> parameter to set a column to null. To set a column to null, do not specify that column at all. Oracle automatically sets that column to null when loading the record. The combination of <code dir="ltr">CONSTANT</code> and a value is a complete column specification. <a id="sthref952"></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1237" class="sect2"><a id="sthref953"></a>
<h3 class="sect2">Setting a Column to an Expression Value<a id="sthref954"></a><a id="sthref955"></a></h3>
<p>Use the <code dir="ltr">EXPRESSION</code> parameter after a column name to set that column to the value<a id="sthref956"></a> returned by a SQL operator or specially written PL/SQL function. The operator or function is indicated in a SQL string that follows the <code dir="ltr">EXPRESSION</code> parameter. Any arbitrary expression may be used in this context provided that any parameters required for the operator or function are correctly specified and that the result returned by the operator or function is compatible with the datatype of the column being loaded.</p>
<a id="i1008675"></a>
<div id="SUTIL1238" class="sect3">
<h4 class="sect3">EXPRESSION Parameter</h4>
<p>The combination of column name, <code dir="ltr">EXPRESSION</code> parameter<a id="sthref957"></a>, and a SQL string is a complete field specification:</p>
<pre dir="ltr">
column_name EXPRESSION "SQL string"
</pre>
<p>In both conventional path mode and direct path mode, the <code dir="ltr">EXPRESSION</code> parameter can be used to load the default value into <code dir="ltr">column_name</code>:</p>
<pre dir="ltr">
column_name EXPRESSION "DEFAULT"
</pre>
<p>Note that if <code dir="ltr">DEFAULT</code> is used and the mode is direct path, then use of a sequence as a default will not work.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1239" class="sect2"><a id="sthref958"></a>
<h3 class="sect2">Setting a Column to the Data File Record Number</h3>
<p>Use the <code dir="ltr">RECNUM</code> parameter after a column name to set that column to the number of the logical record from which that record was loaded. Records are counted sequentially from the beginning of the first data file, starting with record 1. <code dir="ltr">RECNUM</code> is incremented as each logical record is assembled. Thus it increments for records that are discarded, skipped, rejected, or loaded. If you use the option <code dir="ltr">SKIP=10</code>, then the first record loaded has a <code dir="ltr">RECNUM</code> of 11.<a id="sthref959"></a><a id="sthref960"></a><a id="sthref961"></a><a id="sthref962"></a></p>
<a id="i1008287"></a>
<div id="SUTIL1240" class="sect3">
<h4 class="sect3">RECNUM Parameter</h4>
<p>The combination of column name and <code dir="ltr">RECNUM</code> is a complete column specification.</p>
<pre dir="ltr">
column_name RECNUM
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008291"></a>
<div id="SUTIL1241" class="sect2">
<h3 class="sect2">Setting a Column to the Current Date</h3>
<p><a id="sthref963"></a>A column specified with <code dir="ltr">SYSDATE</code> gets the current system date, as defined by the SQL language <code dir="ltr">SYSDATE</code> parameter. See the section on the <code dir="ltr">DATE</code> datatype in <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference.</span></a><a id="sthref964"></a></p>
<a id="i1008302"></a>
<div id="SUTIL1242" class="sect3">
<h4 class="sect3">SYSDATE Parameter</h4>
<p>The combination of column name and the <code dir="ltr">SYSDATE</code> parameter is a complete column specification.</p>
<pre dir="ltr">
column_name SYSDATE
</pre>
<p>The database column must be of type <code dir="ltr">CHAR</code> or <code dir="ltr">DATE</code>. If the column is of type <code dir="ltr">CHAR</code>, then the date is loaded in the form 'dd-mon-yy.' After the load, it can be loaded only in that form. If the system date is loaded into a <code dir="ltr">DATE</code> column, then it can be loaded in a variety of forms that include the time and the date.</p>
<p>A new system date/time is used for each array of records inserted in a conventional path load and for each block of records loaded during a direct path load.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008309"></a>
<div id="SUTIL1243" class="sect2">
<h3 class="sect2">Setting a Column to a Unique Sequence Number</h3>
<p><a id="sthref965"></a><a id="sthref966"></a><a id="sthref967"></a><a id="sthref968"></a><a id="sthref969"></a><a id="sthref970"></a>The <code dir="ltr">SEQUENCE</code> parameter ensures a unique value for a particular column. <code dir="ltr">SEQUENCE</code> increments for each record that is loaded or rejected. It does not increment for records that are discarded or skipped.</p>
<a id="i1008320"></a>
<div id="SUTIL1244" class="sect3">
<h4 class="sect3">SEQUENCE Parameter</h4>
<p>The combination of column name and the <code dir="ltr">SEQUENCE</code> parameter is a complete column specification.</p>
<img width="484" height="91" src="img/sequence.gif" alt="Description of sequence.gif follows" /><br />
<a id="sthref971" href="img_text/sequence.htm">Description of the illustration ''sequence.gif''</a><br />
<br />
<p><a href="#g1026624">Table 10-6</a> describes the parameters used for column specification.</p>
<div id="SUTIL3354" class="tblformal">
<p class="titleintable"><a id="sthref972"></a><a id="g1026624"></a>Table 10-6 Parameters Used for Column Specification</p>
<table class="cellalignment1394" title="Parameters Used for Column Specification" summary="Parameters used for column specification" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t36">Parameter</th>
<th class="cellalignment1395" id="r1c2-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t36" headers="r1c1-t36">
<p><code dir="ltr"><span class="codeinlineitalic">column_name</span></code></p>
</td>
<td class="cellalignment1396" headers="r2c1-t36 r1c2-t36">
<p>The name of the column in the database to which to assign the sequence.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t36" headers="r1c1-t36">
<p><code dir="ltr">SEQUENCE</code></p>
</td>
<td class="cellalignment1396" headers="r3c1-t36 r1c2-t36">
<p>Use the <code dir="ltr">SEQUENCE</code> parameter to specify the value for a column.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t36" headers="r1c1-t36">
<p><code dir="ltr">COUNT</code></p>
</td>
<td class="cellalignment1396" headers="r4c1-t36 r1c2-t36">
<p>The sequence starts with the number of records already in the table plus the increment.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t36" headers="r1c1-t36">
<p><code dir="ltr">MAX</code></p>
</td>
<td class="cellalignment1396" headers="r5c1-t36 r1c2-t36">
<p>The sequence starts with the current maximum value for the column plus the increment.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t36" headers="r1c1-t36">
<p><code dir="ltr"><span class="codeinlineitalic">integer</span></code></p>
</td>
<td class="cellalignment1396" headers="r6c1-t36 r1c2-t36">
<p>Specifies the specific sequence number to begin with.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t36" headers="r1c1-t36">
<p><code dir="ltr"><span class="codeinlineitalic">incr</span></code></p>
</td>
<td class="cellalignment1396" headers="r7c1-t36 r1c2-t36">
<p>The value that the sequence number is to increment after a record is loaded or rejected. This is optional. The default is 1.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformal" -->
<p>If a record is rejected (that is, it has a format error or causes an Oracle error), then the generated sequence numbers are not reshuffled to mask this. If four rows are assigned sequence numbers 10, 12, 14, and 16 in a particular column, and the row with 12 is rejected, then the three rows inserted are numbered 10, 14, and 16, not 10, 12, and 14. This allows the sequence of inserts to be preserved despite data errors. When you correct the rejected data and reinsert it, you can manually set the columns to agree with the sequence.</p>
<p>Case study 3, Loading a Delimited Free-Format File, provides an example of using the <code dir="ltr">SEQUENCE</code> parameter. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1245" class="sect2"><a id="sthref973"></a>
<h3 class="sect2">Generating Sequence Numbers for Multiple Tables</h3>
<p><a id="sthref974"></a><a id="sthref975"></a>Because a unique sequence number is generated for each logical input record, rather than for each table insert, the same sequence number can be used when inserting data into multiple tables. This is frequently useful.</p>
<p>Sometimes, however, you might want to generate different sequence numbers for each <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause. For example, your data format might define three logical records in every input record. In that case, you can use three <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses, each of which inserts a different part of the record into the same table. When you use <code dir="ltr">SEQUENCE(MAX)</code>, SQL*Loader will use the maximum from each table, which can lead to inconsistencies in sequence numbers.</p>
<p>To generate sequence numbers for these records, you must generate unique numbers for each of the three inserts. Use the number of table-inserts per record as the sequence increment, and start the sequence numbers for each insert with successive numbers.</p>
<div id="SUTIL1246" class="sect3"><a id="sthref976"></a>
<h4 class="sect3">Example: Generating Different Sequence Numbers for Each Insert</h4>
<p>Suppose you want to load the following department names into the <code dir="ltr">dept</code> table. Each input record contains three department names, and you want to generate the department numbers automatically.</p>
<pre dir="ltr">
Accounting     Personnel      Manufacturing
Shipping       Purchasing     Maintenance 
... 
</pre>
<p>You could use the following control file entries to generate unique department numbers:</p>
<pre dir="ltr">
INTO TABLE dept 
(deptno  SEQUENCE(1, 3), 
 dname   POSITION(1:14) CHAR) 
INTO TABLE dept 
(deptno  SEQUENCE(2, 3), 
 dname   POSITION(16:29) CHAR) 
INTO TABLE dept 
(deptno  SEQUENCE(3, 3), 
 dname   POSITION(31:44) CHAR) 
</pre>
<p>The first <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause generates department number 1, the second number 2, and the third number 3. They all use 3 as the sequence increment (the number of department names in each record). This control file loads Accounting as department number 1, Personnel as 2, and Manufacturing as 3.</p>
<p>The sequence numbers are then incremented for the next record, so Shipping loads as 4, Purchasing as 5, and so on.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1387">
<tr>
<td class="cellalignment1396">
<table class="cellalignment1392">
<tr>
<td class="cellalignment1391"><a href="ldr_control_file.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1391"><a href="ldr_loading.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1398">
<table class="cellalignment1390">
<tr>
<td class="cellalignment1391"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1391"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1391"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1391"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1391"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1391"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
</body>
</html>
