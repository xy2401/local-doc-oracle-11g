<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Loading Objects, LOBs, and Collections</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093" />
<meta name="dcterms.created" content="2018-03-26T15:55:3Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Utilities" />
<meta name="dcterms.identifier" content="E22490-08" />
<meta name="dcterms.isVersionOf" content="SUTIL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ldr_field_list.htm" title="Previous" type="text/html" />
<link rel="Next" href="ldr_modes.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e22490.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">20/36</span> <!-- End Header -->
<div id="SUTIL007" class="chapter"><a id="g1026656"></a> <a id="i1007590"></a>
<h1 class="chapter"><span class="secnum">11</span> Loading Objects, LOBs, and Collections</h1>
<p>This chapter discusses the following topics:</p>
<ul>
<li>
<p><a href="#i1006457">Loading Column Objects</a></p>
</li>
<li>
<p><a href="#i1009398">Loading Object Tables</a></p>
</li>
<li>
<p><a href="#i1010641">Loading REF Columns</a></p>
</li>
<li>
<p><a href="#i1006803">Loading LOBs</a></p>
</li>
<li>
<p><a href="#i1010766">Loading BFILE Columns</a></p>
</li>
<li>
<p><a href="#i1007180">Loading Collections (Nested Tables and VARRAYs)</a></p>
</li>
<li>
<p><a href="#i1007661">Dynamic Versus Static SDF Specifications</a></p>
</li>
<li>
<p><a href="#i1007322">Loading a Parent Table Separately from Its Child Table</a></p>
</li>
</ul>
<a id="i1006457"></a>
<div id="SUTIL1247" class="sect1">
<h2 class="sect1">Loading Column Objects<a id="sthref977"></a><a id="sthref978"></a><a id="sthref979"></a></h2>
<p>Column objects in the control file are described in terms of their attributes. If the object type on which the column object is based is declared to be nonfinal, then the column object in the control file may be described in terms of the attributes, both derived and declared, of any subtype derived from the base object type. In the data file, the data corresponding to each of the attributes of a column object is in a data field similar to that corresponding to a simple relational column.</p>
<div class="infobox-note">
<p class="notep1"><span class="bold">Note</span>:</p>
With SQL*Loader support for complex datatypes like column objects, the possibility arises that two identical field names could exist in the control file, one corresponding to a column, the other corresponding to a column object's attribute. Certain clauses can refer to fields (for example, <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, <code dir="ltr">DEFAULTIF</code>, <code dir="ltr">SID</code>, <code dir="ltr">OID</code>, <code dir="ltr">REF</code>, <code dir="ltr">BFILE</code>, and so on), causing a naming conflict if identically named fields exist in the control file.
<p>Therefore, if you use clauses that refer to fields, then you must specify the full name. For example, if field <code dir="ltr">fld1</code> is specified to be a <code dir="ltr">COLUMN</code> <code dir="ltr">OBJECT</code> and it contains field <code dir="ltr">fld2</code>, then when you specify <code dir="ltr">fld2</code> in a clause such as <code dir="ltr">NULLIF</code>, you must use the full field name <code dir="ltr">fld1.fld2</code>.</p>
</div>
<p>The following sections show examples of loading column objects:</p>
<ul>
<li>
<p><a href="#i1008533">Loading Column Objects in Stream Record Format</a></p>
</li>
<li>
<p><a href="#i1008538">Loading Column Objects in Variable Record Format</a></p>
</li>
<li>
<p><a href="#i1008543">Loading Nested Column Objects</a></p>
</li>
<li>
<p><a href="#i1008548">Loading Column Objects with a Derived Subtype</a></p>
</li>
<li>
<p><a href="#i1006576">Specifying Null Values for Objects</a></p>
</li>
<li>
<p><a href="#i1009457">Loading Column Objects with User-Defined Constructors</a></p>
</li>
</ul>
<a id="i1008533"></a>
<div id="SUTIL1248" class="sect2">
<h3 class="sect2">Loading <a id="sthref980"></a>Column <a id="sthref981"></a>Objects in <a id="sthref982"></a>Stream Record Format</h3>
<p><a href="#i1006483">Example 11-1</a> shows a case in which the data is in predetermined size fields. The newline character marks the end of a physical record. You can also mark the end of a physical record by using a custom record separator in the operating system file-processing clause (<code dir="ltr">os_file_proc_clause</code>).</p>
<div id="SUTIL3355" class="example">
<p class="titleinexample"><a id="i1006483"></a>Example 11-1 Loading Column Objects in Stream Record Format</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments
   (dept_no     POSITION(01:03)    CHAR,
    dept_name   POSITION(05:15)    CHAR,
<span class="bold">1</span>   dept_mgr    COLUMN OBJECT
      (name     POSITION(17:33)    CHAR,
       age      POSITION(35:37)    INTEGER EXTERNAL,
       emp_id   POSITION(40:46)    INTEGER EXTERNAL) )
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
101 Mathematics  Johny Quest       30   1024
237 Physics      Albert Einstein   65   0000
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3356"></a>Notes</p>
<ol>
<li>
<p>This type of column object specification can be applied recursively to describe nested column objects.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1008538"></a>
<div id="SUTIL1249" class="sect2">
<h3 class="sect2">Loading <a id="sthref983"></a>Column <a id="sthref984"></a>Objects in <a id="sthref985"></a>Variable Record Format<a id="sthref986"></a><a id="sthref987"></a></h3>
<p><a href="#i1011524">Example 11-2</a> shows a case in which the data is in delimited fields.</p>
<div id="SUTIL3357" class="example">
<p class="titleinexample"><a id="i1011524"></a>Example 11-2 Loading Column Objects in Variable Record Format</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
<span class="bold">1</span> INFILE 'sample.dat' "var 6"
INTO TABLE departments
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
<span class="bold">2</span>  (dept_no
   dept_name, 
   dept_mgr       COLUMN OBJECT
      (name       CHAR(30), 
      age         INTEGER EXTERNAL(5), 
      emp_id      INTEGER EXTERNAL(5)) )
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
<span class="bold">3</span>  <span class="italic">000034</span>101,Mathematics,Johny Q.,30,1024,
   <span class="italic">000039237</span>,Physics,"Albert Einstein",65,0000,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3358"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The <code dir="ltr">"var"</code> string includes the number of bytes in the length field at the beginning of each record (in this example, the number is 6). If no value is specified, then the default is 5 bytes. The maximum size of a variable record is 2^32-1. Specifying larger values will result in an error.</p>
</li>
<li>
<p>Although no positional specifications are given, the general syntax remains the same (the column object's name followed by the list of its attributes enclosed in parentheses). Also note that an omitted type specification defaults to <code dir="ltr">CHAR</code> of length 255.</p>
</li>
<li>
<p>The first 6 bytes (italicized) specify the length of the forthcoming record. These length specifications include the newline characters, which are ignored thanks to the terminators after the <code dir="ltr">emp_id</code> field.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1008543"></a>
<div id="SUTIL1250" class="sect2">
<h3 class="sect2">Loading <a id="sthref988"></a>Nested <a id="sthref989"></a>Column <a id="sthref990"></a>Objects<a id="sthref991"></a></h3>
<p><a href="#i1006552">Example 11-3</a> shows a control file describing nested column objects (one column object nested in another column object).</p>
<div id="SUTIL3359" class="example">
<p class="titleinexample"><a id="i1006552"></a>Example 11-3 Loading Nested Column Objects</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE `sample.dat'
INTO TABLE departments_v2
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (dept_no      CHAR(5), 
   dept_name     CHAR(30), 
   dept_mgr      COLUMN OBJECT
      (name      CHAR(30), 
      age        INTEGER EXTERNAL(3),
      emp_id     INTEGER EXTERNAL(7),
<span class="bold">1</span>     em_contact COLUMN OBJECT
         (name      CHAR(30), 
         phone_num  CHAR(20))))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
101,Mathematics,Johny Q.,30,1024,"Barbie",650-251-0010,
237,Physics,"Albert Einstein",65,0000,Wife Einstein,654-3210,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3360"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>This entry specifies a column object nested within a column object.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1008548"></a>
<div id="SUTIL1251" class="sect2">
<h3 class="sect2">Loading Column Objects with a Derived Subtype<a id="sthref992"></a></h3>
<p><a href="#i1008205">Example 11-4</a> shows a case in which a nonfinal base object type has been extended to create a new derived subtype. Although the column object in the table definition is declared to be of the base object type, SQL*Loader allows any subtype to be loaded into the column object, provided that the subtype is derived from the base object type.</p>
<div id="SUTIL3361" class="example">
<p class="titleinexample"><a id="i1008205"></a>Example 11-4 Loading Column Objects with a Subtype</p>
<p class="synopsis">Object Type Definitions</p>
<pre dir="ltr">
CREATE TYPE person_type AS OBJECT
  (name     VARCHAR(30),
   ssn      NUMBER(9)) not final;

CREATE TYPE employee_type UNDER person_type
  (empid    NUMBER(5));

CREATE TABLE personnel
  (deptno   NUMBER(3),
   deptname VARCHAR(30),
   person   person_type);
</pre>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
INTO TABLE personnel
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (deptno        INTEGER EXTERNAL(3),
    deptname      CHAR,
<span class="bold">1</span>   person        COLUMN OBJECT TREAT AS employee_type
      (name       CHAR,
       ssn        INTEGER EXTERNAL(9),
<span class="bold">2</span>      empid      INTEGER EXTERNAL(5)))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
101,Mathematics,Johny Q.,301189453,10249,
237,Physics,"Albert Einstein",128606590,10030,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3362"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The <code dir="ltr">TREAT</code> <code dir="ltr">AS</code> clause indicates that SQL*Loader should treat the column object <code dir="ltr">person</code> as if it were declared to be of the derived type <code dir="ltr">employee_type</code>, instead of its actual declared type, <code dir="ltr">person_type</code>.</p>
</li>
<li>
<p>The <code dir="ltr">empid</code> attribute is allowed here because it is an attribute of the <code dir="ltr">employee_type</code>. If the <code dir="ltr">TREAT</code> <code dir="ltr">AS</code> clause had not been specified, then this attribute would have resulted in an error, because it is not an attribute of the column's declared type.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1006576"></a>
<div id="SUTIL1252" class="sect2">
<h3 class="sect2">Specifying <a id="sthref993"></a>Null Values for <a id="sthref994"></a>Objects</h3>
<p>Specifying null values for <a id="sthref995"></a>nonscalar <a id="sthref996"></a>datatypes is somewhat more complex than for scalar datatypes. An object can have a subset of its attributes be null, it can have all of its attributes be null (an attributively null object), or it can be null itself (an atomically null object).</p>
<div id="SUTIL1253" class="sect3"><a id="sthref997"></a>
<h4 class="sect3">Specifying <a id="sthref998"></a>Attribute <a id="sthref999"></a>Nulls</h4>
<p>In fields corresponding to column objects, you can use the <code dir="ltr">NULLIF</code> clause to specify the field conditions under which a particular attribute should be initialized to <code dir="ltr">NULL</code>. <a href="#i1006590">Example 11-5</a> demonstrates this.</p>
<div id="SUTIL3363" class="example">
<p class="titleinexample"><a id="i1006590"></a>Example 11-5 Specifying Attribute Nulls Using the NULLIF Clause</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments
  (dept_no      POSITION(01:03)    CHAR,
  dept_name     POSITION(05:15)    CHAR NULLIF dept_name=BLANKS,
  dept_mgr      COLUMN OBJECT
<span class="bold">1</span>    ( name     POSITION(17:33)    CHAR NULLIF dept_mgr.name=BLANKS,
<span class="bold">1</span>    age        POSITION(35:37)    INTEGER EXTERNAL NULLIF dept_mgr.age=BLANKS,
<span class="bold">1</span>    emp_id     POSITION(40:46)    INTEGER EXTERNAL NULLIF dept_mgr.empid=BLANKS))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
<span class="bold">2</span>  101             Johny Quest            1024
   237   Physics   Albert Einstein   65   0000
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3364"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The <code dir="ltr">NULLIF</code> clause corresponding to each attribute states the condition under which the attribute value should be <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>The age attribute of the <code dir="ltr">dept_mgr</code> value is null. The <code dir="ltr">dept_name</code> value is also null.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="SUTIL1254" class="sect3"><a id="sthref1000"></a>
<h4 class="sect3">Specifying <a id="sthref1001"></a>Atomic <a id="sthref1002"></a>Nulls</h4>
<p>To specify in the control file the condition under which a particular object should take a null value (atomic null), you must follow that object's name with a <code dir="ltr">NULLIF</code> clause based on a logical combination of any of the mapped fields (for example, in <a href="#i1006590">Example 11-5</a>, the named mapped fields would be <code dir="ltr">dept_no</code>, <code dir="ltr">dept_name</code>, <code dir="ltr">name</code>, <code dir="ltr">age</code>, <code dir="ltr">emp_id</code>, but <code dir="ltr">dept_mgr</code> would not be a named mapped field because it does not correspond (is not mapped) to any field in the data file).</p>
<p>Although the preceding is workable, it is not ideal when the condition under which an object should take the value of null is <span class="italic">independent of any of the mapped fields.</span> In such situations, you can use filler fields.</p>
<p>You can map a filler field to the field in the data file (indicating if a particular object is atomically null or not) and use the filler field in the field condition of the <code dir="ltr">NULLIF</code> clause of the particular object. This is shown in <a href="#i1006626">Example 11-6</a>.</p>
<div id="SUTIL3365" class="example">
<p class="titleinexample"><a id="i1006626"></a>Example 11-6 Loading Data Using Filler Fields</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments_v2
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (dept_no         CHAR(5),
   dept_name        CHAR(30),
<span class="bold">1</span>  is_null          FILLER CHAR,
<span class="bold">2</span>  dept_mgr         COLUMN OBJECT NULLIF is_null=BLANKS
      (name         CHAR(30) NULLIF dept_mgr.name=BLANKS, 
      age           INTEGER EXTERNAL(3) NULLIF dept_mgr.age=BLANKS,
      emp_id        INTEGER EXTERNAL(7) 
                    NULLIF dept_mgr.emp_id=BLANKS,
      em_contact    COLUMN OBJECT NULLIF is_null2=BLANKS
         (name      CHAR(30) 
                    NULLIF dept_mgr.em_contact.name=BLANKS, 
         phone_num  CHAR(20) 
                    NULLIF dept_mgr.em_contact.phone_num=BLANKS)),
<span class="bold">1</span>  is_null2         FILLER CHAR)       
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
101,Mathematics,n,Johny Q.,,1024,"Barbie",608-251-0010,,
237,Physics,,"Albert Einstein",65,0000,,650-654-3210,n,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3366"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The filler field (data file mapped; no corresponding column) is of type <code dir="ltr">CHAR</code> (because it is a delimited field, the <code dir="ltr">CHAR</code> defaults to <code dir="ltr">CHAR(255)</code>). Note that the <code dir="ltr">NULLIF</code> clause is not applicable to the filler field itself.</p>
</li>
<li>
<p>Gets the value of null (atomic null) if the <code dir="ltr">is_null</code> field is blank.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_field_list.htm#i1006668">"Specifying Filler Fields"</a></div>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1009457"></a>
<div id="SUTIL1255" class="sect2">
<h3 class="sect2">Loading Column Objects with User-Defined Constructors<a id="sthref1003"></a><a id="sthref1004"></a></h3>
<p>The Oracle database automatically supplies a default constructor for every object type. This constructor requires that all attributes of the type be specified as arguments in a call to the constructor. When a new instance of the object is created, its attributes take on the corresponding values in the argument list. This constructor is known as the attribute-value constructor<a id="sthref1005"></a><a id="sthref1006"></a><a id="sthref1007"></a>. SQL*Loader uses the attribute-value constructor by default when loading column objects.</p>
<p>It is possible to override the attribute-value constructor by creating one or more user-defined<a id="sthref1008"></a><a id="sthref1009"></a><a id="sthref1010"></a><a id="sthref1011"></a> constructors. When you create a user-defined constructor, you must supply a type body that performs the user-defined logic whenever a new instance of the object is created. A user-defined constructor may have the same argument list as the attribute-value constructor but differ in the logic that its type body implements.</p>
<p>When the argument list of a user-defined constructor function matches the argument list of the attribute-value constructor, there is a difference in behavior between conventional and direct path SQL*Loader. Conventional path mode results in a call to the user-defined constructor. Direct path mode results in a call to the attribute-value constructor. <a href="#i1009648">Example 11-7</a> illustrates this difference.</p>
<div id="SUTIL3367" class="example">
<p class="titleinexample"><a id="i1009648"></a>Example 11-7 Loading a Column Object with Constructors That Match</p>
<p class="synopsis">Object Type Definitions</p>
<pre dir="ltr">
CREATE TYPE person_type AS OBJECT
     (name     VARCHAR(30),
      ssn      NUMBER(9)) not final;

   CREATE TYPE employee_type UNDER person_type
     (empid    NUMBER(5),
   -- User-defined constructor that looks like an attribute-value constructor
      CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER, empid NUMBER)
        RETURN SELF AS RESULT);

   CREATE TYPE BODY employee_type AS
     CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER, empid NUMBER)
      RETURN SELF AS RESULT AS
   --User-defined constructor makes sure that the name attribute is uppercase.
      BEGIN
        SELF.name  := UPPER(name);
        SELF.ssn   := ssn;
        SELF.empid := empid;
        RETURN;
      END;

   CREATE TABLE personnel
     (deptno   NUMBER(3),
      deptname VARCHAR(30),
      employee employee_type);
</pre>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
   INFILE *
   REPLACE
   INTO TABLE personnel
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      (deptno        INTEGER EXTERNAL(3),
       deptname      CHAR,
       employee      COLUMN OBJECT
         (name       CHAR,
          ssn        INTEGER EXTERNAL(9),
          empid      INTEGER EXTERNAL(5)))

   BEGINDATA
<span class="bold">1</span>  101,Mathematics,Johny Q.,301189453,10249,
   237,Physics,"Albert Einstein",128606590,10030,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3368"></a>Notes</p>
<ol>
<li>
<p>When this control file is run in conventional path mode, the name fields, <code dir="ltr">Johny</code> <code dir="ltr">Q.</code> and <code dir="ltr">Albert</code> <code dir="ltr">Einstein</code>, are both loaded in uppercase. This is because the user-defined constructor is called in this mode. In contrast, when this control file is run in direct path mode, the name fields are loaded exactly as they appear in the input data. This is because the attribute-value constructor is called in this mode.</p>
</li>
</ol>
<p>It is possible to create a user-defined constructor whose argument list does not match that of the attribute-value constructor. In this case, both conventional and direct path modes will result in a call to the attribute-value constructor. Consider the definitions in <a href="#i1009642">Example 11-8</a>.</p>
<div id="SUTIL3369" class="example">
<p class="titleinexample"><a id="i1009642"></a>Example 11-8 Loading a Column Object with Constructors That Do Not Match</p>
<p class="synopsis">Object Type Definitions</p>
<pre dir="ltr">
CREATE SEQUENCE employee_ids
    START     WITH  1000
    INCREMENT BY    1;

   CREATE TYPE person_type AS OBJECT
     (name     VARCHAR(30),
      ssn      NUMBER(9)) not final;

   CREATE TYPE employee_type UNDER person_type
     (empid    NUMBER(5),
   -- User-defined constructor that does not look like an attribute-value 
   -- constructor
      CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER)
        RETURN SELF AS RESULT);

   CREATE TYPE BODY employee_type AS
     CONSTRUCTOR FUNCTION
        employee_type (name VARCHAR2, ssn NUMBER)
      RETURN SELF AS RESULT AS
   -- This user-defined constructor makes sure that the name attribute is in
   -- lowercase and assigns the employee identifier based on a sequence.
        nextid     NUMBER;
        stmt       VARCHAR2(64);
      BEGIN

        stmt := 'SELECT employee_ids.nextval FROM DUAL';
        EXECUTE IMMEDIATE stmt INTO nextid;

        SELF.name  := LOWER(name);
        SELF.ssn   := ssn;
        SELF.empid := nextid; 
        RETURN;
      END;

   CREATE TABLE personnel
     (deptno   NUMBER(3),
      deptname VARCHAR(30),
      employee employee_type);
</pre>
<p>If the control file described in <a href="#i1009648">Example 11-7</a> is used with these definitions, then the name fields are loaded exactly as they appear in the input data (that is, in mixed case). This is because the attribute-value constructor is called in both conventional and direct path modes.</p>
<p>It is still possible to load this table using conventional path mode by explicitly making reference to the user-defined constructor in a SQL expression. <a href="#i1009753">Example 11-9</a> shows how this can be done.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3370" class="example">
<p class="titleinexample"><a id="i1009753"></a>Example 11-9 Using SQL to Load Column Objects When Constructors Do Not Match</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
   INFILE *
   REPLACE
   INTO TABLE personnel
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      (deptno        INTEGER EXTERNAL(3),
       deptname      CHAR,
       name          BOUNDFILLER CHAR,
       ssn           BOUNDFILLER INTEGER EXTERNAL(9),
<span class="bold">1</span>      employee      EXPRESSION "employee_type(:NAME, :SSN)")

   BEGINDATA
<span class="bold">1</span>  101,Mathematics,Johny Q.,301189453,
   237,Physics,"Albert Einstein",128606590,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3371"></a>Notes</p>
<ol>
<li>
<p>The employee column object is now loaded using a SQL expression. This expression invokes the user-defined constructor with the correct number of arguments. The name fields, <code dir="ltr">Johny</code> <code dir="ltr">Q.</code> and <code dir="ltr">Albert</code> <code dir="ltr">Einstein</code>, will both be loaded in lowercase. In addition, the employee identifiers for each row's employee column object will have taken their values from the <code dir="ltr">employee_ids</code> sequence.</p>
</li>
</ol>
<p>If the control file in <a href="#i1009753">Example 11-9</a> is used in direct path mode, then the following error is reported:</p>
<pre dir="ltr">
SQL*Loader-951: Error calling once/load initialization
ORA-26052: Unsupported type 121 for SQL expression on column EMPLOYEE.
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1009398"></a>
<div id="SUTIL1256" class="sect1">
<h2 class="sect1">Loading <a id="sthref1012"></a>Object <a id="sthref1013"></a>Tables<a id="sthref1014"></a><a id="sthref1015"></a><a id="sthref1016"></a></h2>
<p>The control file syntax required to load an object table is nearly identical to that used to load a typical relational table. <a href="#i1006678">Example 11-10</a> demonstrates loading an object table with <a id="sthref1017"></a>primary-key-based object identifiers<a id="sthref1018"></a> (OIDs).</p>
<div id="SUTIL3372" class="example">
<p class="titleinexample"><a id="i1006678"></a>Example 11-10 Loading an Object Table with Primary Key OIDs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
DISCARDFILE 'sample.dsc'
BADFILE 'sample.bad'
REPLACE
INTO TABLE employees 
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (name    CHAR(30)                NULLIF name=BLANKS,
   age      INTEGER EXTERNAL(3)     NULLIF age=BLANKS,
   emp_id   INTEGER EXTERNAL(5))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Johny Quest, 18, 007,
Speed Racer, 16, 000,
</pre>
<p>By looking only at the preceding control file you might not be able to determine if the table being loaded was an object table with system-generated OIDs, an object table with primary-key-based OIDs, or a relational table.</p>
<p>You may want to load data that already contains system-generated OIDs and to specify that instead of generating new OIDs, the existing OIDs in the data file should be used. To do this, you would follow the <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clause with the <code dir="ltr">OID</code> clause:</p>
<pre dir="ltr">
OID (<span class="italic">fieldname</span>)
</pre>
<p>In this clause, <code dir="ltr"><span class="codeinlineitalic">fieldname</span></code> is the name of one of the fields (typically a filler field) from the field specification list that is mapped to a data field that contains the system-generated OIDs. SQL*Loader assumes that the OIDs provided are in the correct format and that they preserve OID global uniqueness. Therefore, to ensure uniqueness, you should use the Oracle OID generator to generate the OIDs to be loaded.</p>
<p>The <code dir="ltr">OID</code> clause can only be used for system-generated OIDs, not primary-key-based OIDs.</p>
<p><a href="#i1006710">Example 11-11</a> demonstrates loading system-generated OIDs with the row objects.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3373" class="example">
<p class="titleinexample"><a id="i1006710"></a>Example 11-11 Loading OIDs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
   LOAD DATA
   INFILE 'sample.dat'
   INTO TABLE employees_v2 
<span class="bold">1</span>  OID (s_oid)
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
      (name    CHAR(30)                NULLIF name=BLANKS,
      age      INTEGER EXTERNAL(3)    NULLIF age=BLANKS,
      emp_id   INTEGER EXTERNAL(5),
<span class="bold">2</span>     s_oid    FILLER CHAR(32))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
<span class="bold">3</span>  Johny Quest, 18, 007, 21E978406D3E41FCE03400400B403BC3,
   Speed Racer, 16, 000, 21E978406D4441FCE03400400B403BC3,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3374"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The <code dir="ltr">OID</code> clause specifies that the <code dir="ltr">s_oid</code> loader field contains the OID. The parentheses are required.</p>
</li>
<li>
<p>If <code dir="ltr">s_oid</code> does not contain a valid hexadecimal number, then the particular record is rejected.</p>
</li>
<li>
<p>The OID in the data file is a character string and is interpreted as a 32-digit hexadecimal number. The 32-digit hexadecimal number is later converted into a 16-byte <code dir="ltr">RAW</code> and stored in the object table.</p>
</li>
</ol>
<a id="i1008768"></a>
<div id="SUTIL1257" class="sect2">
<h3 class="sect2">Loading Object Tables with a Subtype<a id="sthref1019"></a><a id="sthref1020"></a></h3>
<p>If an object table's row object is based on a nonfinal type, then SQL*Loader allows for any derived subtype to be loaded into the object table. As previously mentioned, the syntax required to load an object table with a derived subtype is almost identical to that used for a typical relational table. However, in this case, the actual subtype to be used must be named, so that SQL*Loader can determine if it is a valid subtype for the object table. This concept is illustrated in <a href="#i1010122">Example 11-12</a>.</p>
<div id="SUTIL3375" class="example">
<p class="titleinexample"><a id="i1010122"></a>Example 11-12 Loading an Object Table with a Subtype</p>
<p class="synopsis">Object Type Definitions</p>
<pre dir="ltr">
CREATE TYPE employees_type AS OBJECT
  (name     VARCHAR2(30),
   age      NUMBER(3),
   emp_id   NUMBER(5)) not final;

CREATE TYPE hourly_emps_type UNDER employees_type
  (hours    NUMBER(3));

CREATE TABLE employees_v3 of employees_type;
</pre>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
   LOAD DATA

   INFILE 'sample.dat'
   INTO TABLE employees_v3
<span class="bold">1</span>  TREAT AS hourly_emps_type
   FIELDS TERMINATED BY ','
     (name     CHAR(30),
      age      INTEGER EXTERNAL(3),
      emp_id   INTEGER EXTERNAL(5),
<span class="bold">2</span>     hours    INTEGER EXTERNAL(2))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
   Johny Quest, 18, 007, 32,
   Speed Racer, 16, 000, 20,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3376"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The <code dir="ltr">TREAT</code> <code dir="ltr">AS</code> clause indicates that SQL*Loader should treat the object table as if it were declared to be of type <code dir="ltr">hourly_emps_type</code>, instead of its actual declared type, <code dir="ltr">employee_type</code>.</p>
</li>
<li>
<p>The <code dir="ltr">hours</code> attribute is allowed here because it is an attribute of the <code dir="ltr">hourly_emps_type</code>. If the <code dir="ltr">TREAT</code> <code dir="ltr">AS</code> clause had not been specified, then this attribute would have resulted in an error, because it is not an attribute of the object table's declared type.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010641"></a>
<div id="SUTIL1258" class="sect1">
<h2 class="sect1">Loading <a id="sthref1021"></a>REF Column<a id="sthref1022"></a><a id="sthref1023"></a>s</h2>
<p>SQL*Loader can load system-generated OID <code dir="ltr">REF</code> <a id="sthref1024"></a>columns, primary-key-based <code dir="ltr">REF</code> columns, and unscoped <code dir="ltr">REF</code> columns that allow primary keys. For each of these, the way in which table names are specified is important, as described in the following section.</p>
<div id="SUTIL1259" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref1025"></a>
<h3 class="sect2">Specifying Table Names in a REF Clause</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
The information in this section applies only to environments in which the release of both SQL*Loader and Oracle Database are 11<span class="italic">g</span> release 1 (11.1) or later. It does not apply to environments in which either SQL*Loader, Oracle Database, or both are at an earlier release.</div>
<p>In the SQL*Loader control file, the description of the field corresponding to a <code dir="ltr">REF</code> column consists of the column name followed by a REF clause. The REF clause takes as arguments the table name and any attributes applicable to the type of <code dir="ltr">REF</code> column being loaded. The table names can either be specified dynamically (using filler fields) or as constants. The table name can also be specified with or without the schema name.</p>
<p>Whether the table name specified in the REF clause is specified as a constant or by using a filler field, it is interpreted as case-sensitive. This could result in the following situations:</p>
<ul>
<li>
<p>If user <code dir="ltr">SCOTT</code> creates a table named <code dir="ltr">table2</code> in lowercase without quotation marks around the table name, then it can be used in a REF clause in any of the following ways:</p>
<ul>
<li>
<p><code dir="ltr">REF(constant 'TABLE2', ...)</code></p>
</li>
<li>
<p><code dir="ltr">REF(constant '"TABLE2"', ...)</code></p>
</li>
<li>
<p><code dir="ltr">REF(constant 'SCOTT.TABLE2', ...)</code></p>
</li>
</ul>
</li>
<li>
<p>If user <code dir="ltr">SCOTT</code> creates a table named <code dir="ltr">"Table2"</code> using quotation marks around a mixed-case name, then it can be used in a REF clause in any of the following ways:</p>
<ul>
<li>
<p><code dir="ltr">REF(constant 'Table2', ...)</code></p>
</li>
<li>
<p><code dir="ltr">REF(constant '"Table2"', ...)</code></p>
</li>
<li>
<p><code dir="ltr">REF(constant 'SCOTT.Table2', ...)</code></p>
</li>
</ul>
</li>
</ul>
<p>In both of those situations, if <code dir="ltr">constant</code> is replaced with a filler field, then the same values as shown in the examples will also work if they are placed in the data section.</p>
</div>
<!-- class="sect2" -->
<a id="CEGIGEFC"></a>
<div id="SUTIL1260" class="sect2">
<h3 class="sect2"><a id="sthref1026"></a>System-Generated OID REF Columns<a id="sthref1027"></a></h3>
<p>SQL*Loader assumes, when loading system-generated <code dir="ltr">REF</code> columns, that the actual OIDs from which the <code dir="ltr">REF</code> columns are to be constructed are in the data file with the rest of the data. The description of the field corresponding to a <code dir="ltr">REF</code> column consists of the column name followed by the <code dir="ltr">REF</code> clause.</p>
<p>The <code dir="ltr">REF</code> clause takes as arguments the table name and an OID. Note that the arguments can be specified either as constants or dynamically (using filler fields). See <a href="app_ldr_syntax.htm#BABJAGGH">"ref_spec"</a> for the appropriate syntax. <a href="#i1006751">Example 11-13</a> demonstrates loading system-generated OID <code dir="ltr">REF</code> columns.</p>
<div id="SUTIL3377" class="example">
<p class="titleinexample"><a id="i1006751"></a>Example 11-13 Loading System-Generated REF Columns</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments_alt_v2
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
  (dept_no      CHAR(5),
   dept_name    CHAR(30),
<span class="bold">1</span> dept_mgr     REF(t_name, s_oid),
   s_oid        FILLER CHAR(32),
   t_name       FILLER CHAR(30))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
22345, QuestWorld, 21E978406D3E41FCE03400400B403BC3, EMPLOYEES_V2,
23423, Geography, 21E978406D4441FCE03400400B403BC3, EMPLOYEES_V2,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3378"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>If the specified table does not exist, then the record is rejected. The <code dir="ltr">dept_mgr</code> field itself does not map to any field in the data file.</p>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1010305"></a>
<div id="SUTIL1261" class="sect2">
<h3 class="sect2"><a id="sthref1028"></a>Primary Key <a id="sthref1029"></a>REF Columns</h3>
<p>To load a <a id="sthref1030"></a>primary key <code dir="ltr">REF</code> column, the SQL*Loader control-file field description must provide the column name followed by a <code dir="ltr">REF</code> clause. The <code dir="ltr">REF</code> clause takes for arguments a comma-delimited list of field names and constant values. The first argument is the table name, followed by arguments that specify the primary key OID on which the <code dir="ltr">REF</code> column to be loaded is based. See <a href="app_ldr_syntax.htm#BABJAGGH">"ref_spec"</a> for the appropriate syntax.</p>
<p>SQL*Loader assumes that the ordering of the arguments matches the relative ordering of the columns making up the primary key OID in the referenced table. <a href="#i1006786">Example 11-14</a> demonstrates loading primary key <code dir="ltr">REF</code> columns.</p>
<div id="SUTIL3379" class="example">
<p class="titleinexample"><a id="i1006786"></a>Example 11-14 Loading Primary Key REF Columns</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE 'sample.dat'
INTO TABLE departments_alt
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
 (dept_no       CHAR(5),
 dept_name      CHAR(30),
 dept_mgr       REF(CONSTANT 'EMPLOYEES', emp_id),
 emp_id         FILLER CHAR(32))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
22345, QuestWorld, 007,
23423, Geography, 000,
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="SUTIL1262" class="sect2"><a id="sthref1031"></a>
<h3 class="sect2">Unscoped REF Columns That Allow Primary Keys</h3>
<p>An unscoped <code dir="ltr">REF</code> column that allows primary keys can reference both system-generated and primary key <code dir="ltr">REF</code>s. The syntax for loading into such a <code dir="ltr">REF</code> column is the same as if you were loading into a system-generated OID <code dir="ltr">REF</code> column or into a primary-key-based <code dir="ltr">REF</code> column. See <a href="#i1006751">Example 11-13, "Loading System-Generated REF Columns"</a> and <a href="#i1006786">Example 11-14, "Loading Primary Key REF Columns"</a>.</p>
<p>The following restrictions apply when loading into an unscoped <code dir="ltr">REF</code> column that allows primary keys:</p>
<ul>
<li>
<p>Only one type of <code dir="ltr">REF</code> can be referenced by this column during a single-table load, either system-generated or primary key, but not both. If you try to reference both types, then the data row will be rejected with an error message indicating that the referenced table name is invalid.</p>
</li>
<li>
<p>If you are loading unscoped primary key <code dir="ltr">REF</code>s to this column, then only one object table can be referenced during a single-table load. That is, to load unscoped primary key <code dir="ltr">REF</code>s, some pointing to object table X and some pointing to object table Y, you would have to do one of the following:</p>
<ul>
<li>
<p>Perform two single-table loads.</p>
</li>
<li>
<p>Perform a single load using multiple <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> clauses for which the <code dir="ltr">WHEN</code> clause keys off some aspect of the data, such as the object table name for the unscoped primary key <code dir="ltr">REF</code>. For example:</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'data.dat' 

INTO TABLE orders_apk 
APPEND 
when CUST_TBL = "CUSTOMERS_PK" 
fields terminated by "," 
( 
  order_no   position(1)  char, 
  cust_tbl FILLER     char, 
  cust_no  FILLER     char, 
  cust   REF (cust_tbl, cust_no) NULLIF order_no='0' 
) 

INTO TABLE orders_apk 
APPEND 
when CUST_TBL = "CUSTOMERS_PK2" 
fields terminated by "," 
( 
  order_no  position(1)  char, 
  cust_tbl FILLER     char, 
  cust_no  FILLER     char, 
  cust   REF (cust_tbl, cust_no) NULLIF order_no='0' 
) 
</pre></li>
</ul>
<p>If you do not use either of these methods, then the data row will be rejected with an error message indicating that the referenced table name is invalid.</p>
</li>
<li>
<p>Unscoped primary key <code dir="ltr">REF</code>s in collections are not supported by SQL*Loader.</p>
</li>
<li>
<p>If you are loading system-generated <code dir="ltr">REF</code>s into this <code dir="ltr">REF</code> column, then any limitations described in <a href="#CEGIGEFC">"System-Generated OID REF Columns"</a> also apply here.</p>
</li>
<li>
<p>If you are loading primary key <code dir="ltr">REF</code>s into this <code dir="ltr">REF</code> column, then any limitations described in <a href="#i1010305">"Primary Key REF Columns"</a> also apply here.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
For an unscoped <code dir="ltr">REF</code> column that allows primary keys, SQL*Loader takes the first valid object table parsed (either from the <code dir="ltr">REF</code> directive or from the data rows) and uses that object table's OID type to determine the <code dir="ltr">REF</code> type that can be referenced in that single-table load.</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006803"></a>
<div id="SUTIL1263" class="sect1">
<h2 class="sect1">Loading <a id="sthref1032"></a><a id="sthref1033"></a>LOBs<a id="sthref1034"></a></h2>
<p>A LOB is a <span class="italic">large object type.</span> SQL*Loader supports the following types of LOBs:</p>
<ul>
<li>
<p><code dir="ltr">BLOB</code>: an internal LOB containing unstructured binary data<a id="sthref1035"></a><a id="sthref1036"></a></p>
</li>
<li>
<p><code dir="ltr">CLOB</code>: an internal LOB containing character data<a id="sthref1037"></a><a id="sthref1038"></a></p>
</li>
<li>
<p><code dir="ltr">NCLOB</code>: an internal LOB containing characters from a national character set<a id="sthref1039"></a><a id="sthref1040"></a></p>
</li>
<li>
<p><code dir="ltr">BFILE</code>: a <code dir="ltr">BLOB</code> stored outside of the database tablespaces in a server-side operating system file<a id="sthref1041"></a><a id="sthref1042"></a></p>
</li>
</ul>
<p>LOBs can be column datatypes, and except for <code dir="ltr">NCLOB</code>, they can be an object's attribute datatypes. LOBs can have actual values, they can be null, or they can be empty. SQL*Loader creates an empty LOB when there is a 0-length field to store in the LOB. (Note that this is different than other datatypes where SQL*Loader sets the column to NULL for any 0-length string.) This means that <span class="italic">the only way to load NULL values into a LOB column is to use the NULLIF clause.</span></p>
<p><code dir="ltr">XML</code> columns are columns declared to be of type <code dir="ltr">SYS</code>.<code dir="ltr">XMLTYPE</code>. SQL*Loader treats <code dir="ltr">XML</code> columns<a id="sthref1043"></a> as if they were <code dir="ltr">CLOB</code>s. All of the methods described in the following sections for loading LOB data from the primary data file or from LOBFILEs are applicable to loading <code dir="ltr">XML</code> columns.<a id="sthref1044"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot specify a SQL string for LOB fields. This is true even if you specify <code dir="ltr">LOBFILE_spec</code>.</div>
<p>Because LOBs can be quite large, SQL*Loader can load LOB data from either a primary data file (in line with the rest of the data) or from <a id="sthref1045"></a>LOBFILEs, as described in the following sections:</p>
<ul>
<li>
<p><a href="#i1008564">Loading LOB Data from a Primary Data File</a></p>
</li>
<li>
<p><a href="#i1006993">Loading LOB Data from LOBFILEs</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF50994" href="../../server.112/e41084/sql_elements001.htm#SQLRF50994"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about large object (LOB) data types</div>
<a id="i1008564"></a>
<div id="SUTIL1264" class="sect2">
<h3 class="sect2"><a id="sthref1046"></a>Loading LOB Data from a Primary Data File</h3>
<p>To load internal LOBs (<code dir="ltr">BLOB</code>s, <code dir="ltr">CLOB</code>s, and <code dir="ltr">NCLOB</code>s) or <code dir="ltr">XML</code> columns from a primary data file, you can use the following standard SQL*Loader formats:</p>
<ul>
<li>
<p>Predetermined size fields</p>
</li>
<li>
<p>Delimited fields</p>
</li>
<li>
<p>Length-value pair fields</p>
</li>
</ul>
<p>Each of these formats is described in the following sections.</p>
<div id="SUTIL1265" class="sect3"><a id="sthref1047"></a>
<h4 class="sect3"><a id="sthref1048"></a>LOB Data in Predetermined Size Fields</h4>
<p>This is a very fast and conceptually simple format in which to load LOBs, as shown in <a href="#i1006838">Example 11-15</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the LOBs you are loading may not be of equal size, you can use whitespace to pad the LOB data to make the LOBs all of equal length within a particular data field.</div>
<p>To load LOBs using this format, you should use either <code dir="ltr">CHAR</code> or <code dir="ltr">RAW</code> as the loading datatype.</p>
<div id="SUTIL3380" class="example">
<p class="titleinexample"><a id="i1006838"></a>Example 11-15 Loading LOB Data in Predetermined Size Fields</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'sample.dat' "fix 501"
INTO TABLE person_table
   (name       POSITION(01:21)       CHAR,
<span class="bold">1</span>  "RESUME"    POSITION(23:500)      CHAR   DEFAULTIF "RESUME"=BLANKS)
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Julia Nayer      Julia Nayer
             500 Example Parkway
             jnayer@us.example.com ...
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3381"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>Because the <code dir="ltr">DEFAULTIF</code> clause is used, if the data field containing the resume is empty, then the result is an empty LOB rather than a null LOB. However, if a <code dir="ltr">NULLIF</code> clause had been used instead of <code dir="ltr">DEFAULTIF</code>, then the empty data field would be null.</p>
<p>You can use SQL*Loader datatypes other than <code dir="ltr">CHAR</code> to load LOBs. For example, when loading <code dir="ltr">BLOB</code>s, you would probably want to use the <code dir="ltr">RAW</code> datatype.</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="SUTIL1266" class="sect3"><a id="sthref1049"></a>
<h4 class="sect3"><a id="sthref1050"></a>LOB Data in Delimited Fields</h4>
<p>This format handles LOBs of different sizes within the same column (data file field) without a problem. However, this added flexibility can affect performance because SQL*Loader must scan through the data, looking for the delimiter string.</p>
<p>As with single-character delimiters, when you specify string delimiters, you should consider the character set of the data file. When the character set of the data file is different than that of the control file, you can specify the delimiters in hexadecimal notation (that is, <code dir="ltr"><span class="codeinlineitalic">X'hexadecimal</span></code> <code dir="ltr"><span class="codeinlineitalic">string</span></code><code dir="ltr">'</code>). If the delimiters are specified in hexadecimal notation, then the specification must consist of characters that are valid in the character set of the input data file. In contrast, if hexadecimal notation is not used, then the delimiter specification is considered to be in the client's (that is, the control file's) character set. In this case, the delimiter is converted into the data file's character set before SQL*Loader searches for the delimiter in the data file.</p>
<p>Note the following:</p>
<ul>
<li>
<p>Stutter syntax is supported with string delimiters (that is, the closing enclosure delimiter can be stuttered).</p>
</li>
<li>
<p>Leading whitespaces in the initial multicharacter enclosure delimiter are not allowed.</p>
</li>
<li>
<p>If a field is terminated by <code dir="ltr">WHITESPACE</code>, then the leading whitespaces are trimmed.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
SQL*Loader defaults to 255 bytes when moving <code dir="ltr">CLOB</code> data, but a value of up to 2 gigabytes can be specified. For a delimited field, if a length is specified, then that length is used as a maximum. If no maximum is specified, then it defaults to 255 bytes. For a <code dir="ltr">CHAR</code> field that is delimited and is also greater than 255 bytes, you must specify a maximum length. See <a href="ldr_field_list.htm#i1015797">"CHAR"</a> for more information about the <code dir="ltr">CHAR</code> datatype.</div>
</li>
</ul>
<p><a href="#i1006874">Example 11-16</a> shows an example of loading LOB data in delimited fields.</p>
<div id="SUTIL3382" class="example">
<p class="titleinexample"><a id="i1006874"></a>Example 11-16 Loading LOB Data in Delimited Fields</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'sample.dat' "str '|'"
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name        CHAR(25),
<span class="bold">1</span>  "RESUME"     CHAR(507) ENCLOSED BY '&lt;startlob&gt;' AND '&lt;endlob&gt;')
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Julia Nayer,&lt;startlob&gt;        Julia Nayer
                          500 Example Parkway
                          jnayer@us.example.com ...   &lt;endlob&gt;
<span class="bold">2</span>  |Bruce Ernst, .......
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3383"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p><code dir="ltr">&lt;startlob&gt;</code> and <code dir="ltr">&lt;endlob&gt;</code> are the enclosure strings. With the default byte-length semantics, the maximum length for a LOB that can be read using <code dir="ltr">CHAR(507)</code> is 507 bytes. If character-length semantics were used, then the maximum would be 507 characters. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
</li>
<li>
<p>If the record separator <code dir="ltr">'|'</code> had been placed right after <code dir="ltr">&lt;endlob&gt;</code> and followed with the newline character, then the newline would have been interpreted as part of the next record. An alternative would be to make the newline part of the record separator (for example, <code dir="ltr">'|\n'</code> or, in hexadecimal notation, <code dir="ltr">X'7C0A'</code>).</p>
</li>
</ol>
</div>
<!-- class="sect3" -->
<div id="SUTIL1267" class="sect3"><a id="sthref1051"></a>
<h4 class="sect3"><a id="sthref1052"></a>LOB Data in Length-Value Pair Fields</h4>
<p>You can use <code dir="ltr">VARCHAR</code>, <code dir="ltr">VARCHARC</code>, or <code dir="ltr">VARRAW</code> datatypes to load LOB data organized in length-value pair fields. This method of loading provides better performance than using delimited fields, but can reduce flexibility (for example, you must know the LOB length for each LOB before loading). <a href="#i1006907">Example 11-17</a> demonstrates loading LOB data in length-value pair fields.</p>
<div id="SUTIL3384" class="example">
<p class="titleinexample"><a id="i1006907"></a>Example 11-17 Loading LOB Data in Length-Value Pair Fields</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
  LOAD DATA 
<span class="bold">1</span> INFILE 'sample.dat' "str '&lt;endrec&gt;\n'"
  INTO TABLE person_table
  FIELDS TERMINATED BY ','
     (name       CHAR(25),
<span class="bold">2</span>    "RESUME"    VARCHARC(3,500))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
  Julia Nayer,479                Julia Nayer
                             500 Example Parkway
                             jnayer@us.example.com
                                    ... &lt;endrec&gt;
<span class="bold">3</span>    Bruce Ernst,000&lt;endrec&gt;
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3385"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>If the backslash escape character is not supported, then the string used as a record separator in the example could be expressed in hexadecimal notation.</p>
</li>
<li>
<p><code dir="ltr">"RESUME"</code> is a field that corresponds to a <code dir="ltr">CLOB</code> column. In the control file, it is a <code dir="ltr">VARCHARC</code>, whose length field is 3 bytes long and whose maximum size is 500 bytes (with byte-length semantics). If character-length semantics were used, then the length would be 3 characters and the maximum size would be 500 characters. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
</li>
<li>
<p>The length subfield of the <code dir="ltr">VARCHARC</code> is 0 (the value subfield is empty). Consequently, the LOB instance is initialized to empty.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006993"></a>
<div id="SUTIL1268" class="sect2">
<h3 class="sect2">Loading LOB Data from <a id="sthref1053"></a>LOBFILEs</h3>
<p>LOB data can be lengthy enough so that it makes sense to load it from a LOBFILE instead of from a primary data file. In LOBFILEs, LOB data instances are still considered to be in fields (predetermined size, delimited, length-value), but these fields are not organized into records (the concept of a record does not exist within LOBFILEs). Therefore, the processing overhead of dealing with records is avoided. This type of organization of data is ideal for LOB loading.</p>
<p>There is no requirement that a LOB from a LOBFILE fit in memory. SQL*Loader reads LOBFILEs in 64 KB chunks.</p>
<p>In LOBFILEs the data can be in any of the following types of fields:</p>
<ul>
<li>
<p>A single LOB field into which the entire contents of a file can be read</p>
</li>
<li>
<p>Predetermined size fields (fixed-length fields)</p>
</li>
<li>
<p>Delimited fields (that is, <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> or <code dir="ltr">ENCLOSED</code> <code dir="ltr">BY</code>)</p>
<p>The clause <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code> is not applicable to fields read from a LOBFILE.</p>
</li>
<li>
<p>Length-value pair fields (variable-length fields)</p>
<p>To load data from this type of field, use the <code dir="ltr">VARRAW</code>, <code dir="ltr">VARCHAR</code>, or <code dir="ltr">VARCHARC</code> SQL*Loader datatypes.</p>
</li>
</ul>
<p>See <a href="#i1007627">"Examples of Loading LOB Data from LOBFILEs"</a> for examples of using each of these field types. All of the previously mentioned field types can be used to load <code dir="ltr">XML</code> columns.</p>
<p>See <a href="app_ldr_syntax.htm#BABEHEID">"lobfile_spec"</a> for LOBFILE syntax.</p>
<div id="SUTIL1269" class="sect3"><a id="sthref1054"></a>
<h4 class="sect3">Dynamic Versus Static LOBFILE Specifications</h4>
<p>You can specify LOBFILEs either statically (the name of the file is specified in the control file) or dynamically (a <code dir="ltr">FILLER</code> field is used as the source of the file name). In either case, if the LOBFILE is <span class="italic">not</span> terminated by EOF, then when the end of the LOBFILE is reached, the file is closed and further attempts to read data from that file produce results equivalent to reading data from an empty field.</p>
<p>However, if you have a LOBFILE that <span class="italic">is</span> terminated by EOF, then the entire file is always returned on each attempt to read data from that file.</p>
<p>You should not specify the same LOBFILE as the source of two different fields. If you do, then the two fields typically read the data independently.</p>
</div>
<!-- class="sect3" -->
<a id="i1007627"></a>
<div id="SUTIL1270" class="sect3">
<h4 class="sect3">Examples of Loading LOB Data from LOBFILEs</h4>
<p>This section contains examples of loading data from different types of fields in LOBFILEs.</p>
<div id="SUTIL1271" class="sect4"><a id="sthref1055"></a>
<h5 class="sect4">One LOB per File</h5>
<p>In <a href="#CEGHBDGD">Example 11-18</a>, each LOBFILE is the source of a single LOB. To load LOB data that is organized in this way, the column or field name is followed by the LOBFILE datatype specifications.</p>
<div id="SUTIL3386" class="example">
<p class="titleinexample"><a id="CEGHBDGD"></a>Example 11-18 Loading LOB DATA with One LOB per LOBFILE</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'sample.dat'
   INTO TABLE person_table
   FIELDS TERMINATED BY ','
   (name      CHAR(20),
<span class="bold">1</span>  ext_fname    FILLER CHAR(40),
<span class="bold">2</span>  "RESUME"     LOBFILE(ext_fname) TERMINATED BY EOF)
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Johny Quest,jqresume.txt,
Speed Racer,'/private/sracer/srresume.txt',
</pre>
<p class="synopsis">Secondary Data File (jqresume.txt)</p>
<pre dir="ltr">
             Johny Quest
         500 Oracle Parkway
            ...
</pre>
<p class="synopsis">Secondary Data File (srresume.txt)</p>
<pre dir="ltr">
         Speed Racer
     400 Oracle Parkway
        ...
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3387"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The filler field is mapped to the 40-byte data field, which is read using the SQL*Loader <code dir="ltr">CHAR</code> datatype. This assumes the use of default byte-length semantics. If character-length semantics were used, then the field would be mapped to a 40-character data field.</p>
</li>
<li>
<p>SQL*Loader gets the LOBFILE name from the <code dir="ltr">ext_fname</code> filler field. It then loads the data from the LOBFILE (using the <code dir="ltr">CHAR</code> datatype) from the first byte to the EOF character. If no existing LOBFILE is specified, then the <code dir="ltr">"RESUME"</code> field is initialized to empty.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<div id="SUTIL1272" class="sect4"><a id="sthref1056"></a>
<h5 class="sect4"><a id="sthref1057"></a>Predetermined Size LOBs</h5>
<p>In <a href="#i1007065">Example 11-19</a>, you specify the size of the LOBs to be loaded into a particular column in the control file. During the load, SQL*Loader assumes that any LOB data loaded into that particular column is of the specified size. The predetermined size of the fields allows the data-parser to perform optimally. However, it is often difficult to guarantee that all LOBs are the same size.</p>
<div id="SUTIL3388" class="example">
<p class="titleinexample"><a id="i1007065"></a>Example 11-19 Loading LOB Data Using Predetermined Size LOBs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'sample.dat'
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name     CHAR(20),
<span class="bold">1</span>  "RESUME"    LOBFILE(CONSTANT '/usr/private/jquest/jqresume.txt')
               CHAR(2000))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Johny Quest,
Speed Racer,
</pre>
<p class="synopsis">Secondary Data File (jqresume.txt)</p>
<pre dir="ltr">
             Johny Quest
         500 Oracle Parkway
            ...
             Speed Racer
         400 Oracle Parkway
            ...
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3389"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>This entry specifies that SQL*Loader load 2000 bytes of data from the <code dir="ltr">jqresume.txt</code> LOBFILE, using the <code dir="ltr">CHAR</code> datatype, starting with the byte following the byte loaded last during the current loading session. This assumes the use of the default byte-length semantics. If character-length semantics were used, then SQL*Loader would load 2000 characters of data, starting from the first character after the last-loaded character. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<div id="SUTIL1273" class="sect4"><a id="sthref1058"></a>
<h5 class="sect4"><a id="sthref1059"></a>Delimited LOBs</h5>
<p>In <a href="#i1007097">Example 11-20</a>, the LOB data instances in the LOBFILE are delimited. In this format, loading different size LOBs into the same column is not a problem. However, this added flexibility can affect performance, because SQL*Loader must scan through the data, looking for the delimiter string.</p>
<div id="SUTIL3390" class="example">
<p class="titleinexample"><a id="i1007097"></a>Example 11-20 Loading LOB Data Using Delimited LOBs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'sample.dat'
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name     CHAR(20),
<span class="bold">1</span>  "RESUME"    LOBFILE( CONSTANT 'jqresume') CHAR(2000) 
               TERMINATED BY "&lt;endlob&gt;\n")
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Johny Quest,
Speed Racer,
</pre>
<p class="synopsis">Secondary Data File (jqresume.txt)</p>
<pre dir="ltr">
             Johny Quest
         500 Oracle Parkway
            ... &lt;endlob&gt;
             Speed Racer
         400 Oracle Parkway
            ... &lt;endlob&gt;
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3391"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>Because a maximum length of 2000 is specified for <code dir="ltr">CHAR</code>, SQL*Loader knows what to expect as the maximum length of the field, which can result in memory usage optimization. <span class="italic">If you choose to specify a maximum length, then you should be sure not to underestimate its value.</span> The <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> clause specifies the string that terminates the LOBs. Alternatively, you could use the <code dir="ltr">ENCLOSED</code> <code dir="ltr">BY</code> clause. The <code dir="ltr">ENCLOSED</code> <code dir="ltr">BY</code> clause allows a bit more flexibility as to the relative positioning of the LOBs in the LOBFILE (the LOBs in the LOBFILE need not be sequential).</p>
</li>
</ol>
</div>
<!-- class="sect4" -->
<div id="SUTIL1274" class="sect4"><a id="sthref1060"></a>
<h5 class="sect4"><a id="sthref1061"></a>Length-Value Pair Specified LOBs</h5>
<p>In <a href="#i1007136">Example 11-21</a> each LOB in the LOBFILE is preceded by its length. You could use <code dir="ltr">VARCHAR</code>, <code dir="ltr">VARCHARC</code>, or <code dir="ltr">VARRAW</code> datatypes to load LOB data organized in this way.</p>
<p>This method of loading can provide better performance over delimited LOBs, but at the expense of some flexibility (for example, you must know the LOB length for each LOB before loading).</p>
<div id="SUTIL3392" class="example">
<p class="titleinexample"><a id="i1007136"></a>Example 11-21 Loading LOB Data Using Length-Value Pair Specified LOBs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA 
INFILE 'sample.dat'
INTO TABLE person_table
FIELDS TERMINATED BY ','
   (name          CHAR(20),
<span class="bold">1</span>  "RESUME"       LOBFILE(CONSTANT 'jqresume') VARCHARC(4,2000))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
Johny Quest,
Speed Racer,
</pre>
<p class="synopsis">Secondary Data File (jqresume.txt)</p>
<pre dir="ltr">
<span class="bold">2</span>      0501Johny Quest
       500 Oracle Parkway
          ... 
<span class="bold">3</span>      0000   
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3393"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The entry <code dir="ltr">VARCHARC(4,2000)</code> tells SQL*Loader that the LOBs in the LOBFILE are in length-value pair format and that the first 4 bytes should be interpreted as the length. The value of <code dir="ltr">2000</code> tells SQL*Loader that the maximum size of the field is 2000 bytes. This assumes the use of the default byte-length semantics. If character-length semantics were used, then the first 4 characters would be interpreted as the length in characters. The maximum size of the field would be 2000 characters. See <a href="ldr_control_file.htm#i1008619">"Character-Length Semantics"</a>.</p>
</li>
<li>
<p>The entry <code dir="ltr">0501</code> preceding <code dir="ltr">Johny</code> <code dir="ltr">Quest</code> tells SQL*Loader that the LOB consists of the next 501 characters.</p>
</li>
<li>
<p>This entry specifies an empty (not null) LOB.</p>
</li>
</ol>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="SUTIL1275" class="sect3"><a id="sthref1062"></a>
<h4 class="sect3">Considerations When Loading LOBs from LOBFILEs</h4>
<p>Keep in mind the following when you load data using LOBFILEs:</p>
<ul>
<li>
<p>Only LOBs and <code dir="ltr">XML</code> columns can be loaded from LOBFILEs.</p>
</li>
<li>
<p>The failure to load a particular LOB does not result in the rejection of the record containing that LOB. Instead, you will have a record that contains an empty LOB. In the case of an <code dir="ltr">XML</code> column, a null value will be inserted if there is a failure loading the LOB.</p>
</li>
<li>
<p>It is not necessary to specify the maximum length of a field corresponding to a LOB column. If a maximum length <span class="italic">is</span> specified, then SQL*Loader uses it as a hint to optimize memory usage. Therefore, it is important that the maximum length specification does not understate the true maximum length.</p>
</li>
<li>
<p>You cannot supply a position specification (<code dir="ltr">pos_spec</code>) when loading data from a LOBFILE.</p>
</li>
<li>
<p><code dir="ltr">NULLIF</code> or <code dir="ltr">DEFAULTIF</code> field conditions cannot be based on fields read from LOBFILEs.</p>
</li>
<li>
<p>If a nonexistent LOBFILE is specified as a data source for a particular field, then that field is initialized to empty. If the concept of empty does not apply to the particular field type, then the field is initialized to null.</p>
</li>
<li>
<p>Table-level delimiters are not inherited by fields that are read from a LOBFILE.</p>
</li>
<li>
<p>When loading an <code dir="ltr">XML</code> column or referencing a LOB column in a SQL expression in conventional path mode, SQL*Loader must process the LOB data as a temporary LOB. To ensure the best load performance possible in these cases, refer to the guidelines concerning temporary LOB performance in <a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010766"></a>
<div id="SUTIL1276" class="sect1">
<h2 class="sect1">Loading BFILE Columns</h2>
<p>The <code dir="ltr"><a id="sthref1063"></a>BFILE</code> datatype stores unstructured binary data in operating system files outside the database. A <code dir="ltr">BFILE</code> column or attribute stores a file locator that points to the external file containing the data. The file to be loaded as a <code dir="ltr">BFILE</code> does not have to exist at the time of loading; it can be created later. SQL*Loader assumes that the necessary directory objects have already been created (a logical alias name for a physical directory on the server's file system). For more information, see the <a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a>.</p>
<p>A control file field corresponding to a <code dir="ltr">BFILE</code> column consists of a column name followed by the <code dir="ltr">BFILE</code> clause. The <code dir="ltr">BFILE</code> clause takes as arguments a directory object (the server_directory alias) name followed by a <code dir="ltr">BFILE</code> name. Both arguments can be provided as string constants, or they can be dynamically loaded through some other field. See the <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
<p>In the next two examples of loading <code dir="ltr">BFILE</code>s, <a href="#i1010717">Example 11-22</a> has only the file name specified dynamically, while <a href="#i1010734">Example 11-23</a> demonstrates specifying both the <code dir="ltr">BFILE</code> and the directory object dynamically.</p>
<div id="SUTIL3394" class="example">
<p class="titleinexample"><a id="i1010717"></a>Example 11-22 Loading Data Using BFILEs: Only File Name Specified Dynamically</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE sample.dat
INTO TABLE planets
FIELDS TERMINATED BY ','
   (pl_id    CHAR(3), 
   pl_name   CHAR(20),
   fname     FILLER CHAR(30),
<span class="bold">1</span>  pl_pict   BFILE(CONSTANT "scott_dir1", fname))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
1,Mercury,mercury.jpeg,
2,Venus,venus.jpeg,
3,Earth,earth.jpeg,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3395"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The directory name is in quotation marks; therefore, the string is used as is and is not capitalized.</p>
</li>
</ol>
<div id="SUTIL3396" class="example">
<p class="titleinexample"><a id="i1010734"></a>Example 11-23 Loading Data Using BFILEs: File Name and Directory Specified Dynamically</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
LOAD DATA
INFILE sample.dat
INTO TABLE planets
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (pl_id    NUMBER(4), 
   pl_name   CHAR(20), 
   fname     FILLER CHAR(30),
<span class="bold">1</span>  dname     FILLER CHAR(20),
   pl_pict   BFILE(dname, fname) )
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
1, Mercury, mercury.jpeg, scott_dir1,
2, Venus, venus.jpeg, scott_dir1,
3, Earth, earth.jpeg, scott_dir2,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3397"></a><span class="bold">Notes</span></p>
<a id="i1010752"></a>
<ol>
<li>
<p><code dir="ltr">dname</code> is mapped to the data file field containing the directory name corresponding to the file being loaded.</p>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1007180"></a>
<div id="SUTIL1277" class="sect1">
<h2 class="sect1">Loading Collections (Nested Tables and VARRAYs)</h2>
<p><a id="i1007183"></a>Like LOBs, collections<a id="sthref1064"></a><a id="sthref1065"></a> can be loaded either from a primary data file (data inline) or from secondary data files (data out of line). See <a href="#i1007276">"Secondary Data Files (SDFs)"</a> for details about SDFs.</p>
<p>When you load collection data, a mechanism must exist by which SQL*Loader can tell when the data belonging to a particular collection instance has ended. You can achieve this in two ways:</p>
<ul>
<li>
<p>To specify the number of rows or elements that are to be loaded into each nested table or <code dir="ltr">VARRAY</code> instance, use the DDL <code dir="ltr">COUNT</code> function. The value specified for <code dir="ltr">COUNT</code> must either be a number or a character string containing a number, and it must be previously described in the control file before the <code dir="ltr">COUNT</code> clause itself. This positional dependency is specific to the <code dir="ltr">COUNT</code> clause. <code dir="ltr">COUNT(0)</code> or <code dir="ltr">COUNT(cnt_field)</code>, where <code dir="ltr">cnt_field</code> is 0 for the current row, results in a empty collection (not null), unless overridden by a <code dir="ltr">NULLIF</code> clause. See <a href="app_ldr_syntax.htm#BABIHJAH">"count_spec"</a>.</p>
<p>If the <code dir="ltr">COUNT</code> clause specifies a field in a control file and if that field is set to null for the current row, then the collection that uses that count will be set to empty for the current row as well.</p>
</li>
<li>
<p>Use the <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> and <code dir="ltr">ENCLOSED</code> <code dir="ltr">BY</code> clauses to specify a unique collection delimiter. This method cannot be used if an <code dir="ltr">SDF</code> clause is used.</p>
</li>
</ul>
<p>In the control file, collections are described similarly to column objects. See <a href="#i1006457">"Loading Column Objects"</a>. There are some differences:</p>
<ul>
<li>
<p>Collection descriptions employ the two mechanisms discussed in the preceding list.</p>
</li>
<li>
<p>Collection descriptions can include a secondary data file (SDF) specification.</p>
</li>
<li>
<p>A <code dir="ltr">NULLIF</code> or <code dir="ltr">DEFAULTIF</code> clause cannot refer to a field in an SDF unless the clause is on a field in the same SDF.</p>
</li>
<li>
<p>Clauses that take field names as arguments cannot use a field name that is in a collection unless the DDL specification is for a field in the same collection.</p>
</li>
<li>
<p>The field list must contain only one nonfiller field and any number of filler fields. If the <code dir="ltr">VARRAY</code> is a <code dir="ltr">VARRAY</code> of column objects, then the attributes of each column object will be in a nested field list.</p>
</li>
</ul>
<div id="SUTIL1278" class="sect2"><a id="sthref1066"></a>
<h3 class="sect2">Restrictions in Nested Tables and VARRAYs</h3>
<p>The following restrictions exist for nested tables and <code dir="ltr">VARRAY</code>s:</p>
<ul>
<li>
<p>A <code dir="ltr">field_list</code> cannot contain a <code dir="ltr">collection_fld_spec</code>.</p>
</li>
<li>
<p>A <code dir="ltr">col_obj_spec</code> nested within a <code dir="ltr">VARRAY</code> cannot contain a <code dir="ltr">collection_fld_spec</code>.</p>
</li>
<li>
<p>The <code dir="ltr">column_name</code> specified as part of the <code dir="ltr">field_list</code> must be the same as the <code dir="ltr">column_name</code> preceding the <code dir="ltr">VARRAY</code> parameter.</p>
</li>
</ul>
<p>Also, be aware that if you are loading into a table containing nested tables, then SQL*Loader will not automatically split the load into multiple loads and generate a set ID.</p>
<p><a href="#i1007222">Example 11-24</a> demonstrates loading a <code dir="ltr">VARRAY</code> and a nested table.</p>
<div id="SUTIL3398" class="example">
<p class="titleinexample"><a id="i1007222"></a>Example 11-24 Loading a VARRAY and a Nested Table</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
   LOAD DATA
   INFILE 'sample.dat' "str '\n' "
   INTO TABLE dept
   REPLACE
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   (
     dept_no       CHAR(3),
     dname         CHAR(25) NULLIF dname=BLANKS,
<span class="bold">1</span>    emps          VARRAY TERMINATED BY ':'
     (
       emps        COLUMN OBJECT
       (
         name      CHAR(30),
         age       INTEGER EXTERNAL(3),
<span class="bold">2</span>        emp_id    CHAR(7) NULLIF emps.emps.emp_id=BLANKS
     )
   ),
<span class="bold">3</span>   proj_cnt      FILLER CHAR(3),
<span class="bold">4</span>   projects      NESTED TABLE SDF (CONSTANT "pr.txt" "fix 57") COUNT (proj_cnt)
  (
    projects    COLUMN OBJECT
    (
      project_id        POSITION (1:5) INTEGER EXTERNAL(5),
      project_name      POSITION (7:30) CHAR 
                        NULLIF projects.projects.project_name = BLANKS
    )
  )
)
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
 101,MATH,"Napier",28,2828,"Euclid", 123,9999:0
 210,"Topological Transforms",:2
</pre>
<p class="synopsis">Secondary Data File (SDF) (pr.txt)</p>
<pre dir="ltr">
21034 Topological Transforms
77777 Impossible Proof
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3399"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p>The <code dir="ltr">TERMINATED</code> <code dir="ltr">BY</code> clause specifies the <code dir="ltr">VARRAY</code> instance terminator (note that no <code dir="ltr">COUNT</code> clause is used).</p>
</li>
<li>
<p>Full name field references (using dot notation) resolve the field name conflict created by the presence of this filler field.</p>
</li>
<li>
<p><code dir="ltr">proj_cnt</code> is a filler field used as an argument to the <code dir="ltr">COUNT</code> clause.</p>
</li>
<li>
<p>This entry specifies the following:</p>
<ul>
<li>
<p>An SDF called <code dir="ltr">pr</code>.<code dir="ltr">txt</code> as the source of data. It also specifies a fixed-record format within the SDF.</p>
</li>
<li>
<p>If <code dir="ltr">COUNT</code> is 0, then the collection is initialized to empty. Another way to initialize a collection to empty is to use a <code dir="ltr">DEFAULTIF</code> clause. The main field name corresponding to the nested table field description is the same as the field name of its nested nonfiller-field, specifically, the name of the column object field description.</p>
</li>
</ul>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1007276"></a>
<div id="SUTIL1279" class="sect2">
<h3 class="sect2">Secondary Data Files (SDFs)</h3>
<p>Secondary data files (SDFs) are similar in concept to primary data files. Like primary data files, SDFs<a id="sthref1067"></a> are a collection of records, and each record is made up of fields. The SDFs are specified on a per control-file-field basis. They are useful when you load large nested tables and <code dir="ltr">VARRAY</code>s.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Only a <code dir="ltr">collection_fld_spec</code> can name an SDF as its data source.</div>
<p>SDFs are specified using the <code dir="ltr">SDF</code> parameter. The <code dir="ltr">SDF</code> parameter can be followed by either the file specification string, or a <code dir="ltr">FILLER</code> field that is mapped to a data field containing one or more file specification strings.</p>
<p>As for a primary data file, the following can be specified for each SDF:</p>
<ul>
<li>
<p>The record format (fixed, stream, or variable). Also, if stream record format is used, then you can specify the record separator.</p>
</li>
<li>
<p>The record size.</p>
</li>
<li>
<p>The character set for an SDF can be specified using the <code dir="ltr">CHARACTERSET</code> clause (see <a href="ldr_control_file.htm#i1005287">"Handling Different Character Encoding Schemes"</a>).</p>
</li>
<li>
<p>A default delimiter (using the delimiter specification) for the fields that inherit a particular SDF specification (all member fields or attributes of the collection that contain the SDF specification, with exception of the fields containing their own LOBFILE specification).</p>
</li>
</ul>
<p>Also note the following regarding SDFs:</p>
<ul>
<li>
<p>If a nonexistent SDF is specified as a data source for a particular field, then that field is initialized to empty. If the concept of empty does not apply to the particular field type, then the field is initialized to null.</p>
</li>
<li>
<p>Table-level delimiters are not inherited by fields that are read from an SDF.</p>
</li>
<li>
<p>To load SDFs larger than 64 KB, you must use the <code dir="ltr">READSIZE</code> parameter to specify a larger physical record size. You can specify the <code dir="ltr">READSIZE</code> parameter either from the command line or as part of an <code dir="ltr">OPTIONS</code> clause.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="ldr_params.htm#i1004852">"READSIZE (read buffer size)"</a></p>
</li>
<li>
<p><a href="ldr_control_file.htm#i1004788">"OPTIONS Clause"</a></p>
</li>
<li>
<p><a href="app_ldr_syntax.htm#BABHGFGG">"sdf_spec"</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007661"></a>
<div id="SUTIL1280" class="sect1">
<h2 class="sect1">Dynamic Versus Static SDF Specifications</h2>
<p>You can specify SDFs either statically (you specify the actual name of the file) or dynamically (you use a <code dir="ltr">FILLER</code> field as the source of the file name). In either case, when the EOF of an SDF is reached, the file is closed and further attempts at reading data from that particular file produce results equivalent to reading data from an empty field.</p>
<p>In a dynamic secondary file specification, this behavior is slightly different. Whenever the specification changes to reference a new file, the old file is closed, and the data is read from the beginning of the newly referenced file.</p>
<p>The dynamic switching of the data source files has a resetting effect. For example, when SQL*Loader switches from the current file to a previously opened file, the previously opened file is reopened, and the data is read from the beginning of the file.</p>
<p>You should not specify the same SDF as the source of two different fields. If you do, then the two fields will typically read the data independently.</p>
</div>
<!-- class="sect1" -->
<a id="i1007322"></a>
<div id="SUTIL1281" class="sect1">
<h2 class="sect1">Loading a Parent Table Separately from Its Child Table</h2>
<p><a id="i1007325"></a>When you load a table that contains a nested table column, it may be possible to load the parent table separately from the child table. You can load the parent and child tables independently if the SIDs (system-generated or user-defined) are already known at the time of the load (that is, the SIDs are in the data file with the data).</p>
<p><a href="#i1008679">Example 11-25</a> illustrates how to load a parent table with user-provided SIDs.</p>
<div id="SUTIL3400" class="example">
<p class="titleinexample"><a id="i1008679"></a>Example 11-25 Loading a Parent Table with User-Provided SIDs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
   LOAD DATA
   INFILE 'sample.dat' "str '|\n' "
   INTO TABLE dept
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   TRAILING NULLCOLS
   ( dept_no   CHAR(3),
   dname       CHAR(20) NULLIF dname=BLANKS ,
   mysid       FILLER CHAR(32),
<span class="bold">1</span>  projects    SID(mysid))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
101,Math,21E978407D4441FCE03400400B403BC3,|
210,"Topology",21E978408D4441FCE03400400B403BC3,|
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3401"></a><span class="bold">Notes</span></p>
<ol>
<li>
<p><code dir="ltr">mysid</code> is a filler field that is mapped to a data file field containing the actual set IDs and is supplied as an argument to the <code dir="ltr">SID</code> clause.</p>
</li>
</ol>
<p><a href="#i1008683">Example 11-26</a> illustrates how to load a child table (the nested table storage table) with user-provided SIDs.</p>
<div id="SUTIL3402" class="example">
<p class="titleinexample"><a id="i1008683"></a>Example 11-26 Loading a Child Table with User-Provided SIDs</p>
<p class="synopsis">Control File Contents</p>
<pre dir="ltr">
   LOAD DATA
   INFILE 'sample.dat'
   INTO TABLE dept
   FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
   TRAILING NULLCOLS
<span class="bold">1</span>  SID(sidsrc)
   (project_id     INTEGER EXTERNAL(5),
   project_name   CHAR(20) NULLIF project_name=BLANKS,
   sidsrc FILLER  CHAR(32))
</pre>
<p class="synopsis">Data File (sample.dat)</p>
<pre dir="ltr">
21034, "Topological Transforms", 21E978407D4441FCE03400400B403BC3,
77777, "Impossible Proof", 21E978408D4441FCE03400400B403BC3,
</pre></div>
<!-- class="example" -->
<p class="subhead2"><a id="SUTIL3403"></a>Notes</p>
<ol>
<li>
<p>The table-level <code dir="ltr">SID</code> clause tells SQL*Loader that it is loading the storage table for nested tables. <code dir="ltr">sidsrc</code> is the filler field name that is the source of the real set IDs.</p>
</li>
</ol>
<div id="SUTIL1282" class="sect2"><a id="sthref1068"></a>
<h3 class="sect2">Memory Issues When Loading VARRAY Columns</h3>
<p>The following list describes some issues<a id="sthref1069"></a> to keep in mind when you load <code dir="ltr">VARRAY</code> columns:</p>
<ul>
<li>
<p><code dir="ltr">VARRAY</code>s are created in the client's memory before they are loaded into the database. Each element of a <code dir="ltr">VARRAY</code> requires 4 bytes of client memory before it can be loaded into the database. Therefore, when you load a <code dir="ltr">VARRAY</code> with a thousand elements, you will require at least 4000 bytes of client memory for each <code dir="ltr">VARRAY</code> instance before you can load the <code dir="ltr">VARRAY</code>s into the database. In many cases, SQL*Loader requires two to three times that amount of memory to successfully construct and load a <code dir="ltr">VARRAY</code>.</p>
</li>
<li>
<p>The <code dir="ltr">BINDSIZE</code> parameter specifies the amount of memory allocated by SQL*Loader for loading records. Given the value specified for <code dir="ltr">BINDSIZE</code>, SQL*Loader takes into consideration the size of each field being loaded, and determines the number of rows it can load in one transaction. The larger the number of rows, the fewer transactions, resulting in better performance. But if the amount of memory on your system is limited, then at the expense of performance, you can specify a lower value for <code dir="ltr">ROWS</code> than SQL*Loader calculated.</p>
</li>
<li>
<p>Loading very large <code dir="ltr">VARRAY</code>s or a large number of smaller <code dir="ltr">VARRAY</code>s could cause you to run out of memory during the load. If this happens, then specify a smaller value for <code dir="ltr">BINDSIZE</code> or <code dir="ltr">ROWS</code> and retry the load.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1387">
<tr>
<td class="cellalignment1396">
<table class="cellalignment1392">
<tr>
<td class="cellalignment1391"><a href="ldr_field_list.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1391"><a href="ldr_modes.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1398">
<table class="cellalignment1390">
<tr>
<td class="cellalignment1391"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1391"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1391"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1391"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1391"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1391"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
