<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Conventional and Direct Path Loads</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093" />
<meta name="dcterms.created" content="2018-03-26T15:55:3Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Utilities" />
<meta name="dcterms.identifier" content="E22490-08" />
<meta name="dcterms.isVersionOf" content="SUTIL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="ldr_loading.htm" title="Previous" type="text/html" />
<link rel="Next" href="part_et.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e22490.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">21/36</span> <!-- End Header -->
<div id="SUTIL009" class="chapter"><a id="g1023818"></a> <a id="i1011553"></a>
<h1 class="chapter"><span class="secnum">12</span> Conventional and Direct Path Loads</h1>
<p>This chapter describes SQL*Loader's conventional and direct path load methods. The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1007501">Data Loading Methods</a></p>
</li>
<li>
<p><a href="#i1011474">Conventional Path Load</a></p>
</li>
<li>
<p><a href="#i1008815">Direct Path Load</a></p>
</li>
<li>
<p><a href="#i1007669">Using Direct Path Load</a></p>
</li>
<li>
<p><a href="#i1007896">Optimizing Performance of Direct Path Loads</a></p>
</li>
<li>
<p><a href="#i1008033">Optimizing Direct Path Loads on Multiple-CPU Systems</a></p>
</li>
<li>
<p><a href="#i1008055">Avoiding Index Maintenance</a></p>
</li>
<li>
<p><a href="#i1008078">Direct Loads, Integrity Constraints, and Triggers</a></p>
</li>
<li>
<p><a href="#i1008225">Parallel Data Loading Models</a></p>
</li>
<li>
<p><a href="#i1008335">General Performance Improvement Hints</a></p>
</li>
</ul>
<p>For an example of using the direct path load method, see case study 6, Loading Data Using the Direct Path Load Method. The other cases use the conventional path load method. (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
<a id="i1007501"></a>
<div id="SUTIL1283" class="sect1">
<h2 class="sect1">Data Loading Methods<a id="sthref1070"></a></h2>
<p>SQL*Loader provides two methods for loading data:</p>
<ul>
<li>
<p><a href="#i1011474">Conventional Path Load</a></p>
</li>
<li>
<p><a href="#i1008815">Direct Path Load</a></p>
</li>
</ul>
<p>A conventional path load executes SQL <code dir="ltr">INSERT</code> statements to populate tables in an Oracle database. A direct path load eliminates much of the Oracle database overhead by formatting Oracle data blocks and writing the data blocks directly to the database files. A direct load does not compete with other users for database resources, so it can usually load data at near disk speed. Considerations inherent to direct path loads, such as restrictions, security, and backup implications, are discussed in this chapter.</p>
<p>The tables to be loaded must already exist in the database. SQL*Loader never creates tables. It loads existing tables that either already contain data or are empty.<a id="sthref1071"></a></p>
<p><a id="sthref1072"></a>The following privileges are required for a load:<a id="sthref1073"></a></p>
<ul>
<li>
<p>You must have <code dir="ltr">INSERT</code> privileges on the table to be loaded.</p>
</li>
<li>
<p>You must have <code dir="ltr">DELETE</code> privileges on the table to be loaded, when using the <code dir="ltr">REPLACE</code> or <code dir="ltr">TRUNCATE</code> option to empty old data from the table before loading the new data in its place.</p>
</li>
</ul>
<p><a href="#i1011196">Figure 12-1</a> shows how conventional and direct path loads perform database writes.</p>
<div id="SUTIL3404" class="figure">
<p class="titleinfigure"><a id="i1011196"></a>Figure 12-1 Database Writes on SQL*Loader Direct Path and Conventional Path</p>
<img width="438" height="582" src="img/sut81018.gif" alt="Description of Figure 12-1 follows" /><br />
<a id="sthref1074" href="img_text/sut81018.htm">Description of ''Figure 12-1 Database Writes on SQL*Loader Direct Path and Conventional Path''</a><br />
<br /></div>
<!-- class="figure" -->
<div id="SUTIL1284" class="sect2"><a id="sthref1075"></a>
<h3 class="sect2">Loading ROWID Columns<a id="sthref1076"></a></h3>
<p>In both conventional path and direct path, you can specify a text value for a <code dir="ltr">ROWID</code> column. (This is the same text you get when you perform a <code dir="ltr">SELECT</code> <code dir="ltr">ROWID</code> <code dir="ltr">FROM</code> <code dir="ltr">table_name</code> operation.) The character string interpretation of the <code dir="ltr">ROWID</code> is converted into the <code dir="ltr">ROWID</code> type for a column in a table.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1011474"></a>
<div id="SUTIL1285" class="sect1">
<h2 class="sect1">Conventional Path Load</h2>
<p>Conventional path load (the default) uses the SQL <code dir="ltr">INSERT</code> statement and a bind array buffer to load data into database tables. This method is used by all Oracle tools and applications.<span class="bold"><a id="sthref1077"></a><a id="sthref1078"></a></span></p>
<p>When SQL*Loader performs a conventional path load, it competes equally with all other processes for buffer resources. This can slow the load significantly. Extra overhead is added as SQL statements are generated, passed to Oracle, and executed.</p>
<p>The Oracle database looks for partially filled blocks and attempts to fill them on each insert. Although appropriate during normal use, this can slow bulk loads dramatically.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_control_file.htm#i1011891">"Discontinued Conventional Path Loads"</a></div>
<a id="i1010476"></a>
<div id="SUTIL1286" class="sect2">
<h3 class="sect2">Conventional Path Load of a Single Partition</h3>
<p>By definition, a conventional path load uses SQL <code dir="ltr">INSERT</code> statements. During a conventional path load of a single partition, SQL*Loader uses the partition-extended syntax of the <code dir="ltr">INSERT</code> statement, which has the following form:</p>
<pre dir="ltr">
INSERT INTO TABLE T PARTITION (P) VALUES ... 
</pre>
<pre dir="ltr">
</pre>
<p>The SQL layer of the Oracle kernel determines if the row being inserted maps to the specified partition. If the row does not map to the partition, then the row is rejected, and the SQL*Loader log file records an appropriate error message.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1287" class="sect2"><a id="sthref1079"></a>
<h3 class="sect2">When to Use a Conventional Path Load</h3>
<p>If load speed is most important to you, then you should use direct path load because it is faster than conventional path load. However, certain restrictions on direct path loads may require you to use a conventional path load. You should use a conventional path load in the following situations:<a id="sthref1080"></a></p>
<ul>
<li>
<p>When accessing an indexed table concurrently with the load, or when applying inserts or updates to a nonindexed table concurrently with the load</p>
<p>To use a direct path load (except for parallel loads), SQL*Loader must have exclusive write access to the table and exclusive read/write access to any indexes.</p>
</li>
<li>
<p>When loading data into a clustered table</p>
<p>A direct path load does not support loading of clustered tables.</p>
</li>
<li>
<p>When loading a relatively small number of rows into a large indexed table</p>
<p>During a direct path load, the existing index is copied when it is merged with the new index keys. If the existing index is very large and the number of new keys is very small, then the index copy time can offset the time saved by a direct path load.</p>
</li>
<li>
<p>When loading a relatively small number of rows into a large table with referential and column-check integrity constraints</p>
<p>Because these constraints cannot be applied to rows loaded on the direct path, they are disabled for the duration of the load. Then they are applied to the whole table when the load completes. The costs could outweigh the savings for a very large table and a small number of new rows.</p>
</li>
<li>
<p>When loading records and you want to ensure that a record is rejected under any of the following circumstances:</p>
<ul>
<li>
<p>If the record, upon insertion, causes an Oracle error</p>
</li>
<li>
<p>If the record is formatted incorrectly, so that SQL*Loader cannot find field boundaries</p>
</li>
<li>
<p>If the record violates a constraint or tries to make a unique index non-unique</p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008815"></a>
<div id="SUTIL1288" class="sect1">
<h2 class="sect1">Direct Path Load</h2>
<p>Instead of filling a bind array buffer and passing it to the Oracle database with a SQL <code dir="ltr">INSERT</code> statement, a direct path load uses the direct path API to pass the data to be loaded to the load engine in the server. The load engine builds a column array structure from the data passed to it.</p>
<p>The direct path load engine uses the column array structure to format Oracle data blocks and build index keys. The newly formatted database blocks are written directly to the database (multiple blocks per I/O request using asynchronous writes if the host platform supports asynchronous I/O).</p>
<p>Internally, multiple buffers are used for the formatted blocks. While one buffer is being filled, one or more buffers are being written if asynchronous I/O is available on the host platform. Overlapping computation with I/O increases load performance.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_control_file.htm#i1011892">"Discontinued Direct Path Loads"</a></div>
<div id="SUTIL1289" class="sect2"><a id="sthref1081"></a>
<h3 class="sect2">Data Conversion During Direct Path Loads</h3>
<p>During a direct path<a id="sthref1082"></a> load, data conversion<a id="sthref1083"></a><a id="sthref1084"></a> occurs on the client side rather than on the server side. This means that NLS parameters in the initialization parameter file (server-side language handle) will not be used. To override this behavior, you can specify a format mask in the SQL*Loader control file that is equivalent to the setting of the NLS parameter in the initialization parameter file, or set the appropriate environment variable. For example, to specify a date format for a field, you can either set the date format in the SQL*Loader control file as shown in <a href="#i1011154">Example 12-1</a> or set an <code dir="ltr">NLS_DATE_FORMAT</code> environment variable as shown in <a href="#i1011158">Example 12-2</a>.</p>
<div id="SUTIL3405" class="example">
<p class="titleinexample"><a id="i1011154"></a>Example 12-1 Setting the Date Format in the SQL*Loader Control File</p>
<pre dir="ltr">
LOAD DATA
INFILE 'data.dat'
INSERT INTO TABLE emp
FIELDS TERMINATED BY "|"
(
EMPNO NUMBER(4) NOT NULL,
ENAME CHAR(10),
JOB CHAR(9),
MGR NUMBER(4),
HIREDATE DATE 'YYYYMMDD',
SAL NUMBER(7,2),
COMM NUMBER(7,2),
DEPTNO NUMBER(2)
)
</pre></div>
<!-- class="example" -->
<div id="SUTIL3406" class="example">
<p class="titleinexample"><a id="i1011158"></a>Example 12-2 Setting an NLS_DATE_FORMAT Environment Variable</p>
<p>On UNIX Bourne or Korn shell:</p>
<pre dir="ltr">
% NLS_DATE_FORMAT='YYYYMMDD'
% export NLS_DATE_FORMAT
</pre>
<p>On UNIX csh:</p>
<pre dir="ltr">
%setenv NLS_DATE_FORMAT='YYYYMMDD'
</pre></div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<div id="SUTIL1290" class="sect2"><a id="sthref1085"></a>
<h3 class="sect2">Direct Path Load of a Partitioned or Subpartitioned Table</h3>
<p>When loading a <a id="sthref1086"></a><a id="sthref1087"></a><a id="sthref1088"></a><a id="sthref1089"></a>partitioned or subpartitioned table, SQL*Loader partitions the rows and maintains indexes (which can also be partitioned). Note that a direct path load of a partitioned or subpartitioned table can be quite resource-intensive for tables with many partitions or subpartitions.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you are performing a direct path load into multiple partitions and a space error occurs, then the load is rolled back to the last commit point. If there was no commit point, then the entire load is rolled back. This ensures that no data encountered after the space error is written out to a different partition.
<p>You can use the <code dir="ltr">ROWS</code> parameter to specify the frequency of the commit points. If the <code dir="ltr">ROWS</code> parameter is not specified, then the entire load is rolled back.</p>
</div>
</div>
<!-- class="sect2" -->
<div id="SUTIL1291" class="sect2"><a id="sthref1090"></a>
<h3 class="sect2">Direct Path Load of a Single Partition or Subpartition</h3>
<p>When loading a single partition of a partitioned or subpartitioned table, SQL*Loader partitions the rows and rejects any rows that do not map to the partition or subpartition specified in the SQL*Loader control file. Local index partitions that correspond to the data partition or subpartition being loaded are maintained by SQL*Loader. Global indexes are not maintained on single partition or subpartition direct path loads. During a direct path load of a single partition, SQL*Loader uses the partition-extended syntax of the <code dir="ltr">LOAD</code> statement, which has either of the following forms:</p>
<pre dir="ltr">
LOAD INTO TABLE T PARTITION (P) VALUES ... 

LOAD INTO TABLE T SUBPARTITION (P) VALUES ... 
</pre>
<p>While you are loading a partition of a partitioned or subpartitioned table, you are also allowed to perform DML operations on, and direct path loads of, other partitions in the table.</p>
<p>Although a direct path load minimizes database processing, several calls to the Oracle database are required at the beginning and end of the load to initialize and finish the load, respectively. Also, certain DML locks are required during load initialization and are released when the load completes. The following operations occur during the load: index keys are built and put into a sort, and space management routines are used to get new extents when needed and to adjust the upper boundary (high-water mark) for a data savepoint. See <a href="#i1007779">"Using Data Saves to Protect Against Data Loss"</a> for information about adjusting the upper boundary.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1292" class="sect2"><a id="sthref1091"></a>
<h3 class="sect2">Advantages of a Direct Path Load</h3>
<p>A direct path load is faster than the conventional path for the following reasons:<a id="sthref1092"></a></p>
<ul>
<li>
<p>Partial blocks are not used, so no reads are needed to find them, and fewer writes are performed.</p>
</li>
<li>
<p>SQL*Loader need not execute any SQL <code dir="ltr">INSERT</code> statements; therefore, the processing load on the Oracle database is reduced.</p>
</li>
<li>
<p>A direct path load calls on Oracle to lock tables and indexes at the start of the load and releases them when the load is finished. A conventional path load calls Oracle once for each array of rows to process a SQL <code dir="ltr">INSERT</code> statement.</p>
</li>
<li>
<p>A direct path load uses multiblock asynchronous I/O for writes to the database files.</p>
</li>
<li>
<p>During a direct path load, processes perform their own write I/O, instead of using Oracle's buffer cache. This minimizes contention with other Oracle users.</p>
</li>
<li>
<p>The sorted indexes option available during direct path loads enables you to presort data using high-performance sort routines that are native to your system or installation.</p>
</li>
<li>
<p>When a table to be loaded is empty, the presorting option eliminates the sort and merge phases of index-building. The index is filled in as data arrives.</p>
</li>
<li>
<p>Protection against instance failure does not require redo log file entries during direct path loads. Therefore, no time is required to log the load when:</p>
<ul>
<li>
<p>The Oracle database has the SQL <code dir="ltr">NOARCHIVELOG</code> parameter enabled</p>
</li>
<li>
<p>The SQL*Loader <code dir="ltr">UNRECOVERABLE</code> clause is enabled</p>
</li>
<li>
<p>The object being loaded has the SQL <code dir="ltr">NOLOGGING</code> parameter set</p>
</li>
</ul>
<p>See <a href="#i1007854">"Instance Recovery and Direct Path Loads"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1293" class="sect2"><a id="sthref1093"></a>
<h3 class="sect2">Restrictions on Using Direct Path Loads</h3>
<p>The following conditions must be satisfied for you to use the direct path load method:<a id="sthref1094"></a></p>
<ul>
<li>
<p>Tables to be loaded cannot be clustered.</p>
</li>
<li>
<p>Tables to be loaded cannot have Oracle Virtual Private Database (VPD) policies active on INSERT.</p>
</li>
<li>
<p>Segments to be loaded cannot have any active transactions pending.</p>
<p>To check for this condition, use the Oracle Enterprise Manager command <code dir="ltr">MONITOR</code> <code dir="ltr">TABLE</code> to find the object ID for the tables you want to load. Then use the command <code dir="ltr">MONITOR</code> <code dir="ltr">LOCK</code> to see if there are any locks on the tables.</p>
</li>
<li>
<p>For releases of the database earlier than Oracle9<span class="italic">i</span>, you can perform a SQL*Loader direct path load only when the client and server are the same release. This also means that you cannot perform a direct path load of Oracle9<span class="italic">i</span> data into a database of an earlier release. For example, you cannot use direct path load to load data from a release 9.0.1 database into a release 8.1.7 database.</p>
<p>Beginning with Oracle9<span class="italic">i</span>, you can perform a SQL*Loader direct path load when the client and server are different releases. However, both releases must be at least release 9.0.1 and the client release must be the same as or lower than the server release. For example, you can perform a direct path load from a release 9.0.1 database into a release 9.2 database.<a id="sthref1095"></a> However, you cannot use direct path load to load data from a release 10.0.0 database into a release 9.2 database.</p>
</li>
</ul>
<p>The following features are not available with direct path load:</p>
<ul>
<li>
<p>Loading a parent table together with a child table</p>
</li>
<li>
<p>Loading <code dir="ltr">BFILE</code> columns</p>
</li>
<li>
<p>Use of <code dir="ltr">CREATE SEQUENCE</code> during the load. This is because in direct path loads there is no SQL being generated to fetch the next value since direct path does not generate <code dir="ltr">INSERT</code> statements.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1294" class="sect2"><a id="sthref1096"></a>
<h3 class="sect2">Restrictions on a Direct Path Load of a Single Partition</h3>
<p>In addition to the previously listed restrictions, loading a single partition has the following restrictions:</p>
<ul>
<li>
<p>The table that the partition is a member of cannot have any global indexes defined on it.</p>
</li>
<li>
<p>Enabled referential and check constraints on the table that the partition is a member of are not allowed.</p>
</li>
<li>
<p>Enabled triggers are not allowed.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1295" class="sect2"><a id="sthref1097"></a>
<h3 class="sect2">When to Use a Direct Path Load</h3>
<p>If none of the previous restrictions apply, then you should use a direct path load when:<span class="bold"><a id="sthref1098"></a><a id="sthref1099"></a><a id="sthref1100"></a></span></p>
<ul>
<li>
<p>You have a large amount of data to load quickly. A direct path load can quickly load and index large amounts of data. It can also load data into either an empty or nonempty table.</p>
</li>
<li>
<p>You want to load data in parallel for maximum performance. See <a href="#i1008225">"Parallel Data Loading Models"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1296" class="sect2"><a id="sthref1101"></a>
<h3 class="sect2">Integrity Constraints</h3>
<p>All integrity constraints are enforced during direct path loads, although not necessarily at the same time. <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints are enforced during the load. Records that fail these constraints are rejected.<a id="sthref1102"></a><a id="sthref1103"></a><a id="sthref1104"></a></p>
<p><code dir="ltr">UNIQUE</code> constraints are enforced both during and after the load. A record that violates a <code dir="ltr">UNIQUE</code> constraint is not rejected (the record is not available in memory when the constraint violation is detected).</p>
<p>Integrity constraints that depend on other rows or tables, such as referential constraints, are disabled before the direct path load and must be reenabled afterwards. If <code dir="ltr">REENABLE</code> is specified, then SQL*Loader can reenable them automatically at the end of the load. When the constraints are reenabled, the entire table is checked. Any rows that fail this check are reported in the specified error log. See <a href="#i1008078">"Direct Loads, Integrity Constraints, and Triggers"</a>.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1297" class="sect2"><a id="sthref1105"></a>
<h3 class="sect2">Field Defaults on the Direct Path<a id="sthref1106"></a></h3>
<p>Default column specifications defined in the database are not available when you use direct path loading. Fields for which default values are desired must be specified with the <code dir="ltr">DEFAULTIF</code> clause. If a <code dir="ltr">DEFAULTIF</code> clause is not specified and the field is <code dir="ltr">NULL</code>, then a null value is inserted into the database.</p>
</div>
<!-- class="sect2" -->
<a id="i1007664"></a>
<div id="SUTIL1298" class="sect2">
<h3 class="sect2">Loading into Synonyms</h3>
<p>You can load data into a synonym for a table during a direct path load, but the synonym must point directly to either a table or a view on a simple table. Note the following restrictions:</p>
<ul>
<li>
<p>Direct path mode cannot be used if the view is on a table that has user-defined types or XML data.</p>
</li>
<li>
<p>In direct path mode, a view cannot be loaded using a SQL*Loader control file that contains SQL expressions.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007669"></a>
<div id="SUTIL1299" class="sect1">
<h2 class="sect1">Using Direct Path Load<a id="sthref1107"></a></h2>
<p>This section explains how to use the SQL*Loader direct path load method.</p>
<div id="SUTIL1300" class="sect2"><a id="sthref1108"></a>
<h3 class="sect2">Setting Up for Direct Path Loads<a id="sthref1109"></a></h3>
<p>To prepare the database for direct path loads, you must run the setup script, <code dir="ltr"><a id="sthref1110"></a>catldr</code>.<code dir="ltr">sql</code>, to create the necessary views. You need only run this script once for each database you plan to do direct loads to. You can run this script during database installation if you know then that you will be doing direct loads.</p>
</div>
<!-- class="sect2" -->
<a id="i1009607"></a>
<div id="SUTIL1301" class="sect2">
<h3 class="sect2">Specifying a Direct Path Load<a id="sthref1111"></a></h3>
<p>To start SQL*Loader in direct path load mode, set the <code dir="ltr"><a id="sthref1112"></a>DIRECT<a id="sthref1113"></a></code> parameter to <code dir="ltr">true</code> on the command line or in the parameter file, if used, in the format:</p>
<pre dir="ltr">
DIRECT=true
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1007896">"Optimizing Performance of Direct Path Loads"</a> for information about parameters you can use to optimize performance of direct path loads</p>
</li>
<li>
<p><a href="#i1008033">"Optimizing Direct Path Loads on Multiple-CPU Systems"</a> if you are doing a direct path load on a multiple-CPU system or across systems</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<div id="SUTIL1302" class="sect2"><a id="sthref1114"></a>
<h3 class="sect2">Building Indexes</h3>
<p>You can improve performance of direct path loads by using<a id="sthref1115"></a> temporary storage. After each block is formatted, the new index keys are put in a sort (temporary) segment. The old index and the new keys are merged at load finish time to create the new index. The old index, sort (temporary) segment, and new index segment all require storage until the merge is complete. Then the old index and temporary segment are removed.<a id="sthref1116"></a></p>
<p>During a conventional path load, every time a row is inserted the index is updated. This method does not require temporary storage space, but it does add processing time.</p>
<div id="SUTIL1303" class="sect3"><a id="sthref1117"></a>
<h4 class="sect3">Improving Performance</h4>
<p>To improve performance on systems with limited memory, use the <code dir="ltr">SINGLEROW</code> parameter. For more information, see <a href="ldr_control_file.htm#CIAEIFCF">"SINGLEROW Option"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If, during a direct load, you have specified that the data is to be presorted and the existing index is empty, then a temporary segment is not required, and no merge occurs&mdash;the keys are put directly into the index. See <a href="#i1007896">"Optimizing Performance of Direct Path Loads"</a> for more information.</div>
<p>When multiple indexes are built, the temporary segments corresponding to each index exist simultaneously, in addition to the old indexes. The new keys are then merged with the old indexes, one index at a time. As each new index is created, the old index and the corresponding temporary segment are removed.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about how to estimate ind<a id="sthref1118"></a>ex size and set storage parameters</div>
</div>
<!-- class="sect3" -->
<a id="BABCJGDB"></a>
<div id="SUTIL1304" class="sect3">
<h4 class="sect3">Temporary Segment Storage Requirements</h4>
<p>To estimate the amount of temporary segment space needed for storing the new index keys (in bytes), use the following formula:<a id="sthref1119"></a><a id="sthref1120"></a><a id="sthref1121"></a></p>
<pre dir="ltr">
1.3 * key_storage
</pre>
<p>In this formula, key storage is defined as follows:</p>
<pre dir="ltr">
key_storage = (number_of_rows) *
     ( 10 + sum_of_column_sizes + number_of_columns )
</pre>
<p>The columns included in this formula are the columns in the index. There is one length byte per column, and 10 bytes per row are used for a <code dir="ltr">ROWID</code> and additional overhead.</p>
<p>The constant 1.3 reflects the average amount of extra space needed for sorting. This value is appropriate for most randomly ordered data. If the data arrives in exactly opposite order, then twice the key-storage space is required for sorting, and the value of this constant would be 2.0. That is the worst case.</p>
<p>If the data is fully sorted, then only enough space to store the index entries is required, and the value of this constant would be 1.0. See <a href="#i1007922">"Presorting Data for Faster Indexing"</a> for more information.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007756"></a>
<div id="SUTIL1305" class="sect2">
<h3 class="sect2">Indexes Left in<a id="sthref1122"></a><a id="sthref1123"></a> an Unusable State</h3>
<p>SQL*Loader leaves indexes in an Index Unusable state when the data segment being loaded becomes more up-to-date than the index segments that index it.</p>
<p>Any SQL statement that tries to use an index that is in an Index Unusable state returns an error. The following conditions cause a direct path load to leave an index or a partition of a partitioned index in an Index Unusable state:</p>
<ul>
<li>
<p>SQL*Loader runs out of space for the index and cannot update the index.</p>
</li>
<li>
<p>The data is not in the order specified by the <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause.</p>
</li>
<li>
<p>There is an instance failure, or the Oracle shadow process fails while building the index.</p>
</li>
<li>
<p>There are duplicate keys in a unique index.</p>
</li>
<li>
<p>Data savepoints are being used, and the load fails or is terminated by a keyboard interrupt after a data savepoint occurred.</p>
</li>
</ul>
<p>To determine if an index is in an Index Unusable state, you can execute a simple query:</p>
<pre dir="ltr">
SELECT INDEX_NAME, STATUS
   FROM USER_INDEXES 
   WHERE TABLE_NAME = 'tablename';
</pre>
<p>If you are not the owner of the table, then search <code dir="ltr">ALL_INDEXES</code> or <code dir="ltr">DBA_INDEXES</code> instead of <code dir="ltr">USER_INDEXES</code>.</p>
<p>To determine if an index partition is in an unusable state, you can execute the following query:</p>
<pre dir="ltr">
SELECT INDEX_NAME, 
       PARTITION_NAME,
       STATUS FROM USER_IND_PARTITIONS
       WHERE STATUS != 'VALID';
</pre>
<p>If you are not the owner of the table, then search <code dir="ltr">ALL_IND_PARTITIONS</code> and <code dir="ltr">DBA_IND_PARTITIONS</code> instead of <code dir="ltr">USER_IND_PARTITIONS</code>.</p>
</div>
<!-- class="sect2" -->
<a id="i1007779"></a>
<div id="SUTIL1306" class="sect2">
<h3 class="sect2">Using Data Saves to Protect Against Data Loss</h3>
<p>You can use data saves to protect against loss of data due to instance failure. All data loaded up to the last savepoint is protected against instance failure. To continue the load after an instance failure, determine how many rows from the input file were processed before the failure, then use the <code dir="ltr">SKIP</code> parameter to skip those processed rows.</p>
<p>If there are any indexes on the table, drop them before continuing the load, and then re-create them after the load. See <a href="#i1007807">"Data Recovery During Direct Path Loads"</a> for more information about media and instance recovery.<a id="sthref1124"></a><a id="sthref1125"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Indexes are not protected by a data save, because SQL*Loader does not build indexes until after data loading completes. (The only time indexes are built during the load is when presorted data is loaded into an empty table, but these indexes are also unprotected.)</div>
<a id="i1007792"></a>
<div id="SUTIL1307" class="sect3">
<h4 class="sect3">Using the ROWS Parameter</h4>
<p>The <code dir="ltr">ROWS</code> parameter<a id="sthref1126"></a> determines when data saves occur during a direct path load. The value you specify for <code dir="ltr">ROWS</code> is the number of rows you want SQL*Loader to read from the input file before saving inserts in the database.<a id="sthref1127"></a><a id="sthref1128"></a></p>
<p>A data save is an expensive operation. The value for <code dir="ltr">ROWS</code> should be set high enough so that a data save occurs once every 15 minutes or longer. The intent is to provide an upper boundary (high-water mark) on the amount of work that is lost when an instance failure occurs during a long-running direct path load. Setting the value of <code dir="ltr">ROWS</code> to a small number adversely affects performance and data block space utilization.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1308" class="sect3"><a id="sthref1129"></a>
<h4 class="sect3">Data Save Versus Commit</h4>
<p>In a conventional load, <code dir="ltr">ROWS</code> is the number of rows to read before a commit operation. A direct load data save is similar to a conventional load commit, but it is not identical.</p>
<p>The similarities are as follows:</p>
<ul>
<li>
<p>A data save will make the rows visible to other users.</p>
</li>
<li>
<p>Rows cannot be rolled back after a data save.</p>
</li>
</ul>
<p>The major difference is that in a direct path load data save, the indexes will be unusable (in Index Unusable state) until the load completes.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007807"></a>
<div id="SUTIL1309" class="sect2">
<h3 class="sect2">Data Recovery During Direct Path Loads</h3>
<p>SQL*Loader provides full support for data recovery when using the direct path load method. There are two main types of recovery:</p>
<ul>
<li>
<p>Media - recovery from the loss of a database file. You must be operating in <code dir="ltr">ARCHIVELOG</code> mode to recover after you lose a database file.</p>
</li>
<li>
<p>Instance - recovery from a system failure in which in-memory data was changed but lost due to the failure before it was written to disk. The Oracle database can always recover from instance failures, even when redo logs are not archived<a id="sthref1130"></a><a id="sthref1131"></a><a id="sthref1132"></a><a id="sthref1133"></a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about recovery</div>
</li>
</ul>
<div id="SUTIL1310" class="sect3"><a id="sthref1134"></a>
<h4 class="sect3">Media Recovery and Direct Path Loads<a id="sthref1135"></a></h4>
<p>If redo log file archiving is enabled (you are operating in<a id="sthref1136"></a><a id="sthref1137"></a><a id="sthref1138"></a><a id="sthref1139"></a> <code dir="ltr">ARCHIVELOG</code> mode), then SQL*Loader logs loaded data when using the direct path, making media recovery possible. If redo log archiving is not enabled (you are operating in <code dir="ltr">NOARCHIVELOG</code> mode), then media recovery is not possible.</p>
<p>To recover a database file that was lost while it was being loaded, use the same method that you use to recover data loaded with the conventional path:</p>
<ol>
<li>
<p>Restore the most recent backup of the affected database file.</p>
</li>
<li>
<p>Recover the tablespace using the <code dir="ltr">RECOVER</code> command.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink BRADV" href="../../backup.112/e10642/toc.htm"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about the RMAN <code dir="ltr">RECOVER</code> command</div>
</li>
</ol>
</div>
<!-- class="sect3" -->
<a id="i1007854"></a>
<div id="SUTIL1311" class="sect3">
<h4 class="sect3">Instance Recovery and Direct Path Loads</h4>
<p>Because SQL*Loader writes directly to the database files, all rows inserted up to the last data save will automatically be present in the database files if the instance<a id="sthref1140"></a> is restarted. Changes do not need to be recorded in the redo log file to make instance recovery possible.</p>
<p>If an instance failure occurs, then the indexes being built may be left in an Index Unusable state. Indexes that are Unusable must be rebuilt before you can use the table or partition. See <a href="#i1007756">"Indexes Left in an Unusable State"</a> for information about how to determine if an index has been left in Index Unusable state.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1312" class="sect2"><a id="sthref1141"></a>
<h3 class="sect2">Loading Long Data Fields</h3>
<p>Data that is longer than SQL*Loader's maximum buffer size can be loaded on the direct path by using LOBs. You can improve performance when doing this by using a large <code dir="ltr">STREAMSIZE</code> value.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<ul>
<li>
<p><a href="ldr_loading.htm#i1006803">"Loading LOBs"</a></p>
</li>
<li>
<p><a href="#i1008016">"Specifying the Number of Column Array Rows and Size of Stream Buffers"</a></p>
</li>
</ul>
</div>
<p>You could also load data that is longer than the maximum buffer size by using the <code dir="ltr">PIECED</code> parameter, as described in the next section, but Oracle highly recommends that you use LOBs instead.</p>
<div id="SUTIL1313" class="sect3"><a id="sthref1142"></a>
<h4 class="sect3">Loading Data As PIECED<a id="sthref1143"></a></h4>
<p>The <code dir="ltr">PIECED</code> parameter can be used to load data in sections, if the data is in the last column of the logical record. <a id="sthref1144"></a></p>
<p>Declaring a column as <code dir="ltr">PIECED</code> informs the direct path loader that a <code dir="ltr">LONG</code> field might be split across multiple physical records (pieces). In such cases, SQL*Loader processes each piece of the <code dir="ltr">LONG</code> field as it is found in the physical record. All the pieces are read before the record is processed. SQL*Loader makes no attempt to materialize the <code dir="ltr">LONG</code> field before storing it; however, all the pieces are read before the record is processed.<a id="sthref1145"></a></p>
<p>The following restrictions apply when you declare a column as <code dir="ltr">PIECED</code>:</p>
<ul>
<li>
<p>This option is only valid on the direct path.</p>
</li>
<li>
<p>Only one field per table may be <code dir="ltr">PIECED</code>.</p>
</li>
<li>
<p>The <code dir="ltr">PIECED</code> field must be the last field in the logical record.</p>
</li>
<li>
<p>The <code dir="ltr">PIECED</code> field may not be used in any <code dir="ltr">WHEN</code>, <code dir="ltr">NULLIF</code>, or <code dir="ltr">DEFAULTIF</code> clauses.</p>
</li>
<li>
<p>The <code dir="ltr">PIECED</code> field's region in the logical record must not overlap with any other field's region.</p>
</li>
<li>
<p>The <code dir="ltr">PIECED</code> corresponding database column may not be part of the index.</p>
</li>
<li>
<p>It may not be possible to load a rejected record from the bad file if it contains a <code dir="ltr">PIECED</code> field.</p>
<p>For example, a <code dir="ltr">PIECED</code> field could span three records. SQL*Loader loads the piece from the first record and then reuses the buffer for the second buffer. After loading the second piece, the buffer is reused for the third record. If an error is discovered, then only the third record is placed in the bad file because the first two records no longer exist in the buffer. As a result, the record in the bad file would not be valid.</p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007896"></a>
<div id="SUTIL1314" class="sect1">
<h2 class="sect1">Optimizing Performance of Direct Path Loads<a id="sthref1146"></a><a id="sthref1147"></a><a id="sthref1148"></a></h2>
<p>You can control the time and temporary storage used during direct path loads.</p>
<p>To minimize time:</p>
<ul>
<li>
<p>Preallocate storage space</p>
</li>
<li>
<p>Presort the data</p>
</li>
<li>
<p>Perform infrequent data saves</p>
</li>
<li>
<p>Minimize use of the redo log</p>
</li>
<li>
<p>Specify the number of column array rows and the size of the stream buffer</p>
</li>
<li>
<p>Specify a date cache value</p>
</li>
<li>
<p>Set <code dir="ltr">DB_UNRECOVERABLE_SCN_TRACKING=FALSE</code>. Unrecoverable (nologging) direct writes are tracked in the control file by periodically storing the SCN and Time of the last direct write. If these updates to the control file are adversely affecting performance, then setting the <code dir="ltr">DB_UNRECOVERABLE_SCN_TRACKING</code> parameter to <code dir="ltr">FALSE</code> may improve performance.</p>
</li>
</ul>
<p>To minimize space:</p>
<ul>
<li>
<p>When sorting data before the load, sort data on the index that requires the most temporary storage space</p>
</li>
<li>
<p>Avoid index maintenance during the load</p>
</li>
</ul>
<div id="SUTIL1315" class="sect2"><a id="sthref1149"></a>
<h3 class="sect2">Preallocating Storage for Faster Loading</h3>
<p>SQL*Loader automatically adds extents to the table if necessary, but this process takes time. For faster loads into a new table, allocate the required extents when the table is created.<a id="sthref1150"></a><a id="sthref1151"></a></p>
<p>To calculate the space required by a table, see the information about managing database files in the <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide.</span></a> Then use the <code dir="ltr">INITIAL</code> or <code dir="ltr">MINEXTENTS</code> clause in the SQL <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement to allocate the required space.</p>
<p>Another approach is to size extents large enough so that extent allocation is infrequent.</p>
</div>
<!-- class="sect2" -->
<a id="i1007922"></a>
<div id="SUTIL1316" class="sect2">
<h3 class="sect2">Presorting Data for Faster Indexing</h3>
<p>You can improve the performance of direct path loads by presorting your data on indexed columns. Presorting minimizes temporary storage requirements during the load. Presorting also enables you to take advantage of high-performance sorting routines that are optimized for your operating system or application.<span class="bold"><a id="sthref1152"></a><a id="sthref1153"></a><a id="sthref1154"></a></span></p>
<p>If the data is presorted and the existing index is not empty, then presorting minimizes the amount of temporary segment space needed for the new keys. The sort routine appends each new key to the key list.</p>
<p>Instead of requiring extra space for sorting, only space for the keys is needed. To calculate the amount of storage needed, use a sort factor of 1.0 instead of 1.3. For more information about estimating storage requirements, see <a href="#BABCJGDB">"Temporary Segment Storage Requirements"</a>.</p>
<p>If presorting is specified and the existing index is empty, then maximum efficiency is achieved. The new keys are simply inserted into the index. Instead of having a temporary segment and new index existing simultaneously with the empty, old index, only the new index exists. So, temporary storage is not required, and time is saved.</p>
<a id="i1007937"></a>
<div id="SUTIL1317" class="sect3">
<h4 class="sect3">SORTED INDEXES Clause</h4>
<p>The <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause identifies the indexes on which the data is presorted. This clause is allowed only for direct path loads. See case study 6, Loading Data Using the Direct Path Load Method, for an example.<a id="sthref1155"></a><a id="sthref1156"></a> (See <a href="ldr_concepts.htm#i1006494">"SQL*Loader Case Studies"</a> for information on how to access case studies.)</p>
<p>Generally, you specify only one index in the <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause, because data that is sorted for one index is not usually in the right order for another index. When the data is in the same order for multiple indexes, however, all indexes can be specified at once.</p>
<p>All indexes listed in the <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause must be created before you start the direct path load.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1318" class="sect3"><a id="sthref1157"></a>
<h4 class="sect3">Unsorted Data</h4>
<p>If you specify an index in the <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause, and the data is not sorted for that index, then the index is left in an Index Unusable state at the end of the load. The data is present, but any attempt to use the index results in an error. Any index that is left in an Index Unusable state must be rebuilt after the load.<a id="sthref1158"></a><a id="sthref1159"></a><a id="sthref1160"></a><a id="sthref1161"></a></p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1319" class="sect3"><a id="sthref1162"></a>
<h4 class="sect3">Multiple-Column Indexes</h4>
<p>If you specify a multiple-column index in the <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause, then the data should be sorted so that it is ordered first on the first column in the index, next on the second column in the index, and so on.<a id="sthref1163"></a><a id="sthref1164"></a><a id="sthref1165"></a></p>
<p>For example, if the first column of the index is city, and the second column is last name; then the data should be ordered by name within each city, as in the following list:</p>
<pre dir="ltr">
Albuquerque      Adams
Albuquerque      Hartstein
Albuquerque      Klein
...         ...
Boston           Andrews
Boston           Bobrowski
Boston           Heigham
...              ...
</pre></div>
<!-- class="sect3" -->
<div id="SUTIL1320" class="sect3"><a id="sthref1166"></a>
<h4 class="sect3">Choosing the Best Sort Order</h4>
<p>For the best overall performance of direct path loads, you should presort the data based on the index that requires the most temporary segment space. For example, if the primary key is one numeric column, and the secondary key consists of three text columns, then you can minimize both sort time and storage requirements by presorting on the secondary key.<a id="sthref1167"></a><a id="sthref1168"></a></p>
<p>To determine the index that requires the most storage space, use the following procedure:</p>
<ol>
<li>
<p>For each index, add up the widths of all columns in that index.</p>
</li>
<li>
<p>For a single-table load, pick the index with the largest overall width.</p>
</li>
<li>
<p>For each table in a multiple-table load, identify the index with the largest overall width. If the same number of rows are to be loaded into each table, then again pick the index with the largest overall width. Usually, the same number of rows are loaded into each table.</p>
</li>
<li>
<p>If a different number of rows are to be loaded into the indexed tables in a multiple-table load, then multiply the width of each index identified in Step 3 by the number of rows that are to be loaded into that index, and pick the index with the largest result.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1321" class="sect2"><a id="sthref1169"></a>
<h3 class="sect2">Infrequent Data Saves</h3>
<p>Frequent data saves resulting from a small <code dir="ltr">ROWS</code> value adversely affect the performance of a direct path load. A small <code dir="ltr">ROWS</code> value can also result in wasted data block space because the last data block is not written to after a save, even if the data block is not full.</p>
<p>Because direct path loads can be many times faster than conventional loads, the value of <code dir="ltr">ROWS</code> should be considerably higher for a direct load than it would be for a conventional load.<a id="sthref1170"></a><a id="sthref1171"></a><a id="sthref1172"></a></p>
<p>During a data save, loading stops until all of SQL*Loader's buffers are successfully written. You should select the largest value for <code dir="ltr">ROWS</code> that is consistent with safety. It is a good idea to determine the average time to load a row by loading a few thousand rows. Then you can use that value to select a good value for <code dir="ltr">ROWS</code>.</p>
<p>For example, if you can load 20,000 rows per minute, and you do not want to repeat more than 10 minutes of work after an interruption, then set <code dir="ltr">ROWS</code> to be 200,000 (20,000 rows/minute * 10 minutes).</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1322" class="sect2"><a id="sthref1173"></a>
<h3 class="sect2">Minimizing Use of the Redo Log</h3>
<p>One way to speed a direct load dramatically is to minimize<a id="sthref1174"></a> use of the redo log. There are three ways to do this. You can disable archiving, you can specify that the load is unrecoverable, or you can set the SQL <code dir="ltr">NOLOGGING</code> parameter for the objects being loaded. This section discusses all methods.<a id="sthref1175"></a></p>
<a id="i1007996"></a>
<div id="SUTIL1323" class="sect3">
<h4 class="sect3">Disabling Archiving<a id="sthref1176"></a></h4>
<p>If archiving is disabled, then direct path loads do not generate full image redo. Use the SQL <code dir="ltr">ARCHIVELOG</code> and <code dir="ltr">NOARCHIVELOG</code> parameters to set the archiving mode. See the <a class="olink ADMIN" href="../e25494/toc.htm"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information about archiving.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1324" class="sect3"><a id="sthref1177"></a>
<h4 class="sect3">Specifying the SQL*Loader UNRECOVERABLE Clause</h4>
<p>To save time and space in the redo log file, use the SQL*Loader <code dir="ltr">UNRECOVERABLE</code> clause in the control file when you load data. An unrecoverable load does not record loaded data in the redo log file; instead, it generates invalidation redo.</p>
<p>The <code dir="ltr">UNRECOVERABLE</code> clause applies to all objects loaded during the load session (both data and index segments). Therefore, media recovery is disabled for the loaded table, although database changes by other users may continue to be logged.<a id="sthref1178"></a><a id="sthref1179"></a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the data load is not logged, you may want to make a backup of the data after loading.</div>
<p>If media recovery becomes necessary on data that was loaded with the <code dir="ltr">UNRECOVERABLE</code> clause, then the data blocks that were loaded are marked as logically corrupted.</p>
<p>To recover the data, drop and re-create the data. It is a good idea to do backups immediately after the load to preserve the otherwise unrecoverable data.</p>
<p>By default, a direct path load is <code dir="ltr">RECOVERABLE</code>.</p>
<p>The following is an example of specifying the <code dir="ltr">UNRECOVERABLE</code> clause in the control file:</p>
<pre dir="ltr">
UNRECOVERABLE
LOAD DATA
INFILE 'sample.dat'
INTO TABLE emp
(ename VARCHAR2(10), empno NUMBER(4));
</pre></div>
<!-- class="sect3" -->
<div id="SUTIL1325" class="sect3"><a id="sthref1180"></a>
<h4 class="sect3">Setting the SQL NOLOGGING Parameter</h4>
<p>If a data or index segment has the SQL <code dir="ltr">NOLOGGING</code> parameter set, then full image redo logging is disabled for that segment (invalidation redo is generated). Use of the <code dir="ltr">NOLOGGING</code> parameter allows a finer degree of control over the objects that are not logged.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008016"></a>
<div id="SUTIL1326" class="sect2">
<h3 class="sect2">Specifying the Number of Column Array Rows and Size of Stream Buffers</h3>
<p>The number of column array rows determines the number of rows loaded before the stream buffer is built. The <code dir="ltr">STREAMSIZE</code> parameter specifies the size (in bytes) of the data stream sent from the client to the server.</p>
<p>Use the <code dir="ltr">COLUMNARRAYROWS</code> parameter to specify a value for the number of column array rows.<a id="sthref1181"></a> Note that when <code dir="ltr">VARRAY</code>s are loaded using direct path, the <code dir="ltr">COLUMNARRAYROWS</code> parameter defaults to 100 to avoid client object cache thrashing.</p>
<p>Use the <code dir="ltr">STREAMSIZE</code> parameter to specify the size for direct path stream buffers.<a id="sthref1182"></a></p>
<p>The optimal values for these parameters vary, depending on the system, input datatypes, and Oracle column datatypes used. When you are using optimal values for your particular configuration, the elapsed time in the SQL*Loader log file should go down.</p>
<p>To see a list of default values for these and other parameters, invoke SQL*Loader without any parameters, as described in <a href="ldr_params.htm#i1004590">"Invoking SQL*Loader"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You should monitor process paging activity, because if paging becomes excessive, then performance can be significantly degraded. You may need to lower the values for <code dir="ltr">READSIZE</code>, <code dir="ltr">STREAMSIZE</code>, and <code dir="ltr">COLUMNARRAYROWS</code> to avoid excessive paging.</div>
<p>It can be particularly useful to specify the number of column array rows and size of the steam buffer when you perform direct path loads on multiple-CPU systems. See <a href="#i1008033">"Optimizing Direct Path Loads on Multiple-CPU Systems"</a> for more information.</p>
</div>
<!-- class="sect2" -->
<a id="i1010480"></a>
<div id="SUTIL1327" class="sect2">
<h3 class="sect2">Specifying a Value for the Date Cache</h3>
<p>If you are performing a direct path load in which the same date or timestamp values are loaded many times, then a large percentage of total load time can end up being used for converting date and timestamp data. This is especially true if multiple date columns are being loaded. In such a case, it may be possible to improve performance<a id="sthref1183"></a> by using the SQL*Loader date cache<a id="sthref1184"></a>.</p>
<p>The date cache reduces the number of date conversions done when many duplicate values are present in the input data. It enables you to specify the number of unique dates anticipated during the load.</p>
<p>The date cache is enabled by default. To completely disable the date cache, set it to 0.</p>
<p>The default date cache size is 1000 elements. If the default is used and the number of unique input values loaded exceeds 1000, then the date cache is automatically disabled for that table. This prevents excessive and unnecessary lookup times that could affect performance. However, if instead of using the default, you specify a nonzero value for the date cache and it is exceeded, then the date cache is <span class="italic">not</span> disabled. Instead, any input data that exceeded the maximum is explicitly converted using the appropriate conversion routines.</p>
<p>The date cache can be associated with only one table. No date cache sharing can take place across tables. A date cache is created for a table only if all of the following conditions are true:</p>
<ul>
<li>
<p>The <code dir="ltr">DATE_CACHE</code> parameter is not set to 0</p>
</li>
<li>
<p>One or more date values, timestamp values, or both are being loaded that require datatype conversion in order to be stored in the table</p>
</li>
<li>
<p>The load is a direct path load</p>
</li>
</ul>
<p>Date cache statistics are written to the log file. You can use those statistics to improve direct path load performance as follows:</p>
<ul>
<li>
<p>If the number of cache entries is less than the cache size and there are no cache misses, then the cache size could safely be set to a smaller value.</p>
</li>
<li>
<p>If the number of cache hits (entries for which there are duplicate values) is small and the number of cache misses is large, then the cache size should be increased. Be aware that if the cache size is increased too much, then it may cause other problems, such as excessive paging or too much memory usage.</p>
</li>
<li>
<p>If most of the input date values are unique, then the date cache will not enhance performance and therefore should not be used.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Date cache statistics are <span class="italic">not</span> written to the SQL*Loader log file if the cache was active by default and disabled because the maximum was exceeded.</div>
</li>
</ul>
<p>If increasing the cache size does not improve performance, then revert to the default behavior or set the cache size to 0. The overall performance improvement also depends on the datatypes of the other columns being loaded. Improvement will be greater for cases in which the total number of date columns loaded is large compared to other types of data loaded.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="ldr_params.htm#i1007852">"DATE_CACHE"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008033"></a>
<div id="SUTIL1328" class="sect1">
<h2 class="sect1">Optimizing Direct Path Loads on Multiple-CPU Systems</h2>
<p>If you are performing direct path loads on a multiple-CPU system, then SQL*Loader uses multithreading by default. A multiple-CPU system in this case is defined as a single system that has two or more CPUs.<a id="sthref1185"></a></p>
<p>Multithreaded loading means that, when possible, conversion of the column arrays to stream buffers and stream buffer loading are performed in parallel. This optimization<a id="sthref1186"></a><a id="sthref1187"></a> works best when:</p>
<ul>
<li>
<p>Column arrays are large enough to generate multiple direct path stream buffers for loads</p>
</li>
<li>
<p>Data conversions are required from input field datatypes to Oracle column datatypes</p>
<p>The conversions are performed in parallel with stream buffer loading.</p>
</li>
</ul>
<p>The status of this process is recorded in the SQL*Loader log file, as shown in the following sample portion of a log:</p>
<pre dir="ltr">
Total stream buffers loaded by SQL*Loader main thread:         47
Total stream buffers loaded by SQL*Loader load thread:        180
Column array rows:                                           1000
Stream buffer bytes:                                       256000
</pre>
<p>In this example, the SQL*Loader load thread has offloaded the SQL*Loader main thread, allowing the main thread to build the next stream buffer while the load thread loads the current stream on the server.</p>
<p>The goal is to have the load thread perform as many stream buffer loads as possible. This can be accomplished by increasing the number of column array rows, decreasing the stream buffer size, or both. You can monitor the elapsed time in the SQL*Loader log file to determine whether your changes are having the desired effect. See <a href="#i1008016">"Specifying the Number of Column Array Rows and Size of Stream Buffers"</a> for more information.</p>
<p>On single-CPU systems, optimization is turned off by default. When the server is on another system, performance may improve if you manually turn on multithreading.</p>
<p>To turn the multithreading option on or off, use the <code dir="ltr">MULTITHREADING</code> parameter at the SQL*Loader command line or specify it in your SQL*Loader control file.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink LNOCI" href="../../appdev.112/e10646/toc.htm"><span class="italic">Oracle Call Interface Programmer's Guide</span></a> for more information about the concepts of direct path loading</div>
</div>
<!-- class="sect1" -->
<a id="i1008055"></a>
<div id="SUTIL1329" class="sect1">
<h2 class="sect1">Avoiding Index Maintenance</h2>
<p>For both the conventional path and the direct path, SQL*Loader maintains all existing indexes for a table.<span class="bold"><a id="sthref1188"></a><a id="sthref1189"></a></span></p>
<p>To avoid index maintenance, use one of the following methods:</p>
<ul>
<li>
<p>Drop the indexes before beginning of the load.</p>
</li>
<li>
<p>Mark selected indexes or index partitions as Index Unusable before beginning the load and use the <code dir="ltr">SKIP_UNUSABLE_INDEXES<a id="sthref1190"></a><a id="sthref1191"></a><a id="sthref1192"></a></code> parameter.</p>
</li>
<li>
<p>Use the <code dir="ltr">SKIP_INDEX_MAINTENANCE<a id="sthref1193"></a><a id="sthref1194"></a><a id="sthref1195"></a></code> parameter (direct path only, use with caution).</p>
</li>
</ul>
<p>By avoiding index maintenance, you minimize the amount of space required during a direct path load, in the following ways:</p>
<ul>
<li>
<p>You can build indexes one at a time, reducing the amount of sort (temporary) segment space that would otherwise be needed for each index.</p>
</li>
<li>
<p>Only one index segment exists when an index is built, instead of the three segments that temporarily exist when the new keys are merged into the old index to make the new index.</p>
</li>
</ul>
<p>Avoiding index maintenance is quite reasonable when the number of rows to be loaded is large compared to the size of the table. But if relatively few rows are added to a large table, then the time required to resort the indexes may be excessive. In such cases, it is usually better to use the conventional path load method, or to use the <code dir="ltr">SINGLEROW<a id="sthref1196"></a></code> parameter of SQL*Loader. For more information, see <a href="ldr_control_file.htm#CIAEIFCF">"SINGLEROW Option"</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1008078"></a>
<div id="SUTIL1330" class="sect1">
<h2 class="sect1">Direct Loads, Integrity Constraints, and Triggers<a id="sthref1197"></a><a id="sthref1198"></a><a id="sthref1199"></a></h2>
<p>With the conventional path load method, arrays of rows are inserted with standard SQL <code dir="ltr">INSERT</code> statements&mdash;integrity constraints and insert triggers are automatically applied. But when you load data with the direct path, SQL*Loader disables some integrity constraints and all database triggers. This section discusses the implications of using direct path loads with respect to these features.</p>
<div id="SUTIL1331" class="sect2"><a id="sthref1200"></a>
<h3 class="sect2">Integrity Constraints</h3>
<p>During a direct path load, some integrity constraints are automatically disabled. Others are not. For a description of the constraints, see the information about maintaining data integrity in the <a class="olink ADFNS" href="../../appdev.112/e41502/toc.htm"><span class="italic">Oracle Database Advanced Application Developer's Guide.</span></a></p>
<div id="SUTIL1332" class="sect3"><a id="sthref1201"></a>
<h4 class="sect3">Enabled Constraints<a id="sthref1202"></a></h4>
<p>During a direct path load, the constraints that remain enabled are as follows:<a id="sthref1203"></a></p>
<ul>
<li>
<p><code dir="ltr">NOT</code> <code dir="ltr">NULL</code></p>
</li>
<li>
<p><code dir="ltr">UNIQUE</code></p>
</li>
<li>
<p><code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> (unique-constraints on not-null columns)</p>
</li>
</ul>
<p><code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints are checked at column array build time. Any row that violates the <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint is rejected.</p>
<p>Even though <code dir="ltr">UNIQUE</code> constraints remain enabled during direct path loads, any rows that violate those constraints are loaded anyway (this is different than in conventional path in which such rows would be rejected). When indexes are rebuilt at the end of the direct path load, <code dir="ltr">UNIQUE</code> constraints are verified and if a violation is detected, then the index will be left in an Index Unusable state. See <a href="#i1007756">"Indexes Left in an Unusable State"</a>.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1333" class="sect3"><a id="sthref1204"></a>
<h4 class="sect3">Disabled Constraints<a id="sthref1205"></a></h4>
<p>During a direct path load, the following constraints are automatically disabled by default:</p>
<ul>
<li>
<p><code dir="ltr">CHECK</code> constraints</p>
</li>
<li>
<p>Referential constraints (<code dir="ltr">FOREIGN</code> <code dir="ltr">KEY</code>)</p>
</li>
</ul>
<p>You can override<a id="sthref1206"></a> the automatic disabling of <code dir="ltr">CHECK</code> constraints by specifying the <code dir="ltr">EVALUATE CHECK_CONSTRAINTS</code> clause.<a id="sthref1207"></a> SQL*Loader will then evaluate <code dir="ltr">CHECK</code> constraints during a direct path load. Any row that violates the <code dir="ltr">CHECK</code> constraint is rejected. The following example shows the use of the <code dir="ltr">EVALUATE</code> <code dir="ltr">CHECK_CONSTRAINTS</code> clause in a SQL*Loader control file:</p>
<pre dir="ltr">
LOAD DATA 
INFILE * 
APPEND 
INTO TABLE emp 
EVALUATE CHECK_CONSTRAINTS 
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' 
(c1 CHAR(10) ,c2) 
BEGINDATA 
Jones,10
Smith,20 
Brown,30
Taylor,40
</pre></div>
<!-- class="sect3" -->
<div id="SUTIL1334" class="sect3"><a id="sthref1208"></a>
<h4 class="sect3">Reenable Constraints</h4>
<p>When the load completes, the integrity constraints will be reenabled automatically if the <code dir="ltr">REENABLE</code> clause is specified. The syntax for the <code dir="ltr">REENABLE</code> clause is as follows:</p>
<img width="702" height="46" src="img/into_table4.gif" alt="Description of into_table4.gif follows" /><br />
<a id="sthref1209" href="img_text/into_table4.htm">Description of the illustration ''into_table4.gif''</a><br />
<br />
<img width="421" height="37" src="img/into_table5.gif" alt="Description of into_table5.gif follows" /><br />
<a id="sthref1210" href="img_text/into_table5.htm">Description of the illustration ''into_table5.gif''</a><br />
<br />
<p>The optional parameter <code dir="ltr">DISABLED_CONSTRAINTS</code> is provided for readability. If the <code dir="ltr">EXCEPTIONS</code> clause is included, then the table must already exist and you must be able to insert into it. This table contains the <code dir="ltr">ROWID</code>s of all rows that violated one of the integrity constraints. It also contains the name of the constraint that was violated. See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for instructions on how to create an exceptions table.</p>
<p>The SQL*Loader log file describes the constraints that were disabled, the ones that were reenabled, and what error, if any, prevented reenabling or validating of each constraint. It also contains the name of the exceptions table specified for each loaded table.</p>
<p>If the <code dir="ltr">REENABLE</code> clause is not used, then the constraints must be reenabled manually, at which time all rows in the table are verified. If the Oracle database finds any errors in the new data, then error messages are produced. The names of violated constraints and the ROWIDs of the bad data are placed in an exceptions table, if one is specified.</p>
<p>If the <code dir="ltr">REENABLE</code> clause is used, then SQL*Loader automatically reenables the constraint and verifies all new rows. If no errors are found in the new data, then SQL*Loader automatically marks the constraint as validated. If any errors <span class="italic">are</span> found in the new data, then error messages are written to the log file and SQL*Loader marks the status of the constraint as <code dir="ltr">ENABLE</code> <code dir="ltr">NOVALIDATE</code>. The names of violated constraints and the ROWIDs of the bad data are placed in an exceptions table, if one is specified.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Normally, when a table constraint is left in an <code dir="ltr">ENABLE</code> <code dir="ltr">NOVALIDATE</code> state, new data can be inserted into the table but no new invalid data may be inserted. However, SQL*Loader direct path load does not enforce this rule. Thus, if subsequent direct path loads are performed with invalid data, then the invalid data will be inserted but the same error reporting and exception table processing as described previously will take place. In this scenario the exception table may contain duplicate entries if it is not cleared out before each load. Duplicate entries can easily be filtered out by performing a query such as the following:
<pre dir="ltr">
SELECT UNIQUE * FROM exceptions_table; 
</pre></div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because referential integrity must be reverified for the entire table, performance may be improved by using the conventional path, instead of the direct path, when a small number of rows are to be loaded into a very large table.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1335" class="sect2"><a id="sthref1211"></a>
<h3 class="sect2">Database Insert Triggers<a id="sthref1212"></a></h3>
<p>Table insert triggers are also disabled when a direct path load begins. After the rows are loaded and indexes rebuilt, any triggers that were disabled are automatically reenabled. The log file lists all triggers that were disabled for the load. There should not be any errors reenabling triggers<a id="sthref1213"></a><a id="sthref1214"></a>.</p>
<p>Unlike integrity constraints, insert triggers are not reapplied to the whole table when they are enabled. As a result, insert triggers do <span class="italic">not</span> fire for any rows loaded on the direct path. When using the direct path, the application must ensure that any behavior associated with insert triggers is carried out for the new rows.</p>
<div id="SUTIL1336" class="sect3"><a id="sthref1215"></a>
<h4 class="sect3">Replacing Insert Triggers with Integrity Constraints<a id="sthref1216"></a></h4>
<p>Applications commonly use insert triggers to implement integrity constraints. Most of the triggers that these application insert are simple enough that they can be replaced with Oracle's automatic integrity constraints.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1337" class="sect3"><a id="sthref1217"></a>
<h4 class="sect3">When Automatic Constraints Cannot Be Used<a id="sthref1218"></a></h4>
<p>Sometimes an insert trigger cannot be replaced with Oracle's automatic integrity constraints. For example, if an integrity check is implemented with a table lookup in an insert trigger, then automatic check constraints cannot be used, because the automatic constraints can only reference constants and columns in the current row. This section describes two methods for duplicating the effects of such a trigger.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1338" class="sect3"><a id="sthref1219"></a>
<h4 class="sect3">Preparation</h4>
<p>Before either method can be used, the table must be prepared. Use the following general guidelines to prepare the table:</p>
<ol>
<li>
<p>Before the load, add a 1-byte or 1-character column to the table that marks rows as "old data" or "new data."</p>
</li>
<li>
<p>Let the value of null for this column signify "old data" because null columns do not take up space.</p>
</li>
<li>
<p>When loading, flag all loaded rows as "new data" with SQL*Loader's <code dir="ltr">CONSTANT</code> parameter.</p>
</li>
</ol>
<p>After following this procedure, all newly loaded rows are identified, making it possible to operate on the new data without affecting the old rows.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1339" class="sect3"><a id="sthref1220"></a>
<h4 class="sect3">Using an Update Trigger<a id="sthref1221"></a></h4>
<p>Generally, you can use a database update trigger to duplicate the effects of an insert trigger. This method is the simplest. It can be used whenever the insert trigger does not raise any exceptions.</p>
<ol>
<li>
<p>Create an update trigger that duplicates the effects of the insert trigger.</p>
<p>Copy the trigger. Change all occurrences of <code dir="ltr">"</code><code dir="ltr"><span class="codeinlineitalic">new</span></code><code dir="ltr">.column_name"</code> to <code dir="ltr">"</code><code dir="ltr"><span class="codeinlineitalic">old</span></code><code dir="ltr">.column_name"</code>.</p>
</li>
<li>
<p>Replace the current update trigger, if it exists, with the new one.</p>
</li>
<li>
<p>Update the table, changing the "new data" flag to null, thereby firing the update trigger.</p>
</li>
<li>
<p>Restore the original update trigger, if there was one.</p>
</li>
</ol>
<p>Depending on the behavior of the trigger, it may be necessary to have exclusive update access to the table during this operation, so that other users do not inadvertently apply the trigger to rows they modify.</p>
</div>
<!-- class="sect3" -->
<div id="SUTIL1340" class="sect3"><a id="sthref1222"></a>
<h4 class="sect3">Duplicating the Effects of Exception Conditions</h4>
<p>If the insert trigger can raise an exception, then more work is required to duplicate its effects. Raising an exception would prevent the row from being inserted into the table. To duplicate that effect with an update trigger, it is necessary to mark the loaded row for deletion.</p>
<p>The "new data" column cannot be used as a delete flag, because an update trigger cannot modify the columns that caused it to fire. So another column must be added to the table. This column marks the row for deletion. A null value means the row is valid. Whenever the insert trigger would raise an exception, the update trigger can mark the row as invalid by setting a flag in the additional column.</p>
<p>In summary, when an insert trigger can raise an exception condition, its effects can be duplicated by an update trigger, provided:</p>
<ul>
<li>
<p>Two columns (which are usually null) are added to the table</p>
</li>
<li>
<p>The table can be updated exclusively (if necessary)</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="SUTIL1341" class="sect3"><a id="sthref1223"></a>
<h4 class="sect3">Using a Stored Procedure<a id="sthref1224"></a></h4>
<p>The following procedure always works, but it is more complex to implement. It can be used when the insert trigger raises exceptions. It does not require a second additional column; and, because it does not replace the update trigger, it can be used without exclusive access to the table.</p>
<ol>
<li>
<p>Do the following to create a stored procedure that duplicates the effects of the insert trigger:</p>
<ol>
<li>
<p>Declare a cursor for the table, selecting all new rows.</p>
</li>
<li>
<p>Open the cursor and fetch rows, one at a time, in a processing loop.</p>
</li>
<li>
<p>Perform the operations contained in the insert trigger.</p>
</li>
<li>
<p>If the operations succeed, then change the "new data" flag to null.</p>
</li>
<li>
<p>If the operations fail, then change the "new data" flag to "bad data."</p>
</li>
</ol>
</li>
<li>
<p>Execute the stored procedure using an administration tool such as SQL*Plus.</p>
</li>
<li>
<p>After running the procedure, check the table for any rows marked "bad data."</p>
</li>
<li>
<p>Update or remove the bad rows.</p>
</li>
<li>
<p>Reenable the insert trigger.</p>
</li>
</ol>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1342" class="sect2"><a id="sthref1225"></a>
<h3 class="sect2">Permanently Disabled Triggers and Constraints<a id="sthref1226"></a></h3>
<p>SQL*Loader needs to acquire several locks on the table to be loaded to disable triggers and constraints. If a competing process is enabling triggers or constraints at the same time that SQL*Loader is trying to disable them for that table, then SQL*Loader may not be able to acquire exclusive access to the table.<a id="sthref1227"></a><a id="sthref1228"></a></p>
<p>SQL*Loader attempts to handle this situation as gracefully as possible. It attempts to reenable disabled triggers and constraints before exiting. However, the same table-locking problem that made it impossible for SQL*Loader to continue may also have made it impossible for SQL*Loader to finish enabling triggers and constraints. In such cases, triggers and constraints will remain disabled until they are manually enabled.</p>
<p>Although such a situation is unlikely, it is possible. The best way to prevent it is to ensure that no applications are running that could enable triggers or constraints for the table while the direct load is in progress.</p>
<p>If a direct load is terminated due to failure to acquire the proper locks, then carefully check the log. It will show every trigger and constraint that was disabled, and each attempt to reenable them. Any triggers or constraints that were not reenabled by SQL*Loader should be manually enabled with the <code dir="ltr">ENABLE</code> clause of the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement described in <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a><span class="italic">.</span></p>
</div>
<!-- class="sect2" -->
<a id="i1008215"></a>
<div id="SUTIL1343" class="sect2">
<h3 class="sect2">Increasing Performance with <a id="sthref1229"></a><a id="sthref1230"></a>Concurrent Conventional Path Loads</h3>
<p>If triggers or integrity constraints pose a problem, but you want faster loading, then you should consider using concurrent conventional path loads. That is, use multiple load sessions executing concurrently on a multiple-CPU system. Split the input data files into separate files on logical record boundaries, and then load each such input data file with a conventional path load session. The resulting load has the following attributes:</p>
<ul>
<li>
<p>It is faster than a single conventional load on a multiple-CPU system, but probably not as fast as a direct load.</p>
</li>
<li>
<p>Triggers fire, integrity constraints are applied to the loaded rows, and indexes are maintained using the standard DML execution logic<a id="sthref1231"></a><a id="sthref1232"></a><a id="sthref1233"></a>.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008225"></a>
<div id="SUTIL1344" class="sect1">
<h2 class="sect1">Parallel Data Loading Models<a id="sthref1234"></a><a id="sthref1235"></a></h2>
<p>This section discusses three basic models of concurrency that you can use to minimize the elapsed time required for data loading:</p>
<ul>
<li>
<p>Concurrent conventional path loads</p>
</li>
<li>
<p>Intersegment concurrency with the direct path load method</p>
</li>
<li>
<p>Intrasegment concurrency with the direct path load method</p>
</li>
</ul>
<div id="SUTIL1345" class="sect2"><a id="sthref1236"></a>
<h3 class="sect2">Concurrent Conventional Path Loads<a id="sthref1237"></a></h3>
<p>Using multiple conventional path load sessions executing concurrently is discussed in <a href="#i1008215">"Increasing Performance with Concurrent Conventional Path Loads"</a>. You can use this technique to load the same or different objects concurrently with no restrictions.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1346" class="sect2"><a id="sthref1238"></a>
<h3 class="sect2">Intersegment Concurrency with Direct Path</h3>
<p>Intersegment concurrency can be used for concurrent loading of different objects. You can apply this technique to concurrent direct path loading of different tables, or to concurrent direct path loading of different partitions of the same table.</p>
<p>When you direct path load a single partition, consider the following items:</p>
<ul>
<li>
<p>Local indexes can be maintained by the load.</p>
</li>
<li>
<p>Global indexes cannot be maintained by the load.</p>
</li>
<li>
<p>Referential integrity and <code dir="ltr">CHECK</code> constraints must be disabled.</p>
</li>
<li>
<p>Triggers must be disabled.</p>
</li>
<li>
<p>The input data should be partitioned (otherwise many records will be rejected, which adversely affects performance).</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="SUTIL1347" class="sect2"><a id="sthref1239"></a>
<h3 class="sect2">Intrasegment Concurrency with Direct Path<a id="sthref1240"></a><a id="sthref1241"></a></h3>
<p>SQL*Loader permits multiple, concurrent sessions to perform a direct path load into the same table, or into the same partition of a partitioned table. Multiple SQL*Loader sessions improve the performance of a direct path load given the available resources on your system.</p>
<p>This method of data loading is enabled by setting both the <code dir="ltr">DIRECT</code> and the <code dir="ltr">PARALLEL</code> parameters to <code dir="ltr">true</code>, and is often referred to as a parallel direct path load.<span class="italic"><a id="sthref1242"></a></span></p>
<p>It is important to realize that parallelism is user managed. Setting the <code dir="ltr">PARALLEL</code> parameter to <code dir="ltr">true</code> only allows multiple concurrent direct path load sessions.<a id="sthref1243"></a><a id="sthref1244"></a></p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1348" class="sect2"><a id="sthref1245"></a>
<h3 class="sect2">Restrictions on Parallel Direct Path Loads<a id="sthref1246"></a></h3>
<p>The following restrictions are enforced on parallel direct path loads:</p>
<ul>
<li>
<p>Neither local nor global indexes can be maintained by the load.</p>
</li>
<li>
<p>Rows can only be appended. <code dir="ltr">REPLACE</code>, <code dir="ltr">TRUNCATE</code>, and <code dir="ltr">INSERT</code> cannot be used (this is due to the individual loads not being coordinated). If you must truncate a table before a parallel load, then you must do it manually.</p>
</li>
</ul>
<p>Additionally, the following objects must be disabled on parallel direct path loads. You do not have to take any action to disable them. SQL*Loader disables them before the load begins and re-enables them after the load completes:</p>
<ul>
<li>
<p>Referential integrity constraints</p>
</li>
<li>
<p>Triggers</p>
</li>
<li>
<p>CHECK constraints, unless the <code dir="ltr">ENABLE_CHECK_CONSTRAINTS</code> control file option is used</p>
</li>
</ul>
<p>If a parallel direct path load is being applied to a single partition, then you should partition the data first (otherwise, the overhead of record rejection due to a partition mismatch slows down the load).</p>
</div>
<!-- class="sect2" -->
<a id="i1008264"></a>
<div id="SUTIL1349" class="sect2">
<h3 class="sect2">Initiating Multiple SQL*Loader Sessions</h3>
<p>Each SQL*Loader session takes a different data file as input. In all sessions executing a direct load on the same table, you must set <code dir="ltr">PARALLEL</code> to <code dir="ltr">true</code>. The syntax is:</p>
<img width="228" height="58" src="img/parallel.gif" alt="Description of parallel.gif follows" /><br />
<a id="sthref1247" href="img_text/parallel.htm">Description of the illustration ''parallel.gif''</a><br />
<br />
<p><code dir="ltr">PARALLEL</code> can be specified on the command line or in a parameter file. It can also be specified in the control file with the <code dir="ltr">OPTIONS</code> clause.</p>
<p>For example, to invoke three SQL*Loader direct path load sessions on the same table, you would execute each of the following commands at the operating system prompt. After entering each command, you will be prompted for a password.</p>
<pre dir="ltr">
sqlldr USERID=scott CONTROL=load1.ctl DIRECT=TRUE PARALLEL=true
sqlldr USERID=scott CONTROL=load2.ctl DIRECT=TRUE PARALLEL=true
sqlldr USERID=scott CONTROL=load3.ctl DIRECT=TRUE PARALLEL=true
</pre>
<p>The previous commands must be executed in separate sessions, or if permitted on your operating system, as separate background jobs. Note the use of multiple control files. This enables you to be flexible in specifying the files to use for the direct path load.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Indexes are not maintained during a parallel load. Any indexes must be created or re-created manually after the load completes. You can use the parallel index creation or parallel index rebuild feature to speed the building of large indexes after a parallel load.</div>
<p>When you perform a parallel load, SQL*Loader creates temporary segments for each concurrent session and then merges the segments upon completion. The segment created from the merge is then added to the existing segment in the database above the segment's high-water mark. The last extent used of each segment for each loader session is trimmed of any free space before being combined with the other extents of the SQL*Loader session.</p>
</div>
<!-- class="sect2" -->
<a id="i1008282"></a>
<div id="SUTIL1350" class="sect2">
<h3 class="sect2">Parameters for Parallel Direct Path Loads</h3>
<p>When you perform parallel direct path loads, there are options available for specifying attributes of the temporary segment to be allocated by the loader. These options are specified with the <code dir="ltr">FILE</code> and <code dir="ltr">STORAGE</code> parameters. These parameters are valid only for parallel loads.</p>
<div id="SUTIL1351" class="sect3"><a id="sthref1248"></a>
<h4 class="sect3">Using the FILE Parameter to Specify <a id="sthref1249"></a>Temporary Segments</h4>
<p>To allow for maximum I/O throughput, Oracle recommends that each concurrent direct path load session use files located on different disks. In the SQL*Loader control file, use the <code dir="ltr">FILE</code> parameter of the <code dir="ltr">OPTIONS</code> clause to specify the file name of any valid data file in the tablespace of the object (table or partition) being loaded.</p>
<p>For example:</p>
<pre dir="ltr">
LOAD DATA
INFILE 'load1.dat'
INSERT INTO TABLE emp
OPTIONS(FILE='/dat/data1.dat')
(empno POSITION(01:04) INTEGER EXTERNAL NULLIF empno=BLANKS
...
</pre>
<p>You could also specify the <code dir="ltr">FILE</code> parameter on the command line of each concurrent SQL*Loader session, but then it would apply globally to all objects being loaded with that session.<a id="sthref1250"></a><a id="sthref1251"></a><a id="sthref1252"></a></p>
<div id="SUTIL1352" class="sect4"><a id="sthref1253"></a>
<h5 class="sect4">Using the FILE Parameter</h5>
<p>The <code dir="ltr">FILE</code> parameter in the Oracle database has the following restrictions for parallel direct path loads:</p>
<ul>
<li>
<p><span class="bold">For nonpartitioned tables:</span> The specified file must be in the tablespace of the table being loaded.</p>
</li>
<li>
<p><span class="bold">For partitioned tables, single-partition load:</span> The specified file must be in the tablespace of the partition being loaded.</p>
</li>
<li>
<p><span class="bold">For partitioned tables, full-table load:</span> The specified file must be in the tablespace of all partitions being loaded; that is, all partitions must be in the same tablespace.</p>
</li>
</ul>
</div>
<!-- class="sect4" -->
<div id="SUTIL1353" class="sect4"><a id="sthref1254"></a>
<h5 class="sect4">Using the STORAGE Parameter</h5>
<p>You can use the <code dir="ltr"><a id="sthref1255"></a>STORAGE</code> parameter to specify the storage attributes of the temporary segments allocated for a parallel direct path load. If the <code dir="ltr">STORAGE</code> parameter is not used, then the storage attributes of the segment containing the object (table, partition) being loaded are used. Also, when the <code dir="ltr">STORAGE</code> parameter is not specified, SQL*Loader uses a default of 2 KB for <code dir="ltr">EXTENTS</code>.</p>
<p>For example, the following <code dir="ltr">OPTIONS</code> clause could be used to specify <code dir="ltr">STORAGE</code> parameters:</p>
<pre dir="ltr">
OPTIONS (STORAGE=(INITIAL 100M NEXT 100M PCTINCREASE 0))
</pre>
<p>You can use the <code dir="ltr">STORAGE</code> parameter only in the SQL*Loader control file, and not on the command line. Use of the <code dir="ltr">STORAGE</code> parameter to specify anything other than <code dir="ltr">PCTINCREASE</code> of 0, and <code dir="ltr">INITIAL</code> or <code dir="ltr">NEXT</code> values is strongly discouraged and may be silently ignored.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<div id="SUTIL1354" class="sect2"><a id="sthref1256"></a>
<h3 class="sect2"><a id="sthref1257"></a>Enabling Constraints After a Parallel Direct Path Load</h3>
<p>Constraints and triggers must be enabled manually after all data loading is complete.</p>
<p>Because each SQL*Loader session can attempt to reenable constraints on a table after a direct path load, there is a danger that one session may attempt to reenable a constraint before another session is finished loading data. In this case, the first session to complete the load will be unable to enable the constraint because the remaining sessions possess share locks on the table.</p>
<p>Because there is a danger that some constraints might not be reenabled after a direct path load, you should check the status of the constraint after completing the load to ensure that it was enabled properly.</p>
</div>
<!-- class="sect2" -->
<div id="SUTIL1355" class="sect2"><a id="sthref1258"></a>
<h3 class="sect2">PRIMARY KEY and UNIQUE KEY Constraints<a id="sthref1259"></a><a id="sthref1260"></a><a id="sthref1261"></a><a id="sthref1262"></a></h3>
<p><code dir="ltr">PRIMARY</code> <code dir="ltr">KEY</code> and <code dir="ltr">UNIQUE</code> <code dir="ltr">KEY</code> constraints create indexes on a table when they are enabled, and subsequently can take a significantly long time to enable after a direct path loading session if the table is very large. You should consider enabling these constraints manually after a load (and not specifying the automatic enable feature). This enables you to manually create the required indexes in parallel to save time before enabling the constraint.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink PFGRF" href="../e41573/toc.htm"><span class="italic">Oracle Database Performance Tuning Guide</span></a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008335"></a>
<div id="SUTIL1356" class="sect1">
<h2 class="sect1">General Performance Improvement Hints</h2>
<p>If you have control over the format of the data to be loaded, then you can use the following hints to improve load performance:</p>
<ul>
<li>
<p>Make logical record processing efficient.</p>
<ul>
<li>
<p>Use one-to-one mapping of physical records to logical records (avoid using <code dir="ltr">CONTINUEIF</code> and <code dir="ltr">CONCATENATE</code>).</p>
</li>
<li>
<p>Make it easy for the software to identify physical record boundaries. Use the file processing option string <code dir="ltr">"FIX nnn"</code> or <code dir="ltr">"VAR"</code>. If you use the default (stream mode), then on most platforms (for example, UNIX and NT) the loader must scan each physical record for the record terminator (newline character).</p>
</li>
</ul>
</li>
<li>
<p>Make field setting efficient. Field setting is the process of mapping fields in the data file to their corresponding columns in the table being loaded. The mapping function is controlled by the description of the fields in the control file. Field setting (along with data conversion) is the biggest consumer of CPU cycles for most loads<a id="sthref1263"></a>.</p>
<ul>
<li>
<p>Avoid delimited fields; use positional fields. If you use delimited fields, then the loader must scan the input data to find the delimiters. If you use positional fields, then field setting becomes simple pointer arithmetic (very fast).</p>
</li>
<li>
<p>Do not trim whitespace if you do not need to (use <code dir="ltr">PRESERVE</code> <code dir="ltr">BLANKS</code>).</p>
</li>
</ul>
</li>
<li>
<p>Make conversions efficient. SQL*Loader performs character set conversion and datatype conversion for you. Of course, the quickest conversion is no conversion.</p>
<ul>
<li>
<p>Use single-byte character sets if you can.</p>
</li>
<li>
<p>Avoid character set conversions if you can. SQL*Loader supports four character sets:</p>
<ul>
<li>
<p>Client character set (<code dir="ltr">NLS_LANG</code> of the client <code dir="ltr">sqlldr</code> process)</p>
</li>
<li>
<p>Data file character set (usually the same as the client character set)</p>
</li>
<li>
<p>Database character set</p>
</li>
<li>
<p>Database national character set</p>
</li>
</ul>
<p>Performance is optimized if all character sets are the same. For direct path loads, it is best if the data file character set and the database character set are the same. If the character sets are the same, then character set conversion buffers are not allocated.</p>
</li>
</ul>
</li>
<li>
<p>Use direct path loads.</p>
</li>
<li>
<p>Use the <code dir="ltr">SORTED</code> <code dir="ltr">INDEXES</code> clause.</p>
</li>
<li>
<p>Avoid unnecessary <code dir="ltr">NULLIF</code> and <code dir="ltr">DEFAULTIF</code> clauses. Each clause must be evaluated on each column that has a clause associated with it for every row loaded.</p>
</li>
<li>
<p>Use parallel direct path loads and parallel index creation when you can.</p>
</li>
<li>
<p>Be aware of the effect on performance when you have large values for both the <code dir="ltr">CONCATENATE</code> clause and the <code dir="ltr">COLUMNARRAYROWS</code> clause. See <a href="ldr_control_file.htm#i1011559">"Using CONCATENATE to Assemble Logical Records"</a>.</p>
</li>
</ul>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1387">
<tr>
<td class="cellalignment1396">
<table class="cellalignment1392">
<tr>
<td class="cellalignment1391"><a href="ldr_loading.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1391"><a href="part_et.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1398">
<table class="cellalignment1390">
<tr>
<td class="cellalignment1391"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1391"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1391"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1391"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1391"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1391"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
