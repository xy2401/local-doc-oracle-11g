<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Using the Metadata APIs</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1093" />
<meta name="dcterms.created" content="2018-03-26T15:55:18Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Utilities" />
<meta name="dcterms.identifier" content="E22490-08" />
<meta name="dcterms.isVersionOf" content="SUTIL" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="logminer.htm" title="Previous" type="text/html" />
<link rel="Next" href="original_export.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e22490.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">31/36</span> <!-- End Header -->
<div id="SUTIL015" class="chapter"><a id="i1007135"></a>
<h1 class="chapter"><span class="secnum">20</span> Using the Metadata APIs</h1>
<p>This chapter describes use of the Metadata APIs, <code dir="ltr">DBMS_METADATA</code> and <code dir="ltr">DBMS_METADATA_DIFF</code>.</p>
<p>The <code dir="ltr">DBMS_METADATA</code> API enables you to do the following:</p>
<ul>
<li>
<p>Retrieve an object's metadata as XML</p>
</li>
<li>
<p>Transform the XML in a variety of ways, including transforming it into SQL DDL</p>
</li>
<li>
<p>Submit the XML to re-create the object extracted by the retrieval</p>
</li>
</ul>
<p>The <code dir="ltr">DBMS_METADATA_DIFF</code> API lets you compare objects between databases to identify metadata changes over time in objects of the same type.</p>
<p>The following topics are discussed in this chapter:</p>
<ul>
<li>
<p><a href="#i1011012">Why Use the DBMS_METADATA API?</a></p>
</li>
<li>
<p><a href="#i1005591">Overview of the DBMS_METADATA API</a></p>
</li>
<li>
<p><a href="#i1010757">Using the DBMS_METADATA API to Retrieve an Object's Metadata</a></p>
</li>
<li>
<p><a href="#i1013157">Using the DBMS_METADATA API to Re-Create a Retrieved Object</a></p>
</li>
<li>
<p><a href="#i1010810">Using the DBMS_METADATA API to Retrieve Collections of Different Object Types</a></p>
</li>
<li>
<p><a href="#BABIDHGE">Using the DBMS_METADATA_DIFF API to Compare Object Metadata</a></p>
</li>
<li>
<p><a href="#i1010762">Performance Tips for the Programmatic Interface of the DBMS_METADATA API</a></p>
</li>
<li>
<p><a href="#i1011606">Example Usage of the DBMS_METADATA API</a></p>
</li>
<li>
<p><a href="#i1010767">Summary of DBMS_METADATA Procedures</a></p>
</li>
<li>
<p><a href="#BABEADCD">Summary of DBMS_METADATA_DIFF Procedures</a></p>
</li>
</ul>
<a id="i1011012"></a>
<div id="SUTIL1622" class="sect1">
<h2 class="sect1">Why Use the DBMS_METADATA API?</h2>
<p>Over time, as you have used the Oracle database, you may have developed your own code for extracting metadata from the dictionary, manipulating the metadata (adding columns, changing column datatypes, and so on) and then converting the metadata to DDL so that you could re-create the object on the same or another database. Keeping that code updated to support new dictionary features has probably proven to be challenging.</p>
<p>The <code dir="ltr">DBMS_METADATA</code> API eliminates the need for you to write and maintain your own code for metadata extraction. It provides a centralized facility for the extraction, manipulation, and re-creation of dictionary metadata. And it supports all dictionary objects at their most current level.</p>
<p>Although the <code dir="ltr">DBMS_METADATA</code> API can dramatically decrease the amount of custom code you are writing and maintaining, it does not involve any changes to your normal database procedures. The <code dir="ltr">DBMS_METADATA</code> API is installed in the same way as data dictionary views, by running <code dir="ltr">catproc</code>.<code dir="ltr">sql</code> to invoke a SQL script at database installation time. Once it is installed, it is available whenever the instance is operational, even in restricted mode.</p>
<p>The <code dir="ltr">DBMS_METADATA</code> API does not require you to make any source code changes when you change database releases because it is upwardly compatible across different Oracle releases. XML documents retrieved by one release can be processed by the submit interface on the same or later release. For example, XML documents retrieved by an Oracle9<span class="italic">i</span> database can be submitted to Oracle Database 10<span class="italic">g.</span></p>
</div>
<!-- class="sect1" -->
<a id="i1005591"></a>
<div id="SUTIL1623" class="sect1">
<h2 class="sect1">Overview of the DBMS_METADATA API</h2>
<p>For the purposes of the <code dir="ltr">DBMS_METADATA</code> API, every entity in the database is modeled as an object that belongs to an object type. For example, the table <code dir="ltr">scott.emp</code> is an object and its object type is <code dir="ltr">TABLE</code>. When you fetch an object's metadata you must specify the object type.</p>
<p>To fetch a particular object or set of objects within an object type, you specify a filter. Different filters are defined for each object type. For example, two of the filters defined for the <code dir="ltr">TABLE</code> object type are <code dir="ltr">SCHEMA</code> and <code dir="ltr">NAME</code>. They allow you to say, for example, that you want the table whose schema is <code dir="ltr">scott</code> and whose name is <code dir="ltr">emp</code>.</p>
<p>The <code dir="ltr">DBMS_METADATA</code> API makes use of XML (Extensible Markup Language) and XSLT (Extensible Stylesheet Language Transformation). The <code dir="ltr">DBMS_METADATA</code> API represents object metadata as XML because it is a universal format that can be easily parsed and transformed. The <code dir="ltr">DBMS_METADATA</code> API uses XSLT to transform XML documents into either other XML documents or into SQL DDL.</p>
<p>You can use the <code dir="ltr">DBMS_METADATA</code> API to specify one or more transforms (XSLT scripts) to be applied to the XML when the metadata is fetched (or when it is resubmitted). The API provides some predefined transforms, including one named DDL that transforms the XML document into SQL creation DDL.</p>
<p>You can then specify conditions on the transform by using transform parameters. You can also specify optional parse items to access specific attributes of an object's metadata. For more details about all of these options and examples of their implementation, see the following sections:</p>
<ul>
<li>
<p><a href="#i1010757">Using the DBMS_METADATA API to Retrieve an Object's Metadata</a></p>
</li>
<li>
<p><a href="#i1013157">Using the DBMS_METADATA API to Re-Create a Retrieved Object</a></p>
</li>
<li>
<p><a href="#i1010810">Using the DBMS_METADATA API to Retrieve Collections of Different Object Types</a></p>
</li>
</ul>
</div>
<!-- class="sect1" -->
<a id="i1010757"></a>
<div id="SUTIL1624" class="sect1">
<h2 class="sect1">Using the DBMS_METADATA API to Retrieve an Object's Metadata</h2>
<p>The retrieval interface of the <code dir="ltr">DBMS_METADATA</code> API<a id="sthref1739"></a><a id="sthref1740"></a> lets you specify the kind of object to be retrieved. This can be either a particular object type (such as a table, index, or procedure) or a heterogeneous collection of object types that form a logical unit (such as a database export or schema export). By default, metadata that you fetch is returned in an XML document.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
To access objects that are not in your own schema you must have the <code dir="ltr">SELECT_CATALOG_ROLE</code> role. However, roles are disabled within many PL/SQL objects (stored procedures, functions, definer's rights APIs). Therefore, if you are writing a PL/SQL program that will access objects in another schema (or, in general, any objects for which you need the <code dir="ltr">SELECT_CATALOG_ROLE</code> role), then you must put the code in an invoker's rights API.</div>
<p>You can use the programmatic interface for casual browsing, or you can use it to develop applications. You would use the browsing interface if you simply wanted to make ad hoc queries of the system metadata. You would use the programmatic interface when you want to extract dictionary metadata as part of an application. In such cases, the procedures provided by the <code dir="ltr">DBMS_METADATA</code> API can be used in place of SQL scripts and customized code that you may be currently using to do the same thing.</p>
<a id="i1013898"></a>
<div id="SUTIL1625" class="sect2">
<h3 class="sect2">Typical Steps Used for Basic Metadata Retrieval</h3>
<p>When you retrieve metadata, you use the <code dir="ltr">DBMS_METADATA</code> PL/SQL API<a id="sthref1741"></a>. The following examples illustrate the programmatic and browsing interfaces.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#g1029894">Table 20-1</a> for descriptions of <code dir="ltr">DBMS_METADATA</code> procedures used in the programmatic interface</p>
</li>
<li>
<p><a href="#g1030147">Table 20-2</a> for descriptions of <code dir="ltr">DBMS_METADATA</code> procedures used in the browsing interface</p>
</li>
<li>
<p><a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for a complete description of the <code dir="ltr">DBMS_METADATA</code> API.</p>
</li>
</ul>
</div>
<p><a href="#i1013995">Example 20-1</a> provides a basic demonstration of how you might use the <code dir="ltr">DBMS_METADATA</code> programmatic interface to retrieve metadata for one table. It creates a <code dir="ltr">DBMS_METADATA</code> program that creates a function named <code dir="ltr">get_table_md</code>. This function returns metadata for one table.</p>
<div id="SUTIL3618" class="example">
<p class="titleinexample"><a id="i1013995"></a>Example 20-1 Using the DBMS_METADATA Programmatic Interface to Retrieve Data</p>
<ol>
<li>
<p>Create a <code dir="ltr">DBMS_METADATA</code> program that creates a function named <code dir="ltr">get_table_md</code>, which will return the metadata for one table, <code dir="ltr">timecards</code>, in the <code dir="ltr">hr</code> schema. The content of such a program looks as follows. (For this example, name the program <code dir="ltr">metadata_program</code>.<code dir="ltr">sql</code>.)</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION get_table_md RETURN CLOB IS
-- Define local variables.
h NUMBER; --handle returned by OPEN
th NUMBER; -- handle returned by ADD_TRANSFORM
doc CLOB;
BEGIN

-- Specify the object type.
h := DBMS_METADATA.OPEN('TABLE');

-- Use filters to specify the particular object desired.
DBMS_METADATA.SET_FILTER(h,'SCHEMA','HR');
DBMS_METADATA.SET_FILTER(h,'NAME','TIMECARDS');

 -- Request that the metadata be transformed into creation DDL.
th := DBMS_METADATA.ADD_TRANSFORM(h,'DDL');

 -- Fetch the object.
doc := DBMS_METADATA.FETCH_CLOB(h);

 -- Release resources.
DBMS_METADATA.CLOSE(h);
RETURN doc;
END;
/ 
</pre></li>
<li>
<p>Connect as user <code dir="ltr">hr</code>.</p>
</li>
<li>
<p>Run the program to create the <code dir="ltr">get_table_md</code> function:</p>
<p><code dir="ltr">SQL&gt; @metadata_program</code></p>
</li>
<li>
<p>Use the newly created <code dir="ltr">get_table_md</code> function in a select operation. To generate complete, uninterrupted output, set the <code dir="ltr">PAGESIZE</code> to 0 and set <code dir="ltr">LONG</code> to some large number, as shown, before executing your query:</p>
<pre dir="ltr">
SQL&gt; SET PAGESIZE 0
SQL&gt; SET LONG 1000000
SQL&gt; SELECT get_table_md FROM dual;
</pre></li>
<li>
<p>The output, which shows the metadata for the <code dir="ltr">timecards</code> table in the <code dir="ltr">hr</code> schema, looks similar to the following:</p>
<pre dir="ltr">
  CREATE TABLE "HR"."TIMECARDS"
   (    "EMPLOYEE_ID" NUMBER(6,0),
        "WEEK" NUMBER(2,0),
        "JOB_ID" VARCHAR2(10),
        "HOURS_WORKED" NUMBER(4,2),
         FOREIGN KEY ("EMPLOYEE_ID")
          REFERENCES "HR"."EMPLOYEES" ("EMPLOYEE_ID") ENABLE
   ) PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING
  STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645
  PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT)
  TABLESPACE "EXAMPLE"
</pre></li>
</ol>
</div>
<!-- class="example" -->
<p>You can use the browsing interface and get the same results, as shown in <a href="#i1014058">Example 20-2</a>.</p>
<div id="SUTIL3619" class="example">
<p class="titleinexample"><a id="i1014058"></a>Example 20-2 Using the DBMS_METADATA Browsing Interface to Retrieve Data</p>
<pre dir="ltr">
SQL&gt; SET PAGESIZE 0
SQL&gt; SET LONG 1000000
SQL&gt; SELECT DBMS_METADATA.GET_DDL('TABLE','TIMECARDS','HR') FROM dual;
</pre>
<p>The results will be the same as shown in step 5 for <a href="#i1013995">Example 20-1</a>.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1013903"></a>
<div id="SUTIL1626" class="sect2">
<h3 class="sect2">Retrieving Multiple Objects</h3>
<p>In <a href="#i1013995">Example 20-1</a>, the <code dir="ltr">FETCH_CLOB</code> procedure was called only once, because it was known that there was only one object. However, you can also retrieve multiple objects, for example, all the tables in schema <code dir="ltr">scott</code>. To do this, you need to use the following construct:</p>
<pre dir="ltr">
  LOOP
    doc := DBMS_METADATA.FETCH_CLOB(h);
    --
    -- When there are no more objects to be retrieved, FETCH_CLOB returns NULL.
    --
    EXIT WHEN doc IS NULL;
  END LOOP;
</pre>
<p><a href="#i1014062">Example 20-3</a> demonstrates use of this construct and retrieving multiple objects. Connect as user <code dir="ltr">scott</code> for this example. The password is <code dir="ltr">tiger</code>.</p>
<div id="SUTIL3620" class="example">
<p class="titleinexample"><a id="i1014062"></a>Example 20-3 Retrieving Multiple Objects</p>
<ol>
<li>
<p>Create a table named <code dir="ltr">my_metadata</code> and a procedure named <code dir="ltr">get_tables_md</code>, as follows. Because not all objects can be returned, they are stored in a table and queried at the end.</p>
<pre dir="ltr">
DROP TABLE my_metadata;
CREATE TABLE my_metadata (md clob);
CREATE OR REPLACE PROCEDURE get_tables_md IS
-- Define local variables
h       NUMBER;         -- handle returned by 'OPEN'
th      NUMBER;         -- handle returned by 'ADD_TRANSFORM'
doc     CLOB;           -- metadata is returned in a CLOB
BEGIN

 -- Specify the object type.
 h := DBMS_METADATA.OPEN('TABLE');

 -- Use filters to specify the schema.
 DBMS_METADATA.SET_FILTER(h,'SCHEMA','SCOTT');

 -- Request that the metadata be transformed into creation DDL.
 th := DBMS_METADATA.ADD_TRANSFORM(h,'DDL');

 -- Fetch the objects.
 LOOP
   doc := DBMS_METADATA.FETCH_CLOB(h);

  -- When there are no more objects to be retrieved, FETCH_CLOB returns NULL.
   EXIT WHEN doc IS NULL;

   -- Store the metadata in a table.
   INSERT INTO my_metadata(md) VALUES (doc);
   COMMIT;
 END LOOP;
 
 -- Release resources.
 DBMS_METADATA.CLOSE(h);
END;
/
</pre></li>
<li>
<p>Execute the procedure:</p>
<pre dir="ltr">
EXECUTE get_tables_md;
</pre></li>
<li>
<p>Query the <code dir="ltr">my_metadata</code> table to see what was retrieved:</p>
<pre dir="ltr">
SET LONG 9000000
SET PAGES 0
SELECT * FROM my_metadata;
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1014301"></a>
<div id="SUTIL1627" class="sect2">
<h3 class="sect2">Placing Conditions on Transforms</h3>
<p>You can use transform parameters to specify conditions on the transforms you add. To do this, you use the <code dir="ltr">SET_TRANSFORM_PARAM</code> procedure. For example, if you have added the <code dir="ltr">DDL</code> transform for a <code dir="ltr">TABLE</code> object, then you can specify the <code dir="ltr">SEGMENT_ATTRIBUTES</code> transform parameter to indicate that you do not want segment attributes (physical, storage, logging, and so on) to appear in the DDL. The default is that segment attributes do appear in the DDL.</p>
<p><a href="#i1014066">Example 20-4</a> shows use of the <code dir="ltr">SET_TRANSFORM_PARAM</code> procedure.</p>
<div id="SUTIL3621" class="example">
<p class="titleinexample"><a id="i1014066"></a>Example 20-4 Placing Conditions on Transforms</p>
<ol>
<li>
<p>Create a function named <code dir="ltr">get_table_md</code>, as follows:</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION get_table_md RETURN CLOB IS
 -- Define local variables.
 h    NUMBER;   -- handle returned by 'OPEN'
 th   NUMBER;   -- handle returned by 'ADD_TRANSFORM'
 doc  CLOB;
BEGIN

 -- Specify the object type. 
 h := DBMS_METADATA.OPEN('TABLE');

 -- Use filters to specify the particular object desired.
 DBMS_METADATA.SET_FILTER(h,'SCHEMA','HR');
 DBMS_METADATA.SET_FILTER(h,'NAME','TIMECARDS');

 -- Request that the metadata be transformed into creation DDL.
 th := dbms_metadata.add_transform(h,'DDL');

 -- Specify that segment attributes are not to be returned.
 -- Note that this call uses the TRANSFORM handle, not the OPEN handle.
DBMS_METADATA.SET_TRANSFORM_PARAM(th,'SEGMENT_ATTRIBUTES',false);

 -- Fetch the object.
 doc := DBMS_METADATA.FETCH_CLOB(h);

 -- Release resources.
 DBMS_METADATA.CLOSE(h);

 RETURN doc;
END;
/
</pre></li>
<li>
<p>Perform the following query:</p>
<pre dir="ltr">
SQL&gt; SELECT get_table_md FROM dual;
</pre>
<p>The output looks similar to the following:</p>
<pre dir="ltr">
  CREATE TABLE "HR"."TIMECARDS"
   (    "EMPLOYEE_ID" NUMBER(6,0),
        "WEEK" NUMBER(2,0),
        "JOB_ID" VARCHAR2(10),
        "HOURS_WORKED" NUMBER(4,2),
         FOREIGN KEY ("EMPLOYEE_ID")
          REFERENCES "HR"."EMPLOYEES" ("EMPLOYEE_ID") ENABLE
   )
</pre></li>
</ol>
<p>The examples shown up to this point have used a single transform, the <code dir="ltr">DDL</code> transform. The <code dir="ltr">DBMS_METADATA</code> API also enables you to specify multiple transforms, with the output of the first being the input to the next and so on.</p>
<p>Oracle supplies a transform called <code dir="ltr">MODIFY</code> that modifies an XML document. You can do things like change schema names or tablespace names. To do this, you use remap parameters and the <code dir="ltr">SET_REMAP_PARAM</code> procedure.</p>
<p><a href="#i1014070">Example 20-5</a> shows a sample use of the <code dir="ltr">SET_REMAP_PARAM</code> procedure. It first adds the <code dir="ltr">MODIFY</code> transform and specifies remap parameters to change the schema name from <code dir="ltr">hr</code> to <code dir="ltr">scott</code>. It then adds the <code dir="ltr">DDL</code> transform. The output of the <code dir="ltr">MODIFY</code> transform is an XML document that becomes the input to the <code dir="ltr">DDL</code> transform. The end result is the creation DDL for the <code dir="ltr">timecards</code> table with all instances of schema <code dir="ltr">hr</code> changed to <code dir="ltr">scott</code>.</p>
</div>
<!-- class="example" -->
<div id="SUTIL3622" class="example">
<p class="titleinexample"><a id="i1014070"></a>Example 20-5 Modifying an XML Document</p>
<ol>
<li>
<p>Create a function named remap_schema:</p>
<pre dir="ltr">
CREATE OR REPLACE FUNCTION remap_schema RETURN CLOB IS
-- Define local variables.
h NUMBER; --handle returned by OPEN
th NUMBER; -- handle returned by ADD_TRANSFORM
doc CLOB;
BEGIN

-- Specify the object type.
h := DBMS_METADATA.OPEN('TABLE');

-- Use filters to specify the particular object desired.
DBMS_METADATA.SET_FILTER(h,'SCHEMA','HR');
DBMS_METADATA.SET_FILTER(h,'NAME','TIMECARDS');

-- Request that the schema name be modified.
th := DBMS_METADATA.ADD_TRANSFORM(h,'MODIFY');
DBMS_METADATA.SET_REMAP_PARAM(th,'REMAP_SCHEMA','HR','SCOTT');

-- Request that the metadata be transformed into creation DDL.
th := DBMS_METADATA.ADD_TRANSFORM(h,'DDL');

-- Specify that segment attributes are not to be returned.
DBMS_METADATA.SET_TRANSFORM_PARAM(th,'SEGMENT_ATTRIBUTES',false);

-- Fetch the object.
doc := DBMS_METADATA.FETCH_CLOB(h);

-- Release resources.
DBMS_METADATA.CLOSE(h);
RETURN doc;
END;
/ 
</pre></li>
<li>
<p>Perform the following query:</p>
<pre dir="ltr">
SELECT remap_schema FROM dual;
</pre>
<p>The output looks similar to the following:</p>
<pre dir="ltr">
  CREATE TABLE "SCOTT"."TIMECARDS"
   (    "EMPLOYEE_ID" NUMBER(6,0),
        "WEEK" NUMBER(2,0),
        "JOB_ID" VARCHAR2(10),
        "HOURS_WORKED" NUMBER(4,2),
         FOREIGN KEY ("EMPLOYEE_ID")
          REFERENCES "SCOTT"."EMPLOYEES" ("EMPLOYEE_ID") ENABLE
   )
</pre>
<p>If you are familiar with XSLT, then you can add your own user-written transforms to process the XML.</p>
</li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" -->
<a id="i1013913"></a>
<div id="SUTIL1628" class="sect2">
<h3 class="sect2">Accessing Specific Metadata Attributes</h3>
<p>It is often desirable to access specific attributes of an object's metadata, for example, its name or schema. You could get this information by parsing the returned metadata, but the <code dir="ltr">DBMS_METADATA</code> API provides another mechanism; you can specify parse items, specific attributes that will be parsed out of the metadata and returned in a separate data structure. To do this, you use the <code dir="ltr">SET_PARSE_ITEM</code> procedure.</p>
<p><a href="#i1014074">Example 20-6</a> fetches all tables in a schema. For each table, a parse item is used to get its name. The name is then used to get all indexes on the table. The example illustrates the use of the <code dir="ltr">FETCH_DDL</code> function, which returns metadata in a <code dir="ltr">sys</code>.<code dir="ltr">ku$_ddls</code> object.</p>
<p>This example assumes you are connected to a schema that contains some tables and indexes. It also creates a table named <code dir="ltr">my_metadata</code>.</p>
<div id="SUTIL3623" class="example">
<p class="titleinexample"><a id="i1014074"></a>Example 20-6 Using Parse Items to Access Specific Metadata Attributes</p>
<ol>
<li>
<p>Create a table named <code dir="ltr">my_metadata</code> and a procedure named <code dir="ltr">get_tables_and_indexes</code>, as follows:</p>
<pre dir="ltr">
DROP TABLE my_metadata;
CREATE TABLE my_metadata (
  object_type   VARCHAR2(30),
  name          VARCHAR2(30),
  md            CLOB);
CREATE OR REPLACE PROCEDURE get_tables_and_indexes IS
-- Define local variables.
h1      NUMBER;         -- handle returned by OPEN for tables
h2      NUMBER;         -- handle returned by OPEN for indexes
th1     NUMBER;         -- handle returned by ADD_TRANSFORM for tables
th2     NUMBER;         -- handle returned by ADD_TRANSFORM for indexes
doc     sys.ku$_ddls;   -- metadata is returned in sys.ku$_ddls,
                        --  a nested table of sys.ku$_ddl objects
ddl     CLOB;           -- creation DDL for an object
pi      sys.ku$_parsed_items;   -- parse items are returned in this object
                                -- which is contained in sys.ku$_ddl
objname VARCHAR2(30);   -- the parsed object name
idxddls sys.ku$_ddls;   -- metadata is returned in sys.ku$_ddls,
                        --  a nested table of sys.ku$_ddl objects
idxname VARCHAR2(30);   -- the parsed index name
BEGIN
 -- This procedure has an outer loop that fetches tables,
 -- and an inner loop that fetches indexes.
 
 -- Specify the object type: TABLE.
 h1 := DBMS_METADATA.OPEN('TABLE');
 
 -- Request that the table name be returned as a parse item.
 DBMS_METADATA.SET_PARSE_ITEM(h1,'NAME');
 
 -- Request that the metadata be transformed into creation DDL.
 th1 := DBMS_METADATA.ADD_TRANSFORM(h1,'DDL');
 
 -- Specify that segment attributes are not to be returned.
 DBMS_METADATA.SET_TRANSFORM_PARAM(th1,'SEGMENT_ATTRIBUTES',false);
 
 -- Set up the outer loop: fetch the TABLE objects.
 LOOP
   doc := dbms_metadata.fetch_ddl(h1);
 
-- When there are no more objects to be retrieved, FETCH_DDL returns NULL.
   EXIT WHEN doc IS NULL;
 
-- Loop through the rows of the ku$_ddls nested table.
   FOR i IN doc.FIRST..doc.LAST LOOP
     ddl := doc(i).ddlText;
     pi := doc(i).parsedItems;
     -- Loop through the returned parse items.
     IF pi IS NOT NULL AND pi.COUNT &gt; 0 THEN
       FOR j IN pi.FIRST..pi.LAST LOOP
         IF pi(j).item='NAME' THEN
           objname := pi(j).value;
         END IF;
       END LOOP;
     END IF;
     -- Insert information about this object into our table.
     INSERT INTO my_metadata(object_type, name, md)
       VALUES ('TABLE',objname,ddl);
     COMMIT;
   END LOOP;
 
   -- Now fetch indexes using the parsed table name as
   --  a BASE_OBJECT_NAME filter.
 
   -- Specify the object type.
   h2 := DBMS_METADATA.OPEN('INDEX');
 
   -- The base object is the table retrieved in the outer loop.
   DBMS_METADATA.SET_FILTER(h2,'BASE_OBJECT_NAME',objname);
 
   -- Exclude system-generated indexes.
   DBMS_METADATA.SET_FILTER(h2,'SYSTEM_GENERATED',false);
 
   -- Request that the index name be returned as a parse item.
   DBMS_METADATA.SET_PARSE_ITEM(h2,'NAME');
 
   -- Request that the metadata be transformed into creation DDL.
   th2 := DBMS_METADATA.ADD_TRANSFORM(h2,'DDL');
 
   -- Specify that segment attributes are not to be returned.
   DBMS_METADATA.SET_TRANSFORM_PARAM(th2,'SEGMENT_ATTRIBUTES',false);
  
 
   LOOP
    idxddls := dbms_metadata.fetch_ddl(h2);
 
    -- When there are no more objects to  be retrieved, FETCH_DDL returns NULL.
    EXIT WHEN idxddls IS NULL;
 
      FOR i in idxddls.FIRST..idxddls.LAST LOOP
        ddl := idxddls(i).ddlText;
        pi  := idxddls(i).parsedItems;
        -- Loop through the returned parse items.
        IF pi IS NOT NULL AND pi.COUNT &gt; 0 THEN
          FOR j IN pi.FIRST..pi.LAST LOOP
            IF pi(j).item='NAME' THEN
              idxname := pi(j).value;
            END IF;
          END LOOP;
         END IF;
   
         -- Store the metadata in our table.
          INSERT INTO my_metadata(object_type, name, md)
            VALUES ('INDEX',idxname,ddl);
         COMMIT;
       END LOOP;  -- for loop
  END LOOP;
  DBMS_METADATA.CLOSE(h2);
 END LOOP;
 DBMS_METADATA.CLOSE(h1);
END;
/
</pre></li>
<li>
<p>Execute the procedure:</p>
<pre dir="ltr">
EXECUTE get_tables_and_indexes;
</pre></li>
<li>
<p>Perform the following query to see what was retrieved:</p>
<pre dir="ltr">
SET LONG 9000000
SET PAGES 0
SELECT * FROM my_metadata;
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1013157"></a>
<div id="SUTIL1629" class="sect1">
<h2 class="sect1">Using the DBMS_METADATA API to Re-Create a Retrieved Object</h2>
<p>When you fetch metadata for an object, you may want to use it to re-create the object in a different database or schema.</p>
<p>You may not be ready to make remapping decisions when you fetch the metadata. You may want to defer these decisions until later. To accomplish this, you fetch the metadata as XML and store it in a file or table. Later you can use the submit interface to re-create the object.</p>
<p>The submit interface is similar in form to the retrieval interface. It has an <code dir="ltr">OPENW</code> procedure in which you specify the object type of the object to be created. You can specify transforms, transform parameters, and parse items. You can call the <code dir="ltr">CONVERT</code> function to convert the XML to DDL, or you can call the <code dir="ltr">PUT</code> function to both convert XML to DDL and submit the DDL to create the object.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#g1030301">Table 20-3</a> for descriptions of <code dir="ltr">DBMS_METADATA</code> procedures and functions used in the submit interface</div>
<p><a href="#i1014078">Example 20-7</a> fetches the XML for a table in one schema, and then uses the submit interface to re-create the table in another schema.</p>
<div id="SUTIL3624" class="example">
<p class="titleinexample"><a id="i1014078"></a>Example 20-7 Using the Submit Interface to Re-Create a Retrieved Object</p>
<ol>
<li>
<p>Connect as a privileged user:</p>
<pre dir="ltr">
CONNECT system
Enter password: <span class="italic">password</span>
</pre></li>
<li>
<p>Create an invoker's rights package to hold the procedure because access to objects in another schema requires the <code dir="ltr">SELECT_CATALOG_ROLE</code> role. In a definer's rights PL/SQL object (such as a procedure or function), roles are disabled.</p>
<pre dir="ltr">
CREATE OR REPLACE PACKAGE example_pkg AUTHID current_user IS
  PROCEDURE move_table(
        table_name  in VARCHAR2,
        from_schema in VARCHAR2,
        to_schema   in VARCHAR2 );
END example_pkg;
/
CREATE OR REPLACE PACKAGE BODY example_pkg IS
PROCEDURE move_table(
        table_name  in VARCHAR2,
        from_schema in VARCHAR2,
        to_schema   in VARCHAR2 ) IS

-- Define local variables.
h1      NUMBER;         -- handle returned by OPEN
h2      NUMBER;         -- handle returned by OPENW
th1     NUMBER;         -- handle returned by ADD_TRANSFORM for MODIFY
th2     NUMBER;         -- handle returned by ADD_TRANSFORM for DDL
xml     CLOB;           -- XML document
errs    sys.ku$_SubmitResults := sys.ku$_SubmitResults();
err     sys.ku$_SubmitResult;
result  BOOLEAN;
BEGIN

-- Specify the object type.
h1 := DBMS_METADATA.OPEN('TABLE');

-- Use filters to specify the name and schema of the table.
DBMS_METADATA.SET_FILTER(h1,'NAME',table_name);
DBMS_METADATA.SET_FILTER(h1,'SCHEMA',from_schema);

-- Fetch the XML.
xml := DBMS_METADATA.FETCH_CLOB(h1);
IF xml IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('Table ' || from_schema || '.' || table_name
|| ' not found');
    RETURN;
  END IF;

-- Release resources.
DBMS_METADATA.CLOSE(h1);

-- Use the submit interface to re-create the object in another schema.

-- Specify the object type using OPENW (instead of OPEN).
h2 := DBMS_METADATA.OPENW('TABLE');

-- First, add the MODIFY transform.
th1 := DBMS_METADATA.ADD_TRANSFORM(h2,'MODIFY');

-- Specify the desired modification: remap the schema name.
DBMS_METADATA.SET_REMAP_PARAM(th1,'REMAP_SCHEMA',from_schema,to_schema);

-- Now add the DDL transform so that the modified XML can be
--  transformed into creation DDL.
th2 := DBMS_METADATA.ADD_TRANSFORM(h2,'DDL');

-- Call PUT to re-create the object.
result := DBMS_METADATA.PUT(h2,xml,0,errs);

DBMS_METADATA.CLOSE(h2);
  IF NOT result THEN
    -- Process the error information.
    FOR i IN errs.FIRST..errs.LAST LOOP
      err := errs(i);
      FOR j IN err.errorLines.FIRST..err.errorLines.LAST LOOP
        dbms_output.put_line(err.errorLines(j).errorText);
      END LOOP;
    END LOOP;
  END IF;
END;
END example_pkg;
/
</pre></li>
<li>
<p>Now create a table named <code dir="ltr">my_example</code> in the schema <code dir="ltr">SCOTT</code>:</p>
<pre dir="ltr">
CONNECT scott
Enter password:
-- The password is tiger.

DROP TABLE my_example;
CREATE TABLE my_example (a NUMBER, b VARCHAR2(30));

CONNECT system
Enter password: <span class="italic">password</span>

SET LONG 9000000
SET PAGESIZE 0
SET SERVEROUTPUT ON SIZE 100000
</pre></li>
<li>
<p>Copy the <code dir="ltr">my_example</code> table to the <code dir="ltr">SYSTEM</code> schema:</p>
<pre dir="ltr">
DROP TABLE my_example;
EXECUTE example_pkg.move_table('MY_EXAMPLE','SCOTT','SYSTEM');
</pre></li>
<li>
<p>Perform the following query to verify that it worked:</p>
<pre dir="ltr">
SELECT DBMS_METADATA.GET_DDL('TABLE','MY_EXAMPLE') FROM dual;
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i1010810"></a>
<div id="SUTIL1630" class="sect1">
<h2 class="sect1">Using the DBMS_METADATA API to Retrieve Collections of Different Object Types</h2>
<p>There may be times when you need to retrieve<a id="sthref1742"></a> collections of objects in which the objects are of different types, but comprise a logical unit. For example, you might need to retrieve all the objects in a database or a schema, or a table and all its dependent indexes, constraints, grants, audits, and so on. To make such a retrieval possible, the <code dir="ltr">DBMS_METADATA</code> API provides several heterogeneous object types. A heterogeneous object type is an ordered set of object types.</p>
<p>Oracle supplies the following heterogeneous object types:</p>
<ul>
<li>
<p><code dir="ltr">TABLE_EXPORT</code> - a table and its dependent objects</p>
</li>
<li>
<p><code dir="ltr">SCHEMA_EXPORT</code> - a schema and its contents</p>
</li>
<li>
<p><code dir="ltr">DATABASE_EXPORT</code> - the objects in the database</p>
</li>
</ul>
<p>These object types were developed for use by the Data Pump Export utility, but you can use them in your own applications.</p>
<p>You can use only the programmatic retrieval interface (<code dir="ltr">OPEN</code>, <code dir="ltr">FETCH</code>, <code dir="ltr">CLOSE</code>) with these types, not the browsing interface or the submit interface.</p>
<p>You can specify filters for heterogeneous object types, just as you do for the homogeneous types. For example, you can specify the <code dir="ltr">SCHEMA</code> and <code dir="ltr">NAME</code> filters for <code dir="ltr">TABLE_EXPORT</code>, or the <code dir="ltr">SCHEMA</code> filter for <code dir="ltr">SCHEMA_EXPORT</code>.</p>
<p><a href="#i1014082">Example 20-8</a> shows how to retrieve the object types in the <code dir="ltr">scott</code> schema. Connect as user <code dir="ltr">scott</code>. The password is <code dir="ltr">tiger</code>.</p>
<div id="SUTIL3625" class="example">
<p class="titleinexample"><a id="i1014082"></a>Example 20-8 Retrieving Heterogeneous Object Types</p>
<ol>
<li>
<p>Create a table to store the retrieved objects:</p>
<pre dir="ltr">
DROP TABLE my_metadata;
CREATE TABLE my_metadata (md CLOB);
CREATE OR REPLACE PROCEDURE get_schema_md IS

-- Define local variables.
h       NUMBER;         -- handle returned by OPEN
th      NUMBER;         -- handle returned by ADD_TRANSFORM
doc     CLOB;           -- metadata is returned in a CLOB
BEGIN

-- Specify the object type.
 h := DBMS_METADATA.OPEN('SCHEMA_EXPORT');

 -- Use filters to specify the schema.
 DBMS_METADATA.SET_FILTER(h,'SCHEMA','SCOTT');

 -- Request that the metadata be transformed into creation DDL.
 th := DBMS_METADATA.ADD_TRANSFORM(h,'DDL');

 -- Fetch the objects.
 LOOP
   doc := DBMS_METADATA.FETCH_CLOB(h);

   -- When there are no more objects to be retrieved, FETCH_CLOB returns NULL.
   EXIT WHEN doc IS NULL;

   -- Store the metadata in the table.
   INSERT INTO my_metadata(md) VALUES (doc);
   COMMIT;
 END LOOP;
 
 -- Release resources.
 DBMS_METADATA.CLOSE(h);
END;
/
</pre></li>
<li>
<p>Execute the procedure:</p>
<pre dir="ltr">
EXECUTE get_schema_md;
</pre></li>
<li>
<p>Perform the following query to see what was retrieved:</p>
<pre dir="ltr">
SET LONG 9000000
SET PAGESIZE 0
SELECT * FROM my_metadata;
</pre></li>
</ol>
<p>In this example, objects are returned ordered by object type; for example, all tables are returned, then all grants on tables, then all indexes on tables, and so on. The order is, generally speaking, a valid creation order. Thus, if you take the objects in the order in which they were returned and use the submit interface to re-create them in the same order in another schema or database, then there will usually be no errors. (The exceptions usually involve circular references; for example, if package A contains a call to package B, and package B contains a call to package A, then one of the packages will need to be recompiled a second time.)</p>
</div>
<!-- class="example" -->
<div id="SUTIL1631" class="sect2"><a id="sthref1743"></a>
<h3 class="sect2">Filtering the Return of Heterogeneous Object Types</h3>
<p>If you want finer control of the objects returned, then you can use the <code dir="ltr">SET_FILTER</code> procedure and specify that the filter apply only to a specific member type. You do this by specifying the path name of the member type as the fourth parameter to <code dir="ltr">SET_FILTER</code>. In addition, you can use the <code dir="ltr">EXCLUDE_PATH_EXPR</code> filter to exclude all objects of an object type. For a list of valid path names, see the <code dir="ltr">TABLE_EXPORT_OBJECTS</code> catalog view.</p>
<p><a href="#i1014087">Example 20-9</a> shows how you can use <code dir="ltr">SET_FILTER</code> to specify finer control on the objects returned. Connect as user <code dir="ltr">scott</code>. The password is <code dir="ltr">tiger</code>.</p>
<div id="SUTIL3626" class="example">
<p class="titleinexample"><a id="i1014087"></a>Example 20-9 Filtering the Return of Heterogeneous Object Types</p>
<ol>
<li>
<p>Create a table, <code dir="ltr">my_metadata</code>, to store the retrieved objects. And create a procedure, <code dir="ltr">get_schema_md2</code>.</p>
<pre dir="ltr">
DROP TABLE my_metadata;
CREATE TABLE my_metadata (md CLOB);
CREATE OR REPLACE PROCEDURE get_schema_md2 IS

-- Define local variables.
h       NUMBER;         -- handle returned by 'OPEN'
th      NUMBER;         -- handle returned by 'ADD_TRANSFORM'
doc     CLOB;           -- metadata is returned in a CLOB
BEGIN

 -- Specify the object type.
 h := DBMS_METADATA.OPEN('SCHEMA_EXPORT');

 -- Use filters to specify the schema.
 DBMS_METADATA.SET_FILTER(h,'SCHEMA','SCOTT');

 -- Use the fourth parameter to SET_FILTER to specify a filter
 -- that applies to a specific member object type.
 DBMS_METADATA.SET_FILTER(h,'NAME_EXPR','!=''MY_METADATA''','TABLE');

 -- Use the EXCLUDE_PATH_EXPR filter to exclude procedures.
 DBMS_METADATA.SET_FILTER(h,'EXCLUDE_PATH_EXPR','=''PROCEDURE''');

 -- Request that the metadata be transformed into creation DDL.
 th := DBMS_METADATA.ADD_TRANSFORM(h,'DDL');

 -- Use the fourth parameter to SET_TRANSFORM_PARAM to specify a parameter
 --  that applies to a specific member object type.
DBMS_METADATA.SET_TRANSFORM_PARAM(th,'SEGMENT_ATTRIBUTES',false,'TABLE');

 -- Fetch the objects.
 LOOP
   doc := dbms_metadata.fetch_clob(h);

   -- When there are no more objects to be retrieved, FETCH_CLOB returns NULL.
   EXIT WHEN doc IS NULL;

   -- Store the metadata in the table.
   INSERT INTO my_metadata(md) VALUES (doc);
   COMMIT;
 END LOOP;
 
 -- Release resources.
 DBMS_METADATA.CLOSE(h);
END;
/
</pre></li>
<li>
<p>Execute the procedure:</p>
<pre dir="ltr">
EXECUTE get_schema_md2;
</pre></li>
<li>
<p>Perform the following query to see what was retrieved:</p>
<pre dir="ltr">
SET LONG 9000000
SET PAGESIZE 0
SELECT * FROM my_metadata;
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="BABIDHGE"></a>
<div id="SUTIL3627" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Using the DBMS_METADATA_DIFF API to Compare Object Metadata</h2>
<p>This section provides an example that uses the retrieval, comparison, and submit interfaces of <code dir="ltr">DBMS_METADATA</code> and <code dir="ltr">DBMS_METADATA_DIFF</code> to fetch metadata for two tables, compare the metadata, and generate <code dir="ltr">ALTER</code> statements which make one table like the other. For simplicity, function variants are used throughout the example.</p>
<div id="SUTIL3628" class="example">
<p class="titleinexample"><a id="sthref1744"></a>Example 20-10 Comparing Object Metadata</p>
<ol>
<li>
<p>Create two tables, <code dir="ltr">TAB1</code> and <code dir="ltr">TAB2</code>:</p>
<pre dir="ltr">
SQL&gt; CREATE TABLE TAB1
  2     (    "EMPNO" NUMBER(4,0),
  3          "ENAME" VARCHAR2(10),
  4          "JOB" VARCHAR2(9),
  5          "DEPTNO" NUMBER(2,0)
  6     ) ;
 
Table created.
 
SQL&gt; CREATE TABLE TAB2
  2     (    "EMPNO" NUMBER(4,0) PRIMARY KEY ENABLE,
  3          "ENAME" VARCHAR2(20),
  4          "MGR" NUMBER(4,0),
  5          "DEPTNO" NUMBER(2,0)
  6     ) ;
 
Table created.
 
</pre>
<p>Note the differences between <code dir="ltr">TAB1</code> and <code dir="ltr">TAB2</code>:</p>
<ul>
<li>
<p>The table names are different</p>
</li>
<li>
<p><code dir="ltr">TAB2</code> has a primary key constraint; <code dir="ltr">TAB1</code> does not</p>
</li>
<li>
<p>The length of the <code dir="ltr">ENAME</code> column is different in each table</p>
</li>
<li>
<p><code dir="ltr">TAB1</code> has a <code dir="ltr">JOB</code> column; <code dir="ltr">TAB2</code> does not</p>
</li>
<li>
<p><code dir="ltr">TAB2</code> has a <code dir="ltr">MGR</code> column; <code dir="ltr">TAB1</code> does not</p>
</li>
</ul>
</li>
<li>
<p>Create a function to return the table metadata in SXML format. The following are some key points to keep in mind about SXML when you are using the <code dir="ltr">DBMS_METADATA_DIFF</code> API:</p>
<ul>
<li>
<p>SXML is an XML representation of object metadata.</p>
</li>
<li>
<p>The SXML returned is not the same as the XML returned by <code dir="ltr">DBMS_METADATA.GET_XML</code>, which is complex and opaque and contains binary values, instance-specific values, and so on.</p>
</li>
<li>
<p>SXML looks like a direct translation of SQL creation DDL into XML. The tag names and structure correspond to names in the <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
</li>
<li>
<p>SXML is designed to support editing and comparison.</p>
</li>
</ul>
<p>To keep this example simple, a transform parameter is used to suppress physical properties:</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE FUNCTION get_table_sxml(name IN VARCHAR2) RETURN CLOB IS
  2   open_handle NUMBER;
  3   transform_handle NUMBER;
  4   doc CLOB;
  5  BEGIN
  6   open_handle := DBMS_METADATA.OPEN('TABLE');
  7   DBMS_METADATA.SET_FILTER(open_handle,'NAME',name);
  8   --
  9   -- Use the 'SXML' transform to convert XML to SXML
 10   --
 11   transform_handle := DBMS_METADATA.ADD_TRANSFORM(open_handle,'SXML');
 12   --
 13   -- Use this transform parameter to suppress physical properties
 14   --
 15   DBMS_METADATA.SET_TRANSFORM_PARAM(transform_handle,'PHYSICAL_PROPERTIES',
 16                                     FALSE);
 17   doc := DBMS_METADATA.FETCH_CLOB(open_handle);
 18   DBMS_METADATA.CLOSE(open_handle);
 19   RETURN doc;
 20  END;
 21  /
 
Function created.
 
</pre></li>
<li>
<p>Use the <code dir="ltr">get_table_sxml</code> function to fetch the table SXML for the two tables:</p>
<pre dir="ltr">
SQL&gt; SELECT get_table_sxml('TAB1') FROM dual;
 
  &lt;TABLE xmlns="http://xmlns.oracle.com/ku" version="1.0"&gt;
   &lt;SCHEMA&gt;SCOTT&lt;/SCHEMA&gt;
   &lt;NAME&gt;TAB1&lt;/NAME&gt;
   &lt;RELATIONAL_TABLE&gt;
      &lt;COL_LIST&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;EMPNO&lt;/NAME&gt;
            &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
            &lt;PRECISION&gt;4&lt;/PRECISION&gt;
            &lt;SCALE&gt;0&lt;/SCALE&gt;
         &lt;/COL_LIST_ITEM&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;ENAME&lt;/NAME&gt;
            &lt;DATATYPE&gt;VARCHAR2&lt;/DATATYPE&gt;
            &lt;LENGTH&gt;10&lt;/LENGTH&gt;
         &lt;/COL_LIST_ITEM&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;JOB&lt;/NAME&gt;
            &lt;DATATYPE&gt;VARCHAR2&lt;/DATATYPE&gt;
            &lt;LENGTH&gt;9&lt;/LENGTH&gt;
         &lt;/COL_LIST_ITEM&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;DEPTNO&lt;/NAME&gt;
            &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
            &lt;PRECISION&gt;2&lt;/PRECISION&gt;
            &lt;SCALE&gt;0&lt;/SCALE&gt;
         &lt;/COL_LIST_ITEM&gt;
      &lt;/COL_LIST&gt;
   &lt;/RELATIONAL_TABLE&gt;
&lt;/TABLE&gt; 
  
1 row selected.
 
SQL&gt; SELECT get_table_sxml('TAB2') FROM dual;
 
  &lt;TABLE xmlns="http://xmlns.oracle.com/ku" version="1.0"&gt;
   &lt;SCHEMA&gt;SCOTT&lt;/SCHEMA&gt;
   &lt;NAME&gt;TAB2&lt;/NAME&gt;
   &lt;RELATIONAL_TABLE&gt;
      &lt;COL_LIST&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;EMPNO&lt;/NAME&gt;
            &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
            &lt;PRECISION&gt;4&lt;/PRECISION&gt;
            &lt;SCALE&gt;0&lt;/SCALE&gt;
         &lt;/COL_LIST_ITEM&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;ENAME&lt;/NAME&gt;
            &lt;DATATYPE&gt;VARCHAR2&lt;/DATATYPE&gt;
            &lt;LENGTH&gt;20&lt;/LENGTH&gt;
         &lt;/COL_LIST_ITEM&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;MGR&lt;/NAME&gt;
            &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
            &lt;PRECISION&gt;4&lt;/PRECISION&gt;
            &lt;SCALE&gt;0&lt;/SCALE&gt;
         &lt;/COL_LIST_ITEM&gt;
         &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;DEPTNO&lt;/NAME&gt;
            &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
            &lt;PRECISION&gt;2&lt;/PRECISION&gt;
            &lt;SCALE&gt;0&lt;/SCALE&gt;
         &lt;/COL_LIST_ITEM&gt;
      &lt;/COL_LIST&gt;
      &lt;PRIMARY_KEY_CONSTRAINT_LIST&gt;
         &lt;PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt;
            &lt;COL_LIST&gt;
               &lt;COL_LIST_ITEM&gt;
                  &lt;NAME&gt;EMPNO&lt;/NAME&gt;
               &lt;/COL_LIST_ITEM&gt;
            &lt;/COL_LIST&gt;
         &lt;/PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt;
      &lt;/PRIMARY_KEY_CONSTRAINT_LIST&gt;
   &lt;/RELATIONAL_TABLE&gt;
&lt;/TABLE&gt; 
 
1 row selected.
 
</pre></li>
<li>
<p>Compare the results using the <code dir="ltr">DBMS_METADATA</code> browsing APIs:</p>
<pre dir="ltr">
SQL&gt; SELECT dbms_metadata.get_sxml('TABLE','TAB1') FROM dual;
SQL&gt; SELECT dbms_metadata.get_sxml('TABLE','TAB2') FROM dual;
</pre></li>
<li>
<p>Create a function using the <code dir="ltr">DBMS_METADATA_DIFF</code> API to compare the metadata for the two tables. In this function, the <code dir="ltr">get_table_sxml</code> function that was just defined in step 2 is used.</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE FUNCTION compare_table_sxml(name1 IN VARCHAR2,
  2                                          name2 IN VARCHAR2) RETURN CLOB IS
  3   doc1 CLOB;
  4   doc2 CLOB;
  5   diffdoc CLOB;
  6   openc_handle NUMBER;
  7  BEGIN
  8   --
  9   -- Fetch the SXML for the two tables
 10   --
 11   doc1 := get_table_sxml(name1);
 12   doc2 := get_table_sxml(name2);
 13   --
 14   -- Specify the object type in the OPENC call
 15   --
 16   openc_handle := DBMS_METADATA_DIFF.OPENC('TABLE');
 17   --
 18   -- Add each document
 19   --
 20   DBMS_METADATA_DIFF.ADD_DOCUMENT(openc_handle,doc1);
 21   DBMS_METADATA_DIFF.ADD_DOCUMENT(openc_handle,doc2);
 22   --
 23   -- Fetch the SXML difference document
 24   --
 25   diffdoc := DBMS_METADATA_DIFF.FETCH_CLOB(openc_handle);
 26   DBMS_METADATA_DIFF.CLOSE(openc_handle);
 27   RETURN diffdoc;
 28  END;
 29  /
 
Function created.
</pre></li>
<li>
<p>Use the function to fetch the SXML difference document for the two tables:</p>
<pre dir="ltr">
SQL&gt; SELECT compare_table_sxml('TAB1','TAB2') FROM dual;

&lt;TABLE xmlns="http://xmlns.oracle.com/ku" version="1.0"&gt;
  &lt;SCHEMA&gt;SCOTT&lt;/SCHEMA&gt;
  &lt;NAME value1="TAB1"&gt;TAB2&lt;/NAME&gt;
  &lt;RELATIONAL_TABLE&gt;
    &lt;COL_LIST&gt;
      &lt;COL_LIST_ITEM&gt;
        &lt;NAME&gt;EMPNO&lt;/NAME&gt;
        &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
        &lt;PRECISION&gt;4&lt;/PRECISION&gt;
        &lt;SCALE&gt;0&lt;/SCALE&gt;
      &lt;/COL_LIST_ITEM&gt;
      &lt;COL_LIST_ITEM&gt;
        &lt;NAME&gt;ENAME&lt;/NAME&gt;
        &lt;DATATYPE&gt;VARCHAR2&lt;/DATATYPE&gt;
        &lt;LENGTH value1="10"&gt;20&lt;/LENGTH&gt;
      &lt;/COL_LIST_ITEM&gt;
      &lt;COL_LIST_ITEM src="1"&gt;
        &lt;NAME&gt;JOB&lt;/NAME&gt;
        &lt;DATATYPE&gt;VARCHAR2&lt;/DATATYPE&gt;
        &lt;LENGTH&gt;9&lt;/LENGTH&gt;
      &lt;/COL_LIST_ITEM&gt;
      &lt;COL_LIST_ITEM&gt;
        &lt;NAME&gt;DEPTNO&lt;/NAME&gt;
        &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
        &lt;PRECISION&gt;2&lt;/PRECISION&gt;
        &lt;SCALE&gt;0&lt;/SCALE&gt;
      &lt;/COL_LIST_ITEM&gt;
      &lt;COL_LIST_ITEM src="2"&gt;
        &lt;NAME&gt;MGR&lt;/NAME&gt;
        &lt;DATATYPE&gt;NUMBER&lt;/DATATYPE&gt;
        &lt;PRECISION&gt;4&lt;/PRECISION&gt;
        &lt;SCALE&gt;0&lt;/SCALE&gt;
      &lt;/COL_LIST_ITEM&gt;
    &lt;/COL_LIST&gt;
    &lt;PRIMARY_KEY_CONSTRAINT_LIST src="2"&gt;
      &lt;PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt;
        &lt;COL_LIST&gt;
          &lt;COL_LIST_ITEM&gt;
            &lt;NAME&gt;EMPNO&lt;/NAME&gt;
          &lt;/COL_LIST_ITEM&gt;
        &lt;/COL_LIST&gt;
      &lt;/PRIMARY_KEY_CONSTRAINT_LIST_ITEM&gt;
    &lt;/PRIMARY_KEY_CONSTRAINT_LIST&gt;
  &lt;/RELATIONAL_TABLE&gt;
&lt;/TABLE&gt;
 
1 row selected.
 
</pre>
<p>The SXML difference document shows the union of the two SXML documents, with the XML attributes <code dir="ltr">value1</code> and <code dir="ltr">src</code> identifying the differences. When an element exists in only one document it is marked with <code dir="ltr">src</code>. Thus, <code dir="ltr">&lt;COL_LIST_ITEM src="1"&gt;</code> means that this element is in the first document (<code dir="ltr">TAB1</code>) but not in the second. When an element is present in both documents but with different values, the element's value is the value in the second document and the <code dir="ltr">value1</code> gives its value in the first. For example, <code dir="ltr">&lt;LENGTH value1="10"&gt;20&lt;/LENGTH&gt;</code> means that the length is 10 in <code dir="ltr">TAB1</code> (the first document) and 20 in <code dir="ltr">TAB2</code>.</p>
</li>
<li>
<p>Compare the result using the <code dir="ltr">DBMS_METADATA_DIFF</code> browsing APIs:</p>
<pre dir="ltr">
SQL&gt; SELECT dbms_metadata_diff.compare_sxml('TABLE','TAB1','TAB2') FROM dual;
</pre></li>
<li>
<p>Create a function using the <code dir="ltr">DBMS_METADATA.CONVERT</code> API to generate an ALTERXML document. This is an XML document containing <code dir="ltr">ALTER</code> statements to make one object like another. You can also use parse items to get information about the individual <code dir="ltr">ALTER</code> statements. (This example uses the functions defined thus far.)</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE FUNCTION get_table_alterxml(name1 IN VARCHAR2,
  2                                           name2 IN VARCHAR2) RETURN CLOB IS
  3   diffdoc CLOB;
  4   openw_handle NUMBER;
  5   transform_handle NUMBER;
  6   alterxml CLOB;
  7  BEGIN
  8   --
  9   -- Use the function just defined to get the difference document
 10   --
 11   diffdoc := compare_table_sxml(name1,name2);
 12   --
 13   -- Specify the object type in the OPENW call
 14   --
 15   openw_handle := DBMS_METADATA.OPENW('TABLE');
 16   --
 17   -- Use the ALTERXML transform to generate the ALTER_XML document
 18   --
 19   transform_handle := DBMS_METADATA.ADD_TRANSFORM(openw_handle,'ALTERXML');
 20   --
 21   -- Request parse items
 22   --
 23   DBMS_METADATA.SET_PARSE_ITEM(openw_handle,'CLAUSE_TYPE');
 24   DBMS_METADATA.SET_PARSE_ITEM(openw_handle,'NAME');
 25   DBMS_METADATA.SET_PARSE_ITEM(openw_handle,'COLUMN_ATTRIBUTE');
 26   --
 27   -- Create a temporary LOB
 28   --
 29   DBMS_LOB.CREATETEMPORARY(alterxml, TRUE );
 30   --
 31   -- Call CONVERT to do the transform
 32   --
 33   DBMS_METADATA.CONVERT(openw_handle,diffdoc,alterxml);
 34   --
 35   -- Close context and return the result
 36   --
 37   DBMS_METADATA.CLOSE(openw_handle);
 38   RETURN alterxml;
 39  END;
 40  /
 
Function created.
</pre></li>
<li>
<p>Use the function to fetch the ALTER_XML document:</p>
<pre dir="ltr">
SQL&gt; SELECT get_table_alterxml('TAB1','TAB2') FROM dual;
 
&lt;ALTER_XML xmlns="http://xmlns.oracle.com/ku" version="1.0"&gt;
   &lt;OBJECT_TYPE&gt;TABLE&lt;/OBJECT_TYPE&gt;
   &lt;OBJECT1&gt;
      &lt;SCHEMA&gt;SCOTT&lt;/SCHEMA&gt;
      &lt;NAME&gt;TAB1&lt;/NAME&gt;
   &lt;/OBJECT1&gt;
   &lt;OBJECT2&gt;
      &lt;SCHEMA&gt;SCOTT&lt;/SCHEMA&gt;
      &lt;NAME&gt;TAB2&lt;/NAME&gt;
   &lt;/OBJECT2&gt;
   &lt;ALTER_LIST&gt;
      &lt;ALTER_LIST_ITEM&gt;
         &lt;PARSE_LIST&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;NAME&lt;/ITEM&gt;
               &lt;VALUE&gt;MGR&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;CLAUSE_TYPE&lt;/ITEM&gt;
               &lt;VALUE&gt;ADD_COLUMN&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
         &lt;/PARSE_LIST&gt;
         &lt;SQL_LIST&gt;
            &lt;SQL_LIST_ITEM&gt;
               &lt;TEXT&gt;ALTER TABLE "SCOTT"."TAB1" ADD ("MGR" NUMBER(4,0))&lt;/TEXT&gt;
            &lt;/SQL_LIST_ITEM&gt;
         &lt;/SQL_LIST&gt;
      &lt;/ALTER_LIST_ITEM&gt;
      &lt;ALTER_LIST_ITEM&gt;
         &lt;PARSE_LIST&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;NAME&lt;/ITEM&gt;
               &lt;VALUE&gt;JOB&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;CLAUSE_TYPE&lt;/ITEM&gt;
               &lt;VALUE&gt;DROP_COLUMN&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
         &lt;/PARSE_LIST&gt;
         &lt;SQL_LIST&gt;
            &lt;SQL_LIST_ITEM&gt;
               &lt;TEXT&gt;ALTER TABLE "SCOTT"."TAB1" DROP ("JOB")&lt;/TEXT&gt;
            &lt;/SQL_LIST_ITEM&gt;
         &lt;/SQL_LIST&gt;
      &lt;/ALTER_LIST_ITEM&gt;
      &lt;ALTER_LIST_ITEM&gt;
         &lt;PARSE_LIST&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;NAME&lt;/ITEM&gt;
               &lt;VALUE&gt;ENAME&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;CLAUSE_TYPE&lt;/ITEM&gt;
               &lt;VALUE&gt;MODIFY_COLUMN&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;COLUMN_ATTRIBUTE&lt;/ITEM&gt;
               &lt;VALUE&gt; SIZE_INCREASE&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
         &lt;/PARSE_LIST&gt;
         &lt;SQL_LIST&gt;
            &lt;SQL_LIST_ITEM&gt;
               &lt;TEXT&gt;ALTER TABLE "SCOTT"."TAB1" MODIFY 
                    ("ENAME" VARCHAR2(20))
               &lt;/TEXT&gt;
            &lt;/SQL_LIST_ITEM&gt;
         &lt;/SQL_LIST&gt;
      &lt;/ALTER_LIST_ITEM&gt;
      &lt;ALTER_LIST_ITEM&gt;
         &lt;PARSE_LIST&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;CLAUSE_TYPE&lt;/ITEM&gt;
               &lt;VALUE&gt;ADD_CONSTRAINT&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
         &lt;/PARSE_LIST&gt;
         &lt;SQL_LIST&gt;
            &lt;SQL_LIST_ITEM&gt;
               &lt;TEXT&gt;ALTER TABLE "SCOTT"."TAB1" ADD  PRIMARY KEY
                     ("EMPNO") ENABLE
               &lt;/TEXT&gt;
            &lt;/SQL_LIST_ITEM&gt;
         &lt;/SQL_LIST&gt;
      &lt;/ALTER_LIST_ITEM&gt;
      &lt;ALTER_LIST_ITEM&gt;
         &lt;PARSE_LIST&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;NAME&lt;/ITEM&gt;
               &lt;VALUE&gt;TAB1&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
            &lt;PARSE_LIST_ITEM&gt;
               &lt;ITEM&gt;CLAUSE_TYPE&lt;/ITEM&gt;
               &lt;VALUE&gt;RENAME_TABLE&lt;/VALUE&gt;
            &lt;/PARSE_LIST_ITEM&gt;
         &lt;/PARSE_LIST&gt;
         &lt;SQL_LIST&gt;
            &lt;SQL_LIST_ITEM&gt;
               &lt;TEXT&gt;ALTER TABLE "SCOTT"."TAB1" RENAME TO "TAB2"&lt;/TEXT&gt;
            &lt;/SQL_LIST_ITEM&gt;
         &lt;/SQL_LIST&gt;
      &lt;/ALTER_LIST_ITEM&gt;
   &lt;/ALTER_LIST&gt;
&lt;/ALTER_XML&gt;
 
 
1 row selected.
 
</pre></li>
<li>
<p>Compare the result using the <code dir="ltr">DBMS_METADATA_DIFF</code> browsing API:</p>
<pre dir="ltr">
SQL&gt; SELECT dbms_metadata_diff.compare_alter_xml('TABLE','TAB1','TAB2') FROM dual;
</pre></li>
<li>
<p>The ALTER_XML document contains an ALTER_LIST of each of the alters. Each ALTER_LIST_ITEM has a PARSE_LIST containing the parse items as name-value pairs and a SQL_LIST containing the SQL for the particular alter. You can parse this document and decide which of the SQL statements to execute, using the information in the PARSE_LIST. (Note, for example, that in this case one of the alters is a DROP_COLUMN, and you might choose not to execute that.)</p>
</li>
<li>
<p>Create one last function that uses the <code dir="ltr">DBMS_METADATA.CONVERT</code> API and the <code dir="ltr">ALTER DDL</code> transform to convert the ALTER_XML document into SQL DDL:</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE FUNCTION get_table_alterddl(name1 IN VARCHAR2,
  2                                           name2 IN VARCHAR2) RETURN CLOB IS
  3   alterxml CLOB;
  4   openw_handle NUMBER;
  5   transform_handle NUMBER;
  6   alterddl CLOB;
  7  BEGIN
  8   --
  9   -- Use the function just defined to get the ALTER_XML document
 10   --
 11   alterxml := get_table_alterxml(name1,name2);
 12   --
 13   -- Specify the object type in the OPENW call
 14   --
 15   openw_handle := DBMS_METADATA.OPENW('TABLE');
 16   --
 17   -- Use ALTERDDL transform to convert the ALTER_XML document to SQL DDL
 18   -- 
 19   transform_handle := DBMS_METADATA.ADD_TRANSFORM(openw_handle,'ALTERDDL');
 20   --
 21   -- Use the SQLTERMINATOR transform parameter to append a terminator
 22   -- to each SQL statement
 23   --
 24   DBMS_METADATA.SET_TRANSFORM_PARAM(transform_handle,'SQLTERMINATOR',true);
 25   --
 26   -- Create a temporary lob
 27   --
 28   DBMS_LOB.CREATETEMPORARY(alterddl, TRUE );
 29   --
 30   -- Call CONVERT to do the transform
 31   --
 32   DBMS_METADATA.CONVERT(openw_handle,alterxml,alterddl);
 33   --
 34   -- Close context and return the result
 35   --
 36   DBMS_METADATA.CLOSE(openw_handle);
 37   RETURN alterddl;
 38  END;
 39  /
 
Function created.
 
</pre></li>
<li>
<p>Use the function to fetch the SQL ALTER statements:</p>
<pre dir="ltr">
SQL&gt; SELECT get_table_alterddl('TAB1','TAB2') FROM dual;
ALTER TABLE "SCOTT"."TAB1" ADD ("MGR" NUMBER(4,0))
/
  ALTER TABLE "SCOTT"."TAB1" DROP ("JOB")
/
  ALTER TABLE "SCOTT"."TAB1" MODIFY ("ENAME" VARCHAR2(20))
/
  ALTER TABLE "SCOTT"."TAB1" ADD  PRIMARY KEY ("EMPNO") ENABLE
/
  ALTER TABLE "SCOTT"."TAB1" RENAME TO "TAB2"
/
  
1 row selected.
 
</pre></li>
<li>
<p>Compare the results using the <code dir="ltr">DBMS_METADATA_DIFF</code> browsing API:</p>
<pre dir="ltr">
SQL&gt; SELECT dbms_metadata_diff.compare_alter('TABLE','TAB1','TAB2') FROM dual;
ALTER TABLE "SCOTT"."TAB1" ADD ("MGR" NUMBER(4,0))
  ALTER TABLE "SCOTT"."TAB1" DROP ("JOB")
  ALTER TABLE "SCOTT"."TAB1" MODIFY ("ENAME" VARCHAR2(20))
  ALTER TABLE "SCOTT"."TAB1" ADD  PRIMARY KEY ("EMPNO") USING INDEX 
  PCTFREE 10 INITRANS 2 STORAGE ( INITIAL 16384 NEXT 16384 MINEXTENTS 1
  MAXEXTENTS 505 PCTINCREASE 50 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL
  DEFAULT)  ENABLE ALTER TABLE "SCOTT"."TAB1" RENAME TO "TAB2"
 
1 row selected.
</pre></li>
</ol>
</div>
<!-- class="example" --></div>
<!-- class="sect1" -->
<a id="i1010762"></a>
<div id="SUTIL1632" class="sect1">
<h2 class="sect1">Performance Tips for the Programmatic Interface of the DBMS_METADATA API</h2>
<p>This section describes how to enhance<a id="sthref1745"></a> performance when using the programmatic interface of the <code dir="ltr">DBMS_METADATA</code> API.</p>
<ol>
<li>
<p>Fetch all of one type of object before fetching the next. For example, if you are retrieving the definitions of all objects in your schema, first fetch all tables, then all indexes, then all triggers, and so on. This will be much faster than nesting <code dir="ltr">OPEN</code> contexts; that is, fetch one table then all of its indexes, grants, and triggers, then the next table and all of its indexes, grants, and triggers, and so on. <a href="#i1011606">"Example Usage of the DBMS_METADATA API"</a> reflects this second, less efficient means, but its purpose is to demonstrate most of the programmatic calls, which are best shown by this method.</p>
</li>
<li>
<p>Use the <code dir="ltr">SET_COUNT</code> procedure to retrieve more than one object at a time. This minimizes server round trips and eliminates many redundant function calls.</p>
</li>
<li>
<p>When writing a PL/SQL package that calls the <code dir="ltr">DBMS_METADATA</code> API, declare LOB variables and objects that contain LOBs (such as <code dir="ltr">SYS</code>.<code dir="ltr">KU</code>$<code dir="ltr">_DDLS</code>) at package scope rather than within individual functions. This eliminates the creation and deletion of LOB duration structures upon function entrance and exit, which are very expensive operations.</p>
<div class="infoboxnotealso">
<p class="notep1"><span class="bold">See Also</span>:</p>
<a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></div>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1011606"></a>
<div id="SUTIL1633" class="sect1">
<h2 class="sect1">Example Usage of the DBMS_METADATA API</h2>
<p>This section provides an example of how the <code dir="ltr">DBMS_METADATA</code> API could be used. A script is provided that automatically runs the demo for you by performing the following actions:</p>
<ul>
<li>
<p>Establishes a schema (<code dir="ltr">MDDEMO</code>) and some payroll users.</p>
</li>
<li>
<p>Creates three payroll-like tables within the schema and any associated indexes, triggers, and grants.</p>
</li>
<li>
<p>Creates a package, <code dir="ltr">PAYROLL_DEMO</code>, that uses the <code dir="ltr">DBMS_METADATA</code> API. The <code dir="ltr">PAYROLL_DEMO</code> package contains a procedure, <code dir="ltr">GET_PAYROLL_TABLES,</code> that retrieves the DDL for the two tables in the <code dir="ltr">MDDEMO</code> schema that start with <code dir="ltr">PAYROLL</code>. For each table, it retrieves the DDL for the table's associated dependent objects; indexes, grants, and triggers. All the DDL is written to a table named <code dir="ltr">MDDEMO</code>.<code dir="ltr">DDL</code>.</p>
</li>
</ul>
<p>To execute the example, do the following:</p>
<ol>
<li>
<p>Start SQL*Plus as user <code dir="ltr">system</code>. You will be prompted for a password.</p>
<pre dir="ltr">
sqlplus system
</pre></li>
<li>
<p>Install the demo, which is located in the file <code dir="ltr">mddemo.sql</code> in <code dir="ltr">rdbms</code>/<code dir="ltr">demo</code>:</p>
<pre dir="ltr">
SQL&gt; @mddemo
</pre>
<p>For an explanation of what happens during this step, see <a href="#i1011948">"What Does the DBMS_METADATA Example Do?"</a>.</p>
</li>
<li>
<p>Connect as user <code dir="ltr">mddemo</code>. You will be prompted for a password, which is also <code dir="ltr">mddemo</code>.</p>
<pre dir="ltr">
SQL&gt; CONNECT mddemo
Enter password:
</pre></li>
<li>
<p>Set the following parameters so that query output will be complete and readable:</p>
<pre dir="ltr">
SQL&gt; SET PAGESIZE 0
SQL&gt; SET LONG 1000000
</pre></li>
<li>
<p>Execute the <code dir="ltr">GET_PAYROLL_TABLES</code> procedure, as follows:</p>
<pre dir="ltr">
SQL&gt; CALL payroll_demo.get_payroll_tables();
</pre></li>
<li>
<p>Execute the following SQL query:</p>
<pre dir="ltr">
SQL&gt; SELECT ddl FROM DDL ORDER BY SEQNO;
</pre>
<p>The output generated is the result of the execution of the <code dir="ltr">GET_PAYROLL_TABLES</code> procedure. It shows all the DDL that was performed in Step 2 when the demo was installed. See <a href="#i1011848">"Output Generated from the GET_PAYROLL_TABLES Procedure"</a> for a listing of the actual output.</p>
</li>
</ol>
<a id="i1011948"></a>
<div id="SUTIL1634" class="sect2">
<h3 class="sect2">What Does the DBMS_METADATA Example Do?</h3>
<p>When the <code dir="ltr">mddemo</code> script is run, the following steps take place. You can adapt these steps to your own situation.</p>
<ol>
<li>
<p>Drops users as follows, if they exist. This will ensure that you are starting out with fresh data. If the users do not exist, then a message to that effect is displayed, no harm is done, and the demo continues to execute.</p>
<pre dir="ltr">
CONNECT system
Enter password: <span class="italic">password</span>
SQL&gt; DROP USER mddemo CASCADE;
SQL&gt; DROP USER mddemo_clerk CASCADE;
SQL&gt; DROP USER mddemo_mgr CASCADE;
</pre></li>
<li>
<p>Creates user <code dir="ltr">mddemo</code>, identified by <code dir="ltr">mddemo</code>:</p>
<pre dir="ltr">
SQL&gt; CREATE USER mddemo IDENTIFIED BY mddemo;
SQL&gt; GRANT resource, connect, create session,
  1     create table,
  2     create procedure, 
  3     create sequence,
  4     create trigger,
  5     create view,
  6     create synonym,
  7     alter session,
  8  TO mddemo;
</pre></li>
<li>
<p>Creates user <code dir="ltr">mddemo_clerk</code>, identified by <code dir="ltr">clerk</code>:</p>
<pre dir="ltr">
CREATE USER mddemo_clerk IDENTIFIED BY clerk;
</pre></li>
<li>
<p>Creates user <code dir="ltr">mddemo_mgr</code>, identified by <code dir="ltr">mgr</code>:</p>
<pre dir="ltr">
CREATE USER mddemo_mgr IDENTIFIED BY mgr;
</pre></li>
<li>
<p>Connect to SQL*Plus as <code dir="ltr">mddemo</code> (the password is also <code dir="ltr">mddemo</code>):</p>
<pre dir="ltr">
CONNECT mddemo
Enter password:
</pre></li>
<li>
<p>Creates some payroll-type tables:</p>
<pre dir="ltr">
SQL&gt; CREATE TABLE payroll_emps
  2  ( lastname VARCHAR2(60) NOT NULL,
  3  firstname VARCHAR2(20) NOT NULL,
  4  mi VARCHAR2(2),
  5  suffix VARCHAR2(10),
  6  dob DATE NOT NULL,
  7  badge_no NUMBER(6) PRIMARY KEY,
  8  exempt VARCHAR(1) NOT NULL,
  9  salary NUMBER (9,2),
  10 hourly_rate NUMBER (7,2) )
  11 /

SQL&gt; CREATE TABLE payroll_timecards 
  2  (badge_no NUMBER(6) REFERENCES payroll_emps (badge_no),
  3  week NUMBER(2),
  4  job_id NUMBER(5),
  5  hours_worked NUMBER(4,2) )
  6 /
</pre></li>
<li>
<p>Creates a dummy table, <code dir="ltr">audit_trail</code>. This table is used to show that tables that do not start with <code dir="ltr">payroll</code> are not retrieved by the <code dir="ltr">GET_PAYROLL_TABLES</code> procedure.</p>
<pre dir="ltr">
SQL&gt; CREATE TABLE audit_trail 
  2  (action_time DATE,
  3  lastname VARCHAR2(60),
  4  action LONG )
  5  /
</pre></li>
<li>
<p>Creates some grants on the tables just created:</p>
<pre dir="ltr">
SQL&gt; GRANT UPDATE (salary,hourly_rate) ON payroll_emps TO mddemo_clerk;
SQL&gt; GRANT ALL ON payroll_emps TO mddemo_mgr WITH GRANT OPTION;

SQL&gt; GRANT INSERT,UPDATE ON payroll_timecards TO mddemo_clerk;
SQL&gt; GRANT ALL ON payroll_timecards TO mddemo_mgr WITH GRANT OPTION;
</pre></li>
<li>
<p>Creates some indexes on the tables just created:</p>
<pre dir="ltr">
SQL&gt; CREATE INDEX i_payroll_emps_name ON payroll_emps(lastname);
SQL&gt; CREATE INDEX i_payroll_emps_dob ON payroll_emps(dob);
SQL&gt; CREATE INDEX i_payroll_timecards_badge ON payroll_timecards(badge_no);
</pre></li>
<li>
<p>Creates some triggers on the tables just created:</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE PROCEDURE check_sal( salary in number) AS BEGIN
  2  RETURN;
  3  END;
  4  /
</pre>
<p>Note that the security is kept fairly loose to keep the example simple.</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE TRIGGER salary_trigger BEFORE INSERT OR UPDATE OF salary
ON payroll_emps
FOR EACH ROW WHEN (new.salary &gt; 150000)
CALL check_sal(:new.salary)
/

SQL&gt; CREATE OR REPLACE TRIGGER hourly_trigger BEFORE UPDATE OF hourly_rate ON payroll_emps
FOR EACH ROW
BEGIN :new.hourly_rate:=:old.hourly_rate;END;
/
</pre></li>
<li>
<p>Sets up a table to hold the generated DDL:</p>
<pre dir="ltr">
CREATE TABLE ddl (ddl CLOB, seqno NUMBER);
</pre></li>
<li>
<p>Creates the <code dir="ltr">PAYROLL_DEMO</code> package, which provides examples of how <code dir="ltr">DBMS_METADATA</code> procedures can be used.</p>
<pre dir="ltr">
SQL&gt; CREATE OR REPLACE PACKAGE payroll_demo AS PROCEDURE get_payroll_tables;
END;
/
</pre>
<div class="infobox-note">
<p class="notep1">Note:</p>
To see the entire script for this example, including the contents of the <code dir="ltr">PAYROLL_DEMO</code> package, see the file <code dir="ltr">mddemo.sql</code> located in your $<code dir="ltr">ORACLE_HOME/rdbms/demo</code> directory.</div>
</li>
</ol>
</div>
<!-- class="sect2" -->
<a id="i1011848"></a>
<div id="SUTIL1635" class="sect2">
<h3 class="sect2">Output Generated from the GET_PAYROLL_TABLES Procedure</h3>
<p>After you execute the <code dir="ltr">mddemo.payroll_demo.get_payroll_tables</code> procedure, you can execute the following query:</p>
<pre dir="ltr">
SQL&gt; SELECT ddl FROM ddl ORDER BY seqno;
</pre>
<p>The results are as follows, which reflect all the DDL executed by the script as described in the previous section.</p>
<pre dir="ltr">
CREATE TABLE "MDDEMO"."PAYROLL_EMPS"
   (    "LASTNAME" VARCHAR2(60) NOT NULL ENABLE,
        "FIRSTNAME" VARCHAR2(20) NOT NULL ENABLE,
        "MI" VARCHAR2(2),
        "SUFFIX" VARCHAR2(10),
        "DOB" DATE NOT NULL ENABLE,
        "BADGE_NO" NUMBER(6,0),
        "EXEMPT" VARCHAR2(1) NOT NULL ENABLE,
        "SALARY" NUMBER(9,2),
        "HOURLY_RATE" NUMBER(7,2),
 PRIMARY KEY ("BADGE_NO") ENABLE
   ) ;

  GRANT UPDATE ("SALARY") ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_CLERK";
  GRANT UPDATE ("HOURLY_RATE") ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_CLERK";
  GRANT ALTER ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT DELETE ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT INDEX ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT INSERT ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT SELECT ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT UPDATE ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT REFERENCES ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT ON COMMIT REFRESH ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT QUERY REWRITE ON "MDDEMO"."PAYROLL_EMPS" TO "MDDEMO_MGR" WITH GRANT OPTION;

  CREATE INDEX "MDDEMO"."I_PAYROLL_EMPS_DOB" ON "MDDEMO"."PAYROLL_EMPS" ("DOB")
  PCTFREE 10 INITRANS 2 MAXTRANS 255
  STORAGE(INITIAL 10240 NEXT 10240 MINEXTENTS 1 MAXEXTENTS 121 PCTINCREASE 50
  FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT) TABLESPACE "SYSTEM" ;


  CREATE INDEX "MDDEMO"."I_PAYROLL_EMPS_NAME" ON "MDDEMO"."PAYROLL_EMPS" ("LASTNAME")
  PCTFREE 10 INITRANS 2 MAXTRANS 255
  STORAGE(INITIAL 10240 NEXT 10240 MINEXTENTS 1 MAXEXTENTS 121 PCTINCREASE 50
  FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT) TABLESPACE "SYSTEM" ;

  CREATE OR REPLACE TRIGGER hourly_trigger before update of hourly_rate on payroll_emps
for each row
begin :new.hourly_rate:=:old.hourly_rate;end;
/
ALTER TRIGGER "MDDEMO"."HOURLY_TRIGGER" ENABLE;

  CREATE OR REPLACE TRIGGER salary_trigger before insert or update of salary on payroll_emps
for each row  
WHEN (new.salary &gt; 150000)  CALL check_sal(:new.salary)
/
ALTER TRIGGER "MDDEMO"."SALARY_TRIGGER" ENABLE;


CREATE TABLE "MDDEMO"."PAYROLL_TIMECARDS"
   (    "BADGE_NO" NUMBER(6,0),
        "WEEK" NUMBER(2,0),
        "JOB_ID" NUMBER(5,0),
        "HOURS_WORKED" NUMBER(4,2),
 FOREIGN KEY ("BADGE_NO")
  REFERENCES "MDDEMO"."PAYROLL_EMPS" ("BADGE_NO") ENABLE
   ) ;

  GRANT INSERT ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_CLERK";
  GRANT UPDATE ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_CLERK";
  GRANT ALTER ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT DELETE ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT INDEX ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT INSERT ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT SELECT ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT UPDATE ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT REFERENCES ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT ON COMMIT REFRESH ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;
  GRANT QUERY REWRITE ON "MDDEMO"."PAYROLL_TIMECARDS" TO "MDDEMO_MGR" WITH GRANT OPTION;

  CREATE INDEX "MDDEMO"."I_PAYROLL_TIMECARDS_BADGE" ON "MDDEMO"."PAYROLL_TIMECARDS" ("BADGE_NO")
  PCTFREE 10 INITRANS 2 MAXTRANS 255
  STORAGE(INITIAL 10240 NEXT 10240 MINEXTENTS 1 MAXEXTENTS 121 PCTINCREASE 50
  FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT) TABLESPACE "SYSTEM" ;
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010767"></a>
<div id="SUTIL1636" class="sect1">
<h2 class="sect1">Summary of DBMS_METADATA Procedures</h2>
<p>This section provides brief descriptions of the procedures provided by the <code dir="ltr">DBMS_METADATA</code> API. For detailed descriptions of these procedures, see <a class="olink ARPLS026" href="../../appdev.112/e40758/d_metada.htm#ARPLS026"><span class="italic">Oracle Database PL/SQL Packages and Types Reference.</span></a></p>
<p><a id="i1009157"></a><a href="#g1029894">Table 20-1</a> provides a brief description of the procedures provided by the <code dir="ltr">DBMS_METADATA</code> programmatic interface for retrieving multiple objects.</p>
<div id="SUTIL3629" class="tblformalwide">
<p class="titleintable"><a id="sthref1746"></a><a id="g1029894"></a>Table 20-1 DBMS_METADATA Procedures Used for Retrieving Multiple Objects</p>
<table class="cellalignment1399" title="DBMS_METADATA Procedures Used for Retrieving Multiple Objects" summary="DBMS_METADATA procedures used for retrieving multiple objects" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t7">PL/SQL Procedure Name</th>
<th class="cellalignment1395" id="r1c2-t7">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.OPEN()
</pre></td>
<td class="cellalignment1396" headers="r2c1-t7 r1c2-t7">
<p>Specifies the type of object to be retrieved, the version of its metadata, and the object model.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.SET_FILTER()
</pre></td>
<td class="cellalignment1396" headers="r3c1-t7 r1c2-t7">
<p>Specifies restrictions on the objects to be retrieved, for example, the object name or schema.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.SET_COUNT()
</pre></td>
<td class="cellalignment1396" headers="r4c1-t7 r1c2-t7">
<p>Specifies the maximum number of objects to be retrieved in a single <code dir="ltr">FETCH_xxx</code> call.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.GET_QUERY()
</pre></td>
<td class="cellalignment1396" headers="r5c1-t7 r1c2-t7">
<p>Returns the text of the queries that are used by <code dir="ltr">FETCH_xxx</code>. You can use this as a debugging aid.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.SET_PARSE_ITEM()
</pre></td>
<td class="cellalignment1396" headers="r6c1-t7 r1c2-t7">
<p>Enables output parsing by specifying an object attribute to be parsed and returned.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.ADD_TRANSFORM()
</pre></td>
<td class="cellalignment1396" headers="r7c1-t7 r1c2-t7">
<p>Specifies a transform that <code dir="ltr">FETCH_xxx</code> applies to the XML representation of the retrieved objects.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.SET_TRANSFORM_PARAM()
</pre></td>
<td class="cellalignment1396" headers="r8c1-t7 r1c2-t7">
<p>Specifies parameters to the XSLT stylesheet identified by <code dir="ltr">transform_handle.</code></p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r9c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.SET_REMAP_PARAM()
</pre></td>
<td class="cellalignment1396" headers="r9c1-t7 r1c2-t7">
<p>Specifies parameters to the XSLT stylesheet identified by <code dir="ltr">transform_handle</code>.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r10c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.FETCH_xxx()
</pre></td>
<td class="cellalignment1396" headers="r10c1-t7 r1c2-t7">
<p>Returns metadata for objects meeting the criteria established by <code dir="ltr">OPEN</code>, <code dir="ltr">SET_FILTER</code>, <code dir="ltr">SET_COUNT</code>, <code dir="ltr">ADD_TRANSFORM</code>, and so on.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r11c1-t7" headers="r1c1-t7">
<pre dir="ltr">
DBMS_METADATA.CLOSE()
</pre></td>
<td class="cellalignment1396" headers="r11c1-t7 r1c2-t7">
<p>Invalidates the handle returned by <code dir="ltr">OPEN</code> and cleans up the associated state.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a href="#g1030147">Table 20-2</a> lists the procedures provided by the <code dir="ltr">DBMS_METADATA</code> browsing interface and provides a brief description of each one. These functions return metadata for one or more dependent or granted objects. These procedures do not support heterogeneous object types.</p>
<div id="SUTIL3630" class="tblformalwide">
<p class="titleintable"><a id="sthref1747"></a><a id="g1030147"></a>Table 20-2 DBMS_METADATA Procedures Used for the Browsing Interface</p>
<table class="cellalignment1399" title="DBMS_METADATA Procedures Used for the Browsing Interface" summary="DBMS_METADATA procedures used for the browsing interface" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t8">PL/SQL Procedure Name</th>
<th class="cellalignment1395" id="r1c2-t8">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t8" headers="r1c1-t8">
<pre dir="ltr">
DBMS_METADATA.GET_xxx()
</pre></td>
<td class="cellalignment1396" headers="r2c1-t8 r1c2-t8">
<p>Provides a way to return metadata for a single object. Each <code dir="ltr">GET_xxx</code> call consists of an <code dir="ltr">OPEN</code> procedure, one or two <code dir="ltr">SET_FILTER</code> calls, optionally an <code dir="ltr">ADD_TRANSFORM</code> procedure, a <code dir="ltr">FETCH_xxx</code> call, and a <code dir="ltr">CLOSE</code> procedure.</p>
<p>The <code dir="ltr"><span class="codeinlineitalic">object_type</span></code> parameter has the same semantics as in the <code dir="ltr">OPEN procedure</code>. <code dir="ltr"><span class="codeinlineitalic">schema</span></code> and <code dir="ltr"><span class="codeinlineitalic">name</span></code> are used for filtering.</p>
<p>If a transform is specified, then session-level transform flags are inherited.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t8" headers="r1c1-t8">
<pre dir="ltr">
DBMS_METADATA.GET_DEPENDENT_xxx()
</pre></td>
<td class="cellalignment1396" headers="r3c1-t8 r1c2-t8">
<p>Returns the metadata for one or more dependent objects, specified as XML or DDL.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t8" headers="r1c1-t8">
<pre dir="ltr">
DBMS_METADATA.GET_GRANTED_xxx()
</pre></td>
<td class="cellalignment1396" headers="r4c1-t8 r1c2-t8">
<p>Returns the metadata for one or more granted objects, specified as XML or DDL.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a id="i1010227"></a><a href="#g1030301">Table 20-3</a> provides a brief description of the <code dir="ltr">DBMS_METADATA</code> procedures and functions used for XML submission.</p>
<div id="SUTIL3631" class="tblformalwide">
<p class="titleintable"><a id="sthref1748"></a><a id="g1030301"></a>Table 20-3 DBMS_METADATA Procedures and Functions for Submitting XML Data</p>
<table class="cellalignment1399" title="DBMS_METADATA Procedures and Functions for Submitting XML Data" summary="DBMS_METADATA procedures used for submitting XML data" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t9">PL/SQL Name</th>
<th class="cellalignment1395" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.OPENW()
</pre></td>
<td class="cellalignment1396" headers="r2c1-t9 r1c2-t9">
<p>Opens a write context.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.ADD_TRANSFORM()
</pre></td>
<td class="cellalignment1396" headers="r3c1-t9 r1c2-t9">
<p>Specifies a transform for the XML documents</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.SET_TRANSFORM_PARAM() and 
DBMS_METADATA.SET_REMAP_PARAM()
</pre></td>
<td class="cellalignment1396" headers="r4c1-t9 r1c2-t9">
<p><code dir="ltr">SET_TRANSFORM_PARAM</code> specifies a parameter to a transform.</p>
<p><code dir="ltr">SET_REMAP_PARAM</code> specifies a remapping for a transform.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.SET_PARSE_ITEM()
</pre></td>
<td class="cellalignment1396" headers="r5c1-t9 r1c2-t9">
<p>Specifies an object attribute to be parsed.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r6c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.CONVERT()
</pre></td>
<td class="cellalignment1396" headers="r6c1-t9 r1c2-t9">
<p>Converts an XML document to DDL.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r7c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.PUT()
</pre></td>
<td class="cellalignment1396" headers="r7c1-t9 r1c2-t9">
<p>Submits an XML document to the database.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r8c1-t9" headers="r1c1-t9">
<pre dir="ltr">
DBMS_METADATA.CLOSE()
</pre></td>
<td class="cellalignment1396" headers="r8c1-t9 r1c2-t9">
<p>Closes the context opened with <code dir="ltr">OPENW</code>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect1" -->
<a id="BABEADCD"></a>
<div id="SUTIL3632" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Summary of DBMS_METADATA_DIFF Procedures</h2>
<p>This section provides brief descriptions of the procedures and functions provided by the <code dir="ltr">DBMS_METADATA_DIFF</code> API. For detailed descriptions of these procedures, see <a class="olink ARPLS354" href="../../appdev.112/e40758/d_metadiff.htm#ARPLS354"><span class="italic">Oracle Database PL/SQL Packages and Types Reference.</span></a></p>
<div id="SUTIL3633" class="tblformalwide">
<p class="titleintable"><a id="sthref1749"></a><a id="sthref1750"></a>Table 20-4 DBMS_METADATA_DIFF Procedures and Functions</p>
<table class="cellalignment1399" title="DBMS_METADATA_DIFF Procedures and Functions" summary="Summary of DBMS_METADATA_DIFF procedures" dir="ltr">
<thead>
<tr class="cellalignment1388">
<th class="cellalignment1395" id="r1c1-t10">PL/SQL Procedure Name</th>
<th class="cellalignment1395" id="r1c2-t10">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r2c1-t10" headers="r1c1-t10">
<p><code dir="ltr">OPENC</code> function</p>
</td>
<td class="cellalignment1396" headers="r2c1-t10 r1c2-t10">
<p>Specifies the type of objects to be compared.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r3c1-t10" headers="r1c1-t10">
<p><code dir="ltr">ADD_DOCUMENT</code> procedure</p>
</td>
<td class="cellalignment1396" headers="r3c1-t10 r1c2-t10">
<p>Specifies an SXML document to be compared.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r4c1-t10" headers="r1c1-t10">
<p><code dir="ltr">FETCH_CLOB</code> functions and procedures</p>
</td>
<td class="cellalignment1396" headers="r4c1-t10 r1c2-t10">
<p>Returns a CLOB showing the differences between the two documents specified by <code dir="ltr">ADD_DOCUMENT</code>.</p>
</td>
</tr>
<tr class="cellalignment1388">
<td class="cellalignment1396" id="r5c1-t10" headers="r1c1-t10">
<p><code dir="ltr">CLOSE</code> procedure</p>
</td>
<td class="cellalignment1396" headers="r5c1-t10 r1c2-t10">
<p>Invalidates the handle returned by <code dir="ltr">OPENC</code> and cleans up associated state.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1387">
<tr>
<td class="cellalignment1396">
<table class="cellalignment1392">
<tr>
<td class="cellalignment1391"><a href="logminer.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1391"><a href="original_export.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;1996, 2018,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1398">
<table class="cellalignment1390">
<tr>
<td class="cellalignment1391"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1391"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1391"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1391"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1391"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1391"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
