<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Managing Resources with Oracle Database Resource Manager</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1055" />
<meta name="dcterms.created" content="2015-05-05T8:27:37Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Administrator's Guide" />
<meta name="dcterms.identifier" content="E25494-07" />
<meta name="dcterms.isVersionOf" content="ADMIN" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="tasks.htm" title="Previous" type="text/html" />
<link rel="Next" href="schedover.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25494.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">37/49</span> <!-- End Header -->
<div id="ADMIN027" class="chapter"><a id="g1021210"></a> <a id="i1010776"></a>
<h1 class="chapter"><span class="secnum">27</span> Managing Resources with Oracle Database Resource Manager</h1>
<p>In this chapter:</p>
<ul>
<li>
<p><a href="#i1007556">About Oracle Database Resource Manager</a></p>
</li>
<li>
<p><a href="#i1008368">Assigning Sessions to Resource Consumer Groups</a></p>
</li>
<li>
<p><a href="#CHDEDAEA">The Types of Resources Managed by the Resource Manager</a></p>
</li>
<li>
<p><a href="#i1007878">Creating a Simple Resource Plan</a></p>
</li>
<li>
<p><a href="#i1008009">Creating a Complex Resource Plan</a></p>
</li>
<li>
<p><a href="#i1008488">Enabling Oracle Database Resource Manager and Switching Plans</a></p>
</li>
<li>
<p><a href="#i1008504">Putting It All Together: Oracle Database Resource Manager Examples</a></p>
</li>
<li>
<p><a href="#CFHJGBFC">Managing Multiple Database Instances on a Single Server</a></p>
</li>
<li>
<p><a href="#CHDJEGIG">Maintaining Consumer Groups, Plans, and Directives</a></p>
</li>
<li>
<p><a href="#CHDDAFAJ">Viewing Database Resource Manager Configuration and Status</a></p>
</li>
<li>
<p><a href="#i1008730">Monitoring Oracle Database Resource Manager</a></p>
</li>
<li>
<p><a href="#i1010600">Interacting with Operating-System Resource Control</a></p>
</li>
<li>
<p><a href="#CHDFFJGJ">Oracle Database Resource Manager Reference</a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This chapter discusses using PL/SQL package procedures to administer the Resource Manager. An easier way to administer the Resource Manager is with the graphical user interface of Enterprise Manager. For instructions about administering Resource Manager with Enterprise Manager, see <a class="olink ADMQS033" href="../../server.112/e10897/em_manage.htm#ADMQS033"><span class="italic">Oracle Database 2 Day DBA</span></a>.</div>
</li>
</ul>
<a id="i1007556"></a>
<div id="ADMIN11841" class="sect1">
<h2 class="sect1">About Oracle Database Resource Manager<a id="sthref2750"></a></h2>
<p>Oracle Database Resource Manager (the Resource Manager) enables you to manage multiple workloads within a database that are contending for system and database resources.</p>
<p>The following sections provide an overview of the Resource Manager:</p>
<ul>
<li>
<p><a href="#i1007577">What Solutions Does the Resource Manager Provide for Workload Management?</a></p>
</li>
<li>
<p><a href="#i1007599">Elements of the Resource Manager</a></p>
</li>
<li>
<p><a href="#CHDEDAEA">The Types of Resources Managed by the Resource Manager</a></p>
</li>
<li>
<p><a href="#i1007735">About Resource Manager Administration Privileges</a></p>
</li>
</ul>
<a id="i1007577"></a>
<div id="ADMIN11842" class="sect2">
<h3 class="sect2">What Solutions Does the Resource Manager Provide for Workload Management?</h3>
<p>When database resource allocation decisions are left to the operating system, you may encounter the following problems with workload management:</p>
<ul>
<li>
<p>Excessive overhead</p>
<p>Excessive overhead results from operating system context switching between Oracle Database server processes when the number of server processes is high.</p>
</li>
<li>
<p>Inefficient scheduling</p>
<p>The operating system deschedules database servers while they hold latches, which is inefficient.</p>
</li>
<li>
<p>Inappropriate allocation of resources</p>
<p>The operating system distributes resources equally among all active processes and cannot prioritize one task over another.</p>
</li>
<li>
<p>Inability to manage database-specific resources, such as parallel execution servers and active sessions</p>
</li>
</ul>
<p>The Resource Manager helps to overcome these problems by allowing the database more control over how hardware resources are allocated. In an environment with multiple concurrent user sessions that run jobs with differing priorities, all sessions should not be treated equally. The Resource Manager enables you to classify sessions into groups based on session attributes, and to then allocate resources to those groups in a way that optimizes hardware utilization for your application environment.</p>
<p>With the Resource Manager, you can:</p>
<ul>
<li>
<p>Guarantee certain sessions a minimum amount of CPU regardless of the load on the system and the number of users.</p>
</li>
<li>
<p>Distribute available CPU by allocating percentages of CPU time to different users and applications. In a data warehouse, a higher percentage can be given to ROLAP (relational online analytical processing) applications than to batch jobs.</p>
</li>
<li>
<p>Limit the degree of parallelism of any operation performed by members of a group of users.</p>
</li>
<li>
<p>Manage the order of parallel statements in the parallel statement queue. Parallel statements from a critical application can be enqueued ahead of parallel statements from a low priority group of users.</p>
</li>
<li>
<p>Limit the number of parallel servers that a group of users can use. This ensures that all the available parallel servers are not allocated to only one group of users.</p>
</li>
<li>
<p>Create an active session pool. An <span class="bold">active session pool</span> consists of a specified maximum number of user sessions allowed to be concurrently active within a group of users. Additional sessions beyond the maximum are queued for execution, but you can specify a timeout period, after which queued jobs will terminate. The active session pool limits the total number of sessions actively competing for resources, thereby enabling active sessions to make faster progress.</p>
</li>
<li>
<p>Manage runaway sessions or calls in the following ways:</p>
<ul>
<li>
<p>By placing an absolute limit on the percentage of CPU that a group can consume</p>
</li>
<li>
<p>By detecting when a session or call consumes more than a specified amount of CPU or I/O, and then automatically either terminating the session or call, or switching it to a consumer group that is allocated a small amount of CPU, which would in effect mitigate the impact of the runaway session or call</p>
</li>
</ul>
</li>
<li>
<p>Prevent the execution of operations that the optimizer estimates will run for a longer time than a specified limit.</p>
</li>
<li>
<p>Limit the amount of time that a session can be idle. This can be further defined to mean only sessions that are blocking other sessions.</p>
</li>
<li>
<p>Allow a database to use different resource plans, based on changing workload requirements. You can dynamically change the resource plan, for example, from a daytime resource plan to a nighttime resource plan, without having to shut down and restart the instance. You can also schedule a resource plan change with Oracle Scheduler. See <a href="schedover.htm#g1009892">Chapter 28, "Oracle Scheduler Concepts"</a> for more information.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1007599"></a>
<div id="ADMIN11844" class="sect2">
<h3 class="sect2">Elements of the Resource Manager</h3>
<p>The elements of the Resource Manager are described in the following table.</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Database Resource Management Elements" summary="Column 1 lists the elements of database resource management, column 2 describes each element." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t3">Element</th>
<th class="cellalignment1334" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t3" headers="r1c1-t3"><a id="sthref2751"></a><a id="sthref2752"></a>Resource consumer group</td>
<td class="cellalignment1335" headers="r2c1-t3 r1c2-t3">A group of sessions that are grouped together based on resource requirements. The Resource Manager allocates resources to resource consumer groups, not to individual sessions.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t3" headers="r1c1-t3"><a id="sthref2753"></a><a id="sthref2754"></a>Resource plan</td>
<td class="cellalignment1335" headers="r3c1-t3 r1c2-t3">A container for directives that specify how resources are allocated to resource consumer groups. You specify how the database allocates resources by activating a specific resource plan.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t3" headers="r1c1-t3"><a id="sthref2755"></a><a id="sthref2756"></a>Resource plan directive</td>
<td class="cellalignment1335" headers="r4c1-t3 r1c2-t3">Associates a resource consumer group with a particular plan and specifies how resources are to be allocated to that resource consumer group.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>You use the <code dir="ltr">DBMS_RESOURCE_MANAGER</code><a id="sthref2757"></a><a id="sthref2758"></a> PL/SQL package to create and maintain these elements. The elements are stored in tables in the data dictionary. You can view information about them with data dictionary views.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008772">"Resource Manager Data Dictionary Views"</a></div>
<a id="CFHBIJIA"></a>
<div id="ADMIN11845" class="sect3">
<h4 class="sect3">About Resource Consumer Groups</h4>
<p>A resource consumer group (consumer group) is a collection of user sessions that are grouped together based on their processing needs. When a session is created, it is automatically mapped to a consumer group based on mapping rules that you set up. As a database administrator (DBA), you can manually switch a session to a different consumer group. Similarly, an application can run a PL/SQL package procedure that switches its session to a particular consumer group.</p>
<p>Because the Resource Manager allocates resources (such as CPU) only to consumer groups, when a session becomes a member of a consumer group, its resource allocation is determined by the allocation for the consumer group.</p>
<p>There are special consumer groups that are always present in the data dictionary. They cannot be modified or deleted. They are:</p>
<ul>
<li>
<p><code dir="ltr">SYS_GROUP</code></p>
<p>This is the initial consumer group for all sessions created by user accounts <code dir="ltr">SYS</code> or <code dir="ltr">SYSTEM</code>. This initial consumer group can be overridden by session-to&ndash;consumer group mapping rules.</p>
</li>
<li>
<p><code dir="ltr">OTHER_GROUPS</code><a id="sthref2759"></a><a id="sthref2760"></a></p>
<p>This consumer group contains all sessions that have not been assigned to a consumer group. Every resource plan must contain a directive to <code dir="ltr">OTHER_GROUPS</code>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDJAJHE">Table 27-5, "Predefined Resource Consumer Groups"</a></p>
</li>
<li>
<p><a href="#CHDIGIII">"Specifying Session-to&ndash;Consumer Group Mapping Rules"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN11846" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2761"></a>
<h4 class="sect3">About Resource Plan Directives</h4>
<p>The Resource Manager allocates resources to consumer groups according to the set of resource plan directives (directives) that belong to the currently active resource plan. There is a parent-child relationship between a resource plan and its resource plan directives. Each directive references one consumer group, and no two directives for the currently active plan can reference the same consumer group.</p>
<p>A directive has several ways in which it can limit resource allocation for a consumer group. For example, it can control how much CPU the consumer group gets as a percentage of total CPU, and it can limit the total number of sessions that can be active in the consumer group. See <a href="#CHDEDAEA">"The Types of Resources Managed by the Resource Manager"</a> for more information.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11847" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2762"></a>
<h4 class="sect3">About Resource Plans</h4>
<p>In addition to the resource plans that are predefined for each Oracle database, you can create any number of resource plans. However, only one resource plan is active at a time. When a resource plan is active, each of its child resource plan directives controls resource allocation for a different consumer group. Each plan must include a directive that allocates resources to the consumer group named <code dir="ltr">OTHER_GROUPS</code>. <code dir="ltr">OTHER_GROUPS</code> applies to all sessions that belong to a consumer group that is not part of the currently active plan.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Although the term "resource plan" (or just "plan") denotes one element of the Resource Manager, in this chapter it is also used to refer to a complete <span class="italic">resource plan schema</span>, which includes the resource plan element itself, its resource plan directives, and the consumer groups that the directives reference. For example, when this chapter refers to the <code dir="ltr">DAYTIME</code> resource plan, it could mean either the resource plan element named <code dir="ltr">DAYTIME</code>, or the particular resource allocation schema that the <code dir="ltr">DAYTIME</code> resource plan and its directives define. Thus, for brevity, it is acceptable to say, "the <code dir="ltr">DAYTIME</code> plan favors interactive applications over batch applications."</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN11848" class="sect3"><a id="sthref2763"></a>
<h4 class="sect3">Example: A Simple Resource Plan</h4>
<p><a href="#i1007657">Figure 27-1</a> shows a simple resource plan for an organization that runs online transaction processing (OLTP) applications and reporting applications simultaneously during the daytime. The currently active plan, <code dir="ltr">DAYTIME</code>, allocates CPU resources among three resource consumer groups. Specifically, <code dir="ltr">OLTP</code> is allotted 75% of the CPU time, <code dir="ltr">REPORTS</code> is allotted 15%, and <code dir="ltr">OTHER_GROUPS</code> receives the remaining 10%.</p>
<div id="ADMIN13073" class="figure">
<p class="titleinfigure"><a id="i1007657"></a>Figure 27-1 A Simple Resource Plan</p>
<img width="386" height="227" src="img/admin078.gif" alt="Description of Figure 27-1 follows" /><br />
<a id="sthref2764" href="img_text/admin078.htm">Description of "Figure 27-1 A Simple Resource Plan"</a><br />
<br /></div>
<!-- class="figure" -->
<p>Oracle Database provides a procedure (<code dir="ltr">CREATE_SIMPLE_PLAN</code>) that enables you to quickly create a simple resource plan. This procedure is discussed in <a href="#i1007878">"Creating a Simple Resource Plan"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The currently active resource plan does not enforce allocations until CPU usage is at 100%. If the CPU usage is below 100%, the database is not CPU-bound and hence there is no need to enforce allocations to ensure that all sessions get their designated resource allocation.
<p>In addition, when allocations are enforced, unused allocation by any consumer group can be used by other consumer groups. In the previous example, if the <code dir="ltr">OLTP</code> group does not use all of its allocation, the Resource Manager permits the <code dir="ltr">REPORTS</code> group or <code dir="ltr">OTHER_GROUPS</code> group to use the unused allocation.</p>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN11849" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2765"></a>
<h4 class="sect3">About Subplans</h4>
<p>Instead of referencing a consumer group, a resource plan directive (directive) can reference another resource plan. In this case, the plan is referred to as a subplan. The subplan itself has directives that allocate resources to consumer groups and other subplans. The resource allocation scheme then works like this: The <span class="italic">top</span> resource plan (the currently active plan) divides resources among consumer groups and subplans. Each subplan allocates its portion of the total resource allocation among its consumer groups and subplans. You can create hierarchical plans with any number of subplans.</p>
<p>You create a resource subplan in the same way that you create a resource plan. To create a plan that is to be used only as a subplan, you use the <code dir="ltr">SUB_PLAN</code> argument in the package procedure <code dir="ltr">DBMS_RESOURCE_MANAGER.CREATE_PLAN</code>.</p>
<p>In any top level plan, you can reference a subplan only once. A subplan is not required to have a directive to <code dir="ltr">OTHER_GROUPS</code> and cannot be set as a resource plan.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11850" class="sect3"><a id="sthref2766"></a>
<h4 class="sect3">Example: A Resource Plan with Subplans</h4>
<p>In this example, the Great Bread Company allocates the CPU resource as shown in <a href="#i1007676">Figure 27-2</a>. The figure illustrates a top plan<a id="sthref2767"></a><a id="sthref2768"></a> (<code dir="ltr">GREAT_BREAD</code>) and all of its descendents. For simplicity, the requirement to include the <code dir="ltr">OTHER_GROUPS</code> consumer group is ignored, and resource plan directives are not shown, even though they are part of the plan. Rather, the CPU percentages that the directives allocate are shown along the connecting lines between plans, subplans, and consumer groups.</p>
<div id="ADMIN13074" class="figure">
<p class="titleinfigure"><a id="i1007676"></a>Figure 27-2 A Resource Plan With Subplans</p>
<img width="413" height="243" src="img/admin027.gif" alt="Description of Figure 27-2 follows" /><br />
<a id="sthref2769" href="img_text/admin027.htm">Description of "Figure 27-2 A Resource Plan With Subplans"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The <code dir="ltr">GREAT_BREAD</code> plan allocates resources as follows:</p>
<ul>
<li>
<p>20% of CPU resources to the consumer group <code dir="ltr">MARKET</code></p>
</li>
<li>
<p>60% of CPU resources to subplan <code dir="ltr">SALES_TEAM</code>, which in turn divides its share equally between the <code dir="ltr">WHOLESALE</code> and <code dir="ltr">RETAIL</code> consumer groups</p>
</li>
<li>
<p>20% of CPU resources to subplan <code dir="ltr">DEVELOP_TEAM</code>, which in turn divides its resources equally between the <code dir="ltr">BREAD</code> and <code dir="ltr">MUFFIN</code> consumer groups</p>
</li>
</ul>
<p>It is possible for a subplan or consumer group to have multiple parents. An example would be if the <code dir="ltr">MARKET</code> group were included in the <code dir="ltr">SALES_TEAM</code> subplan. However, a plan cannot contain any loops. For example, the <code dir="ltr">SALES_TEAM</code> subplan cannot have a directive that references the <code dir="ltr">GREAT_BREAD</code> plan.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008504">"Putting It All Together: Oracle Database Resource Manager Examples"</a> for an example of a more complex resource plan.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007735"></a>
<div id="ADMIN11860" class="sect2">
<h3 class="sect2">About Resource Manager<a id="sthref2770"></a> Administration Privileges</h3>
<p>You must have the system privilege <a id="sthref2771"></a><a id="sthref2772"></a><code dir="ltr">ADMINISTER_RESOURCE_MANAGER</code> to administer the Resource Manager. This privilege (with the <code dir="ltr">ADMIN</code> option) is granted to database administrators through the <code dir="ltr">DBA</code> role.</p>
<p>Being an administrator for the Resource Manager enables you to execute all of the procedures in the <a id="sthref2773"></a><a id="sthref2774"></a><code dir="ltr">DBMS_RESOURCE_MANAGER</code> PL/SQL package.</p>
<p>You may, as an administrator with the <code dir="ltr">ADMIN</code> option, choose to grant the administrative privilege to other users or roles. To do so, use the <a id="sthref2775"></a><a id="sthref2776"></a><code dir="ltr">DBMS_RESOURCE_MANAGER_PRIVS</code> PL/SQL package. The relevant package procedures are listed in the following table.</p>
<div class="inftblruleinformalwide">
<table class="cellalignment1333" title="DBMS_RESOURCE_MANAGER_PRIVS Procedures" summary="Column 1 lists the procedures of the DBMS_RESOURCE_MANAGER_PRIVS package, column 2 describes the function of each procedure." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t9">Procedure</th>
<th class="cellalignment1334" id="r1c2-t9">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t9" headers="r1c1-t9"><code dir="ltr">GRANT_SYSTEM_PRIVILEGE</code></td>
<td class="cellalignment1335" headers="r2c1-t9 r1c2-t9">Grants the <code dir="ltr">ADMINISTER_RESOURCE_MANAGER</code> system privilege to a user or role.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t9" headers="r1c1-t9"><code dir="ltr">REVOKE_SYSTEM_PRIVILEGE</code></td>
<td class="cellalignment1335" headers="r3c1-t9 r1c2-t9">Revokes the <code dir="ltr">ADMINISTER_RESOURCE_MANAGER</code> system privilege from a user or role.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformalwide" -->
<p>The following PL/SQL block grants the administrative privilege to user <code dir="ltr">HR</code>, but does not grant <code dir="ltr">HR</code> the <code dir="ltr">ADMIN</code> option. Therefore, <code dir="ltr">HR</code> can execute all of the procedures in the <code dir="ltr">DBMS_RESOURCE_MANAGER</code><a id="sthref2777"></a><a id="sthref2778"></a> package, but <code dir="ltr">HR</code> cannot use the <code dir="ltr">GRANT_SYSTEM_PRIVILEGE</code> procedure to grant the administrative privilege to others.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER_PRIVS.GRANT_SYSTEM_PRIVILEGE(
   GRANTEE_NAME   =&gt; 'HR',
   PRIVILEGE_NAME =&gt; 'ADMINISTER_RESOURCE_MANAGER',
   ADMIN_OPTION   =&gt; FALSE);
END;
/
</pre>
<p>You can revoke this privilege using the <code dir="ltr">REVOKE_SYSTEM_PRVILEGE</code> procedure.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">ADMINISTER_RESOURCE_MANAGER</code> system privilege can only be granted or revoked using the <code dir="ltr">DBMS_RESOURCE_MANAGER_PRIVS</code><a id="sthref2779"></a><a id="sthref2780"></a> package. It cannot be granted or revoked through the SQL <code dir="ltr">GRANT</code> or <code dir="ltr">REVOKE</code> statements.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference.</span></a> contains detailed information about the Resource Manager packages:
<ul>
<li>
<p><code dir="ltr">DBMS_RESOURCE_MANAGER</code></p>
</li>
<li>
<p><code dir="ltr">DBMS_RESOURCE_MANAGER_PRIVS</code></p>
</li>
</ul>
<p><a class="olink DBSEG99948" href="../../network.112/e36292/authorization.htm#DBSEG99948"><span class="italic">Oracle Database Security Guide</span></a> contains information about the <code dir="ltr">ADMIN</code> option.</p>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008368"></a>
<div id="ADMIN11873" class="sect1">
<h2 class="sect1">Assigning Sessions to Resource Consumer Groups<a id="sthref2781"></a><a id="sthref2782"></a></h2>
<p>This section describes the automatic and manual methods that database administrators, users, and applications can use to assign sessions to resource consumer groups. When a session is assigned to a resource consumer group, Oracle Database Resource Manager (the Resource Manager) can manage resource allocation for it.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Sessions that are not assigned to a consumer group are placed in the consumer group <code dir="ltr">OTHER_GROUPS</code>.</div>
<p>This section includes the following topics:</p>
<ul>
<li>
<p><a href="#CHDCBIJE">Overview of Assigning Sessions to Resource Consumer Groups</a></p>
</li>
<li>
<p><a href="#i1009363">Assigning an Initial Resource Consumer Group</a></p>
</li>
<li>
<p><a href="#CHDIGIII">Specifying Session-to&ndash;Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a href="#CACIIHGI">Switching Resource Consumer Groups</a></p>
</li>
<li>
<p><a href="#CHDEIHEB">Specifying Automatic Resource Consumer Group Switching</a></p>
</li>
<li>
<p><a href="#i1008409">Granting and Revoking the Switch Privilege</a></p>
</li>
</ul>
<a id="CHDCBIJE"></a>
<div id="ADMIN11874" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Overview of Assigning Sessions to Resource Consumer Groups</h3>
<p>Before you enable the Resource Manager, you must specify how user sessions are assigned to resource consumer groups. You do this by creating <span class="italic">mapping rules</span> that enable the Resource Manager to automatically assign each session to a consumer group upon session startup, based upon session attributes. After a session is assigned to its initial consumer group and is running, you can call a procedure to manually switch the session to a different consumer group. You would typically do this if the session is using excessive resources and must be moved to a consumer group that is more limited in its resource allocation. You can also grant the <span class="italic">switch privilege</span> to users and to applications so that they can switch their sessions from one consumer group to another.</p>
<p>The database can also automatically switch a session from one consumer group to another (typically lower priority) consumer group when there are changes in session attributes or when a session exceeds designated resource consumption limits.</p>
</div>
<!-- class="sect2" -->
<a id="i1009363"></a>
<div id="ADMIN11875" class="sect2">
<h3 class="sect2">Assigning an Initial Resource Consumer Group<a id="sthref2783"></a></h3>
<p>The initial consumer group of a session is determined by the mapping rules that you configure. For information on how to configure mapping rules, see <a href="#CHDIGIII">"Specifying Session-to&ndash;Consumer Group Mapping Rules"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="CHDIGIII"></a>
<div id="ADMIN11882" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Specifying Session-to&ndash;Consumer Group Mapping Rules</h3>
<p>This section provides background information about session-to&ndash;consumer group mapping rules, and describes how to create and prioritize them. The following topics are covered:</p>
<ul>
<li>
<p><a href="#CHDBHBFD">About Session-to&ndash;Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a href="#CHDEDAIB">Creating Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a href="#CFHDHHBJ">Modifying and Deleting Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a href="#CHDBHJIJ">Creating Mapping Rule Priorities</a></p>
</li>
</ul>
<a id="CHDBHBFD"></a>
<div id="ADMIN11883" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">About Session-to&ndash;Consumer Group Mapping Rules</h4>
<p>By creating session-to&ndash;consumer group mapping rules, you can:</p>
<ul>
<li>
<p>Specify the initial consumer group for a session based on session attributes.</p>
</li>
<li>
<p>Enable the Resource Manager to dynamically switch a running session to another consumer group based on changing session attributes.</p>
</li>
</ul>
<p>The mapping rules are based on session attributes such as the user name, the service that the session used to connect to the database, or the name of the client program.</p>
<p>To resolve conflicts among mapping rules, the Resource Manager orders the rules by priority. For example, suppose user <code dir="ltr">SCOTT</code> connects to the database with the <code dir="ltr">SALES</code> service. If one mapping rule states that user <code dir="ltr">SCOTT</code> starts in the <code dir="ltr">MED_PRIORITY</code> consumer group, and another states that sessions that connect with the <code dir="ltr">SALES</code> service start in the <code dir="ltr">HIGH_PRIORITY</code> consumer group, mapping rule priorities resolve this conflict.</p>
<p>There are two types of session attributes upon which mapping rules are based: login attributes and run-time attributes. The login attributes are meaningful only at session login time, when the Resource Manager determines the initial consumer group of the session. Run-time attributes apply any time during and after session login. You can reassign a logged in session to another consumer group by changing any of its run-time attributes.</p>
<p>You use the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> and <code dir="ltr">SET_CONSUMER_GROUP_MAPPING_PRI</code> procedures to configure the automatic assignment of sessions to consumer groups. You must use a pending area for these procedures. (You must create the pending area, run the procedures, optionally validate the pending area, and then submit the pending area. For examples of using the pending area, see <a href="#i1008009">"Creating a Complex Resource Plan"</a>.)</p>
<p>A session is automatically switched to a consumer group through mapping rules at distinct points in time:</p>
<ul>
<li>
<p>When the session first logs in, the mapping rules are evaluated to determine the initial group of the session.</p>
</li>
<li>
<p>If a session attribute is dynamically changed to a new value (which is only possible for run-time attributes), then the mapping rules are reevaluated, and the session might be switched to another consumer group.</p>
</li>
</ul>
<p class="subhead2"><a id="ADMIN13325"></a>Predefined Consumer Group Mapping Rules</p>
<p>Each Oracle database comes with a set of predefined consumer group mapping rules:</p>
<ul>
<li>
<p>As described in <a href="#CFHBIJIA">"About Resource Consumer Groups"</a>, all sessions created by user accounts <code dir="ltr">SYS</code> or <code dir="ltr">SYSTEM</code> are initially mapped to the <code dir="ltr">SYS_GROUP</code> consumer group.</p>
</li>
<li>
<p>Sessions performing a data load with Data Pump or performing backup or copy operations with RMAN are automatically mapped to the predefined consumer groups designated in <a href="#CHDHJCHG">Table 27-6</a>.</p>
</li>
</ul>
<p>You can use the <code dir="ltr">DBMS_RESOURCE_MANAGER</code>.<code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure to modify or delete any of these predefined mapping rules.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1009363">"Assigning an Initial Resource Consumer Group"</a></p>
</li>
<li>
<p><a href="#CHDDHCFE">"Specifying Automatic Switching with Mapping Rules"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<a id="CHDEDAIB"></a>
<div id="ADMIN11884" class="sect3">
<h4 class="sect3">Creating Consumer Group Mapping Rules</h4>
<p>You use the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure to map a session attribute/value pair to a consumer group. The parameters for this procedure are the following:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Parameters of the SET_CONSUMER_GROUP_MAPPING Procedure" summary="Column 1 lists the parameters used with the consumer group mapping procedure, column 2 explains their usage." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t14">Parameter</th>
<th class="cellalignment1334" id="r1c2-t14">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t14" headers="r1c1-t14"><code dir="ltr">ATTRIBUTE</code></td>
<td class="cellalignment1335" headers="r2c1-t14 r1c2-t14">The session attribute type, specified as a package constant</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t14" headers="r1c1-t14"><code dir="ltr">VALUE</code></td>
<td class="cellalignment1335" headers="r3c1-t14 r1c2-t14">The value of the attribute</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t14" headers="r1c1-t14"><code dir="ltr">CONSUMER_GROUP</code></td>
<td class="cellalignment1335" headers="r4c1-t14 r1c2-t14">The consumer group to map to for this attribute/value pair</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p><code dir="ltr">ATTRIBUTE</code> can be one of the following:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="The ATTRIBUTE Parameter of the SET_CONSUMER_GROUP_MAPPING Procedure" summary="Column 1 lists the attributes values that can be set with the ATTRIBUTE parameter of the SET_CONSUMER_GROUP_MAPPING procedure. Column 2 lists the type of the attribute, and column 3 describes its purpose." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t15">Attribute</th>
<th class="cellalignment1334" id="r1c2-t15">Type</th>
<th class="cellalignment1334" id="r1c3-t15">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t15" headers="r1c1-t15"><code dir="ltr">ORACLE_USER</code></td>
<td class="cellalignment1335" headers="r2c1-t15 r1c2-t15">Login</td>
<td class="cellalignment1335" headers="r2c1-t15 r1c3-t15">The Oracle Database user name</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t15" headers="r1c1-t15"><code dir="ltr">SERVICE_NAME</code></td>
<td class="cellalignment1335" headers="r3c1-t15 r1c2-t15">Login</td>
<td class="cellalignment1335" headers="r3c1-t15 r1c3-t15">The database service name used by the client to establish a connection</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t15" headers="r1c1-t15"><code dir="ltr">CLIENT_OS_USER</code></td>
<td class="cellalignment1335" headers="r4c1-t15 r1c2-t15">Login</td>
<td class="cellalignment1335" headers="r4c1-t15 r1c3-t15">The operating system user name of the client that is logging in</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t15" headers="r1c1-t15"><code dir="ltr">CLIENT_PROGRAM</code></td>
<td class="cellalignment1335" headers="r5c1-t15 r1c2-t15">Login</td>
<td class="cellalignment1335" headers="r5c1-t15 r1c3-t15">The name of the client program used to log in to the server</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t15" headers="r1c1-t15"><code dir="ltr">CLIENT_MACHINE</code></td>
<td class="cellalignment1335" headers="r6c1-t15 r1c2-t15">Login</td>
<td class="cellalignment1335" headers="r6c1-t15 r1c3-t15">The name of the computer from which the client is making the connection</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t15" headers="r1c1-t15"><code dir="ltr">CLIENT_ID</code></td>
<td class="cellalignment1335" headers="r7c1-t15 r1c2-t15">Login</td>
<td class="cellalignment1335" headers="r7c1-t15 r1c3-t15">The client identifier for the session
<p>The client identifier session attribute is set by the <code dir="ltr">DBMS_SESSION.SET_IDENTIFIER</code> procedure.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t15" headers="r1c1-t15"><code dir="ltr">MODULE_NAME</code></td>
<td class="cellalignment1335" headers="r8c1-t15 r1c2-t15">Run-time</td>
<td class="cellalignment1335" headers="r8c1-t15 r1c3-t15">The module name in the currently running application as set by the <code dir="ltr">DBMS_APPLICATION_INFO.SET_MODULE</code> procedure or the equivalent OCI attribute setting</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t15" headers="r1c1-t15"><code dir="ltr">MODULE_NAME_ACTION</code></td>
<td class="cellalignment1335" headers="r9c1-t15 r1c2-t15">Run-time</td>
<td class="cellalignment1335" headers="r9c1-t15 r1c3-t15">A combination of the current module and the action being performed as set by either of the following procedures or their equivalent OCI attribute setting:
<ul>
<li>
<p><code dir="ltr">DBMS_APPLICATION_INFO.SET_MODULE</code></p>
</li>
<li>
<p><code dir="ltr">DBMS_APPLICATION_INFO.SET_ACTION</code></p>
</li>
</ul>
<p>The attribute is specified as the module name followed by a period (.), followed by the action name (<code dir="ltr"><span class="codeinlineitalic">module_name.action_name</span></code>).</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r10c1-t15" headers="r1c1-t15"><code dir="ltr">SERVICE_MODULE</code></td>
<td class="cellalignment1335" headers="r10c1-t15 r1c2-t15">Run-time</td>
<td class="cellalignment1335" headers="r10c1-t15 r1c3-t15">A combination of service and module names in this form: <code dir="ltr"><span class="codeinlineitalic">service_name.module_name</span></code></td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r11c1-t15" headers="r1c1-t15"><code dir="ltr">SERVICE_MODULE_ACTION</code></td>
<td class="cellalignment1335" headers="r11c1-t15 r1c2-t15">Run-time</td>
<td class="cellalignment1335" headers="r11c1-t15 r1c3-t15">A combination of service name, module name, and action name, in this form: <code dir="ltr"><span class="codeinlineitalic">service_name.module_name.action_name</span></code></td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r12c1-t15" headers="r1c1-t15"><code dir="ltr">ORACLE_FUNCTION</code></td>
<td class="cellalignment1335" headers="r12c1-t15 r1c2-t15">Run-time</td>
<td class="cellalignment1335" headers="r12c1-t15 r1c3-t15">An RMAN or Data Pump operation. Valid values are <code dir="ltr">DATALOAD</code>, <code dir="ltr">BACKUP</code>, and <code dir="ltr">COPY</code>. There are predefined mappings for each of these values. If your session is performing any of these functions, it is automatically mapped to a predefined consumer group. See <a href="#CHDHJCHG">Table 27-6</a> for details.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>For example, the following PL/SQL block causes user <code dir="ltr">SCOTT</code> to map to the <code dir="ltr">DEV_GROUP</code> consumer group every time that he logs in:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.SET_CONSUMER_GROUP_MAPPING  
     (DBMS_RESOURCE_MANAGER.ORACLE_USER, 'SCOTT', 'DEV_GROUP');
END;
/
</pre>
<p>Again, you must create a pending area before running the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure.</p>
<p>You can use wildcards for the value of most attributes in the <code dir="ltr">value</code> parameter in the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure. To specify values with wildcards, use the same semantics as the SQL <code dir="ltr">LIKE</code> operator. Specifically, wildcards use the following semantics:</p>
<ul>
<li>
<p><code dir="ltr">%</code> for a multicharacter wildcard</p>
</li>
<li>
<p><code dir="ltr">_</code> for a single character wildcard</p>
</li>
<li>
<p><code dir="ltr">\</code> to escape the wildcards</p>
</li>
</ul>
<p>Wildcards can only be used if the attribute is one of the following:</p>
<ul>
<li>
<p><code dir="ltr">CLIENT_OS_USER</code></p>
</li>
<li>
<p><code dir="ltr">CLIENT_PROGRAM</code></p>
</li>
<li>
<p><code dir="ltr">CLIENT_MACHINE</code></p>
</li>
<li>
<p><code dir="ltr">MODULE_NAME</code></p>
</li>
<li>
<p><code dir="ltr">MODULE_NAME_ACTION</code></p>
</li>
<li>
<p><code dir="ltr">SERVICE_MODULE</code></p>
</li>
<li>
<p><code dir="ltr">SERVICE_MODULE_ACTION</code></p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<a id="CFHDHHBJ"></a>
<div id="ADMIN13326" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Modifying and Deleting Consumer Group Mapping Rules</h4>
<p>To modify a consumer group mapping rule, run the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure against the desired attribute/value pair, specifying a new consumer group. To delete a rule, run the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure against the desired attribute/value pair and specify a <code dir="ltr">NULL</code> consumer group.</p>
</div>
<!-- class="sect3" -->
<a id="CHDBHJIJ"></a>
<div id="ADMIN11885" class="sect3">
<h4 class="sect3">Creating Mapping Rule Priorities</h4>
<p>To resolve conflicting mapping rules, you can establish a priority ordering of the session attributes from most important to least important. You use the <code dir="ltr">SET_CONSUMER_GROUP_MAPPING_PRI</code> procedure to set the priority of each attribute to a unique integer from 1 (most important) to 12 (least important). The following example illustrates this setting of priorities:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.SET_CONSUMER_GROUP_MAPPING_PRI(
    EXPLICIT =&gt; 1,
    SERVICE_MODULE_ACTION =&gt; 2,
    SERVICE_MODULE =&gt; 3,
    MODULE_NAME_ACTION =&gt; 4,
    MODULE_NAME =&gt; 5,
    SERVICE_NAME =&gt; 6,
    ORACLE_USER =&gt; 7,
    CLIENT_PROGRAM =&gt; 8,
    CLIENT_OS_USER =&gt; 9,
    CLIENT_MACHINE =&gt; 10,
    CLIENT_ID =&gt; 11);
END;
/
</pre>
<p>In this example, the priority of the database user name is set to 7 (less important), while the priority of the module name is set to 5 (more important).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<code dir="ltr">SET_CONSUMER_GROUP_MAPPING_PRI</code> requires that you include the pseudo-attribute <code dir="ltr">EXPLICIT</code> as an argument. It must be set to 1. It indicates that explicit consumer group switches have the highest priority. You explicitly switch consumer groups with these package procedures, which are described in detail in <a class="olink ARPLS" href="../../appdev.112/e40758/toc.htm"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a>:
<ul>
<li>
<p><code dir="ltr">DBMS_SESSION.SWITCH_CURRENT_CONSUMER_GROUP</code></p>
</li>
<li>
<p><code dir="ltr">DBMS_RESOURCE_MANAGER.SWITCH_CONSUMER_GROUP_FOR_SESS</code></p>
</li>
<li>
<p><code dir="ltr">DBMS_RESOURCE_MANAGER.SWITCH_CONSUMER_GROUP_FOR_USER</code></p>
</li>
</ul>
</div>
<p>To illustrate how mapping rule priorities work, continuing with the previous example, assume that in addition to the mapping of user <code dir="ltr">SCOTT</code> to the <code dir="ltr">DEV_GROUP</code> consumer group, there is also a module name mapping rule as follows:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.SET_CONSUMER_GROUP_MAPPING
     (DBMS_RESOURCE_MANAGER.MODULE_NAME, 'EOD_REPORTS', 'LOW_PRIORITY');
END;
/
</pre>
<p>Now if the application in user <code dir="ltr">SCOTT</code>'s session sets its module name to <code dir="ltr">EOD_REPORTS</code>, the session is reassigned to the <code dir="ltr">LOW_PRIORITY</code> consumer group, because module name mapping has a higher priority than database user mapping.</p>
<p>You can query the view <code dir="ltr">DBA_RSRC_MAPPING_PRIORITY</code> to see the current priority ordering of session attributes.</p>
<p>To prevent unauthorized clients from setting their session attributes so that they map to higher priority consumer groups, user switch privileges for consumer groups are enforced. Thus, even though the attribute of a particular session matches a mapping pair, the mapping rule is ignored if the session does not have the switch privilege for the designated consumer group.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ARPLS003" href="../../appdev.112/e40758/d_appinf.htm#ARPLS003"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about setting the module name with the <code dir="ltr">DBMS_APPLICATION_INFO.SET_MODULE</code> procedure</p>
</li>
<li>
<p><a href="#i1008409">"Granting and Revoking the Switch Privilege"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACIIHGI"></a>
<div id="ADMIN13498" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Switching Resource Consumer Groups</h3>
<p>This section describes ways to switch the resource consumer group of a session.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1009371">Manually Switching Resource Consumer Groups</a></p>
</li>
<li>
<p><a href="#CHDJJIGJ">Enabling Users or Applications to Manually Switch Consumer Groups</a></p>
</li>
</ul>
<a id="i1009371"></a>
<div id="ADMIN11876" class="sect3">
<h4 class="sect3">Manually Switching Resource Consumer Groups<a id="sthref2784"></a></h4>
<p>The <a id="sthref2785"></a><a id="sthref2786"></a><code dir="ltr">DBMS_RESOURCE_MANAGER</code> PL/SQL package provides two procedures that enable you to change the resource consumer group of running sessions. Both of these procedures can also change the consumer group of any parallel execution server sessions associated with the coordinator session. The changes made by these procedures pertain to current sessions only; they are not persistent. They also do not change the initial consumer groups for users.</p>
<p>Instead of killing (terminating) a session of a user who is using excessive CPU, you can change that user's consumer group to one that is allocated fewer resources.</p>
<div id="ADMIN11877" class="sect4"><a id="sthref2787"></a>
<h5 class="sect4">Switching a Single Session<a id="sthref2788"></a></h5>
<p>The <code dir="ltr">SWITCH_CONSUMER_GROUP_FOR_SESS</code> procedure causes the specified session to immediately be moved into the specified resource consumer group. In effect, this procedure can raise or lower priority of the session.</p>
<p>The following PL/SQL block switches a specific session to a new consumer group. The session identifier (<code dir="ltr">SID</code>) is 17, the session serial number (<code dir="ltr">SERIAL#</code>) is 12345, and the new consumer group is the <code dir="ltr">HIGH_PRIORITY</code> consumer group.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.SWITCH_CONSUMER_GROUP_FOR_SESS ('17', '12345',
   'HIGH_PRIORITY');
END;
/
</pre>
<p>The <code dir="ltr">SID</code>, session serial number, and current resource consumer group for a session are viewable using the <code dir="ltr">V$SESSION</code> view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30223" href="../../server.112/e40402/dynviews_3016.htm#REFRN30223"><span class="italic">Oracle Database Reference</span></a> for details about the <code dir="ltr">V$SESSION</code> view.</div>
</div>
<!-- class="sect4" -->
<div id="ADMIN11878" class="sect4"><a id="sthref2789"></a>
<h5 class="sect4">Switching All Sessions for a User<a id="sthref2790"></a></h5>
<p>The <code dir="ltr">SWITCH_CONSUMER_GROUP_FOR_USER</code> procedure changes the resource consumer group for all sessions pertaining to the specified user name. The following PL/SQL block switches all sessions that belong to user <code dir="ltr">HR</code> to the <code dir="ltr">LOW_GROUP</code> consumer group:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.SWITCH_CONSUMER_GROUP_FOR_USER ('HR',
    'LOW_GROUP'); 
END;
/
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CHDJJIGJ"></a>
<div id="ADMIN11886" class="sect3">
<h4 class="sect3">Enabling Users or Applications to Manually Switch Consumer Groups</h4>
<p>You can grant a user the switch privilege so that he can switch his current consumer group using the <code dir="ltr">SWITCH_CURRENT_CONSUMER_GROUP</code> procedure in the <code dir="ltr">DBMS_SESSION</code> package. A user can run this procedure from an interactive session, for example from SQL*Plus, or an application can call this procedure to switch its session, effectively dynamically changing its priority.</p>
<p>The <code dir="ltr">SWITCH_CURRENT_CONSUMER_GROUP</code> procedure enables users to switch to only those consumer groups for which they have the switch privilege. If the caller is another procedure, then this procedure enables users to switch to a consumer group for which the owner of that procedure has switch privileges.</p>
<p>The parameters for this procedure are the following<a id="sthref2791"></a>:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Parameters of the SWITCH_CURRENT_CONSUMER_GROUP Procedure" summary="Column 1 contains the parameters that can be used for switching consumer groups, column 2 explains the use of each parameter." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t19">Parameter</th>
<th class="cellalignment1334" id="r1c2-t19">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t19" headers="r1c1-t19"><code dir="ltr">NEW_CONSUMER_GROUP</code></td>
<td class="cellalignment1335" headers="r2c1-t19 r1c2-t19">The consumer group to which the user is switching.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t19" headers="r1c1-t19"><code dir="ltr">OLD_CONSUMER_GROUP</code></td>
<td class="cellalignment1335" headers="r3c1-t19 r1c2-t19">Returns the name of the consumer group from which the user switched. Can be used to switch back later.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t19" headers="r1c1-t19"><code dir="ltr">INITIAL_GROUP_ON_ERROR</code></td>
<td class="cellalignment1335" headers="r4c1-t19 r1c2-t19">Controls behavior if a switching error occurs.
<p>If <code dir="ltr">TRUE</code>, in the event of an error, the user is switched to the initial consumer group.</p>
<p>If <code dir="ltr">FALSE</code>, raises an error.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>The following SQL*Plus session illustrates switching to a new consumer group. By printing the value of the output parameter <code dir="ltr">old_group</code>, the example illustrates how the old consumer group name is saved.</p>
<pre dir="ltr">
SET serveroutput on
DECLARE
    old_group varchar2(30);
BEGIN
  DBMS_SESSION.SWITCH_CURRENT_CONSUMER_GROUP('BATCH_GROUP', old_group, FALSE);
  DBMS_OUTPUT.PUT_LINE('OLD GROUP = ' || old_group);
END;
/
</pre>
<p>The following line is output:</p>
<pre dir="ltr">
OLD GROUP = OLTP_GROUP
</pre>
<p>Note that the Resource Manager considers a switch to have taken place even if the <code dir="ltr">SWITCH_CURRENT_CONSUMER_GROUP</code> procedure is called to switch the session to the consumer group that it is already in.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The Resource Manager also works in environments where a generic database user name is used to log on to an application. The <code dir="ltr">DBMS_SESSION</code> package can be called to switch the consumer group assignment of a session at session startup, or as particular modules are called.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS054" href="../../appdev.112/e40758/d_sessio.htm#ARPLS054"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for additional examples and more information about the <code dir="ltr">DBMS_SESSION</code> package</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDEIHEB"></a>
<div id="ADMIN11879" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Specifying Automatic Resource Consumer Group Switching</h3>
<p>You can configure the Resource Manager to automatically switch a session to another consumer group when a certain condition is met. Automatic switching can occur when:</p>
<ul>
<li>
<p>A session attribute changes, causing a new mapping rule to take effect.</p>
</li>
<li>
<p>A session exceeds the CPU or I/O resource consumption limits set by its consumer group.</p>
</li>
</ul>
<p>The following sections provide details:</p>
<ul>
<li>
<p><a href="#CHDDHCFE">Specifying Automatic Switching with Mapping Rules</a></p>
</li>
<li>
<p><a href="#CHDDCGGG">Specifying Automatic Switching by Setting Resource Limits</a></p>
</li>
</ul>
<a id="CHDDHCFE"></a>
<div id="ADMIN11880" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying Automatic Switching with Mapping Rules</h4>
<p>If a session attribute changes while the session is running, then the session-to&ndash;consumer group mapping rules are reevaluated. If a new rule takes effect, then the session might be moved to a different consumer group. See <a href="#CHDIGIII">"Specifying Session-to&ndash;Consumer Group Mapping Rules"</a> for more information.</p>
</div>
<!-- class="sect3" -->
<a id="CHDDCGGG"></a>
<div id="ADMIN11881" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Specifying Automatic Switching by Setting Resource Limits</h4>
<p>This section describes managing runaway sessions or calls that use CPU or I/O resources beyond a specified limit. A runaway session is a SQL query, while a runaway call is a PL/SQL call.</p>
<p>When you create a resource plan directive for a consumer group, you can specify limits for CPU and I/O resource consumption for sessions in that group. You can then specify the action that is to be taken if any single call within a session exceeds one of these limits. The possible actions are the following:</p>
<ul>
<li>
<p>The session is dynamically switched to a designated consumer group.</p>
<p>The target consumer group is typically one that has lower resource allocations. The session's user must have <span class="italic">switch privileges</span> on the new consumer group, otherwise the switch cannot occur. See <a href="#i1008409">"Granting and Revoking the Switch Privilege"</a> for more information.</p>
</li>
<li>
<p>The session is killed (terminated).</p>
</li>
<li>
<p>The session's current SQL statement is aborted.</p>
</li>
</ul>
<p>The following are the resource plan directive attributes that are involved in this type of automatic session switching.</p>
<ul>
<li>
<p><code dir="ltr">SWITCH_GROUP</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_TIME</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_ESTIMATE</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_IO_MEGABYTES</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_IO_REQS</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_FOR_CALL</code></p>
</li>
</ul>
<p>See <a href="#i1008232">"Creating Resource Plan Directives"</a> for descriptions of these attributes.</p>
<p>Switches occur for sessions that are running and consuming resources, not waiting for user input or waiting for CPU cycles. After a session is switched, it continues in the target consumer group until it becomes idle, at which point it is switched back to its original consumer group. However, if <code dir="ltr">SWITCH_FOR_CALL</code> is set to <code dir="ltr">TRUE</code>, then the Resource Manager does not wait until the session is idle to return it to its original resource consumer group. Instead, the session is returned when the current top-level call completes. A <span class="bold">top-level call</span> in PL/SQL is an entire PL/SQL block treated as one call. A top-level call in SQL is an individual SQL statement.</p>
<p>The Resource Manager views a session as idle if a certain amount of time passes between calls. This time interval is not configurable.</p>
<p><code dir="ltr">SWITCH_FOR_CALL</code> is useful for three-tier applications where the middle tier server is using session pooling.</p>
<p>A switched session is allowed to continue running even if the active session pool for the new group is full. Under these conditions, a consumer group can have more sessions running than specified by its active session pool.</p>
<p>The following are examples of automatic switching based on resource limits:</p>
<p class="subhead2"><a id="ADMIN12657"></a>Example 1</p>
<p>The following PL/SQL block creates a resource plan directive for the <code dir="ltr">OLTP</code> group that switches any session in that group to the <code dir="ltr">LOW_GROUP</code> consumer group if a call in the sessions exceeds 5 seconds of CPU time. This example prevents unexpectedly long queries from consuming too many resources. The switched-to consumer group is typically one with lower resource allocations.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
   PLAN             =&gt; 'DAYTIME',
   GROUP_OR_SUBPLAN =&gt; 'OLTP',
   COMMENT          =&gt; 'OLTP group',
   MGMT_P1          =&gt; 75,
   SWITCH_GROUP     =&gt; 'LOW_GROUP',
   SWITCH_TIME      =&gt; 5);
END;
/
</pre>
<p class="subhead2"><a id="ADMIN12658"></a>Example 2</p>
<p>The following PL/SQL block creates a resource plan directive for the <code dir="ltr">OLTP</code> group that temporarily switches any session in that group to the <code dir="ltr">LOW_GROUP</code> consumer group if the session exceeds 10,000 I/O requests or exceeds 2,500 Megabytes of data transferred. The session is returned to its original group after the offending top call is complete.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
   PLAN                =&gt; 'DAYTIME',
   GROUP_OR_SUBPLAN    =&gt; 'OLTP',
   COMMENT             =&gt; 'OLTP group',
   MGMT_P1             =&gt; 75,
   SWITCH_GROUP        =&gt; 'LOW_GROUP',
   SWITCH_IO_REQS      =&gt; 10000,
   SWITCH_IO_MEGABYTES =&gt; 2500,
   SWITCH_FOR_CALL     =&gt; TRUE);
END;
/
</pre>
<p class="subhead2"><a id="ADMIN12659"></a>Example 3</p>
<p>The following PL/SQL block creates a resource plan directive for the <code dir="ltr">REPORTING</code> group that kills (terminates) any session that exceeds 60 seconds of CPU time. This example prevents runaway queries from consuming too many resources.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
   PLAN             =&gt; 'DAYTIME',
   GROUP_OR_SUBPLAN =&gt; 'REPORTING',
   COMMENT          =&gt; 'Reporting group',
   MGMT_P1          =&gt; 75,
   SWITCH_GROUP     =&gt; 'KILL_SESSION',
   SWITCH_TIME      =&gt; 60);
END;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1008232">"Creating Resource Plan Directives"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008409"></a>
<div id="ADMIN11887" class="sect2">
<h3 class="sect2">Granting and Revoking the Switch Privilege<a id="sthref2792"></a></h3>
<p>Using the <code dir="ltr">DBMS_RESOURCE_MANAGER_PRIVS</code> PL/SQL package, you can grant or revoke the switch privilege to a user, role, or <code dir="ltr">PUBLIC</code>. The switch privilege enables a user or application to switch a session to a specified resource consumer group. It also enables the database to automatically switch a session to a consumer group specified in a session-to&ndash;consumer group mapping rule or specified in the <code dir="ltr">SWITCH_GROUP</code> parameter of a resource plan directive. The package also enables you to revoke the switch privilege. The relevant package procedures are listed in the following table.</p>
<div class="inftblruleinformalwide">
<table class="cellalignment1333" title="DBMS_RESOURCE_MANAGER_PRIVS Procedures" summary="Column 1 lists the procedures of the DBMS_RESOURCE_MANAGER_PRIVS package, column 2 describes the function of each procedure." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t23">Procedure</th>
<th class="cellalignment1334" id="r1c2-t23">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t23" headers="r1c1-t23"><code dir="ltr">GRANT_SWITCH_CONSUMER_GROUP</code></td>
<td class="cellalignment1335" headers="r2c1-t23 r1c2-t23">Grants permission to a user, role, or <code dir="ltr">PUBLIC</code> to switch to a specified resource consumer group.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t23" headers="r1c1-t23"><code dir="ltr">REVOKE_SWITCH_CONSUMER_GROUP</code></td>
<td class="cellalignment1335" headers="r3c1-t23 r1c2-t23">Revokes permission for a user, role, or <code dir="ltr">PUBLIC</code> to switch to a specified resource consumer group.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformalwide" -->
<p><a id="sthref2793"></a><a id="sthref2794"></a><code dir="ltr">OTHER_GROUPS</code> has switch privileges granted to <code dir="ltr">PUBLIC</code>. Therefore, all users are automatically granted the switch privilege for this consumer group.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDJJIGJ">"Enabling Users or Applications to Manually Switch Consumer Groups"</a></p>
</li>
<li>
<p><a href="#CHDEIHEB">"Specifying Automatic Resource Consumer Group Switching"</a></p>
</li>
</ul>
</div>
<div id="ADMIN11888" class="sect3"><a id="sthref2795"></a>
<h4 class="sect3">Granting the Switch Privilege</h4>
<p>The following example grants user <code dir="ltr">SCOTT</code> the privilege to switch to consumer group <code dir="ltr">OLTP</code>.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER_PRIVS.GRANT_SWITCH_CONSUMER_GROUP (
   GRANTEE_NAME   =&gt; 'SCOTT',
   CONSUMER_GROUP =&gt; 'OLTP',
   GRANT_OPTION   =&gt;  TRUE);
END;
/
</pre>
<p>User <code dir="ltr">SCOTT</code> is also granted permission to grant switch privileges for <code dir="ltr">OLTP</code> to others.</p>
<p>If you grant permission to a role to switch to a particular resource consumer group, then any user who is granted that role and has enabled that role can switch his session to that consumer group.</p>
<p>If you grant <code dir="ltr">PUBLIC</code> the permission to switch to a particular consumer group, then any user can switch to that group.</p>
<p>If the <code dir="ltr">GRANT_OPTION</code> argument is <code dir="ltr">TRUE</code>, then users granted switch privilege for the consumer group can also grant switch privileges for that consumer group to others.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11889" class="sect3"><a id="sthref2796"></a>
<h4 class="sect3">Revoking Switch Privileges<a id="sthref2797"></a></h4>
<p>The following example revokes user <code dir="ltr">SCOTT</code>'s privilege to switch to consumer group <code dir="ltr">OLTP</code>.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER_PRIVS.REVOKE_SWITCH_CONSUMER_GROUP (
   REVOKEE_NAME   =&gt; 'SCOTT', 
   CONSUMER_GROUP =&gt; 'OLTP');
END;
/
</pre>
<p>If you revoke a user's switch privileges for a particular consumer group, any subsequent attempts by that user to switch to that consumer group, either manually or automatically through consumer group mapping rules, will fail. The user's session will then be automatically assigned to <code dir="ltr">OTHER_GROUPS</code>.</p>
<p>If you revoke from a role the switch privileges to a consumer group, any users who had switch privileges for the consumer group only through that role are no longer able to switch to that consumer group.</p>
<p>If you revoke switch privileges to a consumer group from <code dir="ltr">PUBLIC</code>, any users other than those who are explicitly assigned switch privileges either directly or through a role are no longer able to switch to that consumer group.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDEDAEA"></a>
<div id="ADMIN11851" class="sect1">
<h2 class="sect1">The Types of Resources Managed by the Resource Manager</h2>
<p>Resource plan directives specify how resources are allocated to resource consumer groups or subplans. Each directive can specify several different methods for allocating resources to its consumer group or subplan. The following sections summarize these resource allocation methods:</p>
<ul>
<li>
<p><a href="#CHDBFGGD">CPU</a></p>
</li>
<li>
<p><a href="#CHDDDBCD">Degree of Parallelism Limit</a></p>
</li>
<li>
<p><a href="#BABEBJJJ">Parallel Target Percentage</a></p>
</li>
<li>
<p><a href="#BABFAAIB">Parallel Queue Timeout</a></p>
</li>
<li>
<p><a href="#CHDEDIHA">Active Session Pool with Queuing</a></p>
</li>
<li>
<p><a href="#CHDIGAHB">Automatic Consumer Group Switching</a></p>
</li>
<li>
<p><a href="#CHDCDCBA">Canceling SQL and Terminating Sessions</a></p>
</li>
<li>
<p><a href="#CHDBFHEI">Execution Time Limit</a></p>
</li>
<li>
<p><a href="#CHDBGIBD">Undo Pool</a></p>
</li>
<li>
<p><a href="#CHDIJJDJ">Idle Time Limit</a></p>
</li>
</ul>
<a id="CHDBFGGD"></a>
<div id="ADMIN11852" class="sect2">
<h3 class="sect2"><a id="sthref2798"></a>CPU</h3>
<p>To manage CPU resources, Resource Manager allocates resources among consumer groups and redistributes CPU resources that were allocated but were not used. You can also set a limit on the amount of CPU resources that can be allocated to a particular consumer group.</p>
<p>Resource Manager provides the following resource plan directive attributes to control CPU resource allocation:</p>
<ul>
<li>
<p><a href="#BABBCDEF">Management Attributes</a></p>
</li>
<li>
<p><a href="#BABBBBCC">Maximum Utilization Limit</a></p>
</li>
</ul>
<p class="subhead2"><a id="BABBCDEF"></a><a id="ADMIN13465"></a>Management Attributes</p>
<p>Management attributes enable you to specify how CPU resources are to be allocated among consumer groups and subplans. Multiple levels of CPU resource allocation (up to eight levels) provide a means of prioritizing CPU usage within a plan<a id="sthref2799"></a><a id="sthref2800"></a><a id="sthref2801"></a>. Consumer groups and subplans at level 2 get resources that were not allocated at level 1 or that were allocated at level 1 but were not completely consumed by the consumer groups or subplans at level 1. Similarly, resource consumers at level 3 are allocated resources only when some allocation remains from levels 1 and 2. The same rules apply to levels 4 through 8. Multiple levels not only provide a way of prioritizing, but they provide a way of explicitly specifying how all primary and leftover resources are to be used.</p>
<p>Use the management attributes <code dir="ltr">MGMT_P</code><code dir="ltr"><span class="codeinlineitalic">n</span></code>, where <span class="italic">n</span> is an integer between 1 and 8, to specify multiple levels of CPU resource allocation. For example, use the <code dir="ltr">MGMT_P1</code> directive attribute to specify CPU resource allocation at level 1 and <code dir="ltr">MGMT_P2</code> directive attribute to specify resource allocation at level 2.</p>
<p>Use management attributes with parallel statement directive attributes, such as <a href="#CHDDDBCD">Degree of Parallelism Limit</a> and <a href="#BABEBJJJ">Parallel Target Percentage</a>, to control parallel statement queuing. When parallel statement queuing is used, management attributes are used to determine which consumer group is allowed to issue the next parallel statement. For example, if you set the <code dir="ltr">MGMT_P1</code> directive attribute for a consumer group to 80, that group has an 80% chance of issuing the next parallel statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for information about parallel statement queuing</div>
<p>Management attributes also enable you to specify CPU resource allocation for Exadata I/O.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The Exadata documentation for information about using management attributes for Exadata I/O</div>
<p><a href="#CFHHJJHF">Table 27-1</a> illustrates a simple resource plan with three levels.</p>
<div id="ADMIN13322" class="tblhruleformal">
<p class="titleintable"><a id="sthref2802"></a><a id="CFHHJJHF"></a>Table 27-1 A Simple Three-Level Resource Plan</p>
<table class="cellalignment1333" title="A Simple Three-Level Resource Plan" summary="This table has 4 rows, one for each consumer group, and 3 columns. The columns are: Consumer Group, Level 1 CPU Allocation, Level 2 CPU Allocation, and Level 3 CPU Allocation" dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t27">Consumer Group</th>
<th class="cellalignment1334" id="r1c2-t27">Level 1 CPU Allocation</th>
<th class="cellalignment1334" id="r1c3-t27">Level 2 CPU Allocation</th>
<th class="cellalignment1334" id="r1c4-t27">Level 3 CPU Allocation</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t27" headers="r1c1-t27">
<p><code dir="ltr">HIGH_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t27 r1c2-t27">
<p>80%</p>
</td>
<td class="cellalignment1335" headers="r2c1-t27 r1c3-t27">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t27 r1c4-t27">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t27" headers="r1c1-t27">
<p><code dir="ltr">LOW_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t27 r1c2-t27">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t27 r1c3-t27">
<p>50%</p>
</td>
<td class="cellalignment1335" headers="r3c1-t27 r1c4-t27">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t27" headers="r1c1-t27">
<p><code dir="ltr">MAINT_SUBPLAN</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t27 r1c2-t27">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t27 r1c3-t27">
<p>50%</p>
</td>
<td class="cellalignment1335" headers="r4c1-t27 r1c4-t27">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t27" headers="r1c1-t27">
<p><code dir="ltr">OTHER_GROUPS</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t27 r1c2-t27">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t27 r1c3-t27">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t27 r1c4-t27">
<p>100%</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>High priority applications run within <code dir="ltr">HIGH_GROUP</code>, which is allocated 80% of CPU. Because <code dir="ltr">HIGH_GROUP</code> is at level one, it gets priority for CPU utilization, but only up to 80% of CPU. This leaves a remaining 20% of CPU to be shared 50-50 by <code dir="ltr">LOW_GROUP</code> and the <code dir="ltr">MAINT_SUPLAN</code> at level 2. Any unused allocation from levels 1 and 2 are then available to <code dir="ltr">OTHER_GROUPS</code> at level 3. Because <code dir="ltr">OTHER_GROUPS</code> has no sibling consumer groups or subplans at its level, 100% is specified.</p>
<p>Within a particular level, CPU allocations are not fixed. If there is not sufficient load in a particular consumer group or subplan, residual CPU can be allocated to remaining consumer groups or subplans. Thus, when there is only one level, unused allocation by any consumer group or subplan can be redistributed to other "sibling" consumer groups or subplans. If there are multiple levels, then the unused allocation is distributed to the consumer groups or subplans at the next level. If the last level has unused allocations, these allocations can be redistributed to all other levels in proportion to their designated allocations.</p>
<p>As an example of redistribution of unused allocations from one level to another, if during a particular period, <code dir="ltr">HIGH_GROUP</code> consumes only 25% of CPU, then 75% is available to be shared by <code dir="ltr">LOW_GROUP</code> and <code dir="ltr">MAINT_SUBPLAN</code>. Any unused portion of the 75% at level 2 is then made available to <code dir="ltr">OTHER_GROUPS</code> at level 3. However, if <code dir="ltr">OTHER_GROUPS</code> has no session activity at level 3, then the 75% at level 2 can be redistributed to all other consumer groups and subplans in the plan proportionally.</p>
<p class="subhead2"><a id="BABBBBCC"></a><a id="ADMIN13323"></a><a id="sthref2803"></a>Maximum Utilization Limit</p>
<p>In the previous scenario, suppose that due to inactivity elsewhere, <code dir="ltr">LOW_GROUP</code> acquires 90% of CPU. Suppose that you do not want to allow <code dir="ltr">LOW_GROUP</code> to use 90% of the server because you do not want non-critical sessions to inundate the CPUs. The <code dir="ltr">MAX_UTILIZATION_LIMIT</code> attribute of resource plan directives can prevent this situation.</p>
<p>Use the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> attribute to impose an absolute upper limit on CPU utilization for a resource consumer group. This absolute limit overrides any redistribution of CPU within a plan.</p>
<p>Setting the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> attribute is optional. If you omit this attribute for a consumer group, there is no limit on the amount of CPU that the consumer group can use. Therefore, if all the other applications are idle, a consumer group that does not have <code dir="ltr">MAX_UTILIZATION_LIMIT</code> set can be allocated 100% of the CPU resources.</p>
<p>You can also use the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> attribute as the sole means of limiting CPU utilization for consumer groups, without specifying level limits.</p>
<p><a href="#CFHDIHII">Table 27-2</a> shows a variation of the previous plan. In this plan, using <code dir="ltr">MAX_UTILIZATION_LIMIT</code>, CPU utilization is capped at 75% for <code dir="ltr">LOW_GROUP</code>, 50% for <code dir="ltr">MAINT_SUBPLAN</code>, and 75% for <code dir="ltr">OTHER_GROUPS</code>. (Note that the sum of all maximum utilization limits can exceed 100%. Each limit is applied independently.)</p>
<div id="ADMIN13324" class="tblhruleformal">
<p class="titleintable"><a id="sthref2804"></a><a id="CFHDIHII"></a>Table 27-2 A Three-Level Resource Plan with Maximum Utilization Limits</p>
<table class="cellalignment1333" title="A Three-Level Resource Plan with Maximum Utilization Limits" summary="This table has 4 rows, one for each consumer group, and 4 columns. The columns are: Consumer Group, Level 1 CPU Allocation, Level 2 CPU Allocation, Level 3 CPU Allocation, and Maximum Utiliization Limit" dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t28">Consumer Group</th>
<th class="cellalignment1334" id="r1c2-t28">Level 1 CPU Allocation</th>
<th class="cellalignment1334" id="r1c3-t28">Level 2 CPU Allocation</th>
<th class="cellalignment1334" id="r1c4-t28">Level 3 CPU Allocation</th>
<th class="cellalignment1334" id="r1c5-t28">Maximum Utilization Limit</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t28" headers="r1c1-t28">
<p><code dir="ltr">HIGH_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t28 r1c2-t28">
<p>80%</p>
</td>
<td class="cellalignment1335" headers="r2c1-t28 r1c3-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t28 r1c4-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t28 r1c5-t28">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t28" headers="r1c1-t28">
<p><code dir="ltr">LOW_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t28 r1c2-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t28 r1c3-t28">
<p>50%</p>
</td>
<td class="cellalignment1335" headers="r3c1-t28 r1c4-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t28 r1c5-t28">
<p>75%</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t28" headers="r1c1-t28">
<p><code dir="ltr">MAINT_SUBPLAN</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t28 r1c2-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t28 r1c3-t28">
<p>50%</p>
</td>
<td class="cellalignment1335" headers="r4c1-t28 r1c4-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t28 r1c5-t28">
<p>50%</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t28" headers="r1c1-t28">
<p><code dir="ltr">OTHER_GROUPS</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t28 r1c2-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t28 r1c3-t28">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t28 r1c4-t28">
<p>100%</p>
</td>
<td class="cellalignment1335" headers="r5c1-t28 r1c5-t28">
<p>75%</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<p>In the example described in <a href="#CFHDIHII">Table 27-2</a>, if <code dir="ltr">HIGH_GROUP</code> is using only 10% of the CPU at a given time, then the remaining 90% is available to <code dir="ltr">LOW_GROUP</code> and the consumer groups in <code dir="ltr">MAINT_SUBPLAN</code> at level 2. If <code dir="ltr">LOW_GROUP</code> uses only 20% of the CPU, then 70% can be allocated to <code dir="ltr">MAINT_SUBPLAN</code>. However, <code dir="ltr">MAINT_SUBPLAN</code> has a <code dir="ltr">MAX_UTILIZATION_LIMIT</code> of 50%. Therefore, even though more CPU resources are available, the server cannot allocate more than 50% of the CPU to the consumer groups that belong to the subplan <code dir="ltr">MAINT_SUBPLAN</code>.</p>
<p>You can set <code dir="ltr">MAX_UTILIZATION_LIMIT</code> for both a subplan and the consumer groups that the subplan contains. In such cases, the limit for a consumer group is computed using the limits specified for the subplan and that consumer group. For example, the <code dir="ltr">MAINT_SUBPLAN</code> contains the consumer groups <code dir="ltr">MAINT_GROUP1</code> and <code dir="ltr">MAINT_GROUP2</code>. <code dir="ltr">MAINT_GROUP1</code> has <code dir="ltr">MAX_UTILIZATION_LIMIT</code> set to 40%. However, the limit for <code dir="ltr">MAINT_SUBPLAN</code> is set to 50%. Therefore, the limit for consumer group <code dir="ltr">MAINT_GROUP1</code> is computed as 40% of 50%, or 20%. For an example of how to compute <code dir="ltr">MAX_UTILIZATION_LIMIT</code> for a consumer group when limits are specified for both the consumer group and the subplan to which the group belongs, see <a href="#BABEAJGH">"Example 4 - Specifying a Maximum Utilization Limit for Consumer Groups and Subplans"</a>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1008232">"Creating Resource Plan Directives"</a></p>
</li>
<li>
<p><a href="#i1008504">"Putting It All Together: Oracle Database Resource Manager Examples"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDDDBCD"></a>
<div id="ADMIN11854" class="sect2">
<h3 class="sect2">Degree of <a id="sthref2805"></a>Parallelism Limit</h3>
<p>You can limit the maximum degree of parallelism for any operation within a consumer group. The degree of parallelism is the number of parallel execution servers that are associated with a single operation. Use the <code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code> directive attribute to specify the degree of parallelism for a consumer group.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about degree of parallelism in producer/consumer operations</div>
<p>The degree of parallelism limit applies to one operation within a consumer group; it does not limit the total degree of parallelism across all operations within the consumer group. However, you can combine both the <code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code> and the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> directive attributes to achieve the desired control. For more information about the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> attribute, see <a href="#BABEBJJJ">"Parallel Target Percentage"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="BABEBJJJ"></a>
<div id="ADMIN13466" class="sect2">
<h3 class="sect2">Parallel Target <a id="sthref2806"></a>Percentage</h3>
<p>It is possible for a single consumer group to launch enough parallel statements to use all the available parallel servers. If this happens, when a high-priority parallel statement from a different consumer group is run, then no parallel servers are available to allocate to this group. You can avoid such a scenario by limiting the number of parallel servers that can be used by a particular consumer group.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This functionality is available starting with Oracle Database 11<span class="italic">g</span> Release 2 (11.2.0.2).</div>
<p>Use the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> directive attribute to specify the maximum percentage of the parallel server pool that a particular consumer group can use. The number of parallel servers used by a particular consumer group is counted as the sum of the parallel servers used by all sessions in that consumer group.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for information about parallel statement queuing</div>
<p>For example, assume that the total number of parallel servers is 32, as set by the <code dir="ltr">PARALLEL_SERVERS_TARGET</code> initialization parameter, and the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> directive attribute for the consumer group <code dir="ltr">MY_GROUP</code> is set to 50%. This consumer group can use a maximum of 50% of 32, or 16 parallel servers.</p>
<p>If your resource plan has management attributes (<code dir="ltr">MGMT_P1</code>, <code dir="ltr">MGMT_P2</code>, and so on), then a separate parallel statement queue is managed as a First In First Out (FIFO) queue for each management attribute.</p>
<p>If your resource plan does not have any management attributes, then a single parallel statement queue is managed as a FIFO queue.</p>
<p>In the case of an Oracle Real Application Clusters (Oracle RAC) environment, the target number of parallel servers is the sum of (<code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> * <code dir="ltr">PARALLEL_SERVERS_TARGET</code> / 100) across all Oracle RAC instances. If a consumer group is using the number of parallel servers computed above or more, then it has exceeded its limit, and its parallel statements will be queued.</p>
<p>If a consumer group does not have any parallel statements running within an Oracle RAC database, then the first parallel statement is allowed to exceed the limit specified by <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In an Oracle Real Application Clusters (Oracle RAC) environment, the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> attribute applies to the entire cluster and not to a single instance.</div>
<div id="ADMIN13467" class="sect3"><a id="sthref2807"></a>
<h4 class="sect3">Managing Parallel Statement Queuing Using Parallel Target Percentage</h4>
<p>The <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> attribute enables you to specify when parallel statements from a consumer group can be queued. Oracle Database maintains a separate parallel statement queue for each consumer group.</p>
<p>A parallel statement from a consumer group is not run and instead added to the parallel statement queue of that consumer group if the following conditions are met:</p>
<ul>
<li>
<p><code dir="ltr">PARALLEL_DEGREE_POLICY</code> is set to <code dir="ltr">AUTO</code>.</p>
<p>Setting this parameter to <code dir="ltr">AUTO</code> enables automatic degree of parallelism (Auto DOP), parallel statement queuing, and in-memory parallel execution.</p>
<p>Note that parallel statements which have <code dir="ltr">PARALLEL_DEGREE_POLICY</code> set to <code dir="ltr">MANUAL</code> or <code dir="ltr">LIMITED</code> are executed immediately and not added to the parallel statement queue.</p>
</li>
<li>
<p>The number of active parallel servers across all consumer groups exceeds the <code dir="ltr">PARALLEL_SERVERS_TARGET</code> initialization parameter setting. This condition applies regardless of whether you specify <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code>. If <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> is not specified, then it defaults to 100%.</p>
</li>
<li>
<p>The sum of the number of active parallel servers for the consumer group and the degree of parallelism of the parallel statement exceeds the target number of active parallel servers.</p>
<p>The target number of active parallel servers is computed as follows:</p>
<p><code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code>/100 * <code dir="ltr">PARALLEL_SERVERS_TARGET</code></p>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABFAAIB"></a>
<div id="ADMIN13468" class="sect2">
<h3 class="sect2">Parallel <a id="sthref2808"></a>Queue Timeout</h3>
<p>When you use parallel statement queuing, if the database does not have sufficient resources to execute a parallel statement, the statement is queued until the required resources become available. However, there is a chance that a parallel statement may be waiting in the parallel statement queue for longer than is desired. You can prevent such scenarios by specifying the maximum time a parallel statement can wait in the parallel statement queue.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
This functionality is available starting with Oracle Database 11g Release 2 (11.2.0.2).</div>
<p>The <code dir="ltr">PARALLEL_QUEUE_TIMEOUT</code> directive attribute enables you to specify the maximum time, in seconds, that a parallel statement can wait in the parallel statement queue before it is timed out. The <code dir="ltr">PARALLEL_QUEUE_TIMEOUT</code> attribute can be set for each consumer group. This attribute is applicable even if you do not specify other management attributes (<code dir="ltr">MGMT_P1</code>, <code dir="ltr">MGMT_P2</code>, and so on) in your resource plan.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about parallel statement queuing</div>
<div class="infobox-note">
<p class="notep1">Note:</p>
Because the parallel statement queue is clusterwide, all directives related to the parallel statement queue are also clusterwide.</div>
<p>When a parallel statement is timed out, the statement execution ends with the following error message:</p>
<pre dir="ltr">
ORA-07454: queue timeout, n second(s), exceeded
</pre>
<p>If you want more per-workload <a id="sthref2809"></a><a id="sthref2810"></a>management, then you must use the following directive attributes:</p>
<ul>
<li>
<p><code dir="ltr">MGMT_P</code><code dir="ltr"><span class="codeinlineitalic">n</span></code></p>
<p>Management attributes control how a parallel statement is selected from the parallel statement queue for execution. You can prioritize the parallel statements of one consumer group over another by setting a higher value for the management attributes of that group.</p>
</li>
<li>
<p><code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code></p>
</li>
<li>
<p><code dir="ltr">PARALLEL_QUEUE_TIMEOUT</code></p>
</li>
<li>
<p><code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#BABCIJDG">"Example of Managing Parallel Statements Using Directive Attributes"</a> for more information about the combined use of all the parallel server directive attributes</div>
<p>Although parallel server usage is monitored for all sessions, the parallel server directive attributes you set affect only sessions for which parallel statement queuing is enabled (<code dir="ltr">PARALLEL_DEGREE_POLICY</code> is set to <code dir="ltr">AUTO</code>). If a session has the <code dir="ltr">PARALLEL_DEGREE_POLICY</code> set to <code dir="ltr">MANUAL</code>, parallel statements from this session are not queued. However, any parallel servers used by such sessions are included in the count that is used to determine the limit for <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code>. Even if this limit is exceeded, parallel statements from this session are not queued.</p>
</div>
<!-- class="sect2" -->
<a id="CHDEDIHA"></a>
<div id="ADMIN11853" class="sect2">
<h3 class="sect2">Active Session Pool with Queuing</h3>
<p>You can control the maximum number of concurrently active sessions allowed within a consumer group. This maximum defines the <a id="sthref2811"></a><span class="bold">active session pool</span>. An <span class="bold">active session</span> is a session that is actively processing a transaction or SQL statement. Specifically, an active session is either in a transaction, holding a user enqueue, or has an open cursor and has not been idle for over 5 seconds. An active session is considered active even if it is blocked, for example waiting for an I/O request to complete. When the active session pool is full, a session that is trying to process a call is placed into a queue. When an active session completes, the first session in the queue can then be removed from the queue and scheduled for execution. You can also specify a period after which a session in the execution queue times out, causing the call to terminate with an error.</p>
<p>Active session limits should not be used for OLTP workloads. In addition, active session limits should not be used to implement connection pooling or parallel statement queuing.</p>
<p>To manage parallel statements, you must use parallel statement queuing with the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> attribute and management attributes (<code dir="ltr">MGMT_P1</code>, <code dir="ltr">MGMT_P2</code>, and so on).</p>
</div>
<!-- class="sect2" -->
<a id="CHDIGAHB"></a>
<div id="ADMIN11855" class="sect2">
<h3 class="sect2"><a id="sthref2812"></a>Automatic Consumer Group Switching</h3>
<p>This method enables you to control resource allocation by specifying criteria that, if met, causes the automatic switching of a session to a specified consumer group. Typically, this method is used to switch a session from a high-priority consumer group&mdash;one that receives a high proportion of system resources&mdash;to a lower priority consumer group because that session exceeded the expected resource consumption for a typical session in the group.</p>
<p>See <a href="#CHDDCGGG">"Specifying Automatic Switching by Setting Resource Limits"</a> for more information.</p>
</div>
<!-- class="sect2" -->
<a id="CHDCDCBA"></a>
<div id="ADMIN11856" class="sect2">
<h3 class="sect2">Canceling SQL and Terminating Sessions</h3>
<p>You can also specify directives to cancel long-running SQL queries or to terminate long-running sessions based on the amount of system resources consumed. See <a href="#CHDDCGGG">"Specifying Automatic Switching by Setting Resource Limits"</a> for more information.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBFHEI"></a>
<div id="ADMIN11857" class="sect2">
<h3 class="sect2"><a id="sthref2813"></a>Execution Time Limit</h3>
<p>You can specify a maximum execution time allowed for an operation. If the database estimates that an operation will run longer than the specified maximum execution time, then the operation is terminated with an error. This error can be trapped and the operation rescheduled.</p>
</div>
<!-- class="sect2" -->
<a id="CHDBGIBD"></a>
<div id="ADMIN11858" class="sect2">
<h3 class="sect2">Undo Pool</h3>
<p>You can specify an <a id="sthref2814"></a>undo pool for each consumer group. An undo pool controls the total amount of undo for uncommitted transactions that can be generated by a consumer group. When the total undo generated by a consumer group exceeds its undo limit, the current DML statement generating the undo is terminated. No other members of the consumer group can perform further data manipulation until undo space is freed from the pool.</p>
</div>
<!-- class="sect2" -->
<a id="CHDIJJDJ"></a>
<div id="ADMIN11859" class="sect2">
<h3 class="sect2">Idle Time Limit</h3>
<p>You can specify an amount of time that a session can be idle, after which it is terminated. You can also specify a more stringent idle time limit that applies to sessions that are idle and blocking other sessions.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007878"></a>
<div id="ADMIN11861" class="sect1">
<h2 class="sect1">Creating a Simple Resource Plan<a id="sthref2815"></a><a id="sthref2816"></a></h2>
<p>You can quickly create a simple resource plan that is adequate for many situations using the <a id="sthref2817"></a><a id="sthref2818"></a><code dir="ltr">CREATE_SIMPLE_PLAN</code> procedure. This procedure enables you to both create consumer groups and allocate resources to them by executing a single procedure call. Using this procedure, you are not required to invoke the procedures that are described in succeeding sections for creating a pending area, creating each consumer group individually, specifying resource plan directives, and so on.</p>
<p>You specify the following arguments for the <code dir="ltr">CREATE_SIMPLE_PLAN</code> procedure:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Parameters of the CREATE_SIMPLE_PLAN Procedure" summary="Column 1 lists the parameters that can be specified for the CREATE_SIMPLE_PLAN procedure. Column2 describes the function of each parameter." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t38">Parameter</th>
<th class="cellalignment1334" id="r1c2-t38">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t38" headers="r1c1-t38"><code dir="ltr">SIMPLE_PLAN</code></td>
<td class="cellalignment1335" headers="r2c1-t38 r1c2-t38">Name of the plan</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP1</code></td>
<td class="cellalignment1335" headers="r3c1-t38 r1c2-t38">Consumer group name for first group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP1_PERCENT</code></td>
<td class="cellalignment1335" headers="r4c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP2</code></td>
<td class="cellalignment1335" headers="r5c1-t38 r1c2-t38">Consumer group name for second group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP2_PERCENT</code></td>
<td class="cellalignment1335" headers="r6c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP3</code></td>
<td class="cellalignment1335" headers="r7c1-t38 r1c2-t38">Consumer group name for third group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP3_PERCENT</code></td>
<td class="cellalignment1335" headers="r8c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP4</code></td>
<td class="cellalignment1335" headers="r9c1-t38 r1c2-t38">Consumer group name for fourth group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r10c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP4_PERCENT</code></td>
<td class="cellalignment1335" headers="r10c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r11c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP5</code></td>
<td class="cellalignment1335" headers="r11c1-t38 r1c2-t38">Consumer group name for fifth group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r12c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP5_PERCENT</code></td>
<td class="cellalignment1335" headers="r12c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r13c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP6</code></td>
<td class="cellalignment1335" headers="r13c1-t38 r1c2-t38">Consumer group name for sixth group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r14c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP6_PERCENT</code></td>
<td class="cellalignment1335" headers="r14c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r15c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP7</code></td>
<td class="cellalignment1335" headers="r15c1-t38 r1c2-t38">Consumer group name for seventh group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r16c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP7_PERCENT</code></td>
<td class="cellalignment1335" headers="r16c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r17c1-t38" headers="r1c1-t38"><code dir="ltr">CONSUMER_GROUP8</code></td>
<td class="cellalignment1335" headers="r17c1-t38 r1c2-t38">Consumer group name for eighth group</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r18c1-t38" headers="r1c1-t38"><code dir="ltr">GROUP8_PERCENT</code></td>
<td class="cellalignment1335" headers="r18c1-t38 r1c2-t38">CPU resource allocated to this group</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>You can specify up to eight consumer groups with this procedure. The only resource allocation method supported is CPU. The plan uses the <code dir="ltr">EMPHASIS</code> CPU allocation policy (the default) and each consumer group uses the <code dir="ltr">ROUND_ROBIN</code> scheduling policy (also the default). Each consumer group specified in the plan is allocated its CPU percentage at level 2. Also implicitly included in the plan are <code dir="ltr">SYS_GROUP</code> (a system-defined group that is the initial consumer group for the users <code dir="ltr">SYS</code> and <code dir="ltr">SYSTEM</code>) and <code dir="ltr">OTHER_GROUPS</code>. The <code dir="ltr">SYS_GROUP</code> consumer group is allocated 100% of the CPU at level 1, and <code dir="ltr">OTHER_GROUPS</code> is allocated 100% of the CPU at level 3.</p>
<p class="subhead2"><a id="ADMIN12649"></a>Example: Creating a Simple Plan with the CREATE_SIMPLE_PLAN Procedure</p>
<p>The following PL/SQL block creates a simple resource plan with two user-specified consumer groups:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_SIMPLE_PLAN(SIMPLE_PLAN =&gt; 'SIMPLE_PLAN1',
   CONSUMER_GROUP1 =&gt; 'MYGROUP1', GROUP1_PERCENT =&gt; 80,
   CONSUMER_GROUP2 =&gt; 'MYGROUP2', GROUP2_PERCENT =&gt; 20);
END;
/
</pre>
<p>Executing the preceding statements creates the following plan:</p>
<div class="inftblruleinformal">
<table class="cellalignment1333" title="Sample Resource Plan" summary="This table describes the results of executing the previous statements. Column 1 lists the consumer group, columns 2-4 show the amount of CPU granted to each level (level1, level 2, and level3, respectively)." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t39">Consumer Group</th>
<th class="cellalignment1334" id="r1c2-t39">Level 1</th>
<th class="cellalignment1334" id="r1c3-t39">Level 2</th>
<th class="cellalignment1334" id="r1c4-t39">Level 3</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t39" headers="r1c1-t39"><code dir="ltr">SYS_GROUP</code></td>
<td class="cellalignment1335" headers="r2c1-t39 r1c2-t39">100%</td>
<td class="cellalignment1335" headers="r2c1-t39 r1c3-t39">-</td>
<td class="cellalignment1335" headers="r2c1-t39 r1c4-t39">-</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t39" headers="r1c1-t39"><code dir="ltr">MYGROUP1</code></td>
<td class="cellalignment1335" headers="r3c1-t39 r1c2-t39">-</td>
<td class="cellalignment1335" headers="r3c1-t39 r1c3-t39">80%</td>
<td class="cellalignment1335" headers="r3c1-t39 r1c4-t39">-</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t39" headers="r1c1-t39"><code dir="ltr">MYGROUP2</code></td>
<td class="cellalignment1335" headers="r4c1-t39 r1c2-t39">-</td>
<td class="cellalignment1335" headers="r4c1-t39 r1c3-t39">20%</td>
<td class="cellalignment1335" headers="r4c1-t39 r1c4-t39">-</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t39" headers="r1c1-t39"><code dir="ltr">OTHER_GROUPS</code></td>
<td class="cellalignment1335" headers="r5c1-t39 r1c2-t39">-</td>
<td class="cellalignment1335" headers="r5c1-t39 r1c3-t39">-</td>
<td class="cellalignment1335" headers="r5c1-t39 r1c4-t39">100%</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1108090">"Creating a Resource Plan"</a> for more information on the <code dir="ltr">EMPHASIS</code> CPU allocation policy</p>
</li>
<li>
<p><a href="#i1008173">"Creating Resource Consumer Groups"</a> for more information on the <code dir="ltr">ROUND_ROBIN</code> scheduling policy</p>
</li>
<li>
<p><a href="#i1007599">"Elements of the Resource Manager"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1008009"></a>
<div id="ADMIN11862" class="sect1">
<h2 class="sect1">Creating a Complex Resource Plan</h2>
<p>When your situation calls for a more complex resource plan, you must create the plan, with its directives and consumer groups, in a staging area called the pending area, and then validate the plan before storing it in the data dictionary.</p>
<p>The following is a summary of the steps required to create a complex resource plan.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A complex resource plan is any resource plan that is not created with the <code dir="ltr">DBMS_RESOURCE_MANAGER.CREATE_SIMPLE_PLAN</code> procedure.</div>
<p><span class="bold">Step 1</span>: Create a pending area.</p>
<p><span class="bold">Step 2</span>: Create, modify, or delete consumer groups.</p>
<p><span class="bold">Step 3</span>: Create the resource plan.</p>
<p><span class="bold">Step 4</span>: Create resource plan directives.</p>
<p><span class="bold">Step 5</span>: Validate the pending area.</p>
<p><span class="bold">Step 6</span>: Submit the pending area.</p>
<p>You use procedures in the <code dir="ltr">DBMS_RESOURCE_MANAGER</code> PL/SQL package to complete these steps. The following sections provide details:</p>
<ul>
<li>
<p><a href="#CHDHBJCB">About the Pending Area</a></p>
</li>
<li>
<p><a href="#i1108028">Creating a Pending Area</a></p>
</li>
<li>
<p><a href="#i1008173">Creating Resource Consumer Groups</a></p>
</li>
<li>
<p><a href="#i1108090">Creating a Resource Plan</a></p>
</li>
<li>
<p><a href="#i1008232">Creating Resource Plan Directives</a></p>
</li>
<li>
<p><a href="#CHDHFJJJ">Validating the Pending Area</a></p>
</li>
<li>
<p><a href="#CHDBEEFF">Submitting the Pending Area</a></p>
</li>
<li>
<p><a href="#CHDGCDHJ">Clearing the Pending Area</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDEFDCH">Predefined Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a class="olink ARPLS050" href="../../appdev.112/e40758/d_resmgr.htm#ARPLS050"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details on the <code dir="ltr">DBMS_RESOURCE_MANAGER</code> PL/SQL package.</p>
</li>
<li>
<p><a href="#i1007599">"Elements of the Resource Manager"</a></p>
</li>
</ul>
</div>
<a id="CHDHBJCB"></a>
<div id="ADMIN11863" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">About the Pending Area</h3>
<p>The <span class="bold">pending area</span> is a staging area where you can create a new resource plan, update an existing plan, or delete a plan without affecting currently running applications. When you create a pending area, the database initializes it and then copies existing plans into the pending area so that they can be updated.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
After you create the pending area, if you list all plans by querying the <code dir="ltr">DBA_RSRC_PLANS</code> data dictionary view, you see two copies of each plan: one with the <code dir="ltr">PENDING</code> status, and one without. The plans with the <code dir="ltr">PENDING</code> status reflect any changes you made to the plans since creating the pending area. Pending changes can also be viewed for consumer groups using <code dir="ltr">DBA_RSRC_CONSUMER_GROUPS</code> and for resource plan directives using <code dir="ltr">DBA_RSRC_PLAN_DIRECTIVES</code>. See <a href="#i1008772">Resource Manager Data Dictionary Views</a> for more information.</div>
<p>After you make changes in the pending area, you validate the pending area and then submit it. Upon submission, all pending changes are applied to the data dictionary, and the pending area is cleared and deactivated.</p>
<p>If you attempt to create, update, or delete a plan (or create, update, or delete consumer groups or resource plan directives) without first creating the pending area, you receive an error message.</p>
<p>Submitting the pending area does not activate any new plan that you create; it just stores new or updated plan information in the data dictionary. However, if you modify a plan that is currently active, the plan is reactivated with the new plan definition. See <a href="#i1008488">"Enabling Oracle Database Resource Manager and Switching Plans"</a> for information about activating a resource plan.</p>
<p>When you create a pending area, no other users can create one until you submit or clear the pending area or log out.</p>
</div>
<!-- class="sect2" -->
<a id="i1108028"></a>
<div id="ADMIN11864" class="sect2">
<h3 class="sect2">Creating a Pending Area</h3>
<p>You create a pending area with the <code dir="ltr">CREATE_PENDING_AREA</code> procedure.</p>
<p class="subhead2"><a id="ADMIN12650"></a>Example: Creating a pending area:</p>
<p>The following PL/SQL block creates and initializes a pending area:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="i1008173"></a>
<div id="ADMIN11865" class="sect2">
<h3 class="sect2">Creating Resource Consumer Groups<a id="sthref2819"></a><a id="sthref2820"></a></h3>
<p>You create a resource consumer group using the <code dir="ltr">CREATE_CONSUMER_GROUP</code> procedure. You can specify the following parameters<a id="sthref2821"></a>:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Resource Consumer Group Parameters" summary="Column 1 lists the parameters that can be specified when you create a resource consumer group. Column 2 describes the function of each parameter." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t44">Parameter</th>
<th class="cellalignment1334" id="r1c2-t44">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t44" headers="r1c1-t44"><code dir="ltr">CONSUMER_GROUP</code></td>
<td class="cellalignment1335" headers="r2c1-t44 r1c2-t44">Name to assign to the consumer group.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t44" headers="r1c1-t44"><code dir="ltr">COMMENT</code></td>
<td class="cellalignment1335" headers="r3c1-t44 r1c2-t44">Any comment.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t44" headers="r1c1-t44"><code dir="ltr">CPU_MTH</code></td>
<td class="cellalignment1335" headers="r4c1-t44 r1c2-t44">Deprecated. Use <code dir="ltr">MGMT_MTH</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t44" headers="r1c1-t44"><code dir="ltr">MGMT_MTH</code></td>
<td class="cellalignment1335" headers="r5c1-t44 r1c2-t44">The resource allocation method for distributing CPU among sessions in the consumer group. The default is <code dir="ltr"><a id="sthref2822"></a><a id="sthref2823"></a><a id="sthref2824"></a>'ROUND-ROBIN'</code>, which uses a round-robin scheduler to ensure that sessions are fairly executed. <code dir="ltr">'RUN-TO-COMPLETION'</code> specifies that long-running sessions are scheduled ahead of other sessions. This setting helps long-running sessions (such as batch processes) complete sooner.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="ADMIN12651"></a>Example: Creating a Resource Consumer Group</p>
<p>The following PL/SQL block creates a consumer group called <code dir="ltr">OLTP</code> with the default (<code dir="ltr">ROUND-ROBIN</code>) method of allocating resources to sessions in the group:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
   CONSUMER_GROUP =&gt; 'OLTP',
   COMMENT        =&gt; 'OLTP applications');
END;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDDDCCF">"Updating a Consumer Group"</a></p>
</li>
<li>
<p><a href="#CHDHIACE">"Deleting a Consumer Group"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1108090"></a>
<div id="ADMIN11866" class="sect2">
<h3 class="sect2">Creating a Resource Plan</h3>
<p>You create a resource plan with the <code dir="ltr">CREATE_PLAN</code> procedure. You can specify the <a id="sthref2825"></a>parameters shown in the following table. The first two parameters are required. The remainder are optional.</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Resource Plan Parameters" summary="Column 1 lists the parameters that can be specified when creating a resource plan. Column 2 describes the function of each parameter." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t46">Parameter</th>
<th class="cellalignment1334" id="r1c2-t46">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t46" headers="r1c1-t46"><code dir="ltr">PLAN</code></td>
<td class="cellalignment1335" headers="r2c1-t46 r1c2-t46">Name to assign to the plan.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t46" headers="r1c1-t46"><code dir="ltr">COMMENT</code></td>
<td class="cellalignment1335" headers="r3c1-t46 r1c2-t46">Any descriptive comment.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t46" headers="r1c1-t46"><code dir="ltr">CPU_MTH</code><a id="sthref2826"></a><a id="sthref2827"></a></td>
<td class="cellalignment1335" headers="r4c1-t46 r1c2-t46">Deprecated. Use <code dir="ltr">MGMT_MTH</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t46" headers="r1c1-t46"><code dir="ltr">ACTIVE_SESS_POOL_MTH</code><a id="sthref2828"></a><a id="sthref2829"></a><a id="sthref2830"></a></td>
<td class="cellalignment1335" headers="r5c1-t46 r1c2-t46">Active session pool resource allocation method. <code dir="ltr">ACTIVE_SESS_POOL_ABSOLUTE</code> is the default and only method available.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t46" headers="r1c1-t46"><code dir="ltr">PARALLEL_DEGREE_LIMIT_MTH</code><a id="sthref2831"></a><a id="sthref2832"></a><a id="sthref2833"></a></td>
<td class="cellalignment1335" headers="r6c1-t46 r1c2-t46">Resource allocation method for specifying a limit on the <a id="sthref2834"></a>degree of parallelism of any operation. <a id="sthref2835"></a><a id="sthref2836"></a><a id="sthref2837"></a><code dir="ltr">PARALLEL_DEGREE_LIMIT_ABSOLUTE</code> is the default and only method available.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t46" headers="r1c1-t46"><code dir="ltr">QUEUEING_MTH</code><a id="sthref2838"></a><a id="sthref2839"></a><a id="sthref2840"></a></td>
<td class="cellalignment1335" headers="r7c1-t46 r1c2-t46">Queuing resource allocation method. Controls the order in which queued inactive sessions are removed from the queue and added to the active session pool. <code dir="ltr">FIFO_TIMEOUT</code> is the default and only method available.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t46" headers="r1c1-t46"><code dir="ltr">MGMT_MTH</code><a id="sthref2841"></a><a id="sthref2842"></a></td>
<td class="cellalignment1335" headers="r8c1-t46 r1c2-t46">Resource allocation method for specifying how much CPU each consumer group or subplan gets. <code dir="ltr">'EMPHASIS'</code><a id="sthref2843"></a><a id="sthref2844"></a><a id="sthref2845"></a>, the default method, is for single-level or multilevel plans that use percentages to specify how CPU is distributed among consumer groups. <code dir="ltr">'RATIO'</code> is for single-level plans that use ratios to specify how CPU is distributed.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t46" headers="r1c1-t46"><code dir="ltr">SUB_PLAN</code></td>
<td class="cellalignment1335" headers="r9c1-t46 r1c2-t46">If <code dir="ltr">TRUE</code>, the plan cannot be used as the top plan; it can be used as a subplan only. Default is <code dir="ltr">FALSE</code>.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="ADMIN12652"></a>Example: Creating a Resource Plan</p>
<p>The following PL/SQL block creates a resource plan named <code dir="ltr">DAYTIME</code>:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
   PLAN    =&gt; 'DAYTIME',
   COMMENT =&gt; 'More resources for OLTP applications');
END;
/
</pre>
<div id="ADMIN11867" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2846"></a>
<h4 class="sect3">About the RATIO CPU Allocation Method</h4>
<p>The <code dir="ltr">RATIO</code> method is an alternate CPU allocation method intended for simple plans that have only a single level of CPU allocation. Instead of percentages, you specify numbers corresponding to the ratio of CPU that you want to give to each consumer group. To use the <code dir="ltr">RATIO</code> method, you set the <code dir="ltr">MGMT_MTH</code> argument for the <code dir="ltr">CREATE_PLAN</code> procedure to '<code dir="ltr">RATIO</code>'. See <a href="#i1008232">"Creating Resource Plan Directives"</a> for an example of a plan that uses this method.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDGIGJF">"Updating a Plan"</a></p>
</li>
<li>
<p><a href="#CHDBHJHF">"Deleting a Plan"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1008232"></a>
<div id="ADMIN11868" class="sect2">
<h3 class="sect2">Creating Resource Plan Directives<a id="sthref2847"></a><a id="sthref2848"></a></h3>
<p>You use the <code dir="ltr">CREATE_PLAN_DIRECTIVE</code> procedure to create resource plan directives. Each directive belongs to a plan or subplan and allocates resources to either a consumer group or subplan.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The set of directives for a resource plan and its subplans can name a particular subplan only once.
<p>You can specify directives for a particular consumer group in a top plan and its subplans. However, Oracle recommends that the set of directives for a resource plan and its subplans name a particular consumer group only once.</p>
</div>
<p>You can specify the following parameters:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Resource Plan Directive Parameters" summary="Column 1 lists the parameters that can be specified when you create a resource plan directive. Column 2 describes the function of each parameter." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t49">Parameter</th>
<th class="cellalignment1334" id="r1c2-t49">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t49" headers="r1c1-t49"><code dir="ltr">PLAN</code></td>
<td class="cellalignment1335" headers="r2c1-t49 r1c2-t49">Name of the resource plan to which the directive belongs.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t49" headers="r1c1-t49"><code dir="ltr">GROUP_OR_SUBPLAN</code></td>
<td class="cellalignment1335" headers="r3c1-t49 r1c2-t49">Name of the consumer group or subplan to which to allocate resources.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t49" headers="r1c1-t49"><code dir="ltr">COMMENT</code></td>
<td class="cellalignment1335" headers="r4c1-t49 r1c2-t49">Any comment.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P1</code></td>
<td class="cellalignment1335" headers="r5c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P1</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P2</code></td>
<td class="cellalignment1335" headers="r6c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P2</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P3</code></td>
<td class="cellalignment1335" headers="r7c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P3</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P4</code></td>
<td class="cellalignment1335" headers="r8c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P4</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P5</code></td>
<td class="cellalignment1335" headers="r9c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P5</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r10c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P6</code></td>
<td class="cellalignment1335" headers="r10c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P6</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r11c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P7</code></td>
<td class="cellalignment1335" headers="r11c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P7</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r12c1-t49" headers="r1c1-t49"><code dir="ltr">CPU_P8</code></td>
<td class="cellalignment1335" headers="r12c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">MGMT_P8</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r13c1-t49" headers="r1c1-t49"><code dir="ltr">ACTIVE_SESS_POOL_P1</code></td>
<td class="cellalignment1335" headers="r13c1-t49 r1c2-t49">Specifies the maximum number of concurrently active sessions for a consumer group. Other sessions await execution in an inactive session queue. Default is <code dir="ltr">UNLIMITED</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r14c1-t49" headers="r1c1-t49"><code dir="ltr">QUEUEING_P1</code></td>
<td class="cellalignment1335" headers="r14c1-t49 r1c2-t49">Specifies time (in seconds) after which a session in an inactive session queue (waiting for execution) times out and the call is aborted. Default is <code dir="ltr">UNLIMITED</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r15c1-t49" headers="r1c1-t49"><code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code></td>
<td class="cellalignment1335" headers="r15c1-t49 r1c2-t49">Specifies a limit on the degree of parallelism for any operation. Default is <code dir="ltr">UNLIMITED</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r16c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_GROUP</code></td>
<td class="cellalignment1335" headers="r16c1-t49 r1c2-t49">Specifies the consumer group to which a session is switched if switch criteria are met. If the group name is '<code dir="ltr">CANCEL_SQL</code>', then the current call is canceled when switch criteria are met. If the group name is '<code dir="ltr">KILL_SESSION</code>', then the session is killed when switch criteria are met. Default is <code dir="ltr">NULL</code>.
<p>If the group name is '<code dir="ltr">CANCEL_SQL</code>', the <code dir="ltr">SWITCH_FOR_CALL</code> parameter is always set to <code dir="ltr">TRUE</code>, overriding the user-specified setting.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r17c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_TIME</code></td>
<td class="cellalignment1335" headers="r17c1-t49 r1c2-t49">Specifies the time (in CPU seconds) that a call can execute before an action is taken. Default is <code dir="ltr">UNLIMITED</code>. The action is specified by <code dir="ltr">SWITCH_GROUP</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r18c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_ESTIMATE</code></td>
<td class="cellalignment1335" headers="r18c1-t49 r1c2-t49">If <code dir="ltr">TRUE</code>, the database estimates the execution time of each call, and if estimated execution time exceeds <code dir="ltr">SWITCH_TIME</code>, the session is switched to the <code dir="ltr">SWITCH_GROUP</code> before beginning the call. Default is <code dir="ltr">FALSE</code>.
<p>The execution time estimate is obtained from the optimizer. The accuracy of the estimate is dependent on many factors, especially the quality of the optimizer statistics. In general, you should expect statistics to be no more accurate than &plusmn; 10 minutes.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r19c1-t49" headers="r1c1-t49"><code dir="ltr">MAX_EST_EXEC_TIME</code></td>
<td class="cellalignment1335" headers="r19c1-t49 r1c2-t49">Specifies the maximum execution time (in CPU seconds) allowed for a call. If the optimizer estimates that a call will take longer than <code dir="ltr">MAX_EST_EXEC_TIME</code>, the call is not allowed to proceed and <code dir="ltr">ORA-07455</code> is issued. If the optimizer does not provide an estimate, this directive has no effect. Default is <code dir="ltr">UNLIMITED</code>.
<p>The accuracy of the estimate is dependent on many factors, especially the quality of the optimizer statistics.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r20c1-t49" headers="r1c1-t49"><code dir="ltr">UNDO_POOL</code></td>
<td class="cellalignment1335" headers="r20c1-t49 r1c2-t49">Sets a maximum in kilobytes (K) on the total amount of undo for uncommitted transactions that can be generated by a consumer group. Default is <code dir="ltr">UNLIMITED</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r21c1-t49" headers="r1c1-t49"><code dir="ltr">MAX_IDLE_TIME</code></td>
<td class="cellalignment1335" headers="r21c1-t49 r1c2-t49">Indicates the maximum session idle time, in seconds. Default is <code dir="ltr">NULL</code>, which implies unlimited.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r22c1-t49" headers="r1c1-t49"><code dir="ltr">MAX_IDLE_BLOCKER_TIME</code></td>
<td class="cellalignment1335" headers="r22c1-t49 r1c2-t49">Indicates the maximum session idle time of a blocking session, in seconds. Default is <code dir="ltr">NULL</code>, which implies unlimited.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r23c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_TIME_IN_CALL</code></td>
<td class="cellalignment1335" headers="r23c1-t49 r1c2-t49">Deprecated. Use <code dir="ltr">SWITCH_FOR_CALL</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r24c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P1</code></td>
<td class="cellalignment1335" headers="r24c1-t49 r1c2-t49">For a plan with the <code dir="ltr">MGMT_MTH</code> parameter set to <code dir="ltr">EMPHASIS</code>, specifies the CPU percentage to allocate at the first level. For <code dir="ltr">MGMT_MTH</code> set to <code dir="ltr">RATIO</code>, specifies the weight of CPU usage. Default is <code dir="ltr">NULL</code> for all <code dir="ltr">MGMT_P</code><code dir="ltr"><span class="codeinlineitalic">n</span></code> parameters.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r25c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P2</code></td>
<td class="cellalignment1335" headers="r25c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the second level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r26c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P3</code></td>
<td class="cellalignment1335" headers="r26c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the third level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r27c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P4</code></td>
<td class="cellalignment1335" headers="r27c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the fourth level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r28c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P5</code></td>
<td class="cellalignment1335" headers="r28c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the fifth level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r29c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P6</code></td>
<td class="cellalignment1335" headers="r29c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the sixth level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r30c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P7</code></td>
<td class="cellalignment1335" headers="r30c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the seventh level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r31c1-t49" headers="r1c1-t49"><code dir="ltr">MGMT_P8</code></td>
<td class="cellalignment1335" headers="r31c1-t49 r1c2-t49">For <code dir="ltr">EMPHASIS</code>, specifies CPU percentage to allocate at the eighth level. Not applicable for <code dir="ltr">RATIO</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r32c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_IO_MEGABYTES</code></td>
<td class="cellalignment1335" headers="r32c1-t49 r1c2-t49">Specifies the number of megabytes of I/O that a session can transfer (read and write) before an action is taken. Default is <code dir="ltr">UNLIMITED</code>. The action is specified by <code dir="ltr">SWITCH_GROUP</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r33c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_IO_REQS</code></td>
<td class="cellalignment1335" headers="r33c1-t49 r1c2-t49">Specifies the number of I/O requests that a session can execute before an action is taken. Default is <code dir="ltr">UNLIMITED</code>. The action is specified by <code dir="ltr">SWITCH_GROUP</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r34c1-t49" headers="r1c1-t49"><code dir="ltr">SWITCH_FOR_CALL</code></td>
<td class="cellalignment1335" headers="r34c1-t49 r1c2-t49">If <code dir="ltr">TRUE</code>, a session that was automatically switched to another consumer group (according to <code dir="ltr">SWITCH_TIME</code>, <code dir="ltr">SWITCH_IO_MEGABYTES</code>, or <code dir="ltr">SWITCH_IO_REQS</code>) is returned to its original consumer group when the top level call completes. Default is <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r35c1-t49" headers="r1c1-t49"><code dir="ltr">MAX_UTILIZATION_LIMIT</code></td>
<td class="cellalignment1335" headers="r35c1-t49 r1c2-t49">Absolute maximum CPU utilization percentage permitted for the consumer group. This value overrides any level allocations for CPU (<code dir="ltr">MGMT_P1</code> through <code dir="ltr">MGMT_P8</code>), and also imposes a limit on total CPU utilization when unused allocations are redistributed. You can specify this attribute and leave <code dir="ltr">MGMT_P1</code> through <code dir="ltr">MGMT_P8</code> <code dir="ltr">NULL</code>.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r36c1-t49" headers="r1c1-t49"><code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code></td>
<td class="cellalignment1335" headers="r36c1-t49 r1c2-t49">Specifies the maximum percentage of the parallel server pool that a particular consumer group can use. The number of parallel servers used by a particular consumer group is counted as the sum of the parallel servers used by all sessions in that consumer group.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r37c1-t49" headers="r1c1-t49"><code dir="ltr">PARALLEL_QUEUE_TIMEOUT</code></td>
<td class="cellalignment1335" headers="r37c1-t49 r1c2-t49">Specifies the maximum time, in seconds, that a parallel statement can wait in the parallel statement queue before it is timed out.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="ADMIN12653"></a>Example 1:</p>
<p>The following PL/SQL block creates a resource plan directive for plan <code dir="ltr">DAYTIME</code>. (It assumes that the <code dir="ltr">DAYTIME</code> plan and <code dir="ltr">OLTP</code> consumer group are already created in the pending area.)</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
   PLAN             =&gt; 'DAYTIME',
   GROUP_OR_SUBPLAN =&gt; 'OLTP',
   COMMENT          =&gt; 'OLTP group',
   MGMT_P1          =&gt; 75);
END;
/
</pre>
<p>This directive assigns 75% of CPU resources to the <code dir="ltr">OLTP</code> consumer group at level 1.</p>
<p>To complete the plan shown in <a href="#i1007657">Figure 27-1</a>, you would create the <code dir="ltr">REPORTING</code> consumer group, and then execute the following PL/SQL block:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
   PLAN                     =&gt; 'DAYTIME', 
   GROUP_OR_SUBPLAN         =&gt; 'REPORTING',
   COMMENT                  =&gt; 'Reporting group',
   MGMT_P1                  =&gt; 15,
   PARALLEL_DEGREE_LIMIT_P1 =&gt; 8,
   ACTIVE_SESS_POOL_P1      =&gt; 4);

  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
   PLAN                     =&gt; 'DAYTIME', 
   GROUP_OR_SUBPLAN         =&gt; 'OTHER_GROUPS',
   COMMENT                  =&gt; 'This one is required',
   MGMT_P1                  =&gt; 10);
END;
/
</pre>
<p>In this plan, consumer group <code dir="ltr">REPORTING</code> has a maximum degree of parallelism of 8 for any operation, while none of the other consumer groups are limited in their degree of parallelism<a id="sthref2849"></a><a id="sthref2850"></a>. In addition, the <code dir="ltr">REPORTING</code> group has a maximum of 4 concurrently active sessions.</p>
<p class="subhead2"><a id="ADMIN12654"></a>Example 2:</p>
<p>This example uses the <code dir="ltr">RATIO</code> method to allocate CPU, which uses ratios instead of percentages. Suppose your application suite offers three service levels to clients: Gold, Silver, and Bronze. You create three consumer groups named <code dir="ltr">GOLD_CG</code>, <code dir="ltr">SILVER_CG</code>, and <code dir="ltr">BRONZE_CG</code>, and you create the following resource plan:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PLAN
   (PLAN             =&gt; 'SERVICE_LEVEL_PLAN',
    MGMT_MTH         =&gt; 'RATIO', 
    COMMENT          =&gt; 'Plan that supports three service levels');

  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE
   (PLAN             =&gt; 'SERVICE_LEVEL_PLAN',
    GROUP_OR_SUBPLAN =&gt; 'GOLD_CG', 
    COMMENT          =&gt; 'Gold service level customers',
    MGMT_P1          =&gt; 10);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE
   (PLAN             =&gt; 'SERVICE_LEVEL_PLAN',
    GROUP_OR_SUBPLAN =&gt; 'SILVER_CG', 
    COMMENT          =&gt; 'Silver service level customers',  
    MGMT_P1          =&gt; 5);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE
   (PLAN             =&gt; 'SERVICE_LEVEL_PLAN',
    GROUP_OR_SUBPLAN =&gt; 'BRONZE_CG', 
    COMMENT          =&gt; 'Bronze service level customers',
    MGMT_P1          =&gt; 2);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE
    (PLAN            =&gt; 'SERVICE_LEVEL_PLAN', 
    GROUP_OR_SUBPLAN =&gt; 'OTHER_GROUPS',
    COMMENT          =&gt; 'Lowest priority sessions',
    MGMT_P1          =&gt; 1);
END;
/
</pre>
<p>The ratio of CPU allocation is 10:5:2:1 for the <code dir="ltr">GOLD_CG</code>, <code dir="ltr">SILVER_CG</code>, <code dir="ltr">BRONZE_CG</code>, and <code dir="ltr">OTHER_GROUPS</code> consumer groups, respectively.</p>
<p>If sessions exist only in the <code dir="ltr">GOLD_CG</code> and <code dir="ltr">SILVER_CG</code> consumer groups, then the ratio of CPU allocation is 10:5 between the two groups.</p>
<div id="ADMIN11869" class="sect3"><a id="sthref2851"></a>
<h4 class="sect3">How Resource Plan Directives Interact</h4>
<p>You may have occasion to reference the same consumer group from the top plan and any number of subplans. This results in multiple resource plan directives referring to the same consumer group. Although this is allowed, Oracle strongly recommends that you avoid referencing the same consumer group from a top plan and any of its subplans.</p>
<p>When multiple resource plan directives refer to the same consumer group, the following rules apply:</p>
<ul>
<li>
<p>The parallel degree limit for the consumer group will be the <span class="italic">minimum</span> of all the incoming values.</p>
</li>
<li>
<p>The active session pool for the consumer group will be the <span class="italic">sum</span> of all the incoming values and the queue timeout will be the <span class="italic">minimum</span> of all incoming timeout values.</p>
</li>
<li>
<p>The undo pool for the consumer group will be the <span class="italic">sum</span> of all the incoming values.</p>
</li>
<li>
<p>If there is more than one <code dir="ltr">SWITCH_TIME</code>, <code dir="ltr">SWITCH_IO_MEGABYTES</code>, or <code dir="ltr">SWITCH_IO_REQS</code>, Oracle Database Resource Manager (the Resource Manager) chooses the <span class="italic">most restrictive</span> of all incoming values. Specifically:</p>
<ul>
<li>
<p><code dir="ltr">SWITCH_TIME</code> = <code dir="ltr"><span class="codeinlineitalic">min</span></code> (all incoming <code dir="ltr">SWITCH_TIME</code> values)</p>
</li>
<li>
<p><code dir="ltr">SWITCH_IO_MEGABYTES</code> = <code dir="ltr"><span class="codeinlineitalic">min</span></code> (all incoming <code dir="ltr">SWITCH_IO_MEGABYTES</code> values)</p>
</li>
<li>
<p><code dir="ltr">SWITCH_IO_REQS</code> = <code dir="ltr"><span class="codeinlineitalic">min</span></code> (all incoming <code dir="ltr">SWITCH_IO_REQS</code> values)</p>
</li>
<li>
<p><code dir="ltr">SWITCH_ESTIMATE = TRUE</code> overrides <code dir="ltr">SWITCH_ESTIMATE = FALSE</code></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If both plan directives specify the same switch time, but different switch groups, then the choice about which group to switch to is statically but arbitrarily decided by the Resource Manager.</div>
</li>
</ul>
</li>
<li>
<p><code dir="ltr">SWITCH_FOR_CALL</code> is <code dir="ltr">TRUE</code> if any of the incoming values are <code dir="ltr">TRUE</code>.</p>
</li>
<li>
<p>The maximum estimated execution time will be the <span class="italic">most restrictive</span> of all incoming values. Specifically:</p>
<p><code dir="ltr">MAX_EST_EXEC_TIME</code> = <code dir="ltr"><span class="codeinlineitalic">min</span></code> (all incoming <code dir="ltr">MAX_EST_EXEC_TIME</code> values)</p>
</li>
<li>
<p>The maximum idle time is the <span class="italic">minimum</span> of all incoming values.</p>
</li>
<li>
<p>The maximum idle blocker time is the <span class="italic">minimum</span> of all incoming values.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDEAIGB">"Updating a Resource Plan Directive"</a></p>
</li>
<li>
<p><a href="#CHDJHCAC">"Deleting a Resource Plan Directive"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CHDHFJJJ"></a>
<div id="ADMIN11870" class="sect2">
<h3 class="sect2">Validating the Pending Area<a id="sthref2852"></a><a id="sthref2853"></a><a id="sthref2854"></a><a id="sthref2855"></a></h3>
<p>At any time when you are making changes in the pending area, you can call <code dir="ltr">VALIDATE_PENDING_AREA</code> to ensure that the pending area is valid so far.</p>
<p>The following rules must be adhered to, and are checked by the validate procedure:</p>
<ul>
<li>
<p>No plan can contain any loops. A loop occurs when a subplan contains a directive that references a plan that is above the subplan in the plan hierarchy. For example, a subplan cannot reference the top plan.</p>
</li>
<li>
<p>All plans and resource consumer groups referred to by plan directives<a id="sthref2856"></a><a id="sthref2857"></a> must exist.</p>
</li>
<li>
<p>All plans must have plan directives that point to either plans or resource consumer groups.</p>
</li>
<li>
<p>All percentages in any given level must not add up to greater than 100.</p>
</li>
<li>
<p>A plan that is currently being used as a top plan<a id="sthref2858"></a> by an active instance cannot be deleted.</p>
</li>
<li>
<p>The following parameters can appear only in plan directives that refer to resource consumer groups, not other resource plans:</p>
<ul>
<li>
<p><code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code></p>
</li>
<li>
<p><code dir="ltr">ACTIVE_SESS_POOL_P1</code></p>
</li>
<li>
<p><code dir="ltr">QUEUEING_P1</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_GROUP</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_TIME</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_ESTIMATE</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_IO_REQS</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_IO_MEGABYTES</code></p>
</li>
<li>
<p><code dir="ltr">MAX_EST_EXEC_TIME</code></p>
</li>
<li>
<p><code dir="ltr">UNDO_POOL</code></p>
</li>
<li>
<p><code dir="ltr">MAX_IDLE_TIME</code></p>
</li>
<li>
<p><code dir="ltr">MAX_IDLE_BLOCKER_TIME</code></p>
</li>
<li>
<p><code dir="ltr">SWITCH_FOR_CALL</code></p>
</li>
<li>
<p><code dir="ltr">MAX_UTILIZATION_LIMIT</code></p>
</li>
</ul>
</li>
<li>
<p>There can be no more than 28 resource consumer groups in any active plan. Also, at most, a plan can have 28 children.</p>
</li>
<li>
<p>Plans and resource consumer groups cannot have the same name.</p>
</li>
<li>
<p>There must be a plan directive for <code dir="ltr">OTHER_GROUPS</code> somewhere in any active plan. This ensures that a session that is not part of any of the consumer groups included in the currently active plan is allocated resources (as specified by the<a id="sthref2859"></a><a id="sthref2860"></a> directive for <code dir="ltr">OTHER_GROUPS</code>).</p>
</li>
</ul>
<p><code dir="ltr">VALIDATE_PENDING_AREA</code> raises an error if any of the preceding rules are violated. You can then make changes to fix any problems and call the procedure again.</p>
<p>It is possible to create "orphan" consumer groups that have no plan directives referring to them. This allows the creation of consumer groups that will not currently be used, but might be part of some plan to be implemented in the future.</p>
<p class="subhead2"><a id="ADMIN12655"></a>Example: Validating the Pending Area:</p>
<p>The following PL/SQL block validates the pending area.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
END;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDHBJCB">"About the Pending Area"</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDBEEFF"></a>
<div id="ADMIN11871" class="sect2">
<h3 class="sect2">Submitting the Pending Area</h3>
<p>After you have validated your changes, call the <code dir="ltr">SUBMIT_PENDING_AREA</code> procedure to make your changes active.</p>
<p>The submit procedure also performs validation, so you do not necessarily need to make separate calls to the validate procedure. However, if you are making major changes to plans, debugging problems is often easier if you incrementally validate your changes. No changes are submitted (made active) until validation is successful on all of the changes in the pending area.</p>
<p>The <code dir="ltr">SUBMIT_PENDING_AREA</code> procedure clears (deactivates) the pending area after successfully validating and committing the changes.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A call to <code dir="ltr">SUBMIT_PENDING_AREA</code> might fail even if <code dir="ltr">VALIDATE_PENDING_AREA</code> succeeds. This can happen if, for example, a plan being deleted is loaded by an instance after a call to <code dir="ltr">VALIDATE_PENDING_AREA</code>, but before a call to <code dir="ltr">SUBMIT_PENDING_AREA</code>.</div>
<p class="subhead2"><a id="ADMIN12656"></a>Example: Submitting the Pending Area:</p>
<p>The following PL/SQL block submits the pending area:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDHBJCB">"About the Pending Area"</a></div>
</div>
<!-- class="sect2" -->
<a id="CHDGCDHJ"></a>
<div id="ADMIN11872" class="sect2">
<h3 class="sect2">Clearing the Pending Area</h3>
<p>There is also a procedure for clearing the pending area at any time. This PL/SQL block causes all of your changes to be cleared from the pending area and deactivates the pending area:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CLEAR_PENDING_AREA();
END;
/
</pre>
<p>After calling <code dir="ltr">CLEAR_PENDING_AREA</code>, you must call the <code dir="ltr">CREATE_PENDING_AREA</code> procedure before you can again attempt to make changes.<a id="sthref2861"></a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDHBJCB">"About the Pending Area"</a></div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008488"></a>
<div id="ADMIN11890" class="sect1">
<h2 class="sect1">Enabling Oracle Database Resource Manager and Switching Plans</h2>
<p>You <a id="sthref2862"></a><a id="sthref2863"></a><a id="sthref2864"></a><a id="sthref2865"></a>enable Oracle Database Resource Manager (the Resource Manager) by setting the <code dir="ltr">RESOURCE_MANAGER_PLAN</code><a id="sthref2866"></a><a id="sthref2867"></a> initialization parameter. This parameter specifies the top plan<a id="sthref2868"></a><a id="sthref2869"></a>, identifying the plan<a id="sthref2870"></a><a id="sthref2871"></a><a id="sthref2872"></a> to be used for the current instance. If no plan is specified with this parameter, the Resource Manager is not enabled.</p>
<p>By default the Resource Manager is not enabled, except during preconfigured maintenance windows, described later in this section.</p>
<p>The following statement in a text initialization parameter file activates the Resource Manager upon database startup and sets the top plan as <code dir="ltr">mydb_plan</code>.</p>
<pre dir="ltr">
RESOURCE_MANAGER_PLAN = mydb_plan
</pre>
<p>You can also activate or deactivate the Resource Manager, or change the current top plan, using the <code dir="ltr">DBMS_RESOURCE_MANAGER.SWITCH_PLAN</code> package procedure or the <a id="sthref2873"></a><code dir="ltr">ALTER SYSTEM</code> statement.</p>
<p>The following SQL statement sets the top plan to <code dir="ltr">mydb_plan</code>, and activates the Resource Manager if it is not already active:</p>
<pre dir="ltr">
ALTER SYSTEM SET RESOURCE_MANAGER_PLAN = 'mydb_plan';
</pre>
<p>An error message is returned if the specified plan does not exist in the data dictionary.</p>
<p class="subhead2"><a id="ADMIN12660"></a>Automatic Enabling of the Resource Manager by Oracle Scheduler Windows</p>
<p>The Resource Manager automatically activates if an Oracle Scheduler window that specifies a resource plan opens. When the Scheduler window closes, the resource plan associated with the window is disabled, and the resource plan that was running before the Scheduler window opened is reenabled. (If no resource plan was enabled before the window opened, then the Resource Manager is disabled.) In an Oracle Real Application Clusters environment, a Scheduler window applies to all instances, so the window's resource plan is enabled on every instance.</p>
<p>Note that by default a set of automated maintenance tasks run during <span class="bold">maintenance windows</span>, which are predefined Scheduler windows that are members of the <code dir="ltr">MAINTENANCE_WINDOW_GROUP</code> window group and which specify the <code dir="ltr">DEFAULT_MAINTENANCE_PLAN</code> resource plan. Thus, the Resource Manager activates by default during maintenance windows. You can modify these maintenance windows to use a different resource plan, if desired.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If you change the plan associated with maintenance windows, then ensure that you include the subplan <code dir="ltr">ORA$AUTOTASK_SUB_PLAN</code> and the consumer group <code dir="ltr">ORA$DIAGNOSTICS</code> in the new plan.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="schedover.htm#i1106396">"Windows"</a></p>
</li>
<li>
<p><a href="tasks.htm#BABJIJFC">Chapter 26, "Managing Automated Database Maintenance Tasks"</a></p>
</li>
</ul>
</div>
<p class="subhead2"><a id="ADMIN12661"></a>Disabling Plan Switches by Oracle Scheduler Windows</p>
<p>In some cases, the automatic change of Resource Manager plans at Scheduler window boundaries may be undesirable. For example, if you have an important task to finish, and if you set the Resource Manager plan to give your task priority, then you expect that the plan will remain the same until you change it. However, because a Scheduler window could activate after you have set your plan, the Resource Manager plan might change while your task is running.</p>
<p>To prevent this situation, you can set the <code dir="ltr">RESOURCE_MANAGER_PLAN</code> initialization parameter to the name of the plan that you want for the system and prepend "<code dir="ltr">FORCE:</code>" to the name, as shown in the following SQL statement:</p>
<pre dir="ltr">
ALTER SYSTEM SET RESOURCE_MANAGER_PLAN = 'FORCE:mydb_plan';
</pre>
<p>Using the prefix <code dir="ltr">FORCE:</code> indicates that the current resource plan can be changed only when the database administrator changes the value of the <code dir="ltr">RESOURCE_MANAGER_PLAN</code> initialization parameter. This restriction can be lifted by rerunning the command without preceding the plan name with "<code dir="ltr">FORCE:</code>".</p>
<p>The <code dir="ltr">DBMS_RESOURCE_MANAGER.SWITCH_PLAN</code> package procedure has a similar capability.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS050" href="../../appdev.112/e40758/d_resmgr.htm#ARPLS050"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information on <code dir="ltr">DBMS_RESOURCE_MANAGER.SWITCH_PLAN</code>.</div>
<p class="subhead2"><a id="CHDFEGHE"></a><a id="ADMIN12662"></a>Disabling the Resource Manager</p>
<p>To disable the Resource Manager, complete the following steps:</p>
<ol>
<li>
<p>Issue the following SQL statement:</p>
<pre dir="ltr">
ALTER SYSTEM SET RESOURCE_MANAGER_PLAN = '';
</pre></li>
<li>
<p>Disassociate the Resource Manager from all Oracle Scheduler windows.</p>
<p>To do so, for any Scheduler window that references a resource plan in its <code dir="ltr">resource_plan</code> attribute, use the <code dir="ltr">DBMS_SCHEDULER.SET_ATTRIBUTE</code> procedure to set <code dir="ltr">resource_plan</code> to the empty string (''). Qualify the window name with the <code dir="ltr">SYS</code> schema name if you are not logged in as user <code dir="ltr">SYS</code>. You can view Scheduler windows with the <code dir="ltr">DBA_SCHEDULER_WINDOWS</code> data dictionary view. See <a href="scheduse.htm#schedusealtwindow47">"Altering Windows"</a> and <a class="olink ARPLS72235" href="../../appdev.112/e40758/d_sched.htm#ARPLS72235"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
By default, all maintenance windows reference the <code dir="ltr">DEFAULT_MAINTENANCE_PLAN</code> resource plan. To completely disable the Resource Manager, you must alter all maintenance windows to remove this plan. However, use caution, because resource consumption by automated maintenance tasks will no longer be regulated, which may adversely affect the performance of your other sessions. See <a href="tasks.htm#BABJIJFC">Chapter 26, "Managing Automated Database Maintenance Tasks"</a> for more information on maintenance windows.</div>
</li>
</ol>
</div>
<!-- class="sect1" -->
<a id="i1008504"></a>
<div id="ADMIN11012" class="sect1">
<h2 class="sect1">Putting It All Together: Oracle Database Resource Manager Examples</h2>
<p><a id="sthref2874"></a><a id="sthref2875"></a><a id="sthref2876"></a>This section provides some examples of resource plans. The following examples are presented:</p>
<ul>
<li>
<p><a href="#i1008520">Multilevel Plan Example</a></p>
</li>
<li>
<p><a href="#CFHCJGIB">Examples of Using the Maximum Utilization Limit Attribute</a></p>
</li>
<li>
<p><a href="#i1008595">Example of Using Several Resource Allocation Methods</a></p>
</li>
<li>
<p><a href="#BABCIJDG">Example of Managing Parallel Statements Using Directive Attributes</a></p>
</li>
<li>
<p><a href="#i1008675">An Oracle-Supplied Mixed Workload Plan</a></p>
</li>
</ul>
<a id="i1008520"></a>
<div id="ADMIN11891" class="sect2">
<h3 class="sect2">Multilevel Plan Example</h3>
<p>The following PL/SQL block creates a multilevel plan as illustrated in <a href="#BABIIIDF">Figure 27-3</a>. Default resource allocation method settings are used for all plans and resource consumer groups.</p>
<pre dir="ltr">
BEGIN
DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
DBMS_RESOURCE_MANAGER.CREATE_PLAN(PLAN =&gt; 'bugdb_plan', 
   COMMENT =&gt; 'Resource plan/method for bug users sessions');
DBMS_RESOURCE_MANAGER.CREATE_PLAN(PLAN =&gt; 'maildb_plan', 
   COMMENT =&gt; 'Resource plan/method for mail users sessions');
DBMS_RESOURCE_MANAGER.CREATE_PLAN(PLAN =&gt; 'mydb_plan', 
   COMMENT =&gt; 'Resource plan/method for bug and mail users sessions');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'Online_group', 
   COMMENT =&gt; 'Resource consumer group/method for online bug users sessions');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'Batch_group', 
   COMMENT =&gt; 'Resource consumer group/method for batch job bug users sessions');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'Bug_Maint_group',
   COMMENT =&gt; 'Resource consumer group/method for users sessions for bug db maint');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'Users_group', 
   COMMENT =&gt; 'Resource consumer group/method for mail users sessions');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'Postman_group',
   COMMENT =&gt; 'Resource consumer group/method for mail postman');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'Mail_Maint_group', 
   COMMENT =&gt; 'Resource consumer group/method for users sessions for mail db maint');
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'bugdb_plan',
   GROUP_OR_SUBPLAN =&gt; 'Online_group',
   COMMENT =&gt; 'online bug users sessions at level 1', MGMT_P1 =&gt; 80, MGMT_P2=&gt; 0);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'bugdb_plan', 
   GROUP_OR_SUBPLAN =&gt; 'Batch_group', 
   COMMENT =&gt; 'batch bug users sessions at level 1', MGMT_P1 =&gt; 20, MGMT_P2 =&gt; 0,
   PARALLEL_DEGREE_LIMIT_P1 =&gt; 8);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'bugdb_plan', 
   GROUP_OR_SUBPLAN =&gt; 'Bug_Maint_group',
   COMMENT =&gt; 'bug maintenance users sessions at level 2', MGMT_P1 =&gt; 0, MGMT_P2 =&gt; 100);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'bugdb_plan', 
   GROUP_OR_SUBPLAN =&gt; 'OTHER_GROUPS', 
   COMMENT =&gt; 'all other users sessions at level 3', MGMT_P1 =&gt; 0, MGMT_P2 =&gt; 0,
   MGMT_P3 =&gt; 100);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'maildb_plan', 
   GROUP_OR_SUBPLAN =&gt; 'Postman_group',
   COMMENT =&gt; 'mail postman at level 1', MGMT_P1 =&gt; 40, MGMT_P2 =&gt; 0);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'maildb_plan',
   GROUP_OR_SUBPLAN =&gt; 'Users_group',
   COMMENT =&gt; 'mail users sessions at level 2', MGMT_P1 =&gt; 0, MGMT_P2 =&gt; 80);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'maildb_plan',
   GROUP_OR_SUBPLAN =&gt; 'Mail_Maint_group',
   COMMENT =&gt; 'mail maintenance users sessions at level 2', MGMT_P1 =&gt; 0, MGMT_P2 =&gt; 20);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'maildb_plan',
   GROUP_OR_SUBPLAN =&gt; 'OTHER_GROUPS', 
   COMMENT =&gt; 'all other users sessions at level 3', MGMT_P1 =&gt; 0, MGMT_P2 =&gt; 0,
   MGMT_P3 =&gt; 100);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'mydb_plan', 
   GROUP_OR_SUBPLAN =&gt; 'maildb_plan', 
   COMMENT=&gt; 'all mail users sessions at level 1', MGMT_P1 =&gt; 30);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'mydb_plan', 
   GROUP_OR_SUBPLAN =&gt; 'bugdb_plan', 
   COMMENT =&gt; 'all bug users sessions at level 1', MGMT_P1 =&gt; 70);
DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<p>The preceding call to <code dir="ltr">VALIDATE_PENDING_AREA</code> is optional because the validation is implicitly performed in <code dir="ltr">SUBMIT_PENDING_AREA</code>.</p>
<div id="ADMIN13075" class="figure">
<p class="titleinfigure"><a id="BABIIIDF"></a>Figure 27-3 Multilevel Plan Schema</p>
<img width="698" height="309" src="img/admin057.gif" alt="Description of Figure 27-3 follows" /><br />
<a id="sthref2877" href="img_text/admin057.htm">Description of "Figure 27-3 Multilevel Plan Schema"</a><br />
<br /></div>
<!-- class="figure" -->
<p>In this plan schema, CPU resources are allocated as follows:</p>
<ul>
<li>
<p>Under <code dir="ltr">mydb_plan</code>, 30% of CPU is allocated to the <code dir="ltr">maildb_plan</code> subplan, and 70% is allocated to the <code dir="ltr">bugdb_plan</code> subplan. Both subplans are at level 1. Because <code dir="ltr">mydb_plan</code> itself has no levels below level 1, any resource allocations that are unused by either subplan at level 1 can be used by its sibling subplan. Thus, if <code dir="ltr">maildb_plan</code> uses only 20% of CPU, then 80% of CPU is available to <code dir="ltr">bugdb_plan</code>.</p>
</li>
<li>
<p><code dir="ltr">maildb_plan</code> and <code dir="ltr">bugdb_plan</code> define allocations at levels 1, 2, and 3. The levels in these subplans are independent of levels in their parent plan, <code dir="ltr">mydb_plan</code>. That is, all plans and subplans in a plan schema have their own level 1, level 2, level 3, and so on.</p>
</li>
<li>
<p>Of the 30% of CPU allocated to <code dir="ltr">maildb_plan</code>, 40% of that amount (effectively 12% of total CPU) is allocated to <code dir="ltr">Postman_group</code> at level 1. Because <code dir="ltr">Postman_group</code> has no siblings at level 1, there is an implied 60% remaining at level 1. This 60% is then shared by <code dir="ltr">Users_group</code> and <code dir="ltr">Mail_Maint_group</code> at level 2, at 80% and 20%, respectively. In addition to this 60%, <code dir="ltr">Users_group</code> and <code dir="ltr">Mail_Maint_group</code> can also use any of the 40% not used by <code dir="ltr">Postman_group</code> at level 1.</p>
</li>
<li>
<p>CPU resources not used by either <code dir="ltr">Users_group</code> or <code dir="ltr">Mail_Maint_group</code> at level 2 are allocated to <code dir="ltr">OTHER_GROUPS</code>, because in multilevel plans, unused resources are reallocated to consumer groups or subplans at the next lower level, not to siblings at the same level. Thus, if <code dir="ltr">Users_group</code> uses only 70% instead of 80%, the remaining 10% cannot be used by <code dir="ltr">Mail_Maint_group</code>. That 10% is available only to <code dir="ltr">OTHER_GROUPS</code> at level 3.</p>
</li>
<li>
<p>The 70% of CPU allocated to the <code dir="ltr">bugdb_plan</code> subplan is allocated to its consumer groups in a similar fashion. If either <code dir="ltr">Online_group</code> or <code dir="ltr">Batch_group</code> does not use its full allocation, the remainder may be used by <code dir="ltr">Bug_Maint_group</code>. If <code dir="ltr">Bug_Maint_group</code> does not use all of that allocation, the remainder goes to <code dir="ltr">OTHER_GROUPS</code>.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CFHCJGIB"></a>
<div id="ADMIN13327" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Examples of Using the Maximum Utilization Limit Attribute</h3>
<p>You can use the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> directive attribute to limit the CPU utilization for applications. One of the most common scenarios in which this attribute can be used is for database consolidation.</p>
<p>During database consolidation, you may need to be able to do the following:</p>
<ul>
<li>
<p>Manage the performance impact that one application can have on another.</p>
<p>One method of managing this performance impact is to create a consumer group for each application and allocate resources to each consumer group.</p>
</li>
<li>
<p>Limit the utilization of each application.</p>
<p>Typically, in addition to allocating a specific percentage of the CPU resources to each consumer group, you may need to limit the maximum CPU utilization for each group. This limit prevents a consumer group from using all of the CPU resources when all the other consumer groups are idle.</p>
<p>In some cases, you may want all application users to experience consistent performance regardless of the workload from other applications. This can be achieved by specifying a maximum utilization limit for each consumer group in a resource plan.</p>
</li>
</ul>
<p>The following examples demonstrate how to use the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> resource plan directive attribute to:</p>
<ul>
<li>
<p>Restrict total database CPU utilization</p>
</li>
<li>
<p>Quarantine runaway queries</p>
</li>
<li>
<p>Limit CPU usage for applications</p>
</li>
<li>
<p>Limit CPU utilization during maintenance windows</p>
</li>
</ul>
<p class="subhead2"><a id="ADMIN13328"></a>Example 1 - Restricting Overall Database CPU Utilization</p>
<p>In this example, regardless of database load, system workload from Oracle Database never exceeds 90% of CPU, leaving 10% of CPU for other applications sharing the server.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();

  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    =&gt; 'MAXCAP_PLAN',
    COMMENT =&gt; 'Limit overall database CPU');
   
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    PLAN              =&gt; 'MAXCAP_PLAN',
    GROUP_OR_SUBPLAN  =&gt; 'OTHER_GROUPS',
    COMMENT           =&gt; 'This group is mandatory',
    MAX_UTILIZATION_LIMIT =&gt; 90);

  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<p>Because there is no plan directive other than the one for <code dir="ltr">OTHER_GROUPS</code>, all sessions are mapped to <code dir="ltr">OTHER_GROUPS</code>.</p>
<p class="subhead2"><a id="ADMIN13329"></a>Example 2 - Quarantining Runaway Queries</p>
<p>In this example, runaway queries are switched to a consumer group with a maximum utilization limit of 20%, limiting the amount of resources that they can consume until you can intervene. A runaway query is characterized here as one that takes more than 10 minutes of CPU time. Assume that session mapping rules start all sessions in <code dir="ltr">START_GROUP</code>.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();

  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'START_GROUP',
     COMMENT        =&gt; 'Sessions start here');
   
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'QUARANTINE_GROUP',
     COMMENT        =&gt; 'Sessions switched here to quarantine them');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    =&gt; 'Quarantine_plan',
    COMMENT =&gt; 'Quarantine runaway queries');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    PLAN                  =&gt; 'Quarantine_plan',
    GROUP_OR_SUBPLAN      =&gt; 'START_GROUP',
    COMMENT               =&gt; 'Max CPU 10 minutes before switch',
    MGMT_P1               =&gt; 75,
    switch_group          =&gt; 'QUARANTINE_GROUP',
    switch_time           =&gt; 600);
  
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    PLAN                  =&gt; 'Quarantine_plan',
    GROUP_OR_SUBPLAN      =&gt; 'OTHER_GROUPS',
    COMMENT               =&gt; 'Mandatory',
    MGMT_P1               =&gt; 25);
  
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    PLAN                  =&gt; 'Quarantine_plan',
    GROUP_OR_SUBPLAN      =&gt; 'QUARANTINE_GROUP',
    COMMENT               =&gt; 'Limited CPU',
    MGMT_P2               =&gt; 100,
    MAX_UTILIZATION_LIMIT =&gt; 20);

  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Although you could set the maximum utilization limit to zero for <code dir="ltr">QUARANTINE_GROUP</code>, thus completely quarantining runaway queries, it is recommended that you avoid doing this. If the runaway query is holding any resources&mdash;PGA memory, locks, and so on&mdash;required by any other session, then a zero allocation setting could lead to a deadlock.</div>
<p class="subhead2"><a id="ADMIN13330"></a>Example 3 - LImiting CPU for Applications</p>
<p>In this example, assume that mapping rules map application sessions into one of four application groups. Each application group is allocated a maximum utilization limit of 30%. This limits CPU utilization of any one application to 30%. The sum of the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> values exceeds 100%, which is permissible and acceptable in a situation where all applications are not active simultaneously.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
   
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP1_GROUP',
     COMMENT        =&gt; 'Apps group 1');
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP2_GROUP',
     COMMENT        =&gt; 'Apps group 2');
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP3_GROUP',
     COMMENT        =&gt; 'Apps group 3');
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP4_GROUP',
     COMMENT        =&gt; 'Apps group 4');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    =&gt; 'apps_plan',
    COMMENT =&gt; 'Application consolidation');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'apps_plan',
    GROUP_OR_SUBPLAN      =&gt; 'APP1_GROUP',
    COMMENT               =&gt; 'Apps group 1',
    MAX_UTILIZATION_LIMIT =&gt; 30);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'apps_plan',
    GROUP_OR_SUBPLAN      =&gt; 'APP2_GROUP',
    COMMENT               =&gt; 'Apps group 2',
    MAX_UTILIZATION_LIMIT =&gt; 30);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'apps_plan',
    GROUP_OR_SUBPLAN      =&gt; 'APP3_GROUP',
    COMMENT               =&gt; 'Apps group 3',
    MAX_UTILIZATION_LIMIT =&gt; 30);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'apps_plan',
    GROUP_OR_SUBPLAN      =&gt; 'APP4_GROUP',
    COMMENT               =&gt; 'Apps group 4',
    MAX_UTILIZATION_LIMIT =&gt; 30);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'apps_plan',
    GROUP_OR_SUBPLAN      =&gt; 'OTHER_GROUPS',
    COMMENT               =&gt; 'Mandatory',
    MAX_UTILIZATION_LIMIT =&gt; 20);
 
  DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<p>If all four application groups can fully use the CPU allocated to them (30% in this case), then the minimum CPU that is allocated to each application group is computed as a ratio of the application group's limit to the total of the limits of all application groups. In this example, all four application groups are allocated a maximum utilization limit of 30%. Therefore, when all four groups fully use their limits, the CPU allocation to each group is 30/(30+30+30+30) = 25%.</p>
<p class="subhead2"><a id="BABEAJGH"></a><a id="ADMIN13469"></a>Example 4 - Specifying a Maximum Utilization Limit for Consumer Groups and Subplans</p>
<p>The following <a id="sthref2878"></a>example describes how the maximum utilization limit is computed for scenarios, such as the one in <a href="#BABHHCCA">Figure 27-4</a>, where you set <code dir="ltr">MAX_UTILIZATION_LIMIT</code> for a subplan and for consumer groups within the subplan. For simplicity, the requirement to include the <code dir="ltr">OTHER_GROUPS</code> consumer group is ignored, and resource plan directives are not shown, even though they are part of the plan.</p>
<div id="ADMIN13470" class="figure">
<p class="titleinfigure"><a id="BABHHCCA"></a>Figure 27-4 Resource Plan with Maximum Utilization for Subplan and Consumer Groups</p>
<img width="650" height="350" src="img/admin087.gif" alt="Description of Figure 27-4 follows" /><br />
<a id="sthref2879" href="img_text/admin087.htm">Description of "Figure 27-4 Resource Plan with Maximum Utilization for Subplan and Consumer Groups"</a><br />
<br /></div>
<!-- class="figure" -->
<p>The following PL/SQL block creates the plan described in <a href="#BABHHCCA">Figure 27-4</a>.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
    DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP1_GROUP',
     COMMENT        =&gt; 'Group for application #1');
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP2_OLTP_GROUP',
     COMMENT        =&gt; 'Group for OLTP activity in application #2');
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP2_ADHOC_GROUP',
     COMMENT        =&gt; 'Group for ad-hoc queries in application #2');
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP (
     CONSUMER_GROUP =&gt; 'APP2_REPORT_GROUP',
     COMMENT        =&gt; 'Group for reports in application #2');
   DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    =&gt; 'APPS_PLAN',
    COMMENT =&gt; 'Plan for managing 3 applications');
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    =&gt; 'APP2_SUBPLAN',
    COMMENT =&gt; 'Subplan for managing application #2',
    SUB_PLAN =&gt; TRUE);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    PLAN    =&gt; 'APP2_REPORTS_SUBPLAN',
    COMMENT =&gt; 'Subplan for managing reports in application #2',
    SUB_PLAN =&gt; TRUE);

  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APPS_PLAN',
    GROUP_OR_SUBPLAN      =&gt; 'APP1_GROUP',
    COMMENT               =&gt; 'Limit CPU for application #1 to 40%',
    MAX_UTILIZATION_LIMIT =&gt; 40);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APPS_PLAN',
    GROUP_OR_SUBPLAN      =&gt; 'APP2_SUBPLAN',
    COMMENT               =&gt; 'Limit CPU for application #2 to 40%',
    MAX_UTILIZATION_LIMIT =&gt; 40);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APP2_SUBPLAN',
    GROUP_OR_SUBPLAN      =&gt; 'APP2_OLTP_GROUP',
    COMMENT               =&gt; 'Limit CPU for OLTP to 90% of application #2',
    MAX_UTILIZATION_LIMIT =&gt; 90);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APP2_SUBPLAN',
    GROUP_OR_SUBPLAN      =&gt; 'APP2_REPORTS_SUBPLAN',
    COMMENT               =&gt; 'Subplan for ad-hoc and normal reports for application #2');
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APP2_REPORTS_SUBPLAN',
    GROUP_OR_SUBPLAN      =&gt; 'APP2_ADHOC_GROUP',
    COMMENT               =&gt; 'Limit CPU for ad-hoc queries to 50% of application #2 reports',
    MAX_UTILIZATION_LIMIT =&gt; 50);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APP2_REPORTS_SUBPLAN',
    GROUP_OR_SUBPLAN      =&gt; 'APP2_REPORT_GROUP',
    COMMENT               =&gt; 'Limit CPU for reports to 50% of application #2 reports',
    MAX_UTILIZATION_LIMIT =&gt; 50);
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE (
    PLAN                  =&gt; 'APPS_PLAN',
    GROUP_OR_SUBPLAN      =&gt; 'OTHER_GROUPS',
    COMMENT               =&gt; 'No directives for default users');
   DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<p>In this example, the maximum CPU utilization for the consumer group <code dir="ltr">APP1_GROUP</code> and subplan <code dir="ltr">APP2_SUBPLAN</code> is set to 40%. The limit for the consumer groups <code dir="ltr">APP2_ADHOC_GROUP</code> and <code dir="ltr">APP2_REPORT_GROUP</code> is set to 50%.</p>
<p>Because there is no limit specified for the subplan <code dir="ltr">APP2_REPORTS_SUBPLAN</code>, it inherits the limit of its parent subplan <code dir="ltr">APP2_SUBPLAN</code>, which is 40%. The absolute limit for the consumer group <code dir="ltr">APP2_REPORT_GROUP</code> is computed as 50% of its parent subplan, which is 50% of 40%, or 20%.</p>
<p>Similarly, because the consumer group <code dir="ltr">APP2_ADHOC_GROUP</code> is contained in the subplan <code dir="ltr">APP2_REPORTS_SUBPLAN</code>, its limit is computed as a percentage of its parent subplan. The maximum utilization limit for the consumer group <code dir="ltr">APP2_ADHOC_GROUP</code> is 50% of 40%, or 20%.</p>
<p>The maximum CPU utilization for the consumer group <code dir="ltr">APP2_OLTP_GROUP</code> is set to 90%. The parent subplan of <code dir="ltr">APP2_OLTP_GROUP</code>, <code dir="ltr">APP2_SUBPLAN</code>, has a limit of 40%. Therefore, the absolute limit for the group <code dir="ltr">APP2_OLTP_GROUP</code> is 90% of 40%, or 36%.</p>
</div>
<!-- class="sect2" -->
<a id="i1008595"></a>
<div id="ADMIN11892" class="sect2">
<h3 class="sect2">Example of Using Several Resource Allocation Methods</h3>
<p>The example presented here could represent a plan for a database supporting a packaged ERP (Enterprise Resource Planning) or CRM (Customer Relationship Management) application. The work in such an environment can be highly varied. There may be a mix of short transactions and quick queries, in combination with longer running batch jobs that include large parallel queries. The goal is to give good response time to OLTP (Online Transaction Processing), while allowing batch jobs to run in parallel.</p>
<p>The plan is summarized in the following table.</p>
<div class="inftblruleinformalwide">
<table class="cellalignment1333" title="Description of Example Plan" summary="Column 1 contains the consumer group name; column 2 specifies the CPU resource allocation percent; column 3 specifies the active session pool parameter; column 4 specifies the automatic switching parameters; column 5 specifies the maximum estimated execution time, and column 6 specifies the size of the undo pool." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t61">Group</th>
<th class="cellalignment1334" id="r1c2-t61">CPU Resource Allocation %</th>
<th class="cellalignment1334" id="r1c3-t61">Active Session Pool Parameters</th>
<th class="cellalignment1334" id="r1c4-t61">Automatic Consumer Group Switching</th>
<th class="cellalignment1334" id="r1c5-t61">Maximum Estimated Execution Time</th>
<th class="cellalignment1334" id="r1c6-t61">Undo Pool</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t61" headers="r1c1-t61"><code dir="ltr">oltp</code></td>
<td class="cellalignment1335" headers="r2c1-t61 r1c2-t61">Level 1: 80%</td>
<td class="cellalignment1335" headers="r2c1-t61 r1c3-t61">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t61 r1c4-t61">Switch to group: <code dir="ltr">batch</code>
<p>Switch time: 3 secs</p>
</td>
<td class="cellalignment1335" headers="r2c1-t61 r1c5-t61">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t61 r1c6-t61">200K</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t61" headers="r1c1-t61"><code dir="ltr">batch</code></td>
<td class="cellalignment1335" headers="r3c1-t61 r1c2-t61">Level 2: 100%</td>
<td class="cellalignment1335" headers="r3c1-t61 r1c3-t61">Pool size: 5
<p>Timeout: 600 secs</p>
</td>
<td class="cellalignment1335" headers="r3c1-t61 r1c4-t61">--</td>
<td class="cellalignment1335" headers="r3c1-t61 r1c5-t61">3600 secs</td>
<td class="cellalignment1335" headers="r3c1-t61 r1c6-t61">--</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t61" headers="r1c1-t61"><code dir="ltr">OTHER_GROUPS</code></td>
<td class="cellalignment1335" headers="r4c1-t61 r1c2-t61">Level 3: 100%</td>
<td class="cellalignment1335" headers="r4c1-t61 r1c3-t61">--</td>
<td class="cellalignment1335" headers="r4c1-t61 r1c4-t61">--</td>
<td class="cellalignment1335" headers="r4c1-t61 r1c5-t61">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t61 r1c6-t61">--</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformalwide" -->
<p>By assigning only 80% of the CPU to <code dir="ltr">oltp</code> at level 1, <code dir="ltr">batch</code> is guaranteed to get at least 20%, plus any of <code dir="ltr">oltp</code>'s unused CPU resources. <code dir="ltr">OTHER_GROUPS</code>, however, is not guaranteed any CPU resources. It gets CPU resources only if <code dir="ltr">batch</code> cannot consume all of its allocation. A similar-looking plan would give <code dir="ltr">oltp</code> 80% and <code dir="ltr">batch</code> 20%, both at level 1, and <code dir="ltr">OTHER_GROUPS</code> 100% at level 2. With this plan, <code dir="ltr">oltp</code>'s unused CPU allocation would be given to <code dir="ltr">OTHER_GROUPS</code>, not <code dir="ltr">batch</code>.</p>
<p>The following statements create the preceding plan, which is named <code dir="ltr">erp_plan</code>:</p>
<pre dir="ltr">
BEGIN
DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
DBMS_RESOURCE_MANAGER.CREATE_PLAN(PLAN =&gt; 'erp_plan', 
  COMMENT =&gt; 'Resource plan/method for ERP Database');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'oltp', 
  COMMENT =&gt; 'Resource consumer group/method for OLTP jobs');
DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(CONSUMER_GROUP =&gt; 'batch', 
  COMMENT =&gt; 'Resource consumer group/method for BATCH jobs');
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'erp_plan', 
  GROUP_OR_SUBPLAN =&gt; 'oltp', COMMENT =&gt; 'OLTP sessions', MGMT_P1 =&gt; 80, 
  SWITCH_GROUP =&gt; 'batch', SWITCH_TIME =&gt; 3, UNDO_POOL =&gt; 200);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'erp_plan', 
  GROUP_OR_SUBPLAN =&gt; 'batch', COMMENT =&gt; 'BATCH sessions', MGMT_P2 =&gt; 100, 
  ACTIVE_SESS_POOL_P1 =&gt; 5, QUEUEING_P1 =&gt; 600, MAX_EST_EXEC_TIME =&gt; 3600);
DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(PLAN =&gt; 'erp_plan', 
  GROUP_OR_SUBPLAN =&gt; 'OTHER_GROUPS', COMMENT =&gt; 'mandatory', MGMT_P3 =&gt; 100);
DBMS_RESOURCE_MANAGER.VALIDATE_PENDING_AREA();
DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="BABCIJDG"></a>
<div id="ADMIN13471" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Example of <a id="sthref2880"></a>Managing Parallel Statements Using Directive Attributes</h3>
<p>A typical data warehousing environment consists of different types of users with varying resource requirements. Users with common processing needs are grouped into a consumer group. The consumer group <code dir="ltr">URGENT_GROUP</code> consists of users who run reports that provide important information to top management. This group generates a large number of parallel queries. Users from the consumer group <code dir="ltr">ETL_GROUP</code> import data from source systems and perform extract, transform, and load (ETL) operations. The group <code dir="ltr">OTHER_GROUPS</code> contains users who execute ad-hoc queries. You must manage the requirements of these diverse groups of users while optimizing performance.</p>
<p>You can use the following directive <a id="sthref2881"></a><a id="sthref2882"></a>attributes to manage and optimize the execution of parallel statements:</p>
<ul>
<li>
<p><code dir="ltr">MGMT_P</code><span class="italic">n</span></p>
</li>
<li>
<p><code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code></p>
</li>
<li>
<p><code dir="ltr">PARALLEL_QUEUE_TIMEOUT</code></p>
</li>
<li>
<p><code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code></p>
</li>
</ul>
<p><a href="#BABBGHBA">Table 27-3</a> describes the resource allocations of the plan <code dir="ltr">DW_PLAN</code>, which can be used to manage the needs of the data warehouse users. This plan contains the consumer groups <code dir="ltr">URGENT_GROUP</code>, <code dir="ltr">ETL_GROUP</code>, and <code dir="ltr">OTHER_GROUPS</code>. This example demonstrates the use of directive attributes in ensuring that one application or consumer group does not use all the available parallel servers.</p>
<div id="ADMIN13472" class="tblformalwidemax">
<p class="titleintable"><a id="sthref2883"></a><a id="BABBGHBA"></a>Table 27-3 Resource Plan with Parallel Statement Directives</p>
<table class="cellalignment1333" title="Resource Plan with Parallel Statement Directives" summary="This table describes the reource allocations for the plan MY_PLAN." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t62">Consumer Group</th>
<th class="cellalignment1334" id="r1c2-t62">Level 1 CPU Allocation</th>
<th class="cellalignment1334" id="r1c3-t62">Level 2 CPU Allocation</th>
<th class="cellalignment1334" id="r1c4-t62">Level 3 CPU Allocation</th>
<th class="cellalignment1334" id="r1c5-t62">PARALLEL_DEGREE_LIMIT_P1</th>
<th class="cellalignment1334" id="r1c6-t62">PARALLEL_TARGET_PERCENTAGE</th>
<th class="cellalignment1334" id="r1c7-t62">PARALLEL_QUEUE_TIMEOUT</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t62" headers="r1c1-t62">
<p><code dir="ltr">URGENT_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t62 r1c2-t62">
<p>100%</p>
</td>
<td class="cellalignment1335" headers="r2c1-t62 r1c3-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t62 r1c4-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t62 r1c5-t62">
<p>12</p>
</td>
<td class="cellalignment1335" headers="r2c1-t62 r1c6-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r2c1-t62 r1c7-t62">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t62" headers="r1c1-t62">
<p><code dir="ltr">ETL_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t62 r1c2-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t62 r1c3-t62">
<p>100%</p>
</td>
<td class="cellalignment1335" headers="r3c1-t62 r1c4-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t62 r1c5-t62">
<p>8</p>
</td>
<td class="cellalignment1335" headers="r3c1-t62 r1c6-t62">
<p>50%</p>
</td>
<td class="cellalignment1335" headers="r3c1-t62 r1c7-t62">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t62" headers="r1c1-t62">
<p><code dir="ltr">OTHER_GROUPS</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t62 r1c2-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t62 r1c3-t62">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t62 r1c4-t62">
<p>100%</p>
</td>
<td class="cellalignment1335" headers="r4c1-t62 r1c5-t62">
<p>2</p>
</td>
<td class="cellalignment1335" headers="r4c1-t62 r1c6-t62">
<p>50%</p>
</td>
<td class="cellalignment1335" headers="r4c1-t62 r1c7-t62">
<p>360</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwidemax" -->
<p>In this example, the parameter <code dir="ltr">PARALLEL_SERVERS_TARGET</code> is set to 64, which means that the number of parallel servers available is 64. The total number of parallel servers that can be used for parallel statement execution before <code dir="ltr">URGENT_GROUP</code> sessions with <code dir="ltr">PARALLEL_DEGREE_POLICY</code> set to <code dir="ltr">AUTO</code> are added to the parallel statement queue is equal to 64. Because the <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> attribute of <code dir="ltr">ETL_GROUP</code> and <code dir="ltr">OTHER_GROUPS</code> is 50%, the maximum number of parallel servers that can be used by these groups is 50% of 64, or 32 parallel servers each.</p>
<p>Note that parallel statements from a consumer group will only be queued if the <code dir="ltr">PARALLEL_DEGREE_POLICY</code> parameter is set to <code dir="ltr">AUTO</code> and the total number of active servers for the consumer group is higher than <code dir="ltr">PARALLEL_SERVERS_TARGET</code>. If <code dir="ltr">PARALLEL_DEGREE_POLICY</code> is set to <code dir="ltr">MANUAL</code> or <code dir="ltr">LIMITED</code>, then the statements are run provided there are enough parallel servers available. The parallel servers used by such a statement will count toward the total number of parallel servers used by the consumer group. However, the parallel statement will not be added to the parallel statement queue.</p>
<div class="infoboxnotealso">
<p class="notep1">Tip:</p>
For low-priority applications, it is a common practice to set low values for <code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code> and <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code>.</div>
<p>Because <code dir="ltr">URGENT_GROUPS</code> has 100% of the allocation at level 1, its parallel statements will always be dequeued ahead of the other consumer groups from the parallel statement queue. Although <code dir="ltr">URGENT_GROUPS</code> has no <code dir="ltr">PARALLEL_TARGET_PERCENTAGE</code> directive attribute, a statement issued by a session in this group might still be queued if there are not enough available parallel servers to run it.</p>
<p>The degree of parallelism, represented by <code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code>, is set to 12 for <code dir="ltr">URGENT_GROUP</code>. Therefore, each parallel statement from <code dir="ltr">URGENT_GROUP</code> can use a maximum of 12 parallel servers. Similarly, each parallel statement from the <code dir="ltr">ETL_GROUP</code> can use a maximum of 8 parallel servers and each parallel statement from the <code dir="ltr">OTHER_GROUPS</code> can use 2 parallel servers.</p>
<p>Suppose, at a given time, the only parallel statements are from the <code dir="ltr">ETL_GROUP</code>, and they are using 26 out of the 32 parallel servers available to this group. Sessions from this consumer group have <code dir="ltr">PARALLEL_DEGREE_POLICY</code> set to <code dir="ltr">AUTO</code>. If another parallel statement with the <code dir="ltr">PARALLEL_DEGREE_LIMIT_P1</code> attribute set to 8 is launched from <code dir="ltr">ETL_GROUP</code>, then this query cannot be run immediately because the available parallel servers in the <code dir="ltr">ETL_GROUP</code> is 32-26=6 parallel servers. The new parallel statement is queued until the number of parallel servers it requires is available in <code dir="ltr">ETL_GROUP</code>.</p>
<p>While the parallel statements in <code dir="ltr">ETL_GROUP</code> are being executed, suppose a parallel statement is launched from <code dir="ltr">OTHER_GROUPS</code>. This group still has 32 parallel servers available and so the parallel statement is executed.</p>
<p>The <code dir="ltr">PARALLEL_QUEUE_TIMEOUT</code> attribute for <code dir="ltr">OTHER_GROUPS</code> is set to 360. Therefore, any parallel statement from this group can remain in the parallel server queue for 360 seconds only. After this time, the parallel statement is removed from the queue and the error <code dir="ltr">ORA-07454</code> is returned.</p>
</div>
<!-- class="sect2" -->
<a id="i1008675"></a>
<div id="ADMIN11893" class="sect2">
<h3 class="sect2">An Oracle-Supplied Mixed Workload Plan</h3>
<p>Oracle Database includes a predefined resource plan, <a id="sthref2884"></a><a id="sthref2885"></a><a id="sthref2886"></a><code dir="ltr">MIXED_WORKLOAD_PLAN</code>, that prioritizes interactive operations over batch operations, and includes the required subplans and consumer groups recommended by Oracle. <code dir="ltr">MIXED_WORKLOAD_PLAN</code> is defined as follows:</p>
<div class="inftblruleinformal">
<table class="cellalignment1333" title="Description of the MIXED WORKLOAD PLAN Resource Manager Plan" summary="Column 1 lists the resource consumer groups/subplans included in the plan; the next 3 columns specify the CPU resource allocations for level 1, level2, and level 3, respectively. The next column indicates automatic switching parameters, and the final column shows max degree of parallelism" dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t64" rowspan="2">Group or Subplan</th>
<th class="cellalignment1334" id="r1c2-t64" colspan="5">CPU Resource Allocation</th>
</tr>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r2c1-t64" headers="r1c1-t64 r1c1-t64">Level 1</th>
<th class="cellalignment1334" id="r2c2-t64" headers="r1c1-t64 r2c1-t64 r1c2-t64">Level 2</th>
<th class="cellalignment1334" id="r2c3-t64" headers="r1c1-t64 r2c1-t64 r1c2-t64">Level 3</th>
<th class="cellalignment1334" id="r2c4-t64" headers="r1c1-t64 r2c1-t64 r1c2-t64">Automatic Consumer Group Switching</th>
<th class="cellalignment1334" id="r2c5-t64" headers="r1c1-t64 r2c1-t64 r1c2-t64">Max Degree of Parallelism</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t64" headers="r1c1-t64 r2c1-t64"><code dir="ltr">BATCH_GROUP</code></td>
<td class="cellalignment1335" headers="r3c1-t64 r1c2-t64 r2c2-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t64 r1c2-t64 r2c3-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t64 r1c2-t64 r2c4-t64">100%</td>
<td class="cellalignment1335" headers="r3c1-t64 r1c2-t64 r2c5-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r3c1-t64 r1c2-t64">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t64" headers="r1c1-t64 r2c1-t64"><code dir="ltr">INTERACTIVE_GROUP</code></td>
<td class="cellalignment1335" headers="r4c1-t64 r1c2-t64 r2c2-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t64 r1c2-t64 r2c3-t64">85%</td>
<td class="cellalignment1335" headers="r4c1-t64 r1c2-t64 r2c4-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r4c1-t64 r1c2-t64 r2c5-t64">Switch to group: <code dir="ltr">BATCH_GROUP</code>
<p>Switch time: 60 seconds</p>
<p>Switch for call: <code dir="ltr">TRUE</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t64 r1c2-t64">1</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t64" headers="r1c1-t64 r2c1-t64"><code dir="ltr">ORA$AUTOTASK_SUB_PLAN</code></td>
<td class="cellalignment1335" headers="r5c1-t64 r1c2-t64 r2c2-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t64 r1c2-t64 r2c3-t64">5%</td>
<td class="cellalignment1335" headers="r5c1-t64 r1c2-t64 r2c4-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t64 r1c2-t64 r2c5-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r5c1-t64 r1c2-t64">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t64" headers="r1c1-t64 r2c1-t64"><code dir="ltr">ORA$DIAGNOSTICS</code></td>
<td class="cellalignment1335" headers="r6c1-t64 r1c2-t64 r2c2-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r6c1-t64 r1c2-t64 r2c3-t64">5%</td>
<td class="cellalignment1335" headers="r6c1-t64 r1c2-t64 r2c4-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r6c1-t64 r1c2-t64 r2c5-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r6c1-t64 r1c2-t64">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t64" headers="r1c1-t64 r2c1-t64"><code dir="ltr">OTHER_GROUPS</code><a id="sthref2887"></a><a id="sthref2888"></a></td>
<td class="cellalignment1335" headers="r7c1-t64 r1c2-t64 r2c2-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r7c1-t64 r1c2-t64 r2c3-t64">5%</td>
<td class="cellalignment1335" headers="r7c1-t64 r1c2-t64 r2c4-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r7c1-t64 r1c2-t64 r2c5-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r7c1-t64 r1c2-t64">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t64" headers="r1c1-t64 r2c1-t64"><code dir="ltr">SYS_GROUP</code><a id="sthref2889"></a><a id="sthref2890"></a></td>
<td class="cellalignment1335" headers="r8c1-t64 r1c2-t64 r2c2-t64">100%</td>
<td class="cellalignment1335" headers="r8c1-t64 r1c2-t64 r2c3-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r8c1-t64 r1c2-t64 r2c4-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r8c1-t64 r1c2-t64 r2c5-t64">&nbsp;</td>
<td class="cellalignment1335" headers="r8c1-t64 r1c2-t64">&nbsp;</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<p>In this plan, because <code dir="ltr">INTERACTIVE_GROUP</code> is intended for short transactions, any call that consumes more than 60 seconds of CPU time is automatically switched to <code dir="ltr">BATCH_GROUP</code>, which is intended for longer batch operations.</p>
<p>You can use this predefined plan if it is appropriate for your environment. (You can modify the plan, or delete it if you do not intend to use it.) Note that there is nothing special about the names <code dir="ltr">BATCH_GROUP</code> and <code dir="ltr">INTERACTIVE_GROUP</code>. The names reflect only the intended purposes of the groups, and it is up to you to map application sessions to these groups and adjust CPU resource allocation percentages accordingly so that you achieve proper resource management for your interactive and batch applications. For example, to ensure that your interactive applications run under the <code dir="ltr">INTERACTIVE_GROUP</code> consumer group, you must map your interactive applications' user sessions to this consumer group based on user name, service name, program name, module name, or action, as described in <a href="#CHDIGIII">"Specifying Session-to&ndash;Consumer Group Mapping Rules"</a>. You must map your batch applications to the <code dir="ltr">BATCH_GROUP</code> in the same way. Finally, you must enable this plan as described in <a href="#i1008488">"Enabling Oracle Database Resource Manager and Switching Plans"</a>.</p>
<p>See <a href="#CHDBEJJB">Table 27-4</a> and <a href="#CHDJAJHE">Table 27-5</a> for explanations of the other resource consumer groups and subplans in this plan.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CFHJGBFC"></a>
<div id="ADMIN13332" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Managing Multiple Database Instances on a Single Server</h2>
<p>Oracle Database provides a method for managing CPU allocations on a multi-CPU server running multiple database instances. This method is called instance caging. Instance caging and Oracle Database Resource Manager (the Resource Manager) work together to support desired levels of service across multiple instances.</p>
<p>This section contains:</p>
<ul>
<li>
<p><a href="#CFHBDFAG">About Instance Caging</a></p>
</li>
<li>
<p><a href="#CFHGBGFE">Enabling Instance Caging</a></p>
</li>
</ul>
<a id="CFHBDFAG"></a>
<div id="ADMIN13333" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">About Instance Caging</h3>
<p><a id="sthref2891"></a><a id="sthref2892"></a><a id="sthref2893"></a>You might decide to run multiple Oracle database instances on a single multi-CPU server. A typical reason to do so would be server consolidation&mdash;using available hardware resources more efficiently. When running multiple instances on a single server, the instances compete for CPU. One resource-intensive database instance could significantly degrade the performance of the other instances. For example, on a 16-CPU system with four database instances, the operating system might be running one database instance on the majority of the CPUs during a period of heavy load for that instance. This could degrade performance in the other three instances. CPU allocation decisions such as this are made solely by the operating system; the user generally has no control over them.</p>
<p>A simple way to limit CPU consumption for each database instance is to use instance caging. <span class="bold">Instance caging</span> is a method that uses an initialization parameter to limit the number of CPUs that an instance can use simultaneously. In the previous example, if you use instance caging to limit the number of CPUs to four for each of the four instances, there is less likelihood that one instance can interfere with the others. When constrained to four CPUs, an instance might become CPU-bound. This is when the Resource Manager begins to do its work to allocate CPU among the various database sessions according to the resource plan that you set for the instance. Thus, instance caging and the Resource Manager together provide a simple, effective way to manage multiple instances on a single server.</p>
<p>There are two typical approaches to instance caging for a server:</p>
<ul>
<li>
<p>Over-provisioning&mdash;You would use this approach for non-critical databases such as development and test systems, or low-load non-critical production systems. In this approach, the sum of the CPU limits for each instance exceeds the actual number of CPUs on the system. For example, on a 4-CPU system with four database instances, you might limit each instance to three CPUs. When a server is over-provisioned in this way, the instances can impact each other's performance. However, instance caging limits the impact and helps provide somewhat predictable performance. However, if one of the instances has a period of high load, the CPUs are available to handle it. This is a reasonable approach for non-critical systems, because one or more of the instances may frequently be idle or at a very low load.</p>
</li>
<li>
<p>Partitioning&mdash;This approach is for critical production systems, where you want to prevent instances from interfering with each other. You allocate CPUs such that the sum of all allocations is equal to the number of CPUs on the server. For example, on a 16-server system, you might allocate 8 CPUs to the first instance, 4 CPUs to the second, and 2 each to the remaining two instances. By dedicating CPU resources to each database instance, the load on one instance cannot affect another's, and each instance performs predictably.</p>
</li>
</ul>
<p class="subhead2"><a id="ADMIN13473"></a>Using Instance Caging with Maximum Utilization Limit</p>
<p>If you <a id="sthref2894"></a>enable instance caging and set a maximum utilization limit in your resource plan, then the absolute limit is computed as a percentage of the allocated CPU resources.</p>
<p>For example, if you enable instance caging and set the <code dir="ltr">CPU_COUNT</code> to 4, and a consumer group has a maximum utilization limit of 50%, then the consumer group can use a maximum of 50% of 4 CPUs, which is 2 CPUs.</p>
</div>
<!-- class="sect2" -->
<a id="CFHGBGFE"></a>
<div id="ADMIN13334" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Enabling Instance Caging</h3>
<p>To enable instance caging, do the following for each instance on the server:</p>
<ol>
<li>
<p>Enable the Resource Manager by assigning a resource plan, and ensure that the resource plan has CPU directives, using the <code dir="ltr">MGMT_P1</code> through <code dir="ltr">MGMT_P8</code> parameters.</p>
<p>See <a href="#i1008488">"Enabling Oracle Database Resource Manager and Switching Plans"</a> for instructions.</p>
</li>
<li>
<p>Set the <code dir="ltr">cpu_count</code> initialization parameter.</p>
<p>This is a dynamic parameter, and can be set with the following statement:</p>
<pre dir="ltr">
ALTER SYSTEM SET CPU_COUNT = 4;
</pre></li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDJEGIG"></a>
<div id="ADMIN12498" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Maintaining Consumer Groups, Plans, and Directives</h2>
<p>This section provides instructions for maintaining consumer groups, resource plans, and resource plan directives for Oracle Database Resource Manager (the Resource Manager). You perform maintenance tasks using the <code dir="ltr">DBMS_RESOURCE_MANAGER</code> PL/SQL package. The following topics are covered:</p>
<ul>
<li>
<p><a href="#CHDDDCCF">Updating a Consumer Group</a></p>
</li>
<li>
<p><a href="#CHDHIACE">Deleting a Consumer Group</a></p>
</li>
<li>
<p><a href="#CHDGIGJF">Updating a Plan</a></p>
</li>
<li>
<p><a href="#CHDBHJHF">Deleting a Plan</a></p>
</li>
<li>
<p><a href="#CHDEAIGB">Updating a Resource Plan Directive</a></p>
</li>
<li>
<p><a href="#CHDJHCAC">Deleting a Resource Plan Directive</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#CHDEFDCH">Predefined Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a class="olink ARPLS050" href="../../appdev.112/e40758/d_resmgr.htm#ARPLS050"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details on the <code dir="ltr">DBMS_RESOURCE_MANAGER</code> PL/SQL package.</p>
</li>
</ul>
</div>
<a id="CHDDDCCF"></a>
<div id="ADMIN11897" class="sect2">
<h3 class="sect2">Updating a Consumer Group<a id="sthref2895"></a></h3>
<p>You use the <code dir="ltr">UPDATE_CONSUMER_GROUP</code> procedure to update consumer group information. The pending area must be created first, and then submitted after the consumer group is updated. If you do not specify the arguments for the <code dir="ltr">UPDATE_CONSUMER_GROUP</code> procedure, then they remain unchanged in the data dictionary.</p>
</div>
<!-- class="sect2" -->
<a id="CHDHIACE"></a>
<div id="ADMIN11898" class="sect2">
<h3 class="sect2">Deleting a Consumer Group<a id="sthref2896"></a></h3>
<p>The <code dir="ltr">DELETE_CONSUMER_GROUP</code> procedure deletes the specified consumer group. The pending area must be created first, and then submitted after the consumer group is deleted. Upon deletion of a consumer group, all users having the deleted group as their initial consumer group are assigned the <code dir="ltr">OTHER_GROUPS</code><a id="sthref2897"></a><a id="sthref2898"></a> as their initial consumer group. All currently running sessions belonging to a deleted consumer group are assigned to a new consumer group, based on the consumer group mapping rules. If no consumer group is found for a session through mapping, the session is switched to the <code dir="ltr">OTHER_GROUPS</code>.</p>
<p>You cannot delete a consumer group if it is referenced by a resource plan directive.</p>
</div>
<!-- class="sect2" -->
<a id="CHDGIGJF"></a>
<div id="ADMIN11895" class="sect2">
<h3 class="sect2">Updating a Plan<a id="sthref2899"></a></h3>
<p>You use the <code dir="ltr">UPDATE_PLAN</code> procedure to update plan information. The pending area must be created first, and then submitted after the plan is updated. If you do not specify the arguments for the <code dir="ltr">UPDATE_PLAN</code> procedure, they remain unchanged in the data dictionary. The following PL/SQL block updates the <code dir="ltr">COMMENT</code> parameter.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.UPDATE_PLAN(
   PLAN =&gt; 'DAYTIME',
   NEW_COMMENT =&gt; '50% more resources for OLTP applications');
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="CHDBHJHF"></a>
<div id="ADMIN11896" class="sect2">
<h3 class="sect2">Deleting a Plan<a id="sthref2900"></a></h3>
<p>The <code dir="ltr">DELETE_PLAN</code> procedure deletes the specified plan as well as all the plan directives associated with it. The pending area must be created first, and then submitted after the plan is deleted.</p>
<p>The following PL/SQL block deletes the <code dir="ltr">great_bread</code> plan and its directives.</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.DELETE_PLAN(PLAN =&gt; 'great_bread');
END;
/
</pre>
<p>The resource consumer groups referenced by the deleted directives are not deleted, but they are no longer associated with the <code dir="ltr">great_bread</code> plan.</p>
<p>The <a id="sthref2901"></a><code dir="ltr">DELETE_PLAN_CASCADE</code> procedure deletes the specified plan as well as all its descendants: plan directives and those subplans and resource consumer groups that are not marked by the database as mandatory. If <code dir="ltr">DELETE_PLAN_CASCADE</code> encounters an error, then it rolls back, leaving the plan<a id="sthref2902"></a><a id="sthref2903"></a> unchanged.</p>
<p>You cannot delete the currently active plan.</p>
</div>
<!-- class="sect2" -->
<a id="CHDEAIGB"></a>
<div id="ADMIN11899" class="sect2">
<h3 class="sect2">Updating a Resource Plan Directive<a id="sthref2904"></a></h3>
<p>Use the <code dir="ltr">UPDATE_PLAN_DIRECTIVE</code> procedure to update plan directives. The pending area must be created first, and then submitted after the resource plan directive is updated. If you do not specify an argument for the <code dir="ltr">UPDATE_PLAN_DIRECTIVE</code> procedure, then its corresponding parameter in the directive remains unchanged.</p>
<p>The following example adds a comment to a directive:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CLEAR_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.UPDATE_PLAN_DIRECTIVE(
         PLAN             =&gt; 'SIMPLE_PLAN1',
         GROUP_OR_SUBPLAN =&gt; 'MYGROUP1',
         NEW_COMMENT      =&gt; 'Higher priority'
        );
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre>
<p>To clear (nullify) a comment, pass a null string (<code dir="ltr">''</code>). To clear (zero or nullify) any numeric directive parameter, set its new value to -1:</p>
<pre dir="ltr">
BEGIN
  DBMS_RESOURCE_MANAGER.CLEAR_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
  DBMS_RESOURCE_MANAGER.UPDATE_PLAN_DIRECTIVE(
         PLAN                  =&gt; 'SIMPLE_PLAN1',
         GROUP_OR_SUBPLAN      =&gt; 'MYGROUP1',
         NEW_MAX_EST_EXEC_TIME =&gt; -1
        );
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/
</pre></div>
<!-- class="sect2" -->
<a id="CHDJHCAC"></a>
<div id="ADMIN11900" class="sect2">
<h3 class="sect2">Deleting a Resource Plan Directive<a id="sthref2905"></a></h3>
<p>To delete a resource plan directive, use the <code dir="ltr">DELETE_PLAN_DIRECTIVE</code> procedure. The pending area must be created first, and then submitted after the resource plan directive is deleted.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDDAFAJ"></a>
<div id="ADMIN11901" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Viewing Database Resource Manager Configuration and Status</h2>
<p>You can use several static data dictionary views and dynamic performance views to view the current configuration and status of Oracle Database Resource Manager (the Resource Manager). This section provides the following examples:</p>
<ul>
<li>
<p><a href="#CHDFJICH">Viewing Consumer Groups Granted to Users or Roles</a></p>
</li>
<li>
<p><a href="#CHDGBIBE">Viewing Plan Information</a></p>
</li>
<li>
<p><a href="#CHDIBIAF">Viewing Current Consumer Groups for Sessions</a></p>
</li>
<li>
<p><a href="#CHDCJEDI">Viewing the Currently Active Plans</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for details on all static data dictionary views and dynamic performance views</div>
<a id="CHDFJICH"></a>
<div id="ADMIN11902" class="sect2">
<h3 class="sect2">Viewing Consumer Groups Granted to Users or Roles</h3>
<p>The <code dir="ltr">DBA_RSRC_CONSUMER_GROUP_PRIVS</code> view displays the consumer groups granted to users or roles. Specifically, it displays the groups to which a user or role is allowed to belong or be switched. For example, in the view shown below, user <code dir="ltr">SCOTT</code> always starts in the <code dir="ltr">SALES</code> consumer group, can switch to the <code dir="ltr">MARKETING</code> group through a specific grant, and can switch to the <code dir="ltr">DEFAULT_CONSUMER_GROUP</code> (<code dir="ltr">OTHER_GROUPS</code>) and <code dir="ltr">LOW_GROUP</code> groups because they are granted to <code dir="ltr">PUBLIC</code>. <code dir="ltr">SCOTT</code> also can grant the <code dir="ltr">SALES</code> group but not the <code dir="ltr">MARKETING</code> group to other users.</p>
<pre dir="ltr">
SELECT * FROM dba_rsrc_consumer_group_privs;

GRANTEE            GRANTED_GROUP                  GRANT_OPTION INITIAL_GROUP
------------------ ------------------------------ ------------ -------------
PUBLIC             DEFAULT_CONSUMER_GROUP         YES          YES
PUBLIC             LOW_GROUP                      NO           NO
SCOTT              MARKETING                      NO           NO
SCOTT              SALES                          YES          YES
SYSTEM             SYS_GROUP                      NO           YES
</pre>
<p><code dir="ltr">SCOTT</code> was granted the ability to switch to these groups using the <code dir="ltr">DBMS_RESOURCE_MANAGER_PRIVS</code> package.</p>
</div>
<!-- class="sect2" -->
<a id="CHDGBIBE"></a>
<div id="ADMIN11903" class="sect2">
<h3 class="sect2">Viewing Plan Information</h3>
<p>This example uses the <code dir="ltr">DBA_RSRC_PLANS</code> view to display all of the resource plans defined in the database. All plans have a <code dir="ltr">NULL</code> status, meaning that they are not in the pending area.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Plans in the pending area have a status of <code dir="ltr">PENDING</code>. Plans in the pending area are being edited.</div>
<pre dir="ltr">
SELECT plan,status,comments FROM dba_rsrc_plans;

PLAN                        STATUS   COMMENTS
--------------------------- -------- ----------------------------------------
DSS_PLAN                             Example plan for DSS workloads that prio...
ETL_CRITICAL_PLAN                    Example plan for DSS workloads that prio...
MIXED_WORKLOAD_PLAN                  Example plan for a mixed workload that p...
ORA$AUTOTASK_SUB_PLAN                Default sub-plan for automated maintenan...
DEFAULT_MAINTENANCE_PLAN             Default plan for maintenance windows tha...
DEFAULT_PLAN                         Default, basic, pre-defined plan that pr...
INTERNAL_QUIESCE                     Plan for quiescing the database.  This p...
INTERNAL_PLAN                        Internally-used plan for disabling the r...
ORA$AUTOTASK_HIGH_SUB_PLAN           Default sub-plan for high-priority, auto...
</pre></div>
<!-- class="sect2" -->
<a id="CHDIBIAF"></a>
<div id="ADMIN11904" class="sect2">
<h3 class="sect2">Viewing Current Consumer Groups for Sessions</h3>
<p>You can use the <code dir="ltr">V$SESSION</code> view to display the consumer groups that are currently assigned to sessions.</p>
<pre dir="ltr">
SELECT sid,serial#,username,resource_consumer_group FROM v$session;

SID    SERIAL#  USERNAME                  RESOURCE_CONSUMER_GROUP
-----  -------  ------------------------  --------------------------------
   11       136 SYS                       SYS_GROUP
   13     16570 SCOTT                     SALES
   ...
</pre></div>
<!-- class="sect2" -->
<a id="CHDCJEDI"></a>
<div id="ADMIN11905" class="sect2">
<h3 class="sect2">Viewing the Currently Active Plans</h3>
<p>This example sets <code dir="ltr">mydb_plan</code>, as created by the example shown earlier in <a href="#i1008520">"Multilevel Plan Example"</a>, as the top level plan. It then queries the <code dir="ltr">V$RSRC_PLAN</code> view to display the currently active plans. The view displays the current top level plan and all of its descendent subplans.</p>
<pre dir="ltr">
ALTER SYSTEM SET RESOURCE_MANAGER_PLAN = mydb_plan;

System altered.

SELECT name, is_top_plan FROM v$rsrc_plan;

NAME             IS_TOP_PLAN
----------------------------
MYDB_PLAN        TRUE
MAILDB_PLAN      FALSE
BUGDB_PLAN       FALSE
</pre></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1008730"></a>
<div id="ADMIN11906" class="sect1">
<h2 class="sect1">Monitoring Oracle Database Resource Manager</h2>
<p>Use the following dynamic performance views to help you monitor the results of your Oracle Database Resource Manager settings:</p>
<ul>
<li>
<p><a href="#CHDJIIHI">V$RSRC_PLAN</a></p>
</li>
<li>
<p><a href="#CHDCJCGB">V$RSRC_CONSUMER_GROUP</a></p>
</li>
<li>
<p><a href="#CHDEFABB">V$RSRC_SESSION_INFO</a></p>
</li>
<li>
<p><a href="#CHDBCICB">V$RSRC_PLAN_HISTORY</a></p>
</li>
<li>
<p><a href="#CHDEGIIA">V$RSRC_CONS_GROUP_HISTORY</a></p>
</li>
<li>
<p><a href="#BABFDBFA">V$RSRCMGRMETRIC</a></p>
</li>
<li>
<p><a href="#BABFEDEI">V$RSRCMGRMETRIC_HISTORY</a></p>
</li>
</ul>
<p>These views provide:</p>
<ul>
<li>
<p>Current status information</p>
</li>
<li>
<p>History of resource plan activations</p>
</li>
<li>
<p>Current and historical statistics on resource consumption and CPU waits by both resource consumer group and session</p>
</li>
</ul>
<p>In addition, historical statistics are available through the <code dir="ltr">DBA_HIST_RSRC_PLAN</code> and <code dir="ltr">DBA_HIST_RSRC_CONSUMER_GROUP</code> views, which contain Automatic Workload Repository (AWR) snapshots of the <code dir="ltr">V$RSRC_PLAN_HISTORY</code> and <code dir="ltr">V$RSRC_CONS_GROUP_HISTORY</code>, respectively.</p>
<p>For assistance with tuning, the views <code dir="ltr">V$RSRCMGRMETRIC</code> and <code dir="ltr">V$RSRCMGRMETRIC_HISTORY</code> show how much time was spent waiting for CPU and how much CPU was consumed per minute for every consumer group for the past hour. These metrics can be viewed graphically with Enterprise Manager, on the Resource Manager Statistics page.</p>
<p><a id="CHDJIIHI"></a><a id="ADMIN12663"></a><span class="subhead3">V$RSRC_PLAN&nbsp;</span>This view displays the currently active resource plan and its subplans.</p>
<pre dir="ltr">
SELECT name, is_top_plan FROM v$rsrc_plan;
 
NAME                             IS_TOP_PLAN
-------------------------------- -----------
DEFAULT_PLAN                     TRUE
ORA$AUTOTASK_SUB_PLAN            FALSE
ORA$AUTOTASK_HIGH_SUB_PLAN       FALSE
</pre>
<p>The plan for which <code dir="ltr">IS_TOP_PLAN</code> is <code dir="ltr">TRUE</code> is the currently active (top) plan, and the other plans are subplans of either the top plan or of other subplans in the list.</p>
<p>This view also contains other information, including the following:</p>
<ul>
<li>
<p>The <code dir="ltr">INSTANCE_CAGING</code> column shows whether instance caging is enabled.</p>
</li>
<li>
<p>The <code dir="ltr">CPU_MANAGED</code> column shows whether CPU is being managed.</p>
</li>
<li>
<p>The <code dir="ltr">PARALLEL_EXECUTION_MANAGED</code> column shows whether parallel statement queuing is enabled.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30216" href="../../server.112/e40402/dynviews_2159.htm#REFRN30216"><span class="italic">Oracle Database Reference</span></a></div>
<p><a id="CHDCJCGB"></a><a id="ADMIN12664"></a><span class="subhead3">V$RSRC_CONSUMER_GROUP&nbsp;</span>Use the <code dir="ltr">V$RSRC_CONSUMER_GROUP</code> view to monitor resources consumed, including CPU, I/O, and parallel servers. It can also be used to monitor statistics related to CPU resource management, runaway query management, parallel statement queuing, and so on. All of the statistics are cumulative from the time when the plan was activated.</p>
<pre dir="ltr">
SELECT name, active_sessions, queue_length,
  consumed_cpu_time, cpu_waits, cpu_wait_time
  FROM v$rsrc_consumer_group;

NAME               ACTIVE_SESSIONS QUEUE_LENGTH CONSUMED_CPU_TIME  CPU_WAITS CPU_WAIT_TIME
------------------ --------------- ------------ ----------------- ---------- -------------
OLTP_ORDER_ENTRY                 1            0             29690        467          6709
OTHER_GROUPS                     0            0           5982366       4089         60425
SYS_GROUP                        1            0           2420704        914         19540
DSS_QUERIES                      4            2           4594660       3004         55700
</pre>
<p>In the preceding query results, the <code dir="ltr">DSS_QUERIES</code> consumer group has four sessions in its active session pool and two more sessions queued for activation.</p>
<p>A key measure in this view is <code dir="ltr">CPU_WAIT_TIME</code>. This indicates the total time that sessions in the consumer group waited for CPU because of resource management. Not included in this measure are waits due to latch or enqueue contention, I/O waits, and so on.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30214" href="../../server.112/e40402/dynviews_2157.htm#REFRN30214"><span class="italic">Oracle Database Reference</span></a></div>
<p><a id="CHDEFABB"></a><a id="ADMIN12665"></a><span class="subhead3">V$RSRC_SESSION_INFO&nbsp;</span>Use this view to monitor the status of one or more sessions. The view shows how the session has been affected by the Resource Manager. It provides information such as:</p>
<ul>
<li>
<p>The consumer group that the session currently belongs to.</p>
</li>
<li>
<p>The consumer group that the session originally belonged to.</p>
</li>
<li>
<p>The session attribute that was used to map the session to the consumer group.</p>
</li>
<li>
<p>Session state (<code dir="ltr">RUNNING</code>, <code dir="ltr">WAIT_FOR_CPU</code>, <code dir="ltr">QUEUED</code>, and so on).</p>
</li>
<li>
<p>Current and cumulative statistics for metrics, such as CPU consumed, wait times, and queued time. Current statistics reflect statistics for the session since it joined its current consumer group. Cumulative statistics reflect statistics for the session in all consumer groups to which it has belonged since it was created.</p>
</li>
</ul>
<pre dir="ltr">
SELECT se.sid sess_id, co.name consumer_group, 
 se.state, se.consumed_cpu_time cpu_time, se.cpu_wait_time, se.queued_time
 FROM v$rsrc_session_info se, v$rsrc_consumer_group co
 WHERE se.current_consumer_group_id = co.id;

SESS_ID CONSUMER_GROUP     STATE     CPU_TIME CPU_WAIT_TIME QUEUED_TIME
------- ------------------ -------- --------- ------------- -----------
    113 OLTP_ORDER_ENTRY   WAITING     137947         28846           0
    135 OTHER_GROUPS       IDLE        785669         11126           0
    124 OTHER_GROUPS       WAITING      50401         14326           0
    114 SYS_GROUP          RUNNING        495             0           0
    102 SYS_GROUP          IDLE         88054            80           0
    147 DSS_QUERIES        WAITING     460910        512154           0
</pre>
<p><code dir="ltr">CPU_WAIT_TIME</code> in this view has the same meaning as in the <code dir="ltr">V$RSRC_CONSUMER_GROUP</code> view, but applied to an individual session.</p>
<p>You can join this view with the <code dir="ltr">V$SESSION</code> view for more information about a session.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30404" href="../../server.112/e40402/dynviews_2162.htm#REFRN30404"><span class="italic">Oracle Database Reference</span></a></div>
<p><a id="CHDBCICB"></a><a id="ADMIN12666"></a><span class="subhead3">V$RSRC_PLAN_HISTORY&nbsp;</span>This view shows when resource plans were enabled or disabled on the instance. Each resource plan activation or deactivation is assigned a sequence number. For each entry in the view, the <code dir="ltr">V$RSRC_CONS_GROUP_HISTORY</code> view has a corresponding entry for each consumer group in the plan that shows the cumulative statistics for the consumer group. The two views are joined by the <code dir="ltr">SEQUENCE#</code> column in each.</p>
<pre dir="ltr">
SELECT sequence# seq, name plan_name,
to_char(start_time, 'DD-MON-YY HH24:MM') start_time,
to_char(end_time, 'DD-MON-YY HH24:MM') end_time, window_name
FROM v$rsrc_plan_history;

 SEQ PLAN_NAME                  START_TIME      END_TIME        WINDOW_NAME
---- -------------------------- --------------- --------------- ----------------
   1                            29-MAY-07 23:05 29-MAY-07 23:05
   2 DEFAULT_MAINTENANCE_PLAN   29-MAY-07 23:05 30-MAY-07 02:05 TUESDAY_WINDOW
   3                            30-MAY-07 02:05 30-MAY-07 22:05
   4 DEFAULT_MAINTENANCE_PLAN   30-MAY-07 22:05 31-MAY-07 02:05 WEDNESDAY_WINDOW
   5                            31-MAY-07 02:05 31-MAY-07 22:05
   6 DEFAULT_MAINTENANCE_PLAN   31-MAY-07 22:05                 THURSDAY_WINDOW
</pre>
<p>A null value under <code dir="ltr">PLAN_NAME</code> indicates that no plan was active.</p>
<p>AWR snapshots of this view are stored in the <code dir="ltr">DBA_HIST_RSRC_PLAN</code> view.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30403" href="../../server.112/e40402/dynviews_2161.htm#REFRN30403"><span class="italic">Oracle Database Reference</span></a></div>
<p><a id="CHDEGIIA"></a><a id="ADMIN12667"></a><span class="subhead3">V$RSRC_CONS_GROUP_HISTORY&nbsp;</span>This view helps you understand how resources were shared among the consumer groups over time. The <code dir="ltr">sequence#</code> column corresponds to the column of the same name in the <code dir="ltr">V$RSRC_PLAN_HISTORY</code> view. Therefore, you can determine the plan that was active for each row of consumer group statistics.</p>
<pre dir="ltr">
SELECT sequence# seq, name, cpu_wait_time, cpu_waits,
consumed_cpu_time FROM v$rsrc_cons_group_history;
 
 SEQ NAME                      CPU_WAIT_TIME  CPU_WAITS CONSUMED_CPU_TIME
---- ------------------------- ------------- ---------- -----------------
   2 SYS_GROUP                         18133        691          33364431
   2 OTHER_GROUPS                      51252        825         181058333
   2 ORA$AUTOTASK_MEDIUM_GROUP            21          5           4019709
   2 ORA$AUTOTASK_URGENT_GROUP            35          1            198760
   2 ORA$AUTOTASK_STATS_GROUP              0          0                 0
   2 ORA$AUTOTASK_SPACE_GROUP              0          0                 0
   2 ORA$AUTOTASK_SQL_GROUP                0          0                 0
   2 ORA$AUTOTASK_HEALTH_GROUP             0          0                 0
   2 ORA$DIAGNOSTICS                       0          0           1072678
   4 SYS_GROUP                         40344         85          42519265
   4 OTHER_GROUPS                     123295       1040         371481422
   4 ORA$AUTOTASK_MEDIUM_GROUP             1          4           7433002
   4 ORA$AUTOTASK_URGENT_GROUP         22959        158          19964703
   4 ORA$AUTOTASK_STATS_GROUP              0          0                 0
      .
      .
   6 ORA$DIAGNOSTICS                       0          0                 0
</pre>
<p>AWR snapshots of this view are stored in the <code dir="ltr">DBA_HIST_RSRC_CONSUMER_GROUP</code> view. Use <code dir="ltr">DBA_HIST_RSRC_CONSUMER_GROUP</code> with <code dir="ltr">DBA_HIST_RSRC_PLAN</code> to determine the plan that was active for each historical set of consumer group statistics.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN30402" href="../../server.112/e40402/dynviews_2156.htm#REFRN30402"><span class="italic">Oracle Database Reference</span></a></p>
</li>
<li>
<p><a class="olink PFGRF027" href="../../server.112/e41573/autostat.htm#PFGRF027"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about the AWR.</p>
</li>
</ul>
</div>
<p><a id="BABFDBFA"></a><a id="ADMIN13474"></a><span class="subhead3">V$RSRCMGRMETRIC&nbsp;</span>This view enables you to track CPU metrics in milliseconds, in terms of number of sessions, or in terms of utilization for the past one minute. It provides real-time metrics for each consumer group and is very useful in scenarios where you are running workloads and want to continuously monitor CPU resource utilization.</p>
<p>Use this view to compare the maximum possible CPU utilization and average CPU utilization percentage for consumer groups with other consumer group settings such as CPU time used, time waiting for CPU, average number of sessions that are consuming CPU, and number of sessions that are waiting for CPU allocation. For example, you can view the amount of CPU resources a consumer group used and how long it waited for resource allocation. Or, you can view how many sessions from each consumer group are executed against the total number of active sessions.</p>
<p>To track CPU consumption in terms of CPU utilization, use the <code dir="ltr">CPU_UTILIZATION_LIMIT</code> and <code dir="ltr">AVG_CPU_UTILIZATION</code> columns. <code dir="ltr">AVG_CPU_UTILIZATION</code> lists the average percentage of the server's CPU that is consumed by a consumer group. <code dir="ltr">CPU_UTILIZATION_LIMIT</code> represents the maximum percentage of the server's CPU that a consumer group can use. This limit is set using the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> directive attribute.</p>
<pre dir="ltr">
SELECT consumer_group_name, cpu_utilization_limit,
avg_cpu_utilization FROM v$rsrcmgrmetric;
</pre>
<p>Use the <code dir="ltr">CPU_CONSUMED_TIME</code> and <code dir="ltr">CPU_TIME_WAIT</code> columns to track CPU consumption and throttling in milliseconds. The column <code dir="ltr">NUM_CPUS</code> represents the number of CPUs that Resource Manager is managing.</p>
<pre dir="ltr">
SELECT consumer_group_name, cpu_consumed_time,
cpu_wait_time, num_cpus FROM v$rsrcmgrmetric;
</pre>
<p>To track the CPU consumption and throttling in terms of number of sessions, use the <code dir="ltr">RUNNING_SESSIONS_LIMIT</code>, <code dir="ltr">AVG_RUNNING_SESSIONS</code>, and <code dir="ltr">AVG_WAITING_SESSIONS</code> columns. <code dir="ltr">RUNNING_SESSIONS_LIMIT</code> lists the maximum number of sessions, from a particular consumer group, that can be running at any time. This limit is defined by the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> directive attribute that you set either for the consumer group or for a subplan that contains the consumer group. For each consumer group, <code dir="ltr">AVG_RUNNING_SESSIONS</code> lists the average number of sessions that are consuming CPU and <code dir="ltr">AVG_WAITING_SESSIONS</code> lists the average number of sessions that are waiting for CPU.</p>
<pre dir="ltr">
SELECT sequence#, consumer_group_name, running_sessions_limit,
avg_running_sessions, avg_waiting_sessions FROM v$rsrcmgrmetric;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30482" href="../../server.112/e40402/dynviews_2163.htm#REFRN30482"><span class="italic">Oracle Database Reference</span></a></div>
<p class="subhead2"><a id="BABFEDEI"></a><a id="ADMIN13475"></a>V$RSRCMGRMETRIC_HISTORY</p>
<p>The columns in the <code dir="ltr">V$RSRCMGRMETRIC_HISTORY</code> are the same view as <a href="#BABFDBFA">V$RSRCMGRMETRIC</a>. The only difference between these views is that <a href="#BABFDBFA">V$RSRCMGRMETRIC</a> contains metrics for the past one minute only, whereas V$<code dir="ltr">RSRCMGRMETRIC_HISTORY</code> contains metrics for the last 60 minutes.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN30483" href="../../server.112/e40402/dynviews_2164.htm#REFRN30483"><span class="italic">Oracle Database Reference</span></a></div>
</div>
<!-- class="sect1" -->
<a id="i1010600"></a>
<div id="ADMIN11910" class="sect1">
<h2 class="sect1">Interacting with Operating-System Resource <a id="sthref2906"></a>Control</h2>
<p>Many operating systems provide tools for resource management. These tools often contain "workload manager" or "resource manager" in their names, and are intended to allow multiple applications to share the resources of a single server, using an administrator-defined policy. Examples are Hewlett Packard's Process Resource Manager or Solaris Containers, Zones, and Resource Pools.</p>
<div id="ADMIN11911" class="sect2"><a id="sthref2907"></a>
<h3 class="sect2">Guidelines for Using Operating-System Resource Control</h3>
<p>If you choose to use operating-system resource control with Oracle Database, then you must use it judiciously, according to the following guidelines:</p>
<ul>
<li>
<p>If you have multiple instances on a node, and you want to distribute resources among them, then each instance should be assigned to a dedicated operating-system resource manager group or managed entity. To run multiple instances in the managed entity, use instance caging to manage how the CPU resources within the managed entity should be distributed among the instances. When Oracle Database Resource Manager is managing CPU resources, it expects a fixed amount of CPU resources for the instance. Without instance caging, it expects the available CPU resources to be equal to the number of CPUs in the managed entity. With instance caging, it expects the available CPU resources to be equal to the value of the <code dir="ltr">CPU_COUNT</code> initialization parameter. If there are less CPU resources than expected, then the Oracle Database Resource Manager is not as effective at enforcing the resource allocations in the resource plan. See <a href="#CFHJGBFC">"Managing Multiple Database Instances on a Single Server"</a> for information about instance caging.</p>
</li>
<li>
<p>The dedicated entity running all the instance's processes must run at one priority (or resource consumption) level.</p>
</li>
<li>
<p>The CPU resources assigned to the dedicated entity cannot be changed more frequently than once every few minutes.</p>
<p>If the operating-system resource manager is rapidly changing the CPU resources allocated to an Oracle instance, then the Oracle Database Resource Manager might not manage CPU resources effectively. In particular, if the CPU resources allocated to the Oracle instance changes more frequently than every couple of minutes, then these changes might not be observed by Oracle because it only checks for such changes every couple of minutes. In these cases, Oracle Database Resource Manager can over-schedule processes if it concludes that more CPU resources are available than there actually are, and it can under-schedule processes if it concludes that less CPU resources are available than there actually are. If it over-schedules processes, then the <code dir="ltr">MAX_UTILIZATION_LIMIT</code> directives might be exceeded, and the CPU directives might not be accurately enforced. If it under-schedules processes, then the Oracle instance might not fully use the server's resources.</p>
</li>
<li>
<p>Process priority management must not be enabled.</p>
</li>
<li>
<p>Management of individual database processes at different priority levels (for example, using the <code dir="ltr">nice</code> command on UNIX platforms) is not supported. Severe consequences, including instance crashes, can result. Similar undesirable results are possible if operating-system resource control is permitted to manage the memory to which an Oracle Database instance is pinned.</p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CHDFFJGJ"></a>
<div id="ADMIN11913" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Oracle Database Resource Manager Reference</h2>
<p>The following sections provide reference information for Oracle Database Resource Manager (the Resource Manager):</p>
<ul>
<li>
<p><a href="#CHDGBAIB">Predefined Resource Plans and Consumer Groups</a></p>
</li>
<li>
<p><a href="#CHDEFDCH">Predefined Consumer Group Mapping Rules</a></p>
</li>
<li>
<p><a href="#i1008772">Resource Manager Data Dictionary Views</a></p>
</li>
</ul>
<a id="CHDGBAIB"></a>
<div id="ADMIN11914" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Predefined Resource Plans and Consumer Groups</h3>
<p><a href="#CHDBEJJB">Table 27-4</a> lists the resource plans and <a href="#CHDJAJHE">Table 27-5</a> lists the resource consumer groups that are predefined in each Oracle database. You can verify these by querying the views <code dir="ltr">DBA_RSRC_PLANS</code> and <code dir="ltr">DBA_RSRC_CONSUMER_GROUPS</code>.</p>
<p>The following query displays the CPU allocations in the example plan <code dir="ltr">DSS_PLAN</code>:</p>
<pre dir="ltr">
SELECT group_or_subplan, mgmt_p1, mgmt_p2, mgmt_p3, mgmt_p4 
   FROM dba_rsrc_plan_directives WHERE plan = 'DSS_PLAN';
 
GROUP_OR_SUBPLAN                  MGMT_P1    MGMT_P2    MGMT_P3    MGMT_P4
------------------------------ ---------- ---------- ---------- ----------
SYS_GROUP                              75          0          0          0
DSS_CRITICAL_GROUP                      0         75          0          0
DSS_GROUP                               0          0         75          0
ETL_GROUP                               0          0          0         45
BATCH_GROUP                             0          0          0         45
ORA$DIAGNOSTICS                         0          5          0          0
ORA$AUTOTASK_SUB_PLAN                   0          5          0          0
OTHER_GROUPS                            0          0          0         10
</pre>
<div id="ADMIN13076" class="tblruleformalwide">
<p class="titleintable"><a id="sthref2908"></a><a id="CHDBEJJB"></a>Table 27-4 Predefined Resource Plans</p>
<table class="cellalignment1333" title="Predefined Resource Plans" summary="This table has two columns: Resource Plan and Description." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t75">Resource Plan</th>
<th class="cellalignment1334" id="r1c2-t75">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t75" headers="r1c1-t75">
<p><code dir="ltr">DEFAULT_MAINTENANCE_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t75 r1c2-t75">
<p>Default plan for maintenance windows. See <a href="tasks.htm#CIHFBCGH">"About Resource Allocations for Automated Maintenance Tasks"</a> for details of this plan. Because maintenance windows are regular Oracle Scheduler windows, you can change the resource plan associated with them, if desired. If you do change a maintenance window resource plan, ensure that you include the subplan <code dir="ltr">ORA$AUTOTASK_SUB_PLAN</code> and the consumer group <code dir="ltr">ORA$DIAGNOSTICS</code> in the new plan.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t75" headers="r1c1-t75">
<p><code dir="ltr">DEFAULT_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t75 r1c2-t75">
<p>Basic default plan that prioritizes <code dir="ltr">SYS_GROUP</code> operations and allocates minimal resources for automated maintenance and diagnostics operations.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t75" headers="r1c1-t75">
<p><code dir="ltr">DSS_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t75 r1c2-t75">
<p>Example plan for a data warehouse that prioritizes critical DSS queries over non-critical DSS queries and ETL operations.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t75" headers="r1c1-t75">
<p><code dir="ltr">ETL_CRITICAL_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t75 r1c2-t75">
<p>Example plan for a data warehouse that prioritizes ETL operations over DSS queries.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t75" headers="r1c1-t75">
<p><code dir="ltr">INTERNAL_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t75 r1c2-t75">
<p>For disabling the resource manager. For internal use only.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t75" headers="r1c1-t75">
<p><code dir="ltr">INTERNAL_QUIESCE</code></p>
</td>
<td class="cellalignment1335" headers="r7c1-t75 r1c2-t75">
<p>For quiescing the database. This plan cannot be activated directly. To activate, use the <code dir="ltr">QUIESCE</code> command.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t75" headers="r1c1-t75">
<p><code dir="ltr">MIXED_WORKLOAD_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r8c1-t75 r1c2-t75">
<p>Example plan for a mixed workload that prioritizes interactive operations over batch operations. See <a href="#i1008675">"An Oracle-Supplied Mixed Workload Plan"</a> for details.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwide" -->
<div id="ADMIN13077" class="tblruleformalwide">
<p class="titleintable"><a id="sthref2909"></a><a id="CHDJAJHE"></a>Table 27-5 Predefined Resource Consumer Groups</p>
<table class="cellalignment1333" title="Predefined Resource Consumer Groups" summary="This table has two columns: Resource Consumer Group and Description." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t76">Resource Consumer Group</th>
<th class="cellalignment1334" id="r1c2-t76">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t76" headers="r1c1-t76">
<p><code dir="ltr">BATCH_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t76 r1c2-t76">
<p>Consumer group for batch operations. Referenced by the example plan <code dir="ltr">MIXED_WORKLOAD_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t76" headers="r1c1-t76">
<p><code dir="ltr">DSS_CRITICAL_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t76 r1c2-t76">
<p>Consumer group for critical DSS queries. Referenced by the example plans <code dir="ltr">DSS_PLAN</code> and <code dir="ltr">ETL_CRITICAL_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t76" headers="r1c1-t76">
<p><code dir="ltr">DSS_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t76 r1c2-t76">
<p>Consumer group for non-critical DSS queries. Referenced by the example plans <code dir="ltr">DSS_PLAN</code> and <code dir="ltr">ETL_CRITICAL_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ETL_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t76 r1c2-t76">
<p>Consumer group for ETL jobs. Referenced by the example plans <code dir="ltr">DSS_PLAN</code> and <code dir="ltr">ETL_CRITICAL_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t76" headers="r1c1-t76">
<p><code dir="ltr">INTERACTIVE_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t76 r1c2-t76">
<p>Consumer group for interactive, OLTP operations. Referenced by the example plan <code dir="ltr">MIXED_WORKLOAD_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t76" headers="r1c1-t76">
<p><code dir="ltr">LOW_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r7c1-t76 r1c2-t76">
<p>Consumer group for low-priority sessions.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$DIAGNOSTICS</code></p>
</td>
<td class="cellalignment1335" headers="r8c1-t76 r1c2-t76">
<p>Consumer group used by database processes that create diagnostic dumps when critical errors occur.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$AUTOTASK_HEALTH_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r9c1-t76 r1c2-t76">
<p>Reserved for future use. Included in <code dir="ltr">ORA$AUTOTASK_HIGH_SUB_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r10c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$AUTOTASK_MEDIUM_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r10c1-t76 r1c2-t76">
<p>Consumer group for medium-priority maintenance tasks.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r11c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$AUTOTASK_SPACE_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r11c1-t76 r1c2-t76">
<p>Consumer group for Automatic Segment Advisor maintenance task. Included in <code dir="ltr">ORA$AUTOTASK_HIGH_SUB_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r12c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$AUTOTASK_SQL_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r12c1-t76 r1c2-t76">
<p>Consumer group for Automatic SQL Tuning Advisor maintenance task. Included in <code dir="ltr">ORA$AUTOTASK_HIGH_SUB_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r13c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$AUTOTASK_STATS_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r13c1-t76 r1c2-t76">
<p>Consumer group for optimizer statistics gathering maintenance task. Included in <code dir="ltr">ORA$AUTOTASK_HIGH_SUB_PLAN</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r14c1-t76" headers="r1c1-t76">
<p><code dir="ltr">ORA$AUTOTASK_URGENT_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r14c1-t76 r1c2-t76">
<p>Consumer group for urgent maintenance tasks.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r15c1-t76" headers="r1c1-t76">
<p><code dir="ltr">OTHER_GROUPS</code></p>
</td>
<td class="cellalignment1335" headers="r15c1-t76 r1c2-t76">
<p>Default consumer group for all sessions that do not have an explicit initial consumer group, are not mapped to a consumer group with session-to&ndash;consumer group mapping rules, or are mapped to a consumer group that is not in the currently active resource plan.</p>
<p><code dir="ltr">OTHER_GROUPS</code> must have a resource plan directive specified in every plan. It cannot be assigned explicitly to sessions through mapping rules.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r16c1-t76" headers="r1c1-t76">
<p><code dir="ltr">SYS_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r16c1-t76 r1c2-t76">
<p>Consumer group for system administrators. It is the initial consumer group for all sessions created by user accounts <code dir="ltr">SYS</code> or <code dir="ltr">SYSTEM</code>. This initial consumer group can be overridden by session-to&ndash;consumer group mapping rules.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwide" --></div>
<!-- class="sect2" -->
<a id="CHDEFDCH"></a>
<div id="ADMIN11915" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Predefined Consumer Group Mapping Rules</h3>
<p><a href="#CHDHJCHG">Table 27-6</a> summarizes the consumer group mapping rules that are predefined in Oracle Database. You can verify these rules by querying the view <code dir="ltr">DBA_RSRC_GROUP_MAPPINGS</code>. You can use the <code dir="ltr">DBMS_RESOURCE_MANAGER</code>.<code dir="ltr">SET_CONSUMER_GROUP_MAPPING</code> procedure to modify or delete any of these mapping rules.</p>
<div id="ADMIN13078" class="tblruleformalwide">
<p class="titleintable"><a id="sthref2910"></a><a id="CHDHJCHG"></a>Table 27-6 Predefined Consumer Group Mapping Rules</p>
<table class="cellalignment1333" title="Predefined Consumer Group Mapping Rules" summary="This table contains 3 columns: Rule, Mapped Consumer Group, and Notes. The 5 rows describe 5 different predefined mapping rules and their mapped consumer groups." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t77">Attribute</th>
<th class="cellalignment1334" id="r1c2-t77">Value</th>
<th class="cellalignment1334" id="r1c3-t77">Mapped Consumer Group</th>
<th class="cellalignment1334" id="r1c4-t77">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t77" headers="r1c1-t77">
<p><code dir="ltr">ORACLE_USER</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t77 r1c2-t77">
<p><code dir="ltr">SYS</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t77 r1c3-t77">
<p><code dir="ltr">SYS_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t77 r1c4-t77">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t77" headers="r1c1-t77">
<p><code dir="ltr">ORACLE_USER</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t77 r1c2-t77">
<p><code dir="ltr">SYSTEM</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t77 r1c3-t77">
<p><code dir="ltr">SYS_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t77 r1c4-t77">&nbsp;</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t77" headers="r1c1-t77">
<p><code dir="ltr">ORACLE_FUNCTION</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t77 r1c2-t77">
<p><code dir="ltr">BACKUP</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t77 r1c3-t77">
<p><code dir="ltr">BATCH_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t77 r1c4-t77">
<p>The session is running a backup operation with RMAN. The session is automatically switched to <code dir="ltr">BATCH_GROUP</code> when the operation begins.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t77" headers="r1c1-t77">
<p><code dir="ltr">ORACLE_FUNCTION</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t77 r1c2-t77">
<p><code dir="ltr">COPY</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t77 r1c3-t77">
<p><code dir="ltr">BATCH_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t77 r1c4-t77">
<p>The session is running a copy operation with RMAN. The session is automatically switched to <code dir="ltr">BATCH_GROUP</code> when the operation begins.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t77" headers="r1c1-t77">
<p><code dir="ltr">ORACLE_FUNCTION</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t77 r1c2-t77">
<p><code dir="ltr">DATALOAD</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t77 r1c3-t77">
<p><code dir="ltr">ETL_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t77 r1c4-t77">
<p>The session is performing a data load operation with Data Pump. The session is automatically switched to <code dir="ltr">ETL_GROUP</code> when the operation begins.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwide" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CHDIGIII">"Specifying Session-to&ndash;Consumer Group Mapping Rules"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1008772"></a>
<div id="ADMIN11916" class="sect2">
<h3 class="sect2">Resource Manager Data Dictionary Views<a id="sthref2911"></a><a id="sthref2912"></a></h3>
<p><a href="#CHDBHJAA">Table 27-7</a> lists views that are associated with the Resource Manager.</p>
<div id="ADMIN13079" class="tblruleformalwide">
<p class="titleintable"><a id="sthref2913"></a><a id="CHDBHJAA"></a>Table 27-7 Resource Manager Data Dictionary Views</p>
<table class="cellalignment1333" title="Resource Manager Data Dictionary Views" summary="Column 1 lists the names of views that display information relating to database resource management. Column 2 describes each view." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t79">View</th>
<th class="cellalignment1334" id="r1c2-t79">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_CONSUMER_GROUP_PRIVS</code></p>
<p><code dir="ltr">USER_RSRC_CONSUMER_GROUP_PRIVS</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t79 r1c2-t79">
<p><code dir="ltr">DBA</code> view lists all resource consumer groups and the users and roles to which they have been granted. <code dir="ltr">USER</code> view lists all resource consumer groups granted to the user.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_CONSUMER_GROUPS</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t79 r1c2-t79">
<p>Lists all resource consumer groups that exist in the database.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_MANAGER_SYSTEM_PRIVS</code></p>
<p><code dir="ltr">USER_RSRC_MANAGER_SYSTEM_PRIVS</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t79 r1c2-t79">
<p><code dir="ltr">DBA</code> view lists all users and roles that have been granted Resource Manager system privileges. <code dir="ltr">USER</code> view lists all the users that are granted system privileges for the <code dir="ltr">DBMS_RESOURCE_MANAGER</code> package.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_PLAN_DIRECTIVES</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t79 r1c2-t79">
<p>Lists all resource plan directives that exist in the database.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_PLANS</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t79 r1c2-t79">
<p>Lists all resource plans that exist in the database.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_GROUP_MAPPINGS</code></p>
</td>
<td class="cellalignment1335" headers="r7c1-t79 r1c2-t79">
<p>Lists all of the various mapping pairs for all of the session attributes.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_RSRC_MAPPING_PRIORITY</code></p>
</td>
<td class="cellalignment1335" headers="r8c1-t79 r1c2-t79">
<p>Lists the current mapping priority of each attribute.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_HIST_RSRC_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r9c1-t79 r1c2-t79">
<p>Displays historical information about resource plan activation. This view contains AWR snapshots of <code dir="ltr">V$RSRC_PLAN_HISTORY</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r10c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_HIST_RSRC_CONSUMER_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r10c1-t79 r1c2-t79">
<p>Displays historical statistical information about consumer groups. This view contains AWR snapshots of <code dir="ltr">V$RSRC_CONS_GROUP_HISTORY</code>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r11c1-t79" headers="r1c1-t79">
<p><code dir="ltr">DBA_USERS</code></p>
<p><code dir="ltr">USER_USERS</code></p>
</td>
<td class="cellalignment1335" headers="r11c1-t79 r1c2-t79">
<p><code dir="ltr">DBA</code> view contains information about all users of the database. It contains the initial resource consumer group for each user. <code dir="ltr">USER</code> view contains information about the current user. It contains the current user's initial resource consumer group.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r12c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRC_CONS_GROUP_HISTORY</code></p>
</td>
<td class="cellalignment1335" headers="r12c1-t79 r1c2-t79">
<p>For each entry in the view <code dir="ltr">V$RSRC_PLAN_HISTORY</code>, contains an entry for each consumer group in the plan showing the cumulative statistics for the consumer group.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r13c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRC_CONSUMER_GROUP</code></p>
</td>
<td class="cellalignment1335" headers="r13c1-t79 r1c2-t79">
<p>Displays information about active resource consumer groups. This view can be used for tuning.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r14c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRCMGRMETRIC</code></p>
</td>
<td class="cellalignment1335" headers="r14c1-t79 r1c2-t79">
<p>Displays a history of resources consumed and cumulative CPU wait time (due to resource management) per consumer group for the past minute.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r15c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRCMGRMETRIC_HISTORY</code></p>
</td>
<td class="cellalignment1335" headers="r15c1-t79 r1c2-t79">
<p>Displays a history of resources consumed and cumulative CPU wait time (due to resource management) per consumer group for the past hour on a minute-by-minute basis. If a new resource plan is enabled, the history is cleared.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r16c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRC_PLAN</code></p>
</td>
<td class="cellalignment1335" headers="r16c1-t79 r1c2-t79">
<p>Displays the names of all currently active resource plans.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r17c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRC_PLAN_HISTORY</code></p>
</td>
<td class="cellalignment1335" headers="r17c1-t79 r1c2-t79">
<p>Shows when Resource Manager plans were enabled or disabled on the instance. It helps you understand how resources were shared among the consumer groups over time.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r18c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$RSRC_SESSION_INFO</code></p>
</td>
<td class="cellalignment1335" headers="r18c1-t79 r1c2-t79">
<p>Displays Resource Manager statistics for each session. Shows how the session has been affected by the Resource Manager. Can be used for tuning.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r19c1-t79" headers="r1c1-t79">
<p><code dir="ltr">V$SESSION</code></p>
</td>
<td class="cellalignment1335" headers="r19c1-t79 r1c2-t79">
<p>Lists session information for each current session. Specifically, lists the name of the resource consumer group of each current session.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblruleformalwide" -->
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for detailed information about the contents of each of these views</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1326">
<tr>
<td class="cellalignment1335">
<table class="cellalignment1331">
<tr>
<td class="cellalignment1330"><a href="tasks.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1330"><a href="schedover.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1337">
<table class="cellalignment1329">
<tr>
<td class="cellalignment1330"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1330"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1330"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1330"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1330"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1330"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
