<!DOCTYPE html>
<html lang="en" >
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>Managing Tables</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Merged Version 1055" />
<meta name="dcterms.created" content="2015-05-05T8:27:36Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database Administrator's Guide" />
<meta name="dcterms.identifier" content="E25494-07" />
<meta name="dcterms.isVersionOf" content="ADMIN" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2001, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="schema.htm" title="Previous" type="text/html" />
<link rel="Next" href="indexes.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25494.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns" dir="ltr">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">29/49</span> <!-- End Header -->
<div id="ADMIN015" class="chapter"><a id="g1033179"></a> <a id="i1008063"></a>
<h1 class="chapter"><span class="secnum">20</span> Managing Tables</h1>
<p><a id="sthref2125"></a><a id="sthref2126"></a>In this chapter:</p>
<ul>
<li>
<p><a href="#i1008437">About Tables</a></p>
</li>
<li>
<p><a href="#i1006162">Guidelines for Managing Tables</a></p>
</li>
<li>
<p><a href="#i1106335">Creating Tables</a></p>
</li>
<li>
<p><a href="#CJAEJGJF">Loading Tables</a></p>
</li>
<li>
<p><a href="#i1006473">Automatically Collecting Statistics on Tables</a></p>
</li>
<li>
<p><a href="#i1006494">Altering Tables</a></p>
</li>
<li>
<p><a href="#i1006754">Redefining Tables Online</a></p>
</li>
<li>
<p><a href="#i1010007">Researching and Reversing Erroneous Table Changes</a></p>
</li>
<li>
<p><a href="#i1010008">Recovering Tables Using Oracle Flashback Table</a></p>
</li>
<li>
<p><a href="#i1011125">Dropping Tables</a></p>
</li>
<li>
<p><a href="#i1010137">Using Flashback Drop and Managing the Recycle Bin</a></p>
</li>
<li>
<p><a href="#i1010378">Managing Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1007424">Managing External Tables</a></p>
</li>
<li>
<p><a href="#i1007685">Tables Data Dictionary Views</a></p>
</li>
</ul>
<a id="i1008437"></a>
<div id="ADMIN11003" class="sect1">
<h2 class="sect1">About Tables</h2>
<p><a id="sthref2127"></a>Tables are the basic unit of data storage in an Oracle Database. Data is stored in rows and columns. You define a table with a table name, such as <code dir="ltr">employees</code>, and a set of columns. You give each column a column name, such as <code dir="ltr">employee_id</code>, <code dir="ltr">last_name</code>, and <code dir="ltr">job_id</code>; a data type, such as <code dir="ltr">VARCHAR2</code>, <code dir="ltr">DATE</code>, or <code dir="ltr">NUMBER</code>; and a width. The width can be predetermined by the data type, as in <code dir="ltr">DATE</code>. If columns are of the <code dir="ltr">NUMBER</code> data type, define precision and scale instead of width. A row is a collection of column information corresponding to a single record.</p>
<p>You can specify rules for each column of a table. These rules are called integrity constraints. One example is a <code dir="ltr">NOT NULL</code> integrity constraint. This constraint forces the column to contain a value in every row.</p>
<p>You can invoke transparent data encryption to encrypt data before storing it. If users attempt to circumvent the database access control mechanisms by looking inside Oracle data files directly with operating system tools, encryption prevents these users from viewing sensitive data.</p>
<p>Tables can also include<a id="sthref2128"></a><a id="sthref2129"></a> virtual columns. A <span class="bold">virtual column</span> is like any other table column, except that its value is derived by evaluating an expression. The expression can include columns from the same table, constants, SQL functions, and user-defined PL/SQL functions. You cannot explicitly write to a virtual column.</p>
<p>Some column types, such as <code dir="ltr">LOB</code>s, varrays, and nested tables, are stored in their own segments. <code dir="ltr">LOB</code>s and varrays are stored in <code dir="ltr">LOB</code> segments, while nested tables are stored in storage tables. You can specify a <code dir="ltr">STORAGE</code> clause for these segments that will override storage parameters specified at the table level.</p>
<p>After you create a table, you insert rows of data using SQL statements or using an Oracle bulk load utility. Table data can then be queried, deleted, or updated using SQL.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT211" href="../../server.112/e40540/tablecls.htm#CNCPT211"><span class="italic">Oracle Database Concepts</span></a> for an overview of tables</p>
</li>
<li>
<p><a class="olink SQLRF0021" href="../../server.112/e41084/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Reference</span></a> for descriptions of Oracle Database data types</p>
</li>
<li>
<p><a href="schema.htm#g1019613">Chapter 19, "Managing Space for Schema Objects"</a> for guidelines for managing space for tables</p>
</li>
<li>
<p><a href="general.htm#g1017986">Chapter 18, "Managing Schema Objects"</a> for information on additional aspects of managing tables, such as specifying integrity constraints and analyzing tables</p>
</li>
<li>
<p><a class="olink ASOAG600" href="../../network.112/e40393/asotrans.htm#ASOAG600"><span class="italic">Oracle Database Advanced Security Administrator's Guide</span></a> for a discussion of transparent data encryption</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1006162"></a>
<div id="ADMIN01502" class="sect1">
<h2 class="sect1">Guidelines for Managing Tables</h2>
<p><a id="sthref2130"></a>This section describes guidelines to follow when managing tables. Following these guidelines can make the management of your tables easier and can improve performance when creating the table, as well as when loading, updating, and querying the table data.</p>
<p>The following topics are discussed:</p>
<ul>
<li>
<p><a href="#i1006200">Design Tables Before Creating Them</a></p>
</li>
<li>
<p><a href="#i1008262">Specify the Type of Table to Create</a></p>
</li>
<li>
<p><a href="#i1006237">Specify the Location of Each Table</a></p>
</li>
<li>
<p><a href="#i1006253">Consider Parallelizing Table Creation</a></p>
</li>
<li>
<p><a href="#i1106265">Consider Using NOLOGGING When Creating Tables</a></p>
</li>
<li>
<p><a href="#CJAGFBFG">Consider Using Table Compression</a></p>
</li>
<li>
<p><a href="#CJAGJDGF">Consider Encrypting Columns That Contain Sensitive Data</a></p>
</li>
<li>
<p><a href="#CHDGJAGB">Understand Deferred Segment Creation</a></p>
</li>
<li>
<p><a href="#i1006276">Estimate Table Size and Plan Accordingly</a></p>
</li>
<li>
<p><a href="#i1006310">Restrictions to Consider When Creating Tables</a></p>
</li>
</ul>
<a id="i1006200"></a>
<div id="ADMIN11625" class="sect2">
<h3 class="sect2">Design Tables Before Creating Them</h3>
<p><a id="sthref2131"></a>Usually, the application developer is responsible for designing the elements of an application, including the tables. Database administrators are responsible for establishing the attributes of the underlying tablespace that will hold the application tables. Either the DBA or the applications developer, or both working jointly, can be responsible for the actual creation of the tables, depending upon the practices for a site.</p>
<p>Working with the application developer, consider the following guidelines when designing tables:</p>
<ul>
<li>
<p>Use descriptive names for tables, columns, indexes, and clusters.</p>
</li>
<li>
<p>Be consistent in abbreviations and in the use of singular and plural forms of table names and columns.</p>
</li>
<li>
<p>Document the meaning of each table and its columns with the <code dir="ltr">COMMENT</code> command.</p>
</li>
<li>
<p>Normalize each table.</p>
</li>
<li>
<p>Select the appropriate data type for each column.</p>
</li>
<li>
<p>Consider whether your applications would benefit from adding one or more virtual columns to some tables.</p>
</li>
<li>
<p>Define columns that allow nulls last, to conserve storage space.</p>
</li>
<li>
<p>Cluster tables whenever appropriate, to conserve storage space and optimize performance of SQL statements.</p>
</li>
</ul>
<p>Before creating a table, you should also determine whether to use integrity constraints. Integrity constraints can be defined on the columns of a table to enforce the business rules of your database automatically.</p>
</div>
<!-- class="sect2" -->
<a id="i1008262"></a>
<div id="ADMIN11626" class="sect2">
<h3 class="sect2">Specify the Type of Table to Create</h3>
<p>Here are the types of tables that you can create:</p>
<div class="inftblhruleinformal">
<table class="cellalignment1333" title="Table Varieties" summary="Column 1 lists some of the various types of tables, column 2 describes each type of table." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t3">Type of Table</th>
<th class="cellalignment1334" id="r1c2-t3">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t3" headers="r1c1-t3">Ordinary (heap-organized) table</td>
<td class="cellalignment1335" headers="r2c1-t3 r1c2-t3">This is the basic, general purpose type of table which is the primary subject of this chapter. Its data is stored as an unordered collection (heap).</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t3" headers="r1c1-t3">Clustered table</td>
<td class="cellalignment1335" headers="r3c1-t3 r1c2-t3">A clustered table is a table that is part of a cluster. A cluster is a group of tables that share the same data blocks because they share common columns and are often used together.
<p>Clusters and clustered tables are discussed in <a href="clustrs.htm#g1009415">Chapter 22, "Managing Clusters"</a>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t3" headers="r1c1-t3">Index-organized table</td>
<td class="cellalignment1335" headers="r4c1-t3 r1c2-t3">Unlike an ordinary (heap-organized) table, data for an index-organized table is stored in a B-tree index structure in a primary key sorted manner. Besides storing the primary key column values of an index-organized table row, each index entry in the B-tree stores the nonkey column values as well.
<p>Index-organized tables are discussed in <a href="#i1010378">"Managing Index-Organized Tables"</a>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t3" headers="r1c1-t3">Partitioned table</td>
<td class="cellalignment1335" headers="r5c1-t3 r1c2-t3">Partitioned tables enable your data to be broken down into smaller, more manageable pieces called partitions, or even subpartitions. Each partition can have separate physical attributes, such as compression enabled or disabled, type of compression, physical storage settings, and tablespace, thus providing a structure that can be better tuned for availability and performance. In addition, each partition can be managed individually, which can simplify and reduce the time required for backup and administration.
<p>Partitioned tables are discussed in <a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a>.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblhruleinformal" --></div>
<!-- class="sect2" -->
<a id="i1006237"></a>
<div id="ADMIN11627" class="sect2">
<h3 class="sect2">Specify the Location of Each Table</h3>
<p><a id="sthref2132"></a>It is advisable to specify the <code dir="ltr">TABLESPACE</code> clause in a <code dir="ltr"><a id="sthref2133"></a>CREATE TABLE</code> statement to identify the tablespace that is to store the new table. For partitioned tables, you can optionally identify the tablespace that is to store each partition. Ensure that you have the appropriate privileges and quota on any tablespaces that you use. If you do not specify a tablespace in a <code dir="ltr">CREATE TABLE</code> statement, the table is created in your default tablespace.</p>
<p>When specifying the tablespace to contain a new table, ensure that you understand implications of your selection. By properly specifying a tablespace during the creation of each table, you can increase the performance of the database system and decrease the time needed for database administration.</p>
<p>The following situations illustrate how not specifying a tablespace, or specifying an inappropriate one, can affect performance:</p>
<ul>
<li>
<p>If users' objects are created in the <code dir="ltr">SYSTEM</code> tablespace, the performance of the database can suffer, since both data dictionary objects and user objects must contend for the same data files. Users' objects should not be stored in the <code dir="ltr">SYSTEM</code> tablespace. To avoid this, ensure that all users are assigned default tablespaces when they are created in the database.</p>
</li>
<li>
<p>If application-associated tables are arbitrarily stored in various tablespaces, the time necessary to complete administrative operations (such as backup and recovery) for the data of that application can be increased.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006253"></a>
<div id="ADMIN11628" class="sect2">
<h3 class="sect2">Consider Parallelizing Table Creation</h3>
<p><a id="sthref2134"></a><a id="sthref2135"></a>You can use parallel execution when creating tables using a subquery (<code dir="ltr">AS SELECT</code>) in the <code dir="ltr"><a id="sthref2136"></a>CREATE TABLE</code> statement. Because multiple processes work together to create the table, performance of the table creation operation is improved.</p>
<p>Parallelizing table creation is discussed in the section <a href="#i1009052">"Parallelizing Table Creation"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1106265"></a>
<div id="ADMIN11629" class="sect2">
<h3 class="sect2">Consider Using NOLOGGING When Creating Tables</h3>
<p>To create a table most efficiently use the <code dir="ltr">NOLOGGING</code> clause<a id="sthref2137"></a><a id="sthref2138"></a> in the <code dir="ltr">CREATE TABLE...AS SELECT</code> statement. The <code dir="ltr">NOLOGGING</code> clause causes minimal redo information to be generated during the table creation. This has the following benefits:</p>
<ul>
<li>
<p>Space is saved in the redo log files.</p>
</li>
<li>
<p>The time it takes to create the table is decreased.</p>
</li>
<li>
<p>Performance improves for parallel creation of large tables.</p>
</li>
</ul>
<p>The <code dir="ltr">NOLOGGING</code> clause also specifies that subsequent direct loads using SQL*Loader and direct load <code dir="ltr">INSERT</code> operations are not logged. Subsequent DML statements (<code dir="ltr">UPDATE</code>, <code dir="ltr">DELETE</code>, and conventional path insert) are unaffected by the <code dir="ltr">NOLOGGING</code> attribute of the table and generate redo.</p>
<p>If you cannot afford to lose the table after you have created it (for example, you will no longer have access to the data used to create the table) you should take a backup immediately after the table is created. In some situations, such as for tables that are created for temporary use, this precaution may not be necessary.</p>
<p>In general, the relative performance improvement of specifying <code dir="ltr">NOLOGGING</code> is greater for larger tables than for smaller tables. For small tables, <code dir="ltr">NOLOGGING</code> has little effect on the time it takes to create a table. However, for larger tables the performance improvement can be significant, especially when also parallelizing the table creation.</p>
</div>
<!-- class="sect2" -->
<a id="CJAGFBFG"></a>
<div id="ADMIN11630" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Consider Using Table Compression</h3>
<p><a id="sthref2139"></a><a id="sthref2140"></a><a id="sthref2141"></a><a id="sthref2142"></a>As your database grows in size, consider using table compression. Compression saves disk space, reduces memory use in the database buffer cache, and can significantly speed query execution during reads. Compression has a cost in CPU overhead for data loading and DML. However, this cost might be offset by reduced I/O requirements.</p>
<p>Table compression is completely transparent to applications. It is useful in decision support systems (DSS), online transaction processing (OLTP) systems, and archival systems.</p>
<p>You can specify compression for a tablespace, a table, or a partition. If specified at the tablespace level, then all tables created in that tablespace are compressed by default.</p>
<p>Compression can occur while data is being inserted, updated, or bulk loaded into a table. Operations that permit compression include:</p>
<ul>
<li>
<p>Single-row or array inserts and updates</p>
</li>
<li>
<p>The following direct-path <code dir="ltr">INSERT</code> methods:</p>
<ul>
<li>
<p>Direct path SQL*Loader</p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statements</p>
</li>
<li>
<p>Parallel <code dir="ltr">INSERT</code> statements</p>
</li>
<li>
<p><code dir="ltr">INSERT</code> statements with an <code dir="ltr">APPEND</code> or <code dir="ltr">APPEND_VALUES</code> hint</p>
</li>
</ul>
</li>
</ul>
<p>Oracle Database supports several methods of table compression. They are summarized in <a href="#BABIEBBC">Table 20-1</a>.</p>
<div id="ADMIN13513" class="tblformalwide">
<p class="titleintable"><a id="sthref2143"></a><a id="BABIEBBC"></a>Table 20-1 Table Compression Methods</p>
<table class="cellalignment1333" title="Table Compression Methods" summary="This table describes the types of table compression. It has the following columns: Compression Type, Compression Level, CPU Overhead, and Applications." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t4">Table Compression Method</th>
<th class="cellalignment1334" id="r1c2-t4">Compression Level</th>
<th class="cellalignment1334" id="r1c3-t4">CPU Overhead</th>
<th class="cellalignment1334" id="r1c4-t4">Applications</th>
<th class="cellalignment1334" id="r1c5-t4">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t4" headers="r1c1-t4">
<p>Basic compression</p>
</td>
<td class="cellalignment1335" headers="r2c1-t4 r1c2-t4">
<p>High</p>
</td>
<td class="cellalignment1335" headers="r2c1-t4 r1c3-t4">
<p>Minimal</p>
</td>
<td class="cellalignment1335" headers="r2c1-t4 r1c4-t4">
<p>DSS</p>
</td>
<td class="cellalignment1335" headers="r2c1-t4 r1c5-t4">
<p>None.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t4" headers="r1c1-t4">
<p>OLTP compression</p>
</td>
<td class="cellalignment1335" headers="r3c1-t4 r1c2-t4">
<p>High</p>
</td>
<td class="cellalignment1335" headers="r3c1-t4 r1c3-t4">
<p>Minimal</p>
</td>
<td class="cellalignment1335" headers="r3c1-t4 r1c4-t4">
<p>OLTP, DSS</p>
</td>
<td class="cellalignment1335" headers="r3c1-t4 r1c5-t4">
<p>None.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t4" headers="r1c1-t4">
<p>Warehouse compression (Hybrid Columnar Compression)</p>
</td>
<td class="cellalignment1335" headers="r4c1-t4 r1c2-t4">
<p>Higher</p>
</td>
<td class="cellalignment1335" headers="r4c1-t4 r1c3-t4">
<p>Higher</p>
</td>
<td class="cellalignment1335" headers="r4c1-t4 r1c4-t4">
<p>DSS</p>
</td>
<td class="cellalignment1335" headers="r4c1-t4 r1c5-t4">
<p>The compression level and CPU overhead depend on compression level specified (LOW or HIGH).</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t4" headers="r1c1-t4">
<p>Archive compression (Hybrid Columnar Compression)</p>
</td>
<td class="cellalignment1335" headers="r5c1-t4 r1c2-t4">
<p>Highest</p>
</td>
<td class="cellalignment1335" headers="r5c1-t4 r1c3-t4">
<p>Highest</p>
</td>
<td class="cellalignment1335" headers="r5c1-t4 r1c4-t4">
<p>Archiving</p>
</td>
<td class="cellalignment1335" headers="r5c1-t4 r1c5-t4">
<p>The compression level and CPU overhead depend on compression level specified (LOW or HIGH).</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p><a id="sthref2144"></a>When you use basic compression, warehouse compression, or archive compression, compression only occurs when data is bulk loaded into a table.</p>
<p>When you use OLTP compression, compression occurs while data is being inserted, updated, or bulk loaded into a table. Operations that permit compression include:</p>
<ul>
<li>
<p>Single-row or array inserts and updates</p>
<p>Inserts and updates are not compressed immediately. When updating an already compressed block, any columns that are not updated usually remain compressed. Updated columns are stored in an uncompressed format similar to any uncompressed block. The updated values are re-compressed when the block reaches a database-controlled threshold. Inserted data is also compressed when the data in the block reaches a database-controlled threshold.</p>
</li>
<li>
<p>The following direct-path <code dir="ltr">INSERT</code> methods:</p>
<ul>
<li>
<p>Direct path SQL*Loader</p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code> statements</p>
</li>
<li>
<p>Parallel <code dir="ltr">INSERT</code> statements</p>
</li>
<li>
<p><code dir="ltr">INSERT</code> statements with an <code dir="ltr">APPEND</code> or <code dir="ltr">APPEND_VALUES</code> hint</p>
</li>
</ul>
</li>
</ul>
<p>Basic compression compresses data inserted by direct path load only and supports limited data types and SQL operations. OLTP compression is intended for OLTP applications and compresses data manipulated by any SQL operation.</p>
<p>Warehouse compression and archive compression achieve the highest compression levels because they use Hybrid Columnar Compression technology. Hybrid Columnar Compression technology uses a modified form of columnar storage instead of row-major storage. This enables the database to store similar data together, which improves the effectiveness of compression algorithms. For data that is updated, Hybrid Columnar Compression uses more CPU and moves the updated rows to row format so that future updates are faster. Because of this optimization, you should use it only for data that is updated infrequently.</p>
<p>The higher compression levels of Hybrid Columnar Compression are achieved only with data that is direct-path inserted. Conventional inserts and updates are supported, but cause rows to be moved from columnar to row format, and reduce the compression level.</p>
<p>Regardless of the compression method, <code dir="ltr">DELETE</code> operations on a compressed block are identical to <code dir="ltr">DELETE</code> operations on a non-compressed block. Any space obtained on a data block, caused by SQL <code dir="ltr">DELETE</code> operations, is reused by subsequent SQL <code dir="ltr">INSERT</code> operations. With Hybrid Columnar Compression technology, when all the rows in a compression unit are deleted, the space in the compression unit is available for reuse.</p>
<p><a href="#CJAEEHJH">Table 20-2</a> lists characteristics of each table compression method.</p>
<div id="ADMIN13059" class="tblformalwide">
<p class="titleintable"><a id="sthref2145"></a><a id="CJAEEHJH"></a>Table 20-2 Table Compression Characteristics</p>
<table class="cellalignment1333" title="Table Compression Characteristics" summary="This table lists characteristics of the three types of table compression. Columns are: Compression Type, CREATE/ALTER TABLE syntax, Direct Path Insert, DML, Add Column, and Drop Column" dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t5">Table Compression Method</th>
<th class="cellalignment1334" id="r1c2-t5">CREATE/ALTER TABLE Syntax</th>
<th class="cellalignment1334" id="r1c3-t5">Direct-Path INSERT</th>
<th class="cellalignment1334" id="r1c4-t5">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t5" headers="r1c1-t5">
<p>Basic compression</p>
</td>
<td class="cellalignment1335" headers="r2c1-t5 r1c2-t5">
<p><code dir="ltr">COMPRESS [BASIC]</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t5 r1c3-t5">
<p>Rows are compressed with basic compression.</p>
</td>
<td class="cellalignment1335" headers="r2c1-t5 r1c4-t5">
<p><code dir="ltr">COMPRESS</code> and <code dir="ltr">COMPRESS</code> <code dir="ltr">BASIC</code> are equivalent.</p>
<p>Rows inserted without using direct-path insert and updated rows are uncompressed.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t5" headers="r1c1-t5">
<p>OLTP compression</p>
</td>
<td class="cellalignment1335" headers="r3c1-t5 r1c2-t5">
<p><code dir="ltr">COMPRESS FOR OLTP</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t5 r1c3-t5">
<p>Rows are compressed with OLTP compression.</p>
</td>
<td class="cellalignment1335" headers="r3c1-t5 r1c4-t5">
<p>Rows inserted without using direct-path insert and updated rows are compressed using OLTP compression.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t5" headers="r1c1-t5">
<p>Warehouse compression (Hybrid Columnar Compression)</p>
</td>
<td class="cellalignment1335" headers="r4c1-t5 r1c2-t5">
<p><code dir="ltr">COMPRESS FOR QUERY [LOW|HIGH]</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t5 r1c3-t5">
<p>Rows are compressed with warehouse compression.</p>
</td>
<td class="cellalignment1335" headers="r4c1-t5 r1c4-t5">
<p>This compression method can result in high CPU overhead.</p>
<p>Updated rows and rows inserted without using direct-path insert are stored in row format instead of column format, and thus have a lower compression level.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t5" headers="r1c1-t5">
<p>Archive compression (Hybrid Columnar Compression)</p>
</td>
<td class="cellalignment1335" headers="r5c1-t5 r1c2-t5">
<p><code dir="ltr">COMPRESS FOR ARCHIVE [LOW|HIGH]</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t5 r1c3-t5">
<p>Rows are compressed with archive compression.</p>
</td>
<td class="cellalignment1335" headers="r5c1-t5 r1c4-t5">
<p>This compression method can result in high CPU overhead.</p>
<p>Updated rows and rows inserted without using direct-path insert are stored in row format instead of column format, and thus have a lower compression level.</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblformalwide" -->
<p>You specify table compression with the <code dir="ltr">COMPRESS</code> clause of the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement. You can enable compression for an existing table by using these clauses in an <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement. In this case, only data that is inserted or updated after compression is enabled is compressed. Similarly, you can disable table compression for an existing compressed table with the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">NOCOMPRESS</code> statement. In this case, all data that was already compressed remains compressed, and new data is inserted uncompressed.</p>
<p>The <code dir="ltr">COMPRESS</code> <code dir="ltr">FOR</code> <code dir="ltr">QUERY</code> <code dir="ltr">HIGH</code> option is the default data warehouse compression mode. It provides good compression and performance when using Hybrid Columnar Compression on Exadata storage. The <code dir="ltr">COMPRESS</code> <code dir="ltr">FOR</code> <code dir="ltr">QUERY</code> <code dir="ltr">LOW</code> option should be used in environments where load performance is critical. It loads faster than data compressed with the <code dir="ltr">COMPRESS</code> <code dir="ltr">FOR</code> <code dir="ltr">QUERY</code> <code dir="ltr">HIGH</code> option.</p>
<p>The <code dir="ltr">COMPRESS FOR ARCHIVE LOW</code> option is the default archive compression mode. It provides a high compression level and is ideal for infrequently-accessed data. The <code dir="ltr">COMPRESS FOR ARCHIVE HIGH</code> option should be used for data that is rarely accessed.</p>
<p>A compression advisor, provided by the <code dir="ltr">DBMS_COMPRESSION</code> package, helps you determine the expected compression level for a particular table with a particular compression method.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Hybrid Columnar Compression is dependent on the underlying storage system. See <a class="olink DBLIC2152" href="../../license.112/e47877/editions.htm#DBLIC2152"><span class="italic">Oracle Database Licensing Information</span></a> for more information.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT1132" href="../../server.112/e40540/tablecls.htm#CNCPT1132"><span class="italic">Oracle Database Concepts</span></a> for an overview of table compression</p>
</li>
<li>
<p><a href="tspaces.htm#CIHGCFBB">"Compressed Tablespaces"</a></p>
</li>
</ul>
</div>
<div id="ADMIN13514" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2146"></a>
<h4 class="sect3">Examples Related to Table Compression</h4>
<p>The following examples are related to table compression:</p>
<ul>
<li>
<p><a href="#BABJEICA">Example 20-1, "Creating a Table with OLTP Table Compression"</a></p>
</li>
<li>
<p><a href="#BABGGFJJ">Example 20-2, "Creating a Table with Basic Table Compression"</a></p>
</li>
<li>
<p><a href="#BABEGCEC">Example 20-3, "Using Direct-Path Insert to Insert Rows Into a Table"</a></p>
</li>
<li>
<p><a href="#BABCIECI">Example 20-4, "Creating a Table with Warehouse Compression"</a></p>
</li>
<li>
<p><a href="#BABHHAFC">Example 20-5, "Creating a Table with Archive Compression"</a></p>
</li>
</ul>
<div id="ADMIN13515" class="example">
<p class="titleinexample"><a id="BABJEICA"></a>Example 20-1 Creating a Table with OLTP Table Compression</p>
<p>The following example enables OLTP table compression on the table <code dir="ltr">orders</code>:</p>
<pre dir="ltr">
CREATE TABLE orders  ...  COMPRESS FOR OLTP;
</pre>
<p>Data for the <code dir="ltr">orders</code> table is compressed during both direct-path <code dir="ltr">INSERT</code> and conventional DML.</p>
</div>
<!-- class="example" -->
<div id="ADMIN13516" class="example">
<p class="titleinexample"><a id="BABGGFJJ"></a>Example 20-2 Creating a Table with Basic Table Compression</p>
<p>The following statements, which are equivalent, enable basic table compression on the <code dir="ltr">sales_history</code> table, which is a fact table in a data warehouse:</p>
<pre dir="ltr">
CREATE TABLE sales_history  ...  COMPRESS BASIC;

CREATE TABLE sales_history  ...  COMPRESS;
</pre></div>
<!-- class="example" -->
<p>Frequent queries are run against this table, but no DML is expected.</p>
<div id="ADMIN13517" class="example">
<p class="titleinexample"><a id="BABEGCEC"></a>Example 20-3 Using Direct-Path Insert to Insert Rows Into a Table</p>
<p>This example demonstrates using the <a id="sthref2147"></a><code dir="ltr">APPEND</code> hint to insert rows into the <code dir="ltr">sales_history</code> table using direct-path <code dir="ltr">INSERT</code>.</p>
<pre dir="ltr">
INSERT /*+ APPEND */ INTO sales_history SELECT * FROM sales WHERE cust_id=8890;
COMMIT;
</pre></div>
<!-- class="example" -->
<div id="ADMIN13518" class="example">
<p class="titleinexample"><a id="BABCIECI"></a>Example 20-4 Creating a Table with Warehouse Compression</p>
<p>This example enables Hybrid Columnar Compression on the table <code dir="ltr">sales_history</code>:</p>
<pre dir="ltr">
CREATE TABLE sales_history  ...  COMPRESS FOR QUERY;
</pre>
<p>The table is created with the default <code dir="ltr">COMPRESS FOR QUERY HIGH</code> option. This option provides a higher level of compression than basic or OLTP compression. It works well when load performance is critical, frequent queries are run against this table, and no DML is expected.</p>
</div>
<!-- class="example" -->
<div id="ADMIN13519" class="example">
<p class="titleinexample"><a id="BABHHAFC"></a>Example 20-5 Creating a Table with Archive Compression</p>
<p>The following example enables Hybrid Columnar Compression on the table <code dir="ltr">sales_history</code>:</p>
<pre dir="ltr">
CREATE TABLE sales_history  ...  COMPRESS FOR ARCHIVE;
</pre>
<p>The table is created with the default <code dir="ltr">COMPRESS FOR ARCHIVE LOW</code> option. This option provides the highest level of compression and works well for infrequently-accessed data.</p>
</div>
<!-- class="example" --></div>
<!-- class="sect3" -->
<div id="ADMIN12630" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2148"></a>
<h4 class="sect3">Compression and Partitioned Tables</h4>
<p>A table can have both compressed and uncompressed partitions, and different partitions can use different compression methods. If the compression settings for a table and one of its partitions do not match, then the partition setting has precedence for the partition.</p>
<p>To change the compression method for a partition, do one of the following:</p>
<ul>
<li>
<p>To change the compression method for new data only, use <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">MODIFY</code> <code dir="ltr">PARTITION</code> ... <code dir="ltr">COMPRESS</code> ...</p>
</li>
<li>
<p>To change the compression method for both new and existing data, use either <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">MOVE</code> <code dir="ltr">PARTITION</code> ... <code dir="ltr">COMPRESS</code> ... or online table redefinition.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADMIN12631" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2149"></a>
<h4 class="sect3">Determining If a Table Is Compressed</h4>
<p>In the <code dir="ltr">*_TABLES</code> data dictionary views, compressed tables have <code dir="ltr">ENABLED</code> in the <code dir="ltr">COMPRESSION</code> column. For partitioned tables, this column is null, and the <code dir="ltr">COMPRESSION</code> column of the <code dir="ltr">*_TAB_PARTITIONS</code> views indicates the partitions that are compressed. In addition, the <code dir="ltr">COMPRESS_FOR</code> column indicates the compression method in use for the table or partition.</p>
<pre dir="ltr">
SQL&gt; SELECT table_name, compression, compress_for FROM user_tables;
 
TABLE_NAME       COMPRESSION   COMPRESS_FOR
---------------- ------------  -----------------
T1               DISABLED
T2               ENABLED       BASIC
T3               ENABLED       OLTP
T4               ENABLED       QUERY HIGH
T5               ENABLED       ARCHIVE LOW

</pre>
<pre dir="ltr">
SQL&gt; SELECT table_name, partition_name, compression, compress_for
  FROM user_tab_partitions;

TABLE_NAME  PARTITION_NAME   COMPRESSION   COMPRESS_FOR
----------- ---------------- -----------   ------------------------------
SALES       Q4_2004          ENABLED       ARCHIVE HIGH
  ...
SALES       Q3_2008          ENABLED       QUERY HIGH
SALES       Q4_2008          ENABLED       QUERY HIGH
SALES       Q1_2009          ENABLED       OLTP
SALES       Q2_2009          ENABLED       OLTP
</pre></div>
<!-- class="sect3" -->
<div id="ADMIN13520" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2150"></a>
<h4 class="sect3">Determining Which Rows Are Compressed</h4>
<p>When Hybrid Columnar Compression tables are updated, the rows change to a lower level of compression, such as from warehouse compression (<code dir="ltr">QUERY</code> <code dir="ltr">HIGH</code>) to OLTP compression or no compression. To determine the compression level of a row, use the <code dir="ltr">GET_COMPRESSION_TYPE</code> function in the <code dir="ltr">DBMS_COMPRESSION</code> package.</p>
<p>For example, the following query returns the compression type for a row in the <code dir="ltr">hr.employees</code> table:</p>
<pre dir="ltr">
SELECT DECODE(DBMS_COMPRESSION.GET_COMPRESSION_TYPE(
                 ownname =&gt; 'HR', 
                 tabname =&gt; 'EMPLOYEES', 
                 row_id  =&gt; 'AAAVEIAAGAAAABTAAD'), 
   1,  'No Compression',
   2,  'Basic or OLTP Compression', 
   4,  'Hybrid Columnar Compression for Query High',
   8,  'Hybrid Columnar Compression for Query Low',
   16, 'Hybrid Columnar Compression for Archive High',
   32, 'Hybrid Columnar Compression for Archive Low',
   'Unknown Compression Type') compression_type
FROM DUAL;
</pre>
<p>By sampling the table rows, you can determine the percentage of rows that are no longer at the higher compression level. You can use <code dir="ltr">ALTER TABLE</code> or <code dir="ltr">MOVE PARTITION</code> to specify a higher compression level. For example, if 10 percent of the rows are no longer at the highest compression level, then you might alter the table or move the partition to specify a higher compression level.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS65610" href="../../appdev.112/e40758/d_compress.htm#ARPLS65610"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for additional information about <code dir="ltr">GET_COMPRESSION_TYPE</code></div>
</div>
<!-- class="sect3" -->
<div id="ADMIN13521" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2151"></a>
<h4 class="sect3">Changing the Compression Level</h4>
<p>You can change the compression level for a partition, table, or tablespace. For example, suppose a company uses warehouse compression for its sales data, but sales data older than six months is rarely accessed. If the sales data is stored in a table that is partitioned based on the age of the data, then the compression level for the older data can be changed to archive compression to free disk space.</p>
<p>If a table is partitioned, then the <code dir="ltr">DBMS_REDEFINITION</code> package can change the compression level of the table. This package performs online redefinition of a table by creating a temporary copy of the table that holds the table data while it is being redefined. The table being redefined remains available for queries and DML statements during the redefinition. The amount of free space for online table redefinition depends on the relative compression level of the existing table and the new table. Ensure you have enough hard disk space on your system before using the <code dir="ltr">DBMS_REDEFINITION</code> package.</p>
<p>If a table is not partitioned, then you can use the <code dir="ltr">ALTER TABLE...MOVE...COMPRESS FOR...</code> statement to change the compression level. The <code dir="ltr">ALTER TABLE...MOVE</code> statement does not permit DML statements against the table while the command is running.</p>
<p>To change the compression level for a partition, use the <code dir="ltr">ALTER TABLE...MODIFY PARTITION</code> statement. To change the compression level for a tablespace, use the <code dir="ltr">ALTER TABLESPACE</code> statement.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#i1106606">"Moving a Table to a New Segment or Tablespace"</a> for additional information about the <code dir="ltr">ALTER TABLE</code> command</p>
</li>
<li>
<p><a class="olink ARPLS042" href="../../appdev.112/e40758/d_redefi.htm#ARPLS042"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for additional information about the <code dir="ltr">DBMS_REDEFINITION</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN13278" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2152"></a>
<h4 class="sect3">Adding and Dropping Columns in Compressed Tables</h4>
<p>The following restrictions apply when adding columns to compressed tables:</p>
<ul>
<li>
<p>Basic compression&mdash;You cannot specify a default value for an added column.</p>
</li>
<li>
<p>OLTP compression&mdash;If a default value is specified for an added column, then the column must be <code dir="ltr">NOT</code> <code dir="ltr">NULL</code>. Added nullable columns with default values are not supported.</p>
</li>
</ul>
<p>The following restrictions apply when dropping columns in compressed tables:</p>
<ul>
<li>
<p>Basic compression&mdash;Dropping a column is not supported.</p>
</li>
<li>
<p>OLTP compression&mdash;<code dir="ltr">DROP</code> <code dir="ltr">COLUMN</code> is supported, but internally the database sets the column <code dir="ltr">UNUSED</code> to avoid long-running decompression and recompression operations.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADMIN13522" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2153"></a>
<h4 class="sect3">Exporting and Importing Hybrid Columnar Compression Tables</h4>
<p>Hybrid Columnar Compression tables can be imported using the <code dir="ltr">impdp</code> command of the Data Pump Import utility. By default, the <code dir="ltr">impdp</code> command preserves the table properties, and the imported table is a Hybrid Columnar Compression table. On tablespaces not supporting Hybrid Columnar Compression, the <code dir="ltr">impdp</code> command fails with an error. The tables can also be exported using the <code dir="ltr">expdp</code> command.</p>
<p>You can import the Hybrid Columnar Compression table as an uncompressed table using the <code dir="ltr">TRANSFORM:SEGMENT_ATTRIBUTES=n</code> option clause of the <code dir="ltr">impdp</code> command.</p>
<p>An uncompressed or OLTP-compressed table can be converted to Hybrid Columnar Compression format during import. To convert a non-Hybrid Columnar Compression table to a Hybrid Columnar Compression table, do the following:</p>
<ol>
<li>
<p>Specify default compression for the tablespace using the <code dir="ltr">ALTER TABLESPACE ... SET DEFAULT COMPRESS</code> command.</p>
</li>
<li>
<p>Override the <code dir="ltr">SEGMENT_ATTRIBUTES</code> option of the imported table during import.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SUTIL300" href="../../server.112/e22490/dp_import.htm#SUTIL300"><span class="italic">Oracle Database Utilities</span></a> for additional information about the Data Pump Import utility</p>
</li>
<li>
<p><a class="olink SQLRF01002" href="../../server.112/e41084/statements_3002.htm#SQLRF01002"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about the <code dir="ltr">ALTER TABLESPACE</code> command</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN13523" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2154"></a>
<h4 class="sect3">Restoring a Hybrid Columnar Compression Table</h4>
<p>There may be times when a Hybrid Columnar Compression table must be restored from a backup. The table can be restored to a system that supports Hybrid Columnar Compression, or to a system that does not support Hybrid Columnar Compression. When restoring a table with Hybrid Columnar Compression to a system that supports Hybrid Columnar Compression, restore the file using Oracle Recovery Manager (RMAN) as usual.</p>
<p>When a Hybrid Columnar Compression table is restored to a system that does not support Hybrid Columnar Compression, you must convert the table from Hybrid Columnar Compression to OLTP compression or an uncompressed format. To restore the table, do the following:</p>
<ol>
<li>
<p>Ensure there is sufficient storage in environment to hold the data in uncompressed or OLTP compression format.</p>
</li>
<li>
<p>Use RMAN to restore the Hybrid Columnar Compression tablespace.</p>
</li>
<li>
<p>Complete one of the following actions to convert the table from Hybrid Columnar Compression to OLTP compression or an uncompressed format:</p>
<ul>
<li>
<p>Use the following statement to change the data compression from Hybrid Columnar Compression to <code dir="ltr">COMPRESS FOR OLTP</code>:</p>
<pre dir="ltr">
ALTER TABLE <span class="codeinlineitalic">table_name</span> MOVE COMPRESS FOR OLTP;
</pre></li>
<li>
<p>Use the following statement to change the data compression from Hybrid Columnar Compression to <code dir="ltr">NOCOMPRESS</code>:</p>
<pre dir="ltr">
ALTER TABLE <span class="codeinlineitalic">table_name</span> MOVE NOCOMPRESS;
</pre></li>
<li>
<p>Use the following statement to change each partition to <code dir="ltr">NOCOMPRESS</code>:</p>
<pre dir="ltr">
ALTER TABLE <span class="codeinlineitalic">table_name</span> MOVE PARTITION <span class="codeinlineitalic">partition_name</span> NOCOMPRESS;
</pre>
<p>Change each partition separately.</p>
</li>
<li>
<p>Use the following statement to move the data to <code dir="ltr">NOCOMPRESS</code> in parallel:</p>
<pre dir="ltr">
ALTER TABLE <span class="codeinlineitalic">table_name</span> MOVE NOCOMPRESS PARALLEL;
</pre></li>
</ul>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See ALso:</p>
<ul>
<li>
<p><a class="olink BRADV89346" href="../../backup.112/e10642/rcmquick.htm#BRADV89346"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for additional information about RMAN</p>
</li>
<li>
<p><a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about the <code dir="ltr">ALTER TABLE</code> command</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN12894" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2155"></a>
<h4 class="sect3">Notes and Other Restrictions for Compressed Tables</h4>
<p>The following are notes and restrictions related to compressed tables:</p>
<ul>
<li>
<p>Online segment shrink is not supported for compressed tables.</p>
</li>
<li>
<p>The table compression methods described in this section do not apply to SecureFiles large objects (LOBs). SecureFiles LOBs have their own compression methods. See <a class="olink ADLOB4444" href="../../appdev.112/e18294/adlob_smart.htm#ADLOB4444"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for more information.</p>
</li>
<li>
<p>Compression technology uses CPU. Ensure that you have enough available CPU to handle the additional load.</p>
</li>
<li>
<p>Tables created with basic compression have the <code dir="ltr">PCT_FREE</code> parameter automatically set to <code dir="ltr">0</code> unless you specify otherwise.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADMIN13318" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2156"></a>
<h4 class="sect3">Packing Compressed Tables</h4>
<p>If you use conventional DML on a table compressed with basic compression or Hybrid Columnar Compression, then all inserted and updated rows are stored uncompressed or in a less-compressed format. To "pack" the compressed table so that these rows are compressed, use an <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">MOVE</code> statement. This operation takes an exclusive lock on the table, and therefore prevents any updates and loads until it completes. If this is not acceptable, then you can use online table redefinition.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for more details on the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code>...<code dir="ltr">COMPRESS</code>, <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">COMPRESS</code>, and <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">MOVE</code> statements, including restrictions</p>
</li>
<li>
<p><a class="olink VLDBG" href="../e25523/toc.htm"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information on table partitioning</p>
</li>
<li>
<p><a href="#i1009100">"Improving INSERT Performance with Direct-Path INSERT"</a></p>
</li>
<li>
<p><a href="#i1006754">"Redefining Tables Online"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJAGJDGF"></a>
<div id="ADMIN12330" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Consider Encrypting Columns <a id="sthref2157"></a><a id="sthref2158"></a>That Contain Sensitive Data</h3>
<p>You can encrypt individual table columns that contain sensitive data. Examples of sensitive data include social security numbers, credit card numbers, and medical records. Column encryption is transparent to your applications, with some restrictions.</p>
<p>Although encryption is not meant to solve all security problems, it does protect your data from users who try to circumvent the security features of the database and access database files directly through the operating system file system.</p>
<p><a id="sthref2159"></a><a id="sthref2160"></a><a id="sthref2161"></a>Column encryption uses the transparent data encryption feature of Oracle Database, which requires that you create an <span class="italic">Oracle wallet</span> to store the master encryption key for the database. The wallet must be open before you can create a table with encrypted columns and before you can store or retrieve encrypted data. When you open the wallet, it is available to all sessions, and it remains open until you explicitly close it or until the database is shut down.</p>
<p>Transparent data encryption supports industry-standard encryption algorithms, including the following Advanced Encryption Standard (AES) and Triple Data Encryption Standard (3DES) algorithms:</p>
<ul>
<li>
<p>AES256</p>
</li>
<li>
<p>AES192</p>
</li>
<li>
<p>AES128</p>
</li>
<li>
<p>3DES168</p>
</li>
</ul>
<p>You choose the algorithm to use when you create the table. All encrypted columns in the table use the same algorithm. The default is AES192. The encryption key length is implied by the algorithm name. For example, the AES128 algorithm uses 128-bit keys.</p>
<p>If you plan on encrypting many columns in one or more tables, you may want to consider encrypting an entire tablespace instead and storing these tables in that tablespace. Tablespace encryption, which also uses the transparent data encryption feature but encrypts at the physical block level, can perform better than encrypting many columns. Another reason to encrypt at the tablespace level is to address the following limitations of column encryption:</p>
<ul>
<li>
<p>If the <code dir="ltr">COMPATIBLE</code> initialization parameter set to 10.2.0, which is the minimum setting to enable transparent data encryption, data from encrypted columns that is involved in a sort or hash-join and that must be written to a temporary tablespace is written in clear text, and thus exposed to attacks. You must set <code dir="ltr">COMPATIBLE</code> to 11.1.0 or higher to ensure that encrypted data written to a temporary tablespace remains encrypted. Note that as long as <code dir="ltr">COMPATIBLE</code> is set to 10.2.0 or higher, data from encrypted columns remains encrypted when written to the undo tablespace or the redo log.</p>
</li>
<li>
<p>Certain data types, such as object data types, are not supported for column encryption.</p>
</li>
<li>
<p>You cannot use the transportable tablespace feature for a tablespace that includes tables with encrypted columns.</p>
</li>
<li>
<p>Other restrictions, which are detailed in <a class="olink ASOAG9518" href="../../network.112/e40393/asotrans.htm#ASOAG9518"><span class="italic">Oracle Database Advanced Security Administrator's Guide</span></a>.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="tspaces.htm#BABBJGAF">"Encrypted Tablespaces"</a></p>
</li>
<li>
<p><a href="#i1106369">"Example: Creating a Table"</a></p>
</li>
<li>
<p><a class="olink ASOAG600" href="../../network.112/e40393/asotrans.htm#ASOAG600"><span class="italic">Oracle Database Advanced Security Administrator's Guide</span></a> for more information about transparent data encryption and for instructions for creating and opening wallets</p>
</li>
<li>
<p><a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement</p>
</li>
<li>
<p><a class="olink RACAD510" href="../../rac.112/e41960/design.htm#RACAD510"><span class="italic">Oracle Real Application Clusters Administration and Deployment Guide</span></a> for information on using an Oracle wallet in an Oracle Real Application Clusters environment</p>
</li>
<li>
<p><a href="tspaces.htm#i1007169">"Transporting Tablespaces Between Databases"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="CHDGJAGB"></a>
<div id="ADMIN13319" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Understand Deferred Segment Creation<a id="sthref2162"></a><a id="sthref2163"></a></h3>
<p>Beginning with Oracle Database 11<span class="italic">g</span> Release 2, when you create heap-organized tables in a locally managed tablespace, the database defers table segment creation until the first row is inserted.</p>
<p>In addition, segment creation is deferred for any LOB columns of the table, any indexes created implicitly as part of table creation, and any indexes subsequently explicitly created on the table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In Release 11.2.0.1, deferred segment creation is not supported for partitioned tables. This restriction is removed in release 11.2.0.2 and later.</div>
<p>The advantages of this space allocation method are the following:</p>
<ul>
<li>
<p>It saves a significant amount of disk space in applications that create hundreds or thousands of tables upon installation, many of which might never be populated.</p>
</li>
<li>
<p>It reduces application installation time.</p>
</li>
</ul>
<p>There is a small performance penalty when the first row is inserted, because the new segment must be created at that time.</p>
<p>To enable deferred segment creation, compatibility must be set to '11.2.0' or higher.</p>
<p>The new clauses for the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement are:</p>
<ul>
<li>
<p><code dir="ltr">SEGMENT</code> <code dir="ltr">CREATION</code> <code dir="ltr">DEFERRED</code></p>
</li>
<li>
<p><code dir="ltr">SEGMENT</code> <code dir="ltr">CREATION</code> <code dir="ltr">IMMEDIATE</code></p>
</li>
</ul>
<p>These clauses override the default setting of the <code dir="ltr">DEFERRED_SEGMENT_CREATION</code> initialization parameter, <code dir="ltr">TRUE</code>, which defers segment creation. To disable deferred segment creation, set this parameter to <code dir="ltr">FALSE</code>.</p>
<p>Note that when you create a table with deferred segment creation, the new table appears in the <code dir="ltr">*_TABLES</code> views, but no entry for it appears in the <code dir="ltr">*_SEGMENTS</code> views until you insert the first row.</p>
<p>You can verify deferred segment creation by viewing the <code dir="ltr">SEGMENT_CREATED</code> column in <code dir="ltr">*_TABLES</code>, <code dir="ltr">*_INDEXES</code>, and <code dir="ltr">*_LOBS</code> views for nonpartitioned tables, and in <code dir="ltr">*_TAB_PARTITIONS</code>, <code dir="ltr">*_IND_PARTITIONS,</code> and <code dir="ltr">*_LOB_PARTITIONS</code> views for partitioned tables.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
With this new allocation method, it is essential that you do proper capacity planning so that the database has enough disk space to handle segment creation when tables are populated. See <a href="schema.htm#CHDFDCAH">"Capacity Planning for Database Objects"</a>.</div>
<p>The following example creates two tables to demonstrate deferred segment creation. The first table uses the <code dir="ltr">SEGMENT</code> <code dir="ltr">CREATION</code> <code dir="ltr">DEFERRED</code> clause. No segments are created for it initially. The second table uses the <code dir="ltr">SEGMENT</code> <code dir="ltr">CREATION</code> <code dir="ltr">IMMEDIATE</code> clause and, therefore, segments are created for it immediately.</p>
<pre dir="ltr">
CREATE TABLE part_time_employees (
    empno NUMBER(8),
    name VARCHAR2(30),
    hourly_rate NUMBER (7,2)
    )   
    SEGMENT CREATION DEFERRED;
 
CREATE TABLE hourly_employees (
    empno NUMBER(8),
    name VARCHAR2(30),
    hourly_rate NUMBER (7,2)
    ) 
   SEGMENT CREATION IMMEDIATE
   PARTITION BY RANGE(empno)
    (PARTITION empno_to_100 VALUES LESS THAN (100),
    PARTITION empno_to_200 VALUES LESS THAN (200));
</pre>
<p>The following query against <code dir="ltr">USER_SEGMENTS</code> returns two rows for <code dir="ltr">HOURLY_EMPLOYEES</code>, one for each partition, but returns no rows for <code dir="ltr">PART_TIME_EMPLOYEES because</code> segment creation for that table was deferred.</p>
<pre dir="ltr">
SELECT segment_name, partition_name FROM user_segments;
 
SEGMENT_NAME         PARTITION_NAME                                
-------------------- ------------------------------                             
HOURLY_EMPLOYEES     EMPNO_TO_100                       
HOURLY_EMPLOYEES     EMPNO_TO_200       
</pre>
<p>The <code dir="ltr">USER_TABLES</code> view shows that <code dir="ltr">PART_TIME_EMPLOYEES</code> has no segments:</p>
<pre dir="ltr">
SELECT table_name, segment_created FROM user_tables;
 
</pre>
<pre dir="ltr">
TABLE_NAME                     SEGMENT_CREATED
------------------------------ ----------------------------------------
PART_TIME_EMPLOYEES            NO
HOURLY_EMPLOYEES               N/A
</pre>
<p>For the <code dir="ltr">HOURLY_EMPLOYEES</code> table, which is partitioned, the <code dir="ltr">segment_created</code> column is <code dir="ltr">N/A</code> because the <code dir="ltr">USER_TABLES</code> view does not provide that information for partitioned tables. It is available from the <code dir="ltr">USER_TAB_PARTITIONS</code> view, shown below.</p>
<pre dir="ltr">
SELECT table_name, segment_created, partition_name
 FROM user_tab_partitions;

TABLE_NAME           SEGMENT_CREATED      PARTITION_NAME
-------------------- -------------------- ------------------------------
HOURLY_EMPLOYEES     YES                  EMPNO_TO_100
HOURLY_EMPLOYEES     YES                  EMPNO_TO_200
</pre>
<p>The following statements add employees to these tables.</p>
<pre dir="ltr">
INSERT INTO hourly_employees VALUES (99, 'FRose', 20.00);
INSERT INTO hourly_employees VALUES (150, 'LRose', 25.00);
 
INSERT INTO part_time_employees VALUES (50, 'KReilly', 10.00);
</pre>
<p>Repeating the same <code dir="ltr">SELECT</code> statements as before shows that <code dir="ltr">PART_TIME_EMPLOYEES</code> now has a segment, due to the insertion of row data. <code dir="ltr">HOURLY_EMPLOYEES</code> remains as before.</p>
<pre dir="ltr">
SELECT segment_name, partition_name FROM user_segments;
 
SEGMENT_NAME         PARTITION_NAME
-------------------- ------------------------------
PART_TIME_EMPLOYEES
HOURLY_EMPLOYEES     EMPNO_TO_100
HOURLY_EMPLOYEES     EMPNO_TO_200
</pre>
<pre dir="ltr">
SELECT table_name, segment_created FROM user_tables;
 
TABLE_NAME           SEGMENT_CREATED
-------------------- --------------------
PART_TIME_EMPLOYEES  YES
HOURLY_EMPLOYEES     N/A
                                         
</pre>
<p>The <code dir="ltr">USER_TAB_PARTITIONS</code> view does not change.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF54479" href="../../server.112/e41084/statements_7002.htm#SQLRF54479"><span class="italic">Oracle Database SQL Language Reference</span></a> for notes and restrictions on deferred segment creation</div>
</div>
<!-- class="sect2" -->
<a id="BABGHCEA"></a>
<div id="ADMIN13460" class="sect2">
<h3 class="sect2">Materializing Segments<a id="sthref2164"></a><a id="sthref2165"></a><a id="sthref2166"></a></h3>
<p>Beginning with Oracle Database 11<span class="italic">g</span> release 2 (11.2.0.2), the <code dir="ltr">DBMS_SPACE_ADMIN</code> package includes the <code dir="ltr">MATERIALIZE_DEFERRED_SEGMENTS()</code> procedure, which enables you to materialize segments for tables, table partitions, and dependent objects created with deferred segment creation enabled.</p>
<p>You can add segments as needed, rather than starting with more than you need and using database resources unnecessarily.</p>
<p>The following example materializes segments for the <code dir="ltr">EMPLOYEES</code> table in the <code dir="ltr">HR</code> schema.</p>
<pre dir="ltr">
BEGIN
  DBMS_SPACE_ADMIN.MATERIALIZE_DEFERRED_SEGMENTS(
    schema_name  =&gt; 'HR',
    table_name   =&gt; 'EMPLOYEES');
END;
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS73095" href="../../appdev.112/e40758/d_spadmn.htm#ARPLS73095"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details about this procedure</div>
</div>
<!-- class="sect2" -->
<a id="i1006276"></a>
<div id="ADMIN11631" class="sect2">
<h3 class="sect2">Estimate Table Size and Plan Accordingly</h3>
<p><a id="sthref2167"></a><a id="sthref2168"></a>Estimate the sizes of tables before creating them. Preferably, do this as part of database planning. Knowing the sizes, and uses, for database tables is an important part of database planning.</p>
<p>You can use the combined estimated size of tables, along with estimates for indexes, undo space, and redo log files, to determine the amount of disk space that is required to hold an intended database. From these estimates, you can make correct hardware purchases.</p>
<p>You can use the estimated size and growth rate of an individual table to better determine the attributes of a tablespace and its underlying data files that are best suited for the table. This can enable you to more easily manage the table disk space and improve I/O performance of applications that use the table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="schema.htm#CHDFDCAH">"Capacity Planning for Database Objects"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1006310"></a>
<div id="ADMIN11632" class="sect2">
<h3 class="sect2">Restrictions to Consider When Creating Tables<a id="sthref2169"></a></h3>
<p>Here are some restrictions that may affect your table planning and usage:</p>
<ul>
<li>
<p>Tables containing object types cannot be imported into a pre-Oracle8 database.</p>
</li>
<li>
<p>You cannot merge an exported table into a preexisting table having the same name in a different schema.</p>
</li>
<li>
<p>You cannot move types and extent tables to a different schema when the original data still exists in the database.</p>
</li>
<li>
<p>Oracle Database has a limit on the total number of columns that a table (or attributes that an object type) can have. See <a class="olink REFRN004" href="../../server.112/e40402/limits.htm#REFRN004"><span class="italic">Oracle Database Reference</span></a> for this limit.</p>
<p>Further, when you create a table that contains user-defined type data, the database maps columns of user-defined type to relational columns for storing the user-defined type data. This causes additional relational columns to be created. This results in "hidden" relational columns that are not visible in a <code dir="ltr">DESCRIBE</code> table statement and are not returned by a <code dir="ltr">SELECT *</code> statement. Therefore, when you create an object table, or a relational table with columns of <code dir="ltr">REF</code>, varray, nested table, or object type, be aware that the total number of columns that the database actually creates for the table can be more than those you specify.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADOBJ" href="../../appdev.112/e11822/toc.htm"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for more information about user-defined types</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1106335"></a>
<div id="ADMIN01503" class="sect1">
<h2 class="sect1">Creating Tables</h2>
<p><a id="sthref2170"></a>To create a new table in your schema, you must have the <code dir="ltr">CREATE TABLE</code> system privilege. To create a table in another user's schema, you must have the <code dir="ltr">CREATE ANY TABLE</code> system privilege. Additionally, the owner of the table must have a quota for the tablespace that contains the table, or the <code dir="ltr">UNLIMITED TABLESPACE</code> system privilege.</p>
<p><a id="sthref2171"></a>Create tables using the SQL statement <code dir="ltr">CREATE TABLE</code>.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1106369">Example: Creating a Table</a></p>
</li>
<li>
<p><a href="#i1006400">Creating a Temporary Table</a></p>
</li>
<li>
<p><a href="#i1009052">Parallelizing Table Creation</a></p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for exact syntax of the <code dir="ltr">CREATE TABLE</code> and other SQL statements discussed in this chapter</div>
</li>
</ul>
<a id="i1106369"></a>
<div id="ADMIN11004" class="sect2">
<h3 class="sect2">Example: <a id="sthref2172"></a>Creating a Table</h3>
<p>When you issue the following statement, you create a table named <code dir="ltr">admin_emp</code> in the <code dir="ltr">hr</code> schema and store it in the <code dir="ltr">admin_tbs</code> tablespace:</p>
<pre dir="ltr">
CREATE TABLE hr.admin_emp (
         empno      NUMBER(5) PRIMARY KEY,
         ename      VARCHAR2(15) NOT NULL,
         ssn        NUMBER(9) ENCRYPT USING 'AES256',
         job        VARCHAR2(10),
         mgr        NUMBER(5),
         hiredate   DATE DEFAULT (sysdate),
         photo      BLOB,
         sal        NUMBER(7,2),
         hrly_rate  NUMBER(7,2) GENERATED ALWAYS AS (sal/2080),
         comm       NUMBER(7,2),
         deptno     NUMBER(3) NOT NULL
                     CONSTRAINT admin_dept_fkey REFERENCES hr.departments
                     (department_id))
   TABLESPACE admin_tbs
   STORAGE ( INITIAL 50K);

COMMENT ON TABLE hr.admin_emp IS 'Enhanced employee table';
</pre>
<p>Note the following about this example:</p>
<ul>
<li>
<p>Integrity constraints are defined on several columns of the table.</p>
</li>
<li>
<p>The <code dir="ltr">STORAGE</code> clause specifies the size of the first extent. See <a class="olink SQLRF30013" href="../../server.112/e41084/clauses009.htm#SQLRF30013"><span class="italic">Oracle Database SQL Language Reference</span></a> for details on this clause.</p>
</li>
<li>
<p>Encryption is defined on one column (<code dir="ltr">ssn</code>), through the transparent data encryption feature of Oracle Database. The Oracle Wallet must therefore be open for this <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement to succeed.</p>
</li>
<li>
<p>The <code dir="ltr">photo</code> column is of data type <code dir="ltr">BLOB</code>, which is a member of the set of data types called <a id="sthref2173"></a><a id="sthref2174"></a><a id="sthref2175"></a>large objects (LOBs). LOBs are used to store semi-structured data (such as an XML tree) and unstructured data (such as the stream of bits in a color image).</p>
</li>
<li>
<p>One column is defined as a virtual column (<code dir="ltr">hrly_rate</code>). This column computes the employee's hourly rate as the yearly salary divided by 2,080. See <a class="olink SQLRF54465" href="../../server.112/e41084/statements_7002.htm#SQLRF54465"><span class="italic">Oracle Database SQL Language Reference</span></a> for a discussion of rules for virtual columns.</p>
</li>
<li>
<p>A <code dir="ltr">COMMENT</code> statement is used to store a comment for the table. You query the <code dir="ltr">*_TAB_COMMENTS</code> data dictionary views to retrieve such comments. See <a class="olink SQLRF01109" href="../../server.112/e41084/statements_4009.htm#SQLRF01109"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF0021" href="../../server.112/e41084/sql_elements001.htm#SQLRF0021"><span class="italic">Oracle Database SQL Language Reference</span></a> for a description of the data types that you can specify for table columns</p>
</li>
<li>
<p><a href="general.htm#i1006599">"Managing Integrity Constraints"</a></p>
</li>
<li>
<p><a class="olink ASOAG600" href="../../network.112/e40393/asotrans.htm#ASOAG600"><span class="italic">Oracle Database Advanced Security Administrator's Guide</span></a> for information about transparent data encryption and the Oracle Wallet</p>
</li>
<li>
<p><a class="olink ADLOB" href="../../appdev.112/e18294/toc.htm"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for more information about LOBs.</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1006400"></a>
<div id="ADMIN11633" class="sect2">
<h3 class="sect2">Creating a Temporary Table</h3>
<p>Temporary tables<a id="sthref2176"></a><a id="sthref2177"></a><a id="sthref2178"></a> are useful in applications where a result set is to be buffered (temporarily persisted), perhaps because it is constructed by running multiple DML operations. For example, consider the following:</p>
<p>A Web-based airlines reservations application allows a customer to create several optional itineraries. Each itinerary is represented by a row in a temporary table. The application updates the rows to reflect changes in the itineraries. When the customer decides which itinerary she wants to use, the application moves the row for that itinerary to a persistent table.</p>
<p>During the session, the itinerary data is private. At the end of the session, the optional itineraries are dropped.</p>
<p>The definition of a temporary table is visible to all sessions, but the data in a temporary table is visible only to the session that inserts the data into the table.</p>
<p>Use the <code dir="ltr">CREATE GLOBAL TEMPORARY TABLE</code> statement to create a temporary table. The <code dir="ltr">ON COMMIT</code> clause indicates if the data in the table is <span class="bold">transaction-specific</span> (the default) or <span class="bold">session-specific</span>, the implications of which are as follows:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Transaction- and Session-Specific Tables" summary="Column 1 lists the ON COMMIT clause settings, column 2 describes the implications of that setting." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t22">ON COMMIT Setting</th>
<th class="cellalignment1334" id="r1c2-t22">Implications</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t22" headers="r1c1-t22"><code dir="ltr">DELETE ROWS</code></td>
<td class="cellalignment1335" headers="r2c1-t22 r1c2-t22">This creates a temporary table that is transaction specific. A session becomes bound to the temporary table with a transactions first insert into the table. The binding goes away at the end of the transaction. The database truncates the table (delete all rows) after each commit.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t22" headers="r1c1-t22"><code dir="ltr">PRESERVE ROWS</code></td>
<td class="cellalignment1335" headers="r3c1-t22 r1c2-t22">This creates a temporary table that is session specific. A session gets bound to the temporary table with the first insert into the table in the session. This binding goes away at the end of the session or by issuing a <code dir="ltr">TRUNCATE</code> of the table in the session. The database truncates the table when you terminate the session.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>This statement creates a temporary table that is transaction specific:</p>
<pre dir="ltr">
CREATE GLOBAL TEMPORARY TABLE admin_work_area
        (startdate DATE,
         enddate DATE,
         class CHAR(20))
      ON COMMIT DELETE ROWS;
</pre>
<p>Indexes can be created on temporary tables. They are also temporary and the data in the index has the same session or transaction scope as the data in the underlying table.</p>
<p><a id="sthref2179"></a>By default, rows in a temporary table are stored in the default temporary tablespace of the user who creates it. However, you can assign a temporary table to another tablespace upon creation of the temporary table by using the <code dir="ltr">TABLESPACE</code> clause of <code dir="ltr">CREATE GLOBAL TEMPORARY TABLE</code>. You can use this feature to conserve space used by temporary tables. For example, if you must perform many small temporary table operations and the default temporary tablespace is configured for sort operations and thus uses a large extent size, these small operations will consume lots of unnecessary disk space. In this case it is better to allocate a second temporary tablespace with a smaller extent size.</p>
<p>The following two statements create a temporary tablespace with a 64 KB extent size, and then a new temporary table in that tablespace.</p>
<pre dir="ltr">
CREATE TEMPORARY TABLESPACE tbs_t1 
    TEMPFILE 'tbs_t1.f' SIZE 50m REUSE AUTOEXTEND ON
    MAXSIZE UNLIMITED
    EXTENT MANAGEMENT LOCAL UNIFORM SIZE 64K;

CREATE GLOBAL TEMPORARY TABLE admin_work_area
        (startdate DATE,
         enddate DATE,
         class CHAR(20))
      ON COMMIT DELETE ROWS
      TABLESPACE tbs_t1;
</pre>
<div class="infobox-note">
<p class="notep1">See Also:</p>
<a href="tspaces.htm#i1013552">"Temporary Tablespaces"</a></div>
<p>Unlike permanent tables, temporary tables and their indexes do not automatically allocate a segment when they are created. Instead, segments are allocated when the first <code dir="ltr">INSERT</code> (or <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> <code dir="ltr">AS</code> <code dir="ltr">SELECT</code>) is performed. Therefore, if a <code dir="ltr">SELECT</code>, <code dir="ltr">UPDATE</code>, or <code dir="ltr">DELETE</code> is performed before the first <code dir="ltr">INSERT</code>, then the table appears to be empty.</p>
<p>DDL operations (except <code dir="ltr">TRUNCATE</code>) are allowed on an existing temporary table only if no session is currently bound to that temporary table.</p>
<p>If you rollback a transaction, the data you entered is lost, although the table definition persists.</p>
<p>A transaction-specific temporary table allows only one transaction at a time. If there are several autonomous transactions in a single transaction scope, each autonomous transaction can use the table only as soon as the previous one commits.</p>
<p>Because the data in a temporary table is, by definition, temporary, backup and recovery of temporary table data is not available in the event of a system failure. To prepare for such a failure, you should develop alternative methods for preserving temporary table data.</p>
</div>
<!-- class="sect2" -->
<a id="i1009052"></a>
<div id="ADMIN11634" class="sect2">
<h3 class="sect2">Parallelizing Table Creation<a id="sthref2180"></a><a id="sthref2181"></a></h3>
<p>When you specify the <code dir="ltr">AS SELECT</code> clause to create a table and populate it with data from another table, you can use parallel execution. The <code dir="ltr"><a id="sthref2182"></a><a id="sthref2183"></a>CREATE TABLE...AS SELECT</code> statement contains two parts: a <code dir="ltr">CREATE</code> part (DDL) and a <code dir="ltr">SELECT</code> part (query). Oracle Database can parallelize both parts of the statement. The <code dir="ltr">CREATE</code> part is parallelized if <span class="italic">one</span> of the following is true:</p>
<ul>
<li>
<p>A <code dir="ltr">PARALLEL</code> clause is included in the <code dir="ltr">CREATE TABLE...AS SELECT</code> statement</p>
</li>
<li>
<p>An <code dir="ltr">ALTER SESSION FORCE PARALLEL DDL</code> statement is specified</p>
</li>
</ul>
<p>The query part is parallelized if <span class="italic">all</span> of the following are true:</p>
<ul>
<li>
<p>The query includes a parallel hint specification (<code dir="ltr">PARALLEL</code> or <code dir="ltr">PARALLEL_INDEX</code>) <span class="italic">or</span> the <code dir="ltr">CREATE</code> part includes the <code dir="ltr">PARALLEL</code> clause <span class="italic">or</span> the schema objects referred to in the query have a <code dir="ltr">PARALLEL</code> declaration associated with them.</p>
</li>
<li>
<p>At least one of the tables specified in the query requires either a full table scan <span class="italic">or</span> an index range scan spanning multiple partitions.</p>
</li>
</ul>
<p>If you parallelize the creation of a table, that table then has a parallel declaration (the <code dir="ltr">PARALLEL</code> clause) associated with it. Any subsequent DML or queries on the table, for which parallelization is possible, will attempt to use parallel execution.</p>
<p>The following simple statement parallelizes the creation of a table and stores the result in a compressed format, using table compression:</p>
<pre dir="ltr">
CREATE TABLE hr.admin_emp_dept
     PARALLEL COMPRESS
     AS SELECT * FROM hr.employees
     WHERE department_id = 10;
</pre>
<p>In this case, the <code dir="ltr">PARALLEL</code> clause tells the database to select an optimum number of parallel execution servers when creating the table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink VLDBG010" href="../../server.112/e25523/parallel.htm#VLDBG010"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for detailed information on using parallel execution</p>
</li>
<li>
<p><a href="manproc.htm#i1010373">"Managing Processes for Parallel SQL Execution"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="CJAEJGJF"></a>
<div id="ADMIN11635" class="sect1"><!-- infolevel="all" infotype="General" -->
<h2 class="sect1">Loading Tables</h2>
<p>This section describes techniques for loading data into tables. In contains the following topics:</p>
<ul>
<li>
<p><a href="#CIHFFFBC">Methods for Loading Tables</a></p>
</li>
<li>
<p><a href="#i1009100">Improving INSERT Performance with Direct-Path INSERT</a></p>
</li>
<li>
<p><a href="#BABBFGEI">Using Conventional Inserts to Load Tables</a></p>
</li>
<li>
<p><a href="#InsertDMLErrorLogging">Avoiding Bulk INSERT Failures with DML Error Logging</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
Beginning with release 11.2.0.2 of Oracle Database, the default size of the first extent of any new segment for a partitioned table is 8 MB instead of 64 KB. This helps improve performance of inserts and queries on partitioned tables. Although partitioned tables will start with a larger initial size, once sufficient data is inserted, the space consumption will be the same as in previous releases. You can override this default by setting the <code dir="ltr">INITIAL</code> size in the storage clause for the table. This new default only applies to table partitions and LOB partitions.</div>
<a id="CIHFFFBC"></a>
<div id="ADMIN13461" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Methods for Loading Tables</h3>
<p>There are several means of inserting or initially loading data into your tables. Most commonly used are the following:</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Methods of Inserting Data" summary="Column 1 lists the methods of inserting data into tables, column 2 describes each method." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t26">Method</th>
<th class="cellalignment1334" id="r1c2-t26">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t26" headers="r1c1-t26">SQL*Loader</td>
<td class="cellalignment1335" headers="r2c1-t26 r1c2-t26">This Oracle utility program loads data from external files into tables of an Oracle Database.
<p>For information about SQL*Loader, see <a class="olink SUTIL003" href="../../server.112/e22490/ldr_concepts.htm#SUTIL003"><span class="italic">Oracle Database Utilities</span></a>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t26" headers="r1c1-t26"><a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><code dir="ltr">CREATE TABLE</code> ... <code dir="ltr">AS SELECT</code></a> statement (CTAS)</td>
<td class="cellalignment1335" headers="r3c1-t26 r1c2-t26">Using this SQL statement you can create a table and populate it with data selected from another existing table, including an external table.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t26" headers="r1c1-t26"><a class="olink SQLRF01604" href="../../server.112/e41084/statements_9014.htm#SQLRF01604"><code dir="ltr">INSERT</code></a> statement</td>
<td class="cellalignment1335" headers="r4c1-t26 r1c2-t26">The <code dir="ltr">INSERT</code> statement enables you to add rows to a table, either by specifying the column values or by specifying a subquery that selects data from another existing table, including an external table.
<p>One form of the <code dir="ltr">INSERT</code> statement enables direct-path <code dir="ltr">INSERT</code>, which can improve performance, and is useful for bulk loading. See <a href="#i1009100">"Improving INSERT Performance with Direct-Path INSERT"</a>.</p>
<p>If you are inserting a lot of data and want to avoid statement termination and rollback if an error is encountered, you can insert with DML error logging. See <a href="#InsertDMLErrorLogging">"Avoiding Bulk INSERT Failures with DML Error Logging"</a>.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t26" headers="r1c1-t26"><a class="olink SQLRF01606" href="../../server.112/e41084/statements_9016.htm#SQLRF01606"><code dir="ltr">MERGE</code></a> statement</td>
<td class="cellalignment1335" headers="r5c1-t26 r1c2-t26">The <code dir="ltr">MERGE</code> statement enables you to insert rows into or update rows of a table, by selecting rows from another existing table. If a row in the new data corresponds to an item that already exists in the table, then an <code dir="ltr">UPDATE</code> is performed, else an <code dir="ltr">INSERT</code> is performed.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p>See <a class="olink SQLRF" href="../e41084/toc.htm"><span class="italic">Oracle Database SQL Language Reference</span></a> for details on the <code dir="ltr">CREATE TABLE</code> ... <code dir="ltr">AS SELECT</code>, <code dir="ltr">INSERT</code>, and <code dir="ltr">MERGE</code> statements.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Only a few details and examples of inserting data into tables are included in this book. Oracle documentation specific to data warehousing and application development provide more extensive information about inserting and manipulating data in tables. See:
<ul>
<li>
<p><a class="olink DWHSG8270" href="../../server.112/e25554/part4.htm#DWHSG8270"><span class="italic">Oracle Database Data Warehousing Guide</span></a></p>
</li>
<li>
<p><a class="olink ADLOB45151" href="../../appdev.112/e18294/adlob_managing.htm#ADLOB45151"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a></p>
</li>
</ul>
</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1007424">"Managing External Tables"</a></div>
</div>
<!-- class="sect2" -->
<a id="i1009100"></a>
<div id="ADMIN01509" class="sect2">
<h3 class="sect2">Improving INSERT Performance with Direct-Path INSERT</h3>
<p>When loading large amounts of data, you can improve load performance by using direct-path <code dir="ltr">INSERT</code>.</p>
<p>This section contains:</p>
<ul>
<li>
<p><a href="#i1009864">About Direct-Path INSERT</a></p>
</li>
<li>
<p><a href="#i1009877">How Direct-Path INSERT Works</a></p>
</li>
<li>
<p><a href="#i1009872">Loading Data with Direct-Path INSERT</a></p>
</li>
<li>
<p><a href="#i1009882">Specifying the Logging Mode for Direct-Path INSERT</a></p>
</li>
<li>
<p><a href="#i1009887">Additional Considerations for Direct-Path INSERT</a></p>
</li>
</ul>
<a id="i1009864"></a>
<div id="ADMIN11643" class="sect3">
<h4 class="sect3">About Direct-Path INSERT</h4>
<p>Oracle Database inserts data into a table in one of two ways:</p>
<ul>
<li>
<p>During <span class="bold">conventional INSERT operations</span>, the database reuses free space in the table, interleaving newly inserted data with existing data. During such operations, the database also maintains referential integrity constraints.</p>
</li>
<li>
<p>During <span class="bold">direct-path INSERT operations</span>, the database appends the inserted data after existing data in the table. Data is written directly into data files, bypassing the buffer cache. Free space in the table is not reused, and referential integrity constraints are ignored. Direct-path <code dir="ltr">INSERT</code> can perform significantly better than conventional insert.</p>
</li>
</ul>
<p>The database can insert data either in serial mode, where one process executes the statement, or in parallel mode, where multiple processes work together simultaneously to run a single SQL statement. The latter is referred to as parallel execution.</p>
<p>The following are benefits of <a id="sthref2184"></a>direct-path <code dir="ltr">INSERT</code>:</p>
<ul>
<li>
<p>During direct-path <code dir="ltr">INSERT</code>, you can disable the logging of redo and undo entries to reduce load time. Conventional insert operations, in contrast, must always log such entries, because those operations reuse free space and maintain referential integrity.</p>
</li>
<li>
<p><a id="sthref2185"></a>Direct-path <code dir="ltr">INSERT</code> operations ensure atomicity of the transaction, even when run in parallel mode. Atomicity cannot be guaranteed during parallel direct-path loads (using SQL*Loader).</p>
</li>
</ul>
<p>When performing parallel direct-path loads, one notable difference between SQL*Loader and <code dir="ltr">INSERT</code> statements is the following: If errors occur during parallel direct-path loads with SQL*Loader, the load completes, but some indexes could be marked <code dir="ltr">UNUSABLE</code> at the end of the load. Parallel direct-path <code dir="ltr">INSERT</code>, in contrast, rolls back the statement if errors occur during index update.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
A conventional <code dir="ltr">INSERT</code> operation checks for violations of <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints during the insert. Therefore, if a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint is violated for a conventional <code dir="ltr">INSERT</code> operation, then the error is returned during the insert. A direct-path <code dir="ltr">INSERT</code> operation checks for violations of <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraints before the insert. Therefore, if a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint is violated for a direct-path <code dir="ltr">INSERT</code> operation, then the error is returned before the insert.</div>
</div>
<!-- class="sect3" -->
<a id="i1009877"></a>
<div id="ADMIN11645" class="sect3">
<h4 class="sect3">How Direct-Path INSERT Works</h4>
<p>You can use <a id="sthref2186"></a>direct-path <code dir="ltr">INSERT</code> on both partitioned and nonpartitioned tables.</p>
<div id="ADMIN11646" class="sect4"><a id="sthref2187"></a>
<h5 class="sect4">Serial Direct-Path INSERT into Partitioned or Nonpartitioned Tables</h5>
<p>The single process inserts data beyond the current high water mark of the table segment or of each partition segment. (The <span class="glossaryterm">high-water mark</span> is the level at which blocks have never been formatted to receive data.) When a <code dir="ltr">COMMIT</code> runs, the high-water mark is updated to the new value, making the data visible to users.</p>
</div>
<!-- class="sect4" -->
<div id="ADMIN11647" class="sect4"><a id="sthref2188"></a>
<h5 class="sect4">Parallel Direct-Path INSERT into Partitioned Tables</h5>
<p>This situation is analogous to serial direct-path <code dir="ltr">INSERT</code>. Each parallel execution server is assigned one or more partitions, with no more than one process working on a single partition. Each parallel execution server inserts data beyond the current high-water mark of its assigned partition segment(s). When a <code dir="ltr">COMMIT</code> runs, the high-water mark of each partition segment is updated to its new value, making the data visible to users.</p>
</div>
<!-- class="sect4" -->
<a id="i1009688"></a>
<div id="ADMIN11648" class="sect4">
<h5 class="sect4">Parallel Direct-Path INSERT into Nonpartitioned Tables</h5>
<p>Each parallel execution server allocates a new temporary segment and inserts data into that temporary segment. When a <code dir="ltr">COMMIT</code> runs, the parallel execution coordinator merges the new temporary segments into the primary table segment, where it is visible to users.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1009872"></a>
<div id="ADMIN11644" class="sect3">
<h4 class="sect3">Loading Data with Direct-Path INSERT</h4>
<p>You can load data with direct-path <code dir="ltr">INSERT</code> by using direct-path <code dir="ltr">INSERT</code> SQL statements, inserting data in parallel mode, or by using the Oracle SQL*Loader utility in direct-path mode. A direct-path <code dir="ltr">INSERT</code> can be done in either serial or parallel mode.</p>
<div id="ADMIN13320" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2189"></a>
<h5 class="sect4">Serial Mode Inserts with SQL Statements</h5>
<p>You can activate direct-path <code dir="ltr">INSERT</code> in serial mode with SQL in the following ways:</p>
<ul>
<li>
<p>If you are performing an <code dir="ltr">INSERT</code> with a subquery, specify the <code dir="ltr">APPEND</code> hint in each <code dir="ltr">INSERT</code> statement, either immediately after the <code dir="ltr">INSERT</code> keyword, or immediately after the <code dir="ltr">SELECT</code> keyword in the subquery of the <code dir="ltr">INSERT</code> statement.</p>
</li>
<li>
<p>If you are performing an <code dir="ltr">INSERT</code> with the <code dir="ltr">VALUES</code> clause, specify the <code dir="ltr">APPEND_VALUES</code> hint in each <code dir="ltr">INSERT</code> statement immediately after the <code dir="ltr">INSERT</code> keyword. Direct-path <code dir="ltr">INSERT</code> with the <code dir="ltr">VALUES</code> clause is best used when there are hundreds of thousands or millions of rows to load. The typical usage scenario is for array inserts using OCI. Another usage scenario might be inserts in a <code dir="ltr">FORALL</code> statement in PL/SQL.</p>
</li>
</ul>
<p>If you specify the <code dir="ltr">APPEND</code> hint (as opposed to the <code dir="ltr">APPEND_VALUES</code> hint) in an <code dir="ltr">INSERT</code> statement with a <code dir="ltr">VALUES</code> clause, the <code dir="ltr">APPEND</code> hint is ignored and a conventional insert is performed.</p>
<p>The following is an example of using the <code dir="ltr">APPEND</code> hint to perform a direct-path <code dir="ltr">INSERT</code>:</p>
<pre dir="ltr">
INSERT /*+ APPEND */ INTO sales_hist SELECT * FROM sales WHERE cust_id=8890;
</pre>
<p>The following PL/SQL code fragment is an example of using the <code dir="ltr">APPEND_VALUES</code> hint:</p>
<pre dir="ltr">
FORALL i IN 1..numrecords
  INSERT /*+ APPEND_VALUES */ INTO orderdata 
  VALUES(ordernum(i), custid(i), orderdate(i),shipmode(i), paymentid(i));
COMMIT;
</pre></div>
<!-- class="sect4" -->
<div id="ADMIN13321" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2190"></a>
<h5 class="sect4">Parallel Mode Inserts with SQL Statements</h5>
<p><a id="sthref2191"></a>When you are inserting in parallel mode, direct-path <code dir="ltr">INSERT</code> is the default. However, you can insert in parallel mode using conventional <code dir="ltr">INSERT</code> by using the <code dir="ltr">NOAPPEND</code> <code dir="ltr">PARALLEL</code> hint.</p>
<p>To run in parallel DML mode, the following requirements must be met:</p>
<ul>
<li>
<p>You must have Oracle Enterprise Edition installed.</p>
</li>
<li>
<p>You must enable parallel DML in your session. To do this, submit the following statement:</p>
<pre dir="ltr">
ALTER SESSION { ENABLE | FORCE } PARALLEL DML;
</pre></li>
<li>
<p>You must meet at least one of the following requirements:</p>
<ul>
<li>
<p>Specify the parallel attribute for the target table, either at create time or subsequently</p>
</li>
<li>
<p>Specify the <code dir="ltr">PARALLEL</code> hint for each insert operation</p>
</li>
<li>
<p>Set the database initialization parameter <code dir="ltr">PARALLEL_DEGREE_POLICY</code> to <code dir="ltr">AUTO</code></p>
</li>
</ul>
</li>
</ul>
<p>To disable direct-path <code dir="ltr">INSERT</code>, specify the <code dir="ltr">NOAPPEND</code> hint in each <code dir="ltr">INSERT</code> statement. Doing so overrides parallel DML mode.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You cannot query or modify data inserted using direct-path <code dir="ltr">INSERT</code> immediately after the insert is complete. If you attempt to do so, an ORA-12838<a id="sthref2192"></a> error is generated. You must first issue a <code dir="ltr">COMMIT</code> statement before attempting to read or modify the newly-inserted data.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="#BABBFGEI">"Using Conventional Inserts to Load Tables"</a></p>
</li>
<li>
<p><a class="olink PFGRF005" href="../../server.112/e41573/hintsref.htm#PFGRF005"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information on using hints</p>
</li>
<li>
<p><a class="olink SQLRF01604" href="../../server.112/e41084/statements_9014.htm#SQLRF01604"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information on the subquery syntax of <code dir="ltr">INSERT</code> statements and for additional restrictions on using direct-path <code dir="ltr">INSERT</code></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1009882"></a>
<div id="ADMIN11649" class="sect3">
<h4 class="sect3">Specifying the Logging Mode for Direct-Path INSERT</h4>
<p><a id="sthref2193"></a><a id="sthref2194"></a><a id="sthref2195"></a>Direct-path <code dir="ltr">INSERT</code> lets you choose whether to log redo and undo information during the insert operation.</p>
<ul>
<li>
<p>You can specify logging mode for a table, partition, index, or <code dir="ltr">LOB</code> storage at create time (in a <code dir="ltr">CREATE</code> statement) or subsequently (in an <code dir="ltr">ALTER</code> statement).</p>
</li>
<li>
<p>If you do not specify either <code dir="ltr">LOGGING</code> or <code dir="ltr">NOLOGGING</code> at these times:</p>
<ul>
<li>
<p>The logging attribute of a partition defaults to the logging attribute of its table.</p>
</li>
<li>
<p>The logging attribute of a table or index defaults to the logging attribute of the tablespace in which it resides.</p>
</li>
<li>
<p>The logging attribute of <code dir="ltr">LOB</code> storage defaults to <code dir="ltr">LOGGING</code> if you specify <code dir="ltr">CACHE</code> for <code dir="ltr">LOB</code> storage. If you do not specify <code dir="ltr">CACHE</code>, then the logging attributes defaults to that of the tablespace in which the <code dir="ltr">LOB</code> values resides.</p>
</li>
</ul>
</li>
<li>
<p>You set the logging attribute of a tablespace in a <code dir="ltr">CREATE</code> <code dir="ltr">TABLESPACE</code> or <code dir="ltr">ALTER</code> <code dir="ltr">TABLESPACE</code> statements.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the database or tablespace is in <code dir="ltr">FOR<a id="sthref2196"></a>CE</code> <code dir="ltr">LOGGING</code> mode, then direct path <code dir="ltr">INSERT</code> always logs, regardless of the logging setting.</div>
</li>
</ul>
<div id="ADMIN11650" class="sect4"><a id="sthref2197"></a>
<h5 class="sect4"><a id="sthref2198"></a><a id="sthref2199"></a>Direct-Path INSERT with Logging</h5>
<p>In this mode, Oracle Database performs full redo logging for instance and media recovery. If the database is in <code dir="ltr">ARCHIVELOG</code> mode, then you can archive redo logs to tape. If the database is in <code dir="ltr">NOARCHIVELOG</code> mode, then you can recover instance crashes but not disk failures.</p>
</div>
<!-- class="sect4" -->
<a id="CIHGHAAC"></a>
<div id="ADMIN13485" class="sect4">
<h5 class="sect4">Direct-Path INSERT without Logging</h5>
<p>In this mode, Oracle Database inserts data without redo or undo logging. Instead, the database logs a small number of block range invalidation redo records and periodically updates the control file with information about the most recent direct write.</p>
<p>Direct-path <code dir="ltr">INSERT</code> without logging improves performance. However, if you subsequently must perform media recovery, the invalidation redo records mark a range of blocks as logically corrupt, because no redo data was logged for them. Therefore, it is important that you back up the data after such an insert operation.</p>
<p>Beginning with release 11.2.0.2 of Oracle Database, you can significantly improve the performance of unrecoverable direct path inserts by disabling the periodic update of the control files. You do so by setting the initialization parameter <a id="sthref2200"></a><code dir="ltr">DB_UNRECOVERABLE_SCN_TRACKING</code> to <code dir="ltr">FALSE</code>. However, if you perform an unrecoverable direct path insert with these control file updates disabled, you will no longer be able to accurately query the database to determine if any data files are currently unrecoverable.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink BRADV89598" href="../../backup.112/e10642/rcmreprt.htm#BRADV89598"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about unrecoverable data files</p>
</li>
<li>
<p>The section "Determining If a Backup Is Required After Unrecoverable Operations" in <a class="olink SBYDB4896" href="../../server.112/e41134/scenarios.htm#SBYDB4896"><span class="italic">Oracle Data Guard Concepts and Administration</span></a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="i1009887"></a>
<div id="ADMIN11652" class="sect3">
<h4 class="sect3">Additional Considerations for Direct-Path INSERT</h4>
<p>The following are some additional considerations when using direct-path <code dir="ltr">INSERT</code>.</p>
<div id="ADMIN12633" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2201"></a>
<h5 class="sect4">Compressed Tables</h5>
<p>If a table is created with the basic compression, then you must use direct-path <code dir="ltr">INSERT</code> to compress table data as it is loaded. If a table is created with OLTP, warehouse, or archive compression, then best compression ratios are achieved with direct-path <code dir="ltr">INSERT</code>.</p>
<p>See <a href="#CJAGFBFG">"Consider Using Table Compression"</a> for more information.</p>
</div>
<!-- class="sect4" -->
<div id="ADMIN11653" class="sect4"><a id="sthref2202"></a>
<h5 class="sect4"><a id="sthref2203"></a><a id="sthref2204"></a>Index Maintenance with Direct-Path INSERT</h5>
<p>Oracle Database performs index maintenance at the end of direct-path <code dir="ltr">INSERT</code> operations on tables (partitioned or nonpartitioned) that have indexes. This index maintenance is performed by the parallel execution servers for parallel direct-path <code dir="ltr">INSERT</code> or by the single process for serial direct-path <code dir="ltr">INSERT</code>. You can avoid the performance impact of index maintenance by making the index unusable before the <code dir="ltr">INSERT</code> operation and then rebuilding it afterward.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="indexes.htm#CIHJCEAJ">"Making an Index Unusable"</a></div>
</div>
<!-- class="sect4" -->
<div id="ADMIN11654" class="sect4"><a id="sthref2205"></a>
<h5 class="sect4"><a id="sthref2206"></a>Space Considerations with Direct-Path INSERT</h5>
<p>Direct-path <code dir="ltr">INSERT</code> requires more space than conventional-path <code dir="ltr">INSERT</code>.</p>
<p>All serial direct-path <code dir="ltr">INSERT</code> operations, as well as parallel direct-path <code dir="ltr">INSERT</code> into partitioned tables, insert data above the high-water mark of the affected segment. This requires some additional space.</p>
<p>Parallel direct-path <code dir="ltr">INSERT</code> into nonpartitioned tables requires even more space, because it creates a temporary segment for each degree of parallelism. If the nonpartitioned table is not in a locally managed tablespace in automatic segment-space management mode, you can modify the values of the <code dir="ltr">NEXT</code> and <code dir="ltr">PCTINCREASE</code> storage parameter and <code dir="ltr">MINIMUM</code> <code dir="ltr">EXTENT</code> tablespace parameter to provide sufficient (but not excess) storage for the temporary segments. Choose values for these parameters so that:</p>
<ul>
<li>
<p>The size of each extent is not too small (no less than 1 MB). This setting affects the total number of extents in the object.</p>
</li>
<li>
<p>The size of each extent is not so large that the parallel <code dir="ltr">INSERT</code> results in wasted space on segments that are larger than necessary.</p>
</li>
</ul>
<p>After the direct-path <code dir="ltr">INSERT</code> operation is complete, you can reset these parameters to settings more appropriate for serial operations.</p>
</div>
<!-- class="sect4" -->
<div id="ADMIN11655" class="sect4"><a id="sthref2207"></a>
<h5 class="sect4"><a id="sthref2208"></a>Locking Considerations with Direct-Path INSERT</h5>
<p>During direct-path <code dir="ltr">INSERT</code>, the database obtains exclusive locks on the table (or on all partitions of a partitioned table). As a result, users cannot perform any concurrent insert, update, or delete operations on the table, and concurrent index creation and build operations are not permitted. Concurrent queries, however, are supported, but the query will return only the information before the insert operation.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BABBFGEI"></a>
<div id="ADMIN13494" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Using Conventional Inserts to Load Tables</h3>
<p>During <span class="bold">conventional INSERT operations</span>, the database reuses free space in the table, interleaving newly inserted data with existing data. During such operations, the database also maintains referential integrity constraints. Unlike direct-path <code dir="ltr">INSERT</code> operations, conventional <code dir="ltr">INSERT</code> operations do not require an exclusive lock on the table.</p>
<p>Several other restrictions apply to direct-path <code dir="ltr">INSERT</code> operations that do not apply to conventional <code dir="ltr">INSERT</code> operations. See <a class="olink SQLRF55049" href="../../server.112/e41084/statements_9014.htm#SQLRF55049"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about these restrictions.</p>
<p>You can perform a conventional <code dir="ltr">INSERT</code> operation in serial mode or in parallel mode using the <code dir="ltr">NOAPPEND</code> hint.</p>
<p>The following is an example of using the <code dir="ltr">NOAPPEND</code> hint to perform a conventional <code dir="ltr">INSERT</code> in serial mode:</p>
<pre dir="ltr">
INSERT /*+ NOAPPEND */ INTO sales_hist SELECT * FROM sales WHERE cust_id=8890;
</pre>
<p>The following is an example of using the <code dir="ltr">NOAPPEND</code> hint to perform a conventional <code dir="ltr">INSERT</code> in parallel mode:</p>
<pre dir="ltr">
INSERT /*+ NOAPPEND PARALLEL */ INTO sales_hist
   SELECT * FROM sales;
</pre>
<p>To run in parallel DML mode, the following requirements must be met:</p>
<ul>
<li>
<p>You must have Oracle Enterprise Edition installed.</p>
</li>
<li>
<p>You must enable parallel DML in your session. To do this, submit the following statement:</p>
<pre dir="ltr">
ALTER SESSION { ENABLE | FORCE } PARALLEL DML;
</pre></li>
<li>
<p>You must meet at least one of the following requirements:</p>
<ul>
<li>
<p>Specify the parallel attribute for the target table, either at create time or subsequently</p>
</li>
<li>
<p>Specify the <code dir="ltr">PARALLEL</code> hint for each insert operation</p>
</li>
<li>
<p>Set the database initialization parameter <code dir="ltr">PARALLEL_DEGREE_POLICY</code> to <code dir="ltr">AUTO</code></p>
</li>
</ul>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="InsertDMLErrorLogging"></a>
<div id="ADMIN10261" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Avoiding Bulk INSERT Failures wit<a id="sthref2209"></a><a id="sthref2210"></a><a id="sthref2211"></a>h DML Error Logging</h3>
<p>When you load a table using an <code dir="ltr">INSERT</code> statement with subquery, if an error occurs, the statement is terminated and rolled back in its entirety. This can be wasteful of time and system resources. For such <code dir="ltr">INSERT</code> statements, you can avoid this situation by using the DML error logging feature.</p>
<p>To use DML error logging, you add a statement clause that specifies the name of an error logging table into which the database records errors encountered during DML operations. When you add this error logging clause to the <code dir="ltr">INSERT</code> statement, certain types of errors no longer terminate and roll back the statement. Instead, each error is logged and the statement continues. You then take corrective action on the erroneous rows at a later time.</p>
<p>DML error logging works with <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, <code dir="ltr">MERGE</code>, and <code dir="ltr">DELETE</code> statements. This section focuses on <code dir="ltr">INSERT</code> statements.</p>
<p>To insert data with DML error logging:</p>
<ol>
<li>
<p>Create an error logging table. (Optional)</p>
<p>You can create the table manually or use the <code dir="ltr">DBMS_ERRLOG</code> package to automatically create it for you. See <a href="#CJAHJIBE">"Creating an Error Logging Table"</a> for details.</p>
</li>
<li>
<p>Execute an <code dir="ltr">INSERT</code> statement and include an error logging clause. This clause:</p>
<ul>
<li>
<p>Optionally references the error logging table that you created. If you do not provide an error logging table name, the database logs to an error logging table with a default name. The default error logging table name is <code dir="ltr">ERR$_</code> followed by the first 25 characters of the name of the table that is being inserted into.</p>
</li>
<li>
<p>Optionally includes a <span class="bold">tag</span> (a numeric or string literal in parentheses) that gets added to the error log to help identify the statement that caused the errors. If the tag is omitted, a <code dir="ltr">NULL</code> value is used.</p>
</li>
<li>
<p>Optionally includes a <code dir="ltr">REJECT LIMIT</code> subclause.</p>
<p>This subclause indicates the maximum number of errors that can be encountered before the <code dir="ltr">INSERT</code> statement terminates and rolls back. You can also specify <code dir="ltr">UNLIMITED</code>. The default reject limit is zero, which means that upon encountering the first error, the error is logged and the statement rolls back. For parallel DML operations, the reject limit is applied to each parallel server.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If the statement exceeds the reject limit and rolls back, the error logging table retains the log entries recorded so far.</div>
<p>See <a class="olink SQLRF55061" href="../../server.112/e41084/statements_9014.htm#SQLRF55061"><span class="italic">Oracle Database SQL Language Reference</span></a> for error logging clause syntax information.</p>
</li>
<li>
<p>Query the error logging table and take corrective action for the rows that generated errors.</p>
<p>See <a href="#CJAIJFDI">"Error Logging Table Format"</a>, later in this section, for details on the error logging table structure.</p>
</li>
</ol>
<p><a id="ADMIN12632"></a><span class="subhead3">Example&nbsp;</span>The following statement inserts rows into the <code dir="ltr">DW_EMPL</code> table and logs errors to the <code dir="ltr">ERR_EMPL</code> table. The tag '<code dir="ltr">daily_load</code>' is copied to each log entry. The statement terminates and rolls back if the number of errors exceeds 25.</p>
<pre dir="ltr">
INSERT INTO dw_empl
  SELECT employee_id, first_name, last_name, hire_date, salary, department_id 
  FROM employees
  WHERE hire_date &gt; sysdate - 7
  LOG ERRORS INTO err_empl ('daily_load') REJECT LIMIT 25
</pre>
<p>For more examples, see <a class="olink SQLRF55104" href="../../server.112/e41084/statements_9014.htm#SQLRF55104"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink DWHSG8337" href="../../server.112/e25554/transform.htm#DWHSG8337"><span class="italic">Oracle Database Data Warehousing Guide</span></a>.</p>
<a id="CJAIJFDI"></a>
<div id="ADMIN11636" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Error Logging Table Format</h4>
<p>The error logging table consists of two parts:</p>
<ul>
<li>
<p>A mandatory set of columns that describe the error. For example, one column contains the Oracle error number.</p>
<p><a href="#CJABHICH">Table 20-3</a> lists these error description columns.</p>
</li>
<li>
<p>An optional set of columns that contain data from the row that caused the error. The column names match the column names from the table being inserted into (the "DML table").</p>
<p>The number of columns in this part of the error logging table can be zero, one, or more, up to the number of columns in the DML table. If a column exists in the error logging table that has the same name as a column in the DML table, the corresponding data from the offending row being inserted is written to this error logging table column. If a DML table column does not have a corresponding column in the error logging table, the column is not logged. If the error logging table contains a column with a name that does not match a DML table column, the column is ignored.</p>
<p>Because type conversion errors are one type of error that might occur, the data types of the optional columns in the error logging table must be types that can capture any value without data loss or conversion errors. (If the optional log columns were of the same types as the DML table columns, capturing the problematic data into the log could suffer the same data conversion problem that caused the error.) The database makes a best effort to log a meaningful value for data that causes conversion errors. If a value cannot be derived, <code dir="ltr">NULL</code> is logged for the column. An error on insertion into the error logging table causes the statement to terminate.</p>
<p><a href="#CJADIFDC">Table 20-4</a> lists the recommended error logging table column data types to use for each data type from the DML table. These recommended data types are used when you create the error logging table automatically with the <code dir="ltr">DBMS_ERRLOG</code> package.</p>
</li>
</ul>
<div id="ADMIN13064" class="tblhruleformal">
<p class="titleintable"><a id="sthref2212"></a><a id="CJABHICH"></a>Table 20-3 Mandatory Error Description Columns</p>
<table class="cellalignment1333" title="Mandatory Error Description Columns" summary="This table contains 5 rows, one for each of the mandatory error description columns in the error logging table. Each column name is listed with its data type and a description. The columns are Oracle error number, error message text, row ID, type of operation that caused the error, and the user-defined tag from the log errors clause." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t36">Column Name</th>
<th class="cellalignment1334" id="r1c2-t36">Data Type</th>
<th class="cellalignment1334" id="r1c3-t36">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t36" headers="r1c1-t36">
<p><code dir="ltr">ORA_ERR_NUMBER$</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t36 r1c2-t36">
<p><code dir="ltr">NUMBER</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t36 r1c3-t36">
<p>Oracle error number</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t36" headers="r1c1-t36">
<p><code dir="ltr">ORA_ERR_MESG$</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t36 r1c2-t36">
<p><code dir="ltr">VARCHAR2(2000)</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t36 r1c3-t36">
<p>Oracle error message text</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t36" headers="r1c1-t36">
<p><code dir="ltr">ORA_ERR_ROWID$</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t36 r1c2-t36">
<p><code dir="ltr">ROWID</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t36 r1c3-t36">
<p>Rowid of the row in error (for update and delete)</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t36" headers="r1c1-t36">
<p><code dir="ltr">ORA_ERR_OPTYP$</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t36 r1c2-t36">
<p><code dir="ltr">VARCHAR2(2)</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t36 r1c3-t36">
<p>Type of operation: insert (<code dir="ltr">I</code>), update (<code dir="ltr">U</code>), delete (<code dir="ltr">D</code>)</p>
<p>Note: Errors from the update clause and insert clause of a <code dir="ltr">MERGE</code> operation are distinguished by the <code dir="ltr">U</code> and <code dir="ltr">I</code> values.</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t36" headers="r1c1-t36">
<p><code dir="ltr">ORA_ERR_TAG$</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t36 r1c2-t36">
<p><code dir="ltr">VARCHAR2(2000)</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t36 r1c3-t36">
<p>Value of the tag supplied by the user in the error logging clause</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" -->
<div id="ADMIN13065" class="tblhruleformal">
<p class="titleintable"><a id="sthref2213"></a><a id="CJADIFDC"></a>Table 20-4 Error Logging Table Column Data Types</p>
<table class="cellalignment1333" title="Error Logging Table Column Data Types" summary="This table contains 7 rows, where each row lists a data type from the DML table and the corresponding data type in the error logging table. For example, the data types of NUMBER, DATE, and all character types get a corresponding error log data type of VARCHAR2 or NVARCHAR2." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t37">DML Table Column Type</th>
<th class="cellalignment1334" id="r1c2-t37">Error Logging Table Column Type</th>
<th class="cellalignment1334" id="r1c3-t37">Notes</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t37" headers="r1c1-t37">
<p><code dir="ltr">NUMBER</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t37 r1c2-t37">
<p><code dir="ltr">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t37 r1c3-t37">
<p>Able to log conversion errors</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t37" headers="r1c1-t37">
<p><code dir="ltr">CHAR/VARCHAR2(n)</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t37 r1c2-t37">
<p><code dir="ltr">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t37 r1c3-t37">
<p>Logs any value without information loss</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t37" headers="r1c1-t37">
<p><code dir="ltr">NCHAR/NVARCHAR2(n)</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t37 r1c2-t37">
<p><code dir="ltr">NVARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t37 r1c3-t37">
<p>Logs any value without information loss</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t37" headers="r1c1-t37">
<p><code dir="ltr">DATE/TIMESTAMP</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t37 r1c2-t37">
<p><code dir="ltr">VARCHAR2(4000)</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t37 r1c3-t37">
<p>Logs any value without information loss. Converts to character format with the default date/time format mask</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t37" headers="r1c1-t37">
<p><code dir="ltr">RAW</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t37 r1c2-t37">
<p><code dir="ltr">RAW(2000)</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t37 r1c3-t37">
<p>Logs any value without information loss</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t37" headers="r1c1-t37">
<p><code dir="ltr">ROWID</code></p>
</td>
<td class="cellalignment1335" headers="r7c1-t37 r1c2-t37">
<p><code dir="ltr">UROWID</code></p>
</td>
<td class="cellalignment1335" headers="r7c1-t37 r1c3-t37">
<p>Logs any rowid type</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t37" headers="r1c1-t37">
<p><code dir="ltr">LONG/LOB</code></p>
</td>
<td class="cellalignment1335" headers="r8c1-t37 r1c2-t37">&nbsp;</td>
<td class="cellalignment1335" headers="r8c1-t37 r1c3-t37">
<p>Not supported</p>
</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t37" headers="r1c1-t37">
<p>User-defined types</p>
</td>
<td class="cellalignment1335" headers="r9c1-t37 r1c2-t37">&nbsp;</td>
<td class="cellalignment1335" headers="r9c1-t37 r1c3-t37">
<p>Not supported</p>
</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformal" --></div>
<!-- class="sect3" -->
<a id="CJAHJIBE"></a>
<div id="ADMIN11637" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Creating an Error Logging Table</h4>
<p>You can create an error logging table manually, or you can use a PL/SQL package to automatically create one for you.</p>
<div id="ADMIN11638" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2214"></a>
<h5 class="sect4">Creating an Error Logging Table Automatically</h5>
<p>You use the <code dir="ltr">DBMS_ERRLOG</code> package to automatically create an error logging table. The <code dir="ltr">CREATE_ERROR_LOG</code> procedure creates an error logging table with all of the mandatory error description columns plus all of the columns from the named DML table, and performs the data type mappings shown in <a href="#CJADIFDC">Table 20-4</a>.</p>
<p>The following statement creates the error logging table used in the previous example.</p>
<pre dir="ltr">
EXECUTE DBMS_ERRLOG.CREATE_ERROR_LOG('DW_EMPL', 'ERR_EMPL');
</pre>
<p>See <a class="olink ARPLS680" href="../../appdev.112/e40758/d_errlog.htm#ARPLS680"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for details on <code dir="ltr">DBMS_ERRLOG</code>.</p>
</div>
<!-- class="sect4" -->
<div id="ADMIN11639" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2215"></a>
<h5 class="sect4">Creating an Error Logging Table Manually</h5>
<p>You use standard DDL to manually create the error logging table. See <a href="#CJAIJFDI">"Error Logging Table Format"</a> for table structure requirements. You must include all mandatory error description columns. They can be in any order, but must be the first columns in the table.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<div id="ADMIN11640" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2216"></a>
<h4 class="sect3">Error Logging Restrictions and Caveats</h4>
<p>Oracle Database logs the following errors during DML operations:</p>
<ul>
<li>
<p>Column values that are too large</p>
</li>
<li>
<p>Constraint violations (<code dir="ltr">NOT</code> <code dir="ltr">NULL</code>, unique, referential, and check constraints)</p>
</li>
<li>
<p>Errors raised during trigger execution</p>
</li>
<li>
<p>Errors resulting from type conversion between a column in a subquery and the corresponding column of the table</p>
</li>
<li>
<p>Partition mapping errors</p>
</li>
<li>
<p>Certain <code dir="ltr">MERGE</code> operation errors (<code dir="ltr">ORA-30926</code>: Unable to get a stable set of rows for MERGE operation.)</p>
</li>
</ul>
<p>Some errors are not logged, and cause the DML operation to terminate and roll back. For a list of these errors and for other DML logging restrictions, see the discussion of the <code dir="ltr">error_logging_clause</code> in the <code dir="ltr">INSERT</code> section of <a class="olink SQLRF55101" href="../../server.112/e41084/statements_9014.htm#SQLRF55101"><span class="italic">Oracle Database SQL Language Reference</span></a>.</p>
<div id="ADMIN11641" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2217"></a>
<h5 class="sect4">Space Considerations</h5>
<p>Ensure that you consider space requirements before using DML error logging. You require available space not only for the table being inserted into, but also for the error logging table.</p>
</div>
<!-- class="sect4" -->
<div id="ADMIN11642" class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref2218"></a>
<h5 class="sect4">Security</h5>
<p>The user who issues the <code dir="ltr">INSERT</code> statement with DML error logging must have <code dir="ltr">INSERT</code> privileges on the error logging table.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF55101" href="../../server.112/e41084/statements_9014.htm#SQLRF55101"><span class="italic">Oracle Database SQL Language Reference</span></a> and <a class="olink DWHSG8337" href="../../server.112/e25554/transform.htm#DWHSG8337"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for DML error logging examples.</div>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006473"></a>
<div id="ADMIN11656" class="sect1">
<h2 class="sect1">Automatically Collecting <a id="sthref2219"></a><a id="sthref2220"></a>Statistics on Tables</h2>
<p>The PL/SQL package <a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"></a><a id="sthref2221"></a><a id="sthref2222"></a>DBMS_STATS lets you generate and manage statistics for cost-based optimization. You can use this package to gather, modify, view, export, import, and delete statistics. You can also use this package to identify or name statistics that have been gathered.</p>
<p>Formerly, you enabled <code dir="ltr">DBMS_STATS</code> to automatically gather statistics for a table by specifying the <a id="sthref2223"></a><a id="sthref2224"></a><code dir="ltr">MONITORING</code> keyword in the <code dir="ltr">CREATE</code> (or <code dir="ltr">ALTER</code>) <code dir="ltr">TABLE</code> statement. Starting with Oracle Database 11<span class="italic">g</span>, the <code dir="ltr">MONITORING</code> and <code dir="ltr">NOMONITORING</code> keywords have been deprecated and statistics are collected automatically. If you do specify these keywords, they are ignored.</p>
<p>Monitoring tracks the approximate number of <code dir="ltr">INSERT</code>, <code dir="ltr">UPDATE</code>, and <code dir="ltr">DELETE</code> operations for the table since the last time statistics were gathered. Information about how many rows are affected is maintained in the SGA, until periodically (about every three hours) SMON incorporates the data into the data dictionary. This data dictionary information is made visible through the <code dir="ltr">DBA_TAB_MODIFICATIONS,ALL_TAB_MODIFICATIONS</code>, or <code dir="ltr">USER_TAB_MODIFICATIONS</code> views. The database uses these views to identify tables with stale statistics.</p>
<p>The default for the <a class="olink REFRN10214" href="../../server.112/e40402/initparams254.htm#REFRN10214"></a><a id="sthref2225"></a><a id="sthref2226"></a>STATISTICS_LEVEL initialization parameter is <code dir="ltr">TYPICAL</code>, which enables automatic statistics collection. Automatic statistics collection and the <code dir="ltr">DBMS_STATS</code> package enable the optimizer to generate accurate execution plans. Setting the <code dir="ltr">STATISTICS_LEVEL</code> initialization parameter to <code dir="ltr">BASIC</code> disables the collection of many of the important statistics required by Oracle Database features and functionality. To disable monitoring of all tables, set the <code dir="ltr">STATISTICS_LEVEL</code> initialization parameter to <code dir="ltr">BASIC</code>. Automatic statistics collection and the <code dir="ltr">DBMS_STATS</code> package enable the optimizer to generate accurate execution plans.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN10214" href="../../server.112/e40402/initparams254.htm#REFRN10214"><span class="italic">Oracle Database Reference</span></a> for detailed information on the <code dir="ltr">STATISTICS_LEVEL</code> initialization parameter</p>
</li>
<li>
<p><a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information on managing optimizer statistics</p>
</li>
<li>
<p><a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about using the <code dir="ltr">DBMS_STATS</code> package</p>
</li>
<li>
<p><a href="tasks.htm#CIHGDCEH">"About Automated Maintenance Tasks"</a> for information on using the Scheduler to collect statistics automatically</p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" -->
<a id="i1006494"></a>
<div id="ADMIN01504" class="sect1">
<h2 class="sect1">Altering Tables</h2>
<p><a id="sthref2227"></a>You alter a table using the <code dir="ltr">ALTER TABLE</code> statement. To alter a table, the table must be contained in your schema, or you must have either the <code dir="ltr">ALTER</code> object privilege for the table or the <code dir="ltr">ALTER ANY TABLE</code> system privilege.</p>
<p>Many of the usages of the <code dir="ltr">ALTER TABLE</code> statement are presented in the following sections:</p>
<ul>
<li>
<p><a href="#i1006549">Reasons for Using the ALTER TABLE Statement</a></p>
</li>
<li>
<p><a href="#i1006569">Altering Physical Attributes of a Table</a></p>
</li>
<li>
<p><a href="#i1106606">Moving a Table to a New Segment or Tablespace</a></p>
</li>
<li>
<p><a href="#i1006621">Manually Allocating Storage for a Table</a></p>
</li>
<li>
<p><a href="#i1006645">Modifying an Existing Column Definition</a></p>
</li>
<li>
<p><a href="#i1006666">Adding Table Columns</a></p>
</li>
<li>
<p><a href="#i1006687">Renaming Table Columns</a></p>
</li>
<li>
<p><a href="#i1006709">Dropping Table Columns</a></p>
</li>
<li>
<p><a href="#CJAGAFHJ">Placing a Table in Read-Only Mode</a></p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Before altering a table, familiarize yourself with the consequences of doing so. The <a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> lists many of these consequences in the descriptions of the <code dir="ltr">ALTER TABLE</code> clauses.
<p>If a view, materialized view, trigger, domain index, function-based index, check constraint, function, procedure of package depends on a base table, the alteration of the base table or its columns can affect the dependent object. See <a href="general.htm#i1006919">"Managing Object Dependencies"</a> for information about how the database manages dependencies.</p>
</div>
<a id="i1006549"></a>
<div id="ADMIN11657" class="sect2">
<h3 class="sect2">Reasons for Using the ALTER TABLE Statement</h3>
<p><a id="sthref2228"></a><a id="sthref2229"></a>You can use the ALTER TABLE statement to perform any of the following actions that affect a table:</p>
<ul>
<li>
<p>Modify physical characteristics (<code dir="ltr">INITRANS</code> or storage parameters)</p>
</li>
<li>
<p>Move the table to a new segment or tablespace</p>
</li>
<li>
<p>Explicitly allocate an extent or deallocate unused space</p>
</li>
<li>
<p>Add, drop, or rename columns, or modify an existing column definition (data type, length, default value, <code dir="ltr">NOT NULL</code> integrity constraint, column expression (for virtual columns), and encryption properties.)</p>
</li>
<li>
<p>Modify the logging attributes of the table</p>
</li>
<li>
<p>Modify the <code dir="ltr">CACHE</code>/<code dir="ltr">NOCACHE</code> attributes</p>
</li>
<li>
<p>Add, modify or drop integrity constraints associated with the table</p>
</li>
<li>
<p>Enable or disable integrity constraints or triggers associated with the table</p>
</li>
<li>
<p>Modify the degree of parallelism for the table</p>
</li>
<li>
<p>Rename a table</p>
</li>
<li>
<p>Put a table in read-only mode and return it to read/write mode</p>
</li>
<li>
<p>Add or modify index-organized table characteristics</p>
</li>
<li>
<p>Alter the characteristics of an external table</p>
</li>
<li>
<p>Add or modify <code dir="ltr">LOB</code> columns</p>
</li>
<li>
<p>Add or modify object type, nested table, or varray columns</p>
</li>
</ul>
<p>Many of these operations are discussed in succeeding sections.</p>
</div>
<!-- class="sect2" -->
<a id="i1006569"></a>
<div id="ADMIN11658" class="sect2">
<h3 class="sect2">Altering Physical Attributes of a Table<a id="sthref2230"></a></h3>
<p><a id="sthref2231"></a><a id="sthref2232"></a><a id="sthref2233"></a><a id="sthref2234"></a>When altering the transaction entry setting <code dir="ltr">INITRANS</code> of a table, note that a new setting for <code dir="ltr">INITRANS</code> applies only to data blocks subsequently allocated for the table.</p>
<p><a id="sthref2235"></a><a id="sthref2236"></a><a id="sthref2237"></a><a id="sthref2238"></a>The storage parameters <code dir="ltr">INITIAL</code> and <code dir="ltr">MINEXTENTS</code> cannot be altered. All new settings for the other storage parameters (for example, <code dir="ltr">NEXT</code>, <code dir="ltr">PCTINCREASE</code>) affect only extents subsequently allocated for the table. The size of the next extent allocated is determined by the current values of <code dir="ltr"><a id="sthref2239"></a><a id="sthref2240"></a>NEXT</code> and <a id="sthref2241"></a><a id="sthref2242"></a><code dir="ltr">PCTINCREASE</code>, and is not based on previous values of these parameters.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The discussions of the physical attributes clause and the storage clause in <a class="olink SQLRF021" href="../../server.112/e41084/clauses.htm#SQLRF021"><span class="italic">Oracle Database SQL Language Reference</span></a></div>
</div>
<!-- class="sect2" -->
<a id="i1106606"></a>
<div id="ADMIN11659" class="sect2">
<h3 class="sect2">Moving a Table to a New Segment or Tablespace<a id="sthref2243"></a></h3>
<p>The <a id="sthref2244"></a><code dir="ltr">ALTER TABLE...MOVE</code> statement enables you to relocate data of a nonpartitioned table or of a partition of a partitioned table into a new segment, and optionally into a different tablespace for which you have quota. This statement also lets you modify any of the storage attributes of the table or partition, including those which cannot be modified using <code dir="ltr">ALTER TABLE</code>. You can also use the <code dir="ltr">ALTER TABLE...MOVE</code> statement with a <code dir="ltr">COMPRESS</code> clause to store the new segment using table compression.</p>
<p><a id="sthref2245"></a>One important reason to move a table to a new tablespace (with a new data file) is to eliminate the possibility that old versions of column data&mdash;versions left on now unused portions of the disk due to segment shrink, reorganization, or previous table moves&mdash;could be viewed by bypassing the access controls of the database (for example with an operating system utility). This is especially important with columns that you intend to modify by adding transparent data encryption.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <a id="sthref2246"></a><code dir="ltr">ALTER TABLE...MOVE</code> statement does not permit DML against the table while the statement is executing. To leave the table available for DML while moving it, see <a href="#i1006754">"Redefining Tables Online"</a>.</div>
<p>The following statement moves the <code dir="ltr">hr.admin_emp</code> table to a new segment and tablespace, specifying new storage parameters:</p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp MOVE
      STORAGE ( INITIAL 20K
                NEXT 40K
                MINEXTENTS 2
                MAXEXTENTS 20
                PCTINCREASE 0 )
  TABLESPACE hr_tbs;
</pre>
<p>Moving a table changes the rowids of the rows in the table. This causes indexes on the table to be marked <code dir="ltr">UNUSABLE</code>, and DML accessing the table using these indexes will receive an ORA-01502 error. The indexes on the table must be dropped or rebuilt. Likewise, any statistics for the table become invalid and new statistics should be collected after moving the table.</p>
<p>If the table includes <code dir="ltr">LOB</code> column(s), this statement can be used to move the table along with <code dir="ltr">LOB</code> data and <code dir="ltr">LOB</code> index segments (associated with this table) which the user explicitly specifies. If not specified, the default is to not move the <code dir="ltr">LOB</code> data and <code dir="ltr">LOB</code> index segments.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJAGJDGF">"Consider Encrypting Columns That Contain Sensitive Data"</a> for more information on transparent data encryption</div>
</div>
<!-- class="sect2" -->
<a id="i1006621"></a>
<div id="ADMIN11660" class="sect2">
<h3 class="sect2">Manually Allocating Storage for a Table</h3>
<p><a id="sthref2247"></a><a id="sthref2248"></a><a id="sthref2249"></a>Oracle Database dynamically allocates additional extents for the data segment of a table, as required. However, perhaps you want to allocate an additional extent for a table explicitly. For example, in an Oracle Real Application Clusters environment, an extent of a table can be allocated explicitly for a specific instance.</p>
<p>A new extent can be allocated for a table using the <a id="sthref2250"></a><code dir="ltr">ALTER TABLE...ALLOCATE EXTENT</code> clause.</p>
<p>You can also explicitly deallocate unused space using the <code dir="ltr">DEALLOCATE UNUSED</code> clause of <a id="sthref2251"></a><code dir="ltr">ALTER TABLE</code>. This is described in <a href="schema.htm#i1006922">"Reclaiming Wasted Space"</a>.</p>
</div>
<!-- class="sect2" -->
<a id="i1006645"></a>
<div id="ADMIN11661" class="sect2">
<h3 class="sect2">Modifying an Existing Column Definition<a id="sthref2252"></a><a id="sthref2253"></a></h3>
<p>Use the <code dir="ltr"><a id="sthref2254"></a>ALTER TABLE...MODIFY</code> statement to modify an existing column definition. You can modify column data type, default value, column constraint, column expression (for virtual columns) and column encryption.</p>
<p><a id="sthref2255"></a><a id="sthref2256"></a><a id="sthref2257"></a>You can increase the length of an existing column, or decrease it, if all existing data satisfies the new length. You can change a column from byte semantics to <code dir="ltr">CHAR</code> semantics or vice versa. You must set the initialization parameter <code dir="ltr"><a id="sthref2258"></a>BLANK_TRIMMING=TRUE</code> to decrease the length of a non-empty <code dir="ltr">CHAR</code> column.</p>
<p>If you are modifying a table to increase the length of a column of data type <code dir="ltr">CHAR</code>, realize that this can be a time consuming operation and can require substantial additional storage, especially if the table contains many rows. This is because the <code dir="ltr">CHAR</code> value in each row must be blank-padded to satisfy the new column length.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional information about modifying table columns and additional restrictions</div>
</div>
<!-- class="sect2" -->
<a id="i1006666"></a>
<div id="ADMIN11005" class="sect2">
<h3 class="sect2">Adding <a id="sthref2259"></a><a id="sthref2260"></a><a id="sthref2261"></a>Table Columns</h3>
<p>To add a column to an existing table, use the <code dir="ltr"><a id="sthref2262"></a>ALTER TABLE...ADD</code> statement.</p>
<p>The following statement alters the <code dir="ltr">hr.admin_emp</code> table to add a new column named <code dir="ltr">bonus</code>:</p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp
      ADD (bonus NUMBER (7,2));
</pre>
<p>If a new column is added to a table, the column is initially <code dir="ltr">NULL</code> unless you specify the <code dir="ltr">DEFAULT</code> clause. When you specify a default value, the database immediately updates each row with the default value. Note that this can take some time, and that during the update, there is an exclusive DML lock on the table. For some types of tables (for example, tables without LOB columns), if you specify both a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint and a default value, the database can optimize the column add operation and greatly reduce the amount of time that the table is locked for DML.</p>
<p>You can add a column with a <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> constraint only if the table does not contain any rows, or you specify a default value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for additional rules and restrictions for adding table columns</div>
<div id="ADMIN12493" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2263"></a>
<h4 class="sect3">Adding a Col<a id="sthref2264"></a><a id="sthref2265"></a><a id="sthref2266"></a>umn to a Compressed Table</h4>
<p>If you enable basic compression on a table, you can add columns only if you do not specify default values.</p>
<p>If you enable OLTP compression on a table, you can add columns to that table with or without default values. If a default value is specified, the column must be <code dir="ltr">NOT</code> <code dir="ltr">NULL</code>.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJAGFBFG">"Consider Using Table Compression"</a></div>
</div>
<!-- class="sect3" -->
<div id="ADMIN12494" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2267"></a>
<h4 class="sect3">Adding a Virtual Column</h4>
<p>If the new column is a virtual column, its value is determined by its column expression. (Note that a virtual column's value is calculated only when it is queried.)</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT89199" href="../../server.112/e40540/tablecls.htm#CNCPT89199"><span class="italic">Oracle Database Concepts</span></a></p>
</li>
<li>
<p><a href="#i1106369">"Example: Creating a Table"</a> for an example of a virtual column</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006687"></a>
<div id="ADMIN11662" class="sect2">
<h3 class="sect2">Renaming Table Columns<a id="sthref2268"></a><a id="sthref2269"></a></h3>
<p>Oracle Database lets you rename existing columns in a table. Use the <code dir="ltr">RENAME COLUMN</code> clause of the <code dir="ltr"><a id="sthref2270"></a>ALTER TABLE</code> statement to rename a column. The new name must not conflict with the name of any existing column in the table. No other clauses are allowed with the <code dir="ltr">RENAME COLUMN</code> clause.</p>
<p>The following statement renames the <code dir="ltr">comm</code> column of the <code dir="ltr">hr.admin_emp</code> table.</p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp
      RENAME COLUMN comm TO commission;
</pre>
<p>As noted earlier, altering a table column can invalidate dependent objects. However, when you rename a column, the database updates associated data dictionary tables to ensure that function-based indexes and check constraints remain valid.</p>
<p>Oracle Database also lets you rename column constraints. This is discussed in <a href="general.htm#i1006776">"Renaming Constraints"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">RENAME TO</code> clause of <code dir="ltr">ALTER TABLE</code> appears similar in syntax to the <code dir="ltr">RENAME COLUMN</code> clause, but is used for renaming the table itself.</div>
</div>
<!-- class="sect2" -->
<a id="i1006709"></a>
<div id="ADMIN11663" class="sect2">
<h3 class="sect2">Dropping Table Columns<a id="sthref2271"></a><a id="sthref2272"></a></h3>
<p>You can drop columns that are no longer needed from a table, including an index-organized table. This provides a convenient means to free space in a database, and avoids your having to export/import data then re-create indexes and constraints.</p>
<p>You cannot drop all columns from a table, nor can you drop columns from a table owned by <code dir="ltr">SYS</code>. Any attempt to do so results in an error.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for information about additional restrictions and options for dropping columns from a table</div>
<div id="ADMIN11664" class="sect3"><a id="sthref2273"></a>
<h4 class="sect3">Removing Columns from Tables</h4>
<p>When you issue an <a id="sthref2274"></a><code dir="ltr">ALTER TABLE...DROP COLUMN</code> statement, the column descriptor and the data associated with the target column are removed from each row in the table. You can drop multiple columns with one statement.</p>
<p>The following statements are examples of dropping columns from the <code dir="ltr">hr.admin_emp</code> table. The first statement drops only the <code dir="ltr">sal</code> column:</p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp DROP COLUMN sal;
</pre>
<p>The next statement drops both the <code dir="ltr">bonus</code> and <code dir="ltr">comm</code> columns:</p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp DROP (bonus, commission);
</pre></div>
<!-- class="sect3" -->
<div id="ADMIN11665" class="sect3"><a id="sthref2275"></a>
<h4 class="sect3">Marking Columns Unused<a id="sthref2276"></a></h4>
<p>If you are concerned about the length of time it could take to drop column data from all of the rows in a large table, you can use the <a id="sthref2277"></a><code dir="ltr">ALTER TABLE...SET UNUSED</code> statement. This statement marks one or more columns as unused, but does not actually remove the target column data or restore the disk space occupied by these columns. However, a column that is marked as unused is not displayed in queries or data dictionary views, and its name is removed so that a new column can reuse that name. In most cases, constraints, indexes, and statistics defined on the column are also removed. The exception is that any internal indexes for LOB columns that are marked unused are not removed.</p>
<p>To mark the <code dir="ltr">hiredate</code> and <code dir="ltr">mgr</code> columns as unused, execute the following statement:</p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp SET UNUSED (hiredate, mgr);
</pre>
<p><a id="sthref2278"></a>You can later remove columns that are marked as unused by issuing an <a id="sthref2279"></a><code dir="ltr">ALTER TABLE...DROP UNUSED COLUMNS</code> statement. Unused columns are also removed from the target table whenever an explicit drop of any particular column or columns of the table is issued.</p>
<p>The data dictionary views <code dir="ltr">USER_UNUSED_COL_TABS</code>, <code dir="ltr">ALL_UNUSED_COL_TABS</code>, or <code dir="ltr">DBA_UNUSED_COL_TABS</code> can be used to list all tables containing unused columns. The <code dir="ltr">COUNT</code> field shows the number of unused columns in the table.</p>
<pre dir="ltr">
SELECT * FROM DBA_UNUSED_COL_TABS;

OWNER                       TABLE_NAME                  COUNT
--------------------------- --------------------------- -----
HR                          ADMIN_EMP                       2
</pre>
<p>For external tables, the <code dir="ltr">SET</code> <code dir="ltr">UNUSED</code> statement is transparently converted into an <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">DROP</code> <code dir="ltr">COLUMN</code> statement. Because external tables consist of metadata only in the database, the <code dir="ltr">DROP</code> <code dir="ltr">COLUMN</code> statement performs equivalently to the <code dir="ltr">SET</code> <code dir="ltr">UNUSED</code> statement.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11666" class="sect3"><a id="sthref2280"></a>
<h4 class="sect3">Removing Unused Columns</h4>
<p>The <code dir="ltr">ALTER TABLE...DROP UNUSED COLUMNS</code> statement is the only action allowed on unused columns. It physically removes unused columns from the table and reclaims disk space.</p>
<p>In the <code dir="ltr">ALTER TABLE</code> statement that follows, the optional clause <code dir="ltr">CHECKPOINT</code> is specified. This clause causes a checkpoint to be applied after processing the specified number of rows, in this case 250. Checkpointing cuts down on the amount of undo logs accumulated during the drop column operation to avoid a potential exhaustion of undo space.<a id="sthref2281"></a></p>
<pre dir="ltr">
ALTER TABLE hr.admin_emp DROP UNUSED COLUMNS CHECKPOINT 250;
</pre></div>
<!-- class="sect3" -->
<div id="ADMIN12495" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2282"></a>
<h4 class="sect3">Dropping Co<a id="sthref2283"></a><a id="sthref2284"></a><a id="sthref2285"></a>lumns in Compressed Tables</h4>
<p>If you enable OLTP compression on a table, you can drop table columns. If you enable basic compression only, you cannot drop columns.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#CJAGFBFG">"Consider Using Table Compression"</a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJAGAFHJ"></a>
<div id="ADMIN12316" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Placing a Table in Read-Only Mode</h3>
<p><a id="sthref2286"></a><a id="sthref2287"></a>You can place a table in read-only mode with the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">READ</code> <code dir="ltr">ONLY</code> statement, and return it to read/write mode with the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">READ</code> <code dir="ltr">WRITE</code> statement. An example of a table for which read-only mode makes sense is a configuration table. If your application contains configuration tables that are not modified after installation and that must not be modified by users, your application installation scripts can place these tables in read-only mode.</p>
<p>To place a table in read-only mode, you must have the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> privilege on the table or the <code dir="ltr">ALTER</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code> privilege. In addition, the <code dir="ltr">COMPATIBLE</code> initialization parameter must be set to 11.1.0 or greater.</p>
<p>The following example places the <code dir="ltr">SALES</code> table in read-only mode:</p>
<pre dir="ltr">
ALTER TABLE SALES READ ONLY;
</pre>
<p>The following example returns the table to read/write mode:</p>
<pre dir="ltr">
ALTER TABLE SALES READ WRITE;
</pre>
<p>When a table is in read-only mode, operations that attempt to modify table data are disallowed. The following operations are not permitted on a read-only table:</p>
<ul>
<li>
<p>All DML operations on the table or any of its partitions</p>
</li>
<li>
<p><code dir="ltr">TRUNCATE</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code> <code dir="ltr">FOR</code> <code dir="ltr">UPDATE</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">ADD</code>/<code dir="ltr">MODIFY</code>/<code dir="ltr">RENAME</code>/<code dir="ltr">DROP</code> <code dir="ltr">COLUMN</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">SET</code> <code dir="ltr">COLUMN</code> <code dir="ltr">UNUSED</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">DROP</code>/<code dir="ltr">TRUNCATE</code>/<code dir="ltr">EXCHANGE</code> <code dir="ltr">(</code><code dir="ltr">SUB</code><code dir="ltr">)</code><code dir="ltr">PARTITION</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">UPGRADE</code> <code dir="ltr">INCLUDING</code> <code dir="ltr">DATA</code> or <code dir="ltr">ALTER</code> <code dir="ltr">TYPE</code> <code dir="ltr">CASCADE</code> <code dir="ltr">INCLUDING</code> <code dir="ltr">TABLE</code> <code dir="ltr">DATA</code> for a type with read-only table dependents</p>
</li>
<li>
<p>Online redefinition</p>
</li>
<li>
<p><code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code></p>
</li>
</ul>
<p>The following operations are permitted on a read-only table:</p>
<ul>
<li>
<p><code dir="ltr">SELECT</code></p>
</li>
<li>
<p><code dir="ltr">CREATE</code>/<code dir="ltr">ALTER</code>/<code dir="ltr">DROP</code> <code dir="ltr">INDEX</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">ADD</code>/<code dir="ltr">MODIFY</code>/<code dir="ltr">DROP</code>/<code dir="ltr">ENABLE</code>/<code dir="ltr">DISABLE</code> <code dir="ltr">CONSTRAINT</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> for physical property changes</p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">DROP</code> <code dir="ltr">UNUSED</code> <code dir="ltr">COLUMNS</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">ADD</code>/<code dir="ltr">COALESCE</code>/<code dir="ltr">MERGE</code>/<code dir="ltr">MODIFY</code>/<code dir="ltr">MOVE</code>/<code dir="ltr">RENAME</code>/<code dir="ltr">SPLIT</code> <code dir="ltr">(SUB)PARTITION</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">MOVE</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">ENABLE</code> <code dir="ltr">ROW</code> <code dir="ltr">MOVEMENT</code> and <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">SHRINK</code></p>
</li>
<li>
<p><code dir="ltr">RENAME</code> <code dir="ltr">TABLE</code> and <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">RENAME</code> <code dir="ltr">TO</code></p>
</li>
<li>
<p><code dir="ltr">DROP</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">DEALLOCATE</code> <code dir="ltr">UNUSED</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">ADD</code>/<code dir="ltr">DROP</code> <code dir="ltr">SUPPLEMENTAL</code> <code dir="ltr">LOG</code></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement</div>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1006754"></a>
<div id="ADMIN01514" class="sect1">
<h2 class="sect1">Redefinin<a id="sthref2288"></a><a id="sthref2289"></a>g Tables Online</h2>
<p>In any database system, it is occasionally necessary to modify the logical or physical structure of a table to:</p>
<ul>
<li>
<p>Improve the performance of queries or DML</p>
</li>
<li>
<p>Accommodate application changes</p>
</li>
<li>
<p>Manage storage</p>
</li>
</ul>
<p>Oracle Database provides a mechanism to make table structure modifications without significantly affecting the availability of the table. The mechanism is called <span class="bold">online table redefinition</span>. Redefining tables online provides a substantial increase in availability compared to traditional methods of redefining tables.</p>
<p>When a table is redefined online, it is accessible to both queries and DML during much of the redefinition process. Typically, the table is locked in the exclusive mode only during a very small window that is independent of the size of the table and complexity of the redefinition, and that is completely transparent to users. However, if there are many concurrent DML operations during redefinition, then a longer wait might be necessary before the table can be locked. Due to the wait, more changes are committed to the original table, which increases the refresh time and the amount of time that the table is locked.</p>
<p>Online table redefinition requires an amount of free space that is approximately equivalent to the space used by the table being redefined. More space may be required if new columns are added.</p>
<p>You can perform online table redefinition with the Enterprise Manager Reorganize Objects wizard or with the <code dir="ltr">DBMS_REDEFINITION</code> package.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<span class="bold">To invoke the Reorganize Objects wizard:</span>
<ol>
<li>
<p>On the Tables page of Enterprise Manager, click in the <span class="bold">Select</span> column to select the table to redefine.</p>
</li>
<li>
<p>In the Actions list, select <span class="bold">Reorganize</span>.</p>
</li>
<li>
<p>Click <span class="bold">Go</span>.</p>
</li>
</ol>
</div>
<p>This section describes online redefinition with the <code dir="ltr">DBMS_REDEFINITION</code> package. It contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006790">Features of Online Table Redefinition</a></p>
</li>
<li>
<p><a href="#i1006821">Performing Online Redefinition with DBMS_REDEFINITION</a></p>
</li>
<li>
<p><a href="#CJAHIJAH">Results of the Redefinition Process</a></p>
</li>
<li>
<p><a href="#i1106851">Performing Intermediate Synchronization</a></p>
</li>
<li>
<p><a href="#i1006856">Aborting Online Table Redefinition and Cleaning Up After Errors</a></p>
</li>
<li>
<p><a href="#i1106919">Restrictions for Online Redefinition of Tables</a></p>
</li>
<li>
<p><a href="#CJAHDGEC">Online Redefinition of a Single Partition</a></p>
</li>
<li>
<p><a href="#i1006859">Online Table Redefinition Examples</a></p>
</li>
<li>
<p><a href="#i1006801">Privileges Required for the DBMS_REDEFINITION Package</a></p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS042" href="../../appdev.112/e40758/d_redefi.htm#ARPLS042"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for a description of the <code dir="ltr">DBMS_REDEFINITION</code> package</div>
<a id="i1006790"></a>
<div id="ADMIN11667" class="sect2">
<h3 class="sect2">Features of Online Table Redefinition</h3>
<p><a id="sthref2290"></a>Online table redefinition enables you to:</p>
<ul>
<li>
<p>Modify the storage parameters of a table or cluster</p>
</li>
<li>
<p>Move a table or cluster to a different tablespace</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If it is not important to keep a table available for DML when moving it to another tablespace, you can use the simpler <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> <code dir="ltr">MOVE</code> command. See <a href="#i1106606">"Moving a Table to a New Segment or Tablespace"</a>.</div>
</li>
<li>
<p>Add, modify, or drop one or more columns in a table or cluster</p>
</li>
<li>
<p>Add or drop partitioning support (non-clustered tables only)</p>
</li>
<li>
<p>Change partition structure</p>
</li>
<li>
<p>Change physical properties of a single table partition, including moving it to a different tablespace in the same schema</p>
</li>
<li>
<p>Change physical properties of a materialized view log or an Oracle Streams Advanced Queuing queue table</p>
</li>
<li>
<p>Add support for parallel queries</p>
</li>
<li>
<p>Re-create a table or cluster to reduce fragmentation</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In many cases, online segment shrink is an easier way to reduce fragmentation. See <a href="schema.htm#i1006922">"Reclaiming Wasted Space"</a>.</div>
</li>
<li>
<p>Change the organization of a normal table (heap organized) to an index-organized table, or do the reverse.</p>
</li>
<li>
<p>Convert a relational table into a table with object columns, or do the reverse.</p>
</li>
<li>
<p>Convert an object table into a relational table or a table with object columns, or do the reverse.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1006821"></a>
<div id="ADMIN11668" class="sect2">
<h3 class="sect2"><a id="sthref2291"></a><a id="sthref2292"></a>Performing Online Redefinition with DBMS_REDEFINITION</h3>
<p>You use the <code dir="ltr"><a id="sthref2293"></a>DBMS_REDEFINITION</code> package to perform online redefinition of a table. See <a class="olink ARPLS042" href="../../appdev.112/e40758/d_redefi.htm#ARPLS042"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for package details.</p>
<p class="subhead2"><a id="ADMIN12634"></a>To redefine a table online:</p>
<ol>
<li>
<p>Choose the redefinition method: by key or by rowid</p>
<p><span class="bold">By key</span>&mdash;Select a primary key or pseudo-primary key to use for the redefinition. Pseudo-primary keys are unique keys with all component columns having <code dir="ltr">NOT NULL</code> constraints. For this method, the versions of the tables before and after redefinition should have the same primary key columns. This is the preferred and default method of redefinition.</p>
<p><span class="bold">By rowid</span>&mdash;Use this method if no key is available. In this method, a hidden column named <code dir="ltr">M_ROW$$</code> is added to the post-redefined version of the table. It is recommended that this column be dropped or marked as unused after the redefinition is complete. If <code dir="ltr">COMPATIBLE</code> is set to 10.2.0 or higher, the final phase of redefinition automatically sets this column unused. You can then use the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">DROP</code> <code dir="ltr">UNUSED</code> <code dir="ltr">COLUMNS</code> statement to drop it.</p>
<p>You cannot use this method on index-organized tables.</p>
</li>
<li>
<p>Verify that the table can be redefined online by invoking the <code dir="ltr">CAN_REDEF_TABLE</code> procedure. If the table is not a candidate for online redefinition, then this procedure raises an error indicating why the table cannot be redefined online.</p>
</li>
<li>
<p>Create an empty interim table (in the same schema as the table to be redefined) with all of the desired logical and physical attributes. If columns are to be dropped, do not include them in the definition of the interim table. If a column is to be added, then add the column definition to the interim table. If a column is to be modified, create it in the interim table with the properties that you want.</p>
<p>It is not necessary to create the interim table with all the indexes, constraints, grants, and triggers of the table being redefined, because these will be defined in step <a href="#i1013092">7</a> when you copy dependent objects.</p>
</li>
<li>
<p>If redefining a partitioned table with the rowid method, enable row movement on the interim table.</p>
<pre dir="ltr">
ALTER TABLE ... ENABLE ROW MOVEMENT;
</pre></li>
<li>
<p>(Optional) If you are redefining a large table and want to improve the performance of the next step by running it in parallel, issue the following statements:</p>
<pre dir="ltr">
ALTER SESSION FORCE PARALLEL DML PARALLEL <span class="italic">degree-of-parallelism</span>;
ALTER SESSION FORCE PARALLEL QUERY PARALLEL <span class="italic">degree-of-parallelism</span>;
</pre></li>
<li>
<p>Start the redefinition process by calling <code dir="ltr">START_REDEF_TABLE</code>, providing the following:</p>
<ul>
<li>
<p>The schema and table name of the table to be redefined</p>
</li>
<li>
<p>The interim table name</p>
</li>
<li>
<p>A column mapping string that maps the columns of table to be redefined to the columns of the interim table</p>
<p>See <a href="#CJAHGFJJ">"Constructing a Column Mapping String"</a> for details.</p>
</li>
<li>
<p>The redefinition method</p>
<p>Package constants are provided for specifying the redefinition method. <code dir="ltr">DBMS_REDEFINITION.CONS_USE_PK</code> is used to indicate that the redefinition should be done using primary keys or pseudo-primary keys. <code dir="ltr">DBMS_REDEFINITION.CONS_USE_ROWID</code> is use to indicate that the redefinition should be done using rowids. If this argument is omitted, the default method of redefinition (<code dir="ltr">CONS_USE_PK</code>) is assumed.</p>
</li>
<li>
<p>Optionally, the columns to be used in ordering rows</p>
</li>
<li>
<p>If redefining only a single partition of a partitioned table, the partition name</p>
</li>
</ul>
<p>Because this process involves copying data, it may take a while. The table being redefined remains available for queries and DML during the entire process.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
<ul>
<li>
<p>You can query the <code dir="ltr">DBA_REDEFINITION_OBJECTS</code> view to list the objects currently involved in online redefinition.</p>
</li>
<li>
<p>If <code dir="ltr">START_REDEF_TABLE</code> fails for any reason, you must call <code dir="ltr">ABORT_REDEF_TABLE</code>, otherwise subsequent attempts to redefine the table will fail.</p>
</li>
</ul>
</div>
</li>
<li id="i1013092">
<p>Copy dependent objects (such as triggers, indexes, materialized view logs, grants, and constraints) and statistics from the table being redefined to the interim table, using one of the following two methods. Method 1 is the preferred method because it is more automatic, but there may be times that you would choose to use method 2. Method 1 also enables you to copy table statistics to the interim table.</p>
<ul>
<li>
<p>Method 1: Automatically Creating Dependent Objects</p>
<p>Use the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure to automatically create dependent objects on the interim table. This procedure also <span class="bold">registers</span> the dependent objects. Registering the dependent objects enables the identities of these objects and their copied counterparts to be automatically swapped later as part of the redefinition completion process. The result is that when the redefinition is completed, the names of the dependent objects will be the same as the names of the original dependent objects.</p>
<p>For more information, see <a href="#CJAIJDJF">"Creating Dependent Objects Automatically"</a>.</p>
</li>
<li>
<p>Method 2: Manually Creating Dependent Objects</p>
<p>You can manually create dependent objects on the interim table and then register them. For more information, see <a href="#CJABIBBH">"Creating Dependent Objects Manually"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
In Oracle Database Release 9i, you were <span class="italic">required</span> to manually create the triggers, indexes, grants, and constraints on the interim table, and there may still be situations where you want to or must do so. In such cases, any referential constraints involving the interim table (that is, the interim table is either a parent or a child table of the referential constraint) must be created disabled. When online redefinition completes, the referential constraint is automatically enabled. In addition, until the redefinition process is either completed or aborted, any trigger defined on the interim table does not execute.</div>
</li>
</ul>
</li>
<li>
<p>Execute the <code dir="ltr">FINISH_REDEF_TABLE</code> procedure to complete the redefinition of the table. During this procedure, the original table is locked in exclusive mode for a very short time, independent of the amount of data in the original table. However, <code dir="ltr">FINISH_REDEF_TABLE</code> will wait for all pending DML to commit before completing the redefinition.</p>
</li>
<li>
<p>If you used rowids for the redefinition and your <code dir="ltr">COMPATIBLE</code> initialization parameter is set to 10.1.0 or lower, drop or set <code dir="ltr">UNUSED</code> the hidden column <code dir="ltr">M_ROW$$</code> that is now in the redefined table.</p>
<pre dir="ltr">
ALTER TABLE <span class="italic">table_name</span> SET UNUSED (M_ROW$$);
</pre>
<p>If <code dir="ltr">COMPATIBLE</code> is 10.2.0 or higher, this hidden column is automatically set <code dir="ltr">UNUSED</code> when redefinition completes. You can then drop the column with the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">DROP</code> <code dir="ltr">UNUSED</code> <code dir="ltr">COLUMNS</code> statement.</p>
</li>
<li>
<p>Wait for any long-running queries against the interim table to complete, and then drop the interim table.</p>
<p>If you drop the interim table while there are active queries running against it, you may encounter an <code dir="ltr">ORA-08103</code> error ("object no longer exists").</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a href="#i1006859">"Online Table Redefinition Examples"</a></div>
<a id="CJAHGFJJ"></a>
<div id="ADMIN11669" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Constructing a Column Mapping String</h4>
<p>The column mapping string that you pass as an argument to <code dir="ltr">START_REDEF_TABLE</code> contains a comma-delimited list of column mapping pairs, where each pair has the following syntax:</p>
<pre dir="ltr">
[<span class="italic">expression</span>]  <span class="italic">column_name</span>
</pre>
<p>The <code dir="ltr"><span class="codeinlineitalic">column_name</span></code> term indicates a column in the interim table. The optional <code dir="ltr"><span class="codeinlineitalic">expression</span></code> can include columns from the table being redefined, constants, operators, function or method calls, and so on, in accordance with the rules for expressions in a SQL <code dir="ltr">SELECT</code> statement. However, only simple deterministic subexpressions&mdash;that is, subexpressions whose results do not vary between one evaluation and the next&mdash;plus sequences and <code dir="ltr">SYSDATE</code> can be used. No subqueries are permitted. In the simplest case, the expression consists of just a column name from the table being redefined.</p>
<p>If an expression is present, its value is placed in the designated interim table column during redefinition. If the expression is omitted, it is assumed that both the table being redefined and the interim table have a column named <code dir="ltr"><span class="codeinlineitalic">column_name</span></code>, and the value of that column in the table being redefined is placed in the same column in the interim table.</p>
<p>For example, if the <code dir="ltr">override</code> column in the table being redefined is to be renamed to <code dir="ltr">override_commission</code>, and every override commission is to be raised by 2%, the correct column mapping pair is:</p>
<pre dir="ltr">
override*1.02  override_commission
</pre>
<p>If you supply '<code dir="ltr">*</code>' or <code dir="ltr">NULL</code> as the column mapping string, it is assumed that all the columns (with their names unchanged) are to be included in the interim table. Otherwise, only those columns specified explicitly in the string are considered. The order of the column mapping pairs is unimportant.</p>
<p>For examples of column mapping strings, see <a href="#i1006859">"Online Table Redefinition Examples"</a>.</p>
<p><a id="ADMIN12635"></a><span class="subhead3">Data Conversions&nbsp;</span>When mapping columns, you can convert data types, with some restrictions.</p>
<p>If you provide '<code dir="ltr">*</code>' or <code dir="ltr">NULL</code> as the column mapping string, only the implicit conversions permitted by SQL are supported. For example, you can convert from <code dir="ltr">CHAR</code> to <code dir="ltr">VARCHAR2</code>, from <code dir="ltr">INTEGER</code> to <code dir="ltr">NUMBER</code>, and so on.</p>
<p>To perform other data type conversions, including converting from one object type to another or one collection type to another, you must provide a column mapping pair with an expression that performs the conversion. The expression can include the <code dir="ltr">CAST</code> function, built-in functions like <code dir="ltr">TO_NUMBER</code>, conversion functions that you create, and so on.</p>
</div>
<!-- class="sect3" -->
<a id="CJAIJDJF"></a>
<div id="ADMIN11670" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Creating Dependent Objects Automatically</h4>
<p>You use the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure to automatically create dependent objects on the interim table.</p>
<p>You can discover if errors occurred while copying dependent objects by checking the <code dir="ltr">num_errors</code> output argument. If the <code dir="ltr">ignore_errors</code> argument is set to <code dir="ltr">TRUE</code>, the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure continues copying dependent objects even if an error is encountered when creating an object. You can view these errors by querying the <code dir="ltr">DBA_REDEFINITION_ERRORS</code> view.</p>
<p>Reasons for errors include:</p>
<ul>
<li>
<p>A lack of system resources</p>
</li>
<li>
<p>A change in the logical structure of the table that would require recoding the dependent object.</p>
<p>See Example 3 in <a href="#i1006859">"Online Table Redefinition Examples"</a> for a discussion of this type of error.</p>
</li>
</ul>
<p>If <code dir="ltr">ignore_errors</code> is set to <code dir="ltr">FALSE</code>, the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure stops copying objects as soon as any error is encountered.</p>
<p>After you correct any errors you can again attempt to copy the dependent objects by reexecuting the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure. Optionally you can create the objects manually and then register them as explained in <a href="#CJABIBBH">"Creating Dependent Objects Manually"</a>. The <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure can be used multiple times as necessary. If an object has already been successfully copied, it is not copied again.</p>
</div>
<!-- class="sect3" -->
<a id="CJABIBBH"></a>
<div id="ADMIN11671" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Creating Dependent Objects Manually</h4>
<p>If you manually create dependent objects on the interim table with SQL*Plus or Enterprise Manager, you must then use the <code dir="ltr">REGISTER_DEPENDENT_OBJECT</code> procedure to register the dependent objects. Registering dependent objects enables the redefinition completion process to restore dependent object names to what they were before redefinition.</p>
<p>You would also use the <code dir="ltr">REGISTER_DEPENDENT_OBJECT</code> procedure if the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure failed to copy a dependent object and manual intervention is required.</p>
<p>You can query the <code dir="ltr">DBA_REDEFINITION_OBJECTS</code> view to determine which dependent objects are registered. This view shows dependent objects that were registered explicitly with the <code dir="ltr">REGISTER_DEPENDENT_OBJECT</code> procedure or implicitly with the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure. Only current information is shown in the view.</p>
<p>The <code dir="ltr">UNREGISTER_DEPENDENT_OBJECT</code> procedure can be used to unregister a dependent object on the table being redefined and on the interim table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Manually created dependent objects do not have to be identical to their corresponding original dependent objects. For example, when manually creating a materialized view log on the interim table, you can log different columns. In addition, the interim table can have more or fewer dependent objects.</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CJAHIJAH"></a>
<div id="ADMIN11672" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Results of the Redefinition Process</h3>
<p>The following are the end results of the redefinition process:</p>
<ul>
<li>
<p>The original table is redefined with the columns, indexes, constraints, grants, triggers, and statistics of the interim table.</p>
</li>
<li>
<p>Dependent objects that were registered, either explicitly using <code dir="ltr">REGISTER_DEPENDENT_OBJECT</code> or implicitly using <code dir="ltr">COPY_TABLE_DEPENDENTS</code>, are renamed automatically so that dependent object names on the redefined table are the same as before redefinition.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
If no registration is done or no automatic copying is done, then you must manually rename the dependent objects.</div>
</li>
<li>
<p>The referential constraints involving the interim table now involve the redefined table and are enabled.</p>
</li>
<li>
<p>Any indexes, triggers, materialized view logs, grants, and constraints defined on the original table (prior to redefinition) are transferred to the interim table and are dropped when the user drops the interim table. Any referential constraints involving the original table before the redefinition now involve the interim table and are disabled.</p>
</li>
<li>
<p>Some PL/SQL objects, views, synonyms, and other table-dependent objects may become invalidated. Only those objects that depend on elements of the table that were changed are invalidated. For example, if a PL/SQL procedure queries only columns of the redefined table that were unchanged by the redefinition, the procedure remains valid. See <a href="general.htm#i1006919">"Managing Object Dependencies"</a> for more information about schema object dependencies.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="i1106851"></a>
<div id="ADMIN11673" class="sect2">
<h3 class="sect2">Performing <a id="sthref2294"></a>Intermediate Synchronization</h3>
<p>After the redefinition process has been started by calling <code dir="ltr">START_REDEF_TABLE</code> and before <code dir="ltr">FINISH_REDEF_TABLE</code> has been called, a large number of DML statements might have been executed on the original table. If you know that this is the case, it is recommended that you periodically synchronize the interim table with the original table. This is done by calling the <code dir="ltr">SYNC_INTERIM_TABLE</code> procedure. Calling this procedure reduces the time taken by <code dir="ltr">FINISH_REDEF_TABLE</code> to complete the redefinition process. There is no limit to the number of times that you can call <code dir="ltr">SYNC_INTERIM_TABLE</code>.</p>
<p>The small amount of time that the original table is locked during <code dir="ltr">FINISH_REDEF_TABLE</code> is independent of whether <code dir="ltr">SYNC_INTERIM_TABLE</code> has been called.</p>
</div>
<!-- class="sect2" -->
<a id="i1006856"></a>
<div id="ADMIN11674" class="sect2">
<h3 class="sect2"><a id="sthref2295"></a>Aborting Online Table Redefinition and Cleaning Up After Errors</h3>
<p>In the event that an error is raised during the redefinition process, or if you choose to terminate the redefinition process, call <code dir="ltr">ABORT_REDEF_TABLE</code>. This procedure drops temporary logs and tables associated with the redefinition process. After this procedure is called, you can drop the interim table and its dependent objects.</p>
<p>If the online redefinition process must be restarted, if you do not first call <code dir="ltr">ABORT_REDEF_TABLE</code>, subsequent attempts to redefine the table will fail.</p>
</div>
<!-- class="sect2" -->
<a id="i1106919"></a>
<div id="ADMIN01510" class="sect2">
<h3 class="sect2">Restrictions for Online Redefinition of Tables<a id="sthref2296"></a></h3>
<p>The following restrictions apply to the online redefinition of tables:</p>
<ul>
<li>
<p>If the table is to be redefined using primary key or pseudo-primary keys (unique keys or constraints with all component columns having <span class="italic">not null</span> constraints), then the post-redefinition table must have the same primary key or pseudo-primary key columns. If the table is to be redefined using rowids, then the table must not be an index-organized table.</p>
</li>
<li>
<p>After redefining a table that has a materialized view log, the subsequent refresh of any dependent materialized view must be a complete refresh.</p>
</li>
<li>
<p>Tables that are replicated in an n-way master configuration can be redefined, but horizontal subsetting (subset of rows in the table), vertical subsetting (subset of columns in the table), and column transformations are not allowed.</p>
</li>
<li>
<p>The overflow table of an index-organized table cannot be redefined online independently.</p>
</li>
<li>
<p>Tables with fine-grained access control (row-level security) cannot be redefined online.</p>
</li>
<li>
<p>Tables for which Flashback Data Archive is enabled cannot be redefined online. You cannot enable Flashback Data Archive for the interim table.</p>
</li>
<li>
<p>Tables with <code dir="ltr">BFILE</code> columns cannot be redefined online.</p>
</li>
<li>
<p>Tables with <code dir="ltr">LONG</code> columns can be redefined online, but those columns must be converted to <code dir="ltr">CLOBS</code>. Also, <code dir="ltr">LONG RAW</code> columns must be converted to <code dir="ltr">BLOBS</code>. Tables with <code dir="ltr">LOB</code> columns are acceptable.</p>
</li>
<li>
<p>On a system with sufficient resources for parallel execution, and in the case where the interim table is not partitioned, redefinition of a <code dir="ltr">LONG</code> column to a <code dir="ltr">LOB</code> column can be executed in parallel, provided that:</p>
<ul>
<li>
<p>The segment used to store the <code dir="ltr">LOB</code> column in the interim table belongs to a locally managed tablespace with Automatic Segment Space Management (ASSM) enabled.</p>
</li>
<li>
<p>There is a simple mapping from one <code dir="ltr">LONG</code> column to one <code dir="ltr">LOB</code> column, and the interim table has only one <code dir="ltr">LOB</code> column.</p>
</li>
</ul>
<p>In the case where the interim table is partitioned, the normal methods for parallel execution for partitioning apply.</p>
</li>
<li>
<p>Tables in the <code dir="ltr">SYS</code> and <code dir="ltr">SYSTEM</code> schema cannot be redefined online.</p>
</li>
<li>
<p>Temporary tables cannot be redefined.</p>
</li>
<li>
<p>A subset of rows in the table cannot be redefined.</p>
</li>
<li>
<p>Only simple deterministic expressions, sequences, and <code dir="ltr">SYSDATE</code> can be used when mapping the columns in the interim table to those of the original table. For example, subqueries are not allowed.</p>
</li>
<li>
<p>If new columns are being added as part of the redefinition and there are no column mappings for these columns, then they must not be declared <code dir="ltr">NOT</code> <code dir="ltr">NULL</code> until the redefinition is complete.</p>
</li>
<li>
<p>There cannot be any referential constraints between the table being redefined and the interim table.</p>
</li>
<li>
<p>Table redefinition cannot be done <code dir="ltr">NOLOGGING</code>.</p>
</li>
<li>
<p>For materialized view logs and queue tables, online redefinition is restricted to changes in physical properties. No horizontal or vertical subsetting is permitted, nor are any column transformations. The only valid value for the column mapping string is <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>You cannot perform online redefinition on a table that is partitioned if the table includes one or more nested tables.</p>
</li>
<li>
<p>You can convert a <code dir="ltr">VARRAY</code> to a nested table with the <code dir="ltr">CAST</code> operator in the column mapping. However, you cannot convert a nested table to a <code dir="ltr">VARRAY</code>.</p>
</li>
<li>
<p>When the columns in the <code dir="ltr">col_mapping</code> parameter of the <code dir="ltr">DBMS_REDEFINITION.START_REDEF_TABLE</code> procedure include a sequence, the <code dir="ltr">orderby_cols</code> parameter must be <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>Online redefinition cannot run on multiple tables concurrently in separate <code dir="ltr">DBMS_REDEFINITION</code> sessions if the tables are related by reference partitioning.</p>
<p>See <a class="olink VLDBG1093" href="../../server.112/e25523/part_admin001.htm#VLDBG1093"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for more information about reference partitioning.</p>
</li>
<li>
<p>Online redefinition of an object table or <code dir="ltr">XMLType</code> table can cause a dangling <code dir="ltr">REF</code> in other tables if those other tables have a <code dir="ltr">REF</code> column that references the redefined table.</p>
<p>See <a class="olink SQLRF51006" href="../../server.112/e41084/sql_elements001.htm#SQLRF51006"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about dangling <code dir="ltr">REF</code>s.</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<a id="CJAHDGEC"></a>
<div id="ADMIN11675" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Online Rede<a id="sthref2297"></a><a id="sthref2298"></a>finition of a Single Partition</h3>
<p>Beginning with Oracle Database 10g Release 2, you can redefine online a single partition of a table. This is useful if, for example, you want to move a partition to a different tablespace and keep the partition available for DML during the operation.</p>
<p>Another use for this capability is redefining an entire table, but doing it one partition at a time to reduce resource requirements. For example, to move a very large table to a different tablespace, you can move it one partition at a time to minimize the free space and undo space required to complete the move.</p>
<p>Redefining a single partition differs from redefining a table in the following ways:</p>
<ul>
<li>
<p>There is no need to copy dependent objects. It is not valid to use the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure when redefining a single partition.</p>
</li>
<li>
<p>You must manually create any local indexes on the interim table.</p>
</li>
<li>
<p>The column mapping string for <code dir="ltr">START_REDEF_TABLE</code> must be <code dir="ltr">NULL</code>.</p>
</li>
<li>
<p>When using the by-rowid method, the final phase of redefinition drops the hidden column <code dir="ltr">M_ROW$$</code> instead of setting it unused.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
If it is not important to keep a partition available for DML when moving it to another tablespace, you can use the simpler <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">MOVE</code> <code dir="ltr">PARTITION</code> statement.
<p>See also:</p>
<ul>
<li>
<p>The section "Moving Partitions" in <a class="olink VLDBG1193" href="../../server.112/e25523/part_admin002.htm#VLDBG1193"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a></p>
</li>
<li>
<p><a class="olink SQLRF01001" href="../../server.112/e41084/statements_3001.htm#SQLRF01001"><span class="italic">Oracle Database SQL Language Reference</span></a> for details on the <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">MOVE</code> <code dir="ltr">PARTITION</code> statement</p>
</li>
</ul>
</div>
<a id="CJABGDDJ"></a>
<div id="ADMIN11676" class="sect3"><!-- infolevel="all" infotype="General" -->
<h4 class="sect3">Rules for Online Rede<a id="sthref2299"></a><a id="sthref2300"></a>finition of a Single Partition</h4>
<p>The underlying mechanism for redefinition of a single partition is the <span class="bold">exchange partition</span> capability of the database (<code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code>...<code dir="ltr">EXCHANGE</code> <code dir="ltr">PARTITION</code>). Rules and restrictions for online redefinition of a single partition are therefore governed by this mechanism. Here are some general restrictions:</p>
<ul>
<li>
<p>No logical changes (such as adding or dropping a column) are permitted.</p>
</li>
<li>
<p>No changes to the partitioning method (such as changing from range partitioning to hash partitioning) are permitted.</p>
</li>
</ul>
<p>Here are the rules for defining the interim table:</p>
<ul>
<li>
<p>If the partition being redefined is a range, hash, or list partition, the interim table must be nonpartitioned.</p>
</li>
<li>
<p>If the partition being redefined is a range partition of a composite range-hash partitioned table, the interim table must be a hash partitioned table. In addition, the partitioning key of the interim table must be identical to the subpartitioning key of the range-hash partitioned table, and the number of partitions in the interim table must be identical to the number of subpartitions in the range partition being redefined.</p>
</li>
<li>
<p>If the partition being redefined is a hash partition that uses the rowid redefinition method, then row movement must be enabled on the interim table before redefinition starts.</p>
</li>
<li>
<p>If the partition being redefined is a range partition of a composite range-list partitioned table, the interim table must be a list partitioned table. In addition, the partitioning key of the interim table must be identical to the subpartitioning key of the range-list partitioned table, and the values lists of the interim table's list partitions must exactly match the values lists of the list subpartitions in the range partition being redefined.</p>
</li>
<li>
<p>If you define the interim table as compressed, then you must use the by-key method of redefinition, not the by-rowid method.</p>
</li>
</ul>
<p>These additional rules apply if the table being redefined is a partitioned index-organized table:</p>
<ul>
<li>
<p>The interim table must also be index-organized.</p>
</li>
<li>
<p>The original and interim tables must have primary keys on the same columns, in the same order.</p>
</li>
<li>
<p>If key compression is enabled, it must be enabled for both the original and interim tables, with the same prefix length.</p>
</li>
<li>
<p>Both the original and interim tables must have overflow segments, or neither can have them. Likewise for mapping tables.</p>
</li>
<li>
<p>Both the original and interim tables must have identical storage attributes for any LOB columns.</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
The section "Exchanging Partitions" in <a class="olink VLDBG1156" href="../../server.112/e25523/part_admin002.htm#VLDBG1156"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a></div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1006859"></a>
<div id="ADMIN11677" class="sect2">
<h3 class="sect2"><a id="sthref2301"></a>Online Table Redefinition Examples</h3>
<p>For the following examples, see <a class="olink ARPLS042" href="../../appdev.112/e40758/d_redefi.htm#ARPLS042"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for descriptions of all <code dir="ltr">DBMS_REDEFINITION</code> subprograms.</p>
<div class="inftblinformal">
<table class="cellalignment1333" title="Online Table Redefinition Examples" summary="This table summarizes the purpose of each of the four online redefinition example and provides hyperlinks to each." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t63">Example</th>
<th class="cellalignment1334" id="r1c2-t63">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t63" headers="r1c1-t63"><a href="#CJAEBFJA">Example 1</a></td>
<td class="cellalignment1335" headers="r2c1-t63 r1c2-t63">Redefines a table by adding new columns and adding partitioning.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t63" headers="r1c1-t63"><a href="#CJAEIAED">Example 2</a></td>
<td class="cellalignment1335" headers="r3c1-t63 r1c2-t63">Demonstrates redefinition with object data types.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t63" headers="r1c1-t63"><a href="#CJAGDACH">Example 3</a></td>
<td class="cellalignment1335" headers="r4c1-t63 r1c2-t63">Demonstrates redefinition with manually registered dependent objects.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t63" headers="r1c1-t63"><a href="#CJABBFDH">Example 4</a></td>
<td class="cellalignment1335" headers="r5c1-t63 r1c2-t63">Redefines a single table partition, moving it to a different tablespace.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblinformal" -->
<p class="subhead2"><a id="CJAEBFJA"></a><a id="ADMIN12636"></a>Example 1</p>
<p>This example illustrates online redefinition of the previously created table <code dir="ltr">hr.admin_emp</code>, which at this point only contains columns: <code dir="ltr">empno</code>, <code dir="ltr">ename</code>, <code dir="ltr">job</code>, <code dir="ltr">deptno</code>. The table is redefined as follows:</p>
<ul>
<li>
<p>New columns <code dir="ltr">mgr</code>, <code dir="ltr">hiredate</code>, <code dir="ltr">sal</code>, and <code dir="ltr">bonus</code> are added. (These existed in the original table but were dropped in previous examples.)</p>
</li>
<li>
<p>The new column <code dir="ltr">bonus</code> is initialized to 0</p>
</li>
<li>
<p>The column <code dir="ltr">deptno</code> has its value increased by 10.</p>
</li>
<li>
<p>The redefined table is partitioned by range on <code dir="ltr">empno</code>.</p>
</li>
</ul>
<p>The steps in this redefinition are illustrated below.</p>
<ol>
<li>
<p>Verify that the table is a candidate for online redefinition. In this case you specify that the redefinition is to be done using primary keys or pseudo-primary keys.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.CAN_REDEF_TABLE('hr','admin_emp',
      DBMS_REDEFINITION.CONS_USE_PK);
END;
/
</pre></li>
<li>
<p>Create an interim table <code dir="ltr">hr.int_admin_emp</code>.</p>
<pre dir="ltr">
CREATE TABLE hr.int_admin_emp
        (empno      NUMBER(5) PRIMARY KEY,
         ename      VARCHAR2(15) NOT NULL,
         job        VARCHAR2(10),
         mgr        NUMBER(5),
         hiredate   DATE DEFAULT (sysdate),
         sal        NUMBER(7,2),
         deptno     NUMBER(3) NOT NULL,
         bonus      NUMBER (7,2) DEFAULT(1000))
     PARTITION BY RANGE(empno)
       (PARTITION emp1000 VALUES LESS THAN (1000) TABLESPACE admin_tbs,
        PARTITION emp2000 VALUES LESS THAN (2000) TABLESPACE admin_tbs2);
</pre></li>
<li>
<p>Start the redefinition process.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.START_REDEF_TABLE('hr', 'admin_emp','int_admin_emp',
       'empno empno, ename ename, job job, deptno+10 deptno, 0 bonus',
        dbms_redefinition.cons_use_pk);
END;
/
</pre></li>
<li>
<p>Copy dependent objects. (Automatically create any triggers, indexes, materialized view logs, grants, and constraints on <code dir="ltr">hr.int_admin_emp</code>.)</p>
<pre dir="ltr">
DECLARE
num_errors PLS_INTEGER;
BEGIN
  DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS('hr', 'admin_emp','int_admin_emp',
   DBMS_REDEFINITION.CONS_ORIG_PARAMS, TRUE, TRUE, TRUE, TRUE, num_errors);
END;
/
</pre>
<p>Note that the <code dir="ltr">ignore_errors</code> argument is set to <code dir="ltr">TRUE</code> for this call. The reason is that the interim table was created with a primary key constraint, and when <code dir="ltr">COPY_TABLE_DEPENDENTS</code> attempts to copy the primary key constraint and index from the original table, errors occurs. You can ignore these errors, but you must run the query shown in the next step to see if there are other errors.</p>
</li>
<li>
<p>Query the <code dir="ltr">DBA_REDEFINITION_ERRORS</code> view to check for errors.</p>
<pre dir="ltr">
SQL&gt; select object_name, base_table_name, ddl_txt from
         DBA_REDEFINITION_ERRORS;
 
OBJECT_NAME   BASE_TABLE_NAME  DDL_TXT
------------- ---------------- ------------------------------
SYS_C005836   ADMIN_EMP        CREATE UNIQUE INDEX "HR"."TMP$
                               $_SYS_C0058360" ON "HR"."INT_A
                               DMIN_EMP" ("EMPNO")
 
SYS_C005836   ADMIN_EMP        ALTER TABLE "HR"."INT_ADMIN_EM
                               P" ADD CONSTRAINT "TMP$$_SYS_C
                               0058360" PRIMARY KEY
</pre>
<p>These errors are caused by the existing primary key constraint on the interim table and can be ignored. Note that with this approach, the names of the primary key constraint and index on the post-redefined table are changed. An alternate approach, one that avoids errors and name changes, would be to define the interim table without a primary key constraint. In this case, the primary key constraint and index are copied from the original table.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The best approach is to define the interim table with a primary key constraint, use <code dir="ltr">REGISTER_DEPENDENT_OBJECT</code> to register the primary key constraint and index, and then copy the remaining dependent objects with <code dir="ltr">COPY_TABLE_DEPENDENTS</code>. This approach avoids errors and ensures that the redefined table always has a primary key and that the dependent object names do not change.</div>
</li>
<li>
<p>Optionally, synchronize the interim table <code dir="ltr">hr.int_admin_emp</code>.</p>
<pre dir="ltr">
BEGIN 
  DBMS_REDEFINITION.SYNC_INTERIM_TABLE('hr', 'admin_emp', 'int_admin_emp');
END;
/
</pre></li>
<li>
<p>Complete the redefinition.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.FINISH_REDEF_TABLE('hr', 'admin_emp', 'int_admin_emp');
END;
/
</pre>
<p>The table <code dir="ltr">hr.admin_emp</code> is locked in the exclusive mode only for a small window toward the end of this step. After this call the table <code dir="ltr">hr.admin_emp</code> is redefined such that it has all the attributes of the <code dir="ltr">hr.int_admin_emp</code> table.</p>
</li>
<li>
<p>Wait for any long-running queries against the interim table to complete, and then drop the interim table.</p>
</li>
</ol>
<p class="subhead2"><a id="CJAEIAED"></a><a id="ADMIN12637"></a>Example 2</p>
<p>This example redefines a table to change columns into object attributes. The redefined table gets a new column that is an object type.</p>
<p>The original table, named <code dir="ltr">CUSTOMER</code>, is defined as follows:</p>
<pre dir="ltr">
Name         Type          
------------ ------------- 
CID          NUMBER            &lt;- Primary key
NAME         VARCHAR2(30)  
STREET       VARCHAR2(100) 
CITY         VARCHAR2(30)  
STATE        VARCHAR2(2)   
ZIP          NUMBER(5)     
</pre>
<p>The type definition for the new object is:</p>
<pre dir="ltr">
CREATE TYPE ADDR_T AS OBJECT (  
   street VARCHAR2(100),        
   city VARCHAR2(30),           
   state VARCHAR2(2),           
   zip NUMBER(5, 0) );          
</pre>
<p>Here are the steps for this redefinition:</p>
<ol>
<li>
<p>Verify that the table is a candidate for online redefinition. Specify that the redefinition is to be done using primary keys or pseudo-primary keys.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.CAN_REDEF_TABLE('STEVE','CUSTOMER',
        DBMS_REDEFINITION.CONS_USE_PK);
END;
/
</pre></li>
<li>
<p>Create the interim table <code dir="ltr">int_customer</code>.</p>
<pre dir="ltr">
CREATE TABLE INT_CUSTOMER(
  CID NUMBER,
  NAME  VARCHAR2(30),          
  ADDR  ADDR_T);             
  
</pre>
<p>Note that no primary key is defined on the interim table. When dependent objects are copied in step <a href="#CJAJJECE">5</a>, the primary key constraint and index are copied.</p>
</li>
<li>
<p>Because <code dir="ltr">CUSTOMER</code> is a very large table, specify parallel operations for the next step.</p>
<pre dir="ltr">
alter session force parallel dml parallel 4;
alter session force parallel query parallel 4;
</pre></li>
<li>
<p>Start the redefinition process using primary keys.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.START_REDEF_TABLE(
   uname       =&gt; 'STEVE',
   orig_table  =&gt; 'CUSTOMER',
   int_table   =&gt; 'INT_CUSTOMER',
   col_mapping =&gt; 'cid cid,  name name,
      addr_t(street, city, state, zip) addr');
END;
/
</pre>
<p>Note that <code dir="ltr">addr_t(street, city, state, zip)</code> is a call to the object constructor.</p>
</li>
<li id="CJAJJECE">
<p>Copy dependent objects.</p>
<pre dir="ltr">
DECLARE
num_errors PLS_INTEGER;
BEGIN
  DBMS_REDEFINITION.COPY_TABLE_DEPENDENTS(
   'STEVE','CUSTOMER','INT_CUSTOMER',DBMS_REDEFINITION.CONS_ORIG_PARAMS,
    TRUE, TRUE, TRUE, FALSE, num_errors, TRUE);
END;
/
</pre>
<p>Note that for this call, the final argument indicates that table statistics are to be copied to the interim table.</p>
</li>
<li>
<p>Optionally synchronize the interim table.</p>
<pre dir="ltr">
BEGIN 
  DBMS_REDEFINITION.SYNC_INTERIM_TABLE('STEVE', 'CUSTOMER', 'INT_CUSTOMER');
END;
/
</pre></li>
<li>
<p>Complete the redefinition.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.FINISH_REDEF_TABLE('STEVE', 'CUSTOMER', 'INT_CUSTOMER');
END;
/
</pre></li>
<li>
<p>Wait for any long-running queries against the interim table to complete, and then drop the interim table.</p>
</li>
</ol>
<p class="subhead2"><a id="CJAGDACH"></a><a id="ADMIN12638"></a>Example 3</p>
<p>This example addresses the situation where a dependent object must be manually created and registered.</p>
<p>Consider the case where a table <code dir="ltr">T1</code> has a column named <code dir="ltr">C1</code>, and where this column becomes <code dir="ltr">C2</code> after the redefinition. Assume that there is an index <code dir="ltr">Index1</code> on <code dir="ltr">C1</code>. In this case, <code dir="ltr">COPY_TABLE_DEPENDENTS</code> tries to create an index on the interim table corresponding to <code dir="ltr">Index1</code>, and tries to create it on a column <code dir="ltr">C1</code>, which does not exist on the interim table. This results in an error. You must therefore manually create the index on column <code dir="ltr">C2</code> and register it. Here are the steps:</p>
<ol>
<li>
<p>Create the interim table <code dir="ltr">INT_T1</code> and create an index <code dir="ltr">Int_Index1</code> on column <code dir="ltr">C2</code>.</p>
</li>
<li>
<p>Ensure that <code dir="ltr">T1</code> is a candidate for online redefinition with <code dir="ltr">CAN_REDEF_TABLE</code>, and then begin the redefinition process with <code dir="ltr">START_REDEF_TABLE</code>.</p>
</li>
<li>
<p>Register the original (<code dir="ltr">Index1</code>) and interim (<code dir="ltr">Int_Index1</code>) dependent objects.</p>
<pre dir="ltr">
BEGIN
 DBMS_REDEFINITION.REGISTER_DEPENDENT_OBJECT(
   uname         =&gt; 'STEVE',
   orig_table    =&gt; 'T1',
   int_table     =&gt; 'INT_T1',
   dep_type      =&gt; DBMS_REDEFINITION.CONS_INDEX,
   dep_owner     =&gt; 'STEVE',
   dep_orig_name =&gt; 'Index1',
   dep_int_name  =&gt; 'Int_Index1');
END;
/
</pre></li>
<li>
<p>Use <code dir="ltr">COPY_TABLE_DEPENDENTS</code> to copy the remaining dependent objects.</p>
</li>
<li>
<p>Optionally synchronize the interim table.</p>
</li>
<li>
<p>Complete the redefinition and drop the interim table.</p>
</li>
</ol>
<p class="subhead2"><a id="CJABBFDH"></a><a id="ADMIN12639"></a>Example 4</p>
<p>This example demonstrates redefining a single partition. It moves the oldest partition of a range-partitioned sales table to a tablespace named <code dir="ltr">TBS_LOW_FREQ</code>. The table containing the partition to be redefined is defined as follows:</p>
<pre dir="ltr">
CREATE TABLE salestable
(s_productid NUMBER,
s_saledate DATE,
s_custid NUMBER,
s_totalprice NUMBER)
TABLESPACE users
PARTITION BY RANGE(s_saledate)
(PARTITION sal03q1 VALUES LESS THAN (TO_DATE('01-APR-2003', 'DD-MON-YYYY')),
PARTITION sal03q2 VALUES LESS THAN (TO_DATE('01-JUL-2003', 'DD-MON-YYYY')),
PARTITION sal03q3 VALUES LESS THAN (TO_DATE('01-OCT-2003', 'DD-MON-YYYY')),
PARTITION sal03q4 VALUES LESS THAN (TO_DATE('01-JAN-2004', 'DD-MON-YYYY')));
</pre>
<p>The table has a local partitioned index that is defined as follows:</p>
<pre dir="ltr">
CREATE INDEX sales_index ON salestable 
   (s_saledate, s_productid, s_custid) LOCAL;
</pre>
<p>Here are the steps. In the following procedure calls, note the extra argument: partition name (<code dir="ltr">part_name</code>).</p>
<ol>
<li>
<p>Ensure that <code dir="ltr">salestable</code> is a candidate for redefinition.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.CAN_REDEF_TABLE(
   uname        =&gt; 'STEVE',
   tname        =&gt; 'SALESTABLE',
   options_flag =&gt; DBMS_REDEFINITION.CONS_USE_ROWID,
   part_name    =&gt; 'sal03q1');
END;
/
</pre></li>
<li>
<p>Create the interim table in the <code dir="ltr">TBS_LOW_FREQ</code> tablespace. Because this is a redefinition of a range partition, the interim table is nonpartitioned.</p>
<pre dir="ltr">
CREATE TABLE int_salestable
(s_productid NUMBER,
s_saledate DATE,
s_custid NUMBER,
s_totalprice NUMBER)
TABLESPACE tbs_low_freq;
</pre></li>
<li>
<p>Start the redefinition process using rowid.</p>
<pre dir="ltr">
BEGIN
  DBMS_REDEFINITION.START_REDEF_TABLE(
   uname        =&gt; 'STEVE',
   orig_table   =&gt; 'salestable',
   int_table    =&gt; 'int_salestable',
   col_mapping  =&gt; NULL,
   options_flag =&gt; DBMS_REDEFINITION.CONS_USE_ROWID,
   part_name    =&gt; 'sal03q1');
END;
/
</pre></li>
<li>
<p>Manually create any local indexes on the interim table.</p>
<pre dir="ltr">
CREATE INDEX int_sales_index ON int_salestable 
(s_saledate, s_productid, s_custid)
TABLESPACE tbs_low_freq; 
</pre></li>
<li>
<p>Optionally synchronize the interim table.</p>
<pre dir="ltr">
BEGIN 
  DBMS_REDEFINITION.SYNC_INTERIM_TABLE(
   uname      =&gt; 'STEVE', 
   orig_table =&gt; 'salestable', 
   int_table  =&gt; 'int_salestable',
   part_name  =&gt; 'sal03q1');
END;
/
</pre></li>
<li>
<p>Complete the redefinition.</p>
<pre dir="ltr">
BEGIN 
  DBMS_REDEFINITION.FINISH_REDEF_TABLE(
   uname      =&gt; 'STEVE', 
   orig_table =&gt; 'salestable', 
   int_table  =&gt; 'int_salestable',
   part_name  =&gt; 'sal03q1');
END;
/
</pre></li>
<li>
<p>Wait for any long-running queries against the interim table to complete, and then drop the interim table.</p>
</li>
</ol>
<p>The following query shows that the oldest partition has been moved to the new tablespace:</p>
<pre dir="ltr">
select partition_name, tablespace_name from user_tab_partitions
 where table_name = 'SALESTABLE';
 
PARTITION_NAME                 TABLESPACE_NAME
------------------------------ ------------------------------
SAL03Q1                        TBS_LOW_FREQ
SAL03Q2                        USERS
SAL03Q3                        USERS
SAL03Q4                        USERS
 
4 rows selected.
</pre></div>
<!-- class="sect2" -->
<a id="i1006801"></a>
<div id="ADMIN11678" class="sect2">
<h3 class="sect2">Privileges Required for the DBMS_REDEFINITION Package</h3>
<p>Execute privileges on the <code dir="ltr"><a id="sthref2302"></a><a id="sthref2303"></a>DBMS_REDEFINITION</code> package are required to run subprograms in the package. Execute privileges on the <code dir="ltr"><a id="sthref2304"></a><a id="sthref2305"></a>DBMS_REDEFINITION</code> package are granted to <code dir="ltr">EXECUTE_CATALOG_ROLE</code>.</p>
<p>In addition, for a user to redefine a table in the user's schema using the package, the user must be granted the following privileges:</p>
<ul>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">MATERIALIZED</code> <code dir="ltr">VIEW</code></p>
</li>
</ul>
<p>The <code dir="ltr">CREATE TRIGGER</code> privilege is also required to execute the <code dir="ltr">COPY_TABLE_DEPENDENTS</code> procedure.</p>
<p>For a user to redefine a table in other schemas using the package, the user must be granted the following privileges:</p>
<ul>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">DROP</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">LOCK</code> <code dir="ltr">ANY TABLE</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
</ul>
<p>The following additional privileges are required to execute <code dir="ltr">COPY_TABLE_DEPENDENTS</code> on tables in other schemas:</p>
<ul>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TRIGGER</code></p>
</li>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">INDEX</code></p>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010007"></a>
<div id="ADMIN01513" class="sect1">
<h2 class="sect1">Researching and Reversing Erroneous Ta<a id="sthref2306"></a><a id="sthref2307"></a>ble Changes</h2>
<p>To enable you to research and reverse erroneous changes to tables, Oracle Database provides a a group of features that you can use to view past states of database objects or to return database objects to a previous state without using point-in-time media recovery. These features are known as <span class="bold">Oracle Flashback features</span>, and are described in <a class="olink ADFNS1008" href="../../appdev.112/e41502/adfns_flashback.htm#ADFNS1008"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a>.</p>
<p>To research an erroneous change, you can use multiple Oracle Flashback queries to view row data at specific points in time. A more efficient approach would be to use Oracle Flashback Version Query to view all changes to a row over a period of time. With this feature, you append a <code dir="ltr">VERSIONS</code> clause to a <code dir="ltr">SELECT</code> statement that specifies a system change number (SCN) or timestamp range between which you want to view changes to row values. The query also can return associated metadata, such as the transaction responsible for the change.</p>
<p>After you identify an erroneous transaction, you can use Oracle Flashback Transaction Query to identify other changes that were made by the transaction. You can then use Oracle Flashback Transaction to reverse the erroneous transaction. (Note that Oracle Flashback Transaction must also reverse all dependent transactions&mdash;subsequent transactions involving the same rows as the erroneous transaction.) You also have the option of using Oracle Flashback Table, described in <a href="#i1010008">"Recovering Tables Using Oracle Flashback Table"</a>.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must be using automatic undo management to use Oracle Flashback features. See <a href="undo.htm#BJFEHEIC">"Introduction to Automatic Undo Management"</a>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADFNS1008" href="../../appdev.112/e41502/adfns_flashback.htm#ADFNS1008"><span class="italic">Oracle Database Advanced Application Developer's Guide</span></a> for information about Oracle Flashback features.</div>
</div>
<!-- class="sect1" -->
<a id="i1010008"></a>
<div id="ADMIN01512" class="sect1">
<h2 class="sect1">Recovering Tables Using Oracle Flash<a id="sthref2308"></a>back Table</h2>
<p>Oracle Flashback Table enables you to restore a table to its state as of a previous point in time. It provides a fast, online solution for recovering a table that has been accidentally modified or deleted by a user or application. In many cases, Oracle Flashback Table eliminates the need for you to perform more complicated point-in-time recovery operations.<a id="sthref2309"></a></p>
<p>Oracle Flashback Table:</p>
<ul>
<li>
<p>Restores all data in a specified table to a previous point in time described by a timestamp or SCN.</p>
</li>
<li>
<p>Performs the restore operation online.</p>
</li>
<li>
<p>Automatically maintains all of the table attributes, such as indexes, triggers, and constraints that are necessary for an application to function with the flashed-back table.</p>
</li>
<li>
<p>Maintains any remote state in a distributed environment. For example, all of the table modifications required by replication if a replicated table is flashed back.</p>
</li>
<li>
<p>Maintains data integrity as specified by constraints. Tables are flashed back provided none of the table constraints are violated. This includes any referential integrity constraints specified between a table included in the <code dir="ltr">FLASHBACK TABLE</code> statement and another table that is not included in the <code dir="ltr">FLASHBACK TABLE</code> statement.</p>
</li>
<li>
<p>Even after a flashback operation, the data in the original table is not lost. You can later revert to the original state.</p>
</li>
</ul>
<div class="infobox-note">
<p class="notep1">Note:</p>
You must be using automatic undo management to use Oracle Flashback Table. See <a href="undo.htm#BJFEHEIC">"Introduction to Automatic Undo Management"</a>.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink BRADV81517" href="../../backup.112/e10642/rcmflash.htm#BRADV81517"><span class="italic">Oracle Database Backup and Recovery User's Guide</span></a> for more information about the <code dir="ltr">FLASHBACK TABLE</code> statement.</div>
</div>
<!-- class="sect1" -->
<a id="i1011125"></a>
<div id="ADMIN01505" class="sect1">
<h2 class="sect1">Dropping Tables</h2>
<p><a id="sthref2310"></a><a id="sthref2311"></a>To drop a table that you no longer need, use the <code dir="ltr">DROP TABLE</code> statement. <a id="sthref2312"></a>The table must be contained in your schema or you must have the <code dir="ltr">DROP ANY TABLE</code> system privilege.</p>
<div class="infobox-note">
<p class="notep1">Caution:</p>
Before dropping a table<a id="sthref2313"></a>, familiarize yourself with the consequences of doing so:
<ul>
<li>
<p>Dropping a table removes the table definition from the data dictionary. All rows of the table are no longer accessible.</p>
</li>
<li>
<p>All indexes and triggers associated with a table are dropped.</p>
</li>
<li>
<p>All views and PL/SQL program units dependent on a dropped table remain, yet become invalid (not usable). See <a href="general.htm#i1006919">"Managing Object Dependencies"</a> for information about how the database manages dependencies.</p>
</li>
<li>
<p>All synonyms for a dropped table remain, but return an error when used.</p>
</li>
<li>
<p>All extents allocated for a table that is dropped are returned to the free space of the tablespace and can be used by any other object requiring new extents or new objects. All rows corresponding to a clustered table are deleted from the blocks of the cluster. Clustered tables are the subject of <a href="clustrs.htm#g1009415">Chapter 22, "Managing Clusters"</a>.</p>
</li>
</ul>
</div>
<p>The following statement drops the <code dir="ltr">hr.int_admin_emp</code> table:</p>
<pre dir="ltr">
DROP TABLE hr.int_admin_emp;
</pre>
<p><a id="sthref2314"></a>If the table to be dropped contains any primary or unique keys referenced by foreign keys of other tables and you intend to drop the <code dir="ltr">FOREIGN KEY</code> constraints of the child tables, then include the <code dir="ltr"><a id="sthref2315"></a>CASCADE</code> clause in the <code dir="ltr">DROP TABLE</code> statement, as shown below:</p>
<pre dir="ltr">
DROP TABLE hr.admin_emp CASCADE CONSTRAINTS;
</pre>
<p>When you drop a table, normally the database does not immediately release the space associated with the table. Rather, the database renames the table and places it in a recycle bin, where it can later be recovered with the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> statement if you find that you dropped the table in error. If you should want to immediately release the space associated with the table at the time you issue the <code dir="ltr">DROP TABLE</code> statement, include the <code dir="ltr">PURGE</code> clause as shown in the following statement:</p>
<pre dir="ltr">
DROP TABLE hr.admin_emp PURGE;
</pre>
<p>Perhaps instead of dropping a table, you want to truncate it. The <code dir="ltr"><a id="sthref2316"></a>TRUNCATE</code> statement provides a fast, efficient method for deleting all rows from a table, but it does not affect any structures associated with the table being truncated (column definitions, constraints, triggers, and so forth) or authorizations. The <code dir="ltr">TRUNCATE</code> statement is discussed in <a href="general.htm#i1006449">"Truncating Tables and Clusters"</a>.</p>
</div>
<!-- class="sect1" -->
<a id="i1010137"></a>
<div id="ADMIN01511" class="sect1">
<h2 class="sect1">Using Flashback Drop and Managing the Recycle Bin<a id="sthref2317"></a></h2>
<p>When you drop a table, the database does not immediately remove the space associated with the table. The database renames the table and places it and any associated objects in a recycle bin, where, in case the table was dropped in error, it can be recovered at a later time. This feature is called <a id="sthref2318"></a>Flashback Drop, and the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> statement is used to restore the table. Before discussing the use of the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> statement for this purpose, it is important to understand how the recycle bin works, and how you manage its contents.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1011340">What Is the Recycle Bin?</a></p>
</li>
<li>
<p><a href="#i1010757">Viewing and Querying Objects in the Recycle Bin</a></p>
</li>
<li>
<p><a href="#i1011357">Purging Objects in the Recycle Bin</a></p>
</li>
<li>
<p><a href="#i1011362">Restoring Tables from the Recycle Bin</a></p>
</li>
</ul>
<a id="i1011340"></a>
<div id="ADMIN11679" class="sect2">
<h3 class="sect2">What Is the Recycle Bin?</h3>
<p>The <a id="sthref2319"></a><a id="sthref2320"></a>recycle bin is actually a data dictionary table containing information about dropped objects. Dropped tables and any associated objects such as indexes, constraints, nested tables, and the likes are not removed and still occupy space. They continue to count against user space quotas, until specifically purged from the recycle bin or the unlikely situation where they must be purged by the database because of tablespace space constraints.</p>
<p>Each user can be thought of as having his own recycle bin, because, unless a user has the <code dir="ltr">SYSDBA</code> privilege, the only objects that the user has access to in the recycle bin are those that the user owns. A user can view his objects in the recycle bin using the following statement:</p>
<pre dir="ltr">
SELECT * FROM RECYCLEBIN;
</pre>
<p>When you drop a tablespace including its contents, the objects in the tablespace are not placed in the recycle bin and the database purges any entries in the recycle bin for objects located in the tablespace. The database also purges any recycle bin entries for objects in a tablespace when you drop the tablespace, not including contents, and the tablespace is otherwise empty. Likewise:</p>
<ul>
<li>
<p>When you drop a user, any objects belonging to the user are not placed in the recycle bin and any objects in the recycle bin are purged.</p>
</li>
<li>
<p>When you drop a cluster, its member tables are not placed in the recycle bin and any former member tables in the recycle bin are purged.</p>
</li>
<li>
<p>When you drop a type, any dependent objects such as subtypes are not placed in the recycle bin and any former dependent objects in the recycle bin are purged.</p>
</li>
</ul>
<p class="subhead2"><a id="ADMIN12640"></a>Object Naming in the Recycle Bin</p>
<p>When a dropped table is moved to the <a id="sthref2321"></a>recycle bin, the table and its associated objects are given system-generated names. This is necessary to avoid name conflicts that may arise if multiple tables have the same name. This could occur under the following circumstances:</p>
<ul>
<li>
<p>A user drops a table, re-creates it with the same name, then drops it again.</p>
</li>
<li>
<p>Two users have tables with the same name, and both users drop their tables.</p>
</li>
</ul>
<p>The renaming convention is as follows:</p>
<pre dir="ltr">
BIN$<span class="codeinlineitalic">unique_id</span>$<span class="codeinlineitalic">version</span>
</pre>
<p>where:</p>
<ul>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">unique_id</span></code> is a 26-character globally unique identifier for this object, which makes the recycle bin name unique across all databases</p>
</li>
<li>
<p><code dir="ltr"><span class="codeinlineitalic">version</span></code> is a version number assigned by the database</p>
</li>
</ul>
</div>
<!-- class="sect2" -->
<div id="ADMIN11680" class="sect2"><!-- infolevel="all" infotype="General" --><a id="sthref2322"></a>
<h3 class="sect2">Enabling and Disabling the Recycle Bin</h3>
<p>When the recycle bin is enabled, dropped tables and their dependent objects are placed in the recycle bin. When the recycle bin is disabled, dropped tables and their dependent objects are <span class="italic">not</span> placed in the recycle bin; they are just dropped, and you must use other means to recover them (such as recovering from backup).</p>
<p>Disabling the recycle bin does not purge or otherwise affect objects already in the recycle bin. The recycle bin is enabled by default.</p>
<p>You enable and disable the recycle bin by changing the <code dir="ltr">recyclebin</code> initialization parameter. This parameter is not dynamic, so a database restart is required when you change it with an <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code> statement.</p>
<p><span class="bold">To disable the recycle bin:</span></p>
<ol>
<li>
<p>Issue one of the following statements:</p>
<pre dir="ltr">
ALTER SESSION SET recyclebin = OFF;

ALTER SYSTEM SET recyclebin = OFF SCOPE = SPFILE;
</pre></li>
<li>
<p>If you used <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code>, restart the database.</p>
</li>
</ol>
<p><span class="bold">To enable the recycle bin:</span></p>
<ol>
<li>
<p>Issue one of the following statements:</p>
<pre dir="ltr">
ALTER SESSION SET recyclebin = ON;

ALTER SYSTEM SET recyclebin = ON SCOPE = SPFILE;
</pre></li>
<li>
<p>If you used <code dir="ltr">ALTER</code> <code dir="ltr">SYSTEM</code>, restart the database.</p>
</li>
</ol>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="create.htm#i1013946">"About Initialization Parameters and Initialization Parameter Files"</a> for more information on initialization parameters</p>
</li>
<li>
<p><a href="create.htm#i1010047">"Changing Initialization Parameter Values"</a> for a description of dynamic and static initialization parameters</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1010757"></a>
<div id="ADMIN11681" class="sect2">
<h3 class="sect2">Viewing and Querying Objects in the Recycle Bin</h3>
<p>Oracle Database provides two views for obtaining information about objects in the <a id="sthref2323"></a><a id="sthref2324"></a>recycle bin:</p>
<div class="inftblruleinformal">
<table class="cellalignment1333" title="Viewing Information About the Recycle Bin" summary="Column 1 lists the views for obtaning information from the recycle bin, column 2 describes the view." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t71">View</th>
<th class="cellalignment1334" id="r1c2-t71">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t71" headers="r1c1-t71"><code dir="ltr">USER_RECYCLEBIN</code></td>
<td class="cellalignment1335" headers="r2c1-t71 r1c2-t71">This view can be used by users to see their own dropped objects in the recycle bin. It has a synonym <code dir="ltr">RECYCLEBIN</code>, for ease of use.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t71" headers="r1c1-t71"><code dir="ltr">DBA_RECYCLEBIN</code></td>
<td class="cellalignment1335" headers="r3c1-t71 r1c2-t71">This view gives administrators visibility to all dropped objects in the recycle bin</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformal" -->
<p>One use for these views is to identify the name that the database has assigned to a dropped object, as shown in the following example:</p>
<pre dir="ltr">
SELECT object_name, original_name FROM dba_recyclebin
   WHERE owner = 'HR';

OBJECT_NAME                    ORIGINAL_NAME
------------------------------ --------------------------------
BIN$yrMKlZaLMhfgNAgAIMenRA==$0 EMPLOYEES
</pre>
<p>You can also view the contents of the recycle bin using the SQL*Plus command <code dir="ltr">SHOW RECYCLEBIN</code>.</p>
<pre dir="ltr">
SQL&gt; show recyclebin

ORIGINAL NAME    RECYCLEBIN NAME                OBJECT TYPE  DROP TIME
---------------- ------------------------------ ------------ -------------------
EMPLOYEES        BIN$yrMKlZaVMhfgNAgAIMenRA==$0 TABLE        2003-10-27:14:00:19
</pre>
<p>You can query objects that are in the recycle bin, just as you can query other objects. However, you must specify the name of the object as it is identified in the recycle bin. For example:</p>
<pre dir="ltr">
SELECT * FROM "BIN$yrMKlZaVMhfgNAgAIMenRA==$0";
</pre></div>
<!-- class="sect2" -->
<a id="i1011357"></a>
<div id="ADMIN11682" class="sect2">
<h3 class="sect2">Purging Objects in the Recycle Bin</h3>
<p>If you decide that you are never going to restore an item from the <a id="sthref2325"></a><a id="sthref2326"></a>recycle bin, you can use the <code dir="ltr">PURGE</code> statement to remove the items and their associated objects from the recycle bin and release their storage space. You need the same privileges as if you were dropping the item.</p>
<p>When you use the <code dir="ltr">PURGE</code> statement to purge a table, you can use the name that the table is known by in the recycle bin or the original name of the table. The recycle bin name can be obtained from either the <code dir="ltr">DBA_</code> or <code dir="ltr">USER_RECYCLEBIN</code> view as shown in <a href="#i1010757">"Viewing and Querying Objects in the Recycle Bin"</a>. The following hypothetical example purges the table <code dir="ltr">hr.int_admin_emp</code>, which was renamed to <code dir="ltr">BIN$jsleilx392mk2=293$0</code> when it was placed in the recycle bin:</p>
<pre dir="ltr">
PURGE TABLE "BIN$jsleilx392mk2=293$0";
</pre>
<p>You can achieve the same result with the following statement:</p>
<pre dir="ltr">
PURGE TABLE int_admin_emp;
</pre>
<p>You can use the <code dir="ltr">PURGE</code> statement to purge all the objects in the recycle bin that are from a specified tablespace or only the tablespace objects belonging to a specified user, as shown in the following examples:</p>
<pre dir="ltr">
PURGE TABLESPACE example;
PURGE TABLESPACE example USER oe;
</pre>
<p>Users can purge the recycle bin of their own objects, and release space for objects, by using the following statement:</p>
<pre dir="ltr">
PURGE RECYCLEBIN;
</pre>
<p>If you have the <code dir="ltr">SYSDBA</code> privilege, then you can purge the entire recycle bin by specifying <code dir="ltr">DBA_RECYCLEBIN</code>, instead of <code dir="ltr">RECYCLEBIN</code> in the previous statement.</p>
<p>You can also use the <code dir="ltr">PURGE</code> statement to purge an index from the recycle bin or to purge from the recycle bin all objects in a specified tablespace.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01803" href="../../server.112/e41084/statements_9018.htm#SQLRF01803"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information on the <code dir="ltr">PURGE</code> statement</div>
</div>
<!-- class="sect2" -->
<a id="i1011362"></a>
<div id="ADMIN11683" class="sect2">
<h3 class="sect2">Restoring Tables from the Recycle Bin</h3>
<p>Use the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">TO</code> <code dir="ltr">BEFORE</code> <code dir="ltr">DROP</code> statement to recover objects from the recycle bin. You can specify either the name of the table in the <a id="sthref2327"></a><a id="sthref2328"></a>recycle bin or the original table name. An optional <code dir="ltr">RENAME TO</code> clause lets you rename the table as you recover it. The recycle bin name can be obtained from either the <code dir="ltr">DBA_</code> or <code dir="ltr">USER_RECYCLEBIN</code> view as shown in <a href="#i1010757">"Viewing and Querying Objects in the Recycle Bin"</a>. To use the <code dir="ltr">FLASHBACK</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">TO</code> <code dir="ltr">BEFORE</code> <code dir="ltr">DROP</code> statement, you need the same privileges required to drop the table.</p>
<p>The following example restores <code dir="ltr">int_admin_emp</code> table and assigns to it a new name:</p>
<pre dir="ltr">
FLASHBACK TABLE int_admin_emp TO BEFORE DROP 
   RENAME TO int2_admin_emp;
</pre>
<p>The system-generated recycle bin name is very useful if you have dropped a table multiple times. For example, suppose you have three versions of the <code dir="ltr">int2_admin_emp</code> table in the recycle bin and you want to recover the second version. You can do this by issuing two <code dir="ltr">FLASHBACK TABLE</code> statements, or you can query the recycle bin and then flashback to the appropriate system-generated name, as shown in the following example. Including the create time in the query can help you verify that you are restoring the correct table.</p>
<pre dir="ltr">
SELECT object_name, original_name, createtime FROM recyclebin;    

OBJECT_NAME                    ORIGINAL_NAME   CREATETIME
------------------------------ --------------- -------------------
BIN$yrMKlZaLMhfgNAgAIMenRA==$0 INT2_ADMIN_EMP  2006-02-05:21:05:52
BIN$yrMKlZaVMhfgNAgAIMenRA==$0 INT2_ADMIN_EMP  2006-02-05:21:25:13
BIN$yrMKlZaQMhfgNAgAIMenRA==$0 INT2_ADMIN_EMP  2006-02-05:22:05:53

FLASHBACK TABLE "BIN$yrMKlZaVMhfgNAgAIMenRA==$0" TO BEFORE DROP;
</pre>
<p class="subhead2"><a id="ADMIN12641"></a>Restoring Dependent Objects</p>
<p>When you restore a table from the recycle bin, dependent objects such as indexes do not get their original names back; they retain their system-generated recycle bin names. You must manually rename dependent objects to restore their original names. If you plan to manually restore original names for dependent objects, ensure that you make note of each dependent object's system-generated recycle bin name <span class="italic">before</span> you restore the table.</p>
<p>The following is an example of restoring the original names of some of the indexes of the dropped table <code dir="ltr">JOB_HISTORY</code>, from the <code dir="ltr">HR</code> sample schema. The example assumes that you are logged in as the <code dir="ltr">HR</code> user.</p>
<ol>
<li>
<p>After dropping <code dir="ltr">JOB_HISTORY</code> and before restoring it from the recycle bin, run the following query:</p>
<pre dir="ltr">
SELECT OBJECT_NAME, ORIGINAL_NAME, TYPE FROM RECYCLEBIN;

OBJECT_NAME                    ORIGINAL_NAME             TYPE
------------------------------ ------------------------- --------
BIN$DBo9UChtZSbgQFeMiAdCcQ==$0 JHIST_JOB_IX              INDEX
BIN$DBo9UChuZSbgQFeMiAdCcQ==$0 JHIST_EMPLOYEE_IX         INDEX
BIN$DBo9UChvZSbgQFeMiAdCcQ==$0 JHIST_DEPARTMENT_IX       INDEX
BIN$DBo9UChwZSbgQFeMiAdCcQ==$0 JHIST_EMP_ID_ST_DATE_PK   INDEX
BIN$DBo9UChxZSbgQFeMiAdCcQ==$0 JOB_HISTORY               TABLE
</pre></li>
<li>
<p>Restore the table with the following command:</p>
<pre dir="ltr">
FLASHBACK TABLE JOB_HISTORY TO BEFORE DROP;
</pre></li>
<li>
<p>Run the following query to verify that all <code dir="ltr">JOB_HISTORY</code> indexes retained their system-generated recycle bin names:</p>
<pre dir="ltr">
SELECT INDEX_NAME FROM USER_INDEXES WHERE TABLE_NAME = 'JOB_HISTORY';
 
INDEX_NAME
------------------------------
BIN$DBo9UChwZSbgQFeMiAdCcQ==$0
BIN$DBo9UChtZSbgQFeMiAdCcQ==$0
BIN$DBo9UChuZSbgQFeMiAdCcQ==$0
BIN$DBo9UChvZSbgQFeMiAdCcQ==$0
</pre></li>
<li>
<p>Restore the original names of the first two indexes as follows:</p>
<pre dir="ltr">
ALTER INDEX "BIN$DBo9UChtZSbgQFeMiAdCcQ==$0" RENAME TO JHIST_JOB_IX;
ALTER INDEX "BIN$DBo9UChuZSbgQFeMiAdCcQ==$0" RENAME TO JHIST_EMPLOYEE_IX;
</pre>
<p>Note that double quotes are required around the system-generated names.</p>
</li>
</ol>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1010378"></a>
<div id="ADMIN01506" class="sect1">
<h2 class="sect1">Managing Index-Organized Tables</h2>
<p><a id="sthref2329"></a>This section describes aspects of managing index-organized tables, and contains the following topics:</p>
<ul>
<li>
<p><a href="#i1007016">What Are Index-Organized Tables?</a></p>
</li>
<li>
<p><a href="#i1007046">Creating Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1007240">Maintaining Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1007291">Creating Secondary Indexes on Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1007327">Analyzing Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1007389">Using the ORDER BY Clause with Index-Organized Tables</a></p>
</li>
<li>
<p><a href="#i1007400">Converting Index-Organized Tables to Regular Tables</a></p>
</li>
</ul>
<a id="i1007016"></a>
<div id="ADMIN11684" class="sect2">
<h3 class="sect2">What Are Index-Organized Tables<a id="sthref2330"></a>?</h3>
<p>An <span class="bold">index-organized table</span> has a storage organization that is a variant of a primary B-tree. Unlike an ordinary (heap-organized) table whose data is stored as an unordered collection (heap), data for an index-organized table is stored in a B-tree index structure in a primary key sorted manner. Each leaf block in the index structure stores both the key and nonkey columns.</p>
<p>The structure of an index-organized table provides the following benefits:</p>
<ul>
<li>
<p>Fast random access on the primary key because an index-only scan is sufficient. And, because there is no separate table storage area, changes to the table data (such as adding new rows, updating rows, or deleting rows) result only in updating the index structure.</p>
</li>
<li>
<p>Fast range access on the primary key because the rows are clustered in primary key order.</p>
</li>
<li>
<p>Lower storage requirements because duplication of primary keys is avoided. They are not stored both in the index and underlying table, as is true with heap-organized tables.</p>
</li>
</ul>
<p>Index-organized tables have full table functionality. They support features such as constraints, triggers, LOB and object columns, partitioning, parallel operations, online reorganization, and replication. And, they offer these additional features:</p>
<ul>
<li>
<p>Key compression</p>
</li>
<li>
<p>Overflow storage area and specific column placement</p>
</li>
<li>
<p>Secondary indexes, including bitmap indexes.</p>
</li>
</ul>
<p>Index-organized tables are ideal for OLTP applications, which require fast primary key access and high availability. For example, queries and DML on an orders table used in electronic order processing are predominantly based on primary key access, and heavy volume of concurrent DML can cause row chaining and inefficient space usage in indexes, resulting in a frequent need to reorganize. Because an index-organized table can be reorganized online and without invalidating its secondary indexes, the window of unavailability is greatly reduced or eliminated.</p>
<p>Index-organized tables are suitable for modeling application-specific index structures. For example, content-based information retrieval applications containing text, image and audio data require inverted indexes that can be effectively modeled using index-organized tables. A fundamental component of an internet search engine is an inverted index that can be modeled using index-organized tables.</p>
<p>These are but a few of the applications for index-organized tables.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink CNCPT911" href="../../server.112/e40540/indexiot.htm#CNCPT911"><span class="italic">Oracle Database Concepts</span></a> for a more thorough description of index-organized tables</p>
</li>
<li>
<p><a class="olink VLDBG1112" href="../../server.112/e25523/part_admin001.htm#VLDBG1112"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for information about partitioning index-organized tables</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007046"></a>
<div id="ADMIN11685" class="sect2">
<h3 class="sect2">Creating Index-Organized Tables<a id="sthref2331"></a></h3>
<p>You use the <code dir="ltr"><a id="sthref2332"></a>CREATE TABLE</code> statement to create index-organized tables, but you must provide additional information:</p>
<ul>
<li>
<p>An <code dir="ltr">ORGANIZATION INDEX</code> qualifier, which indicates that this is an index-organized table</p>
</li>
<li>
<p>A primary key, specified through a column constraint clause (for a single column primary key) or a table constraint clause (for a multiple-column primary key).</p>
</li>
</ul>
<p>Optionally, you can specify the following:</p>
<ul>
<li>
<p>An <code dir="ltr">OVERFLOW</code> clause, which preserves dense clustering of the B-tree index by enabling the storage of some of the nonkey columns in a separate overflow data segment.</p>
</li>
<li>
<p>A <code dir="ltr">PCTTHRESHOLD</code> value, which, when an overflow segment is being used, defines the maximum size of the portion of the row that is stored in the index block, as a percentage of block size. Rows columns that would cause the row size to exceed this maximum are stored in the overflow segment. The row is broken at a column boundary into two pieces, a head piece and tail piece. The head piece fits in the specified threshold and is stored along with the key in the index leaf block. The tail piece is stored in the overflow area as one or more row pieces. Thus, the index entry contains the key value, the nonkey column values that fit the specified threshold, and a pointer to the rest of the row.</p>
</li>
<li>
<p>An <code dir="ltr">INCLUDING</code> clause, which can be used to specify the nonkey columns that are to be stored in the index block with the primary key.</p>
</li>
</ul>
<a id="i1007057"></a>
<div id="ADMIN11686" class="sect3">
<h4 class="sect3">Example: Creating an Index-Organized Table</h4>
<p>The following statement creates an index-organized table:</p>
<pre dir="ltr">
CREATE TABLE admin_docindex(
        token char(20), 
        doc_id NUMBER,
        token_frequency NUMBER,
        token_offsets VARCHAR2(2000),
        CONSTRAINT pk_admin_docindex PRIMARY KEY (token, doc_id))
    ORGANIZATION INDEX 
    TABLESPACE admin_tbs
    PCTTHRESHOLD 20
    OVERFLOW TABLESPACE admin_tbs2;
</pre>
<p>This example creates an index-organized table named <code dir="ltr">admin_docindex</code>, with a primary key composed of the columns <code dir="ltr">token</code> and <code dir="ltr">doc_id</code>. The <code dir="ltr">OVERFLOW</code> and <code dir="ltr">PCTTHRESHOLD</code> clauses specify that if the length of a row exceeds 20% of the index block size, then the column that exceeded that threshold and all columns after it are moved to the overflow segment. The overflow segment is stored in the <code dir="ltr">admin_tbs2</code> tablespace.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for more information about the syntax to create an index-organized table</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN12496" class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref2333"></a>
<h4 class="sect3">Restrictions for Index-Organized Tables</h4>
<p>The following are restrictions on creating index-organized tables.</p>
<ul>
<li>
<p>The maximum number of columns is 1000.</p>
</li>
<li>
<p>The maximum number of columns in the index portion of a row is 255, including both key and nonkey columns. If more than 255 columns are required, you must use an overflow segment.</p>
</li>
<li>
<p>The maximum number of columns that you can include in the primary key is 32.</p>
</li>
<li>
<p><code dir="ltr">PCTTHRESHOLD</code> must be in the range of 1&ndash;50. The default is 50.</p>
</li>
<li>
<p>All key columns must fit within the specified threshold.</p>
</li>
<li>
<p>If the maximum size of a row exceeds 50% of the index block size and you do not specify an overflow segment, the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement fails.</p>
</li>
<li>
<p>Index-organized tables cannot have virtual columns.</p>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADMIN11687" class="sect3"><a id="sthref2334"></a>
<h4 class="sect3">Creating Index-Organized Tables that Contain Object Types</h4>
<p>Index-organized tables can store <a id="sthref2335"></a>object types. The following example creates object type <code dir="ltr">admin_typ</code>, then creates an index-organized table containing a column of object type <code dir="ltr">admin_typ</code>:</p>
<pre dir="ltr">
CREATE OR REPLACE TYPE admin_typ AS OBJECT
    (col1 NUMBER, col2 VARCHAR2(6));
CREATE TABLE admin_iot (c1 NUMBER primary key, c2 admin_typ)
    ORGANIZATION INDEX;
</pre>
<p>You can also create an index-organized table of object types. For example:</p>
<pre dir="ltr">
CREATE TABLE admin_iot2 OF admin_typ (col1 PRIMARY KEY)
    ORGANIZATION INDEX;
</pre>
<p>Another example, that follows, shows that index-organized tables store <a id="sthref2336"></a>nested tables efficiently. For a nested table column, the database internally creates a storage table to hold all the nested table rows.</p>
<pre dir="ltr">
CREATE TYPE project_t AS OBJECT(pno NUMBER, pname VARCHAR2(80));
/
CREATE TYPE project_set AS TABLE OF project_t;
/
CREATE TABLE proj_tab (eno NUMBER, projects PROJECT_SET)
    NESTED TABLE projects STORE AS emp_project_tab
                ((PRIMARY KEY(nested_table_id, pno)) 
    ORGANIZATION INDEX)
    RETURN AS LOCATOR;
</pre>
<p>The rows belonging to a single nested table instance are identified by a <code dir="ltr">nested_table_id</code> column. If an ordinary table is used to store nested table columns, the nested table rows typically get de-clustered. But when you use an index-organized table, the nested table rows can be clustered based on the <code dir="ltr">nested_table_id</code> column.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> for details of the syntax used for creating index-organized tables</p>
</li>
<li>
<p><a class="olink VLDBG1112" href="../../server.112/e25523/part_admin001.htm#VLDBG1112"><span class="italic">Oracle Database VLDB and Partitioning Guide</span></a> for information about creating partitioned index-organized tables</p>
</li>
<li>
<p><a class="olink ADOBJ" href="../../appdev.112/e11822/toc.htm"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for information about object types</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN11689" class="sect3"><a id="sthref2337"></a>
<h4 class="sect3">Choosing and Monitoring a Threshold Value</h4>
<p>Choose a <a id="sthref2338"></a><a id="sthref2339"></a>threshold value that can accommodate your key columns, as well as the first few nonkey columns (if they are frequently accessed).</p>
<p>After choosing a threshold value, you can monitor tables to verify that the value you specified is appropriate. You can use the <code dir="ltr">ANALYZE</code> <code dir="ltr">TABLE</code> ... <code dir="ltr">LIST</code> <code dir="ltr">CHAINED</code> <code dir="ltr">ROWS</code> statement to determine the number and identity of rows exceeding the threshold value.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a href="general.htm#i1006369">"Listing Chained Rows of Tables and Clusters"</a> for more information about chained rows</p>
</li>
<li>
<p><a class="olink SQLRF01105" href="../../server.112/e41084/statements_4005.htm#SQLRF01105"><span class="italic">Oracle Database SQL Language Reference</span></a> for syntax of the <code dir="ltr">ANALYZE</code> statement</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" -->
<div id="ADMIN11690" class="sect3"><a id="sthref2340"></a>
<h4 class="sect3">Using the <a id="sthref2341"></a><a id="sthref2342"></a>INCLUDING Clause</h4>
<p>In addition to specifying <code dir="ltr">PCTTHRESHOLD</code>, you can use the <code dir="ltr">INCLUDING</code> clause to control which nonkey columns are stored with the key columns. The database accommodates all nonkey columns up to and including the column specified in the <code dir="ltr">INCLUDING</code> clause in the index leaf block, provided it does not exceed the specified threshold. All nonkey columns beyond the column specified in the <code dir="ltr">INCLUDING</code> clause are stored in the overflow segment. If the <code dir="ltr">INCLUDING</code> and <code dir="ltr">PCTTHRESHOLD</code> clauses conflict, <code dir="ltr">PCTTHRESHOLD</code> takes precedence.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Oracle Database moves all primary key columns of an indexed-organized table to the beginning of the table (in their key order) to provide efficient primary key&ndash;based access. As an example:
<pre dir="ltr">
CREATE TABLE admin_iot4(a INT, b INT, c INT, d INT, 
                primary key(c,b))
    ORGANIZATION INDEX;
</pre>
<p>The stored column order is: <code dir="ltr">c b a d</code> (instead of: <code dir="ltr">a b c d</code>). The last primary key column is <code dir="ltr">b</code>, based on the stored column order. The <code dir="ltr">INCLUDING</code> column can be the last primary key column (<code dir="ltr">b</code> in this example), or any nonkey column (that is, any column after <code dir="ltr">b</code> in the stored column order).</p>
</div>
<p>The following <code dir="ltr">CREATE TABLE</code> statement is similar to the one shown earlier in <a href="#i1007057">"Example: Creating an Index-Organized Table"</a> but is modified to create an index-organized table where the <code dir="ltr">token_offsets</code> column value is always stored in the overflow area:</p>
<pre dir="ltr">
CREATE TABLE admin_docindex2(
        token CHAR(20), 
        doc_id NUMBER,
        token_frequency NUMBER,
        token_offsets VARCHAR2(2000),
        CONSTRAINT pk_admin_docindex2 PRIMARY KEY (token, doc_id))
    ORGANIZATION INDEX 
    TABLESPACE admin_tbs
    PCTTHRESHOLD 20
    INCLUDING token_frequency
    OVERFLOW TABLESPACE admin_tbs2;
</pre>
<p>Here, only nonkey columns prior to <code dir="ltr">token_offsets</code> (in this case a single column only) are stored with the key column values in the index leaf block.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11691" class="sect3"><a id="sthref2343"></a>
<h4 class="sect3">Parallelizing Index-Organized Table Creation<a id="sthref2344"></a><a id="sthref2345"></a></h4>
<p>The <code dir="ltr">CREATE TABLE...AS SELECT</code> statement enables you to create an index-organized table and load data from an existing table into it. By including the <code dir="ltr">PARALLEL</code> clause, the load can be done in parallel.</p>
<p>The following statement creates an index-organized table in parallel by selecting rows from the conventional table <code dir="ltr">hr.jobs</code>:</p>
<pre dir="ltr">
CREATE TABLE admin_iot3(i PRIMARY KEY, j, k, l) 
     ORGANIZATION INDEX 
     PARALLEL
     AS SELECT * FROM hr.jobs;
</pre>
<p>This statement provides an alternative to parallel bulk-load using SQL*Loader.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11692" class="sect3"><a id="sthref2346"></a>
<h4 class="sect3">Using Key Compression</h4>
<p>Creating an <a id="sthref2347"></a><a id="sthref2348"></a>index-organized table using key compression enables you to eliminate repeated occurrences of key column prefix values.</p>
<p>Key compression breaks an index key into a prefix and a suffix entry. Compression is achieved by sharing the prefix entries among all the suffix entries in an index block. This sharing can lead to huge savings in space, allowing you to store more keys in each index block while improving performance.</p>
<p>You can enable key compression using the <code dir="ltr"><a id="sthref2349"></a>COMPRESS</code> clause while:</p>
<ul>
<li>
<p>Creating an index-organized table</p>
</li>
<li>
<p>Moving an index-organized table</p>
</li>
</ul>
<p>You can also specify the prefix length (as the number of key columns), which identifies how the key columns are broken into a prefix and suffix entry.</p>
<pre dir="ltr">
CREATE TABLE admin_iot5(i INT, j INT, k INT, l INT, PRIMARY KEY (i, j, k)) 
    ORGANIZATION INDEX COMPRESS;
</pre>
<p>The preceding statement is equivalent to the following statement:</p>
<pre dir="ltr">
CREATE TABLE admin_iot6(i INT, j INT, k INT, l INT, PRIMARY KEY(i, j, k)) 
    ORGANIZATION INDEX COMPRESS 2;
</pre>
<p>For the list of values (1,2,3), (1,2,4), (1,2,7), (1,3,5), (1,3,4), (1,4,4) the repeated occurrences of (1,2), (1,3) are compressed away.</p>
<p>You can also override the default prefix length used for compression as follows:</p>
<pre dir="ltr">
CREATE TABLE admin_iot7(i INT, j INT, k INT, l INT, PRIMARY KEY (i, j, k)) 
    ORGANIZATION INDEX COMPRESS 1;
</pre>
<p>For the list of values (1,2,3), (1,2,4), (1,2,7), (1,3,5), (1,3,4), (1,4,4), the repeated occurrences of 1 are compressed away.</p>
<p>You can disable compression as follows:</p>
<pre dir="ltr">
ALTER TABLE admin_iot5 MOVE NOCOMPRESS;
</pre>
<p>One application of key compression is in a time-series application that uses a set of time-stamped rows belonging to a single item, such as a stock price. Index-organized tables are attractive for such applications because of the ability to cluster rows based on the primary key. By defining an index-organized table with primary key (stock symbol, time stamp), you can store and manipulate time-series data efficiently. You can achieve more storage savings by compressing repeated occurrences of the item identifier (for example, the stock symbol) in a time series by using an index-organized table with key compression.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT1177" href="../../server.112/e40540/indexiot.htm#CNCPT1177"><span class="italic">Oracle Database Concepts</span></a> for more information about key compression</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007240"></a>
<div id="ADMIN11693" class="sect2">
<h3 class="sect2">Maintaining Index-Organized Tables<a id="sthref2350"></a></h3>
<p>Index-organized tables differ from ordinary tables only in physical organization. Logically, they are manipulated in the same manner as ordinary tables. You can specify an index-organized table just as you would specify a regular table in <code dir="ltr">INSERT</code>, <code dir="ltr">SELECT</code>, <code dir="ltr">DELETE</code>, and <code dir="ltr">UPDATE</code> statements.</p>
<div id="ADMIN11694" class="sect3"><a id="sthref2351"></a>
<h4 class="sect3">Altering Index-Organized Tables</h4>
<p>All of the alter options available for ordinary tables are available for index-organized tables. This includes <code dir="ltr">ADD</code>, <code dir="ltr">MODIFY</code>, and <code dir="ltr">DROP</code> <code dir="ltr">COLUMNS</code> and <code dir="ltr">CONSTRAINTS</code>. However, the primary key constraint for an index-organized table cannot be dropped, deferred, or disabled</p>
<p>You can use the <a id="sthref2352"></a><code dir="ltr">ALTER TABLE</code> statement to modify physical and storage attributes for both primary key index and overflow data segments. All the attributes specified prior to the <code dir="ltr">OVERFLOW</code> keyword are applicable to the primary key index segment. All attributes specified after the <code dir="ltr">OVERFLOW</code> key word are applicable to the overflow data segment. For example, you can set the <code dir="ltr">INITRANS</code> of the primary key index segment to 4 and the overflow of the data segment <code dir="ltr">INITRANS</code> to 6 as follows:</p>
<pre dir="ltr">
ALTER TABLE admin_docindex INITRANS 4 OVERFLOW INITRANS 6;
</pre>
<p>You can also alter <code dir="ltr">PCTTHRESHOLD</code> and <code dir="ltr">INCLUDING</code> column values. A new setting is used to break the row into head and overflow tail pieces during subsequent operations. For example, the <code dir="ltr">PCTHRESHOLD</code> and <code dir="ltr">INCLUDING</code> column values can be altered for the <code dir="ltr">admin_docindex</code> table as follows:</p>
<pre dir="ltr">
ALTER TABLE admin_docindex PCTTHRESHOLD 15 INCLUDING doc_id;
</pre>
<p>By setting the <code dir="ltr">INCLUDING</code> column to <code dir="ltr">doc_id</code>, all the columns that follow <code dir="ltr">token_frequency</code> and <code dir="ltr">token_offsets</code>, are stored in the overflow data segment.</p>
<p>For index-organized tables created without an overflow data segment, you can add an overflow data segment by using the <code dir="ltr">ADD OVERFLOW</code> clause. For example, you can add an overflow segment to table <code dir="ltr">admin_iot3</code> as follows:</p>
<pre dir="ltr">
ALTER TABLE admin_iot3 ADD OVERFLOW TABLESPACE admin_tbs2;
</pre></div>
<!-- class="sect3" -->
<div id="ADMIN11695" class="sect3"><a id="sthref2353"></a>
<h4 class="sect3">Moving (Rebuilding) Index-Organized Tables</h4>
<p>Because <a id="sthref2354"></a>index-organized tables are primarily stored in a B-tree index, you can encounter fragmentation as a consequence of incremental updates. However, you can use the <a id="sthref2355"></a><code dir="ltr">ALTER TABLE...MOVE</code> statement to rebuild the index and reduce this fragmentation.</p>
<p>The following statement rebuilds the index-organized table <code dir="ltr">admin_docindex</code>:</p>
<pre dir="ltr">
ALTER TABLE admin_docindex MOVE;
</pre>
<p>You can rebuild index-organized tables online using the <code dir="ltr">ONLINE</code> keyword. The overflow data segment, if present, is rebuilt when the <code dir="ltr">OVERFLOW</code> keyword is specified. For example, to rebuild the <code dir="ltr">admin_docindex</code> table but not the overflow data segment, perform a move online as follows:</p>
<pre dir="ltr">
ALTER TABLE admin_docindex MOVE ONLINE;
</pre>
<p>To rebuild the <code dir="ltr">admin_docindex</code> table along with its overflow data segment perform the move operation as shown in the following statement. This statement also illustrates moving both the table and overflow data segment to new tablespaces.</p>
<pre dir="ltr">
ALTER TABLE admin_docindex MOVE TABLESPACE admin_tbs2 
    OVERFLOW TABLESPACE admin_tbs3;
</pre>
<p>In this last statement, an index-organized table with a LOB column (CLOB) is created. Later, the table is moved with the <code dir="ltr">LOB</code> index and data segment being rebuilt and moved to a new tablespace.</p>
<pre dir="ltr">
CREATE TABLE admin_iot_lob
   (c1 number (6) primary key,
    admin_lob CLOB)
   ORGANIZATION INDEX
   LOB (admin_lob) STORE AS (TABLESPACE admin_tbs2);
.
.
.
ALTER TABLE admin_iot_lob MOVE LOB (admin_lob) STORE AS (TABLESPACE admin_tbs3); 
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ADLOB45315" href="../../appdev.112/e18294/adlob_tables.htm#ADLOB45315"><span class="italic">Oracle Database SecureFiles and Large Objects Developer's Guide</span></a> for information about LOBs in index-organized tables</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007291"></a>
<div id="ADMIN11696" class="sect2">
<h3 class="sect2">Creating Secondary Indexes on Index-Organized Tables</h3>
<p>You can create secondary indexes on an index-organized tables to provide multiple access paths. Secondary indexes on index-organized tables differ from indexes on ordinary tables in two ways:</p>
<ul>
<li>
<p>They store logical rowids instead of physical rowids. This is necessary because the inherent movability of rows in a B-tree index results in the rows having no permanent physical addresses. If the physical location of a row changes, its logical rowid remains valid. One effect of this is that a table maintenance operation, such as <code dir="ltr">ALTER TABLE</code> ... <code dir="ltr">MOVE</code>, does not make the secondary index unusable.</p>
</li>
<li>
<p>The logical rowid also includes a physical guess which identifies the database block address at which the row is likely to be found. If the physical guess is correct, a secondary index scan would incur a single additional I/O once the secondary key is found. The performance would be similar to that of a secondary index-scan on an ordinary table.</p>
</li>
</ul>
<p>Unique and non-unique secondary indexes, function-based secondary indexes, and bitmap indexes are supported as secondary indexes on index-organized tables.</p>
<div id="ADMIN11697" class="sect3"><a id="sthref2356"></a>
<h4 class="sect3">Syntax for Creating the Secondary Index</h4>
<p>The following statement shows the creation of a secondary index on the <code dir="ltr">docindex</code> index-organized table where <code dir="ltr">doc_id</code> and <code dir="ltr">token</code> are the key columns:</p>
<pre dir="ltr">
CREATE INDEX Doc_id_index on Docindex(Doc_id, Token);
</pre>
<p>This secondary index allows the database to efficiently process a query, such as the following, the involves a predicate on <code dir="ltr">doc_id</code>:</p>
<pre dir="ltr">
SELECT Token FROM Docindex WHERE Doc_id = 1;
</pre></div>
<!-- class="sect3" -->
<div id="ADMIN11698" class="sect3"><a id="sthref2357"></a>
<h4 class="sect3">Maintaining Physical Guesses in Logical Rowids</h4>
<p>A logical rowid can include a guess, which identifies the block location of a row at the time the guess is made. Instead of doing a full key search, the database uses the guess to search the block directly. However, as new rows are inserted, guesses can become stale. The indexes are still usable through the primary key-component of the logical rowid, but access to rows is slower.</p>
<p>Collect index statistics with the <code dir="ltr">DBMS_STATS</code> package to monitor the staleness of guesses. The database checks whether the existing guesses are still valid and records the percentage of rows with valid guesses in the data dictionary. This statistic is stored in the <code dir="ltr">PCT_DIRECT_ACCESS</code> column of the <code dir="ltr">DBA_INDEXES</code> view (and related views).</p>
<p>To obtain fresh guesses, you can rebuild the secondary index. Note that rebuilding a secondary index on an index-organized table involves reading the base table, unlike rebuilding an index on an ordinary table. A quicker, more light weight means of fixing the guesses is to use the <code dir="ltr">ALTER</code> <code dir="ltr">INDEX</code> ... <code dir="ltr">UPDATE</code> <code dir="ltr">BLOCK</code> <code dir="ltr">REFERENCES</code> statement. This statement is performed online, while DML is still allowed on the underlying index-organized table.</p>
<p>After you rebuild a secondary index, or otherwise update the block references in the guesses, collect index statistics again.</p>
</div>
<!-- class="sect3" -->
<div id="ADMIN11699" class="sect3"><a id="sthref2358"></a>
<h4 class="sect3">Bitmap Indexes</h4>
<p>Bitmap indexes on index-organized tables are supported, provided the index-organized table is created with a mapping table. This is done by specifying the <code dir="ltr">MAPPING</code> <code dir="ltr">TABLE</code> clause in the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement that you use to create the index-organized table, or in an <code dir="ltr">ALTER</code> <code dir="ltr">TABLE</code> statement to add the mapping table later.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink CNCPT88857" href="../../server.112/e40540/indexiot.htm#CNCPT88857"><span class="italic">Oracle Database Concepts</span></a> for a description of mapping tables</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007327"></a>
<div id="ADMIN11700" class="sect2">
<h3 class="sect2">Analyzing Index-Organized Tables<a id="sthref2359"></a></h3>
<p>Just like ordinary tables, index-organized tables are analyzed using the <code dir="ltr">DBMS_STATS</code> package, or the <code dir="ltr">ANALYZE</code> statement.</p>
<div id="ADMIN11701" class="sect3"><a id="sthref2360"></a>
<h4 class="sect3">Collecting Optimizer Statistics for Index-Organized Tables</h4>
<p>To collect optimizer statistics, use the <code dir="ltr">DBMS_STATS</code> package.</p>
<p>For example, the following statement gathers statistics for the index-organized <code dir="ltr">countries</code> table in the <code dir="ltr">hr</code> schema:</p>
<pre dir="ltr">
EXECUTE DBMS_STATS.GATHER_TABLE_STATS ('HR','COUNTRIES');
</pre>
<p>The <code dir="ltr">DBMS_STATS</code> package analyzes both the primary key index segment and the overflow data segment, and computes logical as well as physical statistics for the table.</p>
<ul>
<li>
<p>The logical statistics can be queried using <code dir="ltr">USER_TABLES</code>, <code dir="ltr">ALL_TABLES</code> or <code dir="ltr">DBA_TABLES</code>.</p>
</li>
<li>
<p>You can query the physical statistics of the primary key index segment using <code dir="ltr">USER_INDEXES</code>, <code dir="ltr">ALL_INDEXES</code> or <code dir="ltr">DBA_INDEXES</code> (and using the primary key index name). For example, you can obtain the primary key index segment physical statistics for the table <code dir="ltr">admin_docindex</code> as follows:</p>
<pre dir="ltr">
SELECT LAST_ANALYZED, BLEVEL,LEAF_BLOCKS, DISTINCT_KEYS 
   FROM DBA_INDEXES WHERE INDEX_NAME= 'PK_ADMIN_DOCINDEX';
</pre></li>
<li>
<p>You can query the physical statistics for the overflow data segment using the <code dir="ltr">USER_TABLES</code>, <code dir="ltr">ALL_TABLES</code> or <code dir="ltr">DBA_TABLES</code>. You can identify the overflow entry by searching for <code dir="ltr">IOT_TYPE = 'IOT_OVERFLOW'</code>. For example, you can obtain overflow data segment physical attributes associated with the <code dir="ltr">admin_docindex</code> table as follows:</p>
<pre dir="ltr">
SELECT LAST_ANALYZED, NUM_ROWS, BLOCKS, EMPTY_BLOCKS 
   FROM DBA_TABLES WHERE IOT_TYPE='IOT_OVERFLOW' 
          and IOT_NAME= 'ADMIN_DOCINDEX';
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for more information about collecting optimizer statistics</p>
</li>
<li>
<p><a class="olink ARPLS059" href="../../appdev.112/e40758/d_stats.htm#ARPLS059"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for more information about of the <code dir="ltr">DBMS_STATS</code> package</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<!-- class="sect3" -->
<div id="ADMIN11702" class="sect3"><a id="sthref2361"></a>
<h4 class="sect3">Validating the Structure of Index-Organized Tables</h4>
<p>Use the <code dir="ltr">ANALYZE</code> statement to validate the structure of your index-organized table or to list any chained rows. These operations are discussed in the following sections located elsewhere in this book:</p>
<ul>
<li>
<p><a href="general.htm#i1006350">"Validating Tables, Indexes, Clusters, and Materialized Views"</a></p>
</li>
<li>
<p><a href="general.htm#i1006369">"Listing Chained Rows of Tables and Clusters"</a></p>
<div class="infobox-note">
<p class="notep1">Note:</p>
There are special considerations when listing chained rows for index-organized tables. These are discussed in the <a class="olink SQLRF01105" href="../../server.112/e41084/statements_4005.htm#SQLRF01105"><span class="italic">Oracle Database SQL Language Reference</span></a>.</div>
</li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="i1007389"></a>
<div id="ADMIN11703" class="sect2">
<h3 class="sect2">Using the ORDER BY Clause with Index-Organized Tables<a id="sthref2362"></a></h3>
<p>If an <code dir="ltr">ORDER BY</code> clause only references the primary key column or a prefix of it, then the optimizer avoids the sorting overhead, as the rows are returned sorted on the primary key columns.</p>
<p>The following queries avoid sorting overhead because the data is already sorted on the primary key:</p>
<pre dir="ltr">
SELECT * FROM admin_docindex2 ORDER BY token, doc_id;
SELECT * FROM admin_docindex2 ORDER BY token;
</pre>
<p>If, however, you have an <code dir="ltr">ORDER BY</code> clause on a suffix of the primary key column or non-primary-key columns, additional sorting is required (assuming no other secondary indexes are defined).</p>
<pre dir="ltr">
SELECT * FROM admin_docindex2 ORDER BY doc_id;
SELECT * FROM admin_docindex2 ORDER BY token_frequency;
</pre></div>
<!-- class="sect2" -->
<a id="i1007400"></a>
<div id="ADMIN11704" class="sect2">
<h3 class="sect2">Converting Index-Organized Tables to Regular Tables<a id="sthref2363"></a></h3>
<p>You can convert index-organized tables to regular (heap organized) tables using the Oracle import or export utilities, or the <code dir="ltr">CREATE TABLE...AS SELECT</code> statement.</p>
<p>To convert an index-organized table to a regular table:</p>
<ul>
<li>
<p>Export the index-organized table data using conventional path.</p>
</li>
<li>
<p>Create a regular table definition with the same definition.</p>
</li>
<li>
<p>Import the index-organized table data, making sure <code dir="ltr">IGNORE=y</code> (ensures that object exists error is ignored).</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Before converting an index-organized table to a regular table, be aware that index-organized tables cannot be exported using pre-Oracle8 versions of the Export utility.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SUTIL" href="../e22490/toc.htm"><span class="italic">Oracle Database Utilities</span></a> for more details about using the original <code dir="ltr">IMP</code> and <code dir="ltr">EXP</code> utilities and the Data Pump import and export utilities</div>
</li>
</ul>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007424"></a>
<div id="ADMIN01507" class="sect1">
<h2 class="sect1">Managing External <a id="sthref2364"></a>Tables</h2>
<p>This section contains:</p>
<ul>
<li>
<p><a href="#CJAFHIDJ">About External Tables</a></p>
</li>
<li>
<p><a href="#i1007480">Creating External Tables</a></p>
</li>
<li>
<p><a href="#i1007591">Altering External Tables</a></p>
</li>
<li>
<p><a href="#CHDHJFJD">Preprocessing External Tables</a></p>
</li>
<li>
<p><a href="#i1007664">Dropping External Tables</a></p>
</li>
<li>
<p><a href="#i1007668">System and Object Privileges for External Tables</a></p>
</li>
</ul>
<a id="CJAFHIDJ"></a>
<div id="ADMIN12896" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">About External Tables</h3>
<p>Oracle Database allows you read-only access to data in <a id="sthref2365"></a>external tables. <span class="bold">External tables</span> are defined as tables that do not reside in the database, and can be in any format for which an access driver is provided. By providing the database with metadata describing an external table, the database is able to expose the data in the external table as if it were data residing in a regular database table. The external data can be queried directly and in parallel using SQL.</p>
<p>You can, for example, select, join, or sort external table data. You can also create views and synonyms for external tables. However, no DML operations (<code dir="ltr">UPDATE</code>, <code dir="ltr">INSERT</code>, or <code dir="ltr">DELETE</code>) are possible, and no indexes can be created, on external tables.</p>
<p>External tables provide a framework to unload the result of an arbitrary <code dir="ltr">SELECT</code> statement into a platform-independent Oracle-proprietary format that can be used by Oracle Data Pump. External tables provide a valuable means for performing basic extraction, transformation, and loading (ETL) tasks that are common for data warehousing.</p>
<p>The means of defining the metadata for external tables is through the <code dir="ltr">CREATE TABLE...ORGANIZATION EXTERNAL</code> statement. This external table definition can be thought of as a view that allows running any SQL query against external data without requiring that the external data first be loaded into the database. An access driver is the actual mechanism used to read the external data in the table. When you use external tables to unload data, the metadata is automatically created based on the data types in the <code dir="ltr">SELECT</code> statement.</p>
<p>Oracle Database provides two access drivers for external tables. The default access driver is <code dir="ltr">ORACLE_LOADER</code>, which allows the reading of data from external files using the Oracle loader technology. The <code dir="ltr">ORACLE_LOADER</code> access driver provides data mapping capabilities which are a subset of the control file syntax of SQL*Loader utility. The second access driver, <code dir="ltr">ORACLE_DATAPUMP</code>, lets you unload data&mdash;that is, read data from the database and insert it into an external table, represented by one or more external files&mdash;and then reload it into an Oracle Database.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
The <code dir="ltr">ANALYZE</code> statement is not supported for gathering statistics for external tables. Use the <code dir="ltr">DBMS_STATS</code> package instead.</div>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF54503" href="../../server.112/e41084/statements_7002.htm#SQLRF54503"><span class="italic">Oracle Database SQL Language Reference</span></a> for restrictions that apply to external tables</p>
</li>
<li>
<p><a class="olink SUTIL011" href="../../server.112/e22490/et_concepts.htm#SUTIL011"><span class="italic">Oracle Database Utilities</span></a> for information about access drivers</p>
</li>
<li>
<p><a class="olink DWHSG8312" href="../../server.112/e25554/transform.htm#DWHSG8312"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information about using external tables for ETL in a data warehousing environment</p>
</li>
<li>
<p><a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about using the <code dir="ltr">DBMS_STATS</code> package</p>
</li>
</ul>
</div>
<p class="subhead2"><a id="ADMIN12897"></a>External Table Restrictions</p>
<p>The following are restrictions on external tables:</p>
<ul>
<li>
<p>The <code dir="ltr">ANALYZE</code> statement is not supported for gathering statistics for external tables. Use the <code dir="ltr">DBMS_STATS</code> package instead.</p>
</li>
<li>
<p>Virtual columns are not supported</p>
</li>
</ul>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SQLRF54503" href="../../server.112/e41084/statements_7002.htm#SQLRF54503"><span class="italic">Oracle Database SQL Language Reference</span></a> for restrictions that apply to external tables</p>
</li>
<li>
<p><a class="olink SUTIL011" href="../../server.112/e22490/et_concepts.htm#SUTIL011"><span class="italic">Oracle Database Utilities</span></a> for information about access drivers</p>
</li>
<li>
<p><a class="olink DWHSG8312" href="../../server.112/e25554/transform.htm#DWHSG8312"><span class="italic">Oracle Database Data Warehousing Guide</span></a> for information about using external tables for ETL in a data warehousing environment</p>
</li>
<li>
<p><a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about using the <code dir="ltr">DBMS_STATS</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007480"></a>
<div id="ADMIN11705" class="sect2">
<h3 class="sect2">Creating External Tables</h3>
<p>You create <a id="sthref2366"></a>external tables using the <code dir="ltr">CREATE</code> <code dir="ltr">TABLE</code> statement with an <a id="sthref2367"></a><a id="sthref2368"></a><code dir="ltr">ORGANIZATION</code> <code dir="ltr">EXTERNAL</code> clause. This statement creates only metadata in the data dictionary.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
External tables cannot have virtual columns.</div>
<p>The following example creates an external table and then uploads the data to a database table. Alternatively, you can unload data through the external table framework by specifying the <code dir="ltr">AS</code> <code dir="ltr"><span class="codeinlineitalic">subquery</span></code> clause of the <code dir="ltr">CREATE TABLE</code> statement. External table data pump unload can use only the <code dir="ltr">ORACLE_DATAPUMP</code> access driver.</p>
<p class="subhead1"><a id="ADMIN12642"></a>EXAMPLE: Creating an External Table and Loading Data<a id="sthref2369"></a><a id="sthref2370"></a><a id="sthref2371"></a></p>
<p>In this example, the data for the external table resides in the two text files <code dir="ltr">empxt1.dat</code> and <code dir="ltr">empxt2.dat</code>.</p>
<p>The file <code dir="ltr">empxt1.dat</code> contains the following sample data:</p>
<pre dir="ltr">
360,Jane,Janus,ST_CLERK,121,17-MAY-2001,3000,0,50,jjanus
361,Mark,Jasper,SA_REP,145,17-MAY-2001,8000,.1,80,mjasper
362,Brenda,Starr,AD_ASST,200,17-MAY-2001,5500,0,10,bstarr
363,Alex,Alda,AC_MGR,145,17-MAY-2001,9000,.15,80,aalda
</pre>
<p>The file <code dir="ltr">empxt2.dat</code> contains the following sample data:</p>
<pre dir="ltr">
401,Jesse,Cromwell,HR_REP,203,17-MAY-2001,7000,0,40,jcromwel
402,Abby,Applegate,IT_PROG,103,17-MAY-2001,9000,.2,60,aapplega
403,Carol,Cousins,AD_VP,100,17-MAY-2001,27000,.3,90,ccousins
404,John,Richardson,AC_ACCOUNT,205,17-MAY-2001,5000,0,110,jrichard
</pre>
<p>The following SQL statements create an external table named <code dir="ltr">admin_ext_employees</code> in the <code dir="ltr">hr</code> schema and load data from the external table into the <code dir="ltr">hr.employees</code> table.</p>
<pre dir="ltr">
CONNECT  /  AS SYSDBA;
-- Set up directories and grant access to hr 
CREATE OR REPLACE DIRECTORY admin_dat_dir
    AS '/flatfiles/data'; 
CREATE OR REPLACE DIRECTORY admin_log_dir 
    AS '/flatfiles/log'; 
CREATE OR REPLACE DIRECTORY admin_bad_dir 
    AS '/flatfiles/bad'; 
GRANT READ ON DIRECTORY admin_dat_dir TO hr; 
GRANT WRITE ON DIRECTORY admin_log_dir TO hr; 
GRANT WRITE ON DIRECTORY admin_bad_dir TO hr;
-- hr connects. Provide the user password (hr) when prompted.
CONNECT hr
-- create the external table
CREATE TABLE admin_ext_employees
                   (employee_id       NUMBER(4), 
                    first_name        VARCHAR2(20),
                    last_name         VARCHAR2(25), 
                    job_id            VARCHAR2(10),
                    manager_id        NUMBER(4),
                    hire_date         DATE,
                    salary            NUMBER(8,2),
                    commission_pct    NUMBER(2,2),
                    department_id     NUMBER(4),
                    email             VARCHAR2(25) 
                   ) 
     ORGANIZATION EXTERNAL 
     ( 
       TYPE ORACLE_LOADER 
       DEFAULT DIRECTORY admin_dat_dir 
       ACCESS PARAMETERS 
       ( 
         records delimited by newline 
         badfile admin_bad_dir:'empxt%a_%p.bad' 
         logfile admin_log_dir:'empxt%a_%p.log' 
         fields terminated by ',' 
         missing field values are null 
         ( employee_id, first_name, last_name, job_id, manager_id, 
           hire_date char date_format date mask "dd-mon-yyyy", 
           salary, commission_pct, department_id, email 
         ) 
       ) 
       LOCATION ('empxt1.dat', 'empxt2.dat') 
     ) 
     PARALLEL 
     REJECT LIMIT UNLIMITED; 
-- enable parallel for loading (good if lots of data to load)
ALTER SESSION ENABLE PARALLEL DML;
-- load the data in hr employees table
INSERT INTO employees (employee_id, first_name, last_name, job_id, manager_id,
                       hire_date, salary, commission_pct, department_id, email) 
            SELECT * FROM admin_ext_employees;
</pre>
<p>The following paragraphs contain descriptive information about this example.</p>
<p>The first few statements in this example create the directory objects for the operating system directories that contain the data sources, and for the bad record and log files specified in the access parameters. You must also grant <code dir="ltr">READ</code> or <code dir="ltr">WRITE</code> directory object privileges, as appropriate.</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
When creating a directory object or BFILEs, ensure that the following conditions are met:
<ul>
<li>
<p>The operating system file must not be a symbolic or hard link.</p>
</li>
<li>
<p>The operating system directory path named in the Oracle Database directory object must be an existing OS directory path.</p>
</li>
<li>
<p>The operating system directory path named in the directory object should not contain any symbolic links in its components.</p>
</li>
</ul>
</div>
<p>The <code dir="ltr">TYPE</code> specification indicates the access driver of the external table. The access driver is the API that interprets the external data for the database. If you omit the <code dir="ltr">TYPE</code> specification, <code dir="ltr">ORACLE_LOADER</code> is the default access driver. You must specify the <code dir="ltr">ORACLE_DATAPUMP</code> access driver if you specify the <code dir="ltr">AS</code> <code dir="ltr"><span class="codeinlineitalic">subquery</span></code> clause to unload data from one Oracle Database and reload it into the same or a different Oracle Database.</p>
<p>The access parameters, specified in the <code dir="ltr">ACCESS PARAMETERS</code> clause, are opaque to the database. These access parameters are defined by the access driver, and are provided to the access driver by the database when the external table is accessed. See <a class="olink SUTIL012" href="../../server.112/e22490/et_params.htm#SUTIL012"><span class="italic">Oracle Database Utilities</span></a> for a description of the <code dir="ltr">ORACLE_LOADER</code> access parameters.</p>
<p>The <code dir="ltr">PARALLEL</code> clause enables parallel query on the data sources. The granule of parallelism is by default a data source, but parallel access within a data source is implemented whenever possible. For example, if <code dir="ltr">PARALLEL=3</code> were specified, then multiple parallel execution servers could be working on a data source. But, parallel access within a data source is provided by the access driver only if all of the following conditions are met:</p>
<ul>
<li>
<p>The media allows random positioning within a data source</p>
</li>
<li>
<p>It is possible to find a record boundary from a random position</p>
</li>
<li>
<p>The data files are large enough to make it worthwhile to break up into multiple chunks</p>
<div class="infobox-note">
<p class="notep1">Note:</p>
Specifying a <code dir="ltr">PARALLEL</code> clause is of value <span class="italic">only</span> when dealing with large amounts of data. Otherwise, it is not advisable to specify a <code dir="ltr">PARALLEL</code> clause, and doing so can be detrimental.</div>
</li>
</ul>
<p>The <code dir="ltr">REJECT</code> <code dir="ltr">LIMIT</code> clause specifies that there is no limit on the number of errors that can occur during a query of the external data. For parallel access, the <code dir="ltr">REJECT</code> <code dir="ltr">LIMIT</code> applies to each parallel execution server independently. For example, if a <code dir="ltr">REJECT</code> <code dir="ltr">LIMIT</code> of 10 is specified, then each parallel query process can allow up to 10 rejections. Therefore, with a parallel degree of two and a <code dir="ltr">REJECT</code> <code dir="ltr">LIMIT</code> of 10, the statement might fail with between 10 and 20 rejections. If one parallel server processes all 10 rejections, then the limit is reached, and the statement is terminated. However, one parallel execution server could process nine rejections and another parallel execution server could process nine rejections and the statement will succeed with 18 rejections. Hence, the only precisely enforced values for <code dir="ltr">REJECT</code> <code dir="ltr">LIMIT</code> on parallel query are <code dir="ltr">0</code> and <code dir="ltr">UNLIMITED</code>.</p>
<p>In this example, the <code dir="ltr">INSERT</code> <code dir="ltr">INTO</code> <code dir="ltr">TABLE</code> statement generates a dataflow from the external data source to the Oracle Database SQL engine where data is processed. As data is parsed by the access driver from the external table sources and provided to the external table interface, the external data is converted from its external representation to its Oracle Database internal data type.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink SQLRF01402" href="../../server.112/e41084/statements_7002.htm#SQLRF01402"><span class="italic">Oracle Database SQL Language Reference</span></a> provides details of the syntax of the <code dir="ltr">CREATE TABLE</code> statement for creating external tables and specifies restrictions on the use of clauses</div>
</div>
<!-- class="sect2" -->
<a id="i1007591"></a>
<div id="ADMIN11706" class="sect2">
<h3 class="sect2">Altering External Tables</h3>
<p>You can use any of the <a id="sthref2372"></a><code dir="ltr">ALTER TABLE</code> clauses shown in <a href="#BABGCGDH">Table 20-5</a> to change the characteristics of an <a id="sthref2373"></a>external table. No other clauses are permitted.</p>
<div id="ADMIN13066" class="tblhruleformalwide">
<p class="titleintable"><a id="sthref2374"></a><a id="BABGCGDH"></a>Table 20-5 ALTER TABLE Clauses for External Tables</p>
<table class="cellalignment1333" title="ALTER TABLE Clauses for External Tables" summary="Column 1 lists the ALTER TABLE clauses that can be used to change the characteristics of an exernal table. Column 2 describes the clause usage, and column 3 provides examples." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t92">ALTER TABLE Clause</th>
<th class="cellalignment1334" id="r1c2-t92">Description</th>
<th class="cellalignment1334" id="r1c3-t92">Example</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t92" headers="r1c1-t92">
<p><code dir="ltr">REJECT LIMIT</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t92 r1c2-t92">
<p>Changes the reject limit. The default value is <code dir="ltr">0</code>.</p>
</td>
<td class="cellalignment1335" headers="r2c1-t92 r1c3-t92">
<pre dir="ltr">
ALTER TABLE admin_ext_employees
   REJECT LIMIT 100;
</pre></td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t92" headers="r1c1-t92">
<p><code dir="ltr">PROJECT</code> <code dir="ltr">COLUMN</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t92 r1c2-t92">
<p>Determines how the access driver validates rows in subsequent queries:</p>
<ul>
<li>
<p><code dir="ltr">PROJECT</code> <code dir="ltr">COLUMN</code> <code dir="ltr">REFERENCED</code>: the access driver processes only the columns in the select list of the query. This setting may not provide a consistent set of rows when querying a different column list from the same external table.</p>
</li>
<li>
<p><code dir="ltr">PROJECT</code> <code dir="ltr">COLUMN</code> <code dir="ltr">ALL</code>: the access driver processes all of the columns defined on the external table. This setting always provides a consistent set of rows when querying an external table. This is the default.</p>
</li>
</ul>
</td>
<td class="cellalignment1335" headers="r3c1-t92 r1c3-t92">
<pre dir="ltr">
ALTER TABLE admin_ext_employees
   PROJECT COLUMN REFERENCED;

ALTER TABLE admin_ext_employees
   PROJECT COLUMN ALL;
</pre></td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t92" headers="r1c1-t92">
<p><code dir="ltr">DEFAULT DIRECTORY</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t92 r1c2-t92">
<p>Changes the default directory specification</p>
</td>
<td class="cellalignment1335" headers="r4c1-t92 r1c3-t92">
<pre dir="ltr">
ALTER TABLE admin_ext_employees 
    DEFAULT DIRECTORY admin_dat2_dir;
</pre></td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="tblhruleformalwide" --></div>
<!-- class="sect2" -->
<a id="CHDHJFJD"></a>
<div id="ADMIN12898" class="sect2"><!-- infolevel="all" infotype="General" -->
<h3 class="sect2">Preprocessing External Tables</h3>
<div class="infobox-note">
<p class="notep1">Caution:</p>
There are security implications to consider when using the <code dir="ltr">PREPROCESSOR</code> clause. See <a class="olink DBSEG10007" href="../../network.112/e36292/guidelines.htm#DBSEG10007"><span class="italic">Oracle Database Security Guide</span></a> for more information.</div>
<p>External tables can be preprocessed by user-supplied preprocessor programs. By using a preprocessing program, users can use data from a file that is not in a format supported by the driver. For example, a user may want to access data stored in a compressed format. Specifying a decompression program for the <code dir="ltr">ORACLE_LOADER</code> access driver allows the data to be decompressed as the access driver processes the data.</p>
<p>To use the preprocessing feature, you must specify the <code dir="ltr">PREPROCESSOR</code> clause in the access parameters of the <code dir="ltr">ORACLE_LOADER</code> access driver. The preprocessor must be a directory object, and the user accessing the external table must have <code dir="ltr">EXECUTE</code> privileges for the directory object. The following example includes the <code dir="ltr">PREPROCESSOR</code> clause and specifies the directory and preprocessor program.</p>
<pre dir="ltr">
CREATE TABLE sales_transactions_ext
(PROD_ID NUMBER,
 CUST_ID NUMBER,
 TIME_ID DATE,
 CHANNEL_ID CHAR,
 PROMO_ID NUMBER,
 QUANTITY_SOLD NUMBER,
 AMOUNT_SOLD NUMBER(10,2),
 UNIT_COST NUMBER(10,2),
 UNIT_PRICE NUMBER(10,2))
ORGANIZATION external
(TYPE oracle_loader
 DEFAULT DIRECTORY data_file_dir
 ACCESS PARAMETERS
  (RECORDS DELIMITED BY NEWLINE
   CHARACTERSET AL32UTF8
   <span class="codeinlinebold">PREPROCESSOR exec_file_dir:'zcat'</span>
   BADFILE log_file_dir:'sh_sales.bad_xt'
   LOGFILE log_file_dir:'sh_sales.log_xt'
   FIELDS TERMINATED BY "|" LDRTRIM
  ( PROD_ID,
    CUST_ID,
    TIME_ID,
    CHANNEL_ID,
    PROMO_ID,
    QUANTITY_SOLD,
    AMOUNT_SOLD,
    UNIT_COST,
    UNIT_PRICE))
 location ('sh_sales.dat.gz')
)REJECT LIMIT UNLIMITED;
</pre>
<p>The <code dir="ltr">PREPROCESSOR</code> clause is not available for databases that use Oracle Database Vault.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink SUTIL1385" href="../../server.112/e22490/et_params.htm#SUTIL1385"><span class="italic">Oracle Database Utilities</span></a> provides information more information about the <code dir="ltr">PREPROCESSOR</code> clause</p>
</li>
<li>
<p><a class="olink DBSEG10007" href="../../network.112/e36292/guidelines.htm#DBSEG10007"><span class="italic">Oracle Database Security Guide</span></a> for more information about the security implications of the <code dir="ltr">PREPROCESSOR</code> clause</p>
</li>
</ul>
</div>
</div>
<!-- class="sect2" -->
<a id="i1007664"></a>
<div id="ADMIN11707" class="sect2">
<h3 class="sect2">Dropping External Tables</h3>
<p>For an <a id="sthref2375"></a>external table, the <code dir="ltr">DROP</code> <code dir="ltr">TABLE</code> statement removes only the table metadata in the database. It has no affect on the actual data, which resides outside of the database.</p>
</div>
<!-- class="sect2" -->
<a id="i1007668"></a>
<div id="ADMIN11708" class="sect2">
<h3 class="sect2">System and Object Privileges for External Tables</h3>
<p>System and object <a id="sthref2376"></a><a id="sthref2377"></a><a id="sthref2378"></a><a id="sthref2379"></a>privileges for external tables are a subset of those for regular table. Only the following system privileges are applicable to external tables:</p>
<ul>
<li>
<p><code dir="ltr">CREATE</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">ALTER</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">DROP</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code> <code dir="ltr">ANY</code> <code dir="ltr">TABLE</code></p>
</li>
</ul>
<p>Only the following object privileges are applicable to external tables:</p>
<ul>
<li>
<p><code dir="ltr">ALTER</code></p>
</li>
<li>
<p><code dir="ltr">SELECT</code></p>
</li>
</ul>
<p>However, object privileges associated with a directory are:</p>
<ul>
<li>
<p><code dir="ltr">READ</code></p>
</li>
<li>
<p><code dir="ltr">WRITE</code></p>
</li>
</ul>
<p>For external tables, <code dir="ltr">READ</code> privileges are required on directory objects that contain data sources, while <code dir="ltr">WRITE</code> privileges are required for directory objects containing bad, log, or discard files.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" -->
<a id="i1007685"></a>
<div id="ADMIN01508" class="sect1">
<h2 class="sect1">Tables Data Dictionary Views<a id="sthref2380"></a><a id="sthref2381"></a></h2>
<p>The following views allow you to access information about tables.</p>
<div class="inftblruleinformalwide">
<table class="cellalignment1333" title="Viewing Information about Tables" summary="Column 1 lists the names of views that can be used to access information about tables. Column 2 describes the view." dir="ltr">
<thead>
<tr class="cellalignment1327">
<th class="cellalignment1334" id="r1c1-t95">View</th>
<th class="cellalignment1334" id="r1c2-t95">Description</th>
</tr>
</thead>
<tbody>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r2c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TABLES</code>
<p><code dir="ltr">ALL_TABLES</code></p>
<p><code dir="ltr">USER_TABLES</code></p>
</td>
<td class="cellalignment1335" headers="r2c1-t95 r1c2-t95"><code dir="ltr">DBA</code> view describes all relational tables in the database. <code dir="ltr">ALL</code> view describes all tables accessible to the user. <code dir="ltr">USER</code> view is restricted to tables owned by the user. Some columns in these views contain statistics that are generated by the <code dir="ltr">DBMS_STATS</code> package or <code dir="ltr">ANALYZE</code> statement.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r3c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TAB_COLUMNS</code>
<p><code dir="ltr">ALL_TAB_COLUMNS</code></p>
<p><code dir="ltr">USER_TAB_COLUMNS</code></p>
</td>
<td class="cellalignment1335" headers="r3c1-t95 r1c2-t95">These views describe the columns of tables, views, and clusters in the database. Some columns in these views contain statistics that are generated by the <code dir="ltr">DBMS_STATS</code> package or <code dir="ltr">ANALYZE</code> statement.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r4c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_ALL_TABLES</code>
<p><code dir="ltr">ALL_ALL_TABLES</code></p>
<p><code dir="ltr">USER_ALL_TABLES</code></p>
</td>
<td class="cellalignment1335" headers="r4c1-t95 r1c2-t95">These views describe all relational and object tables in the database. Object tables are not specifically discussed in this book.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r5c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TAB_COMMENTS</code>
<p><code dir="ltr">ALL_TAB_COMMENTS</code></p>
<p><code dir="ltr">USER_TAB_COMMENTS</code></p>
</td>
<td class="cellalignment1335" headers="r5c1-t95 r1c2-t95">These views display comments for tables and views. Comments are entered using the <code dir="ltr">COMMENT</code><a id="sthref2382"></a> statement.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r6c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_COL_COMMENTS</code>
<p><code dir="ltr">ALL_COL_COMMENTS</code></p>
<p><code dir="ltr">USER_COL_COMMENTS</code></p>
</td>
<td class="cellalignment1335" headers="r6c1-t95 r1c2-t95">These views display comments for table and view columns. Comments are entered using the <code dir="ltr">COMMENT</code> statement.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r7c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_EXTERNAL_TABLES</code>
<p><code dir="ltr">ALL_EXTERNAL_TABLES</code></p>
<p><code dir="ltr">USER_EXTERNAL_TABLES</code></p>
</td>
<td class="cellalignment1335" headers="r7c1-t95 r1c2-t95">These views list the specific attributes of external tables in the database.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r8c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_EXTERNAL_LOCATIONS</code>
<p><code dir="ltr">ALL_EXTERNAL_LOCATIONS</code></p>
<p><code dir="ltr">USER_EXTERNAL_LOCATIONS</code></p>
</td>
<td class="cellalignment1335" headers="r8c1-t95 r1c2-t95">These views list the data sources for external tables.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r9c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TAB_HISTOGRAMS</code>
<p><code dir="ltr">ALL_TAB_HISTOGRAMS</code></p>
<p><code dir="ltr">USER_TAB_HISTOGRAMS</code></p>
</td>
<td class="cellalignment1335" headers="r9c1-t95 r1c2-t95">These views describe histograms on tables and views.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r10c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TAB_STATISTICS</code>
<p><code dir="ltr">ALL_TAB_STATISTICS</code></p>
<p><code dir="ltr">USER_TAB_STATISTICS</code></p>
</td>
<td class="cellalignment1335" headers="r10c1-t95 r1c2-t95">These views contain optimizer statistics for tables.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r11c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TAB_COL_STATISTICS</code>
<p><code dir="ltr">ALL_TAB_COL_STATISTICS</code></p>
<p><code dir="ltr">USER_TAB_COL_STATISTICS</code></p>
</td>
<td class="cellalignment1335" headers="r11c1-t95 r1c2-t95">These views provide column statistics and histogram information extracted from the related <code dir="ltr">TAB_COLUMNS</code> views.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r12c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_TAB_MODIFICATIONS</code>
<p><code dir="ltr">ALL_TAB_MODIFICATIONS</code></p>
<p><code dir="ltr">USER_TAB_MODIFICATIONS</code></p>
</td>
<td class="cellalignment1335" headers="r12c1-t95 r1c2-t95">These views describe tables that have been modified since the last time table statistics were gathered on them. They are not populated immediately, but after a time lapse (usually 3 hours).</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r13c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_ENCRYPTED_COLUMNS</code>
<p><code dir="ltr">USER_ENCRYPTED_COLUMNS</code></p>
<p><code dir="ltr">ALL_ENCRYPTED_COLUMNS</code></p>
</td>
<td class="cellalignment1335" headers="r13c1-t95 r1c2-t95">These views list table columns that are encrypted, and for each column, lists the encryption algorithm in use.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r14c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_UNUSED_COL_TABS</code>
<p><code dir="ltr">ALL_UNUSED_COL_TABS</code></p>
<p><code dir="ltr">USER_UNUSED_COL_TABS</code></p>
</td>
<td class="cellalignment1335" headers="r14c1-t95 r1c2-t95">These views list tables with unused columns, as marked by the <code dir="ltr">ALTER TABLE ... SET UNUSED</code> statement.</td>
</tr>
<tr class="cellalignment1327">
<td class="cellalignment1335" id="r15c1-t95" headers="r1c1-t95"><code dir="ltr">DBA_PARTIAL_DROP_TABS</code>
<p><code dir="ltr">ALL_PARTIAL_DROP_TABS</code></p>
<p><code dir="ltr">USER_PARTIAL_DROP_TABS</code></p>
</td>
<td class="cellalignment1335" headers="r15c1-t95 r1c2-t95">These views list tables that have partially completed <code dir="ltr">DROP COLUMN</code> operations. These operations could be incomplete because the operation was interrupted by the user or a system failure.</td>
</tr>
</tbody>
</table>
<br /></div>
<!-- class="inftblruleinformalwide" -->
<p class="subhead2"><a id="ADMIN12643"></a>Example: Displaying Column Information</p>
<p><a id="sthref2383"></a>Column information, such as name, data type, length, precision, scale, and default data values can be listed using one of the views ending with the <code dir="ltr">_COLUMNS</code> suffix. For example, the following query lists all of the default column values for the <code dir="ltr">emp</code> and <code dir="ltr">dept</code> tables:</p>
<pre dir="ltr">
SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_LENGTH, LAST_ANALYZED
    FROM DBA_TAB_COLUMNS
    WHERE OWNER = 'HR'
    ORDER BY TABLE_NAME;
    
</pre>
<p>The following is the output from the query:</p>
<pre dir="ltr">
TABLE_NAME           COLUMN_NAME          DATA_TYPE   DATA_LENGTH LAST_ANALYZED
-------------------- -------------------- ---------- ------------ -------------
COUNTRIES            COUNTRY_ID           CHAR                  2 05-FEB-03
COUNTRIES            COUNTRY_NAME         VARCHAR2             40 05-FEB-03
COUNTRIES            REGION_ID            NUMBER               22 05-FEB-03
DEPARTMENTS          DEPARTMENT_ID        NUMBER               22 05-FEB-03
DEPARTMENTS          DEPARTMENT_NAME      VARCHAR2             30 05-FEB-03
DEPARTMENTS          MANAGER_ID           NUMBER               22 05-FEB-03
DEPARTMENTS          LOCATION_ID          NUMBER               22 05-FEB-03
EMPLOYEES            EMPLOYEE_ID          NUMBER               22 05-FEB-03
EMPLOYEES            FIRST_NAME           VARCHAR2             20 05-FEB-03
EMPLOYEES            LAST_NAME            VARCHAR2             25 05-FEB-03
EMPLOYEES            EMAIL                VARCHAR2             25 05-FEB-03
.
.
.
LOCATIONS            COUNTRY_ID           CHAR                  2 05-FEB-03
REGIONS              REGION_ID            NUMBER               22 05-FEB-03
REGIONS              REGION_NAME          VARCHAR2             25 05-FEB-03

51 rows selected.
</pre>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for complete descriptions of these views</p>
</li>
<li>
<p><a class="olink ADOBJ7034" href="../../appdev.112/e11822/adobjint.htm#ADOBJ7034"><span class="italic">Oracle Database Object-Relational Developer's Guide</span></a> for information about object tables</p>
</li>
<li>
<p><a class="olink PFGRF003" href="../../server.112/e41573/stats.htm#PFGRF003"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about histograms and generating statistics for tables</p>
</li>
<li>
<p><a href="general.htm#i1006229">"Analyzing Tables, Indexes, and Clusters"</a></p>
</li>
</ul>
</div>
</div>
<!-- class="sect1" --></div>
<!-- class="chapter" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1326">
<tr>
<td class="cellalignment1335">
<table class="cellalignment1331">
<tr>
<td class="cellalignment1330"><a href="schema.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1330"><a href="indexes.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2001, 2015,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1337">
<table class="cellalignment1329">
<tr>
<td class="cellalignment1330"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1330"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1330"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1330"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1330"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1330"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
