<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta charset="utf-8">
<title>How Parallel Execution Works</title>
<meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 5.1.2 Build 037" />
<meta name="dcterms.created" content="2011-09-27T4:11:53Z" />
<meta name="robots" content="all" />
<meta name="dcterms.title" content="Database VLDB and Partitioning Guide" />
<meta name="dcterms.identifier" content="E25523-01" />
<meta name="dcterms.isVersionOf" content="VLDBG" />
<meta name="dcterms.rights" content="Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved." />
<link rel="Start" href="../../index.htm" title="Home" type="text/html" />
<link rel="Copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

<script type="application/javascript"  src="../../dcommon/js/headfoot.js"></script>
<script type="application/javascript"  src="../../nav/js/doccd.js"></script>
<link rel="Contents" href="toc.htm" title="Contents" type="text/html" />
<link rel="Index" href="index.htm" title="Index" type="text/html" />
<link rel="Prev" href="parallel001.htm" title="Previous" type="text/html" />
<link rel="Next" href="parallel003.htm" title="Next" type="text/html" />
<link rel="alternate" href="../e25523.pdf" title="PDF version" type="application/pdf" />
<link rel="schema.dcterms" href="http://purl.org/dc/terms/" />
<link rel="stylesheet" href="../../dcommon/css/fusiondoc.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/header.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/footer.css">
<link rel="stylesheet" type="text/css"  href="../../dcommon/css/fonts.css">
<link rel="stylesheet" href="../../dcommon/css/foundation.css">
<link rel="stylesheet" href="../../dcommon/css/codemirror.css">
<link rel="stylesheet" type="text/css" title="Default" href="../../nav/css/html5.css">
<link rel="stylesheet" href="../../dcommon/css/respond-480-tablet.css">
<link rel="stylesheet" href="../../dcommon/css/respond-768-laptop.css">
<link rel="stylesheet" href="../../dcommon/css/respond-1140-deskop.css">
<script type="application/javascript" src="../../dcommon/js/modernizr.js"></script>
<script type="application/javascript" src="../../dcommon/js/codemirror.js"></script>
<script type="application/javascript" src="../../dcommon/js/jquery.js"></script>
<script type="application/javascript" src="../../dcommon/js/foundation.min.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-552992c80ef99c8d" async="async"></script>
<script type="application/javascript" src="../../dcommon/js/jqfns.js"></script>
<script type="application/javascript" src="../../dcommon/js/ohc-inline-videos.js"></script>
<!-- Add fancyBox -->
<link rel="stylesheet" href="../../dcommon/fancybox/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/jquery.fancybox.pack.js?v=2.1.5"></script>
<!-- Optionally add helpers - button, thumbnail and/or media -->
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.css?v=1.0.5"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-buttons.js?v=1.0.5"></script>
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-media.js?v=1.0.6"></script>
<link rel="stylesheet"  href="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.css?v=1.0.7"  type="text/css" media="screen" />
<script type="text/javascript" src="../../dcommon/fancybox/helpers/jquery.fancybox-thumbs.js?v=1.0.7"></script>
</head>
<body>
<a href="#BEGIN" class="accessibility-top skipto" tabindex="0">Go to main content</a><header><!--
<div class="zz-skip-header"><a id="top" href="#BEGIN">Go to main content</a>--></header>
<div class="row" id="CONTENT">
<div class="IND large-9 medium-8 columns">
<a id="BEGIN" name="BEGIN"></a>
<span id="PAGE" style="display:none;">19/27</span> <!-- End Header --><a id="i1014083"></a><a id="VLDBG1382"></a>
<div class="sect1">
<h1 class="sect1">How Parallel Execution Works</h1>
<p>This section discusses the parallel execution process for SQL statements.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#i1006328">Parallel Execution of SQL Statements</a></p>
</li>
<li>
<p><a href="#BEIDCDCI">How Parallel Execution Servers Communicate</a></p>
</li>
<li>
<p><a href="#BEICCFIE">Degree of Parallelism</a></p>
</li>
<li>
<p><a href="#BEIBACGC">Parallel Statement Queuing</a></p>
</li>
<li>
<p><a href="#CACFBGGG">Parallel Execution Server Pool</a></p>
</li>
<li>
<p><a href="#BEIIGIFH">Granules of Parallelism</a></p>
</li>
<li>
<p><a href="#CACBDJAF">Balancing the Workload</a></p>
</li>
<li>
<p><a href="#BEIGCGEH">Parallel Execution Using Oracle RAC</a></p>
</li>
</ul>
<a id="i1006328"></a><a id="VLDBG0101"></a>
<div class="sect2">
<h2 class="sect2">Parallel Execution of SQL Statements</h2>
<p><a id="sthref856"></a><a id="sthref857"></a><a id="sthref858"></a>Each SQL statement undergoes an optimization and parallelization process when it is parsed. If parallel execution is chosen, then the following steps occur:</p>
<ol>
<li>
<p>The user session or shadow process takes on the role of a coordinator, often called the query coordinator.</p>
</li>
<li>
<p>The query coordinator obtains the necessary number of parallel servers.</p>
</li>
<li>
<p>The SQL statement is executed as a sequence of operations (a full table scan to perform a join on a nonindexed column, an <code>ORDER</code> <code>BY</code> clause, and so on). The parallel execution servers performs each operation in parallel if possible.</p>
</li>
<li>
<p>When the parallel servers are finished executing the statement, the query coordinator performs any portion of the work that cannot be executed in parallel. For example, a parallel query with a <code>SUM()</code> operation requires adding the individual subtotals calculated by each parallel server.</p>
</li>
<li>
<p>Finally, the query coordinator returns any results to the user.</p>
</li>
</ol>
<p>After the optimizer determines the execution plan of a statement, the parallel execution coordinator determines the parallel execution method for each operation in the plan. For example, the parallel execution method might be to perform a parallel full table scan by block range or a parallel index range scan by partition. The coordinator must decide whether an operation can be performed in parallel and, if so, how many parallel execution servers to enlist. The number of parallel execution servers in one set is the degree of parallelism (DOP).</p>
<a id="VLDBG1383"></a>
<div class="sect3"><a id="sthref859"></a>
<h3 class="sect3">Dividing Work Among Parallel Execution Servers</h3>
<p><a id="sthref860"></a>The parallel execution coordinator examines each operation in a SQL statement's execution plan then determines the way in which the rows operated on by the operation must be divided or redistributed among the parallel execution servers. As an example of parallel query with intra- and inter-operation parallelism, consider the query in <a href="#BEIJGGBB">Example 8-1</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BEIJGGBB"></a><a id="VLDBG14083"></a>Example 8-1 Running an Explain Plan for a Query on Customers and Sales</p>
<pre>
EXPLAIN PLAN FOR
SELECT /*+ PARALLEL(4) */ customers.cust_first_name, customers.cust_last_name, 
  MAX(QUANTITY_SOLD), AVG(QUANTITY_SOLD)
FROM sales, customers
WHERE sales.cust_id=customers.cust_id
GROUP BY customers.cust_first_name, customers.cust_last_name;

Explained.
</pre></div>
<!-- class="example" -->
<p>Note that a hint has been used in the query to specify the DOP of the tables <code>customers</code> and <code>sales</code>.</p>
<p><a href="#BEIFFBHE">Example 8-2</a> shows the explain plan output for the query in <a href="#BEIJGGBB">Example 8-1</a>.</p>
<div class="example">
<p class="titleinexample"><a id="BEIFFBHE"></a><a id="VLDBG14084"></a>Example 8-2 Explain Plan Output for a Query on Customers and Sales</p>
<pre>
PLAN_TABLE_OUTPUT
---------------------------------------------------------------------------------------------------
Plan hash value: 4060011603
--------------------------------------------------------------------------------------------
| Id  | Operation                  | Name      | Rows  | Bytes |    TQ  |IN-OUT| PQ Distrib |
---------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT           |           |   925 | 25900 |        |      |            |
|   1 |  PX COORDINATOR            |           |       |       |        |      |            |
|   2 |   PX SEND QC (RANDOM)      | :TQ10003  |   925 | 25900 |  Q1,03 | P-&gt;S | QC (RAND)  |
|   3 |    HASH GROUP BY           |           |   925 | 25900 |  Q1,03 | PCWP |            |
|   4 |     PX RECEIVE             |           |   925 | 25900 |  Q1,03 | PCWP |            |
|   5 |      PX SEND HASH          | :TQ10002  |   925 | 25900 |  Q1,02 | P-&gt;P | HASH       |
|*  6 |       HASH JOIN BUFFERED   |           |   925 | 25900 |  Q1,02 | PCWP |            |
|   7 |        PX RECEIVE          |           |   630 | 12600 |  Q1,02 | PCWP |            |
|   8 |         PX SEND HASH       | :TQ10000  |   630 | 12600 |  Q1,00 | P-&gt;P | HASH       |
|   9 |          PX BLOCK ITERATOR |           |   630 | 12600 |  Q1,00 | PCWC |            |
|  10 |           TABLE ACCESS FULL| CUSTOMERS |   630 | 12600 |  Q1,00 | PCWP |            |
|  11 |        PX RECEIVE          |           |   960 |  7680 |  Q1,02 | PCWP |            |
|  12 |         PX SEND HASH       | :TQ10001  |   960 |  7680 |  Q1,01 | P-&gt;P | HASH       |
|  13 |          PX BLOCK ITERATOR |           |   960 |  7680 |  Q1,01 | PCWC |            |
|  14 |           TABLE ACCESS FULL| SALES     |   960 |  7680 |  Q1,01 | PCWP |            |
------------------------------------------------------------------------------------------------
 
Predicate Information (identified by operation id):
---------------------------------------------------
 
   6 - access("SALES"."CUST_ID"="CUSTOMERS"."CUST_ID")
 
26 rows selected.
</pre></div>
<!-- class="example" -->
<p><a href="#i1010878">Figure 8-1</a> illustrates the data flow or query plan for the query in <a href="#BEIJGGBB">Example 8-1</a>.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1010878"></a><a id="VLDBG1384"></a>Figure 8-1 Data Flow Diagram for Joining Tables</p>
<img width="209" height="414" src="img/vldbg004.gif" alt="Description of Figure 8-1 follows" /><br />
<a id="sthref861" href="img_text/vldbg004.htm">Description of "Figure 8-1 Data Flow Diagram for Joining Tables"</a><br />
<br /></div>
<!-- class="figure" --></div>
<!-- class="sect3" -->
<a id="i1010963"></a><a id="VLDBG1385"></a>
<div class="sect3">
<h3 class="sect3">Parallelism Between Operations</h3>
<p>Given two sets of parallel execution servers SS1 and SS2 for the query plan illustrated in <a href="#i1010878">Figure 8-1</a>, the execution proceeds as follows: each server set (SS1 and SS2) has four execution processes because of the <code>PARALLEL</code> hint in the query that specifies the DOP.</p>
<p>Child set SS1 first scans the table <code>customers</code> and sends rows to SS2, which builds a hash table on the rows. In other words, the consumers in SS2 and the producers in SS1 work concurrently: one in scanning <code>customers</code> in parallel, the other is consuming rows and building the hash table to enable the hash join in parallel. This is an example of inter-operation parallelism.</p>
<p>After SS1 has finished scanning the entire <code>customers</code> table, it scans the <code>sales</code> table in parallel. It sends its rows to servers in SS2, which then perform the probes to finish the hash-join in parallel. After SS1 has scanned the <code>sales</code> table in parallel and sent the rows to SS2, it switches to performing the <code>GROUP</code> <code>BY</code> operation in parallel. This is how two server sets run concurrently to achieve inter-operation parallelism across various operators in the query tree.</p>
<p>Another important aspect of parallel execution is the redistribution of rows when they are sent from servers in one server set to servers in another. For the query plan in <a href="#BEIFFBHE">Example 8-2</a>, after a server process in SS1 scans a row from the <code>customers</code> table, which server process in SS2 should it send it to? The operator into which the rows are flowing decides the redistribution. In this case, the redistribution of rows flowing up from SS1 performing the parallel scan of <code>customers</code> into SS2 performing the parallel hash-join is done by hash partitioning on the join column. That is, a server process scanning <code>customers</code> computes a hash function of the value of the column <code>customers.cust_id</code> to decide the number of the server process in SS2 to send it to. The redistribution method used in parallel queries explicitly shows in the <code>Distrib</code> column in the <code>EXPLAIN</code> <code>PLAN</code> of the query. In <a href="#i1010878">Figure 8-1, "Data Flow Diagram for Joining Tables"</a>, this can be seen on lines 5, 8, and 12 of the <code>EXPLAIN</code> <code>PLAN</code>.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1386"></a>
<div class="sect3"><a id="sthref862"></a>
<h3 class="sect3">Producer or Consumer Operations</h3>
<p><a id="sthref863"></a><a id="sthref864"></a>Operations that require the output of other operations are known as consumer operations. In <a href="#i1010878">Figure 8-1</a>, the <code>GROUP</code> <code>BY</code> <code>SORT</code> operation is the consumer of the <code>HASH</code> <code>JOIN</code> operation because <code>GROUP</code> <code>BY</code> <code>SORT</code> requires the <code>HASH</code> <code>JOIN</code> output.</p>
<p>Consumer operations can begin consuming rows as soon as the producer operations have produced rows. In <a href="#BEIFFBHE">Example 8-2</a>, while the parallel execution servers are producing rows in the <code>FULL</code> <code>SCAN</code> of the <code>sales</code> table, another set of parallel execution servers can begin to perform the <code>HASH</code> <code>JOIN</code> operation to consume the rows.</p>
<p><a id="sthref865"></a><a id="sthref866"></a><a id="sthref867"></a><a id="sthref868"></a><a id="sthref869"></a>Each of the two operations performed concurrently is given its own set of parallel execution servers. Therefore, both query operations and the data flow tree itself have parallelism. The parallelism of an individual operation is called intra-operation parallelism and the parallelism between operations in a data flow tree is called inter-operation parallelism. Due to the producer-consumer nature of the Oracle Database operations, only two operations in a given tree must be performed simultaneously to minimize execution time. To illustrate intra- and inter-operation parallelism, consider the following statement:</p>
<pre>
SELECT * FROM employees ORDER BY last_name;
</pre>
<p>The execution plan implements a full scan of the <code>employees</code> table. This operation is followed by a sorting of the retrieved rows, based on the value of the <code>last_name</code> column. For the sake of this example, assume the <code>last_name</code> column is not indexed. Also assume that the DOP for the query is set to <code>4</code>, which means that four parallel execution servers can be active for any given operation.</p>
<p><a href="#i1010979">Figure 8-2</a> illustrates the parallel execution of the example query.</p>
<div class="figure">
<p class="titleinfigure"><a id="i1010979"></a><a id="VLDBG1387"></a>Figure 8-2 Inter-operation Parallelism and Dynamic Partitioning</p>
<img width="660" height="329" src="img/vldbg013.gif" alt="Description of Figure 8-2 follows" /><br />
<a id="sthref870" href="img_text/vldbg013.htm">Description of "Figure 8-2 Inter-operation Parallelism and Dynamic Partitioning"</a><br />
<br /></div>
<!-- class="figure" -->
<p>As illustrated in <a href="#i1010979">Figure 8-2</a>, there are actually eight parallel execution servers involved in the query even though the DOP is <code>4</code>. This is because a producer and consumer operator can be performed at the same time (inter-operation parallelism).</p>
<p>Also note that all of the parallel execution servers involved in the scan operation send rows to the appropriate parallel execution server performing the <code>SORT</code> operation. If a row scanned by a parallel execution server contains a value for the <code>last_name</code> column between <code>A</code> and <code>G</code>, that row is sent to the first <code>ORDER</code> <code>BY</code> parallel execution server. When the scan operation is complete, the sorting processes can return the sorted results to the query coordinator, which, in turn, returns the complete query results to the user.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEIDCDCI"></a><a id="VLDBG1388"></a>
<div class="sect2">
<h2 class="sect2">How Parallel Execution Servers Communicate</h2>
<p>To execute a query in parallel, Oracle Database generally creates a set of producer parallel execution servers and a set of consumer parallel execution servers. The producer server retrieves rows from tables and the consumer server performs operations such as join, sort, DML, and DDL on these rows. Each server in the producer set has a connection to each server in the consumer set. The number of virtual connections between parallel execution servers increases as the square of the degree of parallelism.</p>
<p>Each communication channel has at least one, and sometimes up to four memory buffers, which are allocated from the shared pool. Multiple memory buffers facilitate <a id="sthref871"></a><a id="sthref872"></a>asynchronous communication among the parallel execution servers.</p>
<p>A single-instance environment uses at most three buffers for each communication channel. An Oracle Real Application Clusters environment uses at most four buffers for each channel. <a href="#BABECFHI">Figure 8-3</a> illustrates message buffers and how producer parallel execution servers connect to consumer parallel execution servers.</p>
<div class="figure">
<p class="titleinfigure"><a id="BABECFHI"></a><a id="VLDBG1389"></a>Figure 8-3 Parallel Execution Server Connections and Buffers</p>
<img width="519" height="285" src="img/vldbg015.gif" alt="Description of Figure 8-3 follows" /><br />
<a id="sthref873" href="img_text/vldbg015.htm">Description of "Figure 8-3 Parallel Execution Server Connections and Buffers"</a><br />
<br /></div>
<!-- class="figure" -->
<p>When a connection is between two processes on the same instance, the servers communicate by passing the buffers back and forth in memory (in the shared pool). When the connection is between processes in different instances, the messages are sent using external high-speed network protocols over the interconnect. In <a href="#BABECFHI">Figure 8-3</a>, the DOP equals the number of parallel execution servers, which in this case is n. <a href="#BABECFHI">Figure 8-3</a> does not show the parallel execution coordinator. Each parallel execution server actually has an additional connection to the parallel execution coordinator. It is important to size the shared pool adequately when using parallel execution. If there is not enough free space in the shared pool to allocate the necessary memory buffers for a parallel server, it fails to start.</p>
</div>
<!-- class="sect2" -->
<a id="BEICCFIE"></a><a id="VLDBG0102"></a>
<div class="sect2">
<h2 class="sect2">Degree of Parallelism</h2>
<p>The number of parallel execution servers associated with a single operation is known as the <span class="bold"><a id="sthref874"></a><a id="sthref875"></a>degree</span> <span class="bold">of</span> <span class="bold">parallelism</span> (DOP). Parallel execution is designed to effectively use multiple CPUs. the Oracle Database parallel execution framework enables you to either explicitly choose a specific degree of parallelism or to rely on Oracle Database to automatically control it.</p>
<p>This section contains the following topics:</p>
<ul>
<li>
<p><a href="#BEIDFDEH">Manually Specifying the Degree of Parallelism</a></p>
</li>
<li>
<p><a href="#CIHGJFFH">Automatic Parallel Degree Policy</a></p>
</li>
<li>
<p><a href="#BEIJAFCF">Controlling Automatic Degree of Parallelism</a></p>
</li>
<li>
<p><a href="#BEICFFGB">In-Memory Parallel Execution</a></p>
</li>
<li>
<p><a href="#BEIECCDD">Adaptive Parallelism</a></p>
</li>
<li>
<p><a href="#CIHEFJGC">Controlling Automatic DOP, Parallel Statement Queuing, and In-Memory Parallel Execution</a></p>
</li>
</ul>
<a id="BEIDFDEH"></a><a id="VLDBG1390"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Manually Specifying the Degree of Parallelism</h3>
<p><a id="sthref876"></a>A specific DOP can be requested from Oracle Database. For example, you can set a fixed DOP at a table or index level:</p>
<pre>
ALTER TABLES sales PARALLEL 8;
ALTER TABLE customers PARALLEL 4;
</pre>
<p>In this case, queries accessing just the <code>sales</code> table use a requested DOP of 8 and queries accessing the <code>customers</code> table request a DOP of 4. A query accessing both the <code>sales</code> and the <code>customers</code> tables is processed with a DOP of 8 and potentially allocates 16 parallel servers (producer or consumer); whenever different DOPs are specified, Oracle Database uses the higher DOP.</p>
<a id="VLDBG1391"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref877"></a>
<h4 class="sect4">Default Parallelism</h4>
<p>If the <code>PARALLEL</code> clause is specified but no degree of parallelism is listed, the object gets the default DOP. Default parallelism uses a formula to determine the DOP based on the system configuration, as in the following:</p>
<ul>
<li>
<p>For a single instance, DOP = <code>PARALLEL_THREADS_PER_CPU x CPU_COUNT</code></p>
</li>
<li>
<p>For an Oracle RAC configuration, DOP = <code>PARALLEL_THREADS_PER_CPU x CPU_COUNT x INSTANCE_COUNT</code></p>
</li>
</ul>
<p>By default, <code>INSTANCE_COUNT</code> is all of the nodes in the cluster. However, if you have used Oracle RAC services to limit the number of nodes across which a parallel operation can execute, then the number of participating nodes is the number of nodes belonging to that service. For example, on a 4-node Oracle RAC cluster, with each node having 8 CPU cores and no Oracle RAC services, the default DOP would be 2 x 8 x 4 = 64.</p>
<p>The default DOP algorithm is designed to use maximum resources and assumes that the operation finishes faster if it can use more resources. Default parallelism targets the single-user workload. In a multiuser environment, default parallelism is not recommended.</p>
<p>The DOP for a SQL statement can also be set or limited by the Resource Manager. See <a class="olink ADMIN027" href="../../server.112/e25494/dbrm.htm#ADMIN027"><span class="italic">Oracle Database Administrator's Guide</span></a> for more information.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="CIHGJFFH"></a><a id="VLDBG0103"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Automatic Parallel Degree Policy</h3>
<p><a id="sthref878"></a>When the parameter <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, Oracle Database automatically decides if a statement should execute in parallel or not and what DOP it should use. Oracle Database also determines if the statement can be executed immediately or if it is queued until more system resources are available. Finally, Oracle Database decides if the statement can take advantage of the aggregated cluster memory or not.</p>
<p>The following is a summary of parallel statement processing when parallel degree policy is set to automatic.</p>
<ol>
<li>
<p>A SQL statement is issued.</p>
</li>
<li>
<p>The statement is parsed and the optimizer determines the execution plan.</p>
</li>
<li>
<p>The threshold limit specified by the <code>PARALLEL_MIN_TIME_THRESHOLD</code> initialization parameter is checked.</p>
<ol>
<li>
<p>If the execution time is less than the threshold limit, the SQL statement is run serially.</p>
</li>
<li>
<p>If the execution time is greater than the threshold limit, the statement is run in parallel based on the DOP that the optimizer calculates.</p>
</li>
</ol>
</li>
</ol>
<p>For more information, see <a href="#BEIGDHCH">"Determining Degree of Parallelism"</a> and <a href="#BEIJAFCF">"Controlling Automatic Degree of Parallelism"</a>.</p>
<a id="BEIGDHCH"></a><a id="VLDBG1392"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4">Determining Degree of Parallelism</h4>
<p>The optimizer automatically determines the DOP for a statement based on the resource requirements of the statement. The optimizer uses the cost of all scan operations (full table scan, index fast full scan, and so on) in the execution plan to determine the necessary DOP for the statement.</p>
<p>However, the optimizer limits the actual DOP to ensure parallel server processes do not overwhelm the system. This limit is set by the parameter <code>PARALLEL_DEGREE_LIMIT</code>. The default for value for this parameter is <code>CPU</code>, which means the number of processes is limited by the number of CPUs on the system (<code>PARALLEL_THREADS_PER_CPU</code> * <code>CPU_COUNT</code> * number of instances available) also known as the default DOP. By adjusting this parameter setting, you can control the maximum DOP the optimizer can choose for a SQL statement.</p>
<p>The DOP determined by the optimizer is shown in the notes section of an explain plan output (shown in the following explain plan output), visible either using the explain plan statement or <code>V$SQL_PLAN</code>.</p>
<pre>
EXPLAIN PLAN FOR
SELECT SUM(AMOUNT_SOLD) FROM SH.SALES;

PLAN TABLE OUTPUT

Plan hash value: 672559287
-------------------------------------------------------------------------------------------------
| Id |          Operation    |   Name |  Rows | Bytes | Cost(%CPU) |    Time   | Pstart |  Pstop |
-------------------------------------------------------------------------------------------------
|  0 | SELECT STATEMENT      |        |    1  |     4 |    5 (0)   |  00:00:01 |        |        |
|  1 | SORT AGGREGATE        |        |    1  |     4 |            |           |        |        |
|  2 |  PX COORDINATOR       |        |    1  |     4 |            |           |        |        |
|  3 |   PX SEND QC(RANDOM)  |:TQ10000|    1  |     4 |    5 (0)   |           |        |        |
|  4 |    SORT AGGREGATE     |        |    1  |     4 |            |           |        |        |
|  5 |     PX BLOCK ITERATOR |        |   960 |  3840 |    5 (0)   |  00:00:01 |      1 |     16 |
|  6 |     TABLE ACCESS FULL |  SALES |   960 |  3840 |    5 (0)   |  00:00:01 |      1 |     16 |
--------------------------------------------------------------------------------------------------
 
Note
-----
   - Computed Degree of Parallelism is 2
   - Degree of Parallelism of 2 is derived from scan of object SH.SALES
</pre>
<p><code>PARALLEL_MIN_TIME_THRESHOLD</code> is the second initialization parameter that controls automatic DOP. It specifies the minimum execution time a statement should have before the statement is considered for automatic DOP. By default, this is 10 seconds. The optimizer first calculates a serial execution plan for the SQL statement; if the estimated execution elapsed time is greater than <code>PARALLEL_MIN_TIME_THRESHOLD</code> <code>(10 seconds)</code>, the statement becomes a candidate for automatic DOP.</p>
</div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEIJAFCF"></a><a id="VLDBG13911"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Controlling Automatic Degree of Parallelism</h3>
<p><a id="sthref879"></a>There are two initialization parameters that control automatic DOP, <code>PARALLEL_DEGREE_POLICY</code> and <code>PARALLEL_MIN_TIME_THRESHOLD</code>. They are also described in <a href="#CIHGJFFH">"Automatic Parallel Degree Policy"</a> and <a href="#CIHEFJGC">"Controlling Automatic DOP, Parallel Statement Queuing, and In-Memory Parallel Execution"</a>. There are also two hints you can use to control parallelism.</p>
<a id="VLDBG1394"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref880"></a>
<h4 class="sect4">Setting Automatic Degree of Parallelism Using ALTER SESSION Statements</h4>
<p>You can <a id="sthref881"></a>set the DOP using an <code>ALTER</code> <code>SESSION</code> statement, as in the following:</p>
<pre>
ALTER SESSION SET parallel_degree_policy = limited;
ALTER TABLE emp parallel (degree default);
</pre></div>
<!-- class="sect4" -->
<a id="VLDBG1395"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" --><a id="sthref882"></a>
<h4 class="sect4">Setting Automatic Degree of Parallelism Using Hints</h4>
<p>You can <a id="sthref883"></a><a id="sthref884"></a>use the <code>PARALLEL</code> hint to force parallelism. It takes an optional parameter: the DOP at which the statement should run. In addition, the <code>NO_PARALLEL</code> hint overrides a <code>PARALLEL</code> parameter in the DDL that created or altered the table.The following example illustrates forcing the statement to be executed in parallel:</p>
<pre>
SELECT /*+parallel */ ename, dname FROM emp e, dept d WHERE e.deptno=d.deptno;
</pre>
<p>The following example illustrates forcing the statement to be executed in parallel with a degree of 10:</p>
<pre>
SELECT /*+ parallel(10) */ ename, dname FROM emp e, dept d
WHERE e.deptno=d.deptno;
</pre>
<p>The following example illustrates forcing the statement to be executed serially:</p>
<pre>
SELECT /*+ no_parallel */ ename, dname FROM emp e, dept d
WHERE e.deptno=d.deptno;
</pre>
<p>The following example illustrates computing the DOP the statement should use:</p>
<pre>
SELECT /*+ parallel(auto) */ ename, dname FROM emp e, dept d
WHERE e.deptno=d.deptno;
</pre>
<p>The following example forces the statement to use Oracle Database 11<span class="italic">g</span> Release 1 (11.1) behavior:</p>
<pre>
SELECT /*+ parallel(manual) */ ename, dname FROM emp e, dept d
WHERE e.deptno=d.deptno;
</pre></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEICFFGB"></a><a id="VLDBG13912"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">In-Memory Parallel Execution</h3>
<p><a id="sthref885"></a><a id="sthref886"></a>When the parameter <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, Oracle Database decides if an object that is accessed using parallel execution would benefit from being cached in the SGA (also called the buffer cache). The decision to cache an object is based on a well-defined set of heuristics including the size of the object and frequency on which it is accessed. In an Oracle RAC environment, Oracle Database maps pieces of the object into each of the buffer caches on the active instances. By creating this mapping, Oracle Database automatically knows which buffer cache to access to find different parts or pieces of the object. Using this information, Oracle Database prevents multiple instances from reading the same information from disk over and over again, thus maximizing the amount of memory that can cache objects. If the size of the object is larger than the size of the buffer cache (single instance) or the size of the buffer cache multiplied by the number of active instances in an Oracle RAC cluster, then the object is read using direct-path reads.</p>
</div>
<!-- class="sect3" -->
<a id="BEIECCDD"></a><a id="VLDBG13913"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Adaptive Parallelism</h3>
<p><a id="sthref887"></a><a id="sthref888"></a><a id="sthref889"></a>The adaptive multiuser algorithm, which is enabled by default, reduces the degree of parallelism as the load on the system increases. When using the Oracle Database adaptive parallelism capabilities, the database uses an algorithm at SQL execution time to determine whether a parallel operation should receive the requested DOP or have its DOP lower to ensure the system is not overloaded.</p>
<p>In a system that makes aggressive use of parallel execution by using a high DOP, the <a id="sthref890"></a>adaptive algorithm adjusts the DOP down when only a few operations are running in parallel. While the algorithm still ensures optimal resource utilization, users may experience inconsistent response times. Using solely the adaptive parallelism capabilities in an environment that requires deterministic response times is not advised. Adaptive parallelism is controlled through the database initialization parameter <code>PARALLEL_ADAPTIVE_MULTI_USER</code>.</p>
</div>
<!-- class="sect3" -->
<a id="CIHEFJGC"></a><a id="VLDBG13914"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Controlling Automatic DOP, Parallel Statement Queuing, and In-Memory Parallel Execution</h3>
<p><a id="sthref891"></a><a id="sthref892"></a><a id="sthref893"></a>The initialization parameter<a id="sthref894"></a><a id="sthref895"></a><a id="sthref896"></a> <code>PARALLEL_DEGREE_POLICY</code> controls whether automatic degree of parallelism (DOP), parallel statement queuing, and in-memory parallel execution are enabled. This parameter has three possible values:</p>
<ul>
<li>
<p><code>MANUAL</code> - Disables automatic DOP, statement queuing and in-memory parallel execution. It reverts the behavior of parallel execution to what it was previous to Oracle Database 11<span class="italic">g</span>, Release 2 (11.2), which is the default.</p>
</li>
<li>
<p><code>LIMITED</code> - Enables automatic DOP for some statements but parallel statement queuing and in-memory parallel execution are disabled. Automatic DOP is applied only to statements that access tables or indexes declared explicitly with the <code>PARALLEL</code> clause. Tables and indexes that have a DOP specified use that explicit DOP setting</p>
</li>
<li>
<p><code>AUTO</code> - Enables automatic DOP, parallel statement queuing, and in-memory parallel execution.</p>
</li>
</ul>
<p>By default, the system only uses parallel execution when a parallel degree has been explicitly set on an object or if a parallel hint is specified in the SQL statement. The degree of parallelism used is exactly what was specified. No parallel statement queue occurs and parallel execution does not use the buffer cache. For information about the parallel statement queue, refer to <a href="#BEIBACGC">"Parallel Statement Queuing"</a>.</p>
<p>If you want Oracle Database to automatically decide the degree of parallelism only for a subset of SQL statements that touch a specific subset of objects, then set <code>PARALLEL_DEGREE_POLICY</code> to <code>LIMITED</code> and set the parallel clause on that subset of objects. If you want Oracle Database to automatically decide the degree of parallelism, then set <code>PARALLEL_DEGREE_POLICY</code> to <code>AUTO</code>.</p>
<p><a id="sthref897"></a><a id="sthref898"></a><a id="sthref899"></a>When <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, Oracle Database determines whether the statement should run in parallel based on the cost of the operations in the execution plan and the hardware characteristics. The hardware characteristics include I/O calibration statistics so these statistics must be gathered otherwise Oracle Database does not use the automatic degree policy feature.</p>
<p>If I/O calibration is not run to gather the required statistics, the explain plan output includes the following text in its notes:</p>
<pre>
automatic DOP: skipped because of IO calibrate statistics are missing
</pre>
<p>I/O calibration statistics can be gathered with the PL/SQL <code>DBMS_RESOURCE_MANAGER.CALIBRATE_IO</code> procedure. I/O calibration is a one-time action if the physical hardware does not change.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink PFGRF94382" href="../../server.112/e41573/iodesign.htm#PFGRF94382"><span class="italic">Oracle Database Performance Tuning Guide</span></a> for information about I/O calibration</p>
</li>
<li>
<p><a class="olink ARPLS050" href="../../appdev.112/e40758/d_resmgr.htm#ARPLS050"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code>DBMS_RESOURCE_MANAGER</code> package</p>
</li>
</ul>
</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEIBACGC"></a><a id="VLDBG1396"></a>
<div class="sect2">
<h2 class="sect2">Parallel Statement Queuing</h2>
<p><a id="sthref900"></a><a id="sthref901"></a><a id="sthref902"></a>When the parameter <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, Oracle Database queues SQL statements that require parallel execution if the necessary parallel server processes are not available. After the necessary resources become available, the SQL statement is dequeued and allowed to execute. The default dequeue order is a simple first in, first out queue based on the time a statement was issued.</p>
<p>The following is a summary of parallel statement processing.</p>
<ol>
<li>
<p>A SQL statements is issued.</p>
</li>
<li>
<p>The statement is parsed and the DOP is automatically determined.</p>
</li>
<li>
<p>Available parallel resources are checked.</p>
<ol>
<li>
<p>If there are enough parallel resources and there are no statements ahead in the queue waiting for the resources, the SQL statement is executed.</p>
</li>
<li>
<p>If there are not enough parallel servers, the SQL statement is queued based on specified conditions and dequeued from the front of the queue when specified conditions are met.</p>
</li>
</ol>
</li>
</ol>
<p>Parallel statements are queued if running the statements would increase the number of active parallel servers above the value of the <code>PARALLEL_SERVERS_TARGET</code> initialization parameter. For example, if <code>PARALLEL_SERVERS_TARGET</code> is set to <code>64</code>, the number of current active servers is 60, and a new parallel statement needs 16 parallel servers, it would be queued because 16 added to 60 is greater than 64, the value of <code>PARALLEL_SERVERS_TARGET</code>.</p>
<p>The default value is described in <a href="parallel005.htm#CIHJEGFI">"PARALLEL_SERVERS_TARGET"</a>. This value is not the maximum number of parallel server processes allowed on the system, but the number available to run parallel statements before parallel statement queuing is used. It is set lower than the maximum number of parallel server processes allowed on the system (<code>PARALLEL_MAX_SERVERS</code>) to ensure each parallel statement gets all of the parallel server resources required and to prevent overloading the system with parallel server processes. Note all serial (nonparallel) statements execute immediately even if parallel statement queuing has been activated.</p>
<p>If a statement has been queued, it is identified by the <code>resmgr:pq</code> <code>queued</code> wait event.</p>
<p>This section discusses the following topics:</p>
<ul>
<li>
<p><a href="#BEIBHJJC">Managing Parallel Statement Queuing with Resource Manager</a></p>
</li>
<li>
<p><a href="#BEIGICGH">Grouping Parallel Statements with BEGIN_SQL_BLOCK .. END_SQL_BLOCK</a></p>
</li>
<li>
<p><a href="#BEIEHFCG">Managing Parallel Statement Queuing with Hints</a></p>
</li>
</ul>
<a id="BEIBHJJC"></a><a id="VLDBG14020"></a>
<div class="sect3">
<h3 class="sect3">Managing Parallel Statement Queuing with Resource Manager</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This functionality is available starting with Oracle Database 11g Release 2 (11.2.0.2).</div>
<p><a id="sthref903"></a><a id="sthref904"></a><a id="sthref905"></a><a id="sthref906"></a>By default, the parallel statement queue operates as a first-in, first-out queue. By configuring and setting a resource plan, you can control the order in which parallel statements are dequeued and the number of parallel servers used by each workload or consumer group.</p>
<p>Resource plans and consumer groups are created using the <code>DBMS_RESOURCE_MANAGER</code> PL/SQL package. A resource plan consists of a collection of directives for each consumer group which specify controls and allocations for various database resources, such as parallel servers. A resource plan is enabled by setting the <code>RESOURCE_MANAGER_PLAN</code> parameter to the name of the resource plan.</p>
<p>The following sections describe the directives that can be used to manage the processing of parallel statements for consumer groups when the parallel degree policy is set to <code>AUTO</code>.</p>
<ul>
<li>
<p><a href="#BEIFAIGI">Managing the Order of the Parallel Statement Queue</a></p>
</li>
<li>
<p><a href="#BEIBBEJH">Limiting the Parallel Server Resources for a Consumer Group</a></p>
</li>
<li>
<p><a href="#BEIDAGBD">Specifying a Parallel Statement Queue Timeout for Each Consumer Group</a></p>
</li>
<li>
<p><a href="#BEIJDADF">Specifying a Degree of Parallelism Limit for Consumer Groups</a></p>
</li>
<li>
<p><a href="#BEIHFJHG">A Sample Scenario for Managing Statements in the Parallel Queue</a></p>
</li>
</ul>
<p>In all cases, the parallel statement queue is managed as a single queue on an Oracle RAC database. Limits for each consumer group apply to all sessions across the Oracle RAC database that belong to that consumer group. The queuing of parallel statements occurs based on the sum of the values of the <code>PARALLEL_SERVERS_TARGET</code> initialization parameter across all database instances.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<ul>
<li>
<p><a class="olink ADMIN027" href="../../server.112/e25494/dbrm.htm#ADMIN027"><span class="italic">Oracle Database Administrator's Guide</span></a> for information about managing Oracle Database resources with Resource Manager</p>
</li>
<li>
<p><a class="olink REFRN" href="../e40402/toc.htm"><span class="italic">Oracle Database Reference</span></a> for information about <code>V$RSRC</code>* views, the <code>DBA_HIST_RSRC_CONSUMER_GROUP</code> view, and parallel query wait events</p>
</li>
<li>
<p><a class="olink ARPLS050" href="../../appdev.112/e40758/d_resmgr.htm#ARPLS050"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code>DBMS_RESOURCE_MANAGER</code> package</p>
</li>
</ul>
</div>
<a id="BEIFAIGI"></a><a id="VLDBG14085"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4"><a id="sthref907"></a>Managing the Order of the Parallel Statement Queue</h4>
<p>You can use Resource Manager to manage the order that parallel statements are dequeued from the parallel statement queue. The parallel statements for a particular consumer group are always dequeued in FIFO order. The directives <code>mgmt_p1</code> ... <code>mgmt_p8</code> are used to determine which consumer group's parallel statement should be dequeued next. These directives are configured using the <code>CREATE_PLAN_DIRECTIVE</code> or <code>UPDATE_PLAN_DIRECTIVE</code> procedure in the <code>DBMS_RESOURCE_MANAGER</code> PL/SQL package.</p>
<p>For example, you can create the PQ_HIGH, PQ_MEDIUM, and PQ_LOW consumer groups and map parallel statement sessions to these consumer groups based on priority. You then create a resource plan that sets <code>mgmt_p1</code> to 70% for PQ_HIGH, 25% for PQ_MEDIUM, and 5% for PQ_LOW. This indicates that PQ_HIGH statements are dequeued next with a probability of 70% of the time, PQ_MEDIUM dequeued next with a probability of 25% of the time, and PQ_LOW dequeued next with a probability of 5% of the time.</p>
</div>
<!-- class="sect4" -->
<a id="BEIBBEJH"></a><a id="VLDBG14086"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4"><a id="sthref908"></a><a id="sthref909"></a>Limiting the Parallel Server Resources for a Consumer Group</h4>
<p>You can use Resource Manager to limit the number of parallel servers that parallel statements from lower priority consumer groups can use for parallel statement processing. Using Resource Manager you can map parallel statement sessions to different consumer groups that each have specific limits on the number of the parallel servers that can be used. When these limits are specified, parallel statements from a consumer group are queued when this limit would be exceeded.</p>
<p>This limitation becomes useful when a database has high priority and low priority consumer groups. Without limits, a user may issue a large number of parallel statements from a low-priority consumer group that utilizes all parallel servers. When a parallel statement from a high priority consumer group is issued, the resource allocation directives can ensure that the high priority parallel statement is dequeued first. By limiting the number of parallel servers a low-priority consumer group can use, you can ensure that there are always some parallel servers available for a high priority consumer group.</p>
<p>To limit the parallel servers used by a consumer group, use the <code>parallel_target_percentage</code> parameter with the <code>CREATE_PLAN_DIRECTIVE</code> procedure or the <code>new_parallel_target_percentage</code> parameter with the <code>UPDATE_PLAN_DIRECTIVE</code> procedure in the <code>DBMS_RESOURCE_MANAGER</code> package. The <code>parallel_target_percentage</code> and <code>new_parallel_target_percentage</code> parameters specify the maximum percentage of the Oracle RAC-wide parallel server pool that is specified by <code>PARALLEL_SERVERS_TARGET</code> that a consumer group can use.</p>
<p>For example, on an Oracle RAC database system, the initialization parameter <code>PARALLEL_SERVERS_TARGET</code> is set to 32 on two nodes so there are a total of 32 x 2 = 64 parallel servers that can be used before queuing begins. You can set up the consumer group PQ_LOW to use 50% of the available parallel servers (<code>parallel_target_percentage</code> = 50) and low priority statements can then be mapped to the PQ_LOW consumer group. This scenario limits any parallel statements from the PQ_LOW consumer group to 64 x 50% = 32 parallel servers, even though there are more inactive or unused parallel servers. In this scenario, after the statements from the PQ_LOW consumer group have used 32 parallel servers, statements from that consumer group are queued.</p>
<p>It is possible in one database to have some sessions with the parallelism degree policy set to MANUAL and some sessions set to AUTO. In this scenario, only the sessions with parallelism degree policy set to AUTO can be queued. However, the parallel servers used in sessions where the parallelism degree policy is set to MANUAL are included in the total of all parallel servers used by a consumer group.</p>
<p>For information about limiting parallel resources for users, refer to <a href="parallel005.htm#BEIGJDHB">"When Users Have Too Many Processes"</a> and <a href="parallel005.htm#BEIEHEBJ">"Limiting the Number of Resources for a User using a Consumer Group"</a>.</p>
</div>
<!-- class="sect4" -->
<a id="BEIDAGBD"></a><a id="VLDBG14087"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4"><a id="sthref910"></a>Specifying a Parallel Statement Queue Timeout for Each Consumer Group</h4>
<p>You can use Resource Manager to set the maximum queue timeout limit so that parallel statements do not stay in the queue for long periods of time. Using Resource Manager you can map parallel statement sessions to different consumer groups that each have specific maximum timeout limits in a resource plan.</p>
<p>To manage the queue timeout, the <code>parallel_queue_timeout</code> parameter is used with the <code>CREATE_PLAN_DIRECTIVE</code> procedure or the <code>new_parallel_queue_timeout</code> parameter is used with the <code>UPDATE_PLAN_DIRECTIVE</code> procedure in the <code>DBMS_RESOURCE_MANAGER</code> package. The <code>parallel_queue_timeout</code> and <code>new_parallel_queue_timeout</code> parameters specify the time in seconds that a statement can remain in a consumer group parallel statement queue. After the timeout period has expired, the statement is terminated with error <code>ORA-7454</code> and removed from the parallel statement queue.</p>
</div>
<!-- class="sect4" -->
<a id="BEIJDADF"></a><a id="VLDBG14088"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4"><a id="sthref911"></a><a id="sthref912"></a>Specifying a Degree of Parallelism Limit for Consumer Groups</h4>
<p>You can use Resource Manager to the limit the degree of parallelism for specific consumer groups. Using Resource Manager you can map parallel statement sessions to different consumer groups that each have specific limits for the degree of parallelism in a resource plan.</p>
<p>To manage the limit of parallelism in consumer groups, use the <code>parallel_degree_limit_p1</code> parameter with the <code>CREATE_PLAN_DIRECTIVE</code> procedure in the <code>DBMS_RESOURCE_MANAGER</code> package or the <code>new_parallel_degree_limit_p1</code> parameter with the <code>UPDATE_PLAN_DIRECTIVE</code> procedure in the <code>DBMS_RESOURCE_MANAGER</code> package. The <code>parallel_degree_limit_p1</code> and <code>new_parallel_degree_limit_p1</code> parameters specify a limit on the degree of parallelism for any operation.</p>
<p>For example, you can create the PQ_HIGH, PQ_MEDIUM, and PQ_LOW consumer groups and map parallel statement sessions to these consumer groups based on priority. You then create a resource plan that specifies degree of parallelism limits so that the PQ_HIGH limit is set to 16, the PQ_MEDIUM limit is set to 8, and the PQ_LOW limit is set to 2.</p>
</div>
<!-- class="sect4" -->
<a id="BEIHFJHG"></a><a id="VLDBG14089"></a>
<div class="sect4"><!-- infolevel="all" infotype="General" -->
<h4 class="sect4"><a id="sthref913"></a>A Sample Scenario for Managing Statements in the Parallel Queue</h4>
<p>This scenario discusses how to manage statements in the parallel queue with consumer groups set up with Resource Manager. For this scenario, consider a data warehouse workload that consists of three types of SQL statements:</p>
<ul>
<li>
<p>Short-running SQL statements</p>
<p>Short-running identifies statements running less than one minute. You expect these statements to have very good response times.</p>
</li>
<li>
<p>Medium-running SQL statements</p>
<p>Medium-running identifies statements running more than one minute, but less than 15 minutes. You expect these statements to have reasonably good response times.</p>
</li>
<li>
<p>Long-running SQL statements</p>
<p>Long-running identifies statements that are ad-hoc or complex queries running more than 15 minutes. You expect these statements to take a long time.</p>
</li>
</ul>
<p>For this data warehouse workload, you want better response times for the short-running statements. To achieve this goal, you must ensue that:</p>
<ul>
<li>
<p>Long-running statements do not use all of the parallel server resources, forcing shorter statements to wait in the parallel statement queue.</p>
</li>
<li>
<p>When both short-running and long-running statements are queued, short-running statements should be dequeued ahead of long-running statements.</p>
</li>
<li>
<p>The DOP for short-running queries is limited because the speedup from a very high DOP is not significant enough to justify the use of a large number of parallel servers.</p>
</li>
</ul>
<p><a href="#BEIIGBCJ">Example 8-3</a> shows how to set up consumer groups using Resource Manager to set priorities for statements in the parallel statement queue. Note the following for this example:</p>
<ul>
<li>
<p>By default, users are assigned to the OTHER_GROUPS consumer group. If the estimated execution time of a SQL statement is longer than 1 minute (60 seconds), then the user switches to MEDIUM_SQL_GROUP. Because <code>switch_for_call</code> is set to <code>TRUE</code>, the user returns to OTHER_GROUPS when the statement has completed. If the user is in MEDIUM_SQL_GROUP and the estimated execution time of the statement is longer than 15 minutes (900 seconds), the user switches to LONG_SQL_GROUP. Similarly, because <code>switch_for_call</code> is set to TRUE, the user returns to OTHER_GROUPS when the query has completed. The directives used to accomplish the switch process are <code>switch_time</code>, <code>switch_estimate</code>, <code>switch_for_call</code>, and <code>switch_group</code>.</p>
</li>
<li>
<p>After the number of active parallel servers reaches the value of the <code>PARALLEL_SERVERS_TARGET</code> initialization parameter, subsequent parallel statements are queued. The <code>mgmt_p[1-8]</code> directives control the order in which parallel statements are dequeued when parallel servers become available. Because <code>mgmt_p1</code> is set to <code>100%</code> for SYS_GROUP in this example, parallel statements from SYS_GROUP are always dequeued first. If no parallel statements from SYS_GROUP are queued, then parallel statements from OTHER_GROUPS are dequeued with probability 70%, from MEDIUM_SQL_GROUP with probability 20%, and LONG_SQL_GROUP with probability 10%.</p>
</li>
<li>
<p>Parallel statements issued from OTHER_GROUPS are limited to a DOP of 4 with the setting of the <code>parallel_degree_limit_p1</code> directive.</p>
</li>
<li>
<p>To prevent parallel statements of the LONG_SQL_GROUP group from using all of the parallel servers, which could potentially cause parallel statements from OTHER_GROUPS or MEDIUM_SQL_GROUP to wait for long periods of time, its <code>parallel_target_percentage</code> directive is set to <code>50%</code>. This means that after LONG_SQL_GROUP has used up 50% of the parallel servers set with the <code>PARALLEL_SERVERS_TARGET</code> initialization parameter, its parallel statements are forced to wait in the queue.</p>
</li>
<li>
<p>Because parallel statements of the LONG_SQL_GROUP group may be queued for a significant amount of time, a timeout is configured for 14400 seconds (4 hours). When a parallel statement from LONG_SQL_GROUP has waited in the queue for 4 hours, the statement is terminated with the error ORA-7454.</p>
</li>
</ul>
<div class="example">
<p class="titleinexample"><a id="BEIIGBCJ"></a><a id="VLDBG14090"></a>Example 8-3 Using consumer groups to set priorities in the parallel statement queue</p>
<pre>
BEGIN
  DBMS_RESOURCE_MANAGER.CREATE_PENDING_AREA();
 
  /* Create consumer groups.
   * By default, users start in OTHER_GROUPS, which is automatically
   * created for every database.
   */
  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(
    'MEDIUM_SQL_GROUP',
    'Medium-running SQL statements, between 1 and 15 minutes.  Medium priority.');

  DBMS_RESOURCE_MANAGER.CREATE_CONSUMER_GROUP(
    'LONG_SQL_GROUP',
    'Long-running SQL statements of over 15 minutes.  Low priority.');
 
  /* Create a plan to manage these consumer groups */
  DBMS_RESOURCE_MANAGER.CREATE_PLAN(
    'REPORTS_PLAN',
    'Plan for daytime that prioritizes short-running queries');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    'REPORTS_PLAN', 'SYS_GROUP', 'Directive for sys activity',
    mgmt_p1 =&gt; 100);
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    'REPORTS_PLAN', 'OTHER_GROUPS', 'Directive for short-running queries',
    mgmt_p2 =&gt; 70,
    parallel_degree_limit_p1 =&gt; 4,
    switch_time =&gt; 60, switch_estimate =&gt; TRUE, switch_for_call =&gt; TRUE,
    switch_group =&gt; 'MEDIUM_SQL_GROUP');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    'REPORTS_PLAN', 'MEDIUM_SQL_GROUP', 'Directive for medium-running queries',
    mgmt_p2 =&gt; 20,
    parallel_target_percentage =&gt; 80,
    switch_time =&gt; 900, switch_estimate =&gt; TRUE, switch_for_call =&gt; TRUE,
    switch_group =&gt; 'LONG_SQL_GROUP');
 
  DBMS_RESOURCE_MANAGER.CREATE_PLAN_DIRECTIVE(
    'REPORTS_PLAN', 'LONG_SQL_GROUP', 'Directive for medium-running queries',
    mgmt_p2 =&gt; 10,
    parallel_target_percentage =&gt; 50,
    parallel_queue_timeout =&gt; 14400);
 
  DBMS_RESOURCE_MANAGER.SUBMIT_PENDING_AREA();
END;
/

/* Allow all users to run in these consumer groups */
EXEC DBMS_RESOURCE_MANAGER_PRIVS.GRANT_SWITCH_CONSUMER_GROUP(
  'public', 'MEDIUM_SQL_GROUP', FALSE);
 
EXEC DBMS_RESOURCE_MANAGER_PRIVS.GRANT_SWITCH_CONSUMER_GROUP(
  'public', 'LONG_SQL_GROUP', FALSE);
</pre></div>
<!-- class="example" --></div>
<!-- class="sect4" --></div>
<!-- class="sect3" -->
<a id="BEIGICGH"></a><a id="VLDBG14091"></a>
<div class="sect3">
<h3 class="sect3">Grouping Parallel Statements with BEGIN_SQL_BLOCK .. END_SQL_BLOCK</h3>
<div class="infobox-note">
<p class="notep1">Note:</p>
This functionality is available starting with Oracle Database 11g Release 2 (11.2.0.2).</div>
<p><a id="sthref914"></a><a id="sthref915"></a>Often it is important for a report or batch job that consists of multiple parallel statements to complete as quickly as possible. For example, when many reports are launched simultaneously, you may want all of the reports to complete as quickly as possible. However, you also want some specific reports to complete first, rather than all reports finishing at the same time.</p>
<p>If a report contains multiple parallel statements and <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, then each parallel statement may be forced to wait in the queue on a busy database. For example, the following steps describe a scenario in SQL statement processing:</p>
<pre>
serial statement
parallel query - dop 8
  -&gt; wait in queue
serial statement
parallel query - dop 32
  -&gt; wait in queue
parallel query - dop 4
  -&gt; wait in queue
</pre>
<p>For a report to be completed quickly, the parallel statements must be grouped to produce the following behavior:</p>
<pre>
start SQL block
serial statement
parallel query - dop 8
  -&gt; first parallel query: ok to wait in queue
serial statement
parallel query - dop 32
  -&gt; avoid or minimize wait
parallel query - dop 4
  -&gt; avoid or minimize wait
end SQL block
</pre>
<p>To group the parallel statements, you can use the <code>BEGIN_SQL_BLOCK</code> and <code>END_SQL_BLOCK</code> procedures in the <code>DBMS_RESOURCE_MANAGER</code> PL/SQL package. For each consumer group, the parallel statement queue is ordered by the time associated with each of the consumer group's parallel statements. Typically, the time associated with a parallel statement is the time that the statement was enqueued, which means that the queue appears to be FIFO. When parallel statements are grouped in a SQL block with the <code>BEGIN_SQL_BLOCK</code> and <code>END_SQL_BLOCK</code> procedures, the first queued parallel statement also uses the time that it was enqueued. However, the second and all subsequent parallel statements receive special treatment and are enqueued using the enqueue time of the first queued parallel statement within the SQL block. With this functionality, the statements frequently move to the front of the parallel statement queue. This preferential treatment ensures that their wait time is minimized.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink ARPLS050" href="../../appdev.112/e40758/d_resmgr.htm#ARPLS050"><span class="italic">Oracle Database PL/SQL Packages and Types Reference</span></a> for information about the <code>DBMS_RESOURCE_MANAGER</code> package</div>
</div>
<!-- class="sect3" -->
<a id="BEIEHFCG"></a><a id="VLDBG14092"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" -->
<h3 class="sect3">Managing Parallel Statement Queuing with Hints</h3>
<p><a id="sthref916"></a><a id="sthref917"></a>You can use the <a id="sthref918"></a><a id="sthref919"></a><code>NO_STATEMENT_QUEUING</code> and <a id="sthref920"></a><a id="sthref921"></a><code>STATEMENT_QUEUING</code> hints in SQL statements to manage parallel statement queuing.</p>
<ul>
<li>
<p><code>NO_STATEMENT_QUEUING</code></p>
<p>When <code>PARALLEL_DEGREE_POLICY</code> is set to <code>AUTO</code>, this hint enables a statement to bypass the parallel statement queue. For example:</p>
<pre>
SELECT /*+ NO_STATEMENT_QUEUING */ emp.last_name, dpt.department_name 
  FROM employees emp, departments dpt 
  WHERE emp.department_id = dpt.department_id;
</pre></li>
<li>
<p><code>STATEMENT_QUEUING</code></p>
<p>When <code>PARALLEL_DEGREE_POLICY</code> is not set to <code>AUTO</code>, this hint enables a statement to be delayed and to only run when parallel processes are available to run at the requested DOP. For example:</p>
<pre>
SELECT /*+ STATEMENT_QUEUING */ emp.last_name, dpt.department_name 
  FROM employees emp, departments dpt 
  WHERE emp.department_id = dpt.department_id;
</pre></li>
</ul>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACFBGGG"></a><a id="VLDBG0104"></a>
<div class="sect2">
<h2 class="sect2">Parallel Execution Server Pool</h2>
<p><a id="sthref922"></a><a id="sthref923"></a><a id="sthref924"></a>When an instance starts, Oracle Database creates a pool of parallel execution servers, which&nbsp;are available for any parallel operation. The initialization parameter <code>PARALLEL_MIN_SERVERS</code> specifies the number of parallel execution servers that Oracle Database creates at instance startup.</p>
<p>When executing a parallel operation, the parallel execution coordinator obtains parallel execution servers from the pool and assigns them to the operation. If necessary, Oracle Database can create additional parallel execution servers for the operation. These parallel execution servers remain with the operation throughout execution. After the statement has been processed completely, the parallel execution servers return to the pool.</p>
<p>If the number of parallel operations increases, Oracle Database creates additional parallel execution servers to handle incoming requests. However, Oracle Database never creates more parallel execution servers for an instance than the value specified by the initialization parameter <code>PARALLEL_MAX_SERVERS</code>.</p>
<p>If the number of parallel operations decreases, Oracle Database terminates any parallel execution servers that have been idle for a threshold interval. Oracle Database does not reduce the size of the pool less than the value of <code>PARALLEL_MIN_SERVERS</code>, no matter how long the parallel execution servers have been idle.</p>
<a id="VLDBG1398"></a>
<div class="sect3"><a id="sthref925"></a>
<h3 class="sect3">Processing without Enough Parallel Execution Servers</h3>
<p>Oracle Database can process a parallel operation with fewer than the requested number of processes. If all parallel execution servers in the pool are occupied and the maximum number of parallel execution servers has been started, the parallel execution coordinator switches to serial processing.</p>
<p>See <a class="olink REFRN10159" href="../../server.112/e40402/initparams187.htm#REFRN10159"><span class="italic">Oracle Database Reference</span></a> for information about using the initialization parameter <code>PARALLEL_MIN_PERCENT</code> and <a href="parallel005.htm#i1007962">"Tuning General Parameters for Parallel Execution"</a> for information about the <code>PARALLEL_MIN_PERCENT</code> and <code>PARALLEL_MAX_SERVERS</code> initialization parameters.</p>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="BEIIGIFH"></a><a id="VLDBG0105"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Granules of Parallelism</h2>
<p>The basic unit of work in parallelism is a called a<a id="sthref926"></a> granule. Oracle Database divides the operation executed in parallel (for example, a table scan, table update, or index creation) into granules. Parallel execution processes execute the operation one granule at a time. The number of granules and their sizes correlate with the degree of parallelism (DOP). The number of granules also affect how well the work is balanced across query server processes.</p>
<a id="VLDBG1399"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref927"></a>
<h3 class="sect3">Block Range Granules</h3>
<p>Block range granules are the basic unit of most parallel operations, even on partitioned tables. Therefore, from an Oracle Database perspective, the degree of parallelism is not related to the number of partitions.</p>
<p>Block range granules are ranges of physical blocks from a table. Oracle Database computes the number and the size of the granules during run-time to optimize and balance the work distribution for all affected parallel execution servers. The number and size of granules are dependent upon the size of the object and the DOP. Block range granules do not depend on static preallocation of tables or indexes. During the computation of the granules, Oracle Database takes the DOP into account and tries to assign granules from different data files to each of the parallel execution servers to avoid contention whenever possible. Additionally, Oracle Database considers the disk affinity of the granules on massive parallel processing (MPP) systems to take advantage of the physical proximity between parallel execution servers and disks.</p>
</div>
<!-- class="sect3" -->
<a id="VLDBG1400"></a>
<div class="sect3"><!-- infolevel="all" infotype="General" --><a id="sthref928"></a>
<h3 class="sect3">Partition Granules</h3>
<p>When partition granules are used, a parallel server process works on an entire partition or subpartition of a table or index. Because partition granules are statically determined by the structure of the table or index when a table or index is created, partition granules do not give you the flexibility in executing an operation in parallel that block granules do. The maximum allowable DOP is the number of partitions. This might limit the utilization of the system and the load balancing across parallel execution servers.</p>
<p>When partition granules are used for parallel access to a table or index, you should use a relatively large number of partitions (ideally, three times the DOP), so that Oracle Database can effectively balance work across the query server processes.</p>
<p>Partition granules are the basic unit of parallel index range scans, joins between two equipartitioned tables where the query optimizer has chosen to use partition-wise joins, and parallel operations that modify multiple partitions of a partitioned object. These operations include parallel creation of partitioned indexes, and parallel creation of partitioned tables.</p>
<p>You can tell which types of granules were used by looking at the execution plan of a statement. The line <code>PX</code> <code>BLOCK</code> <code>ITERATOR</code> above the table or index access indicates that block range granules have been used. In the following example, you can see this on line 7 of the explain plan output just above the <code>TABLE</code> <code>FULL</code> <code>ACCESS</code> on the <code>SALES</code> table.</p>
<pre>
-------------------------------------------------------------------------------------------------
|Id|      Operation          |  Name  |Rows|Bytes|Cost%CPU|  Time  |Pst|Pst|  TQ |INOUT|PQDistri|
-------------------------------------------------------------------------------------------------
| 0|SELECT STATEMENT         |        |  17| 153 |565(100)|00:00:07|   |   |     |     |        |
| 1| PX COORDINATOR          |        |    |     |        |        |   |   |     |     |        |
| 2|  PX SEND QC(RANDOM)     |:TQ10001|  17| 153 |565(100)|00:00:07|   |   |Q1,01|P-&gt;S |QC(RAND)|
| 3|   HASH GROUP BY         |        |  17| 153 |565(100)|00:00:07|   |   |Q1,01|PCWP |        |
| 4|    PX RECEIVE           |        |  17| 153 |565(100)|00:00:07|   |   |Q1,01|PCWP |        |
| 5|     PX SEND HASH        |:TQ10000|  17| 153 |565(100)|00:00:07|   |   |Q1,00|P-&gt;P | HASH   |
| 6|      HASH GROUP BY      |        |  17| 153 |565(100)|00:00:07|   |   |Q1,00|PCWP |        |
| 7|       PX BLOCK ITERATOR |        | 10M| 85M | 60(97) |00:00:01| 1 | 16|Q1,00|PCWC |        |
|*8|        TABLE ACCESS FULL|  SALES | 10M| 85M | 60(97) |00:00:01| 1 | 16|Q1,00|PCWP |        |
-------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
8 - filter("CUST_ID"&lt;=22810 AND "CUST_ID"&gt;=22300)
</pre>
<p>When partition granules are used, you see the line <code>PX</code> <code>PARTITION</code> <code>RANGE</code> above the table or index access in the explain plan output. On line 6 of the example that follows, the plan has <code>PX</code> <code>PARTITION</code> <code>RANGE</code> <code>ALL</code> because this statement accesses all of the 16 partitions in the table. If not all of the partitions are accessed, it simply shows <code>PX</code> <code>PARTITION</code> <code>RANGE</code>.</p>
<pre>
---------------------------------------------------------------------------------------------------
|Id|      Operation                |  Name  |Rows|Byte|Cost%CPU|  Time  |Ps|Ps|  TQ |INOU|PQDistri|
---------------------------------------------------------------------------------------------------
| 0|SELECT STATEMENT               |        |  17| 153|   2(50)|00:00:01|  |  |     |    |        |
| 1| PX COORDINATOR                |        |    |    |        |        |  |  |     |    |        |
| 2|  PX SEND QC(RANDOM)           |:TQ10001|  17| 153|   2(50)|00:00:01|  |  |Q1,01|P-&gt;S|QC(RAND)|
| 3|   HASH GROUP BY               |        |  17| 153|   2(50)|00:00:01|  |  |Q1,01|PCWP|        |
| 4|    PX RECEIVE                 |        |  26| 234|    1(0)|00:00:01|  |  |Q1,01|PCWP|        |
| 5|     PX SEND HASH              |:TQ10000|  26| 234|    1(0)|00:00:01|  |  |Q1,00|P-&gt;P| HASH   |
| 6|      PX PARTITION RANGE ALL   |        |  26| 234|    1(0)|00:00:01|  |  |Q1,00|PCWP|        |
| 7|       TABLEACCESSLOCAL INDEX ROWID|SALES| 26| 234|    1(0)|00:00:01| 1|16|Q1,00|PCWC|        |
|*8|        INDEX RANGE SCAN       |SALES_CUST|26|    |    1(0)|00:00:01| 1|16|Q1,00|PCWP|        |
---------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
8 - access("CUST_ID"&lt;=22810 AND "CUST_ID"&gt;=22300)
</pre></div>
<!-- class="sect3" --></div>
<!-- class="sect2" -->
<a id="CACBDJAF"></a><a id="VLDBG1401"></a>
<div class="sect2">
<h2 class="sect2">Balancing the Workload</h2>
<p><span class="italic"><a id="sthref929"></a><a id="sthref930"></a></span>To optimize performance, all parallel execution servers should have equal workloads. For SQL statements run in parallel by block range or by parallel execution servers, the workload is dynamically divided among the parallel execution servers. This minimizes workload skewing, which occurs when some parallel execution servers perform significantly more work than the other processes.</p>
<p>For the relatively few SQL statements executed in parallel by partitions, if the workload is evenly distributed among the partitions, you can optimize performance by matching the number of parallel execution servers to the number of partitions or by choosing a DOP in which the number of partitions is a multiple of the number of processes. This applies to partition-wise joins and parallel DML on tables created before Oracle9<span class="italic">i</span>. See <a href="parallel007.htm#i1009083">"Limitation on the Degree of Parallelism"</a> for more information.</p>
<p>For example, suppose a table has 16 partitions, and a parallel operation divides the work evenly among them. You can use 16 parallel execution servers (DOP equals 16) to do the work in approximately one-tenth the time that one process would take. You might also use five processes to do the work in one-fifth the time, or two processes to do the work in one-half the time.</p>
<p>If, however, you use 15 processes to work on 16 partitions, the first process to finish its work on one partition then begins work on the 16th partition; and as the other processes finish their work, they become idle. This configuration does not provide good performance when the work is evenly divided among partitions. When the work is unevenly divided, the performance varies depending on whether the partition that is left for last has more or less work than the other partitions.</p>
<p>Similarly, suppose you use six processes to work on 16 partitions and the work is evenly divided. In this case, each process works on a second partition after finishing its first partition, but only four of the processes work on a third partition while the other two remain idle.</p>
<p>In general, you cannot assume that the time taken to perform a parallel operation on a given number of partitions (N) with a given number of parallel execution servers (P) equals N divided by P. This formula does not consider the possibility that some processes might have to wait while others finish working on the last partitions. By choosing an appropriate DOP, however, you can minimize the workload skew and optimize performance.</p>
</div>
<!-- class="sect2" -->
<a id="BEIGCGEH"></a><a id="VLDBG0106"></a>
<div class="sect2"><!-- infolevel="all" infotype="General" -->
<h2 class="sect2">Parallel Execution Using Oracle RAC</h2>
<p>By default, in an Oracle RAC environment, a SQL statement executed in parallel can run across all of the nodes in the cluster. For this cross-node or inter-node parallel execution to perform, the interconnection in the Oracle RAC environment must be size appropriately because inter-node parallel execution may result in a lot of interconnect traffic. If the interconnection has a considerably lower bandwidth in comparison to the I/O bandwidth from the server to the storage subsystem, it may be better to restrict the parallel execution to a single node or to a limited number of nodes. Inter-node parallel execution does not scale with an undersized interconnection.</p>
<p>To limit inter-node parallel execution, you can control parallel execution in an Oracle RAC environment using the <code>PARALLEL_FORCE_LOCAL</code> initialization parameter. By setting this parameter to <code>TRUE</code>, the parallel server processes can only execute on the same Oracle RAC node where the SQL statement was started.</p>
<a id="VLDBG1402"></a>
<div class="sect3"><a id="sthref931"></a>
<h3 class="sect3">Limiting the Number of Available Instances</h3>
<p><a id="sthref932"></a><a id="sthref933"></a><a id="sthref934"></a><a id="sthref935"></a><a id="sthref936"></a>In Oracle Real Application Clusters, services are used to limit the number of instances that participate in a parallel SQL operation. The default service includes all available instances. You can create any number of services, each consisting of one or more instances. Parallel execution servers are to be used only on instances that are members of the specified service.</p>
<div class="infoboxnotealso">
<p class="notep1">See Also:</p>
<a class="olink RACAD" href="../../rac.112/e41960/toc.htm"><span class="italic">Oracle Real Application Clusters Administration and Deployment Guide</span></a> for more information about instance groups</div>
</div>
<!-- class="sect3" --></div>
<!-- class="sect2" --></div>
<!-- class="sect1" --></div>
<!-- class="ind" -->
<!-- Start Footer -->
</div>
<!-- add extra wrapper close div-->
<footer><!--
<hr />
<table class="cellalignment1828">
<tr>
<td class="cellalignment1837">
<table class="cellalignment1833">
<tr>
<td class="cellalignment1832"><a href="parallel001.htm"><img width="24" height="24" src="../../dcommon/gifs/leftnav.gif" alt="Go to previous page" /><br />
<span class="icon">Previous</span></a></td>
<td class="cellalignment1832"><a href="parallel003.htm"><img width="24" height="24" src="../../dcommon/gifs/rightnav.gif" alt="Go to next page" /><br />
<span class="icon">Next</span></a></td>
</tr>
</table>
</td>
<td class="cellalignment-copyrightlogo"><img width="144" height="18" src="../../dcommon/gifs/oracle.gif" alt="Oracle" /><br />
Copyright&nbsp;&copy;&nbsp;2008, 2011,&nbsp;Oracle&nbsp;and/or&nbsp;its&nbsp;affiliates.&nbsp;All&nbsp;rights&nbsp;reserved.<br />
<a href="../../dcommon/html/cpyr.htm">Legal Notices</a></td>
<td class="cellalignment1840">
<table class="cellalignment1831">
<tr>
<td class="cellalignment1832"><a href="../../index.htm"><img width="24" height="24" src="../../dcommon/gifs/doclib.gif" alt="Go to Documentation Home" /><br />
<span class="icon">Home</span></a></td>
<td class="cellalignment1832"><a href="../../nav/portal_booklist.htm"><img width="24" height="24" src="../../dcommon/gifs/booklist.gif" alt="Go to Book List" /><br />
<span class="icon">Book List</span></a></td>
<td class="cellalignment1832"><a href="toc.htm"><img width="24" height="24" src="../../dcommon/gifs/toc.gif" alt="Go to Table of Contents" /><br />
<span class="icon">Contents</span></a></td>
<td class="cellalignment1832"><a href="index.htm"><img width="24" height="24" src="../../dcommon/gifs/index.gif" alt="Go to Index" /><br />
<span class="icon">Index</span></a></td>
<td class="cellalignment1832"><a href="../../nav/mindx.htm"><img width="24" height="24" src="../../dcommon/gifs/masterix.gif" alt="Go to Master Index" /><br />
<span class="icon">Master Index</span></a></td>
<td class="cellalignment1832"><a href="../../dcommon/html/feedback.htm"><img width="24" height="24" src="../../dcommon/gifs/feedbck2.gif" alt="Go to Feedback page" /><br />
<span class="icon">Contact Us</span></a></td>
</tr>
</table>
</td>
</tr>
</table>
--></footer>
<noscript>
<p>Scripting on this page enhances content navigation, but does not change the content in any way.</p>
</noscript>
</body>
</html>
